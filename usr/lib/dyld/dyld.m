BOOL dyld4::APIs::dyld_program_sdk_at_least(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  int v3;
  _BOOL4 v4;
  unsigned int v5;

  v2 = *(_DWORD **)(a1 + 8);
  v3 = v2[16];
  v4 = v3 != 0;
  if ((_DWORD)a2 == -1)
  {
    v5 = v2[13];
  }
  else if (v3 == (_DWORD)a2 || v2[17] == (_DWORD)a2)
  {
    v5 = v2[12];
  }
  else
  {
    v5 = 0;
    v4 = 0;
  }
  return v5 >= HIDWORD(a2) && v4;
}

uint64_t dyld4::APIs::_dyld_objc_class_count(dyld4::APIs *this)
{
  uint64_t v1;
  unsigned int *v3;

  v1 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v1 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_objc_class_count()\n");
    v1 = *((_QWORD *)this + 1);
  }
  v3 = *(unsigned int **)(v1 + 312);
  if (v3)
    return *(unsigned int *)((char *)&v3[2 * v3[1] + 264 + v3[1]] + v3[1] + v3[4] + 1) + v3[2];
  else
    return 0;
}

uint64_t dyld4::APIs::dyld_get_active_platform(dyld4::APIs *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 1);
  v2 = *(unsigned int *)(v1 + 68);
  if (*(_BYTE *)(v1 + 204))
    dyld4::RuntimeState::log(this, "dyld_get_active_platform() => %d\n", v2);
  return v2;
}

void dyld4::APIs::runAllInitializersForMain(dyld4::APIs *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  dyld4::Loader *v6;
  BOOL v7;
  uint64_t v8;
  unsigned int v9;
  dyld4::Loader *v10;
  dyld3::MachOFile *v11;

  v2 = *((_QWORD *)this + 1);
  if (!*(_BYTE *)(v2 + 169) || *(_DWORD *)(v2 + 164) != 3)
    dyld4::SyscallDelegate::disablePageInLinking((dyld4::SyscallDelegate *)v2);
  if (!*((_QWORD *)this + 19))
  {
    dyld4::Loader::beginInitializers(*((dyld4::Loader **)this + 12), this);
    dyld4::Loader::runInitializers(*((dyld4::Loader **)this + 12), this);
    *((_BYTE *)this + 680) = 1;
  }
  dyld4::ExternallyViewableState::setLibSystemInitialized((dyld4::APIs *)((char *)this + 568));
  dyld4::RuntimeState::notifyObjCInit(this, *((const dyld4::Loader **)this + 12));
  v3 = *((_QWORD *)this + 6);
  if (v3)
  {
    v4 = 0;
    v5 = 1;
    do
    {
      v6 = *(dyld4::Loader **)(*((_QWORD *)this + 5) + 8 * v4);
      if ((*((_WORD *)v6 + 2) & 0x2000) != 0)
      {
        dyld4::Loader::beginInitializers(v6, this);
        dyld4::RuntimeState::notifyObjCInit(this, v6);
        dyld4::Loader::runInitializers(v6, this);
        v3 = *((_QWORD *)this + 6);
      }
      v4 = v5;
      v7 = v3 == v5++;
    }
    while (!v7);
    if (v3)
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = *(dyld4::Loader **)(*((_QWORD *)this + 5) + 8 * v8);
        dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(v10, this);
        v11 = (dyld3::MachOFile *)dyld4::Loader::analyzer(v10, this);
        if (dyld3::MachOFile::isMainExecutable(v11))
          break;
        v8 = v9;
        v7 = *((_QWORD *)this + 6) == v9++;
      }
      while (!v7);
    }
  }
}

char *dyld3::MachOFile::installName(dyld3::MachOFile *this)
{
  unsigned int v2[2];
  char *v3;

  *(_QWORD *)v2 = 0;
  v3 = 0;
  if (dyld3::MachOFile::getDylibInstallName(this, (const char **)&v3, &v2[1], v2))
    return v3;
  else
    return 0;
}

uint64_t dyld3::MachOFile::getDylibInstallName(dyld3::MachOFile *this, const char **a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t v8;
  _QWORD v10[8];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  vm_address_t *v15;

  Diagnostics::Diagnostics((Diagnostics *)&v15);
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___ZNK5dyld39MachOFile19getDylibInstallNameEPPKcPjS4__block_invoke;
  v10[3] = &unk_1E4F7E988;
  v10[6] = a4;
  v10[7] = a2;
  v10[4] = &v11;
  v10[5] = a3;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v15, (uint64_t)v10);
  Diagnostics::assertNoError((Diagnostics *)&v15);
  v8 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  mach_o::Error::~Error(&v15);
  return v8;
}

char *dyld4::APIs::dyld_image_path_containing_address(dyld4::APIs *this, char *a2)
{
  char *v5;
  BOOL v6;
  dyld3::MachOLoaded *v7;

  v7 = 0;
  v6 = 0;
  v5 = 0;
  dyld4::APIs::findImageMappedAt(this, a2, &v7, &v6, (const char **)&v5, 0, 0, 0, 0);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_image_path_containing_address(%p) => '%s'\n", a2, v5);
  return v5;
}

uint64_t dyld4::APIs::findImageMappedAt(dyld4::APIs *this, char *a2, const dyld3::MachOLoaded **a3, BOOL *a4, const char **a5, void **a6, unint64_t *a7, unsigned __int8 *a8, const dyld4::Loader **a9)
{
  char v16;
  uint64_t v17;
  DyldSharedCache *v18;
  BOOL v19;
  char *v20;
  uint64_t ImageMappedAt;
  _QWORD *v22;
  uint64_t v24;
  const void **v25;
  uint64_t v26;
  unsigned __int8 *v27;
  _QWORD v29[14];
  char v30;
  unsigned __int8 v31;
  unint64_t v32;
  void *v33;
  unsigned __int8 v34;
  _QWORD v35[14];
  _QWORD v36[6];
  Loader *v37;
  Loader **v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  char v44;

  v16 = 0;
  v41 = 0;
  v42 = &v41;
  v43 = 0x2000000000;
  v44 = 0;
  v17 = *((_QWORD *)this + 1);
  v18 = *(DyldSharedCache **)(v17 + 240);
  if (v18)
    v19 = v18 >= (DyldSharedCache *)a2;
  else
    v19 = 1;
  if (!v19)
  {
    if ((char *)v18 + DyldSharedCache::mappedSize(*(DyldSharedCache **)(v17 + 240)) <= a2)
    {
      v16 = 0;
    }
    else
    {
      v27 = a8;
      v20 = (char *)v18 - DyldSharedCache::unslidLoadAddress(v18);
      v37 = 0;
      v38 = &v37;
      v39 = 0x2000000000;
      v40 = 0;
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 0x40000000;
      v36[2] = ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke;
      v36[3] = &unk_1E4F7DA60;
      v36[4] = &v37;
      v36[5] = a2 - v20;
      DyldSharedCache::forEachRange((char *)v18, (uint64_t)v36, 0);
      if (*((_DWORD *)v38 + 6) == 5)
      {
        v35[0] = _NSConcreteStackBlock;
        v35[1] = 0x40000000;
        v35[2] = ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke_2;
        v35[3] = &unk_1E4F7DA88;
        v35[6] = a3;
        v35[7] = v20;
        v35[8] = a4;
        v35[9] = a5;
        v35[10] = a6;
        v35[11] = a7;
        v35[12] = v27;
        v35[13] = a9;
        v35[4] = &v41;
        v35[5] = a2 - v20;
        DyldSharedCache::forEachImageTextSegment((uint64_t)v18, (uint64_t)v35);
        if (*((_BYTE *)v42 + 24))
        {
          _Block_object_dispose(&v37, 8);
LABEL_28:
          ImageMappedAt = 1;
          goto LABEL_31;
        }
      }
      _Block_object_dispose(&v37, 8);
      v16 = 1;
      a8 = v27;
    }
  }
  v37 = 0;
  v34 = 0;
  if (dyld4::RuntimeState::inPermanentRange(this, (unint64_t)a2, (unint64_t)(a2 + 1), &v34, (const Loader **)&v37))
  {
    if (a3)
      *a3 = (const dyld3::MachOLoaded *)dyld4::Loader::loadAddress((dyld4::Loader *)v37, this);
    if (a4)
      *a4 = 1;
    if (a5)
      *a5 = (const char *)dyld4::Loader::path((dyld4::Loader *)v37, this);
    if ((unint64_t)a6 | (unint64_t)a7)
    {
      v32 = 0;
      v33 = 0;
      v31 = 0;
      if (dyld4::Loader::contains((dyld4::Loader *)v37, this, a2, (const void **)&v33, &v32, &v31))
      {
        if (a6)
          *a6 = v33;
        if (a7)
          *a7 = v32;
      }
    }
    if (a8)
      *a8 = v34;
    if (a9)
      *a9 = (const dyld4::Loader *)v37;
    goto LABEL_28;
  }
  v22 = (_QWORD *)*((_QWORD *)this + 17);
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 0x40000000;
  v29[2] = ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke_3;
  v29[3] = &unk_1E4F7DAB0;
  v30 = v16;
  v29[6] = a2;
  v29[7] = a3;
  v29[8] = a4;
  v29[9] = a5;
  v29[10] = a6;
  v29[11] = a7;
  v29[12] = a8;
  v29[13] = a9;
  v29[4] = &v41;
  v29[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v22, (uint64_t)v29);
  if (*((_BYTE *)v42 + 24) || (v24 = *((_QWORD *)this + 30)) == 0)
  {
LABEL_30:
    ImageMappedAt = *((unsigned __int8 *)v42 + 24) != 0;
  }
  else
  {
    v25 = (const void **)(*((_QWORD *)this + 29) + 8);
    v26 = 16 * v24;
    while (*(v25 - 1) != a2)
    {
      v25 += 2;
      v26 -= 16;
      if (!v26)
        goto LABEL_30;
    }
    ImageMappedAt = dyld4::APIs::findImageMappedAt(this, *v25, a3, a4, a5, (const void **)a6, a7, a8, a9);
  }
LABEL_31:
  _Block_object_dispose(&v41, 8);
  return ImageMappedAt;
}

uint64_t DyldSharedCache::unslidLoadAddress(DyldSharedCache *this)
{
  return *(_QWORD *)((char *)this + *((unsigned int *)this + 4));
}

void DyldSharedCache::forEachRange(char *a1, uint64_t a2, uint64_t a3)
{
  _QWORD v3[7];
  _QWORD v4[3];
  int v5;

  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x2000000000;
  v5 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke;
  v3[3] = &unk_1E4F7E420;
  v3[5] = a3;
  v3[6] = v4;
  v3[4] = a2;
  DyldSharedCache::forEachCache(a1, (uint64_t)v3);
  _Block_object_dispose(v4, 8);
}

uint64_t DyldSharedCache::forEachImageTextSegment(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  char v8;

  if (*(_DWORD *)(result + 16) >= 0x89u)
  {
    v2 = result;
    v3 = *(_QWORD *)(result + 144);
    if (v3)
    {
      v4 = *(_QWORD *)(result + 136);
      v8 = 0;
      if (v3 >= 1)
      {
        v6 = result + v4 + 32 * v3;
        v7 = v4 + result + 32;
        do
        {
          result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, unint64_t, uint64_t, char *))(a2 + 16))(a2, *(_QWORD *)(v7 - 16), *(unsigned int *)(v7 - 8), v7 - 32, v2 + *(unsigned int *)(v7 - 4), &v8);
          if (v7 >= v6)
            break;
          v7 += 32;
        }
        while (!v8);
      }
    }
  }
  return result;
}

uint64_t ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[3];
  __int128 v11;
  uint64_t v12;
  uint64_t v13;

  v10[0] = 2;
  v10[1] = a2;
  v10[2] = a3;
  v12 = a5;
  v11 = *a4;
  v8 = a1 + 32;
  v7 = *(_QWORD *)(a1 + 32);
  v13 = a2 - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 8) + 24);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, __int128 *, uint64_t, uint64_t, uint64_t))(v7 + 16))(v7, v10, a3, a4, a5, a6, a7);
}

BOOL dyld3::MachOFile::getUuid(dyld3::MachOFile *this, unsigned __int8 *a2)
{
  uint64_t *v4;
  _BOOL8 v5;
  _QWORD v7[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  vm_address_t *v12;

  Diagnostics::Diagnostics((Diagnostics *)&v12);
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld39MachOFile7getUuidEPh_block_invoke;
  v7[3] = &unk_1E4F7E9B0;
  v7[4] = &v8;
  v7[5] = a2;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v12, (uint64_t)v7);
  Diagnostics::assertNoError((Diagnostics *)&v12);
  v4 = v9;
  if (*((_BYTE *)v9 + 24))
  {
    v5 = 1;
  }
  else
  {
    bzero(a2, 0x10uLL);
    v5 = *((_BYTE *)v4 + 24) != 0;
  }
  _Block_object_dispose(&v8, 8);
  mach_o::Error::~Error(&v12);
  return v5;
}

uint64_t dyld3::MachOLoaded::getSlide(dyld3::MachOLoaded *this)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  vm_address_t *v9;

  Diagnostics::Diagnostics((Diagnostics *)&v9);
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld311MachOLoaded8getSlideEv_block_invoke;
  v4[3] = &unk_1E4F7F0C0;
  v4[4] = &v5;
  v4[5] = this;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v9, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v9);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  mach_o::Error::~Error(&v9);
  return v2;
}

void Diagnostics::Diagnostics(Diagnostics *this)
{
  *(_QWORD *)this = 0;
}

void mach_o::Error::~Error(vm_address_t **this)
{
  vm_address_t *v2;

  v2 = *this;
  if (v2)
    _simple_sfree(v2);
  *this = 0;
}

_DWORD *dyld3::MachOFile::forEachLoadCommand(_DWORD *result, vm_address_t *this, uint64_t a3)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  _DWORD *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v5 = result;
  v6 = *result;
  if (*result == -17958193)
  {
    v7 = 8;
  }
  else
  {
    if (v6 != -17958194)
    {
      if ((v6 & 0xFEFFFFFF) != 0xCEFAEDFE)
        return (_DWORD *)Diagnostics::error(this, "file does not start with MH_MAGIC[_64]: 0x%08X 0x%08X");
      return result;
    }
    v7 = 7;
  }
  if (result[3] >= 0xDu)
    return (_DWORD *)Diagnostics::error(this, "unknown mach-o filetype (%u)");
  if (result[4])
  {
    v8 = 0;
    v9 = &result[v7];
    v10 = (unint64_t)&result[v7] + result[5];
    v11 = (unint64_t)&result[v7];
    while (1)
    {
      if (v11 > v10 - 8)
        return (_DWORD *)Diagnostics::error(this, "malformed load command #%u of %u at %p with mh=%p, extends past sizeofcmds");
      v12 = *(unsigned int *)(v11 + 4);
      if (v12 <= 7)
        return (_DWORD *)Diagnostics::error(this, "malformed load command #%u of %u at %p with mh=%p, size (0x%X) too small");
      if ((v12 & 3) != 0)
        break;
      v13 = v11 + v12;
      if (v11 + v12 > v10 || v13 < (unint64_t)v9)
        return (_DWORD *)Diagnostics::error(this, "malformed load command #%u of %u at %p with mh=%p, size (0x%X) is too large, load commands end at %p");
      result = (_DWORD *)(*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
      ++v8;
      v11 = v13;
      if (v8 >= v5[4])
        return result;
    }
    return (_DWORD *)Diagnostics::error(this, "malformed load command #%u of %u at %p with mh=%p, size (0x%X) not multiple of 4");
  }
  return result;
}

__n128 ___ZNK5dyld39MachOFile7getUuidEPh_block_invoke(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  __n128 result;

  if (*(_DWORD *)a2 == 27)
  {
    result = *(__n128 *)(a2 + 8);
    *(__n128 *)*(_QWORD *)(a1 + 40) = result;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile14forEachSegmentEU13block_pointerFvRKNS0_11SegmentInfoERbE_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unsigned int v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  unint64_t v23;
  int v24;
  int v26;
  uint64_t v27;
  int v28;
  unint64_t v29;
  int v30;
  _BOOL4 v32;
  int v33;
  int v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;

  v2 = result;
  v3 = *(_QWORD *)(result + 48);
  if (*(_DWORD *)a2 == 1)
  {
    v13 = *(unsigned int *)(a2 + 28);
    v14 = *(_DWORD *)(a2 + 48);
    if (v14)
    {
      v15 = 0;
      LOBYTE(v16) = 0;
      v17 = a2 + 56;
      v18 = a2 + 56 + 68 * v14;
      do
      {
        if (*(_DWORD *)(v17 + 44) > v16)
          v16 = *(_DWORD *)(v17 + 44);
        v15 |= (*(_BYTE *)(v17 + 57) & 3) != 0;
        v17 += 68;
      }
      while (v17 < v18);
      v19 = *(_DWORD *)(v17 - 32) + *(_DWORD *)(v17 - 36);
      v20 = *(_DWORD *)(a2 + 24);
      v21 = v19 - v20;
      v22 = v16 << 16;
    }
    else
    {
      v22 = 0;
      v15 = 0;
      v20 = *(_DWORD *)(a2 + 24);
      v21 = *(_DWORD *)(a2 + 28);
    }
    v29 = *(unsigned int *)(a2 + 36);
    v36 = *(unsigned int *)(a2 + 32);
    v37 = v29;
    v38 = v20;
    v39 = v13;
    v40 = v21;
    v41 = a2 + 8;
    v30 = *(_DWORD *)(a2 + 44);
    v42 = a2 - v3;
    v43 = v30;
    v32 = (v30 & 2) == 0 && *(_BYTE *)(result + 56) != 0;
    v33 = (*(_DWORD *)(a2 + 52) >> 3) & 2 | (*(_DWORD *)(a2 + 52) >> 1) & 4 | v32 & v15;
    if (v29 < v13 && v30 == 3)
      v35 = 8;
    else
      v35 = 0;
    v27 = *(_QWORD *)(result + 32);
    v28 = v35 | v22 | v33 | (16 * (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 40) + 8) + 24) & 0xFFF));
  }
  else
  {
    if (*(_DWORD *)a2 != 25)
      return result;
    v4 = *(_QWORD *)(a2 + 32);
    v5 = *(_DWORD *)(a2 + 64);
    if (v5)
    {
      LOBYTE(v6) = 0;
      v7 = a2 + 72;
      v8 = a2 + 72 + 80 * v5;
      do
      {
        if (*(_DWORD *)(v7 + 52) > v6)
          v6 = *(_DWORD *)(v7 + 52);
        v7 += 80;
      }
      while (v7 < v8);
      v9 = *(_QWORD *)(v7 - 40) + *(_QWORD *)(v7 - 48);
      v10 = *(_QWORD *)(a2 + 24);
      v11 = v9 - v10;
      v12 = v6 << 16;
    }
    else
    {
      v12 = 0;
      v10 = *(_QWORD *)(a2 + 24);
      v11 = *(_QWORD *)(a2 + 32);
    }
    v23 = *(_QWORD *)(a2 + 48);
    v36 = *(_QWORD *)(a2 + 40);
    v37 = v23;
    v38 = v10;
    v39 = v4;
    v40 = v11;
    v41 = a2 + 8;
    v24 = *(_DWORD *)(a2 + 60);
    v42 = a2 - v3;
    v43 = v24;
    if (v23 < v4 && v24 == 3)
      v26 = 8;
    else
      v26 = 0;
    v27 = *(_QWORD *)(result + 32);
    v28 = v26 | v12 | (*(_DWORD *)(a2 + 68) >> 3) & 2 | (*(_DWORD *)(a2 + 68) >> 1) & 4 | (16
                                                                                         * (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 40) + 8) + 24) & 0xFFF));
  }
  v44 = v28;
  result = (*(uint64_t (**)(uint64_t, uint64_t *))(v27 + 16))(v27, &v36);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 40) + 8) + 24);
  return result;
}

Diagnostics *Diagnostics::assertNoError(Diagnostics *this)
{
  if (*(_QWORD *)this)
    Diagnostics::assertNoError(this);
  return this;
}

uint64_t ___ZNK5dyld39MachOFile19getDylibInstallNameEPPKcPjS4__block_invoke(uint64_t result, _DWORD *a2, _BYTE *a3)
{
  _DWORD *v3;

  if ((*a2 | 2) == 0xF)
  {
    v3 = *(_DWORD **)(result + 48);
    **(_DWORD **)(result + 40) = a2[5];
    *v3 = a2[4];
    **(_QWORD **)(result + 56) = (char *)a2 + a2[2];
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded8getSlideEv_block_invoke(uint64_t result, uint64_t a2, _BYTE *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = result;
  v6 = *(_QWORD *)(result + 40);
  if (*(_DWORD *)a2 == 1)
  {
    result = _platform_strcmp((const char *)(a2 + 8), "__TEXT");
    if ((_DWORD)result)
      return result;
    v7 = *(unsigned int *)(a2 + 24);
    goto LABEL_7;
  }
  if (*(_DWORD *)a2 == 25)
  {
    result = _platform_strcmp((const char *)(a2 + 8), "__TEXT");
    if (!(_DWORD)result)
    {
      v7 = *(_QWORD *)(a2 + 24);
LABEL_7:
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 8) + 24) = v6 - v7;
      *a3 = 1;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded23getLinkEditLoadCommandsER11DiagnosticsRNS0_12LinkEditInfoE_block_invoke(uint64_t result, int *a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;

  v3 = result;
  v4 = *a2;
  if (*a2 <= 1)
  {
    switch(v4)
    {
      case -2147483614:
LABEL_12:
        if (a2[1] == 48)
        {
          if (**(_QWORD **)(v3 + 72))
            result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_DYLD_INFO load commands");
        }
        else
        {
          result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_DYLD_INFO load command size wrong");
        }
        **(_QWORD **)(v3 + 72) = a2;
        break;
      case -2147483597:
        if (a2[1] == 16)
        {
          if (*(_QWORD *)(*(_QWORD *)(result + 72) + 8))
            result = Diagnostics::error(*(vm_address_t **)(result + 64), "multiple LC_DYLD_EXPORTS_TRIE load commands");
        }
        else
        {
          result = Diagnostics::error(*(vm_address_t **)(result + 64), "LC_DYLD_EXPORTS_TRIE load command size wrong");
        }
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 8) = a2;
        break;
      case -2147483596:
        if (a2[1] == 16)
        {
          if (*(_QWORD *)(*(_QWORD *)(result + 72) + 16))
            result = Diagnostics::error(*(vm_address_t **)(result + 64), "multiple LC_DYLD_CHAINED_FIXUPS load commands");
        }
        else
        {
          result = Diagnostics::error(*(vm_address_t **)(result + 64), "LC_DYLD_CHAINED_FIXUPS load command size wrong");
        }
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 16) = a2;
        break;
    }
  }
  else
  {
    result = *(_QWORD *)(result + 56);
    switch(v4)
    {
      case 27:
        if (a2[1] == 24)
        {
          if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24))
            result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_UUID load commands");
        }
        else
        {
          result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_UUID load command size wrong");
        }
        v5 = *(_QWORD *)(v3 + 32);
        goto LABEL_70;
      case 28:
      case 31:
      case 32:
      case 35:
      case 39:
      case 40:
      case 42:
      case 43:
      case 45:
      case 46:
      case 49:
        return result;
      case 29:
        if (a2[1] == 16)
        {
          if (*(_QWORD *)(*(_QWORD *)(v3 + 72) + 64))
            result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_CODE_SIGNATURE load commands");
        }
        else
        {
          result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_CODE_SIGNATURE load command size wrong");
        }
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 64) = a2;
        return result;
      case 30:
        if (a2[1] == 16)
        {
          if (*(_QWORD *)(*(_QWORD *)(v3 + 72) + 40))
            result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_SEGMENT_SPLIT_INFO load commands");
        }
        else
        {
          result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_SEGMENT_SPLIT_INFO load command size wrong");
        }
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 40) = a2;
        return result;
      case 33:
        if (a2[1] == 20)
        {
          if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8) + 24))
          {
            result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_ENCRYPTION_INFO load commands");
          }
          else
          {
            result = dyld3::MachOFile::is64((dyld3::MachOFile *)result);
            if ((_DWORD)result)
              result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO found in 64-bit mach-o");
          }
        }
        else
        {
          result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO load command size wrong");
        }
        goto LABEL_69;
      case 34:
        goto LABEL_12;
      case 36:
      case 37:
      case 47:
      case 48:
        if (a2[1] == 16)
        {
          if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8) + 24))
            result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_VERSION_MIN_* load commands");
        }
        else
        {
          result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_VERSION_* load command size wrong");
        }
        v5 = *(_QWORD *)(v3 + 40);
        goto LABEL_70;
      case 38:
        if (a2[1] == 16)
        {
          if (*(_QWORD *)(*(_QWORD *)(v3 + 72) + 48))
            result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_FUNCTION_STARTS load commands");
        }
        else
        {
          result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_FUNCTION_STARTS load command size wrong");
        }
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 48) = a2;
        return result;
      case 41:
        if (a2[1] == 16)
        {
          if (*(_QWORD *)(*(_QWORD *)(v3 + 72) + 56))
            result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_DATA_IN_CODE load commands");
        }
        else
        {
          result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_DATA_IN_CODE load command size wrong");
        }
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 56) = a2;
        return result;
      case 44:
        if (a2[1] == 24)
        {
          if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8) + 24))
          {
            result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_ENCRYPTION_INFO_64 load commands");
          }
          else
          {
            result = dyld3::MachOFile::is64((dyld3::MachOFile *)result);
            if ((result & 1) == 0)
              result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO_64 found in 32-bit mach-o");
          }
        }
        else
        {
          result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO_64 load command size wrong");
        }
LABEL_69:
        v5 = *(_QWORD *)(v3 + 48);
LABEL_70:
        *(_BYTE *)(*(_QWORD *)(v5 + 8) + 24) = 1;
        break;
      case 50:
        if (8 * a2[5] + 24 != a2[1])
          result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_BUILD_VERSION load command size wrong");
        break;
      default:
        if (v4 == 2)
        {
          if (a2[1] == 24)
          {
            if (*(_QWORD *)(*(_QWORD *)(v3 + 72) + 24))
              result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_SYMTAB load commands");
          }
          else
          {
            result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_SYMTAB load command size wrong");
          }
          *(_QWORD *)(*(_QWORD *)(v3 + 72) + 24) = a2;
        }
        else if (v4 == 11)
        {
          if (a2[1] == 80)
          {
            if (*(_QWORD *)(*(_QWORD *)(v3 + 72) + 32))
              result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_DYSYMTAB load commands");
          }
          else
          {
            result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_DYSYMTAB load command size wrong");
          }
          *(_QWORD *)(*(_QWORD *)(v3 + 72) + 32) = a2;
        }
        break;
    }
  }
  return result;
}

uint64_t dyld4::APIs::_dyld_is_memory_immutable(dyld4::APIs *this, char *a2, uint64_t a3)
{
  uint64_t v6;
  char *v7;
  BOOL v8;
  uint64_t *v9;
  _BOOL4 v10;
  uint64_t v11;
  unsigned __int8 v13;
  Loader *v14;
  _QWORD v15[7];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;

  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v6 = *((_QWORD *)this + 1);
  v7 = *(char **)(v6 + 240);
  if (v7)
    v8 = v7 >= a2;
  else
    v8 = 1;
  if (!v8 && &v7[DyldSharedCache::mappedSize(*(DyldSharedCache **)(v6 + 240))] > a2)
  {
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000;
    v15[2] = ___ZN5dyld44APIs25_dyld_is_memory_immutableEPKvm_block_invoke;
    v15[3] = &unk_1E4F7DB00;
    v15[5] = a2;
    v15[6] = a3;
    v15[4] = &v16;
    DyldSharedCache::forEachCache(v7, (uint64_t)v15);
  }
  v9 = v17;
  if (!*((_BYTE *)v17 + 24))
  {
    v14 = 0;
    v13 = 0;
    v10 = dyld4::RuntimeState::inPermanentRange(this, (unint64_t)a2, (unint64_t)&a2[a3], &v13, (const Loader **)&v14);
    v9 = v17;
    if (v10)
      *((_BYTE *)v17 + 24) = ((v13 >> 1) & 1) == 0;
  }
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_is_memory_immutable(%p, %lu) => %d\n", a2, a3, *((unsigned __int8 *)v9 + 24));
    v9 = v17;
  }
  v11 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v16, 8);
  return v11;
}

void _Block_object_dispose(const void *a1, const int a2)
{
  if (a2 != 8)
    dyld4::halt("_Block_object_dispose()", 0);
}

uint64_t dyld4::APIs::_dyld_lookup_section_info(_QWORD *a1, dyld3::MachOFile *a2, dyld4::Loader *this, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint64_t v15;
  _QWORD v16[51];

  if ((int)a4 > 20)
    return 0;
  v16[49] = v4;
  v16[50] = v5;
  if (this)
  {
    v11 = a1[1];
    v12 = *(_QWORD *)(v11 + 240);
    if (v12)
    {
      v13 = DyldSharedCache::mappedSize(*(DyldSharedCache **)(v11 + 240)) + v12;
      v14 = v12 > (unint64_t)this || v13 >= (unint64_t)this;
      if (!v14 && !a1[124])
        return (*(uint64_t (**)(_QWORD *, dyld3::MachOFile *, _QWORD, uint64_t))(*a1 + 928))(a1, a2, 0, a4);
    }
    if (*(_DWORD *)this != 1815378276 || *(_DWORD *)dyld4::Loader::getSectionLocations(this) != 1)
      return (*(uint64_t (**)(_QWORD *, dyld3::MachOFile *, _QWORD, uint64_t))(*a1 + 928))(a1, a2, 0, a4);
    v15 = *(_QWORD *)(dyld4::Loader::getSectionLocations(this) + 8 * a4 + 8);
    if (v15)
      return (uint64_t)a2 + v15;
  }
  else
  {
    v16[0] = 1;
    dyld4::JustInTimeLoader::parseSectionLocations(a2, (uint64_t)v16);
    v15 = v16[a4 + 1];
    if (v15)
      return (uint64_t)a2 + v15;
  }
  return 0;
}

uint64_t dyld4::Loader::getSectionLocations(dyld4::Loader *this)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::getSectionLocations();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::getSectionLocations(this);
  else
    return dyld4::JustInTimeLoader::getSectionLocations(this);
}

uint64_t dyld4::PrebuiltLoader::getSectionLocations(dyld4::PrebuiltLoader *this)
{
  return (uint64_t)this + 104;
}

uint64_t DyldSharedCache::mappedSize(DyldSharedCache *this)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  if (*((_DWORD *)this + 4) >= 0x18Cu)
    return *((_QWORD *)this + 29);
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK15DyldSharedCache10mappedSizeEv_block_invoke;
  v3[3] = &unk_1E4F7E448;
  v3[4] = &v8;
  v3[5] = &v4;
  DyldSharedCache::forEachRegion((uint64_t)this, (uint64_t)v3);
  v1 = v5[3] - v9[3];
  _Block_object_dispose(&v4, 8);
  _Block_object_dispose(&v8, 8);
  return v1;
}

uint64_t ___ZNK5dyld39MachOFile14forEachSectionEU13block_pointerFvRKNS0_11SectionInfoEbRbE_block_invoke(uint64_t result, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unsigned int v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unint64_t v21;
  unsigned int v22;
  unint64_t v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t *v31;
  unint64_t v32;
  const char *v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  int v40;
  int v41;
  uint64_t v42;
  __int128 v43;
  int v44;
  _BOOL4 v46;
  unint64_t v47;
  const char *v48;
  unsigned int v49;
  unint64_t v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  int v55;
  int v56;
  __int128 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  unint64_t v65;
  uint64_t v66;
  const char *v67;
  int v68;
  int v69;
  int v70;
  uint64_t v71;

  v10 = result;
  v11 = *(_QWORD *)(result + 48);
  if (*(_DWORD *)a2 == 1)
  {
    v20 = *(unsigned int *)(a2 + 28);
    v21 = a2 + 56;
    v22 = *(_DWORD *)(a2 + 48);
    v23 = a2 + 56 + 68 * v22;
    if (v22)
    {
      v24 = 0;
      LOBYTE(v25) = 0;
      do
      {
        if (*(_DWORD *)(v21 + 44) > v25)
          v25 = *(_DWORD *)(v21 + 44);
        v24 |= (*(_BYTE *)(v21 + 57) & 3) != 0;
        v21 += 68;
      }
      while (v21 < v23);
      v26 = *(_DWORD *)(a2 + 24);
      v27 = *(_DWORD *)(v21 - 32) + *(_DWORD *)(v21 - 36) - v26;
      v28 = v25 << 16;
    }
    else
    {
      v28 = 0;
      v24 = 0;
      v26 = *(_DWORD *)(a2 + 24);
      v27 = *(_DWORD *)(a2 + 28);
    }
    v42 = *(_QWORD *)(a2 + 32);
    *(_QWORD *)&v43 = v42;
    *((_QWORD *)&v43 + 1) = HIDWORD(v42);
    v57 = v43;
    v58 = v26;
    v59 = v20;
    v60 = v27;
    v61 = a2 + 8;
    v44 = *(_DWORD *)(a2 + 44);
    v62 = a2 - v11;
    v63 = v44;
    v31 = (uint64_t *)(result + 40);
    v30 = *(_QWORD *)(result + 40);
    v46 = (v44 & 2) == 0 && *(_BYTE *)(result + 64) != 0;
    v64 = (*(_DWORD *)(a2 + 52) >> 3) & 2 | v46 & v24 & 0xFF0007 | (*(_DWORD *)(a2 + 52) >> 1) & 4 | v28 & 0xFF0007 | (16 * (*(_DWORD *)(*(_QWORD *)(v30 + 8) + 24) & 0xFFF));
    if (*a3 || !v22)
      goto LABEL_57;
    v47 = a2 + 124;
    do
    {
      v48 = (const char *)(v47 - 68);
      if (*(_BYTE *)(v47 - 53))
      {
        strlcpy(*(char **)(v10 + 56), v48, 0x11uLL);
        v48 = *(const char **)(v10 + 56);
      }
      v49 = *(_DWORD *)(a2 + 24);
      v50 = *(unsigned int *)(v47 - 36);
      if (v50 >= v49)
      {
        v52 = *(_DWORD *)(a2 + 36) + v49;
        v39 = v52 >= v50;
        v53 = v52 - v50;
        v51 = !v39 || v53 < *(_DWORD *)(v47 - 32);
      }
      else
      {
        v51 = 1;
      }
      v66 = *(unsigned int *)(v47 - 32);
      v67 = v48;
      v55 = *(_DWORD *)(v47 - 12);
      v56 = *(_DWORD *)(v47 - 24);
      v68 = *(_DWORD *)(v47 - 28);
      v69 = v55;
      v65 = v50;
      v70 = v56;
      v71 = *(_QWORD *)(v47 - 8);
      result = (*(uint64_t (**)(_QWORD, __int128 *, uint64_t, _BYTE *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v10 + 32) + 16))(*(_QWORD *)(v10 + 32), &v57, v51, a3, a5, a6, a7, a8);
      if (*a3)
        break;
      v39 = v47 >= v23;
      v47 += 68;
    }
    while (!v39);
    goto LABEL_56;
  }
  if (*(_DWORD *)a2 != 25)
    return result;
  v12 = *(_QWORD *)(a2 + 32);
  v13 = a2 + 72;
  v14 = *(_DWORD *)(a2 + 64);
  v15 = a2 + 72 + 80 * v14;
  if (v14)
  {
    LOBYTE(v16) = 0;
    do
    {
      if (*(_DWORD *)(v13 + 52) > v16)
        v16 = *(_DWORD *)(v13 + 52);
      v13 += 80;
    }
    while (v13 < v15);
    v17 = *(_QWORD *)(a2 + 24);
    v18 = *(_QWORD *)(v13 - 40) + *(_QWORD *)(v13 - 48) - v17;
    v19 = v16 << 16;
  }
  else
  {
    v19 = 0;
    v17 = *(_QWORD *)(a2 + 24);
    v18 = *(_QWORD *)(a2 + 32);
  }
  v57 = *(_OWORD *)(a2 + 40);
  v58 = v17;
  v59 = v12;
  v60 = v18;
  v61 = a2 + 8;
  v29 = *(_DWORD *)(a2 + 60);
  v62 = a2 - v11;
  v63 = v29;
  v64 = (*(_DWORD *)(a2 + 68) >> 3) & 2 | (*(_DWORD *)(a2 + 68) >> 1) & 4 | v19;
  v31 = (uint64_t *)(result + 40);
  v30 = *(_QWORD *)(result + 40);
  v64 = v64 & 0xFF0006 | (16 * (*(_DWORD *)(*(_QWORD *)(v30 + 8) + 24) & 0xFFF));
  if (!*a3 && v14)
  {
    v32 = a2 + 152;
    do
    {
      v33 = (const char *)(v32 - 80);
      if (*(_BYTE *)(v32 - 65))
      {
        strlcpy(*(char **)(v10 + 56), v33, 0x11uLL);
        v33 = *(const char **)(v10 + 56);
      }
      v34 = *(_QWORD *)(a2 + 24);
      v35 = *(_QWORD *)(v32 - 48);
      if (v35 >= v34)
      {
        v37 = *(_QWORD *)(a2 + 48) + v34;
        v39 = v37 >= v35;
        v38 = v37 - v35;
        v39 = v39 && v38 >= *(_QWORD *)(v32 - 40);
        v36 = !v39;
      }
      else
      {
        v36 = 1;
      }
      v66 = *(_QWORD *)(v32 - 40);
      v67 = v33;
      v40 = *(_DWORD *)(v32 - 16);
      v41 = *(_DWORD *)(v32 - 28);
      v68 = *(_DWORD *)(v32 - 32);
      v69 = v40;
      v65 = v35;
      v70 = v41;
      v71 = *(_QWORD *)(v32 - 12);
      result = (*(uint64_t (**)(_QWORD, __int128 *, uint64_t, _BYTE *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v10 + 32) + 16))(*(_QWORD *)(v10 + 32), &v57, v36, a3, a5, a6, a7, a8);
      if (*a3)
        break;
      v39 = v32 >= v15;
      v32 += 80;
    }
    while (!v39);
LABEL_56:
    v30 = *v31;
  }
LABEL_57:
  ++*(_DWORD *)(*(_QWORD *)(v30 + 8) + 24);
  return result;
}

uint64_t DyldSharedCache::forEachCache(char *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  char v10;

  v10 = 0;
  result = (*(uint64_t (**)(uint64_t, char *, char *))(a2 + 16))(a2, a1, &v10);
  if (!v10 && *((_DWORD *)a1 + 4) >= 0x18Du && *((_DWORD *)a1 + 99))
  {
    v5 = 0;
    do
    {
      v6 = &a1[*((unsigned int *)a1 + 98)];
      v7 = (uint64_t)&v6[24 * v5 + 16];
      v8 = (uint64_t)&v6[56 * v5 + 16];
      if (*((_DWORD *)a1 + 4) >= 0x1C9u)
        v9 = (_QWORD *)v8;
      else
        v9 = (_QWORD *)v7;
      result = (*(uint64_t (**)(uint64_t, char *, char *))(a2 + 16))(a2, &a1[*v9], &v10);
      if (v10)
        break;
      ++v5;
    }
    while (v5 != *((_DWORD *)a1 + 99));
  }
  return result;
}

uint64_t ___ZN5dyld44APIs25_dyld_is_memory_immutableEPKvm_block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD v3[4];
  __int128 v4;
  uint64_t v5;

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZN5dyld44APIs25_dyld_is_memory_immutableEPKvm_block_invoke_2;
  v3[3] = &unk_1E4F7DAD8;
  v5 = *(_QWORD *)(a1 + 48);
  v4 = *(_OWORD *)(a1 + 32);
  return DyldSharedCache::forEachRegion(a2, (uint64_t)v3);
}

uint64_t DyldSharedCache::forEachRegion(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  char v14;

  result = _platform_strncmp((const char *)a1, "dyld_v1", 7uLL);
  if (!(_DWORD)result)
  {
    v5 = *(unsigned int *)(a1 + 16);
    if (v5 <= 0x400)
    {
      v6 = *(unsigned int *)(a1 + 20);
      if (v6 <= 0x14)
      {
        if (v5 > 0x138)
        {
          if ((_DWORD)v6)
          {
            v10 = a1 + *(unsigned int *)(a1 + 312);
            v11 = v10 + 56 * v6;
            v12 = v10 + 56;
            do
            {
              v13 = 0;
              result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, char *))(a2 + 16))(a2, a1 + *(_QWORD *)(v12 - 40), *(_QWORD *)(v12 - 56), *(_QWORD *)(v12 - 48), *(unsigned int *)(v12 - 4), *(unsigned int *)(v12 - 8), *(_QWORD *)(v12 - 16), &v13);
              if (v13)
                break;
              v9 = v12 >= v11;
              v12 += 56;
            }
            while (!v9);
          }
        }
        else if ((_DWORD)v6)
        {
          v7 = a1 + v5 + 32 * v6;
          v8 = v5 + a1 + 32;
          do
          {
            v14 = 0;
            result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, char *))(a2 + 16))(a2, a1 + *(_QWORD *)(v8 - 16), *(_QWORD *)(v8 - 32), *(_QWORD *)(v8 - 24), *(unsigned int *)(v8 - 4), *(unsigned int *)(v8 - 8), 0, &v14);
            if (v14)
              v9 = 1;
            else
              v9 = v8 >= v7;
            v8 += 32;
          }
          while (!v9);
        }
      }
    }
  }
  return result;
}

int _platform_strncmp(const char *__s1, const char *__s2, size_t __n)
{
  int v3;
  uint64_t v4;
  unsigned int v5;
  int v6;
  unint64_t v9;
  size_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t v13;
  uint8x16_t v14;
  int8x16_t v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  BOOL v23;
  uint8x16_t v24;

  v3 = 0;
  if (!__n)
    return v3;
  while ((__s1 & 0xF) != 0)
  {
    v5 = *(unsigned __int8 *)__s1++;
    v4 = v5;
    v6 = *(unsigned __int8 *)__s2++;
    v3 = v4 - v6;
    if (v4 == v6 && (_DWORD)v4 != 0)
    {
      if (--__n)
        continue;
    }
    return v3;
  }
  if ((__s2 & 0xF) == 0)
    goto LABEL_30;
  v9 = -(uint64_t)__s2 & 0xFF0;
  if (!v9)
    goto LABEL_16;
LABEL_11:
  if (__n > v9)
  {
    v10 = __n - v9;
    while (1)
    {
      v11 = *(int8x16_t *)__s1;
      __s1 += 16;
      v12 = v11;
      v13 = *(int8x16_t *)__s2;
      __s2 += 16;
      v15 = vceqq_s8(v12, v13);
      v14 = (uint8x16_t)vandq_s8(v12, v15);
      v15.i8[0] = vminvq_u8(v14);
      if (!v15.i32[0])
        break;
      v9 -= 16;
      if (!v9)
      {
        __n = v10;
LABEL_16:
        while (1)
        {
          v17 = *(unsigned __int8 *)__s1++;
          v16 = v17;
          v18 = *(unsigned __int8 *)__s2++;
          v3 = v16 - v18;
          if (v16 != v18 || (_DWORD)v16 == 0)
            return v3;
          if (!--__n)
            return v3;
          if ((__s1 & 0xF) == 0)
          {
            v9 = 4080;
            goto LABEL_11;
          }
        }
      }
    }
  }
  else
  {
LABEL_30:
    while (1)
    {
      v20 = *(int8x16_t *)__s1;
      __s1 += 16;
      v21 = v20;
      v22 = *(int8x16_t *)__s2;
      __s2 += 16;
      v15 = vceqq_s8(v21, v22);
      v14 = (uint8x16_t)vandq_s8(v21, v15);
      v15.i8[0] = vminvq_u8(v14);
      if (!v15.i32[0])
        break;
      v23 = __n > 0x10;
      __n -= 16;
      if (!v23)
        return 0;
    }
  }
  v24 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v14, (uint8x16_t)veorq_s8(v15, v15)), (int8x16_t)xmmword_1A5C57E60);
  v24.i8[0] = vminvq_u8(v24);
  if (v24.u32[0] >= __n)
    return 0;
  else
    return __s1[v24.u32[0] - 16] - __s2[v24.u32[0] - 16];
}

uint64_t ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke_2(uint64_t a1, int a2, int a3, int a4, int a5, DyldSharedCache *this, char a7)
{
  DyldSharedCache::mappingName(this, a7);
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32));
}

uint64_t ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, _BYTE *a9)
{
  unint64_t v9;

  v9 = *(_QWORD *)(result + 40);
  if (v9 >= a3 && v9 < a4 + a3)
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a7;
    *a9 = 1;
  }
  return result;
}

const char *DyldSharedCache::mappingName(DyldSharedCache *this, char a2)
{
  const char *v2;
  const char *v3;
  BOOL v4;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;

  if ((this & 4) != 0)
  {
    if ((a2 & 8) != 0)
      return "__TEXT_STUBS";
    else
      return "__TEXT";
  }
  else
  {
    if ((this & 2) != 0)
    {
      v2 = "__DATA_DIRTY";
      v6 = "__TPRO_CONST";
      v7 = "__DATA_CONST";
      if ((a2 & 4) == 0)
        v7 = "__DATA";
      if ((a2 & 0x40) == 0)
        v6 = v7;
      if ((a2 & 2) == 0)
        v2 = v6;
      v3 = "__AUTH_DIRTY";
      v8 = "__AUTH_TPRO_CONST";
      v9 = "__AUTH_CONST";
      if ((a2 & 4) == 0)
        v9 = "__AUTH";
      if ((a2 & 0x40) == 0)
        v8 = v9;
      if ((a2 & 2) == 0)
        v3 = v8;
      v4 = (a2 & 1) == 0;
    }
    else
    {
      v2 = "*unknown*";
      v3 = "__READ_ONLY";
      if ((a2 & 0x20) == 0)
        v3 = "__LINKEDIT";
      v4 = (this & 1) == 0;
    }
    if (v4)
      return v2;
    else
      return v3;
  }
}

uint64_t ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke(_QWORD *a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v6;
  uint64_t result;
  _QWORD v8[8];

  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke_2;
  v8[3] = &unk_1E4F7E3F8;
  v6 = a1[6];
  v8[4] = a1[4];
  v8[5] = v6;
  v8[6] = a2;
  v8[7] = a3;
  result = DyldSharedCache::forEachRegion(a2, (uint64_t)v8);
  if (!*a3)
  {
    result = a1[5];
    if (result)
      result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(result + 16))(result, a2, *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24));
    ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile13inCodeSectionEj_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  unint64_t v4;
  unint64_t v5;

  v4 = *(_QWORD *)(a2 + 64) - *(_QWORD *)(result + 40);
  v5 = *(unsigned int *)(result + 48);
  if (v4 <= v5 && v4 + *(_QWORD *)(a2 + 72) > v5)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = (*(_DWORD *)(a2 + 92) & 0x80000400) != 0;
    *a4 = 1;
  }
  return result;
}

BOOL dyld4::RuntimeState::inPermanentRange(dyld4::RuntimeState *this, unint64_t a2, unint64_t a3, unsigned __int8 *a4, const Loader **a5)
{
  dyld4::RuntimeState::PermanentRanges *v5;
  _BOOL8 result;

  v5 = (dyld4::RuntimeState::PermanentRanges *)*((_QWORD *)this + 131);
  if (!v5)
    return 0;
  do
  {
    result = dyld4::RuntimeState::PermanentRanges::contains(v5, a2, a3, a4, a5);
    if (result)
      break;
    v5 = (dyld4::RuntimeState::PermanentRanges *)atomic_load((unint64_t *)v5);
  }
  while (v5);
  return result;
}

BOOL dyld4::RuntimeState::PermanentRanges::contains(dyld4::RuntimeState::PermanentRanges *this, unint64_t a2, unint64_t a3, unsigned __int8 *a4, const Loader **a5)
{
  unint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  BOOL v8;

  v5 = *((_QWORD *)this + 1);
  if (v5)
  {
    v6 = 0;
    v7 = (_QWORD *)((char *)this + 40);
    v8 = 1;
    while (*(v7 - 3) > a2 || *(v7 - 2) <= a3)
    {
      v8 = ++v6 < v5;
      v7 += 4;
      if (v5 == v6)
        return 0;
    }
    *a4 = *v7;
    *a5 = (const Loader *)*(v7 - 1);
  }
  else
  {
    return 0;
  }
  return v8;
}

uint64_t ___ZNK5dyld39MachOFile14hasLoadCommandEj_block_invoke(uint64_t result, _DWORD *a2, _BYTE *a3)
{
  if (*a2 == *(_DWORD *)(result + 40))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

size_t _platform_strlcpy(void *a1, char *__s, size_t a3)
{
  size_t v6;
  size_t v7;
  size_t v8;

  v6 = _platform_strlen(__s);
  v7 = v6;
  if (v6 >= a3)
  {
    if (a3)
    {
      v8 = a3 - 1;
      memmove(a1, __s, v8);
      *((_BYTE *)a1 + v8) = 0;
    }
  }
  else
  {
    memmove(a1, __s, v6 + 1);
  }
  return v7;
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __n)
{
  _QWORD *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  size_t v15;
  BOOL v16;
  unint64_t k;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  size_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  size_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  size_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  BOOL v43;
  size_t j;
  char v45;
  char *v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  size_t i;
  char v72;

  if ((_BYTE *)__dst - (_BYTE *)__src < __n)
  {
    if (__dst != __src)
    {
      v46 = (char *)__dst + __n;
      v47 = (char *)__src + __n;
      if (__n < 0x40)
      {
        while (1)
        {
          v43 = __n >= 8;
          __n -= 8;
          if (!v43)
            break;
          v70 = *((_QWORD *)v47 - 1);
          v47 -= 8;
          *((_QWORD *)v46 - 1) = v70;
          v46 -= 8;
        }
        for (i = __n + 8; i; --i)
        {
          v72 = *--v47;
          *--v46 = v72;
        }
      }
      else
      {
        if (__n < 0x4000)
        {
          v65 = *((_QWORD *)v47 - 2);
          v66 = *((_QWORD *)v47 - 1);
          v67 = *((_QWORD *)v47 - 4);
          v68 = *((_QWORD *)v47 - 3);
          v52 = (unint64_t)(v46 - 1) & 0xFFFFFFFFFFFFFFE0;
          v69 = v47 - &v46[-v52];
          v54 = *(_QWORD *)(v69 - 16);
          v55 = *(_QWORD *)(v69 - 8);
          v56 = *(_QWORD *)(v69 - 32);
          v57 = *(_QWORD *)(v69 - 24);
          *((_QWORD *)v46 - 2) = v65;
          *((_QWORD *)v46 - 1) = v66;
          *((_QWORD *)v46 - 4) = v67;
          *((_QWORD *)v46 - 3) = v68;
          v58 = v69 - 32;
          v59 = v52 - (_QWORD)__dst - 64;
          if (v52 - (unint64_t)__dst > 0x40)
          {
            do
            {
              *(_QWORD *)(v52 - 16) = v54;
              *(_QWORD *)(v52 - 8) = v55;
              *(_QWORD *)(v52 - 32) = v56;
              *(_QWORD *)(v52 - 24) = v57;
              v52 -= 32;
              v54 = *(_QWORD *)(v58 - 16);
              v55 = *(_QWORD *)(v58 - 8);
              v56 = *(_QWORD *)(v58 - 32);
              v57 = *(_QWORD *)(v58 - 24);
              v58 -= 32;
              v16 = v59 > 0x20;
              v59 -= 32;
            }
            while (v16);
          }
        }
        else
        {
          v48 = *((_QWORD *)v47 - 2);
          v49 = *((_QWORD *)v47 - 1);
          v50 = *((_QWORD *)v47 - 4);
          v51 = *((_QWORD *)v47 - 3);
          v52 = (unint64_t)(v46 - 1) & 0xFFFFFFFFFFFFFFE0;
          v53 = v47 - &v46[-v52];
          v54 = *(_QWORD *)(v53 - 16);
          v55 = *(_QWORD *)(v53 - 8);
          v56 = *(_QWORD *)(v53 - 32);
          v57 = *(_QWORD *)(v53 - 24);
          *((_QWORD *)v46 - 2) = v48;
          *((_QWORD *)v46 - 1) = v49;
          *((_QWORD *)v46 - 4) = v50;
          *((_QWORD *)v46 - 3) = v51;
          v58 = v53 - 32;
          v59 = v52 - (_QWORD)__dst - 64;
          if (v52 - (unint64_t)__dst > 0x40)
          {
            do
            {
              *(_QWORD *)(v52 - 16) = v54;
              *(_QWORD *)(v52 - 8) = v55;
              *(_QWORD *)(v52 - 32) = v56;
              *(_QWORD *)(v52 - 24) = v57;
              v52 -= 32;
              v54 = *(_QWORD *)(v58 - 16);
              v55 = *(_QWORD *)(v58 - 8);
              v56 = *(_QWORD *)(v58 - 32);
              v57 = *(_QWORD *)(v58 - 24);
              v58 -= 32;
              v16 = v59 > 0x20;
              v59 -= 32;
            }
            while (v16);
          }
        }
        v60 = v58 - v59;
        v61 = *(_QWORD *)(v60 - 16);
        v62 = *(_QWORD *)(v60 - 8);
        v63 = *(_QWORD *)(v60 - 32);
        v64 = *(_QWORD *)(v60 - 24);
        *(_QWORD *)(v52 - 16) = v54;
        *(_QWORD *)(v52 - 8) = v55;
        *(_QWORD *)(v52 - 32) = v56;
        *(_QWORD *)(v52 - 24) = v57;
        *((_QWORD *)__dst + 2) = v61;
        *((_QWORD *)__dst + 3) = v62;
        *(_QWORD *)__dst = v63;
        *((_QWORD *)__dst + 1) = v64;
      }
    }
  }
  else
  {
    v3 = __dst;
    if (__n < 0x40)
    {
      while (1)
      {
        v43 = __n >= 8;
        __n -= 8;
        if (!v43)
          break;
        v42 = *(_QWORD *)__src;
        __src = (char *)__src + 8;
        *v3++ = v42;
      }
      for (j = __n + 8; j; --j)
      {
        v45 = *(_BYTE *)__src;
        __src = (char *)__src + 1;
        *(_BYTE *)v3 = v45;
        v3 = (_QWORD *)((char *)v3 + 1);
      }
    }
    else
    {
      if ((_BYTE *)__src - (_BYTE *)__dst < __n)
      {
        if (__n < 0x4000)
        {
          v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0);
          v30 = *(_QWORD *)__src;
          v31 = *((_QWORD *)__src + 1);
          v32 = *((_QWORD *)__src + 2);
          v33 = *((_QWORD *)__src + 3);
          v34 = (uint64_t *)((char *)__src + v4 - (_BYTE *)__dst);
          v10 = *v34;
          v11 = v34[1];
          v12 = v34[2];
          v13 = v34[3];
          v14 = v34 + 4;
          v35 = __n - (v4 - (_BYTE *)__dst);
          *(_QWORD *)__dst = v30;
          *((_QWORD *)__dst + 1) = v31;
          *((_QWORD *)__dst + 2) = v32;
          *((_QWORD *)__dst + 3) = v33;
          v16 = v35 > 0x40;
          for (k = v35 - 64; v16; k -= 32)
          {
            *(_QWORD *)v4 = v10;
            *((_QWORD *)v4 + 1) = v11;
            *((_QWORD *)v4 + 2) = v12;
            *((_QWORD *)v4 + 3) = v13;
            v4 += 32;
            v10 = *v14;
            v11 = v14[1];
            v12 = v14[2];
            v13 = v14[3];
            v14 += 4;
            v16 = k > 0x20;
          }
        }
        else
        {
          v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0);
          v24 = *(_QWORD *)__src;
          v25 = *((_QWORD *)__src + 1);
          v26 = *((_QWORD *)__src + 2);
          v27 = *((_QWORD *)__src + 3);
          v28 = (uint64_t *)((char *)__src + v4 - (_BYTE *)__dst);
          v10 = *v28;
          v11 = v28[1];
          v12 = v28[2];
          v13 = v28[3];
          v14 = v28 + 4;
          v29 = __n - (v4 - (_BYTE *)__dst);
          *(_QWORD *)__dst = v24;
          *((_QWORD *)__dst + 1) = v25;
          *((_QWORD *)__dst + 2) = v26;
          *((_QWORD *)__dst + 3) = v27;
          v16 = v29 > 0x40;
          for (k = v29 - 64; v16; k -= 32)
          {
            *(_QWORD *)v4 = v10;
            *((_QWORD *)v4 + 1) = v11;
            *((_QWORD *)v4 + 2) = v12;
            *((_QWORD *)v4 + 3) = v13;
            v4 += 32;
            v10 = *v14;
            v11 = v14[1];
            v12 = v14[2];
            v13 = v14[3];
            v14 += 4;
            v16 = k > 0x20;
          }
        }
      }
      else if (__n < 0x4000)
      {
        v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0);
        v18 = *(_QWORD *)__src;
        v19 = *((_QWORD *)__src + 1);
        v20 = *((_QWORD *)__src + 2);
        v21 = *((_QWORD *)__src + 3);
        v22 = (uint64_t *)((char *)__src + v4 - (_BYTE *)__dst);
        v10 = *v22;
        v11 = v22[1];
        v12 = v22[2];
        v13 = v22[3];
        v14 = v22 + 4;
        v23 = __n - (v4 - (_BYTE *)__dst);
        *(_QWORD *)__dst = v18;
        *((_QWORD *)__dst + 1) = v19;
        *((_QWORD *)__dst + 2) = v20;
        *((_QWORD *)__dst + 3) = v21;
        v16 = v23 > 0x40;
        for (k = v23 - 64; v16; k -= 32)
        {
          *(_QWORD *)v4 = v10;
          *((_QWORD *)v4 + 1) = v11;
          *((_QWORD *)v4 + 2) = v12;
          *((_QWORD *)v4 + 3) = v13;
          v4 += 32;
          v10 = *v14;
          v11 = v14[1];
          v12 = v14[2];
          v13 = v14[3];
          v14 += 4;
          v16 = k > 0x20;
        }
      }
      else
      {
        v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0);
        v5 = *(_QWORD *)__src;
        v6 = *((_QWORD *)__src + 1);
        v7 = *((_QWORD *)__src + 2);
        v8 = *((_QWORD *)__src + 3);
        v9 = (uint64_t *)((char *)__src + v4 - (_BYTE *)__dst);
        v10 = *v9;
        v11 = v9[1];
        v12 = v9[2];
        v13 = v9[3];
        v14 = v9 + 4;
        v15 = __n - (v4 - (_BYTE *)__dst);
        *(_QWORD *)__dst = v5;
        *((_QWORD *)__dst + 1) = v6;
        *((_QWORD *)__dst + 2) = v7;
        *((_QWORD *)__dst + 3) = v8;
        v16 = v15 > 0x40;
        for (k = v15 - 64; v16; k -= 32)
        {
          *(_QWORD *)v4 = v10;
          *((_QWORD *)v4 + 1) = v11;
          *((_QWORD *)v4 + 2) = v12;
          *((_QWORD *)v4 + 3) = v13;
          v4 += 32;
          v10 = *v14;
          v11 = v14[1];
          v12 = v14[2];
          v13 = v14[3];
          v14 += 4;
          v16 = k > 0x20;
        }
      }
      v36 = (uint64_t *)((char *)v14 + k);
      v37 = *v36;
      v38 = v36[1];
      v39 = v36[2];
      v40 = v36[3];
      *(_QWORD *)v4 = v10;
      *((_QWORD *)v4 + 1) = v11;
      *((_QWORD *)v4 + 2) = v12;
      *((_QWORD *)v4 + 3) = v13;
      v41 = &v4[k];
      *((_QWORD *)v41 + 4) = v37;
      *((_QWORD *)v41 + 5) = v38;
      *((_QWORD *)v41 + 6) = v39;
      *((_QWORD *)v41 + 7) = v40;
    }
  }
  return __dst;
}

uint64_t ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_4(uint64_t result, uint64_t a2, int a3, _BYTE *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;

  if (*(_BYTE *)(a2 + 92) == 22)
  {
    v5 = result;
    if ((*(_BYTE *)(a2 + 52) & 2) != 0)
    {
      result = Diagnostics::error(*(vm_address_t **)(result + 56), "initializer offsets section %s/%s must be in read-only segment");
      goto LABEL_6;
    }
    v6 = *(_QWORD *)(a2 + 72);
    if ((v6 & 3) != 0)
    {
      result = Diagnostics::error(*(vm_address_t **)(result + 56), "initializer offsets section %s/%s has bad size");
LABEL_6:
      *a4 = 1;
      return result;
    }
    if (a3)
    {
      result = Diagnostics::error(*(vm_address_t **)(result + 56), "initializer offsets section %s/%s extends beyond the end of the segment");
      goto LABEL_6;
    }
    v7 = *(_QWORD *)(a2 + 64);
    if ((v7 & 3) != 0)
    {
      result = Diagnostics::error(*(vm_address_t **)(result + 56), "initializer offsets section %s/%s is not 4-byte aligned");
      goto LABEL_6;
    }
    if (v6 >= 1)
    {
      v8 = (unsigned int *)(*(_QWORD *)(result + 48) + v7);
      v9 = (unsigned int *)((char *)v8 + v6);
      while (1)
      {
        v10 = *(_QWORD *)(*(_QWORD *)(v5 + 40) + 8);
        v11 = *(_QWORD *)(v10 + 80);
        if (!v11)
          break;
        v12 = *(_QWORD *)(v5 + 64) + *v8;
        v13 = *(_QWORD *)(v10 + 64);
        v14 = 24 * v11;
        v15 = (unint64_t *)(v13 + 8);
        while (*(v15 - 1) > v12 || *v15 <= v12)
        {
          v15 += 3;
          v14 -= 24;
          if (!v14)
            goto LABEL_22;
        }
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v5 + 32) + 16))();
        if (++v8 >= v9)
          return result;
      }
LABEL_22:
      result = Diagnostics::error(*(vm_address_t **)(v5 + 56), "initializer 0x%08X is not an offset to an executable segment");
      goto LABEL_6;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile32forEachInitializerPointerSectionER11DiagnosticsU13block_pointerFvjjRbE_block_invoke(uint64_t result, uint64_t a2, int a3, _BYTE *a4)
{
  unint64_t v5;
  unint64_t v6;

  if (*(_BYTE *)(a2 + 92) == 9)
  {
    v5 = *(unsigned int *)(result + 56);
    if (*(_QWORD *)(a2 + 72) % v5)
    {
      result = Diagnostics::error(*(vm_address_t **)(result + 40), "initializer section %s/%s has bad size");
    }
    else if (a3)
    {
      result = Diagnostics::error(*(vm_address_t **)(result + 40), "initializer section %s/%s extends beyond its segment");
    }
    else
    {
      v6 = *(_QWORD *)(a2 + 64);
      if (!(v6 % v5))
        return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(result + 32) + 16))(*(_QWORD *)(result + 32), (v6 - *(_DWORD *)(result + 48)));
      result = Diagnostics::error(*(vm_address_t **)(result + 40), "initializer section %s/%s is not pointer aligned");
    }
    *a4 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_2(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *j;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *i;

  if (*(_DWORD *)a2 == 26)
  {
    v8 = *(_QWORD *)(*(_QWORD *)(result + 40) + 8);
    v9 = *(_QWORD *)(v8 + 80);
    if (v9)
    {
      v4 = *(_QWORD *)(a2 + 8);
      v10 = *(_QWORD *)(v8 + 64);
      v11 = 24 * v9;
      for (i = (unint64_t *)(v10 + 8); *(i - 1) > v4 || *i <= v4; i += 3)
      {
        v11 -= 24;
        if (!v11)
          return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
      }
      return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(result + 32) + 16))(*(_QWORD *)(result + 32), (v4 - *(_DWORD *)(result + 48)));
    }
    return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
  }
  if (*(_DWORD *)a2 == 17)
  {
    v2 = *(_QWORD *)(*(_QWORD *)(result + 40) + 8);
    v3 = *(_QWORD *)(v2 + 80);
    if (v3)
    {
      v4 = *(unsigned int *)(a2 + 8);
      v5 = *(_QWORD *)(v2 + 64);
      v6 = 24 * v3;
      for (j = (unint64_t *)(v5 + 8); *(j - 1) > v4 || *j <= v4; j += 3)
      {
        v6 -= 24;
        if (!v6)
          return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
      }
      return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(result + 32) + 16))(*(_QWORD *)(result + 32), (v4 - *(_DWORD *)(result + 48)));
    }
    return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile24forEachSupportedPlatformEU13block_pointerFvNS_8PlatformEjjE_block_invoke(uint64_t result, int *a2)
{
  uint64_t v2;
  int v3;
  uint64_t (*v4)(void);
  uint64_t (*v5)(void);

  v2 = result;
  v3 = *a2;
  if (*a2 <= 46)
  {
    if (v3 == 36)
    {
      v5 = *(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16);
    }
    else
    {
      if (v3 != 37)
        return result;
      v5 = *(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16);
    }
    goto LABEL_13;
  }
  if (v3 != 47)
  {
    if (v3 != 48)
    {
      if (v3 != 50)
        return result;
      v4 = *(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16);
      goto LABEL_10;
    }
    v5 = *(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16);
LABEL_13:
    result = v5();
    goto LABEL_14;
  }
  v4 = *(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16);
LABEL_10:
  result = v4();
LABEL_14:
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v2 + 40) + 8) + 24) = 1;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile20preferredLoadAddressEv_block_invoke(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result;

  result = _platform_strcmp(*(const char **)(a2 + 40), "__TEXT");
  if (!(_DWORD)result)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 16);
    *a3 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded13getLayoutInfoERNS0_10LayoutInfoE_block_invoke(uint64_t a1, int64x2_t *a2)
{
  const char *v4;
  uint64_t result;
  int32x2_t *v6;
  uint64_t v7;

  v4 = (const char *)a2[2].i64[1];
  result = _platform_strcmp(v4, "__TEXT");
  if ((_DWORD)result)
  {
    result = _platform_strcmp(v4, "__LINKEDIT");
    v6 = *(int32x2_t **)(a1 + 40);
    if (!(_DWORD)result)
    {
      v6[2] = *(int32x2_t *)a2[1].i8;
      v6[3] = vmovn_s64(*a2);
      v6[4].i32[0] = (unsigned __int16)a2[3].i32[2] >> 4;
    }
  }
  else
  {
    v7 = a2[1].i64[0];
    v6 = *(int32x2_t **)(a1 + 40);
    *v6 = (int32x2_t)(*(_QWORD *)(a1 + 32) - v7);
    v6[1] = (int32x2_t)v7;
  }
  v6[4].i32[1] = (unsigned __int16)a2[3].i32[2] >> 4;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile21forEachDependentDylibEU13block_pointerFvPKcbbbjjRbE_block_invoke(uint64_t result, char *a2, _BYTE *a3)
{
  int v3;
  uint64_t v7;

  v3 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 + 2147483624) <= 0xB && ((1 << (*(_DWORD *)a2 - 24)) & 0x881) != 0 || v3 == 12)
  {
    v7 = result;
    result = (*(uint64_t (**)(_QWORD, char *, BOOL, BOOL, BOOL, _QWORD, _QWORD, _BYTE *))(*(_QWORD *)(result + 32)
                                                                                                  + 16))(*(_QWORD *)(result + 32), &a2[*((unsigned int *)a2 + 2)], v3 == -2147483624, v3 == -2147483617, v3 == -2147483613, *((unsigned int *)a2 + 5), *((unsigned int *)a2 + 4), a3);
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 40) + 8) + 24);
    if (*a3)
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v7 + 48) + 8) + 24) = 1;
  }
  return result;
}

BOOL ___ZN5dyld44APIs26NSVersionOfLinkTimeLibraryEPKc_block_invoke(uint64_t a1, dyld4 *this, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  _BOOL8 result;

  result = dyld4::nameMatch(this, *(const char **)(a1 + 40), a3);
  if (result)
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a7;
  return result;
}

BOOL dyld4::nameMatch(dyld4 *this, const char *a2, const char *a3)
{
  const char *v4;
  char *v5;
  size_t v6;
  size_t v7;
  size_t v8;

  v4 = (const char *)this;
  v5 = strrchr((char *)this, 47);
  if (v5)
    v4 = v5 + 1;
  if (!_platform_strcmp(v4, a2))
    return 1;
  v6 = _platform_strlen(v4);
  v7 = _platform_strlen(a2);
  if (v6 < v7 + 9)
    return 0;
  v8 = v7;
  return !_platform_strncmp(v4, "lib", 3uLL)
      && !_platform_strcmp(&v4[v6 - 6], ".dylib")
      && !_platform_strncmp(v4 + 3, a2, v8)
      && v4[v8 + 3] == 46;
}

char *__cdecl strrchr(char *__s, int __c)
{
  char *result;
  char *v4;
  int v5;
  int v6;

  result = 0;
  v4 = __s;
  do
  {
    v6 = *v4++;
    v5 = v6;
    if ((char)__c == v6)
      result = __s;
    __s = v4;
  }
  while (v5);
  return result;
}

void Diagnostics::assertNoError(Diagnostics *a1)
{
  const char *v1;

  v1 = (const char *)Diagnostics::errorMessageCStr(a1);
  abort_report_np("%s", v1);
}

uint64_t ___ZNK5dyld416JustInTimeLoader8containsERNS_12RuntimeStateEPKvPS4_PyPh_block_invoke(uint64_t result, uint64_t a2, _BYTE *a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  _BYTE *v6;

  v3 = *(_QWORD *)(result + 48);
  v4 = *(_QWORD *)(result + 40) + *(_QWORD *)(a2 + 16);
  if (v4 <= v3)
  {
    v5 = *(_QWORD *)(a2 + 24);
    if (v3 < v5 + v4)
    {
      **(_QWORD **)(result + 56) = v4;
      v6 = *(_BYTE **)(result + 72);
      **(_QWORD **)(result + 64) = v5;
      *v6 = *(_DWORD *)(a2 + 52);
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
      *a3 = 1;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile33findFairPlayEncryptionLoadCommandEv_block_invoke(uint64_t result, _DWORD *a2, _BYTE *a3)
{
  if (*a2 == 44 || *a2 == 33)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
    *a3 = 1;
  }
  return result;
}

char *___ZNK5dyld39MachOFile10forDyldEnvEU13block_pointerFvPKcRbE_block_invoke(char *result, _DWORD *a2)
{
  char *v2;
  char *v3;

  if (*a2 == 39)
  {
    v2 = result;
    v3 = (char *)a2 + a2[2];
    result = (char *)_platform_strncmp(v3, "DYLD_", 5uLL);
    if (!(_DWORD)result)
    {
      result = _platform_strchr(v3, 61);
      if (result)
        return (char *)(*(uint64_t (**)(void))(*((_QWORD *)v2 + 4) + 16))();
    }
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded17findClosestSymbolEyPPKcPy_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  unint64_t v4;
  unint64_t v5;

  v4 = *(_QWORD *)(result + 40);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24);
  v5 = *(_QWORD *)(a2 + 64);
  if (v5 <= v4 && v4 < *(_QWORD *)(a2 + 72) + v5)
    *a4 = 1;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile19dependentDylibCountEPb_block_invoke(uint64_t result, uint64_t a2, char a3, char a4, int a5)
{
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24);
  if ((a3 & 1) != 0 || (a4 & 1) != 0 || a5)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = 0;
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer14hasSwiftOrObjCEPb_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v7;
  const char *v8;
  uint64_t result;
  _BYTE *v10;

  v7 = a1[5];
  v8 = *(const char **)(a2 + 80);
  result = _platform_strcmp(v8, "__objc_imageinfo");
  if (!(_DWORD)result)
  {
    result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
    if (!(_DWORD)result)
    {
      v10 = (_BYTE *)a1[6];
      if (v10 && *(_BYTE *)(a1[7] + *(_QWORD *)(a2 + 64) + 5))
        *v10 = 1;
      *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  if (*(_DWORD *)(v7 + 4) == 7)
  {
    result = _platform_strcmp(v8, "__image_info");
    if (!(_DWORD)result)
    {
      result = _platform_strcmp(*(const char **)(a2 + 40), "__OBJC");
      if (!(_DWORD)result)
      {
        *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
        *a4 = 1;
      }
    }
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile25forEachInterposingSectionER11DiagnosticsU13block_pointerFvyyRbE_block_invoke(uint64_t a1, uint64_t a2, int a3, _BYTE *a4)
{
  dyld3::MachOFile *v8;
  uint64_t result;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v8 = *(dyld3::MachOFile **)(a1 + 40);
  if (*(_BYTE *)(a2 + 92) == 13
    || (result = _platform_strcmp(*(const char **)(a2 + 80), "__interpose"), !(_DWORD)result)
    && ((v10 = *(const char **)(a2 + 40), !_platform_strncmp(v10, "__DATA", 6uLL))
     || (result = _platform_strncmp(v10, "__AUTH", 6uLL), !(_DWORD)result)))
  {
    if (*(_QWORD *)(a2 + 72) % (unint64_t)*(unsigned int *)(a1 + 56))
    {
      result = Diagnostics::error(*(vm_address_t **)(a1 + 48), "interposing section %s/%s has bad size");
    }
    else if (a3)
    {
      result = Diagnostics::error(*(vm_address_t **)(a1 + 48), "interposing section %s/%s extends beyond the end of the segment");
    }
    else
    {
      v11 = *(_QWORD *)(a2 + 64);
      if (!(v11 % *(unsigned int *)(a1 + 60)))
      {
        v12 = *(_QWORD *)(a1 + 32);
        v13 = v11 - dyld3::MachOFile::preferredLoadAddress(v8);
        return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _BYTE *))(v12 + 16))(v12, v13, *(_QWORD *)(a2 + 72), a4);
      }
      result = Diagnostics::error(*(vm_address_t **)(a1 + 48), "interposing section %s/%s is not pointer aligned");
    }
    *a4 = 1;
  }
  return result;
}

double ___ZNK5dyld313MachOAnalyzer17getLinkeditLayoutER11DiagnosticsyPKhRN6mach_o14LinkeditLayoutE_block_invoke(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  dyld3::MachOFile *v15;
  double result;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  v4 = *(_DWORD *)a2;
  if (*(int *)a2 > 10)
  {
    switch(v4)
    {
      case 29:
        v10 = *(_QWORD *)(a1 + 40);
        v11 = *(_QWORD **)(a1 + 48);
        v12 = *(unsigned int *)(a2 + 8);
        v13 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(v10 + 552) = v12;
        *(_QWORD *)(v10 + 560) = **(_QWORD **)(a1 + 56) - *v11 + v12;
        v14 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)(v14 + 568) = v13;
        *(_DWORD *)(v14 + 576) = 0;
        *(_BYTE *)(v14 + 580) = 1;
        break;
      case 30:
        v56 = *(_QWORD *)(a1 + 40);
        v57 = *(_QWORD **)(a1 + 48);
        v58 = *(unsigned int *)(a2 + 8);
        v59 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(v56 + 456) = v58;
        *(_QWORD *)(v56 + 464) = **(_QWORD **)(a1 + 56) - *v57 + v58;
        v60 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)(v60 + 472) = v59;
        *(_DWORD *)(v60 + 480) = 0;
        *(_BYTE *)(v60 + 484) = 1;
        break;
      case 31:
      case 32:
      case 33:
      case 35:
      case 36:
      case 37:
        return result;
      case 34:
        goto LABEL_14;
      case 38:
        v61 = *(_QWORD *)(a1 + 40);
        v62 = *(_QWORD **)(a1 + 48);
        v63 = *(unsigned int *)(a2 + 8);
        v64 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(v61 + 488) = v63;
        *(_QWORD *)(v61 + 496) = **(_QWORD **)(a1 + 56) - *v62 + v63;
        v65 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)(v65 + 504) = v64;
        *(_DWORD *)(v65 + 512) = 0;
        *(_BYTE *)(v65 + 516) = 1;
        break;
      default:
        if (v4 == 11)
        {
          v66 = *(_QWORD *)(a1 + 40);
          v67 = *(uint64_t **)(a1 + 48);
          *(_BYTE *)(v66 + 589) = 1;
          v68 = *(unsigned int *)(a2 + 72);
          *(_DWORD *)v66 = v68;
          v69 = *v67;
          v70 = *(_QWORD **)(a1 + 56);
          *(_QWORD *)(v66 + 8) = *v70 - v69 + v68;
          v71 = *(_QWORD *)(a1 + 40);
          *(_QWORD *)(v71 + 16) = 0;
          *(_DWORD *)(v71 + 24) = *(_DWORD *)(a2 + 76);
          *(_BYTE *)(v71 + 28) = 1;
          v72 = *(unsigned int *)(a2 + 64);
          *(_DWORD *)(v71 + 32) = v72;
          *(_QWORD *)(v71 + 40) = *v70 - v69 + v72;
          v73 = *(_QWORD *)(a1 + 40);
          *(_QWORD *)(v73 + 48) = 0;
          *(_DWORD *)(v73 + 56) = *(_DWORD *)(a2 + 68);
          *(_BYTE *)(v73 + 60) = 1;
          v74 = *(unsigned int *)(a2 + 56);
          *(_DWORD *)(v73 + 64) = v74;
          *(_QWORD *)(v73 + 72) = *v70 - v69 + v74;
          v75 = *(_QWORD *)(a1 + 40);
          *(_QWORD *)(v75 + 80) = 0;
          *(_DWORD *)(v75 + 88) = *(_DWORD *)(a2 + 60);
          *(_BYTE *)(v75 + 92) = 1;
          *(_DWORD *)(v75 + 96) = 0;
          *(_QWORD *)(v75 + 104) = 0;
          v76 = *(_QWORD *)(a1 + 40);
          *(_DWORD *)(v76 + 112) = 0;
          *(_QWORD *)(v76 + 116) = *(_QWORD *)(a2 + 8);
          *(_BYTE *)(v76 + 124) = 1;
          *(_DWORD *)(v76 + 128) = 0;
          *(_QWORD *)(v76 + 136) = 0;
          v77 = *(_QWORD *)(a1 + 40);
          *(_DWORD *)(v77 + 144) = 0;
          *(_QWORD *)(v77 + 148) = *(_QWORD *)(a2 + 16);
          *(_BYTE *)(v77 + 156) = 1;
          *(_DWORD *)(v77 + 160) = 0;
          *(_QWORD *)(v77 + 168) = 0;
          v78 = *(_QWORD *)(a1 + 40);
          *(_DWORD *)(v78 + 176) = 0;
          result = *(double *)(a2 + 24);
          *(double *)(v78 + 180) = result;
          *(_BYTE *)(v78 + 188) = 1;
        }
        else if (v4 == 41)
        {
          v46 = *(_QWORD *)(a1 + 40);
          v47 = *(_QWORD **)(a1 + 48);
          v48 = *(unsigned int *)(a2 + 8);
          v49 = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(v46 + 520) = v48;
          *(_QWORD *)(v46 + 528) = **(_QWORD **)(a1 + 56) - *v47 + v48;
          v50 = *(_QWORD *)(a1 + 40);
          *(_DWORD *)(v50 + 536) = v49;
          *(_DWORD *)(v50 + 544) = 0;
          *(_BYTE *)(v50 + 548) = 1;
        }
        break;
    }
  }
  else if (v4 > -2147483597)
  {
    if (v4 == -2147483596)
    {
      v51 = *(_QWORD *)(a1 + 40);
      v52 = **(_QWORD **)(a1 + 56) - **(_QWORD **)(a1 + 48);
      v53 = *(unsigned int *)(a2 + 8);
      v54 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v51 + 384) = v53;
      *(_QWORD *)(v51 + 392) = v52 + v53;
      v55 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)(v55 + 400) = v54;
      *(_DWORD *)(v55 + 408) = 0;
      *(_BYTE *)(v55 + 412) = 1;
      *(_QWORD *)(v55 + 416) = a2;
    }
    else if (v4 == 2)
    {
      v15 = *(dyld3::MachOFile **)(a1 + 32);
      *(_BYTE *)(*(_QWORD *)(a1 + 40) + 588) = 1;
      if (dyld3::MachOFile::is64(v15))
        v17 = 16;
      else
        v17 = 12;
      v18 = *(_QWORD *)(a1 + 40);
      v19 = *(uint64_t **)(a1 + 48);
      v20 = *(unsigned int *)(a2 + 8);
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v18 + 192) = v20;
      v22 = *v19;
      v23 = *(_QWORD **)(a1 + 56);
      *(_QWORD *)(v18 + 200) = *v23 - v22 + v20;
      v24 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)(v24 + 208) = v21 * v17;
      *(_DWORD *)(v24 + 216) = v21;
      *(_BYTE *)(v24 + 220) = 1;
      v25 = *(unsigned int *)(a2 + 16);
      LODWORD(v20) = *(_DWORD *)(a2 + 20);
      *(_DWORD *)(v24 + 224) = v25;
      *(_QWORD *)(v24 + 232) = *v23 - v22 + v25;
      v26 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)(v26 + 240) = v20;
      *(_BYTE *)(v26 + 252) = 1;
    }
  }
  else
  {
    if (v4 == -2147483614)
    {
LABEL_14:
      v27 = *(_QWORD *)(a1 + 40);
      v28 = *(uint64_t **)(a1 + 48);
      *(_DWORD *)(v27 + 584) = v4;
      v29 = *(unsigned int *)(a2 + 8);
      v30 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v27 + 256) = v29;
      v31 = *v28;
      v32 = *(_QWORD **)(a1 + 56);
      *(_QWORD *)(v27 + 264) = *v32 - v31 + v29;
      v33 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)(v33 + 272) = v30;
      *(_BYTE *)(v33 + 284) = 1;
      v34 = *(unsigned int *)(a2 + 16);
      v35 = *(_DWORD *)(a2 + 20);
      *(_DWORD *)(v33 + 288) = v34;
      *(_QWORD *)(v33 + 296) = *v32 - v31 + v34;
      v36 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)(v36 + 304) = v35;
      *(_BYTE *)(v36 + 316) = 1;
      v37 = *(unsigned int *)(a2 + 32);
      v38 = *(_DWORD *)(a2 + 36);
      *(_DWORD *)(v36 + 352) = v37;
      *(_QWORD *)(v36 + 360) = *v32 - v31 + v37;
      v39 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)(v39 + 368) = v38;
      v40 = *(unsigned int *)(a2 + 24);
      v41 = *(_DWORD *)(a2 + 28);
      *(_DWORD *)(v39 + 320) = v40;
      v42 = *v32 - v31;
      *(_BYTE *)(v39 + 380) = 1;
      *(_QWORD *)(v39 + 328) = v42 + v40;
      v43 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)(v43 + 336) = v41;
      *(_BYTE *)(v43 + 348) = 1;
      v44 = *(unsigned int *)(a2 + 40);
      v45 = *(_DWORD *)(a2 + 44);
      *(_DWORD *)(v43 + 424) = v44;
      *(_QWORD *)(v43 + 432) = *v32 - v31 + v44;
      v9 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)(v9 + 440) = v45;
    }
    else
    {
      if (v4 != -2147483597)
        return result;
      v5 = *(_QWORD *)(a1 + 40);
      v6 = *(_QWORD **)(a1 + 48);
      v7 = *(unsigned int *)(a2 + 8);
      v8 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v5 + 424) = v7;
      *(_QWORD *)(v5 + 432) = **(_QWORD **)(a1 + 56) - *v6 + v7;
      v9 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)(v9 + 440) = v8;
      *(_DWORD *)(v9 + 448) = 0;
    }
    *(_BYTE *)(v9 + 452) = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke_2(uint64_t result, int *a2)
{
  int v2;
  _DWORD *v3;

  v2 = *a2;
  if (*a2 != 34)
  {
    if (v2 == -2147483597)
    {
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2[2];
      v3 = a2 + 3;
      goto LABEL_6;
    }
    if (v2 != -2147483614)
      return result;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2[10];
  v3 = a2 + 11;
LABEL_6:
  **(_DWORD **)(result + 40) = *v3;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile10hasSectionEPKcS2__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result;

  result = _platform_strcmp(*(const char **)(a2 + 40), *(const char **)(a1 + 40));
  if (!(_DWORD)result)
  {
    result = _platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 48));
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile12isRestrictedEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result;

  result = _platform_strcmp(*(const char **)(a2 + 40), "__RESTRICT");
  if (!(_DWORD)result)
  {
    result = _platform_strcmp(*(const char **)(a2 + 80), "__restrict");
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke(uint64_t result, _DWORD *a2, _BYTE *a3)
{
  _DWORD *v3;

  if (*a2 == 29)
  {
    v3 = *(_DWORD **)(result + 40);
    **(_DWORD **)(result + 32) = a2[2];
    *v3 = a2[3];
    *a3 = 1;
  }
  return result;
}

BOOL dyld3::MachOFile::isPreload(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 5;
}

unint64_t ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke(unint64_t result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (_QWORD *)result;
  v6 = *(_QWORD *)(result + 40);
  v7 = *(unsigned int *)a3;
  if (*(_BYTE *)(result + 64))
    v8 = (_DWORD)v7 == 0;
  else
    v8 = 1;
  if (v8 || (result = (***(uint64_t (****)(_QWORD))(v6 + 152))(*(_QWORD *)(v6 + 152)), result < 4))
  {
    LODWORD(v10) = *(_DWORD *)(*(_QWORD *)(v5[4] + 8) + 48);
    if (!(_DWORD)v10)
    {
      v11 = 0;
      result = (*(uint64_t (**)(_QWORD, uint64_t *))(**(_QWORD **)(v6 + 152) + 48))(*(_QWORD *)(v6 + 152), &v11);
      if ((_DWORD)result)
        dyld4::halt("could not create thread local variables pthread key", 0);
      *(_DWORD *)(*(_QWORD *)(v5[4] + 8) + 48) = v11;
      LODWORD(v10) = *(_DWORD *)(*(_QWORD *)(v5[4] + 8) + 48);
    }
    v10 = v10;
    goto LABEL_13;
  }
  result = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 152) + 168))(*(_QWORD *)(v6 + 152), v7);
  v9 = *(_QWORD *)(v5[4] + 8);
  v10 = *(unsigned int *)(v9 + 48);
  if (!(_DWORD)v10)
  {
    *(_DWORD *)(v9 + 48) = v7;
    goto LABEL_14;
  }
  if ((_DWORD)v10 != (_DWORD)v7)
LABEL_13:
    *a3 = v10;
LABEL_14:
  if (*a2 != v5[6])
    *a2 = v5[7];
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer17forEachTerminatorER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjE_block_invoke_2(uint64_t result, uint64_t a2, int a3, _BYTE *a4)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;

  if (*(_BYTE *)(a2 + 92) == 10)
  {
    v5 = result;
    v6 = *(_QWORD *)(a2 + 72);
    v7 = *(unsigned int *)(result + 80);
    if (v6 % v7)
    {
      result = Diagnostics::error(*(vm_address_t **)(result + 56), "terminator section %s/%s has bad size");
    }
    else if (a3)
    {
      result = Diagnostics::error(*(vm_address_t **)(result + 56), "terminator section %s/%s extends beyond its segment");
    }
    else
    {
      v8 = *(_QWORD *)(result + 48) + *(_QWORD *)(a2 + 64);
      if (v8 % (uint64_t)v7)
      {
        result = Diagnostics::error(*(vm_address_t **)(result + 56), "terminator section %s/%s is not pointer aligned");
      }
      else
      {
        v9 = (char *)(v8 + v6);
        if ((_DWORD)v7 == 8)
        {
          if (v6 < 1)
            return result;
          while (1)
          {
            v10 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(_QWORD *)(v5 + 64), *(_QWORD *)v8);
            v11 = *(_QWORD *)(*(_QWORD *)(v5 + 40) + 8);
            v12 = *(_QWORD *)(v11 + 80);
            if (!v12)
              break;
            v13 = *(_QWORD *)(v11 + 64);
            v14 = 24 * v12;
            v15 = (unint64_t *)(v13 + 8);
            while (*(v15 - 1) > v10 || *v15 <= v10)
            {
              v15 += 3;
              v14 -= 24;
              if (!v14)
                goto LABEL_27;
            }
            result = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(v5 + 32) + 16))(*(_QWORD *)(v5 + 32), (v10 - *(_DWORD *)(v5 + 72)));
            v8 += 8;
            if (v8 >= (unint64_t)v9)
              return result;
          }
LABEL_27:
          result = Diagnostics::error(*(vm_address_t **)(v5 + 56), "terminator 0x%0llX does not point within executable segment");
        }
        else
        {
          if (v6 < 1)
            return result;
          while (1)
          {
            v16 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(_QWORD *)(v5 + 64), *(unsigned int *)v8);
            v17 = *(_QWORD *)(*(_QWORD *)(v5 + 40) + 8);
            v18 = *(_QWORD *)(v17 + 80);
            if (!v18)
              break;
            v19 = *(_QWORD *)(v17 + 64);
            v20 = 24 * v18;
            v21 = (_QWORD *)(v19 + 8);
            while (*(v21 - 1) > (unint64_t)v16 || *v21 <= (unint64_t)v16)
            {
              v21 += 3;
              v20 -= 24;
              if (!v20)
                goto LABEL_28;
            }
            result = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(v5 + 32) + 16))(*(_QWORD *)(v5 + 32), v16 - *(_DWORD *)(v5 + 72));
            v8 += 4;
            if (v8 >= (unint64_t)v9)
              return result;
          }
LABEL_28:
          result = Diagnostics::error(*(vm_address_t **)(v5 + 56), "terminator 0x%0X does not point within executable segment");
        }
      }
    }
    *a4 = 1;
  }
  return result;
}

uint64_t ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  const char *v4;
  uint64_t result;
  const char *v6;
  uint64_t (*v7)(void);
  const char *v8;

  v4 = *(const char **)(a2 + 40);
  if (_platform_strcmp(v4, "__TEXT"))
  {
    result = _platform_strncmp(v4, "__DATA", 6uLL);
    if ((_DWORD)result)
      return result;
    v8 = *(const char **)(a2 + 80);
    if (!_platform_strcmp(v8, "__objc_imageinfo"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_selrefs"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_msgrefs"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_classrefs"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_superrefs"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_protorefs"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_classlist"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_stublist"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_nlclslist"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_catlist"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_catlist2"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_nlcatlist"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_protolist"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v8, "__objc_fork_ok"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    result = _platform_strcmp(v8, "__objc_rawisa");
    if (!(_DWORD)result)
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
  }
  else
  {
    v6 = *(const char **)(a2 + 80);
    if (!_platform_strcmp(v6, "__swift5_protos"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v6, "__swift5_proto"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v6, "__swift5_types"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v6, "__swift5_replace"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    if (!_platform_strcmp(v6, "__swift5_replac2"))
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
    result = _platform_strcmp(v6, "__swift5_acfuncs");
    if (!(_DWORD)result)
    {
      v7 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
      return v7();
    }
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile17hasPlusLoadMethodER11Diagnostics_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result;
  const char *v8;

  result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
  if (!(_DWORD)result)
  {
    v8 = *(const char **)(a2 + 80);
    result = _platform_strcmp(v8, "__objc_nlclslist");
    if (!(_DWORD)result || (result = _platform_strcmp(v8, "__objc_nlcatlist"), !(_DWORD)result))
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t dyld4::JustInTimeLoader::getSectionLocations(dyld4::JustInTimeLoader *this)
{
  return (uint64_t)this + 120;
}

uint64_t ___ZNK5dyld39MachOFile7hasObjCEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v7;
  const char *v8;
  uint64_t result;

  v7 = *(_QWORD *)(a1 + 40);
  v8 = *(const char **)(a2 + 80);
  result = _platform_strcmp(v8, "__objc_imageinfo");
  if (!(_DWORD)result)
  {
    result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  if (*(_DWORD *)(v7 + 4) == 7)
  {
    result = _platform_strcmp(v8, "__image_info");
    if (!(_DWORD)result)
    {
      result = _platform_strcmp(*(const char **)(a2 + 40), "__OBJC");
      if (!(_DWORD)result)
      {
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
        *a4 = 1;
      }
    }
  }
  return result;
}

void ___ZNK5dyld46Loader20makeSegmentsReadOnlyERNS_12RuntimeStateE_block_invoke(_QWORD *a1, uint64_t a2)
{
  dyld4::Loader *v3;
  size_t v4;
  char *v5;
  const dyld4::RuntimeState *v6;
  char *v7;
  char *v8;
  char *v9;
  const char *v10;

  if ((*(_BYTE *)(a2 + 56) & 2) != 0)
  {
    v3 = (dyld4::Loader *)a1[4];
    v4 = *(_QWORD *)(a2 + 24);
    v5 = (char *)(a1[5] + *(_QWORD *)(a2 + 16));
    dyld4::SyscallDelegate::mprotect(*(dyld4::SyscallDelegate **)(a1[6] + 8), v5, v4, 1);
    v6 = (const dyld4::RuntimeState *)a1[6];
    if (*(_BYTE *)(*((_QWORD *)v6 + 1) + 201))
    {
      v7 = &v5[v4];
      v8 = (char *)dyld4::Loader::path(v3, v6);
      v9 = strrchr(v8, 47);
      if (v9)
        v10 = v9 + 1;
      else
        v10 = v8;
      dyld4::RuntimeState::log(v6, "mprotect 0x%012lX->0x%012lX to read-only (%s)\n", v5, v7, v10);
    }
  }
}

uint64_t ___ZNK5dyld39MachOFile17forEachDOFSectionER11DiagnosticsU13block_pointerFvjE_block_invoke(uint64_t result, uint64_t a2, char a3)
{
  if (*(_BYTE *)(a2 + 92) == 15 && (a3 & 1) == 0)
    return (*(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16))();
  return result;
}

uint64_t ___ZNK5dyld39MachOFile16builtForPlatformENS_8PlatformEb_block_invoke(uint64_t result, int a2)
{
  uint64_t v2;

  if (*(_DWORD *)(result + 48) == a2)
    v2 = *(_QWORD *)(result + 32);
  else
    v2 = *(_QWORD *)(result + 40);
  *(_BYTE *)(*(_QWORD *)(v2 + 8) + 24) = 1;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile12segmentCountEv_block_invoke(uint64_t result)
{
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24);
  return result;
}

_QWORD *dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  const void **v4;
  vm_address_t v5;
  vm_size_t v6;
  unint64_t v7;
  vm_size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;

  v2 = result[1];
  v3 = result[2] + a2;
  if (v3 > v2)
  {
    v4 = (const void **)result;
    v5 = result[3];
    v6 = result[4];
    v7 = 2 * v2;
    if (v7 > v3)
      v3 = v7;
    v8 = (vm_page_size + 32 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    result = memmove((void *)v4[3], *v4, 32 * (_QWORD)v4[2]);
    v12 = (const void *)((unint64_t)v4[4] >> 5);
    *v4 = v4[3];
    v4[1] = v12;
    if (v5)
      return (_QWORD *)vm_deallocate(mach_task_self_, v5, v6);
  }
  return result;
}

__n128 ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  __n128 result;
  __int128 v4;
  __int128 v5;

  v2 = *(_QWORD *)(a1 + 32) + ((unint64_t)((unsigned __int16)*(_DWORD *)(a2 + 56) >> 4) << 6);
  result = *(__n128 *)a2;
  v4 = *(_OWORD *)(a2 + 16);
  v5 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v2 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v2 + 48) = v5;
  *(__n128 *)v2 = result;
  *(_OWORD *)(v2 + 16) = v4;
  return result;
}

void ___ZNK5dyld46Loader21makeSegmentsReadWriteERNS_12RuntimeStateE_block_invoke(_QWORD *a1, uint64_t a2)
{
  dyld4::Loader *v3;
  size_t v4;
  char *v5;
  const dyld4::RuntimeState *v6;
  char *v7;
  char *v8;
  char *v9;
  const char *v10;

  if ((*(_BYTE *)(a2 + 56) & 2) != 0)
  {
    v3 = (dyld4::Loader *)a1[4];
    v4 = *(_QWORD *)(a2 + 24);
    v5 = (char *)(a1[5] + *(_QWORD *)(a2 + 16));
    dyld4::SyscallDelegate::mprotect(*(dyld4::SyscallDelegate **)(a1[6] + 8), v5, v4, 3);
    v6 = (const dyld4::RuntimeState *)a1[6];
    if (*(_BYTE *)(*((_QWORD *)v6 + 1) + 201))
    {
      v7 = &v5[v4];
      v8 = (char *)dyld4::Loader::path(v3, v6);
      v9 = strrchr(v8, 47);
      if (v9)
        v10 = v9 + 1;
      else
        v10 = v8;
      dyld4::RuntimeState::log(v6, "mprotect 0x%012lX->0x%012lX to read-write (%s)\n", v5, v7, v10);
    }
  }
}

uint64_t ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke(_QWORD *a1, _QWORD *a2, _BYTE *a3)
{
  const char *v6;
  uint64_t result;

  v6 = (const char *)a2[5];
  result = _platform_strcmp(v6, "__TEXT");
  if ((_DWORD)result)
  {
    result = _platform_strcmp(v6, "__LINKEDIT");
    if (!(_DWORD)result)
    {
      *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = a2[2];
      *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = *a2;
      *a3 = 1;
    }
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = a2[2];
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer12withVMLayoutER11DiagnosticsU13block_pointerFvRKN6mach_o6LayoutEE_block_invoke(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  const char *v10;
  uint64_t result;
  int v12;
  uint64_t v13;

  v4 = a2[2];
  v5 = a2[3];
  v6 = *a2;
  v7 = a2[1];
  v8 = a1[6] + v4;
  v9 = *((_DWORD *)a2 + 13);
  v10 = (const char *)a2[5];
  result = _platform_strcmp(v10, "__TEXT");
  if ((_DWORD)result)
  {
    result = _platform_strcmp(v10, "__LINKEDIT");
    if ((_DWORD)result)
    {
      v12 = 0;
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v6;
      *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = v8;
      v12 = 2;
    }
  }
  else
  {
    v12 = 1;
  }
  v13 = a1[7] + 48 * ((unsigned __int16)*((_DWORD *)a2 + 14) >> 4);
  *(_QWORD *)v13 = v4;
  *(_QWORD *)(v13 + 8) = v5;
  *(_QWORD *)(v13 + 16) = v6;
  *(_QWORD *)(v13 + 24) = v7;
  *(_QWORD *)(v13 + 32) = v8;
  *(_DWORD *)(v13 + 40) = v9;
  *(_DWORD *)(v13 + 44) = v12;
  return result;
}

uint64_t ___ZN5dyld4L12hasDataConstEPKN5dyld39MachOFileE_block_invoke(uint64_t result, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 56) & 2) != 0)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  return result;
}

uint64_t ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  v3 = result;
  if (*(_BYTE *)(result + 48) || (result = _platform_strcmp(*(const char **)(a2 + 40), "__DATA_DIRTY"), (_DWORD)result))
  {
    v4 = *(_QWORD **)(*(_QWORD *)(v3 + 32) + 8);
    v5 = v4[7];
    if (v5 >= v4[6])
      ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
    v6 = *(_QWORD *)(a2 + 24);
    v7 = *(_QWORD *)(v3 + 40) + *(_QWORD *)(a2 + 16);
    v8 = v4[5];
    v4[7] = v5 + 1;
    v9 = (_QWORD *)(v8 + 16 * v5);
    *v9 = v7;
    v9[1] = v6;
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile21analyzeSegmentsLayoutERyRb_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  result = _platform_strcmp(*(const char **)(a2 + 40), "__PAGEZERO");
  if ((_DWORD)result)
  {
    if ((*(_BYTE *)(a2 + 52) & 2) != 0)
    {
      v5 = *(_QWORD *)(a2 + 8);
      v6 = *(_QWORD *)(a2 + 24);
      if (v5 != v6)
      {
        *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
        v5 = v6;
      }
    }
    else
    {
      v5 = *(_QWORD *)(a2 + 24);
    }
    if (!v5)
      *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
    v7 = *(_QWORD *)(a2 + 16);
    v8 = *(_QWORD *)(a1[5] + 8);
    if (v7 < *(_QWORD *)(v8 + 24))
    {
      *(_QWORD *)(v8 + 24) = v7;
      v7 = *(_QWORD *)(a2 + 16);
      v5 = *(_QWORD *)(a2 + 24);
    }
    v9 = v5 + v7;
    v10 = *(_QWORD *)(a1[6] + 8);
    if (v9 > *(_QWORD *)(v10 + 24))
    {
      *(_QWORD *)(v10 + 24) = v9;
      v5 = *(_QWORD *)(a2 + 24);
    }
    *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) += v5;
  }
  return result;
}

uint64_t dyld4::SyscallDelegate::mprotect(dyld4::SyscallDelegate *this, void *a2, size_t a3, int a4)
{
  return mprotect(a2, a3, a4);
}

uint64_t ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(result + 40) + 8 * a2;
  *(_QWORD *)(v3 + 8) = *(_QWORD *)(a3 + 64) - *(_QWORD *)(result + 32);
  *(_QWORD *)(v3 + 176) = *(_QWORD *)(a3 + 72);
  return result;
}

_QWORD *metadata_visitor::ResolvedValue::ResolvedValue(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *result = a2;
  result[1] = a3;
  result[2] = a4;
  return result;
}

_QWORD *dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::verifySpace(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  const void **v4;
  vm_address_t v5;
  vm_size_t v6;
  unint64_t v7;
  vm_size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;

  v2 = result[1];
  v3 = result[2] + a2;
  if (v3 > v2)
  {
    v4 = (const void **)result;
    v5 = result[3];
    v6 = result[4];
    v7 = 2 * v2;
    if (v7 > v3)
      v3 = v7;
    v8 = (vm_page_size + 48 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    result = memmove((void *)v4[3], *v4, 48 * (_QWORD)v4[2]);
    v12 = (unint64_t)v4[4] / 0x30;
    *v4 = v4[3];
    v4[1] = (const void *)v12;
    if (v5)
      return (_QWORD *)vm_deallocate(mach_task_self_, v5, v6);
  }
  return result;
}

ssize_t ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke_2(ssize_t result, const char *a2, uint64_t a3, vm_size_t size, uint64_t a5, uint64_t a6, char a7)
{
  ssize_t v8;
  vm_address_t v9;
  const char *v10;

  if ((a7 & 0x40) == 0 && (a7 & 4) != 0)
  {
    v8 = result;
    v9 = *(_QWORD *)(*(_QWORD *)(result + 32) + 24) + a3;
    if (*(_BYTE *)(*(_QWORD *)(result + 40) + 1))
      dyld4::console((dyld4 *)"marking shared cache range 0x%x permissions: 0x%09lX -> 0x%09lX\n", a2, *(unsigned int *)(result + 56), *(_QWORD *)(*(_QWORD *)(result + 32) + 24) + a3, v9 + size);
    result = dyld4::SyscallDelegate::vm_protect(*(dyld4::SyscallDelegate **)(v8 + 48), mach_task_self_, v9, size, 0, *(_DWORD *)(v8 + 56));
    if ((_DWORD)result)
    {
      if (*(_BYTE *)(*(_QWORD *)(v8 + 40) + 1))
        return dyld4::console((dyld4 *)"failed to mprotect shared cache due to: %d\n", v10, result);
    }
  }
  return result;
}

uint64_t ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD v3[4];
  __int128 v4;
  uint64_t v5;
  int v6;

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke_2;
  v3[3] = &__block_descriptor_tmp_65;
  v4 = *(_OWORD *)(a1 + 32);
  v6 = *(_DWORD *)(a1 + 56);
  v5 = *(_QWORD *)(a1 + 48);
  return DyldSharedCache::forEachRegion(a2, (uint64_t)v3);
}

uint64_t ___ZNK5dyld39MachOFile13enforceFormatENS0_9MalformedE_block_invoke(uint64_t result, int a2, uint64_t a3, unsigned int a4)
{
  char v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  int v9;

  switch(a2)
  {
    case 1:
      switch(*(_DWORD *)(result + 40))
      {
        case 0:
        case 1:
        case 3:
          if (a4 >> 9 >= 0x507)
            goto LABEL_23;
          break;
        case 2:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
          v6 = 659199;
          goto LABEL_22;
        case 9:
          v6 = 659455;
          goto LABEL_22;
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xE:
        case 0xF:
          goto LABEL_15;
        case 0xD:
        case 0x10:
          goto LABEL_20;
        default:
          return result;
      }
      break;
    case 2:
    case 3:
    case 6:
      switch(*(_DWORD *)(result + 40))
      {
        case 0:
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_23;
        case 1:
        case 2:
        case 4:
        case 8:
LABEL_15:
          if (a4 >= 0xD0000)
            goto LABEL_23;
          break;
        case 9:
LABEL_20:
          v9 = 851967;
          goto LABEL_21;
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xE:
        case 0xF:
          if (a4 >= 0x100000)
            goto LABEL_23;
          break;
        case 0xD:
        case 0x10:
          v6 = 1114111;
          goto LABEL_22;
        default:
          return result;
      }
      break;
    case 4:
      v7 = *(_DWORD *)(result + 40);
      if (v7 <= 0x10)
      {
        v8 = 1 << v7;
        if ((v8 & 0xDF16) != 0)
        {
          if (a4 >= 0x90000)
            goto LABEL_23;
        }
        else
        {
          if ((v8 & 0xE9) != 0)
            goto LABEL_23;
          v9 = 589823;
LABEL_21:
          v6 = v9 | 0x10000;
LABEL_22:
          if (a4 > v6)
            goto LABEL_23;
        }
      }
      break;
    case 11:
    case 12:
      v5 = *(_QWORD *)(result + 32);
      result += 32;
      *(_BYTE *)(*(_QWORD *)(v5 + 8) + 24) = 1;
      if (!(a4 >> 17) && *(_DWORD *)(result + 8) == 16)
      {
        v4 = 0;
        goto LABEL_24;
      }
      break;
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
      v4 = 0;
      result += 32;
      goto LABEL_24;
    default:
LABEL_23:
      result += 32;
      v4 = 1;
LABEL_24:
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)result + 8) + 24) = v4;
      break;
  }
  return result;
}

uint64_t ___ZN5dyld44APIs15forEachPlatformEPKN5dyld39MachOFileEU13block_pointerFvjjjE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v5;
  _DWORD *v6;
  unsigned int v7;

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  if (!a4)
  {
    v5 = dyld4::APIs::linkedDylibVersion((dyld4::APIs *)a1, *(const dyld3::MachOFile **)(a1 + 56), "/System/Library/Frameworks/Foundation.framework/Foundation");
    if (v5 >= 0x2A61800)
    {
      v6 = &unk_1A5CBBF24;
      do
      {
        v7 = v6[3];
        if (!v7)
          break;
        v6 += 2;
      }
      while (v5 >= v7);
    }
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZNK5dyld39MachOFile12forEachRPathEU13block_pointerFvPKcRbE_block_invoke(uint64_t result, _DWORD *a2)
{
  if (*a2 == -2147483620)
    return (*(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16))();
  return result;
}

uint64_t ___ZN5dyld413ProcessConfig7Process15getMainPlatformEv_block_invoke(uint64_t result, int a2, int a3, int a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(result + 40);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
  *(_DWORD *)(v4 + 40) = a4;
  *(_DWORD *)(v4 + 48) = a3;
  return result;
}

uint64_t dyld4::SyscallDelegate::disablePageInLinking(dyld4::SyscallDelegate *this)
{
  return __shared_region_check_np((uint64_t *)0xFFFFFFFFFFFFFFFFLL);
}

uint64_t dyld4::ExternallyViewableState::setLibSystemInitialized(dyld4::ExternallyViewableState *this)
{
  uint64_t result;

  result = *(_QWORD *)this;
  if (result)
    result = dyld4::Atlas::ProcessSnapshot::setDyldState(result, 48);
  *(_BYTE *)(*((_QWORD *)this + 3) + 25) = 1;
  return result;
}

uint64_t ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
  if (!*(_QWORD *)(v3 + 24))
    *(_QWORD *)(v3 + 24) = a3;
  return result;
}

uint64_t dyld4::SyscallDelegate::vm_protect(dyld4::SyscallDelegate *this, vm_map_t target_task, vm_address_t address, vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  return vm_protect(target_task, address, size, set_maximum, new_protection);
}

size_t dyld4::Utils::concatenatePaths(dyld4::Utils *this, char *a2, const char *a3)
{
  const char *v6;
  char *v7;

  if (*((_BYTE *)this + _platform_strlen((const char *)this) - 1) == 47 && *a2 == 47)
  {
    v6 = a2 + 1;
    v7 = (char *)this;
  }
  else
  {
    v7 = (char *)this;
    v6 = a2;
  }
  return strlcat(v7, v6, (size_t)a3);
}

uint64_t dyld4::APIs::_dyld_is_objc_constant(dyld4::RuntimeState *a1, int a2, const void *a3)
{
  if (*(_BYTE *)(*((_QWORD *)a1 + 1) + 204))
    dyld4::RuntimeState::log(a1, "_dyld_is_objc_constant(%d, %p)\n", a2, a3);
  return 0;
}

uint64_t dyld4::APIs::_dyld_find_protocol_conformance(dyld4::APIs *this, char *a2, char *a3, char *a4)
{
  uint64_t v8;
  dyld4::objc_headeropt_rw_t *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int Potential;
  unsigned int v15;
  unint64_t v16;
  char isLoaded;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v22;
  unint64_t v23;
  char v24;
  uint64_t i;
  char v26;
  uint64_t j;
  char v28;
  char *v29;
  char *v30;

  v8 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v8 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_find_protocol_conformance(%p, %p, %p)\n", a2, a3, a4);
    v8 = *((_QWORD *)this + 1);
  }
  v9 = *(dyld4::objc_headeropt_rw_t **)(v8 + 296);
  v10 = *(_QWORD *)(v8 + 344);
  if (v9)
    v11 = v10 == 0;
  else
    v11 = 1;
  if (v11)
    return 2;
  if (!a4)
    goto LABEL_12;
  v12 = *(_QWORD *)(v10 + 8);
  if (!v12)
    goto LABEL_12;
  v13 = *(_QWORD *)(v8 + 240);
  v29 = &a4[-v13];
  v30 = &a2[-v13];
  Potential = SwiftHashTable::getPotentialTarget<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>((unsigned int *)(v13 + v12), (objc *)&v29);
  if (Potential == *(_DWORD *)(v13 + v12 + 16))
    goto LABEL_12;
  v15 = Potential;
  v16 = *(_QWORD *)(v13 + v12 + Potential + 16);
  isLoaded = dyld4::objc_headeropt_rw_t::isLoaded(v9, HIWORD(v16));
  if ((v16 & 1) != 0)
  {
    if ((isLoaded & 1) == 0)
    {
      for (i = v12 + v15 + v13 + 40; (*(_BYTE *)(i - 24) & 1) != 0; i += 24)
      {
        v26 = dyld4::objc_headeropt_rw_t::isLoaded(v9, *(unsigned __int16 *)(i + 6));
        if ((v26 & 1) != 0)
          return 0;
      }
      goto LABEL_12;
    }
    return 0;
  }
  if ((isLoaded & 1) != 0)
    return 0;
LABEL_12:
  if (!a3)
    return 2;
  v18 = *(_QWORD *)(v10 + 16);
  if (!v18)
    return 2;
  v19 = *(_QWORD *)(*((_QWORD *)this + 1) + 240);
  v29 = &a3[-v19];
  v30 = &a2[-v19];
  v20 = SwiftHashTable::getPotentialTarget<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>((unsigned int *)(v19 + v18), (objc *)&v29);
  if (v20 == *(_DWORD *)(v19 + v18 + 16))
    return 2;
  v22 = v20;
  v23 = *(_QWORD *)(v19 + v18 + v20 + 16);
  v24 = dyld4::objc_headeropt_rw_t::isLoaded(v9, HIWORD(v23));
  if ((v23 & 1) != 0)
  {
    if ((v24 & 1) == 0)
    {
      for (j = v18 + v22 + v19 + 40; (*(_BYTE *)(j - 24) & 1) != 0; j += 24)
      {
        v28 = dyld4::objc_headeropt_rw_t::isLoaded(v9, *(unsigned __int16 *)(j + 6));
        if ((v28 & 1) != 0)
          return 0;
      }
      return 2;
    }
  }
  else if ((v24 & 1) == 0)
  {
    return 2;
  }
  return 0;
}

uint64_t SwiftHashTable::getPotentialTarget<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>(unsigned int *a1, objc *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;

  v3 = SwiftHashTable::getIndex<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>(a1, a2);
  if ((_DWORD)v3 == -1)
  {
    v7 = a1 + 4;
  }
  else
  {
    v6 = *a1;
    if (v6 <= v3)
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v3, v4, v5);
    v7 = (unsigned int *)((char *)&a1[v3 + 264] + a1[5] + v6);
  }
  return *v7;
}

uint64_t SwiftHashTable::getIndex<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>(unsigned int *a1, objc *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = SwiftHashTable::hash<SwiftTypeProtocolConformanceLocationKey>((uint64_t)a1, a2);
  if (*a1 <= v4)
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v4, v5, v6);
  v7 = v4;
  v8 = *((unsigned __int8 *)a1 + v4 + a1[5] + 1056);
  v9 = SwiftHashTable::checkbyte<SwiftTypeProtocolConformanceLocationKey>((uint64_t)a1, (unsigned __int8 *)a2);
  if (v8 != (_DWORD)v9)
    return 0xFFFFFFFFLL;
  v12 = *a1;
  if (v12 <= v7)
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v9, v10, v11);
  v13 = *(unsigned int *)((char *)&a1[v7 + 264] + a1[5] + v12);
  if ((_DWORD)v13 == -1)
    return 0xFFFFFFFFLL;
  if (SwiftHashTable::equal<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>((uint64_t)a1, (unsigned int *)((char *)a1 + v13), a2))
  {
    return v7;
  }
  return 0xFFFFFFFFLL;
}

uint64_t SwiftHashTable::checkbyte<SwiftTypeProtocolConformanceLocationKey>(uint64_t a1, unsigned __int8 *a2)
{
  return (32 * *a2) & 0xE0 | 0x10u;
}

uint64_t SwiftHashTable::hash<SwiftTypeProtocolConformanceLocationKey>(uint64_t a1, objc *this)
{
  unint64_t v4;
  unint64_t v5;
  int v6;
  unsigned int v7;

  v4 = objc::lookup8(this, (const unsigned __int8 *)8, *(_QWORD *)(a1 + 24));
  v5 = objc::lookup8((objc *)((char *)this + 8), (const unsigned __int8 *)8, *(_QWORD *)(a1 + 24));
  v6 = *(_DWORD *)(a1 + 8);
  if (v6 == 64)
    v7 = 0;
  else
    v7 = (v5 ^ v4) >> v6;
  return v7 ^ *(_DWORD *)(a1 + 4 * *(unsigned __int8 *)(a1 + ((v5 ^ v4) & *(unsigned int *)(a1 + 12)) + 1056) + 32);
}

uint64_t dyld4::objc_headeropt_rw_t::isLoaded(dyld4::objc_headeropt_rw_t *this, unsigned int a2)
{
  if (*(_DWORD *)this <= a2)
    dyld4::objc_headeropt_rw_t::isLoaded();
  return *(_DWORD *)((_BYTE *)this + *((_DWORD *)this + 1) * a2 + 8) & 1;
}

BOOL SwiftHashTable::equal<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

const char *dyld4::APIs::_dyld_get_objc_selector(dyld4::APIs *this, char *__s)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t Index;
  const char *Selector;

  v4 = *((_QWORD *)this + 1);
  v5 = *(_QWORD *)(v4 + 304);
  if (v5)
  {
    Index = objc::StringHashTable::tryGetIndex(*(objc::StringHashTable **)(v4 + 304), __s);
    if ((Index & 0xFF00000000) != 0)
    {
      Selector = (const char *)(v5
                              + *(int *)(v5
                                       + *(unsigned int *)(v5 + 4)
                                       + (*(_DWORD *)(v5 + 16) + 1)
                                       + 4 * Index
                                       + 1056));
      goto LABEL_6;
    }
  }
  if (*((_QWORD *)this + 127))
  {
    Selector = (const char *)prebuilt_objc::findSelector(this, (_QWORD *)this + 47, __s);
LABEL_6:
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
      dyld4::RuntimeState::log(this, "_dyld_get_objc_selector(%s) => %s\n", __s, Selector);
    return Selector;
  }
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_get_objc_selector(%s) => nullptr\n", __s);
  return 0;
}

uint64_t ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  dyld4::RuntimeState *v5;
  dyld4::PrebuiltLoader::BindTargetRef **v6;
  uint64_t v7;
  dyld4::PrebuiltLoader::BindTargetRef *v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;

  v3 = *(_QWORD *)(a2 + 16);
  if (v3)
  {
    v4 = result;
    v5 = *(dyld4::RuntimeState **)(result + 48);
    v6 = *(dyld4::PrebuiltLoader::BindTargetRef ***)a2;
    v7 = 8 * v3 - 8;
    do
    {
      v8 = *v6++;
      v9 = *(_QWORD *)(v4 + 32);
      v10 = dyld4::PrebuiltLoader::BindTargetRef::value(v8, v5, a3);
      result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(v9 + 16))(v9, v10, 1, *(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24);
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24))
        v11 = 1;
      else
        v11 = v7 == 0;
      v7 -= 8;
    }
    while (!v11);
  }
  return result;
}

void dyld4::APIs::_dyld_for_each_objc_protocol(dyld4::RuntimeState *a1, char *a2, uint64_t a3)
{
  int v6;
  unsigned int *v7;
  _QWORD v8[6];
  _QWORD v9[7];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;

  if (*(_BYTE *)(*((_QWORD *)a1 + 1) + 204))
    dyld4::RuntimeState::log(a1, "_dyld_get_objc_protocol(%s)\n", a2);
  if (!*((_QWORD *)a1 + 127))
    goto LABEL_5;
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke;
  v9[3] = &unk_1E4F7DCE8;
  v9[5] = &v10;
  v9[6] = a1;
  v9[4] = a3;
  prebuilt_objc::forEachProtocol(a1, (_QWORD *)a1 + 59, a2, (uint64_t)v9);
  v6 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  if (!v6)
  {
LABEL_5:
    v7 = *(unsigned int **)(*((_QWORD *)a1 + 1) + 320);
    if (v7)
    {
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000;
      v8[2] = ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke_2;
      v8[3] = &unk_1E4F7DD10;
      v8[4] = a3;
      v8[5] = a1;
      objc::ObjectHashTable::forEachObject(v7, a2, (uint64_t)v8);
    }
  }
}

void dyld4::APIs::_dyld_for_each_objc_class(dyld4::RuntimeState *a1, char *a2, uint64_t a3)
{
  int v6;
  unsigned int *v7;
  _QWORD v8[6];
  _QWORD v9[7];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;

  if (*(_BYTE *)(*((_QWORD *)a1 + 1) + 204))
    dyld4::RuntimeState::log(a1, "_dyld_get_objc_class(%s)\n", a2);
  if (!*((_QWORD *)a1 + 127))
    goto LABEL_5;
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke;
  v9[3] = &unk_1E4F7DC98;
  v9[5] = &v10;
  v9[6] = a1;
  v9[4] = a3;
  prebuilt_objc::forEachClass(a1, (_QWORD *)a1 + 53, a2, (uint64_t)v9);
  v6 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  if (!v6)
  {
LABEL_5:
    v7 = *(unsigned int **)(*((_QWORD *)a1 + 1) + 312);
    if (v7)
    {
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000;
      v8[2] = ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke_2;
      v8[3] = &unk_1E4F7DCC0;
      v8[4] = a3;
      v8[5] = a1;
      objc::ObjectHashTable::forEachObject(v7, a2, (uint64_t)v8);
    }
  }
}

uint64_t objc::ObjectHashTable::forEachObject(unsigned int *a1, char *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  char v15;
  char v16;

  result = objc::StringHashTable::tryGetIndex((objc::StringHashTable *)a1, a2);
  if ((result & 0xFF00000000) != 0)
  {
    v6 = a1[1];
    v7 = (uint64_t)&a1[v6 + 264] + v6 + a1[4] + 1;
    v8 = *(_QWORD *)(v7 + 8 * result);
    v9 = (v8 >> 1) & 0x7FFFFFFFFFFFLL;
    if ((v8 & 1) != 0)
    {
      v10 = HIWORD(v8);
      if (v10)
      {
        v11 = (unint64_t *)(v7 + 8 * v6 + 8 * v9 + 4);
        v12 = v10 - 1;
        do
        {
          v15 = 0;
          v13 = *v11++;
          result = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t, char *))(a3 + 16))(a3, (v13 >> 1) & 0x7FFFFFFFFFFFLL, HIWORD(v13), &v15);
          if (v15)
            v14 = 1;
          else
            v14 = v12 == 0;
          --v12;
        }
        while (!v14);
      }
    }
    else
    {
      v16 = 0;
      return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, char *))(a3 + 16))(a3, v9, HIWORD(v8), &v16);
    }
  }
  return result;
}

uint64_t ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  dyld4::RuntimeState *v5;
  dyld4::PrebuiltLoader::BindTargetRef **v6;
  uint64_t v7;
  dyld4::PrebuiltLoader::BindTargetRef *v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;

  v3 = *(_QWORD *)(a2 + 16);
  if (v3)
  {
    v4 = result;
    v5 = *(dyld4::RuntimeState **)(result + 48);
    v6 = *(dyld4::PrebuiltLoader::BindTargetRef ***)a2;
    v7 = 8 * v3 - 8;
    do
    {
      v8 = *v6++;
      v9 = *(_QWORD *)(v4 + 32);
      v10 = dyld4::PrebuiltLoader::BindTargetRef::value(v8, v5, a3);
      result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(v9 + 16))(v9, v10, 1, *(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24);
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24))
        v11 = 1;
      else
        v11 = v7 == 0;
      v7 -= 8;
    }
    while (!v11);
  }
  return result;
}

uint64_t objc::objc_headeropt_rw_t<unsigned long>::isLoaded(unsigned int *a1, unsigned int a2)
{
  if (*a1 <= a2)
    objc::objc_headeropt_rw_t<unsigned long>::isLoaded();
  return *(unsigned int *)((char *)a1 + a1[1] * a2 + 8) & 1;
}

uint64_t dyld4::APIs::_dyld_find_protocol_conformance_on_disk(dyld4::PrebuiltLoaderSet **this, dyld4::PrebuiltLoader::BindTargetRef *a2, dyld4::PrebuiltLoader::BindTargetRef *a3, dyld4::PrebuiltLoader::BindTargetRef *a4)
{
  dyld4::PrebuiltLoaderSet *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  dyld4::PrebuiltLoader::BindTargetRef *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t i;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t Absolute;
  unint64_t v31;

  if (*((_BYTE *)this[1] + 204))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_find_protocol_conformance_on_disk(%p, %p, %p)\n", a2, a3, a4);
  v8 = this[127];
  if (!v8 || !dyld4::PrebuiltLoaderSet::hasOptimizedSwift(this[127]))
    return 2;
  v9 = dyld4::PrebuiltLoaderSet::swiftTypeProtocolTable(v8);
  if (a4)
  {
    if (v9)
    {
      if (this[65])
      {
        Absolute = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a4);
        v31 = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a2);
        v10 = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::find(this[65], (uint64_t)&Absolute);
        if (v10 != *((_QWORD *)this[65] + 7) + 32 * *((_QWORD *)this[65] + 9))
        {
          v11 = v10;
          if (dyld4::EqualTypeConformanceLookupKey::equal(v10, (uint64_t)a4, (uint64_t)a2, (dyld4::RuntimeState *)this))
          {
LABEL_12:
            v15 = (dyld4::PrebuiltLoader::BindTargetRef *)(v11 + 16);
            v16 = dyld4::PrebuiltLoader::BindTargetRef::loaderRef((dyld4::PrebuiltLoader::BindTargetRef *)(v11 + 16), v12, v13);
            v19 = v16 & 0x7FFF;
            if (*((_DWORD *)v8 + 3) <= v19)
              dyld4::RuntimeState::findPrebuiltLoader(v16, v17, v18);
            goto LABEL_22;
          }
          while (1)
          {
            v14 = *(_QWORD *)(v11 + 24);
            if ((v14 & 3) == 0)
              break;
            v11 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((_QWORD *)this[65] + 7, v14 >> 3);
            if (dyld4::EqualTypeConformanceLookupKey::equal(v11, (uint64_t)a4, (uint64_t)a2, (dyld4::RuntimeState *)this))
              goto LABEL_12;
          }
        }
      }
    }
  }
  v20 = dyld4::PrebuiltLoaderSet::swiftMetadataProtocolTable(v8);
  result = 2;
  if (a3 && v20)
  {
    if (this[66])
    {
      Absolute = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a3);
      v31 = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a2);
      v22 = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::find(this[66], (uint64_t)&Absolute);
      if (v22 != *((_QWORD *)this[66] + 7) + 32 * *((_QWORD *)this[66] + 9))
      {
        for (i = v22;
              !dyld4::EqualMetadataConformanceLookupKey::equal(i, (uint64_t)a3, (uint64_t)a2, (dyld4::RuntimeState *)this);
              i = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((_QWORD *)this[66] + 7, v26 >> 3))
        {
          v26 = *(_QWORD *)(i + 24);
          if ((v26 & 3) == 0)
            return 2;
        }
        v15 = (dyld4::PrebuiltLoader::BindTargetRef *)(i + 16);
        v27 = dyld4::PrebuiltLoader::BindTargetRef::loaderRef((dyld4::PrebuiltLoader::BindTargetRef *)(i + 16), v24, v25);
        v19 = v27 & 0x7FFF;
        if (*((_DWORD *)v8 + 3) <= v19)
          dyld4::RuntimeState::findPrebuiltLoader(v27, v28, v29);
LABEL_22:
        dyld4::PrebuiltLoader::loadAddress((dyld4::PrebuiltLoaderSet *)((char *)v8 + *(unsigned int *)((char *)v8 + 4 * v19 + *((unsigned int *)v8 + 4))), (const dyld4::RuntimeState *)this);
        dyld4::PrebuiltLoader::BindTargetRef::offset(v15);
        return 0;
      }
    }
    return 2;
  }
  return result;
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(dyld4::PrebuiltLoader::BindTargetRef *this)
{
  unint64_t v2;

  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(&v2, (uint64_t)this);
  return v2;
}

BOOL dyld4::PrebuiltLoaderSet::hasOptimizedSwift(dyld4::PrebuiltLoaderSet *this)
{
  return *((_DWORD *)this + 16) || *((_DWORD *)this + 17) || *((_DWORD *)this + 18) != 0;
}

uint64_t dyld4::PrebuiltLoaderSet::swiftTypeProtocolTable(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1;

  v1 = *((unsigned int *)this + 16);
  if ((_DWORD)v1)
    return (uint64_t)this + v1;
  else
    return 0;
}

uint64_t dyld4::PrebuiltLoaderSet::swiftMetadataProtocolTable(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1;

  v1 = *((unsigned int *)this + 17);
  if ((_DWORD)v1)
    return (uint64_t)this + v1;
  else
    return 0;
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::find(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t i;
  uint64_t v7;

  v4 = (a1[4] - 1) & dyld4::HashTypeConformanceKey::hash(a2);
  v5 = *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](a1 + 2, v4);
  if (v5 == -1)
    return a1[7] + 32 * a1[9];
  for (i = 1; ; ++i)
  {
    v7 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](a1 + 7, v5);
    if (dyld4::EqualTypeConformanceKey::equal(v7, a2))
      break;
    v4 = (a1[4] - 1) & (v4 + i);
    v5 = *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](a1 + 2, v4);
    if (v5 == -1)
      return a1[7] + 32 * a1[9];
  }
  return dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](a1 + 7, v5);
}

unint64_t dyld4::HashTypeConformanceKey::hash(uint64_t a1)
{
  unint64_t v2;
  unint64_t v4;
  unint64_t v5;

  v5 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)a1) & 0xFFF;
  v4 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8)) & 0xFFF;
  v2 = murmurHash((uint64_t *)&v5, 8, 0);
  return murmurHash((uint64_t *)&v4, 8, 0) ^ v2;
}

unint64_t murmurHash(uint64_t *a1, int a2, uint64_t a3)
{
  unint64_t v3;
  int v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;

  v3 = (0xC6A4A7935BD1E995 * a2) ^ a3;
  if (a2 >= 0)
    v4 = a2;
  else
    v4 = a2 + 7;
  if ((a2 + 7) >= 0xF)
  {
    v5 = 8 * ((uint64_t)v4 >> 3);
    v6 = (char *)&a1[v4 >> 3];
    do
    {
      v7 = *a1++;
      v3 = 0xC6A4A7935BD1E995
         * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v7) ^ ((0xC6A4A7935BD1E995 * v7) >> 47))) ^ v3);
      v5 -= 8;
    }
    while (v5);
    a1 = (uint64_t *)v6;
  }
  switch(a2 & 7)
  {
    case 1:
      goto LABEL_15;
    case 2:
      goto LABEL_14;
    case 3:
      goto LABEL_13;
    case 4:
      goto LABEL_12;
    case 5:
      goto LABEL_11;
    case 6:
      goto LABEL_10;
    case 7:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 6) << 48;
LABEL_10:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 5) << 40;
LABEL_11:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 4) << 32;
LABEL_12:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 3) << 24;
LABEL_13:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 2) << 16;
LABEL_14:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 1) << 8;
LABEL_15:
      v3 ^= *(unsigned __int8 *)a1;
      break;
    default:
      break;
  }
  v8 = 0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v3) ^ ((0xC6A4A7935BD1E995 * v3) >> 47));
  return v8 ^ (v8 >> 47);
}

BOOL dyld4::EqualTypeConformanceKey::equal(uint64_t a1, uint64_t a2)
{
  unsigned __int16 v4;
  int v6;

  v4 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)a1);
  if ((((unsigned __int16)dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)a2) ^ v4) & 0xFFF) != 0)
    return 0;
  v6 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8));
  return ((dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a2 + 8)) ^ v6) & 0xFFFLL) == 0;
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::offset(dyld4::PrebuiltLoader::BindTargetRef *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)this >> 16;
  if ((*(_QWORD *)this & 0x4000000000000000) != 0)
    v2 = (*(_QWORD *)this >> 24) | 0xFFFF8000000000;
  else
    v2 = (*(_QWORD *)this >> 24) & 0x7FFFFFFFFFLL;
  return v2 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)v1 << 56);
}

BOOL dyld4::EqualTypeConformanceLookupKey::equal(uint64_t a1, uint64_t a2, uint64_t a3, dyld4::RuntimeState *a4)
{
  uint64_t v7;

  if (!a4)
    dyld4::EqualTypeConformanceLookupKey::equal();
  return dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)a1, a4, a3) == a2
      && dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8), a4, v7) == a3;
}

uint64_t dyld4::PrebuiltLoader::BindTargetRef::loaderRef(dyld4::PrebuiltLoader::BindTargetRef *this, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = *(_QWORD *)this;
  if (result < 0)
    dyld4::PrebuiltLoader::BindTargetRef::loaderRef(result, a2, a3);
  return result;
}

void ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke(uint64_t a1, char *a2, unsigned int a3, _BYTE *a4)
{
  dyld4::RuntimeState *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  dyld4::Loader **v13;
  uint64_t v14;
  dyld4::Loader *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  dyld4::Loader **v21;
  uint64_t v22;
  dyld4::Loader *v23;
  dyld4::RuntimeState *v24;
  uint64_t v25;
  dyld4::PseudoDylib **v26;
  dyld4::PseudoDylib **v27;
  const char *v28;
  char *v29;
  dyld4::RuntimeState *v30;
  _BOOL4 v31;
  vm_address_t *v32;
  const char *v33;
  dyld4::RuntimeState *v34;
  const char *v35;
  BOOL v36;
  dyld4::RuntimeState *v37;
  const dyld4::RuntimeState *v38;
  int v39;
  _BOOL4 v40;
  vm_address_t *v41;
  int v42;
  unsigned __int8 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  dyld4::Loader **v48;
  uint64_t v49;
  dyld4::Loader *v50;
  BOOL v51;
  dyld4::RuntimeState *v52;
  char *v53;
  vm_address_t **v54;
  dyld4::RuntimeState *v55;
  dyld4::RuntimeState *v56;
  uint64_t v57;
  _BOOL4 v58;
  vm_address_t *v59;
  const char *v60;
  int v61;
  dyld4::RuntimeState *v62;
  dyld4::RuntimeState *v63;
  void *v64;
  _BOOL4 v65;
  vm_address_t *v66;
  const char *v67;
  dyld4::RuntimeState *v68;
  vm_address_t *v69;
  dyld4::RuntimeState *v70;
  dyld4::RuntimeState *v71;
  int8x16_t v72;
  uint64_t v73;
  char v74;
  int v75;
  unsigned __int16 v76[2];
  _QWORD v77[2];
  __int128 v78;
  __int128 v79;

  if (*(_BYTE *)(a1 + 80) && *(_BYTE *)(a1 + 81) && !*(_BYTE *)(a1 + 82) && *(char **)(a1 + 48) != a2)
    return;
  v8 = *(dyld4::RuntimeState **)(a1 + 56);
  if (*(_BYTE *)(*((_QWORD *)v8 + 1) + 208))
  {
    v9 = dyld4::ProcessConfig::PathOverrides::typeName(a3);
    dyld4::RuntimeState::log(v8, "  possible path(%s): \"%s\"\n", v9, a2);
    v8 = *(dyld4::RuntimeState **)(a1 + 56);
  }
  v10 = 0;
  *(_QWORD *)&v78 = (char *)v8 + 32;
  *((_QWORD *)&v78 + 1) = (char *)v8 + 64;
  while (1)
  {
    v11 = *((_QWORD *)&v78 + v10);
    if (!*(_BYTE *)(*(_QWORD *)(a1 + 64) + 5) || v11 != *(_QWORD *)(a1 + 56) + 64)
    {
      v12 = *(_QWORD *)(v11 + 16);
      if (v12)
        break;
    }
LABEL_13:
    if (++v10 == 2)
    {
      v16 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
      if (!*(_BYTE *)(v16 + 186))
      {
        v39 = *a2;
        if (v39 != 47 && v39 != 64)
        {
          v40 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
          v41 = *(vm_address_t **)(a1 + 72);
          if (v40)
            Diagnostics::error(v41, "tried: '%s' (relative path not allowed in hardened program)", a2);
          else
            Diagnostics::appendError(v41, ", '%s' (relative path not allowed in hardened program)");
          return;
        }
      }
      *(_DWORD *)v76 = 0;
      if (dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(v16 + 240), a2, (unsigned int *)v76))
      {
        v17 = 0;
        v18 = *(_QWORD *)(a1 + 56);
        *(_QWORD *)&v78 = v18 + 32;
        *((_QWORD *)&v78 + 1) = v18 + 64;
        while (1)
        {
          v19 = *((_QWORD *)&v78 + v17);
          if (!*(_BYTE *)(*(_QWORD *)(a1 + 64) + 5) || v19 != *(_QWORD *)(a1 + 56) + 64)
          {
            v20 = *(_QWORD *)(v19 + 16);
            if (v20)
              break;
          }
LABEL_23:
          if (++v17 == 2)
            goto LABEL_24;
        }
        v21 = *(dyld4::Loader ***)(v19 + 8);
        v22 = 8 * v20;
        while (1)
        {
          v23 = *v21;
          if (dyld4::Loader::representsCachedDylibIndex(*v21, v76[0]))
            break;
          ++v21;
          v22 -= 8;
          if (!v22)
            goto LABEL_23;
        }
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v23;
        *a4 = 1;
        Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
        v38 = *(const dyld4::RuntimeState **)(a1 + 56);
        if (*(_BYTE *)(*((_QWORD *)v38 + 1) + 208))
        {
          dyld4::Loader::path(v23, v38);
          dyld4::RuntimeState::log(v38, "  found: already-loaded-by-dylib-index: \"%s\" -> %s\n");
        }
        return;
      }
LABEL_24:
      if (*(_BYTE *)(*(_QWORD *)(a1 + 64) + 5))
        return;
      v24 = *(dyld4::RuntimeState **)(a1 + 56);
      v25 = *((_QWORD *)v24 + 79);
      if (v25)
      {
        if (!*(_BYTE *)(*((_QWORD *)v24 + 1) + 208)
          || (dyld4::RuntimeState::log(v24, "searching %llu pseudo-dylibs:\n", *((_QWORD *)v24 + 79)),
              v24 = *(dyld4::RuntimeState **)(a1 + 56),
              (v25 = *((_QWORD *)v24 + 79)) != 0))
        {
          v26 = (dyld4::PseudoDylib **)*((_QWORD *)v24 + 78);
          v27 = &v26[v25];
          while (1)
          {
            v28 = dyld4::PseudoDylib::loadableAtPath(*v26, a2);
            if (v28)
            {
              v29 = (char *)v28;
              v30 = *(dyld4::RuntimeState **)(a1 + 56);
              if (*(_BYTE *)(*((_QWORD *)v30 + 1) + 208))
                dyld4::RuntimeState::log(v30, "  found: pseduo-dylib: \"%s\"\n", a2);
              Diagnostics::Diagnostics((Diagnostics *)&v78);
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = dyld4::JustInTimeLoader::makePseudoDylibLoader((vm_address_t *)&v78, *(_QWORD *)(a1 + 56), v29, *(_QWORD *)(a1 + 64), (mach_o::Header **)*v26);
              if (v29 != a2)
                dyld4::PseudoDylib::disposeString((uint64_t (***)(char *))*v26, v29);
              if (Diagnostics::hasError((Diagnostics *)&v78))
              {
                v31 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
                v32 = *(vm_address_t **)(a1 + 72);
                v33 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v78);
                if (v31)
                  Diagnostics::error(v32, "tried: '%s' (%s)", a2, v33);
                else
                  Diagnostics::appendError(v32, ", '%s' (%s)", a2, v33);
                v34 = *(dyld4::RuntimeState **)(a1 + 56);
                if (*(_BYTE *)(*((_QWORD *)v34 + 1) + 208))
                {
                  v35 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v78);
                  dyld4::RuntimeState::log(v34, "  found: pseudo-dylib-error: \"%s\" => \"%s\"\n", a2, v35);
                }
              }
              if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
              {
                Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
                *a4 = 1;
                v54 = (vm_address_t **)&v78;
                goto LABEL_141;
              }
              mach_o::Error::~Error((vm_address_t **)&v78);
            }
            if (++v26 == v27)
            {
              v24 = *(dyld4::RuntimeState **)(a1 + 56);
              break;
            }
          }
        }
        if (*(_BYTE *)(*((_QWORD *)v24 + 1) + 208) && !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
          dyld4::RuntimeState::log(v24, "   no pseudo-dylibs matched\n");
      }
      v75 = 0;
      v78 = 0u;
      v79 = 0u;
      if (*(_BYTE *)(a1 + 80))
      {
        if (a3 != 3
          && a3 != 8
          && dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 240), a2, (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24)))
        {
          if (dyld4::ProcessConfig::DyldCache::isOverridablePath((dyld4::ProcessConfig::DyldCache *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 240), a2)&& (dyld4::ProcessConfig::fileExists(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8), a2, &v78, &v75) & 1) != 0)
          {
            if (BYTE8(v79))
            {
              v36 = 1;
              goto LABEL_77;
            }
            Diagnostics::Diagnostics((Diagnostics *)&v72);
            goto LABEL_92;
          }
LABEL_101:
          Diagnostics::Diagnostics((Diagnostics *)&v72);
          v56 = *(dyld4::RuntimeState **)(a1 + 56);
          if (*(_BYTE *)(*((_QWORD *)v56 + 1) + 208))
          {
            dyld4::RuntimeState::log(v56, "  found: dylib-from-cache: (0x%04X) \"%s\"\n", *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), a2);
            v56 = *(dyld4::RuntimeState **)(a1 + 56);
          }
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = dyld4::Loader::makeDyldCacheLoader((vm_address_t *)&v72, v56, a2, *(_QWORD *)(a1 + 64), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40)+ 8)+ 24));
          if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 208) && Diagnostics::hasError((Diagnostics *)&v72))
          {
            v53 = "  found: dylib-from-cache-error: \"%s\" => \"%s\"\n";
            goto LABEL_131;
          }
          goto LABEL_132;
        }
        if (dyld4::ProcessConfig::fileExists(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8), a2, &v78, &v75))
        {
          v36 = *(_BYTE *)(a1 + 82) != 0;
          goto LABEL_76;
        }
      }
      else
      {
        v42 = dyld4::ProcessConfig::fileExists(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8), a2, &v78, &v75);
        v43 = 0;
        if (a3 != 3 && a3 != 8)
          v43 = dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 240), a2, (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
        if (v42)
        {
          if (*(_BYTE *)(a1 + 81))
            v36 = 1;
          else
            v36 = v43;
LABEL_76:
          if (BYTE8(v79))
          {
LABEL_77:
            v44 = 0;
            v45 = *(_QWORD *)(a1 + 56);
            v77[0] = v45 + 32;
            v77[1] = v45 + 64;
            while (1)
            {
              v46 = v77[v44];
              if (!*(_BYTE *)(*(_QWORD *)(a1 + 64) + 5) || v46 != *(_QWORD *)(a1 + 56) + 64)
              {
                v47 = *(_QWORD *)(v46 + 16);
                if (v47)
                  break;
              }
LABEL_90:
              if (++v44 == 2)
                goto LABEL_91;
            }
            v48 = *(dyld4::Loader ***)(v46 + 8);
            v49 = 8 * v47;
            while (1)
            {
              v50 = *v48;
              dyld4::Loader::fileID(*v48, &v72);
              if (v74)
              {
                v51 = *((_QWORD *)&v78 + 1) != v72.i64[1] || BYTE8(v79) == 0;
                if (!v51 && (_QWORD)v78 == v72.i64[0] && (_QWORD)v79 == v73)
                  break;
              }
              ++v48;
              v49 -= 8;
              if (!v49)
                goto LABEL_90;
            }
            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v50;
            *a4 = 1;
            Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
            v55 = *(dyld4::RuntimeState **)(a1 + 56);
            if (*(_BYTE *)(*((_QWORD *)v55 + 1) + 208))
            {
              dyld4::Loader::path(v50, *(const dyld4::RuntimeState **)(a1 + 56));
              dyld4::RuntimeState::log(v55, "  found: already-loaded-by-inode-mtime: \"%s\"\n");
            }
            return;
          }
LABEL_91:
          Diagnostics::Diagnostics((Diagnostics *)&v72);
          if (v36)
          {
LABEL_92:
            v52 = *(dyld4::RuntimeState **)(a1 + 56);
            if (*(_BYTE *)(*((_QWORD *)v52 + 1) + 208))
            {
              dyld4::RuntimeState::log(v52, "  found: dylib-from-disk-to-override-cache: \"%s\"\n", a2);
              v52 = *(dyld4::RuntimeState **)(a1 + 56);
            }
            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = dyld4::Loader::makeDiskLoader((vm_address_t *)&v72, v52, a2, *(_QWORD *)(a1 + 64), 1, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40)+ 8)+ 24), 0);
            if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 208)
              && Diagnostics::hasError((Diagnostics *)&v72))
            {
              v53 = "  found: dylib-from-disk-to-override-cache-error: \"%s\" => \"%s\"\n";
              goto LABEL_131;
            }
          }
          else
          {
            v62 = *(dyld4::RuntimeState **)(a1 + 56);
            if (*(_BYTE *)(*((_QWORD *)v62 + 1) + 208))
            {
              dyld4::RuntimeState::log(v62, "  found: dylib-from-disk: \"%s\"\n", a2);
              v62 = *(dyld4::RuntimeState **)(a1 + 56);
            }
            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = dyld4::Loader::makeDiskLoader((vm_address_t *)&v72, v62, a2, *(_QWORD *)(a1 + 64), 0, 0, 0);
            if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 208)
              && Diagnostics::hasError((Diagnostics *)&v72))
            {
              v53 = "  found: dylib-from-disk-error: \"%s\" => \"%s\"\n";
LABEL_131:
              v63 = *(dyld4::RuntimeState **)(a1 + 56);
              v64 = Diagnostics::errorMessage((Diagnostics *)&v72);
              dyld4::RuntimeState::log(v63, v53, a2, v64);
            }
          }
LABEL_132:
          if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
          {
            *a4 = 1;
            Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
          }
          else
          {
            v65 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
            v66 = *(vm_address_t **)(a1 + 72);
            v67 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v72);
            if (v65)
              Diagnostics::error(v66, "tried: '%s' (%s)", a2, v67);
            else
              Diagnostics::appendError(v66, ", '%s' (%s)", a2, v67);
          }
          v54 = (vm_address_t **)&v72;
LABEL_141:
          mach_o::Error::~Error(v54);
          return;
        }
        if ((v43 & 1) != 0)
          goto LABEL_101;
      }
      v57 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 32);
      if (v57 && a3 != 3 && a3 != 8)
        (*(void (**)(uint64_t, char *))(v57 + 16))(v57, a2);
      v58 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
      v59 = *(vm_address_t **)(a1 + 72);
      if (v58)
        Diagnostics::error(v59, "tried: ");
      else
        Diagnostics::appendError(v59, ", ");
      v60 = (const char *)&unk_1A5CBE413;
      if (a3 != 3
        && a3 != 8
        && (!_platform_strncmp(a2, "/usr/lib/", 9uLL)
         || !_platform_strncmp(a2, "/System/Library/", 0x10uLL)
         || !_platform_strncmp(a2, "/System/iOSSupport/usr/lib/", 0x1BuLL)
         || !_platform_strncmp(a2, "/System/iOSSupport/System/Library/", 0x22uLL)
         || !_platform_strncmp(a2, "/System/DriverKit/", 0x12uLL)))
      {
        if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 240))
          v60 = ", not in dyld cache";
        else
          v60 = ", no dyld cache";
      }
      v61 = v75;
      if (v75 == 1)
      {
        if (dyld4::SyscallDelegate::sandboxBlockedStat(*(dyld4::SyscallDelegate **)(*(_QWORD *)(a1 + 56) + 8), a2))
        {
          Diagnostics::appendError(*(vm_address_t **)(a1 + 72), "'%s' (blocked by sandbox)%s", a2, v60);
          v68 = *(dyld4::RuntimeState **)(a1 + 56);
          if (*(_BYTE *)(*((_QWORD *)v68 + 1) + 208))
            dyld4::RuntimeState::log(v68, "    stat(\"%s\") blocked by file system sandbox\n");
          return;
        }
        v61 = v75;
      }
      else if (v75 == 2)
      {
        Diagnostics::appendError(*(vm_address_t **)(a1 + 72), "'%s' (no such file%s)");
        return;
      }
      v69 = *(vm_address_t **)(a1 + 72);
      if (v61 == 666)
      {
        Diagnostics::appendError(v69, "'%s' (not a file%s)", a2, v60);
        v70 = *(dyld4::RuntimeState **)(a1 + 56);
        if (*(_BYTE *)(*((_QWORD *)v70 + 1) + 208))
          dyld4::RuntimeState::log(v70, "    stat(\"%s\") returned path is not a regular file\n");
      }
      else
      {
        Diagnostics::appendError(v69, "'%s' (errno=%d%s)", a2, v61, v60);
        v71 = *(dyld4::RuntimeState **)(a1 + 56);
        if (*(_BYTE *)(*((_QWORD *)v71 + 1) + 208))
          dyld4::RuntimeState::log(v71, "    stat(\"%s\") returned: errno=%d\n");
      }
      return;
    }
  }
  v13 = *(dyld4::Loader ***)(v11 + 8);
  v14 = 8 * v12;
  while (1)
  {
    v15 = *v13;
    if (dyld4::Loader::matchesPath(*v13, *(const dyld4::RuntimeState **)(a1 + 56), a2))
      break;
    ++v13;
    v14 -= 8;
    if (!v14)
      goto LABEL_13;
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v15;
  *a4 = 1;
  Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
  v37 = *(dyld4::RuntimeState **)(a1 + 56);
  if (*(_BYTE *)(*((_QWORD *)v37 + 1) + 208))
    dyld4::RuntimeState::log(v37, "  found: already-loaded-by-path: \"%s\"\n");
}

uint64_t dyld4::Loader::representsCachedDylibIndex(dyld4::Loader *this, int a2)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::representsCachedDylibIndex();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::hiddenFromFlat(this);
  else
    return dyld4::JustInTimeLoader::representsCachedDylibIndex(this, a2);
}

uint64_t dyld4::PrebuiltLoader::hiddenFromFlat(dyld4::PrebuiltLoader *this)
{
  return 0;
}

uint64_t objc::StringHashTable::tryGetIndex(objc::StringHashTable *this, char *__s)
{
  const unsigned __int8 *v4;
  char v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v4 = (const unsigned __int8 *)_platform_strlen(__s);
  v5 = (char)v4;
  v6 = objc::lookup8((objc *)__s, v4, *((_QWORD *)this + 3));
  v7 = *((_DWORD *)this + 3);
  v8 = *((unsigned int *)this + 4);
  if (v7 == 64)
    v9 = 0;
  else
    v9 = v6 >> v7;
  v10 = v9 ^ *((_DWORD *)this + *((unsigned __int8 *)this + (v6 & v8) + 1056) + 8);
  v11 = (char *)this + (v8 + 1) + 1056;
  if (v11[v10] != (v5 & 0x1F | (32 * *__s)))
  {
LABEL_7:
    LODWORD(v12) = 0;
    goto LABEL_8;
  }
  v12 = *(int *)&v11[4 * v10 + *((unsigned int *)this + 1)];
  if ((_DWORD)v12)
  {
    if (!_platform_strcmp(__s, (const char *)this + v12))
    {
      v13 = v10 & 0xFFFFFF00;
      LODWORD(v12) = v10;
      v14 = 0x100000000;
      return v14 | v13 | v12;
    }
    goto LABEL_7;
  }
LABEL_8:
  v13 = 0;
  v14 = 0;
  return v14 | v13 | v12;
}

unint64_t objc::lookup8(objc *this, const unsigned __int8 *a2, unint64_t a3)
{
  unint64_t v3;
  const unsigned __int8 *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;

  v3 = 0x9E3779B97F4A7C13;
  if ((unint64_t)a2 < 0x18)
  {
    v5 = a3;
    v4 = a2;
  }
  else
  {
    v4 = a2;
    v5 = a3;
    do
    {
      v6 = a3
         + ((unint64_t)*((unsigned __int8 *)this + 14) << 48)
         + (*((unsigned int *)this + 2) | ((unint64_t)*((unsigned __int8 *)this + 12) << 32) | ((unint64_t)*((unsigned __int8 *)this + 13) << 40))
         + ((unint64_t)*((unsigned __int8 *)this + 15) << 56);
      v7 = v3
         + ((unint64_t)*((unsigned __int8 *)this + 22) << 48)
         + (*((unsigned int *)this + 4) | ((unint64_t)*((unsigned __int8 *)this + 20) << 32) | ((unint64_t)*((unsigned __int8 *)this + 21) << 40))
         + ((unint64_t)*((unsigned __int8 *)this + 23) << 56);
      v8 = (v5
          + ((unint64_t)*((unsigned __int8 *)this + 6) << 48)
          + (*(unsigned int *)this | ((unint64_t)*((unsigned __int8 *)this + 4) << 32) | ((unint64_t)*((unsigned __int8 *)this + 5) << 40))
          + ((unint64_t)*((unsigned __int8 *)this + 7) << 56)
          - (v6
           + v7)) ^ (v7 >> 43);
      v9 = (v6 - v7 - v8) ^ (v8 << 9);
      v10 = (v7 - v8 - v9) ^ (v9 >> 8);
      v11 = (v8 - v9 - v10) ^ (v10 >> 38);
      v12 = (v9 - v10 - v11) ^ (v11 << 23);
      v13 = (v10 - v11 - v12) ^ (v12 >> 5);
      v14 = (v11 - v12 - v13) ^ (v13 >> 35);
      v15 = (v12 - v13 - v14) ^ (v14 << 49);
      v16 = (v13 - v14 - v15) ^ (v15 >> 11);
      v5 = (v14 - v15 - v16) ^ (v16 >> 12);
      a3 = (v15 - v16 - v5) ^ (v5 << 18);
      v3 = (v16 - v5 - a3) ^ (a3 >> 22);
      this = (objc *)((char *)this + 24);
      v4 -= 24;
    }
    while ((unint64_t)v4 > 0x17);
  }
  v17 = (unint64_t)&a2[v3];
  switch((unint64_t)v4)
  {
    case 1uLL:
      goto LABEL_29;
    case 2uLL:
      goto LABEL_28;
    case 3uLL:
      goto LABEL_27;
    case 4uLL:
      goto LABEL_26;
    case 5uLL:
      goto LABEL_25;
    case 6uLL:
      goto LABEL_24;
    case 7uLL:
      goto LABEL_23;
    case 8uLL:
      goto LABEL_22;
    case 9uLL:
      goto LABEL_21;
    case 0xAuLL:
      goto LABEL_20;
    case 0xBuLL:
      goto LABEL_19;
    case 0xCuLL:
      goto LABEL_18;
    case 0xDuLL:
      goto LABEL_17;
    case 0xEuLL:
      goto LABEL_16;
    case 0xFuLL:
      goto LABEL_15;
    case 0x10uLL:
      goto LABEL_14;
    case 0x11uLL:
      goto LABEL_13;
    case 0x12uLL:
      goto LABEL_12;
    case 0x13uLL:
      goto LABEL_11;
    case 0x14uLL:
      goto LABEL_10;
    case 0x15uLL:
      goto LABEL_9;
    case 0x16uLL:
      goto LABEL_8;
    case 0x17uLL:
      v17 += (unint64_t)*((unsigned __int8 *)this + 22) << 56;
LABEL_8:
      v17 += (unint64_t)*((unsigned __int8 *)this + 21) << 48;
LABEL_9:
      v17 += (unint64_t)*((unsigned __int8 *)this + 20) << 40;
LABEL_10:
      v17 += (unint64_t)*((unsigned __int8 *)this + 19) << 32;
LABEL_11:
      v17 += (unint64_t)*((unsigned __int8 *)this + 18) << 24;
LABEL_12:
      v17 += (unint64_t)*((unsigned __int8 *)this + 17) << 16;
LABEL_13:
      v17 += (unint64_t)*((unsigned __int8 *)this + 16) << 8;
LABEL_14:
      a3 += (unint64_t)*((unsigned __int8 *)this + 15) << 56;
LABEL_15:
      a3 += (unint64_t)*((unsigned __int8 *)this + 14) << 48;
LABEL_16:
      a3 += (unint64_t)*((unsigned __int8 *)this + 13) << 40;
LABEL_17:
      a3 += (unint64_t)*((unsigned __int8 *)this + 12) << 32;
LABEL_18:
      a3 += (unint64_t)*((unsigned __int8 *)this + 11) << 24;
LABEL_19:
      a3 += (unint64_t)*((unsigned __int8 *)this + 10) << 16;
LABEL_20:
      a3 += (unint64_t)*((unsigned __int8 *)this + 9) << 8;
LABEL_21:
      a3 += *((unsigned __int8 *)this + 8);
LABEL_22:
      v5 += (unint64_t)*((unsigned __int8 *)this + 7) << 56;
LABEL_23:
      v5 += (unint64_t)*((unsigned __int8 *)this + 6) << 48;
LABEL_24:
      v5 += (unint64_t)*((unsigned __int8 *)this + 5) << 40;
LABEL_25:
      v5 += (unint64_t)*((unsigned __int8 *)this + 4) << 32;
LABEL_26:
      v5 += (unint64_t)*((unsigned __int8 *)this + 3) << 24;
LABEL_27:
      v5 += (unint64_t)*((unsigned __int8 *)this + 2) << 16;
LABEL_28:
      v5 += (unint64_t)*((unsigned __int8 *)this + 1) << 8;
LABEL_29:
      v5 += *(unsigned __int8 *)this;
      break;
    default:
      break;
  }
  v18 = (v5 - a3 - v17) ^ (v17 >> 43);
  v19 = (a3 - v17 - v18) ^ (v18 << 9);
  v20 = (v17 - v18 - v19) ^ (v19 >> 8);
  v21 = (v18 - v19 - v20) ^ (v20 >> 38);
  v22 = (v19 - v20 - v21) ^ (v21 << 23);
  v23 = (v20 - v21 - v22) ^ (v22 >> 5);
  v24 = (v21 - v22 - v23) ^ (v23 >> 35);
  v25 = (v22 - v23 - v24) ^ (v24 << 49);
  v26 = (v23 - v24 - v25) ^ (v25 >> 11);
  v27 = (v24 - v25 - v26) ^ (v26 >> 12);
  return (v26 - v27 - ((v25 - v26 - v27) ^ (v27 << 18))) ^ (((v25 - v26 - v27) ^ (v27 << 18)) >> 22);
}

int _platform_strcmp(const char *__s1, const char *__s2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  int v5;
  uint64_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  uint8x16_t v12;
  int8x16_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  uint8x16_t v21;

  while ((__s1 & 0xF) != 0)
  {
    v3 = *(unsigned __int8 *)__s1++;
    v2 = v3;
    v4 = *(unsigned __int8 *)__s2++;
    v5 = v2 - v4;
    if (v2 != v4 || (_DWORD)v2 == 0)
      return v5;
  }
  if ((__s2 & 0xF) != 0)
  {
    v8 = -(uint64_t)__s2 & 0xFF0;
    if (!v8)
      goto LABEL_12;
LABEL_10:
    while (1)
    {
      v9 = *(int8x16_t *)__s1;
      __s1 += 16;
      v10 = v9;
      v11 = *(int8x16_t *)__s2;
      __s2 += 16;
      v13 = vceqq_s8(v10, v11);
      v12 = (uint8x16_t)vandq_s8(v10, v13);
      v13.i8[0] = vminvq_u8(v12);
      if (!v13.i32[0])
        break;
      v8 -= 16;
      if (!v8)
      {
LABEL_12:
        while (1)
        {
          v15 = *(unsigned __int8 *)__s1++;
          v14 = v15;
          v16 = *(unsigned __int8 *)__s2++;
          v5 = v14 - v16;
          if (v14 != v16 || (_DWORD)v14 == 0)
            return v5;
          if ((__s1 & 0xF) == 0)
          {
            v8 = 4080;
            goto LABEL_10;
          }
        }
      }
    }
  }
  else
  {
    do
    {
      v18 = *(int8x16_t *)__s1;
      __s1 += 16;
      v19 = v18;
      v20 = *(int8x16_t *)__s2;
      __s2 += 16;
      v13 = vceqq_s8(v19, v20);
      v12 = (uint8x16_t)vandq_s8(v19, v13);
      v13.i8[0] = vminvq_u8(v12);
    }
    while (v13.i32[0]);
  }
  v21 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v12, (uint8x16_t)veorq_s8(v13, v13)), (int8x16_t)xmmword_1A5C5D0A0);
  v21.i8[0] = vminvq_u8(v21);
  return __s1[v21.u32[0] - 16] - __s2[v21.u32[0] - 16];
}

size_t _platform_strnlen(const char *__s1, size_t __n)
{
  unint64_t v3;
  int8x16_t *v4;
  int8x16_t v5;
  uint8x16_t v6;
  size_t v7;
  uint8x16_t v8;
  BOOL v9;
  uint8x16_t v10;
  unint64_t v11;

  if ((__n & 0x8000000000000000) != 0)
    return _platform_strlen(__s1);
  if (!__n)
    return 0;
  v3 = (unint64_t)__s1 & 0xFFFFFFFFFFFFFFF0;
  v4 = (int8x16_t *)&algn_1A5C5D1B0[-(__s1 & 0xF)];
  v5 = *v4;
  v6 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((unint64_t)__s1 & 0xFFFFFFFFFFFFFFF0), *v4);
  v7 = __n + (__s1 & 0xF);
  while (1)
  {
    v5.i8[0] = vminvq_u8(v6);
    if (!v5.i32[0])
      break;
    v9 = v7 > 0x10;
    v7 -= 16;
    if (!v9)
      return v3 - (_QWORD)__s1 + v7 + 16;
    v8 = *(uint8x16_t *)(v3 + 16);
    v3 += 16;
    v6 = v8;
  }
  v10 = (uint8x16_t)veorq_s8(v5, v5);
  v10.i8[0] = vminvq_u8((uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v6, v10), (int8x16_t)xmmword_1A5C5D1A0));
  v11 = v3 - (_QWORD)__s1;
  if (v7 >= v10.u32[0])
    v7 = v10.u32[0];
  return v11 + v7;
}

size_t _platform_strlen(const char *__s)
{
  unint64_t v1;
  int8x16_t *v2;
  int8x16_t v3;
  uint8x16_t i;
  uint8x16_t v5;
  uint8x16_t v6;

  v1 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0;
  v2 = (int8x16_t *)&algn_1A5C5D1B0[-(__s & 0xF)];
  v3 = *v2;
  for (i = (uint8x16_t)vorrq_s8(*(int8x16_t *)((unint64_t)__s & 0xFFFFFFFFFFFFFFF0), *v2); ; i = v5)
  {
    v3.i8[0] = vminvq_u8(i);
    if (!v3.i32[0])
      break;
    v5 = *(uint8x16_t *)(v1 + 16);
    v1 += 16;
  }
  v6 = (uint8x16_t)veorq_s8(v3, v3);
  v6.i8[0] = vminvq_u8((uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(i, v6), (int8x16_t)xmmword_1A5C5D1A0));
  return v1 - (_QWORD)__s + v6.u32[0];
}

double dyld4::Loader::fileID@<D0>(dyld4::Loader *this@<X0>, int8x16_t *a2@<X8>)
{
  double result;

  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::fileID();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::fileID((uint64_t)this, a2);
  *(_QWORD *)&result = dyld4::JustInTimeLoader::fileID((uint64_t)this, (uint64_t)a2).n128_u64[0];
  return result;
}

double dyld4::PrebuiltLoader::fileID@<D0>(uint64_t a1@<X0>, int8x16_t *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  __int8 v4;
  int8x16_t v5;

  if (a1 && *(_WORD *)(a1 + 42))
  {
    v2 = a1 + *(unsigned __int16 *)(a1 + 42);
    v3 = *(_QWORD *)(v2 + 24);
    v4 = *(_BYTE *)(v2 + 52);
    v5 = vextq_s8(*(int8x16_t *)(v2 + 8), *(int8x16_t *)(v2 + 8), 8uLL);
    *a2 = v5;
    a2[1].i64[0] = v3;
    a2[1].i8[8] = v4;
  }
  else
  {
    v5.i64[0] = 0;
    *a2 = 0u;
    a2[1] = 0u;
  }
  return *(double *)v5.i64;
}

uint64_t DyldSharedCache::hasImagePath(DyldSharedCache *this, const char *__s2, unsigned int *a3)
{
  uint64_t v3;
  const unsigned __int8 **v8;
  Diagnostics *v9;
  const char *v10;
  const unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  const unsigned __int8 **v16;
  vm_address_t *v17;

  v3 = *((unsigned int *)this + 4);
  if (*(_QWORD *)((char *)this + v3 + 16))
    return 0;
  if (v3 < 0x118)
  {
    v12 = *((unsigned int *)this + 7);
    if ((_DWORD)v12)
    {
      v13 = 0;
      v14 = (unsigned int *)((char *)this + *((unsigned int *)this + 6) + 24);
      while (1)
      {
        v15 = *v14;
        v14 += 8;
        if (!_platform_strcmp((const char *)this + v15, __s2))
          break;
        if (v12 == ++v13)
          return 0;
      }
      *a3 = v13;
      return 1;
    }
  }
  else
  {
    v8 = (const unsigned __int8 **)((char *)this + *((_QWORD *)this + 33) - *(_QWORD *)((char *)this + v3));
    v9 = (Diagnostics *)((char *)v8 + *((_QWORD *)this + 34));
    Diagnostics::Diagnostics((Diagnostics *)&v17);
    v16 = dyld3::MachOFile::trieWalk((vm_address_t *)&v17, v8, v9, (const unsigned __int8 *)__s2, v10);
    if (v16)
    {
      *a3 = dyld3::MachOFile::read_uleb128((vm_address_t *)&v17, &v16, (const unsigned __int8 **)v9, v11);
      mach_o::Error::~Error(&v17);
      return 1;
    }
    mach_o::Error::~Error(&v17);
  }
  return 0;
}

DyldSharedCache *dyld4::ProcessConfig::DyldCache::indexOfPath(DyldSharedCache **this, const char *a2, unsigned int *a3)
{
  DyldSharedCache *result;

  result = *this;
  if (result)
    return (DyldSharedCache *)DyldSharedCache::hasImagePath(result, a2, a3);
  return result;
}

BOOL dyld4::JustInTimeLoader::representsCachedDylibIndex(dyld4::JustInTimeLoader *this, int a2)
{
  unint64_t v2;

  v2 = *((_QWORD *)this + 5);
  return (v2 & 0x400000) != 0 && ((v2 >> 24) & 0x7FFF) == a2
      || (*((_WORD *)this + 2) & 2) != 0 && (*((_WORD *)this + 3) & 0x7FFF) == a2;
}

uint64_t dyld4::SyscallDelegate::fileExists(uint64_t a1, dyld3 *a2, uint64_t a3, int *a4)
{
  int *v6;
  uint64_t result;
  int v8;
  __darwin_time_t tv_sec;
  uint64_t st_dev;
  stat v11;

  if (dyld3::stat(a2, &v11, (stat *)a3))
  {
    if (a4)
    {
      v6 = __error();
      result = 0;
      v8 = *v6;
LABEL_9:
      *a4 = v8;
      return result;
    }
    return 0;
  }
  if ((v11.st_mode & 0xF000) != 0x8000)
  {
    if (a4)
    {
      result = 0;
      v8 = 666;
      goto LABEL_9;
    }
    return 0;
  }
  result = 1;
  if (a3)
  {
    tv_sec = v11.st_mtimespec.tv_sec;
    st_dev = v11.st_dev;
    *(_QWORD *)a3 = v11.st_ino;
    *(_QWORD *)(a3 + 8) = st_dev;
    *(_QWORD *)(a3 + 16) = tv_sec;
    *(_BYTE *)(a3 + 24) = 1;
  }
  return result;
}

uint64_t dyld3::stat(dyld3 *this, stat *a2, stat *a3)
{
  const char *v3;
  dyld3 *v4;
  uint64_t result;

  v3 = (const char *)a2;
  v4 = this;
  while (1)
  {
    result = stat_with_subsystem((const char *)this, a2);
    if ((_DWORD)result != -1)
      break;
    if (*__error() != 35 && *__error() != 4)
      return 0xFFFFFFFFLL;
    this = v4;
    a2 = (stat *)v3;
  }
  return result;
}

int *__error(void)
{
  int *v0;

  v0 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v0)
    return v0;
  else
    return &errno;
}

uint64_t stat_with_subsystem(const char *a1, stat *a2)
{
  uint64_t v4;
  int *v5;
  char *v6;
  char *next_subsystem_root_path;
  char __dst[1024];

  v4 = stat64(a1, a2);
  if ((v4 & 0x80000000) != 0)
  {
    v5 = __error();
    v6 = (char *)subsystem_root_path;
    if (*v5 == 2 && subsystem_root_path != 0)
    {
      while (1)
      {
        next_subsystem_root_path = extract_next_subsystem_root_path(__dst, v6);
        if (strlcat(__dst, a1, 0x400uLL) > 0x3FF)
          break;
        v4 = stat64(__dst, a2);
        if ((v4 & 0x80000000) == 0)
          return v4;
        __error();
        if (!next_subsystem_root_path)
          return v4;
        v6 = next_subsystem_root_path;
      }
      *__error() = 63;
    }
  }
  return v4;
}

int stat64(const char *a1, stat *a2)
{
  char v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  int64_t v9;

  v9 = mac_syscall(SYS_stat64, (void *)a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2)
    LODWORD(v9) = cerror_nocancel(v9);
  return v9;
}

uint64_t cerror_nocancel(int a1)
{
  int *v1;

  errno = a1;
  v1 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v1)
    *v1 = a1;
  return -1;
}

uint64_t Diagnostics::error(vm_address_t *this, char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  return Diagnostics::error(this, a2, va);
}

uint64_t Diagnostics::appendError(vm_address_t *this, char *__s, ...)
{
  uint64_t v4;
  va_list va;

  va_start(va, __s);
  v4 = *this;
  if (v4)
    _simple_sresize(v4);
  return Diagnostics::error(this, __s, va);
}

uint64_t _simple_vsprintf(uint64_t a1, char *__s, int *a3)
{
  __simple_bprintf(a1, 0, __s, a3);
  return 0;
}

uint64_t __simple_bprintf(uint64_t result, uint64_t (*a2)(uint64_t), char *__s, int *a4)
{
  char *v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  char v11;
  unsigned __int8 *v12;
  _BYTE *v13;
  int v14;
  _BYTE *v15;
  BOOL v16;
  const char *v17;
  char v18;
  unsigned __int8 *v19;
  _BYTE *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  _BYTE *v30;
  int *v31;
  int v32;
  unsigned __int8 *v33;
  uint64_t v34;
  unsigned int v35;
  char v36;
  unsigned __int8 *v37;
  _BYTE *v38;
  int v39;
  _BYTE *v40;
  std::ios_base *v41;
  uint64_t v42;
  char v43;
  unsigned __int8 *v44;
  _BYTE *v45;
  int v46;
  _BYTE *v47;
  int *v48;
  int v49;
  char v50;
  unsigned __int8 *v51;
  _BYTE *v52;
  int v53;
  const char **v54;
  const char *v55;
  const char *v56;
  int v57;
  uint64_t v58;
  char v59;
  unsigned __int8 *v60;
  _BYTE *v61;
  int v62;
  _BYTE *v63;
  char v64;
  unsigned __int8 *v65;
  _BYTE *v66;
  int v67;
  char *v68;
  char v69;
  unint64_t *v70;
  unint64_t v71;
  unint64_t *v72;
  unint64_t v73;
  char v74;
  unsigned __int8 *v75;
  _BYTE *v76;
  int v77;
  _BYTE *v78;
  _BYTE *v79;
  char v80;
  unsigned __int8 *v81;
  _BYTE *v82;
  int v83;
  char *v84;
  char v85;

  if (!*__s)
    return result;
  v4 = __s;
  v6 = result;
  do
  {
    result = (uint64_t)_platform_strchr(v4, 37);
    if (!result)
    {
      while (1)
      {
        v85 = *v4;
        if (!*v4)
          break;
        if (a2 && (result = a2(*v4)) != 0)
        {
          v80 = *(_BYTE *)result;
          if (*(_BYTE *)result)
          {
            v81 = (unsigned __int8 *)(result + 1);
            do
            {
              v82 = *(_BYTE **)(v6 + 8);
              if ((unint64_t)v82 >= *(_QWORD *)(v6 + 16))
              {
                result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                v82 = *(_BYTE **)(v6 + 8);
              }
              *(_QWORD *)(v6 + 8) = v82 + 1;
              *v82 = v80;
              v83 = *v81++;
              v80 = v83;
            }
            while (v83);
          }
        }
        else
        {
          v84 = *(char **)(v6 + 8);
          if ((unint64_t)v84 >= *(_QWORD *)(v6 + 16))
          {
            result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
            v84 = *(char **)(v6 + 8);
          }
          *(_QWORD *)(v6 + 8) = v84 + 1;
          *v84 = v85;
        }
        ++v4;
      }
      return result;
    }
    v7 = result;
    v8 = result - (_QWORD)v4;
    if (result - (uint64_t)v4 >= 1)
    {
      do
      {
        v10 = *v4++;
        v9 = v10;
        if (a2 && (result = a2(v9)) != 0)
        {
          v11 = *(_BYTE *)result;
          if (*(_BYTE *)result)
          {
            v12 = (unsigned __int8 *)(result + 1);
            do
            {
              v13 = *(_BYTE **)(v6 + 8);
              if ((unint64_t)v13 >= *(_QWORD *)(v6 + 16))
              {
                result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                v13 = *(_BYTE **)(v6 + 8);
              }
              *(_QWORD *)(v6 + 8) = v13 + 1;
              *v13 = v11;
              v14 = *v12++;
              v11 = v14;
            }
            while (v14);
          }
        }
        else
        {
          v15 = *(_BYTE **)(v6 + 8);
          if ((unint64_t)v15 >= *(_QWORD *)(v6 + 16))
          {
            result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
            v15 = *(_BYTE **)(v6 + 8);
          }
          *(_QWORD *)(v6 + 8) = v15 + 1;
          *v15 = v9;
        }
        v16 = v8-- <= 1;
      }
      while (!v16);
    }
    v17 = (const char *)(v7 + 1);
    if (*(_BYTE *)(v7 + 1) == 37)
    {
      if (a2 && (result = a2(37)) != 0)
      {
        v18 = *(_BYTE *)result;
        if (*(_BYTE *)result)
        {
          v19 = (unsigned __int8 *)(result + 1);
          do
          {
            v20 = *(_BYTE **)(v6 + 8);
            if ((unint64_t)v20 >= *(_QWORD *)(v6 + 16))
            {
              result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
              v20 = *(_BYTE **)(v6 + 8);
            }
            *(_QWORD *)(v6 + 8) = v20 + 1;
            *v20 = v18;
            v21 = *v19++;
            v18 = v21;
          }
          while (v21);
        }
      }
      else
      {
        v30 = *(_BYTE **)(v6 + 8);
        if ((unint64_t)v30 >= *(_QWORD *)(v6 + 16))
        {
          result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
          v30 = *(_BYTE **)(v6 + 8);
        }
        *(_QWORD *)(v6 + 8) = v30 + 1;
        *v30 = 37;
      }
      v4 = (char *)(v7 + 2);
      continue;
    }
    result = _platform_strncmp((const char *)(v7 + 1), ".*s", 3uLL);
    if (!(_DWORD)result)
    {
LABEL_44:
      v31 = a4;
      v32 = *a4;
      a4 += 4;
      if (v32 >= 1)
      {
        v33 = (unsigned __int8 *)*((_QWORD *)v31 + 1);
        do
        {
          v35 = *v33++;
          v34 = v35;
          if (a2 && (result = a2(v34)) != 0)
          {
            v36 = *(_BYTE *)result;
            if (*(_BYTE *)result)
            {
              v37 = (unsigned __int8 *)(result + 1);
              do
              {
                v38 = *(_BYTE **)(v6 + 8);
                if ((unint64_t)v38 >= *(_QWORD *)(v6 + 16))
                {
                  result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                  v38 = *(_BYTE **)(v6 + 8);
                }
                *(_QWORD *)(v6 + 8) = v38 + 1;
                *v38 = v36;
                v39 = *v37++;
                v36 = v39;
              }
              while (v39);
            }
          }
          else
          {
            v40 = *(_BYTE **)(v6 + 8);
            if ((unint64_t)v40 >= *(_QWORD *)(v6 + 16))
            {
              result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
              v40 = *(_BYTE **)(v6 + 8);
            }
            *(_QWORD *)(v6 + 8) = v40 + 1;
            *v40 = v34;
          }
          v16 = v32-- <= 1;
        }
        while (!v16);
      }
      v17 += 2;
      goto LABEL_148;
    }
    v22 = 0;
    v23 = 0;
    v24 = 0;
    while (1)
    {
      v25 = *v17;
      v26 = *(unsigned __int8 *)v17;
      if (v25 > 98)
      {
        switch(*v17)
        {
          case 'c':
            if (v24 >= 2)
            {
              if (v23)
                v42 = 48;
              else
                v42 = 32;
              do
              {
                if (a2 && (result = a2(v42)) != 0)
                {
                  v43 = *(_BYTE *)result;
                  if (*(_BYTE *)result)
                  {
                    v44 = (unsigned __int8 *)(result + 1);
                    do
                    {
                      v45 = *(_BYTE **)(v6 + 8);
                      if ((unint64_t)v45 >= *(_QWORD *)(v6 + 16))
                      {
                        result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                        v45 = *(_BYTE **)(v6 + 8);
                      }
                      *(_QWORD *)(v6 + 8) = v45 + 1;
                      *v45 = v43;
                      v46 = *v44++;
                      v43 = v46;
                    }
                    while (v46);
                  }
                }
                else
                {
                  v47 = *(_BYTE **)(v6 + 8);
                  if ((unint64_t)v47 >= *(_QWORD *)(v6 + 16))
                  {
                    result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                    v47 = *(_BYTE **)(v6 + 8);
                  }
                  *(_QWORD *)(v6 + 8) = v47 + 1;
                  *v47 = v42;
                }
                v16 = v24-- <= 2;
              }
              while (!v16);
            }
            v48 = a4;
            a4 += 2;
            v49 = *v48;
            if (a2 && (result = a2(*v48)) != 0)
            {
              v50 = *(_BYTE *)result;
              if (*(_BYTE *)result)
              {
                v51 = (unsigned __int8 *)(result + 1);
                do
                {
                  v52 = *(_BYTE **)(v6 + 8);
                  if ((unint64_t)v52 >= *(_QWORD *)(v6 + 16))
                  {
                    result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                    v52 = *(_BYTE **)(v6 + 8);
                  }
                  *(_QWORD *)(v6 + 8) = v52 + 1;
                  *v52 = v50;
                  v53 = *v51++;
                  v50 = v53;
                }
                while (v53);
              }
            }
            else
            {
              v78 = *(_BYTE **)(v6 + 8);
              if ((unint64_t)v78 >= *(_QWORD *)(v6 + 16))
              {
                result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                v78 = *(_BYTE **)(v6 + 8);
              }
              *(_QWORD *)(v6 + 8) = v78 + 1;
              *v78 = v49;
            }
            break;
          case 'd':
          case 'i':
            a4 += 2;
            result = (uint64_t)dec((std::ios_base *)v6);
            break;
          case 'l':
            ++v22;
            ++v17;
            goto LABEL_32;
          case 'o':
            a4 += 2;
            result = (uint64_t)oct((std::ios_base *)v6);
            break;
          case 'p':
            a4 += 2;
            v41 = (std::ios_base *)v6;
            goto LABEL_90;
          case 's':
            v54 = (const char **)a4;
            a4 += 2;
            v55 = *v54;
            if (v55)
              v56 = v55;
            else
              v56 = "(null)";
            result = _platform_strlen(v56);
            v57 = v24 - result;
            if (v24 - (int)result >= 1)
            {
              if (v23)
                v58 = 48;
              else
                v58 = 32;
              do
              {
                if (a2 && (result = a2(v58)) != 0)
                {
                  v59 = *(_BYTE *)result;
                  if (*(_BYTE *)result)
                  {
                    v60 = (unsigned __int8 *)(result + 1);
                    do
                    {
                      v61 = *(_BYTE **)(v6 + 8);
                      if ((unint64_t)v61 >= *(_QWORD *)(v6 + 16))
                      {
                        result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                        v61 = *(_BYTE **)(v6 + 8);
                      }
                      *(_QWORD *)(v6 + 8) = v61 + 1;
                      *v61 = v59;
                      v62 = *v60++;
                      v59 = v62;
                    }
                    while (v62);
                  }
                }
                else
                {
                  v63 = *(_BYTE **)(v6 + 8);
                  if ((unint64_t)v63 >= *(_QWORD *)(v6 + 16))
                  {
                    result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                    v63 = *(_BYTE **)(v6 + 8);
                  }
                  *(_QWORD *)(v6 + 8) = v63 + 1;
                  *v63 = v58;
                }
                v16 = v57-- <= 1;
              }
              while (!v16);
            }
            while (1)
            {
              v69 = *v56;
              if (!*v56)
                break;
              if (a2 && (result = a2(*(unsigned __int8 *)v56)) != 0)
              {
                v64 = *(_BYTE *)result;
                if (*(_BYTE *)result)
                {
                  v65 = (unsigned __int8 *)(result + 1);
                  do
                  {
                    v66 = *(_BYTE **)(v6 + 8);
                    if ((unint64_t)v66 >= *(_QWORD *)(v6 + 16))
                    {
                      result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                      v66 = *(_BYTE **)(v6 + 8);
                    }
                    *(_QWORD *)(v6 + 8) = v66 + 1;
                    *v66 = v64;
                    v67 = *v65++;
                    v64 = v67;
                  }
                  while (v67);
                }
              }
              else
              {
                v68 = *(char **)(v6 + 8);
                if ((unint64_t)v68 >= *(_QWORD *)(v6 + 16))
                {
                  result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                  v68 = *(char **)(v6 + 8);
                }
                *(_QWORD *)(v6 + 8) = v68 + 1;
                *v68 = v69;
              }
              ++v56;
            }
            break;
          case 'u':
            v70 = (unint64_t *)a4;
            a4 += 2;
            if (v22)
              v71 = *v70;
            else
              v71 = *(unsigned int *)v70;
            result = (uint64_t)udec(v6, a2, v71, v24, v23);
            break;
          case 'x':
            goto LABEL_62;
          case 'y':
            v72 = (unint64_t *)a4;
            a4 += 2;
            if (v22)
              v73 = *v72;
            else
              v73 = *(unsigned int *)v72;
            result = (uint64_t)ydec(v6, a2, v73, v24, v23);
            break;
          default:
            goto LABEL_130;
        }
        goto LABEL_148;
      }
      if ((v25 - 49) >= 9)
        break;
LABEL_35:
      if ((v26 - 48) <= 9)
      {
        do
        {
          v27 = 10 * v24 + v26;
          v28 = *(unsigned __int8 *)++v17;
          LOBYTE(v26) = v28;
          v24 = v27 - 48;
        }
        while ((v28 - 48) < 0xA);
      }
LABEL_32:
      result = _platform_strncmp(v17, ".*s", 3uLL);
      if (!(_DWORD)result)
        goto LABEL_44;
    }
    if (v25 == 48)
    {
      ++v23;
      v29 = *(unsigned __int8 *)++v17;
      v26 = v29;
      goto LABEL_35;
    }
    if (v25 == 88)
    {
LABEL_62:
      a4 += 2;
      v41 = (std::ios_base *)v6;
LABEL_90:
      result = (uint64_t)hex(v41);
    }
    else
    {
LABEL_130:
      if (a2 && (result = a2(*(unsigned __int8 *)v17)) != 0)
      {
        v74 = *(_BYTE *)result;
        if (*(_BYTE *)result)
        {
          v75 = (unsigned __int8 *)(result + 1);
          do
          {
            v76 = *(_BYTE **)(v6 + 8);
            if ((unint64_t)v76 >= *(_QWORD *)(v6 + 16))
            {
              result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
              v76 = *(_BYTE **)(v6 + 8);
            }
            *(_QWORD *)(v6 + 8) = v76 + 1;
            *v76 = v74;
            v77 = *v75++;
            v74 = v77;
          }
          while (v77);
        }
      }
      else
      {
        v79 = *(_BYTE **)(v6 + 8);
        if ((unint64_t)v79 >= *(_QWORD *)(v6 + 16))
        {
          result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
          v79 = *(_BYTE **)(v6 + 8);
        }
        *(_QWORD *)(v6 + 8) = v79 + 1;
        *v79 = v26;
      }
    }
LABEL_148:
    v4 = (char *)(v17 + 1);
  }
  while (*v4);
  return result;
}

uint64_t Diagnostics::error(vm_address_t *this, char *__s, char *a3)
{
  vm_address_t v6;

  v6 = *this;
  if (!v6)
  {
    v6 = _simple_salloc();
    *this = v6;
  }
  return _simple_vsprintf(v6, __s, (int *)a3);
}

vm_address_t _simple_salloc()
{
  vm_address_t result;
  vm_address_t v1;
  vm_address_t v2;
  vm_address_t address;

  if (vm_allocate(mach_task_self_, &address, vm_page_size, 1))
    return 0;
  v1 = address + 40;
  *(_QWORD *)address = address + 40;
  result = address;
  v2 = address + vm_page_size - 1;
  *(_QWORD *)(address + 8) = v1;
  *(_QWORD *)(result + 16) = v2;
  *(_QWORD *)(result + 32) = _enlarge;
  return result;
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  kern_return_t v8;
  vm_address_t v9;
  uint64_t reply_port;
  kern_return_t v11;
  kern_return_t v12;
  BOOL v13;
  mach_vm_offset_t v15;
  mach_msg_header_t v16;
  uint64_t v17;
  __int128 v18;
  int v19;

  v15 = *address;
  v8 = _kernelrpc_mach_vm_allocate_trap(target_task, &v15, size, flags);
  v9 = v15;
  if (v8 == 268435459)
  {
    v17 = 0x100000000;
    *(_QWORD *)&v18 = v15;
    *((_QWORD *)&v18 + 1) = size;
    v19 = flags;
    reply_port = mig_get_reply_port();
    *(_QWORD *)&v16.msgh_bits = 0x3400001513;
    *(_QWORD *)&v16.msgh_remote_port = __PAIR64__(reply_port, target_task);
    *(_QWORD *)&v16.msgh_voucher_port = 0x12C000000000;
    v11 = mach_msg2_internal(&v16, 0x200000003uLL, (void *)0x3400001513, (void *)__PAIR64__(reply_port, target_task), (void *)0x12C000000000, (void *)(reply_port << 32), (void *)0x34, 0);
    v12 = v11;
    if ((v11 - 268435458) <= 0xE && ((1 << (v11 - 2)) & 0x4003) != 0)
      goto LABEL_23;
    if (v11)
    {
      mig_dealloc_reply_port(v16.msgh_local_port);
LABEL_23:
      v9 = v15;
      goto LABEL_24;
    }
    if (v16.msgh_id == 71)
    {
      v12 = -308;
    }
    else if (v16.msgh_id == 4900)
    {
      if ((v16.msgh_bits & 0x80000000) == 0)
      {
        if (v16.msgh_size == 44)
        {
          if (!v16.msgh_remote_port)
          {
            v12 = v18;
            if (!(_DWORD)v18)
            {
              v15 = *(_QWORD *)((char *)&v18 + 4);
              goto LABEL_23;
            }
            goto LABEL_22;
          }
        }
        else if (v16.msgh_size == 36)
        {
          if (v16.msgh_remote_port)
            v13 = 1;
          else
            v13 = (_DWORD)v18 == 0;
          if (v13)
            v12 = -300;
          else
            v12 = v18;
          goto LABEL_22;
        }
      }
      v12 = -300;
    }
    else
    {
      v12 = -301;
    }
LABEL_22:
    mach_msg_destroy(&v16);
    goto LABEL_23;
  }
  v12 = v8;
LABEL_24:
  *address = v9;
  return v12;
}

kern_return_t _kernelrpc_mach_vm_allocate_trap(mach_port_name_t target, mach_vm_offset_t *addr, mach_vm_size_t size, int flags)
{
  return mac_syscall(KERNELRPC_MACH_VM_ALLOCATE_TRAP, target, addr, size, flags);
}

kern_return_t _kernelrpc_mach_vm_purgable_control_trap(mach_port_name_t target, mach_vm_offset_t address, vm_purgable_t control, int *state)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  return mac_syscall(-11, *(void **)&target, (void *)address, *(void **)&control, state, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_vm_deallocate_trap(mach_port_name_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  return mac_syscall(KERNELRPC_MACH_VM_DEALLOCATE_TRAP, target, address, size);
}

kern_return_t task_dyld_process_info_notify_get(mach_port_name_array_t names_addr, natural_t *names_count_addr)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  return mac_syscall(-13, names_addr, names_count_addr, v2, v3, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_vm_protect_trap(mach_port_name_t target, mach_vm_address_t address, mach_vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  return mac_syscall(KERNELRPC_MACH_VM_PROTECT_TRAP, target, address, size, set_maximum, new_protection);
}

kern_return_t _kernelrpc_mach_vm_map_trap(mach_port_name_t target, mach_vm_offset_t *address, mach_vm_size_t size, mach_vm_offset_t mask, int flags, vm_prot_t cur_protection)
{
  return mac_syscall(KERNELRPC_MACH_VM_MAP_TRAP, target, address, size, (mach_vm_offset_t *)mask, flags, cur_protection);
}

kern_return_t _kernelrpc_mach_port_allocate_trap(mach_port_name_t target, mach_port_right_t right, mach_port_name_t *name)
{
  return mac_syscall(KERNELRPC_MACH_PORT_ALLOCATE_TRAP, target, right, name);
}

kern_return_t _kernelrpc_mach_port_deallocate_trap(mach_port_name_t target, mach_port_name_t name)
{
  return mac_syscall(KERNELRPC_MACH_PORT_DEALLOCATE_TRAP, target, name);
}

kern_return_t _kernelrpc_mach_port_mod_refs_trap(mach_port_name_t target, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return mac_syscall(KERNELRPC_MACH_PORT_MOD_REFS_TRAP, target, name, right, delta);
}

kern_return_t _kernelrpc_mach_port_move_member_trap(mach_port_name_t target, mach_port_name_t member, mach_port_name_t after)
{
  return mac_syscall(KERNELRPC_MACH_PORT_MOVE_MEMBER_TRAP, target, member, after);
}

kern_return_t _kernelrpc_mach_port_insert_right_trap(mach_port_name_t target, mach_port_name_t name, mach_port_name_t poly, mach_msg_type_name_t polyPoly)
{
  return mac_syscall(KERNELRPC_MACH_PORT_INSERT_RIGHT_TRAP, target, name, poly, polyPoly);
}

kern_return_t _kernelrpc_mach_port_insert_member_trap(mach_port_name_t target, mach_port_name_t name, mach_port_name_t pset)
{
  return mac_syscall(KERNELRPC_MACH_PORT_INSERT_MEMBER_TRAP, target, name, pset);
}

kern_return_t _kernelrpc_mach_port_extract_member_trap(mach_port_name_t target, mach_port_name_t name, mach_port_name_t pset)
{
  return mac_syscall(KERNELRPC_MACH_PORT_EXTRACT_MEMBER_TRAP, target, name, pset);
}

kern_return_t _kernelrpc_mach_port_construct_trap(mach_port_name_t target, mach_port_options_t *options, uint64_t context, mach_port_name_t *name)
{
  return mac_syscall(KERNELRPC_MACH_PORT_CONSTRUCT_TRAP, target, options, context, name);
}

kern_return_t _kernelrpc_mach_port_destruct_trap(mach_port_name_t target, mach_port_name_t name, mach_port_delta_t srdelta, uint64_t guard)
{
  return mac_syscall(KERNELRPC_MACH_PORT_DESTRUCT_TRAP, target, name, srdelta, guard);
}

mach_port_name_t mach_reply_port()
{
  return mac_syscall(MACH_REPLY_PORT_TRAP);
}

mach_port_name_t thread_self_trap()
{
  return mac_syscall(THREAD_SELF_TRAP);
}

mach_port_name_t task_self_trap(void)
{
  return mac_syscall(TASK_SELF_TRAP);
}

mach_port_name_t host_self_trap()
{
  return mac_syscall(HOST_SELF_TRAP);
}

mach_msg_return_t mach_msg_trap(mach_msg_header_t *a1, mach_msg_option_t a2, mach_msg_size_t a3, mach_msg_size_t a4, mach_port_name_t a5, mach_msg_timeout_t a6, mach_port_name_t a7)
{
  return mac_syscall(MACH_MSG_TRAP, a1, a2, a3, a4, a5, a6, a7);
}

mach_msg_return_t mach_msg_overwrite_trap(mach_msg_header_t *a1, mach_msg_option_t a2, mach_msg_size_t a3, mach_msg_size_t a4, mach_port_name_t a5, mach_msg_timeout_t a6, mach_port_name_t a7, mach_msg_header_t *a8)
{
  return mac_syscall(MACH_MSG_OVERWRITE_TRAP, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t semaphore_signal_trap(mach_port_name_t a1)
{
  return mac_syscall(SEMAPHORE_SIGNAL_TRAP, a1);
}

kern_return_t semaphore_signal_all_trap(mach_port_name_t a1)
{
  return mac_syscall(SEMAPHORE_SIGNAL_ALL_TRAP, a1);
}

kern_return_t semaphore_signal_thread_trap(mach_port_name_t a1, mach_port_name_t a2)
{
  return mac_syscall(SEMAPHORE_SIGNAL_THREAD_TRAP, a1, a2);
}

kern_return_t semaphore_wait_trap(mach_port_name_t a1)
{
  return mac_syscall(SEMAPHORE_WAIT_TRAP, a1);
}

kern_return_t semaphore_wait_signal_trap(mach_port_name_t a1, mach_port_name_t a2)
{
  return mac_syscall(SEMAPHORE_WAIT_SIGNAL_TRAP, a1, a2);
}

kern_return_t semaphore_timedwait_trap(mach_port_name_t a1, unsigned int a2, clock_res_t a3)
{
  return mac_syscall(SEMAPHORE_TIMEDWAIT_TRAP, a1, a2, a3);
}

kern_return_t semaphore_timedwait_signal_trap(mach_port_name_t a1, mach_port_name_t a2, unsigned int a3, clock_res_t a4)
{
  return mac_syscall(SEMAPHORE_TIMEDWAIT_SIGNAL_TRAP, a1, a2, a3, a4);
}

kern_return_t _kernelrpc_mach_port_get_attributes_trap(mach_port_name_t target, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info_out, mach_msg_type_number_t *port_info_outCnt)
{
  void *v5;
  void *v6;
  void *v7;

  return mac_syscall(-40, *(void **)&target, *(void **)&name, *(void **)&flavor, port_info_out, port_info_outCnt, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_port_guard_trap(mach_port_name_t target, mach_port_name_t name, uint64_t guard, BOOLean_t strict)
{
  return mac_syscall(KERNELRPC_MACH_PORT_GUARD_TRAP, target, name, guard, strict);
}

kern_return_t _kernelrpc_mach_port_unguard_trap(mach_port_name_t target, mach_port_name_t name, uint64_t guard)
{
  return mac_syscall(KERNELRPC_MACH_PORT_UNGUARD_TRAP, target, name, guard);
}

kern_return_t mach_generate_activity_id(mach_port_name_t target, int count, uint64_t *activity_id)
{
  BOOLean_t v3;
  vm_size_t v4;

  return mac_syscall(MAP_FD_TRAP, target, *(vm_offset_t *)&count, activity_id, v3, v4);
}

kern_return_t task_name_for_pid(mach_port_name_t target_tport, int pid, mach_port_name_t *tn)
{
  return mac_syscall(TASK_NAME_FOR_PID_TRAP, target_tport, pid, tn);
}

kern_return_t task_for_pid(mach_port_name_t target_tport, int pid, mach_port_name_t *t)
{
  return mac_syscall(TASK_FOR_PID_TRAP, target_tport, pid, t);
}

kern_return_t pid_for_task(mach_port_name_t t, int *x)
{
  return mac_syscall(PID_FOR_TASK_TRAP, t, x);
}

int64_t mach_msg2_trap(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-47, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t macx_swapon(uint64_t filename, int flags, int size, int priority)
{
  return mac_syscall(MACX_SWAPON_TRAP, filename, flags, size, priority);
}

kern_return_t macx_swapoff(uint64_t filename, int flags)
{
  return mac_syscall(MACX_SWAPOFF_TRAP, filename, flags);
}

int64_t thread_get_special_reply_port(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-50, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t macx_triggers(int hi_water, int low_water, int flags, mach_port_t alert_port)
{
  return mac_syscall(MACX_TRIGGERS_TRAP, hi_water, low_water, flags, alert_port);
}

kern_return_t macx_backing_store_suspend(BOOLean_t suspend)
{
  return mac_syscall(MACX_BACKING_STORE_SUSPEND_TRAP, suspend);
}

kern_return_t macx_backing_store_recovery(int pid)
{
  return mac_syscall(MACX_BACKING_STORE_RECOVERY_TRAP, pid);
}

BOOLean_t swtch_pri(int pri)
{
  return mac_syscall(SWTCH_PRI_TRAP, pri);
}

BOOLean_t swtch(void)
{
  return mac_syscall(SWTCH_TRAP);
}

kern_return_t syscall_thread_switch(mach_port_name_t a1, int a2, mach_msg_timeout_t a3)
{
  return mac_syscall(THREAD_SWITCH_TRAP, a1, a2, a3);
}

kern_return_t clock_sleep_trap(mach_port_name_t clock_name, sleep_type_t sleep_type, int sleep_sec, int sleep_nsec, mach_timespec_t *wakeup_time)
{
  return mac_syscall(CLOCK_SLEEP_TRAP, clock_name, sleep_type, sleep_sec, sleep_nsec, (mach_timespec_t)wakeup_time);
}

kern_return_t host_create_mach_voucher_trap(mach_port_name_t host, mach_voucher_attr_raw_recipe_array_t recipes, int recipes_size, mach_port_name_t *voucher)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  return mac_syscall(-70, *(void **)&host, recipes, *(void **)&recipes_size, voucher, v4, v5, v6, v7);
}

kern_return_t mach_voucher_extract_attr_recipe_trap(mach_port_name_t voucher_name, mach_voucher_attr_key_t key, mach_voucher_attr_raw_recipe_t recipe, mach_msg_type_number_t *recipe_size)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  return mac_syscall(-72, *(void **)&voucher_name, *(void **)&key, recipe, recipe_size, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_port_type_trap(ipc_space_t task, mach_port_name_t name, mach_port_type_t *ptype)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  return mac_syscall(-76, *(void **)&task, *(void **)&name, ptype, v3, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_port_request_notification_trap(ipc_space_t task, mach_port_name_t name, mach_msg_id_t msgid, mach_port_mscount_t sync, mach_port_name_t notify, mach_msg_type_name_t notifyPoly, mach_port_name_t *previous)
{
  void *v7;

  return mac_syscall(-77, *(void **)&task, *(void **)&name, *(void **)&msgid, *(void **)&sync, *(void **)&notify, *(void **)&notifyPoly, previous, v7);
}

int64_t _exclaves_ctl_trap(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-88, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t mach_timebase_info_trap(mach_timebase_info *a1)
{
  return mac_syscall(MACH_TIMEBASE_INFO_TRAP, a1);
}

kern_return_t mach_wait_until(uint64_t deadline)
{
  return mac_syscall(MACH_WAIT_UNTIL_TRAP, deadline);
}

mach_port_name_t mk_timer_create()
{
  return mac_syscall(MK_TIMER_CREATE_TRAP);
}

kern_return_t mk_timer_destroy(mach_port_name_t a1)
{
  return mac_syscall(MK_TIMER_DESTROY_TRAP, a1);
}

kern_return_t mk_timer_arm(mach_port_name_t a1, uint64_t a2)
{
  return mac_syscall(MK_TIMER_ARM_TRAP, a1, a2);
}

kern_return_t mk_timer_cancel(mach_port_name_t a1, uint64_t a2)
{
  return mac_syscall(MK_TIMER_CANCEL_TRAP, a1, a2);
}

int64_t mk_timer_arm_leeway(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-95, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t debug_control_port_for_pid(mach_port_name_t target_tport, int pid, mach_port_name_t *t)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  return mac_syscall(-96, *(void **)&target_tport, *(void **)&pid, t, v3, v4, v5, v6, v7);
}

size_t _simple_sresize(uint64_t a1)
{
  const char *v2;
  size_t result;

  v2 = *(const char **)a1;
  result = _platform_strlen(*(const char **)a1);
  *(_QWORD *)(a1 + 8) = &v2[result];
  return result;
}

BOOL dyld_parse_boot_arg_cstr(char *a1, const char *a2, char *a3, size_t a4)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  int64_t v17;
  char *v18;
  _BOOL8 v19;
  char *v20;
  char *v21;
  int v22;
  const char *v23;
  BOOL v24;
  const char *v25;
  const char *v26;
  int v28[256];

  while (1)
  {
    _platform_memset(v28, 170, 0x400uLL);
    v8 = _platform_strchr(a1, 32);
    if (v8)
    {
      v16 = v8;
      v17 = v8 - a1;
      if (v17 < 0)
        dyld_halt("value not representable as size_t", v9, v10, v11, v12, v13, v14, v15, v28[0]);
      v18 = v16 + 1;
    }
    else
    {
      v17 = _platform_strlen(a1);
      v18 = 0;
    }
    v19 = (unint64_t)(v17 + 1) < 0x400;
    if ((unint64_t)(v17 + 1) > 0x3FF)
      break;
    strlcpy((char *)v28, a1, v17 + 1);
    v20 = _platform_strchr((char *)v28, 61);
    if (v20)
    {
      *v20 = 0;
      v22 = v20[1];
      v21 = v20 + 1;
      if (v22)
        v23 = v21;
      else
        v23 = 0;
    }
    else
    {
      v23 = 0;
    }
    if (v23)
      v24 = 0;
    else
      v24 = LOBYTE(v28[0]) == 45;
    if (v24)
      v25 = (char *)v28 + 1;
    else
      v25 = (const char *)v28;
    if (!_platform_strcmp(v25, a2))
    {
      if (a3)
      {
        if (v23)
          v26 = v23;
        else
          v26 = (const char *)&unk_1A5CBE413;
        strlcpy(a3, v26, a4);
      }
      return v19;
    }
    a1 = v18;
    if (!v18)
      return 0;
  }
  return v19;
}

char *__cdecl _platform_strchr(char *__s, int __c)
{
  int8x16_t v2;
  uint64_t v3;
  unint64_t v4;
  int8x16_t v5;
  uint8x16_t i;
  int8x16_t v7;
  uint8x16_t v8;
  char *result;

  v2 = vdupq_n_s8(__c);
  v3 = __s & 0xF;
  v4 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0;
  v5 = *(int8x16_t *)&algn_1A5C5E670[-v3];
  for (i = (uint8x16_t)vorrq_s8(vbicq_s8(*(int8x16_t *)v4, vceqq_s8(*(int8x16_t *)v4, v2)), v5);
        ;
        i = (uint8x16_t)vbicq_s8(v7, v5))
  {
    v5.i8[0] = vminvq_u8(i);
    if (!v5.i32[0])
      break;
    v7 = *(int8x16_t *)(v4 + 16);
    v4 += 16;
    v5 = vceqq_s8(v7, v2);
  }
  v8 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(i, (uint8x16_t)veorq_s8(v5, v5)), (int8x16_t)xmmword_1A5C5E660);
  v8.i8[0] = vminvq_u8(v8);
  result = (char *)(v4 + v8.u32[0]);
  if (__c != (unint64_t)*result)
    return 0;
  return result;
}

__n128 dyld4::JustInTimeLoader::fileID@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a1 + 56);
  v3 = *(_OWORD *)(a1 + 72);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

std::ios_base *__cdecl hex(std::ios_base *__str)
{
  uint64_t (*v1)(uint64_t);
  unint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t (*v9)(uint64_t);
  const char *v11;
  const char *v12;
  BOOL v13;
  char *v14;
  unsigned __int8 v15;
  _BYTE *v16;
  char v17;
  unsigned __int8 *v18;
  _BYTE *v19;
  int v20;
  unsigned __int8 *v21;
  unsigned __int8 v22;
  char v23;
  std::ios_base *result;
  int v25;
  uint64_t v26;
  char v27;
  unsigned __int8 *v28;
  _BYTE *v29;
  int v30;
  _BYTE *v31;
  char *v33;
  unsigned __int8 v34;
  char v35;
  unsigned __int8 *v36;
  _BYTE *v37;
  int v38;
  unsigned __int8 *v39;
  unsigned __int8 v40;
  char v41;
  unsigned __int8 *v42;
  _BYTE *v43;
  int v44;
  char *v45;
  char v46;
  char v47;
  char v48;

  v7 = v4;
  v8 = v3;
  v9 = v1;
  v11 = "0123456789ABCDEF";
  if (!v5)
    v11 = "0123456789abcdef";
  v48 = 0;
  if (v2)
  {
    v12 = &v48;
    do
    {
      *--v12 = v11[v2 & 0xF];
      v13 = v2 >= 0x10;
      v2 >>= 4;
    }
    while (v13);
    if (!v6)
      goto LABEL_23;
  }
  else
  {
    v12 = &v47;
    v47 = 48;
    if (!v6)
    {
LABEL_23:
      v23 = 1;
      goto LABEL_25;
    }
  }
  v8 = v3 - 2;
  if (v4)
  {
    v14 = (char *)&_0x;
    v15 = 48;
    do
    {
      if (v9 && (v16 = (_BYTE *)v9(v15)) != 0)
      {
        v17 = *v16;
        if (*v16)
        {
          v18 = v16 + 1;
          do
          {
            v19 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v19 >= __str->__precision_)
            {
              (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
              v19 = *(_BYTE **)&__str->__fmtflags_;
            }
            *(_QWORD *)&__str->__fmtflags_ = v19 + 1;
            *v19 = v17;
            v20 = *v18++;
            v17 = v20;
          }
          while (v20);
        }
      }
      else
      {
        v21 = *(unsigned __int8 **)&__str->__fmtflags_;
        if ((unint64_t)v21 >= __str->__precision_)
        {
          (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
          v21 = *(unsigned __int8 **)&__str->__fmtflags_;
        }
        *(_QWORD *)&__str->__fmtflags_ = v21 + 1;
        *v21 = v15;
      }
      v22 = *++v14;
      v15 = v22;
    }
    while (v14 != (char *)&unk_1A5CBC298);
    goto LABEL_23;
  }
  v23 = 0;
LABEL_25:
  result = (std::ios_base *)_platform_strlen(v12);
  v25 = v8 - (_DWORD)result;
  if (v25 >= 1)
  {
    if (v7)
      v26 = 48;
    else
      v26 = 32;
    do
    {
      if (v9 && (result = (std::ios_base *)v9(v26)) != 0)
      {
        v27 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          v28 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            v29 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v29 >= __str->__precision_)
            {
              result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              v29 = *(_BYTE **)&__str->__fmtflags_;
            }
            *(_QWORD *)&__str->__fmtflags_ = v29 + 1;
            *v29 = v27;
            v30 = *v28++;
            v27 = v30;
          }
          while (v30);
        }
      }
      else
      {
        v31 = *(_BYTE **)&__str->__fmtflags_;
        if ((unint64_t)v31 >= __str->__precision_)
        {
          result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          v31 = *(_BYTE **)&__str->__fmtflags_;
        }
        *(_QWORD *)&__str->__fmtflags_ = v31 + 1;
        *v31 = v26;
      }
    }
    while (v25-- > 1);
  }
  if ((v23 & 1) == 0)
  {
    v33 = (char *)&_0x;
    v34 = 48;
    do
    {
      if (v9 && (result = (std::ios_base *)v9(v34)) != 0)
      {
        v35 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          v36 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            v37 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v37 >= __str->__precision_)
            {
              result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              v37 = *(_BYTE **)&__str->__fmtflags_;
            }
            *(_QWORD *)&__str->__fmtflags_ = v37 + 1;
            *v37 = v35;
            v38 = *v36++;
            v35 = v38;
          }
          while (v38);
        }
      }
      else
      {
        v39 = *(unsigned __int8 **)&__str->__fmtflags_;
        if ((unint64_t)v39 >= __str->__precision_)
        {
          result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          v39 = *(unsigned __int8 **)&__str->__fmtflags_;
        }
        *(_QWORD *)&__str->__fmtflags_ = v39 + 1;
        *v39 = v34;
      }
      v40 = *++v33;
      v34 = v40;
    }
    while (v33 != (char *)&unk_1A5CBC298);
  }
  while (1)
  {
    v46 = *v12;
    if (!*v12)
      break;
    if (v9 && (result = (std::ios_base *)v9(*(unsigned __int8 *)v12)) != 0)
    {
      v41 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        v42 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          v43 = *(_BYTE **)&__str->__fmtflags_;
          if ((unint64_t)v43 >= __str->__precision_)
          {
            result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            v43 = *(_BYTE **)&__str->__fmtflags_;
          }
          *(_QWORD *)&__str->__fmtflags_ = v43 + 1;
          *v43 = v41;
          v44 = *v42++;
          v41 = v44;
        }
        while (v44);
      }
    }
    else
    {
      v45 = *(char **)&__str->__fmtflags_;
      if ((unint64_t)v45 >= __str->__precision_)
      {
        result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        v45 = *(char **)&__str->__fmtflags_;
      }
      *(_QWORD *)&__str->__fmtflags_ = v45 + 1;
      *v45 = v46;
    }
    ++v12;
  }
  return result;
}

void dyld4::PrebuiltLoader::BindTargetRef::loaderRef(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_2_1("loaderRef", "PrebuiltLoader.cpp", a3, "_regular.kind == 0");
}

dyld4::PrebuiltLoader *dyld4::Loader::makeDiskLoader(vm_address_t *a1, dyld4::RuntimeState *a2, char *a3, uint64_t a4, int a5, unsigned int a6, uint64_t a7)
{
  dyld4::PrebuiltLoader *result;
  uint64_t v15;
  unsigned int v16;

  if (*(_BYTE *)(a4 + 5))
    return 0;
  result = dyld4::RuntimeState::findPrebuiltLoader(a2, a3);
  if (!result)
  {
    if (a5)
    {
      v15 = *((_QWORD *)a2 + 1);
      if (*(_BYTE *)(v15 + 157))
      {
        v16 = 0;
        if (dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(v15 + 240), a3, &v16))
          a6 = v16;
      }
    }
    return (dyld4::PrebuiltLoader *)dyld4::JustInTimeLoader::makeJustInTimeLoaderDisk(a1, (uint64_t)a2, (dyld3 *)a3, a4, a5, a6, a7);
  }
  return result;
}

uint64_t dyld4::JustInTimeLoader::makeJustInTimeLoaderDisk(vm_address_t *a1, uint64_t a2, dyld3 *a3, uint64_t a4, char a5, int a6, uint64_t a7)
{
  int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v18[10];
  int v19;
  char v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;

  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = 0;
  v14 = dyld3::GradedArchs::checksOSBinary(*(dyld3::GradedArchs **)(*(_QWORD *)(a2 + 8) + 144));
  v15 = *(_QWORD *)(a2 + 8);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  v18[2] = ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke;
  v18[3] = &unk_1E4F7D468;
  v18[6] = a3;
  v18[7] = a2;
  v18[4] = &v21;
  v18[5] = a1;
  v20 = a5;
  v19 = a6;
  v18[8] = a4;
  v18[9] = a7;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(v15, a1, a3, v14, (uint64_t)v18);
  v16 = v22[3];
  _Block_object_dispose(&v21, 8);
  return v16;
}

uint64_t dyld3::GradedArchs::checksOSBinary(dyld3::GradedArchs *this)
{
  uint64_t i;
  int v2;

  for (i = 0; i != 48; i += 12)
  {
    v2 = *(_DWORD *)((char *)this + i);
    if (!v2)
      break;
    LOBYTE(v2) = *((_BYTE *)this + i + 8);
    if ((_BYTE)v2)
    {
      LOBYTE(v2) = 1;
      return v2 & 1;
    }
  }
  return v2 & 1;
}

BOOL dyld4::EqualMetadataConformanceLookupKey::equal(uint64_t a1, uint64_t a2, uint64_t a3, dyld4::RuntimeState *a4)
{
  uint64_t v7;

  if (!a4)
    dyld4::EqualMetadataConformanceLookupKey::equal();
  return dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)a1, a4, a3) == a2
      && dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8), a4, v7) == a3;
}

const char *dyld4::ProcessConfig::PathOverrides::typeName(unsigned int a1)
{
  if (a1 > 0xF)
    return "unknown";
  else
    return (&off_1E4F7C888)[a1];
}

void dyld4::halt(char *__source, uint64_t *a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v8;
  const char *v9;
  const char *v10;
  char __dst[1024];
  int v12;
  uint64_t v13;
  uint64_t v14;
  char v15[2028];

  strlcpy(dyld4::error_string, __source, 0x400uLL);
  qword_1EE805DD0 = (uint64_t)dyld4::error_string;
  dyld4::console((dyld4 *)"%s\n", v4, __source);
  v12 = 1;
  v14 = 0;
  v13 = 0;
  if (a2)
  {
    v6 = *a2;
    if (*a2 == 4 || v6 == 1)
      LODWORD(v13) = 1;
    v8 = (const char *)a2[2];
    v5 = 20;
    if (v8)
    {
      HIDWORD(v13) = 20;
      v5 = strlcpy(v15, v8, 0x7ECuLL) + 21;
    }
    v9 = (const char *)a2[1];
    if (v9)
    {
      LODWORD(v14) = v5;
      v5 = v5 + strlcpy((char *)&v12 + (int)v5, v9, 2048 - (int)v5) + 1;
    }
    v10 = (const char *)a2[3];
    if (v10)
    {
      HIDWORD(v14) = v5;
      v5 = v5 + strlcpy((char *)&v12 + (int)v5, v10, 2048 - (int)v5) + 1;
    }
  }
  else
  {
    v5 = 20;
    v6 = 9;
  }
  strlcpy(__dst, __source, 0x400uLL);
  abort_with_payload((void *)6, (void *)v6, &v12, (void *)v5, __dst, 0);
}

BOOL dyld4::APIs::dyld_shared_cache_some_image_overridden(dyld4::APIs *this)
{
  int v1;

  v1 = *((unsigned __int8 *)this + 1158);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_shared_cache_some_image_overridden() => %d\n", *((unsigned __int8 *)this + 1158));
  return v1 != 0;
}

uint64_t ___ZN5dyld44APIs28_dyld_get_image_vmaddr_slideEj_block_invoke(uint64_t result)
{
  const dyld4::RuntimeState *v1;
  unint64_t v2;
  uint64_t v3;
  dyld3::MachOLoaded *Address;

  v1 = *(const dyld4::RuntimeState **)(result + 40);
  v2 = *(unsigned int *)(result + 48);
  if (*((_QWORD *)v1 + 6) > v2)
  {
    v3 = result;
    Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*(dyld4::Loader **)(*((_QWORD *)v1 + 5) + 8 * v2), v1);
    result = dyld3::MachOLoaded::getSlide(Address);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t dyld4::PrebuiltLoaderSet::isValid(dyld4::PrebuiltLoaderSet *this, dyld4::RuntimeState *a2)
{
  const char *v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  DyldSharedCache *v8;
  const char *v9;
  double v10;
  uint64_t MustBeMissingPath;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  char v18;
  uint64_t v19;
  unsigned __int8 *v20;
  _QWORD v23[7];
  __n128 v24;
  uint64_t v25;
  char v26;
  __int128 v27;

  if (!dyld4::PrebuiltLoaderSet::validHeader(this, a2))
    return 0;
  v5 = *((unsigned int *)this + 7);
  if ((_DWORD)v5)
  {
    v6 = *(_OWORD *)((char *)this + v5);
    v27 = v6;
    v7 = *((_QWORD *)a2 + 1);
    v8 = *(DyldSharedCache **)(v7 + 240);
    if (!v8)
    {
      if (*(_BYTE *)(v7 + 207))
        dyld4::console((dyld4 *)"not using PrebuiltLoaderSet %p because process does not have a dyld cache\n", v4, *(double *)&v6, this);
      return 0;
    }
    v24 = 0uLL;
    *(_QWORD *)&v10 = DyldSharedCache::getUUID(v8, &v24).n128_u64[0];
    if ((_QWORD)v27 != v24.n128_u64[0] || *((_QWORD *)&v27 + 1) != v24.n128_u64[1])
    {
      if (*(_BYTE *)(*((_QWORD *)a2 + 1) + 207))
        dyld4::console((dyld4 *)"not using PrebuiltLoaderSet %p because cache UUID does not match\n", v9, v10, this);
      return 0;
    }
  }
  v24.n128_u64[0] = 0;
  v24.n128_u64[1] = (unint64_t)&v24;
  v25 = 0x2000000000;
  v26 = 0;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  v23[2] = ___ZNK5dyld417PrebuiltLoaderSet7isValidERNS_12RuntimeStateE_block_invoke;
  v23[3] = &unk_1E4F7D638;
  v23[5] = this;
  v23[6] = a2;
  v23[4] = &v24;
  MustBeMissingPath = dyld4::PrebuiltLoaderSet::forEachMustBeMissingPath((size_t)this, (uint64_t)v23);
  v15 = 0;
  if (!*(_BYTE *)(v24.n128_u64[1] + 24))
  {
    v16 = *((_DWORD *)this + 3);
    if (!v16)
      goto LABEL_20;
    v17 = 0;
    v18 = 0;
    do
    {
      if (v16 <= (unsigned __int16)v17)
        dyld4::RuntimeState::findPrebuiltLoader(MustBeMissingPath, v13, v14);
      MustBeMissingPath = dyld4::PrebuiltLoader::isValid((dyld4::PrebuiltLoaderSet *)((char *)this+ *(unsigned int *)((char *)this+ 4 * (unsigned __int16)v17+ *((unsigned int *)this + 4))), a2, v14);
      v18 |= MustBeMissingPath ^ 1;
      ++v17;
      v16 = *((_DWORD *)this + 3);
    }
    while (v17 < v16);
    if ((v18 & 1) != 0)
    {
      v15 = 0;
    }
    else
    {
LABEL_20:
      v19 = *(unsigned int *)(*((_QWORD *)a2 + 1) + 392);
      if ((_DWORD)v19)
      {
        v20 = (unsigned __int8 *)*((_QWORD *)a2 + 125);
        do
        {
          if (*v20++)
            ++v16;
          --v19;
        }
        while (v19);
      }
      *((_DWORD *)a2 + 261) = v16;
      v15 = 1;
    }
  }
  _Block_object_dispose(&v24, 8);
  return v15;
}

dyld4::Loader *dyld4::Loader::makeDyldCacheLoader(vm_address_t *a1, dyld4::RuntimeState *a2, char *a3, uint64_t a4, int a5)
{
  dyld4::PrebuiltLoader *v5;
  int v8;
  dyld4::PrebuiltLoader *PrebuiltLoader;
  _DWORD *v13;

  if (*(_BYTE *)(a4 + 5))
    return 0;
  v8 = a4;
  PrebuiltLoader = dyld4::RuntimeState::findPrebuiltLoader(a2, a3);
  if (PrebuiltLoader)
  {
    v5 = PrebuiltLoader;
    v13 = (_DWORD *)dyld4::PrebuiltLoader::mf(PrebuiltLoader, a2);
    if ((dyld3::MachOFile::loadableIntoProcess(v13, *(_DWORD *)(*((_QWORD *)a2 + 1) + 68), a3, *(unsigned __int8 *)(*((_QWORD *)a2 + 1) + 168)) & 1) != 0)return v5;
  }
  return dyld4::JustInTimeLoader::makeJustInTimeLoaderDyldCache(a1, a2, a3, v8, a5);
}

uint64_t dyld3::MachOFile::loadableIntoProcess(_DWORD *a1, unsigned int a2, const char *a3, int a4)
{
  uint64_t v8;
  uint64_t v10;
  _DWORD *v11;
  int v12;
  _DWORD *v13;
  int v14;
  unint64_t v15;

  if (!dyld3::MachOFile::builtForPlatform(a1, a2, 0))
  {
    if (a2 <= 0xC && ((1 << a2) & 0x1380) != 0)
    {
      if (dyld3::MachOFile::builtForPlatform(a1, 1, 0))
      {
        v10 = 0;
        while (_platform_strcmp(dyld3::MachOFile::loadableIntoProcess(dyld3::Platform,char const*,BOOL)const::macOSHost[v10], a3))
        {
          if (++v10 == 6)
            goto LABEL_10;
        }
        return 1;
      }
    }
    else
    {
LABEL_10:
      if (a2 == 1 && a1[3] == 2)
      {
        v8 = 1;
        v11 = a1;
        v12 = 6;
        goto LABEL_17;
      }
    }
    if (a2 == 7)
    {
      v8 = 1;
      v11 = a1;
      v12 = 12;
    }
    else
    {
      if (a2 != 2)
        goto LABEL_18;
      v8 = 1;
      v11 = a1;
      v12 = 11;
    }
LABEL_17:
    if (dyld3::MachOFile::builtForPlatform(v11, v12, 1))
      return v8;
LABEL_18:
    if (!a4)
    {
LABEL_33:
      if (a2 == 6)
      {
LABEL_34:
        v8 = 1;
        if (dyld3::MachOFile::builtForPlatform(a1, 1, 1))
          return v8;
      }
      return 0;
    }
    if (a2 == 12)
    {
      v8 = 1;
      v13 = a1;
      v14 = 7;
    }
    else
    {
      if (a2 != 11)
        goto LABEL_24;
      v8 = 1;
      v13 = a1;
      v14 = 2;
    }
    if (dyld3::MachOFile::builtForPlatform(v13, v14, 1))
      return v8;
LABEL_24:
    HIDWORD(v15) = a2;
    LODWORD(v15) = a2 - 6;
    switch((v15 >> 1))
    {
      case 0u:
        goto LABEL_34;
      case 5u:
        v8 = 1;
        if (dyld3::MachOFile::builtForPlatform(a1, 1, 0))
          return v8;
        if (a2 == 6)
          goto LABEL_34;
        if (a2 == 20)
          goto LABEL_32;
        if (a2 != 18)
          return 0;
LABEL_29:
        v8 = 1;
        if (dyld3::MachOFile::builtForPlatform(a1, 2, 1))
          return v8;
        if (a2 == 6)
          goto LABEL_34;
        if (a2 != 20)
          return 0;
LABEL_32:
        v8 = 1;
        if (!dyld3::MachOFile::builtForPlatform(a1, 3, 1))
          goto LABEL_33;
        return v8;
      case 6u:
        goto LABEL_29;
      case 7u:
        goto LABEL_32;
      default:
        return 0;
    }
  }
  return 1;
}

BOOL dyld3::MachOFile::builtForPlatform(_DWORD *a1, int a2, int a3)
{
  _BOOL8 v6;
  _QWORD v8[6];
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld39MachOFile16builtForPlatformENS_8PlatformEb_block_invoke;
  v8[3] = &unk_1E4F7E898;
  v9 = a2;
  v8[4] = &v14;
  v8[5] = &v10;
  dyld3::MachOFile::forEachSupportedPlatform(a1, (uint64_t)v8);
  if (!*((_BYTE *)v11 + 24) || (v6 = 0, !a3))
  {
    if (*((_BYTE *)v15 + 24))
    {
      v6 = 1;
    }
    else
    {
      v6 = 0;
      if (a2 == 1 && !*((_BYTE *)v11 + 24))
        v6 = ((a1[1] - 7) & 0xFEFFFFFF) == 0;
    }
  }
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
  return v6;
}

void dyld3::MachOFile::forEachSupportedPlatform(_DWORD *a1, uint64_t a2)
{
  _QWORD v4[7];
  _QWORD v5[3];
  char v6;
  vm_address_t *v7;

  Diagnostics::Diagnostics((Diagnostics *)&v7);
  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x2000000000;
  v6 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile24forEachSupportedPlatformEU13block_pointerFvNS_8PlatformEjjE_block_invoke;
  v4[3] = &unk_1E4F7E8F0;
  v4[5] = v5;
  v4[6] = a1;
  v4[4] = a2;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v7, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v7);
  _Block_object_dispose(v5, 8);
  mach_o::Error::~Error(&v7);
}

dyld4::PrebuiltLoader *dyld4::RuntimeState::findPrebuiltLoader(dyld4::RuntimeState *this, const char *__s2)
{
  uint64_t hasImagePath;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  dyld4::PrebuiltLoader *v8;
  dyld4::PrebuiltLoaderSet *v9;
  dyld4::PrebuiltLoader *Loader;
  uint64_t v11;
  unsigned int v13;

  v13 = 0;
  if (!*((_QWORD *)this + 124))
    goto LABEL_5;
  hasImagePath = DyldSharedCache::hasImagePath(*(DyldSharedCache **)(*((_QWORD *)this + 1) + 240), __s2, &v13);
  if (!(_DWORD)hasImagePath)
    goto LABEL_5;
  v7 = *((_QWORD *)this + 124);
  if (*(_DWORD *)(v7 + 12) <= (unsigned __int16)v13)
    dyld4::RuntimeState::findPrebuiltLoader(hasImagePath, v5, v6);
  v8 = (dyld4::PrebuiltLoader *)(v7 + *(unsigned int *)(v7 + *(unsigned int *)(v7 + 16) + 4 * (unsigned __int16)v13));
  if (!dyld4::PrebuiltLoader::isValid(v8, this, v6))
  {
LABEL_5:
    v9 = (dyld4::PrebuiltLoaderSet *)*((_QWORD *)this + 127);
    if (!v9)
      return 0;
    Loader = (dyld4::PrebuiltLoader *)dyld4::PrebuiltLoaderSet::findLoader(v9, this, __s2);
    if (!Loader)
      return 0;
    v8 = Loader;
    if (!dyld4::PrebuiltLoader::isValid(Loader, this, v11))
      return 0;
  }
  return v8;
}

BOOL dyld4::PrebuiltLoader::isValid(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2, uint64_t a3)
{
  __int16 v3;
  __int16 v4;
  char *v5;
  int v6;
  _BOOL8 v7;
  dyld4::PrebuiltLoader *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int i;
  uint64_t v16;
  __int16 v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int j;
  uint64_t v23;
  __int16 v24;
  char *v25;
  uint64_t v26;
  dyld4::PrebuiltLoader **v27;
  uint64_t v28;
  dyld4::PrebuiltLoader *v29;
  char v30;
  _WORD **v31;
  uint64_t v32;
  __int16 v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  __int16 v43;
  char *v44;
  _QWORD v45[2];
  uint64_t v46;
  vm_address_t address;
  vm_size_t size;
  char v49;

  v3 = *((_WORD *)this + 3);
  v4 = v3;
  v5 = (char *)a2 + 1024;
  if (v3 >= 0)
    v5 = (char *)a2 + 1000;
  v6 = *(unsigned __int8 *)(*(_QWORD *)v5 + (v3 & 0x7FFF));
  if ((v6 - 2) < 8)
    return 1;
  if (v6 == 255)
    return 0;
  v10 = this;
  v11 = *(unsigned __int8 *)(*((_QWORD *)a2 + 1) + 399);
  if (!v6)
  {
    this = (dyld4::PrebuiltLoader *)dyld4::PrebuiltLoader::recursiveMarkBeingValidated(this, a2, v11 == 0);
    v4 = *((_WORD *)v10 + 3);
  }
  v12 = 0;
  v45[0] = &v49;
  v45[1] = 1024;
  address = 0;
  size = 0;
  v46 = 0;
  if ((v4 & 0x8000) == 0)
  {
LABEL_19:
    if (!v11)
      goto LABEL_29;
    goto LABEL_20;
  }
  v13 = *((_QWORD *)a2 + 127);
  v14 = *(_DWORD *)(v13 + 12);
  if (v14)
  {
    v12 = 0;
    for (i = 0; i < v14; ++i)
    {
      if (v14 <= (unsigned __int16)i)
        dyld4::RuntimeState::findPrebuiltLoader((uint64_t)this, (uint64_t)a2, a3);
      v16 = v13 + *(unsigned int *)(v13 + *(unsigned int *)(v13 + 16) + 4 * (unsigned __int16)i);
      v17 = *(_WORD *)(v16 + 6);
      if (v17 >= 0)
        v18 = (char *)a2 + 1000;
      else
        v18 = (char *)a2 + 1024;
      if (*(_BYTE *)(*(_QWORD *)v18 + (v17 & 0x7FFF)) == 1)
      {
        this = (dyld4::PrebuiltLoader *)dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v45, 1);
        v19 = v46;
        v12 = ++v46;
        *(_QWORD *)(v45[0] + 8 * v19) = v16;
        v14 = *(_DWORD *)(v13 + 12);
      }
    }
    goto LABEL_19;
  }
  v12 = 0;
  if (!v11)
    goto LABEL_29;
LABEL_20:
  v20 = *((_QWORD *)a2 + 124);
  v21 = *(_DWORD *)(v20 + 12);
  if (v21)
  {
    for (j = 0; j < v21; ++j)
    {
      if (v21 <= (unsigned __int16)j)
        dyld4::RuntimeState::findPrebuiltLoader((uint64_t)this, (uint64_t)a2, a3);
      v23 = v20 + *(unsigned int *)(v20 + *(unsigned int *)(v20 + 16) + 4 * (unsigned __int16)j);
      v24 = *(_WORD *)(v23 + 6);
      if (v24 >= 0)
        v25 = (char *)a2 + 1000;
      else
        v25 = (char *)a2 + 1024;
      if (*(_BYTE *)(*(_QWORD *)v25 + (v24 & 0x7FFF)) == 1)
      {
        this = (dyld4::PrebuiltLoader *)dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v45, 1);
        v26 = v46;
        v12 = ++v46;
        *(_QWORD *)(v45[0] + 8 * v26) = v23;
        v21 = *(_DWORD *)(v20 + 12);
      }
    }
  }
LABEL_29:
  if (v12)
  {
    v27 = (dyld4::PrebuiltLoader **)v45[0];
    v28 = 8 * v12;
    do
    {
      v29 = *v27++;
      dyld4::PrebuiltLoader::invalidateInIsolation(v29, a2);
      v28 -= 8;
    }
    while (v28);
  }
  while (v46)
  {
    v30 = 0;
    v31 = (_WORD **)v45[0];
    v32 = 8 * v46;
    do
    {
      v33 = (*v31)[3];
      if (v33 >= 0)
        v34 = (char *)a2 + 1000;
      else
        v34 = (char *)a2 + 1024;
      v35 = *(_QWORD *)v34;
      v36 = v33 & 0x7FFF;
      if (*(_BYTE *)(*(_QWORD *)v34 + v36) == 1)
      {
        dyld4::PrebuiltLoader::invalidateShallow(*v31, a2);
        if (*(_BYTE *)(v35 + v36) != 1)
          v30 = 1;
      }
      ++v31;
      v32 -= 8;
    }
    while (v32);
    if ((v30 & 1) == 0)
    {
      if (v46)
      {
        v37 = v45[0];
        v38 = 8 * v46;
        do
        {
          v39 = *(_WORD *)(*(_QWORD *)v37 + 6);
          if (v39 >= 0)
            v40 = (char *)a2 + 1000;
          else
            v40 = (char *)a2 + 1024;
          v41 = *(_QWORD *)v40;
          v42 = v39 & 0x7FFF;
          if (*(_BYTE *)(v41 + v42) == 1)
            *(_BYTE *)(v41 + v42) = 2;
          v37 += 8;
          v38 -= 8;
        }
        while (v38);
      }
      break;
    }
  }
  v43 = *((_WORD *)v10 + 3);
  if (v43 >= 0)
    v44 = (char *)a2 + 1000;
  else
    v44 = (char *)a2 + 1024;
  v7 = *(unsigned __int8 *)(*(_QWORD *)v44 + (v43 & 0x7FFF)) != 255;
  v46 = 0;
  if (address)
    vm_deallocate(mach_task_self_, address, size);
  return v7;
}

_WORD *dyld4::PrebuiltLoader::invalidateShallow(_WORD *this, const dyld4::RuntimeState *a2)
{
  _WORD *v3;
  uint64_t v4;
  __int16 v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v8;

  if (this[24])
  {
    v3 = this;
    v4 = 0;
    do
    {
      this = (_WORD *)dyld4::PrebuiltLoader::dependent(v3, a2, v4, 0);
      if (this && (this[2] & 1) != 0)
      {
        v5 = this[3];
        v6 = *((_QWORD *)a2 + 128);
        v7 = v5 >= 0 ? *((_QWORD *)a2 + 125) : *((_QWORD *)a2 + 128);
        if (*(unsigned __int8 *)(v7 + (v5 & 0x7FFF)) == 255)
        {
          v8 = v3[3];
          if (v8 >= 0)
            v6 = *((_QWORD *)a2 + 125);
          *(_BYTE *)(v6 + (v8 & 0x7FFF)) = -1;
        }
      }
      v4 = (v4 + 1);
    }
    while (v4 < (unsigned __int16)v3[24]);
  }
  return this;
}

void dyld4::PrebuiltLoader::invalidateInIsolation(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2)
{
  __int16 v2;
  char *v3;
  uint64_t v4;
  unint64_t v5;
  __int16 v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  dyld3 *v14;
  uint64_t v15;
  dyld4::ProcessConfig::DyldCache *v16;
  unint64_t v17;
  dyld4::Utils *v18;
  dyld3 *v19;
  const char **v20;
  int v21;
  const char *v22;
  int v23;
  char *v24;
  const char *v25;
  size_t v26;
  dyld4::SyscallDelegate *v27;
  const char *v28;
  char *v32;
  const char *v33;
  char *v34;
  const char *v35;
  _QWORD v36[7];
  char v37;
  __int128 v38;
  __int128 v39;

  v2 = *((_WORD *)this + 3);
  if (v2 >= 0)
    v3 = (char *)a2 + 1000;
  else
    v3 = (char *)a2 + 1024;
  v4 = *(_QWORD *)v3;
  v5 = v2 & 0x7FFF;
  if (*(unsigned __int8 *)(*(_QWORD *)v3 + v5) > 1u)
    return;
  v8 = *((_WORD *)this + 2);
  if ((v8 & 2) != 0)
  {
    v15 = *((_QWORD *)a2 + 1);
    if (!*(_QWORD *)(v15 + 240))
    {
      *(_BYTE *)(v4 + v5) = -1;
      return;
    }
    if ((*((_WORD *)this + 22) & 2) != 0)
    {
      if (!*(_BYTE *)(v15 + 396))
      {
        if (*((_WORD *)this + 16))
          v16 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
        else
          v16 = 0;
        if (!dyld4::ProcessConfig::DyldCache::isAlwaysOverridablePath(v16, (const char *)a2))
          return;
        v15 = *((_QWORD *)a2 + 1);
        v8 = *((_WORD *)this + 2);
      }
      *(_QWORD *)&v38 = 0;
      *((_QWORD *)&v38 + 1) = &v38;
      *(_QWORD *)&v39 = 0x2000000000;
      BYTE8(v39) = 0;
      v37 = 0;
      if ((v8 & 2) != 0 || (v17 = *((_WORD *)this + 3) & 0x7FFF, *((_QWORD *)a2 + 42) <= v17))
      {
        if (*((_WORD *)this + 16))
          v18 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
        else
          v18 = 0;
      }
      else
      {
        v18 = *(dyld4::Utils **)(*((_QWORD *)a2 + 41) + 8 * v17);
      }
      v33 = (const char *)*(unsigned int *)(v15 + 68);
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 0x40000000;
      v36[2] = ___ZNK5dyld414PrebuiltLoader21invalidateInIsolationERKNS_12RuntimeStateE_block_invoke;
      v36[3] = &unk_1E4F7D4D8;
      v36[5] = this;
      v36[6] = a2;
      v36[4] = &v38;
      dyld4::ProcessConfig::PathOverrides::forEachPathVariant(v15 + 400, v18, v33, 0, 1, &v37, (uint64_t)v36);
      if (*(_BYTE *)(*((_QWORD *)&v38 + 1) + 24))
      {
        if (*(_BYTE *)(*((_QWORD *)a2 + 1) + 207))
        {
          v34 = dyld4::Loader::leafName(this, a2);
          dyld4::console((dyld4 *)"PrebuiltLoader %p '%s' not used because a file was found that overrides it\n", v35, this, v34);
        }
        *(_BYTE *)(v4 + v5) = -1;
      }
      _Block_object_dispose(&v38, 8);
    }
  }
  else if (*((_WORD *)this + 21) && (v9 = (char *)this + *((unsigned __int16 *)this + 21), v9[52]))
  {
    v11 = *((_QWORD *)v9 + 1);
    v10 = *((_QWORD *)v9 + 2);
    v12 = *((_QWORD *)v9 + 3);
    v38 = 0u;
    v39 = 0u;
    v13 = *((_QWORD *)a2 + 1);
    if (*((_QWORD *)a2 + 42) <= v5)
    {
      if (*((_WORD *)this + 16))
        v14 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
      else
        v14 = 0;
    }
    else
    {
      v14 = *(dyld3 **)(*((_QWORD *)a2 + 41) + 8 * v5);
    }
    if (!dyld4::SyscallDelegate::fileExists(v13, v14, (uint64_t)&v38, 0))
    {
      *(_BYTE *)(v4 + v5) = -1;
      if (!*(_BYTE *)(*((_QWORD *)a2 + 1) + 207))
        return;
      v32 = "PrebuiltLoader %p not used because file missing\n";
LABEL_55:
      dyld4::console((dyld4 *)v32, v28, this);
      return;
    }
    if (*((_QWORD *)&v38 + 1) != v11 || BYTE8(v39) == 0 || (_QWORD)v38 != v10 || (_QWORD)v39 != v12)
    {
      *(_BYTE *)(v4 + v5) = -1;
      if (*(_BYTE *)(*((_QWORD *)a2 + 1) + 207))
      {
        v32 = "PrebuiltLoader %p not used because file inode/mtime does not match\n";
        goto LABEL_55;
      }
    }
  }
  else
  {
    if (*((_QWORD *)a2 + 42) <= v5)
    {
      if (*((_WORD *)this + 16))
        v19 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
      else
        v19 = 0;
    }
    else
    {
      v19 = *(dyld3 **)(*((_QWORD *)a2 + 41) + 8 * v5);
    }
    v20 = (const char **)*((_QWORD *)a2 + 1);
    if (_platform_strcmp((const char *)v19, v20[2]))
    {
      v21 = dyld4::SyscallDelegate::open((dyld4::SyscallDelegate *)v20, v19, 0, 0);
      if (v21 == -1)
      {
        *(_BYTE *)(v4 + v5) = -1;
        if (*(_BYTE *)(*((_QWORD *)a2 + 1) + 207))
          dyld4::console((dyld4 *)"PrebuiltLoader %p not used because file '%s' cannot be opened\n", v22, this, v19);
      }
      else
      {
        v23 = v21;
        Diagnostics::Diagnostics((Diagnostics *)&v38);
        if (*((_WORD *)this + 21))
          v24 = (char *)this + *((unsigned __int16 *)this + 21);
        else
          v24 = 0;
        v26 = dyld4::Loader::validateFile((vm_address_t *)&v38, (uint64_t)a2, v23, (const char *)v19, (unsigned int *)this + 20, (uint64_t)v24);
        v27 = (dyld4::SyscallDelegate *)*((_QWORD *)a2 + 1);
        if (v26 == -1)
        {
          *(_BYTE *)(v4 + v5) = -1;
          if (*((_BYTE *)v27 + 207))
          {
            dyld4::console((dyld4 *)"PrebuiltLoader %p not used because file '%s' cdHash changed\n", v25, this, v19);
            v27 = (dyld4::SyscallDelegate *)*((_QWORD *)a2 + 1);
          }
        }
        dyld4::SyscallDelegate::close(v27, v23);
        mach_o::Error::~Error((vm_address_t **)&v38);
      }
    }
  }
}

_QWORD *dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  const void **v4;
  vm_address_t v5;
  vm_size_t v6;
  unint64_t v7;
  vm_size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;

  v2 = result[1];
  v3 = result[2] + a2;
  if (v3 > v2)
  {
    v4 = (const void **)result;
    v5 = result[3];
    v6 = result[4];
    v7 = 2 * v2;
    if (v7 > v3)
      v3 = v7;
    v8 = (vm_page_size + 8 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    result = memmove((void *)v4[3], *v4, 8 * (_QWORD)v4[2]);
    v12 = (const void *)((unint64_t)v4[4] >> 3);
    *v4 = v4[3];
    v4[1] = v12;
    if (v5)
      return (_QWORD *)vm_deallocate(mach_task_self_, v5, v6);
  }
  return result;
}

BOOL dyld4::ProcessConfig::DyldCache::isAlwaysOverridablePath(dyld4::ProcessConfig::DyldCache *this, const char *a2)
{
  return _platform_strcmp((const char *)this, "/usr/lib/system/libdispatch.dylib") == 0;
}

uint64_t dyld4::Loader::isDelayInit(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::isDelayInit();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::isDelayInit((uint64_t)this, (uint64_t)a2);
  else
    return dyld4::JustInTimeLoader::isDelayInit((uint64_t)this);
}

BOOL dyld4::PrebuiltLoader::isDelayInit(uint64_t a1, uint64_t a2)
{
  __int16 v2;
  _QWORD *v3;

  v2 = *(_WORD *)(a1 + 6);
  if (v2 >= 0)
    v3 = (_QWORD *)(a2 + 1000);
  else
    v3 = (_QWORD *)(a2 + 1024);
  return *(_BYTE *)(*v3 + (v2 & 0x7FFF)) == 7;
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::value(dyld4::PrebuiltLoader::BindTargetRef *this, dyld4::RuntimeState *a2, uint64_t a3)
{
  unint64_t v3;
  dyld4::PrebuiltLoader *v6;
  uint64_t Address;
  uint64_t v8;
  uint64_t v10;
  __int16 v11;

  v3 = *(_QWORD *)this;
  if ((*(_QWORD *)this & 0x8000000000000000) != 0)
  {
    v10 = (v3 >> 8) | 0x80000000000000;
    if ((v3 & 0x4000000000000000) == 0)
      v10 = (v3 >> 8) & 0x7FFFFFFFFFFFFFLL;
    return v10 | (v3 << 56);
  }
  else
  {
    v11 = *(_QWORD *)this;
    v6 = (dyld4::PrebuiltLoader *)dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v11, a2, a3);
    Address = dyld4::PrebuiltLoader::loadAddress(v6, a2);
    v8 = (*(_QWORD *)this >> 24) | 0xFFFF8000000000;
    if ((*(_QWORD *)this & 0x4000000000000000) == 0)
      v8 = (*(_QWORD *)this >> 24) & 0x7FFFFFFFFFLL;
    return Address + (*(_QWORD *)this >> 16 << 56) + v8;
  }
}

uint64_t dyld4::Loader::LoaderRef::loader(dyld4::Loader::LoaderRef *this, const dyld4::RuntimeState *a2, uint64_t a3)
{
  int v3;
  unsigned int v4;
  uint64_t v5;

  v3 = *(__int16 *)this;
  v4 = *(unsigned __int16 *)this;
  if (v3 < 0)
  {
    v5 = *((_QWORD *)a2 + 127);
    LOWORD(v3) = v4 & 0x7FFF;
    if (*(_DWORD *)(v5 + 12) <= (v4 & 0x7FFF))
      dyld4::RuntimeState::findPrebuiltLoader((uint64_t)this, (uint64_t)a2, a3);
  }
  else
  {
    v5 = *((_QWORD *)a2 + 124);
    if (*(_DWORD *)(v5 + 12) <= v4)
      dyld4::RuntimeState::findPrebuiltLoader((uint64_t)this, (uint64_t)a2, a3);
  }
  return v5 + *(unsigned int *)(v5 + *(unsigned int *)(v5 + 16) + 4 * (unsigned __int16)v3);
}

uint64_t dyld4::Loader::beginInitializers(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::beginInitializers();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::beginInitializers(this, a2);
  else
    return dyld4::JustInTimeLoader::beginInitializers((uint64_t)this);
}

uint64_t dyld4::PrebuiltLoader::beginInitializers(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2)
{
  __int16 v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t result;

  v2 = *((_WORD *)this + 3);
  if (v2 >= 0)
    v3 = (char *)a2 + 1000;
  else
    v3 = (char *)a2 + 1024;
  v4 = *(_QWORD *)v3;
  v5 = v2 & 0x7FFF;
  v6 = *(unsigned __int8 *)(v4 + v5);
  if ((v6 - 8) < 2)
    return 1;
  if (v6 != 6)
    dyld4::PrebuiltLoader::beginInitializers();
  result = 0;
  *(_BYTE *)(v4 + v5) = 8;
  return result;
}

uint64_t dyld4::PrebuiltLoader::contains(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2, char *a3, const void **a4, unint64_t *a5, unsigned __int8 *a6)
{
  unint64_t Address;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;

  Address = dyld4::PrebuiltLoader::loadAddress(this, a2);
  if (Address > (unint64_t)a3)
    return 0;
  v12 = *((unsigned __int16 *)this + 22);
  if (v12 < 0x10)
    return 0;
  v13 = &a3[-Address];
  v14 = (char *)this + *((unsigned __int16 *)this + 23);
  v15 = 16 * (v12 >> 4);
  while (1)
  {
    v16 = *(_QWORD *)v14 & 0x7FFFFFFFFFFFFFFLL;
    if ((unint64_t)v13 >= v16)
    {
      v17 = *((unsigned int *)v14 + 3);
      if ((unint64_t)v13 < v16 + v17)
        break;
    }
    v14 += 16;
    v15 -= 16;
    if (!v15)
      return 0;
  }
  *a4 = (const void *)(Address + v16);
  *a5 = v17;
  *a6 = (*(_QWORD *)v14 >> 59) & 7;
  return 1;
}

uint64_t DyldSharedCache::getIndexedImageEntry(DyldSharedCache *this, int a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;

  v4 = *((unsigned int *)this + 4);
  v5 = 24;
  if (v4 > 0x1C3)
    v5 = 448;
  v6 = (_QWORD *)((char *)this + 32 * a2 + *(unsigned int *)((char *)this + v5));
  *a3 = v6[1];
  *a4 = v6[2];
  return (uint64_t)this + *v6 - *(_QWORD *)((char *)this + v4);
}

uint64_t dyld4::Loader::dependentCount(dyld4::Loader *this)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::dependentCount();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::dependentCount(this);
  else
    return dyld4::JustInTimeLoader::dependentCount(this);
}

uint64_t dyld4::PrebuiltLoader::dependentCount(dyld4::PrebuiltLoader *this)
{
  return *((unsigned __int16 *)this + 24);
}

uint64_t dyld4::Loader::setDelayInit(dyld4::Loader *this, dyld4::RuntimeState *a2, int a3)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::setDelayInit();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::setDelayInit((uint64_t)this, (uint64_t)a2, a3);
  else
    return dyld4::JustInTimeLoader::setDelayInit((uint64_t)this, (uint64_t)a2, a3);
}

uint64_t dyld4::PrebuiltLoader::setDelayInit(uint64_t result, uint64_t a2, int a3)
{
  __int16 v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  char v8;

  v3 = *(_WORD *)(result + 6);
  if (v3 >= 0)
    v4 = (uint64_t *)(a2 + 1000);
  else
    v4 = (uint64_t *)(a2 + 1024);
  v5 = *v4;
  v6 = v3 & 0x7FFF;
  v7 = *(unsigned __int8 *)(v5 + v6);
  if (a3)
  {
    if (v7 != 6)
      return result;
    v8 = 7;
  }
  else
  {
    if (v7 != 7)
      return result;
    v8 = 6;
  }
  *(_BYTE *)(v5 + v6) = v8;
  return result;
}

const dyld4::RuntimeState *dyld4::RuntimeState::notifyObjCInit(const dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  uint64_t v2;
  const void *Address;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  lsl::Lock *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[4];
  int v17;
  const void *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  lsl::Lock *v25;

  if ((*((_WORD *)a2 + 2) & 8) != 0)
  {
    v2 = (uint64_t)this;
    if (*((_QWORD *)this + 89))
    {
      Address = (const void *)dyld4::Loader::loadAddress(a2, this);
      v5 = (const char *)dyld4::Loader::path(a2, (const dyld4::RuntimeState *)v2);
      v17 = 520552480;
      v18 = Address;
      v19 = 0u;
      v20 = 0u;
      v21 = 0u;
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v17, v6, v7, v8, v9, v10, v11, v12);
      if (*(_BYTE *)(*(_QWORD *)(v2 + 8) + 205))
        dyld4::RuntimeState::log((dyld4::RuntimeState *)v2, "objc-init-notifier called with mh=%p, path=%s\n", Address, v5);
      v16[0] = Address;
      v16[1] = v5;
      v16[2] = a2;
      v16[3] = dyld4::Loader::dyldDoesObjCFixups(a2);
      v13 = *(lsl::Lock **)(v2 + 128);
      lsl::MemoryManager::lockGuard(v13, &v25);
      v14 = *((_QWORD *)v13 + 3) - 1;
      *((_QWORD *)v13 + 3) = v14;
      if (!v14)
        lsl::MemoryManager::writeProtect(v13, 1);
      lsl::Lock::unlock(v25);
      (*(void (**)(_QWORD *))(v2 + 712))(v16);
      lsl::MemoryManager::lockGuard(v13, &v25);
      v15 = *((_QWORD *)v13 + 3);
      if (!v15)
      {
        lsl::MemoryManager::writeProtect(v13, 0);
        v15 = *((_QWORD *)v13 + 3);
      }
      *((_QWORD *)v13 + 3) = v15 + 1;
      lsl::Lock::unlock(v25);
      return (const dyld4::RuntimeState *)dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v17);
    }
  }
  return this;
}

void dyld4::Loader::runInitializers(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::runInitializers();
  if ((*((_WORD *)this + 2) & 1) != 0)
    dyld4::PrebuiltLoader::runInitializers(this, a2);
  else
    dyld4::JustInTimeLoader::runInitializers((uint64_t (****)(char *))this, a2);
}

void dyld4::PrebuiltLoader::runInitializers(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2)
{
  __int16 v4;
  char *v5;

  if ((*((_WORD *)this + 22) & 1) != 0)
    dyld4::Loader::findAndRunAllInitializers(this, a2);
  v4 = *((_WORD *)this + 3);
  if (v4 >= 0)
    v5 = (char *)a2 + 1000;
  else
    v5 = (char *)a2 + 1024;
  *(_BYTE *)(*(_QWORD *)v5 + (v4 & 0x7FFF)) = 9;
}

uint64_t dyld4::JustInTimeLoader::isDelayInit(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 46) >> 7;
}

void dyld4::Loader::findAndRunAllInitializers(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  dyld3::MachOAnalyzer *Address;
  _QWORD v5[7];
  _QWORD v6[7];
  _BYTE v7[24];
  vm_address_t *v8;

  Diagnostics::Diagnostics((Diagnostics *)&v8);
  Address = (dyld3::MachOAnalyzer *)dyld4::Loader::loadAddress(this, a2);
  dyld3::MachOAnalyzer::makeVMAddrConverter(Address, 1, (uint64_t)v7);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke;
  v6[3] = &__block_descriptor_tmp_102;
  v6[4] = this;
  v6[5] = Address;
  v6[6] = a2;
  dyld3::MachOAnalyzer::forEachInitializer(Address, (vm_address_t *)&v8, (uint64_t)v7, (uint64_t)v6);
  if (!dyld3::MachOFile::isArch(Address, "arm64e"))
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = ___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke_2;
    v5[3] = &__block_descriptor_tmp_105;
    v5[4] = this;
    v5[5] = Address;
    v5[6] = a2;
    dyld3::MachOAnalyzer::forEachTerminator(Address, (vm_address_t *)&v8, (uint64_t)v7, (uint64_t)v5);
  }
  mach_o::Error::~Error(&v8);
}

uint64_t dyld3::MachOAnalyzer::makeVMAddrConverter@<X0>(dyld3::MachOAnalyzer *this@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t result;

  *(_QWORD *)a3 = dyld3::MachOFile::preferredLoadAddress(this);
  *(_QWORD *)(a3 + 8) = dyld3::MachOLoaded::getSlide(this);
  result = dyld3::MachOFile::hasChainedFixups(this);
  if ((_DWORD)result)
    result = dyld3::MachOAnalyzer::chainedPointerFormat(this);
  *(_WORD *)(a3 + 16) = result;
  *(_BYTE *)(a3 + 18) = a2;
  return result;
}

uint64_t dyld3::MachOFile::hasChainedFixups(dyld3::MachOFile *this)
{
  if (*((_DWORD *)this + 1) == 16777228
    && (*((_DWORD *)this + 2) & 0xFFFFFF) == 2
    && (dyld3::MachOFile::hasLoadCommand(this, -2147483614) & 1) != 0)
  {
    return 1;
  }
  else
  {
    return dyld3::MachOFile::hasLoadCommand(this, -2147483596);
  }
}

uint64_t dyld3::MachOFile::hasLoadCommand(dyld3::MachOFile *this, int a2)
{
  uint64_t v4;
  _QWORD v6[5];
  int v7;
  vm_address_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v8);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK5dyld39MachOFile14hasLoadCommandEj_block_invoke;
  v6[3] = &unk_1E4F7EB60;
  v7 = a2;
  v6[4] = &v9;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v8, (uint64_t)v6);
  v4 = *((unsigned __int8 *)v10 + 24);
  mach_o::Error::~Error(&v8);
  _Block_object_dispose(&v9, 8);
  return v4;
}

void dyld3::MachOAnalyzer::forEachInitializer(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t Address;
  uint64_t Slide;
  _QWORD v10[9];
  _QWORD v11[10];
  int v12;
  _QWORD v13[8];
  _QWORD v14[5];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  double (*v18)(uint64_t, uint64_t);
  _QWORD *(*v19)(_QWORD *);
  _QWORD v20[5];
  uint64_t v21;
  vm_address_t v22;
  vm_size_t v23;

  v15 = 0;
  v16 = &v15;
  v17 = 0x6802000000;
  v18 = __Block_byref_object_copy__13;
  v19 = __Block_byref_object_dispose__13;
  v20[3] = v20;
  v20[4] = 1;
  v23 = 0;
  v21 = 0;
  v22 = 0;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke;
  v14[3] = &unk_1E4F7F3D0;
  v14[4] = &v15;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v14);
  if (v16[10])
  {
    Address = dyld3::MachOFile::preferredLoadAddress(a1);
    Slide = dyld3::MachOLoaded::getSlide(a1);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_2;
    v13[3] = &unk_1E4F7F3F8;
    v13[4] = a4;
    v13[5] = &v15;
    v13[6] = Address;
    v13[7] = a2;
    dyld3::MachOFile::forEachLoadCommand(a1, a2, (uint64_t)v13);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_3;
    v11[3] = &unk_1E4F7F420;
    v12 = dyld3::MachOFile::pointerSize(a1);
    v11[6] = a1;
    v11[7] = a3;
    v11[4] = a4;
    v11[5] = &v15;
    v11[8] = a2;
    v11[9] = Address;
    dyld3::MachOFile::forEachInitializerPointerSection(a1, (uint64_t)a2, (uint64_t)v11);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    v10[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_4;
    v10[3] = &unk_1E4F7F448;
    v10[6] = Slide;
    v10[7] = a2;
    v10[8] = Address;
    v10[4] = a4;
    v10[5] = &v15;
    dyld3::MachOFile::forEachSection(a1, (uint64_t)v10);
  }
  else
  {
    Diagnostics::error(a2, "no exeutable segments");
  }
  _Block_object_dispose(&v15, 8);
  v21 = 0;
  if (v22)
    vm_deallocate(mach_task_self_, v22, v23);
}

BOOL dyld3::MachOFile::isArch(dyld3::MachOFile *this, const char *__s1)
{
  uint64_t v3;
  const char *v4;

  v3 = 0;
  v4 = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v3 + 1]) != *((_DWORD *)this + 1)
       || (*((_DWORD *)this + 2) & 0xFFFFFF) != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v3 + 3))
  {
    v3 += 2;
    if (v3 == 26)
      return _platform_strcmp(__s1, v4) == 0;
  }
  v4 = (&dyld3::MachOFile::_s_archInfos)[v3];
  return _platform_strcmp(__s1, v4) == 0;
}

void dyld3::MachOFile::forEachInitializerPointerSection(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3)
{
  int v4;
  _QWORD v5[7];
  int v6;

  if (*(_DWORD *)a1 == -17958193)
    v4 = 8;
  else
    v4 = 4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile32forEachInitializerPointerSectionER11DiagnosticsU13block_pointerFvjjRbE_block_invoke;
  v5[3] = &unk_1E4F7ED18;
  v6 = v4;
  v5[4] = a3;
  v5[5] = a2;
  v5[6] = dyld3::MachOFile::preferredLoadAddress(a1);
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v5);
}

uint64_t dyld4::JustInTimeLoader::setDelayInit(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3;
  unint64_t v4;

  v3 = *(_QWORD *)(result + 40);
  if (a3)
  {
    if ((v3 & 0x40000) != 0)
      return result;
    v4 = v3 | 0x80000000000000;
  }
  else
  {
    v4 = v3 & 0xFF7FFFFFFFFFFFFFLL;
  }
  *(_QWORD *)(result + 40) = v4;
  return result;
}

uint64_t dyld3::MachOAnalyzer::chainedPointerFormat(dyld3::MachOAnalyzer *this)
{
  dyld3::MachOFile *v2;
  const dyld_chained_fixups_header *v3;

  v2 = (dyld3::MachOFile *)dyld3::MachOAnalyzer::chainedFixupsHeader(this);
  if (v2)
    return dyld3::MachOFile::chainedPointerFormat(v2, v3);
  if (*((_DWORD *)this + 1) != 16777228 || dyld3::MachOFile::maskedCpuSubtype(this) != 2)
    dyld3::MachOAnalyzer::chainedPointerFormat();
  return 1;
}

uint64_t dyld3::MachOFile::chainedPointerFormat(dyld3::MachOFile *this, const dyld_chained_fixups_header *a2)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  unsigned int *v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;

  v2 = *((unsigned int *)this + 1);
  v3 = (char *)this + v2;
  v4 = *(unsigned int *)((char *)this + v2);
  if (!(_DWORD)v4)
    return 0;
  v5 = (unsigned int *)((char *)this + v2 + 4);
  while (1)
  {
    v7 = *v5++;
    v6 = v7;
    if (v7)
    {
      v8 = &v3[v6];
      if (*((_WORD *)v8 + 10))
        break;
    }
    if (!--v4)
      return 0;
  }
  return *((unsigned __int16 *)v8 + 3);
}

void dyld4::Loader::setUpPageInLinking(dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  dyld4::SyscallDelegate *v12;
  dyld3 *v13;
  int v14;
  int v15;
  int *v16;
  BOOL v18;
  const char *v19;
  int *v20;
  dyld3::MachOAnalyzer *v21;
  char v22;
  uint64_t v23;
  _QWORD v24[15];
  int v25;
  BOOL v26;
  char v27;
  _QWORD v28[7];
  uint64_t v29;
  vm_address_t address;
  vm_size_t size;
  _QWORD v32[7];
  uint64_t v33;
  vm_address_t v34;
  vm_size_t v35;
  _QWORD v36[3];
  __int16 v37;
  _QWORD v38[3];
  __int16 v39;
  char v40;
  char v41;

  v12 = (dyld4::SyscallDelegate *)*((_QWORD *)a3 + 1);
  v13 = (dyld3 *)dyld4::Loader::path(a1, a3);
  v14 = dyld4::SyscallDelegate::open(v12, v13, 0, 0);
  if (v14 == -1)
  {
    v19 = (const char *)dyld4::Loader::path(a1, a3);
    v20 = __error();
    Diagnostics::error(a2, "open(\"%s\", O_RDONLY) failed with errno=%d", v19, *v20);
  }
  else
  {
    v15 = v14;
    v16 = (int *)*((_QWORD *)a3 + 1);
    v18 = v16[41] >= 2
       && *((_QWORD *)a3 + 19) == 0
       && !dyld4::SyscallDelegate::sandboxBlockedPageInLinking((dyld4::SyscallDelegate *)v16);
    v21 = (dyld3::MachOAnalyzer *)dyld4::Loader::loadAddress(a1, a3);
    v22 = *(_BYTE *)(*((_QWORD *)a3 + 1) + 159);
    v38[0] = 0;
    v38[1] = v38;
    v38[2] = 0x2000000000;
    v39 = 0;
    v36[0] = 0;
    v36[1] = v36;
    v36[2] = 0x2000000000;
    v37 = 0;
    v32[0] = 0;
    v32[1] = v32;
    v32[2] = 0x5002000000;
    v32[3] = __Block_byref_object_copy__2;
    v32[4] = __Block_byref_object_dispose__2;
    v32[5] = &v41;
    v32[6] = 8;
    v34 = 0;
    v35 = 0;
    v33 = 0;
    v28[0] = 0;
    v28[1] = v28;
    v28[2] = 0x5002000000;
    v28[3] = __Block_byref_object_copy__2;
    v28[4] = __Block_byref_object_dispose__2;
    v28[5] = &v40;
    v28[6] = 8;
    address = 0;
    size = 0;
    v29 = 0;
    v23 = dyld3::MachOAnalyzer::chainStartsOffset(v21);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000;
    v24[2] = ___ZNK5dyld46Loader18setUpPageInLinkingER11DiagnosticsRNS_12RuntimeStateEmyRKN5dyld35ArrayIPKvEE_block_invoke;
    v24[3] = &unk_1E4F7CE38;
    v24[8] = a1;
    v24[9] = v21;
    v24[4] = v38;
    v24[5] = v36;
    v25 = v15;
    v24[10] = a2;
    v24[11] = a5;
    v26 = v18;
    v27 = v22;
    v24[6] = v32;
    v24[7] = v28;
    v24[12] = a4;
    v24[13] = a3;
    v24[14] = a6;
    dyld3::MachOAnalyzer::withChainStarts((char *)v21, a2, v23, (uint64_t)v24);
    dyld4::SyscallDelegate::close(*((dyld4::SyscallDelegate **)a3 + 1), v15);
    _Block_object_dispose(v28, 8);
    v29 = 0;
    if (address)
      vm_deallocate(mach_task_self_, address, size);
    _Block_object_dispose(v32, 8);
    v33 = 0;
    if (v34)
      vm_deallocate(mach_task_self_, v34, v35);
    _Block_object_dispose(v36, 8);
    _Block_object_dispose(v38, 8);
  }
}

uint64_t dyld4::RuntimeLocks::withNotifiersReadLock(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *a1;
  if (!v4)
    return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  (*(void (**)(uint64_t, _QWORD *, _QWORD))(*(_QWORD *)v4 + 104))(v4, a1 + 2, 0);
  (*(void (**)(uint64_t))(a2 + 16))(a2);
  return (*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*a1 + 112))(*a1, a1 + 2);
}

uint64_t ___ZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const dyld4::RuntimeState *v9;
  uint64_t v10;
  const void **v11;
  const void **v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  dyld4::Loader **v16;
  uint64_t v17;
  dyld4::Loader *v18;
  dyld3::MachOLoaded *Address;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t Slide;
  uint64_t v28;
  const void **v29;
  uint64_t v30;
  uint64_t v31;
  const void *v32;
  dyld4::Loader **v33;
  uint64_t v34;
  dyld4::Loader *v35;
  dyld3::MachOLoaded *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  const void **v46;
  const void *v47;
  unint64_t v48;
  dyld3::MachOLoaded **v49;
  size_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char *v61;
  size_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  unint64_t v70;
  dyld3::MachOLoaded *v71;
  const void **v72;
  int v73;
  dyld3::MachOLoaded *v74;
  uint64_t v75;
  const void *v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;

  v8 = result;
  v9 = *(const dyld4::RuntimeState **)(result + 32);
  v10 = *((_QWORD *)v9 + 93);
  if (v10)
  {
    v11 = (const void **)*((_QWORD *)v9 + 92);
    v12 = &v11[v10];
    do
    {
      v13 = *(_QWORD *)(v8 + 40);
      v14 = *(_QWORD *)(v13 + 8);
      if (v14)
      {
        v15 = *v11;
        v16 = *(dyld4::Loader ***)v13;
        v17 = 8 * v14;
        do
        {
          v18 = *v16;
          Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*v16, v9);
          v73 = 520552472;
          v74 = Address;
          v75 = 0;
          v76 = v15;
          v77 = 0u;
          v78 = 0u;
          v79 = 0u;
          v80 = 0u;
          v81 = 0u;
          dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v73, v20, v21, v22, v23, v24, v25, v26);
          if (*(_BYTE *)(*((_QWORD *)v9 + 1) + 205))
            dyld4::RuntimeState::log(v9, "notifier %p called with mh=%p\n", v15, Address);
          if ((*((_WORD *)v18 + 2) & 2) != 0)
            Slide = *(_QWORD *)(*((_QWORD *)v9 + 1) + 264);
          else
            Slide = dyld3::MachOLoaded::getSlide(Address);
          ((void (*)(dyld3::MachOLoaded *, uint64_t))v15)(Address, Slide);
          result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v73);
          ++v16;
          v17 -= 8;
        }
        while (v17);
      }
      ++v11;
    }
    while (v11 != v12);
  }
  v28 = *((_QWORD *)v9 + 101);
  if (v28)
  {
    v29 = (const void **)*((_QWORD *)v9 + 100);
    v72 = &v29[v28];
    do
    {
      v30 = *(_QWORD *)(v8 + 40);
      v31 = *(_QWORD *)(v30 + 8);
      if (v31)
      {
        v32 = *v29;
        v33 = *(dyld4::Loader ***)v30;
        v34 = 8 * v31;
        do
        {
          v35 = *v33;
          v36 = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*v33, v9);
          v73 = 520552472;
          v74 = v36;
          v75 = 0;
          v76 = v32;
          v77 = 0u;
          v78 = 0u;
          v79 = 0u;
          v80 = 0u;
          v81 = 0u;
          dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v73, v37, v38, v39, v40, v41, v42, v43);
          if (*(_BYTE *)(*((_QWORD *)v9 + 1) + 205))
            dyld4::RuntimeState::log(v9, "notifier %p called with mh=%p\n", v32, v36);
          v44 = dyld4::Loader::path(v35, v9);
          ((void (*)(dyld3::MachOLoaded *, uint64_t, BOOL))v32)(v36, v44, (*((_WORD *)v35 + 2) & 0x20) == 0);
          result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v73);
          ++v33;
          v34 -= 8;
        }
        while (v34);
      }
      ++v29;
    }
    while (v29 != v72);
  }
  v45 = *((_QWORD *)v9 + 105);
  if (v45)
  {
    v46 = (const void **)*((_QWORD *)v9 + 104);
    v72 = &v46[v45];
    do
    {
      v47 = *v46;
      __chkstk_darwin(result, a2, a3, a4, a5, a6, a7, a8, (uint64_t)v72);
      v49 = (dyld3::MachOLoaded **)((char *)&v72 - ((v48 + 15) & 0xFFFFFFFF0));
      if (v48 >= 0x200)
        v50 = 512;
      else
        v50 = v48;
      bzero((char *)&v72 - ((v48 + 15) & 0xFFFFFFFF0), v50);
      v51 = *(_DWORD *)(v8 + 48);
      __chkstk_darwin(v52, v53, v54, v55, v56, v57, v58, v59, (uint64_t)v72);
      v61 = (char *)&v72 - ((v60 + 15) & 0xFFFFFFFF0);
      if (v60 >= 0x200)
        v62 = 512;
      else
        v62 = v60;
      bzero((char *)&v72 - ((v60 + 15) & 0xFFFFFFFF0), v62);
      if (v51)
      {
        v70 = 0;
        do
        {
          v49[v70] = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*(dyld4::Loader **)(**(_QWORD **)(v8 + 40) + 8 * v70), v9);
          *(_QWORD *)&v61[8 * v70] = dyld4::Loader::path(*(dyld4::Loader **)(**(_QWORD **)(v8 + 40) + 8 * v70), v9);
          ++v70;
        }
        while (v70 < *(unsigned int *)(v8 + 48));
      }
      v71 = *v49;
      v73 = 520552472;
      v74 = v71;
      v75 = 0;
      v76 = v47;
      v77 = 0u;
      v78 = 0u;
      v79 = 0u;
      v80 = 0u;
      v81 = 0u;
      dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v73, v63, v64, v65, v66, v67, v68, v69);
      if (*(_BYTE *)(*((_QWORD *)v9 + 1) + 205))
        dyld4::RuntimeState::log(v9, "bulk notifier %p called with %d images\n", v47, *(_DWORD *)(v8 + 48));
      ((void (*)(_QWORD, dyld3::MachOLoaded **, char *))v47)(*(unsigned int *)(v8 + 48), v49, v61);
      result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v73);
      ++v46;
    }
    while (v46 != v72);
  }
  return result;
}

void dyld4::RuntimeState::notifyLoad(const dyld4::RuntimeState *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v9;
  uint64_t v10;
  dyld4::Loader **v11;
  uint64_t v12;
  dyld4::Loader *v13;
  unsigned int *Address;
  dyld3 *v15;
  stat *v16;
  unsigned __int8 (*st_ino)[16];
  fsobj_id st_dev;
  void *v19;
  fsobj_id v20;
  fsid v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t Lock;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  size_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  dyld4::Loader **v55;
  uint64_t v56;
  dyld4::Loader *v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  int DoesObjCFixups;
  const void **v62;
  _BOOL4 hasConstantSegmentsToProtect;
  __int16 v64;
  uint64_t v65;
  lsl::Lock *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  void *v74;
  void (*v75)(uint64_t, const void **);
  void (*v76)(uint64_t);
  unint64_t i;
  uint64_t v78;
  uint64_t v79;
  dyld4::Loader **v80;
  uint64_t v81;
  dyld4::Loader *v82;
  const void *v83;
  uint64_t v84;
  int v85;
  char *v86;
  const void **v87;
  const dyld4::RuntimeState **v88;
  const dyld4::RuntimeState *v89;
  char v90;
  char v91;
  unsigned int v92;
  _QWORD v93[6];
  int v94;
  stat v95;
  char v96[8];
  uint64_t v97;
  _BYTE *(*v98)(_BYTE *, unsigned int);
  void *v99;
  const void **v100;
  const dyld4::RuntimeState ***v101;
  unsigned int *v102;
  char *v103;

  v84 = a2;
  v9 = *(_QWORD *)(a2 + 8);
  if (kdebug_is_enabled(0x1F050000u, a2, a3, a4, a5, a6, a7, a8))
  {
    v10 = *(_QWORD *)(v84 + 8);
    if (v10)
    {
      v11 = *(dyld4::Loader ***)v84;
      v12 = 8 * v10;
      do
      {
        v13 = *v11;
        Address = (unsigned int *)dyld4::Loader::loadAddress(*v11, a1);
        if ((*((_WORD *)v13 + 2) & 2) != 0
          || (v15 = (dyld3 *)dyld4::Loader::path(v13, a1), dyld3::stat(v15, &v95, v16)))
        {
          st_ino = 0;
          st_dev = 0;
        }
        else
        {
          st_ino = (unsigned __int8 (*)[16])v95.st_ino;
          st_dev = (fsobj_id)v95.st_dev;
        }
        *(_QWORD *)v96 = 0;
        v97 = 0;
        dyld3::MachOFile::getUuid((dyld3::MachOFile *)Address, (unsigned __int8 *)v96);
        v19 = (void *)dyld4::Loader::path(v13, a1);
        v20 = st_dev;
        v21 = (fsid)Address;
        dyld3::kdebug_trace_dyld_image(0, v19, (void **)v96, st_ino, v20, v21, (const void *)Address[2], v22, v83);
        ++v11;
        v12 -= 8;
      }
      while (v12);
    }
  }
  v23 = (_QWORD *)*((_QWORD *)a1 + 17);
  v93[0] = _NSConcreteStackBlock;
  v93[1] = 0x40000000;
  v93[2] = ___ZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke;
  v93[3] = &__block_descriptor_tmp_94;
  v24 = v84;
  v93[4] = a1;
  v93[5] = v84;
  v94 = v9;
  Lock = dyld4::RuntimeLocks::withNotifiersReadLock(v23, (uint64_t)v93);
  v92 = 0;
  v91 = 0;
  __chkstk_darwin(Lock, v26, v27, v28, v29, v30, v31, v32, (uint64_t)&v83);
  v33 = (8 * v9 + 15) & 0xFFFFFFFF0;
  v34 = (char *)&v83 - v33;
  if (8 * (unint64_t)v9 >= 0x200)
    v35 = 512;
  else
    v35 = 8 * v9;
  bzero((char *)&v83 - v33, v35);
  __chkstk_darwin(v36, v37, v38, v39, v40, v41, v42, v43, (uint64_t)v83);
  v44 = (char *)&v83 - v33;
  bzero((char *)&v83 - v33, v35);
  __chkstk_darwin(v45, v46, v47, v48, v49, v50, v51, v52, (uint64_t)v83);
  v87 = &v83 - 4 * v9;
  if (*((_QWORD *)a1 + 88) || *((_QWORD *)a1 + 90))
  {
    v53 = *(_QWORD *)(v24 + 8);
    if (v53)
    {
      v85 = 0;
      v54 = 0;
      v55 = *(dyld4::Loader ***)v24;
      v56 = 8 * v53;
      v86 = v34;
      do
      {
        v57 = *v55;
        if ((*((_WORD *)*v55 + 2) & 4) != 0)
        {
          *(_QWORD *)&v34[8 * v54] = dyld4::Loader::path(*v55, a1);
          v58 = dyld4::Loader::loadAddress(v57, a1);
          v59 = v44;
          *(_QWORD *)&v44[8 * v54] = v58;
          v60 = dyld4::Loader::path(v57, a1);
          DoesObjCFixups = dyld4::Loader::dyldDoesObjCFixups(v57);
          v62 = &v87[4 * v54];
          *v62 = (const void *)v58;
          v62[1] = (const void *)v60;
          v62[2] = v57;
          *((_DWORD *)v62 + 6) = DoesObjCFixups;
          v54 = (v54 + 1);
          v92 = v54;
          hasConstantSegmentsToProtect = dyld4::Loader::hasConstantSegmentsToProtect(v57);
          v64 = *((_WORD *)v57 + 2);
          if (hasConstantSegmentsToProtect && (v64 & 0x80) != 0)
          {
            dyld4::Loader::makeSegmentsReadWrite(v57, a1);
            v64 = *((_WORD *)v57 + 2);
          }
          v34 = v86;
          v44 = v59;
          if ((v64 & 2) != 0)
          {
            v85 = 1;
            v91 = 1;
          }
        }
        ++v55;
        v56 -= 8;
      }
      while (v56);
      v65 = v84;
      if ((_DWORD)v54)
      {
        v90 = 0;
        v88 = &v89;
        v89 = a1;
        v66 = (lsl::Lock *)*((_QWORD *)a1 + 16);
        lsl::MemoryManager::lockGuard(v66, (lsl::Lock **)&v95);
        v67 = *((_QWORD *)v66 + 3);
        if (!v67)
        {
          lsl::MemoryManager::writeProtect(v66, 0);
          v67 = *((_QWORD *)v66 + 3);
        }
        *((_QWORD *)v66 + 3) = v67 + 1;
        lsl::Lock::unlock(*(lsl::Lock **)&v95.st_dev);
        v95.st_dev = 520552484;
        memset(&v95.st_ino, 0, 104);
        dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v95, v68, v69, v70, v71, v72, v73, v74);
        v75 = (void (*)(uint64_t, const void **))*((_QWORD *)a1 + 88);
        if (v75)
        {
          if (v85)
          {
            dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(&v89);
            v75 = (void (*)(uint64_t, const void **))*((_QWORD *)a1 + 88);
          }
          v75(v54, v87);
        }
        else
        {
          v76 = (void (*)(uint64_t))*((_QWORD *)a1 + 90);
          if (v76)
          {
            *(_QWORD *)v96 = _NSConcreteStackBlock;
            v97 = 0x40000000;
            v98 = ___ZZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEEENK3__0clEv_block_invoke;
            v99 = &__block_descriptor_tmp_163;
            v102 = &v92;
            v103 = &v91;
            v100 = v87;
            v101 = &v88;
            v76(v54);
          }
        }
        if (*(_BYTE *)(*((_QWORD *)a1 + 1) + 205))
        {
          dyld4::RuntimeState::log(a1, "objc-mapped-notifier called with %d images:\n", v92);
          if (v92)
          {
            for (i = 0; i < v92; ++i)
              dyld4::RuntimeState::log(a1, " objc-mapped: %p %s\n", *(const void **)&v44[8 * i], *(const char **)&v34[8 * i]);
          }
        }
        dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v95);
        lsl::MemoryManager::lockGuard(v66, (lsl::Lock **)&v95);
        v78 = *((_QWORD *)v66 + 3) - 1;
        *((_QWORD *)v66 + 3) = v78;
        if (!v78)
          lsl::MemoryManager::writeProtect(v66, 1);
        lsl::Lock::unlock(*(lsl::Lock **)&v95.st_dev);
        v65 = v84;
        if (v90)
          dyld4::ProcessConfig::DyldCache::makeDataConstWritable((char **)(*((_QWORD *)v89 + 1) + 240), *((_QWORD *)v89 + 1) + 200, *((_QWORD *)v89 + 1), 0);
      }
      v79 = *(_QWORD *)(v65 + 8);
      if (v79)
      {
        v80 = *(dyld4::Loader ***)v65;
        v81 = 8 * v79;
        do
        {
          v82 = *v80;
          if ((*((_WORD *)*v80 + 2) & 4) != 0
            && dyld4::Loader::hasConstantSegmentsToProtect(*v80)
            && (*((_WORD *)v82 + 2) & 0x80) != 0)
          {
            dyld4::Loader::makeSegmentsReadOnly(v82, a1);
          }
          ++v80;
          v81 -= 8;
        }
        while (v81);
      }
    }
  }
}

uint64_t dyld3::MachOAnalyzer::chainStartsOffset(dyld3::MachOAnalyzer *this)
{
  uint64_t result;

  result = dyld3::MachOAnalyzer::chainedFixupsHeader(this);
  if (result)
    return result - (_QWORD)this + *(unsigned int *)(result + 4);
  return result;
}

uint64_t dyld3::MachOAnalyzer::chainedFixupsHeader(dyld3::MachOAnalyzer *this)
{
  uint64_t LinkEditContent;
  _BYTE v4[16];
  uint64_t v5;
  uint64_t v6;
  vm_address_t *v7;

  Diagnostics::Diagnostics((Diagnostics *)&v7);
  dyld3::MachOLoaded::getLinkEditPointers(this, (vm_address_t *)&v7, (uint64_t)v4);
  LinkEditContent = 0;
  if (!Diagnostics::hasError((Diagnostics *)&v7) && v5)
    LinkEditContent = dyld3::MachOLoaded::getLinkEditContent((uint64_t)this, (uint64_t)&v6, *(_DWORD *)(v5 + 8));
  mach_o::Error::~Error(&v7);
  return LinkEditContent;
}

uint64_t dyld3::MachOLoaded::getLinkEditContent(uint64_t a1, uint64_t a2, int a3)
{
  return *(_QWORD *)a2 + *(_QWORD *)(a2 + 16) + (a3 - *(_DWORD *)(a2 + 24));
}

uint64_t dyld3::MachOAnalyzer::withChainStarts(char *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t LinkEditContent;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a3)
    return (*(uint64_t (**)(uint64_t, char *))(a4 + 16))(a4, &a1[a3]);
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)&v9);
  result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    if (v10)
    {
      LinkEditContent = dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v11, *(_DWORD *)(v10 + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, LinkEditContent + *(unsigned int *)(LinkEditContent + 4));
    }
    else
    {
      return Diagnostics::error(a2, "image does not use chained fixups");
    }
  }
  return result;
}

void ___ZNK5dyld46Loader18setUpPageInLinkingER11DiagnosticsRNS_12RuntimeStateEmyRKN5dyld35ArrayIPKvEE_block_invoke(uint64_t a1, uint64_t a2)
{
  _DWORD *v3;
  dyld4::Loader *v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[4];
  __int128 v10;
  __int128 v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  int v16;
  char v17;
  char v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 0;
  v4 = *(dyld4::Loader **)(a1 + 64);
  v3 = *(_DWORD **)(a1 + 72);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___ZNK5dyld46Loader18setUpPageInLinkingER11DiagnosticsRNS_12RuntimeStateEmyRKN5dyld35ArrayIPKvEE_block_invoke_2;
  v9[3] = &unk_1E4F7CE10;
  v5 = *(_QWORD *)(a1 + 80);
  v13 = a2;
  v14 = v5;
  v16 = *(_DWORD *)(a1 + 120);
  v15 = *(_OWORD *)(a1 + 88);
  v17 = *(_BYTE *)(a1 + 124);
  v18 = *(_BYTE *)(a1 + 125);
  v6 = *(_OWORD *)(a1 + 48);
  v10 = *(_OWORD *)(a1 + 32);
  v11 = v6;
  v12 = &v19;
  dyld3::MachOFile::forEachSegment(v3, (uint64_t)v9);
  if (v20[3])
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    if (*(_QWORD *)(v7 + 56)
      && dyld4::setUpPageInLinkingRegions(*(const dyld4::RuntimeState **)(a1 + 104), v4, *(_QWORD *)(a1 + 96), *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8) + 164) == 1, (const mwl_region *)(v7 + 40), *(_QWORD *)(a1 + 112)))
    {
      dyld4::setUpPageInLinkingRegions(*(const dyld4::RuntimeState **)(a1 + 104), v4, *(_QWORD *)(a1 + 96), *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), 1, (const mwl_region *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), *(_QWORD *)(a1 + 112));
    }
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    if (*(_QWORD *)(v8 + 56))
      dyld4::setUpPageInLinkingRegions(*(const dyld4::RuntimeState **)(a1 + 104), v4, *(_QWORD *)(a1 + 96), *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), 1, (const mwl_region *)(v8 + 40), *(_QWORD *)(a1 + 112));
  }
  _Block_object_dispose(&v19, 8);
}

uint64_t dyld4::JustInTimeLoader::beginInitializers(uint64_t a1)
{
  unint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if ((v1 & 0x40000) == 0)
    *(_QWORD *)(a1 + 40) = v1 | 0x40000;
  return (v1 >> 18) & 1;
}

dyld4::PseudoDylib *dyld4::JustInTimeLoader::runInitializers(uint64_t (****this)(char *), dyld4::RuntimeState *a2)
{
  dyld4::PseudoDylib *result;
  char *v5;

  dyld4::Loader::findAndRunAllInitializers((dyld4::Loader *)this, a2);
  result = (dyld4::PseudoDylib *)this[13];
  if (result)
  {
    result = (dyld4::PseudoDylib *)dyld4::PseudoDylib::initialize(result);
    if (result)
    {
      v5 = (char *)result;
      dyld4::RuntimeState::log(a2, "error running pseudo-dylib initializers: %s", (const char *)result);
      return (dyld4::PseudoDylib *)dyld4::PseudoDylib::disposeString(this[13], v5);
    }
  }
  return result;
}

const os_unfair_lock *lsl::MemoryManager::lockGuard@<X0>(lsl::Lock *this@<X0>, lsl::Lock **a2@<X8>)
{
  *a2 = this;
  return lsl::Lock::lock(this);
}

void dyld3::MachOAnalyzer::forEachTerminator(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t Slide;
  _QWORD v10[10];
  int v11;
  _QWORD v12[5];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  double (*v16)(uint64_t, uint64_t);
  _QWORD *(*v17)(_QWORD *);
  _QWORD v18[5];
  uint64_t v19;
  vm_address_t address;
  vm_size_t size;

  v13 = 0;
  v14 = &v13;
  v15 = 0x6802000000;
  v16 = __Block_byref_object_copy__13;
  v17 = __Block_byref_object_dispose__13;
  v18[3] = v18;
  v18[4] = 1;
  size = 0;
  v19 = 0;
  address = 0;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = ___ZNK5dyld313MachOAnalyzer17forEachTerminatorER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjE_block_invoke;
  v12[3] = &unk_1E4F7F470;
  v12[4] = &v13;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v12);
  if (v14[10])
  {
    v8 = dyld3::MachOFile::preferredLoadAddress(a1);
    Slide = dyld3::MachOLoaded::getSlide(a1);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    v10[2] = ___ZNK5dyld313MachOAnalyzer17forEachTerminatorER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjE_block_invoke_2;
    v10[3] = &unk_1E4F7F498;
    v11 = dyld3::MachOFile::pointerSize(a1);
    v10[6] = Slide;
    v10[7] = a2;
    v10[4] = a4;
    v10[5] = &v13;
    v10[8] = a3;
    v10[9] = v8;
    dyld3::MachOFile::forEachSection(a1, (uint64_t)v10);
  }
  else
  {
    Diagnostics::error(a2, "no exeutable segments");
  }
  _Block_object_dispose(&v13, 8);
  v19 = 0;
  if (address)
    vm_deallocate(mach_task_self_, address, size);
}

uint64_t dyld4::JustInTimeLoader::dyldDoesObjCFixups(dyld4::JustInTimeLoader *this)
{
  return (*((unsigned __int16 *)this + 2) >> 1) & 1;
}

uint64_t dyld4::ProcessConfig::DyldCache::makeDataConstWritable(char **a1, uint64_t a2, uint64_t a3, int a4)
{
  char *v4;
  int v5;
  _QWORD v7[7];
  int v8;

  v4 = *a1;
  v7[0] = _NSConcreteStackBlock;
  if (a4)
    v5 = 19;
  else
    v5 = 1;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke;
  v7[3] = &__block_descriptor_tmp_67;
  v7[4] = a1;
  v7[5] = a2;
  v8 = v5;
  v7[6] = a3;
  return DyldSharedCache::forEachCache(v4, (uint64_t)v7);
}

void mach_o::Fixups::forEachBindTarget_Opcodes(dyld3::MachOFile ***a1, Diagnostics *a2, char a3, uint64_t a4, uint64_t a5)
{
  _QWORD v5[6];
  _QWORD v6[6];
  _QWORD v7[3];
  int v8;
  _QWORD v9[3];
  int v10;

  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x2000000000;
  v10 = -1;
  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  v8 = -1;
  v5[5] = v7;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke;
  v6[3] = &unk_1E4F7F298;
  v6[4] = a4;
  v6[5] = v9;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2;
  v5[3] = &unk_1E4F7F2C0;
  v5[4] = a5;
  mach_o::Fixups::forEachBindUnified_Opcodes(a1, a2, a3, (uint64_t)v6, (uint64_t)v5);
  _Block_object_dispose(v7, 8);
  _Block_object_dispose(v9, 8);
}

void mach_o::Fixups::forEachBindUnified_Opcodes(dyld3::MachOFile ***a1, Diagnostics *a2, char a3, uint64_t a4, uint64_t a5)
{
  BOOL v8;
  _QWORD v9[8];
  _QWORD v10[8];
  char v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  __n128 (*v15)(uint64_t, uint64_t);
  uint64_t (*v16)();
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;

  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  v12 = 0;
  v13 = &v12;
  v14 = 0x4802000000;
  v15 = __Block_byref_object_copy__53_0;
  v16 = __Block_byref_object_dispose__54_0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke;
  v10[3] = &unk_1E4F7F228;
  v10[6] = &v17;
  v10[7] = a1;
  v11 = a3;
  v10[4] = a4;
  v10[5] = &v12;
  if (!mach_o::Fixups::forEachBind_OpcodesRegular(a1, a2, (uint64_t)v10))
  {
    v8 = mach_o::Fixups::forEachBind_OpcodesLazy(a1, a2, (uint64_t)v10);
    _Block_object_dispose(&v12, 8);
    _Block_object_dispose(&v17, 8);
    if (v8)
      return;
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = 0;
    v12 = 0;
    v13 = &v12;
    v14 = 0x4802000000;
    v15 = __Block_byref_object_copy__53_0;
    v16 = __Block_byref_object_dispose__54_0;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke_2;
    v9[3] = &unk_1E4F7F250;
    v9[6] = &v17;
    v9[7] = a1;
    v9[4] = a5;
    v9[5] = &v12;
    mach_o::Fixups::forEachBind_OpcodesWeak(a1, a2, (uint64_t)v9, (uint64_t)&__block_literal_global_3);
  }
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v17, 8);
}

BOOL mach_o::Fixups::forEachBind_OpcodesWeak(dyld3::MachOFile ***a1, Diagnostics *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v7;
  char v8;
  _BYTE *v9;
  uint64_t v10;
  dyld3::MachOFile *v11;
  char v12;
  char v13;
  const unsigned __int8 *v14;
  const unsigned __int8 **v15;
  unsigned int v16;
  _BYTE *v17;
  unsigned int v18;
  const unsigned __int8 **v19;
  int v20;
  const unsigned __int8 *v21;
  unint64_t v22;
  const unsigned __int8 *v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unint64_t v27;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  unsigned __int8 v33;
  unsigned __int8 **v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  const unsigned __int8 **v39;
  char v40;

  if (!*((_BYTE *)(*a1)[3] + 348))
    return 0;
  v7 = dyld3::MachOFile::pointerSize(**a1);
  v40 = 0;
  v35 = dyld3::MachOFile::dependentDylibCount(**a1, 0);
  v8 = 0;
  v36 = 0;
  v37 = 0;
  v9 = 0;
  v33 = 0;
  v10 = 0;
  v11 = (*a1)[3];
  v34 = (unsigned __int8 **)(*((_QWORD *)v11 + 41) + *((unsigned int *)v11 + 84));
  v39 = (const unsigned __int8 **)*((_QWORD *)v11 + 41);
  v12 = 1;
  v13 = 1;
  do
  {
    if (!Diagnostics::noError(a2))
      break;
    v15 = v39;
    if ((v39 >= (const unsigned __int8 **)v34) | v8 & 1)
      break;
    v17 = (char *)v39 + 1;
    v16 = *(unsigned __int8 *)v39;
    v39 = (const unsigned __int8 **)((char *)v39 + 1);
    v18 = v16 & 0xF;
    v8 = 1;
    switch(v16 >> 4)
    {
      case 0u:
        break;
      case 1u:
      case 2u:
      case 3u:
        Diagnostics::error((vm_address_t *)a2, "unexpected dylib ordinal in weak_bind");
        goto LABEL_16;
      case 4u:
        if (*v17)
        {
          v19 = (const unsigned __int8 **)((char *)v15 + 2);
          do
          {
            v39 = v19;
            v20 = *(unsigned __int8 *)v19;
            v19 = (const unsigned __int8 **)((char *)v19 + 1);
          }
          while (v20);
          v15 = (const unsigned __int8 **)((char *)v19 - 2);
        }
        LOBYTE(v36) = v16 & 1;
        v39 = (const unsigned __int8 **)((char *)v15 + 2);
        if (v18 >= 8)
          (*(void (**)(uint64_t, _BYTE *))(a4 + 16))(a4, v17);
        v8 = 0;
        v12 = 1;
        v9 = v17;
        break;
      case 5u:
        v8 = 0;
        v13 = v16 & 0xF;
        break;
      case 6u:
        v37 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        v8 = 0;
        v12 = 1;
        break;
      case 7u:
        v10 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        v8 = 0;
        BYTE4(v36) = 1;
        v33 = v18;
        break;
      case 8u:
        v8 = 0;
        v10 += dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        break;
      case 9u:
        LOBYTE(v31) = v12;
        LOWORD(v30) = v36 & 1;
        LOBYTE(v29) = v13;
        (*(void (**)(uint64_t, const char *, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", BYTE4(v36) & 1, 1, v35, 4294967293, v7, v33, v10, v29, v9, v30, v37, v31, &v40);
        v12 = 0;
        v8 = 0;
        v10 += v7;
        break;
      case 0xAu:
        LOBYTE(v31) = v12;
        LOWORD(v30) = v36 & 1;
        LOBYTE(v29) = v13;
        (*(void (**)(uint64_t, const char *, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", BYTE4(v36) & 1, 1, v35, 4294967293, v7, v33, v10, v29, v9, v30, v37, v31, &v40);
        v12 = 0;
        v8 = 0;
        v10 += v7 + dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v21);
        break;
      case 0xBu:
        LOBYTE(v31) = v12;
        LOWORD(v30) = v36 & 1;
        LOBYTE(v29) = v13;
        (*(void (**)(uint64_t, const char *, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", BYTE4(v36) & 1, 1, v35, 4294967293, v7, v33, v10, v29, v9, v30, v37, v31, &v40);
        v12 = 0;
        v8 = 0;
        v10 += v7 + v7 * v18;
        break;
      case 0xCu:
        v22 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        v24 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v23);
        if (!v22)
          goto LABEL_16;
        v32 = a4;
        v25 = v24 + v7;
        v26 = 1;
        do
        {
          LOBYTE(v31) = v12;
          LOWORD(v30) = v36 & 1;
          LOBYTE(v29) = v13;
          (*(void (**)(uint64_t, const char *, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", BYTE4(v36) & 1, 1, v35, 4294967293, v7, v33, v10, v29, v9, v30, v37, v31, &v40);
          v12 = 0;
          v10 += v25;
          if (v40)
            break;
          v27 = v26++;
        }
        while (v22 > v27);
        v8 = 0;
        a4 = v32;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad bind opcode 0x%02X");
LABEL_16:
        v8 = 0;
        break;
    }
  }
  while (!v40);
  return v40 != 0;
}

uint64_t ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;

  v13 = **(_QWORD **)(a1 + 56);
  v15 = *(_QWORD *)(v13 + 8);
  v14 = *(_QWORD *)(v13 + 16);
  if (v14)
  {
    v16 = 48 * v14;
    v17 = v15;
    do
    {
      if (*(_DWORD *)(v17 + 44) == 1)
        break;
      v17 += 48;
      v16 -= 48;
    }
    while (v16);
  }
  v18 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (*(_QWORD *)(v18 + 48) != a11 || *(_QWORD *)(v18 + 56) != a13)
  {
    v19 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v20 = *(_DWORD *)(v19 + 24);
    *(_DWORD *)(v19 + 24) = v20 + 1;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = v20;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 44) = -3;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48) = a11;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 56) = a13;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 64) = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 65) = 0;
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v5;

  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) != *a4)
  {
    v5 = result;
    result = (*(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16))();
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 40) + 8) + 24) = *a4;
  }
  return result;
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3(uint64_t a1, uint64_t a2)
{
  dyld4::Loader *v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  vm_address_t *v8;

  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) != *(_DWORD *)a2)
    ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3_cold_1();
  v4 = *(dyld4::Loader **)(a1 + 56);
  Diagnostics::Diagnostics((Diagnostics *)&v8);
  v7 = 0;
  v5 = 0u;
  v6 = 0u;
  dyld4::Loader::resolveSymbol(v4, *(dyld4::RuntimeState **)(a1 + 64), (vm_address_t *)&v8, *(unsigned int *)(a2 + 4), *(const char **)(a2 + 8), *(unsigned __int8 *)(a2 + 24), *(unsigned __int8 *)(a2 + 25), *(_QWORD *)(a1 + 32), (uint64_t)&v5);
  if (Diagnostics::hasError((Diagnostics *)&v8))
  {
    *(_QWORD *)&v5 = 0;
    *(_QWORD *)&v6 = 0;
    v7 = 1;
  }
  else
  {
    *(_QWORD *)&v6 = v6 + *(_QWORD *)(a2 + 16);
  }
  (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40));
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  mach_o::Error::~Error(&v8);
}

uint64_t dyld4::APIs::dladdr(dyld4::APIs *this, int *a2, dl_info *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  dyld3::MachOLoaded *v11;
  const char **p_dli_sname;
  void *v13;
  const char *v14;
  uint64_t v15;
  const char *dli_sname;
  dyld4::PseudoDylib *v17;
  unint64_t v19;
  _QWORD v20[7];
  unint64_t v21;
  unint64_t *v22;
  uint64_t v23;
  char v24;
  unsigned __int8 v25;
  unint64_t v26;
  void *v27;
  char *v28;
  dyld4::Loader *v29;
  dyld3::MachOLoaded *v30;
  BOOL v31;
  int v32;
  int *v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;

  v32 = 520618000;
  v33 = a2;
  v34 = 0u;
  v35 = 0u;
  v36 = 0u;
  v37 = 0u;
  v38 = 0u;
  v39 = 0u;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v32, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dladdr(%p, %p)\n", a2, a3);
  if (a3)
  {
    v31 = 0;
    v29 = 0;
    v30 = 0;
    v27 = 0;
    v28 = 0;
    v26 = 0;
    v25 = 0;
    if (dyld4::APIs::findImageMappedAt(this, (char *)a2, &v30, &v31, (const char **)&v28, &v27, &v26, &v25, &v29))
    {
      v11 = v30;
      a3->dli_fname = v28;
      a3->dli_fbase = v11;
      v21 = 0;
      if (v11 == (dyld3::MachOLoaded *)a2)
      {
        a3->dli_sname = "__dso_handle";
        a3->dli_saddr = a2;
      }
      else
      {
        p_dli_sname = &a3->dli_sname;
        if (dyld3::MachOLoaded::findClosestSymbol(v11, (uint64_t)a2, &a3->dli_sname, &v21))
        {
          v13 = (void *)v21;
          a3->dli_saddr = (void *)v21;
          if (a3->dli_fbase == v13)
          {
            *p_dli_sname = 0;
            a3->dli_saddr = 0;
          }
          else
          {
            v14 = *p_dli_sname;
            if (*p_dli_sname && *v14 == 95)
              *p_dli_sname = v14 + 1;
          }
        }
        else
        {
          *p_dli_sname = 0;
          a3->dli_saddr = 0;
          if (v29)
          {
            if ((*((_WORD *)v29 + 2) & 1) == 0)
            {
              v17 = (dyld4::PseudoDylib *)*((_QWORD *)v29 + 13);
              if (v17)
                dyld4::PseudoDylib::lookupAddress(v17, a2, a3);
            }
          }
        }
      }
      v15 = 1;
    }
    else
    {
      v15 = 0;
      if (a2 >= &dword_1A5C55000 && (unint64_t)a2 < 0x1A5E55000)
      {
        v21 = 0;
        v22 = &v21;
        v23 = 0x2000000000;
        v24 = 0;
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 0x40000000;
        v20[2] = ___ZN5dyld44APIs6dladdrEPKvP7dl_info_block_invoke;
        v20[3] = &unk_1E4F7DB28;
        v20[5] = &dword_1A5C55000;
        v20[6] = a2;
        v20[4] = &v21;
        dyld3::MachOFile::forEachSegment(&dword_1A5C55000, (uint64_t)v20);
        if (*((_BYTE *)v22 + 24))
        {
          a3->dli_fname = "/usr/lib/dyld";
          a3->dli_fbase = &dword_1A5C55000;
          v19 = 0;
          if (dyld3::MachOLoaded::findClosestSymbol((dyld3::MachOLoaded *)&dword_1A5C55000, (uint64_t)a2, &a3->dli_sname, &v19))
          {
            a3->dli_saddr = (void *)v19;
            dli_sname = a3->dli_sname;
            if (*dli_sname == 95)
              a3->dli_sname = ++dli_sname;
            if (!_platform_strcmp(dli_sname, "_ZN5dyld45startEPKNS_10KernelArgsE"))
            {
              a3->dli_sname = "start";
              a3->dli_saddr = a2;
            }
          }
        }
        _Block_object_dispose(&v21, 8);
        v15 = 0;
      }
    }
    *((_QWORD *)&v36 + 1) = v15;
    *(_QWORD *)&v37 = 0;
    *((_QWORD *)&v37 + 1) = a3->dli_fbase;
    *(_QWORD *)&v38 = 0;
    *((_QWORD *)&v38 + 1) = a3->dli_saddr;
    *(_QWORD *)&v39 = 0;
  }
  else
  {
    v15 = 0;
  }
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v32);
  return v15;
}

uint64_t dyld3::MachOLoaded::findClosestSymbol(dyld3::MachOLoaded *this, uint64_t a2, const char **a3, unint64_t *a4)
{
  uint64_t v8;
  unint64_t v9;
  int v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL4 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int *v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  unsigned int *v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int *v27;
  unsigned int *v28;
  unint64_t v29;
  unsigned int v30;
  unsigned int *v31;
  unsigned int *v32;
  unint64_t v33;
  _QWORD v35[6];
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  int v39;
  char v40[24];
  _DWORD *v41;
  unsigned int *v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  vm_address_t *v46;

  Diagnostics::Diagnostics((Diagnostics *)&v46);
  dyld3::MachOLoaded::getLinkEditPointers(this, (vm_address_t *)&v46, (uint64_t)v40);
  v8 = 0;
  if (!Diagnostics::hasError((Diagnostics *)&v46))
  {
    v8 = 0;
    if (v41)
    {
      if (v42)
      {
        v9 = a2 - v43;
        v36 = 0;
        v37 = &v36;
        v38 = 0x2000000000;
        v39 = 0;
        v35[0] = _NSConcreteStackBlock;
        v35[1] = 0x40000000;
        v35[2] = ___ZNK5dyld311MachOLoaded17findClosestSymbolEyPPKcPy_block_invoke;
        v35[3] = &unk_1E4F7F110;
        v35[4] = &v36;
        v35[5] = a2 - v43;
        dyld3::MachOFile::forEachSection(this, (uint64_t)v35);
        v10 = v41[4];
        v11 = v41[5];
        v12 = v45;
        v13 = v43 + v44;
        v14 = v43 + v44 + (v41[2] - v45);
        v15 = dyld3::MachOFile::is64(this);
        v16 = v42[4];
        v17 = v42[5];
        v18 = 0;
        if (v15)
        {
          if ((_DWORD)v17)
          {
            v19 = (unsigned int *)(v14 + 16 * v16);
            v20 = &v19[4 * v17];
            do
            {
              if ((~*((unsigned __int8 *)v19 + 4) & 0xE) == 0)
              {
                v21 = *((_QWORD *)v19 + 1);
                if (v18)
                {
                  if (v21 <= v9 && *((_QWORD *)v18 + 1) < v21)
                  {
LABEL_13:
                    if (*((_DWORD *)v37 + 6) == *((unsigned __int8 *)v19 + 5))
                      v18 = v19;
                  }
                }
                else if (v21 <= v9)
                {
                  goto LABEL_13;
                }
              }
              v19 += 4;
            }
            while (v19 < v20);
          }
          v22 = v42[3];
          if ((_DWORD)v22)
          {
            v23 = (unsigned int *)(v14 + 16 * v42[2]);
            v24 = &v23[4 * v22];
            do
            {
              if ((v23[1] & 0xEE) == 0xE)
              {
                v25 = *((_QWORD *)v23 + 1);
                if (v18)
                {
                  if (v25 <= v9 && *((_QWORD *)v18 + 1) < v25)
                  {
LABEL_24:
                    if (*((_DWORD *)v37 + 6) == *((unsigned __int8 *)v23 + 5))
                      v18 = v23;
                  }
                }
                else if (v25 <= v9)
                {
                  goto LABEL_24;
                }
              }
              v23 += 4;
            }
            while (v23 < v24);
          }
          if (v18)
          {
            v26 = *((_QWORD *)v18 + 1);
LABEL_53:
            *a4 = v43 + v26;
            if (*v18 < v11)
              *a3 = (const char *)(v13 + (v10 - v12) + *v18);
            v8 = 1;
            goto LABEL_57;
          }
          goto LABEL_56;
        }
        if ((_DWORD)v17)
        {
          v27 = (unsigned int *)(v14 + 12 * v16);
          v28 = &v27[3 * v17];
          do
          {
            if ((~*((unsigned __int8 *)v27 + 4) & 0xE) == 0)
            {
              v29 = v27[2];
              if (v18)
              {
                if (v9 >= v29 && v18[2] < v29)
                {
LABEL_37:
                  if (*((_DWORD *)v37 + 6) == *((unsigned __int8 *)v27 + 5))
                    v18 = v27;
                }
              }
              else if (v9 >= v29)
              {
                goto LABEL_37;
              }
            }
            v27 += 3;
          }
          while (v27 < v28);
        }
        v30 = v42[3];
        if (!v30)
        {
LABEL_51:
          if (v18)
          {
            v26 = v18[2];
            goto LABEL_53;
          }
LABEL_56:
          v8 = 0;
LABEL_57:
          _Block_object_dispose(&v36, 8);
          goto LABEL_58;
        }
        v31 = (unsigned int *)(v14 + 12 * v42[2]);
        v32 = &v31[3 * v30];
        while (1)
        {
          if ((v31[1] & 0xEE) == 0xE)
          {
            v33 = v31[2];
            if (v18)
            {
              if (v9 >= v33 && v18[2] < v33)
              {
LABEL_48:
                if (*((_DWORD *)v37 + 6) == *((unsigned __int8 *)v31 + 5))
                  v18 = v31;
              }
            }
            else if (v9 >= v33)
            {
              goto LABEL_48;
            }
          }
          v31 += 3;
          if (v31 >= v32)
            goto LABEL_51;
        }
      }
    }
  }
LABEL_58:
  mach_o::Error::~Error(&v46);
  return v8;
}

BOOL dyld3::MachOFile::is64(dyld3::MachOFile *this)
{
  return *(_DWORD *)this == -17958193;
}

void dyld3::MachOLoaded::getLinkEditPointers(_DWORD *a1, vm_address_t *a2, uint64_t a3)
{
  _QWORD v6[6];

  dyld3::MachOLoaded::getLinkEditLoadCommands(a1, a2, a3);
  if (Diagnostics::noError((Diagnostics *)a2))
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = ___ZNK5dyld311MachOLoaded13getLayoutInfoERNS0_10LayoutInfoE_block_invoke;
    v6[3] = &__block_descriptor_tmp_34_0;
    v6[4] = a1;
    v6[5] = a3 + 72;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v6);
  }
}

void dyld3::MachOLoaded::getLinkEditLoadCommands(_DWORD *a1, vm_address_t *a2, uint64_t a3)
{
  _QWORD v5[10];
  _QWORD v6[3];
  char v7;
  _QWORD v8[3];
  char v9;
  _QWORD v10[3];
  char v11;

  *(_QWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  v10[0] = 0;
  v10[1] = v10;
  v10[2] = 0x2000000000;
  v11 = 0;
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  v9 = 0;
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x2000000000;
  v7 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld311MachOLoaded23getLinkEditLoadCommandsER11DiagnosticsRNS0_12LinkEditInfoE_block_invoke;
  v5[3] = &unk_1E4F7EFE8;
  v5[8] = a2;
  v5[9] = a3;
  v5[4] = v10;
  v5[5] = v8;
  v5[6] = v6;
  v5[7] = a1;
  dyld3::MachOFile::forEachLoadCommand(a1, a2, (uint64_t)v5);
  if (Diagnostics::noError((Diagnostics *)a2) && *(_QWORD *)(a3 + 32) && !*(_QWORD *)(a3 + 24))
    Diagnostics::error(a2, "LC_DYSYMTAB but no LC_SYMTAB load command");
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(v8, 8);
  _Block_object_dispose(v10, 8);
}

void dyld3::MachOAnalyzer::forEachBindUnified_Opcodes(dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 hasError;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t (*v19)();
  BOOL v20;
  uint64_t v21;
  _QWORD v22[8];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[7];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  char v38;
  void **v39;
  uint64_t v40;
  uint64_t v41;
  __n128 (*v42)(uint64_t, uint64_t);
  uint64_t (*v43)();
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  int v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;

  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)&v48);
  hasError = Diagnostics::hasError((Diagnostics *)a2);
  if (!hasError)
  {
    __chkstk_darwin(hasError, v11, v12, v13, v14, v15, v16, v17, (uint64_t)&v21);
    v19 = (uint64_t (*)())&v22[-8 * v18 - 1];
    v39 = _NSConcreteStackBlock;
    v40 = 0x40000000;
    v41 = (uint64_t)___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    v42 = (__n128 (*)(uint64_t, uint64_t))&__block_descriptor_tmp_58_0;
    v43 = v19;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)&v39);
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      v44 = 0;
      v45 = &v44;
      v46 = 0x2000000000;
      v47 = 0;
      v39 = 0;
      v40 = (uint64_t)&v39;
      v41 = 0x4802000000;
      v42 = __Block_byref_object_copy__251;
      v43 = __Block_byref_object_dispose__252;
      v30[0] = _NSConcreteStackBlock;
      v30[1] = 0x40000000;
      v30[2] = ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke;
      v30[3] = &unk_1E4F7F5D8;
      v33 = v50;
      v32 = v49;
      v31 = v48;
      v37 = v54;
      v36 = v53;
      v35 = v52;
      v34 = v51;
      v30[5] = &v39;
      v30[6] = &v44;
      v38 = a3;
      v30[4] = a4;
      if (!dyld3::MachOAnalyzer::forEachBind_OpcodesRegular(a1, (Diagnostics *)a2, (uint64_t)&v48, (uint64_t)v19, (uint64_t)v30))
      {
        v20 = dyld3::MachOAnalyzer::forEachBind_OpcodesLazy(a1, (Diagnostics *)a2, (uint64_t)&v48, (uint64_t)v19, (uint64_t)v30);
        _Block_object_dispose(&v39, 8);
        _Block_object_dispose(&v44, 8);
        if (v20)
          return;
        v44 = 0;
        v45 = &v44;
        v46 = 0x2000000000;
        v47 = 0;
        v39 = 0;
        v40 = (uint64_t)&v39;
        v41 = 0x4802000000;
        v42 = __Block_byref_object_copy__251;
        v43 = __Block_byref_object_dispose__252;
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000;
        v22[2] = ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke_2;
        v22[3] = &unk_1E4F7F600;
        v24 = v49;
        v23 = v48;
        v29 = v54;
        v28 = v53;
        v27 = v52;
        v25 = v50;
        v26 = v51;
        v22[6] = &v44;
        v22[7] = v19;
        v22[4] = a5;
        v22[5] = &v39;
        dyld3::MachOAnalyzer::forEachBind_OpcodesWeak(a1, (Diagnostics *)a2, (uint64_t)&v48, (uint64_t)v19, (uint64_t)v22, (uint64_t)&__block_literal_global_257);
      }
      _Block_object_dispose(&v39, 8);
      _Block_object_dispose(&v44, 8);
    }
  }
}

BOOL dyld3::MachOAnalyzer::forEachBind_OpcodesWeak(dyld3::MachOFile *a1, Diagnostics *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int v9;
  char v10;
  _BYTE *v11;
  uint64_t v12;
  char v13;
  char v14;
  const unsigned __int8 *v15;
  const unsigned __int8 **v16;
  unsigned int v17;
  _BYTE *v18;
  unsigned int v19;
  const unsigned __int8 **v20;
  int v21;
  const unsigned __int8 *v22;
  unint64_t v23;
  const unsigned __int8 *v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unint64_t v28;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  unsigned __int8 **v35;
  unsigned int v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  const unsigned __int8 **LinkEditContent;
  char v43;

  if (!*(_QWORD *)a3 || !*(_DWORD *)(*(_QWORD *)a3 + 28))
    return 0;
  v9 = dyld3::MachOFile::pointerSize(a1);
  v43 = 0;
  v36 = dyld3::MachOFile::dependentDylibCount(a1, 0);
  v10 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v11 = 0;
  v12 = 0;
  LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, a3 + 72, *(_DWORD *)(*(_QWORD *)a3 + 24));
  v35 = (unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(*(_QWORD *)a3 + 28));
  v13 = 1;
  v14 = 1;
  do
  {
    if (!Diagnostics::noError(a2))
      break;
    v16 = LinkEditContent;
    if ((LinkEditContent >= (const unsigned __int8 **)v35) | v10 & 1)
      break;
    v18 = (char *)LinkEditContent + 1;
    v17 = *(unsigned __int8 *)LinkEditContent;
    LinkEditContent = (const unsigned __int8 **)((char *)LinkEditContent + 1);
    v19 = v17 & 0xF;
    v10 = 1;
    switch(v17 >> 4)
    {
      case 0u:
        break;
      case 1u:
      case 2u:
      case 3u:
        Diagnostics::error((vm_address_t *)a2, "unexpected dylib ordinal in weak_bind");
        goto LABEL_17;
      case 4u:
        if (*v18)
        {
          v20 = (const unsigned __int8 **)((char *)v16 + 2);
          do
          {
            LinkEditContent = v20;
            v21 = *(unsigned __int8 *)v20;
            v20 = (const unsigned __int8 **)((char *)v20 + 1);
          }
          while (v21);
          v16 = (const unsigned __int8 **)((char *)v20 - 2);
        }
        v37 = v17 & 1;
        LinkEditContent = (const unsigned __int8 **)((char *)v16 + 2);
        if (v19 >= 8)
          (*(void (**)(uint64_t, _BYTE *))(a6 + 16))(a6, v18);
        v10 = 0;
        v13 = 1;
        v11 = v18;
        break;
      case 5u:
        v10 = 0;
        v14 = v17 & 0xF;
        break;
      case 6u:
        v39 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v35, v15);
        v10 = 0;
        v13 = 1;
        break;
      case 7u:
        v12 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v35, v15);
        v10 = 0;
        LOBYTE(v38) = v19;
        BYTE4(v38) = 1;
        break;
      case 8u:
        v10 = 0;
        v12 += dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v35, v15);
        break;
      case 9u:
        LOBYTE(v33) = v13;
        LOWORD(v32) = v37 & 1;
        LOBYTE(v31) = v14;
        BYTE4(v30) = v38;
        LODWORD(v30) = v9;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND", a3, a4, BYTE4(v38) & 1, 1, v36, 4294967293, v30, v12, v31, v11, v32, v39, v33, &v43);
        v13 = 0;
        v10 = 0;
        v12 += v9;
        break;
      case 0xAu:
        LOBYTE(v33) = v13;
        LOWORD(v32) = v37 & 1;
        LOBYTE(v31) = v14;
        BYTE4(v30) = v38;
        LODWORD(v30) = v9;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", a3, a4, BYTE4(v38) & 1, 1, v36, 4294967293, v30, v12, v31, v11, v32, v39, v33, &v43);
        v13 = 0;
        v10 = 0;
        v12 += v9
             + dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v35, v22);
        break;
      case 0xBu:
        LOBYTE(v33) = v13;
        LOWORD(v32) = v37 & 1;
        LOBYTE(v31) = v14;
        BYTE4(v30) = v38;
        LODWORD(v30) = v9;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", a3, a4, BYTE4(v38) & 1, 1, v36, 4294967293, v30, v12, v31, v11, v32, v39, v33, &v43);
        v13 = 0;
        v10 = 0;
        v12 += v9 + v9 * v19;
        break;
      case 0xCu:
        v23 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v35, v15);
        v25 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v35, v24);
        if (!v23)
          goto LABEL_17;
        v26 = v25 + v9;
        v27 = 1;
        do
        {
          LOBYTE(v33) = v13;
          LOWORD(v32) = v37 & 1;
          LOBYTE(v31) = v14;
          BYTE4(v30) = v38;
          LODWORD(v30) = v9;
          (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", a3, a4, BYTE4(v38) & 1, 1, v36, 4294967293, v30, v12, v31, v11, v32, v39, v33, &v43);
          v13 = 0;
          v12 += v26;
          if (v43)
            break;
          v28 = v27++;
        }
        while (v23 > v28);
        v10 = 0;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad bind opcode 0x%02X");
LABEL_17:
        v10 = 0;
        break;
    }
  }
  while (!v43);
  return v43 != 0;
}

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_5(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  int v4;
  dyld4::Loader *v6;
  uint64_t *v7;
  uint64_t v8;
  const dyld4::RuntimeState *v9;
  char *v10;
  char *v11;
  const char *v12;
  char *v13;
  char *v14;
  const char *v15;

  v3 = (_QWORD *)a1[6];
  if (v3[2] <= (unint64_t)a3)
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>((uint64_t)a1, a2, a3);
  v4 = a3;
  v6 = (dyld4::Loader *)a1[4];
  v7 = (uint64_t *)(a1[5] + a2);
  v8 = *(_QWORD *)(*v3 + 8 * a3);
  v9 = (const dyld4::RuntimeState *)a1[7];
  if (v8 == -1)
  {
    if (*(_BYTE *)(*((_QWORD *)v9 + 1) + 202))
    {
      v13 = (char *)dyld4::Loader::path(v6, v9);
      v14 = strrchr(v13, 47);
      if (v14)
        v15 = v14 + 1;
      else
        v15 = v13;
      dyld4::RuntimeState::log(v9, "fixup: *0x%012lX (skipping missing weak bind) <%s/weak-bind#%u>\n", v7, v15, v4);
    }
  }
  else
  {
    if (*(_BYTE *)(*((_QWORD *)v9 + 1) + 202))
    {
      v10 = (char *)dyld4::Loader::path(v6, v9);
      v11 = strrchr(v10, 47);
      if (v11)
        v12 = v11 + 1;
      else
        v12 = v10;
      dyld4::RuntimeState::log(v9, "fixup: *0x%012lX = 0x%012lX <%s/weak-bind#%u>\n", v7, v8, v12, v4);
    }
    *v7 = v8;
  }
}

uint64_t ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke_2(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;
  uint64_t v15;
  int v16;

  v14 = *(_QWORD *)(a1[5] + 8);
  if (*(_QWORD *)(v14 + 48) != a12 || *(_QWORD *)(v14 + 56) != a14)
  {
    v15 = *(_QWORD *)(a1[6] + 8);
    v16 = *(_DWORD *)(v15 + 24);
    *(_DWORD *)(v15 + 24) = v16 + 1;
    *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 40) = v16;
    *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 44) = -3;
    *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 48) = a12;
    *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 56) = a14;
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 64) = 0;
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 65) = 0;
  }
  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

uint64_t dyld3::MachOFile::read_sleb128(vm_address_t *this, const unsigned __int8 ***a2, const unsigned __int8 **a3, const unsigned __int8 *a4)
{
  const unsigned __int8 **v4;
  int v5;
  uint64_t v6;
  int v7;
  const unsigned __int8 **v8;
  unsigned int v9;
  uint64_t v10;

  v4 = *a2;
  if (*a2 == a3)
  {
    v6 = 0;
    v7 = 0;
    v9 = 0;
LABEL_7:
    Diagnostics::error(this, "malformed sleb128");
  }
  else
  {
    v5 = 0;
    v6 = 0;
    v7 = -7 * (_DWORD)v4 - (_DWORD)a3 + 8 * (_DWORD)a3;
    while (1)
    {
      v8 = (const unsigned __int8 **)((char *)v4 + 1);
      *a2 = (const unsigned __int8 **)((char *)v4 + 1);
      v9 = *(unsigned __int8 *)v4;
      v6 |= (unint64_t)(v9 & 0x7F) << v5;
      if ((v9 & 0x80) == 0)
        break;
      v5 += 7;
      v4 = (const unsigned __int8 **)((char *)v4 + 1);
      if (v8 == a3)
        goto LABEL_7;
    }
    v7 = v5 + 7;
  }
  if (((v7 < 64) & (v9 >> 6)) != 0)
    v10 = -1 << v7;
  else
    v10 = 0;
  return v10 | v6;
}

BOOL dyld3::MachOAnalyzer::forEachBind_OpcodesLazy(dyld3::MachOFile *a1, Diagnostics *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v9;
  char v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  const unsigned __int8 **v14;
  const unsigned __int8 *v15;
  const unsigned __int8 **v16;
  _BYTE *v17;
  unsigned __int8 v18;
  char v19;
  const unsigned __int8 **v20;
  int v21;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  char v29;
  uint64_t v30;
  uint64_t v31;
  const unsigned __int8 **LinkEditContent;
  char v33;

  if (!*(_QWORD *)a3 || !*(_DWORD *)(*(_QWORD *)a3 + 36))
    return 0;
  v9 = dyld3::MachOFile::pointerSize(a1);
  v33 = 0;
  v27 = dyld3::MachOFile::dependentDylibCount(a1, 0);
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, a3 + 72, *(_DWORD *)(*(_QWORD *)a3 + 32));
  v14 = (const unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(*(_QWORD *)a3 + 36));
  do
  {
    if (!Diagnostics::noError(a2))
      break;
    v16 = LinkEditContent;
    if (LinkEditContent >= v14)
      break;
    v17 = (char *)LinkEditContent + 1;
    v18 = *(_BYTE *)LinkEditContent;
    LinkEditContent = (const unsigned __int8 **)((char *)LinkEditContent + 1);
    v19 = v18 & 0xF;
    switch(v18 >> 4)
    {
      case 0:
        break;
      case 1:
        v10 = 1;
        v11 = v18 & 0xF;
        break;
      case 2:
        v11 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, v14, v15);
        goto LABEL_12;
      case 3:
        if ((v18 & 0xF) != 0)
          v11 = *(_DWORD *)&v18 | 0xFFFFFFF0;
        else
          v11 = 0;
LABEL_12:
        v10 = 1;
        break;
      case 4:
        if (*v17)
        {
          v20 = (const unsigned __int8 **)((char *)v16 + 2);
          do
          {
            LinkEditContent = v20;
            v21 = *(unsigned __int8 *)v20;
            v20 = (const unsigned __int8 **)((char *)v20 + 1);
          }
          while (v21);
          v16 = (const unsigned __int8 **)((char *)v20 - 2);
        }
        v29 = v18 & 1;
        LinkEditContent = (const unsigned __int8 **)((char *)v16 + 2);
        v12 = v17;
        break;
      case 6:
        v31 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &LinkEditContent, v14, v15);
        break;
      case 7:
        v13 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, v14, v15);
        LOBYTE(v30) = v19;
        BYTE4(v30) = 1;
        break;
      case 9:
        LOBYTE(v26) = 1;
        BYTE1(v25) = 1;
        LOBYTE(v25) = v29 & 1;
        LOBYTE(v24) = 1;
        BYTE4(v23) = v30;
        LODWORD(v23) = v9;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND", a3, a4, BYTE4(v30) & 1, v10 & 1, v27, v11, v23, v13, v24, v12, v25, v31, v26, &v33);
        v13 += v9;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad lazy bind opcode 0x%02X", v18 & 0xF0);
        break;
    }
  }
  while (!v33);
  return v33 != 0;
}

uint64_t dyld3::MachOFile::dependentDylibCount(dyld3::MachOFile *this, BOOL *a2)
{
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile19dependentDylibCountEPb_block_invoke;
  v5[3] = &unk_1E4F7EC28;
  v5[4] = &v10;
  v5[5] = &v6;
  dyld3::MachOFile::forEachDependentDylib(this, (uint64_t)v5);
  if (a2)
    *a2 = *((_BYTE *)v7 + 24);
  v3 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v6, 8);
  _Block_object_dispose(&v10, 8);
  return v3;
}

uint64_t dyld4::APIs::NSVersionOfLinkTimeLibrary(dyld4::Loader **this, const char *a2)
{
  dyld3::MachOFile *Address;
  uint64_t v5;
  _QWORD v7[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = -1;
  Address = (dyld3::MachOFile *)dyld4::Loader::loadAddress(this[3], (const dyld4::RuntimeState *)this);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld44APIs26NSVersionOfLinkTimeLibraryEPKc_block_invoke;
  v7[3] = &unk_1E4F7D860;
  v7[4] = &v8;
  v7[5] = a2;
  dyld3::MachOFile::forEachDependentDylib(Address, (uint64_t)v7);
  if (*((_BYTE *)this[1] + 204))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "NSVersionOfLinkTimeLibrary(%s) =>0x%08X\n", a2, *((_DWORD *)v9 + 6));
  v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void dyld3::MachOFile::forEachDependentDylib(dyld3::MachOFile *a1, uint64_t a2)
{
  char *v4;
  const char *v5;
  char *v6;
  _QWORD v7[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;
  vm_address_t *v16;
  unsigned int v17[2];
  char *v18;

  Diagnostics::Diagnostics((Diagnostics *)&v16);
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld39MachOFile21forEachDependentDylibEU13block_pointerFvPKcbbbjjRbE_block_invoke;
  v7[3] = &unk_1E4F7E9D8;
  v7[4] = a2;
  v7[5] = &v12;
  v7[6] = &v8;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v16, (uint64_t)v7);
  if (!*((_DWORD *)v13 + 6) && !*((_BYTE *)v9 + 24))
  {
    if (dyld3::MachOFile::builtForPlatform(a1, 10, 1))
    {
      if (*((_DWORD *)a1 + 3) != 6
        || ((*(_QWORD *)v17 = 0,
             v18 = 0,
             !dyld3::MachOFile::getDylibInstallName(a1, (const char **)&v18, &v17[1], v17))
          ? (v4 = 0)
          : (v4 = v18),
            _platform_strncmp(v4, "/System/DriverKit/usr/lib/system/", 0x21uLL)))
      {
        v5 = "/System/DriverKit/usr/lib/libSystem.B.dylib";
LABEL_10:
        (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t *))(a2 + 16))(a2, v5, 0, 0, 0, 0x10000, 0x10000, v9 + 3);
      }
    }
    else if (!dyld3::MachOFile::builtForPlatform(a1, 16, 1)
           && !dyld3::MachOFile::builtForPlatform(a1, 18, 1)
           && !dyld3::MachOFile::builtForPlatform(a1, 20, 1))
    {
      if (*((_DWORD *)a1 + 3) != 6
        || (v6 = dyld3::MachOFile::installName(a1), _platform_strncmp(v6, "/usr/lib/system/", 0x10uLL)))
      {
        v5 = "/usr/lib/libSystem.B.dylib";
        goto LABEL_10;
      }
    }
  }
  Diagnostics::assertNoError((Diagnostics *)&v16);
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  mach_o::Error::~Error(&v16);
}

BOOL dyld3::MachOAnalyzer::forEachBind_OpcodesRegular(dyld3::MachOFile *a1, Diagnostics *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v8;
  char v9;
  char v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  Diagnostics *v15;
  const unsigned __int8 *v16;
  const unsigned __int8 **v17;
  unsigned __int8 *v18;
  unsigned int v19;
  int v20;
  const unsigned __int8 **v21;
  int v22;
  const unsigned __int8 *v23;
  unint64_t v24;
  const unsigned __int8 *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unint64_t v29;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  unsigned __int8 **v36;
  unsigned int v37;
  unsigned __int8 *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const unsigned __int8 **LinkEditContent;
  char v44;

  if (!*(_QWORD *)a3 || !*(_DWORD *)(*(_QWORD *)a3 + 20))
    return 0;
  v8 = dyld3::MachOFile::pointerSize(a1);
  v44 = 0;
  v37 = dyld3::MachOFile::dependentDylibCount(a1, 0);
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v38 = 0;
  v13 = 0;
  LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, a3 + 72, *(_DWORD *)(*(_QWORD *)a3 + 16));
  v36 = (unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(*(_QWORD *)a3 + 20));
  v14 = v8;
  v15 = a2;
  do
  {
    if (!Diagnostics::noError(v15))
      break;
    v17 = LinkEditContent;
    if ((LinkEditContent >= (const unsigned __int8 **)v36) | v9 & 1)
      break;
    v18 = (unsigned __int8 *)LinkEditContent + 1;
    v19 = *(unsigned __int8 *)LinkEditContent;
    LinkEditContent = (const unsigned __int8 **)((char *)LinkEditContent + 1);
    v20 = v19 & 0xF;
    v9 = 1;
    switch(v19 >> 4)
    {
      case 0u:
        break;
      case 1u:
        v9 = 0;
        v11 = 1;
        v12 = v19 & 0xF;
        break;
      case 2u:
        v12 = dyld3::MachOFile::read_uleb128((vm_address_t *)v15, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        v9 = 0;
        goto LABEL_13;
      case 3u:
        v9 = 0;
        if ((v19 & 0xF) != 0)
          v12 = v19 | 0xFFFFFFF0;
        else
          v12 = 0;
LABEL_13:
        v11 = 1;
        break;
      case 4u:
        if (*v18)
        {
          v21 = (const unsigned __int8 **)((char *)v17 + 2);
          do
          {
            LinkEditContent = v21;
            v22 = *(unsigned __int8 *)v21;
            v21 = (const unsigned __int8 **)((char *)v21 + 1);
          }
          while (v22);
          v17 = (const unsigned __int8 **)((char *)v21 - 2);
        }
        v9 = 0;
        LOBYTE(v39) = v19 & 1;
        LinkEditContent = (const unsigned __int8 **)((char *)v17 + 2);
        v10 = 1;
        v38 = v18;
        break;
      case 5u:
        v9 = 0;
        BYTE4(v40) = v19 & 0xF;
        break;
      case 6u:
        v41 = dyld3::MachOFile::read_sleb128((vm_address_t *)v15, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        v9 = 0;
        v10 = 1;
        break;
      case 7u:
        v13 = dyld3::MachOFile::read_uleb128((vm_address_t *)v15, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        v9 = 0;
        BYTE4(v39) = v20;
        LOBYTE(v40) = 1;
        break;
      case 8u:
        v9 = 0;
        v13 += dyld3::MachOFile::read_uleb128((vm_address_t *)v15, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        break;
      case 9u:
        LOBYTE(v34) = v10;
        LOWORD(v33) = v39 & 1;
        LOBYTE(v32) = BYTE4(v40);
        BYTE4(v31) = BYTE4(v39);
        LODWORD(v31) = v14;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND", a3, a4, v40 & 1, v11 & 1, v37, v12, v31, v13, v32, v38, v33, v41, v34, &v44);
        v10 = 0;
        v9 = 0;
        v13 += v14;
        break;
      case 0xAu:
        LOBYTE(v34) = v10;
        LOWORD(v33) = v39 & 1;
        LOBYTE(v32) = BYTE4(v40);
        BYTE4(v31) = BYTE4(v39);
        LODWORD(v31) = v14;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", a3, a4, v40 & 1, v11 & 1, v37, v12, v31, v13, v32, v38, v33, v41, v34, &v44);
        v10 = 0;
        v9 = 0;
        v13 += v14
             + dyld3::MachOFile::read_uleb128((vm_address_t *)v15, &LinkEditContent, (const unsigned __int8 **)v36, v23);
        break;
      case 0xBu:
        LOBYTE(v34) = v10;
        LOWORD(v33) = v39 & 1;
        LOBYTE(v32) = BYTE4(v40);
        BYTE4(v31) = BYTE4(v39);
        LODWORD(v31) = v14;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", a3, a4, v40 & 1, v11 & 1, v37, v12, v31, v13, v32, v38, v33, v41, v34, &v44);
        v10 = 0;
        v9 = 0;
        v13 += (v14 + v14 * v20);
        break;
      case 0xCu:
        v24 = dyld3::MachOFile::read_uleb128((vm_address_t *)v15, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        v26 = dyld3::MachOFile::read_uleb128((vm_address_t *)v15, &LinkEditContent, (const unsigned __int8 **)v36, v25);
        if (!v24)
          goto LABEL_31;
        v27 = v26 + v14;
        v28 = 1;
        do
        {
          LOBYTE(v34) = v10;
          LOWORD(v33) = v39 & 1;
          LOBYTE(v32) = BYTE4(v40);
          BYTE4(v31) = BYTE4(v39);
          LODWORD(v31) = v14;
          (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", a3, a4, v40 & 1, v11 & 1, v37, v12, v31, v13, v32, v38, v33, v41, v34, &v44);
          v10 = 0;
          v13 += v27;
          if (v44)
            break;
          v29 = v28++;
        }
        while (v24 > v29);
        v9 = 0;
        v15 = a2;
        break;
      default:
        Diagnostics::error((vm_address_t *)v15, "bad bind opcode 0x%02X", *v18);
LABEL_31:
        v9 = 0;
        break;
    }
  }
  while (!v44);
  return v44 != 0;
}

uint64_t ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9, unsigned __int8 a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18)
{
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  BOOL v22;

  v18 = *(_QWORD *)(a4 + ((unint64_t)a10 << 6) + 16);
  v19 = *(_QWORD *)(a1 + 136);
  if (a17)
  {
    v20 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v21 = *(_DWORD *)(v20 + 24);
    *(_DWORD *)(v20 + 24) = v21 + 1;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = v21;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 44) = a8;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48) = a13;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 56) = a16;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 64) = a14;
    if (a15)
      v22 = *(_BYTE *)(a1 + 168) != 0;
    else
      v22 = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 65) = v22;
  }
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), v18 + a11 - v19, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40, a18);
}

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  int v4;
  const dyld4::Loader *v6;
  unint64_t *v7;
  unint64_t v8;
  const dyld4::RuntimeState *v9;
  char *v10;
  char *v11;
  const char *v12;
  _QWORD *v13;
  uint64_t v14;
  const char **v15;
  uint64_t v16;

  v3 = *(_QWORD **)(a1 + 48);
  if (v3[2] <= (unint64_t)a3)
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(a1, a2, a3);
  v4 = a3;
  v6 = *(const dyld4::Loader **)(a1 + 32);
  v7 = (unint64_t *)(*(_QWORD *)(a1 + 40) + a2);
  v8 = *(_QWORD *)(*v3 + 8 * a3);
  v9 = *(const dyld4::RuntimeState **)(a1 + 56);
  if (*(_BYTE *)(*((_QWORD *)v9 + 1) + 202))
  {
    v10 = (char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 32), v9);
    v11 = strrchr(v10, 47);
    if (v11)
      v12 = v11 + 1;
    else
      v12 = v10;
    dyld4::RuntimeState::log(v9, "fixup: *0x%012lX = 0x%012lX <%s/bind#%u>\n", v7, v8, v12, v4);
    v9 = *(const dyld4::RuntimeState **)(a1 + 56);
  }
  *v7 = v8;
  if (v8 == *((_QWORD *)v9 + 14))
  {
    v13 = *(_QWORD **)(a1 + 64);
    v14 = v13[2];
    if (v14)
    {
      v15 = (const char **)(*v13 + 8);
      v16 = 16 * v14;
      while (*(_DWORD *)v15 != v4)
      {
        v15 += 2;
        v16 -= 16;
        if (!v16)
          return;
      }
      dyld4::RuntimeState::addMissingFlatLazySymbol(v9, v6, *(v15 - 1), v7);
    }
  }
}

uint64_t ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t dyld3::MachOAnalyzer::forEachRebase_Opcodes(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4, char *a5)
{
  int v10;
  const unsigned __int8 **LinkEditContent;
  const unsigned __int8 **v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  const unsigned __int8 *v17;
  const unsigned __int8 **v18;
  unsigned __int8 v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  BOOL v23;
  uint64_t v24;
  unint64_t v25;
  unsigned int v26;
  unint64_t v27;
  BOOL v28;
  const unsigned __int8 *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  const unsigned __int8 *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  unint64_t v38;
  BOOL v39;
  char *v41;
  uint64_t v42;
  int v43;
  unsigned int v44;
  const unsigned __int8 **v45;
  vm_address_t *v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  unsigned __int8 v52;
  const unsigned __int8 **v53;

  if (dyld3::MachOFile::is64(a1))
    v10 = 2;
  else
    v10 = 1;
  v44 = v10;
  if (!*(_QWORD *)a3)
    dyld3::MachOAnalyzer::forEachRebase_Opcodes();
  v48 = a5;
  v49 = a4;
  LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, a3 + 72, *(_DWORD *)(*(_QWORD *)a3 + 8));
  v47 = a3;
  v42 = *(unsigned int *)(*(_QWORD *)a3 + 12);
  v43 = (int)LinkEditContent;
  v12 = (const unsigned __int8 **)((char *)LinkEditContent + v42);
  v53 = LinkEditContent;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v52 = 0;
  v50 = dyld3::MachOFile::pointerSize(a1);
  v45 = v12;
  v46 = a2;
  while (2)
  {
    if (Diagnostics::noError((Diagnostics *)a2))
    {
      v18 = v53;
      if (v53 < v12)
      {
        v19 = *(_BYTE *)v53;
        v53 = (const unsigned __int8 **)((char *)v53 + 1);
        v20 = v19 & 0xF;
        switch(v19 >> 4)
        {
          case 0:
            v41 = (char *)v18 + 1;
            if ((char *)v12 - v41 >= 16)
              Diagnostics::error(a2, "rebase opcodes terminated early at offset %d of %d", (_DWORD)v41 - v43, v42);
            return 1;
          case 1:
            switch(v20)
            {
              case 1u:
                v16 = v44;
                break;
              case 3u:
                v16 = 3;
                break;
              case 2u:
                v16 = 4;
                break;
              default:
                v16 = 0;
                break;
            }
            goto LABEL_46;
          case 2:
            v14 = dyld3::MachOFile::read_uleb128(a2, &v53, v12, v17);
            v13 = 1;
            v15 = v20;
            goto LABEL_46;
          case 3:
            v14 += dyld3::MachOFile::read_uleb128(a2, &v53, v12, v17);
            goto LABEL_46;
          case 4:
            v14 += v50 * v20;
            goto LABEL_46;
          case 5:
            if ((v19 & 0xF) == 0)
              goto LABEL_46;
            v21 = v13;
            v22 = 1;
            do
            {
              (*((void (**)(char *, const char *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, _DWORD, unsigned __int8 *))v48
               + 2))(v48, "REBASE_OPCODE_DO_REBASE_IMM_TIMES", v47, v49, v21 & 1, v50, v15, v14, v16, &v52);
              v14 += v50;
              if (v52)
                v23 = 1;
              else
                v23 = v22 >= v20;
              ++v22;
            }
            while (!v23);
            v13 = v21;
            a2 = v46;
            v12 = v45;
            v16 = v16;
            a5 = &jpt_1A5C64370;
            if (v52)
              return v52;
            continue;
          case 6:
            v24 = dyld3::MachOFile::read_uleb128(a2, &v53, v12, v17);
            if (v24)
            {
              v25 = v24;
              v26 = 1;
              do
              {
                (*((void (**)(char *, const char *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, _DWORD, unsigned __int8 *))v48
                 + 2))(v48, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES", v47, v49, v13 & 1, v50, v15, v14, v16, &v52);
                v14 += v50;
                v27 = v26++;
                if (v52)
                  v28 = 0;
                else
                  v28 = v25 > v27;
              }
              while (v28);
              a5 = &jpt_1A5C64370;
              v16 = v16;
              v12 = v45;
              a2 = v46;
            }
            goto LABEL_46;
          case 7:
            (*((void (**)(char *, const char *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, _DWORD, unsigned __int8 *))v48
             + 2))(v48, "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB", v47, v49, v13 & 1, v50, v15, v14, v16, &v52);
            v14 += v50 + dyld3::MachOFile::read_uleb128(a2, &v53, v12, v29);
            goto LABEL_46;
          case 8:
            v30 = a5;
            v31 = v16;
            v32 = dyld3::MachOFile::read_uleb128(a2, &v53, v12, v17);
            if (Diagnostics::hasError((Diagnostics *)a2)
              || (v34 = dyld3::MachOFile::read_uleb128(a2, &v53, v12, v33), !v32))
            {
              v16 = v31;
              a5 = v30;
            }
            else
            {
              v35 = v34 + v50;
              v51 = v15;
              v36 = v13;
              v37 = 1;
              do
              {
                (*((void (**)(char *, const char *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, _DWORD, unsigned __int8 *))v48
                 + 2))(v48, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB", v47, v49, v36 & 1, v50, v51, v14, v31, &v52);
                v38 = v37++;
                v14 += v35;
                if (v52)
                  v39 = 0;
                else
                  v39 = v32 > v38;
              }
              while (v39);
              v12 = v45;
              a2 = v46;
              v13 = v36;
              v15 = v51;
              v16 = v31;
              a5 = &jpt_1A5C64370;
            }
            goto LABEL_46;
          default:
            Diagnostics::error(a2, "unknown rebase opcode 0x%02X", v19 & 0xF0);
LABEL_46:
            if (v52)
              return v52;
            continue;
        }
      }
    }
    return v52;
  }
}

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_3(_QWORD *a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  dyld4::RuntimeState *v4;

  v2 = (uint64_t *)(a1[4] + a2);
  v3 = a1[5] + *v2;
  v4 = (dyld4::RuntimeState *)a1[6];
  if (*(_BYTE *)(*((_QWORD *)v4 + 1) + 202))
    dyld4::RuntimeState::log(v4, "fixup: *0x%012lX = 0x%012lX <rebase>\n", v2, v3);
  *v2 = v3;
}

uint64_t ___ZNK5dyld313MachOAnalyzer29forEachRebaseLocation_OpcodesER11DiagnosticsU13block_pointerFvyRbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

BOOL Diagnostics::noError(Diagnostics *this)
{
  return *(_QWORD *)this == 0;
}

uint64_t dyld3::MachOFile::read_uleb128(vm_address_t *this, const unsigned __int8 ***a2, const unsigned __int8 **a3, const unsigned __int8 *a4)
{
  unint64_t v5;
  uint64_t v6;
  const unsigned __int8 **v7;
  char *v8;
  int v9;

  v5 = 0;
  v6 = 0;
  v7 = *a2;
  v8 = "malformed uleb128";
  while (v7 != a3)
  {
    if (v5 > 0x3F)
    {
      v8 = "uleb128 too big for uint64";
      break;
    }
    v6 |= (unint64_t)(*(_BYTE *)v7 & 0x7F) << v5;
    v5 += 7;
    *a2 = (const unsigned __int8 **)((char *)v7 + 1);
    v9 = *(char *)v7;
    v7 = (const unsigned __int8 **)((char *)v7 + 1);
    if ((v9 & 0x80000000) == 0)
      return v6;
  }
  Diagnostics::error(this, v8);
  return v6;
}

uint64_t ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_3(uint64_t result, unsigned int a2, unsigned int a3, _BYTE *a4)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;

  v5 = result;
  v6 = (uint64_t *)(*(_QWORD *)(result + 48) + a2);
  v7 = (uint64_t *)((char *)v6 + a3);
  if (*(_DWORD *)(result + 80) == 8)
  {
    if (!a3)
      return result;
    while (1)
    {
      v8 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(_QWORD *)(v5 + 56), *v6);
      v9 = *(_QWORD *)(*(_QWORD *)(v5 + 40) + 8);
      v10 = *(_QWORD *)(v9 + 80);
      if (!v10)
        break;
      v11 = *(_QWORD *)(v9 + 64);
      v12 = 24 * v10;
      v13 = (unint64_t *)(v11 + 8);
      while (*(v13 - 1) > v8 || *v13 <= v8)
      {
        v13 += 3;
        v12 -= 24;
        if (!v12)
          goto LABEL_20;
      }
      result = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(v5 + 32) + 16))(*(_QWORD *)(v5 + 32), (v8 - *(_DWORD *)(v5 + 72)));
      if (++v6 >= v7)
        return result;
    }
LABEL_20:
    result = Diagnostics::error(*(vm_address_t **)(v5 + 64), "initializer 0x%0llX does not point within executable segment");
  }
  else
  {
    if (!a3)
      return result;
    while (1)
    {
      v14 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(_QWORD *)(v5 + 56), *(unsigned int *)v6);
      v15 = *(_QWORD *)(*(_QWORD *)(v5 + 40) + 8);
      v16 = *(_QWORD *)(v15 + 80);
      if (!v16)
        break;
      v17 = *(_QWORD *)(v15 + 64);
      v18 = 24 * v16;
      v19 = (_QWORD *)(v17 + 8);
      while (*(v19 - 1) > (unint64_t)v14 || *v19 <= (unint64_t)v14)
      {
        v19 += 3;
        v18 -= 24;
        if (!v18)
          goto LABEL_21;
      }
      result = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(v5 + 32) + 16))(*(_QWORD *)(v5 + 32), v14 - *(_DWORD *)(v5 + 72));
      v6 = (uint64_t *)((char *)v6 + 4);
      if (v6 >= v7)
        return result;
    }
LABEL_21:
    result = Diagnostics::error(*(vm_address_t **)(v5 + 64), "initializer 0x%0X does not point within executable segment");
  }
  *a4 = 1;
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachObjCProtocol(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10;
  uint64_t result;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;

  v10 = dyld3::MachOFile::pointerSize(a1);
  result = dyld3::MachOLoaded::getSlide(a1);
  v12 = result;
  v13 = (uint64_t *)((char *)a1 + a2);
  if (v10 == 8)
  {
    v29 = 0;
    if (a3)
    {
      v14 = a3 - 1;
      do
      {
        v15 = v14;
        v16 = *v13++;
        v17 = (uint64_t *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v16) + v12);
        v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v17);
        v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[1]);
        v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[2]);
        v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[3]);
        v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[4]);
        v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[5]);
        v28 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[6]);
        result = (*(uint64_t (**)(void))(*(_QWORD *)a5 + 16))();
        if (v29)
          break;
        v14 = v15 - 1;
      }
      while (v15);
    }
  }
  else
  {
    v29 = 0;
    if (a3)
    {
      v18 = a3 - 1;
      do
      {
        v19 = v18;
        v20 = *(_DWORD *)v13;
        v13 = (uint64_t *)((char *)v13 + 4);
        v21 = (unsigned int *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v20) + v12);
        v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v21);
        v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[1]);
        v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[2]);
        v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[3]);
        v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[4]);
        v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[5]);
        v28 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[6]);
        result = (*(uint64_t (**)(void))(*(_QWORD *)a5 + 16))();
        if (v29)
          break;
        v18 = v19 - 1;
      }
      while (v19);
    }
  }
  return result;
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  dyld4::RuntimeState *v6;
  uint64_t v7;

  v3 = *(_QWORD *)(a1[4] + 8);
  v4 = *(unsigned int *)(v3 + 24);
  *(_DWORD *)(v3 + 24) = v4 + 1;
  if (a1[7] <= v4)
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>((uint64_t)a1, a2, a3);
  if (*(_BYTE *)(a1[5] + v4) == 1)
  {
    v5 = (uint64_t *)(a1[9] + a2 - a1[8]);
    v7 = a1[10];
    v6 = (dyld4::RuntimeState *)a1[11];
    if (*(_BYTE *)(*((_QWORD *)v6 + 1) + 202))
      dyld4::RuntimeState::log(v6, "fixup: *0x%012lX = 0x%012lX <objc-protocol>\n", v5, v7);
    *v5 = v7;
  }
}

void dyld3::MachOAnalyzer::forEachObjCClass(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[12];
  _QWORD v19[12];
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  char v23;

  if (dyld3::MachOFile::pointerSize(a1) == 8)
  {
    v20 = 0;
    v21 = &v20;
    v22 = 0x2000000000;
    v23 = 0;
    if (a3)
    {
      v10 = a3 - 1;
      do
      {
        v11 = v10;
        v12 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *(_QWORD *)((char *)a1 + a2));
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 0x40000000;
        v19[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke;
        v19[3] = &unk_1E4F7F538;
        v19[6] = a5;
        v19[7] = v12;
        v19[4] = &v20;
        v19[5] = a1;
        v19[8] = a4;
        memset(&v19[9], 0, 24);
        dyld3::MachOAnalyzer::parseObjCClass(a1, a4, v12, v13, (uint64_t)v19);
        if (*((_BYTE *)v21 + 24))
          break;
        v10 = v11 - 1;
        a2 += 8;
      }
      while (v11);
    }
  }
  else
  {
    v20 = 0;
    v21 = &v20;
    v22 = 0x2000000000;
    v23 = 0;
    if (a3)
    {
      v14 = a3 - 1;
      do
      {
        v15 = v14;
        v16 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *(unsigned int *)((char *)a1 + a2));
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 0x40000000;
        v18[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_3;
        v18[3] = &unk_1E4F7F588;
        v18[6] = a5;
        v18[7] = v16;
        v18[4] = &v20;
        v18[5] = a1;
        v18[8] = a4;
        memset(&v18[9], 0, 24);
        dyld3::MachOAnalyzer::parseObjCClass(a1, a4, v16, v17, (uint64_t)v18);
        if (*((_BYTE *)v21 + 24))
          break;
        v14 = v15 - 1;
        a2 += 4;
      }
      while (v15);
    }
  }
  _Block_object_dispose(&v20, 8);
}

uint64_t dyld3::MachOAnalyzer::parseObjCClass(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  _BYTE v21[38];
  _BYTE v22[19];

  v9 = dyld3::MachOFile::pointerSize(a1);
  memset(v21, 0, sizeof(v21));
  v10 = (unsigned int *)(dyld3::MachOLoaded::getSlide(a1) + a3);
  if (v9 != 8)
  {
    v11 = a3 + 4;
    v12 = a3 + 16;
    *(_QWORD *)v21 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *v10);
    *(_QWORD *)&v21[8] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v10[1]);
    v15 = v10[3];
    if ((_DWORD)v15)
      v16 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v15);
    else
      v16 = 0;
    *(_QWORD *)&v21[16] = v16;
    *(_QWORD *)&v21[24] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v10[4]) & 0xFFFFFFFCLL;
    *(_OWORD *)v22 = *(_OWORD *)a2;
    *(_DWORD *)&v22[15] = *(_DWORD *)(a2 + 15);
    v19 = v10[4];
    v21[36] = v19 & 1;
    v21[37] = (v19 & 2) != 0;
    if ((v19 & 3) != 0)
    {
      v18 = v10[5];
      goto LABEL_13;
    }
LABEL_12:
    v18 = 0;
    goto LABEL_13;
  }
  v11 = a3 + 8;
  v12 = a3 + 32;
  *(_QWORD *)v21 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *(_QWORD *)v10);
  *(_QWORD *)&v21[8] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *((_QWORD *)v10 + 1));
  v13 = *((_QWORD *)v10 + 3);
  if (v13)
    v14 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v13);
  else
    v14 = 0;
  *(_QWORD *)&v21[16] = v14;
  *(_QWORD *)&v21[24] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *((_QWORD *)v10 + 4)) & 0x7FFFFFFFFFF8;
  *(_OWORD *)v22 = *(_OWORD *)a2;
  *(_DWORD *)&v22[15] = *(_DWORD *)(a2 + 15);
  v17 = *((_QWORD *)v10 + 4);
  v21[36] = v17 & 1;
  v21[37] = (v17 & 2) != 0;
  if ((v17 & 3) == 0)
    goto LABEL_12;
  v18 = v10[10];
LABEL_13:
  *(_DWORD *)&v21[32] = v18;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(a5 + 16))(a5, v11, v12, v21);
}

uint64_t dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  unint64_t v6;
  uint64_t v7;

  v2 = a2;
  v7 = a2;
  if (*(_BYTE *)(a1 + 18))
  {
    if (a2)
      return a2 - *(_QWORD *)(a1 + 8);
  }
  else
  {
    v4 = *(unsigned __int16 *)(a1 + 16);
    if (*(_WORD *)(a1 + 16) && v2)
    {
      v6 = 0;
      if ((mach_o::ChainedFixupPointerOnDisk::isRebase((mach_o::ChainedFixupPointerOnDisk *)&v7, v4, *(_QWORD *)a1, &v6) & 1) != 0)return v6 + *(_QWORD *)a1;
      else
        return v7;
    }
  }
  return v2;
}

uint64_t dyld3::MachOFile::pointerSize(dyld3::MachOFile *this)
{
  if (*(_DWORD *)this == -17958193)
    return 8;
  else
    return 4;
}

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 40)
                                                                                                + 16))(**(_QWORD **)(a1 + 40), *(_QWORD *)(a1 + 48), a2, a3, a4, 1, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  dyld3::MachOFile *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[7];

  v6 = *(dyld3::MachOFile **)(a1 + 40);
  result = (*(uint64_t (**)(void))(**(_QWORD **)(a1 + 48) + 16))();
  v9 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(*(_QWORD *)(v9 + 8) + 24))
  {
    v10 = *a4;
    v11 = *(_QWORD *)(a1 + 64);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    v12[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_2;
    v12[3] = &unk_1E4F7F510;
    v12[5] = *(_QWORD *)(a1 + 48);
    v12[6] = v10;
    v12[4] = v9;
    return dyld3::MachOAnalyzer::parseObjCClass(v6, v11, v10, v8, (uint64_t)v12);
  }
  return result;
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t OnlyDataField;
  uint64_t v7;
  dyld4::RuntimeState *v8;
  _DWORD *v9;
  uint64_t v10;

  OnlyDataField = dyld3::MachOAnalyzer::ObjCClassInfo::getReadOnlyDataField(a5, 2, *(_DWORD *)(a1 + 64));
  if (OnlyDataField)
  {
    v7 = OnlyDataField - **(_QWORD **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v7) & 1) == 0)
    {
      v8 = *(dyld4::RuntimeState **)(a1 + 56);
      v9 = (_DWORD *)(**(_QWORD **)(a1 + 48) + v7);
      v10 = *v9 | 1;
      if (*(_BYTE *)(*((_QWORD *)v8 + 1) + 202))
        dyld4::RuntimeState::log(v8, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v9, v10);
      *v9 = v10;
    }
  }
}

uint64_t dyld3::MachOAnalyzer::ObjCClassInfo::getReadOnlyDataField(uint64_t a1, int a2, int a3)
{
  uint64_t v4;
  uint64_t result;
  unsigned int *v6;
  uint64_t v7;

  v4 = *(_QWORD *)(a1 + 24);
  result = a1 + 40;
  v6 = (unsigned int *)(*(_QWORD *)(a1 + 48) + v4);
  if (a3 == 8)
  {
    switch(a2)
    {
      case 0:
        v7 = *((_QWORD *)v6 + 3);
        goto LABEL_4;
      case 1:
        v7 = *((_QWORD *)v6 + 5);
        goto LABEL_4;
      case 2:
        v7 = *((_QWORD *)v6 + 4);
        goto LABEL_4;
      case 3:
        v7 = *((_QWORD *)v6 + 8);
        goto LABEL_4;
      case 4:
        goto LABEL_7;
      default:
        return result;
    }
  }
  else
  {
    switch(a2)
    {
      case 0:
        v7 = v6[4];
        goto LABEL_4;
      case 1:
        v7 = v6[6];
        goto LABEL_4;
      case 2:
        v7 = v6[5];
        goto LABEL_4;
      case 3:
        v7 = v6[9];
LABEL_4:
        result = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(result, v7);
        break;
      case 4:
LABEL_7:
        result = *v6;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t dyld3::MachOAnalyzer::objcMethodListIsRelative(dyld3::MachOAnalyzer *this, uint64_t a2)
{
  if (a2)
    return *(_DWORD *)((char *)this + a2) >> 31;
  else
    return 0;
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_3(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  unint64_t *v6;
  unint64_t v7;
  dyld4::RuntimeState *v8;

  if ((a6 & 1) == 0 && *(_BYTE *)(a5 + 36) && (*(_BYTE *)(a5 + 32) & 1) == 0)
  {
    v6 = (unint64_t *)(a1[5] + a4 - a1[4]);
    v7 = *v6 & 0xFFFFFFFFFFFFFFFCLL | 2;
    v8 = (dyld4::RuntimeState *)a1[6];
    if (*(_BYTE *)(*((_QWORD *)v8 + 1) + 202))
      dyld4::RuntimeState::log(v8, "fixup: *0x%012lX = 0x%012lX <mark swift stable>\n", v6, v7);
    *v6 = v7;
  }
}

const os_unfair_lock *dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  lsl::Lock *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13[2];
  lsl::Lock *v14;

  v2 = (lsl::Lock *)*((_QWORD *)a2 + 16);
  v13[0] = (uint64_t)a2;
  v13[1] = (uint64_t)this;
  lsl::MemoryManager::lockGuard(v2, &v14);
  v3 = *((_QWORD *)v2 + 3);
  if (!v3)
  {
    lsl::MemoryManager::writeProtect(v2, 0);
    v3 = *((_QWORD *)v2 + 3);
  }
  *((_QWORD *)v2 + 3) = v3 + 1;
  lsl::Lock::unlock(v14);
  dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(dyld4::RuntimeState &)const::$_0::operator()(v13, v4, v5, v6, v7, v8, v9, v10);
  lsl::MemoryManager::lockGuard(v2, &v14);
  v11 = *((_QWORD *)v2 + 3) - 1;
  *((_QWORD *)v2 + 3) = v11;
  if (!v11)
    lsl::MemoryManager::writeProtect(v2, 1);
  return lsl::Lock::unlock(v14);
}

void dyld4::JustInTimeLoader::loadDependents(uint64_t a1, Diagnostics *a2, dyld4::RuntimeState *a3, __int128 *a4)
{
  mach_o::Error *v8;
  __int128 v9;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  __int128 v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[2];
  _QWORD v22[9];
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  int v26;

  if ((*(_BYTE *)(a1 + 42) & 1) == 0)
  {
    v23 = 0;
    v24 = &v23;
    v25 = 0x2000000000;
    v26 = 0;
    v8 = *(mach_o::Error **)(a1 + 32);
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 0x40000000;
    v22[2] = ___ZN5dyld416JustInTimeLoader14loadDependentsER11DiagnosticsRNS_12RuntimeStateERKNS_6Loader11LoadOptionsE_block_invoke;
    v22[3] = &unk_1E4F7D288;
    v22[4] = &v23;
    v22[5] = a1;
    v22[6] = a3;
    v22[7] = a4;
    v22[8] = a2;
    mach_o::Header::forEachLinkedDylib(v8, (uint64_t)v22);
    *(_QWORD *)(a1 + 40) |= 0x10000uLL;
    if (!Diagnostics::hasError(a2))
    {
      v21[0] = *((_QWORD *)a4 + 2);
      v21[1] = a1;
      v9 = a4[1];
      v10 = *((_QWORD *)a4 + 4);
      v17 = *a4;
      v19 = *((_QWORD *)&v9 + 1);
      v20 = v10;
      v18 = v21;
      v11 = v24;
      *((_DWORD *)v24 + 6) = 0;
      v12 = *(_QWORD *)(a1 + 40);
      if ((v12 & 0x7FFF8000000000) != 0)
      {
        v13 = 0;
        do
        {
          v14 = *(_QWORD *)(a1 + 8 * v13 + 464);
          if (v14)
          {
            dyld4::Loader::loadDependents(v14, a2, a3, &v17);
            v11 = v24;
          }
          v13 = *((_DWORD *)v11 + 6) + 1;
          *((_DWORD *)v11 + 6) = v13;
          v12 = *(_QWORD *)(a1 + 40);
        }
        while (v13 < (unsigned __int16)(v12 >> 39));
      }
      if ((v12 & 0x400000) != 0)
      {
        *(_QWORD *)(a1 + 88) = dyld4::JustInTimeLoader::makePatchTable((dyld4::JustInTimeLoader *)a1, a3, (v12 >> 24) & 0x7FFF);
        *(_QWORD *)(a1 + 96) = 0;
        if (*(_BYTE *)(*((_QWORD *)a3 + 1) + 157))
        {
          v16 = dyld4::Loader::indexOfUnzipperedTwin(a3, (const dyld4::RuntimeState *)(*(_DWORD *)(a1 + 43) & 0x7FFF), v15);
          if (v16 != 0xFFFF)
            *(_QWORD *)(a1 + 96) = dyld4::JustInTimeLoader::makePatchTable((dyld4::JustInTimeLoader *)a1, a3, v16);
        }
      }
    }
    _Block_object_dispose(&v23, 8);
  }
}

void dyld4::PrebuiltLoader::loadDependents(uint64_t a1, vm_address_t *a2, dyld4::RuntimeState *a3, __int128 *a4)
{
  __int16 v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  size_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  _QWORD v34[2];

  v8 = *(_WORD *)(a1 + 6);
  if (v8 >= 0)
    v9 = (uint64_t *)((char *)a3 + 1000);
  else
    v9 = (uint64_t *)((char *)a3 + 1024);
  v10 = *v9;
  v11 = v8 & 0x7FFF;
  dyld4::PrebuiltLoader::map(a1, a2, (uint64_t)a3);
  if (*(unsigned __int8 *)(v10 + v11) <= 3u)
  {
    *(_BYTE *)(v10 + v11) = 4;
    __chkstk_darwin(v12, v13, v14, v15, v16, v17, v18, v19, v31);
    v22 = (char *)&v31 - v21;
    if (v20 >= 0x200)
      v23 = 512;
    else
      v23 = v20;
    bzero((char *)&v31 - v21, v23);
    LODWORD(v24) = *(unsigned __int16 *)(a1 + 48);
    if (*(_WORD *)(a1 + 48))
    {
      v25 = 0;
      do
      {
        v26 = dyld4::PrebuiltLoader::dependent((_WORD *)a1, a3, v25, 0);
        *(_QWORD *)&v22[8 * v25] = v26;
        if (v26)
          dyld4::PrebuiltLoader::map(v26, a2, (uint64_t)a3);
        ++v25;
        v24 = *(unsigned __int16 *)(a1 + 48);
      }
      while (v25 < v24);
    }
    v34[0] = *((_QWORD *)a4 + 2);
    v34[1] = a1;
    v27 = a4[1];
    v31 = *a4;
    v32 = v27;
    v28 = *((_QWORD *)a4 + 4);
    BYTE11(v31) = *(_BYTE *)(a1 + 5) & 1;
    v33 = v28;
    *(_QWORD *)&v32 = v34;
    if ((_DWORD)v24)
    {
      v29 = 0;
      do
      {
        v30 = *(_QWORD *)&v22[8 * v29];
        if (v30)
        {
          dyld4::PrebuiltLoader::loadDependents(v30, a2, a3, &v31);
          LODWORD(v24) = *(unsigned __int16 *)(a1 + 48);
        }
        ++v29;
      }
      while (v29 < v24);
    }
    *(_BYTE *)(v10 + v11) = 5;
  }
}

void dyld4::PrebuiltLoader::map(uint64_t a1, vm_address_t *a2, uint64_t a3)
{
  __int16 v3;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  const char *v10;
  unsigned int v11;
  unint64_t v12;
  dyld3 *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  void *v19;
  uint64_t v20;
  vm_address_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[3];

  v3 = *(_WORD *)(a1 + 6);
  if (v3 >= 0)
    v4 = (uint64_t *)(a3 + 1000);
  else
    v4 = (uint64_t *)(a3 + 1024);
  v5 = *v4;
  v6 = v3 & 0x7FFF;
  if (*(unsigned __int8 *)(*v4 + v6) > 2u)
    return;
  if (*(_BYTE *)(*(_QWORD *)(a3 + 8) + 207))
  {
    if ((*(_WORD *)(a1 + 4) & 2) != 0 || *(_QWORD *)(a3 + 336) <= v6)
    {
      if (*(_WORD *)(a1 + 32))
        v10 = (const char *)(a1 + *(unsigned __int16 *)(a1 + 32));
      else
        v10 = 0;
    }
    else
    {
      v10 = *(const char **)(*(_QWORD *)(a3 + 328) + 8 * v6);
    }
    dyld4::RuntimeState::log((dyld4::RuntimeState *)a3, "using PrebuiltLoader %p for %s\n", (const void *)a1, v10);
  }
  v11 = *(unsigned __int16 *)(a1 + 4);
  if ((v11 & 2) != 0)
  {
    *(_BYTE *)(v5 + v6) = 3;
    v14 = *(_BYTE **)(a3 + 8);
    if (v14[201])
    {
      dyld4::Loader::logSegmentsFromSharedCache((dyld4::Loader *)a1, (dyld4::RuntimeState *)a3);
      v14 = *(_BYTE **)(a3 + 8);
    }
    if (v14[200])
    {
      if ((*(_WORD *)(a1 + 4) & 2) != 0 || (v15 = *(_WORD *)(a1 + 6) & 0x7FFF, *(_QWORD *)(a3 + 336) <= v15))
      {
        if (*(_WORD *)(a1 + 32))
          v16 = (char *)(a1 + *(unsigned __int16 *)(a1 + 32));
        else
          v16 = 0;
      }
      else
      {
        v16 = *(char **)(*(_QWORD *)(a3 + 328) + 8 * v15);
      }
      dyld4::Loader::logLoad((dyld4::Loader *)a1, (dyld4::RuntimeState *)a3, v16);
      v14 = *(_BYTE **)(a3 + 8);
    }
    if (v14[157] && (*(_WORD *)(a1 + 44) & 8) != 0)
      *(_BYTE *)(a3 + 1159) = 1;
  }
  else if (*(_QWORD *)(a3 + 24) == a1)
  {
    if (*(unsigned __int8 *)(v5 + v6) <= 2u)
      *(_BYTE *)(v5 + v6) = 3;
    dyld4::PrebuiltLoader::setLoadAddress(a1, a3, *(_QWORD *)(*(_QWORD *)(a3 + 8) + 8));
  }
  else
  {
    v12 = *(_WORD *)(a1 + 6) & 0x7FFF;
    if (*(_QWORD *)(a3 + 336) <= v12)
    {
      if (*(_WORD *)(a1 + 32))
        v13 = (dyld3 *)(a1 + *(unsigned __int16 *)(a1 + 32));
      else
        v13 = 0;
    }
    else
    {
      v13 = *(dyld3 **)(*(_QWORD *)(a3 + 328) + 8 * v12);
    }
    v17 = *(unsigned int *)(a1 + 76);
    v18 = (unint64_t)*(unsigned __int16 *)(a1 + 44) >> 4;
    v28[0] = a1 + *(unsigned __int16 *)(a1 + 46);
    v28[1] = v18;
    v28[2] = v18;
    v19 = (void *)((v11 >> 5) & 1);
    if (*(_WORD *)(a1 + 42))
      v20 = a1 + *(unsigned __int16 *)(a1 + 42);
    else
      v20 = 0;
    LOBYTE(v27) = 1;
    v21 = dyld4::Loader::mapSegments(a2, (dyld4::SyscallDelegate **)a3, v13, v17, (unsigned int *)(a1 + 80), 1, v28, v19, v27, v20);
    if (Diagnostics::hasError((Diagnostics *)a2))
      return;
    dyld4::PrebuiltLoader::setLoadAddress(a1, a3, v21);
    *(_BYTE *)(v5 + v6) = 3;
    if (*(_BYTE *)(*(_QWORD *)(a3 + 8) + 200))
    {
      if ((*(_WORD *)(a1 + 4) & 2) != 0 || (v22 = *(_WORD *)(a1 + 6) & 0x7FFF, *(_QWORD *)(a3 + 336) <= v22))
      {
        if (*(_WORD *)(a1 + 32))
          v23 = (char *)(a1 + *(unsigned __int16 *)(a1 + 32));
        else
          v23 = 0;
      }
      else
      {
        v23 = *(char **)(*(_QWORD *)(a3 + 328) + 8 * v22);
      }
      dyld4::Loader::logLoad((dyld4::Loader *)a1, (dyld4::RuntimeState *)a3, v23);
    }
  }
  if (*(_DWORD *)(*(_QWORD *)(a3 + 8) + 540) && (v24 = *(_QWORD *)(a3 + 48)) != 0)
  {
    v25 = *(_QWORD **)(a3 + 40);
    v26 = 8 * v24;
    while (*v25 != a1)
    {
      ++v25;
      v26 -= 8;
      if (!v26)
        goto LABEL_53;
    }
  }
  else
  {
LABEL_53:
    dyld4::RuntimeState::add((dyld4::RuntimeState *)a3, (const dyld4::Loader *)a1);
  }
}

void __chkstk_darwin_probe(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t v9;
  uint64_t *v10;

  v10 = &a9;
  if (v9 >= 0x1000)
  {
    do
    {
      v10 -= 512;
      v9 -= 4096;
    }
    while (v9 > 0x1000);
  }
}

void ___chkstk_darwin(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __chkstk_darwin_probe(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

void bzero(void *a1, size_t a2)
{
  unint64_t v2;
  char *v3;
  BOOL v8;
  char *v9;

  if (a2 < 0x40)
    JUMPOUT(0x1A5C65AB0);
  if (a2 < 0x8000)
    JUMPOUT(0x1A5C65A50);
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 0;
  *((_QWORD *)a1 + 4) = 0;
  *((_QWORD *)a1 + 5) = 0;
  *((_QWORD *)a1 + 6) = 0;
  *((_QWORD *)a1 + 7) = 0;
  v2 = ((unint64_t)a1 + 64) & 0xFFFFFFFFFFFFFFC0;
  v3 = (char *)a1 + a2 - v2 - 64;
  if ((unint64_t)a1 + a2 > v2 + 64)
  {
    do
    {
      __asm { DC              ZVA, X3 }
      v2 += 64;
      v8 = (unint64_t)v3 > 0x40;
      v3 -= 64;
    }
    while (v8);
  }
  v9 = &v3[v2];
  *(_QWORD *)v9 = 0;
  *((_QWORD *)v9 + 1) = 0;
  *((_QWORD *)v9 + 2) = 0;
  *((_QWORD *)v9 + 3) = 0;
  *((_QWORD *)v9 + 4) = 0;
  *((_QWORD *)v9 + 5) = 0;
  *((_QWORD *)v9 + 6) = 0;
  *((_QWORD *)v9 + 7) = 0;
}

void *__cdecl _platform_memset(void *__b, int __c, size_t __len)
{
  uint64_t v3;
  uint64_t *v4;
  char *v5;
  char *v6;
  BOOL v7;
  unint64_t j;
  uint64_t *v9;
  char *v10;
  BOOL v11;
  size_t i;

  v3 = 0x101010101010101 * __c;
  v4 = (uint64_t *)__b;
  if (__len < 0x40)
  {
    while (1)
    {
      v11 = __len >= 8;
      __len -= 8;
      if (!v11)
        break;
      *v4++ = v3;
    }
    for (i = __len + 8; i; --i)
    {
      *(_BYTE *)v4 = v3;
      v4 = (uint64_t *)((char *)v4 + 1);
    }
  }
  else
  {
    if (__len < 0x8000)
    {
      *(_QWORD *)__b = v3;
      *((_QWORD *)__b + 1) = v3;
      *((_QWORD *)__b + 2) = v3;
      *((_QWORD *)__b + 3) = v3;
      *((_QWORD *)__b + 4) = v3;
      *((_QWORD *)__b + 5) = v3;
      *((_QWORD *)__b + 6) = v3;
      *((_QWORD *)__b + 7) = v3;
      v5 = (char *)(((unint64_t)__b + 64) & 0xFFFFFFFFFFFFFFC0);
      v10 = (char *)__b + __len;
      v7 = v10 > v5 + 64;
      for (j = v10 - (v5 + 64); v7; j -= 64)
      {
        *(_QWORD *)v5 = v3;
        *((_QWORD *)v5 + 1) = v3;
        *((_QWORD *)v5 + 2) = v3;
        *((_QWORD *)v5 + 3) = v3;
        *((_QWORD *)v5 + 4) = v3;
        *((_QWORD *)v5 + 5) = v3;
        *((_QWORD *)v5 + 6) = v3;
        *((_QWORD *)v5 + 7) = v3;
        v5 += 64;
        v7 = j > 0x40;
      }
    }
    else
    {
      if (!v3)
        JUMPOUT(0x1A5C6597CLL);
      *(_QWORD *)__b = v3;
      *((_QWORD *)__b + 1) = v3;
      *((_QWORD *)__b + 2) = v3;
      *((_QWORD *)__b + 3) = v3;
      *((_QWORD *)__b + 4) = v3;
      *((_QWORD *)__b + 5) = v3;
      *((_QWORD *)__b + 6) = v3;
      *((_QWORD *)__b + 7) = v3;
      v5 = (char *)(((unint64_t)__b + 64) & 0xFFFFFFFFFFFFFFC0);
      v6 = (char *)__b + __len;
      v7 = v6 > v5 + 64;
      for (j = v6 - (v5 + 64); v7; j -= 64)
      {
        *(_QWORD *)v5 = v3;
        *((_QWORD *)v5 + 1) = v3;
        *((_QWORD *)v5 + 2) = v3;
        *((_QWORD *)v5 + 3) = v3;
        *((_QWORD *)v5 + 4) = v3;
        *((_QWORD *)v5 + 5) = v3;
        *((_QWORD *)v5 + 6) = v3;
        *((_QWORD *)v5 + 7) = v3;
        v5 += 64;
        v7 = j > 0x40;
      }
    }
    v9 = (uint64_t *)&v5[j];
    *v9 = v3;
    v9[1] = v3;
    v9[2] = v3;
    v9[3] = v3;
    v9[4] = v3;
    v9[5] = v3;
    v9[6] = v3;
    v9[7] = v3;
  }
  return __b;
}

void dyld4::RuntimeState::add(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  dyld3::MachOFile *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  const char *v11;

  lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 32, *((_QWORD *)this + 6) + 1);
  v4 = *((_QWORD *)this + 5);
  v5 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = v5 + 1;
  *(_QWORD *)(v4 + 8 * v5) = a2;
  if (!*((_QWORD *)this + 13) || !*((_QWORD *)this + 12))
  {
    if ((~*((unsigned __int16 *)a2 + 2) & 3) != 0)
    {
      v7 = (dyld3::MachOFile *)dyld4::Loader::mf(a2, this);
      if (!dyld3::MachOFile::isDylib(v7))
        return;
      v6 = dyld3::MachOFile::installName(v7);
    }
    else
    {
      v6 = (char *)dyld4::Loader::path(a2, this);
    }
    v8 = v6;
    if (v6)
    {
      v9 = *((_QWORD *)this + 1);
      v10 = *(_DWORD *)(v9 + 68);
      if (v10 == 10)
      {
        if (_platform_strcmp(v8, "/System/DriverKit/usr/lib/system/libdyld.dylib"))
        {
          v11 = "/System/DriverKit/usr/lib/libSystem.dylib";
          goto LABEL_20;
        }
LABEL_23:
        dyld4::RuntimeState::setDyldLoader(this, a2);
        return;
      }
      if (*(_BYTE *)(v9 + 169) && dyld3::MachOFile::isExclaveKitPlatform(v10, 0))
      {
        if (_platform_strlen(v8) < 0x13)
          return;
        if (!_platform_strcmp(v8 + 18, "/usr/lib/system/libdyld.dylib")
          || !_platform_strcmp(v8, "/usr/lib/system/libdyld.dylib"))
        {
          goto LABEL_23;
        }
        if (!_platform_strcmp(v8 + 18, "/usr/lib/libSystem.dylib"))
        {
LABEL_21:
          *((_QWORD *)this + 12) = a2;
          return;
        }
      }
      else if (!_platform_strcmp(v8, "/usr/lib/system/libdyld.dylib"))
      {
        goto LABEL_23;
      }
      v11 = "/usr/lib/libSystem.B.dylib";
LABEL_20:
      if (_platform_strcmp(v8, v11))
        return;
      goto LABEL_21;
    }
  }
}

void __chkstk_darwin(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (___chkstk_darwin)
    ___chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  else
    __chkstk_darwin_probe(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t dyld3::MachOFile::isExclaveKitPlatform(int a1, _DWORD *a2)
{
  uint64_t result;

  if (a1 == 20)
  {
    if (a2)
    {
      LODWORD(result) = 3;
LABEL_10:
      *a2 = result;
    }
    return 1;
  }
  if (a1 == 18)
  {
    if (a2)
    {
      LODWORD(result) = 2;
      goto LABEL_10;
    }
    return 1;
  }
  if (a1 != 16)
    return 0;
  result = 1;
  if (a2)
    goto LABEL_10;
  return result;
}

void dyld4::Loader::loadDependents(uint64_t a1, vm_address_t *a2, dyld4::RuntimeState *a3, __int128 *a4)
{
  if (*(_DWORD *)a1 != 1815378276)
    dyld4::Loader::loadDependents();
  if ((*(_WORD *)(a1 + 4) & 1) != 0)
    dyld4::PrebuiltLoader::loadDependents(a1, a2, a3, a4);
  else
    dyld4::JustInTimeLoader::loadDependents(a1, (Diagnostics *)a2, a3, a4);
}

void dyld4::Loader::applyFixupsGeneric(dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  dyld3::MachOLoaded *Address;
  uint64_t Slide;
  _BOOL4 hasError;
  uint64_t v18;
  _QWORD v19[8];
  _QWORD v20[9];
  _QWORD v21[7];
  _QWORD v22[9];

  Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(a1, a3);
  Slide = dyld3::MachOLoaded::getSlide(Address);
  if (dyld3::MachOFile::hasChainedFixups(Address))
  {
    if (!*(_DWORD *)(*((_QWORD *)a3 + 1) + 164)
      || !dyld3::MachOFile::hasChainedFixupsLoadCommand(Address)
      || *(_QWORD *)(a5 + 16) >> 4 > 0x270uLL
      || (dyld4::Loader::setUpPageInLinking(a1, a2, a3, Slide, a4, a5),
          hasError = Diagnostics::hasError((Diagnostics *)a2),
          Diagnostics::clearError((vm_address_t **)a2),
          hasError))
    {
      v18 = dyld3::MachOAnalyzer::chainStartsOffset(Address);
      v22[0] = _NSConcreteStackBlock;
      v22[1] = 0x40000000;
      v22[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke;
      v22[3] = &__block_descriptor_tmp_90;
      v22[4] = Address;
      v22[5] = a2;
      v22[6] = Slide;
      v22[7] = a5;
      v22[8] = a3;
      dyld3::MachOAnalyzer::withChainStarts((char *)Address, a2, v18, (uint64_t)v22);
    }
  }
  else if (dyld3::MachOFile::hasOpcodeFixups(Address))
  {
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000;
    v21[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_3;
    v21[3] = &__block_descriptor_tmp_93;
    v21[4] = Address;
    v21[5] = Slide;
    v21[6] = a3;
    dyld3::MachOAnalyzer::forEachRebaseLocation_Opcodes(Address, a2, (uint64_t)v21);
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 0x40000000;
      v20[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_4;
      v20[3] = &__block_descriptor_tmp_96_0;
      v20[4] = a1;
      v20[5] = Address;
      v20[6] = a5;
      v20[7] = a3;
      v20[8] = a8;
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 0x40000000;
      v19[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_5;
      v19[3] = &__block_descriptor_tmp_99_0;
      v19[4] = a1;
      v19[5] = Address;
      v19[6] = a6;
      v19[7] = a3;
      dyld3::MachOAnalyzer::forEachBindLocation_Opcodes(Address, a2, (uint64_t)v20, (uint64_t)v19);
    }
  }
}

mach_o::Error *mach_o::Header::forEachLoadCommand@<X0>(mach_o::Error *result@<X0>, uint64_t a2@<X1>, mach_o::Error *a3@<X8>)
{
  mach_o::Error *v4;
  int v6;
  uint64_t v7;
  char *v8;
  char *v9;
  int v10;
  char *i;
  uint64_t v12;
  char *v13;

  v4 = result;
  v6 = *(_DWORD *)result;
  if (*(_DWORD *)result == -17958193)
  {
    v7 = 32;
  }
  else
  {
    if (v6 != -17958194)
    {
      if ((v6 & 0xFEFFFFFF) == 0xCEFAEDFE)
        return mach_o::Error::Error(a3, "big endian mach-o file");
      else
        return mach_o::Error::Error(a3, "file does not start with MH_MAGIC[_64]: 0x%08X 0x%08X");
    }
    v7 = 28;
  }
  if (*((_DWORD *)result + 3) >= 0xDu)
    return mach_o::Error::Error(a3, "unknown mach-o filetype (%u)");
  if (*((_DWORD *)result + 4))
  {
    v8 = (char *)result + v7;
    v9 = (char *)result + v7 + *((unsigned int *)result + 5);
    v10 = 1;
    for (i = (char *)result + v7; ; i = v13)
    {
      if (i >= v9)
        return mach_o::Error::Error(a3, "malformed load command (%d of %d) at %p with mh=%p, off end of load commands");
      v12 = *((unsigned int *)i + 1);
      if (v12 <= 7)
        break;
      v13 = &i[v12];
      if (&i[v12] > v9 || v13 < v8)
        return mach_o::Error::Error(a3, "malformed load command (%d of %d) at %p with mh=%p, size (0x%X) is too large, load commands end at %p");
      result = (mach_o::Error *)(*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
      if (++v10 > *((_DWORD *)v4 + 4))
        goto LABEL_20;
    }
    return mach_o::Error::Error(a3, "malformed load command (%d of %d) at %p with mh=%p, size (0x%X) too small");
  }
  else
  {
LABEL_20:
    *(_QWORD *)a3 = 0;
  }
  return result;
}

uint64_t mach_o::Header::loadCommandToDylibKind(mach_o::Header *this, const dylib_command *a2)
{
  int v3;

  if (*((_DWORD *)this + 3) == 443815936 && *((_DWORD *)this + 2) == 28)
    return *((unsigned int *)this + 6);
  v3 = *(_DWORD *)this;
  if (*(int *)this > -2147483614)
  {
    if (v3 == -2147483613)
    {
      return 4;
    }
    else
    {
      if (v3 != 12)
        goto LABEL_14;
      return 0;
    }
  }
  else
  {
    if (v3 != -2147483624)
    {
      if (v3 == -2147483617)
        return 2;
LABEL_14:
      mach_o::Header::loadCommandToDylibKind();
    }
    return 1;
  }
}

void ___ZN5dyld416JustInTimeLoader14loadDependentsER11DiagnosticsRNS_12RuntimeStateERKNS_6Loader11LoadOptionsE_block_invoke(uint64_t a1, char *a2, int a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  int v9;
  uint64_t v10;
  char v11;
  char v12;
  uint64_t v13;
  DyldSharedCache **v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  dyld4::Loader **v18;
  uint64_t v19;
  dyld4::Loader *v20;
  dyld4::RuntimeState *v21;
  const char *v22;
  __int128 *v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  dyld4::Loader *Loader;
  char *v28;
  vm_address_t *v29;
  const char *v30;
  const char *v31;
  const char *v32;
  const char *v33;
  vm_address_t *v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  vm_address_t *v38;
  _QWORD v39[2];
  char v40[4];

  v9 = a3;
  v10 = *(_QWORD *)(a1 + 40);
  if ((~a3 & 0xA) == 0)
    v9 = a3 & 0xF7;
  if ((~v9 & 3) != 0)
    v11 = v9;
  else
    v11 = v9 & 0xFE;
  if ((*(_BYTE *)(v10 + 42) & 0x80) == 0)
    *(_BYTE *)dyld4::JustInTimeLoader::dependentAttrs(*(dyld4::JustInTimeLoader **)(a1 + 40), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)) = v11;
  v12 = v11 & 1;
  if ((*(_WORD *)(v10 + 4) & 2) != 0
    && (v11 & 1) != 0
    && (v13 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8),
        v15 = *(_QWORD *)(v13 + 240),
        v14 = (DyldSharedCache **)(v13 + 240),
        *(_DWORD *)v40 = 0,
        v15)
    && (dyld4::ProcessConfig::DyldCache::indexOfPath(v14, a2, (unsigned int *)v40) & 1) == 0)
  {
    v21 = *(dyld4::RuntimeState **)(a1 + 48);
    if (*(_BYTE *)(*((_QWORD *)v21 + 1) + 207))
    {
      if (*(_WORD *)(v10 + 40))
        v22 = (const char *)(v10 + *(unsigned __int16 *)(v10 + 40));
      else
        v22 = 0;
      dyld4::RuntimeState::log(v21, "Skipping shared cache weak-linked dylib '%s' from '%s'\n", a2, v22);
    }
    *(_QWORD *)(v10 + 8 * *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 464) = 0;
  }
  else
  {
    if (*a2 != 47)
      goto LABEL_25;
    v16 = *(_QWORD *)(a1 + 48);
    v17 = *(_QWORD *)(v16 + 48);
    if (!v17)
      goto LABEL_25;
    v18 = *(dyld4::Loader ***)(v16 + 40);
    v19 = 8 * v17;
    while (1)
    {
      v20 = *v18;
      if (dyld4::Loader::matchesPath(*v18, *(const dyld4::RuntimeState **)(a1 + 48), a2))
        break;
      ++v18;
      v19 -= 8;
      if (!v19)
        goto LABEL_25;
    }
    if (!v20)
    {
LABEL_25:
      v39[0] = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 16);
      v39[1] = v10;
      Diagnostics::Diagnostics((Diagnostics *)&v38);
      v23 = *(__int128 **)(a1 + 56);
      v24 = *v23;
      v25 = v23[1];
      v37 = *((_QWORD *)v23 + 4);
      v35 = v24;
      v36 = v25;
      BYTE11(v35) = *(_BYTE *)(v10 + 5) & 1;
      *(_QWORD *)&v36 = v39;
      BYTE2(v35) = v12;
      v26 = *((_QWORD *)v23 + 3);
      if (v26)
        Loader = (dyld4::Loader *)(*(uint64_t (**)(uint64_t, vm_address_t **, _QWORD, char *, __int128 *))(v26 + 16))(v26, &v38, *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 68), a2, &v35);
      else
        Loader = dyld4::Loader::getLoader(&v38, *(DyldSharedCache ****)(a1 + 48), a2, (uint64_t)&v35);
      v20 = Loader;
      if (Diagnostics::hasError((Diagnostics *)&v38))
      {
        dyld4::Loader::getUuidStr((unsigned __int8 *)v10, v40, v28);
        Diagnostics::Diagnostics((Diagnostics *)&v34);
        dyld4::Loader::tooNewErrorAddendum((dyld4::Loader *)v10, (Diagnostics *)&v34, *(dyld4::RuntimeState **)(a1 + 48));
        v29 = *(vm_address_t **)(a1 + 64);
        if (*(_WORD *)(v10 + 40))
          v30 = (const char *)(v10 + *(unsigned __int16 *)(v10 + 40));
        else
          v30 = 0;
        v31 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v34);
        v32 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v38);
        Diagnostics::error(v29, "Library not loaded: %s\n  Referenced from: <%s> %s%s\n  Reason: %s", a2, v40, v30, v31, v32);
        if (**(_BYTE **)(a1 + 56))
        {
          if (*(_WORD *)(v10 + 40))
            v33 = (const char *)(v10 + *(unsigned __int16 *)(v10 + 40));
          else
            v33 = 0;
          dyld4::RuntimeState::setLaunchMissingDylib(*(_QWORD **)(a1 + 48), a2, v33);
        }
        *a6 = 1;
        mach_o::Error::~Error(&v34);
      }
      mach_o::Error::~Error(&v38);
    }
    *(_QWORD *)(v10 + 8 * *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 464) = v20;
  }
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t dyld3::MachOFile::hasChainedFixupsLoadCommand(dyld3::MachOFile *this)
{
  return dyld3::MachOFile::hasLoadCommand(this, -2147483596);
}

void dyld4::Loader::makeSegmentsReadOnly(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  dyld3::MachOLoaded *Address;
  _QWORD v5[7];

  Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(this, a2);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld46Loader20makeSegmentsReadOnlyERNS_12RuntimeStateE_block_invoke;
  v5[3] = &__block_descriptor_tmp_114_0;
  v5[4] = this;
  v5[5] = dyld3::MachOLoaded::getSlide(Address);
  v5[6] = a2;
  dyld3::MachOFile::forEachSegment(Address, (uint64_t)v5);
}

void dyld4::PrebuiltLoader::applyObjCFixups(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2)
{
  uint64_t v3;
  char *v5;
  dyld3::MachOFile *Address;
  dyld3::MachOFile *v7;
  int v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  _QWORD v18[8];
  _QWORD v19[8];
  _QWORD v20[8];
  int v21;
  _QWORD v22[7];
  _QWORD v23[11];
  _QWORD v24[12];
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  _BYTE v31[24];
  dyld3::MachOFile *v32;
  dyld3::MachOFile *v33;

  if (this)
  {
    v3 = *((unsigned int *)this + 14);
    if ((_DWORD)v3)
    {
      v5 = (char *)this + v3;
      Address = (dyld3::MachOFile *)dyld4::PrebuiltLoader::loadAddress(this, a2);
      v32 = Address;
      v33 = Address;
      v7 = (dyld3::MachOFile *)dyld4::PrebuiltLoader::loadAddress(this, a2);
      v8 = dyld3::MachOFile::pointerSize(v7);
      v9 = (char *)Address + *(_QWORD *)v5;
      *((_DWORD *)v9 + 1) |= 0x80u;
      if (*(_BYTE *)(*((_QWORD *)a2 + 1) + 202))
        dyld4::RuntimeState::log(a2, "fixup: *0x%012lX = 0x%012lX <objc-info preoptimized>\n", v9, *(_QWORD *)v9);
      dyld3::MachOAnalyzer::makeVMAddrConverter(Address, 1, (uint64_t)v31);
      v10 = dyld3::MachOFile::preferredLoadAddress(Address);
      v11 = v10;
      v30 = v10;
      v12 = *((unsigned int *)v5 + 16);
      if ((_DWORD)v12)
      {
        v13 = *(_QWORD *)(*((_QWORD *)a2 + 127) + 56) + *(_QWORD *)(*((_QWORD *)a2 + 1) + 240);
        v14 = *((unsigned int *)v5 + 13);
        v26 = 0;
        v27 = &v26;
        v28 = 0x2000000000;
        v29 = 0;
        v24[0] = _NSConcreteStackBlock;
        v24[1] = 0x40000000;
        v24[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke;
        v24[3] = &unk_1E4F7D500;
        v24[6] = v14;
        v24[7] = v14;
        v24[4] = &v26;
        v24[5] = &v5[v12];
        v24[8] = v10;
        v24[9] = Address;
        v24[10] = v13;
        v24[11] = a2;
        v25 = v24;
        dyld3::MachOAnalyzer::forEachObjCProtocol(Address, *((_QWORD *)v5 + 4), v14, (uint64_t)v31, (uint64_t)&v25);
        _Block_object_dispose(&v26, 8);
      }
      v15 = *((unsigned int *)v5 + 18);
      if ((_DWORD)v15)
      {
        v16 = *(_QWORD *)(*((_QWORD *)a2 + 1) + 304);
        v17 = &v5[*((unsigned int *)v5 + 17)];
        v26 = 0;
        v27 = &v26;
        v28 = 0x2000000000;
        v29 = 0;
        v23[0] = _NSConcreteStackBlock;
        v23[1] = 0x40000000;
        v23[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_2;
        v23[3] = &unk_1E4F7D528;
        v23[6] = v15;
        v23[7] = v15;
        v23[4] = &v26;
        v23[5] = v17;
        v23[8] = v16;
        v23[9] = a2;
        v23[10] = Address;
        dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique(a2, this, v11, (uint64_t)v5, (uint64_t)v23);
        _Block_object_dispose(&v26, 8);
      }
      if (v5[56])
      {
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000;
        v22[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_3;
        v22[3] = &__block_descriptor_tmp_35_0;
        v22[4] = v11;
        v22[5] = Address;
        v22[6] = a2;
        v26 = v22;
        dyld3::MachOAnalyzer::forEachObjCClass(Address, *((_QWORD *)v5 + 2), *((unsigned int *)v5 + 11), (uint64_t)v31, (uint64_t)&v26);
      }
      if (v5[57])
      {
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 0x40000000;
        v20[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_4;
        v20[3] = &__block_descriptor_tmp_36;
        v20[4] = &v30;
        v20[5] = &v33;
        v20[6] = &v32;
        v20[7] = a2;
        v21 = v8;
        v26 = v20;
        dyld3::MachOAnalyzer::forEachObjCClass(Address, *((_QWORD *)v5 + 2), *((unsigned int *)v5 + 11), (uint64_t)v31, (uint64_t)&v26);
      }
      if (v5[58])
      {
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 0x40000000;
        v19[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_5;
        v19[3] = &__block_descriptor_tmp_38_0;
        v19[4] = &v30;
        v19[5] = &v33;
        v19[6] = &v32;
        v19[7] = a2;
        v26 = v19;
        dyld3::MachOAnalyzer::forEachObjCCategory(v33, *((_QWORD *)v5 + 3), *((unsigned int *)v5 + 12), (uint64_t)v31, (uint64_t)&v26);
      }
      if (v5[59])
      {
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 0x40000000;
        v18[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_6;
        v18[3] = &__block_descriptor_tmp_39;
        v18[4] = &v30;
        v18[5] = &v33;
        v18[6] = &v32;
        v18[7] = a2;
        v26 = v18;
        dyld3::MachOAnalyzer::forEachObjCProtocol(v33, *((_QWORD *)v5 + 4), *((unsigned int *)v5 + 13), (uint64_t)v31, (uint64_t)&v26);
      }
    }
  }
}

uint64_t dyld4::PrebuiltLoader::setLoadAddress(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;

  v3 = *(__int16 *)(a1 + 6);
  if ((v3 & 0x80000000) == 0)
    dyld4::PrebuiltLoader::setLoadAddress();
  return dyld4::RuntimeState::setAppLoadAddress(a2, v3 & 0x7FFF, a3);
}

uint64_t dyld4::RuntimeState::setAppLoadAddress(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(result + 1016);
  if (!v3)
    dyld4::RuntimeState::setAppLoadAddress();
  if (*(_DWORD *)(v3 + 12) <= a2)
    dyld4::RuntimeState::setAppLoadAddress();
  *(_QWORD *)(*(_QWORD *)(result + 1032) + 8 * a2) = a3;
  return result;
}

void dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique(dyld4::RuntimeState *a1, dyld4::Loader *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const dyld3::MachOAnalyzer *v10;
  unsigned int v11[8];
  vm_address_t *v12;

  Diagnostics::Diagnostics((Diagnostics *)&v12);
  v10 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(a2, a1);
  metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)v11, v10);
  if (Diagnostics::hasError((Diagnostics *)&v12))
    dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique();
  dyld4::forEachSelectorReferenceToUnique(v11, a3, a4, a5);
  dyld4::forEachClassSelectorReferenceToUnique(v11, a3, a4, a5);
  dyld4::forEachCategorySelectorReferenceToUnique(v11, a3, a4, a5);
  dyld4::forEachProtocolSelectorReferenceToUnique(v11, a3, a4, a5);
  mach_o::Error::~Error(&v12);
}

void objc_visitor::Visitor::forEachSelectorReference(unsigned int *a1, uint64_t a2)
{
  _QWORD v2[6];

  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = ___ZNK12objc_visitor7Visitor24forEachSelectorReferenceEU13block_pointerFv9VMAddressS1_PKcE_block_invoke;
  v2[3] = &unk_1E4F7E5A8;
  v2[4] = a2;
  v2[5] = a1;
  objc_visitor::Visitor::forEachSelectorReference(a1, (uint64_t)v2);
}

{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[3];
  _BYTE v11[24];
  unint64_t v12;
  char v13;

  objc_visitor::Visitor::findSection((uint64_t)a1, (uint64_t)objc_visitor::Visitor::findObjCDataSection(char const*)const::objcDataSegments, 3, (uint64_t)"__objc_selrefs", (uint64_t)v11);
  if (v13)
  {
    v4 = v12;
    v5 = *a1;
    v6 = v12 / v5;
    if (v12 % v5)
      objc_visitor::Visitor::forEachSelectorReference();
    v7 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v11);
    if (v4 >= v5)
    {
      v8 = v7;
      v9 = 0;
      do
      {
        metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v8 + v9 * *a1), v10);
        (*(void (**)(uint64_t, _QWORD *))(a2 + 16))(a2, v10);
        ++v9;
      }
      while (v6 != v9);
    }
  }
}

metadata_visitor::Visitor *metadata_visitor::Visitor::Visitor(metadata_visitor::Visitor *this, const dyld3::MachOAnalyzer *a2)
{
  *(_DWORD *)this = 0;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = dyld3::MachOFile::preferredLoadAddress(a2);
  *((_BYTE *)this + 24) = 1;
  *(_DWORD *)this = dyld3::MachOFile::pointerSize(a2);
  return this;
}

void objc_visitor::Visitor::forEachClass(unsigned int *a1, int a2, uint64_t a3)
{
  _BYTE v6[40];

  objc_visitor::Visitor::findSection((uint64_t)a1, (uint64_t)objc_visitor::Visitor::findObjCDataSection(char const*)const::objcDataSegments, 3, (uint64_t)"__objc_classlist", (uint64_t)v6);
  if (v6[32])
    objc_visitor::Visitor::forEachClass(a1, a2, (lsl::Allocator::Pool *)v6, a3);
}

uint64_t objc_visitor::Class::getBaseMethods@<X0>(uint64_t a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5;
  uint64_t v6;
  char *v7;
  uint64_t *v9[3];
  __n128 v10;

  objc_visitor::Class::getClassData(a1, a2, &v10);
  v5 = *a2;
  v6 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v10);
  if (v5 == 4)
    v7 = (char *)(v6 + 20);
  else
    v7 = (char *)(v6 + 32);
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

__n128 objc_visitor::Class::getClassData@<Q0>(uint64_t a1@<X0>, int *a2@<X1>, __n128 *a3@<X8>)
{
  int v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  __n128 *v12;
  char *v13;
  __n128 result;
  _QWORD v15[3];
  _QWORD v16[3];
  uint64_t *v17[3];

  v5 = *a2;
  v6 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v5 == 4)
    v7 = (char *)(v6 + 16);
  else
    v7 = (char *)(v6 + 32);
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v17);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v17, v16);
  v8 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v16);
  if (!v9)
    std::__throw_bad_optional_access[abi:nn180100]();
  v10 = 4294967292;
  if (*a2 != 4)
    v10 = 0x7FFFFFFFFFF8;
  v11 = v10 & v8;
  if (v11 == v8)
  {
    v12 = (__n128 *)v16;
  }
  else
  {
    v13 = (char *)(lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v16) + v11 - v8);
    v12 = (__n128 *)v15;
    metadata_visitor::Visitor::getField((uint64_t)a2, v13, v15);
  }
  result = *v12;
  *a3 = *v12;
  a3[1].n128_u64[0] = v12[1].n128_u64[0];
  return result;
}

uint64_t objc_visitor::MethodList::numMethods(objc_visitor::MethodList *this)
{
  uint64_t v1;

  if (!*((_BYTE *)this + 24))
    return 0;
  v1 = lsl::Allocator::Pool::allocator(this);
  if (!v1)
    objc_visitor::MethodList::numMethods();
  return *(unsigned int *)(v1 + 4);
}

uint64_t ___ZN12objc_visitor7Visitor24forEachClassAndMetaClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t metadata_visitor::Visitor::resolveOptionalRebase@<X0>(uint64_t this@<X0>, uint64_t **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;

  v3 = **a2;
  if (v3)
  {
    if (!*(_BYTE *)(this + 24))
      std::__throw_bad_optional_access[abi:nn180100]();
    v4 = v3 - *(_QWORD *)(this + 8) + *(_QWORD *)(this + 16);
    *(_QWORD *)a3 = v3;
    *(_QWORD *)(a3 + 8) = v4;
    LOBYTE(v3) = 1;
    *(_QWORD *)(a3 + 16) = 1;
  }
  else
  {
    *(_BYTE *)a3 = 0;
  }
  *(_BYTE *)(a3 + 24) = v3;
  return this;
}

double objc_visitor::MethodList::getMethod@<D0>(lsl::Allocator::Pool *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  int *v7;
  int *v8;
  int v9;
  double result;
  __int128 v11;
  uint64_t v12;

  if (!*((_BYTE *)a1 + 24))
    objc_visitor::MethodList::getMethod();
  v7 = (int *)lsl::Allocator::Pool::allocator(a1);
  if (!v7)
    objc_visitor::MethodList::getMethod();
  v8 = v7;
  metadata_visitor::Visitor::getField(a2, (char *)v7 + (*v7 & 0xFFFCu) * a3 + 8, &v11);
  if (*v8 >= 0)
    v9 = 2;
  else
    v9 = (*v8 >> 30) & 1;
  result = *(double *)&v11;
  *(_OWORD *)(a4 + 8) = v11;
  *(_QWORD *)(a4 + 24) = v12;
  *(_DWORD *)a4 = v9;
  return result;
}

int *objc_visitor::Method::getName(int *result, uint64_t a2)
{
  int v3;
  metadata_visitor::ResolvedValue *v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  _QWORD v8[3];
  uint64_t *v9[3];

  v3 = *result;
  if (!*result)
  {
    v4 = (metadata_visitor::ResolvedValue *)(result + 2);
    v5 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    v6 = metadata_visitor::ResolvedValue::vmAddress(v4);
    if (!v7)
      std::__throw_bad_optional_access[abi:nn180100]();
    metadata_visitor::Visitor::getValueFor(a2, v6 + v5, 1, v9);
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    objc_visitor::Method::getNameField(result, a2, v9);
LABEL_8:
    metadata_visitor::Visitor::resolveRebase(a2, v9, v8);
    return (int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v8);
  }
  if (v3 == 1)
    objc_visitor::Method::getName();
  return result;
}

int *objc_visitor::Method::getNameVMAddr(int *result, uint64_t a2)
{
  int v3;
  metadata_visitor::ResolvedValue *v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  _QWORD v8[3];
  uint64_t *v9[3];

  v3 = *result;
  if (!*result)
  {
    v4 = (metadata_visitor::ResolvedValue *)(result + 2);
    v5 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    v6 = metadata_visitor::ResolvedValue::vmAddress(v4);
    if (!v7)
      std::__throw_bad_optional_access[abi:nn180100]();
    metadata_visitor::Visitor::getValueFor(a2, v6 + v5, 1, v9);
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    objc_visitor::Method::getNameField(result, a2, v9);
LABEL_8:
    metadata_visitor::Visitor::resolveRebase(a2, v9, v8);
    return (int *)metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v8);
  }
  if (v3 == 1)
    objc_visitor::Method::getNameVMAddr();
  return result;
}

int *objc_visitor::Method::getNameField@<X0>(int *result@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  int v4;
  char *v6;

  v4 = *result;
  if (*result == 2)
  {
    v6 = (char *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    return (int *)metadata_visitor::Visitor::getField(a2, v6, a3);
  }
  else
  {
    if (v4 == 1)
      objc_visitor::Method::getNameField();
    if (!v4)
      objc_visitor::Method::getNameField();
  }
  return result;
}

uint64_t objc_visitor::MethodList::usesRelativeOffsets(objc_visitor::MethodList *this)
{
  _DWORD *v1;

  if (!*((_BYTE *)this + 24))
    return 0;
  v1 = (_DWORD *)lsl::Allocator::Pool::allocator(this);
  if (!v1)
    objc_visitor::MethodList::usesRelativeOffsets();
  return *v1 >> 31;
}

uint64_t objc_visitor::Class::getISA@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, BOOL *a3@<X2>, _QWORD *a4@<X8>)
{
  char *v7;
  uint64_t *v9[3];

  v7 = (char *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  metadata_visitor::Visitor::getField(a2, v7, v9);
  return metadata_visitor::Visitor::resolveBindOrRebase(a2, v9, a3, a4);
}

uint64_t metadata_visitor::Visitor::resolveBindOrRebase@<X0>(uint64_t this@<X0>, uint64_t **a2@<X1>, BOOL *x2_0@<X2>, _QWORD *a3@<X8>)
{
  *x2_0 = 0;
  return metadata_visitor::Visitor::resolveRebase(this, a2, a3);
}

void objc_visitor::MethodList::getMethod()
{
  __assert_rtn("getMethod", "ObjCVisitor.cpp", 1048, "methodListPos.has_value()");
}

{
  __assert_rtn("getMethod", "ObjCVisitor.cpp", 1053, "methodList != nullptr");
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  if (!a1)
    abort_report_np("Assertion failed: (%s), file %s, line %d.\n", a4, a2, a3);
  abort_report_np("Assertion failed: (%s), function %s, file %s, line %d.\n", a4, a1, a2, a3);
}

void abort_report_np(char *__format, ...)
{
  char __str[1024];
  va_list va;

  va_start(va, __format);
  vsnprintf(__str, 0x400uLL, __format, va);
  dyld4::halt(__str, 0);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  vm_address_t *v8;
  const char *v9;

  v8 = (vm_address_t *)_simple_salloc();
  LODWORD(a4) = _simple_vsprintf((uint64_t)v8, (char *)__format, (int *)a4);
  v9 = (const char *)_simple_string((_BYTE **)v8);
  strlcpy(__str, v9, __size);
  _simple_sfree(v8);
  return (int)a4;
}

uint64_t metadata_visitor::Visitor::getField@<X0>(uint64_t this@<X0>, char *a2@<X2>, _QWORD *a3@<X8>)
{
  char *v4;

  if (!*(_BYTE *)(this + 24))
    std::__throw_bad_optional_access[abi:nn180100]();
  v4 = &a2[*(_QWORD *)(this + 16) - *(_QWORD *)(this + 8)];
  *a3 = a2;
  a3[1] = v4;
  a3[2] = 1;
  return this;
}

uint64_t ___ZNK12objc_visitor7Visitor24forEachSelectorReferenceEU13block_pointerFv9VMAddressS1_PKcE_block_invoke(uint64_t a1, uint64_t **a2)
{
  _QWORD v5[3];

  metadata_visitor::Visitor::resolveRebase(*(_QWORD *)(a1 + 40), a2, v5);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)a2);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v5);
  lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v5);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t lsl::Allocator::Pool::allocator(lsl::Allocator::Pool *this)
{
  return *(_QWORD *)this;
}

uint64_t metadata_visitor::ResolvedValue::vmAddress(metadata_visitor::ResolvedValue *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t metadata_visitor::Visitor::resolveRebase@<X0>(uint64_t this@<X0>, uint64_t **a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;

  v3 = **a2;
  if (v3)
  {
    if (!*(_BYTE *)(this + 24))
      std::__throw_bad_optional_access[abi:nn180100]();
    v4 = v3 - *(_QWORD *)(this + 8) + *(_QWORD *)(this + 16);
    *a3 = v3;
    a3[1] = v4;
    a3[2] = 1;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  return this;
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  dyld4::PrebuiltLoader::BindTargetRef *v7;
  unint64_t v8;
  const char *v9;
  uint64_t v10;
  dyld4::RuntimeState *v11;
  const char **v12;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v4 = *(unsigned int *)(v3 + 24);
  *(_DWORD *)(v3 + 24) = v4 + 1;
  if (*(_QWORD *)(a1 + 56) <= v4)
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(a1, a2, a3);
  v7 = (dyld4::PrebuiltLoader::BindTargetRef *)(*(_QWORD *)(a1 + 40) + 8 * v4);
  v8 = *(_QWORD *)v7;
  if ((*(_QWORD *)v7 & 0x8000000000000000) != 0)
  {
    v10 = (v8 >> 8) | 0x80000000000000;
    if ((v8 & 0x4000000000000000) == 0)
      v10 = (v8 >> 8) & 0x7FFFFFFFFFFFFFLL;
    v9 = (const char *)(*(_QWORD *)(a1 + 64) + (v10 | (v8 << 56)));
  }
  else
  {
    v9 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value(v7, *(dyld4::RuntimeState **)(a1 + 72), a3);
  }
  v11 = *(dyld4::RuntimeState **)(a1 + 72);
  v12 = (const char **)(*(_QWORD *)(a1 + 80) + a2);
  if (*(_BYTE *)(*((_QWORD *)v11 + 1) + 202))
    dyld4::RuntimeState::log(v11, "fixup: *0x%012lX = 0x%012lX <objc-selector '%s'>\n", v12, v9, v9);
  *v12 = v9;
}

void abort(void)
{
  dyld4::halt("dyld calling abort()\n", 0);
}

void objc_visitor::Visitor::forEachClassAndMetaClass(unsigned int *a1, uint64_t a2)
{
  _QWORD v2[5];

  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = ___ZN12objc_visitor7Visitor24forEachClassAndMetaClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke;
  v2[3] = &unk_1E4F7E580;
  v2[4] = a2;
  objc_visitor::Visitor::forEachClass(a1, 1, (uint64_t)v2);
}

uint64_t dyld3::MachOAnalyzer::forEachRebaseLocation_Opcodes(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  _BOOL8 hasError;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD v18[5];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _OWORD v26[7];
  _QWORD v27[5];

  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v26);
  hasError = Diagnostics::hasError((Diagnostics *)a2);
  if (hasError)
    return 0;
  __chkstk_darwin(hasError, v7, v8, v9, v10, v11, v12, v13, v17);
  v16 = &v18[-8 * v15 - 1];
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 0x40000000;
  v27[2] = ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
  v27[3] = &__block_descriptor_tmp_58_0;
  v27[4] = v16;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v27);
  if (Diagnostics::hasError((Diagnostics *)a2))
    return 0;
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  v18[2] = ___ZNK5dyld313MachOAnalyzer29forEachRebaseLocation_OpcodesER11DiagnosticsU13block_pointerFvyRbE_block_invoke;
  v18[3] = &unk_1E4F7F758;
  v22 = v26[3];
  v23 = v26[4];
  v24 = v26[5];
  v25 = v26[6];
  v19 = v26[0];
  v20 = v26[1];
  v21 = v26[2];
  v18[4] = a3;
  return dyld3::MachOAnalyzer::forEachRebase_Opcodes(a1, a2, (uint64_t)v26, (uint64_t)v16, (char *)v18);
}

void dyld3::MachOAnalyzer::forEachBindLocation_Opcodes(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[5];
  _QWORD v5[5];

  v4[4] = a4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke;
  v5[3] = &unk_1E4F7F708;
  v5[4] = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke_2;
  v4[3] = &unk_1E4F7F730;
  dyld3::MachOAnalyzer::forEachBindUnified_Opcodes(a1, a2, 0, (uint64_t)v5, (uint64_t)v4);
}

BOOL dyld4::Loader::hasConstantSegmentsToProtect(dyld4::Loader *this)
{
  return (*((_WORD *)this + 2) & 0x12) == 16;
}

uint64_t dyld4::Loader::dyldDoesObjCFixups(dyld4::Loader *this)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::dyldDoesObjCFixups();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::dyldDoesObjCFixups(this);
  else
    return dyld4::JustInTimeLoader::dyldDoesObjCFixups(this);
}

BOOL dyld4::PrebuiltLoader::dyldDoesObjCFixups(dyld4::PrebuiltLoader *this)
{
  uint64_t v1;

  if (this && (v1 = *((unsigned int *)this + 14), (_DWORD)v1))
    return *(_QWORD *)((char *)this + v1) != 0;
  else
    return (*((unsigned __int16 *)this + 2) >> 1) & 1;
}

__n128 dyld3::Array<_dyld_objc_notify_mapped_info>::push_back(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  _OWORD *v5;
  __n128 result;
  __int128 v7;

  v3 = a1[2];
  if (v3 >= a1[1])
    dyld4::RuntimeState::appendInterposingTuples((uint64_t)a1, a2, a3);
  v4 = *a1;
  a1[2] = v3 + 1;
  v5 = (_OWORD *)(v4 + 32 * v3);
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *v5 = *(_OWORD *)a2;
  v5[1] = v7;
  return result;
}

void dyld4::Loader::makeSegmentsReadWrite(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  dyld3::MachOLoaded *Address;
  _QWORD v5[7];

  Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(this, a2);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld46Loader21makeSegmentsReadWriteERNS_12RuntimeStateE_block_invoke;
  v5[3] = &__block_descriptor_tmp_116;
  v5[4] = this;
  v5[5] = dyld3::MachOLoaded::getSlide(Address);
  v5[6] = a2;
  dyld3::MachOFile::forEachSegment(Address, (uint64_t)v5);
}

void dyld4::RuntimeState::setDyldLoader(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  vm_address_t *v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  *((_QWORD *)this + 13) = a2;
  v5 = xmmword_1E4F7C908;
  v6 = unk_1E4F7C918;
  v7 = 2;
  Diagnostics::Diagnostics((Diagnostics *)&v4);
  if (dyld4::Loader::hasExportedSymbol((uint64_t)a2, (vm_address_t *)&v4, this, "__dyld_missing_symbol_abort", 1u, 1, (uint64_t *)&v5, 0))
  {
    *((_QWORD *)this + 14) = dyld4::Loader::resolvedAddress(this, (uint64_t)&v5);
    if ((_DWORD)v7 != 1)
      dyld4::RuntimeState::setDyldLoader();
    *((_QWORD *)this + 15) = v6;
  }
  mach_o::Error::~Error(&v4);
}

uint64_t ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke(_QWORD *a1, unsigned int *a2)
{
  vm_address_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[5];
  __int128 v10;
  uint64_t v11;

  v4 = a1[4];
  v3 = (vm_address_t *)a1[5];
  v5 = a1[6];
  v6 = a1[7];
  v7 = *(_QWORD *)(v6 + 16);
  v10 = *(_OWORD *)v6;
  v11 = v7;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_2;
  v9[3] = &__block_descriptor_tmp_89_0;
  v9[4] = a1[8];
  return dyld3::MachOLoaded::fixupAllChainedFixups(v4, v3, a2, v5, &v10, (uint64_t)v9);
}

uint64_t dyld3::MachOLoaded::fixupAllChainedFixups(uint64_t a1, vm_address_t *a2, unsigned int *a3, uint64_t a4, __int128 *a5, uint64_t a6)
{
  _QWORD v7[6];
  __int128 v8;
  uint64_t v9;
  vm_address_t *v10;
  uint64_t v11;

  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld311MachOLoaded21fixupAllChainedFixupsER11DiagnosticsPK28dyld_chained_starts_in_imagemNS_5ArrayIPKvEEU13block_pointerFvPvSA_E_block_invoke;
  v7[3] = &unk_1E4F7F160;
  v8 = *a5;
  v9 = *((_QWORD *)a5 + 2);
  v10 = a2;
  v11 = a4;
  v7[4] = a6;
  v7[5] = a1;
  return dyld3::MachOLoaded::forEachFixupInAllChains(a1, a2, a3, 1, (uint64_t)v7);
}

uint64_t dyld3::MachOLoaded::forEachFixupInAllChains(uint64_t result, vm_address_t *a2, unsigned int *a3, char a4, uint64_t a5)
{
  unint64_t v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = *a3;
  if ((_DWORD)v5)
  {
    v10 = result;
    v11 = 1;
    do
    {
      v12 = a3[v11];
      if ((_DWORD)v12)
      {
        result = dyld3::MachOLoaded::forEachFixupInSegmentChains(v10, a2, (uint64_t)a3 + v12, a4, a5);
        v5 = *a3;
      }
      ++v11;
    }
    while (v11 - 1 < v5);
  }
  return result;
}

uint64_t dyld3::MachOLoaded::forEachFixupInSegmentChains(uint64_t result, vm_address_t *a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int v11;
  __int16 v12;
  _QWORD v13[6];

  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  v13[2] = ___ZNK5dyld311MachOLoaded27forEachFixupInSegmentChainsER11DiagnosticsPK30dyld_chained_starts_in_segmentbU13block_pointerFvPN6mach_o25ChainedFixupPointerOnDiskES5_RbE_block_invoke;
  v13[3] = &unk_1E4F7F188;
  v13[4] = a5;
  v13[5] = a3;
  if (*(_WORD *)(a3 + 20))
  {
    v8 = result;
    v9 = 0;
    do
    {
      v10 = *(unsigned __int16 *)(a3 + 2 * v9 + 22);
      if ((_DWORD)v10 == 0xFFFF)
      {
        result = 0;
      }
      else if ((v10 & 0x8000) != 0)
      {
        v11 = v10 & 0x7FFF;
        do
        {
          v12 = *(_WORD *)(a3 + 2 * v11 + 22);
          result = dyld3::MachOFile::walkChain(a2, (unsigned int *)(v8 + *(_QWORD *)(a3 + 8) + v9 * *(unsigned __int16 *)(a3 + 4) + (v12 & 0x7FFF)), (mach_o::ChainedFixupPointerOnDisk *)*(unsigned __int16 *)(a3 + 6), a4, *(_DWORD *)(a3 + 16), (uint64_t)v13);
          if (v12 < 0)
            break;
          ++v11;
        }
        while ((result & 1) == 0);
      }
      else
      {
        result = dyld3::MachOFile::walkChain(a2, (unsigned int *)(v8 + *(_QWORD *)(a3 + 8) + v9 * *(unsigned __int16 *)(a3 + 4) + v10), (mach_o::ChainedFixupPointerOnDisk *)*(unsigned __int16 *)(a3 + 6), a4, *(_DWORD *)(a3 + 16), (uint64_t)v13);
      }
      ++v9;
    }
    while (v9 < *(unsigned __int16 *)(a3 + 20) && (result & 1) == 0);
  }
  return result;
}

uint64_t dyld3::MachOFile::walkChain(vm_address_t *a1, unsigned int *a2, mach_o::ChainedFixupPointerOnDisk *this, char a4, unsigned int a5, uint64_t a6)
{
  int v9;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  char v21;

  v9 = (int)this;
  v12 = mach_o::ChainedFixupPointerOnDisk::strideSize(this);
  v21 = 0;
  v14 = *a2;
  v13 = a2[1];
  (*(void (**)(uint64_t, unsigned int *, char *))(a6 + 16))(a6, a2, &v21);
  if (v21)
    return 1;
  while (2)
  {
    switch(v9)
    {
      case 1:
      case 7:
      case 9:
      case 10:
      case 12:
        v15 = (v13 >> 19) & 0x7FF;
        if (!v15)
          return 0;
        goto LABEL_17;
      case 2:
      case 6:
        v16 = (v13 >> 19) & 0xFFF;
        if (!v16)
          return 0;
        v17 = (4 * v16);
        goto LABEL_18;
      case 3:
        v18 = (v14 >> 26) & 0x1F;
        if (!v18)
          return 0;
        a2 = (unsigned int *)((char *)a2 + (4 * v18));
        if ((a4 & 1) == 0)
        {
          while (1)
          {
            v19 = *a2;
            if ((*a2 & 0x80000000) != 0 || (v19 & 0x3FFFFFF) <= a5)
              break;
            a2 = (unsigned int *)((char *)a2 + (HIBYTE(v19) & 0x7CLL));
          }
        }
        goto LABEL_19;
      case 5:
        if (!(v14 >> 26))
          return 0;
        v17 = HIBYTE(v14) & 0xFC;
        goto LABEL_18;
      case 8:
      case 11:
        v15 = (v13 >> 19) & 0xFFF;
        if (!v15)
          return 0;
        goto LABEL_17;
      case 13:
        v15 = (v13 >> 20) & 0x7FF;
        if (v15)
        {
LABEL_17:
          v17 = (v15 * v12);
LABEL_18:
          a2 = (unsigned int *)((char *)a2 + v17);
LABEL_19:
          v14 = *a2;
          v13 = a2[1];
          (*(void (**)(uint64_t, unsigned int *, char *))(a6 + 16))(a6, a2, &v21);
          if (v21)
            return 1;
          continue;
        }
        return 0;
      default:
        Diagnostics::error(a1, "unknown pointer format 0x%04X", v9);
        return 1;
    }
  }
}

uint64_t ___ZNK5dyld311MachOLoaded27forEachFixupInSegmentChainsER11DiagnosticsPK30dyld_chained_starts_in_segmentbU13block_pointerFvPN6mach_o25ChainedFixupPointerOnDiskES5_RbE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), a2, *(_QWORD *)(a1 + 40), a3);
}

uint64_t ___ZNK5dyld311MachOLoaded21fixupAllChainedFixupsER11DiagnosticsPK28dyld_chained_starts_in_imagemNS_5ArrayIPKvEEU13block_pointerFvPvSA_E_block_invoke(uint64_t a1, mach_o::ChainedFixupPointerOnDisk::Generic64 *this, uint64_t a3, _BYTE *a4)
{
  int v6;
  uint64_t v8;
  unint64_t v9;
  uint64_t result;
  uint64_t v11;
  unint64_t v12;

  v6 = *(unsigned __int16 *)(a3 + 6);
  if ((v6 | 4) != 6)
  {
    result = Diagnostics::error(*(vm_address_t **)(a1 + 72), "unsupported pointer chain format: 0x%04X");
    goto LABEL_14;
  }
  v8 = *(_QWORD *)this;
  if ((*(_QWORD *)this & 0x8000000000000000) != 0)
  {
    if ((v8 & 0xFFFFFFuLL) < *(_QWORD *)(a1 + 64))
    {
      v11 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * (v8 & 0xFFFFFF));
      v12 = mach_o::ChainedFixupPointerOnDisk::Generic64::signExtendedAddend(this);
LABEL_9:
      v9 = v12 + v11;
      goto LABEL_10;
    }
    result = Diagnostics::error(*(vm_address_t **)(a1 + 72), "out of range bind ordinal %d (max %llu)");
LABEL_14:
    *a4 = 1;
    return result;
  }
  if (v6 != 2)
  {
    v11 = *(_QWORD *)(a1 + 40);
    v12 = mach_o::ChainedFixupPointerOnDisk::Generic64::unpackedTarget(this);
    goto LABEL_9;
  }
  v9 = *(_QWORD *)(a1 + 80) + mach_o::ChainedFixupPointerOnDisk::Generic64::unpackedTarget(this);
LABEL_10:
  result = *(_QWORD *)(a1 + 32);
  if (result)
    result = (*(uint64_t (**)(uint64_t, mach_o::ChainedFixupPointerOnDisk::Generic64 *, unint64_t))(result + 16))(result, this, v9);
  *(_QWORD *)this = v9;
  return result;
}

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_2(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  dyld4::RuntimeState *v5;

  v5 = *(dyld4::RuntimeState **)(a1 + 32);
  if (*(_BYTE *)(*((_QWORD *)v5 + 1) + 202))
    dyld4::RuntimeState::log(v5, "fixup: *0x%012lX = 0x%012lX\n", a2, a3);
  *a2 = a3;
}

unint64_t mach_o::ChainedFixupPointerOnDisk::Generic64::unpackedTarget(mach_o::ChainedFixupPointerOnDisk::Generic64 *this)
{
  return *(_QWORD *)this & 0xFFFFFFFFFLL | ((unint64_t)(*(_QWORD *)this >> 36) << 56);
}

uint64_t mach_o::ChainedFixupPointerOnDisk::Generic64::signExtendedAddend(mach_o::ChainedFixupPointerOnDisk::Generic64 *this)
{
  return *((unsigned __int8 *)this + 3);
}

uint64_t mach_o::ChainedFixupPointerOnDisk::strideSize(mach_o::ChainedFixupPointerOnDisk *this)
{
  if (((_DWORD)this - 1) >= 0xD)
    mach_o::ChainedFixupPointerOnDisk::strideSize();
  return dword_1A5CBC14C[(__int16)((_WORD)this - 1)];
}

void dyld4::RuntimeState::buildInterposingTables(dyld4::RuntimeState *this)
{
  uint64_t v2;
  dyld4::Loader **v3;
  uint64_t v4;
  dyld4::Loader *v5;
  dyld3::MachOFile *v6;
  dyld3::MachOFile *v7;
  unint64_t v8;
  uint64_t v9;
  dyld4::Loader **v10;
  uint64_t v11;
  dyld4::Loader *v12;
  _DWORD *v13;
  _QWORD v14[7];
  _QWORD v15[7];
  vm_address_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  double (*v20)(uint64_t, uint64_t);
  _QWORD *(*v21)(_QWORD *);
  char *v22;
  uint64_t v23;
  uint64_t v24;
  vm_address_t address;
  vm_size_t size;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  int v30;
  char v31;

  if (*(_BYTE *)(*((_QWORD *)this + 1) + 190))
  {
    v27 = 0;
    v28 = &v27;
    v29 = 0x2000000000;
    v30 = 0;
    v17 = 0;
    v18 = &v17;
    v19 = 0x5002000000;
    v20 = __Block_byref_object_copy__74;
    v21 = __Block_byref_object_dispose__75;
    v22 = &v31;
    v23 = 8;
    address = 0;
    size = 0;
    v24 = 0;
    v2 = *((_QWORD *)this + 6);
    if (v2)
    {
      v3 = (dyld4::Loader **)*((_QWORD *)this + 5);
      v4 = 8 * v2;
      do
      {
        v5 = *v3;
        v6 = (dyld3::MachOFile *)dyld4::Loader::analyzer(*v3, this);
        if ((*((_WORD *)v5 + 2) & 2) == 0)
        {
          v7 = v6;
          if (dyld3::MachOFile::isDylib(v6))
          {
            Diagnostics::Diagnostics((Diagnostics *)&v16);
            v15[0] = _NSConcreteStackBlock;
            v15[1] = 0x40000000;
            v15[2] = ___ZN5dyld412RuntimeState22buildInterposingTablesEv_block_invoke;
            v15[3] = &unk_1E4F7CA90;
            v15[4] = &v27;
            v15[5] = &v17;
            v15[6] = v5;
            dyld3::MachOFile::forEachInterposingSection(v7, (uint64_t)&v16, (uint64_t)v15);
            mach_o::Error::~Error(&v16);
          }
        }
        ++v3;
        v4 -= 8;
      }
      while (v4);
      v8 = *((unsigned int *)v28 + 6);
      if ((_DWORD)v8)
      {
        lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)this + 160, v8);
        lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)this + 192, *((unsigned int *)v28 + 6));
        v9 = v18[7];
        if (v9)
        {
          v10 = (dyld4::Loader **)v18[5];
          v11 = 8 * v9;
          do
          {
            v12 = *v10++;
            Diagnostics::Diagnostics((Diagnostics *)&v16);
            v13 = (_DWORD *)dyld4::Loader::analyzer(v12, this);
            v14[0] = _NSConcreteStackBlock;
            v14[1] = 0x40000000;
            v14[2] = ___ZN5dyld412RuntimeState22buildInterposingTablesEv_block_invoke_2;
            v14[3] = &__block_descriptor_tmp_78;
            v14[4] = this;
            v14[5] = v12;
            v14[6] = v13;
            dyld3::MachOFile::forEachInterposingSection(v13, (uint64_t)&v16, (uint64_t)v14);
            mach_o::Error::~Error(&v16);
            v11 -= 8;
          }
          while (v11);
        }
      }
    }
    _Block_object_dispose(&v17, 8);
    v24 = 0;
    if (address)
      vm_deallocate(mach_task_self_, address, size);
    _Block_object_dispose(&v27, 8);
  }
}

BOOL dyld3::MachOFile::isDylib(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 6;
}

void dyld3::MachOFile::forEachInterposingSection(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  BOOL v3;
  int v4;
  _QWORD v5[7];
  int v6;
  int v7;

  v3 = *a1 == -17958193;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile25forEachInterposingSectionER11DiagnosticsU13block_pointerFvyyRbE_block_invoke;
  v5[3] = &unk_1E4F7EAC0;
  if (v3)
    v4 = 8;
  else
    v4 = 4;
  v5[5] = a1;
  v5[6] = a2;
  v6 = 2 * v4;
  v7 = v4;
  v5[4] = a3;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v5);
}

void (*dyld4::prepare(dyld4 *this, vm_address_t *a2, const dyld3::MachOAnalyzer *a3))(dyld4 *this, int a2, const char *const *a3, const char *const *a4, const char *const *a5)
{
  void *v4;
  uint64_t v5;
  const char **v6;
  const char *v7;
  const char **v8;
  const char *v9;
  uint64_t v10;
  const dyld4::Loader *LaunchLoader;
  const mach_o::Layout *v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL8 hasError;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  lsl::AllocatorLayout *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  lsl::Allocator *v51;
  size_t v52;
  uint64_t v53;
  lsl::AllocatorLayout *v54;
  uint64_t v55;
  const char **v56;
  const char **v57;
  lsl::Allocator *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  dyld4::DyldCacheDataConstLazyScopedWriter *v72;
  uint64_t v73;
  dyld4::Loader **v74;
  uint64_t v75;
  dyld4::Loader *v76;
  dyld4::RuntimeState *v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  uint64_t v84;
  vm_address_t *v85;
  stat *v86;
  int v87;
  uint64_t v88;
  unsigned __int8 (*v89)[16];
  fsobj_id st_dev;
  fsid v91;
  dyld4::Loader *v92;
  dyld3::MachOLoaded *Address;
  uint64_t SectionContent;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  dyld4::Loader **v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  void *v115;
  void *v116;
  void *v117;
  void *v118;
  void *v119;
  void *v120;
  BOOL v121;
  uint64_t v122;
  dyld4::Loader *v123;
  dyld4::Loader *v124;
  dyld3::MachOFile *v125;
  const char *v126;
  uint64_t is_enabled;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  void *v134;
  uint64_t v135;
  dyld4::Loader **v136;
  uint64_t v137;
  dyld4::Loader *v138;
  fsid v139;
  dyld3 *v140;
  stat *v141;
  fsobj_id v142;
  unsigned __int8 (*v143)[16];
  void *v144;
  fsobj_id v145;
  fsid v146;
  uint64_t v147;
  const dyld4::MissingPaths *v148;
  vm_address_t LaunchSet;
  const dyld4::PrebuiltLoaderSet *v150;
  const char *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  lsl::Allocator *v161;
  size_t v162;
  uint64_t v163;
  lsl::AllocatorLayout *v164;
  uint64_t v165;
  const char **v166;
  const char **v167;
  lsl::Allocator *v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  void *v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  void *v188;
  uint64_t v189;
  void (*v190)(dyld4 *, int, const char *const *, const char *const *, const char *const *);
  char *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  lsl::Allocator *v203;
  size_t v204;
  uint64_t v205;
  lsl::AllocatorLayout *v206;
  uint64_t v207;
  const char **v208;
  const char **v209;
  unint64_t v210;
  vm_address_t **v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  char *v215;
  const char *v216;
  const void *v217;
  void *v218;
  vm_address_t *v219;
  uint64_t v220;
  _BOOL4 v221;
  vm_address_t *v222[2];
  unint64_t v223;
  stat v224;
  _QWORD v225[6];
  __darwin_ino64_t st_ino;
  unint64_t v227;
  unint64_t v228;
  __int128 v229;
  _QWORD *v230;
  uint64_t v231;
  _QWORD *v232;
  vm_address_t *v233;
  _QWORD v234[5];
  uint64_t v235;
  uint64_t *v236;
  uint64_t v237;
  __n128 (*v238)(uint64_t, uint64_t);
  void (*v239)(uint64_t);
  _BYTE v240[24];
  _QWORD v241[6];
  __int16 v242;
  int v243;
  __int16 v244;
  uint64_t v245;
  _QWORD *v246;
  uint64_t v247;
  uint64_t v248;
  _QWORD v249[2];
  uint64_t v250;
  uint64_t *v251;
  uint64_t v252;
  double (*v253)(uint64_t, uint64_t);
  _QWORD *(*v254)(_QWORD *);
  _QWORD v255[2];
  uint64_t v256;
  vm_address_t v257;
  vm_size_t v258;
  __darwin_ino64_t v259;
  uint64_t v260;
  char v261;

  v219 = a2;
  if (dyld3::kdebug_trace_dyld_enabled((dyld3 *)0x1F070004, a2))
    v218 = dyld3::kdebug_trace_dyld_duration_start((void *)0x1F070004, *(_QWORD *)(*((_QWORD *)this + 1) + 8), 0, 0, 0, 0, 0, v4);
  else
    v218 = 0;
  v5 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v5 + 208))
  {
    if (!*(_BYTE *)(v5 + 185))
    {
      dyld4::RuntimeState::log(this, "Note: DYLD_PRINT_* disabled by AMFI\n");
      v5 = *((_QWORD *)this + 1);
    }
    if (!*(_BYTE *)(v5 + 190))
    {
      dyld4::RuntimeState::log(this, "Note: interposing disabled by AMFI\n");
      v5 = *((_QWORD *)this + 1);
    }
  }
  if (*(_BYTE *)(v5 + 209))
  {
    v6 = *(const char ***)(v5 + 120);
    v7 = *v6;
    if (*v6)
    {
      v8 = v6 + 1;
      do
      {
        dyld4::RuntimeState::log(this, "%s\n", v7);
        v9 = *v8++;
        v7 = v9;
      }
      while (v9);
    }
  }
  dyld4::RuntimeState::initializeClosureMode(this);
  v10 = *((_QWORD *)this + 127);
  if (v10)
  {
    if (!*(_DWORD *)(v10 + 12))
      __assert_rtn("atIndex", "PrebuiltLoader.h", 336, "loaderIndex < loadersArrayCount");
    LaunchLoader = (const dyld4::Loader *)(v10 + *(unsigned int *)(v10 + *(unsigned int *)(v10 + 16)));
    lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 32, *((unsigned int *)this + 261));
  }
  else
  {
    if (*((_QWORD *)this + 7) <= 0x1FFuLL)
      lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)this + 32, 0x200uLL);
    Diagnostics::Diagnostics((Diagnostics *)&v224);
    LaunchLoader = (const dyld4::Loader *)dyld4::JustInTimeLoader::makeLaunchLoader((dyld4::JustInTimeLoader *)&v224, this, *(dyld4::RuntimeState **)(*((_QWORD *)this + 1) + 8), *(const dyld3::MachOAnalyzer **)(*((_QWORD *)this + 1) + 16), 0, v12);
    if (Diagnostics::hasError((Diagnostics *)&v224))
    {
      v216 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v224);
      dyld4::RuntimeState::log(this, "%s in %s\n", v216, *(const char **)(*((_QWORD *)this + 1) + 16));
      v211 = (vm_address_t **)&v224;
      goto LABEL_139;
    }
    mach_o::Error::~Error((vm_address_t **)&v224);
  }
  dyld4::RuntimeState::setMainLoader(this, LaunchLoader);
  dyld4::RuntimeState::notifyDebuggerLoad(this, LaunchLoader);
  if ((*((_WORD *)LaunchLoader + 2) & 1) != 0)
  {
    v13 = 0;
  }
  else if (*((_BYTE *)this + 1040))
  {
    v13 = 1;
  }
  else
  {
    v13 = *((_BYTE *)this + 1041) != 0;
  }
  v250 = 0;
  v251 = &v250;
  v252 = 0x5002000000;
  v253 = __Block_byref_object_copy__20;
  v254 = __Block_byref_object_dispose__21;
  v255[0] = &v261;
  v255[1] = 16;
  v258 = 0;
  v256 = 0;
  v257 = 0;
  dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v255, 1);
  v14 = v256++;
  *(_QWORD *)(v255[0] + 8 * v14) = LaunchLoader;
  v249[0] = 0;
  v249[1] = LaunchLoader;
  v247 = 0;
  v248 = 0;
  v15 = *((_QWORD *)this + 1) + 400;
  v241[0] = _NSConcreteStackBlock;
  v241[1] = 0x40000000;
  v241[2] = ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke;
  v241[3] = &unk_1E4F7BEA8;
  v242 = 257;
  v243 = 0;
  v244 = 257;
  v245 = 0;
  v246 = v249;
  v241[4] = &v250;
  v241[5] = this;
  dyld4::ProcessConfig::PathOverrides::forEachInsertedDylib(v15, (uint64_t)v241);
  if (v251[7] != 1)
  {
    v16 = *((_QWORD *)this + 6);
    if (v16 == 1)
    {
      v17 = 1;
    }
    else
    {
      memmove(*((void **)this + 5), (const void *)(*((_QWORD *)this + 5) + 8), 8 * v16 - 8);
      v17 = *((_QWORD *)this + 6);
    }
    *((_QWORD *)this + 6) = v17 - 1;
    lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 32, v17);
    v18 = *((_QWORD *)this + 5);
    v19 = *((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = v19 + 1;
    *(_QWORD *)(v18 + 8 * v19) = LaunchLoader;
  }
  v235 = 0;
  v236 = &v235;
  v237 = 0x4002000000;
  v238 = __Block_byref_object_copy__26;
  v239 = __Block_byref_object_dispose__27;
  memset(v240, 0, sizeof(v240));
  v234[0] = _NSConcreteStackBlock;
  v234[1] = 0x40000000;
  v234[2] = ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_28;
  v234[3] = &unk_1E4F7BED0;
  v234[4] = &v235;
  Diagnostics::Diagnostics((Diagnostics *)&v233);
  DWORD2(v229) = 0;
  v231 = 0;
  v232 = 0;
  *(_QWORD *)&v229 = 0x100000000000101;
  v230 = v249;
  if (v13)
    v232 = v234;
  v28 = v251[7];
  if (v28)
  {
    v29 = (uint64_t *)v251[5];
    v30 = 8 * v28;
    while (1)
    {
      dyld4::Loader::loadDependents(*v29, (vm_address_t *)&v233, this, &v229);
      hasError = Diagnostics::hasError((Diagnostics *)&v233);
      if (hasError)
        break;
      ++v29;
      v30 -= 8;
      if (!v30)
      {
        v31 = v251[7];
        goto LABEL_38;
      }
    }
    v193 = v251[7];
    v194 = *((_QWORD *)this + 6);
    v195 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)hasError);
    __chkstk_darwin(v195, v195 - v193 + 8 * v194 + 64, v196, v197, v198, v199, v200, v201, (uint64_t)v217);
    v203 = (lsl::Allocator *)((char *)&v217 - v202);
    bzero((char *)&v217 - v202, v204);
    v205 = *((_QWORD *)this + 6);
    v207 = lsl::AllocatorLayout::minSize(v206);
    *(_QWORD *)&v224.st_dev = lsl::Allocator::stackAllocatorInternal(v203, (char *)(v207 - v193 + 8 * v205 + 64), v208, v209);
    memset(&v224.st_ino, 0, 24);
    lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v224, *((_QWORD *)this + 6) - v193);
    if (v193 == *((_QWORD *)this + 6))
    {
      v210 = *(_QWORD *)&v224.st_uid;
    }
    else
    {
      v210 = *(_QWORD *)&v224.st_uid;
      do
      {
        v212 = *((_QWORD *)this + 5);
        lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v224, v210 + 1);
        v213 = *(_QWORD *)(v212 + 8 * v193);
        v214 = *(_QWORD *)&v224.st_uid;
        v210 = ++*(_QWORD *)&v224.st_uid;
        *(_QWORD *)(v224.st_ino + 8 * v214) = v213;
        ++v193;
      }
      while (v193 != *((_QWORD *)this + 6));
    }
    st_ino = v224.st_ino;
    v227 = v210;
    dyld4::RuntimeState::notifyDebuggerLoad(this, (uint64_t)&st_ino);
    dyld4::ExternallyViewableState::disableCrashReportBacktrace((uint64_t)this + 568);
    v211 = &v233;
LABEL_139:
    v215 = (char *)Diagnostics::errorMessage((Diagnostics *)v211);
    dyld4::halt(v215, (uint64_t *)this + 81);
  }
  v31 = 0;
LABEL_38:
  __chkstk_darwin(hasError, v21, v22, v23, v24, v25, v26, v27, (uint64_t)v217);
  v34 = (char *)&v217 - ((v33 + 23) & 0xFFFFFFFFFFFFFFF0);
  v35 = *((_QWORD *)this + 6);
  st_ino = (__darwin_ino64_t)v34;
  v227 = v35;
  v228 = 0;
  if (v35)
  {
    v36 = 0;
    v37 = (uint64_t *)*((_QWORD *)this + 5);
    v38 = 8 * v35;
    do
    {
      v39 = *v37;
      if ((*(_WORD *)(*v37 + 4) & 2) == 0)
      {
        if (v36 >= v35)
LABEL_131:
          __assert_rtn("push_back", "Array.h", 64, "_usedCount < _allocCount");
        v228 = v36 + 1;
        *(_QWORD *)(st_ino + 8 * v36++) = v39;
      }
      ++v37;
      v38 -= 8;
    }
    while (v38);
  }
  v221 = v13;
  v220 = v32;
  dyld4::RuntimeState::addPermanentRanges((uint64_t)this, (uint64_t)&st_ino);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 161))
  {
    v40 = lsl::Allocator::malloc(*((lsl::Allocator **)this + 2), 0x60uLL);
    v41 = (lsl::AllocatorLayout *)dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)v40);
    *((_QWORD *)this + 46) = v41;
    v42 = *((_QWORD *)this + 6);
    v43 = lsl::AllocatorLayout::minSize(v41);
    __chkstk_darwin(v43, v43 + 8 * v42 + 64, v44, v45, v46, v47, v48, v49, (uint64_t)v217);
    v51 = (lsl::Allocator *)((char *)&v217 - v50);
    bzero((char *)&v217 - v50, v52);
    v53 = *((_QWORD *)this + 6);
    v55 = lsl::AllocatorLayout::minSize(v54);
    v58 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v51, (char *)(v55 + 8 * v53 + 64), v56, v57);
    *(_QWORD *)&v224.st_dev = v58;
    memset(&v224.st_ino, 0, 24);
    lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v224, *((_QWORD *)this + 6));
    v59 = *((_QWORD *)this + 6);
    v60 = *(_QWORD *)&v224.st_uid;
    if (v59)
    {
      v61 = (uint64_t *)*((_QWORD *)this + 5);
      v62 = 8 * v59;
      do
      {
        v63 = *v61++;
        lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v224, v60 + 1);
        v64 = *(_QWORD *)&v224.st_uid;
        v60 = ++*(_QWORD *)&v224.st_uid;
        *(_QWORD *)(v224.st_ino + 8 * v64) = v63;
        v62 -= 8;
      }
      while (v62);
    }
    v259 = v224.st_ino;
    v260 = v60;
    dyld4::Loader::addWeakDefsToMap(this, (uint64_t)&v259);
    if (v224.st_ino)
      lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v224, 0);
    lsl::Allocator::~Allocator(v58);
  }
  dyld4::RuntimeState::buildInterposingTables(this);
  v224.st_dev = 520552460;
  memset(&v224.st_ino, 0, 104);
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v224, v65, v66, v67, v68, v69, v70, v71);
  dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter((uint64_t)&v259, (uint64_t)this);
  dyld4::JustInTimeLoader::handleStrongWeakDefOverrides((uint64_t)this, (dyld4::RuntimeState *)&v259, v72);
  v73 = *((_QWORD *)this + 6);
  if (v73)
  {
    v74 = (dyld4::Loader **)*((_QWORD *)this + 5);
    v75 = 8 * v73;
    while (1)
    {
      v76 = *v74;
      Diagnostics::Diagnostics((Diagnostics *)v222);
      dyld4::Loader::applyFixups((uint64_t)v76, (Diagnostics *)v222, (uint64_t)this, (dyld4::DyldCacheDataConstLazyScopedWriter *)&v259, 1, 0);
      if (Diagnostics::hasError((Diagnostics *)v222))
        break;
      dyld4::Loader::applyCachePatches(v76, this, (dyld4::DyldCacheDataConstLazyScopedWriter *)&v259);
      mach_o::Error::~Error(v222);
      ++v74;
      v75 -= 8;
      if (!v75)
        goto LABEL_55;
    }
    v211 = v222;
    goto LABEL_139;
  }
LABEL_55:
  dyld4::RuntimeState::doSingletonPatching(this, (dyld4::DyldCacheDataConstLazyScopedWriter *)&v259);
  dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)&v259);
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v224);
  if (*((_QWORD *)this + 22))
    dyld4::Loader::applyInterposingToDyldCache(this, v77);
  if ((*((_WORD *)LaunchLoader + 2) & 1) != 0)
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter((uint64_t)&v224, (uint64_t)this);
    v84 = *((_QWORD *)this + 127);
    v225[0] = _NSConcreteStackBlock;
    v225[1] = 0x40000000;
    v225[2] = ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_2;
    v225[3] = &__block_descriptor_tmp_35;
    v225[4] = this;
    v225[5] = &v224;
    dyld4::PrebuiltLoaderSet::forEachCachePatch(v84, (uint64_t)v225);
    dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)&v224);
  }
  if (kdebug_is_enabled(0x1F050000u, (uint64_t)v77, v78, v79, v80, v81, v82, v83)
    && (dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)v219) & 1) == 0)
  {
    v260 = 0;
    v259 = 0;
    v85 = v219;
    dyld3::MachOFile::getUuid((dyld3::MachOFile *)v219, (unsigned __int8 *)&v259);
    v87 = dyld3::stat(*(dyld3 **)(*((_QWORD *)this + 1) + 72), &v224, v86);
    if (v87)
      v89 = 0;
    else
      v89 = (unsigned __int8 (*)[16])v224.st_ino;
    if (v87)
      st_dev = 0;
    else
      st_dev = (fsobj_id)v224.st_dev;
    v91 = (fsid)v85;
    dyld3::kdebug_trace_dyld_image(0, *(void **)(*((_QWORD *)this + 1) + 72), (void **)&v259, v89, st_dev, v91, (const void *)*((unsigned int *)v85 + 2), v88, v217);
  }
  v92 = (dyld4::Loader *)*((_QWORD *)this + 13);
  if (!v92)
  {
    v192 = "libdyld.dylib not found";
    goto LABEL_143;
  }
  Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(v92, this);
  v223 = 0;
  SectionContent = dyld3::MachOLoaded::findSectionContent(Address, "__TPRO_CONST", "__dyld4", &v223);
  if (!SectionContent)
  {
    v192 = "compatible libdyld.dylib not found";
    goto LABEL_143;
  }
  v95 = SectionContent;
  *(_QWORD *)SectionContent = this;
  v96 = dyld4::ExternallyViewableState::storeProcessInfoPointer((uint64_t)this + 568, (dyld_all_image_infos **)(SectionContent + 8));
  v104 = *((_QWORD *)this + 1);
  *(_QWORD *)(v95 + 16) = *(_QWORD *)(v104 + 8);
  v95 += 16;
  *((_QWORD *)this + 18) = v95;
  **(_QWORD **)(v95 + 32) = *(_QWORD *)(v104 + 136);
  v105 = *((_QWORD *)this + 1);
  v106 = *((_QWORD *)this + 18);
  **(_DWORD **)(v106 + 8) = *(_DWORD *)(v105 + 104);
  **(_QWORD **)(v106 + 16) = *(_QWORD *)(v105 + 112);
  **(_QWORD **)(*((_QWORD *)this + 18) + 24) = *(_QWORD *)(*((_QWORD *)this + 1) + 120);
  if (!*((_QWORD *)this + 12))
  {
    v192 = "program does not link with libSystem.B.dylib";
    goto LABEL_143;
  }
  __chkstk_darwin(v96, v97, v98, v99, v100, v101, v102, v103, (uint64_t)v217);
  v109 = (dyld4::Loader **)((char *)&v217 - ((v108 + 23) & 0xFFFFFFFFFFFFFFF0));
  if (!v107)
    __assert_rtn("operator[]", "Array.h", 56, "idx < _usedCount");
  v110 = 0;
  v111 = *((_QWORD *)this + 5);
  do
  {
    if (v107 == v110)
      goto LABEL_131;
    v112 = v110 + 1;
    v109[v110] = *(dyld4::Loader **)(v111 + 8 * v110);
    ++v110;
    v108 -= 8;
  }
  while (v108);
  v219 = (vm_address_t *)v240;
  if (v31 == -1)
    v113 = v112;
  else
    v113 = v31;
  dyld4::RuntimeState::partitionDelayLoads((uint64_t)this, v109, v112, v109, v113, 0);
  if (*(_QWORD *)(*((_QWORD *)this + 1) + 232))
    v121 = v113 == 0;
  else
    v121 = 1;
  if (!v121)
  {
    v122 = 8 * v113;
    do
    {
      v124 = *v109++;
      v123 = v124;
      v125 = (dyld3::MachOFile *)dyld4::Loader::mf(v124, this);
      if (dyld3::MachOFile::isMainExecutable(v125))
        v126 = "main";
      else
        v126 = "insert";
      dyld4::Loader::logChainToLinksWith(v123, this, v126);
      v122 -= 8;
    }
    while (v122);
  }
  is_enabled = kdebug_is_enabled(0x1F050000u, v114, v115, v116, v117, v118, v119, v120);
  if ((_DWORD)is_enabled)
  {
    v135 = *((_QWORD *)this + 6);
    if (v135)
    {
      v136 = (dyld4::Loader **)*((_QWORD *)this + 5);
      v137 = 8 * v135;
      do
      {
        v138 = *v136;
        v139 = (fsid)dyld4::Loader::loadAddress(*v136, this);
        if ((*((_WORD *)v138 + 2) & 2) != 0
          || (v140 = (dyld3 *)dyld4::Loader::path(v138, this), dyld3::stat(v140, &v224, v141)))
        {
          v142 = 0;
          v143 = 0;
        }
        else
        {
          v143 = (unsigned __int8 (*)[16])v224.st_ino;
          v142 = (fsobj_id)v224.st_dev;
        }
        v144 = (void *)dyld4::Loader::path(v138, this);
        v145 = v142;
        v146 = v139;
        is_enabled = dyld3::kdebug_trace_dyld_image(0, v144, (void **)v138 + 1, v143, v145, v146, (const void *)*((unsigned int *)v138 + 6), v147, v217);
        ++v136;
        v137 -= 8;
      }
      while (v137);
    }
  }
  if (v221)
  {
    v224.st_dev = 520552468;
    memset(&v224.st_ino, 0, 104);
    dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v224, v128, v129, v130, v131, v132, v133, v134);
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
      dyld4::RuntimeState::log(this, "building PrebuiltLoaderSet for main executable\n");
    Diagnostics::Diagnostics((Diagnostics *)&v259);
    LaunchSet = dyld4::PrebuiltLoaderSet::makeLaunchSet(&v259, this, (dyld4::RuntimeState *)(v236 + 5), v148);
    if (LaunchSet && (v150 = (const dyld4::PrebuiltLoaderSet *)LaunchSet, Diagnostics::noError((Diagnostics *)&v259)))
    {
      if (*((_BYTE *)this + 1041))
      {
        v192 = "dyld: PrebuiltLoaderSet expected but not found";
        goto LABEL_143;
      }
      if (dyld4::RuntimeState::saveAppPrebuiltLoaderSet(this, v150))
        *((_BYTE *)this + 1160) = 1;
      dyld4::PrebuiltLoaderSet::deallocate((vm_address_t)v150);
      *(_OWORD *)&v224.st_mtimespec.tv_nsec = xmmword_1A5CBAC50;
    }
    else if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
    {
      v151 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v259);
      dyld4::RuntimeState::log(this, "could not build PrebuiltLoaderSet: %s\n", v151);
    }
    mach_o::Error::~Error((vm_address_t **)&v259);
    is_enabled = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v224);
  }
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 194))
    goto LABEL_121;
  v152 = *((_QWORD *)this + 6);
  v153 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)is_enabled);
  __chkstk_darwin(v153, v153 + 8 * v152 + 64, v154, v155, v156, v157, v158, v159, (uint64_t)v217);
  v161 = (lsl::Allocator *)((char *)&v217 - v160);
  bzero((char *)&v217 - v160, v162);
  v163 = *((_QWORD *)this + 6);
  v165 = lsl::AllocatorLayout::minSize(v164);
  v168 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v161, (char *)(v165 + 8 * v163 + 64), v166, v167);
  *(_QWORD *)&v224.st_dev = v168;
  memset(&v224.st_ino, 0, 24);
  lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v224, *((_QWORD *)this + 6));
  v169 = *((_QWORD *)this + 6);
  v170 = *(_QWORD *)&v224.st_uid;
  if (v169)
  {
    v171 = (uint64_t *)*((_QWORD *)this + 5);
    v172 = 8 * v169;
    do
    {
      v173 = *v171++;
      lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v224, v170 + 1);
      v174 = *(_QWORD *)&v224.st_uid;
      v170 = ++*(_QWORD *)&v224.st_uid;
      *(_QWORD *)(v224.st_ino + 8 * v174) = v173;
      v172 -= 8;
    }
    while (v172);
  }
  v259 = v224.st_ino + 8 * v31;
  v260 = v170 - v31;
  dyld4::RuntimeState::notifyDebuggerLoad(this, (uint64_t)&v259);
  v222[0] = (vm_address_t *)v224.st_ino;
  v222[1] = *(vm_address_t **)&v224.st_uid;
  dyld4::RuntimeState::notifyDtrace((uint64_t)this, (uint64_t)v222);
  if (v224.st_ino)
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v224, 0);
  lsl::Allocator::~Allocator(v168);
  if (dyld4::ExternallyViewableState::notifyMonitorNeeded((dyld4 *)((char *)this + 568)))
    dyld4::ExternallyViewableState::notifyMonitorOfDyldBeforeInitializers((dyld4 *)((char *)this + 568), v175, v176, v177, v178, v179, v180, v181);
  (*(void (**)(dyld4 *))(*(_QWORD *)this + 856))(this);
  if (dyld4::ExternallyViewableState::notifyMonitorNeeded((dyld4 *)((char *)this + 568)))
    dyld4::ExternallyViewableState::notifyMonitorOfMainCalled((dyld4 *)((char *)this + 568), v182, v183, v184, v185, v186, v187, v188);
  if (dyld3::kdebug_trace_dyld_enabled((dyld3 *)0x1F070004, v182))
    dyld3::kdebug_trace_dyld_duration_end((int64_t)v218, (void *)0x1F070004, 0, 0, 0, 0, (void *)4, 0);
  v189 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v189 + 193))
  {
LABEL_121:
    v190 = dyld4::fake_main;
    goto LABEL_122;
  }
  if (*(_DWORD *)(v189 + 68) != 10)
  {
    *(_QWORD *)&v224.st_dev = 0;
    LOBYTE(v259) = 0;
    if (dyld3::MachOFile::getEntry(*(dyld3::MachOFile **)(v189 + 8), (unint64_t *)&v224, (BOOL *)&v259))
    {
      if (!(_BYTE)v259)
      {
        v190 = (void (*)(dyld4 *, int, const char *const *, const char *const *, const char *const *))(*(_QWORD *)&v224.st_dev + *(_QWORD *)(*((_QWORD *)this + 1) + 8));
        goto LABEL_122;
      }
      v192 = "main executable is missing LC_MAIN";
    }
    else
    {
      v192 = "main executable has no entry point";
    }
LABEL_143:
    dyld4::halt(v192, 0);
  }
  v190 = (void (*)(dyld4 *, int, const char *const *, const char *const *, const char *const *))*((_QWORD *)this + 132);
  if (!v190)
  {
    v192 = "DriverKit main entry point not set";
    goto LABEL_143;
  }
LABEL_122:
  mach_o::Error::~Error(&v233);
  _Block_object_dispose(&v235, 8);
  dyld4::BumpAllocator::~BumpAllocator(v219);
  _Block_object_dispose(&v250, 8);
  v256 = 0;
  if (v257)
    vm_deallocate(mach_task_self_, v257, v258);
  return v190;
}

uint64_t lsl::Vector<dyld4::Loader const*>::reserve(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  if (*(_QWORD *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      v2 = 16;
    }
    return lsl::Vector<dyld4::Loader const*>::reserveExact(result, v2);
  }
  return result;
}

void dyld4::Loader::applyCachePatches(dyld4::Loader *this, dyld4::RuntimeState *a2, dyld4::DyldCacheDataConstLazyScopedWriter *a3)
{
  dyld3::MachOFile *v6;
  _QWORD v7[10];
  unsigned __int16 v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  unsigned __int16 v18;

  v18 = 0;
  v17 = 0;
  if (dyld4::Loader::overridesDylibInCache((uint64_t)this, &v17, &v18) && v17)
  {
    v6 = *(dyld3::MachOFile **)(*((_QWORD *)a2 + 1) + 240);
    v13 = 0;
    v14 = &v13;
    v15 = 0x2000000000;
    v16 = 0;
    v9 = 0;
    v10 = &v9;
    v11 = 0x2000000000;
    v12 = v17;
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke;
    v7[3] = &unk_1E4F7D1C0;
    v7[6] = this;
    v7[7] = a2;
    v8 = v18;
    v7[8] = v6;
    v7[9] = a3;
    v7[4] = &v9;
    v7[5] = &v13;
    DyldSharedCache::forEachPatchableExport(v6, v18, (uint64_t)v7);
    if (*(_QWORD *)v10[3] != -1)
      dyld4::Loader::applyCachePatches();
    if (*((_BYTE *)v14 + 24))
      dyld4::RuntimeState::setVMAccountingSuspending(a2, 0);
    _Block_object_dispose(&v9, 8);
    _Block_object_dispose(&v13, 8);
  }
}

uint64_t dyld4::Loader::overridesDylibInCache(uint64_t a1, _QWORD *a2, _WORD *a3)
{
  if (*(_DWORD *)a1 != 1815378276)
    dyld4::Loader::overridesDylibInCache();
  if ((*(_WORD *)(a1 + 4) & 1) != 0)
    return dyld4::PrebuiltLoader::overridesDylibInCache(a1, a2, a3);
  else
    return dyld4::JustInTimeLoader::overridesDylibInCache(a1, a2, a3);
}

uint64_t dyld4::PrebuiltLoader::overridesDylibInCache(uint64_t a1, _QWORD *a2, _WORD *a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(unsigned __int16 *)(a1 + 44);
  if ((v3 & 8) != 0)
  {
    v4 = *(unsigned int *)(a1 + 88);
    if ((_DWORD)v4)
      v5 = a1 + v4;
    else
      v5 = 0;
    *a2 = v5;
    *a3 = *(_WORD *)(a1 + 60);
  }
  return (v3 >> 3) & 1;
}

int64_t dyld3::kdebug_trace_dyld_duration_end(int64_t result, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  void *v11;
  void *v13;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  int64_t v21;
  int64_t v22;
  int64_t v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;

  if (!result)
    return result;
  v11 = a5;
  v13 = a3;
  v15 = (void *)result;
  result = kdebug_is_enabled(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)result)
    return result;
  if (a4)
  {
    v21 = kdebug_trace_string(a2, 0, a4, v16, v17, v18, v19, v20);
    if (v21 == -1)
      v13 = 0;
    else
      v13 = (void *)v21;
  }
  if (a6)
  {
    v22 = kdebug_trace_string(a2, 0, a6, v16, v17, v18, v19, v20);
    if (v22 == -1)
      v11 = 0;
    else
      v11 = (void *)v22;
  }
  if (a8)
  {
    v23 = kdebug_trace_string(a2, 0, a8, v16, v17, v18, v19, v20);
    if (v23 == -1)
      v27 = 0;
    else
      v27 = (void *)v23;
    result = kdebug_trace((void *)(a2 | 2), v15, v13, v11, v27, v24, v25, v26);
    if (v27)
      result = kdebug_trace_string(a2, v27, 0, v28, v29, v30, v31, v32);
    if (!a6)
      goto LABEL_22;
    goto LABEL_20;
  }
  result = kdebug_trace((void *)(a2 | 2), v15, v13, v11, a7, v18, v19, v20);
  if (a6)
  {
LABEL_20:
    if (v11)
      result = kdebug_trace_string(a2, v11, 0, v28, v29, v30, v31, v32);
  }
LABEL_22:
  if (a4)
  {
    if (v13)
      return kdebug_trace_string(a2, v13, 0, v28, v29, v30, v31, v32);
  }
  return result;
}

void *dyld3::ScopedTimer::startTimer(dyld3::ScopedTimer *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  void *result;

  result = dyld3::kdebug_trace_dyld_duration_start((void *)*(unsigned int *)this, *((_QWORD *)this + 1), *((void **)this + 2), *((void **)this + 3), *((void **)this + 4), *((void **)this + 5), *((void **)this + 6), a8);
  *((_QWORD *)this + 13) = result;
  return result;
}

void *dyld3::kdebug_trace_dyld_duration_start(void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  void *v11;
  void *v13;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  unint64_t v20;
  void *v21;
  int64_t v22;
  int64_t v23;
  int64_t v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;

  v11 = a4;
  v13 = (void *)a2;
  if (!kdebug_is_enabled(a1, a2, a3, a4, a5, a6, a7, a8))
    return 0;
  do
  {
    v20 = __ldaxr(&dyld3::trace_pair_id);
    v21 = (void *)(v20 + 1);
  }
  while (__stlxr(v20 + 1, &dyld3::trace_pair_id));
  if (a3)
  {
    v22 = kdebug_trace_string(a1, 0, a3, v15, v16, v17, v18, v19);
    if (v22 == -1)
      v13 = 0;
    else
      v13 = (void *)v22;
  }
  if (a5)
  {
    v23 = kdebug_trace_string(a1, 0, a5, v15, v16, v17, v18, v19);
    if (v23 == -1)
      v11 = 0;
    else
      v11 = (void *)v23;
  }
  if (a7)
  {
    v24 = kdebug_trace_string(a1, 0, a7, v15, v16, v17, v18, v19);
    if (v24 == -1)
      v28 = 0;
    else
      v28 = (void *)v24;
    kdebug_trace((void *)(a1 | 1), v21, v13, v11, v28, v25, v26, v27);
    if (v28)
      kdebug_trace_string(a1, v28, 0, v29, v30, v31, v32, v33);
    if (!a5)
      goto LABEL_23;
    goto LABEL_21;
  }
  kdebug_trace((void *)(a1 | 1), v21, v13, v11, a6, v17, v18, v19);
  if (a5)
  {
LABEL_21:
    if (v11)
      kdebug_trace_string(a1, v11, 0, v29, v30, v31, v32, v33);
  }
LABEL_23:
  if (a3 && v13)
    kdebug_trace_string(a1, v13, 0, v29, v30, v31, v32, v33);
  return v21;
}

uint64_t dyld3::kdebug_trace_dyld_region(dyld3 *this, uint64_t a2, int a3, void *a4, void **a5, unsigned __int8 (*a6)[16], fsobj_id a7, fsid a8, const void *a9)
{
  __int16 v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;

  v15 = 4 * (_WORD)this;
  v16 = (void *)((4 * ((unsigned __int16)this & 0x3FFF)) | 0x1F050000u);
  v17 = (void *)kdebug_trace_string(v16, 0, a4, a4, a5, a6, *(void **)&a7, *(void **)&a8);
  kdebug_trace(v16, *a5, a5[1], *(void **)&a8, (void *)((int)a7.fid_objno | *(_QWORD *)&a7 & 0xFFFFFFFF00000000), v18, v19, v20);
  kdebug_trace((void *)((v15 + 4) & 0xFFFC | 0x1F050000u), a6, v17, (void *)(a3 | (unint64_t)(a2 << 32)), 0, v21, v22, v23);
  return kdebug_trace_string(v16, v17, 0, v24, v25, v26, v27, v28);
}

uint64_t __kdebug_trace64(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_kdebug_trace64, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

int64_t __kdebug_trace_string(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  int64_t result;

  result = mac_syscall(SYS_kdebug_trace_string, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror(result, a2, a3, a4, a5, a6, a7, a8);
  return result;
}

int64_t kdebug_trace_string(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  int *v17;

  if (!kdebug_is_enabled(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8))
    return 0;
  if (a2 != (void *)-1 && (a2 || a3))
    return __kdebug_trace_string(a1, a2, a3, v11, v12, v13, v14, v15);
  v17 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (!v17)
    v17 = &errno;
  *v17 = 22;
  return -1;
}

uint64_t kdebug_trace(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result;
  void *v14;
  void *v15;
  void *v16;

  result = kdebug_is_enabled(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
    return __kdebug_trace64(a1, a2, a3, a4, a5, v14, v15, v16);
  return result;
}

BOOL kdebug_is_enabled(unsigned int a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v9;
  mach_vm_address_t v11;
  uint64_t v13;
  mach_vm_address_t address;

  if (!MEMORY[0xFFFFFC100])
    return 0;
  if ((MEMORY[0xFFFFFC100] & 2) == 0)
    return 1;
  v9 = kdebug_typefilter_typefilter;
  if (!kdebug_typefilter_typefilter)
  {
    v13 = 0;
    address = 0;
    if (!__kdebug_typefilter(&address, &v13, a3, a4, a5, a6, a7, a8))
    {
      v11 = address;
      if (address)
      {
        while (!__ldaxr((unint64_t *)&kdebug_typefilter_typefilter))
        {
          if (!__stlxr(v11, (unint64_t *)&kdebug_typefilter_typefilter))
            goto LABEL_8;
        }
        __clrex();
        mach_vm_deallocate(mach_task_self_, address, 0x2000uLL);
      }
    }
LABEL_8:
    v9 = kdebug_typefilter_typefilter;
    if (!kdebug_typefilter_typefilter)
      return 1;
  }
  return ((*(unsigned __int8 *)(v9 + ((unint64_t)a1 >> 19)) >> (BYTE2(a1) & 7)) & 1) != 0;
}

uint64_t dyld3::ScopedTimer::endTimer(dyld3::ScopedTimer *this)
{
  return dyld3::kdebug_trace_dyld_duration_end(*((_QWORD *)this + 13), (void *)*(unsigned int *)this, *((void **)this + 7), *((void **)this + 8), *((void **)this + 9), *((void **)this + 10), *((void **)this + 11), *((void **)this + 12));
}

uint64_t dyld4::APIs::_dyld_find_unwind_sections(dyld4::APIs *this, char *a2, dyld3::MachOLoaded **a3)
{
  uint64_t ImageMappedAt;
  dyld3::MachOLoaded *v7;
  dyld4::Loader *v8;
  uint64_t (***v9)(char *);
  const char *UnwindSections;
  char *v11;
  uint64_t SectionContent;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v17;
  dyld4::Loader *v18;
  dyld3::MachOLoaded *v19;

  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_find_unwind_sections(%p, %p)\n", a2, a3);
  v18 = 0;
  v19 = 0;
  ImageMappedAt = dyld4::APIs::findImageMappedAt(this, a2, &v19, 0, 0, 0, 0, 0, &v18);
  if ((_DWORD)ImageMappedAt)
  {
    v8 = v18;
    v7 = v19;
    *a3 = v19;
    *(_OWORD *)(a3 + 1) = 0u;
    *(_OWORD *)(a3 + 3) = 0u;
    if (!v8)
      goto LABEL_13;
    if ((*((_WORD *)v8 + 2) & 1) != 0)
      goto LABEL_13;
    v9 = (uint64_t (***)(char *))*((_QWORD *)v8 + 13);
    if (!v9)
      goto LABEL_13;
    LOBYTE(v17) = 0;
    UnwindSections = (const char *)dyld4::PseudoDylib::findUnwindSections(v9, (uint64_t)a2, (uint64_t)&v17, (uint64_t)a3);
    if (UnwindSections)
    {
      v11 = (char *)UnwindSections;
      if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
        dyld4::RuntimeState::log(this, "_dyld_pseudodylib_find_unwind_sections(%p, %p) returned error: %s", a2, a3, UnwindSections);
      dyld4::PseudoDylib::disposeString(v9, v11);
    }
    if (!(_BYTE)v17)
    {
      v7 = v19;
LABEL_13:
      v17 = 0;
      SectionContent = dyld3::MachOLoaded::findSectionContent(v7, "__TEXT", "__eh_frame", &v17);
      if (SectionContent)
      {
        v13 = v17;
        a3[1] = (dyld3::MachOLoaded *)SectionContent;
        a3[2] = (dyld3::MachOLoaded *)v13;
      }
      v14 = dyld3::MachOLoaded::findSectionContent(v19, "__TEXT", "__unwind_info", &v17);
      if (v14)
      {
        v15 = v17;
        a3[3] = (dyld3::MachOLoaded *)v14;
        a3[4] = (dyld3::MachOLoaded *)v15;
      }
    }
  }
  return ImageMappedAt;
}

void dyld4::RuntimeState::doSingletonPatching(dyld4::RuntimeState *this, dyld4::DyldCacheDataConstLazyScopedWriter *a2)
{
  uint64_t (***v3)(_QWORD);
  unint64_t i;
  uint64_t v5;
  _OWORD *v6;
  _OWORD *v7;

  if (*((_QWORD *)this + 38) != *((_QWORD *)this + 44))
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(a2);
    v3 = (uint64_t (***)(_QWORD))*((_QWORD *)this + 19);
    if (v3 && (unint64_t)(**v3)(v3) >= 3)
      (*(void (**)(_QWORD))(**((_QWORD **)this + 19) + 160))(*((_QWORD *)this + 19));
    for (i = *((_QWORD *)this + 44); i < *((_QWORD *)this + 38); *((_QWORD *)this + 44) = i)
    {
      v5 = *((_QWORD *)this + 37) + 16 * i;
      v6 = *(_OWORD **)v5;
      v7 = *(_OWORD **)(v5 + 8);
      *v6 = *v7;
      if (*(_BYTE *)(*((_QWORD *)this + 1) + 202))
        dyld4::RuntimeState::log(this, "cache singleton fixup: *0x%012lX = 0x%012lX\n", v6, v7);
      i = *((_QWORD *)this + 44) + 1;
    }
  }
}

void dyld4::RuntimeState::notifyDtrace(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  dof_ioctl_data *v13;
  uint64_t v14;
  dyld4::Loader **v15;
  uint64_t v16;
  dyld4::Loader *v17;
  _DWORD *v18;
  uint64_t v19;
  dyld4::Loader **v20;
  uint64_t v21;
  dyld4::Loader *v22;
  uint64_t v23;
  uint64_t dofiod_count;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32[2];
  _QWORD v33[9];
  vm_address_t *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  char v38;

  v4 = dyld4::SyscallDelegate::dtraceUserProbesEnabled(*(dyld4::SyscallDelegate **)(a1 + 8));
  if ((_DWORD)v4)
  {
    v32[1] = (uint64_t)v32;
    __chkstk_darwin(v4, v5, v6, v7, v8, v9, v10, v11, v32[0]);
    v13 = (dof_ioctl_data *)((char *)v32 - ((v12 + 1295) & 0xFFFFFFFFFFFFFFF0));
    v13->dofiod_count = 0;
    v35 = 0;
    v36 = &v35;
    v37 = 0x2000000000;
    v38 = 0;
    v14 = *(_QWORD *)(a2 + 8);
    if (v14)
    {
      v15 = *(dyld4::Loader ***)a2;
      v16 = 8 * v14;
      do
      {
        v17 = *v15++;
        Diagnostics::Diagnostics((Diagnostics *)&v34);
        v18 = (_DWORD *)dyld4::Loader::analyzer(v17, (dyld4::RuntimeState *)a1);
        v33[0] = _NSConcreteStackBlock;
        v33[1] = 0x40000000;
        v33[2] = ___ZN5dyld412RuntimeState12notifyDtraceERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke;
        v33[3] = &unk_1E4F7CB28;
        v33[6] = v13;
        v33[7] = v18;
        v33[8] = v17;
        v33[4] = &v35;
        v33[5] = a1;
        dyld3::MachOFile::forEachDOFSection(v18, (uint64_t)&v34, (uint64_t)v33);
        mach_o::Error::~Error(&v34);
        v16 -= 8;
      }
      while (v16);
      if (v13->dofiod_count)
      {
        dyld4::SyscallDelegate::dtraceRegisterUserProbes(*(dyld4::SyscallDelegate **)(a1 + 8), v13);
        if (*((_BYTE *)v36 + 24))
        {
          v19 = *(_QWORD *)(a2 + 8);
          if (v19)
          {
            v20 = *(dyld4::Loader ***)a2;
            v21 = *(_QWORD *)a2 + 8 * v19;
            v32[0] = (uint64_t)&v13->dofiod_helpers[0].dofhp_dof;
            do
            {
              v22 = *v20;
              if ((*((_WORD *)*v20 + 2) & 0x20) == 0)
              {
                v23 = dyld4::Loader::analyzer(*v20, (dyld4::RuntimeState *)a1);
                dofiod_count = v13->dofiod_count;
                if (v13->dofiod_count)
                {
                  v25 = v23;
                  v26 = 0;
                  v27 = (uint64_t *)v32[0];
                  do
                  {
                    if (*(v27 - 1) == v25)
                    {
                      v28 = *v27;
                      lsl::Vector<dyld4::InterposeTupleAll>::reserve(a1 + 888, *(_QWORD *)(a1 + 904) + 1);
                      v29 = *(_QWORD *)(a1 + 896);
                      v30 = *(_QWORD *)(a1 + 904);
                      *(_QWORD *)(a1 + 904) = v30 + 1;
                      v31 = v29 + 16 * v30;
                      *(_QWORD *)v31 = v22;
                      *(_DWORD *)(v31 + 8) = v28;
                      dofiod_count = v13->dofiod_count;
                    }
                    v27 += 10;
                    ++v26;
                  }
                  while (v26 < dofiod_count);
                }
              }
              ++v20;
            }
            while (v20 != (dyld4::Loader **)v21);
          }
        }
      }
    }
    _Block_object_dispose(&v35, 8);
  }
}

uint64_t dyld4::SyscallDelegate::dtraceUserProbesEnabled(dyld4::SyscallDelegate *this)
{
  return MEMORY[0xFFFFFC092] & 1;
}

unint64_t ___ZN5dyld44APIs5dlsymEPvPKc_block_invoke(unint64_t result)
{
  const dyld4::RuntimeState *v1;
  uint64_t v2;
  unint64_t v3;
  dyld4::Loader **v4;
  uint64_t v5;
  dyld4::Loader *v6;

  v1 = *(const dyld4::RuntimeState **)(result + 56);
  v2 = *((_QWORD *)v1 + 6);
  if (v2)
  {
    v3 = result;
    v4 = (dyld4::Loader **)*((_QWORD *)v1 + 5);
    v5 = 8 * v2;
    while (1)
    {
      v6 = *v4;
      result = dyld4::Loader::hiddenFromFlat(*v4, 0);
      if ((result & 1) == 0)
      {
        result = dyld4::Loader::hasExportedSymbol((uint64_t)v6, (vm_address_t *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 40), v1, *(const unsigned __int8 **)(v3 + 64), 1u, 0, (uint64_t *)(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8) + 40), 0);
        if ((_DWORD)result)
          break;
      }
      ++v4;
      v5 -= 8;
      if (!v5)
        return result;
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8) + 24) = 1;
  }
  return result;
}

uint64_t dyld4::Loader::hasExportedSymbol(uint64_t a1, vm_address_t *a2, const dyld4::RuntimeState *a3, const unsigned __int8 *a4, unsigned int a5, int a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  char v18;
  int v19;
  uint64_t Address;
  const char *v21;
  const unsigned __int8 **v22;
  Diagnostics *v23;
  const unsigned __int8 **v24;
  const unsigned __int8 *v25;
  char v26;
  const unsigned __int8 *v27;
  char v28;
  const unsigned __int8 *v29;
  uint64_t v30;
  uint64_t v31;
  const unsigned __int8 *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  dyld3::MachOFile *v37;
  dyld4::RuntimeState *v38;
  const dyld4::Loader *v39;
  uint64_t v40;
  int v41;
  uint64_t (***v42)(char *);
  char *v43;
  char *v44;
  uint64_t v45;
  unint64_t v46;
  BOOL v47;
  uint64_t v48;
  char v49;
  const char *v50;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  const unsigned __int8 **v64;
  dyld4::RuntimeState *v65;
  const dyld4::Loader *v66;
  char v67;
  uint64_t v68;
  uint64_t *v69;
  int v70;
  _QWORD v71[11];
  unsigned int v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  char v78;
  const unsigned __int8 **v79;

  v70 = a6;
  if (a8)
  {
    v15 = a8[2];
    if (v15)
    {
      v16 = (_QWORD *)*a8;
      v17 = 8 * v15;
      while (*v16 != a1)
      {
        ++v16;
        v17 -= 8;
        if (!v17)
          goto LABEL_6;
      }
      return 0;
    }
LABEL_6:
    v75 = a1;
    dyld3::Array<dyld4::Loader const*>::push_back(a8, &v75, (uint64_t)a3);
  }
  v69 = a7;
  switch(a5)
  {
    case 0u:
      v18 = 0;
      HIDWORD(v68) = 0;
      v19 = 1;
      break;
    case 1u:
      v18 = 0;
      HIDWORD(v68) = 0;
      v19 = 0;
      break;
    case 2u:
      v18 = 1;
      HIDWORD(v68) = 1;
      goto LABEL_14;
    case 3u:
      v18 = 0;
      HIDWORD(v68) = 1;
LABEL_14:
      v19 = 1;
      break;
    default:
      HIDWORD(v68) = 0;
      v19 = 0;
      v18 = 1;
      break;
  }
  Address = dyld4::Loader::loadAddress((dyld4::Loader *)a1, a3);
  v73 = 0;
  v72 = 0;
  if (!dyld4::Loader::getExportsTrie((dyld4::Loader *)a1, &v73, &v72))
  {
    v40 = dyld4::Loader::mf((dyld4::Loader *)a1, a3);
    v75 = 0;
    v76 = &v75;
    v77 = 0x2000000000;
    v78 = 0;
    v71[0] = _NSConcreteStackBlock;
    v71[1] = 0x40000000;
    v71[2] = ___ZNK5dyld46Loader17hasExportedSymbolER11DiagnosticsRNS_12RuntimeStateEPKcNS0_18ExportedSymbolModeENS0_12ResolverModeEPNS0_14ResolvedSymbolEPN5dyld35ArrayIPKS0_EE_block_invoke;
    v71[3] = &unk_1E4F7D0E0;
    v71[6] = a2;
    v71[7] = a4;
    v71[8] = v69;
    v71[9] = v40;
    v71[10] = a3;
    v71[4] = &v75;
    v71[5] = a1;
    dyld4::Loader::withLayout((dyld4::Loader *)a1, a2, a3, (uint64_t)v71);
    v41 = *((unsigned __int8 *)v76 + 24);
    _Block_object_dispose(&v75, 8);
    if (v41)
      return 1;
    goto LABEL_31;
  }
  v22 = (const unsigned __int8 **)(Address + v73);
  v23 = (Diagnostics *)(Address + v73 + v72);
  v24 = dyld3::MachOFile::trieWalk(a2, v22, v23, a4, v21);
  if (v24)
    v26 = v18;
  else
    v26 = 1;
  if ((v26 & 1) != 0)
  {
LABEL_31:
    if (a1)
    {
      if ((*(_WORD *)(a1 + 4) & 1) == 0)
      {
        v42 = *(uint64_t (****)(char *))(a1 + 104);
        if (v42)
        {
          v74 = 0;
          v75 = (uint64_t)a4;
          v79 = 0;
          v43 = (char *)dyld4::PseudoDylib::lookupSymbols(v42, (uint64_t)&v75, 1, (uint64_t)&v79, 1, (uint64_t)&v74, 1);
          v35 = v43 == 0;
          if (v43)
          {
            v44 = v43;
            Diagnostics::error(a2, "pseudo-dylib lookup error: %s", v43);
            dyld4::PseudoDylib::disposeString(v42, v44);
            return v35;
          }
          if ((v74 & 1) != 0)
          {
            v63 = (uint64_t)v69;
            *v69 = a1;
            *(_QWORD *)(v63 + 8) = a4;
            v64 = v79;
            *(_QWORD *)(v63 + 16) = (char *)v64 - dyld4::Loader::mf((dyld4::Loader *)a1, a3);
            *(_DWORD *)(v63 + 32) = 1;
            *(_BYTE *)(v63 + 36) = (v74 & 4) != 0;
            v65 = dyld4::Loader::resolvedAddress(a3, v63);
            *(_QWORD *)(v63 + 24) = v65;
            *(_QWORD *)(v63 + 24) = dyld4::Loader::interpose(a3, v65, 0, v66);
            v67 = v74;
            *(_BYTE *)(v63 + 37) = (v74 & 2) != 0;
            *(_BYTE *)(v63 + 38) = 0;
            *(_BYTE *)(v63 + 39) = (v67 & 8) != 0;
            return v35;
          }
        }
      }
    }
    if (!v19)
      return 0;
    v35 = dyld4::Loader::dependentCount((dyld4::Loader *)a1);
    if (!(_DWORD)v35)
      return v35;
    v48 = 0;
    while (1)
    {
      LOBYTE(v75) = 0;
      if (dyld4::Loader::dependent((dyld4::JustInTimeLoader *)a1, a3, v48, (char *)&v75))
      {
        if ((v75 & 2) != 0 || ((v75 & 0xC) != 0 ? (v49 = 1) : (v49 = BYTE4(v68) ^ 1), (v49 & 1) == 0))
        {
          if (dyld4::Loader::hasExportedSymbol())
            break;
        }
      }
      v48 = (v48 + 1);
      if ((_DWORD)v35 == (_DWORD)v48)
        return 0;
    }
    return 1;
  }
  v79 = v24;
  v28 = dyld3::MachOFile::read_uleb128(a2, &v79, (const unsigned __int8 **)v23, v25);
  if ((v28 & 8) == 0)
  {
    v30 = (uint64_t)v69;
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      v31 = dyld3::MachOFile::read_uleb128(a2, &v79, (const unsigned __int8 **)v23, v29);
      if (!v70 && (v28 & 0x10) != 0)
      {
        v33 = dyld3::MachOFile::read_uleb128(a2, &v79, (const unsigned __int8 **)v23, v32);
        v34 = dyld4::Loader::loadAddress((dyld4::Loader *)a1, a3);
        v31 = ((uint64_t (*)(void))(v34 + v33))() - v34;
        v30 = (uint64_t)v69;
      }
      *(_QWORD *)v30 = a1;
      *(_QWORD *)(v30 + 8) = a4;
      *(_QWORD *)(v30 + 16) = v31;
      v35 = 1;
      if ((v28 & 3) == 2)
        v36 = 2;
      else
        v36 = 1;
      *(_DWORD *)(v30 + 32) = v36;
      v37 = (dyld3::MachOFile *)dyld4::Loader::mf((dyld4::Loader *)a1, a3);
      *(_BYTE *)(v30 + 36) = dyld3::MachOFile::inCodeSection(v37, *(_DWORD *)(v30 + 16));
      v38 = dyld4::Loader::resolvedAddress(a3, v30);
      *(_QWORD *)(v30 + 24) = v38;
      *(_QWORD *)(v30 + 24) = dyld4::Loader::interpose(a3, v38, 0, v39);
      *(_BYTE *)(v30 + 37) = (v28 & 4) != 0;
      *(_WORD *)(v30 + 38) = 0;
      return v35;
    }
    return 0;
  }
  v45 = dyld3::MachOFile::read_uleb128(a2, &v79, (const unsigned __int8 **)v23, v27);
  v46 = v45;
  if (*(_BYTE *)v79)
  {
    v47 = _platform_strcmp((const char *)v79, (const char *)a4) != 0;
    if (!v46)
      goto LABEL_54;
  }
  else
  {
    v47 = 0;
    if (!v45)
    {
LABEL_54:
      v50 = (const char *)dyld4::Loader::path((dyld4::Loader *)a1, a3);
      Diagnostics::error(a2, "re-export ordinal %lld in %s out of range for %s", v46, v50, (const char *)a4);
      return 0;
    }
  }
  if (v46 > dyld4::Loader::dependentCount((dyld4::Loader *)a1))
    goto LABEL_54;
  LOBYTE(v74) = 0;
  v52 = dyld4::Loader::dependent((dyld4::JustInTimeLoader *)a1, a3, (v46 - 1), (char *)&v74);
  if (!v52)
    return 0;
  if (a5 == 1 && v47)
    v59 = 0;
  else
    v59 = a5;
  v60 = !v47;
  if (!a8)
    v60 = 1;
  if ((v60 & 1) != 0)
    return dyld4::Loader::hasExportedSymbol();
  __chkstk_darwin(v52, v53, v54, v55, v59, v56, v57, v58, v68);
  v62 = (uint64_t *)*((_QWORD *)a3 + 6);
  v75 = (uint64_t)&v68 - ((v61 + 23) & 0xFFFFFFFFFFFFFFF0);
  v76 = v62;
  v77 = 0;
  return dyld4::Loader::hasExportedSymbol();
}

const unsigned __int8 **dyld3::MachOFile::trieWalk(vm_address_t *this, const unsigned __int8 **a2, Diagnostics *a3, const unsigned __int8 *a4, const char *a5)
{
  const unsigned __int8 *v9;
  const unsigned __int8 **v10;
  uint64_t v11;
  const unsigned __int8 **v12;
  int v13;
  uint64_t v14;
  BOOL v15;
  unsigned __int8 *v16;
  const unsigned __int8 **v17;
  int v18;
  int v19;
  int v20;
  BOOL v21;
  const unsigned __int8 **v22;
  const unsigned __int8 **v23;
  const unsigned __int8 *v24;
  int v25;
  int v26;
  int v27;
  unint64_t v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  const unsigned __int8 **v33;
  _QWORD v34[2];
  uint64_t v35;
  vm_address_t address;
  vm_size_t size;
  char v38;

  v34[0] = &v38;
  v34[1] = 128;
  address = 0;
  size = 0;
  v35 = 0;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v34, 1);
  v10 = 0;
  v11 = v35++;
  *(_DWORD *)(v34[0] + 4 * v11) = 0;
  if (a2 >= (const unsigned __int8 **)a3)
    goto LABEL_38;
  v12 = a2;
  while (2)
  {
    v13 = *(char *)v12;
    v33 = (const unsigned __int8 **)((char *)v12 + 1);
    if (v13 < 0)
    {
      v33 = v12;
      v14 = dyld3::MachOFile::read_uleb128(this, &v33, (const unsigned __int8 **)a3, v9);
      if (Diagnostics::hasError((Diagnostics *)this))
      {
LABEL_37:
        v10 = 0;
        break;
      }
    }
    else
    {
      v14 = v13;
    }
    v10 = v33;
    if (*a4)
      v15 = 1;
    else
      v15 = v14 == 0;
    if (!v15)
      break;
    v16 = (unsigned __int8 *)v33 + v14;
    if ((char *)v33 + v14 > (char *)a3)
      goto LABEL_37;
    v19 = *v16;
    v17 = (const unsigned __int8 **)(v16 + 1);
    v18 = v19;
    v33 = v17;
    if (!v19)
      goto LABEL_37;
    while (1)
    {
      v20 = *(unsigned __int8 *)v17;
      if (!*(_BYTE *)v17)
        break;
      v21 = 0;
      v22 = (const unsigned __int8 **)((char *)v17 + 1);
      v23 = (const unsigned __int8 **)((char *)v17 + 2);
      v24 = a4;
      do
      {
        v17 = v23;
        if (v21)
        {
          v21 = 1;
        }
        else
        {
          v25 = *v24++;
          v21 = v20 != v25;
        }
        v33 = v22;
        v26 = *(unsigned __int8 *)v22;
        v22 = (const unsigned __int8 **)((char *)v22 + 1);
        v20 = v26;
        v23 = (const unsigned __int8 **)((char *)v23 + 1);
      }
      while (v26);
      if (!v21)
      {
        v17 = (const unsigned __int8 **)((char *)v22 - 1);
        a4 = v24;
        break;
      }
      do
      {
        v27 = *(char *)v17;
        v17 = (const unsigned __int8 **)((char *)v17 + 1);
      }
      while (v27 < 0);
      v33 = v17;
      if (v17 > (const unsigned __int8 **)a3)
      {
        Diagnostics::error(this, "malformed trie node, child node extends past end of trie\n");
        goto LABEL_37;
      }
      if (!(_BYTE)--v18)
        goto LABEL_37;
    }
    v33 = (const unsigned __int8 **)((char *)v17 + 1);
    v28 = dyld3::MachOFile::read_uleb128(this, &v33, (const unsigned __int8 **)a3, v9);
    if (Diagnostics::hasError((Diagnostics *)this))
      goto LABEL_37;
    if (!v28
      || (v12 = (const unsigned __int8 **)((char *)a2 + v28), (char *)a2 + v28 > (char *)a3)
      || v28 > a3 - (Diagnostics *)a2)
    {
      Diagnostics::error(this, "malformed trie child, nodeOffset=0x%llX out of range\n");
      goto LABEL_37;
    }
    if (v35)
    {
      v29 = (_DWORD *)v34[0];
      v30 = 4 * v35;
      while (v28 != *v29)
      {
        ++v29;
        v30 -= 4;
        if (!v30)
          goto LABEL_33;
      }
      Diagnostics::error(this, "malformed trie child, cycle to nodeOffset=0x%llX\n");
      goto LABEL_37;
    }
LABEL_33:
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v34, 1);
    v10 = 0;
    v31 = v35++;
    *(_DWORD *)(v34[0] + 4 * v31) = v28;
    v33 = (const unsigned __int8 **)((char *)a2 + v28);
    if (v12 < (const unsigned __int8 **)a3)
      continue;
    break;
  }
LABEL_38:
  v35 = 0;
  if (address)
    vm_deallocate(mach_task_self_, address, size);
  return v10;
}

BOOL Diagnostics::hasError(Diagnostics *this)
{
  return *(_QWORD *)this != 0;
}

_QWORD *dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  const void **v4;
  vm_address_t v5;
  vm_size_t v6;
  unint64_t v7;
  vm_size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;

  v2 = result[1];
  v3 = result[2] + a2;
  if (v3 > v2)
  {
    v4 = (const void **)result;
    v5 = result[3];
    v6 = result[4];
    v7 = 2 * v2;
    if (v7 > v3)
      v3 = v7;
    v8 = (vm_page_size + 4 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    result = memmove((void *)v4[3], *v4, 4 * (_QWORD)v4[2]);
    v12 = (const void *)((unint64_t)v4[4] >> 2);
    *v4 = v4[3];
    v4[1] = v12;
    if (v5)
      return (_QWORD *)vm_deallocate(mach_task_self_, v5, v6);
  }
  return result;
}

BOOL dyld4::Loader::getExportsTrie(dyld4::Loader *this, unint64_t *a2, unsigned int *a3)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::getExportsTrie();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::getExportsTrie(this, a2, a3);
  else
    return dyld4::JustInTimeLoader::getExportsTrie(this, a2, a3);
}

BOOL dyld4::PrebuiltLoader::getExportsTrie(dyld4::PrebuiltLoader *this, unint64_t *a2, unsigned int *a3)
{
  unsigned int v3;

  *a2 = *((_QWORD *)this + 8);
  v3 = *((_DWORD *)this + 18);
  *a3 = v3;
  return v3 != 0;
}

uint64_t *dyld3::Array<dyld4::Loader const*>::push_back(uint64_t *result, uint64_t *a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = result[2];
  if (v3 >= result[1])
    dyld4::RuntimeState::appendInterposingTuples((uint64_t)result, (uint64_t)a2, a3);
  v4 = *a2;
  v5 = *result;
  result[2] = v3 + 1;
  *(_QWORD *)(v5 + 8 * v3) = v4;
  return result;
}

BOOL dyld3::MachOFile::inCodeSection(dyld3::MachOFile *this, int a2)
{
  _BOOL8 v3;
  _QWORD v5[6];
  int v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  if (*((_DWORD *)this + 1) != 16777228 || (*((_DWORD *)this + 2) & 0xFFFFFF) != 2)
    return 0;
  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile13inCodeSectionEj_block_invoke;
  v5[3] = &unk_1E4F7EC00;
  v6 = a2;
  v5[4] = &v7;
  v5[5] = dyld3::MachOFile::preferredLoadAddress(this);
  dyld3::MachOFile::forEachSection(this, (uint64_t)v5);
  v3 = *((_BYTE *)v8 + 24) != 0;
  _Block_object_dispose(&v7, 8);
  return v3;
}

void dyld3::MachOFile::forEachSection(_DWORD *a1, uint64_t a2)
{
  BOOL v4;
  _QWORD v5[8];
  BOOL v6;
  _QWORD v7[3];
  int v8;
  vm_address_t *v9;
  char v10;

  Diagnostics::Diagnostics((Diagnostics *)&v9);
  v4 = a1[1] == 7;
  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  v8 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile14forEachSectionEU13block_pointerFvRKNS0_11SectionInfoEbRbE_block_invoke;
  v5[3] = &unk_1E4F7EA98;
  v5[6] = a1;
  v5[7] = &v10;
  v5[4] = a2;
  v5[5] = v7;
  v6 = v4;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v9, (uint64_t)v5);
  Diagnostics::assertNoError((Diagnostics *)&v9);
  _Block_object_dispose(v7, 8);
  mach_o::Error::~Error(&v9);
}

uint64_t dyld3::MachOFile::preferredLoadAddress(dyld3::MachOFile *this)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile20preferredLoadAddressEv_block_invoke;
  v3[3] = &unk_1E4F7EA70;
  v3[4] = &v4;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void dyld3::MachOFile::forEachSegment(_DWORD *a1, uint64_t a2)
{
  BOOL v4;
  _QWORD v5[7];
  BOOL v6;
  _QWORD v7[3];
  int v8;
  vm_address_t *v9;

  Diagnostics::Diagnostics((Diagnostics *)&v9);
  v4 = a1[1] == 7;
  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  v8 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile14forEachSegmentEU13block_pointerFvRKNS0_11SegmentInfoERbE_block_invoke;
  v5[3] = &unk_1E4F7EA48;
  v5[5] = v7;
  v5[6] = a1;
  v5[4] = a2;
  v6 = v4;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v9, (uint64_t)v5);
  Diagnostics::assertNoError((Diagnostics *)&v9);
  _Block_object_dispose(v7, 8);
  mach_o::Error::~Error(&v9);
}

unint64_t dyld4::Loader::hiddenFromFlat(dyld4::Loader *this, char a2)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::hiddenFromFlat();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::hiddenFromFlat(this);
  else
    return dyld4::JustInTimeLoader::hiddenFromFlat(this, a2);
}

BOOL dyld4::JustInTimeLoader::getExportsTrie(dyld4::JustInTimeLoader *this, unint64_t *a2, unsigned int *a3)
{
  unint64_t v3;

  v3 = *((unsigned int *)this + 28);
  if ((_DWORD)v3)
  {
    *a2 = v3;
    *a3 = *((_DWORD *)this + 29);
  }
  return (_DWORD)v3 != 0;
}

BOOL dyld4::ExternallyViewableState::notifyMonitorNeeded(dyld4::ExternallyViewableState *this)
{
  return *(_DWORD *)(*((_QWORD *)this + 3) + 200) == 1229016646;
}

uint64_t __kdebug_typefilter(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_kdebug_typefilter, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t dyld4::JustInTimeLoader::overridesDylibInCache(uint64_t a1, _QWORD *a2, _WORD *a3)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a1 + 40);
  if ((v3 & 0x400000) != 0)
  {
    *a2 = *(_QWORD *)(a1 + 88);
    *a3 = *(_WORD *)(a1 + 43) & 0x7FFF;
  }
  return (v3 >> 22) & 1;
}

void ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  dyld4::Loader *v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  const char **v13;
  const char *v14;
  const dyld4::RuntimeState *v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const dyld4::RuntimeState *v19;
  dyld3::MachOFile *v20;
  int hasOpcodeFixups;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  dyld4::Loader **v26;
  uint64_t v27;
  dyld4::Loader *v28;
  int v29;
  uint64_t hasBeenFixedUp;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  const char *v38;
  const dyld4::RuntimeState *v39;
  const char *v40;
  uint64_t v41;
  __int128 v42;
  const char *v43;
  const dyld4::RuntimeState *v44;
  const char *v45;
  const char *v46;
  const dyld4::RuntimeState *v47;
  char *v48;
  char *v49;
  const char *v50;
  uint64_t v51;
  __int128 v52;
  BOOL v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  dyld3::MachOFile *v57;
  uint64_t Address;
  dyld4::RuntimeState *v59;
  uint64_t v60;
  const char *v61;
  const char *v62;
  const char *v63;
  uint64_t v64;
  char *v65;
  unint64_t v66;
  char *v67;
  unsigned int v68[4];
  __int128 v69;
  uint64_t v70;
  _QWORD v71[2];

  v9 = *(dyld4::Loader **)(a1 + 56);
  if (*(_BYTE *)(a1 + 88))
    dyld4::RuntimeState::log(*(dyld4::RuntimeState **)(a1 + 64), "looking for weak-def symbol '%s':\n", v63);
  v10 = *(_QWORD *)(a1 + 64);
  v11 = *(_QWORD *)(v10 + 360) + 1;
  *(_QWORD *)(v10 + 360) = v11;
  if (v11 >= 0x1389 && !*(_QWORD *)(v10 + 368))
  {
    v12 = lsl::Allocator::malloc(*(lsl::Allocator **)(v10 + 16), 0x60uLL);
    *(_QWORD *)(*(_QWORD *)(a1 + 64) + 368) = dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)v12);
    v10 = *(_QWORD *)(a1 + 64);
  }
  v13 = *(const char ***)(v10 + 368);
  if (v13
    && (v13 = dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>((uint64_t)v13, (uint64_t *)v13 + 2, v13 + 7, 0, (const char **)(a1 + 72)), v13 != (const char **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 368) + 56)+ 24 * *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 368) + 72)))&& (v14 = v13[1]) != 0)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = v14;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48) = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 56) = (unint64_t)v13[2] & 0x3FFFFFFFFFFFFFFFLL;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 64) = 0;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 72) = 1;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 76) = ((unint64_t)v13[2] & 0x4000000000000000) != 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 77) = (uint64_t)v13[2] < 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 78) = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 79) = 0;
    if (*(_BYTE *)(a1 + 88))
    {
      v15 = *(const dyld4::RuntimeState **)(a1 + 64);
      v16 = *(const char **)(a1 + 72);
      v17 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), v15);
      dyld4::RuntimeState::log(v15, "  found %s in map, using impl from %s\n", v16, v17);
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 1;
  }
  else
  {
    __chkstk_darwin((uint64_t)v13, a2, a3, a4, a5, a6, a7, a8, (uint64_t)&v64);
    v67 = (char *)&v64 - ((v18 + 23) & 0xFFFFFFFFFFFFFFF0);
    v19 = *(const dyld4::RuntimeState **)(a1 + 64);
    v66 = *((_QWORD *)v19 + 6);
    if ((*((_WORD *)v9 + 2) & 2) != 0)
    {
      hasOpcodeFixups = 0;
    }
    else
    {
      v20 = (dyld3::MachOFile *)dyld4::Loader::mf(v9, v19);
      hasOpcodeFixups = dyld3::MachOFile::hasOpcodeFixups(v20);
      v19 = *(const dyld4::RuntimeState **)(a1 + 64);
    }
    v22 = 0;
    v23 = 0;
    v71[0] = (char *)v19 + 32;
    v71[1] = (char *)v19 + 64;
    v65 = v67 + 8;
    do
    {
      v24 = v71[v22];
      v25 = *(_QWORD *)(v24 + 16);
      if (v25)
      {
        v26 = *(dyld4::Loader ***)(v24 + 8);
        v27 = 8 * v25;
        do
        {
          v28 = *v26;
          if ((*((_WORD *)*v26 + 2) & 0x800) != 0
            && (dyld4::Loader::hiddenFromFlat(*v26, 0) & 1) == 0
            && dyld4::Loader::hasExportedSymbol((uint64_t)v28, *(vm_address_t **)(a1 + 80), *(const dyld4::RuntimeState **)(a1 + 64), *(const unsigned __int8 **)(a1 + 72), 1u, 1, (uint64_t *)v68, 0))
          {
            v29 = BYTE5(v70) ? 0 : hasOpcodeFixups;
            if (v29 != 1 || (*((_WORD *)v28 + 2) & 2) == 0)
            {
              if ((*(_WORD *)(*(_QWORD *)v68 + 4) & 2) != 0)
              {
                hasBeenFixedUp = dyld4::Loader::hasBeenFixedUp(v28, *(dyld4::RuntimeState **)(a1 + 64));
                if ((hasBeenFixedUp & 1) == 0)
                {
                  if (v23 >= v66)
                    dyld4::RuntimeState::appendInterposingTuples(hasBeenFixedUp, v31, v32);
                  v33 = v69;
                  v34 = &v67[16 * v23++];
                  *(_QWORD *)v34 = *(_QWORD *)v68;
                  *((_QWORD *)v34 + 1) = v33;
                }
              }
              v35 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
              if (!*(_BYTE *)(v35 + 24))
              {
                *(_BYTE *)(v35 + 24) = 1;
                v36 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
                v37 = v69;
                *(_OWORD *)(v36 + 40) = *(_OWORD *)v68;
                *(_OWORD *)(v36 + 56) = v37;
                *(_QWORD *)(v36 + 72) = v70;
                if (*(_BYTE *)(a1 + 88))
                {
                  v39 = *(const dyld4::RuntimeState **)(a1 + 64);
                  v38 = *(const char **)(a1 + 72);
                  v40 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)v68, v39);
                  dyld4::RuntimeState::log(v39, "  using '%s' in %s\n", v38, v40);
                }
              }
              if (!BYTE5(v70))
              {
                v41 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
                if (*(_BYTE *)(v41 + 77))
                {
                  v42 = v69;
                  *(_OWORD *)(v41 + 40) = *(_OWORD *)v68;
                  *(_OWORD *)(v41 + 56) = v42;
                  *(_QWORD *)(v41 + 72) = v70;
                  if (*(_BYTE *)(a1 + 88))
                  {
                    v44 = *(const dyld4::RuntimeState **)(a1 + 64);
                    v43 = *(const char **)(a1 + 72);
                    v45 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)v68, v44);
                    dyld4::RuntimeState::log(v44, "  using non-weak '%s' in %s\n", v43, v45);
                  }
                }
              }
            }
          }
          ++v26;
          v27 -= 8;
        }
        while (v27);
      }
      if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24)
        && dyld4::Loader::hiddenFromFlat(v9, 0))
      {
        if (*(_BYTE *)(a1 + 88))
        {
          v47 = *(const dyld4::RuntimeState **)(a1 + 64);
          v46 = *(const char **)(a1 + 72);
          v48 = (char *)dyld4::Loader::path(v9, v47);
          v49 = strrchr(v48, 47);
          if (v49)
            v50 = v49 + 1;
          else
            v50 = v48;
          dyld4::RuntimeState::log(v47, "  did not find unhidden '%s', trying self (%s)\n", v46, v50);
        }
        if (dyld4::Loader::hasExportedSymbol((uint64_t)v9, *(vm_address_t **)(a1 + 80), *(const dyld4::RuntimeState **)(a1 + 64), *(const unsigned __int8 **)(a1 + 72), 1u, 1, (uint64_t *)v68, 0))
        {
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 1;
          v51 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
          v52 = v69;
          *(_OWORD *)(v51 + 40) = *(_OWORD *)v68;
          *(_OWORD *)(v51 + 56) = v52;
          *(_QWORD *)(v51 + 72) = v70;
        }
      }
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24))
        v53 = v23 == 0;
      else
        v53 = 1;
      if (!v53
        && (*(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) + 4) & 2) == 0
        && *(_QWORD *)(a1 + 32))
      {
        v54 = 0;
        v55 = 16 * v23;
        v56 = v65;
        do
        {
          v57 = (dyld3::MachOFile *)dyld4::Loader::mf(*((dyld4::Loader **)v56 - 1), *(const dyld4::RuntimeState **)(a1 + 64));
          v68[0] = 0;
          if (dyld4::ProcessConfig::DyldCache::findMachHeaderImageIndex((DyldSharedCache **)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 240), (const mach_header *)v57, v68))
          {
            Address = dyld3::MachOFile::preferredLoadAddress(v57);
            v59 = *(dyld4::RuntimeState **)(a1 + 64);
            v60 = *(_QWORD *)v56 + Address - *(_QWORD *)(*((_QWORD *)v59 + 1) + 272);
            if (v60 != v54)
            {
              if (*(_BYTE *)(a1 + 88))
              {
                v61 = *(const char **)(a1 + 72);
                v62 = (const char *)dyld4::Loader::path(*((dyld4::Loader **)v56 - 1), *(const dyld4::RuntimeState **)(a1 + 64));
                dyld4::RuntimeState::log(v59, "  found use of '%s' in cache, need to override: %s\n", v61, v62);
              }
              (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
              v54 = v60;
            }
          }
          v56 += 16;
          v55 -= 16;
        }
        while (v55);
      }
      ++v22;
    }
    while (v22 != 2);
  }
}

uint64_t dyld3::MachOFile::hasWeakDefs(dyld3::MachOFile *this)
{
  return *((unsigned __int8 *)this + 25) >> 7;
}

uint64_t dyld4::Loader::hasBeenFixedUp(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::hasBeenFixedUp();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::hasBeenFixedUp((uint64_t)this, (uint64_t)a2);
  else
    return dyld4::JustInTimeLoader::hasBeenFixedUp(this, a2);
}

BOOL dyld4::PrebuiltLoader::hasBeenFixedUp(uint64_t a1, uint64_t a2)
{
  __int16 v2;
  _QWORD *v3;

  v2 = *(_WORD *)(a1 + 6);
  if (v2 >= 0)
    v3 = (_QWORD *)(a2 + 1000);
  else
    v3 = (_QWORD *)(a2 + 1024);
  return *(unsigned __int8 *)(*v3 + (v2 & 0x7FFF)) > 5u;
}

uint64_t dyld3::MachOFile::hasOpcodeFixups(dyld3::MachOFile *this)
{
  if ((dyld3::MachOFile::hasLoadCommand(this, -2147483614) & 1) != 0)
    return 1;
  else
    return dyld3::MachOFile::hasLoadCommand(this, 34);
}

uint64_t ___ZN5dyld44APIs35_dyld_register_for_bulk_image_loadsEPFvjPPK11mach_headerPPKcE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const dyld4::RuntimeState *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v26;

  v9 = *(const dyld4::RuntimeState **)(a1 + 32);
  v10 = *((_QWORD *)v9 + 6);
  v11 = 8 * v10;
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v26);
  v12 = (v11 + 15) & 0xFFFFFFFF0;
  v13 = (char *)&v26 - v12;
  if (v11 >= 0x200)
    v14 = 512;
  else
    v14 = 8 * v10;
  bzero((char *)&v26 - v12, v14);
  __chkstk_darwin(v15, v16, v17, v18, v19, v20, v21, v22, v26);
  v23 = (char *)&v26 - v12;
  bzero(v23, v14);
  if ((_DWORD)v10)
  {
    v24 = 0;
    do
    {
      *(_QWORD *)&v13[v24] = dyld4::Loader::loadAddress(*(dyld4::Loader **)(*((_QWORD *)v9 + 5) + v24), v9);
      *(_QWORD *)&v23[v24] = dyld4::Loader::path(*(dyld4::Loader **)(*((_QWORD *)v9 + 5) + v24), v9);
      v24 += 8;
    }
    while (v11 != v24);
  }
  if (*(_BYTE *)(*((_QWORD *)v9 + 1) + 205))
    dyld4::RuntimeState::log(v9, "add bulk notifier %p called with %d images\n", *(const void **)(a1 + 40), v10);
  return (*(uint64_t (**)(uint64_t, char *, char *))(a1 + 40))(v10, v13, v23);
}

unint64_t *dyld4::RuntimeState::addPermanentRanges(uint64_t a1, uint64_t a2)
{
  unint64_t *result;
  unint64_t *v4;
  unint64_t *i;

  result = dyld4::RuntimeState::PermanentRanges::make((lsl::Allocator **)a1, a2);
  v4 = *(unint64_t **)(a1 + 1048);
  if (v4)
  {
    for (i = (unint64_t *)atomic_load(v4); i; i = (unint64_t *)atomic_load(i))
      v4 = i;
    atomic_store((unint64_t)result, v4);
  }
  else
  {
    *(_QWORD *)(a1 + 1048) = result;
  }
  return result;
}

unint64_t *dyld4::RuntimeState::PermanentRanges::make(lsl::Allocator **a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  dyld4::Loader **v6;
  dyld4::Loader *v7;
  dyld3::MachOLoaded *Address;
  uint64_t Slide;
  _DWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t v14;
  _OWORD *v15;
  _OWORD *v16;
  __int128 v17;
  _QWORD v20[9];
  _QWORD v21[3];
  char v22;
  _QWORD v23[4];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  double (*v27)(uint64_t, uint64_t);
  _QWORD *(*v28)(_QWORD *);
  char *v29;
  uint64_t v30;
  uint64_t v31;
  vm_address_t v32;
  vm_size_t v33;

  v4 = *(_QWORD *)(a2 + 16);
  v24 = 0;
  v25 = &v24;
  v26 = 0x5002000000;
  v27 = __Block_byref_object_copy__0;
  v28 = __Block_byref_object_dispose__0;
  v5 = 8 * v4;
  v29 = (char *)&v20[-1] - v2;
  v30 = 8 * v4;
  v32 = 0;
  v33 = 0;
  v31 = 0;
  if (v4)
  {
    v6 = *(dyld4::Loader ***)a2;
    do
    {
      v7 = *v6++;
      Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(v7, (const dyld4::RuntimeState *)a1);
      Slide = dyld3::MachOLoaded::getSlide(Address);
      v23[0] = 0;
      v23[1] = v23;
      v23[2] = 0x2000000000;
      v23[3] = 0;
      v21[0] = 0;
      v21[1] = v21;
      v21[2] = 0x2000000000;
      v22 = 0;
      v10 = (_DWORD *)dyld4::Loader::loadAddress(v7, (const dyld4::RuntimeState *)a1);
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 0x40000000;
      v20[2] = ___ZN5dyld412RuntimeState15PermanentRanges4makeERS0_RKN5dyld35ArrayIPKNS_6LoaderEEE_block_invoke;
      v20[3] = &unk_1E4F7C980;
      v20[4] = v23;
      v20[5] = v21;
      v20[7] = Slide;
      v20[6] = &v24;
      v20[8] = v7;
      dyld3::MachOFile::forEachSegment(v10, (uint64_t)v20);
      _Block_object_dispose(v21, 8);
      _Block_object_dispose(v23, 8);
      v5 -= 8;
    }
    while (v5);
    v11 = *((unsigned int *)v25 + 14);
  }
  else
  {
    v11 = 0;
  }
  v12 = lsl::Allocator::malloc(a1[2], (32 * v11) | 0x10);
  v13 = v12;
  atomic_store(0, v12);
  v12[1] = v11;
  if (v11)
  {
    v14 = 0;
    v15 = v12 + 2;
    do
    {
      v16 = (_OWORD *)dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](v25 + 5, v14);
      v17 = v16[1];
      *v15 = *v16;
      v15[1] = v17;
      v15 += 2;
      ++v14;
    }
    while (v11 != v14);
  }
  _Block_object_dispose(&v24, 8);
  v31 = 0;
  if (v32)
    vm_deallocate(mach_task_self_, v32, v33);
  return v13;
}

void dyld4::ProcessConfig::PathOverrides::forEachInsertedDylib(uint64_t a1, uint64_t a2)
{
  _BYTE *v2;
  _QWORD v3[6];
  _QWORD v4[3];
  _BYTE v5[8];

  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x2000000000;
  v5[0] = 0;
  v2 = *(_BYTE **)(a1 + 96);
  if (v2 && *v2)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 0x40000000;
    v3[2] = ___ZNK5dyld413ProcessConfig13PathOverrides20forEachInsertedDylibEU13block_pointerFvPKcRbE_block_invoke;
    v3[3] = &unk_1E4F7C0C8;
    v3[4] = a2;
    v3[5] = v4;
    dyld4::ProcessConfig::PathOverrides::forEachInColonList((uint64_t)v2, 0, v5, (uint64_t)v3);
  }
  _Block_object_dispose(v4, 8);
}

uint64_t dyld4::ExternallyViewableState::storeProcessInfoPointer(uint64_t this, dyld_all_image_infos **a2)
{
  *a2 = *(dyld_all_image_infos **)(this + 24);
  return this;
}

uint64_t dyld4::JustInTimeLoader::handleStrongWeakDefOverrides(uint64_t this, dyld4::RuntimeState *a2, dyld4::DyldCacheDataConstLazyScopedWriter *a3)
{
  uint64_t v3;
  _QWORD v4[7];
  _QWORD v5[6];

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld416JustInTimeLoader28handleStrongWeakDefOverridesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke;
  v5[3] = &__block_descriptor_tmp_15_0;
  v5[4] = this;
  v5[5] = a2;
  v3 = *(_QWORD *)(this + 24);
  if (v3)
  {
    if ((*(_WORD *)(v3 + 4) & 0x800) != 0)
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      v4[2] = ___ZN5dyld416JustInTimeLoader28handleStrongWeakDefOverridesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2;
      v4[3] = &unk_1E4F7D2D0;
      v4[5] = v3;
      v4[6] = this;
      v4[4] = v5;
      return dyld3::MachOFile::forEachTreatAsWeakDef((uint64_t)v4);
    }
  }
  return this;
}

void dyld4::RuntimeState::notifyDebuggerLoad(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  size_t v13;
  lsl::AllocatorLayout *v14;
  uint64_t v15;
  const char **v16;
  const char **v17;
  lsl::Allocator *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[2];
  lsl::Allocator *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v4 = lsl::AllocatorLayout::minSize(this);
  __chkstk_darwin(v4, v4 + 72, v5, v6, v7, v8, v9, v10, v20);
  v12 = (char *)&v21[-1] - ((v11 + 87) & 0xFFFFFFFFFFFFFFF0);
  bzero(v12, v13);
  v15 = lsl::AllocatorLayout::minSize(v14);
  v18 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v12, (char *)(v15 + 72), v16, v17);
  v22 = v18;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v22, 1uLL);
  lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v22, v24 + 1);
  v19 = v24++;
  *(_QWORD *)(v23 + 8 * v19) = a2;
  v21[0] = v23;
  v21[1] = v19 + 1;
  dyld4::RuntimeState::notifyDebuggerLoad(this, (uint64_t)v21);
  if (v23)
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v22, 0);
  lsl::Allocator::~Allocator(v18);
}

void dyld4::RuntimeState::setMainLoader(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  dyld3::MachOLoaded *v4;
  uint64_t v5;
  _QWORD v6[8];
  _QWORD v7[3];
  int v8;

  *((_QWORD *)this + 3) = a2;
  v4 = (dyld3::MachOLoaded *)dyld4::Loader::analyzer(a2, this);
  v5 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v5 + 200))
  {
    dyld4::Loader::logLoad(a2, this, *(char **)(v5 + 16));
    v5 = *((_QWORD *)this + 1);
  }
  if (*(_BYTE *)(v5 + 201))
  {
    dyld4::RuntimeState::log(this, "Kernel mapped %s\n", *(const char **)(v5 + 16));
    v7[0] = 0;
    v7[1] = v7;
    v7[2] = 0x2000000000;
    v8 = 0;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = ___ZN5dyld412RuntimeState13setMainLoaderEPKNS_6LoaderE_block_invoke;
    v6[3] = &unk_1E4F7C938;
    v6[4] = v7;
    v6[5] = this;
    v6[6] = dyld3::MachOLoaded::getSlide(v4);
    v6[7] = v4;
    dyld3::MachOFile::forEachSegment(v4, (uint64_t)v6);
    _Block_object_dispose(v7, 8);
  }
}

BOOL dyld3::MachOFile::getEntry(dyld3::MachOFile *this, unint64_t *a2, BOOL *a3)
{
  _BOOL8 v6;
  _QWORD v8[7];
  vm_address_t *v9;

  Diagnostics::Diagnostics((Diagnostics *)&v9);
  *a2 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld39MachOFile8getEntryERyRb_block_invoke;
  v8[3] = &__block_descriptor_tmp_104_0;
  v8[4] = this;
  v8[5] = a3;
  v8[6] = a2;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v9, (uint64_t)v8);
  v6 = *a2 != 0;
  mach_o::Error::~Error(&v9);
  return v6;
}

void dyld4::BumpAllocator::~BumpAllocator(vm_address_t *this)
{
  if (*this)
  {
    vm_deallocate(mach_task_self_, *this, this[1]);
    this[1] = 0;
    this[2] = 0;
    *this = 0;
  }
}

uint64_t dyld4::PrebuiltLoaderSet::forEachCachePatch(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  if (*(_DWORD *)(result + 20))
  {
    v3 = result;
    v4 = 0;
    v5 = result + *(unsigned int *)(result + 24);
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v5);
      ++v4;
      v5 += 16;
    }
    while (v4 < *(unsigned int *)(v3 + 20));
  }
  return result;
}

dyld3::MachOLoaded *dyld4::APIs::dyld_image_header_containing_address(dyld4::APIs *this, char *a2)
{
  dyld3::MachOLoaded *v5;

  v5 = 0;
  dyld4::APIs::findImageMappedAt(this, a2, &v5, 0, 0, 0, 0, 0, 0);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_image_header_containing_address(%p) =>%p\n", a2, v5);
  return v5;
}

dyld4::Atlas::ProcessSnapshot *dyld4::Atlas::ProcessSnapshot::ProcessSnapshot(dyld4::Atlas::ProcessSnapshot *this, lsl::Allocator *a2, dyld4::FileManager *a3, char a4)
{
  _QWORD *v7;
  _QWORD *v8;

  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = a2;
  *((_QWORD *)this + 5) = 0;
  *((_BYTE *)this + 48) = 0;
  v7 = (_QWORD *)((char *)this + 72);
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  v8 = lsl::Allocator::aligned_alloc(a2, 8uLL, 0x30uLL);
  *v8 = a2;
  *(_OWORD *)(v8 + 1) = 0u;
  *(_OWORD *)(v8 + 3) = 0u;
  v8[5] = a2;
  lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(v7, (lsl::Allocator::AllocationMetadata *)v8);
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_BYTE *)this + 104) = a4;
  *((_BYTE *)this + 105) = 1;
  return this;
}

BOOL dyld4::APIs::_dyld_get_image_uuid(dyld4::APIs *this, mach_header *a2, unsigned __int8 *a3)
{
  _BOOL8 result;

  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_get_image_uuid(%p, %p)\n", a2, a3);
  result = dyld3::MachOFile::hasMachOMagic((dyld3::MachOFile *)a2);
  if ((_DWORD)result)
    return dyld3::MachOFile::getUuid((dyld3::MachOFile *)a2, a3);
  return result;
}

__int128 *dyld4::Atlas::ProcessSnapshot::ProcessSnapshot(__int128 *a1, lsl::Allocator *a2, uint64_t a3, char a4, uint64_t a5, unint64_t a6)
{
  uint64_t *v11;
  const os_unfair_lock **v12;
  _QWORD *v13;
  const os_unfair_lock **v14;
  _QWORD *v15;
  void *v16;
  const os_unfair_lock *v17;
  void *v18;
  const os_unfair_lock *v19;
  const os_unfair_lock *v21;
  __int128 *v22;
  __int128 v23;
  uint64_t *v24;
  const os_unfair_lock **v25;
  const os_unfair_lock **v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  __int128 *v49;
  uint64_t v50;
  __int128 *v51;

  *(_QWORD *)a1 = a2;
  *((_QWORD *)a1 + 1) = a3;
  *((_QWORD *)a1 + 2) = 0;
  v11 = (uint64_t *)(a1 + 1);
  *((_QWORD *)a1 + 3) = a2;
  *((_QWORD *)a1 + 5) = 0;
  *((_BYTE *)a1 + 48) = 0;
  *((_QWORD *)a1 + 7) = 0;
  v12 = (const os_unfair_lock **)a1 + 7;
  v13 = (_QWORD *)a1 + 9;
  *((_QWORD *)a1 + 8) = 0;
  v14 = (const os_unfair_lock **)(a1 + 4);
  v15 = lsl::Allocator::aligned_alloc(a2, 8uLL, 0x30uLL);
  *v15 = a2;
  *(_OWORD *)(v15 + 1) = 0u;
  *(_OWORD *)(v15 + 3) = 0u;
  v15[5] = a2;
  lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(v13, (lsl::Allocator::AllocationMetadata *)v15);
  *((_QWORD *)a1 + 10) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 11) = 0;
  *((_BYTE *)a1 + 104) = a4;
  *((_BYTE *)a1 + 105) = 1;
  v22 = a1;
  v23 = *a1;
  v24 = v11;
  v25 = v14;
  v26 = v12;
  v27 = v23;
  v29 = 0;
  v30 = 0;
  v28 = 0;
  v31 = v23;
  v33 = 0;
  v34 = 0;
  v32 = 0;
  v35 = v23;
  v37 = 0;
  v38 = 0;
  v36 = 0;
  v39 = v23;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = -1491447450;
  v45 = 0;
  v44 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = a1 + 5;
  v50 = (uint64_t)a1 + 88;
  v51 = a1 + 6;
  if ((dyld4::Atlas::ProcessSnapshot::Serializer::deserialize((uint64_t)&v22, a5, a6) & 1) == 0)
  {
    if (*v11)
    {
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate(*v11, *((lsl::Allocator **)a1 + 3));
      *((_QWORD *)a1 + 2) = 0;
    }
    *((_QWORD *)a1 + 5) = 0;
    *((_BYTE *)a1 + 48) = 0;
    v21 = 0;
    if (&v21 != v12)
    {
      v17 = *v12;
      *v12 = 0;
      v21 = v17;
    }
    lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v21, v16);
    v21 = 0;
    if (&v21 != v14)
    {
      v19 = *v14;
      *v14 = 0;
      v21 = v19;
    }
    lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr(&v21, v18);
    *((_BYTE *)a1 + 105) = 0;
    *((_QWORD *)a1 + 11) = 0;
    *((_QWORD *)a1 + 12) = 0;
    *((_QWORD *)a1 + 10) = 0;
  }
  if (v40)
    lsl::Vector<unsigned int>::resize((const os_unfair_lock *)&v39, 0);
  if (v36)
    lsl::Vector<std::byte>::resize((const os_unfair_lock *)&v35, 0);
  if (v32)
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v31, 0);
  if (v28)
    lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize((const os_unfair_lock *)&v27, 0);
  return a1;
}

const os_unfair_lock *dyld4::Atlas::ProcessSnapshot::serialize@<X0>(dyld4::Atlas::ProcessSnapshot *this@<X0>, lsl::Allocator **a2@<X8>)
{
  const os_unfair_lock *result;
  dyld4::Atlas::ProcessSnapshot *v3;
  __int128 v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char *v31;
  char *v32;

  v3 = this;
  v5 = (char *)this + 16;
  v6 = (char *)this + 64;
  v7 = (char *)this + 56;
  v24 = -1491447450;
  v4 = *(_OWORD *)this;
  v8 = v4;
  v10 = 0;
  v11 = 0;
  v9 = 0;
  v12 = v4;
  v14 = 0;
  v15 = 0;
  v13 = 0;
  v16 = v4;
  v18 = 0;
  v19 = 0;
  v17 = 0;
  v20 = v4;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v26 = 0;
  v25 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = (char *)this + 80;
  v31 = (char *)this + 88;
  v32 = (char *)this + 96;
  result = dyld4::Atlas::ProcessSnapshot::Serializer::serialize((dyld4::Atlas::ProcessSnapshot::Serializer *)&v3, a2);
  if (v21)
    result = lsl::Vector<unsigned int>::resize((const os_unfair_lock *)&v20, 0);
  if (v17)
    result = lsl::Vector<std::byte>::resize((const os_unfair_lock *)&v16, 0);
  if (v13)
    result = lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v12, 0);
  if (v9)
    return lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize((const os_unfair_lock *)&v8, 0);
  return result;
}

const os_unfair_lock *lsl::Vector<std::byte>::resize(const os_unfair_lock *result, unint64_t a2)
{
  _QWORD *v2;
  const os_unfair_lock *v3;

  if (*(_QWORD *)&result[6]._os_unfair_lock_opaque < a2)
    return (const os_unfair_lock *)lsl::Vector<std::byte>::reserve((uint64_t)result, a2);
  if (a2)
  {
    *(_QWORD *)&result[4]._os_unfair_lock_opaque = a2;
    *(_QWORD *)&result[6]._os_unfair_lock_opaque = a2;
    return (const os_unfair_lock *)lsl::Allocator::realloc(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, *(_QWORD **)&result[2]._os_unfair_lock_opaque, a2);
  }
  else
  {
    v3 = result + 2;
    v2 = *(_QWORD **)&result[2]._os_unfair_lock_opaque;
    if (v2)
      result = lsl::Allocator::free(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, v2);
    *(_QWORD *)&v3->_os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[2]._os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[4]._os_unfair_lock_opaque = 0;
  }
  return result;
}

const os_unfair_lock *lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize(const os_unfair_lock *result, unint64_t a2)
{
  _QWORD *v2;
  const os_unfair_lock *v3;

  if (*(_QWORD *)&result[6]._os_unfair_lock_opaque < a2)
    return (const os_unfair_lock *)lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)result, a2);
  if (a2)
  {
    *(_QWORD *)&result[4]._os_unfair_lock_opaque = a2;
    *(_QWORD *)&result[6]._os_unfair_lock_opaque = a2;
    return (const os_unfair_lock *)lsl::Allocator::realloc(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, *(_QWORD **)&result[2]._os_unfair_lock_opaque, 16 * a2);
  }
  else
  {
    v3 = result + 2;
    v2 = *(_QWORD **)&result[2]._os_unfair_lock_opaque;
    if (v2)
      result = lsl::Allocator::free(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, v2);
    *(_QWORD *)&v3->_os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[2]._os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[4]._os_unfair_lock_opaque = 0;
  }
  return result;
}

const os_unfair_lock *lsl::Vector<dyld4::Loader const*>::resize(const os_unfair_lock *result, unint64_t a2)
{
  _QWORD *v2;
  const os_unfair_lock *v3;

  if (*(_QWORD *)&result[6]._os_unfair_lock_opaque < a2)
    return (const os_unfair_lock *)lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)result, a2);
  if (a2)
  {
    *(_QWORD *)&result[4]._os_unfair_lock_opaque = a2;
    *(_QWORD *)&result[6]._os_unfair_lock_opaque = a2;
    return (const os_unfair_lock *)lsl::Allocator::realloc(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, *(_QWORD **)&result[2]._os_unfair_lock_opaque, 8 * a2);
  }
  else
  {
    v3 = result + 2;
    v2 = *(_QWORD **)&result[2]._os_unfair_lock_opaque;
    if (v2)
      result = lsl::Allocator::free(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, v2);
    *(_QWORD *)&v3->_os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[2]._os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[4]._os_unfair_lock_opaque = 0;
  }
  return result;
}

const os_unfair_lock *lsl::Vector<unsigned int>::resize(const os_unfair_lock *result, unint64_t a2)
{
  _QWORD *v2;
  const os_unfair_lock *v3;

  if (*(_QWORD *)&result[6]._os_unfair_lock_opaque < a2)
    return (const os_unfair_lock *)lsl::Vector<unsigned int>::reserve((uint64_t)result, a2);
  if (a2)
  {
    *(_QWORD *)&result[4]._os_unfair_lock_opaque = a2;
    *(_QWORD *)&result[6]._os_unfair_lock_opaque = a2;
    return (const os_unfair_lock *)lsl::Allocator::realloc(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, *(_QWORD **)&result[2]._os_unfair_lock_opaque, 4 * a2);
  }
  else
  {
    v3 = result + 2;
    v2 = *(_QWORD **)&result[2]._os_unfair_lock_opaque;
    if (v2)
      result = lsl::Allocator::free(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, v2);
    *(_QWORD *)&v3->_os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[2]._os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[4]._os_unfair_lock_opaque = 0;
  }
  return result;
}

const os_unfair_lock *dyld4::Atlas::ProcessSnapshot::Serializer::serialize@<X0>(dyld4::Atlas::ProcessSnapshot::Serializer *this@<X0>, lsl::Allocator **a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  lsl::Allocator *v6;
  uint64_t v7;
  dyld4::FileRecord *v8;
  __n128 *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  unsigned __int8 v17;
  uint64_t v18;
  uint64_t v19;
  dyld4::FileRecord *v20;
  __n128 *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  char v31;
  const os_unfair_lock *v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  unsigned __int8 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int *v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  char *v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  uint64_t v81;
  unsigned __int8 v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  dyld4::Atlas::Image *v87;
  uint64_t v88;
  unint64_t v89;
  char v90;
  unint64_t v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  char v95;
  lsl::Allocator *v96;
  lsl::Allocator *v97;
  lsl::Allocator *v98;
  unsigned int *v99;
  const os_unfair_lock *result;
  char *v101;
  char *v102;
  uint64_t v103;
  lsl::Allocator *v104;
  uint64_t v105;
  char v106;
  const os_unfair_lock *v107;
  lsl::Allocator *v108;
  uint64_t v109;
  char v110;
  uint64_t *v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  uint64_t v118;
  int v119;
  char v120;
  uint64_t v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  uint64_t v128;
  int v129;
  char v130;
  char *v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  _QWORD v136[3];
  __int16 v137;
  char v138;
  char *Path;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  uint64_t v145;
  __int16 v146;
  unsigned __int8 v147;
  _OWORD v148[8];

  *((_QWORD *)this + 25) = mach_absolute_time();
  ++*((_DWORD *)this + 52);
  v6 = (lsl::Allocator *)*((_QWORD *)this + 1);
  *a2 = v6;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  v107 = 0;
  v108 = v6;
  v109 = 0;
  v110 = 0;
  v103 = 0;
  v104 = v6;
  v105 = 0;
  v106 = 0;
  if (vm_page_size == 0x4000)
    *((_QWORD *)this + 27) |= 4uLL;
  v7 = **((_QWORD **)this + 4);
  if (v7)
  {
    *((_QWORD *)this + 27) |= 1uLL;
    v8 = (dyld4::FileRecord *)(v7 + 8);
    if (dyld4::FileRecord::persistent((dyld4::FileRecord *)(v7 + 8)))
    {
      v9 = (__n128 *)dyld4::FileRecord::volume(v8);
      lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::insert((uint64_t)&v103, v9, (uint64_t)v148);
    }
    else
    {
      Path = (char *)dyld4::FileRecord::getPath(v8);
      if (Path)
      {
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v107, &Path, (uint64_t)v148);
      }
      else
      {
        v131 = "???";
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v107, &v131, (uint64_t)v148);
      }
    }
  }
  *(_QWORD *)&v148[0] = *((_QWORD *)this + 3);
  v10 = *(char **)&v148[0];
  memset((char *)v148 + 8, 0, 91);
  v11 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)v148, v4, v5);
  v12 = *(char **)v11;
  v140 = *(_OWORD *)(v11 + 8);
  v13 = *(_OWORD *)(v11 + 72);
  v14 = *(_OWORD *)(v11 + 56);
  v15 = *(_OWORD *)(v11 + 40);
  v141 = *(_OWORD *)(v11 + 24);
  v142 = v15;
  v143 = v14;
  v144 = v13;
  v16 = *(_QWORD *)(v11 + 88);
  v146 = *(_WORD *)(v11 + 96);
  v17 = *(_BYTE *)(v11 + 98);
  v145 = v16;
  Path = v12;
  v147 = v17;
  *(_OWORD *)((char *)&v148[4] + 10) = 0u;
  v132 = 0u;
  v133 = 0u;
  v134 = 0u;
  v135 = 0u;
  memset(v136, 0, sizeof(v136));
  v131 = v10;
  v137 = 0;
  v138 = 0;
  while (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&Path, (uint64_t)&v131))
  {
    v20 = (dyld4::FileRecord *)(*(_QWORD *)(*((_QWORD *)&v140 + v147 - 1) + 8 * *((unsigned __int8 *)&v145 + v147 - 1))
                              + 8);
    if (dyld4::FileRecord::persistent(v20))
    {
      v21 = (__n128 *)dyld4::FileRecord::volume(v20);
      lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::insert((uint64_t)&v103, v21, (uint64_t)v148);
    }
    else
    {
      v102 = 0;
      v102 = (char *)dyld4::FileRecord::getPath(v20);
      if (v102)
      {
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v107, &v102, (uint64_t)v148);
      }
      else
      {
        v101 = "???";
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v107, &v101, (uint64_t)v148);
      }
    }
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)&Path, v22, v23);
  }
  *(_QWORD *)&v148[0] = &v103;
  memset((char *)v148 + 8, 0, 109);
  v24 = lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator++((uint64_t)v148, v18, v19);
  v25 = *(_QWORD *)v24;
  v26 = *(_OWORD *)(v24 + 88);
  v27 = *(_OWORD *)(v24 + 72);
  v28 = *(_OWORD *)(v24 + 56);
  v124 = *(_OWORD *)(v24 + 40);
  v125 = v28;
  v126 = v27;
  v127 = v26;
  v29 = *(_OWORD *)(v24 + 24);
  v122 = *(_OWORD *)(v24 + 8);
  v123 = v29;
  v30 = *(_QWORD *)(v24 + 104);
  v129 = *(_DWORD *)(v24 + 112);
  v31 = *(_BYTE *)(v24 + 116);
  v128 = v30;
  v121 = v25;
  v130 = v31;
  memset(v148, 0, 108);
  v111 = &v103;
  v117 = 0u;
  v116 = 0u;
  v115 = 0u;
  v114 = 0u;
  v113 = 0u;
  v112 = 0u;
  v119 = 0;
  v118 = 0;
  v120 = 0;
  v32 = (const os_unfair_lock *)lsl::Vector<lsl::UUID>::Vector<lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::const_iterator>(v148, &v121, (uint64_t)&v111, *((_QWORD *)this + 1));
  if ((_OWORD *)((char *)this + 48) != v148)
  {
    v35 = v148[1];
    v148[1] = *((_OWORD *)this + 4);
    v37 = *((_QWORD *)this + 6);
    v36 = *((_QWORD *)this + 7);
    *((_OWORD *)this + 3) = v148[0];
    *((_OWORD *)this + 4) = v35;
    *(_QWORD *)&v148[0] = v37;
    *((_QWORD *)&v148[0] + 1) = v36;
    if (!v36)
      goto LABEL_19;
    goto LABEL_18;
  }
  if (*((_QWORD *)&v148[0] + 1))
LABEL_18:
    lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize(v32, 0);
LABEL_19:
  *(_QWORD *)&v148[0] = &v107;
  memset((char *)v148 + 8, 0, 91);
  v38 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)v148, v33, v34);
  v39 = *(char **)v38;
  v140 = *(_OWORD *)(v38 + 8);
  v40 = *(_OWORD *)(v38 + 72);
  v41 = *(_OWORD *)(v38 + 56);
  v42 = *(_OWORD *)(v38 + 40);
  v141 = *(_OWORD *)(v38 + 24);
  v142 = v42;
  v143 = v41;
  v144 = v40;
  v43 = *(_QWORD *)(v38 + 88);
  v146 = *(_WORD *)(v38 + 96);
  v44 = *(_BYTE *)(v38 + 98);
  v145 = v43;
  Path = v39;
  v147 = v44;
  *(_OWORD *)((char *)v136 + 2) = 0u;
  memset((char *)v148 + 8, 0, 91);
  *(_QWORD *)&v148[0] = &v107;
  while (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&Path, (uint64_t)v148))
  {
    v45 = v147 - 1;
    v46 = *((_QWORD *)&v140 + v45);
    v47 = *((unsigned __int8 *)&v145 + v45);
    v48 = *((_QWORD *)this + 16);
    lsl::Vector<unsigned int>::reserve((uint64_t)this + 144, *((_QWORD *)this + 20) + 1);
    v49 = *((_QWORD *)this + 19);
    v50 = *((_QWORD *)this + 20);
    *((_QWORD *)this + 20) = v50 + 1;
    *(_DWORD *)(v49 + 4 * v50) = v48;
    v51 = *(char **)(v46 + 8 * v47);
    if (*v51)
    {
      v52 = 1;
      do
      {
        lsl::Vector<std::byte>::reserve((uint64_t)this + 112, *((_QWORD *)this + 16) + 1);
        v53 = *v51;
        v54 = *((_QWORD *)this + 15);
        v55 = *((_QWORD *)this + 16);
        *((_QWORD *)this + 16) = v55 + 1;
        *(_BYTE *)(v54 + v55) = v53;
        v51 = (char *)(*(_QWORD *)(v46 + 8 * v47) + v52++);
      }
      while (*v51);
    }
    lsl::Vector<std::byte>::reserve((uint64_t)this + 112, *((_QWORD *)this + 16) + 1);
    v56 = *((_QWORD *)this + 15);
    v57 = *((_QWORD *)this + 16);
    *((_QWORD *)this + 16) = v57 + 1;
    *(_BYTE *)(v56 + v57) = 0;
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)&Path, v58, v59);
  }
  v60 = *((_QWORD *)this + 20);
  if (v60)
  {
    v61 = (unsigned int *)*((_QWORD *)this + 19);
    v62 = *((_QWORD *)this + 12);
    v63 = 4 * v60;
    do
    {
      v64 = *v61++;
      v65 = *((_QWORD *)this + 15) + v64;
      lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 80, v62 + 1);
      v66 = *((_QWORD *)this + 11);
      v67 = *((_QWORD *)this + 12);
      v62 = v67 + 1;
      *((_QWORD *)this + 12) = v67 + 1;
      *(_QWORD *)(v66 + 8 * v67) = v65;
      v63 -= 4;
    }
    while (v63);
  }
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 44), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 45), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned long long>(*((_QWORD *)this + 23), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 48), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 52), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned long long>(*((_QWORD *)this + 25), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 53), (uint64_t)a2);
  lsl::emitPVLEUInt64(*((_QWORD *)this + 27), (uint64_t)a2);
  lsl::emitPVLEUInt64(**((_QWORD **)this + 28), (uint64_t)a2);
  lsl::emitPVLEUInt64(**((_QWORD **)this + 29), (uint64_t)a2);
  lsl::emitPVLEUInt64(**((_QWORD **)this + 30), (uint64_t)a2);
  lsl::emitPVLEUInt64(*((_QWORD *)this + 8), (uint64_t)a2);
  v68 = *((_QWORD *)this + 8);
  if (v68)
  {
    v69 = (char *)*((_QWORD *)this + 7);
    v70 = 16 * v68;
    do
    {
      v71 = v69 + 16;
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>((uint64_t)v148, v69, v69 + 16, (uint64_t)a2);
      v69 = v71;
      v70 -= 16;
    }
    while (v70);
  }
  lsl::emitPVLEUInt64(*((_QWORD *)this + 16), (uint64_t)a2);
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>((uint64_t)v148, *((char **)this + 15), (char *)(*((_QWORD *)this + 15) + *((_QWORD *)this + 16)), (uint64_t)a2);
  if ((*((_QWORD *)this + 27) & 1) != 0)
  {
    v72 = 14;
    if ((*((_QWORD *)this + 27) & 4) == 0)
      v72 = 12;
    dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo((uint64_t)this, *(_QWORD *)(**((_QWORD **)this + 4) + 160) >> v72, (char *)(**((_QWORD **)this + 4) + 88), (dyld4::FileRecord *)(**((_QWORD **)this + 4) + 8), (uint64_t)a2);
    dyld4::Atlas::Bitmap::emit(**((_QWORD **)this + 5), (uint64_t)a2);
  }
  lsl::emitPVLEUInt64(*(_QWORD *)(*((_QWORD *)this + 3) + 24), (uint64_t)a2);
  *(_QWORD *)&v148[0] = *((_QWORD *)this + 3);
  v73 = *(_QWORD *)&v148[0];
  memset((char *)v148 + 8, 0, 91);
  v76 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)v148, v74, v75);
  v77 = *(char **)v76;
  v140 = *(_OWORD *)(v76 + 8);
  v78 = *(_OWORD *)(v76 + 72);
  v79 = *(_OWORD *)(v76 + 56);
  v80 = *(_OWORD *)(v76 + 40);
  v141 = *(_OWORD *)(v76 + 24);
  v142 = v80;
  v143 = v79;
  v144 = v78;
  v81 = *(_QWORD *)(v76 + 88);
  v146 = *(_WORD *)(v76 + 96);
  v82 = *(_BYTE *)(v76 + 98);
  v145 = v81;
  Path = v77;
  v147 = v82;
  *(_OWORD *)((char *)v136 + 2) = 0u;
  memset((char *)v148 + 8, 0, 91);
  *(_QWORD *)&v148[0] = v73;
  if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&Path, (uint64_t)v148))
  {
    v83 = 0;
    do
    {
      v84 = v147 - 1;
      v85 = *((_QWORD *)&v140 + v84);
      v86 = *((unsigned __int8 *)&v145 + v84);
      v87 = *(dyld4::Atlas::Image **)(v85 + 8 * v86);
      v88 = *((_QWORD *)v87 + 20);
      v89 = v88 - v83;
      if ((*((_QWORD *)this + 27) & 4) != 0)
        v90 = 14;
      else
        v90 = 12;
      v91 = v89 >> v90;
      v92 = (char *)dyld4::Atlas::Image::uuid(v87);
      dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo((uint64_t)this, v91, v92, (dyld4::FileRecord *)(*(_QWORD *)(v85 + 8 * v86) + 8), (uint64_t)a2);
      lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)&Path, v93, v94);
      v95 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&Path, (uint64_t)v148);
      v83 = v88;
    }
    while (v95);
  }
  while (1)
  {
    v98 = a2[2];
    if ((v98 & 0xF) == 0)
      break;
    lsl::Vector<std::byte>::reserve((uint64_t)a2, (unint64_t)v98 + 1);
    v96 = a2[1];
    v97 = a2[2];
    a2[2] = (lsl::Allocator *)((char *)v97 + 1);
    *((_BYTE *)v97 + (_QWORD)v96) = 0;
  }
  v99 = (unsigned int *)lsl::CRC32c::CRC32c((uint64_t)v148);
  lsl::CRC32c::operator()(v99, (uint64_t)a2[1], (uint64_t)a2[2]);
  *((_DWORD *)a2[1] + 8) = lsl::CRC32c::operator unsigned int((uint64_t)v148);
  if (v103)
    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::deallocate(v103, v104);
  result = v107;
  if (v107)
    return lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::deallocate((uint64_t)v107, v108);
  return result;
}

uint64_t lsl::Vector<std::byte>::reserve(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  if (*(_QWORD *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      v2 = 16;
    }
    return lsl::Vector<std::byte>::reserveExact(result, v2);
  }
  return result;
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  BOOL v11;
  unsigned int v12;

  v2 = *(unsigned __int8 *)(a2 + 98);
  v3 = *(unsigned __int8 *)(a1 + 98);
  if (v2 >= v3)
    v4 = *(unsigned __int8 *)(a1 + 98);
  else
    v4 = *(unsigned __int8 *)(a2 + 98);
  if ((_DWORD)v4)
  {
    v5 = (unsigned __int8 *)(a1 + 88);
    v6 = (unsigned __int8 *)(a2 + 88);
    while (1)
    {
      v8 = *v5++;
      v7 = v8;
      v9 = *v6++;
      v10 = v7 >= v9;
      if (v7 != v9)
        break;
      if (!--v4)
        goto LABEL_8;
    }
    if (v10)
      return 1;
    else
      return 0xFFFFFFFFLL;
  }
  else
  {
LABEL_8:
    v11 = v3 == v2;
    if (v3 < v2)
      v12 = -1;
    else
      v12 = 1;
    if (v11)
      return 0;
    else
      return v12;
  }
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *(unsigned __int8 *)(result + 98);
  v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 98))
  {
    v5 = *((unsigned __int8 *)v4 + 32);
    v6 = result + 88;
    ++*(_BYTE *)(result + 88 + (v3 - 1));
    if (v3 == v5)
    {
      v7 = *((unsigned __int8 *)v4 + 32);
      if (v7)
      {
        for (i = 0; i != v7; ++i)
        {
          if (*(_BYTE *)(v6 + (v7 + ~(_BYTE)i)) != (*(_BYTE *)(*(_QWORD *)(result
                                                                                           + 8
                                                                                           + 8
                                                                                           * (v7 + ~(_BYTE)i))
                                                                               + 248) & 0x7F))
            break;
          *(_BYTE *)(result + 98) = v7 + ~(_BYTE)i;
        }
      }
    }
    else
    {
      v15 = *(unsigned __int8 *)(result + 98);
      if (v15 != *((unsigned __int8 *)v4 + 32))
      {
        v16 = result + 8;
        do
        {
          v17 = *(_QWORD *)(v16 + 8 * (v15 - 1));
          if (*(char *)(v17 + 248) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
          *(_QWORD *)(v16 + 8 * v15) = *(_QWORD *)(v17
                                                                    + 8
                                                                    * *(unsigned __int8 *)(v6
                                                                                         + v15
                                                                                         - 1)
                                                                    + 120);
          *(_BYTE *)(v6 + v15) = 0;
          LOBYTE(v15) = *(_BYTE *)(result + 98) + 1;
          *(_BYTE *)(result + 98) = v15;
        }
        while (*((unsigned __int8 *)v4 + 32) != v15);
      }
    }
  }
  else
  {
    v9 = *v4;
    *(_BYTE *)(result + 98) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      v10 = 0;
      v11 = result + 8;
      do
      {
        *(_QWORD *)(v11 + 8 * v10) = v9;
        *(_BYTE *)(result + 88 + v10) = 0;
        v12 = *(unsigned __int8 *)(result + 98);
        v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          v14 = *(_QWORD *)(v11 + 8 * v12);
          if (*(char *)(v14 + 248) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
          v9 = *(_QWORD *)(v14 + 120);
        }
        v10 = v12 + 1;
        *(_BYTE *)(result + 98) = v10;
      }
      while (v13 > v10);
    }
  }
  return result;
}

uint64_t lsl::Vector<std::byte>::reserveExact(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t i;
  _QWORD *v7;

  if (*(_QWORD *)(result + 24) < a2)
  {
    v3 = result;
    result = lsl::Allocator::realloc(*(lsl::Allocator **)result, *(_QWORD **)(result + 8), a2);
    if ((result & 1) == 0)
    {
      result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)v3, 0x10uLL, a2);
      v4 = result;
      v5 = *(_QWORD *)(v3 + 16);
      if (v5)
      {
        for (i = 0; i < v5; ++i)
        {
          *(_BYTE *)(result + i) = *(_BYTE *)(*(_QWORD *)(v3 + 8) + i);
          v5 = *(_QWORD *)(v3 + 16);
        }
      }
      v7 = *(_QWORD **)(v3 + 8);
      if (v7)
      {
        result = (uint64_t)lsl::Allocator::free(*(lsl::Allocator **)v3, v7);
        v5 = *(_QWORD *)(v3 + 16);
      }
      if (v5 >= a2)
        v5 = a2;
      *(_QWORD *)(v3 + 8) = v4;
      *(_QWORD *)(v3 + 16) = v5;
    }
    *(_QWORD *)(v3 + 24) = a2;
  }
  return result;
}

_QWORD *lsl::Allocator::aligned_alloc(lsl::Allocator *this, unint64_t a2, unint64_t a3)
{
  uint8x8_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  lsl::Lock *v10;
  _QWORD *v11;
  lsl::Allocator::Pool *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *bytes;
  uint64_t v19;
  lsl::Allocator::Pool *v20;

  v4 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] != 1)
    lsl::Allocator::aligned_alloc();
  v7 = 16;
  if (a2 <= 0x10)
    v8 = 16;
  else
    v8 = a2;
  if (a3 > 0x10)
    v7 = a3;
  v9 = (v8 + v7 - 1) & -v8;
  v10 = (lsl::Lock *)*((_QWORD *)this + 5);
  lsl::Lock::lock(v10);
  v11 = (_QWORD *)*((_QWORD *)this + 5);
  v11[5] = a2;
  v11[6] = a3;
  v11[7] = v8;
  v11[8] = v9;
  v12 = (lsl::Allocator::Pool *)*((_QWORD *)this + 1);
  if (*((_BYTE *)this + 32))
    v13 = lsl::Allocator::Pool::aligned_alloc_best_fit(v12, v8, v9);
  else
    v13 = lsl::Allocator::Pool::aligned_alloc(v12, v8, v9);
  v14 = v13;
  if (!v13)
  {
    v15 = *((_QWORD *)this + 1);
    if (((v8 + v9 + 16463) & 0xFFFFFFFFFFFFC000) <= 0x40000)
      v16 = 0x40000;
    else
      v16 = (v8 + v9 + 16463) & 0xFFFFFFFFFFFFC000;
    v17 = *(_QWORD *)(v15 + 8);
    bytes = (unint64_t *)lsl::MemoryManager::vm_allocate_bytes(*((lsl::MemoryManager **)this + 5), v16);
    lsl::Allocator::Pool::Pool(v17, (uint64_t)this, v15, (unint64_t)bytes, v19, bytes, v19);
    *(_QWORD *)(v15 + 8) = v17;
    v20 = *(lsl::Allocator::Pool **)(*((_QWORD *)this + 1) + 8);
    *((_QWORD *)this + 1) = v20;
    v14 = lsl::Allocator::Pool::aligned_alloc(v20, v8, v9);
    if (!v14)
      lsl::Allocator::aligned_alloc();
  }
  *((_QWORD *)this + 2) += v9;
  lsl::Lock::unlock(v10);
  return v14;
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(int a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  char v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  v3 = 0;
  v8 = a1;
  do
  {
    result = lsl::Vector<std::byte>::reserve(a2, *(_QWORD *)(a2 + 16) + 1);
    v5 = *((_BYTE *)&v8 + v3);
    v6 = *(_QWORD *)(a2 + 8);
    v7 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 16) = v7 + 1;
    *(_BYTE *)(v6 + v7) = v5;
    ++v3;
  }
  while (v3 != 4);
  return result;
}

char *dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo(uint64_t a1, unint64_t a2, char *a3, dyld4::FileRecord *this, uint64_t a5)
{
  uint64_t v10;
  int v11;
  BOOL v12;
  unint64_t v13;
  char *result;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  unint64_t v29;
  uint64_t Path;
  char v31;

  v10 = 0;
  do
  {
    v11 = a3[v10];
    if (a3[v10])
      v12 = 1;
    else
      v12 = v10 == 15;
    ++v10;
  }
  while (!v12);
  v13 = 4 * (v11 != 0);
  if (dyld4::FileRecord::persistent(this))
  {
    v13 |= 1uLL;
  }
  else if (dyld4::FileRecord::getPath(this))
  {
    v13 |= 2uLL;
  }
  lsl::emitPVLEUInt64(v13, a5);
  result = lsl::emitPVLEUInt64(a2, a5);
  if ((v13 & 4) != 0)
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>((uint64_t)&v31, a3, a3 + 16, a5);
  if ((v13 & 1) != 0)
  {
    v15 = *(_QWORD *)(a1 + 56);
    v16 = *(_QWORD *)(a1 + 64);
    v17 = dyld4::FileRecord::volume(this);
    if (v16)
    {
      do
      {
        v18 = 0;
        v19 = v16 >> 1;
        v20 = v15 + 16 * (v16 >> 1);
        while (1)
        {
          v21 = *(unsigned __int8 *)(v20 + v18);
          v22 = *(unsigned __int8 *)(v17 + v18);
          if (v21 < v22)
            break;
          if (v22 < v21 || v18++ == 15)
            goto LABEL_24;
        }
        v15 = v20 + 16;
        v19 = v16 + ~v19;
LABEL_24:
        v16 = v19;
      }
      while (v19);
    }
    if (v15 == *(_QWORD *)(a1 + 56) + 16 * *(_QWORD *)(a1 + 64))
      dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo();
    v24 = dyld4::FileRecord::volume(this);
    v25 = 0;
    do
    {
      v26 = *(unsigned __int8 *)(v15 + v25);
      v27 = *(unsigned __int8 *)(v24 + v25);
    }
    while (v26 == v27 && v25++ != 15);
    if (v26 != v27)
      dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo();
    lsl::emitPVLEUInt64((unsigned __int16)((unint64_t)(v15 - *(_DWORD *)(a1 + 56)) >> 4), a5);
    v29 = dyld4::FileRecord::objectID(this);
    result = lsl::emitPVLEUInt64(v29, a5);
  }
  if ((v13 & 2) != 0)
  {
    Path = dyld4::FileRecord::getPath(this);
    return dyld4::Atlas::ProcessSnapshot::Serializer::emitStringRef(a1, Path, a5);
  }
  return result;
}

char *lsl::emitPVLEUInt64(unint64_t a1, uint64_t a2)
{
  int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v11;
  uint64_t v12;

  v11 = a1;
  v3 = __clz(a1);
  if (v3 == 64)
    v4 = 1;
  else
    v4 = 64 - v3;
  if (v4 < 0x39)
  {
    v9 = (v4 + 6) / 7;
    v11 = (a1 << v9) | (1 << (v9 - 1));
    v7 = (char *)&v11 + v9;
    v8 = (char *)&v12 + 7;
  }
  else
  {
    lsl::Vector<std::byte>::reserve(a2, *(_QWORD *)(a2 + 16) + 1);
    v5 = *(_QWORD *)(a2 + 8);
    v6 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 16) = v6 + 1;
    *(_BYTE *)(v5 + v6) = 0;
    v7 = (char *)&v12;
    v8 = (char *)&v12 + 6;
  }
  return std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>((uint64_t)v8, (char *)&v11, v7, a2);
}

uint64_t dyld4::FileRecord::getPath(dyld4::FileRecord *this)
{
  fsid_t v2;
  void *v3;
  const os_unfair_lock *v4;
  char *v6;

  if (!*((_QWORD *)this + 5))
  {
    v2 = (fsid_t)*((_QWORD *)this + 2);
    if (v2)
      dyld4::FileManager::getPath(*(char **)this, v2, *((_QWORD *)this + 1), &v6);
    else
      dyld4::FileManager::getPath(*(char **)this, (const UUID *)((char *)this + 24), *((_QWORD *)this + 1), &v6);
    v4 = (const os_unfair_lock *)*((_QWORD *)this + 5);
    *((_QWORD *)this + 5) = v6;
    if (v4)
      lsl::Allocator::freeObject(v4, v3);
  }
  return *((_QWORD *)this + 5);
}

BOOL dyld4::FileRecord::persistent(dyld4::FileRecord *this)
{
  uint64_t v1;
  char *v2;
  int v3;
  BOOL v4;

  v1 = 0;
  v2 = (char *)this + 24;
  do
  {
    v3 = v2[v1];
    if (v2[v1])
      v4 = 1;
    else
      v4 = v1 == 15;
    ++v1;
  }
  while (!v4);
  return v3 && *((_QWORD *)this + 1) != 0;
}

uint64_t dyld4::FileRecord::volume(dyld4::FileRecord *this)
{
  return (uint64_t)this + 24;
}

uint64_t dyld4::Atlas::Image::uuid(dyld4::Atlas::Image *this)
{
  dyld3::MachOFile *v2;
  dyld3::MachOFile *v3;
  unsigned __int8 v5[16];

  if (!*((_BYTE *)this + 184))
  {
    memset(v5, 0, sizeof(v5));
    v2 = (dyld3::MachOFile *)dyld4::Atlas::Image::ml(this);
    if (v2)
    {
      v3 = v2;
      if (dyld3::MachOFile::hasMachOMagic(v2) && dyld3::MachOFile::getUuid(v3, v5))
        *((_OWORD *)this + 6) = *(_OWORD *)v5;
    }
    *((_BYTE *)this + 184) = 1;
  }
  return (uint64_t)this + 96;
}

BOOL dyld3::MachOFile::hasMachOMagic(dyld3::MachOFile *this)
{
  return *(_DWORD *)this >> 1 == 2138504551;
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::insert_internal@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result;
  uint64_t v9;
  char *v10;
  int v11;
  int v12;
  char *v13;
  char *v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  _QWORD *v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE v34[27];

  if (*(_QWORD *)a1)
  {
    v29 = a1;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    memset(v34, 0, sizeof(v34));
    result = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(a2, (uint64_t)&v29);
    if ((_BYTE)result
      && (v9 = *(unsigned __int8 *)(a2 + 98),
          v10 = *(char **)(*(_QWORD *)(a2 + 8 + 8 * (v9 - 1)) + 8 * *(unsigned __int8 *)(a2 + 88 + v9 - 1)),
          v11 = **a3,
          v11 >= *v10))
    {
      v12 = *v10;
      v13 = v10 + 1;
      v14 = *a3 + 1;
      while (v12 && (char)v12 >= (char)v11)
      {
        if ((_BYTE)v11)
        {
          v15 = *v14++;
          v11 = v15;
          v16 = *v13++;
          v12 = v16;
          if (v11 >= v16)
            continue;
        }
        goto LABEL_9;
      }
      v25 = 0;
      v27 = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
      v28 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = v28;
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(_QWORD *)a4 = *(_QWORD *)a2;
      *(_OWORD *)(a4 + 8) = v27;
      *(_QWORD *)(a4 + 88) = *(_QWORD *)(a2 + 88);
      *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
      *(_BYTE *)(a4 + 98) = v9;
    }
    else
    {
LABEL_9:
      v29 = a1;
      v30 = 0u;
      v31 = 0u;
      v32 = 0u;
      v33 = 0u;
      memset(v34, 0, sizeof(v34));
      if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(a2, (uint64_t)&v29)&& *(unsigned __int8 *)(a2 + 98) == *(unsigned __int8 *)(a1 + 32))
      {
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2, v17, v18);
        v19 = a2 + 88;
        v20 = *(unsigned __int8 *)(a2 + 98) - 1;
        v21 = *(_BYTE *)(a2 + 88 + v20);
      }
      else
      {
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--(a2, v17, v18);
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2, v22, v23);
        v19 = a2 + 88;
        v24 = *(unsigned __int8 *)(a2 + 98) + a2 + 88;
        v21 = *(_BYTE *)(v24 - 1) + 1;
        *(_BYTE *)(v24 - 1) = v21;
        v20 = *(unsigned __int8 *)(a2 + 98) - 1;
      }
      result = (uint64_t)lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(*(char **)(a2 + 8 + 8 * v20), v21, a3);
      ++*(_QWORD *)(a1 + 24);
      *(_QWORD *)a4 = *(_QWORD *)a2;
      *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
      *(_QWORD *)(a4 + 88) = *(_QWORD *)v19;
      *(_WORD *)(a4 + 96) = *(_WORD *)(v19 + 8);
      *(_BYTE *)(a4 + 98) = *(_BYTE *)(a2 + 98);
      v25 = 1;
    }
  }
  else
  {
    v26 = lsl::Allocator::aligned_alloc(*(lsl::Allocator **)(a1 + 8), 0x100uLL, 0x100uLL);
    *((_BYTE *)v26 + 248) = 0x80;
    *(_OWORD *)v26 = 0u;
    *((_OWORD *)v26 + 1) = 0u;
    *((_OWORD *)v26 + 2) = 0u;
    *((_OWORD *)v26 + 3) = 0u;
    *((_OWORD *)v26 + 4) = 0u;
    *((_OWORD *)v26 + 5) = 0u;
    *((_OWORD *)v26 + 6) = 0u;
    *((_OWORD *)v26 + 7) = 0u;
    *((_OWORD *)v26 + 8) = 0u;
    *((_OWORD *)v26 + 9) = 0u;
    *((_OWORD *)v26 + 10) = 0u;
    *((_OWORD *)v26 + 11) = 0u;
    *((_OWORD *)v26 + 12) = 0u;
    *((_OWORD *)v26 + 13) = 0u;
    *((_OWORD *)v26 + 14) = 0u;
    v26[30] = 0;
    *(_QWORD *)a1 = v26;
    v25 = 1;
    *(_BYTE *)(a1 + 32) = 1;
    *(_QWORD *)(a2 + 8) = v26;
    *(_BYTE *)(a2 + 98) = 1;
    result = (uint64_t)lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert((char *)v26, 0, a3);
    ++*(_QWORD *)(a1 + 24);
    *(_QWORD *)a4 = *(_QWORD *)a2;
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_QWORD *)(a4 + 88) = *(_QWORD *)(a2 + 88);
    *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
    *(_BYTE *)(a4 + 98) = *(_BYTE *)(a2 + 98);
  }
  *(_BYTE *)(a4 + 104) = v25;
  return result;
}

char *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(char *result, uint64_t a2, _QWORD *a3)
{
  int v3;
  int v4;
  int v5;
  char *v7;
  char *v8;

  v3 = result[248];
  v4 = v3 & 0x7F;
  if (v3 >= 0)
    v5 = 15;
  else
    v5 = 31;
  if (v4 == v5)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert((uint64_t)result, a2, (uint64_t)a3);
  if (v5 == (_DWORD)a2)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert((uint64_t)result, a2, (uint64_t)a3);
  v7 = result;
  v8 = &result[8 * a2];
  if (v4 != (_DWORD)a2)
  {
    result = (char *)memmove(&result[8 * a2 + 8], &result[8 * a2], 8 * (v3 & 0x7F) - 8 * a2);
    LOBYTE(v3) = v7[248];
  }
  v7[248] = v3 + 1;
  *(_QWORD *)v8 = *a3;
  return result;
}

char *dyld4::Atlas::ProcessSnapshot::Serializer::emitStringRef(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v10;
  char v11;
  char v12;

  v10 = a2;
  v5 = *(_QWORD **)(a1 + 88);
  v6 = &v5[*(_QWORD *)(a1 + 96)];
  v11 = 0;
  v7 = std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char const*,std::__identity,lsl::ConstCharStarCompare>(v5, v6, &v10);
  v8 = *(_QWORD **)(a1 + 88);
  if (v7 == &v8[*(_QWORD *)(a1 + 96)])
  {
    v12 = 0;
    v7 = std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char [4],std::__identity,lsl::ConstCharStarCompare>(v8, v7, "???");
  }
  return lsl::emitPVLEUInt64((*(_DWORD *)v7 - *(_DWORD *)(a1 + 120)), a3);
}

uint64_t lsl::Vector<unsigned int>::reserve(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  if (*(_QWORD *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      v2 = 16;
    }
    return lsl::Vector<unsigned int>::reserveExact(result, v2);
  }
  return result;
}

double lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert@<D0>(uint64_t *a1@<X0>, char **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  double result;
  char v7;
  char *v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  __int16 v16;
  char v17;
  char v18;
  _BYTE v19[104];

  v8 = *a2;
  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::const_iterator((uint64_t)v19, a1, &v8);
  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::insert_internal((uint64_t)a1, (uint64_t)v19, &v8, (uint64_t)&v9);
  v5 = v9;
  *(_OWORD *)(a3 + 24) = v11;
  *(_OWORD *)(a3 + 40) = v12;
  *(_OWORD *)(a3 + 56) = v13;
  *(_OWORD *)(a3 + 72) = v14;
  result = *(double *)&v10;
  *(_OWORD *)(a3 + 8) = v10;
  *(_QWORD *)(a3 + 88) = v15;
  *(_WORD *)(a3 + 96) = v16;
  v7 = v17;
  *(_QWORD *)a3 = v5;
  *(_BYTE *)(a3 + 98) = v7;
  *(_BYTE *)(a3 + 104) = v18;
  return result;
}

{
  uint64_t v6;
  double result;
  char v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  __int16 v16;
  char v17;
  char v18;
  _BYTE v19[104];

  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::const_iterator((uint64_t)v19, a1, a2);
  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::insert_internal((uint64_t)a1, (uint64_t)v19, a2, (uint64_t)&v9);
  v6 = v9;
  *(_OWORD *)(a3 + 24) = v11;
  *(_OWORD *)(a3 + 40) = v12;
  *(_OWORD *)(a3 + 56) = v13;
  *(_OWORD *)(a3 + 72) = v14;
  result = *(double *)&v10;
  *(_OWORD *)(a3 + 8) = v10;
  *(_QWORD *)(a3 + 88) = v15;
  *(_WORD *)(a3 + 96) = v16;
  v8 = v17;
  *(_QWORD *)a3 = v6;
  *(_BYTE *)(a3 + 98) = v8;
  *(_BYTE *)(a3 + 104) = v18;
  return result;
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::const_iterator(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v4;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  __int16 v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  int v18;
  int v19;
  char *v20;
  char *v21;
  int v22;
  int v23;

  *(_QWORD *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  v4 = a1 + 8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 83) = 0u;
  if (*((_BYTE *)a2 + 32))
  {
    v7 = 0;
    v8 = *a2;
    v9 = a1 + 88;
    do
    {
      *(_QWORD *)(v4 + 8 * v7) = v8;
      v10 = std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<char const**>,std::__wrap_iter<char const**>,char const*,std::__identity,lsl::ConstCharStarCompare>((_QWORD *)v8, (_QWORD *)(v8 + 8 * (*(_BYTE *)(v8 + 248) & 0x7F)), a3);
      v13 = (_WORD)v10 - v8;
      v14 = ((unint64_t)v10 - v8) >> 3;
      *(_BYTE *)(v9 + v7) = v14;
      v15 = *(_QWORD *)(v4 + 8 * v7);
      if ((*(_BYTE *)(v15 + 248) & 0x7F) != v14)
      {
        v17 = *(char **)(v15 + (v13 & 0x7F8));
        v18 = *v17;
        if (v18 < *(char *)*a3)
        {
LABEL_15:
          *(_BYTE *)(a1 + 98) = v7 + 1;
          return a1;
        }
        v19 = *(unsigned __int8 *)*a3;
        v20 = (char *)(*a3 + 1);
        v21 = v17 + 1;
        while (v19 && (char)v19 >= (char)v18)
        {
          if ((_BYTE)v18)
          {
            v22 = *v21++;
            v18 = v22;
            v23 = *v20++;
            v19 = v23;
            if (v18 >= v23)
              continue;
          }
          goto LABEL_15;
        }
      }
      v16 = *((unsigned __int8 *)a2 + 32);
      if ((_DWORD)v7 + 1 != (_DWORD)v16)
      {
        if ((*(_BYTE *)(v15 + 248) & 0x80) != 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)v10, v11, v12);
        v8 = *(_QWORD *)(v15 + (v13 & 0x7F8) + 120);
      }
      ++v7;
    }
    while (v7 < v16);
    for (*(_BYTE *)(a1 + 98) = v16; (_BYTE)v16; *(_BYTE *)(a1 + 98) = v16)
    {
      if (*(_BYTE *)(v9 + v16 - 1) != (*(_BYTE *)(*(_QWORD *)(v4
                                                                                            + 8 * v16
                                                                                            - 8)
                                                                                + 248) & 0x7F))
        break;
      LOBYTE(v16) = v16 - 1;
    }
  }
  return a1;
}

unsigned __int8 *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion(unsigned __int8 *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned __int8 v22;
  uint64_t v23;

  v3 = result[98];
  if ((_DWORD)v3 != *(unsigned __int8 *)(*(_QWORD *)result + 32))
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion((uint64_t)result, a2, a3);
  v4 = result;
  v5 = result + 8;
  if (*(char *)(*(_QWORD *)&result[8 * v3] + 248) >= 0)
    v6 = 15;
  else
    v6 = 31;
  if ((*(_BYTE *)(*(_QWORD *)&result[8 * v3] + 248) & 0x7F) == v6)
  {
    if (!result[98])
      goto LABEL_15;
    v7 = 0;
    v8 = 0;
    do
    {
      if (*(char *)(v5[v7] + 248) >= 0)
        v9 = 15;
      else
        v9 = 31;
      if ((*(_BYTE *)(v5[v7] + 248) & 0x7F) != v9)
        v8 = v7;
      ++v7;
    }
    while (v3 != v7);
    if (!v8)
    {
LABEL_15:
      if (*(char *)(*v5 + 248) >= 0)
        v10 = 15;
      else
        v10 = 31;
      if ((*(_BYTE *)(*v5 + 248) & 0x7F) == v10)
      {
        result = (unsigned __int8 *)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)(*(_QWORD *)result + 8), 0x100uLL, 0x100uLL);
        v11 = **(_QWORD **)v4;
        result[248] = 0;
        *(_OWORD *)result = 0u;
        *((_OWORD *)result + 1) = 0u;
        *((_OWORD *)result + 2) = 0u;
        *((_OWORD *)result + 3) = 0u;
        *((_OWORD *)result + 4) = 0u;
        *((_OWORD *)result + 5) = 0u;
        *((_OWORD *)result + 6) = 0u;
        *((_QWORD *)result + 14) = 0;
        *((_QWORD *)result + 15) = v11;
        **(_QWORD **)v4 = result;
        if (v4[98] && (result = (unsigned __int8 *)memmove(v4 + 89, v4 + 88, v4[98]), v4[98]))
        {
          result = (unsigned __int8 *)memmove(v5 + 1, v5, 8 * v4[98]);
          LOBYTE(v3) = v4[98] + 1;
        }
        else
        {
          LOBYTE(v3) = 1;
        }
        v8 = 0;
        v4[88] = 0;
        v12 = *(uint64_t **)v4;
        *((_QWORD *)v4 + 1) = **(_QWORD **)v4;
        ++*((_BYTE *)v12 + 32);
        v4[98] = v3;
      }
      else
      {
        v8 = 0;
      }
    }
    if (v8 + 1 < v3)
    {
      v13 = v4 + 88;
      v14 = v8;
      do
      {
        v15 = v14;
        result = (unsigned __int8 *)lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((char *)v5[v14], v13[v14], *(lsl::Allocator **)(*(_QWORD *)v4 + 8));
        v18 = v5[v14];
        if (*(char *)(v18 + 248) < 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v16, v17);
        v19 = v13[v14];
        v20 = *(_QWORD *)(v18 + 8 * v19 + 120);
        v21 = v4[v14 + 89];
        if (v21 > (*(_BYTE *)(v20 + 248) & 0x7Fu))
        {
          v22 = v19 + 1;
          v13[v14] = v22;
          v4[v14 + 89] = v21 + (~*(_BYTE *)(v20 + 248) | 0x80);
          v23 = v5[v14];
          if (*(char *)(v23 + 248) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v16, v17);
          *(_QWORD *)&v4[8 * v14 + 16] = *(_QWORD *)(v23 + 8 * v22 + 120);
        }
        ++v14;
      }
      while (v15 + 2 < v4[98]);
    }
  }
  return result;
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned long long>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = 0;
  v8 = a1;
  do
  {
    result = lsl::Vector<std::byte>::reserve(a2, *(_QWORD *)(a2 + 16) + 1);
    v5 = *((_BYTE *)&v8 + v3);
    v6 = *(_QWORD *)(a2 + 8);
    v7 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 16) = v7 + 1;
    *(_BYTE *)(v6 + v7) = v5;
    ++v3;
  }
  while (v3 != 8);
  return result;
}

uint64_t mach_absolute_time(void)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  unint64_t StatusReg;
  uint64_t v5;
  unint64_t v6;

  if (!MEMORY[0xFFFFFC090])
    return mach_absolute_time_kernel();
  if (MEMORY[0xFFFFFC090] == 2)
  {
    do
    {
      v3 = MEMORY[0xFFFFFC088];
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 6));
    }
    while (v3 != MEMORY[0xFFFFFC088]);
    return StatusReg + v3;
  }
  else if (MEMORY[0xFFFFFC090] == 3)
  {
    do
    {
      v5 = MEMORY[0xFFFFFC088];
      v6 = _ReadStatusReg(ARM64_SYSREG(3, 4, 15, 10, 6));
    }
    while (v5 != MEMORY[0xFFFFFC088]);
    return v6 + v5;
  }
  else
  {
    __isb(0xFu);
    do
    {
      v1 = MEMORY[0xFFFFFC088];
      v2 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    }
    while (v1 != MEMORY[0xFFFFFC088]);
    return v2 + v1;
  }
}

uint64_t mach_absolute_time_kernel()
{
  return mac_syscall(MACH_ABSOLUTE_TIME_TRAP);
}

int64_t mach_continuous_time_kernel(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-4, a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t lsl::CRC32c::CRC32c(uint64_t this)
{
  *(_QWORD *)this = &lsl::sCRC32cSW;
  *(_DWORD *)(this + 8) = -1;
  return this;
}

uint64_t lsl::CRC32c::operator unsigned int(uint64_t a1)
{
  return ~*(_DWORD *)(a1 + 8);
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator++(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *(unsigned __int8 *)(result + 116);
  v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 116))
  {
    v5 = *((unsigned __int8 *)v4 + 32);
    v6 = result + 104;
    ++*(_BYTE *)(result + 104 + (v3 - 1));
    if (v3 == v5)
    {
      v7 = *((unsigned __int8 *)v4 + 32);
      if (v7)
      {
        for (i = 0; i != v7; ++i)
        {
          if (*(_BYTE *)(v6 + (v7 + ~(_BYTE)i)) != (*(_BYTE *)(*(_QWORD *)(result
                                                                                           + 8
                                                                                           + 8
                                                                                           * (v7 + ~(_BYTE)i))
                                                                               + 248) & 0x7F))
            break;
          *(_BYTE *)(result + 116) = v7 + ~(_BYTE)i;
        }
      }
    }
    else
    {
      v15 = *(unsigned __int8 *)(result + 116);
      if (v15 != *((unsigned __int8 *)v4 + 32))
      {
        v16 = result + 8;
        do
        {
          v17 = *(_QWORD *)(v16 + 8 * (v15 - 1));
          if (*(char *)(v17 + 248) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
          *(_QWORD *)(v16 + 8 * v15) = *(_QWORD *)(v17
                                                                    + 8
                                                                    * *(unsigned __int8 *)(v6
                                                                                         + v15
                                                                                         - 1)
                                                                    + 160);
          *(_BYTE *)(v6 + v15) = 0;
          LOBYTE(v15) = *(_BYTE *)(result + 116) + 1;
          *(_BYTE *)(result + 116) = v15;
        }
        while (*((unsigned __int8 *)v4 + 32) != v15);
      }
    }
  }
  else
  {
    v9 = *v4;
    *(_BYTE *)(result + 116) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      v10 = 0;
      v11 = result + 8;
      do
      {
        *(_QWORD *)(v11 + 8 * v10) = v9;
        *(_BYTE *)(result + 104 + v10) = 0;
        v12 = *(unsigned __int8 *)(result + 116);
        v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          v14 = *(_QWORD *)(v11 + 8 * v12);
          if (*(char *)(v14 + 248) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
          v9 = *(_QWORD *)(v14 + 160);
        }
        v10 = v12 + 1;
        *(_BYTE *)(result + 116) = v10;
      }
      while (v13 > v10);
    }
  }
  return result;
}

uint64_t dyld4::FileRecord::objectID(dyld4::FileRecord *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  if (!result)
  {
    dyld4::FileRecord::stat((uint64_t)this);
    return *((_QWORD *)this + 1);
  }
  return result;
}

double lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::insert@<D0>(uint64_t a1@<X0>, __n128 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  double result;
  char v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  int v16;
  char v17;
  char v18;
  __n128 v19;
  _BYTE v20[120];

  v19 = *a2;
  lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::const_iterator((uint64_t)v20, a1, (uint64_t)&v19);
  lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::insert_internal(a1, (uint64_t)v20, &v19, (uint64_t)&v8);
  v5 = v8;
  *(_OWORD *)(a3 + 40) = v11;
  *(_OWORD *)(a3 + 56) = v12;
  *(_OWORD *)(a3 + 72) = v13;
  *(_OWORD *)(a3 + 88) = v14;
  *(_OWORD *)(a3 + 8) = v9;
  result = *(double *)&v10;
  *(_OWORD *)(a3 + 24) = v10;
  *(_QWORD *)(a3 + 104) = v15;
  *(_DWORD *)(a3 + 112) = v16;
  v7 = v17;
  *(_QWORD *)a3 = v5;
  *(_BYTE *)(a3 + 116) = v7;
  *(_BYTE *)(a3 + 120) = v18;
  return result;
}

void lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::insert_internal(uint64_t a1@<X0>, uint64_t a2@<X1>, __n128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  char v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _BYTE v32[29];

  if (*(_QWORD *)a1)
  {
    v26 = a1;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    memset(v32, 0, sizeof(v32));
    if (lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>(a2, (uint64_t)&v26))
    {
      v8 = 0;
      v9 = *(unsigned __int8 *)(a2 + 116);
      while (1)
      {
        v10 = a3->n128_u8[v8];
        v11 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 8 + 8 * (v9 - 1))
                                 + 16 * *(unsigned __int8 *)(a2 + 104 + v9 - 1)
                                 + v8);
        if (v10 < v11)
          break;
        if (v11 < v10 || v8++ == 15)
        {
          v13 = 0;
          v14 = *(_OWORD *)(a2 + 56);
          *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
          *(_OWORD *)(a4 + 56) = v14;
          v15 = *(_OWORD *)(a2 + 88);
          *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
          *(_OWORD *)(a4 + 88) = v15;
          v16 = *(_OWORD *)(a2 + 24);
          *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
          *(_QWORD *)a4 = *(_QWORD *)a2;
          *(_OWORD *)(a4 + 24) = v16;
          *(_QWORD *)(a4 + 104) = *(_QWORD *)(a2 + 104);
          *(_DWORD *)(a4 + 112) = *(_DWORD *)(a2 + 112);
          *(_BYTE *)(a4 + 116) = v9;
          goto LABEL_17;
        }
      }
    }
    v26 = a1;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    memset(v32, 0, sizeof(v32));
    if (lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>(a2, (uint64_t)&v26)&& *(unsigned __int8 *)(a2 + 116) == *(unsigned __int8 *)(a1 + 32))
    {
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2, v17, v18);
      v19 = a2 + 104;
      v20 = *(unsigned __int8 *)(a2 + 116) - 1;
      v21 = *(_BYTE *)(a2 + 104 + v20);
    }
    else
    {
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator--(a2, v17, v18);
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2, v23, v24);
      v19 = a2 + 104;
      v25 = *(unsigned __int8 *)(a2 + 116) + a2 + 104;
      v21 = *(_BYTE *)(v25 - 1) + 1;
      *(_BYTE *)(v25 - 1) = v21;
      v20 = *(unsigned __int8 *)(a2 + 116) - 1;
    }
    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::insert(*(_QWORD *)(a2 + 8 + 8 * v20), v21, a3);
    ++*(_QWORD *)(a1 + 24);
    *(_QWORD *)a4 = *(_QWORD *)a2;
    *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(_QWORD *)(a4 + 104) = *(_QWORD *)v19;
    *(_DWORD *)(a4 + 112) = *(_DWORD *)(v19 + 8);
    *(_BYTE *)(a4 + 116) = *(_BYTE *)(a2 + 116);
    v13 = 1;
  }
  else
  {
    v22 = lsl::Allocator::aligned_alloc(*(lsl::Allocator **)(a1 + 8), 0x100uLL, 0x100uLL);
    *((_BYTE *)v22 + 248) = 0x80;
    *(_OWORD *)v22 = 0u;
    *((_OWORD *)v22 + 1) = 0u;
    *((_OWORD *)v22 + 2) = 0u;
    *((_OWORD *)v22 + 3) = 0u;
    *((_OWORD *)v22 + 4) = 0u;
    *((_OWORD *)v22 + 5) = 0u;
    *((_OWORD *)v22 + 6) = 0u;
    *((_OWORD *)v22 + 7) = 0u;
    *((_OWORD *)v22 + 8) = 0u;
    *((_OWORD *)v22 + 9) = 0u;
    *((_OWORD *)v22 + 10) = 0u;
    *((_OWORD *)v22 + 11) = 0u;
    *((_OWORD *)v22 + 12) = 0u;
    *((_OWORD *)v22 + 13) = 0u;
    *((_OWORD *)v22 + 14) = 0u;
    *(_QWORD *)a1 = v22;
    v13 = 1;
    *(_BYTE *)(a1 + 32) = 1;
    *(_QWORD *)(a2 + 8) = v22;
    *(_BYTE *)(a2 + 116) = 1;
    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::insert((uint64_t)v22, 0, a3);
    ++*(_QWORD *)(a1 + 24);
    *(_QWORD *)a4 = *(_QWORD *)a2;
    *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(_QWORD *)(a4 + 104) = *(_QWORD *)(a2 + 104);
    *(_DWORD *)(a4 + 112) = *(_DWORD *)(a2 + 112);
    *(_BYTE *)(a4 + 116) = *(_BYTE *)(a2 + 116);
  }
LABEL_17:
  *(_BYTE *)(a4 + 120) = v13;
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::const_iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unint64_t v19;

  *(_QWORD *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  v4 = a1 + 8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 101) = 0u;
  if (*(_BYTE *)(a2 + 32))
  {
    v7 = 0;
    v8 = *(_QWORD *)a2;
    v9 = a1 + 104;
    while (1)
    {
      *(_QWORD *)(v4 + 8 * v7) = v8;
      v10 = lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::lower_bound_index(v8, a3);
      *(_BYTE *)(v9 + v7) = v10;
      v13 = *(_QWORD *)(v4 + 8 * v7);
      v14 = *(char *)(v13 + 248);
      if ((_DWORD)v10 != (v14 & 0x7F))
        break;
LABEL_11:
      v19 = *(unsigned __int8 *)(a2 + 32);
      if ((_DWORD)v7 + 1 != (_DWORD)v19)
      {
        if (v14 < 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(v10, v11, v12);
        v8 = *(_QWORD *)(v13 + 8 * v10 + 160);
      }
      if (++v7 >= v19)
      {
        for (*(_BYTE *)(a1 + 116) = v19; (_BYTE)v19; *(_BYTE *)(a1 + 116) = v19)
        {
          if (*(_BYTE *)(v9 + v19 - 1) != (*(_BYTE *)(*(_QWORD *)(v4
                                                                                                + 8
                                                                                                * v19
                                                                                                - 8)
                                                                                    + 248) & 0x7F))
            break;
          LOBYTE(v19) = v19 - 1;
        }
        return a1;
      }
    }
    v15 = 0;
    while (1)
    {
      v16 = *(unsigned __int8 *)(v13 + 16 * v10 + v15);
      v17 = *(unsigned __int8 *)(a3 + v15);
      if (v16 < v17)
        break;
      if (v17 < v16 || v15++ == 15)
        goto LABEL_11;
    }
    *(_BYTE *)(a1 + 116) = v7 + 1;
  }
  return a1;
}

mach_vm_address_t lsl::MemoryManager::vm_allocate_bytes(lsl::MemoryManager *this, uint64_t a2)
{
  unint64_t v3;
  kern_return_t v4;
  mach_vm_address_t address;
  char v7[1024];

  v3 = (a2 + 0x3FFF) & 0xFFFFFFFFFFFFC000;
  address = 0x100000000;
  if (mach_vm_map(mach_task_self_, &address, v3, vm_page_mask, 1006632961, 0, 0, 0, 3, 7, 1u))
  {
    v4 = vm_allocate(mach_task_self_, &address, v3, 1006632961);
    if (v4)
      lsl::MemoryManager::vm_allocate_bytes(v7, v3, (uint64_t *)this, v4);
  }
  return address;
}

kern_return_t vm_protect(vm_map_t target_task, vm_address_t address, vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  kern_return_t v10;
  uint64_t reply_port;
  kern_return_t v12;
  mach_msg_header_t v15;
  uint64_t v16;
  vm_address_t v17;
  vm_size_t v18;
  BOOLean_t v19;
  vm_prot_t v20;

  v10 = _kernelrpc_mach_vm_protect_trap(target_task, address, size, set_maximum, new_protection);
  if (v10 == 268435459)
  {
    v16 = 0x100000000;
    v17 = address;
    v18 = size;
    v19 = set_maximum;
    v20 = new_protection;
    reply_port = mig_get_reply_port();
    *(_QWORD *)&v15.msgh_bits = 0x3800001513;
    *(_QWORD *)&v15.msgh_remote_port = __PAIR64__(reply_port, target_task);
    *(_QWORD *)&v15.msgh_voucher_port = 0x12C200000000;
    v12 = mach_msg2_internal(&v15, 0x200000003uLL, (void *)0x3800001513, (void *)__PAIR64__(reply_port, target_task), (void *)0x12C200000000, (void *)(reply_port << 32), (void *)0x2C, 0);
    v10 = v12;
    if ((v12 - 268435458) > 0xE || ((1 << (v12 - 2)) & 0x4003) == 0)
    {
      if (v12)
      {
        mig_dealloc_reply_port(v15.msgh_local_port);
        return v10;
      }
      if (v15.msgh_id == 71)
      {
        v10 = -308;
      }
      else if (v15.msgh_id == 4902)
      {
        v10 = -300;
        if ((v15.msgh_bits & 0x80000000) == 0 && v15.msgh_size == 36 && !v15.msgh_remote_port)
        {
          v10 = v17;
          if (!(_DWORD)v17)
            return v10;
        }
      }
      else
      {
        v10 = -301;
      }
      mach_msg_destroy(&v15);
    }
  }
  return v10;
}

uint64_t lsl::Vector<unsigned int>::reserveExact(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _DWORD *v7;
  int *v8;
  int v9;
  unint64_t v10;

  if (*(_QWORD *)(result + 24) < a2)
  {
    v3 = result;
    result = lsl::Allocator::realloc(*(lsl::Allocator **)result, *(_QWORD **)(result + 8), 4 * a2);
    if ((result & 1) != 0)
    {
LABEL_12:
      *(_QWORD *)(v3 + 24) = a2;
      return result;
    }
    result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)v3, 0x10uLL, 4 * a2);
    v4 = result;
    v5 = *(_QWORD **)(v3 + 8);
    v6 = *(_QWORD *)(v3 + 16);
    if (v6)
    {
      v7 = (_DWORD *)result;
      v8 = *(int **)(v3 + 8);
      do
      {
        v9 = *v8++;
        *v7++ = v9;
        --v6;
      }
      while (v6);
    }
    else if (!v5)
    {
      v10 = 0;
      goto LABEL_9;
    }
    result = (uint64_t)lsl::Allocator::free(*(lsl::Allocator **)v3, v5);
    v10 = *(_QWORD *)(v3 + 16);
LABEL_9:
    if (v10 >= a2)
      v10 = a2;
    *(_QWORD *)(v3 + 8) = v4;
    *(_QWORD *)(v3 + 16) = v10;
    goto LABEL_12;
  }
  return result;
}

uint64_t lsl::Vector<dyld4::Loader const*>::reserveExact(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;

  if (*(_QWORD *)(result + 24) < a2)
  {
    v3 = result;
    result = lsl::Allocator::realloc(*(lsl::Allocator **)result, *(_QWORD **)(result + 8), 8 * a2);
    if ((result & 1) == 0)
    {
      result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)v3, 0x10uLL, 8 * a2);
      v4 = result;
      v5 = *(_QWORD *)(v3 + 16);
      if (v5)
      {
        v6 = 0;
        v7 = (_QWORD *)result;
        do
          *v7++ = *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v6++);
        while (v5 != v6);
      }
      v8 = *(_QWORD **)(v3 + 8);
      if (v8)
      {
        result = (uint64_t)lsl::Allocator::free(*(lsl::Allocator **)v3, v8);
        v5 = *(_QWORD *)(v3 + 16);
      }
      if (v5 >= a2)
        v5 = a2;
      *(_QWORD *)(v3 + 8) = v4;
      *(_QWORD *)(v3 + 16) = v5;
    }
    *(_QWORD *)(v3 + 24) = a2;
  }
  return result;
}

const os_unfair_lock *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::deallocate(uint64_t a1, lsl::Allocator *a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  if ((*(char *)(a1 + 248) & 0x80000000) == 0)
  {
    v4 = (uint64_t *)(a1 + 120);
    v5 = 8 * *(unsigned __int8 *)(a1 + 248) + 8;
    do
    {
      v6 = *v4++;
      lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::deallocate(v6, a2);
      v5 -= 8;
    }
    while (v5);
  }
  return lsl::Allocator::free(a2, (_QWORD *)a1);
}

char *dyld4::Atlas::Bitmap::emit(uint64_t a1, uint64_t a2)
{
  char v5;

  lsl::emitPVLEUInt64(*(_QWORD *)a1, a2);
  return std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>((uint64_t)&v5, *(char **)(a1 + 8), (char *)(*(_QWORD *)(a1 + 8) + ((unint64_t)(*(_QWORD *)a1 + 7) >> 3)), a2);
}

_QWORD *lsl::Vector<lsl::UUID>::Vector<lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::const_iterator>(_QWORD *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  _OWORD v15[6];
  uint64_t v16;
  int v17;
  unsigned __int8 v18;

  *a1 = a4;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  v14 = *a2;
  v15[2] = *(_OWORD *)(a2 + 5);
  v15[3] = *(_OWORD *)(a2 + 7);
  v15[4] = *(_OWORD *)(a2 + 9);
  v15[5] = *(_OWORD *)(a2 + 11);
  v15[0] = *(_OWORD *)(a2 + 1);
  v15[1] = *(_OWORD *)(a2 + 3);
  v16 = a2[13];
  v17 = *((_DWORD *)a2 + 28);
  v18 = *((_BYTE *)a2 + 116);
  while (lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>((uint64_t)&v14, a3))
  {
    v6 = v18 - 1;
    v7 = *((_QWORD *)v15 + v6);
    v8 = *((unsigned __int8 *)&v16 + v6);
    lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)a1, a1[2] + 1);
    v9 = a1[1];
    v10 = a1[2];
    a1[2] = v10 + 1;
    *(_OWORD *)(v9 + 16 * v10) = *(_OWORD *)(v7 + 16 * v8);
    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator++((uint64_t)&v14, v11, v12);
  }
  return a1;
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  BOOL v11;
  unsigned int v12;

  v2 = *(unsigned __int8 *)(a2 + 116);
  v3 = *(unsigned __int8 *)(a1 + 116);
  if (v2 >= v3)
    v4 = *(unsigned __int8 *)(a1 + 116);
  else
    v4 = *(unsigned __int8 *)(a2 + 116);
  if ((_DWORD)v4)
  {
    v5 = (unsigned __int8 *)(a1 + 104);
    v6 = (unsigned __int8 *)(a2 + 104);
    while (1)
    {
      v8 = *v5++;
      v7 = v8;
      v9 = *v6++;
      v10 = v7 >= v9;
      if (v7 != v9)
        break;
      if (!--v4)
        goto LABEL_8;
    }
    if (v10)
      return 1;
    else
      return 0xFFFFFFFFLL;
  }
  else
  {
LABEL_8:
    v11 = v3 == v2;
    if (v3 < v2)
      v12 = -1;
    else
      v12 = 1;
    if (v11)
      return 0;
    else
      return v12;
  }
}

uint64_t lsl::Vector<dyld4::InterposeTupleAll>::reserve(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  if (*(_QWORD *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      v2 = 16;
    }
    return lsl::Vector<dyld4::RuntimeState::DynamicReference>::reserveExact(result, v2);
  }
  return result;
}

uint64_t lsl::Vector<dyld4::RuntimeState::DynamicReference>::reserveExact(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  _QWORD *v8;

  if (*(_QWORD *)(result + 24) < a2)
  {
    v3 = result;
    result = lsl::Allocator::realloc(*(lsl::Allocator **)result, *(_QWORD **)(result + 8), 16 * a2);
    if ((result & 1) == 0)
    {
      result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)v3, 0x10uLL, 16 * a2);
      v4 = result;
      v5 = *(_QWORD *)(v3 + 16);
      if (v5)
      {
        v6 = 0;
        for (i = 0; i < v5; ++i)
        {
          *(_OWORD *)(result + v6) = *(_OWORD *)(*(_QWORD *)(v3 + 8) + v6);
          v5 = *(_QWORD *)(v3 + 16);
          v6 += 16;
        }
      }
      v8 = *(_QWORD **)(v3 + 8);
      if (v8)
      {
        result = (uint64_t)lsl::Allocator::free(*(lsl::Allocator **)v3, v8);
        v5 = *(_QWORD *)(v3 + 16);
      }
      if (v5 >= a2)
        v5 = a2;
      *(_QWORD *)(v3 + 8) = v4;
      *(_QWORD *)(v3 + 16) = v5;
    }
    *(_QWORD *)(v3 + 24) = a2;
  }
  return result;
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::lower_bound_index(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;

  LODWORD(v2) = a1;
  v3 = *(_BYTE *)(a1 + 248) & 0x7F;
  if ((*(_BYTE *)(a1 + 248) & 0x7F) != 0)
  {
    v2 = a1;
    do
    {
      v4 = 0;
      v5 = v3 >> 1;
      v6 = v2 + 16 * (v3 >> 1);
      while (1)
      {
        v7 = *(unsigned __int8 *)(v6 + v4);
        v8 = *(unsigned __int8 *)(a2 + v4);
        if (v7 < v8)
          break;
        if (v8 < v7 || v4++ == 15)
          goto LABEL_12;
      }
      v2 = v6 + 16;
      v5 = v3 + ~v5;
LABEL_12:
      v3 = v5;
    }
    while (v5);
  }
  return ((v2 - a1) >> 4);
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  char v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;

  v3 = *(unsigned __int8 *)(result + 98);
  v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 98))
  {
    if ((_DWORD)v3 == *((unsigned __int8 *)v4 + 32))
    {
      v5 = result + 88;
      v6 = v3 - 1;
      v7 = (char *)(result + 88 + v3 - 1);
      v8 = *v7;
      if (!*(_BYTE *)(result + 88 + (v3 - 1)))
      {
        if (!*v7)
        {
          do
          {
            LODWORD(v3) = v3 - 1;
            *(_BYTE *)(result + 98) = v3;
            v6 = v3 - 1;
            v8 = *(_BYTE *)(v5 + v6);
          }
          while (!v8);
        }
        v7 = (char *)(v5 + v6);
      }
    }
    else
    {
      v16 = result + 8;
      v17 = result + 88;
      do
      {
        v18 = *(_QWORD *)(v16 + 8 * (v3 - 1));
        if (*(char *)(v18 + 248) < 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
        v19 = *(_QWORD *)(v18 + 8 * *(unsigned __int8 *)(v17 + v3 - 1) + 120);
        *(_QWORD *)(v16 + 8 * v3) = v19;
        *(_BYTE *)(v17 + v3) = *(_BYTE *)(v19 + 248) & 0x7F;
        LOBYTE(v3) = *(_BYTE *)(result + 98) + 1;
        *(_BYTE *)(result + 98) = v3;
      }
      while (*((unsigned __int8 *)v4 + 32) != v3);
      v20 = v17 + v3;
      v21 = *(_BYTE *)(v20 - 1);
      v7 = (char *)(v20 - 1);
      v8 = v21;
    }
  }
  else
  {
    v9 = *v4;
    *(_BYTE *)(result + 98) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      v10 = 0;
      v11 = result + 8;
      do
      {
        *(_QWORD *)(v11 + 8 * v10) = v9;
        *(_BYTE *)(result + 88 + v10) = *(_BYTE *)(v9 + 248) & 0x7F;
        v12 = *(unsigned __int8 *)(result + 98);
        v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          v14 = *(_QWORD *)(v11 + 8 * v12);
          if (*(char *)(v14 + 248) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
          v9 = *(_QWORD *)(v14 + 8 * *(unsigned __int8 *)(v14 + 248) + 120);
        }
        v10 = v12 + 1;
        *(_BYTE *)(result + 98) = v10;
      }
      while (v13 > v10);
      v15 = v10 - 1;
    }
    else
    {
      v15 = -1;
    }
    v7 = (char *)(result + v15 + 88);
    v8 = *v7;
  }
  *v7 = v8 - 1;
  return result;
}

__n128 lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::insert(uint64_t a1, uint64_t a2, __n128 *a3)
{
  int v3;
  int v4;
  int v5;
  __n128 *v8;
  __n128 result;

  v3 = *(char *)(a1 + 248);
  v4 = v3 & 0x7F;
  if (v3 >= 0)
    v5 = 10;
  else
    v5 = 15;
  if (v4 == v5)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(a1, a2, (uint64_t)a3);
  if (v5 == (_DWORD)a2)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(a1, a2, (uint64_t)a3);
  v8 = (__n128 *)(a1 + 16 * a2);
  if (v4 != (_DWORD)a2)
  {
    memmove((void *)(a1 + 16 * a2 + 16), (const void *)(a1 + 16 * a2), 16 * (v3 & 0x7F) - 16 * a2);
    LOBYTE(v3) = *(_BYTE *)(a1 + 248);
  }
  *(_BYTE *)(a1 + 248) = v3 + 1;
  result = *a3;
  *v8 = *a3;
  return result;
}

const os_unfair_lock *lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::deallocate(uint64_t a1, lsl::Allocator *a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  if ((*(char *)(a1 + 248) & 0x80000000) == 0)
  {
    v4 = (uint64_t *)(a1 + 160);
    v5 = 8 * *(unsigned __int8 *)(a1 + 248) + 8;
    do
    {
      v6 = *v4++;
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::deallocate(v6, a2);
      v5 -= 8;
    }
    while (v5);
  }
  return lsl::Allocator::free(a2, (_QWORD *)a1);
}

char *dyld4::FileManager::getPath@<X0>(char *this@<X0>, const UUID *a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  char *v5;
  uint64_t v7;
  int v8;
  BOOL v9;
  uint64_t v10;

  v5 = this;
  v7 = 0;
  do
  {
    v8 = (*a2)[v7];
    if ((*a2)[v7])
      v9 = 1;
    else
      v9 = v7 == 15;
    ++v7;
  }
  while (!v9);
  if (v8)
  {
    v10 = dyld4::FileManager::fsidForUUID((dyld4::FileManager *)this, a2, a3);
    return dyld4::FileManager::getPath(v5, (fsid_t)v10, a3, a4);
  }
  else
  {
    *a4 = 0;
  }
  return this;
}

char *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild(char *a1, uint64_t a2, lsl::Allocator *this)
{
  uint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char v7;
  int v8;
  int v9;
  int v10;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *result;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char v20;
  __int128 v21;
  char v22;
  uint64_t v23;
  int v24;
  char v25;
  int v26;
  char v27;
  int v28;
  int v29;
  int v30;

  if (a1[248] < 0)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)a1, a2, (uint64_t)this);
  v3 = a1[248];
  if (v3 >= 0xF)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)a1, a2, (uint64_t)this);
  v4 = a1;
  v5 = a1 + 120;
  v6 = (uint64_t)&a1[8 * a2 + 120];
  v7 = *(_BYTE *)(*(_QWORD *)v6 + 248);
  v8 = v7;
  v9 = v7 & 0x7F;
  if (v7 >= 0)
    v10 = 15;
  else
    v10 = 31;
  if (v9 != v10)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)a1, a2, (uint64_t)this);
  v12 = a2;
  if (v8 >= 0)
    v13 = 7;
  else
    v13 = 15;
  v14 = &a1[8 * a2];
  if ((_DWORD)v3 != (_DWORD)a2)
  {
    a1 = (char *)memmove(&a1[8 * a2 + 8], &a1[8 * a2], 8 * v3 - 8 * a2);
    a2 = v4[248];
  }
  if ((a2 & 0x80) != 0)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)a1, a2, (uint64_t)this);
  v15 = &v5[8 * a2];
  if (v15 != (char *)v6)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), (size_t)&v15[-v6]);
    LOBYTE(a2) = v4[248];
  }
  v4[248] = a2 + 1;
  *(_QWORD *)v14 = *(_QWORD *)(*(_QWORD *)v6 + 8 * v13);
  result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  v19 = result;
  v20 = *(_BYTE *)(*(_QWORD *)v6 + 248);
  result[248] = v20 & 0x80;
  if (v20 < 0)
  {
    *((_QWORD *)result + 30) = 0;
    v21 = 0uLL;
    *((_OWORD *)result + 13) = 0u;
    *((_OWORD *)result + 14) = 0u;
    *((_OWORD *)result + 11) = 0u;
    *((_OWORD *)result + 12) = 0u;
    *((_OWORD *)result + 9) = 0u;
    *((_OWORD *)result + 10) = 0u;
    *((_OWORD *)result + 7) = 0u;
    *((_OWORD *)result + 8) = 0u;
  }
  else
  {
    *((_QWORD *)result + 14) = 0;
    v21 = 0uLL;
  }
  *((_OWORD *)result + 5) = v21;
  *((_OWORD *)result + 6) = v21;
  *((_OWORD *)result + 3) = v21;
  *((_OWORD *)result + 4) = v21;
  *((_OWORD *)result + 1) = v21;
  *((_OWORD *)result + 2) = v21;
  *(_OWORD *)result = v21;
  if (v4[248] < 0)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v17, v18);
  v22 = v9 + ~(_BYTE)v13;
  *(_QWORD *)&v5[8 * v12 + 8] = result;
  if (v22)
    result = (char *)memmove(result, (const void *)(*(_QWORD *)v6 + 8 * v13 + 8), 8 * (v9 + ~(_BYTE)v13));
  v23 = *(_QWORD *)v6;
  v24 = *(char *)(*(_QWORD *)v6 + 248);
  if ((v24 & 0x80000000) == 0)
  {
    if (v19[248] < 0)
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v17, v18);
    result = (char *)memmove(v19 + 120, (const void *)(v23 + 8 * v13 + 128), 8 * (v9 + ~(_BYTE)v13) + 8);
    v23 = *(_QWORD *)v6;
    LOBYTE(v24) = *(_BYTE *)(*(_QWORD *)v6 + 248);
  }
  *(_BYTE *)(v23 + 248) = v24 + ~v22;
  v25 = v19[248] + v22;
  v19[248] = v25;
  if (v25 >= 0)
    v26 = 15;
  else
    v26 = 31;
  if ((v25 & 0x7F) == v26
    || ((v27 = *(_BYTE *)(v23 + 248), v28 = v27, v29 = v27 & 0x7F, v28 >= 0) ? (v30 = 15) : (v30 = 31), v29 == v30))
  {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)result, v17, v18);
  }
  return result;
}

uint64_t dyld4::APIs::_dyld_image_count(dyld4::APIs *this)
{
  uint64_t v1;

  v1 = *((unsigned int *)this + 12);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_image_count() => %d\n", *((_DWORD *)this + 12));
  return v1;
}

_QWORD *dyld4::ExternallyViewableState::init(uint64_t *a1, lsl::Allocator *a2, lsl::Allocator *this, dyld4::FileManager *a4, unsigned int a5)
{
  dyld4::Atlas::ProcessSnapshot *v10;
  void *v11;
  const os_unfair_lock *v13;

  a1[1] = (uint64_t)a4;
  v10 = (dyld4::Atlas::ProcessSnapshot *)lsl::Allocator::aligned_alloc(this, 8uLL, 0x70uLL);
  v13 = 0;
  *a1 = dyld4::Atlas::ProcessSnapshot::ProcessSnapshot(v10, this, a4, 1);
  lsl::UniquePtr<dyld4::Atlas::ProcessSnapshot>::~UniquePtr(&v13, v11);
  dyld4::Atlas::ProcessSnapshot::setDyldState(*a1, 16);
  dyld4::Atlas::ProcessSnapshot::setPlatform(*a1, a5);
  return dyld4::ExternallyViewableState::initOld(a1, a2, a5);
}

const os_unfair_lock **dyld4::Atlas::ProcessSnapshot::addImage(lsl::Allocator **a1, dyld4::Atlas::Image *a2)
{
  uint64_t v2;
  const os_unfair_lock *v4;
  _BYTE v5[112];

  v2 = (uint64_t)(a1 + 2);
  lsl::Allocator::makeUnique<dyld4::Atlas::Image,dyld4::Atlas::Image>(*a1, a2, &v4);
  lsl::OrderedSet<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>>::insert(v2, (uint64_t *)&v4, (uint64_t)v5);
  return lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(&v4);
}

void dyld4::recordFromInfo(lsl::Allocator *a1@<X0>, dyld4::FileManager *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  _BYTE v13[80];
  _OWORD v14[4];
  uint64_t v15;
  __int16 v16;
  char v17;

  memset(v14, 0, sizeof(v14));
  v15 = 0x1FFFFFFFFLL;
  v16 = 0;
  v17 = 1;
  v8 = *(_QWORD *)a3;
  if (!*(_QWORD *)a3 || (v9 = *(_QWORD *)(a3 + 8)) == 0)
  {
LABEL_9:
    dyld4::FileManager::fileRecordForPath(a2, a1, *(const char **)(a3 + 16), a4);
    goto LABEL_10;
  }
  dyld4::FileManager::fileRecordForVolumeDevIDAndObjID(a2, v8, v9, (dyld4::FileRecord *)v13);
  dyld4::FileRecord::operator=((dyld4::FileRecord *)v14, (dyld4::FileRecord *)v13);
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v13);
  v10 = (_BYTE *)dyld4::FileRecord::volume((dyld4::FileRecord *)v14);
  if (!*v10)
  {
    v11 = 1;
    while (v11 != 16)
    {
      if (v10[v11++])
      {
        if ((unint64_t)(v11 - 2) <= 0xE)
          goto LABEL_4;
        goto LABEL_9;
      }
    }
    goto LABEL_9;
  }
LABEL_4:
  dyld4::FileRecord::FileRecord(a4, (dyld4::FileRecord *)v14);
LABEL_10:
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v14);
}

uint64_t dyld4::Atlas::Bitmap::Bitmap(uint64_t a1, lsl::Allocator *a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  void *v10;
  _QWORD *v11;
  const os_unfair_lock *v12;
  unint64_t v13;
  const os_unfair_lock *v14;
  uint64_t __dst;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  __dst = 0;
  if ((lsl::readPVLEUInt64((uint64_t *)a3, &__dst) & 1) != 0)
  {
    v7 = __dst;
    *(_QWORD *)a1 = __dst;
    v8 = v7 + 7;
    v9 = (unint64_t)(v7 + 7) >> 3;
    v11 = lsl::Allocator::malloc(a2, v9);
    v12 = *(const os_unfair_lock **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v11;
    if (v12)
      lsl::Allocator::freeObject(v12, v10);
    if (v8 >= 8)
      memmove(*(void **)(a1 + 8), *(const void **)a3, v9);
    v13 = *(_QWORD *)(a3 + 8) - v9;
    *(_QWORD *)a3 += v9;
    *(_QWORD *)(a3 + 8) = v13;
  }
  else
  {
    v14 = *(const os_unfair_lock **)(a1 + 8);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    if (v14)
      lsl::Allocator::freeObject(v14, v6);
  }
  return a1;
}

void dyld4::ExternallyViewableState::addImages(uint64_t a1, lsl::Allocator *a2, lsl::Allocator *a3, uint64_t *a4)
{
  lsl::Allocator *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  const mach_header *v12;
  const mach_header *v13;
  uint64_t v14;
  const mach_header **v15;
  unsigned int **v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char **v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  _QWORD *v42;
  uint64_t v43;
  const mach_header **v44;
  uint64_t v45;
  const mach_header **v46;
  uint64_t v47;
  const mach_header *v48;
  uint64_t v49;
  os_unfair_lock_t v50;
  lsl::Allocator *v51;
  uint64_t *v52;
  lsl::Allocator *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  os_unfair_lock *v59;
  dyld4::Atlas::Mapper *v60;
  uint64_t v61;
  void *v62;
  char v63;
  _BYTE v64[80];

  v51 = a2;
  v53 = a3;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v50 = (os_unfair_lock_t)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  dyld4::ExternallyViewableState::ensureSnapshot((uint64_t *)a1, a3);
  v52 = a4;
  v8 = a4[1];
  if (v8)
  {
    v9 = *v52;
    v10 = 40 * v8;
    do
    {
      v11 = *(unsigned __int8 *)(v9 + 32);
      v12 = *(const mach_header **)(v9 + 16);
      v13 = *(const mach_header **)(v9 + 24);
      lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)&v53, v55 + 1);
      v14 = v55++;
      v15 = (const mach_header **)(v54 + 24 * v14);
      *v15 = v13;
      v15[1] = v12;
      v15[2] = 0;
      if (v11)
      {
        if (*(_QWORD *)dyld4::Atlas::ProcessSnapshot::sharedCache(*(dyld4::Atlas::ProcessSnapshot **)a1))
          dyld4::Atlas::ProcessSnapshot::addSharedCacheImage(*(_QWORD *)a1, v13);
      }
      else
      {
        dyld4::ExternallyViewableState::addImageUUID((dyld4::ExternallyViewableState *)a1, (const dyld3::MachOFile *)v13);
        dyld4::recordFromInfo(a3, *(dyld4::FileManager **)(a1 + 8), v9, (uint64_t)v64);
        v16 = (unsigned int **)dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
        dyld4::Atlas::Image::Image((uint64_t)&v57, (uint64_t)a3, (dyld4::FileRecord *)v64, v16, (uint64_t)v13);
        dyld4::Atlas::ProcessSnapshot::addImage(*(lsl::Allocator ***)a1, (dyld4::Atlas::Image *)&v57);
        v17 = v62;
        if (v62 && v63)
          dyld4::Atlas::Mapper::unmap(v60, (unint64_t)v62, v61);
        if (v59)
          lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v59, v17);
        dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v58);
        dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v64);
      }
      v9 += 40;
      v10 -= 40;
    }
    while (v10);
  }
  dyld4::ExternallyViewableState::commit((const os_unfair_lock *)a1, *(dyld4::Atlas::ProcessSnapshot **)a1, v51, v7);
  dyld4::ExternallyViewableState::release((const os_unfair_lock *)a1, a3);
  v18 = mach_absolute_time();
  v19 = dyld4::ExternallyViewableState::addImagesOld(a1, (uint64_t)&v53, v18);
  if (*(_DWORD *)(*(_QWORD *)(a1 + 24) + 200) == 1229016646)
  {
    __chkstk_darwin(v19, v20, v21, v22, v23, v24, v25, v26, v49);
    __chkstk_darwin(v29, v30, *(_QWORD *)(v28 + 8), v31, (uint64_t)&v49 - ((v27 + 23) & 0xFFFFFFFFFFFFFFF0), v32, v33, v34, v49);
    v44 = (const mach_header **)((char *)&v49 - ((v43 + 23) & 0xFFFFFFFFFFFFFFF0));
    if (!v37)
      dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>();
    v45 = 0;
    v46 = (const mach_header **)(*v42 + 24);
    v47 = 40 * v37;
    do
    {
      if (v37 == v45)
        dyld4::RuntimeState::appendInterposingTuples(v35, v36, v37);
      v38[v45] = (const char *)*(v46 - 1);
      v48 = *v46;
      v46 += 5;
      v44[v45++] = v48;
      v47 -= 40;
    }
    while (v47);
    dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges((dyld4::ExternallyViewableState *)a1, 0, v37, v44, v38, v39, v40, v41);
  }
  os_unfair_lock_unlock(v50);
  if (v54)
    lsl::Vector<dyld_image_info>::resize((const os_unfair_lock *)&v53, 0);
}

uint64_t dyld4::Atlas::ProcessSnapshot::addSharedCacheImage(uint64_t this, const mach_header *a2)
{
  char *v2;
  uint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;

  v2 = *(char **)(*(_QWORD *)(this + 64) + 160);
  v3 = *((_QWORD *)v2 + 18);
  v4 = &v2[*((_QWORD *)v2 + 17)];
  if (v3)
  {
    v5 = (char *)((char *)a2 - v2 + *((_QWORD *)v2 + 28));
    v6 = 32 * v3;
    v7 = &v2[*((_QWORD *)v2 + 17)];
    while (*((char **)v7 + 2) != v5)
    {
      v7 += 32;
      v6 -= 32;
      if (!v6)
        goto LABEL_5;
    }
  }
  else
  {
    v7 = &v2[*((_QWORD *)v2 + 17)];
  }
  if (v7 == &v4[32 * v3])
LABEL_5:
    dyld4::Atlas::ProcessSnapshot::addSharedCacheImage();
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(this + 56) + 8) + ((unint64_t)((v7 - v4) >> 5) >> 3)) |= 1 << (((v7 - v4) >> 5) & 7);
  return this;
}

uint64_t lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  if (*(_QWORD *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      v2 = 16;
    }
    return lsl::Vector<dyld4::RuntimeState::MissingFlatSymbol>::reserveExact(result, v2);
  }
  return result;
}

uint64_t dyld4::Atlas::ProcessSnapshot::sharedCache(dyld4::Atlas::ProcessSnapshot *this)
{
  return (uint64_t)this + 64;
}

uint64_t lsl::Vector<dyld4::RuntimeState::MissingFlatSymbol>::reserveExact(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;
  __int128 *v9;
  __int128 v10;
  _QWORD *v11;

  if (*(_QWORD *)(result + 24) < a2)
  {
    v3 = result;
    result = lsl::Allocator::realloc(*(lsl::Allocator **)result, *(_QWORD **)(result + 8), 24 * a2);
    if ((result & 1) == 0)
    {
      result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)v3, 0x10uLL, 24 * a2);
      v4 = result;
      v5 = *(_QWORD *)(v3 + 16);
      if (v5)
      {
        v6 = 0;
        for (i = 0; i < v5; ++i)
        {
          v8 = result + v6;
          v9 = (__int128 *)(*(_QWORD *)(v3 + 8) + v6);
          v10 = *v9;
          *(_QWORD *)(v8 + 16) = *((_QWORD *)v9 + 2);
          *(_OWORD *)v8 = v10;
          v5 = *(_QWORD *)(v3 + 16);
          v6 += 24;
        }
      }
      v11 = *(_QWORD **)(v3 + 8);
      if (v11)
      {
        result = (uint64_t)lsl::Allocator::free(*(lsl::Allocator **)v3, v11);
        v5 = *(_QWORD *)(v3 + 16);
      }
      if (v5 >= a2)
        v5 = a2;
      *(_QWORD *)(v3 + 8) = v4;
      *(_QWORD *)(v3 + 16) = v5;
    }
    *(_QWORD *)(v3 + 24) = a2;
  }
  return result;
}

const os_unfair_lock *dyld4::ExternallyViewableState::commit(const os_unfair_lock *this, dyld4::Atlas::ProcessSnapshot *a2, lsl::Allocator *a3, lsl::Allocator *a4)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned __int128 *v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  unint64_t v17;
  unint64_t v18;
  unsigned __int128 *v19;
  _BYTE v20[56];
  int v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  lsl::Allocator *v29;
  const void *v30;
  unint64_t v31;

  if (!a2)
    return this;
  v5 = (uint64_t)this;
  dyld4::Atlas::ProcessSnapshot::serialize(a2, &v29);
  v7 = (unint64_t)v30;
  v6 = v31;
  v8 = (unsigned __int128 *)(*(_QWORD *)(v5 + 24) + 304);
  v9 = *(_QWORD **)v8;
  do
    __ldxp(v8);
  while (__stxp(__PAIR128__(v6, v7), v8));
  if (!v9)
    goto LABEL_10;
  if ((lsl::Allocator::owned(a3, (unint64_t)v9, 8) & 1) == 0)
  {
LABEL_9:
    v6 = v31;
LABEL_10:
    v9 = lsl::Allocator::malloc(a3, v6);
    goto LABEL_11;
  }
  v10 = lsl::Allocator::size(a3, v9);
  v17 = v31;
  if (v10 < v31)
  {
    if (lsl::Allocator::realloc(a3, v9, v31))
    {
LABEL_11:
      v17 = v31;
      goto LABEL_12;
    }
    lsl::Allocator::free(a3, v9);
    goto LABEL_9;
  }
LABEL_12:
  if (v17)
  {
    memmove(v9, v30, v17);
    v18 = v31;
  }
  else
  {
    v18 = 0;
  }
  v19 = (unsigned __int128 *)(*(_QWORD *)(v5 + 24) + 304);
  do
    __ldxp(v19);
  while (__stxp(__PAIR128__(v18, (unint64_t)v9), v19));
  v21 = 520552496;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v21, v11, v17, v12, v13, v14, v15, v16);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v20, *(_DWORD *)(*(_QWORD *)(v5 + 24) + 200));
  dyld4::RemoteNotificationResponder::blockOnSynchronousEvent((dyld4::RemoteNotificationResponder *)v20, 0);
  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v20);
  this = (const os_unfair_lock *)dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v21);
  if (v30)
    return lsl::Vector<std::byte>::resize((const os_unfair_lock *)&v29, 0);
  return this;
}

_QWORD *lsl::Allocator::malloc(lsl::Allocator *this, unint64_t a2)
{
  return lsl::Allocator::aligned_alloc(this, 0x10uLL, a2);
}

void dyld4::RemoteNotificationResponder::~RemoteNotificationResponder(dyld4::RemoteNotificationResponder *this)
{
  unint64_t v2;
  vm_size_t v3;

  if (*((_DWORD *)this + 10))
  {
    v2 = 0;
    do
      mach_port_deallocate(mach_task_self_, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v2++));
    while (v2 < *((unsigned int *)this + 10));
    v3 = *((_QWORD *)this + 6);
    if (v3)
      vm_deallocate(mach_task_self_, *((_QWORD *)this + 4), v3);
  }
}

mach_port_name_array_t dyld4::RemoteNotificationResponder::RemoteNotificationResponder(mach_port_name_array_t names_addr, int a2)
{
  natural_t *v3;
  mach_port_name_array_t *v4;
  kern_return_t v5;
  mach_port_name_t v6;
  vm_size_t v7;

  *(_OWORD *)names_addr = 0u;
  *((_OWORD *)names_addr + 1) = 0u;
  *((_QWORD *)names_addr + 4) = names_addr;
  names_addr[10] = 8;
  v3 = names_addr + 10;
  *((_QWORD *)names_addr + 6) = 0;
  if (a2 != 1229016646)
    goto LABEL_10;
  v4 = (mach_port_name_array_t *)(names_addr + 8);
  v5 = task_dyld_process_info_notify_get(names_addr, names_addr + 10);
  while (v5 == 3)
  {
    v6 = 2 * names_addr[10];
    if (v6 <= 0x10)
      v6 = 16;
    names_addr[10] = v6;
    v7 = 4 * v6;
    *((_QWORD *)names_addr + 6) = v7;
    if (vm_allocate(mach_task_self_, (vm_address_t *)names_addr + 4, v7, 1))
      goto LABEL_10;
    v5 = task_dyld_process_info_notify_get(*v4, v3);
    if (v5)
    {
      vm_deallocate(mach_task_self_, *((_QWORD *)names_addr + 4), *((_QWORD *)names_addr + 6));
      *((_QWORD *)names_addr + 6) = 0;
    }
  }
  if (v5)
LABEL_10:
    *v3 = 0;
  return names_addr;
}

uint64_t dyld4::RemoteNotificationResponder::blockOnSynchronousEvent(dyld4::RemoteNotificationResponder *this, int a2)
{
  mach_msg_header_t v3;

  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, a2 + 0x4000, 0x18u, &v3);
}

uint64_t dyld4::RemoteNotificationResponder::sendMessage(uint64_t this, mach_msg_id_t a2, mach_msg_size_t a3, mach_msg_header_t *a4)
{
  uint64_t v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  mach_port_name_t v11;
  mach_port_t v12;
  mach_port_options_t options;
  mach_port_name_t name;
  mach_msg_header_t rcv_msg;

  if (*(_DWORD *)(this + 40))
  {
    v7 = this;
    name = 0;
    *(_OWORD *)&options.flags = xmmword_1A5CBB860;
    options.reserved[1] = 0;
    this = mach_port_construct(mach_task_self_, &options, (mach_port_context_t)&name, &name);
    if (!(_DWORD)this)
    {
      v8 = *(unsigned int *)(v7 + 40);
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(v7 + 32);
          if (*(_DWORD *)(v10 + 4 * i))
          {
            a4->msgh_bits = 5395;
            a4->msgh_id = a2;
            v11 = name;
            a4->msgh_local_port = name;
            v12 = *(_DWORD *)(v10 + 4 * i);
            a4->msgh_voucher_port = 0;
            a4->msgh_size = a3;
            a4->msgh_remote_port = v12;
            if (mach_msg_overwrite(a4, 3, a3, 0x5Cu, v11, 0, 0, &rcv_msg, 0))
            {
              mach_msg_destroy(a4);
              *(_DWORD *)(*(_QWORD *)(v7 + 32) + 4 * i) = 0;
            }
            v8 = *(unsigned int *)(v7 + 40);
          }
        }
      }
      return mach_port_destruct(mach_task_self_, name, 0, (mach_port_context_t)&name);
    }
  }
  return this;
}

uint64_t *dyld4::ExternallyViewableState::ensureSnapshot(uint64_t *this, lsl::Allocator *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  void *v9;
  const os_unfair_lock *v10;

  if (!*this)
  {
    v3 = this;
    v4 = this[3];
    v5 = *(_QWORD *)(v4 + 304);
    v6 = *(_QWORD *)(v4 + 312);
    v7 = this[1];
    v8 = lsl::Allocator::aligned_alloc(a2, 8uLL, 0x70uLL);
    v10 = 0;
    *v3 = dyld4::Atlas::ProcessSnapshot::ProcessSnapshot(v8, a2, v7, 1, v5, v6);
    lsl::UniquePtr<dyld4::Atlas::ProcessSnapshot>::~UniquePtr(&v10, v9);
    return (uint64_t *)dyld4::Atlas::ProcessSnapshot::setDyldState(*v3, 80);
  }
  return this;
}

const os_unfair_lock *lsl::Vector<dyld_image_info>::resize(const os_unfair_lock *result, unint64_t a2)
{
  _QWORD *v2;
  const os_unfair_lock *v3;

  if (*(_QWORD *)&result[6]._os_unfair_lock_opaque < a2)
    return (const os_unfair_lock *)lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)result, a2);
  if (a2)
  {
    *(_QWORD *)&result[4]._os_unfair_lock_opaque = a2;
    *(_QWORD *)&result[6]._os_unfair_lock_opaque = a2;
    return (const os_unfair_lock *)lsl::Allocator::realloc(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, *(_QWORD **)&result[2]._os_unfair_lock_opaque, 24 * a2);
  }
  else
  {
    v3 = result + 2;
    v2 = *(_QWORD **)&result[2]._os_unfair_lock_opaque;
    if (v2)
      result = lsl::Allocator::free(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, v2);
    *(_QWORD *)&v3->_os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[2]._os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[4]._os_unfair_lock_opaque = 0;
  }
  return result;
}

uint64_t dyld4::Atlas::ProcessSnapshot::setDyldState(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 96) = a2;
  return this;
}

const os_unfair_lock **lsl::UniquePtr<dyld4::Atlas::ProcessSnapshot>::~UniquePtr(const os_unfair_lock **a1, void *a2)
{
  const os_unfair_lock *v3;
  os_unfair_lock *v4;
  void *v5;
  void *v6;
  uint64_t v7;

  v3 = *a1;
  if (*a1)
  {
    v4 = *(os_unfair_lock **)&v3[18]._os_unfair_lock_opaque;
    if (v4)
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v4, a2);
    lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr((const os_unfair_lock **)&v3[16], a2);
    lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v3[14], v5);
    v7 = *(_QWORD *)&v3[4]._os_unfair_lock_opaque;
    if (v7)
    {
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate(v7, *(lsl::Allocator **)&v3[6]._os_unfair_lock_opaque);
      *(_QWORD *)&v3[4]._os_unfair_lock_opaque = 0;
    }
    *(_QWORD *)&v3[10]._os_unfair_lock_opaque = 0;
    LOBYTE(v3[12]._os_unfair_lock_opaque) = 0;
    lsl::Allocator::freeObject(*a1, v6);
  }
  return a1;
}

uint64_t lldb_image_notifier(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t *v8;
  unsigned int v9;
  void *started;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v25;
  int v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  v8 = (uint64_t *)a3;
  v9 = a2;
  v26 = 520552492;
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0;
  started = dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v26, a2, a3, a4, a5, a6, a7, a8);
  __chkstk_darwin((uint64_t)started, v9, v12, v13, v14, v15, v16, v17, v25);
  v20 = (char *)&v25 - v19;
  if (v9)
  {
    v21 = v18;
    v22 = v20;
    do
    {
      v23 = *v8;
      v8 += 3;
      *v22++ = v23;
      --v21;
    }
    while (v21);
  }
  if (a1 <= 3 && (_DWORD)a1 != 2)
    _dyld_debugger_notification(a1);
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v26);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  uint64_t v1;
  void *v2;
  void *v3;
  void *v4;
  unsigned int v5;

  v5 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (!__ldaxr(&lock->_os_unfair_lock_opaque))
  {
    if (!__stxr(v5, &lock->_os_unfair_lock_opaque))
      return;
  }
  __clrex();
  _os_unfair_lock_lock_slow(&lock->_os_unfair_lock_opaque, 0, 0, v5, v1, v2, v3, v4);
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::deserialize(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t i;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  os_unfair_lock *v23;
  unsigned int v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  void *v28;
  void *v29;
  char v30;
  lsl::Allocator *v31;
  unsigned int v32;
  lsl::Allocator *v33;
  void *v34;
  lsl::Allocator **v35;
  lsl::Allocator *v36;
  lsl::Allocator *v37;
  _QWORD *v38;
  lsl::Allocator *v39;
  void *v40;
  lsl::Allocator **v41;
  lsl::Allocator *v42;
  _BOOL4 v43;
  dyld4::FileRecord *v44;
  const os_unfair_lock *v45;
  uint64_t v46;
  lsl::Allocator *v47;
  unint64_t v48;
  unint64_t __dst;
  unsigned int v50[4];
  char *v51;
  unint64_t v52;
  _OWORD v53[7];
  _OWORD v54[4];
  uint64_t v55;
  __int16 v56;
  char v57;
  os_unfair_lock *v58;
  __int128 v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char v63;
  char v64;
  char v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD v68[2];
  char *v69[9];
  __int16 v70;
  char v71;
  __int128 v72;

  v3 = a3 - 36;
  if (a3 < 0x24)
    return 0;
  v4 = 0;
  v8 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 176) = *(_DWORD *)a2;
  v9 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 180) = v9;
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 208) = *(_DWORD *)(a2 + 20);
  *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 24);
  v10 = *(_DWORD *)(a2 + 32);
  v11 = a2 + 36;
  v51 = (char *)(a2 + 36);
  v52 = a3 - 36;
  *(_DWORD *)(a1 + 212) = v10;
  if (v8 == -1491447450 && !v9)
  {
    lsl::CRC32c::CRC32c((uint64_t)v50);
    lsl::CRC32c::operator()(v50, a2, 32);
    lsl::CRC32c::operator()(v50, 0);
    lsl::CRC32c::operator()(v50, v11, v3);
    v12 = *(_DWORD *)(a1 + 212);
    v4 = 0;
    if (v12 == lsl::CRC32c::operator unsigned int((uint64_t)v50))
    {
      __dst = 0;
      if (!lsl::readPVLEUInt64((uint64_t *)&v51, (uint64_t *)(a1 + 216)))
        return 0;
      if (!lsl::readPVLEUInt64((uint64_t *)&v51, *(uint64_t **)(a1 + 224)))
        return 0;
      if (!lsl::readPVLEUInt64((uint64_t *)&v51, *(uint64_t **)(a1 + 232)))
        return 0;
      if (!lsl::readPVLEUInt64((uint64_t *)&v51, *(uint64_t **)(a1 + 240)))
        return 0;
      if (!lsl::readPVLEUInt64((uint64_t *)&v51, (uint64_t *)&__dst))
        return 0;
      v13 = v52;
      v14 = __dst;
      if (v52 < 16 * __dst)
        return 0;
      if (__dst)
      {
        v15 = 0;
        for (i = 0; i < __dst; ++i)
        {
          v54[0] = *(_OWORD *)&v51[v15];
          lsl::Vector<dyld4::InterposeTupleAll>::reserve(a1 + 48, *(_QWORD *)(a1 + 64) + 1);
          v17 = *(_QWORD *)(a1 + 56);
          v18 = *(_QWORD *)(a1 + 64);
          *(_QWORD *)(a1 + 64) = v18 + 1;
          *(_OWORD *)(v17 + 16 * v18) = v54[0];
          v15 += 16;
        }
        v13 = v52;
        v14 = 16 * __dst;
      }
      v19 = v13 - v14;
      v51 = &v51[v13 - v19];
      v52 = v19;
      v48 = 0;
      if ((lsl::readPVLEUInt64((uint64_t *)&v51, (uint64_t *)&v48) & 1) == 0 || v52 < v48)
        return 0;
      lsl::Vector<std::byte>::reserve(a1 + 112, v48);
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<unsigned char *,unsigned char *,std::back_insert_iterator<lsl::Vector<char>>>((uint64_t)v54, v51, &v51[v48], a1 + 112);
      v51 += v48;
      v52 -= v48;
      if ((*(_BYTE *)(a1 + 216) & 1) == 0)
      {
LABEL_20:
        v47 = 0;
        if (!lsl::readPVLEUInt64((uint64_t *)&v51, (uint64_t *)&v47))
          return 0;
        v4 = 1;
        if (!v47)
          return v4;
        v20 = 0;
        v21 = 0;
        while (1)
        {
          v46 = 0;
          v72 = 0uLL;
          memset(v69, 0, 64);
          v69[8] = (char *)0x1FFFFFFFFLL;
          v70 = 0;
          v71 = 1;
          if (!dyld4::Atlas::ProcessSnapshot::Serializer::readMappedFileInfo(a1, (uint64_t *)&v51, &v46, &v72, (dyld4::FileRecord *)v69))break;
          v22 = 14;
          if ((*(_QWORD *)(a1 + 216) & 4) == 0)
            v22 = 12;
          v21 += v46 << v22;
          v46 = v21;
          if (*(_BYTE *)(*(_QWORD *)a1 + 104))
          {
            v23 = *(os_unfair_lock **)(*(_QWORD *)a1 + 72);
            if (v23)
            {
              do
                v24 = __ldxr(&v23->_os_unfair_lock_opaque);
              while (__stxr(v24 + 1, &v23->_os_unfair_lock_opaque));
            }
          }
          else
          {
            lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&>(*(lsl::Allocator **)(a1 + 8), *(_QWORD *)(a1 + 8), v54);
            v23 = *(os_unfair_lock **)&v54[0];
          }
          v25 = v46;
          *(_QWORD *)&v54[0] = *(_QWORD *)(a1 + 8);
          dyld4::FileRecord::FileRecord((uint64_t)v54 + 8, (dyld4::FileRecord *)v69);
          v58 = v23;
          if (v23)
          {
            do
              v26 = __ldxr(&v23->_os_unfair_lock_opaque);
            while (__stxr(v26 + 1, &v23->_os_unfair_lock_opaque));
          }
          v59 = v72;
          v61 = 0;
          v62 = 0;
          v60 = 0;
          v63 = 0;
          v64 = 0;
          v65 = 0;
          v66 = v25;
          v67 = 0;
          v68[0] = 0;
          *(_DWORD *)((char *)v68 + 7) = 0;
          v27 = *(_QWORD *)(a1 + 24);
          lsl::Allocator::makeUnique<dyld4::Atlas::Image,dyld4::Atlas::Image>(*(lsl::Allocator **)(a1 + 8), (dyld4::Atlas::Image *)v54, &v45);
          lsl::OrderedSet<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>>::insert(v27, (uint64_t *)&v45, (uint64_t)v53);
          lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(&v45);
          dyld4::Atlas::Image::~Image((dyld4::Atlas::Image *)v54);
          if (v23)
            lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v23, v28);
          dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v69);
          if ((unint64_t)v47 <= ++v20)
            return 1;
        }
        v44 = (dyld4::FileRecord *)v69;
LABEL_55:
        dyld4::FileRecord::~FileRecord(v44);
        return 0;
      }
      v69[0] = 0;
      v53[0] = 0uLL;
      memset(v54, 0, sizeof(v54));
      v55 = 0x1FFFFFFFFLL;
      v56 = 0;
      v57 = 1;
      if ((dyld4::Atlas::ProcessSnapshot::Serializer::readMappedFileInfo(a1, (uint64_t *)&v51, (uint64_t *)v69, v53, (dyld4::FileRecord *)v54) & 1) == 0)goto LABEL_53;
      v30 = 14;
      if ((*(_QWORD *)(a1 + 216) & 4) == 0)
        v30 = 12;
      v69[0] = (char *)((uint64_t)v69[0] << v30);
      if (*(_BYTE *)(*(_QWORD *)a1 + 104))
      {
        v31 = *(lsl::Allocator **)(*(_QWORD *)a1 + 72);
        if (v31)
        {
          do
            v32 = __ldxr((unsigned int *)v31);
          while (__stxr(v32 + 1, (unsigned int *)v31));
        }
      }
      else
      {
        lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&>(*(lsl::Allocator **)(a1 + 8), *(_QWORD *)(a1 + 8), &v47);
        v31 = v47;
      }
      *(_QWORD *)&v72 = v31;
      if (!v31)
      {
LABEL_53:
        v44 = (dyld4::FileRecord *)v54;
        goto LABEL_55;
      }
      if (*((_QWORD *)v31 + 1))
      {
        v33 = *(lsl::Allocator **)(a1 + 8);
        v46 = *(_QWORD *)(a1 + 216) & 2;
        lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,lsl::Allocator&,dyld4::FileRecord,lsl::SharedPtr<dyld4::Atlas::Mapper> &,unsigned long long &,unsigned long long>(v33, (uint64_t)v33, (dyld4::FileRecord *)v54, (unsigned int **)&v72, v69, &v46, (uint64_t *)&v47);
        v35 = *(lsl::Allocator ***)(a1 + 32);
        if (&v47 != v35)
        {
          v36 = *v35;
          *v35 = v47;
          v47 = v36;
        }
        lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr((const os_unfair_lock **)&v47, v34);
        v37 = *(lsl::Allocator **)(a1 + 8);
        v38 = lsl::Allocator::aligned_alloc(v37, 8uLL, 0x10uLL);
        v39 = (lsl::Allocator *)dyld4::Atlas::Bitmap::Bitmap((uint64_t)v38, v37, (uint64_t)&v51);
        v47 = v39;
        v41 = *(lsl::Allocator ***)(a1 + 40);
        if (&v47 != v41)
        {
          v42 = *v41;
          *v41 = v39;
          v47 = v42;
        }
        lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v47, v40);
        v43 = ***(_QWORD ***)(a1 + 40) == 0;
        v31 = (lsl::Allocator *)v72;
        if (!(_QWORD)v72)
        {
LABEL_58:
          dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v54);
          if (v43)
            return 0;
          goto LABEL_20;
        }
      }
      else
      {
        v43 = 1;
      }
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock *)v31, v29);
      goto LABEL_58;
    }
  }
  return v4;
}

__n128 dyld4::FileRecord::swap(dyld4::FileRecord *this, dyld4::FileRecord *a2)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const os_unfair_lock *v8;
  uint64_t v9;
  __n128 result;
  __int128 v11;

  v4 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)a2 + 24) = v4;
  v5 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  *((_QWORD *)a2 + 1) = v5;
  v6 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  *((_QWORD *)a2 + 2) = v6;
  v7 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  v8 = (const os_unfair_lock *)*((_QWORD *)a2 + 5);
  if (a2 == this)
  {
    *((_QWORD *)a2 + 5) = v7;
    if (v8)
      lsl::Allocator::freeObject(v8, a2);
  }
  else
  {
    *((_QWORD *)this + 5) = v8;
    *((_QWORD *)a2 + 5) = v7;
  }
  v9 = *(_QWORD *)this;
  *(_QWORD *)this = *(_QWORD *)a2;
  *(_QWORD *)a2 = v9;
  result = *((__n128 *)a2 + 3);
  v11 = *((_OWORD *)this + 3);
  *((__n128 *)this + 3) = result;
  *((_OWORD *)a2 + 3) = v11;
  LODWORD(v9) = *((_DWORD *)this + 16);
  *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
  *((_DWORD *)a2 + 16) = v9;
  LODWORD(v9) = *((_DWORD *)this + 17);
  *((_DWORD *)this + 17) = *((_DWORD *)a2 + 17);
  *((_DWORD *)a2 + 17) = v9;
  LOWORD(v9) = *((_WORD *)this + 36);
  *((_WORD *)this + 36) = *((_WORD *)a2 + 36);
  *((_WORD *)a2 + 36) = v9;
  LOBYTE(v9) = *((_BYTE *)this + 74);
  *((_BYTE *)this + 74) = *((_BYTE *)a2 + 74);
  *((_BYTE *)a2 + 74) = v9;
  return result;
}

void dyld4::FileRecord::~FileRecord(dyld4::FileRecord *this, void *a2)
{
  int v3;
  const os_unfair_lock *v4;

  v3 = *((_DWORD *)this + 16);
  if (v3 != -1)
  {
    close(v3);
    *((_DWORD *)this + 16) = -1;
  }
  v4 = (const os_unfair_lock *)*((_QWORD *)this + 5);
  if (v4)
    lsl::Allocator::freeObject(v4, a2);
}

const os_unfair_lock *lsl::Allocator::free(lsl::Allocator *this, _QWORD *a2)
{
  lsl::Lock *v4;

  v4 = (lsl::Lock *)*((_QWORD *)this + 5);
  lsl::Lock::lock(v4);
  if (a2)
  {
    *((_QWORD *)this + 2) += (char *)a2 - (*(a2 - 1) & 0xFFFFFFFFFFFFFFFCLL);
    lsl::Allocator::AllocationMetadata::deallocate((lsl::Allocator::AllocationMetadata *)(a2 - 2));
  }
  return lsl::Lock::unlock(v4);
}

_QWORD *lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(_QWORD *a1, lsl::Allocator::AllocationMetadata *this)
{
  lsl::Allocator::AllocationMetadata *v4;
  lsl::Allocator::Pool *v5;
  lsl::Allocator *v6;
  _QWORD *v7;

  *a1 = 0;
  v4 = (lsl::Allocator::AllocationMetadata *)lsl::Allocator::AllocationMetadata::forPtr(this, this);
  v5 = (lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(v4, 1);
  v6 = (lsl::Allocator *)lsl::Allocator::Pool::allocator(v5);
  v7 = lsl::Allocator::aligned_alloc(v6, 8uLL, 0x10uLL);
  *(_DWORD *)v7 = 0;
  v7[1] = this;
  *a1 = v7;
  return a1;
}

uint64_t dyld4::FileRecord::FileRecord(uint64_t a1, dyld4::FileRecord *a2)
{
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 64) = 0x1FFFFFFFFLL;
  *(_WORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 74) = 1;
  dyld4::FileRecord::swap((dyld4::FileRecord *)a1, a2);
  return a1;
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::readMappedFileInfo(uint64_t a1, uint64_t *a2, uint64_t *a3, _OWORD *a4, dyld4::FileRecord *a5)
{
  uint64_t result;
  char v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t __dst;
  _BYTE v16[80];

  __dst = 0;
  result = lsl::readPVLEUInt64(a2, &__dst);
  if ((_DWORD)result)
  {
    result = lsl::readPVLEUInt64(a2, a3);
    if ((_DWORD)result)
    {
      v11 = __dst;
      if ((__dst & 4) != 0)
      {
        if ((unint64_t)a2[1] < 0x10)
          return 0;
        *a4 = *(_OWORD *)*a2;
        v12 = a2[1] - 16;
        *a2 += 16;
        a2[1] = v12;
      }
      if ((v11 & 1) == 0)
      {
        if ((v11 & 2) == 0)
          return 1;
        goto LABEL_8;
      }
      v13 = 0;
      v14 = 0;
      if (lsl::readPVLEUInt64(a2, (uint64_t *)&v14)
        && lsl::readPVLEUInt64(a2, (uint64_t *)&v13)
        && v14 < *(_QWORD *)(a1 + 64))
      {
        dyld4::FileManager::fileRecordForVolumeUUIDAndObjID(*(dyld4::FileManager **)(a1 + 16), (const UUID *)(*(_QWORD *)(a1 + 56) + 16 * v14), v13, (uint64_t)v16);
        dyld4::FileRecord::operator=(a5, (dyld4::FileRecord *)v16);
        dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v16);
        if ((__dst & 2) == 0)
          return 1;
LABEL_8:
        v14 = 0;
        if (lsl::readPVLEUInt64(a2, (uint64_t *)&v14) && v14 < *(_QWORD *)(a1 + 128))
        {
          dyld4::FileManager::fileRecordForPath(*(dyld4::FileManager **)(a1 + 16), *(lsl::Allocator **)(a1 + 8), (const char *)(*(_QWORD *)(a1 + 120) + v14), (uint64_t)v16);
          dyld4::FileRecord::operator=(a5, (dyld4::FileRecord *)v16);
          dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v16);
          return 1;
        }
      }
      return 0;
    }
  }
  return result;
}

dyld4::FileRecord *dyld4::FileRecord::operator=(dyld4::FileRecord *a1, dyld4::FileRecord *a2)
{
  dyld4::FileRecord::swap(a1, a2);
  return a1;
}

void lsl::Allocator::makeUnique<dyld4::Atlas::Image,dyld4::Atlas::Image>(lsl::Allocator *a1@<X0>, dyld4::Atlas::Image *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v5;

  v5 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0xC0uLL);
  *v5 = *(_QWORD *)a2;
  *(_OWORD *)(v5 + 7) = 0u;
  *(_OWORD *)(v5 + 5) = 0u;
  *(_OWORD *)(v5 + 3) = 0u;
  *(_OWORD *)(v5 + 1) = 0u;
  v5[9] = 0x1FFFFFFFFLL;
  *((_WORD *)v5 + 40) = 0;
  *((_BYTE *)v5 + 82) = 1;
  *((_BYTE *)v5 + 144) = 0;
  *((_BYTE *)v5 + 152) = 0;
  *((_BYTE *)v5 + 136) = 0;
  *(_OWORD *)(v5 + 15) = 0u;
  *(_OWORD *)(v5 + 13) = 0u;
  *(_OWORD *)(v5 + 11) = 0u;
  *(_DWORD *)((char *)v5 + 183) = 0;
  v5[21] = 0;
  v5[22] = 0;
  v5[20] = 0;
  dyld4::Atlas::Image::swap((dyld4::Atlas::Image *)v5, a2);
  *a3 = v5;
}

void dyld4::Atlas::Image::swap(dyld4::Atlas::Image *this, dyld4::Atlas::Image *a2)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  char v10;
  char v11;

  if (this != a2)
  {
    v4 = *((_OWORD *)this + 6);
    *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
    *((_OWORD *)a2 + 6) = v4;
    dyld4::Atlas::Mapper::Pointer<dyld3::MachOLoaded>::swap((uint64_t *)this + 14, (uint64_t *)a2 + 14);
    std::optional<unsigned long long>::swap[abi:nn180100]((uint64_t *)this + 18, (uint64_t *)a2 + 18);
    v5 = *((_QWORD *)this + 20);
    *((_QWORD *)this + 20) = *((_QWORD *)a2 + 20);
    *((_QWORD *)a2 + 20) = v5;
    v6 = *((_QWORD *)this + 11);
    *((_QWORD *)this + 11) = *((_QWORD *)a2 + 11);
    *((_QWORD *)a2 + 11) = v6;
    v7 = *((_QWORD *)this + 21);
    *((_QWORD *)this + 21) = *((_QWORD *)a2 + 21);
    *((_QWORD *)a2 + 21) = v7;
    v8 = *((_QWORD *)this + 22);
    *((_QWORD *)this + 22) = *((_QWORD *)a2 + 22);
    *((_QWORD *)a2 + 22) = v8;
    dyld4::FileRecord::swap((dyld4::Atlas::Image *)((char *)this + 8), (dyld4::Atlas::Image *)((char *)a2 + 8));
    v9 = *((_BYTE *)this + 184);
    *((_BYTE *)this + 184) = *((_BYTE *)a2 + 184);
    *((_BYTE *)a2 + 184) = v9;
    v10 = *((_BYTE *)this + 185);
    *((_BYTE *)this + 185) = *((_BYTE *)a2 + 185);
    *((_BYTE *)a2 + 185) = v10;
    v11 = *((_BYTE *)this + 186);
    *((_BYTE *)this + 186) = *((_BYTE *)a2 + 186);
    *((_BYTE *)a2 + 186) = v11;
  }
}

uint64_t *dyld4::Atlas::Mapper::Pointer<dyld3::MachOLoaded>::swap(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (result != a2)
  {
    v2 = *result;
    v3 = result[1];
    v4 = a2[1];
    *result = *a2;
    result[1] = v4;
    *a2 = v2;
    a2[1] = v3;
    v5 = result[2];
    result[2] = a2[2];
    a2[2] = v5;
    LOBYTE(v5) = *((_BYTE *)result + 24);
    *((_BYTE *)result + 24) = *((_BYTE *)a2 + 24);
    *((_BYTE *)a2 + 24) = v5;
  }
  return result;
}

double lsl::OrderedSet<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>>::insert@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  double result;
  char v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  __int16 v16;
  char v17;
  char v18;
  _BYTE v19[104];

  lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::const_iterator((uint64_t)v19, a1, (uint64_t)a2);
  lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::insert_internal(a1, (uint64_t)v19, a2, (uint64_t)&v9);
  v6 = v9;
  *(_OWORD *)(a3 + 24) = v11;
  *(_OWORD *)(a3 + 40) = v12;
  *(_OWORD *)(a3 + 56) = v13;
  *(_OWORD *)(a3 + 72) = v14;
  result = *(double *)&v10;
  *(_OWORD *)(a3 + 8) = v10;
  *(_QWORD *)(a3 + 88) = v15;
  *(_WORD *)(a3 + 96) = v16;
  v8 = v17;
  *(_QWORD *)a3 = v6;
  *(_BYTE *)(a3 + 98) = v8;
  *(_BYTE *)(a3 + 104) = v18;
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::insert_internal@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 v14;
  _QWORD *v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[27];

  if (*(_QWORD *)a1)
  {
    v22 = a1;
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    memset(v27, 0, sizeof(v27));
    result = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(a2, (uint64_t)&v22);
    if ((_BYTE)result
      && (v9 = *(unsigned __int8 *)(a2 + 98),
          *(_QWORD *)(*a3 + 160) >= *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8 + 8 * (v9 - 1))
                                                          + 8 * *(unsigned __int8 *)(a2 + 88 + v9 - 1))
                                              + 160)))
    {
      v16 = 0;
      v20 = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
      v21 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = v21;
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(_QWORD *)a4 = *(_QWORD *)a2;
      *(_OWORD *)(a4 + 8) = v20;
      *(_QWORD *)(a4 + 88) = *(_QWORD *)(a2 + 88);
      *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
      *(_BYTE *)(a4 + 98) = v9;
    }
    else
    {
      v22 = a1;
      v23 = 0u;
      v24 = 0u;
      v25 = 0u;
      v26 = 0u;
      memset(v27, 0, sizeof(v27));
      if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(a2, (uint64_t)&v22)&& *(unsigned __int8 *)(a2 + 98) == *(unsigned __int8 *)(a1 + 32))
      {
        lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2, v10, v11);
        v12 = a2 + 88;
        v13 = *(unsigned __int8 *)(a2 + 98) - 1;
        v14 = *(_BYTE *)(a2 + 88 + v13);
      }
      else
      {
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--(a2, v10, v11);
        lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2, v17, v18);
        v12 = a2 + 88;
        v19 = *(unsigned __int8 *)(a2 + 98) + a2 + 88;
        v14 = *(_BYTE *)(v19 - 1) + 1;
        *(_BYTE *)(v19 - 1) = v14;
        v13 = *(unsigned __int8 *)(a2 + 98) - 1;
      }
      result = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::insert(*(_QWORD *)(a2 + 8 + 8 * v13), v14, a3);
      ++*(_QWORD *)(a1 + 24);
      *(_QWORD *)a4 = *(_QWORD *)a2;
      *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
      *(_QWORD *)(a4 + 88) = *(_QWORD *)v12;
      *(_WORD *)(a4 + 96) = *(_WORD *)(v12 + 8);
      *(_BYTE *)(a4 + 98) = *(_BYTE *)(a2 + 98);
      v16 = 1;
    }
  }
  else
  {
    v15 = lsl::Allocator::aligned_alloc(*(lsl::Allocator **)(a1 + 8), 0x100uLL, 0x100uLL);
    *((_BYTE *)v15 + 248) = 0x80;
    *(_OWORD *)v15 = 0u;
    *((_OWORD *)v15 + 1) = 0u;
    *((_OWORD *)v15 + 2) = 0u;
    *((_OWORD *)v15 + 3) = 0u;
    *((_OWORD *)v15 + 4) = 0u;
    *((_OWORD *)v15 + 5) = 0u;
    *((_OWORD *)v15 + 6) = 0u;
    *((_OWORD *)v15 + 7) = 0u;
    *((_OWORD *)v15 + 8) = 0u;
    *((_OWORD *)v15 + 9) = 0u;
    *((_OWORD *)v15 + 10) = 0u;
    *((_OWORD *)v15 + 11) = 0u;
    *((_OWORD *)v15 + 12) = 0u;
    *((_OWORD *)v15 + 13) = 0u;
    *((_OWORD *)v15 + 14) = 0u;
    v15[30] = 0;
    *(_QWORD *)a1 = v15;
    v16 = 1;
    *(_BYTE *)(a1 + 32) = 1;
    *(_QWORD *)(a2 + 8) = v15;
    *(_BYTE *)(a2 + 98) = 1;
    result = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::insert((uint64_t)v15, 0, a3);
    ++*(_QWORD *)(a1 + 24);
    *(_QWORD *)a4 = *(_QWORD *)a2;
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_QWORD *)(a4 + 88) = *(_QWORD *)(a2 + 88);
    *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
    *(_BYTE *)(a4 + 98) = *(_BYTE *)(a2 + 98);
  }
  *(_BYTE *)(a4 + 104) = v16;
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::insert(uint64_t result, uint64_t a2, uint64_t *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = *(char *)(result + 248);
  v4 = v3 & 0x7F;
  if (v3 >= 0)
    v5 = 15;
  else
    v5 = 31;
  if (v4 == v5)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(result, a2, (uint64_t)a3);
  if (v5 == (_DWORD)a2)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(result, a2, (uint64_t)a3);
  v6 = (uint64_t *)(result + 8 * a2);
  if (v4 != (_DWORD)a2)
  {
    v7 = (uint64_t *)(result + 8 * (v3 & 0x7F));
    v10 = *v7;
    v8 = v7 - 1;
    v9 = v10;
    v11 = 8 * a2 - 8 * (v3 & 0x7F);
    do
    {
      v12 = *v8;
      *v8 = v9;
      v8[1] = v12;
      --v8;
      v11 += 8;
    }
    while (v11);
  }
  *(_BYTE *)(result + 248) = v3 + 1;
  if (v6 != a3)
  {
    v13 = *v6;
    *v6 = *a3;
    *a3 = v13;
  }
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::const_iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unint64_t v16;

  *(_QWORD *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  v4 = a1 + 8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 83) = 0u;
  if (*(_BYTE *)(a2 + 32))
  {
    v7 = 0;
    v8 = *(_QWORD *)a2;
    v9 = a1 + 88;
    do
    {
      v10 = v9 + 8 * v7;
      *(_QWORD *)(v10 - 80) = v8;
      v11 = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::lower_bound_index(v8, a3);
      *(_BYTE *)(v9 + v7) = v11;
      v14 = *(_QWORD *)(v10 - 80);
      v15 = *(char *)(v14 + 248);
      if ((_DWORD)v11 != (v15 & 0x7F)
        && *(_QWORD *)(*(_QWORD *)(v14 + 8 * v11) + 160) < *(_QWORD *)(*(_QWORD *)a3 + 160))
      {
        *(_BYTE *)(a1 + 98) = v7 + 1;
        return a1;
      }
      v16 = *(unsigned __int8 *)(a2 + 32);
      if ((_DWORD)v7 + 1 != (_DWORD)v16)
      {
        if (v15 < 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(v11, v12, v13);
        v8 = *(_QWORD *)(v14 + 8 * v11 + 120);
      }
      ++v7;
    }
    while (v7 < v16);
    for (*(_BYTE *)(a1 + 98) = v16; (_BYTE)v16; *(_BYTE *)(a1 + 98) = v16)
    {
      if (*(_BYTE *)(v9 + v16 - 1) != (*(_BYTE *)(*(_QWORD *)(v4
                                                                                            + 8 * v16
                                                                                            - 8)
                                                                                + 248) & 0x7F))
        break;
      LOBYTE(v16) = v16 - 1;
    }
  }
  return a1;
}

double dyld4::FileManager::fileRecordForPath@<D0>(dyld4::FileManager *this@<X0>, lsl::Allocator *a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  char *v6;
  double result;

  if (a3)
    v6 = lsl::Allocator::strdup(a2, a3);
  else
    v6 = 0;
  *(_QWORD *)a4 = this;
  *(_OWORD *)(a4 + 8) = 0u;
  *(_OWORD *)(a4 + 24) = 0u;
  *(_QWORD *)(a4 + 48) = 0;
  *(_QWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 40) = v6;
  *(_QWORD *)&result = 0x1FFFFFFFFLL;
  *(_QWORD *)(a4 + 64) = 0x1FFFFFFFFLL;
  *(_WORD *)(a4 + 72) = 0;
  *(_BYTE *)(a4 + 74) = 1;
  return result;
}

char *lsl::Allocator::strdup(lsl::Allocator *this, const char *__s)
{
  unint64_t v4;
  char *v5;

  v4 = _platform_strlen(__s) + 1;
  v5 = (char *)lsl::Allocator::aligned_alloc(this, 0x10uLL, v4);
  strlcpy(v5, __s, v4);
  return v5;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::lower_bound_index(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  uint64_t *v5;
  _QWORD *v6;
  uint64_t v7;

  v2 = *(_BYTE *)(a1 + 248) & 0x7F;
  if ((*(_BYTE *)(a1 + 248) & 0x7F) != 0)
  {
    v3 = (_QWORD *)a1;
    do
    {
      v4 = v2 >> 1;
      v5 = &v3[v2 >> 1];
      v7 = *v5;
      v6 = v5 + 1;
      v2 += ~(v2 >> 1);
      if (*(_QWORD *)(v7 + 160) < *(_QWORD *)(*(_QWORD *)a2 + 160))
        v3 = v6;
      else
        v2 = v4;
    }
    while (v2);
  }
  else
  {
    LODWORD(v3) = a1 + 8 * v2;
  }
  return (((_DWORD)v3 - a1) >> 3);
}

uint64_t lsl::CRC32c::operator()(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t))(**(_QWORD **)a1 + 32))(*(_QWORD *)a1, a1[2], a2, a3);
  a1[2] = result;
  return result;
}

uint64_t lsl::CRC32cSW::checksum(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t result;
  char v5;

  for (result = a2; a4; --a4)
  {
    v5 = *a3++;
    result = lsl::CRC32cSW::sCRC32cTable[(v5 ^ result)] ^ (result >> 8);
  }
  return result;
}

unsigned __int8 *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::prepareForInsertion(unsigned __int8 *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  int v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned __int8 v23;
  uint64_t v24;

  v3 = result[98];
  if ((_DWORD)v3 != *(unsigned __int8 *)(*(_QWORD *)result + 32))
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion((uint64_t)result, a2, a3);
  v4 = result;
  v5 = result + 8;
  if (*(char *)(*(_QWORD *)&result[8 * v3] + 248) >= 0)
    v6 = 15;
  else
    v6 = 31;
  if ((*(_BYTE *)(*(_QWORD *)&result[8 * v3] + 248) & 0x7F) == v6)
  {
    if (!result[98])
      goto LABEL_15;
    v7 = 0;
    v8 = 0;
    do
    {
      if (*(char *)(v5[v7] + 248) >= 0)
        v9 = 15;
      else
        v9 = 31;
      if ((*(_BYTE *)(v5[v7] + 248) & 0x7F) != v9)
        v8 = v7;
      ++v7;
    }
    while (v3 != v7);
    if (!v8)
    {
LABEL_15:
      if (*(char *)(*v5 + 248) >= 0)
        v10 = 15;
      else
        v10 = 31;
      if ((*(_BYTE *)(*v5 + 248) & 0x7F) == v10)
      {
        v11 = lsl::Allocator::aligned_alloc(*(lsl::Allocator **)(*(_QWORD *)result + 8), 0x100uLL, 0x100uLL);
        result = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::NodeCore((uint64_t)v11, **(_QWORD **)v4, v12);
        **(_QWORD **)v4 = result;
        if (v4[98] && (result = (unsigned __int8 *)memmove(v4 + 89, v4 + 88, v4[98]), v4[98]))
        {
          result = (unsigned __int8 *)memmove(v5 + 1, v5, 8 * v4[98]);
          LOBYTE(v3) = v4[98] + 1;
        }
        else
        {
          LOBYTE(v3) = 1;
        }
        v8 = 0;
        v4[88] = 0;
        v13 = *(uint64_t **)v4;
        *((_QWORD *)v4 + 1) = **(_QWORD **)v4;
        ++*((_BYTE *)v13 + 32);
        v4[98] = v3;
      }
      else
      {
        v8 = 0;
      }
    }
    if (v8 + 1 < v3)
    {
      v14 = v4 + 88;
      v15 = v8;
      do
      {
        v16 = v15;
        result = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::splitChild(v5[v15], v14[v15], *(lsl::Allocator **)(*(_QWORD *)v4 + 8));
        v19 = v5[v15];
        if (*(char *)(v19 + 248) < 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v17, v18);
        v20 = v14[v15];
        v21 = *(_QWORD *)(v19 + 8 * v20 + 120);
        v22 = v4[v15 + 89];
        if (v22 > (*(_BYTE *)(v21 + 248) & 0x7Fu))
        {
          v23 = v20 + 1;
          v14[v15] = v23;
          v4[v15 + 89] = v22 + (~*(_BYTE *)(v21 + 248) | 0x80);
          v24 = v5[v15];
          if (*(char *)(v24 + 248) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v17, v18);
          *(_QWORD *)&v4[8 * v15 + 16] = *(_QWORD *)(v24 + 8 * v23 + 120);
        }
        ++v15;
      }
      while (v16 + 2 < v4[98]);
    }
  }
  return result;
}

double dyld4::FileManager::fileRecordForVolumeUUIDAndObjID@<D0>(dyld4::FileManager *this@<X0>, const UUID *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  double result;

  *(_QWORD *)a4 = this;
  *(_QWORD *)(a4 + 8) = a3;
  *(_QWORD *)(a4 + 16) = 0;
  *(_OWORD *)(a4 + 24) = *(_OWORD *)a2;
  *(_QWORD *)(a4 + 48) = 0;
  *(_QWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_QWORD *)&result = 0x1FFFFFFFFLL;
  *(_QWORD *)(a4 + 64) = 0x1FFFFFFFFLL;
  *(_WORD *)(a4 + 72) = 0;
  *(_BYTE *)(a4 + 74) = 1;
  return result;
}

const os_unfair_lock *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate(uint64_t a1, lsl::Allocator *a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  const os_unfair_lock **v8;
  const os_unfair_lock **v9;
  unint64_t v10;

  if ((*(char *)(a1 + 248) & 0x80000000) == 0)
  {
    v4 = (uint64_t *)(a1 + 120);
    v5 = 8 * *(unsigned __int8 *)(a1 + 248) + 8;
    do
    {
      v6 = *v4++;
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate(v6, a2);
      v5 -= 8;
    }
    while (v5);
  }
  v7 = 0;
  v8 = (const os_unfair_lock **)a1;
  do
  {
    v9 = lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(v8);
    ++v7;
    if (*(char *)(a1 + 248) >= 0)
      v10 = 15;
    else
      v10 = 31;
    v8 = v9 + 1;
  }
  while (v7 < v10);
  return lsl::Allocator::free(a2, (_QWORD *)a1);
}

const os_unfair_lock **lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(const os_unfair_lock **a1)
{
  const os_unfair_lock *v2;
  void *v3;
  os_unfair_lock *v4;
  void *v5;

  v2 = *a1;
  if (*a1)
  {
    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v2[28]);
    v4 = *(os_unfair_lock **)&v2[22]._os_unfair_lock_opaque;
    if (v4)
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v4, v3);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v2[2]);
    lsl::Allocator::freeObject(*a1, v5);
  }
  return a1;
}

_DWORD *dyld4::Atlas::Image::ml(dyld4::Atlas::Image *this)
{
  _DWORD *result;
  os_unfair_lock *v3;
  __int128 *v4;
  char *v5;
  void *v6;
  os_unfair_lock *v7;
  dyld4::Atlas::Mapper *v8;
  char *v9;
  char v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  dyld4::Atlas::Mapper *v15;
  char *v16;
  char v17;
  char *v18;
  __int128 v19;
  char *v20;
  char v21;

  if (*((_BYTE *)this + 186))
    return 0;
  result = (_DWORD *)*((_QWORD *)this + 16);
  if (result)
    return result;
  v4 = (__int128 *)((char *)this + 88);
  v3 = (os_unfair_lock *)*((_QWORD *)this + 11);
  v5 = (char *)*((_QWORD *)this + 20);
  if (!v3 || !*(_QWORD *)&v3[2]._os_unfair_lock_opaque)
  {
    dyld4::Atlas::Mapper::mapperForMachO(*(dyld4::Atlas::Mapper **)this, (dyld4::Atlas::Image *)((char *)this + 8), (dyld4::Atlas::Image *)((char *)this + 96), *((const UUID **)this + 20), &v19);
    if (&v19 == v4)
    {
      v7 = (os_unfair_lock *)v19;
      if (!(_QWORD)v19)
      {
LABEL_9:
        v3 = *(os_unfair_lock **)v4;
        if (!*(_QWORD *)v4)
        {
LABEL_25:
          result = 0;
          *((_BYTE *)this + 186) = 1;
          return result;
        }
        goto LABEL_10;
      }
    }
    else
    {
      v7 = *(os_unfair_lock **)v4;
      *(_QWORD *)v4 = v19;
      *(_QWORD *)&v19 = v7;
      if (!v7)
        goto LABEL_9;
    }
    lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v7, v6);
    goto LABEL_9;
  }
LABEL_10:
  v8 = *(dyld4::Atlas::Mapper **)&v3[2]._os_unfair_lock_opaque;
  if (!v8)
    goto LABEL_25;
  *(_QWORD *)&v19 = *(_QWORD *)&v3[2]._os_unfair_lock_opaque;
  *((_QWORD *)&v19 + 1) = 4096;
  v9 = dyld4::Atlas::Mapper::map(v8, v5, 4096);
  v20 = v9;
  v21 = v10;
  if ((__int128 *)((char *)this + 112) != &v19)
  {
    v19 = *((_OWORD *)this + 7);
    *((_QWORD *)this + 14) = v8;
    *((_QWORD *)this + 15) = 4096;
    v11 = (char *)*((_QWORD *)this + 16);
    *((_QWORD *)this + 16) = v9;
    v20 = v11;
    LOBYTE(v11) = *((_BYTE *)this + 136);
    *((_BYTE *)this + 136) = v10;
    v21 = (char)v11;
  }
  dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v19);
  result = (_DWORD *)*((_QWORD *)this + 16);
  if (!result)
    goto LABEL_25;
  v12 = result[5];
  v13 = 28;
  if (*result == -17958193)
    v13 = 32;
  v14 = v13 + v12;
  if ((unint64_t)(v13 + v12) > 0x1000)
  {
    v15 = *(_QWORD *)v4 ? *(dyld4::Atlas::Mapper **)(*(_QWORD *)v4 + 8) : 0;
    *(_QWORD *)&v19 = v15;
    *((_QWORD *)&v19 + 1) = v13 + v12;
    v16 = dyld4::Atlas::Mapper::map(v15, v5, v14);
    v20 = v16;
    v21 = v17;
    if ((__int128 *)((char *)this + 112) != &v19)
    {
      v19 = *((_OWORD *)this + 7);
      *((_QWORD *)this + 14) = v15;
      *((_QWORD *)this + 15) = v14;
      v18 = (char *)*((_QWORD *)this + 16);
      *((_QWORD *)this + 16) = v16;
      v20 = v18;
      LOBYTE(v18) = *((_BYTE *)this + 136);
      *((_BYTE *)this + 136) = v17;
      v21 = (char)v18;
    }
    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v19);
    result = (_DWORD *)*((_QWORD *)this + 16);
    if (!result)
      goto LABEL_25;
  }
  return result;
}

uint64_t dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer(uint64_t a1)
{
  unint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 && *(_BYTE *)(a1 + 24))
    dyld4::Atlas::Mapper::unmap(*(dyld4::Atlas::Mapper **)a1, v2, *(_QWORD *)(a1 + 8));
  return a1;
}

char *dyld4::Atlas::Mapper::map(dyld4::Atlas::Mapper *this, char *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  off_t v12;
  char *v13;
  char *v14;

  v3 = *((_QWORD *)this + 4);
  if (v3)
    return &a2[v3 - *(_QWORD *)(*((_QWORD *)this + 1) + 16)];
  v5 = *((_QWORD *)this + 2);
  if (v5)
  {
    v6 = *((_QWORD *)this + 1);
    v7 = 32 * v5;
    while (1)
    {
      v8 = *(_QWORD *)(v6 + 16);
      if (v8 <= (unint64_t)a2)
      {
        v9 = *(_QWORD *)(v6 + 8) + v8;
        if (v9 > (unint64_t)a2)
          break;
      }
      v6 += 32;
      v7 -= 32;
      if (!v7)
        return (char *)-1;
    }
    v10 = *(_DWORD *)(v6 + 24);
    if (v10 == -1)
    {
      return &a2[*(_QWORD *)v6 - v8];
    }
    else
    {
      if ((unint64_t)&a2[a3] > v9)
        dyld4::Atlas::Mapper::map();
      v11 = (unint64_t)&a2[*(_QWORD *)v6 - v8];
      v12 = v11 & -(uint64_t)vm_page_size;
      v13 = (char *)(v11 - v12);
      v14 = (char *)mmap(0, v11 - v12 + a3, 1, 2, v10, v12);
      if (v14 == (char *)-1)
        return (char *)1;
      else
        return &v14[(_QWORD)v13];
    }
  }
  return a2;
}

void dyld4::Atlas::Mapper::~Mapper(dyld4::Atlas::Mapper *this)
{
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  __int32 *v5;
  uint64_t v6;
  __int32 *v7;
  __int32 *v8;
  __int32 *v9;
  __int32 *v10;
  __int32 v11;
  size_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __int32 *v16;
  size_t v17;
  uint64_t v18;

  if (*((_QWORD *)this + 4))
    dyld4::Atlas::Mapper::~Mapper();
  v15 = *((_QWORD *)this + 5);
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v2 = *((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 2);
  if (v3)
  {
    v4 = 0;
    v5 = 0;
    v6 = 32 * v3;
    v7 = (__int32 *)(v2 + 24);
    do
    {
      if (*v7 != -1)
      {
        v8 = &v5[v4];
        v9 = wmemchr(v5, *v7, v4);
        v10 = v9 ? v9 : v8;
        v5 = v16;
        v4 = v17;
        if (v10 == &v16[v17])
        {
          lsl::Vector<unsigned int>::reserve((uint64_t)&v15, v17 + 1);
          v11 = *v7;
          v5 = v16;
          v12 = v17;
          v4 = ++v17;
          v16[v12] = v11;
        }
      }
      v7 += 8;
      v6 -= 32;
    }
    while (v6);
    if (v4)
    {
      v13 = 4 * v4;
      do
      {
        v14 = *v5++;
        close(v14);
        v13 -= 4;
      }
      while (v13);
      v5 = v16;
    }
    if (v5)
      lsl::Vector<unsigned int>::resize((const os_unfair_lock *)&v15, 0);
    v2 = *((_QWORD *)this + 1);
  }
  if (v2)
    lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize((const os_unfair_lock *)this, 0);
}

const os_unfair_lock *dyld4::ExternallyViewableState::release(const os_unfair_lock *this, lsl::Allocator *a2)
{
  uint64_t v2;
  const os_unfair_lock *v4;
  os_unfair_lock *v5;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)&this->_os_unfair_lock_opaque;
  if (*(_QWORD *)&this->_os_unfair_lock_opaque)
  {
    v4 = this;
    v5 = *(os_unfair_lock **)(v2 + 72);
    if (v5)
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v5, a2);
    lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr((const os_unfair_lock **)(v2 + 64), a2);
    lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)(v2 + 56), v6);
    v7 = *(_QWORD *)(v2 + 16);
    if (v7)
    {
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate(v7, *(lsl::Allocator **)(v2 + 24));
      *(_QWORD *)(v2 + 16) = 0;
    }
    *(_QWORD *)(v2 + 40) = 0;
    *(_BYTE *)(v2 + 48) = 0;
    this = lsl::Allocator::free(a2, *(_QWORD **)&v4->_os_unfair_lock_opaque);
    *(_QWORD *)&v4->_os_unfair_lock_opaque = 0;
  }
  return this;
}

uint64_t *lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr(uint64_t *a1, void *a2)
{
  uint64_t v3;

  v3 = *a1;
  if (v3)
  {
    if (*(_QWORD *)(v3 + 8))
    {
      lsl::Allocator::freeObject(*(const os_unfair_lock **)(v3 + 8), a2);
      v3 = *a1;
    }
    lsl::Allocator::freeObject((const os_unfair_lock *)v3, a2);
  }
  return a1;
}

const os_unfair_lock **lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr(const os_unfair_lock **a1, void *a2)
{
  const os_unfair_lock *v3;
  os_unfair_lock *v4;
  void *v5;

  v3 = *a1;
  if (*a1)
  {
    v4 = *(os_unfair_lock **)&v3[36]._os_unfair_lock_opaque;
    if (v4)
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v4, a2);
    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v3[28]);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v3[2]);
    lsl::Allocator::freeObject(*a1, v5);
  }
  return a1;
}

uint64_t dyld4::Atlas::SharedCache::SharedCache(uint64_t a1, uint64_t a2, dyld4::FileRecord *a3, unsigned int **a4, char *a5, char a6)
{
  __int128 *v10;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  dyld4::Atlas::Mapper *v14;
  vm_size_t v15;
  char *v16;
  char v17;
  char *v18;
  uint64_t v19;
  unsigned int v20;
  vm_size_t v21;
  uint64_t v22;
  dyld4::Atlas::Mapper *v23;
  char *v24;
  char *v25;
  char v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  dyld4::Atlas::Mapper *v40;
  char *v41;
  char *v42;
  char v43;
  vm_size_t v44;
  uint64_t v45;
  dyld4::Atlas::Mapper *v46;
  char *v47;
  __int128 v48;
  char *v49;
  char v50;
  uint64_t v51;
  char *v52;
  __int128 v54;
  char *v55;
  char v56;
  __int128 v57;
  char *v58;
  char v59;

  *(_QWORD *)a1 = a2;
  dyld4::FileRecord::FileRecord(a1 + 8, a3);
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  v10 = (__int128 *)(a1 + 112);
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  v11 = *a4;
  *(_QWORD *)(a1 + 144) = *a4;
  if (!v11)
  {
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 160) = a5;
    *(_BYTE *)(a1 + 168) = a6;
    goto LABEL_52;
  }
  do
    v12 = __ldxr(v11);
  while (__stxr(v12 + 1, v11));
  v13 = *(_QWORD *)(a1 + 144);
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = a5;
  *(_BYTE *)(a1 + 168) = a6;
  if (!v13 || (v14 = *(dyld4::Atlas::Mapper **)(v13 + 8)) == 0)
LABEL_52:
    dyld4::Atlas::SharedCache::SharedCache();
  v15 = vm_page_size;
  *(_QWORD *)&v57 = *(_QWORD *)(v13 + 8);
  *((_QWORD *)&v57 + 1) = vm_page_size;
  v16 = dyld4::Atlas::Mapper::map(v14, a5, vm_page_size);
  v58 = v16;
  v59 = v17;
  if (v10 != &v57)
  {
    v57 = *(_OWORD *)(a1 + 112);
    *(_QWORD *)(a1 + 112) = v14;
    *(_QWORD *)(a1 + 120) = v15;
    v18 = *(char **)(a1 + 128);
    *(_QWORD *)(a1 + 128) = v16;
    v58 = v18;
    LOBYTE(v18) = *(_BYTE *)(a1 + 136);
    *(_BYTE *)(a1 + 136) = v17;
    v59 = (char)v18;
  }
  dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v57);
  v19 = *(_QWORD *)(a1 + 128);
  v20 = *(_DWORD *)(v19 + 16);
  if (v20 >= 0x18C)
    v21 = *(unsigned int *)(v19 + 392) + 56 * *(unsigned int *)(v19 + 396);
  else
    v21 = *(unsigned int *)(v19 + 24) + 32 * *(unsigned int *)(v19 + 28);
  if (v21 > vm_page_size)
  {
    v22 = *(_QWORD *)(a1 + 144);
    if (v22)
      v23 = *(dyld4::Atlas::Mapper **)(v22 + 8);
    else
      v23 = 0;
    v24 = *(char **)(a1 + 160);
    *(_QWORD *)&v57 = v23;
    *((_QWORD *)&v57 + 1) = v21;
    v25 = dyld4::Atlas::Mapper::map(v23, v24, v21);
    v58 = v25;
    v59 = v26;
    if (v10 != &v57)
    {
      v57 = *(_OWORD *)(a1 + 112);
      *(_QWORD *)(a1 + 112) = v23;
      *(_QWORD *)(a1 + 120) = v21;
      v27 = *(char **)(a1 + 128);
      *(_QWORD *)(a1 + 128) = v25;
      v58 = v27;
      LOBYTE(v27) = *(_BYTE *)(a1 + 136);
      *(_BYTE *)(a1 + 136) = v26;
      v59 = (char)v27;
    }
    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v57);
    v19 = *(_QWORD *)(a1 + 128);
  }
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(v19 + 88);
  v28 = *(_QWORD *)(v19 + 224);
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(a1 + 160) - v28;
  if (*(_DWORD *)(v19 + 16) < 0x18Cu)
  {
    v30 = *(unsigned int *)(v19 + 316);
    if ((_DWORD)v30)
    {
      v31 = 0;
      v32 = (_QWORD *)(*(unsigned int *)(v19 + 312) + v19 + 8);
      do
      {
        if (v31 <= *v32 + *(v32 - 1))
          v31 = *v32 + *(v32 - 1);
        v32 += 7;
        --v30;
      }
      while (v30);
    }
    else
    {
      v31 = 0;
    }
    if (v20 >= 0x18C && *(_DWORD *)(v19 + 396))
    {
      v33 = 0;
      v34 = v19;
      do
      {
        v35 = *(_DWORD *)(v34 + 16);
        v36 = v19 + *(unsigned int *)(v34 + 392);
        v37 = v36 + 24 * v33 + 16;
        v38 = (_QWORD *)(v36 + 56 * v33 + 16);
        if (v35 < 0x1C9)
          v38 = (_QWORD *)v37;
        v39 = *(_QWORD *)(a1 + 144);
        if (v39)
          v40 = *(dyld4::Atlas::Mapper **)(v39 + 8);
        else
          v40 = 0;
        v41 = &a5[*v38];
        *(_QWORD *)&v57 = v40;
        *((_QWORD *)&v57 + 1) = vm_page_size;
        v42 = dyld4::Atlas::Mapper::map(v40, v41, vm_page_size);
        v58 = v42;
        v59 = v43;
        if (*((_DWORD *)v42 + 4) < 0x18Cu)
          v44 = *((unsigned int *)v42 + 6) + 32 * *((unsigned int *)v42 + 7);
        else
          v44 = *((unsigned int *)v42 + 98) + 56 * *((unsigned int *)v42 + 99);
        if (v44 > vm_page_size)
        {
          v45 = *(_QWORD *)(a1 + 144);
          if (v45)
            v46 = *(dyld4::Atlas::Mapper **)(v45 + 8);
          else
            v46 = 0;
          *(_QWORD *)&v54 = v46;
          *((_QWORD *)&v54 + 1) = v44;
          v47 = dyld4::Atlas::Mapper::map(v46, v41, v44);
          v48 = v54;
          v54 = v57;
          v57 = v48;
          v49 = v58;
          v58 = v47;
          v55 = v49;
          LOBYTE(v49) = v59;
          v59 = v50;
          v56 = (char)v49;
          dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v54);
          v42 = v58;
        }
        v51 = *((unsigned int *)v42 + 79);
        if ((_DWORD)v51)
        {
          v52 = &v42[*((unsigned int *)v42 + 78) + 8];
          do
          {
            if (v31 <= *(_QWORD *)v52 + *((_QWORD *)v52 - 1))
              v31 = *(_QWORD *)v52 + *((_QWORD *)v52 - 1);
            v52 += 56;
            --v51;
          }
          while (v51);
        }
        dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v57);
        ++v33;
        v34 = *(_QWORD *)(a1 + 128);
      }
      while (v33 < *(unsigned int *)(v34 + 396));
      v28 = *(_QWORD *)(v34 + 224);
    }
    v29 = v31 - v28;
  }
  else
  {
    v29 = *(_QWORD *)(v19 + 232);
  }
  *(_QWORD *)(a1 + 104) = v29;
  return a1;
}

uint64_t lsl::CRC32c::operator()(unsigned int *a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)a1 + 16))(*(_QWORD *)a1, a1[2], a2);
  a1[2] = result;
  return result;
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, uint64_t a2, int a3)
{
  int v4;

  v4 = a3;
  return (*(uint64_t (**)(lsl::CRC32cSW *, uint64_t, int *, uint64_t))(*(_QWORD *)this + 32))(this, a2, &v4, 4);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  int v6;
  unsigned int v7;

  v6 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  do
    v7 = __ldxr(&lock->_os_unfair_lock_opaque);
  while (__stlxr(0, &lock->_os_unfair_lock_opaque));
  if (v7 != v6)
    _os_unfair_lock_unlock_slow(lock, v6, v7, v1, v2, v3, v4, v5);
}

uint64_t dyld4::ExternallyViewableState::addImagesOld(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;

  atomic_store(0, (unint64_t *)(*(_QWORD *)(a1 + 24) + 8));
  lsl::Vector<dyld_image_info>::insert<dyld_image_info*>(*(_QWORD *)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24 * *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16), *(_BYTE **)(a2 + 8), (_BYTE *)(*(_QWORD *)(a2 + 8) + 24 * *(_QWORD *)(a2 + 16)));
  v6 = *(_QWORD *)(a1 + 24);
  *(_DWORD *)(v6 + 4) = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
  atomic_store(a3, (unint64_t *)(v6 + 184));
  atomic_store(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), (unint64_t *)(*(_QWORD *)(a1 + 24) + 8));
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 24) + 16))(0, *(unsigned int *)(a2 + 16), *(_QWORD *)(a2 + 8));
}

uint64_t lsl::Vector<dyld_image_info>::insert<dyld_image_info*>(uint64_t a1, uint64_t a2, _BYTE *a3, _BYTE *a4)
{
  unint64_t v7;
  size_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v7 = 0xAAAAAAAAAAAAAAABLL * ((a2 - *(_QWORD *)(a1 + 8)) >> 3);
  v8 = a4 - a3;
  v9 = (a4 - a3) >> 3;
  v10 = 0xAAAAAAAAAAAAAAABLL * v9;
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(a1, *(_QWORD *)(a1 + 16) - 0x5555555555555555 * v9);
  v11 = *(_QWORD *)(a1 + 16);
  if (v11 != v7)
    memmove((void *)(24 * (v11 + v10) - (24 * v11 - (*(_QWORD *)(a1 + 8) + 24 * v7))), (const void *)(*(_QWORD *)(a1 + 8) + 24 * v7), 24 * v11 - 24 * v7);
  if (a4 != a3)
    memmove((void *)(*(_QWORD *)(a1 + 8) + 24 * v7), a3, v8);
  v12 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) += v10;
  return v12 + 24 * v7;
}

uint64_t lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,lsl::Allocator&,dyld4::FileRecord,lsl::SharedPtr<dyld4::Atlas::Mapper> &,unsigned long long &,unsigned long long>@<X0>(lsl::Allocator *a1@<X0>, uint64_t a2@<X1>, dyld4::FileRecord *a3@<X2>, unsigned int **a4@<X3>, char **a5@<X4>, _QWORD *a6@<X5>, uint64_t *a7@<X8>)
{
  _QWORD *v13;
  uint64_t result;

  v13 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0xB0uLL);
  result = dyld4::Atlas::SharedCache::SharedCache((uint64_t)v13, a2, a3, a4, *a5, *a6 != 0);
  *a7 = result;
  return result;
}

dyld4::FileRecord *dyld4::FileManager::fileRecordForVolumeDevIDAndObjID@<X0>(dyld4::FileManager *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, dyld4::FileRecord *a4@<X8>)
{
  return dyld4::FileRecord::FileRecord(a4, this, a3, a2, 0);
}

dyld4::FileRecord *dyld4::FileRecord::FileRecord(dyld4::FileRecord *this, dyld4::FileManager *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  *((_QWORD *)this + 2) = a4;
  *((_QWORD *)this + 3) = dyld4::FileManager::uuidForFileSystem(a2, a4);
  *((_QWORD *)this + 4) = v7;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = a5;
  *((_QWORD *)this + 8) = 0x1FFFFFFFFLL;
  *((_WORD *)this + 36) = 0;
  *((_BYTE *)this + 74) = 1;
  if (*((_QWORD *)this + 1) && a5 && *((_QWORD *)this + 2))
    *((_DWORD *)this + 17) = 0;
  return this;
}

uint64_t dyld4::FileManager::uuidForFileSystem(dyld4::FileManager *this, unsigned int a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  _BYTE v21[15];
  unsigned __int8 v22;
  _BYTE v23[143];
  unsigned __int8 v24;
  uint64_t v25;
  _OWORD v26[7];
  uint64_t v27;
  _BYTE v28[15];
  unsigned __int8 v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v3 = *((_QWORD *)this + 2);
  *(_QWORD *)&v23[8] = 0;
  *(_QWORD *)&v23[16] = 0;
  v4 = a2;
  *(_QWORD *)v23 = a2;
  lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find(v3, (unint64_t *)v23, (uint64_t)&v12);
  v26[4] = v17;
  v26[5] = v18;
  v26[6] = v19;
  v25 = v12;
  v26[0] = v13;
  v26[1] = v14;
  v26[2] = v15;
  v26[3] = v16;
  *(_QWORD *)&v28[7] = *(_QWORD *)&v21[7];
  v27 = v20;
  *(_QWORD *)v28 = *(_QWORD *)v21;
  v29 = v22;
  v5 = *((_QWORD *)this + 2);
  memset(v23, 0, 135);
  v12 = v5;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0;
  memset(v21, 0, sizeof(v21));
  v22 = 0;
  if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v25, (uint64_t)&v12))
  {
    dyld4::FileManager::reloadFSInfos(this);
    v6 = *((_QWORD *)this + 2);
    v31 = 0;
    v32 = 0;
    v30 = v4;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find(v6, &v30, (uint64_t)&v12);
    *(_OWORD *)&v23[72] = v17;
    *(_OWORD *)&v23[88] = v18;
    *(_OWORD *)&v23[104] = v19;
    *(_QWORD *)v23 = v12;
    *(_OWORD *)&v23[8] = v13;
    *(_OWORD *)&v23[24] = v14;
    *(_OWORD *)&v23[40] = v15;
    *(_OWORD *)&v23[56] = v16;
    *(_QWORD *)&v23[135] = *(_QWORD *)&v21[7];
    *(_QWORD *)&v23[120] = v20;
    *(_QWORD *)&v23[128] = *(_QWORD *)v21;
    v24 = v22;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::swap(&v25, (uint64_t *)v23);
  }
  v7 = *((_QWORD *)this + 2);
  memset(v23, 0, 135);
  v12 = v7;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0;
  memset(v21, 0, sizeof(v21));
  v22 = 0;
  if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v25, (uint64_t)&v12))
  {
    v8 = *((_QWORD *)this + 2);
    *(_QWORD *)&v23[8] = 0;
    *(_QWORD *)&v23[16] = 0;
    *(_QWORD *)v23 = v4;
    lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::insert(v8, (uint64_t)v23, (uint64_t)&v12);
    v9 = *((_QWORD *)this + 2);
    v31 = 0;
    v32 = 0;
    v30 = v4;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find(v9, &v30, (uint64_t)&v12);
    *(_OWORD *)&v23[72] = v17;
    *(_OWORD *)&v23[88] = v18;
    *(_OWORD *)&v23[104] = v19;
    *(_QWORD *)v23 = v12;
    *(_OWORD *)&v23[8] = v13;
    *(_OWORD *)&v23[24] = v14;
    *(_OWORD *)&v23[40] = v15;
    *(_OWORD *)&v23[56] = v16;
    *(_QWORD *)&v23[135] = *(_QWORD *)&v21[7];
    *(_QWORD *)&v23[120] = v20;
    *(_QWORD *)&v23[128] = *(_QWORD *)v21;
    v24 = v22;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::swap(&v25, (uint64_t *)v23);
  }
  v10 = *((_QWORD *)this + 2);
  memset(v23, 0, 135);
  v12 = v10;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0;
  memset(v21, 0, sizeof(v21));
  v22 = 0;
  if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v25, (uint64_t)&v12))dyld4::FileManager::uuidForFileSystem();
  return *(_QWORD *)(*((_QWORD *)v26 + v29 - 1) + 24 * v28[v29 - 1] + 8);
}

uint64_t dyld4::Atlas::ProcessSnapshot::identityMapper(dyld4::Atlas::ProcessSnapshot *this)
{
  return (uint64_t)this + 72;
}

uint64_t dyld4::Atlas::Image::Image(uint64_t a1, uint64_t a2, dyld4::FileRecord *a3, unsigned int **a4, uint64_t a5)
{
  unsigned int *v8;
  unsigned int v9;

  *(_QWORD *)a1 = a2;
  dyld4::FileRecord::FileRecord(a1 + 8, a3);
  v8 = *a4;
  *(_QWORD *)(a1 + 88) = *a4;
  if (v8)
  {
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  *(_BYTE *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 121) = 0u;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 160) = a5;
  *(_DWORD *)(a1 + 183) = 0;
  return a1;
}

uint64_t dyld4::Atlas::ProcessSnapshot::setPlatform(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 80) = a2;
  return this;
}

_QWORD *dyld4::ExternallyViewableState::initOld(_QWORD *a1, lsl::Allocator *this, int a3)
{
  _DWORD *v5;
  _QWORD *v6;
  _QWORD *result;

  v5 = sProcessInfo;
  a1[3] = sProcessInfo;
  v5[80] = a3;
  v6 = lsl::Allocator::malloc(this, 0x20uLL);
  *v6 = this;
  v6[1] = 0;
  v6[2] = 0;
  v6[3] = 0;
  a1[4] = v6;
  result = lsl::Allocator::malloc(this, 0x20uLL);
  *result = this;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  a1[5] = result;
  return result;
}

uint64_t *lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::swap(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  char v8;
  char v9;

  v2 = *result;
  *result = *a2;
  *a2 = v2;
  for (i = 1; i != 16; ++i)
  {
    v4 = result[i];
    result[i] = a2[i];
    a2[i] = v4;
  }
  v5 = 0;
  v6 = result + 16;
  v7 = a2 + 16;
  do
  {
    v8 = *((_BYTE *)v6 + v5);
    *((_BYTE *)v6 + v5) = *((_BYTE *)v7 + v5);
    *((_BYTE *)v7 + v5++) = v8;
  }
  while (v5 != 15);
  v9 = *((_BYTE *)result + 143);
  *((_BYTE *)result + 143) = *((_BYTE *)a2 + 143);
  *((_BYTE *)a2 + 143) = v9;
  return result;
}

char *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::splitChild(uint64_t a1, uint64_t a2, lsl::Allocator *this)
{
  unsigned int v3;
  uint64_t v5;
  uint64_t v6;
  char v7;
  int v8;
  int v9;
  int v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  char *result;
  uint64_t v27;
  uint64_t v28;
  _BYTE *v29;
  int v30;
  __int128 v31;
  char v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  int v39;
  char v40;
  int v41;
  char v42;
  int v43;
  int v44;
  int v45;

  if (*(char *)(a1 + 248) < 0)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild(a1, a2, (uint64_t)this);
  v3 = *(unsigned __int8 *)(a1 + 248);
  if (v3 >= 0xF)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild(a1, a2, (uint64_t)this);
  v5 = a1 + 120;
  v6 = a1 + 120 + 8 * a2;
  v7 = *(_BYTE *)(*(_QWORD *)v6 + 248);
  v8 = v7;
  v9 = v7 & 0x7F;
  if (v7 >= 0)
    v10 = 15;
  else
    v10 = 31;
  if (v9 != v10)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild(a1, a2, (uint64_t)this);
  v12 = *(unsigned __int8 *)(a1 + 248);
  v13 = v12 + 1;
  v14 = a2;
  if (v8 >= 0)
    v15 = 7;
  else
    v15 = 15;
  if (v3 != (_DWORD)a2)
  {
    v16 = (uint64_t *)(a1 + 8 * v12);
    v19 = *v16;
    v17 = v16 - 1;
    v18 = v19;
    v20 = 8 * a2 - 8 * v12;
    do
    {
      v21 = *v17;
      *v17 = v18;
      v17[1] = v21;
      --v17;
      v20 += 8;
    }
    while (v20);
  }
  v22 = (uint64_t *)(a1 + 8 * a2);
  v23 = v5 + 8 * v13;
  if (v23 != v6 + 8)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), v23 - (v6 + 8));
    LOBYTE(v3) = *(_BYTE *)(a1 + 248);
  }
  *(_BYTE *)(a1 + 248) = v3 + 1;
  v24 = (uint64_t *)(*(_QWORD *)v6 + 8 * v15);
  if (v24 != v22)
  {
    v25 = *v22;
    *v22 = *v24;
    *v24 = v25;
  }
  result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  v29 = result;
  v30 = *(char *)(*(_QWORD *)v6 + 248);
  result[248] = *(_BYTE *)(*(_QWORD *)v6 + 248) & 0x80;
  if (v30 < 0)
  {
    *((_QWORD *)result + 30) = 0;
    v31 = 0uLL;
    *((_OWORD *)result + 13) = 0u;
    *((_OWORD *)result + 14) = 0u;
    *((_OWORD *)result + 11) = 0u;
    *((_OWORD *)result + 12) = 0u;
    *((_OWORD *)result + 9) = 0u;
    *((_OWORD *)result + 10) = 0u;
    *((_OWORD *)result + 7) = 0u;
    *((_OWORD *)result + 8) = 0u;
  }
  else
  {
    *((_QWORD *)result + 14) = 0;
    v31 = 0uLL;
  }
  *((_OWORD *)result + 5) = v31;
  *((_OWORD *)result + 6) = v31;
  *((_OWORD *)result + 3) = v31;
  *((_OWORD *)result + 4) = v31;
  *((_OWORD *)result + 1) = v31;
  *((_OWORD *)result + 2) = v31;
  *(_OWORD *)result = v31;
  if (*(char *)(a1 + 248) < 0)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v27, v28);
  v32 = v9 + ~(_BYTE)v15;
  v33 = (uint64_t *)(v5 + 8 * v14);
  v33[1] = (uint64_t)result;
  v34 = *v33;
  if (v32)
  {
    v35 = (uint64_t *)(v34 + 8 * v15 + 8);
    v36 = 8 * (v9 + ~(_BYTE)v15);
    v37 = (uint64_t *)result;
    do
    {
      if (v35 != v37)
      {
        v38 = *v37;
        *v37 = *v35;
        *v35 = v38;
      }
      ++v35;
      ++v37;
      v36 -= 8;
    }
    while (v36);
    v34 = *(_QWORD *)v6;
  }
  v39 = *(char *)(v34 + 248);
  if ((v39 & 0x80000000) == 0)
  {
    if (v30 < 0)
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v27, v28);
    result = (char *)memmove(result + 120, (const void *)(v34 + 8 * v15 + 128), 8 * (v9 + ~(_BYTE)v15) + 8);
    v34 = *(_QWORD *)v6;
    LOBYTE(v39) = *(_BYTE *)(*(_QWORD *)v6 + 248);
  }
  *(_BYTE *)(v34 + 248) = v39 + ~v32;
  v40 = v29[248] + v32;
  v29[248] = v40;
  if (v40 >= 0)
    v41 = 15;
  else
    v41 = 31;
  if ((v40 & 0x7F) == v41
    || ((v42 = *(_BYTE *)(v34 + 248), v43 = v42, v44 = v42 & 0x7F, v43 >= 0) ? (v45 = 15) : (v45 = 31), v44 == v45))
  {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)result, v27, v28);
  }
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::NodeCore(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = 0;
  *(_BYTE *)(result + 248) = 0;
  do
  {
    *(_QWORD *)(result + v3) = 0;
    v3 += 8;
  }
  while (v3 != 120);
  if (*(char *)(result + 248) < 0)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
  *(_QWORD *)(result + 120) = a2;
  return result;
}

DyldSharedCache *dyld4::APIs::_dyld_shared_cache_real_path(DyldSharedCache ***this, const char *a2)
{
  DyldSharedCache *v4;
  DyldSharedCache *v5;

  v4 = dyld4::ProcessConfig::canonicalDylibPathInCache(this[1], a2);
  v5 = v4;
  if (*((_BYTE *)this[1] + 204))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_shared_cache_real_path(%s) => '%s'\n", a2, (const char *)v4);
  return v5;
}

void dyld4::RuntimeState::notifyDebuggerLoad(lsl::AllocatorLayout *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  size_t v13;
  lsl::AllocatorLayout *v14;
  char *v15;
  const char **v16;
  const char **v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  lsl::Allocator *v27;
  size_t v28;
  uint64_t v29;
  lsl::AllocatorLayout *v30;
  uint64_t v31;
  const char **v32;
  const char **v33;
  lsl::Allocator *v34;
  uint64_t v35;
  dyld4::Loader **v36;
  uint64_t v37;
  dyld4::Loader *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t Address;
  int v43;
  uint64_t v44;
  uint64_t v45;
  lsl::Allocator *v46;
  lsl::Allocator *v47;
  lsl::AllocatorLayout *v48;
  int8x16_t v49[2];
  lsl::Allocator *v50;
  int8x16_t v51;
  uint64_t v52;

  v4 = lsl::AllocatorLayout::minSize(a1);
  __chkstk_darwin(v4, v4, v5, v6, v7, v8, v9, v10, (uint64_t)v48);
  v12 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v12, v13);
  v15 = (char *)lsl::AllocatorLayout::minSize(v14);
  v48 = (lsl::AllocatorLayout *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v12, v15, v16, v17);
  v18 = *(_QWORD *)(a2 + 8);
  v19 = lsl::AllocatorLayout::minSize(v48);
  __chkstk_darwin(v19, v19 + 40 * v18 + 64, v20, v21, v22, v23, v24, v25, (uint64_t)v48);
  v27 = (lsl::Allocator *)((char *)&v48 - v26);
  bzero((char *)&v48 - v26, v28);
  v29 = *(_QWORD *)(a2 + 8);
  v31 = lsl::AllocatorLayout::minSize(v30);
  v34 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v27, (char *)(v31 + 40 * v29 + 64), v32, v33);
  v50 = v34;
  v51 = 0uLL;
  v52 = 0;
  lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserveExact((uint64_t)&v50, *(_QWORD *)(a2 + 8));
  v35 = *(_QWORD *)(a2 + 8);
  if (v35)
  {
    v36 = *(dyld4::Loader ***)a2;
    v37 = 8 * v35;
    do
    {
      v38 = *v36;
      if (*v36 != *((dyld4::Loader **)a1 + 3))
      {
        if ((*((_WORD *)v38 + 2) & 2) != 0)
        {
          v40 = 0;
          v39 = 0;
        }
        else
        {
          dyld4::Loader::fileID(*v36, v49);
          v39 = v49[0].i64[1];
          v40 = v49[0].i64[0];
        }
        v41 = dyld4::Loader::path(v38, a1);
        Address = dyld4::Loader::loadAddress(v38, a1);
        v43 = (*((unsigned __int8 *)v38 + 4) >> 1) & 1;
        lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserve((uint64_t)&v50, v51.i64[1] + 1);
        v44 = v51.i64[1]++;
        v45 = v51.i64[0] + 40 * v44;
        *(_QWORD *)v45 = v39;
        *(_QWORD *)(v45 + 8) = v40;
        *(_QWORD *)(v45 + 16) = v41;
        *(_QWORD *)(v45 + 24) = Address;
        *(_BYTE *)(v45 + 32) = v43;
      }
      ++v36;
      v37 -= 8;
    }
    while (v37);
  }
  v46 = v48;
  if (v51.i64[1])
  {
    v47 = (lsl::Allocator *)*((_QWORD *)a1 + 2);
    v49[0] = v51;
    dyld4::ExternallyViewableState::addImages((uint64_t)a1 + 568, v47, v48, v49[0].i64);
  }
  if (v51.i64[0])
    lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::resize((const os_unfair_lock *)&v50, 0);
  lsl::Allocator::~Allocator(v34);
  lsl::Allocator::~Allocator(v46);
}

uint64_t lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserve(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  if (*(_QWORD *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      v2 = 16;
    }
    return lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserveExact(result, v2);
  }
  return result;
}

unint64_t dyld4::APIs::dlopen_from(dyld4::RuntimeLocks **this, dyld4::Loader *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v9;
  dyld4::RuntimeLocks *v12;
  uint64_t v13;
  int v14;
  dyld4::RuntimeLocks *v15;
  DyldSharedCache *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL8 isInitialized;
  const char *v21;
  uint64_t v22;
  unint64_t v23;
  dyld4::Loader *v24;
  dyld4::RuntimeLocks *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  size_t v35;
  lsl::AllocatorLayout *v36;
  uint64_t v37;
  const char **v38;
  const char **v39;
  lsl::AllocatorLayout *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  size_t v50;
  lsl::AllocatorLayout *v51;
  uint64_t v52;
  const char **v53;
  const char **v54;
  lsl::Allocator *v55;
  dyld4::RuntimeLocks *v56;
  lsl::Lock *v57;
  uint64_t v58;
  uint64_t v59;
  lsl::AllocatorLayout *v60;
  uint64_t v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  size_t v77;
  lsl::AllocatorLayout *v78;
  uint64_t v79;
  const char **v80;
  const char **v81;
  lsl::Lock *v82;
  lsl::AllocatorLayout *v83;
  uint64_t v84;
  uint64_t v85;
  char v86;
  uint64_t v87;
  uint64_t *v88;
  uint64_t v89;
  _QWORD *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  size_t v100;
  lsl::AllocatorLayout *v101;
  uint64_t v102;
  const char **v103;
  const char **v104;
  lsl::Allocator *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t (***v117)(char *);
  const char *v118;
  char *v119;
  uint64_t v120;
  uint64_t v121;
  const char *v122;
  uint64_t v123;
  const char *v124;
  lsl::Lock *v126;
  dyld4::RuntimeLocks *v127;
  int v128;
  lsl::Allocator *v129;
  lsl::Allocator *v130;
  lsl::Allocator *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  lsl::Lock *v135;
  _QWORD *v136;
  uint64_t v137;
  uint64_t v138;
  _QWORD v139[9];
  lsl::Allocator *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  lsl::Allocator *v144;
  lsl::Lock *v145;
  _QWORD *v146;
  uint64_t v147;
  dyld4::Loader *v148;
  unint64_t v149;
  lsl::AllocatorLayout *ImageContaining;
  unsigned __int8 v151;
  int v152;
  uint64_t v153;
  dyld4::Loader *v154;
  uint64_t v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  int v161;
  dyld4::Loader *v162;

  v9 = a3;
  v162 = a2;
  v161 = a3;
  v152 = 520617984;
  v153 = 0;
  v154 = a2;
  v155 = (int)a3;
  v156 = 0u;
  v157 = 0u;
  v158 = 0u;
  v159 = 0u;
  v160 = 0u;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v152, (uint64_t)a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (*((_BYTE *)this[1] + 204))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "dlopen(\"%s\", 0x%08X)\n", (const char *)a2, v9);
  if (this[143] != (dyld4::RuntimeLocks *)-1)
  {
    v12 = this[19];
    if (v12)
    {
      v13 = (*(uint64_t (**)(dyld4::RuntimeLocks *))(*(_QWORD *)v12 + 64))(v12);
      if (v13)
        *(_BYTE *)(v13 + 8) = 0;
    }
  }
  v14 = v161;
  v151 = BYTE1(v161) & 1;
  if (!v162)
  {
    if ((v161 & 0x100) != 0)
      v23 = -5;
    else
      v23 = -2;
    goto LABEL_81;
  }
  v15 = this[124];
  if (v15)
  {
    LODWORD(v144) = 0;
    v16 = dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)this[1] + 30, (const char *)v162, (unsigned int *)&v144);
    if ((_DWORD)v16)
    {
      if (*((_DWORD *)v15 + 3) <= (unsigned __int16)v144)
        dyld4::RuntimeState::findPrebuiltLoader((uint64_t)v16, v17, v18);
      v19 = (uint64_t)v15 + *(unsigned int *)((char *)v15 + 4 * (unsigned __int16)v144 + *((unsigned int *)v15 + 4));
      isInitialized = dyld4::PrebuiltLoader::isInitialized(v19, (uint64_t)this);
      if (isInitialized)
      {
        if ((v19 & 1) != 0)
          dyld4::APIs::dlopen_from(isInitialized, (uint64_t)v21, v22);
        v23 = v19 ^ (unint64_t)&dword_1A5C55000 | v151;
        if (*((_BYTE *)this[1] + 204))
        {
          v24 = dyld4::Loader::leafName(v162, v21);
          dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "      dlopen(%s) => %p\n", (const char *)v24, (const void *)v23);
        }
        *((_QWORD *)&v157 + 1) = v23;
        *(_QWORD *)&v158 = 0;
        goto LABEL_81;
      }
    }
    v14 = v161;
  }
  v25 = this[17];
  if ((v14 & 0x10) == 0)
    dyld4::RuntimeLocks::takeDlopenLockBeforeFork(this[17]);
  ImageContaining = 0;
  ImageContaining = (lsl::AllocatorLayout *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a4);
  v148 = 0;
  v149 = 0;
  v26 = lsl::AllocatorLayout::minSize(ImageContaining);
  __chkstk_darwin(v26, v26 + 1088, v27, v28, v29, v30, v31, v32, (uint64_t)v126);
  v34 = (char *)&v126 - ((v33 + 1103) & 0xFFFFFFFFFFFFFFF0);
  bzero(v34, v35);
  v37 = lsl::AllocatorLayout::minSize(v36);
  v130 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v34, (char *)(v37 + 1088), v38, v39);
  v144 = v130;
  v145 = 0;
  v146 = 0;
  v147 = 0;
  v40 = (lsl::AllocatorLayout *)lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v144, 0x80uLL);
  v41 = lsl::AllocatorLayout::minSize(v40);
  __chkstk_darwin(v41, v41 + 192, v42, v43, v44, v45, v46, v47, (uint64_t)v126);
  v49 = (char *)&v126 - ((v48 + 207) & 0xFFFFFFFFFFFFFFF0);
  bzero(v49, v50);
  v52 = lsl::AllocatorLayout::minSize(v51);
  v55 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v49, (char *)(v52 + 192), v53, v54);
  v140 = v55;
  v141 = 0;
  v142 = 0;
  v143 = 0;
  lsl::Vector<dyld4::RuntimeState::DynamicReference>::reserveExact((uint64_t)&v140, 8uLL);
  v57 = this[16];
  v56 = this[17];
  v139[0] = this;
  v139[1] = &ImageContaining;
  v139[2] = &v161;
  v139[3] = &v148;
  v139[4] = &v162;
  v139[5] = &v149;
  v139[6] = &v151;
  v139[7] = &v140;
  v139[8] = &v144;
  lsl::MemoryManager::lockGuard(v57, &v135);
  v58 = *((_QWORD *)v57 + 3);
  if (!v58)
  {
    lsl::MemoryManager::writeProtect(v57, 0);
    v58 = *((_QWORD *)v57 + 3);
  }
  *((_QWORD *)v57 + 3) = v58 + 1;
  lsl::Lock::unlock(v135);
  if (*(_QWORD *)v56)
  {
    (*(void (**)(_QWORD, _QWORD *, _QWORD))(**(_QWORD **)v56 + 104))(*(_QWORD *)v56, (_QWORD *)v56 + 1, 0);
    dyld4::APIs::dlopen_from(char const*,int,void *)::$_0::operator()((uint64_t)v139);
    (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)v56 + 112))(*(_QWORD *)v56, (_QWORD *)v56 + 1);
  }
  else
  {
    dyld4::APIs::dlopen_from(char const*,int,void *)::$_0::operator()((uint64_t)v139);
  }
  lsl::MemoryManager::lockGuard(v57, &v135);
  v59 = *((_QWORD *)v57 + 3) - 1;
  *((_QWORD *)v57 + 3) = v59;
  if (!v59)
    lsl::MemoryManager::writeProtect(v57, 1);
  v60 = (lsl::AllocatorLayout *)lsl::Lock::unlock(v135);
  if (!v142)
    goto LABEL_60;
  v129 = v55;
  v68 = lsl::AllocatorLayout::minSize(v60);
  __chkstk_darwin(v68, v68 + 128, v69, v70, v71, v72, v73, v74, (uint64_t)v126);
  v76 = (char *)&v126 - ((v75 + 143) & 0xFFFFFFFFFFFFFFF0);
  bzero(v76, v77);
  v79 = lsl::AllocatorLayout::minSize(v78);
  v82 = (lsl::Lock *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v76, (char *)(v79 + 128), v80, v81);
  v135 = v82;
  v136 = 0;
  v137 = 0;
  v138 = 0;
  v83 = (lsl::AllocatorLayout *)lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v135, 8uLL);
  v84 = v142;
  if (!v142)
    goto LABEL_57;
  v126 = v82;
  v127 = v25;
  v128 = v14;
  v85 = 0;
  v86 = 0;
  while (1)
  {
    v87 = v141;
    v88 = (uint64_t *)(v141 + 16 * v85);
    if (v137)
    {
      v89 = 8 * v137;
      v90 = v136;
      while (*v90 != *v88)
      {
        ++v90;
        v89 -= 8;
        if (!v89)
        {
          v90 = &v136[v137];
          break;
        }
      }
    }
    else
    {
      v90 = v136;
    }
    if (v137 == v90 - v136)
      break;
    v109 = v85 + 1;
LABEL_54:
    v85 = v109;
    if (v109 == v84)
      goto LABEL_55;
  }
  v91 = lsl::AllocatorLayout::minSize(v83);
  __chkstk_darwin(v91, v91 + 128, v92, v93, v94, v95, v96, v97, (uint64_t)v126);
  v99 = (char *)&v126 - ((v98 + 143) & 0xFFFFFFFFFFFFFFF0);
  bzero(v99, v100);
  v102 = lsl::AllocatorLayout::minSize(v101);
  v105 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v99, (char *)(v102 + 128), v103, v104);
  v131 = v105;
  v133 = 0;
  v134 = 0;
  v132 = 0;
  lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v131, 8uLL);
  lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v131, v133 + 1);
  v106 = *(_QWORD *)(v87 + 16 * v85 + 8);
  v107 = v133;
  v108 = ++v133;
  *(_QWORD *)(v132 + 8 * v107) = v106;
  v109 = v85 + 1;
  v110 = v142;
  if (v85 + 1 != v142)
  {
    v111 = 16 * v85;
    v112 = v109;
    do
    {
      v113 = v141 + v111;
      if (*(_QWORD *)(v141 + v111 + 16) == *v88)
      {
        lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v131, v108 + 1);
        v114 = *(_QWORD *)(v113 + 24);
        v115 = v133;
        v108 = ++v133;
        *(_QWORD *)(v132 + 8 * v115) = v114;
        v110 = v142;
      }
      ++v112;
      v111 += 16;
    }
    while (v112 != v110);
  }
  v116 = *v88;
  if ((*(_WORD *)(*v88 + 4) & 1) != 0)
    v116 = 0;
  v117 = *(uint64_t (****)(char *))(v116 + 104);
  v118 = (const char *)dyld4::PseudoDylib::finalizeRequestedSymbols(v117, v132, v108);
  v119 = (char *)v118;
  if (v118)
  {
    dyld4::APIs::setErrorString((vm_address_t *)this, "dlopen(%s, 0x%04X): %s", (const char *)v162, v161, v118);
    dyld4::PseudoDylib::disposeString(v117, v119);
    v86 = 1;
  }
  else
  {
    lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v135, v137 + 1);
    v120 = *v88;
    v121 = v137++;
    v136[v121] = v120;
  }
  if (v132)
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v131, 0);
  lsl::Allocator::~Allocator(v105);
  if (!v119)
  {
    v84 = v142;
    goto LABEL_54;
  }
LABEL_55:
  LOBYTE(v14) = v128;
  v82 = v126;
  v25 = v127;
  if ((v86 & 1) != 0)
  {
    v148 = 0;
    v149 = 0;
  }
LABEL_57:
  if (v136)
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v135, 0);
  lsl::Allocator::~Allocator(v82);
  v55 = v129;
LABEL_60:
  if (v148 && (v161 & 0x10) == 0)
  {
    if (v146)
    {
      v135 = v145;
      v136 = v146;
      dyld4::RuntimeState::notifyLoad((const dyld4::RuntimeState *)this, (uint64_t)&v135, v62, v63, v64, v65, v66, v67);
    }
    if (*((_BYTE *)this + 680))
    {
      v60 = (lsl::AllocatorLayout *)dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(v148, (dyld4::RuntimeState *)this);
    }
    else if (*((_BYTE *)this[1] + 203))
    {
      v122 = (const char *)dyld4::Loader::path(v148, (const dyld4::RuntimeState *)this);
      dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "dlopen() within libSystem's initializer, so skipping initialization of %s\n", v122);
    }
    if ((v148 & 1) != 0)
      dyld4::APIs::dlopen_from((uint64_t)v60, v61, (uint64_t)v62);
    v149 = (unint64_t)v148 ^ (unint64_t)&dword_1A5C55000 | v151;
  }
  if (*((_BYTE *)this[1] + 204))
  {
    v123 = (*(uint64_t (**)(dyld4::RuntimeLocks *, dyld4::RuntimeLocks *))(*(_QWORD *)this[19] + 64))(this[19], this[143]);
    if (v123 && *(_BYTE *)(v123 + 8))
    {
      dyld4::Loader::leafName(v162, v124);
      dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "      dlopen(%s) => NULL, '%s'\n");
    }
    else
    {
      dyld4::Loader::leafName(v162, v124);
      dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "      dlopen(%s) => %p\n");
    }
  }
  v23 = v149;
  *((_QWORD *)&v157 + 1) = v149;
  *(_QWORD *)&v158 = 0;
  if (v141)
    lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize((const os_unfair_lock *)&v140, 0);
  lsl::Allocator::~Allocator(v55);
  if (v145)
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v144, 0);
  lsl::Allocator::~Allocator(v130);
  if ((v14 & 0x10) == 0)
    dyld4::RuntimeLocks::releaseDlopenLockInForkParent(v25);
LABEL_81:
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v152);
  return v23;
}

BOOL dyld4::PrebuiltLoader::isInitialized(uint64_t a1, uint64_t a2)
{
  __int16 v2;
  _QWORD *v3;

  v2 = *(_WORD *)(a1 + 6);
  if (v2 >= 0)
    v3 = (_QWORD *)(a2 + 1000);
  else
    v3 = (_QWORD *)(a2 + 1024);
  return *(_BYTE *)(*v3 + (v2 & 0x7FFF)) == 9;
}

vm_address_t *Diagnostics::clearError(vm_address_t **this)
{
  vm_address_t *result;

  result = *this;
  if (result)
    result = _simple_sfree(result);
  *this = 0;
  return result;
}

kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  kern_return_t v6;
  uint64_t reply_port;
  kern_return_t v8;
  mach_msg_header_t v11;
  uint64_t v12;
  mach_vm_address_t v13;
  mach_vm_size_t v14;

  v6 = _kernelrpc_mach_vm_deallocate_trap(target, address, size);
  if (v6 == 268435459)
  {
    v12 = 0x100000000;
    v13 = address;
    v14 = size;
    reply_port = mig_get_reply_port();
    *(_QWORD *)&v11.msgh_bits = 0x3000001513;
    *(_QWORD *)&v11.msgh_remote_port = __PAIR64__(reply_port, target);
    *(_QWORD *)&v11.msgh_voucher_port = 0x12C100000000;
    v8 = mach_msg2_internal(&v11, 0x200000003uLL, (void *)0x3000001513, (void *)__PAIR64__(reply_port, target), (void *)0x12C100000000, (void *)(reply_port << 32), (void *)0x2C, 0);
    v6 = v8;
    if ((v8 - 268435458) > 0xE || ((1 << (v8 - 2)) & 0x4003) == 0)
    {
      if (v8)
      {
        mig_dealloc_reply_port(v11.msgh_local_port);
        return v6;
      }
      if (v11.msgh_id == 71)
      {
        v6 = -308;
      }
      else if (v11.msgh_id == 4901)
      {
        v6 = -300;
        if ((v11.msgh_bits & 0x80000000) == 0 && *(_QWORD *)&v11.msgh_size == 36)
        {
          v6 = v13;
          if (!(_DWORD)v13)
            return v6;
        }
      }
      else
      {
        v6 = -301;
      }
      mach_msg_destroy(&v11);
    }
  }
  return v6;
}

vm_address_t *_simple_sfree(vm_address_t *address)
{
  vm_address_t v1;
  uint64_t v2;

  if (address)
  {
    v1 = (vm_address_t)address;
    if (((vm_page_size - 1) & *address) != 0)
    {
      v2 = address[2] - (_QWORD)address + 1;
    }
    else
    {
      vm_deallocate(mach_task_self_, *address, address[2] - *address + 1);
      v2 = vm_page_size;
    }
    return (vm_address_t *)vm_deallocate(mach_task_self_, v1, v2);
  }
  return address;
}

dyld4::Loader *dyld4::Loader::getLoader(vm_address_t **a1, DyldSharedCache ***a2, const char *a3, uint64_t a4)
{
  char *v5;
  DyldSharedCache **v8;
  vm_address_t **v9;
  int v10;
  int v11;
  int v12;
  _BOOL4 v13;
  DyldSharedCache *v14;
  const char *v15;
  unsigned int v16;
  _BOOL4 isOverridablePath;
  dyld4::SyscallDelegate *v18;
  char v19;
  vm_address_t **v20;
  uint64_t v21;
  DyldSharedCache ***v22;
  DyldSharedCache **v23;
  dyld4::Loader **v24;
  uint64_t v25;
  dyld4::Loader *v26;
  const char *v27;
  uint64_t v28;
  DyldSharedCache ***v29;
  DyldSharedCache **v30;
  dyld4::Loader **v31;
  uint64_t v32;
  dyld4::Loader *v33;
  const char *v34;
  size_t v35;
  size_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  DyldSharedCache ***v47;
  DyldSharedCache **v48;
  dyld4::Loader **v49;
  uint64_t v50;
  size_t v51;
  uint64_t Loader;
  uint64_t *v53;
  uint64_t **v54;
  _DWORD *v55;
  const char *v56;
  uint64_t v58;
  vm_address_t **v59;
  uint64_t *v60;
  _BOOL4 v61;
  _QWORD v62[5];
  _QWORD v63[10];
  char v64;
  char v65;
  BOOL v66;
  _QWORD v67[3];
  unsigned int v68;
  uint64_t v69;
  uint64_t *v70;
  uint64_t v71;
  uint64_t v72;
  DyldSharedCache ***v73;
  DyldSharedCache ****v74;
  uint64_t v75;
  char v76;

  v5 = (char *)a3;
  v69 = 0;
  v70 = &v69;
  v71 = 0x2000000000;
  v72 = 0;
  v8 = a2[1];
  if (v8[30])
    LODWORD(v9) = *((_BYTE *)v8 + 396) == 0;
  else
    LODWORD(v9) = 0;
  if (*((_BYTE *)v8 + 208))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "find path \"%s\"\n", a3);
  v10 = _platform_strncmp(v5, "@rpath/", 7uLL);
  v11 = *v5;
  if (v11 == 47)
  {
    v13 = 0;
    if (!v10)
      goto LABEL_38;
  }
  else if (v11 == 46 && ((v12 = v5[1], v12 == 47) || v12 == 46 && v5[2] == 47))
  {
    v13 = 1;
    if (!v10)
    {
LABEL_38:
      v61 = v13;
      LODWORD(v60) = (_DWORD)v9;
      v9 = a1;
      v28 = 0;
      v73 = a2 + 4;
      v74 = (DyldSharedCache ****)(a2 + 8);
      while (1)
      {
        v29 = (&v73)[v28];
        v30 = v29[2];
        if (v30)
          break;
LABEL_43:
        if (++v28 == 2)
        {
          a1 = v9;
          LOBYTE(v9) = (_BYTE)v60;
          goto LABEL_45;
        }
      }
      v31 = v29[1];
      v32 = 8 * (_QWORD)v30;
      while (1)
      {
        v33 = *v31;
        if (dyld4::Loader::matchesPath(*v31, (const dyld4::RuntimeState *)a2, v5))
          break;
        ++v31;
        v32 -= 8;
        if (!v32)
          goto LABEL_43;
      }
      if (*((_BYTE *)a2[1] + 208))
      {
        v34 = (const char *)dyld4::Loader::path(v33, (const dyld4::RuntimeState *)a2);
        dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  found: already-loaded-by-rpath: %s\n", v34);
      }
      goto LABEL_89;
    }
  }
  else
  {
    v13 = v11 != 64;
    if (!v10)
      goto LABEL_38;
  }
  if (*(_BYTE *)(a4 + 1) || v11 == 47 || v11 == 64 || _platform_strchr(v5, 47))
  {
LABEL_15:
    v14 = dyld4::ProcessConfig::canonicalDylibPathInCache(a2[1], v5);
    if (v14)
    {
      v15 = (const char *)v14;
      if (_platform_strcmp((const char *)v14, v5))
      {
        if (*((_BYTE *)a2[1] + 208))
          dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  switch to canonical cache path: %s\n", v15);
        v5 = (char *)v15;
      }
    }
    v67[0] = 0;
    v67[1] = v67;
    v67[2] = 0x2000000000;
    v68 = 0;
    v16 = dyld4::ProcessConfig::DyldCache::indexOfPath(a2[1] + 30, v5, &v68);
    isOverridablePath = 0;
    if (v16)
      isOverridablePath = dyld4::ProcessConfig::DyldCache::isOverridablePath((dyld4::ProcessConfig::DyldCache *)(a2[1] + 30), v5);
    v63[0] = _NSConcreteStackBlock;
    v63[1] = 0x40000000;
    v63[2] = ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke;
    v63[3] = &unk_1E4F7CD70;
    v64 = (char)v9;
    v65 = v16;
    v66 = isOverridablePath;
    v63[6] = v5;
    v63[7] = a2;
    v63[8] = a4;
    v63[9] = a1;
    v63[4] = &v69;
    v63[5] = v67;
    dyld4::Loader::forEachPath(isOverridablePath, (uint64_t)a2, (dyld4::Utils *)v5, a4, (uint64_t)v63);
    if (!v70[3])
    {
      v18 = (dyld4::SyscallDelegate *)a2[1];
      v19 = !v13;
      if (*((_BYTE *)v18 + 186))
        v19 = 1;
      if ((v19 & 1) != 0)
      {
        if ((*(_BYTE *)(a4 + 1) || _platform_strchr(v5, 47))
          && *v5 != 64
          && dyld4::SyscallDelegate::realpath(v18, (dyld3 *)v5, (char *)&v73))
        {
          v51 = _platform_strlen((const char *)&v73);
          if (_platform_strncmp(v5, (const char *)&v73, v51))
          {
            if (*((_BYTE *)a2[1] + 208))
              dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  switch to realpath: \"%s\"\n", (const char *)&v73);
            Loader = dyld4::Loader::getLoader(a1, a2, &v73, a4);
            v70[3] = Loader;
          }
        }
      }
      else
      {
        v20 = a1;
        v21 = 0;
        v73 = a2 + 4;
        v74 = (DyldSharedCache ****)(a2 + 8);
        do
        {
          v22 = (&v73)[v21];
          v23 = v22[2];
          if (v23)
          {
            v24 = v22[1];
            v25 = 8 * (_QWORD)v23;
            while (1)
            {
              v26 = *v24;
              if (dyld4::Loader::matchesPath(*v24, (const dyld4::RuntimeState *)a2, v5))
                break;
              ++v24;
              v25 -= 8;
              if (!v25)
                goto LABEL_35;
            }
            if (*((_BYTE *)a2[1] + 208))
            {
              v27 = (const char *)dyld4::Loader::path(v26, (const dyld4::RuntimeState *)a2);
              dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  found existing image by install name: \"%s\"\n", v27);
            }
            v70[3] = (uint64_t)v26;
            Diagnostics::clearError(v20);
          }
LABEL_35:
          ++v21;
        }
        while (v21 != 2);
        a1 = v20;
      }
    }
    v53 = v70;
    if (*((_BYTE *)a2[1] + 208) && !v70[3])
    {
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  not found: \"%s\"\n", v5);
      v53 = v70;
    }
    if (!v53[3])
    {
      if (*v5 != 64
        || *((_BYTE *)a2[1] + 184)
        || (Diagnostics::appendError((vm_address_t *)a1, ", (security policy does not allow @ path expansion)"), !v70[3]))
      {
        if (*(unsigned __int8 *)(a4 + 2) | *(unsigned __int8 *)(a4 + 5))
        {
          Diagnostics::clearError(a1);
        }
        else if (Diagnostics::noError((Diagnostics *)a1) && !_platform_strncmp(v5, "@rpath/", 7uLL))
        {
          v73 = 0;
          v74 = &v73;
          v75 = 0x2000000000;
          v76 = 0;
          v54 = *(uint64_t ***)(a4 + 16);
          if (v54)
          {
            while (!*((_BYTE *)v74 + 24))
            {
              v55 = (_DWORD *)dyld4::Loader::mf((dyld4::Loader *)v54[1], (const dyld4::RuntimeState *)a2);
              v62[0] = _NSConcreteStackBlock;
              v62[1] = 0x40000000;
              v62[2] = ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke_2;
              v62[3] = &unk_1E4F7CD98;
              v62[4] = &v73;
              dyld3::MachOFile::forEachRPath(v55, (uint64_t)v62);
              v54 = (uint64_t **)*v54;
              if (!v54)
              {
                if (!*((_BYTE *)v74 + 24))
                  goto LABEL_86;
                break;
              }
            }
            Diagnostics::error((vm_address_t *)a1, "no LC_RPATH's used.  They may be invalid, eg, not start with '@loader_path' or '@executable_path'");
          }
          else
          {
LABEL_86:
            Diagnostics::error((vm_address_t *)a1, "no LC_RPATH's found");
          }
          _Block_object_dispose(&v73, 8);
        }
      }
    }
    v33 = (dyld4::Loader *)v70[3];
    _Block_object_dispose(v67, 8);
  }
  else
  {
    v61 = v13;
    v59 = a1;
    v35 = _platform_strlen(v5);
    v60 = &v58;
    v36 = v35 + 8;
    __chkstk_darwin(v35, v37, v38, v39, v40, v41, v42, v43, v58);
    v45 = (char *)&v58 - ((v44 + 23) & 0xFFFFFFFFFFFFFFF0);
    strlcpy(v45, "@rpath/", v36);
    strlcat(v45, v5, v36);
    v46 = 0;
    v73 = a2 + 4;
    v74 = (DyldSharedCache ****)(a2 + 8);
    while (1)
    {
      v47 = (&v73)[v46];
      v48 = v47[2];
      if (v48)
        break;
LABEL_56:
      if (++v46 == 2)
      {
        a1 = v59;
LABEL_45:
        LOBYTE(v13) = v61;
        goto LABEL_15;
      }
    }
    v49 = v47[1];
    v50 = 8 * (_QWORD)v48;
    while (1)
    {
      v33 = *v49;
      if (dyld4::Loader::matchesPath(*v49, (const dyld4::RuntimeState *)a2, v45))
        break;
      ++v49;
      v50 -= 8;
      if (!v50)
        goto LABEL_56;
    }
    if (*((_BYTE *)a2[1] + 208))
    {
      v56 = (const char *)dyld4::Loader::path(v33, (const dyld4::RuntimeState *)a2);
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  found: already-loaded-by-rpath: %s\n", v56);
    }
  }
LABEL_89:
  _Block_object_dispose(&v69, 8);
  return v33;
}

BOOL dyld4::ProcessConfig::DyldCache::isOverridablePath(dyld4::ProcessConfig::DyldCache *this, const char *__s1)
{
  return *((_BYTE *)this + 156) || _platform_strcmp(__s1, "/usr/lib/system/libdispatch.dylib") == 0;
}

DyldSharedCache *dyld4::ProcessConfig::DyldCache::getCanonicalPath(DyldSharedCache **this, const char *a2)
{
  DyldSharedCache *result;
  unsigned int v4;

  result = *this;
  if (result)
  {
    v4 = 0;
    if (DyldSharedCache::hasImagePath(result, a2, &v4))
      return (DyldSharedCache *)DyldSharedCache::getIndexedImagePath(*this, v4);
    else
      return 0;
  }
  return result;
}

DyldSharedCache *dyld4::ProcessConfig::canonicalDylibPathInCache(DyldSharedCache **this, const char *a2)
{
  return dyld4::ProcessConfig::DyldCache::getCanonicalPath(this + 30, a2);
}

uint64_t DyldSharedCache::getIndexedImagePath(DyldSharedCache *this, int a2)
{
  uint64_t v2;

  v2 = 24;
  if (*((_DWORD *)this + 4) > 0x1C3u)
    v2 = 448;
  return (uint64_t)this + *(unsigned int *)((char *)this + 32 * a2 + *(unsigned int *)((char *)this + v2) + 24);
}

void dyld4::Loader::forEachPath(int a1, uint64_t a2, dyld4::Utils *__s, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t *v12;
  const char *v13;
  const char *v14;
  int v15;
  _QWORD v16[9];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  char v20;

  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  v9 = *(_QWORD *)(a2 + 8);
  if (*(_BYTE *)(a4 + 1))
  {
    v10 = 0;
    v11 = *(_QWORD *)(a2 + 8);
    v12 = &v17;
  }
  else if (_platform_strchr((char *)__s, 47))
  {
    v10 = dyld4::ProcessConfig::PathOverrides::getFrameworkPartialPath((dyld4::ProcessConfig::PathOverrides *)(v9 + 400), __s, v13) == 0;
    v11 = *(_QWORD *)(a2 + 8);
    v12 = v18;
  }
  else
  {
    v10 = 0;
    v12 = &v17;
    v11 = v9;
  }
  v14 = (const char *)*(unsigned int *)(v11 + 68);
  v15 = *(unsigned __int8 *)(a4 + 11);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  v16[2] = ___ZN5dyld46Loader11forEachPathER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsEU13block_pointerFvS6_NS_13ProcessConfig13PathOverrides4TypeERbE_block_invoke;
  v16[3] = &unk_1E4F7CD48;
  v16[6] = a4;
  v16[7] = __s;
  v16[8] = a2;
  v16[4] = a5;
  v16[5] = &v17;
  dyld4::ProcessConfig::PathOverrides::forEachPathVariant(v9 + 400, __s, v14, v15, v10, (_BYTE *)v12 + 24, (uint64_t)v16);
  _Block_object_dispose(&v17, 8);
}

const char *dyld4::ProcessConfig::PathOverrides::forEachPathVariant(uint64_t a1, dyld4::Utils *a2, const char *a3, int a4, int a5, _BYTE *a6, uint64_t a7)
{
  unsigned int v10;
  const char *result;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  const char *v26;
  uint64_t v27;
  size_t v28;
  int v29;
  size_t v30;
  size_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  size_t v41;
  size_t v42;
  size_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  size_t v53;
  size_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  size_t v65;
  size_t v66;
  size_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  char *v81;
  const char *v82;
  size_t v83;
  size_t v84;
  size_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  char *v95;
  _BYTE *v96;
  int v97;
  _QWORD v98[10];
  _QWORD v99[10];
  _QWORD v100[9];
  _QWORD v101[9];

  v97 = a5;
  v10 = a3;
  result = (const char *)dyld4::ProcessConfig::PathOverrides::getFrameworkPartialPath((dyld4::ProcessConfig::PathOverrides *)a1, a2, a3);
  v14 = result;
  if (result)
  {
    v15 = *(_QWORD *)(a1 + 8);
    v16 = *(_QWORD *)(a1 + 56);
    if (!(v15 | v16))
      goto LABEL_10;
    v101[0] = _NSConcreteStackBlock;
    v101[1] = 0x40000000;
    v101[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke;
    v101[3] = &unk_1E4F7C190;
    v101[6] = _platform_strlen(result);
    v101[7] = v14;
    v101[8] = a6;
    v101[4] = a7;
    v101[5] = a1;
    v17 = v101;
    v18 = v15;
    v19 = v16;
  }
  else
  {
    v20 = *(_QWORD *)a1;
    v21 = *(_QWORD *)(a1 + 48);
    if (!(*(_QWORD *)a1 | v21))
      goto LABEL_10;
    v22 = strrchr((char *)a2, 47);
    v96 = a6;
    v23 = a7;
    v24 = v10;
    v25 = a4;
    if (v22)
      v26 = v22 + 1;
    else
      v26 = (const char *)a2;
    v100[0] = _NSConcreteStackBlock;
    v100[1] = 0x40000000;
    v100[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_2;
    v100[3] = &unk_1E4F7C1B8;
    v100[6] = _platform_strlen(v26);
    v100[7] = v26;
    a4 = v25;
    v10 = v24;
    a7 = v23;
    v14 = 0;
    a6 = v96;
    v100[8] = v96;
    v100[4] = a7;
    v100[5] = a1;
    v17 = v100;
    v18 = v20;
    v19 = v21;
  }
  result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachInColonList(v18, v19, a6, (uint64_t)v17);
LABEL_10:
  if (*a6)
    return result;
  v27 = a1 + 128;
  while (1)
  {
    v27 = *(_QWORD *)v27;
    if (!v27)
      break;
    if (!_platform_strcmp(*(const char **)(v27 + 8), (const char *)a2))
      return (const char *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _BYTE *))(a7 + 16))(a7, *(_QWORD *)(v27 + 16), 1, a6);
  }
  if (*(_BYTE *)a2 == 64)
    goto LABEL_17;
  if (v10 == 6)
  {
    v29 = _platform_strncmp((const char *)a2, "/System/iOSSupport/", 0x13uLL);
    if (*(_QWORD *)(a1 + 120))
    {
      if (v29)
      {
        v30 = _platform_strlen((const char *)a2);
        v31 = v30 + 26;
        __chkstk_darwin(v30, v32, v33, v34, v35, v36, v37, v38, (uint64_t)v96);
        LODWORD(v96) = a4;
        v40 = (char *)&v96 - ((v39 + 41) & 0xFFFFFFFFFFFFFFF0);
        strlcpy(v40, "/System/iOSSupport", v31);
        strlcat(v40, (const char *)a2, v31);
        result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)v40, 3, a6, a7);
        if (*a6)
          return result;
        v41 = _platform_strlen(*(const char **)(a1 + 120));
        v42 = _platform_strlen((const char *)a2);
        v43 = v41 + v42 + 26;
        __chkstk_darwin(v42, v44, v45, v46, v47, v48, v49, v50, (uint64_t)v96);
        v52 = (char *)&v96 - v51;
        strlcpy((char *)&v96 - v51, *(const char **)(a1 + 120), v43);
        strlcat(v52, "/System/iOSSupport", v43);
        strlcat(v52, (const char *)a2, v43);
        result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)v52, 6, a6, a7);
        if (*a6)
          return result;
        v53 = _platform_strlen((const char *)a2);
        v54 = v53 + 26;
        __chkstk_darwin(v53, v55, v56, v57, v58, v59, v60, v61, (uint64_t)v96);
        v63 = (char *)&v96 - ((v62 + 41) & 0xFFFFFFFFFFFFFFF0);
        strlcpy(v63, "/System/iOSSupport", v54);
        strlcat(v63, (const char *)a2, v54);
        v64 = (uint64_t)v63;
        a4 = (int)v96;
        result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, v64, 4, a6, a7);
        if (*a6)
          return result;
      }
      goto LABEL_29;
    }
    if (v29)
    {
      v84 = _platform_strlen((const char *)a2);
      LODWORD(v96) = 6;
      v85 = v84 + 26;
      __chkstk_darwin(v84, v86, v87, v88, v89, v90, v91, v92, (uint64_t)v96);
      v94 = a4;
      v95 = (char *)&v96 - ((v93 + 41) & 0xFFFFFFFFFFFFFFF0);
      strlcpy(v95, "/System/iOSSupport", v85);
      strlcat(v95, (const char *)a2, v85);
      v78 = a1;
      v79 = (uint64_t)v95;
      a4 = v94;
      v80 = 4;
      goto LABEL_37;
    }
  }
  else if (*(_QWORD *)(a1 + 120))
  {
LABEL_29:
    result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)a2, 8, a6, a7);
    if (*a6)
      return result;
    v65 = _platform_strlen(*(const char **)(a1 + 120));
    v66 = _platform_strlen((const char *)a2);
    LODWORD(v96) = v10;
    v67 = v65 + v66 + 8;
    __chkstk_darwin(v66, v68, v69, v70, v71, v72, v73, v74, (uint64_t)v96);
    v75 = a4;
    v77 = (char *)&v96 - v76;
    strlcpy((char *)&v96 - v76, *(const char **)(a1 + 120), v67);
    strlcat(v77, (const char *)a2, v67);
    v78 = a1;
    v79 = (uint64_t)v77;
    a4 = v75;
    v80 = 7;
LABEL_37:
    result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(v78, v79, v80, a6, a7);
    v10 = v96;
    if (*a6)
      return result;
  }
LABEL_17:
  result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)a2, 9, a6, a7);
  if (!*a6 && (v97 & 1) == 0)
  {
    if (v14)
    {
      v28 = _platform_strlen(v14);
      v99[0] = _NSConcreteStackBlock;
      v99[1] = 0x40000000;
      v99[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_3;
      v99[3] = &unk_1E4F7C1E0;
      v99[6] = v28;
      v99[7] = v14;
      v99[8] = a2;
      v99[9] = a6;
      v99[4] = a7;
      v99[5] = a1;
      return (const char *)dyld4::ProcessConfig::PathOverrides::forEachFrameworkFallback(a1, v10, a4, a6, (uint64_t)v99);
    }
    else
    {
      v81 = strrchr((char *)a2, 47);
      if (v81)
        v82 = v81 + 1;
      else
        v82 = (const char *)a2;
      v83 = _platform_strlen(v82);
      v98[0] = _NSConcreteStackBlock;
      v98[1] = 0x40000000;
      v98[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_4;
      v98[3] = &unk_1E4F7C208;
      v98[6] = v83;
      v98[7] = v82;
      v98[8] = a2;
      v98[9] = a6;
      v98[4] = a7;
      v98[5] = a1;
      return (const char *)dyld4::ProcessConfig::PathOverrides::forEachDylibFallback(a1, v10, a4, a6, (uint64_t)v98);
    }
  }
  return result;
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t result;
  _QWORD v12[8];

  v10 = *(_QWORD *)(a1 + 104);
  if (!v10)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(a5 + 16))(a5, a2, a3, a4);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachImageSuffixEPKcNS1_4TypeERbU13block_pointerFvS3_S4_S5_E_block_invoke;
  v12[3] = &unk_1E4F7C168;
  v12[4] = a5;
  v12[5] = a1;
  v12[6] = a2;
  v12[7] = a4;
  result = dyld4::ProcessConfig::PathOverrides::forEachInColonList(v10, 0, a4, (uint64_t)v12);
  if (!*a4)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(a5 + 16))(a5, a2, a3, a4);
  return result;
}

void dyld4::Loader::forEachResolvedAtPathVar(const dyld4::RuntimeState *a1, char *__s1, uint64_t a3, uint64_t a4, _BYTE *a5, uint64_t a6)
{
  int v12;
  BOOL v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t **v17;
  BOOL i;
  _DWORD *v19;
  _QWORD v20[11];
  int v21;
  char v22[1024];

  v12 = _platform_strncmp(__s1, "@rpath/", 7uLL);
  if (v12)
    v13 = 1;
  else
    v13 = *(_BYTE *)(a3 + 6) == 0;
  if (v13)
  {
    v14 = v12;
    if (dyld4::Loader::expandAtLoaderPath(a1, __s1, a3, *(dyld4::Loader **)(*(_QWORD *)(a3 + 16) + 8), 0, v22))
    {
      (*(void (**)(uint64_t, char *, uint64_t, _BYTE *))(a6 + 16))(a6, v22, 11, a5);
    }
    else if (dyld4::Loader::expandAtExecutablePath(a1, __s1, v15, 0, v22))
    {
      (*(void (**)(uint64_t, char *, uint64_t, _BYTE *))(a6 + 16))(a6, v22, 12, a5);
    }
    else
    {
      if (v14)
        goto LABEL_19;
      if ((_DWORD)a4 == 13)
        v16 = 13;
      else
        v16 = 10;
      v17 = *(uint64_t ***)(a3 + 16);
      for (i = *a5 == 0; v17 && !*a5; i = *a5 == 0)
      {
        v19 = (_DWORD *)dyld4::Loader::mf((dyld4::Loader *)v17[1], a1);
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 0x40000000;
        v20[2] = ___ZN5dyld46Loader24forEachResolvedAtPathVarERNS_12RuntimeStateEPKcRKNS0_11LoadOptionsENS_13ProcessConfig13PathOverrides4TypeERbU13block_pointerFvS4_SA_SB_E_block_invoke;
        v20[3] = &unk_1E4F7CDC0;
        v20[6] = v17;
        v20[7] = a3;
        v20[8] = v22;
        v20[9] = __s1 + 6;
        v20[4] = a6;
        v20[5] = a1;
        v21 = v16;
        v20[10] = a5;
        dyld3::MachOFile::forEachRPath(v19, (uint64_t)v20);
        v17 = (uint64_t **)*v17;
      }
      if (i)
      {
LABEL_19:
        if (*__s1 != 64)
          (*(void (**)(uint64_t, char *, uint64_t, _BYTE *))(a6 + 16))(a6, __s1, a4, a5);
      }
    }
  }
  else
  {
    (*(void (**)(uint64_t, char *, uint64_t, _BYTE *))(a6 + 16))(a6, __s1, a4, a5);
  }
}

char *dyld4::Loader::expandAtExecutablePath(dyld4::RuntimeState *a1, char *__s1, uint64_t a3, uint64_t a4, char *a5)
{
  char *v8;
  int v10;
  uint64_t v12;

  if (_platform_strncmp(__s1, "@executable_path", 0x10uLL))
    return 0;
  v10 = __s1[16];
  if (v10 != 47 && v10 != 0)
    return 0;
  v12 = *((_QWORD *)a1 + 1);
  if (!*(_BYTE *)(v12 + 184))
  {
    if (*(_BYTE *)(v12 + 208))
      dyld4::RuntimeState::log(a1, "    @executable_path not expanded due to security policy\n");
    return 0;
  }
  return dyld4::Loader::expandAndNormalizeAtExecutablePath(*(dyld4::Loader **)(v12 + 16), __s1, a5, v8);
}

uint64_t dyld4::Loader::expandAtLoaderPath(dyld4::RuntimeState *a1, char *__s1, uint64_t a3, dyld4::Loader *a4, int a5, char *a6)
{
  uint64_t result;
  int v13;
  const char *v14;
  int v15;
  uint64_t v17;
  BOOL v18;
  const char *v20;

  if (_platform_strncmp(__s1, "@loader_path", 0xCuLL))
    return 0;
  v15 = __s1[12];
  v14 = __s1 + 12;
  v13 = v15;
  if (v15 != 47 && v13 != 0)
    return 0;
  v17 = *((_QWORD *)a1 + 1);
  if (*(_BYTE *)(a3 + 6))
  {
    if (*(_BYTE *)(v17 + 208))
      dyld4::RuntimeState::log(a1, "    @loader_path not allowed in DYLD_INSERT_LIBRARIES\n");
    return 0;
  }
  if (*(_BYTE *)(v17 + 184))
    v18 = 1;
  else
    v18 = a5 == 0;
  if (!v18 && *((_QWORD *)a1 + 3) == (_QWORD)a4)
  {
    if (*(_BYTE *)(v17 + 208))
      dyld4::RuntimeState::log(a1, "    @loader_path in LC_RPATH from main executable not expanded due to security policy\n");
    return 0;
  }
  v20 = (const char *)dyld4::Loader::path(a4, a1);
  strlcpy(a6, v20, 0x400uLL);
  result = (uint64_t)strrchr(a6, 47);
  if (result)
  {
    strlcpy((char *)result, v14, (size_t)&a6[-result + 1024]);
    return 1;
  }
  return result;
}

void ___ZN5dyld46Loader11forEachPathER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsEU13block_pointerFvS6_NS_13ProcessConfig13PathOverrides4TypeERbE_block_invoke(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v5;
  int v6;
  char v7[1024];
  char __dst[1024];

  v5 = *(_QWORD *)(a1 + 48);
  if ((_DWORD)a3 != 9 || *(_BYTE *)(v5 + 1) || (v6 = **(unsigned __int8 **)(a1 + 56), v6 == 47) || v6 == 64)
  {
    dyld4::Loader::forEachResolvedAtPathVar(*(const dyld4::RuntimeState **)(a1 + 64), a2, v5, a3, (_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(_QWORD *)(a1 + 32));
  }
  else
  {
    strcpy(__dst, "@rpath/");
    strlcat(__dst, a2, 0x400uLL);
    dyld4::Loader::forEachResolvedAtPathVar(*(const dyld4::RuntimeState **)(a1 + 64), __dst, *(_QWORD *)(a1 + 48), 13, (_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(_QWORD *)(a1 + 32));
    if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
    {
      strcpy(v7, "/usr/lib/");
      strlcat(v7, *(const char **)(a1 + 56), 0x400uLL);
      (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
      if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
      {
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 184))
          (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
      }
    }
  }
}

uint64_t dyld4::ProcessConfig::PathOverrides::getFrameworkPartialPath(dyld4::ProcessConfig::PathOverrides *this, dyld4::Utils *a2, const char *a3)
{
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  dyld4::Utils *v13;
  uint64_t i;
  _BOOL8 v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  const char *v19;
  const char *v20;
  char *v21;
  const char *v22;
  const char *v23;
  char v25;
  uint64_t v26;

  v5 = dyld4::Utils::strrstr(a2, ".framework/", a3);
  if (v5)
    v12 = v5 >= (char *)a2;
  else
    v12 = 0;
  if (!v12)
    return 0;
  v13 = (dyld4::Utils *)v5;
  for (i = 0; ; ++i)
  {
    if (v13 == a2 || *(_BYTE *)v13 == 47)
    {
      v15 = v13 != a2;
      v16 = v13 == a2 ? (uint64_t)v13 : (uint64_t)v13 + 1;
      v17 = i - v15;
      __chkstk_darwin((uint64_t)v5, v16, v6, v7, v8, v9, v10, v11, v26);
      v19 = (char *)&v26 - v18;
      strncpy((char *)&v26 - v18, v20, i - v15);
      v19[i - v15] = 0;
      v5 = strrchr((char *)a2, 47);
      if (v5)
      {
        v21 = v5;
        v22 = v5 + 1;
        v5 = (char *)_platform_strcmp(v19, v5 + 1);
        if (!(_DWORD)v5)
          break;
        v23 = (const char *)*((_QWORD *)this + 13);
        if (v23)
        {
          v5 = (char *)_platform_strncmp(v19, v22, v17);
          if (!(_DWORD)v5)
          {
            v5 = (char *)_platform_strcmp(v23, &v21[v17 + 1]);
            if (!(_DWORD)v5)
              break;
          }
        }
      }
    }
    v13 = (dyld4::Utils *)((char *)v13 - 1);
    if (v13 < a2)
      return 0;
  }
  if (v13 == a2)
    v25 = 2;
  else
    v25 = 1;
  return (uint64_t)v13 + (v25 & 1);
}

char *dyld4::Utils::strrstr(dyld4::Utils *this, const char *__s, const char *a3)
{
  size_t v5;
  size_t v6;
  size_t v7;
  char *v8;

  v5 = _platform_strlen(__s);
  v6 = _platform_strlen((const char *)this);
  if (!v6)
    return 0;
  v7 = v6;
  while (1)
  {
    v8 = (char *)this + v7;
    if (!_platform_strncmp((const char *)this + v7, __s, v5))
      break;
    if (!--v7)
      return 0;
  }
  return v8;
}

char *_platform_strncpy(char *a1, char *__s1, size_t __n)
{
  size_t v6;
  size_t v7;
  size_t v8;

  v6 = _platform_strnlen(__s1, __n);
  v7 = __n - v6;
  if (__n <= v6)
  {
    memmove(a1, __s1, __n);
  }
  else
  {
    v8 = v6;
    memmove(a1, __s1, v6);
    _platform_memset(&a1[v8], 0, v7);
  }
  return a1;
}

size_t _platform_strlcat(const char *a1, char *__s, size_t a3)
{
  size_t v6;
  size_t v7;
  size_t v8;
  size_t v9;
  char *v10;

  v6 = _platform_strlen(__s);
  v7 = _platform_strnlen(a1, a3);
  v8 = a3 - v7;
  if (a3 == v7)
  {
    v9 = a3;
  }
  else
  {
    v9 = v7;
    v10 = (char *)&a1[v7];
    if (v6 >= v8)
    {
      memmove(v10, __s, v8 - 1);
      a1[a3 - 1] = 0;
    }
    else
    {
      memmove(v10, __s, v6 + 1);
    }
  }
  return v9 + v6;
}

uint64_t dyld4::APIs::findImageContaining(dyld4::APIs *this, void *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v2 = (_QWORD *)*((_QWORD *)this + 17);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs19findImageContainingEPv_block_invoke;
  v5[3] = &unk_1E4F7DB50;
  v5[5] = this;
  v5[6] = a2;
  v5[4] = &v6;
  dyld4::RuntimeLocks::withLoadersReadLock(v2, (uint64_t)v5);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t dyld4::APIs::_dyld_get_image_header(dyld4::APIs *this, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD v7[6];
  int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v4 = (_QWORD *)*((_QWORD *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld44APIs22_dyld_get_image_headerEj_block_invoke;
  v7[3] = &unk_1E4F7D7E8;
  v8 = a2;
  v7[4] = &v9;
  v7[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_get_image_header(%u) => %p\n", a2, (const void *)v10[3]);
  v5 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t dyld4::APIs::_dyld_get_image_name(dyld4::APIs *this, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD v7[6];
  int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v4 = (_QWORD *)*((_QWORD *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld44APIs20_dyld_get_image_nameEj_block_invoke;
  v7[3] = &unk_1E4F7D838;
  v8 = a2;
  v7[4] = &v9;
  v7[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_get_image_name(%u) => %s\n", a2, (const char *)v10[3]);
  v5 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t dyld4::RuntimeLocks::withLoadersReadLock(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *a1;
  if (!v4)
    return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  (*(void (**)(uint64_t, _QWORD *, _QWORD))(*(_QWORD *)v4 + 104))(v4, a1 + 1, 0);
  (*(void (**)(uint64_t))(a2 + 16))(a2);
  return (*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*a1 + 112))(*a1, a1 + 1);
}

uint64_t ___ZN5dyld44APIs20_dyld_get_image_nameEj_block_invoke(uint64_t result)
{
  const dyld4::RuntimeState *v1;
  unint64_t v2;
  uint64_t v3;

  v1 = *(const dyld4::RuntimeState **)(result + 40);
  v2 = *(unsigned int *)(result + 48);
  if (*((_QWORD *)v1 + 6) > v2)
  {
    v3 = result;
    result = dyld4::Loader::path(*(dyld4::Loader **)(*((_QWORD *)v1 + 5) + 8 * v2), v1);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t ___ZN5dyld44APIs22_dyld_get_image_headerEj_block_invoke(uint64_t result)
{
  const dyld4::RuntimeState *v1;
  unint64_t v2;
  uint64_t v3;

  v1 = *(const dyld4::RuntimeState **)(result + 40);
  v2 = *(unsigned int *)(result + 48);
  if (*((_QWORD *)v1 + 6) > v2)
  {
    v3 = result;
    result = dyld4::Loader::loadAddress(*(dyld4::Loader **)(*((_QWORD *)v1 + 5) + 8 * v2), v1);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke_3(uint64_t result)
{
  dyld4::RuntimeState *v1;
  uint64_t v2;
  uint64_t v3;
  dyld4::Loader **v4;
  uint64_t v5;
  dyld4::Loader *v6;
  BOOL *v7;
  void **v8;
  unint64_t *v9;
  unsigned __int8 *v10;
  dyld4::Loader **v11;
  unsigned __int8 v12;
  unint64_t v13;
  void *v14;

  v1 = *(dyld4::RuntimeState **)(result + 40);
  v2 = *((_QWORD *)v1 + 6);
  if (v2)
  {
    v3 = result;
    v4 = (dyld4::Loader **)*((_QWORD *)v1 + 5);
    v5 = 8 * v2;
    while (1)
    {
      v6 = *v4;
      if (((*((unsigned __int16 *)*v4 + 2) >> 1) & 1) == *(_BYTE *)(v3 + 112))
      {
        v13 = 0;
        v14 = 0;
        v12 = 0;
        result = dyld4::Loader::contains(v6, v1, *(char **)(v3 + 48), (const void **)&v14, &v13, &v12);
        if ((_DWORD)result)
          break;
      }
      ++v4;
      v5 -= 8;
      if (!v5)
        return result;
    }
    if (*(_QWORD *)(v3 + 56))
    {
      result = dyld4::Loader::loadAddress(v6, v1);
      **(_QWORD **)(v3 + 56) = result;
    }
    v7 = *(BOOL **)(v3 + 64);
    if (v7)
      *v7 = (*((_BYTE *)v6 + 4) & 0x20) != 0;
    if (*(_QWORD *)(v3 + 72))
    {
      result = dyld4::Loader::path(v6, v1);
      **(_QWORD **)(v3 + 72) = result;
    }
    v8 = *(void ***)(v3 + 80);
    if (v8)
      *v8 = v14;
    v9 = *(unint64_t **)(v3 + 88);
    if (v9)
      *v9 = v13;
    v10 = *(unsigned __int8 **)(v3 + 96);
    if (v10)
      *v10 = v12;
    v11 = *(dyld4::Loader ***)(v3 + 104);
    if (v11)
      *v11 = v6;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = 1;
  }
  return result;
}

BOOL dyld4::JustInTimeLoader::contains(dyld4::JustInTimeLoader *this, dyld4::RuntimeState *a2, unint64_t a3, const void **a4, unint64_t *a5, unsigned __int8 *a6)
{
  dyld3::MachOFile *v6;
  _BOOL8 v7;
  unint64_t *v8;
  _QWORD v10[10];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;

  v6 = (dyld3::MachOFile *)*((_QWORD *)this + 4);
  if ((unint64_t)v6 > a3)
    return 0;
  v8 = (unint64_t *)*((_QWORD *)this + 13);
  if (v8 && *v8 <= a3 && *v8 + v8[1] > a3)
    return 1;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___ZNK5dyld416JustInTimeLoader8containsERNS_12RuntimeStateEPKvPS4_PyPh_block_invoke;
  v10[3] = &unk_1E4F7D238;
  v10[6] = a3;
  v10[7] = a4;
  v10[8] = a5;
  v10[9] = a6;
  v10[4] = &v11;
  v10[5] = (char *)v6 - dyld3::MachOFile::preferredLoadAddress(v6);
  dyld3::MachOFile::forEachSegment(v6, (uint64_t)v10);
  v7 = *((_BYTE *)v12 + 24) != 0;
  _Block_object_dispose(&v11, 8);
  return v7;
}

uint64_t ___ZN5dyld44APIs19findImageContainingEPv_block_invoke(uint64_t result)
{
  dyld4::RuntimeState *v1;
  uint64_t v2;
  uint64_t v3;
  dyld4::Loader **v4;
  uint64_t v5;
  dyld4::Loader *v6;
  unsigned __int8 v7;
  unint64_t v8;
  void *v9;

  v1 = *(dyld4::RuntimeState **)(result + 40);
  v2 = *((_QWORD *)v1 + 6);
  if (v2)
  {
    v3 = result;
    v4 = (dyld4::Loader **)*((_QWORD *)v1 + 5);
    v5 = 8 * v2;
    while (1)
    {
      v6 = *v4;
      v8 = 0;
      v9 = 0;
      v7 = 0;
      result = dyld4::Loader::contains(v6, v1, *(char **)(v3 + 48), (const void **)&v9, &v8, &v7);
      if ((_DWORD)result)
        break;
      ++v4;
      v5 -= 8;
      if (!v5)
        return result;
    }
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = v6;
  }
  return result;
}

uint64_t dyld4::Loader::contains(dyld4::Loader *this, dyld4::RuntimeState *a2, char *a3, const void **a4, unint64_t *a5, unsigned __int8 *a6)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::contains();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::contains(this, a2, a3, a4, a5, a6);
  else
    return dyld4::JustInTimeLoader::contains(this, a2, (unint64_t)a3, a4, a5, a6);
}

uint64_t dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = a2;
  *(_BYTE *)(result + 8) = 0;
  return result;
}

void dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter(dyld4::DyldCacheDataConstLazyScopedWriter *this)
{
  if (*((_BYTE *)this + 8))
    dyld4::ProcessConfig::DyldCache::makeDataConstWritable((char **)(*(_QWORD *)(*(_QWORD *)this + 8) + 240), *(_QWORD *)(*(_QWORD *)this + 8) + 200, *(_QWORD *)(*(_QWORD *)this + 8), 0);
}

const os_unfair_lock *lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::resize(const os_unfair_lock *result, unint64_t a2)
{
  _QWORD *v2;
  const os_unfair_lock *v3;

  if (*(_QWORD *)&result[6]._os_unfair_lock_opaque < a2)
    return (const os_unfair_lock *)lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserve((uint64_t)result, a2);
  if (a2)
  {
    *(_QWORD *)&result[4]._os_unfair_lock_opaque = a2;
    *(_QWORD *)&result[6]._os_unfair_lock_opaque = a2;
    return (const os_unfair_lock *)lsl::Allocator::realloc(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, *(_QWORD **)&result[2]._os_unfair_lock_opaque, 40 * a2);
  }
  else
  {
    v3 = result + 2;
    v2 = *(_QWORD **)&result[2]._os_unfair_lock_opaque;
    if (v2)
      result = lsl::Allocator::free(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, v2);
    *(_QWORD *)&v3->_os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[2]._os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[4]._os_unfair_lock_opaque = 0;
  }
  return result;
}

uint64_t lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserveExact(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 *v8;
  __int128 v9;
  __int128 v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  if (*(_QWORD *)(result + 24) < a2)
  {
    v3 = result;
    result = lsl::Allocator::realloc(*(lsl::Allocator **)result, *(_QWORD **)(result + 8), 40 * a2);
    if ((result & 1) == 0)
    {
      result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)v3, 0x10uLL, 40 * a2);
      v4 = result;
      if (*(_QWORD *)(v3 + 16))
      {
        v5 = 0;
        v6 = 0;
        do
        {
          v7 = result + v5;
          v8 = (__int128 *)(*(_QWORD *)(v3 + 8) + v5);
          v9 = *v8;
          v10 = v8[1];
          *(_QWORD *)(v7 + 32) = *((_QWORD *)v8 + 4);
          *(_OWORD *)v7 = v9;
          *(_OWORD *)(v7 + 16) = v10;
          ++v6;
          v11 = *(_QWORD *)(v3 + 16);
          v5 += 40;
        }
        while (v11 > v6);
      }
      else
      {
        v11 = 0;
      }
      v12 = *(_QWORD **)(v3 + 8);
      if (v12)
      {
        result = (uint64_t)lsl::Allocator::free(*(lsl::Allocator **)v3, v12);
        v11 = *(_QWORD *)(v3 + 16);
      }
      if (v11 >= a2)
        v13 = a2;
      else
        v13 = v11;
      *(_QWORD *)(v3 + 8) = v4;
      *(_QWORD *)(v3 + 16) = v13;
    }
    *(_QWORD *)(v3 + 24) = a2;
  }
  return result;
}

uint64_t dyld4::RuntimeLocks::releaseDlopenLockInForkParent(dyld4::RuntimeLocks *this)
{
  uint64_t result;

  result = *(_QWORD *)this;
  if (result)
    return (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)result + 112))(result, (char *)this + 32);
  return result;
}

uint64_t dyld4::RuntimeLocks::takeDlopenLockBeforeFork(dyld4::RuntimeLocks *this)
{
  uint64_t result;

  result = *(_QWORD *)this;
  if (result)
    return (*(uint64_t (**)(uint64_t, char *, _QWORD))(*(_QWORD *)result + 104))(result, (char *)this + 32, 0);
  return result;
}

uint64_t dyld4::RuntimeState::incDlRefCount(uint64_t this, const dyld4::Loader *a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  if ((*((_WORD *)a2 + 2) & 0x20) == 0)
  {
    v3 = this;
    v4 = *(_QWORD *)(this + 1080);
    if (v4)
    {
      v5 = (_QWORD *)(*(_QWORD *)(this + 1072) + 8);
      v6 = 16 * v4;
      while ((const dyld4::Loader *)*(v5 - 1) != a2)
      {
        v5 += 2;
        v6 -= 16;
        if (!v6)
          goto LABEL_6;
      }
      ++*v5;
    }
    else
    {
LABEL_6:
      this = lsl::Vector<dyld4::InterposeTupleAll>::reserve(this + 1064, v4 + 1);
      v7 = *(_QWORD *)(v3 + 1072);
      v8 = *(_QWORD *)(v3 + 1080);
      *(_QWORD *)(v3 + 1080) = v8 + 1;
      v9 = (_QWORD *)(v7 + 16 * v8);
      *v9 = a2;
      v9[1] = 1;
    }
  }
  return this;
}

void dyld4::RuntimeState::notifyObjCPatching(dyld4::RuntimeState *this)
{
  uint64_t (***v2)(_QWORD);
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;

  if (*((_QWORD *)this + 87) && *((_QWORD *)this + 34))
  {
    v2 = (uint64_t (***)(_QWORD))*((_QWORD *)this + 19);
    if (v2 && (unint64_t)(**v2)(v2) >= 3)
      (*(void (**)(_QWORD))(**((_QWORD **)this + 19) + 160))(*((_QWORD *)this + 19));
    v3 = *((_QWORD *)this + 34);
    if (v3)
    {
      v4 = (_QWORD *)*((_QWORD *)this + 33);
      v5 = &v4[4 * v3];
      do
      {
        (*((void (**)(_QWORD, _QWORD, _QWORD, _QWORD))this + 87))(*v4, v4[1], v4[2], v4[3]);
        v4 += 4;
      }
      while (v4 != v5);
    }
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 205))
      dyld4::RuntimeState::log(this, "objc-patch-class-notifier called with %lld patches:\n", *((_QWORD *)this + 34));
    *((_QWORD *)this + 34) = 0;
  }
}

void dyld4::RuntimeState::rebindMissingFlatLazySymbols(uint64_t a1, dyld4::Loader ***a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v10;
  dyld4::Loader ***v11[3];
  vm_address_t *v12;

  Diagnostics::Diagnostics((Diagnostics *)&v12);
  v4 = *(_QWORD *)(a1 + 928);
  v5 = *(_QWORD *)(a1 + 936);
  v6 = v4 + 24 * v5;
  v11[0] = a2;
  v11[1] = (dyld4::Loader ***)&v12;
  v11[2] = (dyld4::Loader ***)a1;
  if (v5)
  {
    v7 = 24 * v5;
    while ((dyld4::RuntimeState::rebindMissingFlatLazySymbols(std::span<dyld4::Loader const*,18446744073709551615ul> const&)::$_0::operator()(v11, v4) & 1) == 0)
    {
      v4 += 24;
      v7 -= 24;
      if (!v7)
      {
        v4 = v6;
        goto LABEL_13;
      }
    }
  }
  v8 = v4 + 24;
  if (v4 != v6 && v8 != v6)
  {
    do
    {
      if ((dyld4::RuntimeState::rebindMissingFlatLazySymbols(std::span<dyld4::Loader const*,18446744073709551615ul> const&)::$_0::operator()(v11, v8) & 1) == 0)
      {
        v10 = *(_OWORD *)v8;
        *(_QWORD *)(v4 + 16) = *(_QWORD *)(v8 + 16);
        *(_OWORD *)v4 = v10;
        v4 += 24;
      }
      v8 += 24;
    }
    while (v8 != v6);
  }
LABEL_13:
  *(_QWORD *)(a1 + 936) += 0x5555555555555555 * ((*(_QWORD *)(a1 + 928) + 24 * *(_QWORD *)(a1 + 936) - v4) >> 3);
  mach_o::Error::~Error(&v12);
}

ssize_t ___ZNK5dyld414PrebuiltLoader21invalidateInIsolationERKNS_12RuntimeStateE_block_invoke(ssize_t result, uint64_t a2, int a3, _BYTE *a4)
{
  ssize_t v6;
  _WORD *v7;
  const char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  _QWORD *v17;
  unint64_t v18;
  char *v19;
  _QWORD *v20;
  unint64_t v21;
  char *v22;
  __int128 v23;
  __int128 v24;

  if (a3 >= 10)
  {
    *a4 = 1;
    return result;
  }
  v6 = result;
  v23 = 0u;
  v24 = 0u;
  v7 = *(_WORD **)(result + 40);
  result = dyld4::ProcessConfig::fileExists(*(_QWORD *)(*(_QWORD *)(result + 48) + 8), a2, &v23, 0);
  if ((_DWORD)result)
  {
    if (!v7 || !v7[21] || (v9 = (char *)v7 + (unsigned __int16)v7[21], !v9[52]))
    {
      v20 = *(_QWORD **)(v6 + 48);
      if (*(_BYTE *)(v20[1] + 207))
      {
        if ((v7[2] & 2) != 0 || (v21 = v7[3] & 0x7FFF, v20[42] <= v21))
        {
          if (v7[16])
            v22 = (char *)v7 + (unsigned __int16)v7[16];
          else
            v22 = 0;
        }
        else
        {
          v22 = *(char **)(v20[41] + 8 * v21);
        }
        result = dyld4::console((dyld4 *)"found '%s' which invalidates PrebuiltLoader for '%s'\n", v8, a2, v22);
      }
      goto LABEL_29;
    }
    v10 = *((_QWORD *)v9 + 1);
    v13 = v9 + 16;
    v11 = *((_QWORD *)v9 + 2);
    v12 = *((_QWORD *)v13 + 1);
    if (*((_QWORD *)&v23 + 1) != v10 || BYTE8(v24) == 0 || (_QWORD)v23 != v11 || (_QWORD)v24 != v12)
    {
      v17 = *(_QWORD **)(v6 + 48);
      if (*(_BYTE *)(v17[1] + 207))
      {
        if ((v7[2] & 2) != 0 || (v18 = v7[3] & 0x7FFF, v17[42] <= v18))
        {
          if (v7[16])
            v19 = (char *)v7 + (unsigned __int16)v7[16];
          else
            v19 = 0;
        }
        else
        {
          v19 = *(char **)(v17[41] + 8 * v18);
        }
        result = dyld4::console((dyld4 *)"found '%s' with different inode/mtime than PrebuiltLoader for '%s'\n", v8, a2, v19);
      }
LABEL_29:
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v6 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

void *Diagnostics::errorMessage(Diagnostics *this)
{
  _BYTE **v1;

  v1 = *(_BYTE ***)this;
  if (v1)
    return (void *)_simple_string(v1);
  else
    return &unk_1A5CBE413;
}

void ___ZN5dyld44APIs33_dyld_register_func_for_add_imageEPFvPK11mach_headerlE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const void **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  size_t v23;
  unint64_t v24;
  dyld3::MachOLoaded *Address;
  uint64_t Slide;
  const void *v27;
  uint64_t v28;
  uint64_t v29;

  v9 = *(_QWORD *)(a1 + 32);
  v10 = *(unsigned int *)(v9 + 48);
  v11 = 8 * v10;
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v29);
  v12 = (const void **)((char *)&v29 - ((8 * v10 + 15) & 0xFFFFFFFF0));
  __chkstk_darwin(v13, v14, v15, v16, v17, v18, v19, v20, v29);
  v22 = (uint64_t *)((char *)&v29 - v21);
  if (v10)
  {
    if (v11 >= 0x200)
      v23 = 512;
    else
      v23 = 8 * v10;
    bzero(v12, v23);
    v24 = 0;
    do
    {
      Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*(dyld4::Loader **)(*(_QWORD *)(v9 + 40) + v24), (const dyld4::RuntimeState *)v9);
      v12[v24 / 8] = Address;
      if ((*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v9 + 40) + v24) + 4) & 2) != 0)
        Slide = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 264);
      else
        Slide = dyld3::MachOLoaded::getSlide(Address);
      v22[v24 / 8] = Slide;
      v24 += 8;
    }
    while (v11 != v24);
    do
    {
      v27 = *v12;
      if (*(_BYTE *)(*(_QWORD *)(v9 + 8) + 205))
        dyld4::RuntimeState::log((dyld4::RuntimeState *)v9, "add notifier %p called with mh=%p\n", *(const void **)(a1 + 40), *v12);
      v28 = *v22++;
      (*(void (**)(const void *, uint64_t))(a1 + 40))(v27, v28);
      ++v12;
      --v10;
    }
    while (v10);
  }
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachFrameworkFallback(uint64_t result, unsigned int a2, int a3, _BYTE *a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  _QWORD v11[6];

  v8 = *(_QWORD *)(result + 24);
  v9 = *(_QWORD *)(result + 72);
  if (v8 | v9)
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = ___ZNK5dyld413ProcessConfig13PathOverrides24forEachFrameworkFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke;
    v11[3] = &unk_1E4F7C140;
    v11[4] = a5;
    v11[5] = a4;
    return dyld4::ProcessConfig::PathOverrides::forEachInColonList(v8, v9, a4, (uint64_t)v11);
  }
  else if (a3 && a2 <= 0xC)
  {
    if (((1 << a2) & 0x1BFD) != 0)
    {
      if (*(_DWORD *)(result + 136) != 2)
        return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))(a5, "/System/Library/Frameworks", 15, a4);
    }
    else if (a2 == 1)
    {
      v10 = *(_DWORD *)(result + 136);
      if (v10 == 1)
        return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))(a5, "/System/Library/Frameworks", 15, a4);
      if (!v10)
      {
        result = (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))(a5, "/Library/Frameworks", 15, a4);
        if (!*a4)
          return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))(a5, "/System/Library/Frameworks", 15, a4);
      }
    }
  }
  return result;
}

uint64_t ___ZN5dyld44APIs25NSVersionOfRunTimeLibraryEPKc_block_invoke(uint64_t result)
{
  const dyld4::RuntimeState *v1;
  uint64_t v2;
  uint64_t v3;
  dyld4::Loader **v4;
  uint64_t v5;
  dyld3::MachOFile *Address;
  const char *v7;
  unsigned int v8[2];
  dyld4 *v9;

  v1 = *(const dyld4::RuntimeState **)(result + 40);
  v2 = *((_QWORD *)v1 + 6);
  if (v2)
  {
    v3 = result;
    v4 = (dyld4::Loader **)*((_QWORD *)v1 + 5);
    v5 = 8 * v2;
    while (1)
    {
      Address = (dyld3::MachOFile *)dyld4::Loader::loadAddress(*v4, v1);
      *(_QWORD *)v8 = 0;
      v9 = 0;
      result = dyld3::MachOFile::getDylibInstallName(Address, (const char **)&v9, v8, &v8[1]);
      if ((_DWORD)result)
      {
        result = dyld4::nameMatch(v9, *(const char **)(v3 + 48), v7);
        if ((_DWORD)result)
          break;
      }
      ++v4;
      v5 -= 8;
      if (!v5)
        return result;
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = v8[1];
  }
  return result;
}

void dyld3::MachOFile::forEachRPath(_DWORD *a1, uint64_t a2)
{
  _QWORD v4[5];
  vm_address_t *v5;

  Diagnostics::Diagnostics((Diagnostics *)&v5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile12forEachRPathEU13block_pointerFvPKcRbE_block_invoke;
  v4[3] = &unk_1E4F7EBD8;
  v4[4] = a2;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v5, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v5);
  mach_o::Error::~Error(&v5);
}

void ___ZN5dyld44APIs16dlopen_preflightEPKc_block_invoke(_QWORD *a1, dyld3 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL4 v11;
  vm_address_t *v12;
  const char *v13;
  _QWORD v14[9];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  void (*v19)(uint64_t);
  vm_address_t *v20;

  v7 = a1[6];
  v15 = 0;
  v16 = &v15;
  v17 = 0x3002000000;
  v18 = __Block_byref_object_copy__6;
  v19 = __Block_byref_object_dispose__6;
  Diagnostics::Diagnostics((Diagnostics *)&v20);
  v8 = *(_QWORD *)(v7 + 8);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = ___ZN5dyld44APIs16dlopen_preflightEPKc_block_invoke_2;
  v14[3] = &unk_1E4F7DB78;
  v9 = a1[7];
  v14[6] = v7;
  v14[7] = v9;
  v10 = a1[4];
  v14[4] = &v15;
  v14[5] = v10;
  v14[8] = a4;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(v8, (vm_address_t *)v16 + 5, a2, 1, (uint64_t)v14);
  if (!*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) && Diagnostics::hasError((Diagnostics *)(v16 + 5)))
  {
    v11 = Diagnostics::noError((Diagnostics *)(*(_QWORD *)(a1[5] + 8) + 40));
    v12 = (vm_address_t *)(*(_QWORD *)(a1[5] + 8) + 40);
    v13 = (const char *)Diagnostics::errorMessage((Diagnostics *)(v16 + 5));
    if (v11)
      Diagnostics::error(v12, "tried: '%s' (%s)", (const char *)a2, v13);
    else
      Diagnostics::appendError(v12, ", '%s' (%s)", (const char *)a2, v13);
  }
  _Block_object_dispose(&v15, 8);
  mach_o::Error::~Error(&v20);
}

uint64_t dyld4::APIs::dyld_get_base_platform(dyld4::APIs *this, uint64_t a2)
{
  int v2;
  uint64_t v4;
  uint64_t v5;

  v2 = a2;
  v4 = dyld3::MachOFile::basePlatform(a2);
  v5 = v4;
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_get_base_platform(%d) => %d\n", v2, v4);
  return v5;
}

void dyld4::RuntimeState::loadAppPrebuiltLoaderSet(dyld4::RuntimeState *this)
{
  uint64_t v2;
  dyld3::MachOAnalyzer *Only;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  int v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  vm_address_t *v19;
  char *v20;
  __int128 v21;
  char v22;

  if (dyld4::SyscallDelegate::fileExists(*((_QWORD *)this + 1), *((dyld3 **)this + 126), 0, 0))
  {
    v20 = &v22;
    v21 = xmmword_1A5CBB330;
    if ((dyld4::RuntimeState::buildBootToken((uint64_t)this, (uint64_t *)&v20) & 1) != 0)
    {
      if (dyld4::RuntimeState::fileAlreadyHasBootToken((uint64_t)this, v2, (uint64_t)&v20))
      {
        Diagnostics::Diagnostics((Diagnostics *)&v19);
        Only = dyld4::SyscallDelegate::mapFileReadOnly(*((_QWORD *)this + 1), (vm_address_t *)&v19, *((dyld3 **)this + 126), 0, 0, 0, 0);
        *((_QWORD *)this + 127) = Only;
        if (Only)
        {
          dyld4::RuntimeState::allocateProcessArrays(this, *((unsigned int *)Only + 3));
          **((_QWORD **)this + 129) = *(_QWORD *)(*((_QWORD *)this + 1) + 8);
          if (*((_QWORD *)this + 127))
          {
            v11 = 520552504;
            v12 = 0u;
            v13 = 0u;
            v14 = 0u;
            v15 = 0u;
            v16 = 0u;
            v17 = 0u;
            v18 = 0;
            dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v11, v4, v5, v6, v7, v8, v9, v10);
            if ((dyld4::PrebuiltLoaderSet::isValid(*((dyld4::PrebuiltLoaderSet **)this + 127), this) & 1) == 0)
            {
              dyld4::SyscallDelegate::unmapFile(*((dyld4::SyscallDelegate **)this + 1), *((void **)this + 127), *(unsigned int *)(*((_QWORD *)this + 127) + 8));
              *((_QWORD *)this + 127) = 0;
            }
            dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v11);
          }
        }
        mach_o::Error::~Error(&v19);
      }
      else if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
      {
        dyld4::RuntimeState::log(this, "existing PrebuiltLoaderSet file not used because boot-token differs\n");
      }
    }
    else if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
    {
      dyld4::RuntimeState::log(this, "did not look for saved PrebuiltLoaderSet because main executable is not codesigned\n");
    }
  }
}

BOOL dyld4::RuntimeState::fileAlreadyHasBootToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BOOL8 result;
  void *__s2;
  size_t __n[2];
  char v7;

  __s2 = &v7;
  *(_OWORD *)__n = xmmword_1A5CBB330;
  result = dyld4::SyscallDelegate::getFileAttribute(*(_QWORD *)(a1 + 8), *(char **)(a1 + 1008), "com.apple.dyld", (uint64_t)&__s2);
  if (result)
    return __n[1] == *(_QWORD *)(a3 + 16) && _platform_memcmp(*(const void **)a3, __s2, __n[1]) == 0;
  return result;
}

BOOL dyld4::SyscallDelegate::getFileAttribute(int a1, char *path, char *name, uint64_t a4)
{
  unint64_t v5;

  v5 = getxattr(path, name, *(void **)a4, *(_QWORD *)(a4 + 8), 0, 0);
  if (v5 != -1)
  {
    if (*(_QWORD *)(a4 + 8) < v5)
      dyld4::SyscallDelegate::getFileAttribute();
    *(_QWORD *)(a4 + 16) = v5;
  }
  return v5 != -1;
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  char v6;
  ssize_t result;

  result = mac_syscall(SYS_getxattr, path, name, value, size, position, options);
  if (v6)
    return cerror_nocancel(result);
  return result;
}

const char *dyld4::RuntimeState::buildBootToken(uint64_t a1, uint64_t *a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t i;
  char *v10;
  size_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  char v16;
  unsigned __int8 v17[8];
  uint64_t v18;
  unsigned __int8 v19[128];

  v15 = 0;
  result = dyld4::ProcessConfig::Process::appleParam((const char ***)(*(_QWORD *)(a1 + 8) + 8), "executable_boothash");
  if (result)
  {
    result = (const char *)hexStringToBytes(result, v19, 0x80u, &v15);
    if ((_DWORD)result)
    {
      v6 = v15;
      if (v15)
      {
        v7 = v19;
        do
        {
          dyld3::Array<unsigned char>::push_back(a2, (char *)v7++, v5);
          --v6;
        }
        while (v6);
      }
      *(_QWORD *)v17 = 0;
      v18 = 0;
      if (dyld3::MachOFile::getUuid((dyld3::MachOFile *)&dword_1A5C55000, v17))
      {
        for (i = 0; i != 16; ++i)
          dyld3::Array<unsigned char>::push_back(a2, (char *)&v17[i], v8);
      }
      v10 = *(char **)(*(_QWORD *)(a1 + 8) + 24);
      v11 = _platform_strlen(v10);
      v13 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v16, (uint64_t *)v10, v11);
      v14 = 8;
      do
      {
        v16 = v13;
        dyld3::Array<unsigned char>::push_back(a2, &v16, v12);
        v13 >>= 8;
        --v14;
      }
      while (v14);
      return (const char *)1;
    }
  }
  return result;
}

uint64_t *dyld3::Array<unsigned char>::push_back(uint64_t *result, char *a2, uint64_t a3)
{
  unint64_t v3;
  char v4;
  uint64_t v5;

  v3 = result[2];
  if (v3 >= result[1])
    dyld4::RuntimeState::appendInterposingTuples((uint64_t)result, (uint64_t)a2, a3);
  v4 = *a2;
  v5 = *result;
  result[2] = v3 + 1;
  *(_BYTE *)(v5 + v3) = v4;
  return result;
}

BOOL DyldSharedCache::hasLaunchLoaderSetWithCDHash(DyldSharedCache *this, const char *a2)
{
  return DyldSharedCache::findLaunchLoaderSetWithCDHash(this, a2) != 0;
}

char *DyldSharedCache::findLaunchLoaderSetWithCDHash(DyldSharedCache *this, const char *__s)
{
  char __dst[144];

  if (!__s || _platform_strlen(__s) > 0x7F)
    return 0;
  strcpy(__dst, "/cdhash/");
  strlcat(__dst, __s, 0x8CuLL);
  return DyldSharedCache::findLaunchLoaderSet(this, __dst);
}

void dyld4::RuntimeState::initializeClosureMode(dyld4::RuntimeState *this)
{
  __int128 v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  int valid;
  _QWORD *v7;
  uint64_t v8;
  char *LaunchLoaderSet;
  dyld4::PrebuiltLoaderSet *v10;
  uint64_t v11;
  const char *v12;
  DyldSharedCache *v13;
  const char *v14;
  char *LaunchLoaderSetWithCDHash;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  const char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  DyldSharedCache *v31;
  const char *v32;
  char *v33;
  const char *v34;
  dyld4::Loader *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  dyld4::Loader *v39;
  const char *v40;
  dyld4::Loader *v41;
  uint64_t v42;
  DyldSharedCache *v43;
  const char *v44;
  char v45;
  uint64_t v46;
  const char *v47;
  const char *v48;
  int v49;
  int v50;
  uint64_t v51;
  unsigned int v52;
  dyld4::PrebuiltLoaderSet **v53;
  dyld4::PrebuiltLoaderSet *v54;
  uint64_t *v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  uint64_t v70;
  _QWORD *v71;
  _QWORD *v72;
  uint64_t v73;
  _QWORD *v74;
  _QWORD *v75;
  dyld4::PrebuiltLoaderSet *v76;
  _BYTE *v77;
  uint64_t v78;
  char v79;
  const char *v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  dyld4::PrebuiltLoader *v86;
  uint64_t v87;
  const char *v88;
  const char *v89;
  uint64_t v90;
  unsigned int v91;
  unsigned int v92;
  char __dst[1024];

  v2 = 0uLL;
  *((_OWORD *)this + 62) = 0u;
  v3 = *((_QWORD *)this + 1);
  v4 = *(_QWORD *)(v3 + 240);
  if (v4)
  {
    if (*(_DWORD *)(v4 + 16) >= 0x170u)
    {
      v5 = (unsigned int *)(*(_QWORD *)(v3 + 264) + *(_QWORD *)(v4 + 328));
      valid = dyld4::PrebuiltLoaderSet::validHeader((dyld4::PrebuiltLoaderSet *)v5, this);
      v2 = 0uLL;
      if (valid)
      {
        *((_QWORD *)this + 124) = v5;
        v7 = lsl::Allocator::malloc(*((lsl::Allocator **)this + 2), v5[3]);
        *((_QWORD *)this + 125) = v7;
        bzero(v7, *(unsigned int *)(*((_QWORD *)this + 124) + 12));
        v2 = 0uLL;
      }
    }
  }
  *((_QWORD *)this + 126) = 0;
  *((_OWORD *)this + 64) = v2;
  *((_BYTE *)this + 1040) = 0;
  v8 = *((_QWORD *)this + 1);
  if (!*(_QWORD *)(v8 + 240))
  {
    if (*(_BYTE *)(v8 + 207))
      dyld4::RuntimeState::log(this, "PrebuiltLoaders not being used because there is no dyld shared cache\n");
    goto LABEL_48;
  }
  if (dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp((dyld4::ProcessConfig::PathOverrides *)(v8 + 400)))
  {
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
      dyld4::RuntimeState::log(this, "PrebuiltLoaders not being used because DYLD_ env vars are set\n");
    goto LABEL_48;
  }
  if (!*((_QWORD *)this + 124) || !*((_QWORD *)this + 125))
  {
LABEL_48:
    v50 = 0;
    v49 = 0;
    v53 = (dyld4::PrebuiltLoaderSet **)((char *)this + 1016);
    goto LABEL_49;
  }
  LaunchLoaderSet = DyldSharedCache::findLaunchLoaderSet(*(DyldSharedCache **)(*((_QWORD *)this + 1) + 240), *(const char **)(*((_QWORD *)this + 1) + 16));
  if (LaunchLoaderSet)
  {
    v10 = (dyld4::PrebuiltLoaderSet *)LaunchLoaderSet;
  }
  else
  {
    v11 = *((_QWORD *)this + 1);
    v12 = *(const char **)(v11 + 16);
    if (_platform_strncmp(v12, "/System/", 8uLL))
    {
      if (!_platform_strncmp(v12, "/private/var/containers/Bundle/Application/", 0x2BuLL))
      {
        v13 = *(DyldSharedCache **)(v11 + 240);
        v14 = dyld4::ProcessConfig::Process::appleParam((const char ***)(v11 + 8), "executable_cdhash");
        LaunchLoaderSetWithCDHash = DyldSharedCache::findLaunchLoaderSetWithCDHash(v13, v14);
        if (LaunchLoaderSetWithCDHash)
        {
          v10 = (dyld4::PrebuiltLoaderSet *)LaunchLoaderSetWithCDHash;
          if (!*((_DWORD *)LaunchLoaderSetWithCDHash + 3))
            dyld4::RuntimeState::findPrebuiltLoader((uint64_t)LaunchLoaderSetWithCDHash, v16, v17);
          v18 = (const char *)dyld4::PrebuiltLoader::path((dyld4::PrebuiltLoader *)&LaunchLoaderSetWithCDHash[*(unsigned int *)&LaunchLoaderSetWithCDHash[*((unsigned int *)LaunchLoaderSetWithCDHash + 4)]], this);
          if (!_platform_strncmp(v18, "/private/var/staged_system_apps/", 0x20uLL))
          {
            v19 = v18 + 32;
            v20 = *(_QWORD *)(*((_QWORD *)this + 1) + 16);
            v21 = _platform_strchr((char *)(v20 + 44), 47) + 1;
            v22 = _platform_strcmp(v19, v21);
            if (!(_DWORD)v22)
            {
              v25 = *((_DWORD *)v10 + 3);
              if (v25)
              {
                v26 = 0;
                v27 = &v21[-v20];
                do
                {
                  if (v25 <= (unsigned __int16)v26)
                    dyld4::RuntimeState::findPrebuiltLoader(v22, v23, v24);
                  v28 = (char *)dyld4::PrebuiltLoader::path((dyld4::PrebuiltLoaderSet *)((char *)v10+ *(unsigned int *)((char *)v10+ 4 * (unsigned __int16)v26+ *((unsigned int *)v10 + 4))), this);
                  if (!_platform_strncmp(v28, "/private/var/staged_system_apps/", 0x20uLL))
                  {
                    strlcpy(__dst, *(const char **)(*((_QWORD *)this + 1) + 16), 0x400uLL);
                    __dst[(_QWORD)v27] = 0;
                    strlcat(__dst, v28 + 32, 0x400uLL);
                    v28 = lsl::Allocator::strdup(*((lsl::Allocator **)this + 2), __dst);
                  }
                  v22 = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 320, *((_QWORD *)this + 42) + 1);
                  v29 = *((_QWORD *)this + 41);
                  v30 = *((_QWORD *)this + 42);
                  *((_QWORD *)this + 42) = v30 + 1;
                  *(_QWORD *)(v29 + 8 * v30) = v28;
                  ++v26;
                  v25 = *((_DWORD *)v10 + 3);
                }
                while (v25 > v26);
              }
              goto LABEL_33;
            }
          }
        }
      }
    }
    else
    {
      v31 = *(DyldSharedCache **)(v11 + 240);
      v32 = dyld4::ProcessConfig::Process::appleParam((const char ***)(v11 + 8), "executable_cdhash");
      v33 = DyldSharedCache::findLaunchLoaderSetWithCDHash(v31, v32);
      if (v33)
      {
        v10 = (dyld4::PrebuiltLoaderSet *)v33;
        v35 = dyld4::Loader::leafName(*(dyld4::Loader **)(*((_QWORD *)this + 1) + 16), v34);
        if (!*((_DWORD *)v10 + 3))
          dyld4::RuntimeState::findPrebuiltLoader((uint64_t)v35, v36, v37);
        v38 = (const char *)v35;
        v39 = (dyld4::Loader *)dyld4::PrebuiltLoader::path((dyld4::PrebuiltLoaderSet *)((char *)v10+ *(unsigned int *)((char *)v10 + *((unsigned int *)v10 + 4))), this);
        v41 = dyld4::Loader::leafName(v39, v40);
        if (!_platform_strcmp(v38, (const char *)v41))
          goto LABEL_33;
      }
    }
    v42 = *((_QWORD *)this + 1);
    v43 = *(DyldSharedCache **)(v42 + 240);
    v44 = dyld4::ProcessConfig::Process::appleParam((const char ***)(v42 + 8), "executable_cdhash");
    if (!DyldSharedCache::hasLaunchLoaderSetWithCDHash(v43, v44))
    {
      v51 = *((_QWORD *)this + 1);
      v52 = *(_DWORD *)(v51 + 68);
      if (v52 <= 0xB)
      {
        v45 = 1;
        if (((1 << v52) & 0x81C) != 0)
        {
          v10 = 0;
          goto LABEL_34;
        }
      }
      dyld4::ProcessConfig::Process::appleParam((const char ***)(v51 + 8), "executable_cdhash");
    }
    v10 = 0;
  }
LABEL_33:
  v45 = 0;
LABEL_34:
  v46 = *((_QWORD *)this + 1);
  if (!*(_BYTE *)(v46 + 169))
    goto LABEL_39;
  v47 = dyld4::ProcessConfig::Process::environ((const char ***)(v46 + 8), "DYLD_USE_CLOSURES");
  if (!v47)
    goto LABEL_39;
  v48 = v47;
  if (!_platform_strcmp(v47, "0"))
  {
    *((_QWORD *)this + 124) = 0;
    goto LABEL_48;
  }
  if (_platform_strcmp(v48, "1"))
  {
    if (!_platform_strcmp(v48, "2"))
    {
      v90 = *((_QWORD *)this + 1);
      v91 = *(_DWORD *)(v90 + 68) - 2;
      if (v91 >= 0xA || ((0x207u >> v91) & 1) == 0)
      {
        dyld4::ProcessConfig::Process::appleParam((const char ***)(v90 + 8), "executable_cdhash");
        if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
          dyld4::RuntimeState::log(this, "PrebuiltLoaders cannot be used with unsigned or old format programs\n");
      }
      v50 = 0;
      v49 = 1;
LABEL_41:
      dyld4::RuntimeState::buildAppPrebuiltLoaderSetPath(this, 0);
      if (*((_QWORD *)this + 126))
      {
        dyld4::RuntimeState::loadAppPrebuiltLoaderSet(this);
        goto LABEL_84;
      }
      goto LABEL_83;
    }
LABEL_39:
    v49 = 0;
    if ((v45 & 1) == 0)
    {
      v50 = 0;
      goto LABEL_84;
    }
    v50 = 1;
    goto LABEL_41;
  }
  v81 = *((_QWORD *)this + 1);
  v82 = *(_DWORD *)(v81 + 68) - 2;
  if (v82 >= 0xA || ((0x207u >> v82) & 1) == 0)
  {
    dyld4::ProcessConfig::Process::appleParam((const char ***)(v81 + 8), "executable_cdhash");
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
      dyld4::RuntimeState::log(this, "PrebuiltLoaders cannot be used with unsigned or old format programs\n");
    v49 = 0;
LABEL_83:
    v50 = 0;
    goto LABEL_84;
  }
  v49 = 0;
  v50 = 1;
LABEL_84:
  v53 = (dyld4::PrebuiltLoaderSet **)((char *)this + 1016);
  v54 = (dyld4::PrebuiltLoaderSet *)*((_QWORD *)this + 127);
  if (!v10 || v54)
  {
LABEL_50:
    if (v54)
    {
      v55 = (uint64_t *)dyld4::PrebuiltLoaderSet::objcSelectorMap(v54);
      if (v55)
      {
        v56 = *v55;
        v57 = (char *)v55 + 4 * *v55;
        v58 = *((_QWORD *)v57 + 1);
        *((_QWORD *)this + 47) = v55 + 1;
        *((_QWORD *)this + 48) = v56;
        *((_QWORD *)this + 49) = v56;
        *((_QWORD *)this + 50) = v57 + 16;
        *((_QWORD *)this + 51) = v58;
        *((_QWORD *)this + 52) = v58;
      }
      v59 = (uint64_t *)dyld4::PrebuiltLoaderSet::objcClassMap(*v53);
      if (v59)
      {
        v60 = *v59;
        v61 = &v59[*v59];
        v62 = v61[1];
        *((_QWORD *)this + 53) = v59 + 1;
        *((_QWORD *)this + 54) = v60;
        *((_QWORD *)this + 55) = v60;
        *((_QWORD *)this + 56) = v61 + 2;
        *((_QWORD *)this + 57) = v62;
        *((_QWORD *)this + 58) = v62;
      }
      v63 = (uint64_t *)dyld4::PrebuiltLoaderSet::objcProtocolMap(*v53);
      if (v63)
      {
        v64 = *v63;
        v65 = &v63[*v63];
        v66 = v65[1];
        *((_QWORD *)this + 59) = v63 + 1;
        *((_QWORD *)this + 60) = v64;
        *((_QWORD *)this + 61) = v64;
        *((_QWORD *)this + 62) = v65 + 2;
        *((_QWORD *)this + 63) = v66;
        *((_QWORD *)this + 64) = v66;
      }
      v67 = dyld4::PrebuiltLoaderSet::swiftTypeProtocolTable(*v53);
      if (v67)
      {
        v68 = (_QWORD *)v67;
        v69 = lsl::Allocator::malloc(*((lsl::Allocator **)this + 2), 0x68uLL);
        *((_QWORD *)this + 65) = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap((uint64_t)v69, (uint64_t)this, v68);
      }
      v70 = dyld4::PrebuiltLoaderSet::swiftMetadataProtocolTable(*v53);
      if (v70)
      {
        v71 = (_QWORD *)v70;
        v72 = lsl::Allocator::malloc(*((lsl::Allocator **)this + 2), 0x68uLL);
        *((_QWORD *)this + 66) = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap((uint64_t)v72, (uint64_t)this, v71);
      }
      v73 = dyld4::PrebuiltLoaderSet::swiftForeignTypeProtocolTable(*v53);
      if (v73)
      {
        v74 = (_QWORD *)v73;
        v75 = lsl::Allocator::malloc(*((lsl::Allocator **)this + 2), 0x68uLL);
        *((_QWORD *)this + 67) = dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap((uint64_t)v75, (uint64_t)this, v74);
      }
    }
    v76 = *v53;
    if (!*v53)
    {
      *((_BYTE *)this + 1040) = v50;
      if (v50)
        goto LABEL_65;
      v76 = 0;
    }
LABEL_69:
    *((_BYTE *)this + 1041) = 0;
    if (!v49)
      return;
    v77 = (char *)this + 1041;
    if (v76)
      return;
    goto LABEL_71;
  }
  if (!dyld4::PrebuiltLoaderSet::validHeader(v10, this))
    goto LABEL_49;
  dyld4::RuntimeState::allocateProcessArrays(this, *((unsigned int *)v10 + 3));
  **((_QWORD **)this + 129) = *(_QWORD *)(*((_QWORD *)this + 1) + 8);
  if (!*((_DWORD *)v10 + 3))
    dyld4::RuntimeState::findPrebuiltLoader(v83, v84, v85);
  v86 = (dyld4::PrebuiltLoaderSet *)((char *)v10 + *(unsigned int *)((char *)v10 + *((unsigned int *)v10 + 4)));
  v87 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v87 + 207))
  {
    dyld4::RuntimeState::log(this, "PrebuiltLoader %p found for %s in the dyld cache\n", (char *)v10 + *(unsigned int *)((char *)v10 + *((unsigned int *)v10 + 4)), *(const char **)(v87 + 16));
    v87 = *((_QWORD *)this + 1);
  }
  v88 = dyld4::ProcessConfig::Process::appleParam((const char ***)(v87 + 8), "executable_cdhash");
  if (!v88
    || (v92 = 0, !hexStringToBytes(v88, (unsigned __int8 *)__dst, 0x14u, &v92))
    || !dyld4::PrebuiltLoader::recordedCdHashIs(v86, (const unsigned __int8 *)__dst))
  {
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
      dyld4::RuntimeState::log(this, "PrebuiltLoader %p not used because cdHash does not match\n", v86);
    goto LABEL_49;
  }
  *((_QWORD *)this + 127) = v10;
  if ((dyld4::PrebuiltLoaderSet::isValid(v10, this) & 1) != 0)
  {
LABEL_49:
    v54 = *v53;
    goto LABEL_50;
  }
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
  {
    v89 = (const char *)dyld4::PrebuiltLoader::path(v86, this);
    dyld4::RuntimeState::log(this, "PrebuiltLoader %p not used because Loader for %s is invalid\n", v10, v89);
  }
  *((_QWORD *)this + 127) = 0;
  *((_BYTE *)this + 1040) = v50;
  if ((v50 & 1) == 0)
  {
    v76 = 0;
    LOBYTE(v50) = 0;
    goto LABEL_69;
  }
LABEL_65:
  dyld4::RuntimeState::buildAppPrebuiltLoaderSetPath(this, 1);
  *((_BYTE *)this + 1041) = 0;
  if (!v49)
    return;
  v77 = (char *)this + 1041;
  LOBYTE(v50) = 1;
  if (*v53)
    return;
LABEL_71:
  v78 = *((_QWORD *)this + 1);
  v79 = v50 ^ 1;
  if (!*(_QWORD *)(v78 + 240))
    v79 = 1;
  if ((v79 & 1) == 0)
  {
    v80 = (const char *)*((_QWORD *)this + 126);
    if (v80)
    {
      *v77 = 1;
      if (*(_BYTE *)(v78 + 207))
        dyld4::RuntimeState::log(this, "PrebuiltLoaderSet required for '%s' but not found at '%s'\n", *(const char **)(v78 + 136), v80);
    }
  }
}

uint64_t dyld4::PrebuiltLoaderSet::validHeader(dyld4::PrebuiltLoaderSet *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this == 1936733284)
  {
    if (*((_DWORD *)this + 1) == 389703534)
      return 1;
    if (*(_BYTE *)(*((_QWORD *)a2 + 1) + 207))
      dyld4::console((dyld4 *)"not using PrebuiltLoaderSet %p because versionHash (0x%08X) does not match dyld (0x%08X)\n", (const char *)a2, this, *((unsigned int *)this + 1), 389703534);
  }
  else if (*(_BYTE *)(*((_QWORD *)a2 + 1) + 207))
  {
    dyld4::console((dyld4 *)"not using PrebuiltLoaderSet %p because magic at start does not match\n", (const char *)a2, this);
  }
  return 0;
}

char *DyldSharedCache::findLaunchLoaderSet(DyldSharedCache *this, const char *a2)
{
  uint64_t v2;
  uint64_t v4;
  char *v6;
  const unsigned __int8 **v7;
  Diagnostics *v8;
  uint64_t v9;
  const char *v10;
  const unsigned __int8 *v11;
  unint64_t v12;
  char *v13;
  const unsigned __int8 **v15;
  vm_address_t *v16;

  v2 = *((unsigned int *)this + 4);
  if (v2 < 0x168)
    return 0;
  v4 = *((_QWORD *)this + 44);
  if (!v4)
    return 0;
  v6 = (char *)this - *(_QWORD *)((char *)this + v2);
  v7 = (const unsigned __int8 **)&v6[v4];
  v8 = (Diagnostics *)&v6[v4 + *((unsigned int *)this + 90)];
  v9 = *((_QWORD *)this + 42);
  Diagnostics::Diagnostics((Diagnostics *)&v16);
  v15 = dyld3::MachOFile::trieWalk((vm_address_t *)&v16, v7, v8, (const unsigned __int8 *)a2, v10);
  if (v15
    && (v12 = dyld3::MachOFile::read_uleb128((vm_address_t *)&v16, &v15, (const unsigned __int8 **)v8, v11), v12 < *((_QWORD *)this + 43)))
  {
    v13 = &v6[v9 + v12];
  }
  else
  {
    v13 = 0;
  }
  mach_o::Error::~Error(&v16);
  return v13;
}

const char *dyld4::ProcessConfig::Process::appleParam(const char ***this, char *a2)
{
  return _simple_getenv(this[15], a2);
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;

  *(_OWORD *)(a1 + 16) = 0u;
  v5 = (_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)a1 = *a3;
  *(_QWORD *)(a1 + 8) = a3[1];
  v6 = a3 + 3;
  v7 = a3[2];
  *v5 = a3 + 3;
  *(_QWORD *)(a1 + 24) = v7;
  if (v7)
  {
    v8 = dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v5, v7);
    v11 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 32) = v7;
    if (v11)
      dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap((uint64_t)v8, v9, v10);
  }
  v12 = &v6[v7];
  v13 = *v12;
  *(_QWORD *)(a1 + 56) = v12 + 1;
  *(_QWORD *)(a1 + 64) = v13;
  if (v13)
  {
    dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve((_QWORD *)(a1 + 56), v13);
    *(_QWORD *)(a1 + 72) = v13;
  }
  *(_QWORD *)(a1 + 96) = a2;
  return a1;
}

BOOL dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp(dyld4::ProcessConfig::PathOverrides *this)
{
  return *(_QWORD *)this
      || *((_QWORD *)this + 1)
      || *((_QWORD *)this + 4)
      || *((_QWORD *)this + 5)
      || *((_QWORD *)this + 12)
      || *((_QWORD *)this + 13)
      || *((_QWORD *)this + 11)
      || *((_QWORD *)this + 10)
      || *((_QWORD *)this + 6)
      || *((_QWORD *)this + 7) != 0;
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;

  *(_OWORD *)(a1 + 16) = 0u;
  v5 = (_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)a1 = *a3;
  *(_QWORD *)(a1 + 8) = a3[1];
  v6 = a3 + 3;
  v7 = a3[2];
  *v5 = a3 + 3;
  *(_QWORD *)(a1 + 24) = v7;
  if (v7)
  {
    v8 = dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v5, v7);
    v11 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 32) = v7;
    if (v11)
      dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap((uint64_t)v8, v9, v10);
  }
  v12 = &v6[v7];
  v13 = *v12;
  *(_QWORD *)(a1 + 56) = v12 + 1;
  *(_QWORD *)(a1 + 64) = v13;
  if (v13)
  {
    dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve((_QWORD *)(a1 + 56), v13);
    *(_QWORD *)(a1 + 72) = v13;
  }
  *(_QWORD *)(a1 + 96) = a2;
  return a1;
}

void dyld4::RuntimeState::allocateProcessArrays(dyld4::RuntimeState *this, unint64_t a2)
{
  *((_QWORD *)this + 128) = lsl::Allocator::malloc(*((lsl::Allocator **)this + 2), a2);
  *((_QWORD *)this + 129) = lsl::Allocator::malloc(*((lsl::Allocator **)this + 2), 8 * a2);
  bzero(*((void **)this + 128), a2);
  bzero(*((void **)this + 129), 8 * a2);
}

BOOL hexStringToBytes(const char *a1, unsigned __int8 *a2, unsigned int a3, unsigned int *a4)
{
  char v4;
  int v5;
  const char *v6;
  char v7;
  char v8;
  unsigned __int8 v9;
  int v10;
  _BOOL8 result;

  *a4 = 0;
  v4 = *a1;
  if (!*a1)
    return 1;
  v5 = 0;
  v6 = a1 + 1;
  v7 = 1;
  while (1)
  {
    v8 = v4 - 48;
    if ((v4 - 48) < 0xAu)
      goto LABEL_6;
    if ((v4 - 65) <= 5u)
    {
      v8 = v4 - 55;
LABEL_6:
      if ((v7 & 1) != 0)
        goto LABEL_7;
      goto LABEL_10;
    }
    if ((v4 - 97) > 5u)
      return 0;
    v8 = v4 - 87;
    if ((v7 & 1) != 0)
    {
LABEL_7:
      v9 = 16 * v8;
      goto LABEL_11;
    }
LABEL_10:
    *a4 = v5 + 1;
    v9 = a2[v5] | v8;
LABEL_11:
    a2[v5] = v9;
    v10 = *(unsigned __int8 *)v6++;
    v4 = v10;
    result = v10 == 0;
    if (v10)
    {
      v7 ^= 1u;
      v5 = *a4;
      if (*a4 <= a3)
        continue;
    }
    return result;
  }
}

_QWORD *dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  const void **v3;
  vm_address_t v4;
  vm_size_t v5;
  unint64_t v6;
  vm_size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;

  v2 = result[1];
  if (v2 < a2)
  {
    v3 = (const void **)result;
    v4 = result[3];
    v5 = result[4];
    v6 = 2 * v2;
    if (v6 <= a2)
      v6 = a2;
    v7 = (vm_page_size + 8 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    result = memmove((void *)v3[3], *v3, 8 * (_QWORD)v3[2]);
    v11 = (const void *)((unint64_t)v3[4] >> 3);
    *v3 = v3[3];
    v3[1] = v11;
    if (v4)
      return (_QWORD *)vm_deallocate(mach_task_self_, v4, v5);
  }
  return result;
}

void dyld4::RuntimeState::buildAppPrebuiltLoaderSetPath(dyld4::RuntimeState *this, int a2)
{
  const char *v4;
  uint64_t v5;
  BOOL v6;
  char *v7;
  dyld4::SyscallDelegate *v8;
  _BOOL4 isMaybeContainerized;
  uint64_t v10;
  stat *v11;
  char *v12;
  const char *v13;
  dyld4::SyscallDelegate *v14;
  stat *v15;
  const char *v16;
  char *v17;
  size_t v18;
  char **v19;
  unint64_t v20;
  int v21;
  char *v22;
  char __source[32];
  char __dst[1024];

  v4 = dyld4::ProcessConfig::Process::environ((const char ***)(*((_QWORD *)this + 1) + 8), "DYLD_CLOSURE_DIR");
  v5 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v5 + 169))
    v6 = v4 == 0;
  else
    v6 = 1;
  if (!v6)
  {
    strlcpy(__dst, v4, 0x400uLL);
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
      dyld4::RuntimeState::log(this, "using DYLD_CLOSURE_DIR to find loaders\n");
    goto LABEL_16;
  }
  v7 = (char *)dyld4::ProcessConfig::Process::environ((const char ***)(v5 + 8), "HOME");
  v8 = (dyld4::SyscallDelegate *)*((_QWORD *)this + 1);
  if (!v7)
  {
    if (*((_BYTE *)v8 + 207))
      dyld4::RuntimeState::log(this, "did not look for saved PrebuiltLoaderSet because $DYLD_CLOSURE_DIR and $HOME are not set\n");
    return;
  }
  isMaybeContainerized = dyld4::SyscallDelegate::isMaybeContainerized(v8, v7);
  v10 = *((_QWORD *)this + 1);
  if (!isMaybeContainerized)
  {
    if (!*(_BYTE *)(v10 + 169))
    {
      if (*(_BYTE *)(v10 + 207))
        dyld4::RuntimeState::log(this, "did not look for saved PrebuiltLoaderSet because $HOME is not containerized and this is not an internal install\n");
      return;
    }
    v13 = dyld4::ProcessConfig::Process::environ((const char ***)(v10 + 8), "DYLD_USE_CLOSURES");
    v14 = (dyld4::SyscallDelegate *)*((_QWORD *)this + 1);
    if (!v13)
    {
      if (*((_BYTE *)v14 + 207))
        dyld4::RuntimeState::log(this, "did not look for saved PrebuiltLoaderSet because DYLD_USE_CLOSURES is not set\n");
      return;
    }
    if (dyld4::SyscallDelegate::realpathdir(v14, (dyld3 *)v7, __dst))
    {
      strlcat(__dst, "/Library/Caches/com.apple.dyld/", 0x400uLL);
      strlcat(__dst, *(const char **)(*((_QWORD *)this + 1) + 136), 0x400uLL);
      strlcat(__dst, "/", 0x400uLL);
      if (!a2
        || dyld4::SyscallDelegate::dirExists(*((dyld4::SyscallDelegate **)this + 1), (dyld3 *)__dst, v15)
        || dyld4::SyscallDelegate::mkdirs(*((dyld4::SyscallDelegate **)this + 1), __dst))
      {
        v16 = dyld4::ProcessConfig::Process::appleParam((const char ***)(*((_QWORD *)this + 1) + 8), "executable_cdhash");
        if (v16)
        {
          strlcat(__dst, v16, 0x400uLL);
          strlcat(__dst, "-", 0x400uLL);
        }
        v17 = *(char **)(*((_QWORD *)this + 1) + 16);
        v18 = _platform_strlen(v17);
        v20 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)__source, (uint64_t *)v17, v18);
        v22 = __source;
        v21 = 8;
        do
        {
          dyld4::Loader::appendHexByte(v20, &v22, v19);
          v20 >>= 8;
          --v21;
        }
        while (v21);
        *v22 = 0;
        v12 = __source;
        goto LABEL_31;
      }
      goto LABEL_42;
    }
LABEL_32:
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
      dyld4::RuntimeState::log(this, "did not look for saved PrebuiltLoaderSet because $HOME failed realpath\n");
    return;
  }
  if (!dyld4::SyscallDelegate::realpathdir((dyld4::SyscallDelegate *)v10, (dyld3 *)v7, __dst))
    goto LABEL_32;
  strlcat(__dst, "/Library/Caches/com.apple.dyld/", 0x400uLL);
  if (dyld4::SyscallDelegate::isContainerized(*((dyld4::SyscallDelegate **)this + 1), __dst))
  {
    if (!a2
      || dyld4::SyscallDelegate::dirExists(*((dyld4::SyscallDelegate **)this + 1), (dyld3 *)__dst, v11)
      || dyld4::SyscallDelegate::mkdirs(*((dyld4::SyscallDelegate **)this + 1), __dst))
    {
      v12 = *(char **)(*((_QWORD *)this + 1) + 136);
LABEL_31:
      strlcat(__dst, v12, 0x400uLL);
      strlcat(__dst, ".dyld4", 0x400uLL);
LABEL_16:
      *((_QWORD *)this + 126) = lsl::Allocator::strdup(*((lsl::Allocator **)this + 2), __dst);
      return;
    }
LABEL_42:
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
      dyld4::RuntimeState::log(this, "failed to make directory for PrebuiltLoaderSet\n");
    return;
  }
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
    dyld4::RuntimeState::log(this, "did not look for saved PrebuiltLoaderSet because $HOME is not containerized\n");
}

const char *dyld4::ProcessConfig::Process::environ(const char ***this, char *a2)
{
  return _simple_getenv(this[14], a2);
}

BOOL dyld4::SyscallDelegate::isMaybeContainerized(dyld4::SyscallDelegate *this, char *__s1)
{
  return __s1 && strstr(__s1, "/var/mobile/Containers/Data/") != 0;
}

const char *_platform_strstr(const char *a1, char *__s)
{
  const char *v2;
  const char *v3;
  int v4;
  size_t v5;
  int v6;
  const char *v7;

  v2 = a1;
  v3 = __s + 1;
  v4 = *__s;
  if (!*__s)
    return a1;
  v5 = _platform_strlen(__s + 1);
  while (1)
  {
    v6 = *(unsigned __int8 *)v2;
    if (!*v2)
      break;
    v7 = v2++;
    if (v6 == v4 && !_platform_strncmp(v2, v3, v5))
      return v7;
  }
  return 0;
}

BOOL dyld4::PrebuiltLoader::recordedCdHashIs(dyld4::PrebuiltLoader *this, const unsigned __int8 *a2)
{
  _BOOL8 result;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  result = 0;
  if (this && *((_WORD *)this + 21))
  {
    v4 = (char *)this + *((unsigned __int16 *)this + 21);
    if (v4[53])
    {
      v5 = *((_QWORD *)v4 + 4);
      v6 = *((_QWORD *)v4 + 5);
      v7 = *((unsigned int *)v4 + 12);
      return v5 == *(_QWORD *)a2 && v6 == *((_QWORD *)a2 + 1) && v7 == *((_DWORD *)a2 + 4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL dyld4::SyscallDelegate::isContainerized(dyld4::SyscallDelegate *this, const char *__s1)
{
  return __s1 && _platform_strncmp(__s1, "/private/var/mobile/Containers/Data/", 0x24uLL) == 0;
}

uint64_t dyld4::APIs::_dyld_find_foreign_type_protocol_conformance(dyld4::APIs *this, char *a2, const char *a3, uint64_t a4)
{
  uint64_t v8;
  dyld4::objc_headeropt_rw_t *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int Potential;
  unsigned int v16;
  unint64_t v17;
  char isLoaded;
  uint64_t i;
  char v20;
  _QWORD v21[3];

  v8 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v8 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_find_protocol_conformance(%p, %s)\n", a2, a3);
    v8 = *((_QWORD *)this + 1);
  }
  v9 = *(dyld4::objc_headeropt_rw_t **)(v8 + 296);
  v10 = *(_QWORD *)(v8 + 344);
  if (v9)
    v11 = v10 == 0;
  else
    v11 = 1;
  if (v11)
    return 2;
  v12 = *(_QWORD *)(v10 + 24);
  if (!v12)
    return 2;
  v13 = *(_QWORD *)(v8 + 240);
  v21[0] = a3;
  v21[1] = a4;
  v21[2] = &a2[-v13];
  Potential = SwiftHashTable::getPotentialTarget<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>((unsigned int *)(v13 + v12), (uint64_t)v21, v13);
  if (Potential == *(_DWORD *)(v13 + v12 + 16))
    return 2;
  v16 = Potential;
  v17 = *(_QWORD *)(v13 + v12 + Potential + 16);
  isLoaded = dyld4::objc_headeropt_rw_t::isLoaded(v9, HIWORD(v17));
  if ((v17 & 1) != 0)
  {
    if ((isLoaded & 1) == 0)
    {
      for (i = v12 + v16 + v13 + 40; (*(_BYTE *)(i - 24) & 1) != 0; i += 24)
      {
        v20 = dyld4::objc_headeropt_rw_t::isLoaded(v9, *(unsigned __int16 *)(i + 6));
        if ((v20 & 1) != 0)
          return 0;
      }
      return 2;
    }
  }
  else if ((isLoaded & 1) == 0)
  {
    return 2;
  }
  return 0;
}

uint64_t SwiftHashTable::getPotentialTarget<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;

  v4 = SwiftHashTable::getIndex<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>(a1, a2, a3);
  if ((_DWORD)v4 == -1)
  {
    v8 = a1 + 4;
  }
  else
  {
    v7 = *a1;
    if (v7 <= v4)
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v4, v5, v6);
    v8 = (unsigned int *)((char *)&a1[v4 + 264] + a1[5] + v7);
  }
  return *v8;
}

uint64_t SwiftHashTable::getIndex<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v6 = SwiftHashTable::hash<SwiftForeignTypeProtocolConformanceLookupKey>((uint64_t)a1, a2);
  if (*a1 <= v6)
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v6, v7, v8);
  v9 = v6;
  v10 = *((unsigned __int8 *)a1 + v6 + a1[5] + 1056);
  v11 = SwiftHashTable::checkbyte<SwiftForeignTypeProtocolConformanceLookupKey>((uint64_t)a1, a2);
  if (v10 != (_DWORD)v11)
    return 0xFFFFFFFFLL;
  v14 = *a1;
  if (v14 <= v9)
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v11, v12, v13);
  v15 = *(unsigned int *)((char *)&a1[v9 + 264] + a1[5] + v14);
  if ((_DWORD)v15 == -1)
    return 0xFFFFFFFFLL;
  if (SwiftHashTable::equal<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>((uint64_t)a1, (unsigned int *)((char *)a1 + v15), a2, a3))
  {
    return v9;
  }
  return 0xFFFFFFFFLL;
}

uint64_t SwiftHashTable::checkbyte<SwiftForeignTypeProtocolConformanceLookupKey>(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 8) & 0x1F | (32 * (**(_BYTE **)a2 & 7u));
}

uint64_t SwiftHashTable::hash<SwiftForeignTypeProtocolConformanceLookupKey>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  int v6;
  unsigned int v7;

  v4 = objc::lookup8(*(objc **)a2, *(const unsigned __int8 **)(a2 + 8), *(_QWORD *)(a1 + 24));
  v5 = objc::lookup8((objc *)(a2 + 16), (const unsigned __int8 *)8, *(_QWORD *)(a1 + 24));
  v6 = *(_DWORD *)(a1 + 8);
  if (v6 == 64)
    v7 = 0;
  else
    v7 = (v5 ^ v4) >> v6;
  return v7 ^ *(_DWORD *)(a1 + 4 * *(unsigned __int8 *)(a1 + ((v5 ^ v4) & *(unsigned int *)(a1 + 12)) + 1056) + 32);
}

BOOL SwiftHashTable::equal<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  size_t v4;

  v4 = HIWORD(*a2);
  return a2[1] == *(_QWORD *)(a3 + 16)
      && v4 == *(_QWORD *)(a3 + 8)
      && _platform_memcmp((const void *)(a4 + (*a2 & 0xFFFFFFFFFFFFLL)), *(const void **)a3, v4) == 0;
}

int _platform_memcmp(const void *__s1, const void *__s2, size_t __n)
{
  BOOL v3;
  size_t v4;
  char *v5;
  char *v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  BOOL v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  uint8x16_t v16;
  size_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  unsigned int v24;
  unsigned int v25;
  unint64_t v26;
  uint64_t v27;
  unsigned int v28;
  int v29;

  v3 = __n >= 0x10;
  v4 = __n - 16;
  if (!v3)
  {
    v3 = __CFADD__(v4, 8);
    v17 = v4 + 8;
    if (v3)
    {
      v19 = *(_QWORD *)__s1;
      __s1 = (char *)__s1 + 8;
      v18 = v19;
      v21 = *(_QWORD *)__s2;
      __s2 = (char *)__s2 + 8;
      v20 = v21;
      v22 = v18 - v21;
      if (v18 != v21)
        goto LABEL_18;
      v17 -= 8;
    }
    v3 = __CFADD__(v17, 4);
    v23 = v17 + 4;
    if (!v3)
    {
      v23 += 4;
      LODWORD(v22) = 0;
      goto LABEL_20;
    }
    v24 = *(_DWORD *)__s1;
    __s1 = (char *)__s1 + 4;
    v18 = v24;
    v25 = *(_DWORD *)__s2;
    __s2 = (char *)__s2 + 4;
    v20 = v25;
    v22 = v18 - v25;
    if (v18 == v25)
    {
      do
      {
LABEL_20:
        v3 = v23-- != 0;
        if (!v3)
          break;
        v28 = *(unsigned __int8 *)__s1;
        __s1 = (char *)__s1 + 1;
        v27 = v28;
        v29 = *(unsigned __int8 *)__s2;
        __s2 = (char *)__s2 + 1;
        LODWORD(v22) = v27 - v29;
      }
      while (v27 == v29);
      return v22;
    }
LABEL_18:
    v26 = __clz(bswap64(v22)) & 0xFFFFFFFFFFFFFFF8;
    return (v18 >> v26) - (v20 >> v26);
  }
  if (v4)
  {
    v5 = (char *)__s1 + v4;
    v6 = (char *)__s2 + v4;
    while (1)
    {
      v7 = *(int8x16_t *)__s1;
      __s1 = (char *)__s1 + 16;
      v8 = v7;
      v9 = *(int8x16_t *)__s2;
      __s2 = (char *)__s2 + 16;
      v10 = vceqq_s8(v8, v9);
      v8.i8[0] = vminvq_u8((uint8x16_t)v10);
      if (!v8.i32[0])
        break;
      v11 = v4 > 0x10;
      v4 -= 16;
      if (!v11)
      {
        __s1 = v5;
        __s2 = v6;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v12 = *(int8x16_t *)__s1;
    __s1 = (char *)__s1 + 16;
    v13 = v12;
    v14 = *(int8x16_t *)__s2;
    __s2 = (char *)__s2 + 16;
    v10 = vceqq_s8(v13, v14);
    v13.i8[0] = vminvq_u8((uint8x16_t)v10);
    if (v13.i32[0])
      return 0;
  }
  v16 = (uint8x16_t)vorrq_s8(v10, (int8x16_t)xmmword_1A5C772A0);
  v16.i8[0] = vminvq_u8(v16);
  return *((unsigned __int8 *)__s1 + v16.u32[0] - 16) - *((unsigned __int8 *)__s2 + v16.u32[0] - 16);
}

uint64_t dyld4::APIs::_dyld_find_foreign_type_protocol_conformance_on_disk(dyld4::APIs *this, dyld4::PrebuiltLoader::BindTargetRef *a2, dyld4::PrebuiltLoader::BindTargetRef *a3, uint64_t a4)
{
  dyld4::PrebuiltLoaderSet *v4;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _QWORD v21[4];

  v4 = (dyld4::PrebuiltLoaderSet *)*((_QWORD *)this + 127);
  if (!v4)
    return 2;
  if (!dyld4::PrebuiltLoaderSet::hasOptimizedSwift(*((dyld4::PrebuiltLoaderSet **)this + 127)))
    return 2;
  if (!dyld4::PrebuiltLoaderSet::swiftForeignTypeProtocolTable(v4))
    return 2;
  if (!*((_QWORD *)this + 67))
    return 2;
  v21[0] = 0;
  v21[1] = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a3);
  v21[2] = a4;
  v21[3] = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a2);
  v10 = (_QWORD *)dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::find(*((_QWORD *)this + 67), (uint64_t)v21, v9);
  if (v10 == (_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 67) + 56) + 48 * *(_QWORD *)(*((_QWORD *)this + 67) + 72)))
    return 2;
  v11 = v10;
  if (dyld4::EqualForeignConformanceLookupKey::equal(v10, (const char *)a3, a4, (uint64_t)a2, this))
  {
LABEL_10:
    v20 = v11[4];
    v16 = dyld4::PrebuiltLoader::BindTargetRef::loaderRef((dyld4::PrebuiltLoader::BindTargetRef *)&v20, v12, v13);
    if (*((_DWORD *)v4 + 3) <= (v16 & 0x7FFF))
      dyld4::RuntimeState::findPrebuiltLoader(v16, v17, v18);
    dyld4::PrebuiltLoader::loadAddress((dyld4::PrebuiltLoaderSet *)((char *)v4+ *(unsigned int *)((char *)v4 + 4 * (v16 & 0x7FFF) + *((unsigned int *)v4 + 4))), this);
    dyld4::PrebuiltLoader::BindTargetRef::offset((dyld4::PrebuiltLoader::BindTargetRef *)&v20);
    return 0;
  }
  else
  {
    v14 = 2;
    while (1)
    {
      v15 = v11[5];
      if ((v15 & 3) == 0)
        break;
      v11 = (_QWORD *)dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((_QWORD *)(*((_QWORD *)this + 67) + 56), v15 >> 3);
      if (dyld4::EqualForeignConformanceLookupKey::equal(v11, (const char *)a3, a4, (uint64_t)a2, this))
        goto LABEL_10;
    }
  }
  return v14;
}

uint64_t dyld4::PrebuiltLoaderSet::swiftForeignTypeProtocolTable(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1;

  v1 = *((unsigned int *)this + 18);
  if ((_DWORD)v1)
    return (uint64_t)this + v1;
  else
    return 0;
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::find(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t i;
  uint64_t v8;

  v5 = (*(_QWORD *)(a1 + 32) - 1) & dyld4::HashForeignConformanceKey::hash(a2, *(dyld4::RuntimeState **)(a1 + 96), a3);
  v6 = *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v5);
  if (v6 == -1)
    return *(_QWORD *)(a1 + 56) + 48 * *(_QWORD *)(a1 + 72);
  for (i = 1; ; ++i)
  {
    v8 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v6);
    if (dyld4::EqualForeignConformanceKey::equal(v8, a2, *(dyld4::RuntimeState **)(a1 + 96)))
      break;
    v5 = (*(_QWORD *)(a1 + 32) - 1) & (v5 + i);
    v6 = *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v5);
    if (v6 == -1)
      return *(_QWORD *)(a1 + 56) + 48 * *(_QWORD *)(a1 + 72);
  }
  return dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v6);
}

unint64_t dyld4::HashForeignConformanceKey::hash(uint64_t a1, dyld4::RuntimeState *a2, uint64_t a3)
{
  uint64_t *v4;
  unint64_t v5;
  unint64_t v7;

  if (a2)
    v4 = (uint64_t *)dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8), a2, a3);
  else
    v4 = *(uint64_t **)a1;
  v7 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 24)) & 0xFFF;
  v5 = murmurHash(v4, *(_DWORD *)(a1 + 16), 0);
  return murmurHash((uint64_t *)&v7, 8, 0) ^ v5;
}

BOOL dyld4::EqualForeignConformanceKey::equal(uint64_t a1, uint64_t a2, dyld4::RuntimeState *a3)
{
  const char *v6;
  uint64_t v7;
  const char *v8;
  size_t v9;
  BOOL v10;
  int v12;

  if (a3)
  {
    v6 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8), a3, (uint64_t)a3);
    v8 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a2 + 8), a3, v7);
  }
  else
  {
    v6 = *(const char **)a1;
    v8 = *(const char **)a2;
  }
  v9 = *(_QWORD *)(a1 + 16);
  if (_platform_strncmp(v6, v8, v9))
    v10 = 0;
  else
    v10 = v9 == *(_QWORD *)(a2 + 16);
  if (!v10)
    return 0;
  v12 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 24));
  return ((dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a2 + 24)) ^ v12) & 0xFFFLL) == 0;
}

BOOL dyld4::EqualForeignConformanceLookupKey::equal(_QWORD *a1, const char *a2, uint64_t a3, uint64_t a4, dyld4::RuntimeState *a5)
{
  const char *v10;
  size_t v11;
  int v12;
  uint64_t v13;

  if (!a5)
    dyld4::EqualForeignConformanceLookupKey::equal();
  v10 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 1), a5, a3);
  v11 = a1[2];
  v12 = _platform_strncmp(v10, a2, v11);
  return v11 == a3
      && v12 == 0
      && dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 3), a5, v13) == a4;
}

uint64_t dyld4::APIs::dlclose(dyld4::APIs *this, unint64_t a2)
{
  dyld4::RuntimeLocks *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  const dyld4::Loader *v13;
  uint64_t v14;
  uint64_t v15;
  int v17;
  unint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;

  v4 = (dyld4::RuntimeLocks *)*((_QWORD *)this + 17);
  dyld4::RuntimeLocks::takeDlopenLockBeforeFork(v4);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dlclose(%p)\n", (const void *)a2);
  v17 = 520617992;
  v18 = a2;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v17, v5, v6, v7, v8, v9, v10, v11);
  v12 = 0;
  if (a2 != -5 && a2 != -2)
  {
    if (a2)
      v13 = (const dyld4::Loader *)(a2 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_1A5C55000);
    else
      v13 = 0;
    if (dyld4::APIs::validLoader((lsl::Allocator **)this, v13))
    {
      dyld4::RuntimeState::decDlRefCount((const os_unfair_lock *)this, v13);
      if (*((_QWORD *)this + 143) != -1
        && (v14 = *((_QWORD *)this + 19)) != 0
        && (v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 64))(v14)) != 0)
      {
        v12 = 0;
        *(_BYTE *)(v15 + 8) = 0;
      }
      else
      {
        v12 = 0;
      }
    }
    else
    {
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlclose(%p): invalid handle", (const void *)a2);
      v12 = 0xFFFFFFFFLL;
    }
  }
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v17);
  dyld4::RuntimeLocks::releaseDlopenLockInForkParent(v4);
  return v12;
}

const os_unfair_lock *dyld4::RuntimeState::decDlRefCount(const os_unfair_lock *this, const dyld4::Loader *a2)
{
  os_unfair_lock *v3;
  lsl::Lock *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  size_t v8;
  unsigned int *p_os_unfair_lock_opaque;
  unsigned int v11;
  unsigned int v12;
  BOOL v13;
  signed int v14;
  uint64_t v15;
  lsl::Lock *v16;

  if ((*((_WORD *)a2 + 2) & 0x20) == 0)
  {
    v3 = (os_unfair_lock *)this;
    v4 = *(lsl::Lock **)&this[32]._os_unfair_lock_opaque;
    lsl::MemoryManager::lockGuard(v4, &v16);
    v5 = *((_QWORD *)v4 + 3);
    if (!v5)
    {
      lsl::MemoryManager::writeProtect(v4, 0);
      v5 = *((_QWORD *)v4 + 3);
    }
    *((_QWORD *)v4 + 3) = v5 + 1;
    lsl::Lock::unlock(v16);
    v6 = *(_QWORD *)&v3[270]._os_unfair_lock_opaque;
    if (v6)
    {
      v7 = (_QWORD *)(*(_QWORD *)&v3[268]._os_unfair_lock_opaque + 8);
      v8 = 16 * v6 - 16;
      while ((const dyld4::Loader *)*(v7 - 1) != a2)
      {
        v7 += 2;
        v8 -= 16;
        if (v8 == -16)
          goto LABEL_20;
      }
      if ((*v7)-- == 1)
      {
        if (v8)
        {
          memmove(v7 - 1, v7 + 1, v8);
          v6 = *(_QWORD *)&v3[270]._os_unfair_lock_opaque;
        }
        *(_QWORD *)&v3[270]._os_unfair_lock_opaque = v6 - 1;
        p_os_unfair_lock_opaque = &v3[282]._os_unfair_lock_opaque;
        do
          v11 = __ldxr(p_os_unfair_lock_opaque);
        while (__stxr(v11 + 1, p_os_unfair_lock_opaque));
        if (!v11)
        {
          do
          {
            dyld4::RuntimeState::garbageCollectInner((dyld4::RuntimeState *)v3);
            do
            {
              v12 = __ldxr(p_os_unfair_lock_opaque);
              v13 = __OFSUB__(v12, 1);
              v14 = v12 - 1;
            }
            while (__stxr(v14, p_os_unfair_lock_opaque));
          }
          while (!((v14 < 0) ^ v13 | (v14 == 0)));
        }
      }
    }
LABEL_20:
    lsl::MemoryManager::lockGuard(v4, &v16);
    v15 = *((_QWORD *)v4 + 3) - 1;
    *((_QWORD *)v4 + 3) = v15;
    if (!v15)
      lsl::MemoryManager::writeProtect(v4, 1);
    return lsl::Lock::unlock(v16);
  }
  return this;
}

uint64_t dyld3::MachOFile::forEachTreatAsWeakDef(uint64_t a1)
{
  uint64_t i;
  uint64_t result;

  for (i = 0; i != 22; ++i)
    result = (*(uint64_t (**)(uint64_t, char *))(a1 + 16))(a1, dyld3::sTreatAsWeak[i]);
  return result;
}

void ___ZN5dyld416JustInTimeLoader28handleStrongWeakDefOverridesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2(uint64_t a1, const char *a2)
{
  _BYTE v4[40];
  vm_address_t *v5;

  Diagnostics::Diagnostics((Diagnostics *)&v5);
  dyld4::Loader::resolveSymbol(*(dyld4::Loader **)(a1 + 40), *(dyld4::RuntimeState **)(a1 + 48), (vm_address_t *)&v5, 4294967293, a2, 1, 0, *(_QWORD *)(a1 + 32), (uint64_t)v4);
  mach_o::Error::~Error(&v5);
}

void mach_o::Fixups::forEachBindTarget_ChainedFixups(dyld3::MachOFile ***a1, vm_address_t *a2, uint64_t a3)
{
  _QWORD v6[6];
  _QWORD v7[6];
  _QWORD v8[3];
  int v9;

  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  v9 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke;
  v7[3] = &unk_1E4F7F1B0;
  v7[4] = a3;
  v7[5] = v8;
  mach_o::Fixups::forEachChainedFixupTarget(a1, a2, (uint64_t)v7);
  if (Diagnostics::noError((Diagnostics *)a2)
    && dyld3::MachOFile::isMainExecutable(**a1)
    && dyld3::MachOFile::hasWeakDefs(**a1))
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2;
    v6[3] = &unk_1E4F7F1D8;
    v6[4] = a3;
    v6[5] = v8;
    dyld3::MachOFile::forEachTreatAsWeakDef((uint64_t)v6);
  }
  _Block_object_dispose(v8, 8);
}

BOOL dyld3::MachOFile::isMainExecutable(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 2;
}

dyld3::MachOFile ***mach_o::Fixups::forEachChainedFixupTarget(dyld3::MachOFile ***result, vm_address_t *this, uint64_t a3)
{
  dyld3::MachOFile *v3;
  _QWORD v4[5];

  v3 = (*result)[3];
  if (*((_BYTE *)v3 + 316))
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = ___ZNK6mach_o6Fixups25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke;
    v4[3] = &unk_1E4F7F200;
    v4[4] = a3;
    return (dyld3::MachOFile ***)mach_o::Fixups::parseOrgArm64eChainedFixups(result, this, 0, (uint64_t)v4, 0);
  }
  else if (*((_BYTE *)v3 + 412))
  {
    return (dyld3::MachOFile ***)dyld3::MachOFile::forEachChainedFixupTarget(this, *((unsigned int **)v3 + 49), *((_QWORD *)v3 + 52), a3);
  }
  return result;
}

BOOL mach_o::Fixups::forEachBind_OpcodesLazy(dyld3::MachOFile ***a1, Diagnostics *a2, uint64_t a3)
{
  unsigned int v6;
  char v7;
  char v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  dyld3::MachOFile *v12;
  const unsigned __int8 **v13;
  const unsigned __int8 *v14;
  const unsigned __int8 **v15;
  _BYTE *v16;
  unsigned __int8 v17;
  char v18;
  const unsigned __int8 **v19;
  int v20;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  const unsigned __int8 **v29;
  char v30;

  if (!*((_BYTE *)(*a1)[3] + 380))
    return 0;
  v6 = dyld3::MachOFile::pointerSize(**a1);
  v30 = 0;
  v26 = dyld3::MachOFile::dependentDylibCount(**a1, 0);
  v7 = 0;
  v27 = 0;
  v28 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = (*a1)[3];
  v13 = (const unsigned __int8 **)(*((_QWORD *)v12 + 45) + *((unsigned int *)v12 + 92));
  v29 = (const unsigned __int8 **)*((_QWORD *)v12 + 45);
  v25 = v6;
  do
  {
    if (!Diagnostics::noError(a2))
      break;
    v15 = v29;
    if (v29 >= v13)
      break;
    v16 = (char *)v29 + 1;
    v17 = *(_BYTE *)v29;
    v29 = (const unsigned __int8 **)((char *)v29 + 1);
    v18 = v17 & 0xF;
    switch(v17 >> 4)
    {
      case 0:
        break;
      case 1:
        v8 = 1;
        v9 = v17 & 0xF;
        break;
      case 2:
        v9 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v29, v13, v14);
        goto LABEL_11;
      case 3:
        if ((v17 & 0xF) != 0)
          v9 = *(_DWORD *)&v17 | 0xFFFFFFF0;
        else
          v9 = 0;
LABEL_11:
        v8 = 1;
        break;
      case 4:
        if (*v16)
        {
          v19 = (const unsigned __int8 **)((char *)v15 + 2);
          do
          {
            v29 = v19;
            v20 = *(unsigned __int8 *)v19;
            v19 = (const unsigned __int8 **)((char *)v19 + 1);
          }
          while (v20);
          v15 = (const unsigned __int8 **)((char *)v19 - 2);
        }
        v7 = v17 & 1;
        v29 = (const unsigned __int8 **)((char *)v15 + 2);
        v10 = v16;
        break;
      case 6:
        v28 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &v29, v13, v14);
        break;
      case 7:
        v11 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v29, v13, v14);
        LOBYTE(v27) = v18;
        BYTE4(v27) = 1;
        break;
      case 9:
        LOBYTE(v24) = 1;
        BYTE1(v23) = 1;
        LOBYTE(v23) = v7 & 1;
        LOBYTE(v22) = 1;
        (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", BYTE4(v27) & 1, v8 & 1, v26, v9, v25, v27, v11, v22, v10, v23, v28, v24, &v30);
        v11 += v25;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad lazy bind opcode 0x%02X", v17 & 0xF0);
        break;
    }
  }
  while (!v30);
  return v30 != 0;
}

BOOL mach_o::Fixups::forEachBind_OpcodesRegular(dyld3::MachOFile ***a1, Diagnostics *a2, uint64_t a3)
{
  unsigned int v6;
  char v7;
  char v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  dyld3::MachOFile *v12;
  const unsigned __int8 **v13;
  uint64_t v14;
  const unsigned __int8 *v15;
  const unsigned __int8 **v16;
  unsigned __int8 *v17;
  unsigned int v18;
  int v19;
  const unsigned __int8 **v20;
  int v21;
  const unsigned __int8 *v22;
  unint64_t v23;
  const unsigned __int8 *v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unint64_t v28;
  int v30;
  int v31;
  int v32;
  const unsigned __int8 **v33;
  Diagnostics *v34;
  unsigned __int8 v35;
  unsigned int v36;
  unsigned __int8 *v37;
  char v38;
  uint64_t v39;
  uint64_t v40;
  const unsigned __int8 **v41;
  char v42;

  if (!*((_BYTE *)(*a1)[3] + 316))
    return 0;
  v6 = dyld3::MachOFile::pointerSize(**a1);
  v42 = 0;
  v35 = 0;
  v36 = dyld3::MachOFile::dependentDylibCount(**a1, 0);
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v37 = 0;
  v11 = 0;
  v12 = (*a1)[3];
  v41 = (const unsigned __int8 **)*((_QWORD *)v12 + 37);
  v13 = (const unsigned __int8 **)((char *)v41 + *((unsigned int *)v12 + 76));
  v14 = v6;
  do
  {
    if (!Diagnostics::noError(a2))
      break;
    v16 = v41;
    if ((v41 >= v13) | v7 & 1)
      break;
    v17 = (unsigned __int8 *)v41 + 1;
    v18 = *(unsigned __int8 *)v41;
    v41 = (const unsigned __int8 **)((char *)v41 + 1);
    v19 = v18 & 0xF;
    v7 = 1;
    switch(v18 >> 4)
    {
      case 0u:
        break;
      case 1u:
        v7 = 0;
        v9 = 1;
        v10 = v18 & 0xF;
        break;
      case 2u:
        v10 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v15);
        v7 = 0;
        goto LABEL_12;
      case 3u:
        v7 = 0;
        if ((v18 & 0xF) != 0)
          v10 = v18 | 0xFFFFFFF0;
        else
          v10 = 0;
LABEL_12:
        v9 = 1;
        break;
      case 4u:
        if (*v17)
        {
          v20 = (const unsigned __int8 **)((char *)v16 + 2);
          do
          {
            v41 = v20;
            v21 = *(unsigned __int8 *)v20;
            v20 = (const unsigned __int8 **)((char *)v20 + 1);
          }
          while (v21);
          v16 = (const unsigned __int8 **)((char *)v20 - 2);
        }
        v7 = 0;
        v38 = v18 & 1;
        v41 = (const unsigned __int8 **)((char *)v16 + 2);
        v8 = 1;
        v37 = v17;
        break;
      case 5u:
        v7 = 0;
        BYTE4(v39) = v18 & 0xF;
        break;
      case 6u:
        v40 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &v41, v13, v15);
        v7 = 0;
        v8 = 1;
        break;
      case 7u:
        v11 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v15);
        v7 = 0;
        LOBYTE(v39) = 1;
        v35 = v19;
        break;
      case 8u:
        v7 = 0;
        v11 += dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v15);
        break;
      case 9u:
        LOBYTE(v32) = v8;
        LOWORD(v31) = v38 & 1;
        LOBYTE(v30) = BYTE4(v39);
        (*(void (**)(uint64_t, const char *, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", v39 & 1, v9 & 1, v36, v10, v14, v35, v11, v30, v37, v31, v40, v32, &v42);
        v8 = 0;
        v7 = 0;
        v11 += v14;
        break;
      case 0xAu:
        LOBYTE(v32) = v8;
        LOWORD(v31) = v38 & 1;
        LOBYTE(v30) = BYTE4(v39);
        (*(void (**)(uint64_t, const char *, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", v39 & 1, v9 & 1, v36, v10, v14, v35, v11, v30, v37, v31, v40, v32, &v42);
        v8 = 0;
        v7 = 0;
        v11 += v14 + dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v22);
        break;
      case 0xBu:
        LOBYTE(v32) = v8;
        LOWORD(v31) = v38 & 1;
        LOBYTE(v30) = BYTE4(v39);
        (*(void (**)(uint64_t, const char *, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", v39 & 1, v9 & 1, v36, v10, v14, v35, v11, v30, v37, v31, v40, v32, &v42);
        v8 = 0;
        v7 = 0;
        v11 += (v14 + v14 * v19);
        break;
      case 0xCu:
        v23 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v15);
        v25 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v24);
        if (!v23)
          goto LABEL_30;
        v33 = v13;
        v34 = a2;
        v26 = v25 + v14;
        v27 = 1;
        do
        {
          LOBYTE(v32) = v8;
          LOWORD(v31) = v38 & 1;
          LOBYTE(v30) = BYTE4(v39);
          (*(void (**)(uint64_t, const char *, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", v39 & 1, v9 & 1, v36, v10, v14, v35, v11, v30, v37, v31, v40, v32, &v42);
          v8 = 0;
          v11 += v26;
          if (v42)
            break;
          v28 = v27++;
        }
        while (v23 > v28);
        v7 = 0;
        v13 = v33;
        a2 = v34;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad bind opcode 0x%02X", *v17);
LABEL_30:
        v7 = 0;
        break;
    }
  }
  while (!v42);
  return v42 != 0;
}

uint64_t ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, char a13, uint64_t a14, char a15, uint64_t a16)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;

  v16 = **(_QWORD **)(a1 + 56);
  v18 = *(uint64_t **)(v16 + 8);
  v17 = *(_QWORD *)(v16 + 16);
  if (v17)
  {
    v17 *= 48;
    v19 = v18;
    while (*((_DWORD *)v19 + 11) != 1)
    {
      v19 += 6;
      v17 -= 48;
      if (!v17)
        goto LABEL_7;
    }
    v17 = *v19;
  }
LABEL_7:
  v20 = v18[6 * a8];
  if (a15)
  {
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v22 = *(_DWORD *)(v21 + 24);
    *(_DWORD *)(v21 + 24) = v22 + 1;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = v22;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 44) = a6;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48) = a11;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 56) = a14;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 64) = a12;
    if (a13)
      v23 = *(_BYTE *)(a1 + 64) != 0;
    else
      v23 = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 65) = v23;
  }
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), v20 + a9 - v17, a8, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40, a16);
}

uint64_t ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke(uint64_t result, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v5;

  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) != *a4)
  {
    v5 = result;
    result = (*(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16))();
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 40) + 8) + 24) = *a4;
  }
  return result;
}

vm_address_t *dyld3::MachOFile::forEachChainedFixupTarget(vm_address_t *this, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  vm_address_t *v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v8;
  char *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  char *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  unint64_t v23;
  uint64_t v24;
  char v25;

  v4 = this;
  v5 = a2[2];
  v6 = *(_DWORD *)(a3 + 12);
  if (v5 > v6)
    return (vm_address_t *)Diagnostics::error(this, "malformed import table");
  v8 = a2[3];
  if (v6 < v8)
    return (vm_address_t *)Diagnostics::error(this, "malformed import table");
  v25 = 0;
  v10 = (char *)a2 + v8;
  v11 = v6 - v8;
  v12 = a2[5];
  switch(v12)
  {
    case 3u:
      if (!a2[4])
        return this;
      v17 = 0;
      v18 = (_QWORD *)((char *)a2 + v5 + 8);
      while (1)
      {
        v19 = *(v18 - 1);
        if (v11 < HIDWORD(v19))
          break;
        if ((unsigned __int16)*(v18 - 1) <= 0xFFF0u)
          v20 = (unsigned __int16)*(v18 - 1);
        else
          v20 = (__int16)v19;
        this = (vm_address_t *)(*(uint64_t (**)(uint64_t, uint64_t, char *, _QWORD, unint64_t, char *))(a4 + 16))(a4, v20, &v10[HIDWORD(v19)], *v18, (v19 >> 16) & 1, &v25);
        if (!v25)
        {
          v18 += 2;
          if (++v17 < (unint64_t)a2[4])
            continue;
        }
        return this;
      }
      break;
    case 2u:
      if (!a2[4])
        return this;
      v21 = 0;
      v22 = (int *)((char *)a2 + v5 + 4);
      while (1)
      {
        v23 = *(v22 - 1);
        if (*(v22 - 1) >> 9 > v11)
          break;
        if (*(v22 - 1) <= 0xF0u)
          v24 = *(v22 - 1);
        else
          v24 = (char)v23;
        this = (vm_address_t *)(*(uint64_t (**)(uint64_t, uint64_t, char *, _QWORD, _QWORD, char *))(a4 + 16))(a4, v24, &v10[v23 >> 9], *v22, (v23 >> 8) & 1, &v25);
        if (!v25)
        {
          v22 += 2;
          if (++v21 < (unint64_t)a2[4])
            continue;
        }
        return this;
      }
      break;
    case 1u:
      if (!a2[4])
        return this;
      v13 = 0;
      v14 = (char *)a2 + v5;
      while (1)
      {
        v15 = *(unsigned int *)&v14[4 * v13];
        if (*(_DWORD *)&v14[4 * v13] >> 9 > v11)
          break;
        if (*(_DWORD *)&v14[4 * v13] <= 0xF0u)
          v16 = *(_DWORD *)&v14[4 * v13];
        else
          v16 = (char)v15;
        this = (vm_address_t *)(*(uint64_t (**)(uint64_t, uint64_t, char *, _QWORD, _QWORD, char *))(a4 + 16))(a4, v16, &v10[v15 >> 9], 0, (v15 >> 8) & 1, &v25);
        if (!v25 && ++v13 < (unint64_t)a2[4])
          continue;
        return this;
      }
      break;
    default:
      return (vm_address_t *)Diagnostics::error(this, "unknown imports format");
  }
  return (vm_address_t *)Diagnostics::error(v4, "malformed import table, string overflow");
}

uint64_t ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  _DWORD v10[2];
  uint64_t v11;
  uint64_t v12;
  char v13;
  char v14;

  v8 = a1 + 32;
  v7 = *(_QWORD *)(a1 + 32);
  v10[0] = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 8) + 24);
  v10[1] = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = 0;
  result = (*(uint64_t (**)(uint64_t, _DWORD *, uint64_t, uint64_t))(v7 + 16))(v7, v10, a6, a4);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  return result;
}

BOOL ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  _BOOL8 result;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) != *(_DWORD *)a2)
    ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2_cold_1();
  v9 = 0;
  v7 = 0u;
  v8 = 0u;
  dyld4::Loader::resolveSymbol(*(dyld4::Loader **)(a1 + 56), *(dyld4::RuntimeState **)(a1 + 72), *(vm_address_t **)(a1 + 64), *(unsigned int *)(a2 + 4), *(const char **)(a2 + 8), *(unsigned __int8 *)(a2 + 24), *(unsigned __int8 *)(a2 + 25), *(_QWORD *)(a1 + 32), (uint64_t)&v7);
  *(_QWORD *)&v8 = v8 + *(_QWORD *)(a2 + 16);
  (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40));
  result = Diagnostics::hasError(*(Diagnostics **)(a1 + 64));
  if (result)
    *a3 = 1;
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  return result;
}

void dyld4::Loader::resolveSymbol(dyld4::Loader *this@<X0>, dyld4::RuntimeState *a2@<X2>, vm_address_t *a3@<X1>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  int v10;
  int v12;
  uint64_t v17;
  dyld4::Loader *v18;
  char v19;
  _QWORD *v20;
  char *v21;
  const dyld4::Loader *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  _QWORD *v28;
  const dyld4::Loader *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  __int128 v33;
  uint64_t *v34;
  uint64_t v35;
  int v36;
  char *v37;
  dyld4::Loader *v38;
  const char *v39;
  uint64_t *v40;
  uint64_t *v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  const char *v46;
  const char *v47;
  __int128 v48;
  uint64_t *v49;
  __int128 v50;
  const void *v51;
  const char *v52;
  uint64_t *v53;
  __int128 v54;
  uint64_t v55;
  vm_address_t *v56;
  __int16 v57;
  uint64_t v58;
  _QWORD v59[11];
  char v60;
  _QWORD v61[10];
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  __n128 (*v65)(uint64_t, uint64_t);
  uint64_t (*v66)();
  uint64_t v67;
  const char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unsigned __int8 v72[8];
  unsigned __int8 *v73;
  uint64_t v74;
  char v75;
  __int128 v76;
  uint64_t v77;
  char v78;

  HIDWORD(v55) = a7;
  v10 = a6;
  v12 = a4;
  v62 = 0;
  v63 = &v62;
  v64 = 0x5002000000;
  v65 = __Block_byref_object_copy__122;
  v66 = __Block_byref_object_dispose__123;
  v67 = 0;
  v68 = a5;
  v69 = 0;
  v70 = 0;
  v71 = 2;
  v17 = (a4 - 1);
  if ((int)a4 >= 1 && dyld4::Loader::dependentCount(this) >= a4)
  {
    v18 = (dyld4::Loader *)dyld4::Loader::dependent(this, a2, v17, 0);
LABEL_16:
    v63[5] = (uint64_t)v18;
    if (v18
      && (__chkstk_darwin((uint64_t)v18, (uint64_t)a3, (uint64_t)a2, a4, (uint64_t)a5, a6, a7, a8, v55),
          v31 = *((_QWORD *)a2 + 6),
          *(_QWORD *)&v76 = (char *)&v55 - ((v30 + 23) & 0xFFFFFFFFFFFFFFF0),
          *((_QWORD *)&v76 + 1) = v31,
          v77 = 0,
          dyld4::Loader::hasExportedSymbol(v63[5], a3, a2, (const unsigned __int8 *)a5, 0, 1, v63 + 5, (uint64_t *)&v76)))
    {
      v32 = v63;
      v33 = *(_OWORD *)(v63 + 7);
      *(_OWORD *)a9 = *(_OWORD *)(v63 + 5);
      *(_OWORD *)(a9 + 16) = v33;
      *(_QWORD *)(a9 + 32) = v32[9];
    }
    else
    {
      v58 = 0;
      v57 = 0;
      if (v10)
      {
        v34 = v63;
        *((_DWORD *)v63 + 18) = 2;
        v34[7] = 0;
      }
      else if (HIDWORD(v55) && (v35 = *((_QWORD *)a2 + 15)) != 0)
      {
        v34 = v63;
        v63[5] = *((_QWORD *)a2 + 13);
        v34[6] = (uint64_t)a5;
        v34[7] = v35;
        v34[9] = 1;
      }
      else
      {
        v36 = dyld4::Loader::overridesDylibInCache((uint64_t)this, &v58, &v57);
        v34 = v63;
        if (v36)
        {
          *((_DWORD *)v63 + 18) = 2;
          v34[7] = 195903495;
        }
        else
        {
          v38 = (dyld4::Loader *)v63[5];
          if (v38)
            v39 = (const char *)dyld4::Loader::path(v38, a2);
          else
            v39 = "unknown";
          if (!*((_QWORD *)a2 + 19))
          {
            v42 = (const char *)dyld4::Loader::path(this, a2);
            dyld4::RuntimeState::setLaunchMissingSymbol(a2, a5, v39, v42);
          }
          if ((*((_WORD *)this + 2) & 0x400) != 0)
            dyld4::Loader::uuidToStr((unsigned __int8 *)this + 8, (unsigned __int8 *)&v76, v37);
          else
            strcpy((char *)&v76, "no uuid");
          v43 = v63[5];
          if (v43 && (*(_WORD *)(v43 + 4) & 0x400) != 0)
            dyld4::Loader::uuidToStr((unsigned __int8 *)(v43 + 8), v72, v37);
          else
            strcpy((char *)v72, "no uuid");
          Diagnostics::Diagnostics((Diagnostics *)&v56);
          dyld4::Loader::tooNewErrorAddendum(this, (Diagnostics *)&v56, a2);
          v46 = (const char *)dyld4::Loader::path(this, a2);
          v47 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v56);
          Diagnostics::error(a3, "Symbol not found: %s\n  Referenced from: <%s> %s%s\n  Expected in:     <%s> %s", a5, (const char *)&v76, v46, v47, (const char *)v72, v39);
          mach_o::Error::~Error(&v56);
LABEL_48:
          v34 = v63;
        }
      }
      v48 = *(_OWORD *)(v34 + 7);
      *(_OWORD *)a9 = *(_OWORD *)(v34 + 5);
      *(_OWORD *)(a9 + 16) = v48;
      *(_QWORD *)(a9 + 32) = v34[9];
    }
  }
  else
  {
    v18 = this;
    switch(v12)
    {
      case -3:
        v19 = *(_BYTE *)(*((_QWORD *)a2 + 1) + 202);
        *(_QWORD *)v72 = 0;
        v73 = v72;
        v74 = 0x2000000000;
        v75 = 0;
        v20 = (_QWORD *)*((_QWORD *)a2 + 17);
        v59[0] = _NSConcreteStackBlock;
        v59[1] = 0x40000000;
        v59[2] = ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke_2;
        v59[3] = &unk_1E4F7D040;
        v60 = v19;
        v59[8] = a2;
        v59[9] = a5;
        v59[6] = v72;
        v59[7] = this;
        v59[10] = a3;
        v59[4] = a8;
        v59[5] = &v62;
        dyld4::RuntimeLocks::withLoadersReadLock(v20, (uint64_t)v59);
        if (v73[24])
        {
          v22 = (const dyld4::Loader *)v63[5];
          if (v22 != this)
            dyld4::RuntimeState::addDynamicReference(a2, this, v22);
          if (*((_QWORD *)a2 + 46) && (dyld4::Loader::hiddenFromFlat((dyld4::Loader *)v63[5], 0) & 1) == 0)
          {
            v23 = v63[5];
            v24 = v63[7] & 0x3FFFFFFFFFFFFFFFLL | ((unint64_t)*((unsigned __int8 *)v63 + 76) << 62) | ((unint64_t)*((unsigned __int8 *)v63 + 77) << 63);
            v25 = *((_QWORD *)a2 + 46);
            v77 = 0;
            v76 = (unint64_t)a5;
            v26 = dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::insert(v25, &v76);
            *(_QWORD *)(v26 + 8) = v23;
            *(_QWORD *)(v26 + 16) = v24;
          }
        }
        else if (v10)
        {
          v40 = v63;
          *((_DWORD *)v63 + 18) = 2;
          v40[7] = 0;
        }
        else
        {
          if ((*((_WORD *)this + 2) & 0x400) != 0)
            dyld4::Loader::uuidToStr((unsigned __int8 *)this + 8, (unsigned __int8 *)&v76, v21);
          else
            strcpy((char *)&v76, "no uuid");
          v52 = (const char *)dyld4::Loader::path(this, a2);
          Diagnostics::error(a3, "Symbol not found: %s\n  Referenced from: <%s> %s\n  Expected as weak-def export from some loaded dylib", a5, (const char *)&v76, v52);
        }
        v53 = v63;
        v54 = *(_OWORD *)(v63 + 7);
        *(_OWORD *)a9 = *(_OWORD *)(v63 + 5);
        *(_OWORD *)(a9 + 16) = v54;
        *(_QWORD *)(a9 + 32) = v53[9];
        v51 = v72;
        break;
      case -2:
        *(_QWORD *)&v76 = 0;
        *((_QWORD *)&v76 + 1) = &v76;
        v77 = 0x2000000000;
        v78 = 0;
        v28 = (_QWORD *)*((_QWORD *)a2 + 17);
        v61[0] = _NSConcreteStackBlock;
        v61[1] = 0x40000000;
        v61[2] = ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke;
        v61[3] = &unk_1E4F7D018;
        v61[6] = this;
        v61[7] = a2;
        v61[8] = a3;
        v61[9] = a5;
        v61[4] = &v62;
        v61[5] = &v76;
        dyld4::RuntimeLocks::withLoadersReadLock(v28, (uint64_t)v61);
        if (*(_BYTE *)(*((_QWORD *)&v76 + 1) + 24))
        {
          v29 = (const dyld4::Loader *)v63[5];
          if (v29 != this)
            dyld4::RuntimeState::addDynamicReference(a2, this, v29);
        }
        else if (v10)
        {
          v41 = v63;
          *((_DWORD *)v63 + 18) = 2;
          v41[7] = 0;
        }
        else if (HIDWORD(v55) && (v44 = *((_QWORD *)a2 + 15)) != 0)
        {
          v45 = v63;
          v63[5] = *((_QWORD *)a2 + 13);
          v45[6] = (uint64_t)a5;
          v45[7] = v44;
          v45[8] = 0;
          *((_DWORD *)v45 + 18) = 1;
          *((_DWORD *)v45 + 19) = 0x10000;
        }
        else
        {
          Diagnostics::error(a3, "symbol not found in flat namespace '%s'", a5);
        }
        v49 = v63;
        v50 = *(_OWORD *)(v63 + 7);
        *(_OWORD *)a9 = *(_OWORD *)(v63 + 5);
        *(_OWORD *)(a9 + 16) = v50;
        *(_QWORD *)(a9 + 32) = v49[9];
        v51 = &v76;
        break;
      case -1:
        v18 = (dyld4::Loader *)*((_QWORD *)a2 + 3);
        goto LABEL_16;
      case 0:
        goto LABEL_16;
      default:
        v27 = (const char *)dyld4::Loader::path(this, a2);
        Diagnostics::error(a3, "unknown library ordinal %d in %s when binding '%s'", v12, v27, a5);
        goto LABEL_48;
    }
    _Block_object_dispose(v51, 8);
  }
  _Block_object_dispose(&v62, 8);
}

uint64_t dyld4::JustInTimeLoader::dependentCount(dyld4::JustInTimeLoader *this)
{
  return (unsigned __int16)(*((_QWORD *)this + 5) >> 39);
}

const void *dyld4::APIs::dlsym(dyld4::APIs *this, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  void *v8;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  int v26;
  const dyld4::Loader *v27;
  _BOOL8 valid;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  unsigned int v38;
  uint64_t ImageContaining;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t (***v63)(char *);
  const char *v64;
  char *v65;
  uint64_t v66;
  _QWORD v67[9];
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  char v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  __n128 (*v75)(uint64_t, uint64_t);
  uint64_t (*v76)();
  uint64_t v77[5];
  uint64_t v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t (*v81)(uint64_t, uint64_t);
  void (*v82)(uint64_t);
  vm_address_t *v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  const char *v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;

  v84 = 520617996;
  v85 = a2;
  v86 = 0;
  v87 = 0;
  v88 = a3;
  v89 = 0u;
  v90 = 0u;
  v91 = 0u;
  v92 = 0u;
  v93 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v84, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dlsym(%p, \"%s\")\n", (const void *)a2, a3);
  if (*((_QWORD *)this + 143) != -1)
  {
    v12 = *((_QWORD *)this + 19);
    if (v12)
    {
      v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 64))(v12);
      if (v13)
        *(_BYTE *)(v13 + 8) = 0;
    }
  }
  if (!_platform_strcmp(a3, "pthread_jit_write_with_callback_np")
    || !_platform_strncmp(a3, "se_memory_inline_jit", 0x14uLL))
  {
    goto LABEL_12;
  }
  if (dyld4::APIs::addressLookupsDisabled(this, a3))
  {
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
      dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => NULL (blocked)\n", a3);
LABEL_12:
    v14 = 0;
    goto LABEL_13;
  }
  v16 = _platform_strlen(a3);
  __chkstk_darwin(v16, v17, v18, v19, v20, v21, v22, v23, v66);
  v25 = (char *)&v67[-1] - ((v24 + 17) & 0xFFFFFFFFFFFFFFF0);
  *v25 = 95;
  strlcpy(v25 + 1, a3, v24 + 1);
  v78 = 0;
  v79 = &v78;
  v80 = 0x3002000000;
  v81 = __Block_byref_object_copy__6;
  v82 = __Block_byref_object_dispose__6;
  Diagnostics::Diagnostics((Diagnostics *)&v83);
  v72 = 0;
  v73 = &v72;
  v74 = 0x5002000000;
  v75 = __Block_byref_object_copy__96;
  v76 = __Block_byref_object_dispose__97;
  v26 = 0;
  v27 = 0;
  switch(a2)
  {
    case -5:
      if ((dyld4::Loader::hasExportedSymbol(*((_QWORD *)this + 3), (vm_address_t *)v79 + 5, this, (const unsigned __int8 *)v25, 0, 1, v77, 0) & 1) != 0)goto LABEL_31;
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_MAIN_ONLY, %s): symbol not found");
      goto LABEL_51;
    case -3:
      ImageContaining = dyld4::APIs::findImageContaining(this, v8);
      if (!ImageContaining)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_SELF, %s): called by unknown image (caller=%p)");
        goto LABEL_51;
      }
      __chkstk_darwin(ImageContaining, v40, v41, v42, v43, v44, v45, v46, v66);
      v48 = (uint64_t *)*((_QWORD *)this + 6);
      v68 = (uint64_t)&v67[-1] - ((v47 + 23) & 0xFFFFFFFFFFFFFFF0);
      v69 = v48;
      v70 = 0;
      if ((dyld4::Loader::hasExportedSymbol(v49, (vm_address_t *)v79 + 5, this, (const unsigned __int8 *)v25, 3u, 0, v73 + 5, &v68) & 1) != 0)goto LABEL_31;
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_SELF, %s): symbol not found");
      goto LABEL_54;
    case -2:
      v68 = 0;
      v69 = &v68;
      v70 = 0x2000000000;
      v71 = 0;
      v50 = (_QWORD *)*((_QWORD *)this + 17);
      v67[0] = _NSConcreteStackBlock;
      v67[1] = 0x40000000;
      v67[2] = ___ZN5dyld44APIs5dlsymEPvPKc_block_invoke;
      v67[3] = &unk_1E4F7DBC8;
      v67[7] = this;
      v67[8] = v25;
      v67[4] = &v78;
      v67[5] = &v72;
      v67[6] = &v68;
      dyld4::RuntimeLocks::withLoadersReadLock(v50, (uint64_t)v67);
      if (*((_BYTE *)v69 + 24))
      {
        _Block_object_dispose(&v68, 8);
        goto LABEL_31;
      }
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_DEFAULT, %s): symbol not found", a3);
      if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
        dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => NULL\n", a3);
      _Block_object_dispose(&v68, 8);
      goto LABEL_56;
    case -1:
      v51 = dyld4::APIs::findImageContaining(this, v8);
      if (!v51)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_NEXT, %s): called by unknown image (caller=%p)");
        goto LABEL_51;
      }
      __chkstk_darwin(v51, v52, v53, v54, v55, v56, v57, v58, v66);
      v60 = (uint64_t *)*((_QWORD *)this + 6);
      v68 = (uint64_t)&v67[-1] - ((v59 + 23) & 0xFFFFFFFFFFFFFFF0);
      v69 = v60;
      v70 = 0;
      if ((dyld4::Loader::hasExportedSymbol(v61, (vm_address_t *)v79 + 5, this, (const unsigned __int8 *)v25, 2u, 0, v73 + 5, &v68) & 1) != 0)goto LABEL_31;
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_NEXT, %s): symbol not found");
LABEL_54:
      if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
        goto LABEL_55;
      goto LABEL_56;
    case 0:
      goto LABEL_18;
    default:
      v26 = a2 & 1;
      v27 = (const dyld4::Loader *)(a2 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_1A5C55000);
LABEL_18:
      valid = dyld4::APIs::validLoader((lsl::Allocator **)this, v27);
      if (!valid)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(%p, %s): invalid handle");
        goto LABEL_51;
      }
      __chkstk_darwin(valid, v29, v30, v31, v32, v33, v34, v35, v66);
      v37 = (uint64_t *)*((_QWORD *)this + 6);
      v68 = (uint64_t)&v67[-1] - ((v36 + 23) & 0xFFFFFFFFFFFFFFF0);
      v69 = v37;
      v70 = 0;
      if (v26)
        v38 = 0;
      else
        v38 = 3;
      if ((dyld4::Loader::hasExportedSymbol((uint64_t)v27, (vm_address_t *)v79 + 5, this, (const unsigned __int8 *)v25, v38, 0, v73 + 5, &v68) & 1) == 0)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(%p, %s): symbol not found", (const void *)a2, a3);
        if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
          dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => NULL\n", a3);
        goto LABEL_56;
      }
LABEL_31:
      v62 = v73[5];
      if (!v62)
      {
LABEL_51:
        if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
LABEL_55:
          dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => NULL\n", a3);
        goto LABEL_56;
      }
      v14 = (const void *)v73[8];
      if (*((_BYTE *)v73 + 79))
      {
        if ((*(_WORD *)(v62 + 4) & 1) != 0)
          v62 = 0;
        v63 = *(uint64_t (****)(char *))(v62 + 104);
        v64 = (const char *)dyld4::PseudoDylib::finalizeRequestedSymbols(v63, (uint64_t)(v73 + 6), 1);
        if (v64)
        {
          v65 = (char *)v64;
          if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
            dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => NULL, error finalizing pseudo-dylib symbols: %s", a3, v64);
          dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(%s): error finalizing pseudo-dylib symbols: %s", a3, v65);
          dyld4::PseudoDylib::disposeString(v63, v65);
LABEL_56:
          v14 = 0;
          goto LABEL_57;
        }
      }
      if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
        dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => %p\n", a3, v14);
      v90 = (unint64_t)v14;
LABEL_57:
      _Block_object_dispose(&v72, 8);
      _Block_object_dispose(&v78, 8);
      mach_o::Error::~Error(&v83);
LABEL_13:
      dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v84);
      return v14;
  }
}

const dyld4::RuntimeState *dyld4::Loader::resolvedAddress(const dyld4::RuntimeState *result, uint64_t a2)
{
  unsigned int v2;

  v2 = *(_DWORD *)(a2 + 32);
  if (v2 < 2)
    return (const dyld4::RuntimeState *)(*(_QWORD *)(a2 + 16) + dyld4::Loader::loadAddress(*(dyld4::Loader **)a2, result));
  if (v2 == 2)
    return *(const dyld4::RuntimeState **)(a2 + 16);
  return result;
}

dyld4::RuntimeState *dyld4::Loader::interpose(dyld4::Loader *this, dyld4::RuntimeState *a2, dyld4::Loader *a3, const dyld4::Loader *a4)
{
  dyld4::RuntimeState *v4;
  uint64_t v6;
  dyld4::RuntimeState **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  dyld4::RuntimeState *v16;
  const char *v17;

  v4 = a2;
  if (a2)
  {
    v6 = *((_QWORD *)this + 30);
    if (v6)
    {
      v7 = (dyld4::RuntimeState **)*((_QWORD *)this + 29);
      v8 = 16 * v6;
      while (v7[1] != a2)
      {
        v7 += 2;
        v8 -= 16;
        if (!v8)
          goto LABEL_6;
      }
      goto LABEL_21;
    }
LABEL_6:
    v9 = *((_QWORD *)this + 38);
    if (v9)
    {
      v7 = (dyld4::RuntimeState **)*((_QWORD *)this + 37);
      v10 = 16 * v9;
      while (v7[1] != a2)
      {
        v7 += 2;
        v10 -= 16;
        if (!v10)
          goto LABEL_10;
      }
LABEL_21:
      v11 = *((_QWORD *)this + 1);
      goto LABEL_22;
    }
LABEL_10:
    v11 = *((_QWORD *)this + 1);
    if (*(_BYTE *)(v11 + 190))
    {
      v12 = *((_QWORD *)this + 26);
      if (v12)
      {
        v7 = (dyld4::RuntimeState **)(*((_QWORD *)this + 25) + 8);
        v13 = 24 * v12;
        while (v7[1] != a2 || *(v7 - 1) != a3)
        {
          v7 += 3;
          v13 -= 24;
          if (!v13)
            goto LABEL_16;
        }
        if (!*(_BYTE *)(v11 + 206))
          return *v7;
        v16 = *v7;
        goto LABEL_24;
      }
LABEL_16:
      v14 = *((_QWORD *)this + 22);
      if (v14)
      {
        v7 = (dyld4::RuntimeState **)*((_QWORD *)this + 21);
        v15 = 16 * v14;
        while (v7[1] != a2)
        {
          v7 += 2;
          v15 -= 16;
          if (!v15)
            return v4;
        }
LABEL_22:
        if (!*(_BYTE *)(v11 + 206))
          return *v7;
        v16 = *v7;
        if (!a3)
        {
          v17 = "dlsym";
          goto LABEL_26;
        }
LABEL_24:
        v17 = (const char *)dyld4::Loader::path(a3, this);
LABEL_26:
        dyld4::RuntimeState::log(this, "  interpose replaced 0x%08lX with 0x%08lX in %s\n", v4, v16, v17);
        return *v7;
      }
    }
  }
  return v4;
}

BOOL dyld4::APIs::validLoader(lsl::Allocator **this, const dyld4::Loader *a2)
{
  return a2
      && ((lsl::Allocator::owned(this[2], (unint64_t)a2, 32) & 1) != 0
       || dyld4::RuntimeState::inPrebuiltLoader((dyld4::RuntimeState *)this, a2, 32))
      && dyld4::Loader::hasMagic(a2);
}

BOOL dyld4::Loader::hasMagic(dyld4::Loader *this)
{
  return *(_DWORD *)this == 1815378276;
}

BOOL dyld4::RuntimeState::inPrebuiltLoader(dyld4::RuntimeState *this, dyld4::PrebuiltLoaderSet *a2, uint64_t a3)
{
  dyld4::PrebuiltLoaderSet *v6;
  dyld4::PrebuiltLoaderSet *v7;
  _BOOL8 result;

  v6 = (dyld4::PrebuiltLoaderSet *)*((_QWORD *)this + 124);
  result = 1;
  if (!v6 || !dyld4::PrebuiltLoaderSet::contains(v6, a2, a3))
  {
    v7 = (dyld4::PrebuiltLoaderSet *)*((_QWORD *)this + 127);
    if (!v7 || !dyld4::PrebuiltLoaderSet::contains(v7, a2, a3))
      return 0;
  }
  return result;
}

BOOL dyld4::PrebuiltLoaderSet::contains(dyld4::PrebuiltLoaderSet *this, dyld4::PrebuiltLoaderSet *a2, uint64_t a3)
{
  return a2 >= this && (char *)a2 + a3 <= (char *)this + *((unsigned int *)this + 2);
}

uint64_t dyld4::JustInTimeLoader::dependentAttrs(dyld4::JustInTimeLoader *this, unsigned int a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 5);
  v3 = (unsigned __int16)(v2 >> 39);
  if (v3 <= a2)
    dyld4::JustInTimeLoader::dependentAttrs();
  if ((v2 & 0x800000) != 0)
    dyld4::JustInTimeLoader::dependentAttrs();
  return (uint64_t)this + 8 * v3 + a2 + 464;
}

vm_address_t *dyld4::APIs::setErrorString(vm_address_t *this, char *a2, ...)
{
  vm_address_t *v2;
  vm_address_t *v4;
  const char *v5;
  size_t v6;
  size_t *v7;
  uint64_t v8;
  const char *v9;
  va_list va;

  va_start(va, a2);
  if (this[143] != -1)
  {
    v2 = this;
    if (this[19])
    {
      this = (vm_address_t *)_simple_salloc();
      if (this)
      {
        v4 = this;
        _simple_vsprintf((uint64_t)this, a2, (int *)va);
        v5 = (const char *)_simple_string((_BYTE **)v4);
        v6 = _platform_strlen(v5) + 17;
        v7 = (size_t *)(*(uint64_t (**)(vm_address_t, vm_address_t))(*(_QWORD *)v2[19] + 64))(v2[19], v2[143]);
        if (v7)
        {
          v8 = (uint64_t)v7;
          if (*v7 >= v6)
          {
LABEL_10:
            v9 = (const char *)_simple_string((_BYTE **)v4);
            strcpy((char *)(v8 + 9), v9);
            *(_BYTE *)(v8 + 8) = 1;
            return _simple_sfree(v4);
          }
          (*(void (**)(vm_address_t, size_t *))(*(_QWORD *)v2[19] + 16))(v2[19], v7);
        }
        if (v6 <= 0x100)
          v6 = 256;
        v8 = (*(uint64_t (**)(vm_address_t, size_t))(*(_QWORD *)v2[19] + 8))(v2[19], v6);
        *(_QWORD *)v8 = v6;
        *(_BYTE *)(v8 + 8) = 0;
        (*(void (**)(vm_address_t, vm_address_t, uint64_t))(*(_QWORD *)v2[19] + 72))(v2[19], v2[143], v8);
        goto LABEL_10;
      }
    }
  }
  return this;
}

uint64_t _simple_string(_BYTE **a1)
{
  *a1[1] = 0;
  return (uint64_t)*a1;
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  size_t v4;

  v4 = _platform_strlen(__src);
  memmove(__dst, __src, v4 + 1);
  return __dst;
}

const os_unfair_lock *dyld4::RuntimeState::addDynamicReference(dyld4::RuntimeState *this, const dyld4::Loader *a2, const dyld4::Loader *a3)
{
  const os_unfair_lock *result;
  lsl::Lock *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[2];
  void (*v12)(_QWORD *);
  void *v13;
  dyld4::RuntimeState *v14;
  const dyld4::Loader *v15;
  const dyld4::Loader *v16;
  lsl::Lock *v17;

  if ((*((_WORD *)a3 + 2) & 0x20) == 0
    || (result = (const os_unfair_lock *)dyld4::Loader::isDelayInit(a3, this), (_DWORD)result))
  {
    v7 = (lsl::Lock *)*((_QWORD *)this + 16);
    v8 = (_QWORD *)*((_QWORD *)this + 17);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v12 = (void (*)(_QWORD *))___ZN5dyld412RuntimeState19addDynamicReferenceEPKNS_6LoaderES3__block_invoke;
    v13 = &__block_descriptor_tmp_45;
    v14 = this;
    v15 = a2;
    v16 = a3;
    lsl::MemoryManager::lockGuard(v7, &v17);
    v9 = *((_QWORD *)v7 + 3);
    if (!v9)
    {
      lsl::MemoryManager::writeProtect(v7, 0);
      v9 = *((_QWORD *)v7 + 3);
    }
    *((_QWORD *)v7 + 3) = v9 + 1;
    lsl::Lock::unlock(v17);
    if (*v8)
    {
      (*(void (**)(_QWORD, _QWORD *, _QWORD))(*(_QWORD *)*v8 + 104))(*v8, v8 + 1, 0);
      v12(v11);
      (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)*v8 + 112))(*v8, v8 + 1);
    }
    else
    {
      ___ZN5dyld412RuntimeState19addDynamicReferenceEPKNS_6LoaderES3__block_invoke(v11);
    }
    lsl::MemoryManager::lockGuard(v7, &v17);
    v10 = *((_QWORD *)v7 + 3) - 1;
    *((_QWORD *)v7 + 3) = v10;
    if (!v10)
      lsl::MemoryManager::writeProtect(v7, 1);
    return lsl::Lock::unlock(v17);
  }
  return result;
}

const os_unfair_lock *dyld4::APIs::_libdyld_initialize(dyld4::RuntimeState *a1, uint64_t a2)
{
  lsl::Lock *v4;
  uint64_t v5;
  uint64_t v6;
  lsl::Lock *v8;

  v4 = (lsl::Lock *)*((_QWORD *)a1 + 16);
  lsl::MemoryManager::lockGuard(v4, &v8);
  v5 = *((_QWORD *)v4 + 3);
  if (!v5)
  {
    lsl::MemoryManager::writeProtect(v4, 0);
    v5 = *((_QWORD *)v4 + 3);
  }
  *((_QWORD *)v4 + 3) = v5 + 1;
  lsl::Lock::unlock(v8);
  dyld4::RuntimeState::setHelpers((uint64_t)a1, a2);
  dyld4::RuntimeState::initialize(a1);
  lsl::MemoryManager::lockGuard(v4, &v8);
  v6 = *((_QWORD *)v4 + 3) - 1;
  *((_QWORD *)v4 + 3) = v6;
  if (!v6)
    lsl::MemoryManager::writeProtect(v4, 1);
  return lsl::Lock::unlock(v8);
}

uint64_t dyld4::RuntimeState::setHelpers(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 136) = a2;
  *(_QWORD *)(result + 152) = a2;
  return result;
}

void *dyld4::RuntimeState::_instantiateTLVs(dyld4::RuntimeState *this, uint64_t a2)
{
  _QWORD *v4;
  void *v5;
  _QWORD v7[8];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v4 = (_QWORD *)*((_QWORD *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld412RuntimeState16_instantiateTLVsEm_block_invoke;
  v7[3] = &unk_1E4F7CBC0;
  v7[6] = this;
  v7[7] = a2;
  v7[4] = &v12;
  v7[5] = &v8;
  dyld4::RuntimeLocks::withTLVLock(v4, (uint64_t)v7);
  if (v13[3])
  {
    v5 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 19) + 8))(*((_QWORD *)this + 19), v9[3]);
    memmove(v5, (const void *)v13[3], v9[3]);
    (*(void (**)(_QWORD, uint64_t, void *))(**((_QWORD **)this + 19) + 72))(*((_QWORD *)this + 19), a2, v5);
  }
  else
  {
    v5 = 0;
  }
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  return v5;
}

double dyld4::RuntimeState::initialize(dyld4::RuntimeState *this)
{
  uint64_t v2;
  dyld4::Loader **v3;
  uint64_t v4;
  const dyld3::MachOAnalyzer *v5;
  __n128 *v6;
  uint64_t v7;
  double result;
  __n128 v9;

  (*(void (**)(_QWORD, char *))(**((_QWORD **)this + 19) + 48))(*((_QWORD *)this + 19), (char *)this + 1144);
  (*(void (**)(_QWORD, char *))(**((_QWORD **)this + 19) + 56))(*((_QWORD *)this + 19), (char *)this + 1136);
  v2 = *((_QWORD *)this + 6);
  if (v2)
  {
    v3 = (dyld4::Loader **)*((_QWORD *)this + 5);
    v4 = 8 * v2;
    do
    {
      if ((*((_WORD *)*v3 + 2) & 0x1000) != 0)
      {
        v5 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*v3, this);
        dyld4::RuntimeState::setUpTLVs(this, v5);
      }
      ++v3;
      v4 -= 8;
    }
    while (v4);
  }
  v6 = (__n128 *)*((_QWORD *)this + 16);
  v7 = *((_QWORD *)this + 17) + 40;
  v9.n128_u64[0] = (unint64_t)this;
  v9.n128_u64[1] = v7;
  *(_QWORD *)&result = lsl::MemoryManager::adoptLock(v6, &v9).n128_u64[0];
  return result;
}

uint64_t dyld3::MachOFile::hasThreadLocalVariables(dyld3::MachOFile *this)
{
  return *((unsigned __int8 *)this + 26) >> 7;
}

void dyld4::RuntimeState::setUpTLVs(dyld4::RuntimeState *this, const dyld3::MachOAnalyzer *a2)
{
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  int v9;
  uint64_t *v10;
  int v11;
  _QWORD *v12;
  _QWORD v13[6];
  _QWORD v14[8];
  BOOL v15;
  vm_address_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  __n128 (*v20)(uint64_t, uint64_t);
  uint64_t (*v21)();
  const dyld3::MachOAnalyzer *v22;
  int v23;

  v17 = 0;
  v18 = &v17;
  v19 = 0x4002000000;
  v20 = __Block_byref_object_copy__102;
  v21 = __Block_byref_object_dispose__103;
  v22 = a2;
  v23 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v16);
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 144))(*((_QWORD *)this + 19));
  v5 = 0;
  v6 = *((_QWORD *)this + 1);
  v7 = *(_QWORD *)(v6 + 240);
  if (v7)
    v8 = v7 >= (unint64_t)a2;
  else
    v8 = 1;
  if (!v8)
    v5 = v7 + DyldSharedCache::mappedSize(*(DyldSharedCache **)(v6 + 240)) > (unint64_t)a2;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke;
  v14[3] = &unk_1E4F7CB70;
  v15 = v5;
  v14[4] = &v17;
  v14[5] = this;
  v14[6] = v4;
  v14[7] = v4;
  v9 = dyld3::MachOAnalyzer::forEachThreadLocalVariable(a2, (uint64_t)&v16, (uint64_t)v14);
  v10 = v18;
  *((_DWORD *)v18 + 13) = v9;
  *((_DWORD *)v10 + 14) = v11;
  v12 = (_QWORD *)*((_QWORD *)this + 17);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  v13[2] = ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke_2;
  v13[3] = &unk_1E4F7CB98;
  v13[4] = &v17;
  v13[5] = this;
  dyld4::RuntimeLocks::withTLVLock(v12, (uint64_t)v13);
  mach_o::Error::~Error(&v16);
  _Block_object_dispose(&v17, 8);
}

uint64_t dyld4::RuntimeLocks::withTLVLock(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *a1;
  if (!v4)
    return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  (*(void (**)(uint64_t, _QWORD *, _QWORD))(*(_QWORD *)v4 + 104))(v4, a1 + 3, 0);
  (*(void (**)(uint64_t))(a2 + 16))(a2);
  return (*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*a1 + 112))(*a1, a1 + 3);
}

__n128 ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __n128 *v5;
  __n128 result;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(v1 + 856, *(_QWORD *)(v1 + 872) + 1);
  v3 = *(_QWORD *)(v1 + 864);
  v4 = *(_QWORD *)(v1 + 872);
  *(_QWORD *)(v1 + 872) = v4 + 1;
  v5 = (__n128 *)(v3 + 24 * v4);
  result = *(__n128 *)(v2 + 40);
  v5[1].n128_u64[0] = *(_QWORD *)(v2 + 56);
  *v5 = result;
  return result;
}

const os_unfair_lock *lsl::Lock::unlock(lsl::Lock *this)
{
  const os_unfair_lock *result;

  result = (const os_unfair_lock *)*((_QWORD *)this + 1);
  if (result)
  {
    os_unfair_lock_assert_owner(result);
    if (!*(_QWORD *)this)
      lsl::Lock::unlock();
    return (const os_unfair_lock *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)this + 152)
                                                                             + 192))(*(_QWORD *)(*(_QWORD *)this + 152), *((_QWORD *)this + 1));
  }
  return result;
}

const os_unfair_lock *lsl::Lock::lock(lsl::Lock *this)
{
  const os_unfair_lock *result;

  result = (const os_unfair_lock *)*((_QWORD *)this + 1);
  if (result)
  {
    os_unfair_lock_assert_not_owner(result);
    if (!*(_QWORD *)this)
      lsl::Lock::lock();
    return (const os_unfair_lock *)(*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)this + 152)
                                                                                     + 184))(*(_QWORD *)(*(_QWORD *)this + 152), *((_QWORD *)this + 1), 0);
  }
  return result;
}

void os_unfair_lock_assert_owner(const os_unfair_lock *lock)
{
  int v1;
  uint32_t os_unfair_lock_opaque;

  v1 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  os_unfair_lock_opaque = lock->_os_unfair_lock_opaque;
  if ((os_unfair_lock_opaque | 1) != v1)
    os_unfair_lock_assert_owner_cold_1(os_unfair_lock_opaque);
}

void os_unfair_lock_assert_not_owner(const os_unfair_lock *lock)
{
  int v1;
  uint32_t os_unfair_lock_opaque;

  v1 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  os_unfair_lock_opaque = lock->_os_unfair_lock_opaque;
  if ((os_unfair_lock_opaque | 1) == v1)
    os_unfair_lock_assert_not_owner_cold_1(os_unfair_lock_opaque);
}

uint64_t dyld4::APIs::dlopen(dyld4::APIs *this, const char *a2, uint64_t a3)
{
  uint64_t v3;

  return (*(uint64_t (**)(dyld4::APIs *, const char *, uint64_t, uint64_t))(*(_QWORD *)this + 776))(this, a2, a3, v3);
}

uint64_t dyld4::setUpPageInLinkingRegions(const dyld4::RuntimeState *a1, dyld4::Loader *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const mwl_region *a7, uint64_t a8)
{
  __int16 v9;
  __int16 v10;
  mach_vm_address_t mwlr_address;
  unsigned int v14;
  uint64_t v15;
  _DWORD **v16;
  _DWORD *v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  char v21;
  uint64_t v22;
  char *v23;
  size_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const mwl_region *__attribute__((__org_arrdim(0,0))) v33;
  mach_vm_address_t v34;
  char *v35;
  int v36;
  _OWORD *v37;
  int v38;
  uint64_t v39;
  unsigned int **v40;
  unsigned int *v41;
  int v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const mwl_info_hdr *v54;
  const unsigned int *v55;
  uint64_t v56;
  const mwl_region *v57;
  uint64_t v58;
  uint64_t v59;
  mwl_region *v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;
  const mwl_region *v64;
  uint64_t v65;
  const char *v66;
  mach_vm_address_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t result;
  uint64_t v76;
  const char *v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  const mwl_region *v82;
  const mwl_region *__attribute__((__org_arrdim(0,0))) v83;
  dyld4::Loader *v84;

  v81 = a6;
  v9 = a5;
  v10 = a4;
  v84 = a2;
  mwlr_address = a7->mwlr_address;
  v14 = 4 * mwlr_address + 4;
  v83 = a7;
  if (mwlr_address)
  {
    v15 = 48 * mwlr_address;
    v16 = (_DWORD **)(*(_QWORD *)&a7->mwlr_fd + 40);
    do
    {
      v17 = *v16;
      v16 += 6;
      v14 = (v14 + *v17 + 3) & 0xFFFFFFFC;
      v15 -= 48;
    }
    while (v15);
  }
  v18 = (v14 + 47) & 0xFFFFFFF8;
  v19 = *(_QWORD *)(a8 + 16);
  if ((_DWORD)a4 == 3)
    v20 = 2;
  else
    v20 = 3;
  if ((_DWORD)a4 == 3)
    v21 = 2;
  else
    v21 = 3;
  __chkstk_darwin((uint64_t)a1, (v19 << v20) + v18, a3, a4, a5, a6, (uint64_t)a7, a8, v80);
  v23 = (char *)&v80 - v22;
  v82 = (const mwl_region *)v24;
  bzero((char *)&v80 - v22, v24);
  *(_DWORD *)v23 = 7;
  *((_WORD *)v23 + 2) = v9;
  *((_WORD *)v23 + 3) = v10;
  *((_DWORD *)v23 + 2) = v18;
  *((_DWORD *)v23 + 3) = v19;
  *((_DWORD *)v23 + 4) = 40;
  *((_DWORD *)v23 + 5) = v14;
  *((_QWORD *)v23 + 3) = a3;
  *((_QWORD *)v23 + 4) = dyld4::Loader::loadAddress(v84, a1);
  v25 = memmove(&v23[v18], *(const void **)a8, ((_DWORD)v19 << v21));
  v33 = v83;
  v34 = v83->mwlr_address;
  v35 = &v23[*((unsigned int *)v23 + 4)];
  *(_DWORD *)v35 = v34;
  if (v34)
  {
    v36 = 0;
    v37 = *(_OWORD **)&v33->mwlr_fd;
    v38 = 4 * v34 + 4;
    v39 = 48 * v34;
    v40 = (unsigned int **)v37 + 5;
    do
    {
      *(_DWORD *)&v35[4 * v36 + 4] = v38;
      v41 = *v40;
      v40 += 6;
      v42 = *v41;
      v43 = memmove(&v23[*((_DWORD *)v23 + 4) + v38], v41, *v41);
      ++v36;
      v38 += v42;
      v39 -= 48;
    }
    while (v39);
    __chkstk_darwin((uint64_t)v43, v44, v45, v46, v47, v48, v49, v50, v80);
    v57 = (const mwl_region *)((char *)&v80 - (v56 & 0xFFFFFFFFFFFFFFE0 | 0x10));
    v58 = 0;
    v59 = 48 * v34;
    v60 = (mwl_region *)v57;
    v33 = v83;
    do
    {
      if (v34 == v58)
        dyld4::RuntimeState::appendInterposingTuples(v51, v52, v53);
      ++v58;
      v61 = *v37;
      v62 = v37[1];
      v37 += 3;
      *(_OWORD *)&v60->mwlr_fd = v61;
      *(_OWORD *)&v60->mwlr_address = v62;
      ++v60;
      v59 -= 48;
    }
    while (v59);
  }
  else
  {
    __chkstk_darwin((uint64_t)v25, v26, v27, v28, v29, v30, v31, v32, v80);
    v57 = (const mwl_region *)((char *)&v80 - (v63 & 0xFFFFFFFFFFFFFFE0 | 0x10));
    LODWORD(v58) = 0;
  }
  if ((v81 & 1) != 0)
  {
    v64 = v82;
    return dyld4::dyld_map_with_linking_np((dyld4 *)v23, v64, v53, v54, v55);
  }
  v83 = v57;
  v65 = *((_QWORD *)a1 + 1);
  if (*(_BYTE *)(v65 + 202) || *(_BYTE *)(v65 + 201))
  {
    v66 = (const char *)dyld4::Loader::path(v84, a1);
    dyld4::RuntimeState::log(a1, "Setting up kernel page-in linking for %s\n", v66);
    v67 = v33->mwlr_address;
    if (v67)
    {
      v68 = 48 * v67;
      v69 = *(_QWORD *)&v33->mwlr_fd + 16;
      do
      {
        v70 = *(_QWORD *)(v69 + 8);
        v71 = *(_DWORD *)(v69 - 12);
        v79 = v70 >> 10;
        v78 = v70 + *(_QWORD *)v69;
        if ((v71 & 4) != 0)
          v72 = 120;
        else
          v72 = 46;
        if ((v71 & 2) != 0)
          v73 = 119;
        else
          v73 = 46;
        if ((v71 & 1) != 0)
          v74 = 114;
        else
          v74 = 46;
        dyld4::RuntimeState::log(a1, "%14s (%c%c%c) 0x%012llX->0x%012llX (fileOffset=0x%0llX, size=%lluKB)\n", *(const char **)(v69 + 16), v74, v73, v72, *(_QWORD *)v69, v78, *(_QWORD *)(v69 - 8), v79);
        v69 += 48;
        v68 -= 48;
      }
      while (v68);
    }
  }
  v64 = v82;
  result = __map_with_linking_np(v83, v58, (const mwl_info_hdr *)v23, (uint32_t)v82);
  if ((_DWORD)result)
  {
    v76 = *((_QWORD *)a1 + 1);
    if (*(_BYTE *)(v76 + 202) || *(_BYTE *)(v76 + 201))
    {
      v77 = (const char *)dyld4::Loader::path(v84, a1);
      dyld4::RuntimeState::log(a1, "__map_with_linking_np(%s) failed, falling back to linking in-process\n", v77);
    }
    return dyld4::dyld_map_with_linking_np((dyld4 *)v23, v64, v53, v54, v55);
  }
  return result;
}

int __map_with_linking_np(const mwl_region regions[], uint32_t regionCount, const mwl_info_hdr *blob, uint32_t blobSize)
{
  char v4;
  int result;

  result = mac_syscall(SYS_map_with_linking_np, regions, regionCount, blob, blobSize);
  if (v4)
    return cerror_nocancel(result);
  return result;
}

uint64_t dyld4::dyld_map_with_linking_np(dyld4 *this, const mwl_region *a2, unsigned int a3, const mwl_info_hdr *a4, const unsigned int *a5)
{
  int v6;
  int v7;
  char v8;
  uint64_t v9;
  char *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  char *v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  uint64_t v27;
  dyld4 *v28;
  const mwl_info_hdr *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  const dyld_chained_starts_in_segment *v33;
  int v34;
  __int16 v35;
  char *v36;

  if (*(_DWORD *)this != 7)
    return 0xFFFFFFFFLL;
  v6 = *((_DWORD *)this + 2);
  v7 = *((_DWORD *)this + 3);
  if (*((_WORD *)this + 3) == 3)
    v8 = 2;
  else
    v8 = 3;
  if ((v7 << v8) + v6 > a2)
  {
    fprintf(__stderrp, "bind table extends past blob, blobSize=%d, offset=%d, count=%d\n", (_DWORD)a2, v6, v7);
    return 0xFFFFFFFFLL;
  }
  v9 = *((unsigned int *)this + 4);
  if (*((_DWORD *)this + 5) + (int)v9 > a2)
    return 0xFFFFFFFFLL;
  v11 = (char *)this + v9;
  v12 = *(unsigned int *)((char *)this + v9);
  if ((_DWORD)v12)
  {
    v13 = 0;
    v36 = v11;
    while (1)
    {
      v14 = *(unsigned int *)&v11[4 * v13 + 4];
      if ((_DWORD)v14)
      {
        v15 = &v11[v14];
        if (*(_WORD *)&v11[v14 + 20])
          break;
      }
LABEL_33:
      if (++v13 >= v12)
        return 0;
    }
    v16 = 0;
    v17 = *((_QWORD *)v15 + 1) + *((_QWORD *)this + 4);
    while (1)
    {
      v18 = *((unsigned int *)this + 4);
      v19 = (char *)this + v18;
      v20 = *(unsigned int *)((char *)this + v18);
      if (!(_DWORD)v20)
LABEL_35:
        dyld4::dyld_map_with_linking_np();
      v21 = v17 + v16 * *((unsigned __int16 *)this + 2);
      v22 = v18 + 4;
      while (1)
      {
        v23 = &v19[*(unsigned int *)((char *)this + v22)];
        v24 = *((_QWORD *)v23 + 1) + *((_QWORD *)this + 4);
        if (v24 <= v21
          && v24 + *((unsigned __int16 *)v23 + 10) * (unint64_t)*((unsigned __int16 *)v23 + 2) > v21)
        {
          break;
        }
        v22 += 4;
        if (!--v20)
          goto LABEL_35;
      }
      v25 = *((unsigned __int16 *)this + 3);
      v26 = (v21 - v24) / *((unsigned __int16 *)v23 + 2);
      if (v25 == 6)
        break;
      if (v25 == 3)
      {
        v31 = *(unsigned __int16 *)&v23[2 * v26 + 22];
        if ((_DWORD)v31 != 0xFFFF)
        {
          v32 = *((unsigned int *)this + 2);
          v33 = (const dyld_chained_starts_in_segment *)((char *)this + v32);
          if ((v31 & 0x8000) != 0)
          {
            v34 = v31 & 0x7FFF;
            do
            {
              v35 = *(_WORD *)&v23[2 * v34 + 22];
              dyld4::fixupChain32((_DWORD *)(v21 + (v35 & 0x7FFF)), (unsigned int *)this, (const mwl_info_hdr *)v23, v33, a5);
              ++v34;
            }
            while ((v35 & 0x8000) == 0);
          }
          else
          {
            dyld4::fixupChain32((_DWORD *)(v21 + v31), (unsigned int *)this, (const mwl_info_hdr *)v23, (const dyld_chained_starts_in_segment *)((char *)this + v32), a5);
          }
        }
        goto LABEL_31;
      }
      if (v25 == 2)
      {
        v27 = v17 + v16 * *((unsigned __int16 *)this + 2);
        v28 = this;
        v29 = (const mwl_info_hdr *)v23;
        v30 = 0;
LABEL_25:
        dyld4::fixupPage64(v27, v28, v29, (const dyld_chained_starts_in_segment *)v26, v30);
      }
LABEL_31:
      if (++v16 >= *((unsigned __int16 *)v15 + 10))
      {
        v11 = v36;
        v12 = *(unsigned int *)v36;
        goto LABEL_33;
      }
    }
    v27 = v17 + v16 * *((unsigned __int16 *)this + 2);
    v28 = this;
    v29 = (const mwl_info_hdr *)v23;
    v30 = 1;
    goto LABEL_25;
  }
  return 0;
}

uint64_t dyld4::fixupPage64(uint64_t this, _DWORD *a2, const mwl_info_hdr *a3, const dyld_chained_starts_in_segment *a4, int a5)
{
  uint64_t v5;
  char *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;

  v5 = *((unsigned __int16 *)&a3->mwli_chains_size + a4 + 1);
  if (v5 != 0xFFFF)
  {
    v6 = (char *)a2 + a2[2];
    v7 = (uint64_t *)(this + v5);
    v8 = 6;
    if (a5)
      v8 = 8;
    v9 = *(_QWORD *)&a2[v8];
    do
    {
      v10 = *v7;
      if (*v7 < 0)
      {
        v12 = a2[3];
        if ((v10 & 0xFFFFFF) >= v12)
          return fprintf(__stderrp, "out of range bind ordinal %u (max %u)", v10 & 0xFFFFFF, v12);
        v11 = *(_QWORD *)&v6[8 * (v10 & 0xFFFFFF)] + BYTE3(v10);
      }
      else
      {
        v11 = (v10 & 0xFFFFFFFFFLL) + v9 + (v10 >> 36 << 56);
      }
      v13 = (v10 >> 51) & 0xFFF;
      *v7 = v11;
      v7 = (uint64_t *)((char *)v7 + 4 * v13);
    }
    while (v13);
  }
  return this;
}

_QWORD *dyld3::OverflowSafeArray<dyld3::SegmentRanges::SegmentRange,4294967295ull>::verifySpace(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  const void **v4;
  vm_address_t v5;
  vm_size_t v6;
  unint64_t v7;
  vm_size_t v8;
  unint64_t v9;

  v2 = result[1];
  v3 = result[2] + a2;
  if (v3 > v2)
  {
    v4 = (const void **)result;
    v5 = result[3];
    v6 = result[4];
    v7 = 2 * v2;
    if (v7 > v3)
      v3 = v7;
    v8 = (vm_page_size + 24 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    if (vm_allocate(mach_task_self_, result + 3, v8, 1006632961))
      ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2_cold_1();
    result = memmove((void *)v4[3], *v4, 24 * (_QWORD)v4[2]);
    v9 = (unint64_t)v4[4] / 0x18;
    *v4 = v4[3];
    v4[1] = (const void *)v9;
    if (v5)
      return (_QWORD *)vm_deallocate(mach_task_self_, v5, v6);
  }
  return result;
}

const void *dyld4::APIs::_dyld_get_shared_cache_range(dyld4::APIs *this, unint64_t *a2)
{
  uint64_t v4;
  const void *v5;
  unint64_t v6;

  v4 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v4 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_get_shared_cache_range(%p)", a2);
    v4 = *((_QWORD *)this + 1);
  }
  *a2 = 0;
  v5 = *(const void **)(v4 + 240);
  if (v5)
  {
    v6 = DyldSharedCache::mappedSize(*(DyldSharedCache **)(v4 + 240));
    *a2 = v6;
    v4 = *((_QWORD *)this + 1);
  }
  else
  {
    v6 = 0;
  }
  if (*(_BYTE *)(v4 + 204))
    dyld4::RuntimeState::log(this, " => %p,0x%lX\n", v5, v6);
  return v5;
}

uint64_t dyld4::APIs::_dyld_get_image_slide(dyld4::APIs *this, mach_header *a2)
{
  _BOOL4 hasMachOMagic;
  const dyld3::MachOFile *v5;
  uint64_t v6;
  uint64_t Slide;

  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_get_image_slide(%p)", a2);
  hasMachOMagic = dyld3::MachOFile::hasMachOMagic((dyld3::MachOFile *)a2);
  v6 = *((_QWORD *)this + 1);
  if (hasMachOMagic)
  {
    if (DyldSharedCache::inDyldCache(*(DyldSharedCache **)(v6 + 240), (const DyldSharedCache *)a2, v5))
    {
      v6 = *((_QWORD *)this + 1);
      Slide = *(_QWORD *)(v6 + 264);
    }
    else
    {
      Slide = dyld3::MachOLoaded::getSlide((dyld3::MachOLoaded *)a2);
      v6 = *((_QWORD *)this + 1);
    }
  }
  else
  {
    Slide = 0;
  }
  if (*(_BYTE *)(v6 + 204))
    dyld4::RuntimeState::log(this, " => 0x%lX\n", Slide);
  return Slide;
}

uint64_t dyld4::APIs::getSdkVersion(dyld4::APIs *this, const mach_header *a2)
{
  uint64_t v2;
  _QWORD v4[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  _QWORD v9[3];
  char v10;

  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x2000000000;
  v10 = 0;
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN5dyld44APIs13getSdkVersionEPK11mach_header_block_invoke;
  v4[3] = &unk_1E4F7D950;
  v4[5] = &v5;
  v4[6] = this;
  v4[4] = v9;
  dyld4::APIs::forEachImageVersion((uint64_t)this, &a2->magic, (uint64_t)v4);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  _Block_object_dispose(v9, 8);
  return v2;
}

uint64_t dyld4::APIs::dyld_sdk_at_least(dyld4::RuntimeState *a1, unsigned int *a2, unint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;

  v6 = dyld4::APIs::mapFromVersionSet((uint64_t)a1, a3, *(unsigned int *)(*((_QWORD *)a1 + 1) + 68));
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___ZN5dyld44APIs17dyld_sdk_at_leastEPK11mach_header20dyld_build_version_t_block_invoke;
  v9[3] = &unk_1E4F7D9A0;
  v9[4] = &v10;
  v9[5] = v6;
  dyld4::APIs::forEachImageVersion((uint64_t)a1, a2, (uint64_t)v9);
  if (*(_BYTE *)(*((_QWORD *)a1 + 1) + 204))
    dyld4::RuntimeState::log(a1, "dyld_sdk_at_least(%p, <%d,0x%08X>) => %d\n", a2, a3, HIDWORD(a3), *((unsigned __int8 *)v11 + 24));
  v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

void dyld4::APIs::forEachImageVersion(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  const dyld3::MachOFile *v6;
  uint64_t v7;
  vm_address_t *v8;

  Diagnostics::Diagnostics((Diagnostics *)&v8);
  v7 = *(_QWORD *)(a1 + 8);
  if (*(unsigned int **)(v7 + 8) == a2)
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a3 + 16))(a3, *(unsigned int *)(v7 + 68), *(unsigned int *)(v7 + 48), *(unsigned int *)(v7 + 56));
  }
  else if (DyldSharedCache::inDyldCache(*(DyldSharedCache **)(v7 + 240), (const DyldSharedCache *)a2, v6))
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a3 + 16))(a3, *(unsigned int *)(*(_QWORD *)(a1 + 8) + 384), *(unsigned int *)(*(_QWORD *)(a1 + 8) + 388), *(unsigned int *)(*(_QWORD *)(a1 + 8) + 388));
  }
  else if (dyld3::MachOFile::isMachO((dyld3::MachOFile *)a2, (vm_address_t *)&v8, a2[5] + 32))
  {
    dyld4::APIs::forEachPlatform(a1, (const dyld3::MachOFile *)a2, a3);
  }
  mach_o::Error::~Error(&v8);
}

BOOL DyldSharedCache::inDyldCache(DyldSharedCache *this, const DyldSharedCache *a2, const dyld3::MachOFile *a3)
{
  int v5;
  _BOOL8 result;

  v5 = dyld3::MachOFile::inDyldCache(a2);
  result = 0;
  if (a2 >= this && this)
  {
    if (v5)
      return (DyldSharedCache *)((char *)this + DyldSharedCache::mappedSize(this)) > a2;
  }
  return result;
}

uint64_t dyld3::MachOFile::inDyldCache(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 6) >> 31;
}

uint64_t ___ZN5dyld44APIs13getSdkVersionEPK11mach_header_block_invoke(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v7;
  int v8;

  v3 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
  if (!*(_BYTE *)(v3 + 24))
  {
    v4 = result;
    v5 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 48) + 8) + 68);
    if (v5 == (_DWORD)a2)
    {
      *(_BYTE *)(v3 + 24) = 1;
      result = dyld3::MachOFile::basePlatform(a2);
      v7 = a3 + 458752;
      v8 = a3 + 589824;
      if ((_DWORD)result != 5)
        v8 = a3;
      if ((_DWORD)result != 4)
        v7 = v8;
      goto LABEL_10;
    }
    if ((_DWORD)a2 == 7 && v5 == 6)
    {
      *(_BYTE *)(v3 + 24) = 1;
      v7 = 786432;
LABEL_10:
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24) = v7;
    }
  }
  return result;
}

uint64_t dyld4::ProcessConfig::Process::findVersionSetEquivalent(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  int *v8;
  int v9;
  unsigned int v10;
  int *v11;

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = dyld3::sVersionMap;
  while (1)
  {
    v9 = dyld3::MachOFile::basePlatform(a2);
    v10 = -1;
    switch(v9)
    {
      case 1:
        v11 = v8 + 1;
        goto LABEL_9;
      case 2:
        v11 = v8 + 2;
        goto LABEL_9;
      case 3:
        v11 = v8 + 4;
        goto LABEL_9;
      case 4:
        v11 = v8 + 3;
        goto LABEL_9;
      case 5:
        v11 = v8 + 5;
        goto LABEL_9;
      case 11:
        v11 = &dyld3::sVersionMap[v5 + 7];
LABEL_9:
        v10 = *v11;
        break;
      default:
        break;
    }
    if (v10 > a3)
      break;
    v6 = dyld3::sVersionMap[v5];
    v8 += 9;
    v5 += 9;
    v7 = v10;
    if (v5 == 423)
    {
      v7 = v10;
      break;
    }
  }
  if (v10 == -1 && v7 == 0)
    return 0xFFFFFFFFLL;
  else
    return v6;
}

uint64_t ___ZN5dyld44APIs17dyld_sdk_at_leastEPK11mach_header20dyld_build_version_t_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6;
  uint64_t result;

  v6 = dyld3::MachOFile::basePlatform(a2);
  result = dyld3::MachOFile::basePlatform(*(unsigned int *)(a1 + 40));
  if (v6 == (_DWORD)result)
  {
    result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result)
    {
      if (*(_DWORD *)(a1 + 44) <= a3)
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    }
  }
  return result;
}

uint64_t dyld3::MachOFile::basePlatform(uint64_t result)
{
  if (result <= 0x1E && ((0x7E1F9FFFu >> result) & 1) != 0)
    return dword_1A5CBC06C[(int)result];
  return result;
}

void dyld4::JustInTimeLoader::withRegions(dyld3::MachOFile *a1, uint64_t a2)
{
  int v4;
  uint64_t Address;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16[6];
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  __n128 (*v21)(uint64_t, uint64_t);
  uint64_t (*v22)();
  char *v23;
  uint64_t v24;
  uint64_t v25;

  v4 = dyld3::MachOFile::segmentCount(a1);
  Address = dyld3::MachOFile::preferredLoadAddress(a1);
  __chkstk_darwin(Address, v6, v7, v8, v9, v10, v11, v12, v16[0]);
  v18 = 0;
  v19 = &v18;
  v20 = 0x4002000000;
  v21 = __Block_byref_object_copy__75;
  v22 = __Block_byref_object_dispose__76;
  v23 = (char *)v16 - v14;
  v24 = v13;
  v25 = 0;
  v16[0] = (uint64_t)_NSConcreteStackBlock;
  v16[1] = 0x40000000;
  v16[2] = (uint64_t)___ZN5dyld416JustInTimeLoader11withRegionsEPKN5dyld39MachOFileEU13block_pointerFvRKNS1_5ArrayINS_6Loader6RegionEEEE_block_invoke;
  v16[3] = (uint64_t)&unk_1E4F7D418;
  v17 = v4;
  v16[4] = (uint64_t)&v18;
  v16[5] = v15;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v16);
  (*(void (**)(uint64_t, uint64_t *))(a2 + 16))(a2, v19 + 5);
  _Block_object_dispose(&v18, 8);
}

void dyld4::Loader::forEachBindTarget(dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7)
{
  _QWORD v7[10];
  char v8;

  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke;
  v7[3] = &unk_1E4F7CF70;
  v8 = a5;
  v7[8] = a2;
  v7[9] = a3;
  v7[4] = a4;
  v7[5] = a6;
  v7[6] = a7;
  v7[7] = a1;
  dyld4::Loader::withLayout(a1, a2, a3, (uint64_t)v7);
}

void dyld4::Loader::withLayout(dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4)
{
  if (*(_DWORD *)a1 != 1815378276)
    dyld4::Loader::withLayout();
  if ((*((_WORD *)a1 + 2) & 1) != 0)
    dyld4::PrebuiltLoader::withLayout(a1, a2, a3, a4);
  else
    dyld4::JustInTimeLoader::withLayout((uint64_t)a1, a2, (uint64_t)a3, a4);
}

void dyld4::JustInTimeLoader::withLayout(uint64_t a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  dyld3::MachOAnalyzer::withVMLayout(*(dyld3::MachOLoaded **)(a1 + 32), a2, a4);
}

void dyld3::MachOAnalyzer::withVMLayout(dyld3::MachOLoaded *a1, vm_address_t *a2, uint64_t a3)
{
  uint64_t Slide;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  vm_address_t *v20;
  int v21;
  uint64_t v22;
  _QWORD v23[2];
  int v24;
  uint64_t v25;
  _QWORD v26[2];
  int v27;
  uint64_t v28;
  _QWORD v29[2];
  int v30;
  uint64_t v31;
  _QWORD v32[2];
  int v33;
  uint64_t v34;
  _QWORD v35[2];
  int v36;
  uint64_t v37;
  _QWORD v38[2];
  int v39;
  uint64_t v40;
  _QWORD v41[2];
  int v42;
  uint64_t v43;
  _QWORD v44[2];
  int v45;
  uint64_t v46;
  _QWORD v47[2];
  int v48;
  uint64_t v49;
  _QWORD v50[2];
  int v51;
  uint64_t v52;
  _QWORD v53[2];
  int v54;
  uint64_t v55;
  _QWORD v56[2];
  int v57;
  uint64_t v58;
  _QWORD v59[3];
  int v60;
  uint64_t v61;
  _QWORD v62[2];
  int v63;
  uint64_t v64;
  _QWORD v65[2];
  int v66;
  uint64_t v67;
  _QWORD v68[2];
  int v69;
  uint64_t v70;
  _QWORD v71[2];
  int v72;
  uint64_t v73;
  _QWORD v74[2];
  int v75;
  __int16 v76;
  _QWORD v77[8];
  uint64_t v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD v86[8];
  uint64_t v87;
  uint64_t v88;

  v20 = a2;
  Slide = dyld3::MachOLoaded::getSlide(a1);
  v82 = 0;
  v83 = &v82;
  v84 = 0x2000000000;
  v85 = 0;
  v78 = 0;
  v79 = &v78;
  v80 = 0x2000000000;
  v81 = 0;
  v6 = dyld3::MachOFile::segmentCount(a1);
  v7 = v6;
  __chkstk_darwin(v6, v8, v9, v10, v11, v12, v13, v14, (uint64_t)&v19);
  v16 = &v19 - 2 * v15;
  if (v17)
    bzero(v16, 48 * ((48 * (unint64_t)v7 - 48) / 0x30) + 48);
  v77[0] = _NSConcreteStackBlock;
  v77[1] = 0x40000000;
  v77[2] = ___ZNK5dyld313MachOAnalyzer12withVMLayoutER11DiagnosticsU13block_pointerFvRKN6mach_o6LayoutEE_block_invoke;
  v77[3] = &unk_1E4F7F7A0;
  v77[4] = &v82;
  v77[5] = &v78;
  v77[6] = Slide;
  v77[7] = v16;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v77);
  v21 = 0;
  v22 = 0;
  v23[0] = 0;
  *(_QWORD *)((char *)v23 + 5) = 0;
  v24 = 0;
  v25 = 0;
  v26[0] = 0;
  *(_QWORD *)((char *)v26 + 5) = 0;
  v27 = 0;
  v28 = 0;
  v29[0] = 0;
  *(_QWORD *)((char *)v29 + 5) = 0;
  v30 = 0;
  v31 = 0;
  v32[0] = 0;
  *(_QWORD *)((char *)v32 + 5) = 0;
  v33 = 0;
  *(_QWORD *)((char *)v35 + 5) = 0;
  v34 = 0;
  v35[0] = 0;
  v36 = 0;
  v37 = 0;
  v38[0] = 0;
  *(_QWORD *)((char *)v38 + 5) = 0;
  v39 = 0;
  v40 = 0;
  v41[0] = 0;
  *(_QWORD *)((char *)v41 + 5) = 0;
  v42 = 0;
  v43 = 0;
  v44[0] = 0;
  *(_QWORD *)((char *)v44 + 5) = 0;
  v45 = 0;
  *(_QWORD *)((char *)v47 + 5) = 0;
  v46 = 0;
  v47[0] = 0;
  v48 = 0;
  *(_QWORD *)((char *)v50 + 5) = 0;
  v49 = 0;
  v50[0] = 0;
  v51 = 0;
  *(_QWORD *)((char *)v53 + 5) = 0;
  v52 = 0;
  v53[0] = 0;
  v54 = 0;
  *(_QWORD *)((char *)v56 + 5) = 0;
  v55 = 0;
  v56[0] = 0;
  v57 = 0;
  *(_QWORD *)((char *)v59 + 5) = 0;
  v58 = 0;
  v59[0] = 0;
  v59[2] = 0;
  v60 = 0;
  *(_QWORD *)((char *)v62 + 5) = 0;
  v61 = 0;
  v62[0] = 0;
  v63 = 0;
  *(_QWORD *)((char *)v65 + 5) = 0;
  v64 = 0;
  v65[0] = 0;
  v66 = 0;
  *(_QWORD *)((char *)v68 + 5) = 0;
  v68[0] = 0;
  v67 = 0;
  v69 = 0;
  *(_QWORD *)((char *)v71 + 5) = 0;
  v71[0] = 0;
  v70 = 0;
  v72 = 0;
  *(_QWORD *)((char *)v74 + 5) = 0;
  v74[0] = 0;
  v73 = 0;
  v75 = 0;
  v76 = 0;
  v18 = v83[3];
  v87 = v79[3];
  v88 = v18;
  v86[0] = _NSConcreteStackBlock;
  v86[1] = 0x40000000;
  v86[2] = ___ZNK5dyld313MachOAnalyzer17getLinkeditLayoutER11DiagnosticsyPKhRN6mach_o14LinkeditLayoutE_block_invoke;
  v86[3] = &__block_descriptor_tmp_269;
  v86[4] = a1;
  v86[5] = &v21;
  v86[6] = &v88;
  v86[7] = &v87;
  dyld3::MachOFile::forEachLoadCommand(a1, v20, (uint64_t)v86);
  mach_o::Layout::Layout(v86, (uint64_t)a1, (uint64_t)v16, v7, (uint64_t)&v21);
  (*(void (**)(uint64_t, _QWORD *))(a3 + 16))(a3, v86);
  _Block_object_dispose(&v78, 8);
  _Block_object_dispose(&v82, 8);
}

uint64_t dyld3::MachOFile::segmentCount(dyld3::MachOFile *this)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile12segmentCountEv_block_invoke;
  v3[3] = &unk_1E4F7EDB0;
  v3[4] = &v4;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v3);
  v1 = *((unsigned int *)v5 + 6);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  dyld3::MachOFile ***v4;
  char v5;
  uint64_t v6;
  _QWORD v7[9];
  _QWORD v8[4];
  __int128 v9;
  _QWORD *v10;
  uint64_t v11;
  vm_address_t *v12;
  uint64_t v13;
  _QWORD v14[3];
  int v15;
  _QWORD v16[3];
  int v17;
  uint64_t v18;

  v3 = *(_QWORD *)(a1 + 56);
  v4 = (dyld3::MachOFile ***)mach_o::SymbolTable::SymbolTable(&v18, a2);
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x2000000000;
  v17 = 0;
  v14[0] = 0;
  v14[1] = v14;
  v14[2] = 0x2000000000;
  v15 = 0;
  v5 = *(_BYTE *)(a1 + 80);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2;
  v8[3] = &unk_1E4F7CF20;
  v10 = v16;
  v11 = v3;
  v6 = *(_QWORD *)(a1 + 72);
  v12 = *(vm_address_t **)(a1 + 64);
  v13 = v6;
  v9 = *(_OWORD *)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3;
  v7[3] = &unk_1E4F7CF48;
  v7[7] = v3;
  v7[8] = v6;
  v7[4] = v9;
  v7[5] = *(_QWORD *)(a1 + 48);
  v7[6] = v14;
  mach_o::Fixups::forEachBindTarget(v4, v12, v5, 0, (uint64_t)v8, (uint64_t)v7);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(v16, 8);
}

void mach_o::Fixups::forEachBindTarget(dyld3::MachOFile ***a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!dyld3::MachOFile::isPreload(**a1))
  {
    if (dyld3::MachOFile::hasChainedFixups(**a1))
    {
      mach_o::Fixups::forEachBindTarget_ChainedFixups(a1, a2, a5);
    }
    else if (dyld3::MachOFile::hasOpcodeFixups(**a1))
    {
      mach_o::Fixups::forEachBindTarget_Opcodes(a1, (Diagnostics *)a2, a3, a5, a6);
    }
  }
}

_QWORD *mach_o::Layout::Layout(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *result = a2;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  return result;
}

_QWORD *mach_o::SymbolTable::SymbolTable(_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke_2(uint64_t a1, _QWORD *a2)
{
  _BOOL8 hasCodeSignature;
  mach_o::Header *v5;
  dyld4::RuntimeState *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;

  hasCodeSignature = dyld3::MachOFile::hasCodeSignature(*(dyld3::MachOFile **)(a1 + 40), &v9, &v10);
  LOBYTE(v8) = 0;
  v5 = (mach_o::Header *)dyld4::Loader::mapSegments(*(vm_address_t **)(a1 + 48), *(dyld4::SyscallDelegate ***)(a1 + 56), *(dyld3 **)(a1 + 64), *(_QWORD *)(a1 + 72), &v9, hasCodeSignature, a2, (void *)*(unsigned __int8 *)(a1 + 164), v8, a1 + 80);
  if (v5)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = dyld4::JustInTimeLoader::make(*(_QWORD *)(a1 + 56), v5, *(const char **)(a1 + 64), *(__int128 **)(a1 + 136), *(_QWORD *)(a1 + 80), *(_BYTE *)(a1 + 164), *(_BYTE *)(a1 + 165), *(unsigned __int8 *)(a1 + 166), *(_DWORD *)(a1 + 160));
    v6 = *(dyld4::RuntimeState **)(a1 + 56);
    if (*(_BYTE *)(*((_QWORD *)v6 + 1) + 200))
      dyld4::Loader::logLoad(*(dyld4::Loader **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), v6, *(char **)(a1 + 64));
    if (*(_BYTE *)(*(_QWORD *)(a1 + 152) + 3))
    {
      v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      *(_QWORD *)(v7 + 40) |= 0x80000uLL;
    }
  }
}

_QWORD *dyld4::JustInTimeLoader::make(uint64_t a1, mach_o::Header *this, const char *a3, __int128 *a4, uint64_t a5, char a6, char a7, int a8, __int16 a9)
{
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  _QWORD *v22;
  const dyld3::MachOFile *v23;
  char hasPlusLoadMethod;
  char v25;
  char hasConstObjCSection;
  char *v27;
  BOOL v28;
  __int128 v29;
  __int128 v30;
  __int16 v31;
  _BOOL4 isDylib;
  unint64_t v33;
  char *v34;
  _OWORD *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t i;
  const char *v41;
  BOOL v42;
  char hasObjC;
  char v44;
  char v45;
  char v46;
  char v47;
  char v48;
  char v49;
  BOOL Uuid;
  char hasWeakDefs;
  char hasThreadLocalVariables;
  BOOL v53;
  BOOL v54;
  vm_address_t *v55[5];
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  char v59;
  unsigned __int8 v60[16];

  v54 = 1;
  v16 = mach_o::Header::linkedDylibCount(this, &v54);
  v17 = v16 - 1;
  if (!v16)
    v17 = 1;
  v18 = 8 * v17 + 472;
  v19 = v16;
  if (v54)
    v20 = 0;
  else
    v20 = v16;
  v41 = a3;
  v21 = _platform_strlen(a3);
  v22 = lsl::Allocator::malloc(*(lsl::Allocator **)(a1 + 16), v21 + v20 + v18 + 1);
  memset(v60, 0, sizeof(v60));
  dyld4::Loader::InitialOptions::InitialOptions((uint64_t)&v42);
  v42 = DyldSharedCache::inDyldCache(*(DyldSharedCache **)(*(_QWORD *)(a1 + 8) + 240), this, v23);
  hasObjC = dyld3::MachOFile::hasObjC(this);
  Diagnostics::Diagnostics((Diagnostics *)v55);
  hasPlusLoadMethod = dyld3::MachOFile::hasPlusLoadMethod(this, (Diagnostics *)v55);
  mach_o::Error::~Error(v55);
  v44 = hasPlusLoadMethod;
  v56 = 0;
  v57 = &v56;
  v58 = 0x2000000000;
  v59 = 0;
  v55[0] = (vm_address_t *)_NSConcreteStackBlock;
  v55[1] = (vm_address_t *)0x40000000;
  v55[2] = (vm_address_t *)___ZN5dyld4L12hasDataConstEPKN5dyld39MachOFileE_block_invoke;
  v55[3] = (vm_address_t *)&unk_1E4F7D4B0;
  v55[4] = (vm_address_t *)&v56;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v55);
  v25 = *((_BYTE *)v57 + 24);
  _Block_object_dispose(&v56, 8);
  v45 = v25;
  v46 = a6 | a8;
  v47 = a7;
  if (hasObjC)
    hasConstObjCSection = dyld3::MachOFile::hasConstObjCSection(this);
  else
    hasConstObjCSection = 0;
  v48 = hasConstObjCSection;
  v49 = dyld3::MachOFile::enforceFormat(this, 16) ^ 1;
  Uuid = dyld3::MachOFile::getUuid(this, v60);
  hasWeakDefs = dyld3::MachOFile::hasWeakDefs(this);
  hasThreadLocalVariables = dyld3::MachOFile::hasThreadLocalVariables(this);
  if (dyld3::MachOFile::isDylib(this))
  {
    v27 = dyld3::MachOFile::installName(this);
    v28 = _platform_strncmp(v27, "/usr/lib/system/lib", 0x13uLL) == 0;
  }
  else
  {
    v28 = 0;
  }
  v53 = v28;
  dyld4::Loader::Loader((uint64_t)v22, &v42, 0, 0, 0, 0);
  v22[4] = this;
  v22[6] = 0;
  v29 = *a4;
  v30 = a4[1];
  v22[15] = 1;
  *(_OWORD *)(v22 + 7) = v29;
  *(_OWORD *)(v22 + 9) = v30;
  *(_OWORD *)(v22 + 11) = 0u;
  *(_OWORD *)(v22 + 13) = 0u;
  if (v54)
    v31 = 0;
  else
    v31 = v19;
  v22[5] = v22[5] & 0xFFFFFFFFFFF00000 | (unsigned __int16)(v31 + v18);
  isDylib = dyld3::MachOFile::isDylib(this);
  v33 = 0;
  if (isDylib)
  {
    v34 = dyld3::MachOFile::installName(this);
    v33 = (unint64_t)(_platform_strcmp(v34, v41) != 0) << 20;
  }
  v22[5] = v22[5] & 0xFFFFFFFF4FFFFFLL | v33 | ((unint64_t)v54 << 23);
  v22[6] = a5;
  v35 = v22 + 1;
  if (Uuid)
    *v35 = *(_OWORD *)v60;
  else
    bzero(v35, 0x10uLL);
  *((_DWORD *)v22 + 6) = *((_DWORD *)this + 2);
  dyld4::JustInTimeLoader::parseSectionLocations(this, (uint64_t)(v22 + 15));
  if ((dyld3::MachOFile::hasExportTrie(this, (unsigned int *)v22 + 28, (unsigned int *)v22 + 29) & 1) == 0)
    v22[14] = 0;
  v22[11] = 0;
  v22[13] = 0;
  v36 = 0x400000;
  if (!a8)
    v36 = 0;
  v37 = v36 & 0xFFFFFF8000FFFFFFLL | ((unint64_t)(a9 & 0x7FFF) << 24) | ((unint64_t)(unsigned __int16)v19 << 39) | v22[5] & 0xFF80000000BFFFFFLL;
  v22[5] = v37;
  if ((_DWORD)v19)
  {
    for (i = 0; i != v19; ++i)
    {
      v22[i + 58] = 0;
      if (!v54)
        *(_BYTE *)dyld4::JustInTimeLoader::dependentAttrs((dyld4::JustInTimeLoader *)v22, i) = mach_o::LinkedDylibAttributes::regular;
    }
    LOWORD(v37) = *((_WORD *)v22 + 20);
  }
  strlcpy((char *)v22 + (unsigned __int16)v37, v41, 0x400uLL);
  v22[5] &= ~0x80000000000000uLL;
  dyld4::RuntimeState::add((dyld4::RuntimeState *)a1, (const dyld4::Loader *)v22);
  if ((a8 & 1) != 0)
  {
    if (v42)
      *(_BYTE *)(a1 + 1159) = 1;
    else
      *(_BYTE *)(a1 + 1158) = 1;
  }
  if (*(_BYTE *)(*(_QWORD *)(a1 + 8) + 207))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)a1, "using JustInTimeLoader %p for %s\n", v22, v41);
  return v22;
}

uint64_t dyld3::MachOFile::hasExportTrie(dyld3::MachOFile *this, unsigned int *a2, unsigned int *a3)
{
  uint64_t v6;
  int v7;
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  vm_address_t *v14;
  _QWORD v15[7];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;

  v24 = 0;
  v25 = &v24;
  v26 = 0x2000000000;
  v27 = 0;
  v20 = 0;
  v21 = &v20;
  v22 = 0x2000000000;
  v23 = 0;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke;
  v15[3] = &unk_1E4F7EE00;
  v15[4] = &v24;
  v15[5] = &v20;
  v15[6] = &v16;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v15);
  Diagnostics::Diagnostics((Diagnostics *)&v14);
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = -1;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke_2;
  v9[3] = &unk_1E4F7EE28;
  v9[4] = &v10;
  v9[5] = a3;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v14, (uint64_t)v9);
  v6 = 0;
  if (!Diagnostics::hasError((Diagnostics *)&v14))
  {
    v7 = *((_DWORD *)v11 + 6);
    if (v7 == -1)
    {
      v6 = 0;
    }
    else
    {
      *a2 = *((_DWORD *)v21 + 6) + v7 - (*((_DWORD *)v17 + 6) + *((_DWORD *)v25 + 6));
      v6 = 1;
    }
  }
  _Block_object_dispose(&v10, 8);
  mach_o::Error::~Error(&v14);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v24, 8);
  return v6;
}

uint64_t dyld3::MachOFile::hasObjC(dyld3::MachOFile *this)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile7hasObjCEv_block_invoke;
  v3[3] = &unk_1E4F7E938;
  v3[4] = &v4;
  v3[5] = this;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t dyld3::MachOFile::hasPlusLoadMethod(dyld3::MachOFile *this, Diagnostics *a2)
{
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile17hasPlusLoadMethodER11Diagnostics_block_invoke;
  v4[3] = &unk_1E4F7EC50;
  v4[4] = &v5;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v4);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t dyld3::MachOFile::enforceFormat(_DWORD *a1, int a2)
{
  uint64_t v2;
  _QWORD v4[5];
  int v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile13enforceFormatENS0_9MalformedE_block_invoke;
  v4[3] = &unk_1E4F7EF78;
  v5 = a2;
  v4[4] = &v6;
  dyld3::MachOFile::forEachSupportedPlatform(a1, (uint64_t)v4);
  v2 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t dyld4::Loader::Loader(uint64_t result, _BYTE *a2, __int16 a3, int a4, __int16 a5, int a6)
{
  __int16 v6;
  __int16 v7;
  __int16 v8;
  __int16 v9;
  __int16 v10;
  __int16 v11;
  __int16 v12;
  __int16 v13;
  __int16 v14;
  __int16 v15;
  __int16 v16;
  __int16 v17;
  __int16 v18;
  __int16 v19;
  __int16 v20;

  *(_DWORD *)result = 1815378276;
  v6 = *(_WORD *)(result + 4) & 0xFFFE | a3;
  *(_WORD *)(result + 4) = v6;
  v7 = v6 & 0xFFFD | (2 * (*a2 & 0x7F));
  *(_WORD *)(result + 4) = v7;
  v8 = v7 & 0xFFFB | (4 * (a2[1] & 0x3F));
  *(_WORD *)(result + 4) = v8;
  v9 = v8 & 0xFFF7 | (8 * (a2[2] & 0x1F));
  *(_WORD *)(result + 4) = v9;
  v10 = v9 & 0xFFEF | (16 * (a2[3] & 0xF));
  *(_WORD *)(result + 4) = v10;
  v11 = v10 & 0xFFDF | (32 * (a2[4] & 7));
  *(_WORD *)(result + 4) = v11;
  v12 = v11 & 0xFFBF | ((a2[5] & 3) << 6);
  *(_WORD *)(result + 4) = v12;
  v13 = v12 & 0xFF7F | ((a2[6] & 1) << 7);
  *(_WORD *)(result + 4) = v13;
  v14 = v13 & 0xFCFF | (a2[7] << 8);
  if (a6)
    v15 = 512;
  else
    v15 = 0;
  v16 = v14 | v15;
  *(_WORD *)(result + 4) = v16;
  v17 = v16 & 0xFBFF | (a2[8] << 10);
  *(_WORD *)(result + 4) = v17;
  v18 = v17 & 0xF7FF | (a2[9] << 11);
  *(_WORD *)(result + 4) = v18;
  v19 = v18 & 0xEFFF | (a2[10] << 12);
  *(_WORD *)(result + 4) = v19;
  *(_WORD *)(result + 4) = v19 & 0x1FFF | (a2[11] << 13);
  if (a4)
    v20 = 0x8000;
  else
    v20 = 0;
  *(_WORD *)(result + 6) = v20 | a5;
  *(_QWORD *)(result + 24) = 0;
  return result;
}

uint64_t dyld4::Loader::InitialOptions::InitialOptions(uint64_t this)
{
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)this = 0;
  return this;
}

void dyld4::JustInTimeLoader::parseSectionLocations(dyld3::MachOFile *a1, uint64_t a2)
{
  _QWORD v4[5];
  _QWORD v5[6];

  *(_OWORD *)(a2 + 248) = 0u;
  *(_OWORD *)(a2 + 232) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 184) = 0u;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 312) = 0u;
  *(_OWORD *)(a2 + 328) = 0u;
  *(_OWORD *)(a2 + 280) = 0u;
  *(_OWORD *)(a2 + 296) = 0u;
  *(_OWORD *)(a2 + 264) = 0u;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke;
  v5[3] = &__block_descriptor_tmp_46_1;
  v5[4] = dyld3::MachOFile::preferredLoadAddress(a1);
  v5[5] = a2;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke_2;
  v4[3] = &unk_1E4F7D3C8;
  v4[4] = v5;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v4);
}

BOOL dyld3::MachOFile::hasCodeSignature(dyld3::MachOFile *this, unsigned int *a2, unsigned int *a3)
{
  _BOOL8 v6;
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;
  _QWORD v17[6];
  vm_address_t *v18;

  *a2 = 0;
  *a3 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v18);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  v17[2] = ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke;
  v17[3] = &__block_descriptor_tmp_157_0;
  v17[4] = a2;
  v17[5] = a3;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v18, (uint64_t)v17);
  Diagnostics::assertNoError((Diagnostics *)&v18);
  if (*a2)
  {
    if ((*((_DWORD *)this + 1) | 0x1000000) == 0x1000007)
    {
      v13 = 0;
      v14 = &v13;
      v15 = 0x2000000000;
      v16 = 0;
      v9 = 0;
      v10 = &v9;
      v11 = 0x2000000000;
      v12 = 0;
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000;
      v8[2] = ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke_2;
      v8[3] = &unk_1E4F7ED60;
      v8[4] = &v13;
      v8[5] = &v9;
      dyld3::MachOFile::forEachSupportedPlatform(this, (uint64_t)v8);
      if (*((_BYTE *)v14 + 24))
        v6 = *((_BYTE *)v10 + 24) == 0;
      else
        v6 = 0;
      _Block_object_dispose(&v9, 8);
      _Block_object_dispose(&v13, 8);
    }
    else
    {
      v6 = 1;
    }
  }
  else
  {
    v6 = 0;
  }
  mach_o::Error::~Error(&v18);
  return v6;
}

void ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke(uint64_t a1, dyld3::FatFile *a2, unint64_t a3, int a4, uint64_t *a5, uint64_t a6)
{
  int *v10;
  dyld3::MachOFile *v11;
  _BYTE *v12;
  char v13;
  BOOL v14;
  unint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  vm_address_t *v21;
  unint64_t v22;
  _QWORD v23[16];
  char v24;
  uint64_t *v25;
  int8x16_t v26;
  int v27;
  BOOL v28;
  char v29;
  char v30;

  v22 = 0;
  v10 = dyld3::MachOFile::compatibleSlice(*(vm_address_t **)(a1 + 40), &v22, a2, a3, *(const char **)(a1 + 48), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 68), a4, *(dyld3::GradedArchs **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 144), *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 169));
  if (v10)
  {
    v11 = (dyld3::MachOFile *)v10;
    if (dyld3::MachOFile::isDylib((dyld3::MachOFile *)v10))
    {
      v12 = *(_BYTE **)(a1 + 64);
      if (!v12[7])
      {
        Diagnostics::error(*(vm_address_t **)(a1 + 40), "cannot load dylib '%s'");
        return;
      }
    }
    else if (dyld3::MachOFile::isBundle(v11))
    {
      v12 = *(_BYTE **)(a1 + 64);
      if (!v12[8])
      {
        Diagnostics::error(*(vm_address_t **)(a1 + 40), "cannot link against bundle '%s'");
        return;
      }
    }
    else
    {
      if (!dyld3::MachOFile::isMainExecutable(v11))
      {
        Diagnostics::error(*(vm_address_t **)(a1 + 40), "unloadable mach-o file type %d '%s'");
        return;
      }
      v12 = *(_BYTE **)(a1 + 64);
      if (!v12[9])
      {
        v21 = *(vm_address_t **)(a1 + 40);
        if (v12[1])
          Diagnostics::error(v21, "cannot link against a main executable '%s'");
        else
          Diagnostics::error(v21, "cannot dlopen a main executable '%s'");
        return;
      }
    }
    v13 = v12[4];
    if (v12[10])
    {
      v14 = 0;
    }
    else if (*v12)
    {
      v14 = 1;
    }
    else
    {
      v14 = dyld3::MachOAnalyzer::neverUnload(v11);
    }
    v15 = dyld3::MachOFile::mappedSize(v11);
    v16 = *((_BYTE *)a5 + 24);
    v17 = *a5;
    v23[0] = _NSConcreteStackBlock;
    v23[2] = ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke_2;
    v23[3] = &unk_1E4F7D440;
    v18 = *(_QWORD *)(a1 + 56);
    v19 = *(_QWORD *)(a1 + 32);
    v23[6] = *(_QWORD *)(a1 + 40);
    v23[7] = v18;
    v20 = a5[2];
    v23[1] = 0x40000000;
    v23[8] = a6;
    v23[9] = v15;
    v28 = v14;
    v23[10] = v11 - a2;
    v23[12] = v17;
    v23[13] = v20;
    v24 = v16;
    v23[4] = v19;
    v23[5] = v11;
    v25 = a5;
    v29 = v13;
    v30 = *(_BYTE *)(a1 + 84);
    v27 = *(_DWORD *)(a1 + 80);
    v26 = vextq_s8(*(int8x16_t *)(a1 + 64), *(int8x16_t *)(a1 + 64), 8uLL);
    dyld4::JustInTimeLoader::withRegions(v11, (uint64_t)v23);
  }
}

dyld3::MachOAnalyzer *dyld4::SyscallDelegate::withReadOnlyMappedFile(int a1, vm_address_t *a2, dyld3 *a3, int a4, uint64_t a5)
{
  unsigned __int8 *v6;
  dyld3::MachOAnalyzer *result;
  dyld3::MachOAnalyzer *v8;
  unsigned __int8 v9;
  _OWORD v10[2];
  size_t v11;
  _BYTE v12[1024];

  v11 = 0;
  memset(v10, 0, sizeof(v10));
  v9 = 0;
  if (a4)
    v6 = &v9;
  else
    v6 = 0;
  result = dyld4::SyscallDelegate::mapFileReadOnly(a1, a2, a3, (off_t *)&v11, (uint64_t)v10, v6, (uint64_t)v12);
  if (result)
  {
    v8 = result;
    (*(void (**)(uint64_t, dyld3::MachOAnalyzer *, size_t, _QWORD, _OWORD *, _BYTE *))(a5 + 16))(a5, result, v11, v9, v10, v12);
    return (dyld3::MachOAnalyzer *)munmap(v8, v11);
  }
  return result;
}

dyld3::MachOAnalyzer *dyld4::SyscallDelegate::mapFileReadOnly(int a1, vm_address_t *a2, dyld3 *this, off_t *a4, uint64_t a5, _BYTE *a6, uint64_t a7)
{
  int v13;
  int v14;
  dyld3::MachOAnalyzer *v15;
  dyld3::MachOAnalyzer *v16;
  __darwin_time_t tv_sec;
  uint64_t st_dev;
  const void *v19;
  int v20;
  pid_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  pid_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  off_t st_size;
  int *v35;
  dyld3::FatFile *v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD v39[6];
  int v40;
  stat v41;

  if (dyld3::stat(this, &v41, (stat *)this) == -1)
  {
    v20 = *__error();
    if (v20 == 2)
    {
      Diagnostics::error(a2, "no such file");
    }
    else if (v20 == 1
           && (v21 = getpid(),
               (int)sandbox_check(v21, (vm_address_t *)"file-read-metadata", 1073741825, v22, v23, v24, v25, v26, this) >= 1))
    {
      Diagnostics::error(a2, "file system sandbox blocked stat()", v37);
    }
    else
    {
      __error();
      Diagnostics::error(a2, "stat() failed with errno=%d");
    }
    return 0;
  }
  if (!v41.st_size)
    return 0;
  v13 = dyld3::open(this, 0, 0);
  if (v13 < 0)
  {
    if (*__error() == 1
      && (v27 = getpid(),
          (int)sandbox_check(v27, (vm_address_t *)"file-read-data", 1073741825, v28, v29, v30, v31, v32, this) >= 1))
    {
      Diagnostics::error(a2, "file system sandbox blocked open()", v38);
    }
    else
    {
      Diagnostics::error(a2, "open() failed with errno=%d");
    }
    return 0;
  }
  v14 = v13;
  v15 = (dyld3::MachOAnalyzer *)mmap(0, v41.st_size, 1, 2, v13, 0);
  if (v15 == (dyld3::MachOAnalyzer *)-1)
  {
    st_size = v41.st_size;
    v35 = __error();
    Diagnostics::error(a2, "mmap(size=0x%0lX) failed with errno=%d", st_size, *v35);
    close(v14);
    return 0;
  }
  v16 = v15;
  if (a4)
    *a4 = v41.st_size;
  if (a5)
  {
    tv_sec = v41.st_mtimespec.tv_sec;
    st_dev = v41.st_dev;
    *(_QWORD *)a5 = v41.st_ino;
    *(_QWORD *)(a5 + 8) = st_dev;
    *(_QWORD *)(a5 + 16) = tv_sec;
    *(_BYTE *)(a5 + 24) = 1;
  }
  if (a7)
    fcntl(v14, 50, a7);
  if (a6)
  {
    *a6 = 0;
    if (dyld3::MachOFile::hasMachOMagic(v16))
    {
      if (*((_DWORD *)v16 + 1) == 16777228
        && (*((_DWORD *)v16 + 2) & 0xFFFFFF) == 2
        && dyld3::MachOAnalyzer::isOSBinary(v16, v14, 0))
      {
        *a6 = 1;
      }
    }
    else
    {
      v36 = (dyld3::FatFile *)dyld3::FatFile::isFatFile(v16, v19);
      if (v36)
      {
        v39[0] = _NSConcreteStackBlock;
        v39[1] = 0x40000000;
        v39[2] = ___ZNK5dyld415SyscallDelegate15mapFileReadOnlyER11DiagnosticsPKcPmPNS_6FileIDEPbPc_block_invoke;
        v39[3] = &__block_descriptor_tmp_14;
        v40 = v14;
        v39[4] = v16;
        v39[5] = a6;
        dyld3::FatFile::forEachSlice(v36, a2, v41.st_size, (uint64_t)v39);
      }
    }
  }
  close(v14);
  return v16;
}

vm_address_t dyld4::Loader::mapSegments(vm_address_t *a1, dyld4::SyscallDelegate **a2, dyld3 *a3, uint64_t a4, unsigned int *a5, uint64_t a6, _QWORD *a7, void *a8, uint64_t a9, uint64_t a10)
{
  int v11;
  vm_size_t v13;
  uint64_t v17;
  dyld4::RuntimeState *v18;
  off_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  vm_address_t *v28;
  char *v29;
  int v30;
  int v31;
  char *v32;
  char *v33;
  vm_address_t v34;
  uint64_t v36;
  int v37;
  unsigned int *v38;
  uint64_t v39;
  uint64_t v40;
  size_t v41;
  BOOL v43;
  int v44;
  dyld3::MachOFile *v45;
  int *v46;
  vm_size_t v47;
  vm_size_t v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  vm_address_t v54;
  void *v55;
  void *v56;
  vm_size_t v57;
  off_t v58;
  int v59;
  int v60;
  uint64_t v61;
  dyld3 *v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  vm_address_t address;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;
  unsigned int v77[16];
  unsigned int v78[2];
  uint64_t v79;
  vm_address_t *p_address;

  v11 = a6;
  v13 = a4;
  v60 = 520552456;
  v61 = 0;
  v62 = a3;
  v63 = 0u;
  v64 = 0u;
  v65 = 0u;
  v66 = 0u;
  v67 = 0u;
  v68 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v60, (uint64_t)a2, (uint64_t)a3, a4, (uint64_t)a5, a6, (uint64_t)a7, a8);
  v17 = dyld4::SyscallDelegate::open(a2[1], a3, 0, 0);
  if ((_DWORD)v17 == -1)
  {
    v30 = *__error();
    if (v30 == 2)
    {
      Diagnostics::error(a1, "no such file");
    }
    else if (v30 == 1 && dyld4::SyscallDelegate::sandboxBlockedOpen(a2[1], (const char *)a3))
    {
      Diagnostics::error(a1, "file system sandbox blocked open(\"%s\", O_RDONLY)");
    }
    else
    {
      Diagnostics::error(a1, "open(\"%s\", O_RDONLY) failed with errno=%d");
    }
    goto LABEL_23;
  }
  v18 = (dyld4::RuntimeState *)v17;
  v19 = dyld4::Loader::validateFile(a1, (uint64_t)a2, v17, (const char *)a3, a5, a10);
  if (Diagnostics::hasError((Diagnostics *)a1))
    goto LABEL_22;
  if (v11 && a5[1])
  {
    LODWORD(address) = 520552464;
    v70 = 0u;
    v71 = 0u;
    v72 = 0u;
    v73 = 0u;
    v74 = 0u;
    v75 = 0u;
    v76 = 0;
    dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&address, v20, v21, v22, v23, v24, v25, v26);
    v27 = *a5;
    v28 = (vm_address_t *)a5[1];
    *(_QWORD *)v78 = v19;
    v79 = v27;
    p_address = v28;
    if (dyld4::SyscallDelegate::fcntl(a2[1], (int)v18, 97, v78) == -1)
    {
      v31 = *__error();
      dyld4::getUuidFromFd(a2, v18, v19, (unsigned __int8 *)v77, v32);
      if (v31 == 85 || v31 == 1)
        Diagnostics::error(a1, "code signature invalid in <%s> '%s' (errno=%d) sliceOffset=0x%08llX, codeBlobOffset=0x%08X, codeBlobSize=0x%08X");
      else
        Diagnostics::error(a1, "fcntl(fd, F_ADDFILESIGS_RETURN) failed with errno=%d in <%s> '%s', sliceOffset=0x%08llX, codeBlobOffset=0x%08X, codeBlobSize=0x%08X");
      goto LABEL_63;
    }
    if (*(_QWORD *)v78 < (unint64_t)*a5)
    {
      dyld4::getUuidFromFd(a2, v18, v19, (unsigned __int8 *)v77, v29);
      Diagnostics::error(a1, "code signature does not cover entire file up to signature in <%s> '%s' (signed 0x%08llX, expected 0x%08X) for '%s'");
LABEL_63:
      dyld4::SyscallDelegate::close(a2[1], (int)v18);
      dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&address);
      goto LABEL_23;
    }
    dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&address);
  }
  LOBYTE(address) = 0;
  *(_QWORD *)v78 = v19;
  v79 = 512;
  p_address = &address;
  if (dyld4::SyscallDelegate::fcntl(a2[1], (int)v18, 98, v78) == -1)
  {
    dyld4::getUuidFromFd(a2, v18, v19, (unsigned __int8 *)v77, v33);
    Diagnostics::error(a1, "code signature in <%s> '%s' not valid for use in process: %s");
    goto LABEL_22;
  }
  address = 0;
  if (vm_allocate(mach_task_self_, &address, v13, 1))
  {
    Diagnostics::error(a1, "vm_allocate(size=0x%0llX) failed with result=%d");
    goto LABEL_22;
  }
  if (*((_BYTE *)a2[1] + 201))
  {
    if (v19)
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "Mapping %s (slice offset=0x%llX)\n");
    else
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "Mapping %s\n");
  }
  v36 = a7[2];
  if (!v36)
  {
LABEL_57:
    v77[0] = 0;
    v78[0] = 0;
    v54 = address;
    if (dyld3::MachOFile::isFairPlayEncrypted((dyld3::MachOFile *)address, v77, v78)
      && dyld4::SyscallDelegate::mremap_encrypted(a2[1], (void *)(address + v77[0]), (void *)v78[0], (void *)1, (void *)*(unsigned int *)(v54 + 4), (void *)*(unsigned int *)(v54 + 8), v55, v56))
    {
      Diagnostics::error(a1, "could not register fairplay decryption, mremap_encrypted() => %d");
      goto LABEL_60;
    }
    dyld4::SyscallDelegate::close(a2[1], (int)v18);
    v34 = address;
    goto LABEL_24;
  }
  v37 = 0;
  v59 = *((unsigned __int8 *)a2[1] + 159);
  v38 = (unsigned int *)(*a7 + 12);
  v39 = 16 * v36;
  v58 = v19;
  while (1)
  {
    v40 = *(_QWORD *)(v38 - 3);
    if ((v40 & 0x4000000000000000) != 0)
      goto LABEL_56;
    v41 = *v38;
    if (!(_DWORD)v41)
      goto LABEL_56;
    if ((v40 & 0x7FFFFFFFFFFFFFFLL) == 0 && v37 != 0)
      goto LABEL_56;
    v43 = v40 > -1 || v59 == 0;
    v44 = v43 ? 18 : 524306;
    v45 = (dyld3::MachOFile *)dyld4::SyscallDelegate::mmap(a2[1], (void *)(address + (v40 & 0x7FFFFFFFFFFFFFFLL)), v41, ((unint64_t)v40 >> 59) & 7, v44, (int)v18, v19 + *(v38 - 1));
    v46 = __error();
    if (v45 == (dyld3::MachOFile *)-1)
      break;
    if (!v37 && !dyld3::MachOFile::isMachO(v45, a1, *v38))
      goto LABEL_60;
    if (*((_BYTE *)a2[1] + 201))
    {
      v47 = v13;
      v48 = (vm_size_t)v45 + ((vm_page_size + *v38 - 1) & -(uint64_t)vm_page_size);
      v49 = (const char *)dyld3::MachOLoaded::segmentName((dyld3::MachOLoaded *)address, v37);
      v50 = *(_QWORD *)(v38 - 3) >> 59;
      v57 = v48;
      v13 = v47;
      v19 = v58;
      v51 = 120;
      if ((v50 & 4) == 0)
        v51 = 46;
      v52 = 119;
      if ((v50 & 2) == 0)
        v52 = 46;
      v53 = 114;
      if ((*(_QWORD *)(v38 - 3) & 0x800000000000000) == 0)
        v53 = 46;
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "%14s (%c%c%c) 0x%012lX->0x%012lX\n", v49, v53, v52, v51, v45, v57);
    }
    ++v37;
LABEL_56:
    v38 += 4;
    v39 -= 16;
    if (!v39)
      goto LABEL_57;
  }
  if (*v46 == 1)
  {
    if (dyld4::SyscallDelegate::sandboxBlockedMmap(a2[1], (const char *)a3))
      Diagnostics::error(a1, "file system sandbox blocked mmap() of '%s'");
    else
      Diagnostics::error(a1, "code signing blocked mmap() of '%s'");
  }
  else
  {
    Diagnostics::error(a1, "mmap(addr=0x%0llX, size=0x%08X) failed with errno=%d for %s");
  }
LABEL_60:
  vm_deallocate(mach_task_self_, address, v13);
LABEL_22:
  dyld4::SyscallDelegate::close(a2[1], (int)v18);
LABEL_23:
  v34 = 0;
LABEL_24:
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v60);
  return v34;
}

void *__mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  char v6;
  void *result;

  result = mac_syscall(SYS_mmap, a1, a2, a3, a4, a5, a6);
  if (v6)
    return (void *)cerror_nocancel((int)result);
  return result;
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  if ((a4 & 2) != 0)
  {
    if (a2)
      return __mmap(a1, a2, a3, a4 | 0x40000u, a5, a6);
  }
  else if (a2 && (a4 & 1) != 0)
  {
    return __mmap(a1, a2, a3, a4 | 0x40000u, a5, a6);
  }
  cerror_nocancel(22);
  return (void *)-1;
}

void *dyld4::SyscallDelegate::mmap(dyld4::SyscallDelegate *this, void *a2, size_t a3, int a4, int a5, int a6, off_t a7)
{
  return mmap(a2, a3, a4, a5, a6, a7);
}

BOOL dyld3::MachOFile::isMachO(dyld3::MachOFile *this, vm_address_t *a2, unint64_t a3)
{
  int v4;
  BOOL v5;
  uint64_t v6;

  if (a3 <= 0x1B)
  {
    Diagnostics::error(a2, "MachO header exceeds file length");
    return 0;
  }
  v4 = *(_DWORD *)this;
  if (*(_DWORD *)this >> 1 != 2138504551)
  {
    if ((v4 & 0xFEFFFFFF) != 0xCEFAEDFE)
      Diagnostics::error(a2, "file does not start with MH_MAGIC[_64]");
    return 0;
  }
  v5 = v4 == -17958193;
  v6 = 28;
  if (v5)
    v6 = 32;
  if (v6 + (unint64_t)*((unsigned int *)this + 5) > a3)
  {
    Diagnostics::error(a2, "load commands exceed length of first segment");
    return 0;
  }
  dyld3::MachOFile::forEachLoadCommand(this, a2, (uint64_t)&__block_literal_global_2);
  return Diagnostics::noError((Diagnostics *)a2);
}

uint64_t dyld4::SyscallDelegate::fcntl(dyld4::SyscallDelegate *this, int a2, int a3, void *a4)
{
  return fcntl(a2, a3, a4);
}

int fcntl(int a1, int a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v9;
  va_list va;

  va_start(va, a2);
  v9 = va_arg(va, void *);
  switch(a2)
  {
    case '*':
    case '+':
    case ',':
    case '1':
    case '2':
    case '4':
    case '8':
    case '9':
    case ';':
    case '=':
    case 'A':
    case 'B':
    case 'G':
    case 'H':
    case 'K':
    case 'N':
    case 'S':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '^':
    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'l':
    case 'o':
    case 'q':
      goto LABEL_2;
    case '-':
    case '.':
    case '/':
    case '0':
    case '3':
    case '5':
    case '6':
    case '7':
    case ':':
    case '<':
    case '>':
    case '?':
    case '@':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'I':
    case 'J':
    case 'L':
    case 'M':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case '_':
    case 'j':
    case 'k':
    case 'm':
    case 'n':
    case 'p':
      goto LABEL_5;
    default:
      if ((a2 - 7) < 4)
LABEL_2:
        v7 = v9;
      else
LABEL_5:
        v7 = (void *)(int)v9;
      return __fcntl(a1, *(void **)&a2, v7, v2, v3, v4, v5, v6);
  }
}

int __fcntl(int a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t v9;

  LODWORD(v9) = mac_syscall(SYS_fcntl, a1, (int)a2, a3);
  if (v8)
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  return v9;
}

uint64_t dyld4::SyscallDelegate::close(dyld4::SyscallDelegate *this, int a2)
{
  return close(a2);
}

uint64_t dyld4::SyscallDelegate::open(dyld4::SyscallDelegate *this, dyld3 *a2, const char *a3, uint64_t a4)
{
  return dyld3::open(a2, a3, a4);
}

uint64_t dyld3::MachOFile::isFairPlayEncrypted(dyld3::MachOFile *this, unsigned int *a2, unsigned int *a3)
{
  _DWORD *FairPlayEncryptionLoadCommand;
  unsigned int v6;
  uint64_t result;

  FairPlayEncryptionLoadCommand = (_DWORD *)dyld3::MachOFile::findFairPlayEncryptionLoadCommand(this);
  if (FairPlayEncryptionLoadCommand && FairPlayEncryptionLoadCommand[4] == 1)
  {
    *a2 = FairPlayEncryptionLoadCommand[2];
    v6 = FairPlayEncryptionLoadCommand[3];
    result = 1;
  }
  else
  {
    v6 = 0;
    result = 0;
    *a2 = 0;
  }
  *a3 = v6;
  return result;
}

uint64_t dyld3::MachOFile::findFairPlayEncryptionLoadCommand(dyld3::MachOFile *this)
{
  uint64_t v2;
  _QWORD v4[5];
  vm_address_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile33findFairPlayEncryptionLoadCommandEv_block_invoke;
  v4[3] = &unk_1E4F7EB38;
  v4[4] = &v6;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v5, (uint64_t)v4);
  v2 = 0;
  if (Diagnostics::noError((Diagnostics *)&v5))
    v2 = v7[3];
  mach_o::Error::~Error(&v5);
  _Block_object_dispose(&v6, 8);
  return v2;
}

BOOL dyld4::SyscallDelegate::realpath(dyld4::SyscallDelegate *this, dyld3 *a2, char *a3)
{
  const char *v4;
  int v5;
  int v6;
  _BOOL8 v7;
  char *v8;
  int v9;
  int v10;
  int v11;
  char __dst[1024];

  v4 = (const char *)a2;
  v5 = dyld3::open(a2, 0, 0);
  if (v5 == -1)
  {
    strlcpy(__dst, v4, 0x400uLL);
    v8 = strrchr(__dst, 47);
    if (v8)
    {
      *v8 = 0;
      v4 += v8 - __dst + 1;
    }
    else
    {
      strcpy(__dst, ".");
    }
    v9 = dyld3::open((dyld3 *)__dst, (const char *)0x100000, 0);
    if (v9 == -1)
      return 0;
    v10 = v9;
    v11 = fcntl(v9, 50, a3);
    close(v10);
    if (v11)
    {
      return 0;
    }
    else
    {
      strlcat(a3, "/", 0x400uLL);
      strlcat(a3, v4, 0x400uLL);
      return 1;
    }
  }
  else
  {
    v6 = v5;
    v7 = fcntl(v5, 50, a3) == 0;
    close(v6);
  }
  return v7;
}

uint64_t dyld3::open(dyld3 *this, const char *a2, uint64_t a3)
{
  int v4;
  uint64_t v6;
  uint64_t v7;

  v4 = (int)a2;
  do
  {
    if ((v4 & 0x200) != 0)
      v6 = open((const char *)this, v4, a3);
    else
      v6 = open_with_subsystem((const char *)this, v4);
    v7 = v6;
  }
  while ((_DWORD)v6 == -1 && (*__error() == 35 || *__error() == 4));
  return v7;
}

uint64_t open_with_subsystem(const char *a1, int a2)
{
  uint64_t v4;
  int *v5;
  char *v6;
  char *next_subsystem_root_path;
  char __dst[1024];

  if ((a2 & 0x200) != 0)
  {
    *__error() = 22;
    return 0xFFFFFFFFLL;
  }
  else
  {
    v4 = open(a1, a2);
    if ((v4 & 0x80000000) != 0)
    {
      v5 = __error();
      v6 = (char *)subsystem_root_path;
      if (*v5 == 2 && subsystem_root_path != 0)
      {
        while (1)
        {
          next_subsystem_root_path = extract_next_subsystem_root_path(__dst, v6);
          if (strlcat(__dst, a1, 0x400uLL) > 0x3FF)
            break;
          v4 = open(__dst, a2);
          if ((v4 & 0x80000000) == 0)
            return v4;
          __error();
          if (!next_subsystem_root_path)
            return v4;
          v6 = next_subsystem_root_path;
        }
        *__error() = 63;
      }
    }
  }
  return v4;
}

int open(const char *a1, int a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  unsigned __int16 v7;
  uint64_t v9;
  va_list va;

  va_start(va, a2);
  v9 = va_arg(va, _QWORD);
  if ((a2 & 0x200) != 0)
    v7 = v9;
  else
    v7 = 0;
  return __open(a1, *(void **)&a2, (void *)v7, v2, v3, v4, v5, v6);
}

int __open(const char *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t v9;

  LODWORD(v9) = mac_syscall(SYS_open, a1, (int)a2, a3);
  if (v8)
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  return v9;
}

uint64_t cerror(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  int v8;

  v8 = a1;
  _pthread_exit_if_canceled(a1, a2, a3, a4, a5, a6, a7, a8);
  cerror_nocancel(v8);
  return -1;
}

uint64_t _pthread_exit_if_canceled(uint64_t result, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  int v8;
  uint64_t v9;
  unint64_t StatusReg;
  unint64_t v11;
  uint64_t v12;

  if (result == 4)
  {
    v8 = result;
    result = __pthread_canceled(0, a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v12 = *(_QWORD *)(StatusReg - 224);
      v11 = StatusReg - 224;
      if ((_pthread_ptr_munge_token ^ v12) == v11)
      {
        *(_DWORD *)(v11 + 168) = v8;
        *(_BYTE *)(v11 + 165) = 1;
        pthread_exit((void *)1);
      }
      _pthread_exit_if_canceled_cold_1(result, v9);
    }
  }
  return result;
}

uint64_t dyld3::GradedArchs::grade(dyld3::GradedArchs *this, int a2, int a3, char a4)
{
  uint64_t v4;
  int v5;

  v4 = 0;
  while (1)
  {
    v5 = *(_DWORD *)((char *)this + v4);
    if (!v5)
      return 0;
    if (v5 == a2
      && *(_DWORD *)((char *)this + v4 + 4) == (a3 & 0xFFFFFF)
      && (!*((_BYTE *)this + v4 + 8) || (a4 & 1) != 0))
    {
      break;
    }
    v4 += 12;
    if (v4 == 48)
      return 0;
  }
  return *(unsigned __int16 *)((char *)this + v4 + 10);
}

unint64_t dyld3::MachOFile::mappedSize(dyld3::MachOFile *this)
{
  BOOL v2;
  unint64_t v3;

  v3 = 0;
  dyld3::MachOFile::analyzeSegmentsLayout(this, &v3, &v2);
  return v3;
}

void dyld3::MachOFile::analyzeSegmentsLayout(dyld3::MachOFile *this, unint64_t *a2, BOOL *a3)
{
  int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  BOOL v10;
  BOOL v11;
  _QWORD v12[8];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  char v28;

  v25 = 0;
  v26 = &v25;
  v27 = 0x2000000000;
  v28 = 0;
  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = -1;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = ___ZNK5dyld39MachOFile21analyzeSegmentsLayoutERyRb_block_invoke;
  v12[3] = &unk_1E4F7ED88;
  v12[4] = &v25;
  v12[5] = &v21;
  v12[6] = &v17;
  v12[7] = &v13;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v12);
  v6 = *((_DWORD *)this + 1);
  if (v6 == 33554444 || v6 == 16777228 || v6 == 12 && *((_DWORD *)this + 3) != 11 && *((_DWORD *)this + 2) == 12)
    v7 = 0x3FFFLL;
  else
    v7 = 4095;
  v8 = (v18[3] - v22[3] + v7) & ~v7;
  v9 = v14[3];
  *a2 = v8;
  if (*((_BYTE *)v26 + 24))
    v10 = 0;
  else
    v10 = v8 == v9;
  v11 = !v10;
  *a3 = v11;
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
}

BOOL dyld3::MachOAnalyzer::neverUnload(dyld3::MachOAnalyzer *this)
{
  _BOOL8 v2;
  _QWORD v4[5];
  vm_address_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;
  BOOL v10;

  v10 = 0;
  if (dyld3::MachOAnalyzer::hasSwiftOrObjC(this, &v10) && (v10 || !dyld3::MachOFile::isBundle(this))
    || (dyld3::MachOFile::hasThreadLocalVariables(this) & 1) != 0)
  {
    return 1;
  }
  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld313MachOAnalyzer11neverUnloadEv_block_invoke;
  v4[3] = &unk_1E4F7F4E8;
  v4[4] = &v6;
  dyld3::MachOFile::forEachDOFSection(this, (uint64_t)&v5, (uint64_t)v4);
  v2 = Diagnostics::noError((Diagnostics *)&v5) && *((_BYTE *)v7 + 24);
  mach_o::Error::~Error(&v5);
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t dyld3::MachOAnalyzer::hasSwiftOrObjC(dyld3::MachOAnalyzer *this, BOOL *a2)
{
  uint64_t v3;
  _QWORD v5[8];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;

  if (a2)
    *a2 = 0;
  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld313MachOAnalyzer14hasSwiftOrObjCEPb_block_invoke;
  v5[3] = &unk_1E4F7F4C0;
  v5[6] = a2;
  v5[7] = dyld3::MachOLoaded::getSlide(this);
  v5[4] = &v6;
  v5[5] = this;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v5);
  v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void dyld3::MachOFile::forEachDOFSection(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD v3[5];

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile17forEachDOFSectionER11DiagnosticsU13block_pointerFvjE_block_invoke;
  v3[3] = &unk_1E4F7EDD8;
  v3[4] = a3;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v3);
}

size_t dyld4::Loader::validateFile(vm_address_t *a1, uint64_t a2, int a3, const char *a4, unsigned int *a5, uint64_t a6)
{
  int v12;
  size_t v13;
  dyld3::FatFile *v14;
  dyld3::FatFile *v15;
  int *v16;
  int *v17;
  unint64_t v18;
  _DWORD *v19;
  _QWORD v21[6];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  char v25;
  unint64_t v26;
  stat v27;

  if (dyld4::SyscallDelegate::fstat(*(dyld4::SyscallDelegate **)(a2 + 8), a3, &v27))
  {
    v12 = *__error();
    if (v12 == 2)
    {
      Diagnostics::error(a1, "no such file");
    }
    else if (v12 == 1 && dyld4::SyscallDelegate::sandboxBlockedStat(*(dyld4::SyscallDelegate **)(a2 + 8), a4))
    {
      Diagnostics::error(a1, "file system sandbox blocked stat(\"%s\")");
    }
    else
    {
      Diagnostics::error(a1, "stat(\"%s\") failed with errno=%d");
    }
    return -1;
  }
  if (*(_BYTE *)(a6 + 52))
  {
    if (v27.st_ino != *(_QWORD *)(a6 + 16))
    {
      Diagnostics::error(a1, "file inode changed from 0x%llX to 0x%llX since Loader was built for '%s'");
      return -1;
    }
    if (v27.st_mtimespec.tv_sec != *(_QWORD *)(a6 + 24))
    {
      Diagnostics::error(a1, "file mtime changed from 0x%llX to 0x%lX since Loader was built for '%s'");
      return -1;
    }
    v13 = *(_QWORD *)a6;
    if (v27.st_size < *(_QWORD *)a6)
    {
      Diagnostics::error(a1, "file too small for slice offset '%s'");
      return -1;
    }
  }
  else
  {
    if (!a5[1])
      return -1;
    v14 = (dyld3::FatFile *)dyld4::SyscallDelegate::mmap(*(dyld4::SyscallDelegate **)(a2 + 8), 0, v27.st_size, 1, 2, a3, 0);
    if (v14 == (dyld3::FatFile *)-1)
    {
      Diagnostics::error(a1, "could not mmap() '%s'");
      return -1;
    }
    v15 = v14;
    v26 = 0;
    v16 = dyld3::MachOFile::compatibleSlice(a1, &v26, v14, v27.st_size, a4, *(_DWORD *)(*(_QWORD *)(a2 + 8) + 68), 0, *(dyld3::GradedArchs **)(*(_QWORD *)(a2 + 8) + 144), *(_BYTE *)(*(_QWORD *)(a2 + 8) + 169));
    if (v16)
    {
      v17 = v16;
      v22 = 0;
      v23 = &v22;
      v24 = 0x2000000000;
      v25 = 0;
      v18 = a5[1];
      v19 = (int *)((char *)v16 + *a5);
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 0x40000000;
      v21[2] = ___ZN5dyld46Loader12validateFileER11DiagnosticsRKNS_12RuntimeStateEiPKcRKNS0_19CodeSignatureInFileERKNS0_18FileValidationInfoE_block_invoke;
      v21[3] = &unk_1E4F7CDE8;
      v21[4] = &v22;
      v21[5] = a6;
      dyld3::MachOFile::forEachCDHashOfCodeSignature((uint64_t)v16, v19, v18, (uint64_t)v21);
      if (*((_BYTE *)v23 + 24))
      {
        v13 = (char *)v17 - (char *)v15;
      }
      else
      {
        Diagnostics::error(a1, "file cdHash not as expected '%s'", a4);
        v13 = -1;
      }
      _Block_object_dispose(&v22, 8);
    }
    else
    {
      v13 = -1;
    }
    dyld4::SyscallDelegate::unmapFile(*(dyld4::SyscallDelegate **)(a2 + 8), v15, *(_QWORD *)a6);
  }
  return v13;
}

int fstat64(int a1, stat *a2)
{
  char v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  int64_t v9;

  v9 = mac_syscall(SYS_fstat64, *(void **)&a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2)
    LODWORD(v9) = cerror_nocancel(v9);
  return v9;
}

uint64_t dyld4::SyscallDelegate::fstat(dyld4::SyscallDelegate *this, int a2, stat *a3)
{
  return fstat64(a2, a3);
}

void dyld4::APIs::forEachPlatform(uint64_t a1, const dyld3::MachOFile *a2, uint64_t a3)
{
  dyld4::APIs *v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int v8;
  uint64_t v9;
  _QWORD v10[8];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___ZN5dyld44APIs15forEachPlatformEPKN5dyld39MachOFileEU13block_pointerFvjjjE_block_invoke;
  v10[3] = &unk_1E4F7DA18;
  v10[6] = a1;
  v10[7] = a2;
  v10[4] = a3;
  v10[5] = &v11;
  dyld3::MachOFile::forEachSupportedPlatform(a2, (uint64_t)v10);
  if (!*((_BYTE *)v12 + 24))
  {
    v6 = dyld4::APIs::linkedDylibVersion(v5, a2, "/System/Library/Frameworks/Foundation.framework/Foundation");
    if (v6 >= 0x2A61800)
    {
      v7 = (unsigned int *)&unk_1A5CBBF24;
      do
      {
        v8 = v7[3];
        if (!v8)
        {
          v9 = 458752;
          goto LABEL_9;
        }
        v7 += 2;
      }
      while (v6 >= v8);
      v9 = *v7;
      if (!(_DWORD)v9)
        goto LABEL_10;
LABEL_9:
      (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a3 + 16))(a3, 2, v9, 0);
    }
  }
LABEL_10:
  _Block_object_dispose(&v11, 8);
}

BOOL dyld3::MachOFile::isBundle(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 8;
}

BOOL dyld3::MachOAnalyzer::isOSBinary(dyld3::MachOAnalyzer *this, int a2, uint64_t a3)
{
  _BOOL4 hasCodeSignature;
  _BOOL8 result;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10[2];
  _QWORD v11[7];

  if (a2 == -1)
    return 0;
  *(_QWORD *)v10 = 0;
  hasCodeSignature = dyld3::MachOFile::hasCodeSignature(this, &v10[1], v10);
  result = 0;
  if (!hasCodeSignature)
    return result;
  v11[0] = a3;
  v11[1] = v10[1];
  v11[2] = v10[0];
  if (fcntl(a2, 97, v11) == -1)
    return 0;
  v9 = 1;
  v8 = a3;
  return fcntl(a2, 105, &v8) != -1 && HIDWORD(v9) != 0;
}

void dyld4::FileManager::reloadFSInfos(dyld4::FileManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  size_t v11;
  lsl::AllocatorLayout *v12;
  char *v13;
  const char **v14;
  const char **v15;
  lsl::Allocator *v16;
  int v17;
  uint64_t v18;
  statfs *v19;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t v36;
  _OWORD *v37;
  uint64_t *v38;
  uint64_t *v39;
  _BYTE *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  _BYTE v53[15];
  char v54;
  uint64_t v55;
  __int128 v56;
  __int128 v57;
  _OWORD v58[5];
  uint64_t v59;
  _BYTE v60[16];
  _BYTE v61[32];
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  _BYTE v67[24];

  v2 = lsl::AllocatorLayout::minSize(this);
  __chkstk_darwin(v2, v2, v3, v4, v5, v6, v7, v8, v36);
  v10 = (char *)&v36 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v10, v11);
  v13 = (char *)lsl::AllocatorLayout::minSize(v12);
  v16 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v10, v13, v14, v15);
  v17 = dyld4::SyscallDelegate::getfsstat(*(dyld4::SyscallDelegate **)this, 0, 0, 2);
  if (v17 != -1)
  {
    LODWORD(v18) = v17;
    while (1)
    {
      v19 = (statfs *)lsl::Allocator::malloc(v16, 2168 * (int)v18);
      if (dyld4::SyscallDelegate::getfsstat(*(dyld4::SyscallDelegate **)this, v19, 2168 * (int)v18, 2) == (_DWORD)v18)
        break;
      lsl::Allocator::free(v16, v19);
      LODWORD(v18) = dyld4::SyscallDelegate::getfsstat(*(dyld4::SyscallDelegate **)this, 0, 0, 2);
      if ((_DWORD)v18 == -1)
        goto LABEL_20;
    }
    if ((int)v18 >= 1)
    {
      v41 = &v61[8];
      v39 = (uint64_t *)&v67[8];
      v40 = v60;
      v37 = (_OWORD *)((char *)v58 + 8);
      v38 = &v43;
      _X22 = v19;
      v18 = v18;
      do
      {
        __asm { PRFM            #0, [X22,#0x1998] }
        v26 = _X22->f_fsid.val[0];
        v27 = *((_QWORD *)this + 2);
        v28 = v41;
        *v41 = 0;
        v28[1] = 0;
        *(_QWORD *)v61 = v26;
        lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find(v27, (unint64_t *)v61, (uint64_t)&v44);
        v55 = v44;
        v58[2] = v49;
        v58[3] = v50;
        v58[4] = v51;
        v59 = v52;
        v56 = v45;
        v57 = v46;
        v58[0] = v47;
        v58[1] = v48;
        v29 = *(_QWORD *)v53;
        v30 = v40;
        *(_QWORD *)(v40 + 7) = *(_QWORD *)&v53[7];
        *v30 = v29;
        v60[15] = v54;
        v31 = *((_QWORD *)this + 2);
        v66 = 0u;
        memset(v67, 0, 23);
        v64 = 0u;
        v65 = 0u;
        v62 = 0u;
        v63 = 0u;
        memset(v61, 0, sizeof(v61));
        v44 = v31;
        v45 = 0u;
        v46 = 0u;
        v47 = 0u;
        v48 = 0u;
        v49 = 0u;
        v50 = 0u;
        v51 = 0u;
        v52 = 0;
        v32 = *v39;
        *(_QWORD *)&v53[7] = *(uint64_t *)((char *)v39 + 7);
        *(_QWORD *)v53 = v32;
        v54 = 0;
        if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v55, (uint64_t)&v44))
        {
          if ((_X22->f_flags & 0x4000) != 0)
          {
            *(_DWORD *)v61 = 5;
            *(_DWORD *)&v61[12] = 0;
            *(_QWORD *)&v61[16] = 0;
            *(_QWORD *)&v61[4] = 0x8006000000000006;
            if (!dyld4::SyscallDelegate::getattrlist(*(dyld4::SyscallDelegate **)this, _X22->f_mntonname, (attrlist *)v61, &v55, 0x40uLL, 0)&& (BYTE8(v56) & 1) != 0)
            {
              v33 = *((_QWORD *)this + 2);
              v42 = v26;
              *(_OWORD *)v38 = *v37;
            }
            else
            {
              v33 = *((_QWORD *)this + 2);
              v35 = v38;
              *v38 = 0;
              v35[1] = 0;
              v42 = v26;
            }
            v34 = &v42;
          }
          else
          {
            v33 = *((_QWORD *)this + 2);
            v56 = 0uLL;
            v55 = v26;
            v34 = &v55;
          }
          lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::insert(v33, (uint64_t)v34, (uint64_t)&v44);
        }
        ++_X22;
        --v18;
      }
      while (v18);
    }
    lsl::Allocator::free(v16, v19);
  }
LABEL_20:
  lsl::Allocator::~Allocator(v16);
}

double lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find@<D0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned __int8 v6;
  double result;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v24[2];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  _BYTE v31[15];
  unsigned __int8 v32;

  lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::const_iterator((uint64_t)&v23, a1, a2);
  v13 = a1;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0;
  if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v23, (uint64_t)&v13)&& (v6 = v32, *a2 >= *(_QWORD *)(*((_QWORD *)v24 + v32 - 1) + 24 * v31[v32 - 1])))
  {
    v8 = v28;
    *(_OWORD *)(a3 + 72) = v27;
    *(_OWORD *)(a3 + 88) = v8;
    *(_OWORD *)(a3 + 104) = v29;
    v9 = v24[1];
    *(_OWORD *)(a3 + 8) = v24[0];
    *(_OWORD *)(a3 + 24) = v9;
    result = *(double *)&v25;
    v10 = v26;
    *(_OWORD *)(a3 + 40) = v25;
    *(_QWORD *)a3 = v23;
    v11 = v30;
    *(_OWORD *)(a3 + 56) = v10;
    *(_QWORD *)(a3 + 135) = *(_QWORD *)&v31[7];
    v12 = *(_QWORD *)v31;
    *(_QWORD *)(a3 + 120) = v11;
    *(_QWORD *)(a3 + 128) = v12;
    *(_BYTE *)(a3 + 143) = v6;
  }
  else
  {
    *(_QWORD *)a3 = a1;
    result = 0.0;
    *(_OWORD *)(a3 + 8) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
    *(_OWORD *)(a3 + 40) = 0u;
    *(_OWORD *)(a3 + 56) = 0u;
    *(_OWORD *)(a3 + 72) = 0u;
    *(_OWORD *)(a3 + 88) = 0u;
    *(_OWORD *)(a3 + 104) = 0u;
    *(_OWORD *)(a3 + 120) = 0u;
    *(_QWORD *)(a3 + 136) = 0;
  }
  return result;
}

uint64_t lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::const_iterator(uint64_t result, uint64_t a2, unint64_t *a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;

  *(_QWORD *)result = a2;
  *(_OWORD *)(result + 8) = 0u;
  v3 = result + 8;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  *(_OWORD *)(result + 104) = 0u;
  *(_OWORD *)(result + 120) = 0u;
  *(_QWORD *)(result + 136) = 0;
  if (*(_BYTE *)(a2 + 32))
  {
    v4 = 0;
    v5 = *(_QWORD *)a2;
    v6 = result + 128;
    do
    {
      *(_QWORD *)(v3 + 8 * v4) = v5;
      v7 = *(_BYTE *)(v5 + 240) & 0x7F;
      if ((*(_BYTE *)(v5 + 240) & 0x7F) != 0)
      {
        v8 = (_QWORD *)v5;
        do
        {
          v9 = v7 >> 1;
          v10 = &v8[3 * (v7 >> 1)];
          v12 = *v10;
          v11 = v10 + 3;
          v7 += ~(v7 >> 1);
          if (v12 < *a3)
            v8 = v11;
          else
            v7 = v9;
        }
        while (v7);
      }
      else
      {
        v8 = (_QWORD *)(v5 + 24 * (*(_BYTE *)(v5 + 240) & 0x7F));
      }
      v13 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v8 - v5) >> 3);
      *(_BYTE *)(v6 + v4) = v13;
      v14 = *(_QWORD *)(v3 + 8 * v4);
      if ((*(_BYTE *)(v14 + 240) & 0x7F) != v13
        && *(_QWORD *)(v14 + 24 * v13) < *a3)
      {
        *(_BYTE *)(result + 143) = v4 + 1;
        return result;
      }
      v15 = *(unsigned __int8 *)(a2 + 32);
      if ((_DWORD)v4 + 1 != (_DWORD)v15)
      {
        if ((*(_BYTE *)(v14 + 240) & 0x80) != 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, (uint64_t)a3);
        v5 = *(_QWORD *)(v14 + 8 * v13 + 168);
      }
      ++v4;
    }
    while (v4 < v15);
    for (*(_BYTE *)(result + 143) = v15; (_BYTE)v15; *(_BYTE *)(result + 143) = v15)
    {
      if (*(_BYTE *)(v6 + v15 - 1) != (*(_BYTE *)(*(_QWORD *)(result
                                                                                            + 8 * v15)
                                                                                + 240) & 0x7F))
        break;
      LOBYTE(v15) = v15 - 1;
    }
  }
  return result;
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::insert_internal(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  char v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  if (*(_QWORD *)a1)
  {
    v26 = a1;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    v34 = 0u;
    v35 = 0;
    if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>(a2, (uint64_t)&v26))
    {
      v8 = *(unsigned __int8 *)(a2 + 143);
      if (*a3 >= *(_QWORD *)(*(_QWORD *)(a2 + 8 + 8 * (v8 - 1)) + 24 * *(unsigned __int8 *)(a2 + 128 + v8 - 1)))
      {
        v15 = 0;
        v21 = *(_OWORD *)(a2 + 88);
        *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
        *(_OWORD *)(a4 + 88) = v21;
        *(_OWORD *)(a4 + 104) = *(_OWORD *)(a2 + 104);
        v22 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
        *(_OWORD *)(a4 + 24) = v22;
        v23 = *(_OWORD *)(a2 + 56);
        *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
        *(_QWORD *)a4 = *(_QWORD *)a2;
        *(_QWORD *)(a4 + 135) = *(_QWORD *)(a2 + 135);
        v24 = *(_QWORD *)(a2 + 120);
        *(_OWORD *)(a4 + 56) = v23;
        v25 = *(_QWORD *)(a2 + 128);
        *(_QWORD *)(a4 + 120) = v24;
        *(_QWORD *)(a4 + 128) = v25;
        *(_BYTE *)(a4 + 143) = v8;
        goto LABEL_11;
      }
    }
    v26 = a1;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    v34 = 0u;
    v35 = 0;
    if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>(a2, (uint64_t)&v26)&& *(unsigned __int8 *)(a2 + 143) == *(unsigned __int8 *)(a1 + 32))
    {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
      v11 = (uint64_t *)(a2 + 128);
      v12 = *(unsigned __int8 *)(a2 + 143) - 1;
      v13 = *(_BYTE *)(a2 + 128 + v12);
    }
    else
    {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator--(a2, v9, v10);
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
      v11 = (uint64_t *)(a2 + 128);
      v18 = *(unsigned __int8 *)(a2 + 143) + a2 + 128;
      v13 = *(_BYTE *)(v18 - 1) + 1;
      *(_BYTE *)(v18 - 1) = v13;
      v12 = *(unsigned __int8 *)(a2 + 143) - 1;
    }
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert(*(_QWORD *)(a2 + 8 + 8 * v12), v13, (uint64_t)a3);
    ++*(_QWORD *)(a1 + 24);
    *(_QWORD *)a4 = *(_QWORD *)a2;
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 104) = *(_OWORD *)(a2 + 104);
    v19 = *(_QWORD *)(a2 + 120);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    v20 = *v11;
    *(_QWORD *)(a4 + 135) = *(uint64_t *)((char *)v11 + 7);
    *(_QWORD *)(a4 + 120) = v19;
    *(_QWORD *)(a4 + 128) = v20;
    v17 = *(_BYTE *)(a2 + 143);
    v15 = 1;
  }
  else
  {
    v14 = lsl::Allocator::aligned_alloc(*(lsl::Allocator **)(a1 + 8), 0x100uLL, 0x100uLL);
    *((_BYTE *)v14 + 240) = 0x80;
    *(_OWORD *)v14 = 0u;
    *((_OWORD *)v14 + 1) = 0u;
    *((_OWORD *)v14 + 2) = 0u;
    *((_OWORD *)v14 + 3) = 0u;
    *((_OWORD *)v14 + 4) = 0u;
    *((_OWORD *)v14 + 5) = 0u;
    *((_OWORD *)v14 + 6) = 0u;
    *((_OWORD *)v14 + 7) = 0u;
    *((_OWORD *)v14 + 8) = 0u;
    *((_OWORD *)v14 + 9) = 0u;
    *((_OWORD *)v14 + 10) = 0u;
    *((_OWORD *)v14 + 11) = 0u;
    *((_OWORD *)v14 + 12) = 0u;
    *((_OWORD *)v14 + 13) = 0u;
    *((_OWORD *)v14 + 14) = 0u;
    *(_QWORD *)a1 = v14;
    v15 = 1;
    *(_BYTE *)(a1 + 32) = 1;
    *(_QWORD *)(a2 + 8) = v14;
    *(_BYTE *)(a2 + 143) = 1;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert((uint64_t)v14, 0, (uint64_t)a3);
    ++*(_QWORD *)(a1 + 24);
    *(_QWORD *)a4 = *(_QWORD *)a2;
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 104) = *(_OWORD *)(a2 + 104);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_QWORD *)(a4 + 135) = *(_QWORD *)(a2 + 135);
    v16 = *(_QWORD *)(a2 + 128);
    *(_QWORD *)(a4 + 120) = *(_QWORD *)(a2 + 120);
    *(_QWORD *)(a4 + 128) = v16;
    v17 = *(_BYTE *)(a2 + 143);
  }
  *(_BYTE *)(a4 + 143) = v17;
LABEL_11:
  *(_BYTE *)(a4 + 144) = v15;
}

uint64_t lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  BOOL v11;
  unsigned int v12;

  v2 = *(unsigned __int8 *)(a2 + 143);
  v3 = *(unsigned __int8 *)(a1 + 143);
  if (v2 >= v3)
    v4 = *(unsigned __int8 *)(a1 + 143);
  else
    v4 = *(unsigned __int8 *)(a2 + 143);
  if ((_DWORD)v4)
  {
    v5 = (unsigned __int8 *)(a1 + 128);
    v6 = (unsigned __int8 *)(a2 + 128);
    while (1)
    {
      v8 = *v5++;
      v7 = v8;
      v9 = *v6++;
      v10 = v7 >= v9;
      if (v7 != v9)
        break;
      if (!--v4)
        goto LABEL_8;
    }
    if (v10)
      return 1;
    else
      return 0xFFFFFFFFLL;
  }
  else
  {
LABEL_8:
    v11 = v3 == v2;
    if (v3 < v2)
      v12 = -1;
    else
      v12 = 1;
    if (v11)
      return 0;
    else
      return v12;
  }
}

__n128 lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert(uint64_t a1, unsigned int a2, uint64_t a3)
{
  char v3;
  char v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 result;

  v3 = *(_BYTE *)(a1 + 240);
  v4 = v3;
  v5 = v3 & 0x7F;
  if (v3 >= 0)
    v6 = 7;
  else
    v6 = 10;
  if ((_DWORD)v5 == v6)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  if (v6 == a2)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  if ((_DWORD)v5 != a2)
  {
    v7 = 3 * v5;
    v8 = a1 + 8 * v7;
    v9 = 24 * a2 - 8 * v7;
    v10 = v8;
    do
    {
      v11 = *(_QWORD *)(v10 - 24);
      v10 -= 24;
      *(_QWORD *)v8 = v11;
      *(_OWORD *)(v8 + 8) = *(_OWORD *)(v8 - 16);
      v8 = v10;
      v9 += 24;
    }
    while (v9);
    v4 = *(_BYTE *)(a1 + 240);
  }
  *(_BYTE *)(a1 + 240) = v4 + 1;
  *(_QWORD *)(a1 + 24 * a2) = *(_QWORD *)a3;
  result = *(__n128 *)(a3 + 8);
  *(__n128 *)(a1 + 24 * a2 + 8) = result;
  return result;
}

double lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::insert@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  double result;
  uint64_t v7;
  __int16 v8;
  unint64_t v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  _BYTE v20[15];
  __int16 v21;
  _BYTE v22[144];

  v9 = *(_QWORD *)a2;
  v10 = *(_OWORD *)(a2 + 8);
  lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::const_iterator((uint64_t)v22, a1, &v9);
  lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::insert_internal(a1, (uint64_t)v22, &v9, (uint64_t)&v11);
  v5 = v11;
  *(_OWORD *)(a3 + 72) = v16;
  *(_OWORD *)(a3 + 88) = v17;
  *(_OWORD *)(a3 + 104) = v18;
  *(_OWORD *)(a3 + 8) = v12;
  *(_OWORD *)(a3 + 24) = v13;
  *(_OWORD *)(a3 + 40) = v14;
  result = *(double *)&v15;
  *(_OWORD *)(a3 + 56) = v15;
  *(_QWORD *)(a3 + 135) = *(_QWORD *)&v20[7];
  v7 = *(_QWORD *)v20;
  *(_QWORD *)(a3 + 120) = v19;
  *(_QWORD *)(a3 + 128) = v7;
  v8 = v21;
  *(_QWORD *)a3 = v5;
  *(_WORD *)(a3 + 143) = v8;
  return result;
}

unsigned __int8 *lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion(unsigned __int8 *result)
{
  uint64_t v1;
  unsigned __int8 *v2;
  _QWORD *v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t *v10;
  unsigned __int8 *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned __int8 v20;
  uint64_t v21;

  v1 = result[143];
  if ((_DWORD)v1 != *(unsigned __int8 *)(*(_QWORD *)result + 32))
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion();
  v2 = result;
  v3 = result + 8;
  if (*(char *)(*(_QWORD *)&result[8 * v1] + 240) >= 0)
    v4 = 7;
  else
    v4 = 10;
  if ((*(_BYTE *)(*(_QWORD *)&result[8 * v1] + 240) & 0x7F) == v4)
  {
    if (!result[143])
      goto LABEL_15;
    v5 = 0;
    v6 = 0;
    do
    {
      if (*(char *)(v3[v5] + 240) >= 0)
        v7 = 7;
      else
        v7 = 10;
      if ((*(_BYTE *)(v3[v5] + 240) & 0x7F) != v7)
        v6 = v5;
      ++v5;
    }
    while (v1 != v5);
    if (!v6)
    {
LABEL_15:
      if (*(char *)(*v3 + 240) >= 0)
        v8 = 7;
      else
        v8 = 10;
      if ((*(_BYTE *)(*v3 + 240) & 0x7F) == v8)
      {
        result = (unsigned __int8 *)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)(*(_QWORD *)result + 8), 0x100uLL, 0x100uLL);
        v9 = **(_QWORD **)v2;
        result[240] = 0;
        *(_OWORD *)result = 0u;
        *((_OWORD *)result + 1) = 0u;
        *((_OWORD *)result + 2) = 0u;
        *((_OWORD *)result + 3) = 0u;
        *((_OWORD *)result + 4) = 0u;
        *((_OWORD *)result + 5) = 0u;
        *((_OWORD *)result + 6) = 0u;
        *((_OWORD *)result + 7) = 0u;
        *((_OWORD *)result + 8) = 0u;
        *((_OWORD *)result + 9) = 0u;
        *((_QWORD *)result + 20) = 0;
        *((_QWORD *)result + 21) = v9;
        **(_QWORD **)v2 = result;
        if (v2[143] && (result = (unsigned __int8 *)memmove(v2 + 129, v2 + 128, v2[143]), v2[143]))
        {
          result = (unsigned __int8 *)memmove(v3 + 1, v3, 8 * v2[143]);
          LOBYTE(v1) = v2[143] + 1;
        }
        else
        {
          LOBYTE(v1) = 1;
        }
        v6 = 0;
        v2[128] = 0;
        v10 = *(uint64_t **)v2;
        *((_QWORD *)v2 + 1) = **(_QWORD **)v2;
        ++*((_BYTE *)v10 + 32);
        v2[143] = v1;
      }
      else
      {
        v6 = 0;
      }
    }
    if (v6 + 1 < v1)
    {
      v11 = v2 + 128;
      v12 = v6;
      do
      {
        v13 = v12;
        result = (unsigned __int8 *)lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild(v3[v12], v11[v12], *(lsl::Allocator **)(*(_QWORD *)v2 + 8));
        v16 = v3[v12];
        if (*(char *)(v16 + 240) < 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v14, v15);
        v17 = v11[v12];
        v18 = *(_QWORD *)(v16 + 8 * v17 + 168);
        v19 = v2[v12 + 129];
        if (v19 > (*(_BYTE *)(v18 + 240) & 0x7Fu))
        {
          v20 = v17 + 1;
          v11[v12] = v20;
          v2[v12 + 129] = v19 + (~*(_BYTE *)(v18 + 240) | 0x80);
          v21 = v3[v12];
          if (*(char *)(v21 + 240) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v14, v15);
          *(_QWORD *)&v2[8 * v12 + 16] = *(_QWORD *)(v21 + 8 * v20 + 168);
        }
        ++v12;
      }
      while (v13 + 2 < v2[143]);
    }
  }
  return result;
}

int getfsstat64(statfs *a1, int a2, int a3)
{
  char v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  int64_t v9;

  v9 = mac_syscall(SYS_getfsstat64, a1, *(void **)&a2, *(void **)&a3, v4, v5, v6, v7, v8);
  if (v3)
    LODWORD(v9) = cerror_nocancel(v9);
  return v9;
}

uint64_t dyld4::SyscallDelegate::getfsstat(dyld4::SyscallDelegate *this, statfs *a2, int a3, int a4)
{
  return getfsstat64(a2, a3, a4);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  char v5;
  int result;

  result = mac_syscall(SYS_getattrlist, a1, a2, a3, a4, a5);
  if (v5)
    return cerror_nocancel(result);
  return result;
}

uint64_t lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator--(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  char v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;

  v3 = *(unsigned __int8 *)(result + 143);
  v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 143))
  {
    if ((_DWORD)v3 == *((unsigned __int8 *)v4 + 32))
    {
      v5 = result + 128;
      v6 = v3 - 1;
      v7 = (char *)(result + 128 + v3 - 1);
      v8 = *v7;
      if (!*(_BYTE *)(result + 128 + (v3 - 1)))
      {
        if (!*v7)
        {
          do
          {
            LODWORD(v3) = v3 - 1;
            *(_BYTE *)(result + 143) = v3;
            v6 = v3 - 1;
            v8 = *(_BYTE *)(v5 + v6);
          }
          while (!v8);
        }
        v7 = (char *)(v5 + v6);
      }
    }
    else
    {
      v16 = result + 8;
      v17 = result + 128;
      do
      {
        v18 = *(_QWORD *)(v16 + 8 * (v3 - 1));
        if (*(char *)(v18 + 240) < 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
        v19 = *(_QWORD *)(v18 + 8 * *(unsigned __int8 *)(v17 + v3 - 1) + 168);
        *(_QWORD *)(v16 + 8 * v3) = v19;
        *(_BYTE *)(v17 + v3) = *(_BYTE *)(v19 + 240) & 0x7F;
        LOBYTE(v3) = *(_BYTE *)(result + 143) + 1;
        *(_BYTE *)(result + 143) = v3;
      }
      while (*((unsigned __int8 *)v4 + 32) != v3);
      v20 = v17 + v3;
      v21 = *(_BYTE *)(v20 - 1);
      v7 = (char *)(v20 - 1);
      v8 = v21;
    }
  }
  else
  {
    v9 = *v4;
    *(_BYTE *)(result + 143) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      v10 = 0;
      v11 = result + 8;
      do
      {
        *(_QWORD *)(v11 + 8 * v10) = v9;
        *(_BYTE *)(result + 128 + v10) = *(_BYTE *)(v9 + 240) & 0x7F;
        v12 = *(unsigned __int8 *)(result + 143);
        v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          v14 = *(_QWORD *)(v11 + 8 * v12);
          if (*(char *)(v14 + 240) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
          v9 = *(_QWORD *)(v14 + 8 * *(unsigned __int8 *)(v14 + 240) + 168);
        }
        v10 = v12 + 1;
        *(_BYTE *)(result + 143) = v10;
      }
      while (v13 > v10);
      v15 = v10 - 1;
    }
    else
    {
      v15 = -1;
    }
    v7 = (char *)(result + v15 + 128);
    v8 = *v7;
  }
  *v7 = v8 - 1;
  return result;
}

uint64_t dyld4::SyscallDelegate::getattrlist(dyld4::SyscallDelegate *this, const char *a2, attrlist *a3, void *a4, size_t a5, unsigned int a6)
{
  return getattrlist(a2, a3, a4, a5, a6);
}

char *lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild(uint64_t a1, uint64_t a2, lsl::Allocator *this)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  char v7;
  int v8;
  int v9;
  int v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *result;
  uint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  char v25;
  __int128 v26;
  unsigned __int8 v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  int v34;
  char v35;
  int v36;
  char v37;
  int v38;
  int v39;
  int v40;

  if (*(char *)(a1 + 240) < 0)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  v3 = *(unsigned __int8 *)(a1 + 240);
  if (v3 >= 7)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  v5 = a1 + 168;
  v6 = a1 + 168 + 8 * a2;
  v7 = *(_BYTE *)(*(_QWORD *)v6 + 240);
  v8 = v7;
  v9 = v7 & 0x7F;
  if (v7 >= 0)
    v10 = 7;
  else
    v10 = 10;
  if (v9 != v10)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  v12 = a2;
  if (v8 >= 0)
    v13 = 3;
  else
    v13 = 5;
  if ((_DWORD)v3 != (_DWORD)a2)
  {
    v14 = 3 * v3;
    v15 = a1 + 24 * v3;
    v16 = 24 * a2 - 8 * v14;
    v17 = v15;
    do
    {
      v18 = *(_QWORD *)(v17 - 24);
      v17 -= 24;
      *(_QWORD *)v15 = v18;
      *(_OWORD *)(v15 + 8) = *(_OWORD *)(v15 - 16);
      v15 = v17;
      v16 += 24;
    }
    while (v16);
    a2 = *(unsigned __int8 *)(a1 + 240);
  }
  if ((a2 & 0x80) != 0)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(a1, a2, (uint64_t)this);
  v19 = v5 + 8 * a2;
  if (v19 != v6)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), v19 - v6);
    LOBYTE(a2) = *(_BYTE *)(a1 + 240);
  }
  *(_BYTE *)(a1 + 240) = a2 + 1;
  v20 = *(_QWORD *)v6 + 24 * v13;
  *(_QWORD *)(a1 + 24 * v12) = *(_QWORD *)v20;
  *(_OWORD *)(a1 + 24 * v12 + 8) = *(_OWORD *)(v20 + 8);
  result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  v24 = result;
  v25 = *(_BYTE *)(*(_QWORD *)v6 + 240);
  result[240] = v25 & 0x80;
  if (v25 < 0)
  {
    v26 = 0uLL;
    *((_OWORD *)result + 13) = 0u;
    *((_OWORD *)result + 14) = 0u;
    *((_OWORD *)result + 11) = 0u;
    *((_OWORD *)result + 12) = 0u;
    *((_OWORD *)result + 10) = 0u;
  }
  else
  {
    *((_QWORD *)result + 20) = 0;
    v26 = 0uLL;
  }
  *((_OWORD *)result + 8) = v26;
  *((_OWORD *)result + 9) = v26;
  *((_OWORD *)result + 6) = v26;
  *((_OWORD *)result + 7) = v26;
  *((_OWORD *)result + 4) = v26;
  *((_OWORD *)result + 5) = v26;
  *((_OWORD *)result + 2) = v26;
  *((_OWORD *)result + 3) = v26;
  *(_OWORD *)result = v26;
  *((_OWORD *)result + 1) = v26;
  if (*(char *)(a1 + 240) < 0)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v22, v23);
  v27 = v9 + ~(_BYTE)v13;
  v28 = (uint64_t *)(v5 + 8 * v12);
  v28[1] = (uint64_t)result;
  v29 = *v28;
  if (v27)
  {
    v30 = v29 + 24 * v13;
    v31 = v30 + 24 * v27 + 24;
    v32 = v30 + 24;
    v33 = result;
    do
    {
      *(_QWORD *)v33 = *(_QWORD *)v32;
      *(_OWORD *)(v33 + 8) = *(_OWORD *)(v32 + 8);
      v32 += 24;
      v33 += 24;
    }
    while (v32 != v31);
    v29 = *(_QWORD *)v6;
  }
  v34 = *(char *)(v29 + 240);
  if ((v34 & 0x80000000) == 0)
  {
    if (result[240] < 0)
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v22, v23);
    result = (char *)memmove(result + 168, (const void *)(v29 + 8 * v13 + 176), 8 * v27 + 8);
    v29 = *(_QWORD *)v6;
    LOBYTE(v34) = *(_BYTE *)(*(_QWORD *)v6 + 240);
  }
  *(_BYTE *)(v29 + 240) = v34 + ~v27;
  v35 = v24[240] + v27;
  v24[240] = v35;
  if (v35 >= 0)
    v36 = 7;
  else
    v36 = 10;
  if ((v35 & 0x7F) == v36
    || ((v37 = *(_BYTE *)(v29 + 240), v38 = v37, v39 = v37 & 0x7F, v38 >= 0) ? (v40 = 7) : (v40 = 10), v39 == v40))
  {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  return result;
}

double ___ZN5dyld416JustInTimeLoader11withRegionsEPKN5dyld39MachOFileEU13block_pointerFvRKNS1_5ArrayINS_6Loader6RegionEEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  double result;
  uint64_t v9;
  uint64_t v10;
  unsigned __int32 v11;
  __n128 v12;
  __n128 v13;

  v4 = *(unsigned int *)(a2 + 56);
  v5 = *(_QWORD *)(a2 + 8);
  if ((v4 & 8) != 0 && !v5)
    goto LABEL_10;
  v6 = *(_DWORD *)(a2 + 52);
  v13.n128_u64[0] = (v4 << 62) & 0x8000000000000000 | ((unint64_t)(v6 & 7) << 59) | (*(_QWORD *)(a2 + 16)
                                                                                            - *(_QWORD *)(a1 + 40)) & 0x7FFFFFFFFFFFFFFLL;
  v13.n128_u32[2] = *(_QWORD *)a2;
  v13.n128_u32[3] = v5;
  if ((unsigned __int16)v4 >> 4 == *(_DWORD *)(a1 + 48) - 1 && v6 == 1)
    v13.n128_u32[3] = *(_QWORD *)(a2 + 24);
  *(_QWORD *)&result = dyld3::Array<dyld4::Loader::Region>::push_back((uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), &v13).n128_u64[0];
  if ((*(_BYTE *)(a2 + 56) & 8) != 0)
  {
LABEL_10:
    v9 = *(_QWORD *)(a2 + 8);
    v10 = *(_QWORD *)(a1 + 32);
    v12.n128_u64[0] = (*(_QWORD *)(a2 + 16) - *(_QWORD *)(a1 + 40) + v9) & 0x7FFFFFFFFFFFFFFLL | ((unint64_t)(*(_DWORD *)(a2 + 52) & 7) << 59) | 0x4000000000000000;
    v11 = *(_DWORD *)(a2 + 24) - v9;
    v12.n128_u32[2] = 0;
    v12.n128_u32[3] = v11;
    *(_QWORD *)&result = dyld3::Array<dyld4::Loader::Region>::push_back((uint64_t *)(*(_QWORD *)(v10 + 8) + 40), &v12).n128_u64[0];
  }
  return result;
}

__n128 dyld3::Array<dyld4::Loader::Region>::push_back(uint64_t *a1, __n128 *a2)
{
  unint64_t v2;
  uint64_t v3;
  __n128 result;

  v2 = a1[2];
  if (v2 >= a1[1])
    ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
  v3 = *a1;
  a1[2] = v2 + 1;
  result = *a2;
  *(__n128 *)(v3 + 16 * v2) = *a2;
  return result;
}

BOOL dyld4::APIs::_dyld_shared_cache_contains_path(DyldSharedCache ***this, const char *a2)
{
  DyldSharedCache *v4;
  DyldSharedCache *v5;

  v4 = dyld4::ProcessConfig::canonicalDylibPathInCache(this[1], a2);
  v5 = v4;
  if (*((_BYTE *)this[1] + 204))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_shared_cache_contains_path(%s) => %d\n", a2, v4 != 0);
  return v5 != 0;
}

BOOL dyld4::APIs::dyld_program_minos_at_least(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  int v3;
  _BOOL4 v4;
  unsigned int v5;

  v2 = *(_DWORD **)(a1 + 8);
  v3 = v2[16];
  v4 = v3 != 0;
  if ((_DWORD)a2 == -1)
  {
    v5 = v2[15];
  }
  else if (v3 == (_DWORD)a2 || v2[17] == (_DWORD)a2)
  {
    v5 = v2[14];
  }
  else
  {
    v5 = 0;
    v4 = 0;
  }
  return v5 >= HIDWORD(a2) && v4;
}

const void *dyld4::APIs::_dyld_get_prog_image_header(dyld4::APIs *this)
{
  uint64_t v1;
  const void *v2;

  v1 = *((_QWORD *)this + 1);
  v2 = *(const void **)(v1 + 8);
  if (*(_BYTE *)(v1 + 204))
    dyld4::RuntimeState::log(this, "_dyld_get_prog_image_header() => %p\n", v2);
  return v2;
}

uint64_t dyld4::APIs::_NSGetExecutablePath(dyld4::APIs *this, char *a2, unsigned int *a3)
{
  uint64_t v5;
  uint64_t v7;
  const char *v8;
  size_t v9;
  size_t v10;

  v5 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v5 + 204))
  {
    dyld4::RuntimeState::log(this, "_NSGetExecutablePath(%p, %p)\n", a2, a3);
    v5 = *((_QWORD *)this + 1);
  }
  v7 = 16;
  if (*(_DWORD *)(v5 + 68) == 1)
    v7 = 24;
  v8 = *(const char **)(v5 + v7);
  v9 = _platform_strlen(v8);
  v10 = *a3;
  if (v9 + 1 <= v10)
  {
    strlcpy(a2, v8, v10);
    return 0;
  }
  else
  {
    *a3 = v9 + 1;
    return 0xFFFFFFFFLL;
  }
}

unint64_t dyld4::JustInTimeLoader::hiddenFromFlat(dyld4::JustInTimeLoader *this, char a2)
{
  unint64_t v2;
  unint64_t result;

  v2 = *((_QWORD *)this + 5);
  if ((a2 & 1) == 0)
    return (v2 >> 19) & 1;
  result = 0;
  *((_QWORD *)this + 5) = v2 & 0xFFFFFFFFFFF7FFFFLL;
  return result;
}

uint64_t dyld4::CacheFinder::CacheFinder(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int *v7;
  dyld3 *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  const char *v13;
  int v14;
  const char *v15;
  char *v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  char *v22;
  uint64_t v23;
  _DWORD v24[2];
  __int128 v25;
  uint64_t v26;
  int v27;
  int v28;

  *(_DWORD *)a1 = -1;
  *(_QWORD *)(a1 + 8) = a4;
  *(_DWORD *)(a1 + 16) = 4;
  v7 = (int *)(a1 + 16);
  *(_QWORD *)(a1 + 20) = -1;
  *(_QWORD *)(a1 + 28) = -1;
  *(_QWORD *)(a1 + 36) = -1;
  *(_DWORD *)(a1 + 44) = -1;
  *(_BYTE *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = -1;
  v8 = (dyld3 *)_simple_getenv(*(const char ***)(a2 + 112), "DYLD_SHARED_CACHE_DIR");
  if (v8)
  {
    v9 = dyld4::SyscallDelegate::open(*(dyld4::SyscallDelegate **)(a1 + 8), v8, 0, 0);
    *(_DWORD *)a1 = v9;
    if (v9 == -1)
      return a1;
  }
  if ((*(_BYTE *)(a2 + 88) & 8) != 0)
    goto LABEL_31;
  v10 = *(_DWORD *)(a2 + 96);
  v24[0] = 1;
  v24[1] = v10;
  v25 = *(_OWORD *)(a2 + 104);
  v26 = *(_QWORD *)(a2 + 120);
  v11 = *(_DWORD *)(a2 + 60);
  v27 = -1;
  v28 = v11;
  v12 = ignite((uint64_t)v24, v7);
  if ((_DWORD)v12)
  {
    v14 = v12;
    if (*(_DWORD *)(a2 + 144) == 1)
    {
      dyld4::console((dyld4 *)"ignite() returned %d\n", v13, v12);
      if (v14 <= 84)
      {
        if (v14 == 8)
        {
          v16 = "ignition disabled\n";
        }
        else
        {
          if (v14 != 19)
            goto LABEL_23;
          v16 = "no shared cache available\n";
        }
        goto LABEL_22;
      }
      switch(v14)
      {
        case 'Y':
          v16 = "ignition partially disabled\n";
LABEL_22:
          dyld4::console((dyld4 *)v16, v15, v23);
          break;
        case 'U':
          v22 = "no shared cache in cryptex";
LABEL_41:
          dyld4::halt(v22, 0);
        case 'Z':
          v22 = "ignition failed";
          goto LABEL_41;
      }
    }
    else if ((_DWORD)v12 == 85 && *(_BYTE *)(a3 + 1))
    {
      dyld4::console((dyld4 *)"ignite() returned %d\n", v13, 85);
    }
  }
  else
  {
    v17 = *(_DWORD *)(a1 + 24);
    if ((v17 & 0x80000000) == 0)
    {
      if (*(_DWORD *)a1 == -1)
      {
        *(_DWORD *)a1 = v17;
        *(_BYTE *)(a1 + 48) = 1;
      }
      else
      {
        dyld4::SyscallDelegate::close(*(dyld4::SyscallDelegate **)(a1 + 8), v17);
      }
    }
    v18 = *(_DWORD *)(a1 + 32);
    if ((v18 & 0x80000000) == 0)
      *(_DWORD *)(a1 + 52) = v18;
  }
LABEL_23:
  if (*(_BYTE *)(a1 + 48))
  {
    if (*(_DWORD *)(a2 + 60) == 10)
      v19 = (*(_QWORD *)(a2 + 88) >> 5) & 1;
    else
      v19 = *(_QWORD *)(a2 + 88) & 0x10;
    if (!v19)
      return a1;
    if (*(_DWORD *)a1 != -1)
      dyld4::SyscallDelegate::close(*(dyld4::SyscallDelegate **)(a1 + 8), *(_DWORD *)a1);
    *(_DWORD *)a1 = -1;
    *(_BYTE *)(a1 + 48) = 0;
  }
LABEL_31:
  if (*(_DWORD *)a1 == -1)
  {
    if (*(_DWORD *)(a2 + 60) == 10)
      v20 = "/System/DriverKit/System/Library/dyld/";
    else
      v20 = "/System/Library/Caches/com.apple.dyld/";
    *(_DWORD *)a1 = dyld4::SyscallDelegate::open(*(dyld4::SyscallDelegate **)(a1 + 8), (dyld3 *)v20, 0, 0);
  }
  return a1;
}

dyld4::ProcessConfig::Process *dyld4::ProcessConfig::Process::Process(dyld4::ProcessConfig::Process *this, const dyld4::KernelArgs *a2, dyld4::SyscallDelegate *a3, lsl::Allocator *a4)
{
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  const char *v17;
  BOOL v18;
  char v19;
  const char *v20;
  const char *v21;
  int v22;
  const char *v23;
  int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v31;

  v8 = (_QWORD *)((char *)this + 88);
  dyld4::SyscallDelegate::DyldCommPage::DyldCommPage((dyld4::ProcessConfig::Process *)((char *)this + 88));
  v9 = *((_QWORD *)a2 + 1);
  *(_QWORD *)this = *(_QWORD *)a2;
  *((_DWORD *)this + 24) = v9;
  v10 = (_QWORD *)((char *)a2 + 8 * v9 + 24);
  *((_QWORD *)this + 13) = (char *)a2 + 16;
  *((_QWORD *)this + 14) = v10;
  while (*v10++)
    ;
  *((_QWORD *)this + 15) = v10;
  *((_DWORD *)this + 36) = dyld4::SyscallDelegate::getpid();
  *((_QWORD *)this + 11) = dyld4::SyscallDelegate::dyldCommPageFlags(a3);
  *((_BYTE *)this + 148) = dyld4::PrebuiltLoader::hiddenFromFlat(a3);
  *((_QWORD *)this + 3) = dyld4::ProcessConfig::Process::getMainFileID((const char ***)this);
  *((_QWORD *)this + 4) = v12;
  *((_QWORD *)this + 9) = dyld4::ProcessConfig::Process::getDyldFileID((const char ***)this);
  *((_QWORD *)this + 10) = v13;
  *((_QWORD *)this + 2) = dyld4::ProcessConfig::Process::getMainUnrealPath((const char ***)this, a3, a4);
  *((_QWORD *)this + 1) = dyld4::ProcessConfig::Process::getMainPath(this, a3, a4);
  v14 = (char *)*((_QWORD *)this + 2);
  v15 = strrchr(v14, 47);
  if (v15)
    v16 = v15 + 1;
  else
    v16 = v14;
  *((_QWORD *)this + 16) = v16;
  *((_QWORD *)this + 8) = dyld4::ProcessConfig::Process::getDyldPath((fsid_t *)this, a3, a4);
  if (*((_DWORD *)this + 36) == 1)
    *v8 = *(unsigned int *)v8;
  *((_DWORD *)this + 15) = dyld4::ProcessConfig::Process::getMainPlatform(this);
  *((_BYTE *)this + 149) = 0;
  v17 = dyld3::MachOFile::archName(*(dyld3::MachOFile **)this);
  *((_QWORD *)this + 17) = dyld4::SyscallDelegate::getGradedArchs(a3, v17, 0);
  *((_BYTE *)this + 150) = (*((_QWORD *)this + 11) & 0x200000) == 0;
  if (_simple_getenv(*((const char ***)this + 15), "dyld_hw_tpro_pagers"))
    v18 = vm_page_size == 0x4000;
  else
    v18 = 0;
  v19 = v18;
  *((_BYTE *)this + 151) = v19;
  *((_BYTE *)this + 152) = (*((_QWORD *)this + 11) & 0xC0000) != 0x80000;
  *((_BYTE *)this + 153) = 0;
  *((_DWORD *)this + 39) = 2;
  if (!dyld4::SyscallDelegate::internalInstall(a3))
  {
LABEL_21:
    if (*((int *)this + 39) <= 1)
      goto LABEL_25;
    goto LABEL_22;
  }
  if ((*(_BYTE *)v8 & 0x80) != 0)
    goto LABEL_23;
  v20 = _simple_getenv(*((const char ***)this + 14), "DYLD_PAGEIN_LINKING");
  if (!v20)
    goto LABEL_21;
  v21 = v20;
  if (!_platform_strcmp(v20, "0"))
  {
LABEL_23:
    v22 = 0;
LABEL_24:
    *((_DWORD *)this + 39) = v22;
    goto LABEL_25;
  }
  if (!_platform_strcmp(v21, "1"))
  {
    v22 = 1;
    goto LABEL_24;
  }
  if (_platform_strcmp(v21, "2"))
  {
    if (_platform_strcmp(v21, "3"))
      goto LABEL_21;
    v31 = 3;
  }
  else
  {
    v31 = 2;
  }
  *((_DWORD *)this + 39) = v31;
LABEL_22:
  if (dyld4::SyscallDelegate::sandboxBlockedPageInLinking(a3))
    goto LABEL_23;
LABEL_25:
  v23 = (const char *)*((_QWORD *)this + 16);
  v24 = *((_DWORD *)this + 15);
  v25 = *((_DWORD *)this + 10);
  v26 = *((unsigned __int8 *)this + 150);
  if (v24 == 2 && *((_BYTE *)this + 150))
  {
    v27 = 0;
    while (_platform_strcmp(v23, (&dyld4::dataConstApps_iOS14_5_arm64)[v27]))
    {
      if (++v27 == 37)
        goto LABEL_32;
    }
    if (v25 >> 8 < 0xE0F)
      goto LABEL_45;
LABEL_32:
    v28 = 0;
    while (_platform_strcmp(v23, (&dyld4::dataConstApps_iOS14_5_Intune_arm64)[v28]))
    {
      if (++v28 == 137)
        goto LABEL_37;
    }
    if (v25 >> 8 < 0xE0F)
      goto LABEL_45;
LABEL_37:
    v26 = 1;
  }
  if (v24 == 2 && v26)
  {
    v29 = 0;
    while (_platform_strcmp(v23, (&dyld4::dataConstApps_iOS15_0)[v29]))
    {
      if (++v29 == 30)
        return this;
    }
    if (HIWORD(v25) <= 0xEu)
LABEL_45:
      *((_BYTE *)this + 150) = 0;
  }
  return this;
}

uint64_t dyld4::SyscallDelegate::dyldCommPageFlags(dyld4::SyscallDelegate *this)
{
  return MEMORY[0xFFFFFC160];
}

void *dyld4::SyscallDelegate::getGradedArchs(dyld4::SyscallDelegate *this, const char *a2, dyld3::GradedArchs *a3)
{
  return dyld3::GradedArchs::forCurrentOS(a3);
}

uint64_t dyld4::ExternallyViewableState::switchToDyldInDyldCache(dyld4::ExternallyViewableState *this, const dyld3::MachOFile *a2)
{
  uint64_t v3;
  void (*v4)(uint64_t, uint64_t, dyld4::ExternallyViewableState **);
  uint64_t v5;
  void (*v7)(uint64_t, uint64_t, dyld4::ExternallyViewableState **);
  dyld4::ExternallyViewableState *v8;
  const char *v9;
  uint64_t v10;
  mach_msg_type_number_t task_info_outCnt;
  integer_t task_info_out[6];

  task_info_outCnt = 5;
  if (task_info(mach_task_self_, 0x11u, task_info_out, &task_info_outCnt))
    return 0;
  v3 = *(_QWORD *)task_info_out;
  if (proc_set_dyld_all_image_info(&dyld_all_image_infos, (void *)0x170))
  {
    sProcessInfo = (_UNKNOWN *)v3;
    v4 = *(void (**)(uint64_t, uint64_t, dyld4::ExternallyViewableState **))(v3 + 16);
    *(_QWORD *)(v3 + 32) = this;
    *(_QWORD *)(v3 + 192) = "/usr/lib/dyld";
    *(_QWORD *)(v3 + 16) = lldb_image_notifier;
    *(_QWORD *)(v3 + 48) = "cache";
    v8 = this;
    v9 = "/usr/lib/dyld";
    v10 = 0;
    v4(3, 1, &v8);
    return 0;
  }
  if (*(_DWORD *)(v3 + 200))
    dword_1ECCECB88 = *(_DWORD *)(v3 + 200);
  v7 = *(void (**)(uint64_t, uint64_t, dyld4::ExternallyViewableState **))(v3 + 16);
  v8 = this;
  v9 = "/usr/lib/dyld";
  v10 = 0;
  v5 = 1;
  v7(3, 1, &v8);
  return v5;
}

uint64_t __proc_info(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_proc_info, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  mach_msg_type_number_t v7;
  uint64_t reply_port;
  kern_return_t v9;
  kern_return_t v10;
  BOOL v11;
  mach_msg_type_number_t v14;
  uint64_t v15;
  mach_msg_header_t v16;
  uint64_t v17;
  task_flavor_t v18;
  mach_msg_size_t v19;
  _OWORD v20[24];

  v17 = 0x100000000;
  v7 = *task_info_outCnt;
  if (*task_info_outCnt >= 0x5E)
    v7 = 94;
  memset(v20, 0, sizeof(v20));
  v18 = flavor;
  v19 = v7;
  reply_port = mig_get_reply_port();
  *(_QWORD *)&v16.msgh_bits = 0x2800001513;
  *(_QWORD *)&v16.msgh_remote_port = __PAIR64__(reply_port, target_task);
  *(_QWORD *)&v16.msgh_voucher_port = 0xD4D00000000;
  v9 = mach_msg2_internal(&v16, 0x200000003uLL, (void *)0x2800001513, (void *)__PAIR64__(reply_port, target_task), (void *)0xD4D00000000, (void *)(reply_port << 32), (void *)0x1A8, 0);
  v10 = v9;
  if ((v9 - 268435458) > 0xE || ((1 << (v9 - 2)) & 0x4003) == 0)
  {
    if (v9)
    {
      mig_dealloc_reply_port(v16.msgh_local_port);
      return v10;
    }
    if (v16.msgh_id == 71)
    {
      v10 = -308;
    }
    else if (v16.msgh_id == 3505)
    {
      if ((v16.msgh_bits & 0x80000000) == 0)
      {
        if (v16.msgh_size - 417 <= 0xFFFFFE86)
        {
          if (v16.msgh_remote_port)
            v11 = 1;
          else
            v11 = v18 == 0;
          if (!v11 && v16.msgh_size == 36)
            v10 = v18;
          else
            v10 = -300;
          goto LABEL_24;
        }
        if (!v16.msgh_remote_port)
        {
          v10 = v18;
          if (v18)
            goto LABEL_24;
          v14 = v19;
          if (v19 <= 0x5E && v19 <= (v16.msgh_size - 40) >> 2 && v16.msgh_size == 4 * v19 + 40)
          {
            v15 = *task_info_outCnt;
            if (v19 <= v15)
            {
              memmove(task_info_out, v20, 4 * v19);
              v10 = 0;
              *task_info_outCnt = v14;
            }
            else
            {
              memmove(task_info_out, v20, 4 * v15);
              *task_info_outCnt = v14;
              return -307;
            }
            return v10;
          }
        }
      }
      v10 = -300;
    }
    else
    {
      v10 = -301;
    }
LABEL_24:
    mach_msg_destroy(&v16);
  }
  return v10;
}

int64_t mach_msg2_internal(void *a1, unint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  void *v16;
  int64_t result;
  unint64_t v18;
  void *v19;

  v16 = (void *)(a2 & 0xFFFFFFFFFFFFFBBFLL);
  result = mach_msg2_trap(a1, (void *)(a2 & 0xFFFFFFFFFFFFFBBFLL), a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    if ((a2 & 0x40) == 0)
    {
      while ((_DWORD)result == 268435463)
        result = mach_msg2_trap(a1, v16, a3, a4, a5, a6, a7, a8);
    }
    if ((a2 & 0x400) == 0 && (_DWORD)result == 268451845)
    {
      if ((~(_BYTE)a2 & 3) != 0)
        v18 = a2;
      else
        v18 = a2 & 0xFFFFFFFFFFFFBBBELL;
      v19 = (void *)(v18 & 0xFFFFFFFFFFFFFBBELL);
      do
        result = mach_msg2_trap(a1, v19, (void *)a3, a4, a5, a6, a7, a8);
      while ((_DWORD)result == 268451845);
    }
  }
  return result;
}

uint64_t proc_set_dyld_all_image_info(void *a1, void *a2)
{
  void *v4;
  void *v5;
  void *v6;

  v4 = (void *)getpid();
  return __proc_info((void *)0xF, v4, 0, 0, a1, a2, v5, v6);
}

mach_port_t mig_get_reply_port(void)
{
  unint64_t StatusReg;
  mach_port_t result;
  mach_port_options_t v2;
  mach_port_name_t name;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  result = *(_DWORD *)(StatusReg + 16);
  name = result;
  if (!result)
  {
    v2.reserved[1] = 0;
    *(_OWORD *)&v2.flags = xmmword_1A5CBC990;
    result = mach_port_construct(mach_task_self_, &v2, 0, &name);
    if (result)
    {
      qword_1EE805DD0 = (uint64_t)"mach_port_construct for mig_get_reply_port failed";
      qword_1EE805E00 = (int)result;
      __break(1u);
    }
    else
    {
      result = name;
      *(_QWORD *)(StatusReg + 16) = name;
    }
  }
  return result;
}

kern_return_t mach_port_construct(ipc_space_t task, mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  kern_return_t v8;
  uint64_t reply_port;
  kern_return_t v10;
  BOOL v11;
  mach_msg_header_t v13;
  int v14;
  mach_port_options_ptr_t v15;
  uint64_t v16;
  uint64_t v17;
  mach_port_context_t v18;

  v8 = _kernelrpc_mach_port_construct_trap(task, options, context, name);
  if (v8 == 268435459)
  {
    v14 = 1;
    v15 = options;
    v16 = 0x1801000100;
    v17 = 0x100000000;
    v18 = context;
    reply_port = mig_get_reply_port();
    *(_QWORD *)&v13.msgh_bits = 0x3C80001513;
    *(_QWORD *)&v13.msgh_remote_port = __PAIR64__(reply_port, task);
    *(_QWORD *)&v13.msgh_voucher_port = 0xC9F00000000;
    v10 = mach_msg2_internal(&v13, 0x200000003uLL, (void *)0x3C80001513, (void *)__PAIR64__(reply_port, task), (void *)0xC9F00000000, (void *)((reply_port << 32) | 1), (void *)0x30, 0);
    v8 = v10;
    if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
    {
      if (!v10)
      {
        if (v13.msgh_id == 71)
        {
          v8 = -308;
        }
        else if (v13.msgh_id == 3331)
        {
          if ((v13.msgh_bits & 0x80000000) == 0)
          {
            if (v13.msgh_size == 40)
            {
              if (!v13.msgh_remote_port)
              {
                v8 = HIDWORD(v15);
                if (!HIDWORD(v15))
                {
                  *name = v16;
                  return v8;
                }
                goto LABEL_21;
              }
            }
            else if (v13.msgh_size == 36)
            {
              if (v13.msgh_remote_port)
                v11 = 1;
              else
                v11 = HIDWORD(v15) == 0;
              if (v11)
                v8 = -300;
              else
                v8 = HIDWORD(v15);
              goto LABEL_21;
            }
          }
          v8 = -300;
        }
        else
        {
          v8 = -301;
        }
LABEL_21:
        mach_msg_destroy(&v13);
        return v8;
      }
      mig_dealloc_reply_port(v13.msgh_local_port);
    }
  }
  return v8;
}

unint64_t dyld4::SyscallDelegate::amfiFlags(dyld4::SyscallDelegate *this, int a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v11;

  v11 = 0;
  v8 = 2;
  if (!a2)
    v8 = 0;
  if ((_DWORD)a3)
    v9 = v8 | 4;
  else
    v9 = v8;
  if (amfi_check_dyld_policy_self(v9, &v11, a3, a4, a5, a6, a7, a8))
    return 0;
  else
    return v11;
}

uint64_t amfi_check_dyld_policy_self(uint64_t a1, unint64_t *a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result;
  unint64_t v10;
  _QWORD v11[2];

  if (!a2)
    return 22;
  *a2 = 0;
  v10 = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = a1;
  v11[1] = &v10;
  result = __sandbox_ms("AMFI", (void *)0x5A, v11, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
    result = *__error();
  *a2 = v10;
  return result;
}

BOOL dyld4::SyscallDelegate::sandboxBlockedPageInLinking(dyld4::SyscallDelegate *this)
{
  pid_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = getpid();
  return (int)sandbox_check(v1, (vm_address_t *)"syscall-unix", 1073741838, v2, v3, v4, v5, v6, 0x226u) > 0;
}

uint64_t sandbox_check(int a1, vm_address_t *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  _QWORD v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  unsigned int *v25;
  vm_address_t *v26;

  v26 = a2;
  sandbox_operation_fixup(&v26);
  v17[0] = 0;
  v18 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17[1] = a1;
  *(_QWORD *)&v18 = v26;
  v25 = &a9;
  return sandbox_check_common(v17, a3, &a9, v11, v12, v13, v14, v15);
}

vm_address_t *sandbox_operation_fixup(vm_address_t **a1)
{
  vm_address_t *result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = *a1;
  if (result)
  {
    result = (vm_address_t *)_platform_strcmp((const char *)result, "iokit-open");
    if (!(_DWORD)result)
    {
      result = sandbox_warn("sandbox operation \"%s\" is obsolete; replace with \"%s\"",
                 v3,
                 v4,
                 v5,
                 v6,
                 v7,
                 v8,
                 v9,
                 (int)"iokit-open");
      *a1 = (vm_address_t *)"iokit-open-user-client";
    }
  }
  return result;
}

uint64_t sandbox_check_common(_QWORD *a1, int a2, unsigned int *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int *v11;
  _DWORD *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t **v15;
  unsigned int *v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;

  v23 = a3;
  *a1 = &v18;
  if ((a2 & 0x40000000) != 0)
  {
    a1[5] |= 1uLL;
    if ((a2 & 0x20000000) == 0)
    {
LABEL_3:
      if ((a2 & 0x10000000) == 0)
        goto LABEL_4;
      goto LABEL_12;
    }
  }
  else if ((a2 & 0x20000000) == 0)
  {
    goto LABEL_3;
  }
  a1[5] |= 2uLL;
  if ((a2 & 0x10000000) == 0)
  {
LABEL_4:
    if ((a2 & 0x8000000) == 0)
      goto LABEL_5;
    goto LABEL_13;
  }
LABEL_12:
  a1[5] |= 8uLL;
  if ((a2 & 0x8000000) == 0)
  {
LABEL_5:
    if ((a2 & 0x4000000) == 0)
      goto LABEL_6;
    goto LABEL_14;
  }
LABEL_13:
  a1[5] |= 0x10uLL;
  if ((a2 & 0x4000000) == 0)
  {
LABEL_6:
    if ((a2 & 0x2000000) == 0)
      goto LABEL_8;
    goto LABEL_7;
  }
LABEL_14:
  a1[5] |= 0x20uLL;
  if ((a2 & 0x2000000) != 0)
LABEL_7:
    a1[5] |= 0x40uLL;
LABEL_8:
  v21 = 0;
  v22 = 0;
  v19 = 0;
  v20 = 0;
  v8 = a2 & 0x81FFFFFF;
  v18 = 0;
  v9 = 240;
  switch((int)v8)
  {
    case 0:
      a1[3] = 0;
      a1[4] = 0;
      goto LABEL_36;
    case 1:
      goto LABEL_32;
    case 2:
      v8 = 6;
      goto LABEL_32;
    case 3:
      v8 = 7;
      goto LABEL_32;
    case 4:
      v8 = 25;
      goto LABEL_32;
    case 5:
      v8 = 27;
      goto LABEL_32;
    case 6:
      v8 = 28;
      goto LABEL_32;
    case 7:
      v8 = 33;
      goto LABEL_32;
    case 8:
      v8 = 34;
      goto LABEL_32;
    case 9:
      v10 = v23;
      v23 += 2;
      v21 = *(_QWORD *)v10;
      v23 = v10 + 4;
      v22 = (int)v10[2];
      a1[3] = 35;
      a1[4] = &v21;
      goto LABEL_36;
    case 10:
      goto LABEL_34;
    case 11:
      v11 = v23;
      v23 += 2;
      v12 = *(_DWORD **)v11;
      v23 = v11 + 4;
      v13 = (uint64_t *)*((_QWORD *)v11 + 1);
      a1[3] = 241;
      LODWORD(v20) = *v12;
      v19 = *v13;
      v14 = &v19;
      goto LABEL_35;
    case 12:
      v8 = 50;
      goto LABEL_32;
    case 13:
      v8 = 19;
      goto LABEL_32;
    case 14:
      v9 = 65;
      goto LABEL_34;
    case 15:
      v8 = 45;
      goto LABEL_32;
    case 16:
      v9 = 75;
      goto LABEL_34;
    case 17:
      v8 = 5;
LABEL_32:
      a1[3] = v8;
      v15 = (uint64_t **)v23;
      v23 += 2;
      v14 = *v15;
      goto LABEL_35;
    case 18:
      v9 = 52;
LABEL_34:
      a1[3] = v9;
      v16 = v23;
      v23 += 2;
      v14 = (uint64_t *)*v16;
LABEL_35:
      a1[4] = v14;
LABEL_36:
      if (__sandbox_ms("Sandbox", (void *)2, a1, a4, a5, a6, a7, a8))
        goto LABEL_37;
      result = v18 != 0;
      break;
    default:
      *__error() = 22;
LABEL_37:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t __sandbox_ms(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS___mac_syscall, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t _dylib_cache_fire(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  int dylib_root;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  pid_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  pid_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  pid_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  pid_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v72;
  char v73;
  char v74[1023];

  dylib_root = boot_get_dylib_root(a3);
  bzero(&v73, 0x400uLL);
  if (*a2 < 3uLL || dylib_root < 0)
  {
    dylib_root = *(_DWORD *)(a3 + 16);
    v13 = 19;
  }
  else
  {
    v13 = 85;
  }
  ignition_get_shared_cache_directory(&v73, v6, v7, v8, v9, v10, v11, v12);
  if (v74[0] == 47)
    dyld_halt("bogus shared cache path: %s", v14, v15, v16, v17, v18, v19, v20, (int)&v73);
  v21 = getpid();
  dlog(-1, "libignition: %d: %12s: finding shared cache on %s: ignition level = %llu, search root fd = %d, subpath = %s\n", v22, v23, v24, v25, v26, v27, v21);
  v28 = openat(dylib_root, v74, 0x100000);
  v72 = v28;
  v29 = __error();
  if (v28 < 0)
  {
    if (!*v29)
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v30, v31, v32, v33, v34, v35, v36, (int)"dycash");
  }
  else
  {
    *v29 = 0;
  }
  v37 = *__error();
  if (v37 == 2)
  {
    v50 = getpid();
    dlog(-1, "libignition: %d: %12s: shared cache not found: root = %s, path = %s\n", v51, v52, v53, v54, v55, v56, v50);
    goto LABEL_13;
  }
  if (!v37)
  {
    realpathfd(v28, (uint64_t)&v73, (int)"dylib cache path");
    v38 = getpid();
    dlog(-1, "libignition: %d: %12s: opened shared cache directory: %s\n", v39, v40, v41, v42, v43, v44, v38);
    boot_set_root(a3, (uint64_t)&_boot_root_dylib_cache, &v72, v45, v46, v47, v48, v49);
    v13 = 0;
LABEL_13:
    closefd_optional(&v72, (int)"shared cache directory");
    return v13;
  }
  v13 = *__error();
  v57 = getpid();
  dlog(-1, "libignition: %d: %12s: failed to open shared cache: %s: %d\n", v58, v59, v60, v61, v62, v63, v57);
  closefd_optional(&v72, (int)"shared cache directory");
  if (v13 >= 0x6A)
    dyld_halt("error not set to valid posix code: %d", v64, v65, v66, v67, v68, v69, v70, v13);
  return v13;
}

int openat(int a1, const char *a2, int a3, ...)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  unsigned __int16 v7;
  uint64_t v9;
  va_list va;

  va_start(va, a3);
  v9 = va_arg(va, _QWORD);
  if ((a3 & 0x200) != 0)
    v7 = v9;
  else
    v7 = 0;
  return __openat(a1, (char *)a2, *(void **)&a3, (void *)v7, v3, v4, v5, v6);
}

int __openat(int a1, char *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t v9;

  LODWORD(v9) = mac_syscall(SYS_openat, a1, a2, (int)a3);
  if (v8)
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  return v9;
}

char *ignition_get_shared_cache_directory(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v9;

  if (*(_DWORD *)(*(_QWORD *)configuration((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8) + 36) == 10)
    v9 = "/System/DriverKit/System/Library/dyld/";
  else
    v9 = "/System/Library/Caches/com.apple.dyld/";
  strlcpy(a1, v9, 0x400uLL);
  return a1;
}

uint64_t configuration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  int vars0;

  result = _config;
  if (!_config)
    dyld_halt("configuration not initialized", a2, a3, a4, a5, a6, a7, a8, vars0);
  return result;
}

uint64_t boot_get_dylib_root(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

uint64_t realpathfd(int a1, uint64_t a2, int a3)
{
  char ***v6;
  char *v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (fcntl(a1, 50, a2) == -1)
  {
    v6 = boot_get();
    v7 = (*v6)[1];
    v8 = (unint64_t)(*v6)[2];
    v9 = *__error();
    __error();
    ignition_halt(v7, v9, v8, "failed to realpath %s: %d: %d", v10, v11, v12, v13, a3);
  }
  return a2;
}

uint64_t _graft_fetch_fire(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  pid_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  pid_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v47;
  int v48;

  v47 = -1;
  v4 = openat(*(_DWORD *)(a3 + 16), "System/Cryptexes/OS", 0x100000);
  v48 = v4;
  v5 = __error();
  if (v4 < 0)
  {
    if (!*v5)
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v6, v7, v8, v9, v10, v11, v12, (int)"cnl");
  }
  else
  {
    *v5 = 0;
  }
  v13 = *__error();
  if (v13 == 2)
  {
    v19 = getpid();
    dlog(-1, "libignition: %d: %12s: no os cryptex available; continuing\n", v20, v21, v22, v23, v24, v25, v19);
    goto LABEL_8;
  }
  if (!v13)
  {
    v47 = dupfd(v4, (int)"os cryptex canonical directory");
LABEL_8:
    boot_set_root(a3, (uint64_t)&_boot_root_canonical_os, &v48, v14, v15, v16, v17, v18);
    boot_set_root(a3, (uint64_t)&_boot_root_cryptex_os, &v47, v26, v27, v28, v29, v30);
    v31 = 0;
    goto LABEL_10;
  }
  v31 = *__error();
  v32 = getpid();
  dlog(-1, "libignition: %d: %12s: failed to open os cryptex canonical directory: %d\n", v33, v34, v35, v36, v37, v38, v32);
LABEL_10:
  closefd_optional(&v48, (int)"os cryptex canonical directory");
  closefd_optional(&v47, (int)"os cryptex canonical directory [dup]");
  if (v31 >= 0x6A)
    dyld_halt("error not set to valid posix code: %d", v39, v40, v41, v42, v43, v44, v45, v31);
  return v31;
}

uint64_t boot_set_root(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _DWORD *v10;
  uint64_t result;

  v8 = *(_QWORD *)(a2 + 16);
  if (v8 < 0)
    dyld_halt("invalid offset: %lld", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(_QWORD *)(a2 + 16));
  v10 = (_DWORD *)(a1 + v8);
  closefd_optional((int *)(a1 + v8), (int)"old root");
  result = xferfd(a3);
  *v10 = result;
  return result;
}

uint64_t ignite(uint64_t a1, int *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  pid_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  size_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _BOOL8 v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  pid_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  pid_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  pid_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  pid_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  pid_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  char **v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  char ***v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  pid_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  int v160;
  char ***v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  int v166;
  char ***v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  int v172;
  char ***v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  char ***v178;
  char *v179;
  unint64_t v180;
  int v181;
  int *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  size_t v187;
  char v188[1216];
  char ***v189;
  _OWORD v190[2];
  uint64_t v191;
  int v192;
  uint64_t v193;

  v191 = 0xFFFFFFFFLL;
  memset(v190, 0, sizeof(v190));
  LODWORD(v190[0]) = 1;
  v189 = 0;
  bzero(v188, 0x4C0uLL);
  v187 = 1216;
  v193 = 1;
  v192 = 2;
  if (getpid() == 1)
  {
    v11 = _open_as(0x20000, (int *)&v193 + 1);
    if (v11)
    {
      v160 = v11;
      v161 = boot_get();
      ignition_halt((*v161)[1], v160, (unint64_t)(*v161)[2], "failed to reserve stdin descriptor: %s: %d", v162, v163, v164, v165, (int)"/dev/null");
    }
    v12 = _open_as(131073, (int *)&v193);
    if (v12)
    {
      v166 = v12;
      v167 = boot_get();
      ignition_halt((*v167)[1], v166, (unint64_t)(*v167)[2], "failed to reserve stdout descriptor: %s: %d", v168, v169, v170, v171, (int)"/dev/null");
    }
    v13 = _open_as(131074, &v192);
    if (v13)
    {
      v172 = v13;
      v173 = boot_get();
      ignition_halt((*v173)[1], v172, (unint64_t)(*v173)[2], "failed to reserve stderr descriptor: %s: %d", v174, v175, v176, v177, (int)"/dev/null");
    }
  }
  v14 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    if (v14 != 1)
      dyld_halt("unsupported parameter struct version: 0x%x", v4, v5, v6, v7, v8, v9, v10, v14);
    HIDWORD(v191) = *(_DWORD *)(a1 + 36);
  }
  v15 = *(_DWORD *)(a1 + 4);
  LODWORD(v190[0]) = 1;
  DWORD1(v190[0]) = v15;
  *(_OWORD *)((char *)v190 + 8) = *(_OWORD *)(a1 + 8);
  *((_QWORD *)&v190[1] + 1) = *(_QWORD *)(a1 + 24);
  LODWORD(v191) = *(_DWORD *)(a1 + 32);
  log_init((uint64_t)v190);
  dlog(-1, "%s\n", v16, v17, v18, v19, v20, v21, (int)__darwin_version_string[0]);
  v22 = sysctlbyname("kern.bootargs", v188, &v187, 0, 0);
  v23 = __error();
  if (v22 < 0)
  {
    if (!*v23)
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v24, v25, v26, v27, v28, v29, v30, (int)"ret");
  }
  else
  {
    *v23 = 0;
  }
  v38 = *__error();
  if (v38 > 11)
  {
    if (v38 != 22)
    {
      if (v38 != 12)
        goto LABEL_32;
      v39 = getpid();
      __error();
      dlog(-1, "libignition: %d: boot-arg buff not large enough: actual = %lu, expected >= %lu: %d\n", v40, v41, v42, v43, v44, v45, v39);
    }
    goto LABEL_18;
  }
  if ((v38 - 1) < 2)
  {
LABEL_18:
    v188[0] = 0;
    goto LABEL_19;
  }
  if (v38)
  {
LABEL_32:
    v178 = boot_get();
    v179 = (*v178)[1];
    v180 = (unint64_t)(*v178)[2];
    v181 = *__error();
    v182 = __error();
    ignition_halt(v179, v181, v180, "failed to read boot args: %d", v183, v184, v185, v186, *v182);
  }
LABEL_19:
  v46 = arguments_init(v188, v31, v32, v33, v34, v35, v36, v37);
  arguments(v46, v47, v48, v49, v50, v51, v52, v53);
  arguments_dump();
  v54 = configuration_init((uint64_t)v190, v188);
  v62 = configuration(v54, v55, v56, v57, v58, v59, v60, v61);
  configuration_dump(v62);
  if (getpid() == 1)
  {
    v63 = getpid();
    dlog(-1, "libignition: %d: %s   :\n", v64, v65, v66, v67, v68, v69, v63);
    v70 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v71, v72, v73, v74, v75, v76, v70);
    v77 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v78, v79, v80, v81, v82, v83, v77);
    v84 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v85, v86, v87, v88, v89, v90, v84);
    v91 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v92, v93, v94, v95, v96, v97, v91);
  }
  v98 = boot_select_spec(v62);
  boot_dump_spec();
  v106 = boot_init(v98, v99, v100, v101, v102, v103, v104, v105);
  v189 = v106;
  v119 = boot_boot(v106, v107, v108, v109, v110, v111, v112, v113);
  if ((_DWORD)v119)
  {
    v120 = getpid();
    dlog(-1, "libignition: %d: ignition boot failed: %d\n", v121, v122, v123, v124, v125, v126, v120);
  }
  else
  {
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_preboot, a2, v114, v115, v116, v117, v118);
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_dylib_cache, a2, v127, v128, v129, v130, v131);
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_xart, a2, v132, v133, v134, v135, v136);
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_cryptex_app, a2, v137, v138, v139, v140, v141);
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_cryptex_os, a2, v142, v143, v144, v145, v146);
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_preboot_groupdir, a2, v147, v148, v149, v150, v151);
  }
  if (getpid() == 1)
  {
    close(0);
    close(1);
    close(2);
  }
  boot_destroy(&v189, v152, v153, v154, v155, v156, v157, v158);
  log_destroy();
  return v119;
}

uint64_t boot_set_payload(uint64_t result, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v11;

  if (*a3 >= 5)
    dyld_halt("unsupported payload version: actual = %u, expected <= %u", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
  if (*a3 >= *(_DWORD *)(a2 + 8))
  {
    v8 = *(_QWORD *)(a2 + 16);
    if (v8 < 0)
      dyld_halt("invalid offset: %lld", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(_QWORD *)(a2 + 16));
    v9 = *(_QWORD *)(a2 + 24);
    if (v9 < 0)
      dyld_halt("invalid offset: %lld", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(_QWORD *)(a2 + 24));
    v11 = dupfd_optional(*(_DWORD *)(result + v8), (int)"boot root");
    result = xferfd(&v11);
    *(int *)((char *)a3 + v9) = result;
  }
  return result;
}

uint64_t xferfd(_DWORD *a1)
{
  uint64_t v1;

  v1 = *a1;
  *a1 = -1;
  return v1;
}

uint64_t dupfd_optional(int a1, int a2)
{
  if (a1 < 0)
    return 0xFFFFFFFFLL;
  else
    return dupfd(a1, a2);
}

uint64_t dupfd(int a1, int a2)
{
  uint64_t result;
  char ***v5;
  char *v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  result = dup(a1);
  if (a1 < 0)
  {
    v5 = boot_get();
    v6 = (*v5)[1];
    v7 = (unint64_t)(*v5)[2];
    v8 = *__error();
    __error();
    ignition_halt(v6, v8, v7, "failed to dup %s: fd = %d: %d", v9, v10, v11, v12, a2);
  }
  return result;
}

int dup(int a1)
{
  char v1;
  int result;

  result = mac_syscall(SYS_dup, a1);
  if (v1)
    return cerror_nocancel(result);
  return result;
}

char ***boot_init(char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t i;
  unint64_t v9;

  for (i = 0; i != 9; ++i)
  {
    v9 = (unint64_t)(&__roots)[i][2];
    if ((v9 & 0x8000000000000000) != 0)
      dyld_halt("invalid offset: %lld", a2, a3, a4, a5, a6, a7, a8, (int)(&__roots)[i][2]);
    *(_DWORD *)((char *)__boot + v9) = -1;
  }
  __boot[0] = a1;
  return __boot;
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  size_t v10;
  int result;
  size_t v12;
  int v13[14];
  uint64_t v14;

  v14 = 0x300000000;
  v12 = 56;
  v10 = _platform_strlen(a1);
  result = __sysctl((int *)&v14, 2u, v13, &v12, (void *)a1, v10);
  if ((result & 0x80000000) == 0)
    return __sysctl(v13, v12 >> 2, a2, a3, a4, a5);
  return result;
}

int __sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  char v6;
  int result;

  result = mac_syscall(SYS_sysctl, a1, a2, a3, a4, a5, a6);
  if (v6)
    return cerror_nocancel(result);
  return result;
}

uint64_t log_init(uint64_t a1)
{
  uint64_t result;

  __g = a1;
  dword_1ECCECC44 = *(_DWORD *)(a1 + 32);
  result = _open_console();
  dword_1ECCECC40 = result;
  qword_1ECCECC48 = *(_QWORD *)(a1 + 16);
  return result;
}

int *log_destroy()
{
  return closefd_optional(&dword_1ECCECC40, (int)"console");
}

ssize_t configuration_dump(uint64_t a1)
{
  ssize_t result;
  uint64_t v3;
  pid_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  pid_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  pid_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  pid_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  pid_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  pid_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  pid_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  pid_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  pid_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  pid_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  pid_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  pid_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  pid_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  pid_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  pid_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  pid_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  pid_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  pid_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  pid_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;

  result = getpid();
  if ((int)result <= 1)
  {
    v3 = *(_QWORD *)(a1 + 6952);
    if (v3)
      _platform_strcmp((const char *)(v3 + 50), (const char *)&unk_1A5CBE413);
    v4 = getpid();
    dlog(-1, "libignition: %d: %s   :\n", v5, v6, v7, v8, v9, v10, v4);
    v11 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v12, v13, v14, v15, v16, v17, v11);
    v18 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v19, v20, v21, v22, v23, v24, v18);
    v25 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v26, v27, v28, v29, v30, v31, v25);
    v32 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v33, v34, v35, v36, v37, v38, v32);
    v39 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v40, v41, v42, v43, v44, v45, v39);
    v46 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v47, v48, v49, v50, v51, v52, v46);
    v53 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v54, v55, v56, v57, v58, v59, v53);
    v60 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v61, v62, v63, v64, v65, v66, v60);
    v67 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v68, v69, v70, v71, v72, v73, v67);
    v74 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v75, v76, v77, v78, v79, v80, v74);
    v81 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v82, v83, v84, v85, v86, v87, v81);
    v88 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v89, v90, v91, v92, v93, v94, v88);
    v95 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v96, v97, v98, v99, v100, v101, v95);
    v102 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v103, v104, v105, v106, v107, v108, v102);
    v109 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v110, v111, v112, v113, v114, v115, v109);
    v116 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v117, v118, v119, v120, v121, v122, v116);
    v123 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v124, v125, v126, v127, v128, v129, v123);
    v130 = getpid();
    return dlog(-1, "libignition: %d:   %s : %s\n", v131, v132, v133, v134, v135, v136, v130);
  }
  return result;
}

char **boot_select_spec(uint64_t a1)
{
  _BYTE *v2;
  char **result;

  v2 = (_BYTE *)(a1 + 4604);
  ignition_test_BRA(2);
  if (!v2[2428])
    return &_boot_spec_post_initproc;
  if (*(_QWORD *)(a1 + 400))
    return &_boot_spec_remote_ramdisk;
  if (*(_DWORD *)(a1 + 4600) || *(_QWORD *)(a1 + 472) || *(_QWORD *)(a1 + 1504) || *(_QWORD *)(a1 + 2536))
    return &_boot_spec_remote_nerd;
  if (*v2)
    return &_boot_spec_remote_ramdisk;
  if (*(_QWORD *)(a1 + 280) || *(_QWORD *)(a1 + 288) || *(_QWORD *)(a1 + 296))
    return &_boot_spec_remote_dmg;
  result = &_boot_spec_local;
  if (!*(_QWORD *)(a1 + 304))
  {
    if (*(_QWORD *)(a1 + 312))
      return &_boot_spec_remote_dmg;
    result = &_boot_spec_remote_dmg;
    if (!*(_QWORD *)(a1 + 320) && (*(_BYTE *)(a1 + 4608) & 1) == 0)
      return &_boot_spec_local;
  }
  return result;
}

ssize_t boot_dump_spec()
{
  ssize_t result;
  pid_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  pid_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  pid_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  result = getpid();
  if ((_DWORD)result == 1)
  {
    v1 = getpid();
    dlog(-1, "libignition: %d: %s   :\n", v2, v3, v4, v5, v6, v7, v1);
    v8 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v9, v10, v11, v12, v13, v14, v8);
    v15 = getpid();
    return dlog(-1, "libignition: %d:   %s : 0x%llx\n", v16, v17, v18, v19, v20, v21, v15);
  }
  return result;
}

uint64_t boot_boot(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD v29[2];
  int v30;

  arguments((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  v29[0] = *a1 + 24;
  v29[1] = 0;
  v30 = open("/", 537919488);
  if (v30 < 0)
  {
    v22 = __boot[0][1];
    v23 = __boot[0][2];
    v24 = *__error();
    __error();
    ignition_halt(v22, v24, (unint64_t)v23, "failed to open root directory: %s: %d", v25, v26, v27, v28, (int)"/");
  }
  boot_set_root((uint64_t)a1, (uint64_t)&_boot_root_fs, &v30, v9, v10, v11, v12, v13);
  result = stage_next(v29);
  if (!result)
  {
    LODWORD(result) = -1;
    goto LABEL_10;
  }
  while (1)
  {
    a1[1] = result;
    result = stage_fire(result, (uint64_t)a1, v16, v17, v18, v19, v20, v21);
    if ((_DWORD)result)
      break;
    result = stage_next(v29);
    if (!result)
      return result;
  }
  if (result >= 0x6A)
LABEL_10:
    dyld_halt("error not set to valid posix code: %d", v15, v16, v17, v18, v19, v20, v21, result);
  return result;
}

uint64_t stage_next(_QWORD *a1)
{
  unint64_t v1;
  uint64_t v2;

  v1 = a1[1];
  if (v1 >= *(_QWORD *)(*a1 + 64))
    return 0;
  v2 = *(_QWORD *)(*a1 + 8 * v1);
  a1[1] = v1 + 1;
  return v2;
}

uint64_t stage_fire(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;
  uint64_t v11;
  pid_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  pid_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  pid_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;

  v10 = (_QWORD *)arguments(a1, a2, a3, a4, a5, a6, a7, a8);
  if (*v10 >= *(_QWORD *)(a1 + 40))
  {
    v19 = getpid();
    dlog(-1, "libignition: %d: %12s: %s\n", v20, v21, v22, v23, v24, v25, v19);
    v26 = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t))(a1 + 48))(a1, v10, a2);
    if ((_DWORD)v26)
    {
      v11 = v26;
      v27 = getpid();
      dlog(-1, "libignition: %d: %12s: ignition failed: %d\n", v28, v29, v30, v31, v32, v33, v27);
    }
    else
    {
      if ((*(_QWORD *)(a1 + 32) & 0x8000000000000000) == 0
        && !(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 56))(a1, a2))
      {
        dyld_halt("stage did not set payload: %s", v43, v44, v45, v46, v47, v48, v49, *(_QWORD *)a1);
      }
      v11 = 0;
    }
  }
  else
  {
    v11 = ~(*(uint64_t *)(a1 + 32) >> 63) & 0x59;
    v12 = getpid();
    dlog(-1, "libignition: %d: %12s: ignition level insufficient: actual = %llu, required >= %llu\n", v13, v14, v15, v16, v17, v18, v12);
  }
  v34 = (const char *)v10[3];
  if (v34 && !_platform_strcmp(v34, *(const char **)a1))
    dyld_halt("halting after %s ignition stage; if you did not intend to do this, clear the ignition_halt_after boot-arg",
      v35,
      v36,
      v37,
      v38,
      v39,
      v40,
      v41,
      *(_QWORD *)a1);
  return v11;
}

ssize_t dlog(int a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return vdlog(a1, a2, &a9, a4, a5, a6, a7, a8);
}

ssize_t vdlog(int a1, char *a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  ssize_t result;
  int v12;

  if (!__g)
    dyld_halt("logging not yet initialized", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v12);
  result = getpid();
  if ((int)result <= 1)
  {
    if (a1 < 0)
    {
      a1 = dword_1ECCECC44;
      if (dword_1ECCECC44 < 0)
        a1 = _open_console();
    }
    return _simple_vdprintf(a1, a2, a3);
  }
  return result;
}

pid_t getpid(void)
{
  pid_t result;

  result = _current_pid;
  if (_current_pid <= 0)
    return cerror_nocancel(mac_syscall(SYS_getpid));
  return result;
}

uint64_t arguments(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  int vars0;

  result = _args;
  if (!_args)
    dyld_halt("arguments not initialized", a2, a3, a4, a5, a6, a7, a8, vars0);
  return result;
}

size_t arguments_init(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  size_t result;
  _OWORD v12[4];
  uint64_t v13;

  v13 = 0;
  memset(v12, 0, sizeof(v12));
  if (_args)
    dyld_halt("arguments already initialized", a2, a3, a4, a5, a6, a7, a8, v12[0]);
  if (dyld_parse_boot_arg_int(a1, "ignition_level", (unint64_t *)&v13))
    __args = v13;
  if (dyld_parse_boot_arg_cstr(a1, "ignition_force_dylib_root", (char *)v12, 0x40uLL))
  {
    if (_platform_strcmp((const char *)v12, "none"))
    {
      if (_platform_strcmp((const char *)v12, "cryptex"))
      {
        if (_platform_strcmp((const char *)v12, "livefs"))
        {
          if (_platform_strcmp((const char *)v12, "rootfs"))
            goto LABEL_14;
          v9 = 3;
        }
        else
        {
          v9 = 2;
        }
      }
      else
      {
        v9 = 1;
      }
    }
    else
    {
      v9 = 0;
    }
    qword_1EE805D30 = v9;
  }
LABEL_14:
  if (!dyld_parse_boot_arg_cstr(a1, "ignition_live_app_graft", (char *)v12, 0x40uLL))
    goto LABEL_22;
  if (_platform_strcmp((const char *)v12, "skip"))
  {
    if (_platform_strcmp((const char *)v12, "optional"))
    {
      if (_platform_strcmp((const char *)v12, "require"))
        goto LABEL_22;
      v10 = 2;
    }
    else
    {
      v10 = 1;
    }
  }
  else
  {
    v10 = 0;
  }
  qword_1EE805D38 = v10;
LABEL_22:
  result = dyld_parse_boot_arg_cstr(a1, "ignition_halt_after", (char *)v12, 0x40uLL);
  if ((_DWORD)result)
  {
    result = strlcpy(byte_1EE805D48, (const char *)v12, 0x40uLL);
    qword_1EE805D40 = (uint64_t)byte_1EE805D48;
  }
  _args = (uint64_t)&__args;
  return result;
}

BOOL configuration_init(uint64_t a1, char *a2)
{
  uint64_t v4;
  int v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  pid_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int *v23;
  int v24;
  uint64_t *v25;
  int v26;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  const char *v33;
  int v34;
  int *v35;
  int v36;
  const char **v37;
  const char *v38;
  uint64_t v39;
  _BYTE **v40;
  _BYTE *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _BOOL8 result;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  int v56;
  int v57;
  char v58[1024];
  char __source[16];
  __int128 v60;
  __int128 v61;
  __int128 v62;
  unint64_t v63;
  size_t v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  int v73;
  size_t v74;
  char __s1[16];
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  uint64_t v91;

  v63 = 0;
  v62 = 0u;
  v61 = 0u;
  v60 = 0u;
  *(_OWORD *)__source = 0u;
  bzero(v58, 0x400uLL);
  ignition_test_BRA(1);
  __config[0] = a1;
  v4 = 0x36Fu;
  LOBYTE(__config[v4]) = getpid() == 1;
  _derive_proc_name(a1, byte_1ECCECCE8);
  qword_1ECCECCE0 = (uint64_t)byte_1ECCECCE8;
  if (!LOBYTE(__config[v4]))
    goto LABEL_60;
  v91 = 0;
  v90 = 0u;
  v89 = 0u;
  v88 = 0u;
  v87 = 0u;
  v86 = 0u;
  v85 = 0u;
  v84 = 0u;
  v83 = 0u;
  v82 = 0u;
  v81 = 0u;
  v80 = 0u;
  v79 = 0u;
  v78 = 0u;
  v77 = 0u;
  v76 = 0u;
  *(_OWORD *)__s1 = 0u;
  v74 = 256;
  v73 = -1431699456;
  v72 = 0u;
  v71 = 0u;
  v70 = 0u;
  v69 = 0u;
  v68 = 0u;
  v67 = 0u;
  v66 = 0u;
  v65 = 0u;
  v64 = 132;
  v5 = sysctlbyname("security.mac.img4.ignition_blob", &v65, &v64, 0, 0);
  v6 = __error();
  if (v5 < 0)
  {
    if (!*v6)
      goto LABEL_75;
  }
  else
  {
    *v6 = 0;
  }
  v14 = *__error();
  if (v14 == 2)
  {
    v15 = getpid();
    dlog(-1, "libignition: %d: ignition blob not available\n", v16, v17, v18, v19, v20, v21, v15);
  }
  else
  {
    if (v14)
    {
      v50 = *__error();
      v57 = *__error();
      v55 = "failed to query ignition blob: %d";
      goto LABEL_83;
    }
    xmmword_1ECCEE7D8 = v71;
    unk_1ECCEE7E8 = v72;
    dword_1ECCEE7F8 = v73;
    xmmword_1ECCEE798 = v67;
    unk_1ECCEE7A8 = v68;
    xmmword_1ECCEE7B8 = v69;
    unk_1ECCEE7C8 = v70;
    xmmword_1ECCEE778 = v65;
    unk_1ECCEE788 = v66;
    qword_1ECCEE800 = (uint64_t)&xmmword_1ECCEE778;
    qword_1ECCEE768 = (uint64_t)&unk_1ECCEE78A;
  }
  __s1[0] = 0;
  v74 = 256;
  v22 = sysctlbyname("hw.osenvironment", __s1, &v74, 0, 0);
  v23 = __error();
  if (v22 < 0)
  {
    if (!*v23)
      goto LABEL_75;
  }
  else
  {
    *v23 = 0;
  }
  v24 = *__error();
  if ((v24 - 1) >= 2 && v24 != 22)
  {
    if (v24)
    {
      v50 = *__error();
      v57 = *__error();
      v55 = "failed to read os environment: %d";
      goto LABEL_83;
    }
    if (_platform_strcmp(__s1, (const char *)&unk_1A5CBE413))
    {
      strlcpy(byte_1ECCECE20, __s1, 0x40uLL);
      qword_1ECCECDE8 = (uint64_t)byte_1ECCECE20;
      v25 = &qword_1ECCECDF0;
      if (_platform_strcmp(__s1, "kcgen"))
      {
        if (_platform_strcmp(__s1, "fvunlock"))
        {
          if (_platform_strcmp(__s1, "recoveryos"))
          {
            if (_platform_strcmp(__s1, "diagnostics"))
            {
              if (_platform_strcmp(__s1, "migration"))
              {
                if (_platform_strcmp(__s1, "eacs"))
                  goto LABEL_28;
                v25 = &qword_1ECCECE18;
              }
              else
              {
                v25 = &qword_1ECCECE10;
              }
            }
            else
            {
              v25 = &qword_1ECCECE08;
            }
          }
          else
          {
            v25 = &qword_1ECCECE00;
          }
        }
        else
        {
          v25 = &qword_1ECCECDF8;
        }
      }
      *v25 = qword_1ECCECDE8;
    }
  }
LABEL_28:
  __s1[0] = 0;
  v74 = 256;
  v26 = sysctlbyname("hw.target", __s1, &v74, 0, 0);
  v27 = __error();
  if (v26 < 0)
  {
    if (!*v27)
      goto LABEL_75;
  }
  else
  {
    *v27 = 0;
  }
  v32 = *__error();
  if (v32 != 2)
  {
    if (v32 == 1)
    {
      v33 = "unknownap";
      goto LABEL_39;
    }
    if (v32)
    {
      v50 = *__error();
      v57 = *__error();
      v55 = "failed to query hardware target: %d";
      goto LABEL_83;
    }
    if (v74 >= 0x40)
      ignition_halt((void *)6, 0, 0x40uLL, "hardware target string too long: actual = %lu, expected < %lu", v28, v29, v30, v31, v74);
    if (v74 >= 2)
    {
      dyld_tolower_cstr(__s1, (uint64_t)byte_1ECCEE810, v74);
      goto LABEL_40;
    }
  }
  v33 = "x86legacyap";
LABEL_39:
  strlcpy(byte_1ECCEE810, v33, 0x40uLL);
LABEL_40:
  qword_1ECCEE808 = (uint64_t)byte_1ECCEE810;
  v34 = fsctl("/", 0x40084A6AuLL, &v91, 0);
  v35 = __error();
  if (v34 < 0)
  {
    if (*v35)
      goto LABEL_43;
LABEL_75:
    dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v7, v8, v9, v10, v11, v12, v13, (int)"ret");
  }
  *v35 = 0;
LABEL_43:
  v36 = *__error();
  if (v36 != 25 && v36 != 1)
  {
    if (!v36)
    {
      qword_1ECCEDED8 = v91;
      goto LABEL_47;
    }
    v50 = *__error();
    v57 = *__error();
    v55 = "failed to query root device status: %d";
LABEL_83:
    ignition_halt((void *)6, v50, 0x40uLL, v55, v51, v52, v53, v54, v57);
  }
LABEL_47:
  if (statfs64("/", &stru_1ECCEDEE8))
  {
    v50 = *__error();
    v57 = *__error();
    v55 = "statfs failed: %d";
    goto LABEL_83;
  }
  qword_1ECCEE760 = (uint64_t)&stru_1ECCEDEE8;
  v37 = *(const char ***)(a1 + 16);
  if (v37)
  {
    if (_simple_getenv(v37, "XPC_USERSPACE_REBOOTED"))
      byte_1ECCEE852 = 1;
    v38 = _simple_getenv(*(const char ***)(a1 + 16), "XPC_USERSPACE_PIVOTEDROOT");
    if (v38)
    {
      strlcpy(byte_1ECCEDAD0, v38, 0x400uLL);
      qword_1ECCEDAC8 = (uint64_t)byte_1ECCEDAD0;
    }
  }
  v39 = *(unsigned int *)(a1 + 4);
  if ((int)v39 >= 1)
  {
    v40 = *(_BYTE ***)(a1 + 8);
    do
    {
      v41 = *v40;
      if (**v40 == 45)
        v41 = *v40 + 1;
      if (*v41 == 115)
        byte_1ECCEE851 = 1;
      ++v40;
      --v39;
    }
    while (v39);
  }
LABEL_60:
  if (dyld_parse_boot_arg_cstr(a2, "rd", __source, 0x40uLL))
  {
    strlcpy(byte_1ECCECE70, __source, 0x40uLL);
    qword_1ECCECE60 = (uint64_t)byte_1ECCECE70;
    if (!_platform_strcmp(__source, "md0"))
      qword_1ECCECE68 = (uint64_t)byte_1ECCECE70;
  }
  if (dyld_parse_boot_arg_cstr(a2, "arp0", v58, 0x400uLL))
  {
    strlcpy(byte_1ECCECEB8, v58, 0x400uLL);
    qword_1ECCECEB0 = (uint64_t)byte_1ECCECEB8;
  }
  if (dyld_parse_boot_arg_cstr(a2, "rp", v58, 0x400uLL))
  {
    strlcpy(byte_1ECCED2C0, v58, 0x400uLL);
    qword_1ECCED2B8 = (uint64_t)byte_1ECCED2C0;
  }
  if (dyld_parse_boot_arg_cstr(a2, "rp0", v58, 0x400uLL))
  {
    strlcpy(byte_1ECCED6C8, v58, 0x400uLL);
    qword_1ECCED6C0 = (uint64_t)byte_1ECCED6C8;
  }
  if (dyld_parse_boot_arg_int(a2, "rootdmg-ramdisk", &v63))
  {
    if (HIDWORD(v63))
      dyld_halt("value not representable as uint32_t", v42, v43, v44, v45, v46, v47, v48, v56);
    dword_1ECCEDED0 = v63;
  }
  result = dyld_parse_boot_arg_int(a2, "restore", 0);
  if (result)
    byte_1ECCEDED4 = 1;
  dword_1ECCEDEE0 = MEMORY[0xFFFFF4084];
  _config = (uint64_t)__config;
  return result;
}

BOOL dyld_parse_boot_arg_int(char *a1, const char *a2, unint64_t *a3)
{
  __int128 v4;
  const char *v5;
  _BOOL8 v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  int v13;
  unsigned int v14;
  unint64_t v15;
  __int128 v17;
  unint64_t v18;
  char __dst[4];
  unint64_t v20;

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17 = v4;
  v18 = 0xAAAAAAAAAAAAAAAALL;
  v5 = (const char *)&v17;
  v6 = dyld_parse_boot_arg_cstr(a1, a2, (char *)&v17, 0x18uLL);
  if (!v6)
    return v6;
  if (strstr((char *)&v17, "0x") == (char *)&v17)
    v5 = (char *)&v17 + 2;
  if (!a3)
    return v6;
  v7 = _platform_strlen(v5);
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v20 = 0;
  while (1)
  {
    strcpy(__dst, "00");
    if (v7 == 1)
    {
      v13 = v5[v10];
      __dst[0] = v5[v10];
      __dst[1] = 48;
      v8 += 4;
      v11 = 1;
    }
    else
    {
      if (!v7)
      {
        v11 = 0;
        v12 = 0;
        v8 += 8;
        goto LABEL_16;
      }
      strlcpy(__dst, &v5[v10], 3uLL);
      v13 = __dst[0];
      v11 = 2;
    }
    v12 = v13 - 48;
    if ((v13 - 48) >= 0xA)
    {
      if ((v13 - 97) > 5)
      {
        if ((v13 - 65) > 5)
          goto LABEL_23;
        v12 = v13 - 55;
      }
      else
      {
        v12 = v13 - 87;
      }
    }
LABEL_16:
    v14 = __dst[1] - 48;
    if (v14 >= 0xA)
      break;
LABEL_21:
    *((_BYTE *)&v20 + v9) = v14 | (16 * v12);
    v7 -= v11;
    v10 += v11;
    if (++v9 == 8)
    {
      v15 = bswap64(v20) >> v8;
      goto LABEL_24;
    }
  }
  if (__dst[1] - 97 <= 5)
  {
    LOBYTE(v14) = __dst[1] - 87;
    goto LABEL_21;
  }
  if (__dst[1] - 65 <= 5)
  {
    LOBYTE(v14) = __dst[1] - 55;
    goto LABEL_21;
  }
LABEL_23:
  v15 = 0;
LABEL_24:
  *a3 = v15;
  return v6;
}

ssize_t arguments_dump()
{
  ssize_t result;
  pid_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  pid_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  pid_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  pid_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  result = getpid();
  if ((int)result <= 1)
  {
    v1 = getpid();
    dlog(-1, "libignition: %d: %s   :\n", v2, v3, v4, v5, v6, v7, v1);
    v8 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v9, v10, v11, v12, v13, v14, v8);
    v15 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v16, v17, v18, v19, v20, v21, v15);
    v22 = getpid();
    return dlog(-1, "libignition: %d:   %s : %s\n", v23, v24, v25, v26, v27, v28, v22);
  }
  return result;
}

uint64_t _open_console()
{
  uint64_t v0;

  v0 = dword_1ECCECC40;
  if (dword_1ECCECC40 < 0 && getpid() == 1)
  {
    v0 = open("/dev/console", 131073);
    dword_1ECCECC40 = v0;
  }
  return v0;
}

uint64_t _hello_fire(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  pid_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  configuration(a1, a2, a3, a4, a5, a6, a7, a8);
  v8 = getpid();
  getpid();
  dlog(-1, "libignition: %d: %12s: hello from %s.%d\n", v9, v10, v11, v12, v13, v14, v8);
  return 0;
}

uint64_t _graft_select_fire(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v5;
  int dylib_root;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  pid_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  pid_t v45;
  pid_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  pid_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  pid_t v67;
  int v68;
  stat v69;
  char v70;
  char v71[1023];

  v5 = a3[4];
  dylib_root = boot_get_dylib_root((uint64_t)a3);
  bzero(&v70, 0x400uLL);
  memset(&v69, 0, sizeof(v69));
  if (dylib_root < 0)
  {
    v30 = getpid();
    dlog(-1, "libignition: %d: %12s: cryptex graft point not present; not using fallback\n",
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v30);
    return 0;
  }
  ignition_get_shared_cache_directory(&v70, v7, v8, v9, v10, v11, v12, v13);
  if (v71[0] == 47)
    dyld_halt("bogus shared cache path: %s", v14, v15, v16, v17, v18, v19, v20, (int)&v70);
  v21 = fstatat64(dylib_root, v71, &v69, 0);
  v22 = __error();
  if (v21 < 0)
  {
    if (!*v22)
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v23, v24, v25, v26, v27, v28, v29, (int)"ret");
  }
  else
  {
    *v22 = 0;
  }
  v37 = *__error();
  if (v37 != 2)
  {
    if (v37)
    {
      v45 = getpid();
      __error();
      v67 = v45;
      v44 = "libignition: %d: %12s: failed to stat dylib cache directory: %d\n";
    }
    else
    {
      if ((v69.st_mode & 0xF000) != 0x4000)
        goto LABEL_14;
      v67 = getpid();
      v44 = "libignition: %d: %12s: dylib cache directory present; not overriding\n";
    }
    v5 = -1;
    dlog(-1, v44, v38, v39, v40, v41, v42, v43, v67);
  }
LABEL_14:
  switch(*(_QWORD *)(a2 + 8))
  {
    case 0:
      v46 = getpid();
      dlog(-1, "libignition: %d: %12s: not forcing root fallback\n", v47, v48, v49, v50, v51, v52, v46);
      if ((v5 & 0x80000000) == 0)
        goto LABEL_21;
      return 0;
    case 1:
      v5 = a3[8];
      if ((v5 & 0x80000000) == 0)
        goto LABEL_21;
      return 0;
    case 2:
      v5 = a3[11];
      goto LABEL_20;
    case 3:
      v5 = a3[4];
      if (v5 < 0)
        return 0;
      goto LABEL_21;
    default:
LABEL_20:
      if ((v5 & 0x80000000) == 0)
      {
LABEL_21:
        v53 = getpid();
        dlog(-1, "libignition: %d: %12s: overriding os cryptex root: %s\n", v54, v55, v56, v57, v58, v59, v53);
        v68 = dupfd(v5, (int)"fallback root");
        boot_set_dylib_root((uint64_t)a3, &v68, v60, v61, v62, v63, v64, v65);
      }
      break;
  }
  return 0;
}

int fstatat64(int a1, const char *a2, stat *a3, int a4)
{
  char v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  int64_t v9;

  v9 = mac_syscall(SYS_fstatat64, *(void **)&a1, (void *)a2, a3, *(void **)&a4, v5, v6, v7, v8);
  if (v4)
    LODWORD(v9) = cerror_nocancel(v9);
  return v9;
}

uint64_t _goodbye_fire()
{
  return 0;
}

uint64_t _dylib_cache_payload_check(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if ((*(_QWORD *)(a1 + 32) & 0x8000000000000000) != 0)
    return 0;
  v8 = *(_QWORD *)(a1 + 24);
  if (v8 < 0)
    dyld_halt("invalid offset: %lld", a2, a3, a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 24));
  return a2 + v8;
}

char *_derive_proc_name(uint64_t a1, char *a2)
{
  const char *v4;
  char *v5;
  char *v6;
  const char *v7;

  v4 = _simple_getenv(*(const char ***)(a1 + 24), "executable_path");
  if (v4)
  {
    v5 = (char *)v4;
LABEL_5:
    v6 = strrchr(v5, 47);
    goto LABEL_6;
  }
  if (*(_DWORD *)(a1 + 4))
  {
    v5 = **(char ***)(a1 + 8);
    goto LABEL_5;
  }
  v6 = 0;
  v5 = "unknown proc";
LABEL_6:
  if (v6)
    v7 = v6 + 1;
  else
    v7 = v5;
  strlcpy(a2, v7, 0xFFuLL);
  return a2;
}

dyld4::SyscallDelegate::DyldCommPage *dyld4::SyscallDelegate::DyldCommPage::DyldCommPage(dyld4::SyscallDelegate::DyldCommPage *this)
{
  bzero(this, 8uLL);
  return this;
}

char *dyld4::ProcessConfig::Process::getMainUnrealPath(const char ***this, dyld4::SyscallDelegate *a2, lsl::Allocator *a3)
{
  const char *v6;
  int v7;
  char __dst[1024];

  v6 = _simple_getenv(this[15], "executable_path");
  if (!v6)
    v6 = *this[13];
  v7 = *(unsigned __int8 *)v6;
  if (v7 != 47)
  {
    if (v7 == 46)
      v6 += 2 * (v6[1] == 47);
    if (dyld4::SyscallDelegate::getCWD(a2, __dst))
    {
      strlcat(__dst, "/", 0x400uLL);
      strlcat(__dst, v6, 0x400uLL);
      return lsl::Allocator::strdup(a3, __dst);
    }
  }
  return (char *)v6;
}

uint64_t dyld4::ProcessConfig::Process::getMainPlatform(dyld4::ProcessConfig::Process *this)
{
  _DWORD *v2;
  const char *v3;
  const char *v4;
  int v5;
  const char *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t VersionSetEquivalent;
  uint64_t v12;
  _QWORD v14[6];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;

  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 12) = 0;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v2 = *(_DWORD **)this;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = ___ZN5dyld413ProcessConfig7Process15getMainPlatformEv_block_invoke;
  v14[3] = &unk_1E4F7BF38;
  v14[4] = &v15;
  v14[5] = this;
  dyld3::MachOFile::forEachSupportedPlatform(v2, (uint64_t)v14);
  if (*((_DWORD *)v16 + 6) != 1)
    goto LABEL_20;
  v3 = _simple_getenv(*((const char ***)this + 14), "DYLD_FORCE_PLATFORM");
  if (!v3)
    goto LABEL_20;
  v4 = v3;
  if (!dyld3::MachOFile::allowsAlternatePlatform(*(dyld3::MachOFile **)this))
    goto LABEL_20;
  v5 = *(unsigned __int8 *)v4;
  if (v5 == 54)
  {
    v7 = 6;
    goto LABEL_9;
  }
  if (v5 == 50)
  {
    v6 = dyld3::MachOFile::archName(*(dyld3::MachOFile **)this);
    if (!_platform_strcmp(v6, "arm64"))
    {
      v7 = 2;
LABEL_9:
      *((_DWORD *)v16 + 6) = v7;
    }
  }
  v8 = 0;
  while (dyld3::sVersionMap[v8 + 1] != *((_DWORD *)this + 10))
  {
    v8 += 9;
    if (v8 == 423)
      goto LABEL_15;
  }
  *((_DWORD *)this + 10) = dyld3::sVersionMap[v8 + 2];
LABEL_15:
  v9 = 0;
  while (dyld3::sVersionMap[v9 + 1] != *((_DWORD *)this + 12))
  {
    v9 += 9;
    if (v9 == 423)
      goto LABEL_20;
  }
  *((_DWORD *)this + 12) = dyld3::sVersionMap[v9 + 2];
LABEL_20:
  v10 = dyld3::MachOFile::basePlatform(*((unsigned int *)v16 + 6));
  *((_DWORD *)this + 14) = v10;
  VersionSetEquivalent = dyld4::ProcessConfig::Process::findVersionSetEquivalent(v10, v10, *((_DWORD *)this + 10));
  *((_DWORD *)this + 11) = VersionSetEquivalent;
  *((_DWORD *)this + 13) = dyld4::ProcessConfig::Process::findVersionSetEquivalent(VersionSetEquivalent, *((unsigned int *)this + 14), *((_DWORD *)this + 12));
  v12 = *((unsigned int *)v16 + 6);
  _Block_object_dispose(&v15, 8);
  return v12;
}

dyld4::ProcessConfig::Process *dyld4::ProcessConfig::Process::getDyldFileID(const char ***this)
{
  dyld4::ProcessConfig::Process *result;

  result = (dyld4::ProcessConfig::Process *)_simple_getenv(this[15], "dyld_file");
  if (result)
    return (dyld4::ProcessConfig::Process *)dyld4::ProcessConfig::Process::fileIDFromFileHexStrings(result, (const char *)result);
  return result;
}

dyld4::ProcessConfig::Process *dyld4::ProcessConfig::Process::getMainFileID(const char ***this)
{
  dyld4::ProcessConfig::Process *result;

  result = (dyld4::ProcessConfig::Process *)_simple_getenv(this[15], "executable_file");
  if (result)
    return (dyld4::ProcessConfig::Process *)dyld4::ProcessConfig::Process::fileIDFromFileHexStrings(result, (const char *)result);
  return result;
}

uint64_t dyld4::ProcessConfig::Process::fileIDFromFileHexStrings(dyld4::ProcessConfig::Process *this, const char *a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v5;

  v5 = 0;
  v2 = hexToUInt64(a2, (const char **)&v5);
  if (!v5)
    return 0;
  v3 = v2;
  hexToUInt64(v5 + 1, (const char **)&v5);
  if (v5)
    return v3;
  else
    return 0;
}

uint64_t hexToUInt64(const char *a1, const char **a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned __int8 v5;

  if (!a1)
    return 0;
  if (*a1 == 48)
    a1 += 2 * (a1[1] == 120);
  if (a2)
    *a2 = a1 + 16;
  v2 = 0;
  v3 = 0;
  while (1)
  {
    v4 = a1[v2];
    v5 = v4 - 48;
    if ((v4 - 48) >= 0xA)
      break;
LABEL_12:
    v3 = 16 * v3 + v5;
    if (++v2 == 16)
      return v3;
  }
  if ((v4 - 65) <= 5)
  {
    v5 = v4 - 55;
    goto LABEL_12;
  }
  if ((v4 - 97) <= 5)
  {
    v5 = v4 - 87;
    goto LABEL_12;
  }
  if (a2)
    *a2 = &a1[v2];
  return v3;
}

const char *dyld3::MachOFile::archName(dyld3::MachOFile *this)
{
  uint64_t v1;
  int v2;
  int v3;
  const char *result;

  v1 = 0;
  v2 = *((_DWORD *)this + 1);
  v3 = *((_DWORD *)this + 2) & 0xFFFFFF;
  result = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v1 + 1]) != v2
       || v3 != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v1 + 3))
  {
    v1 += 2;
    if (v1 == 26)
      return result;
  }
  return (&dyld3::MachOFile::_s_archInfos)[v1];
}

char *dyld4::ProcessConfig::Process::getMainPath(dyld4::ProcessConfig::Process *this, dyld4::SyscallDelegate *a2, lsl::Allocator *a3)
{
  fsid_t v6;
  uint64_t v7;
  char __s[1024];

  v6 = (fsid_t)*((_QWORD *)this + 3);
  if (v6)
  {
    v7 = *((_QWORD *)this + 4);
    if (v7)
    {
      if (dyld4::SyscallDelegate::fsgetpath(a2, __s, 0x400uLL, v6, v7) != -1)
        return lsl::Allocator::strdup(a3, __s);
    }
  }
  if (dyld4::SyscallDelegate::realpath(a2, *((dyld3 **)this + 2), __s))
    return lsl::Allocator::strdup(a3, __s);
  else
    return (char *)*((_QWORD *)this + 2);
}

char *dyld4::ProcessConfig::Process::getDyldPath(fsid_t *this, dyld4::SyscallDelegate *a2, lsl::Allocator *a3)
{
  fsid_t v3;
  uint64_t v4;
  char __s[1024];

  v3 = this[9];
  if (*(_QWORD *)&v3
    && (v4 = (uint64_t)this[10]) != 0
    && dyld4::SyscallDelegate::fsgetpath(a2, __s, 0x400uLL, v3, v4) != -1)
  {
    return lsl::Allocator::strdup(a3, __s);
  }
  else
  {
    return "/usr/lib/dyld";
  }
}

void *dyld3::GradedArchs::forCurrentOS(dyld3::GradedArchs *this)
{
  return &dyld3::GradedArchs::arm64;
}

void dyld_halt(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  vm_address_t v10;
  const char *v11;
  _BYTE **v12;

  v10 = _simple_salloc();
  if (v10)
  {
    v12 = (_BYTE **)v10;
    _simple_vsprintf(v10, a1, &a9);
    v11 = (const char *)_simple_string(v12);
  }
  else
  {
    v11 = "panic: [failed to allocate panic message]";
  }
  if (getpid() == 1)
    syscall(55, 3072, v11);
  qword_1EE805DD0 = (uint64_t)v11;
  __break(1u);
  JUMPOUT(0x1A5C82F58);
}

uint64_t dyld4::APIs::dyld_shared_cache_iterate_text(dyld4::RuntimeState *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7;

  if (*(_BYTE *)(*((_QWORD *)a1 + 1) + 204))
    dyld4::RuntimeState::log(a1, "dyld_shared_cache_iterate_text()\n");
  v7 = 0;
  return (*(uint64_t (**)(dyld4::RuntimeState *, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a1 + 528))(a1, a2, &v7, a3);
}

uint64_t dyld4::APIs::dyld_shared_cache_find_iterate_text(dyld4::RuntimeState *a1, dyld4::RuntimeState *a2, char **a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v9;
  DyldSharedCache *CacheInDirAndMap;
  BOOL v11;
  uint64_t v12;
  char *v13;
  unint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t *v18;
  char *v19;
  char **v20;
  char *v21;
  uint64_t result;
  _QWORD v23[6];
  _QWORD v24[5];
  size_t v25;
  __n128 v26;
  uint64_t v27;
  uint64_t v28;

  v9 = *((_QWORD *)a1 + 1);
  if (*(_BYTE *)(v9 + 204))
  {
    dyld4::RuntimeState::log(a1, "dyld_shared_cache_find_iterate_text()\n");
    v9 = *((_QWORD *)a1 + 1);
  }
  v25 = 0;
  CacheInDirAndMap = *(DyldSharedCache **)(v9 + 240);
  if (!CacheInDirAndMap
    || ((v26 = 0uLL, DyldSharedCache::getUUID(CacheInDirAndMap, &v26), v26.n128_u64[0] == *(_QWORD *)a2)
      ? (v11 = v26.n128_u64[1] == *((_QWORD *)a2 + 1))
      : (v11 = 0),
        !v11))
  {
    CacheInDirAndMap = (DyldSharedCache *)dyld4::findCacheInDirAndMap(a1, a2, "/System/Library/Caches/com.apple.dyld/", (const char *)&v25, a5);
    if (!CacheInDirAndMap)
    {
      v12 = 0;
      while (1)
      {
        v13 = cryptexPrefixes[v12];
        v26.n128_u8[0] = 0;
        if (dyld4::Utils::concatenatePaths((dyld4::Utils *)&v26, v13, (const char *)0x400) <= 0x3FF
          && dyld4::Utils::concatenatePaths((dyld4::Utils *)&v26, "/System/Library/Caches/com.apple.dyld/", (const char *)0x400) <= 0x3FF)
        {
          v15 = dyld4::findCacheInDirAndMap(a1, a2, (char *)&v26, (const char *)&v25, v14);
          if (v15)
            break;
        }
        if (++v12 == 3)
        {
          CacheInDirAndMap = (DyldSharedCache *)dyld4::findCacheInDirAndMap(a1, a2, "/System/DriverKit/System/Library/dyld/", (const char *)&v25, v14);
          if (CacheInDirAndMap)
            goto LABEL_26;
          v16 = 0;
          while (1)
          {
            v17 = cryptexPrefixes[v16];
            v26.n128_u8[0] = 0;
            if (dyld4::Utils::concatenatePaths((dyld4::Utils *)&v26, v17, (const char *)0x400) <= 0x3FF
              && dyld4::Utils::concatenatePaths((dyld4::Utils *)&v26, "/System/DriverKit/System/Library/dyld/", (const char *)0x400) <= 0x3FF)
            {
              v15 = dyld4::findCacheInDirAndMap(a1, a2, (char *)&v26, (const char *)&v25, v18);
              if (v15)
                goto LABEL_25;
            }
            if (++v16 == 3)
            {
              v19 = *a3;
              if (!*a3)
                return 0xFFFFFFFFLL;
              v20 = a3 + 1;
              while (1)
              {
                v15 = dyld4::findCacheInDirAndMap(a1, a2, v19, (const char *)&v25, v18);
                if (v15)
                  break;
                v21 = *v20++;
                v19 = v21;
                result = 0xFFFFFFFFLL;
                if (!v21)
                  return result;
              }
              goto LABEL_25;
            }
          }
        }
      }
LABEL_25:
      CacheInDirAndMap = (DyldSharedCache *)v15;
    }
  }
LABEL_26:
  v26.n128_u64[0] = 0;
  v26.n128_u64[1] = (unint64_t)&v26;
  v27 = 0x2000000000;
  v28 = 0;
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 0x40000000;
  v24[2] = ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke;
  v24[3] = &unk_1E4F7DC48;
  v24[4] = &v26;
  DyldSharedCache::forEachRegion((uint64_t)CacheInDirAndMap, (uint64_t)v24);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  v23[2] = ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke_2;
  v23[3] = &unk_1E4F7DC70;
  v23[4] = a4;
  v23[5] = &v26;
  DyldSharedCache::forEachImageTextSegment((uint64_t)CacheInDirAndMap, (uint64_t)v23);
  if (v25)
    munmap(CacheInDirAndMap, v25);
  _Block_object_dispose(&v26, 8);
  return 0;
}

void start(dyld4::KernelArgs *a1, unsigned int *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  __darwin_time_t Slide;
  const char **Envp;
  const char **Apple;
  const char *v14;
  uint64_t v15;
  const dyld3::MachOFile *v16;
  char v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  uint64_t v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  stat *v32;
  int v33;
  uint64_t v34;
  unsigned __int8 (*st_ino)[16];
  fsobj_id st_dev;
  fsid v37;
  fsobj_id v38;
  fsid v39;
  uint64_t v40;
  uint64_t v41;
  lsl::Lock *v42;
  lsl::Lock *v43;
  lsl::Lock *v44;
  void *v45;
  size_t v46;
  const char **v47;
  DyldSharedCache *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const char **v54;
  const char *v55;
  const dyld3::MachOFile *v56;
  fsobj_id v57;
  unsigned __int8 *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  const char **v63;
  const char **v64;
  lsl::Allocator *v65;
  lsl::Lock *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  const void *v70;
  _QWORD v71[6];
  int *v72;
  dyld4::KernelArgs *v73;
  unint64_t v74;
  unint64_t v75;
  DyldSharedCache *v76;
  uint64_t v77;
  uint64_t (*v78)(uint64_t, uint64_t);
  void *v79;
  lsl::Lock **v80;
  uint64_t v81;
  char v82;
  lsl::Lock *v83;
  lsl::Lock **v84;
  uint64_t v85;
  void *v86;
  void (*v87)(uint64_t);
  stat *v88;
  __int128 v89;
  stat v90;

  v73 = a1;
  dyld3::kdebug_trace_dyld_marker((void *)0x1F070034, 0, 0, 0, 0, 0, 0, a8, 0, 0);
  v72 = &dword_1A5C55000;
  if ((dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)&dword_1A5C55000) & 1) == 0)
  {
    if ((dyld3::MachOFile::hasChainedFixups((dyld3::MachOFile *)&dword_1A5C55000) & 1) == 0)
      goto LABEL_44;
    Slide = dyld3::MachOLoaded::getSlide((dyld3::MachOLoaded *)&dword_1A5C55000);
    v83 = 0;
    v84 = &v83;
    v85 = 0x3002000000;
    v86 = __Block_byref_object_copy_;
    v87 = __Block_byref_object_dispose_;
    Diagnostics::Diagnostics((Diagnostics *)&v88);
    *(_QWORD *)&v90.st_dev = _NSConcreteStackBlock;
    v90.st_ino = 0x40000000;
    *(_QWORD *)&v90.st_uid = ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke;
    *(_QWORD *)&v90.st_rdev = &unk_1E4F7BE38;
    v90.st_atimespec.tv_sec = (__darwin_time_t)&v83;
    v90.st_atimespec.tv_nsec = (uint64_t)&dword_1A5C55000;
    v90.st_mtimespec.tv_sec = Slide;
    dyld3::MachOAnalyzer::withChainStarts((char *)&dword_1A5C55000, (vm_address_t *)v84 + 5, 0, (uint64_t)&v90);
    Diagnostics::assertNoError((Diagnostics *)(v84 + 5));
    v76 = (DyldSharedCache *)_NSConcreteStackBlock;
    v77 = 0x40000000;
    v78 = ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke_2;
    v79 = &__block_descriptor_tmp_4;
    v80 = (lsl::Lock **)Slide;
    dyld3::MachOFile::forEachSegment(&dword_1A5C55000, (uint64_t)&v76);
    _Block_object_dispose(&v83, 8);
    mach_o::Error::~Error((vm_address_t **)&v88);
    a3 = 0;
    a2 = 0;
  }
  mach_init();
  Envp = (const char **)dyld4::KernelArgs::findEnvp(a1);
  Apple = (const char **)dyld4::KernelArgs::findApple(a1);
  v14 = _simple_getenv(Apple, "vm_force_4k_pages");
  if (v14 && *v14 == 49)
    vm_page_size = 4096;
  lsl::MemoryManager::MemoryManager((lsl::MemoryManager *)&v90, Envp, Apple, a3);
  lsl::MemoryManager::lockGuard((lsl::Lock *)&v90, &v83);
  v15 = *(_QWORD *)&v90.st_rdev;
  if (!*(_QWORD *)&v90.st_rdev)
  {
    lsl::MemoryManager::writeProtect((lsl::MemoryManager *)&v90, 0);
    v15 = *(_QWORD *)&v90.st_rdev;
  }
  *(_QWORD *)&v90.st_rdev = v15 + 1;
  lsl::Lock::unlock(v83);
  __guard_setup(Apple);
  lsl::MemoryManager::lockGuard((lsl::Lock *)&v90, &v83);
  if (!--*(_QWORD *)&v90.st_rdev)
    lsl::MemoryManager::writeProtect((lsl::MemoryManager *)&v90, 1);
  lsl::Lock::unlock(v83);
  _subsystem_init(Apple);
  if (dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)&dword_1A5C55000))
  {
    mach_port_mod_refs(mach_task_self_, mach_task_self_, 0, -1);
    v17 = dyld4::ExternallyViewableState::switchToDyldInDyldCache((dyld4::ExternallyViewableState *)&dword_1A5C55000, v16);
    if (kdebug_is_enabled(0x1F050014u, v18, v19, v20, v21, v22, v23, v24))
    {
      v83 = 0;
      v84 = 0;
      dyld3::MachOFile::getUuid((dyld3::MachOFile *)&dword_1A5C55000, (unsigned __int8 *)&v83);
      v33 = dyld3::stat((dyld3 *)"/usr/lib/dyld", &v90, v32);
      if (v33)
        st_ino = 0;
      else
        st_ino = (unsigned __int8 (*)[16])v90.st_ino;
      if (v33)
        st_dev = 0;
      else
        st_dev = (fsobj_id)v90.st_dev;
      v37 = (fsid)a2;
      dyld3::kdebug_trace_dyld_image((dyld3 *)5, "/usr/lib/dyld", (void **)&v83, st_ino, st_dev, v37, (const void *)a2[2], v34, v70);
    }
    if (kdebug_is_enabled(0x1F050000u, v25, v26, v27, v28, v29, v30, v31))
    {
      *(_QWORD *)&v90.st_dev = 0;
      v90.st_ino = 0;
      dyld3::MachOFile::getUuid((dyld3::MachOFile *)&dword_1A5C55000, (unsigned __int8 *)&v90);
      v38 = 0;
      v39 = (fsid)&dword_1A5C55000;
      dyld3::kdebug_trace_dyld_image(0, "/usr/lib/dyld", (void **)&v90, 0, v38, v39, 0, v40, v70);
    }
    v83 = 0;
    v84 = &v83;
    v85 = 0x4002000000;
    v86 = __Block_byref_object_copy__7;
    v87 = (void (*)(uint64_t))__Block_byref_object_dispose__8;
    v88 = &v90;
    v89 = xmmword_1A5CBAC40;
    v41 = dyld3::MachOLoaded::getSlide((dyld3::MachOLoaded *)a2);
    v76 = (DyldSharedCache *)_NSConcreteStackBlock;
    v77 = 0x40000000;
    v78 = ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke;
    v79 = &unk_1E4F7BE80;
    v82 = v17;
    v80 = &v83;
    v81 = v41;
    dyld3::MachOFile::forEachSegment(a2, (uint64_t)&v76);
    v42 = v84[7];
    if (v42)
    {
      v43 = v84[5];
      v44 = (lsl::Lock *)((char *)v43 + 16 * (_QWORD)v42);
      do
      {
        v45 = *(void **)v43;
        v46 = *((_QWORD *)v43 + 1);
        v43 = (lsl::Lock *)((char *)v43 + 16);
        munmap(v45, v46);
      }
      while (v43 != v44);
    }
    _Block_object_dispose(&v83, 8);
  }
  else
  {
    v47 = (const char **)dyld4::KernelArgs::findEnvp(a1);
    if (!_simple_getenv(v47, "DYLD_SHARED_REGION"))
    {
      *(_QWORD *)&v90.st_dev = 0;
      v90.st_ino = 0;
      if (dyld3::MachOFile::getUuid((dyld3::MachOFile *)&dword_1A5C55000, (unsigned __int8 *)&v90))
      {
        v75 = 0;
        v76 = 0;
        v74 = 0;
        if (dyld4::SyscallDelegate::hasExistingDyldCache((dyld4::SyscallDelegate *)&dyld4::sSyscallDelegate, (unint64_t *)&v76, &v75, &v74))
        {
          v48 = v76;
          v49 = DyldSharedCache::slide(v76);
          v50 = *((_QWORD *)v48 + 15);
          if (v50)
          {
            v51 = v49;
            v52 = v50 + v49;
            v83 = 0;
            v84 = 0;
            if (dyld3::MachOFile::getUuid((dyld3::MachOFile *)(v50 + v49), (unsigned __int8 *)&v83)
              && *(lsl::Lock **)&v90.st_dev == v83
              && v90.st_ino == (_QWORD)v84)
            {
              v54 = (const char **)dyld4::KernelArgs::findEnvp(a1);
              v55 = _simple_getenv(v54, "DYLD_IN_CACHE");
              if (!v55 || _platform_strcmp(v55, "0"))
              {
                dyld4::ExternallyViewableState::switchDyldLoadAddress(v52, v56);
                v57 = (fsobj_id)v75;
                dyld3::kdebug_trace_dyld_cache((unsigned __int8 (*)[16])v74, v57, v76, (char *)v48 + 88, v58, v59, v60, v61);
                dyld4::restartWithDyldInCache(a1, (const dyld4::KernelArgs *)&dword_1A5C55000, v48, (const DyldSharedCache *)(*((_QWORD *)v48 + 16) + v51), v62);
              }
            }
          }
        }
      }
    }
  }
  dyld4::RuntimeLocks::RuntimeLocks((dyld4::RuntimeLocks *)&v90);
  v63 = (const char **)dyld4::KernelArgs::findEnvp(a1);
  v64 = (const char **)dyld4::KernelArgs::findApple(a1);
  lsl::PreallocatedAllocatorLayout<278528ull>::init((lsl::AllocatorLayout *)&dyld4::preallocator, v63, v64, a3);
  v65 = (lsl::Allocator *)lsl::AllocatorLayout::allocator((lsl::AllocatorLayout *)&dyld4::preallocator);
  v75 = 0;
  v76 = 0;
  v66 = (lsl::Lock *)lsl::Allocator::memoryManager(v65);
  v71[0] = v65;
  v71[1] = &v73;
  v71[2] = &v76;
  v71[3] = &v90;
  v71[4] = &v72;
  v71[5] = &v75;
  lsl::MemoryManager::lockGuard(v66, &v83);
  v67 = *((_QWORD *)v66 + 3);
  if (!v67)
  {
    lsl::MemoryManager::writeProtect(v66, 0);
    v67 = *((_QWORD *)v66 + 3);
  }
  *((_QWORD *)v66 + 3) = v67 + 1;
  lsl::Lock::unlock(v83);
  dyld4::start(dyld4::KernelArgs *,void *,void *)::$_0::operator()((uint64_t)v71);
  lsl::MemoryManager::lockGuard(v66, &v83);
  v68 = *((_QWORD *)v66 + 3) - 1;
  *((_QWORD *)v66 + 3) = v68;
  if (!v68)
    lsl::MemoryManager::writeProtect(v66, 1);
  lsl::Lock::Guard::~Guard(&v83);
  v69 = ((uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))v75)(*(unsigned int *)(*((_QWORD *)v76 + 1) + 104), *(_QWORD *)(*((_QWORD *)v76 + 1) + 112), *(_QWORD *)(*((_QWORD *)v76 + 1) + 120), *(_QWORD *)(*((_QWORD *)v76 + 1) + 128));
  (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)v76 + 19) + 120))(*((_QWORD *)v76 + 19), v69);
LABEL_44:
  __assert_rtn("rebaseSelf", "dyldMain.cpp", 1115, "dyldMA->hasChainedFixups()");
}

int __munmap(void *a1, size_t a2)
{
  char v2;
  int result;

  result = mac_syscall(SYS_munmap, a1, a2);
  if (v2)
    return cerror_nocancel(result);
  return result;
}

_QWORD *dyld4::KernelArgs::findApple(dyld4::KernelArgs *this)
{
  _QWORD *result;

  result = (_QWORD *)((char *)this + 8 * *((_QWORD *)this + 1) + 24);
  while (*result++)
    ;
  return result;
}

uint64_t mach_init()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  if ((mach_init_mach_init_inited & 1) == 0)
  {
    mach_task_self_ = task_self_trap();
    _task_reply_port = mach_reply_port();
    if (!vm_kernel_page_shift)
      vm_kernel_page_shift = MEMORY[0xFFFFF4037];
    if (!vm_page_shift)
    {
      vm_page_shift = MEMORY[0xFFFFF4025];
      vm_page_size = 1 << MEMORY[0xFFFFF4025];
      vm_page_mask = vm_page_size - 1;
    }
    _pthread_set_self(0, v0, v1, v2, v3, v4, v5, v6);
    mach_init_mach_init_inited = 1;
  }
  return 0;
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  kern_return_t v8;
  uint64_t reply_port;
  kern_return_t v10;
  mach_msg_header_t v13;
  uint64_t v14;
  mach_port_name_t v15;
  mach_port_right_t v16;
  mach_port_delta_t v17;

  v8 = _kernelrpc_mach_port_mod_refs_trap(task, name, right, delta);
  if (v8 == 268435459)
  {
    v14 = 0x100000000;
    v15 = name;
    v16 = right;
    v17 = delta;
    reply_port = mig_get_reply_port();
    *(_QWORD *)&v13.msgh_bits = 0x2C00001513;
    *(_QWORD *)&v13.msgh_remote_port = __PAIR64__(reply_port, task);
    *(_QWORD *)&v13.msgh_voucher_port = 0xC8800000000;
    v10 = mach_msg2_internal(&v13, 0x200000003uLL, (void *)0x2C00001513, (void *)__PAIR64__(reply_port, task), (void *)0xC8800000000, (void *)(reply_port << 32), (void *)0x2C, 0);
    v8 = v10;
    if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
    {
      if (v10)
      {
        mig_dealloc_reply_port(v13.msgh_local_port);
        return v8;
      }
      if (v13.msgh_id == 71)
      {
        v8 = -308;
      }
      else if (v13.msgh_id == 3308)
      {
        v8 = -300;
        if ((v13.msgh_bits & 0x80000000) == 0 && *(_QWORD *)&v13.msgh_size == 36)
        {
          v8 = v15;
          if (!v15)
            return v8;
        }
      }
      else
      {
        v8 = -301;
      }
      mach_msg_destroy(&v13);
    }
  }
  return v8;
}

int64_t _thread_set_tsd_base(void *a1)
{
  return mac_syscall(MACHDEP_SYSCALL_TRAP, 2, a1);
}

const char *_subsystem_init(const char **a1)
{
  const char *result;

  result = _simple_getenv(a1, "subsystem_root_path");
  if (result)
    subsystem_root_path = (uint64_t)result;
  return result;
}

uint64_t _pthread_set_self_dyld(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result;

  result = __thread_selfid(a1, a2, a3, a4, a5, a6, a7, a8);
  qword_1ECCEE998 = result;
  if (result == -1)
  {
    qword_1EE805DD0 = (uint64_t)"BUG IN LIBPTHREAD: failed to set thread_id";
    __break(1u);
  }
  else
  {
    qword_1ECCEE9A0 = (uint64_t)&_main_thread;
    unk_1ECCEE9A8 = &unk_1ECCEE96C;
    return _thread_set_tsd_base(&qword_1ECCEE9A0);
  }
  return result;
}

int64_t __thread_selfid(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  int64_t result;

  result = mac_syscall(SYS_thread_selfid, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror(result, a2, a3, a4, a5, a6, a7, a8);
  return result;
}

uint64_t _pthread_set_self(_QWORD *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result;

  if (!a1)
    return _pthread_set_self_dyld(0, a2, a3, a4, a5, a6, a7, a8);
  result = __thread_selfid(a1, a2, a3, a4, a5, a6, a7, a8);
  a1[27] = result;
  if (result != -1)
    return _thread_set_tsd_base(a1 + 28);
  qword_1EE805DD0 = (uint64_t)"BUG IN LIBPTHREAD: failed to set thread_id";
  __break(1u);
  return result;
}

uint64_t __guard_setup(_QWORD *a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t result;
  char v5;
  unsigned __int8 *v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v1 = *a1;
  if (*a1)
  {
    v2 = a1;
    v3 = __stack_chk_guard;
    while (1)
    {
      result = _platform_strncmp((const char *)v1, "stack_guard=", 0xCuLL);
      if (!(_DWORD)result)
      {
        v5 = *(_BYTE *)(v1 + 12);
        if (v5)
        {
          v6 = (unsigned __int8 *)(v1 + 13);
          do
          {
            v7 = v5;
            v8 = (v5 - 97);
            v9 = v7 - 48;
            if ((v7 - 48) >= 0xA)
              v9 = 0;
            if ((v7 - 65) <= 5)
              v10 = v7 - 55;
            else
              v10 = v9;
            v11 = v7 - 87;
            if (v8 <= 5)
              v12 = v11;
            else
              v12 = v10;
            v3 = v12 | (16 * v3);
            __stack_chk_guard = v3;
            v13 = *v6++;
            v5 = v13;
          }
          while (v13);
        }
        if (v3)
          break;
      }
      v14 = v2[1];
      ++v2;
      v1 = v14;
      if (!v14)
        goto LABEL_17;
    }
  }
  else
  {
LABEL_17:
    v15 = arc4random();
    result = arc4random();
    __stack_chk_guard = result | (unint64_t)(v15 << 32);
  }
  return result;
}

double dyld4::ExternallyViewableState::setDyld(uint64_t a1, lsl::Allocator *a2, uint64_t a3)
{
  mach_header *v6;
  unsigned int **v7;
  void *v8;
  _BYTE v10[8];
  uint64_t v11;
  lsl::Allocator *v12;
  dyld4::Atlas::Mapper *v13;
  uint64_t v14;
  void *v15;
  char v16;
  _BYTE v17[80];

  v6 = *(mach_header **)(a3 + 24);
  dyld4::ExternallyViewableState::ensureSnapshot((uint64_t *)a1, a2);
  if (dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)v6)
    && *(_QWORD *)dyld4::Atlas::ProcessSnapshot::sharedCache(*(dyld4::Atlas::ProcessSnapshot **)a1))
  {
    dyld4::Atlas::ProcessSnapshot::addSharedCacheImage(*(_QWORD *)a1, v6);
  }
  else
  {
    dyld4::recordFromInfo(a2, *(dyld4::FileManager **)(a1 + 8), a3, (uint64_t)v17);
    v7 = (unsigned int **)dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
    dyld4::Atlas::Image::Image((uint64_t)v10, (uint64_t)a2, (dyld4::FileRecord *)v17, v7, *(_QWORD *)(a3 + 24));
    dyld4::Atlas::ProcessSnapshot::addImage(*(lsl::Allocator ***)a1, (dyld4::Atlas::Image *)v10);
    v8 = v15;
    if (v15 && v16)
      dyld4::Atlas::Mapper::unmap(v13, (unint64_t)v15, v14);
    if (v12)
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock *)v12, v8);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v11);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v17);
  }
  return dyld4::ExternallyViewableState::setDyldOld((dyld4::ExternallyViewableState *)a1, a3);
}

const os_unfair_lock *dyld4::ExternallyViewableState::commit(const os_unfair_lock *this, lsl::Allocator *a2, lsl::Allocator *a3, lsl::Allocator *a4)
{
  dyld4::ExternallyViewableState::commit(this, *(dyld4::Atlas::ProcessSnapshot **)&this->_os_unfair_lock_opaque, a2, a4);
  return dyld4::ExternallyViewableState::release(this, a3);
}

const os_unfair_lock *dyld4::ExternallyViewableState::setInitialImageCount(dyld4::ExternallyViewableState *this, unsigned int a2)
{
  unint64_t v3;
  const os_unfair_lock *v4;

  v3 = a2;
  dyld4::Atlas::ProcessSnapshot::setInitialImageCount(*(_QWORD *)this, a2);
  v4 = (const os_unfair_lock *)*((_QWORD *)this + 4);
  *(_QWORD *)(*((_QWORD *)this + 3) + 112) = v3;
  return lsl::Vector<dyld_image_info>::resize(v4, v3);
}

uint64_t dyld4::Atlas::ProcessSnapshot::setInitialImageCount(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 88) = a2;
  return this;
}

void dyld4::ExternallyViewableState::setSharedCacheInfo(uint64_t a1, lsl::Allocator *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  void *v11;
  uint64_t v12;
  DyldSharedCache *v13;
  _BYTE v14[8];
  dyld4::Atlas::Mapper *v15[15];
  void *v16;
  char v17;
  lsl::Allocator *v18;
  _BYTE v19[80];

  dyld4::recordFromInfo(a2, *(dyld4::FileManager **)(a1 + 8), a4, (uint64_t)v19);
  if (dyld4::FileRecord::exists((dyld4::FileRecord *)v19))
  {
    v10 = dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
    dyld4::Atlas::SharedCache::SharedCache(v14, a2, v19, v10, *(_QWORD *)(a4 + 24), a5);
    dyld4::Atlas::ProcessSnapshot::addSharedCache(*(_QWORD *)a1, (uint64_t)v14);
    if (v18)
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock *)v18, v11);
    if (v16 && v17)
      dyld4::Atlas::Mapper::unmap(v15[13], (unint64_t)v16, (uint64_t)v15[14]);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v15);
  }
  v12 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v12 + 152) = a3;
  v13 = *(DyldSharedCache **)(a4 + 24);
  *(_QWORD *)(v12 + 176) = v13;
  *(_OWORD *)(v12 + 288) = *(_OWORD *)a4;
  *(_BYTE *)(v12 + 24) = a5;
  if (v13)
    DyldSharedCache::getUUID(v13, (__n128 *)(v12 + 160));
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v19);
}

BOOL dyld4::APIs::_dyld_get_shared_cache_uuid(dyld4::APIs *this, __n128 *a2)
{
  uint64_t v3;
  uint64_t v5;

  v3 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v3 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_get_shared_cache_uuid(%p)\n", a2);
    v3 = *((_QWORD *)this + 1);
  }
  v5 = *(_QWORD *)(v3 + 240);
  if (v5)
    DyldSharedCache::getUUID(*(DyldSharedCache **)(v3 + 240), a2);
  return v5 != 0;
}

__n128 DyldSharedCache::getUUID(DyldSharedCache *this, __n128 *a2)
{
  __n128 result;

  result = *(__n128 *)((char *)this + 88);
  *a2 = result;
  return result;
}

BOOL dyld4::FileRecord::exists(dyld4::FileRecord *this)
{
  dyld4::FileRecord::stat((uint64_t)this);
  return *((_DWORD *)this + 17) == 0;
}

uint64_t dyld4::FileRecord::stat(uint64_t this)
{
  uint64_t v1;
  int v2;
  const char *Path;
  __darwin_time_t tv_sec;
  uint64_t v5;
  int v6;
  uint64_t v8;
  stat v9;

  if (*(_DWORD *)(this + 68) == 1)
  {
    v1 = this;
    v2 = *(_DWORD *)(this + 64);
    if (v2 == -1)
    {
      Path = (const char *)dyld4::FileRecord::getPath((dyld4::FileRecord *)v1);
      this = stat64(Path, &v9);
    }
    else
    {
      this = fstat64(v2, &v9);
    }
    *(_DWORD *)(v1 + 68) = this;
    if (!(_DWORD)this)
    {
      tv_sec = v9.st_mtimespec.tv_sec;
      *(_QWORD *)(v1 + 48) = v9.st_size;
      *(_QWORD *)(v1 + 56) = tv_sec;
      *(_WORD *)(v1 + 72) = v9.st_mode;
      if (!*(_QWORD *)(v1 + 8))
      {
        v5 = 24;
        do
        {
          v6 = *(unsigned __int8 *)(v1 + v5);
          if (*(_BYTE *)(v1 + v5))
            break;
        }
        while (v5++ != 39);
        if (!v6)
        {
          *(_QWORD *)(v1 + 8) = v9.st_ino;
          this = dyld4::FileManager::uuidForFileSystem(*(dyld4::FileManager **)v1, v9.st_dev);
          *(_QWORD *)(v1 + 24) = this;
          *(_QWORD *)(v1 + 32) = v8;
        }
      }
    }
  }
  return this;
}

uint64_t *dyld4::Atlas::ProcessSnapshot::addSharedCache(uint64_t a1, uint64_t a2)
{
  const os_unfair_lock **v3;
  void *v4;
  const os_unfair_lock *v5;
  lsl::Allocator *v6;
  uint64_t v7;
  os_unfair_lock *v8;
  void *v9;
  const os_unfair_lock **v10;
  const os_unfair_lock *v11;
  const os_unfair_lock *v13;

  v3 = (const os_unfair_lock **)(a1 + 64);
  lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,dyld4::Atlas::SharedCache>(*(lsl::Allocator **)a1, a2, &v13);
  if (&v13 != v3)
  {
    v5 = *v3;
    *v3 = v13;
    v13 = v5;
  }
  lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr(&v13, v4);
  v6 = *(lsl::Allocator **)a1;
  v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 128) + 144);
  v8 = (os_unfair_lock *)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)a1, 8uLL, 0x10uLL);
  *(_QWORD *)&v8->_os_unfair_lock_opaque = v7;
  *(_QWORD *)&v8[2]._os_unfair_lock_opaque = lsl::Allocator::malloc(v6, (unint64_t)(v7 + 7) >> 3);
  v13 = v8;
  v10 = (const os_unfair_lock **)(a1 + 56);
  if (&v13 != (const os_unfair_lock **)(a1 + 56))
  {
    v11 = *v10;
    *v10 = v8;
    v13 = v11;
  }
  return lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v13, v9);
}

void dyld4::ExternallyViewableState::addImageInfo(uint64_t a1, lsl::Allocator *a2, uint64_t a3)
{
  unsigned int **v6;
  uint64_t v7;
  dyld4::FileRecord *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  mach_header *v13;
  void *v14;
  char *v15;
  mach_header *v16;
  _BYTE v17[8];
  uint64_t v18;
  lsl::Allocator *v19;
  dyld4::Atlas::Mapper *v20;
  uint64_t v21;
  void *v22;
  char v23;
  _BYTE v24[80];

  dyld4::recordFromInfo(a2, *(dyld4::FileManager **)(a1 + 8), a3, (uint64_t)v24);
  v6 = (unsigned int **)dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
  dyld4::Atlas::Image::Image((uint64_t)v17, (uint64_t)a2, (dyld4::FileRecord *)v24, v6, *(_QWORD *)(a3 + 24));
  dyld4::Atlas::ProcessSnapshot::addImage(*(lsl::Allocator ***)a1, (dyld4::Atlas::Image *)v17);
  v7 = mach_absolute_time();
  v8 = (dyld4::FileRecord *)dyld4::Atlas::Image::file((dyld4::Atlas::Image *)v17);
  v9 = dyld4::FileRecord::mtime(v8);
  dyld4::ExternallyViewableState::addImageInfoOld((dyld4::ExternallyViewableState *)a1, (int8x16_t *)a3, v7, v9);
  if (*(_DWORD *)(*(_QWORD *)(a1 + 24) + 200) == 1229016646)
  {
    v13 = *(mach_header **)(a3 + 24);
    v15 = *(char **)(a3 + 16);
    v16 = v13;
    dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges((dyld4::ExternallyViewableState *)a1, 0, 1, (const mach_header **)&v16, (const char **)&v15, v10, v11, v12);
  }
  v14 = v22;
  if (v22 && v23)
    dyld4::Atlas::Mapper::unmap(v20, (unint64_t)v22, v21);
  if (v19)
    lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock *)v19, v14);
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v18);
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v24);
}

uint64_t dyld4::Atlas::Image::file(dyld4::Atlas::Image *this)
{
  return (uint64_t)this + 8;
}

uint64_t dyld4::FileRecord::mtime(dyld4::FileRecord *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 7);
  if (!result)
  {
    dyld4::FileRecord::stat((uint64_t)this);
    return *((_QWORD *)this + 7);
  }
  return result;
}

uint64_t dyld4::ExternallyViewableState::addImageInfoOld(dyld4::ExternallyViewableState *a1, int8x16_t *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int8x16_t *v11;
  uint64_t v12;
  __n128 v13;
  int8x16_t v15;

  atomic_store(0, (unint64_t *)(*((_QWORD *)a1 + 3) + 8));
  v8 = *((_QWORD *)a1 + 4);
  v15 = a2[1];
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(v8, *(_QWORD *)(v8 + 16) + 1);
  v9 = *(_QWORD *)(v8 + 8);
  v10 = *(_QWORD *)(v8 + 16);
  *(_QWORD *)(v8 + 16) = v10 + 1;
  v11 = (int8x16_t *)(v9 + 24 * v10);
  *v11 = vextq_s8(v15, v15, 8uLL);
  v11[1].i64[0] = a4;
  v12 = *((_QWORD *)a1 + 3);
  *(_DWORD *)(v12 + 4) = *(_QWORD *)(*((_QWORD *)a1 + 4) + 16);
  atomic_store(a3, (unint64_t *)(v12 + 184));
  atomic_store(*(_QWORD *)(*((_QWORD *)a1 + 4) + 8), (unint64_t *)(*((_QWORD *)a1 + 3) + 8));
  v13 = dyld4::ExternallyViewableState::addImageUUID(a1, (const dyld3::MachOFile *)a2[1].i64[1]);
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, __n128))(*((_QWORD *)a1 + 3) + 16))(0, 1, *(_QWORD *)(*((_QWORD *)a1 + 4) + 8) + 24 * *(_QWORD *)(*((_QWORD *)a1 + 4) + 16) - 24, v13);
}

__n128 dyld4::ExternallyViewableState::addImageUUID(dyld4::ExternallyViewableState *this, const dyld3::MachOFile *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __n128 *v6;
  __n128 result;
  uint64_t v8;
  uint64_t v9;
  __n128 v10;
  unint64_t v11;

  v10.n128_u64[0] = (unint64_t)a2;
  dyld3::MachOFile::getUuid(a2, &v10.n128_u8[8]);
  *(_QWORD *)(*((_QWORD *)this + 3) + 96) = 0;
  v3 = *((_QWORD *)this + 5);
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(v3, *(_QWORD *)(v3 + 16) + 1);
  v4 = *(_QWORD *)(v3 + 8);
  v5 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(v3 + 16) = v5 + 1;
  v6 = (__n128 *)(v4 + 24 * v5);
  result = v10;
  v6[1].n128_u64[0] = v11;
  *v6 = result;
  v8 = *((_QWORD *)this + 5);
  v9 = *((_QWORD *)this + 3);
  *(_QWORD *)(v9 + 88) = *(_QWORD *)(v8 + 16);
  *(_QWORD *)(v9 + 96) = *(_QWORD *)(v8 + 8);
  return result;
}

double dyld4::ExternallyViewableState::setDyldOld(dyld4::ExternallyViewableState *a1, uint64_t a2)
{
  const dyld3::MachOFile *v3;
  double result;

  v3 = *(const dyld3::MachOFile **)(a2 + 24);
  *(_QWORD *)(*((_QWORD *)a1 + 3) + 192) = *(_QWORD *)(a2 + 16);
  if ((dyld3::MachOFile::inDyldCache(v3) & 1) == 0)
    *(_QWORD *)&result = dyld4::ExternallyViewableState::addImageUUID(a1, v3).n128_u64[0];
  return result;
}

dyld4::ProcessConfig *dyld4::ProcessConfig::ProcessConfig(dyld4::ProcessConfig *this, const dyld4::KernelArgs *a2, dyld4::SyscallDelegate *a3, lsl::Allocator *a4)
{
  const char ***v7;
  dyld4::ProcessConfig::PathOverrides *v8;

  v7 = (const char ***)((char *)this + 8);
  dyld4::ProcessConfig::Process::Process((dyld4::ProcessConfig *)((char *)this + 8), a2, a3, a4);
  dyld4::ProcessConfig::Security::Security((dyld4::ProcessConfig *)((char *)this + 168), v7, a3);
  dyld4::ProcessConfig::Logging::Logging((uint64_t)this + 200, (uint64_t)v7, (uint64_t)this + 168, a3);
  dyld4::ProcessConfig::DyldCache::DyldCache((uint64_t)this + 240, (uint64_t)v7, (dyld4::ProcessConfig *)((char *)this + 168), (uint64_t)this + 200, a3, a4);
  v8 = (dyld4::ProcessConfig::PathOverrides *)dyld4::ProcessConfig::PathOverrides::PathOverrides((uint64_t)this + 400, (uint64_t)v7, (dyld4::ProcessConfig *)((char *)this + 168), (uint64_t)this + 200, (uint64_t)this + 240, (uint64_t)a3, a4);
  if (dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp(v8))
    *((_BYTE *)this + 399) = 1;
  return this;
}

uint64_t dyld4::ProcessConfig::DyldCache::DyldCache(uint64_t a1, uint64_t a2, const dyld4::ProcessConfig::Security *a3, uint64_t a4, dyld4::PrebuiltLoader *a5, lsl::Allocator *a6)
{
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  const char *v15;
  const char *v16;
  BOOL v17;
  char v18;
  BOOL v19;
  size_t *v20;
  size_t DyldCache;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  DyldSharedCache *v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  unsigned int *v35;
  fsid_t v36;
  uint64_t v37;
  char *v38;
  char *v40;
  _QWORD v41[5];
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  uint64_t v46[2];
  char v47;
  __int128 v48;
  int v49;
  dyld4::SyscallDelegate *v50[6];
  int v51;
  char __s[8];
  uint64_t v53;
  uint64_t (*v54)(uint64_t, uint64_t);
  void *v55;
  uint64_t v56;
  uint64_t v57;
  dyld4::PrebuiltLoader *v58;
  int v59;

  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  v12 = *(_QWORD *)(a2 + 88);
  dyld4::CacheFinder::CacheFinder((uint64_t)v50, a2, a4, (uint64_t)a5);
  if (*(_DWORD *)(a2 + 144) == 1)
  {
    if (*((_BYTE *)a3 + 1))
    {
      v13 = ((unint64_t)(*(_QWORD *)(a2 + 88) | v12) >> 2) & 1;
      v14 = (*(_QWORD *)(a2 + 88) & 5) == 1;
    }
    else
    {
      LOBYTE(v13) = 0;
      v14 = 1;
    }
  }
  else
  {
    v14 = v12 & 1;
    v13 = (v12 >> 2) & 1;
  }
  v15 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_SHARED_REGION");
  v16 = v15;
  v17 = 0;
  LODWORD(v48) = v50[0];
  if (*((_BYTE *)a3 + 19) && v15)
    v17 = _platform_strcmp(v15, "private") == 0;
  BYTE4(v48) = v17;
  v18 = dyld4::PrebuiltLoader::hiddenFromFlat(a5);
  v19 = 0;
  BYTE5(v48) = v18;
  WORD3(v48) = *(unsigned __int8 *)(a4 + 1);
  BYTE8(v48) = *(_BYTE *)(a2 + 150);
  BYTE9(v48) = v14;
  BYTE10(v48) = v13;
  BYTE11(v48) = *(_BYTE *)(a2 + 148);
  if (*(int *)(a2 + 156) >= 2)
    v19 = !dyld4::SyscallDelegate::sandboxBlockedPageInLinking(a5);
  BYTE12(v48) = v19;
  v49 = *(_DWORD *)(a2 + 60);
  *(_QWORD *)a1 = 0;
  *(_WORD *)(a1 + 156) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 159) = 1;
  *(_BYTE *)(a1 + 158) = v17;
  *(_OWORD *)(a1 + 40) = 0u;
  v20 = (size_t *)(a1 + 40);
  *(_QWORD *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  v42 = 0;
  v43 = 0;
  v45 = 0;
  v44 = 0;
  v46[0] = 0;
  v46[1] = 0;
  v47 = 0;
  DyldCache = (size_t)dyld4::SyscallDelegate::getDyldCache((uint64_t)a5, &v48, (uint64_t)&v42);
  v29 = v42;
  if (v42)
  {
    *(_QWORD *)a1 = v42;
    *(_OWORD *)(a1 + 8) = *(_OWORD *)v46;
    *(_BYTE *)(a1 + 156) = v47;
    *(_BYTE *)(a1 + 157) = *(_BYTE *)(v29 + 221) & 1;
    *(_QWORD *)(a1 + 24) = v43;
    dyld4::ProcessConfig::DyldCache::setPlatformOSVersion((dyld4::ProcessConfig::DyldCache *)a1, (const dyld4::ProcessConfig::Process *)a2);
    *(_QWORD *)(a1 + 32) = DyldSharedCache::unslidLoadAddress(*(DyldSharedCache **)a1);
    *(_QWORD *)(a1 + 48) = DyldSharedCache::objcHeaderInfoRO(*(DyldSharedCache **)a1);
    *(_QWORD *)(a1 + 56) = DyldSharedCache::objcHeaderInfoRW(*(DyldSharedCache **)a1);
    *(_QWORD *)(a1 + 64) = DyldSharedCache::objcSelectorHashTable(*(DyldSharedCache **)a1);
    *(_QWORD *)(a1 + 72) = DyldSharedCache::objcClassHashTable(*(DyldSharedCache **)a1);
    *(_QWORD *)(a1 + 80) = DyldSharedCache::objcProtocolHashTable(*(DyldSharedCache **)a1);
    *(_QWORD *)(a1 + 104) = DyldSharedCache::swiftOpt(*(DyldSharedCache **)a1);
    *(_DWORD *)(a1 + 152) = DyldSharedCache::imagesCount(*(DyldSharedCache **)a1);
    *(_QWORD *)(a1 + 112) = 0;
    v30 = *(_QWORD *)(a1 + 48);
    v31 = *(DyldSharedCache **)a1;
    if (v30)
      *(_QWORD *)(a1 + 112) = v30 - (_QWORD)v31 + *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 120) = 0;
    v32 = DyldSharedCache::patchTable(v31);
    v33 = *(char **)a1;
    v34 = *(_QWORD *)(*(_QWORD *)a1 + 152);
    *(_QWORD *)(a1 + 128) = v32;
    *(_QWORD *)(a1 + 136) = v34;
    if (!BYTE8(v48))
    {
      *(_QWORD *)__s = _NSConcreteStackBlock;
      v53 = 0x40000000;
      v54 = ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke;
      v55 = &__block_descriptor_tmp_67;
      v56 = a1;
      v57 = a4;
      v59 = 19;
      v58 = a5;
      DyldSharedCache::forEachCache(v33, (uint64_t)__s);
    }
    if (!_simple_getenv(*(const char ***)(a2 + 120), "dyld_hw_tpro") || vm_page_size != 0x4000 || *(_BYTE *)(a1 + 158))
    {
      v35 = *(unsigned int **)a1;
      v41[0] = _NSConcreteStackBlock;
      v41[1] = 0x40000000;
      v41[2] = ___ZN5dyld413ProcessConfig9DyldCacheC2ERNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke;
      v41[3] = &__block_descriptor_tmp_52;
      v41[4] = a1;
      DyldSharedCache::forEachTPRORegion(v35, (uint64_t)v41);
    }
    if (!*(_BYTE *)(a1 + 156))
      *(_BYTE *)(a1 + 159) = 0;
    v36 = (fsid_t)v46[0];
    if (v46[0] && v46[1])
    {
      DyldCache = dyld4::SyscallDelegate::fsgetpath(a5, __s, 0x400uLL, v36, v46[1]);
      if (DyldCache != -1)
      {
        DyldCache = (size_t)lsl::Allocator::strdup(a6, __s);
        *v20 = DyldCache;
      }
      goto LABEL_31;
    }
    v40 = "dyld shared region dynamic config data was not set\n";
LABEL_39:
    dyld4::halt(v40, 0);
  }
  if (v45)
    DyldCache = dyld4::console((dyld4 *)"dyld cache '%s' not loaded: %s\n", v22, *v20, v44);
  if (v16)
  {
    DyldCache = _platform_strcmp(v16, "private");
    if (!(_DWORD)DyldCache && !v45)
    {
      v40 = "dyld private shared cache could not be found\n";
      goto LABEL_39;
    }
  }
LABEL_31:
  v37 = v51;
  if (v51 != -1)
  {
    DyldCache = dyld4::SyscallDelegate::getpath(a5, v51, __s);
    if ((_DWORD)DyldCache)
    {
      v38 = lsl::Allocator::strdup(a6, __s);
      DyldCache = _platform_strlen(v38);
      *(_QWORD *)(a1 + 88) = v38;
      *(_QWORD *)(a1 + 96) = DyldCache;
    }
  }
  if (*(_DWORD *)(a2 + 144) == 1)
    dyld4::ProcessConfig::DyldCache::setupDyldCommPage((dyld4::ProcessConfig::DyldCache *)DyldCache, (dyld4::ProcessConfig::Process *)a2, a3, a5);
  dyld4::CacheFinder::~CacheFinder(v50, v37, v23, v24, v25, v26, v27, v28);
  return a1;
}

ssize_t dyld4::SyscallDelegate::fsgetpath(dyld4::SyscallDelegate *this, char *a2, size_t a3, fsid_t a4, uint64_t a5)
{
  fsid_t v6;

  v6 = a4;
  return fsgetpath(a2, a3, &v6, a5);
}

ssize_t fsgetpath(char *a1, size_t a2, fsid_t *a3, uint64_t a4)
{
  char v4;
  ssize_t result;

  result = mac_syscall(SYS_fsgetpath, a1, a2, a3, a4);
  if (v4)
    return cerror_nocancel(result);
  return result;
}

BOOL dyld4::SyscallDelegate::getpath(dyld4::SyscallDelegate *this, int a2, char *a3)
{
  return fcntl(a2, 50, a3) == 0;
}

DyldSharedCache *dyld4::SyscallDelegate::getDyldCache(uint64_t a1, __int128 *a2, uint64_t a3)
{
  DyldSharedCache *result;
  fsobj_id v5;
  unsigned __int8 *v6;
  void *v7;
  void *v8;
  void *v9;
  __int128 v10;
  int v11;
  __n128 v12;

  v10 = *a2;
  v11 = *((_DWORD *)a2 + 4);
  BYTE5(v10) = 0;
  dyld3::loadDyldCache((uint64_t)&v10, (_QWORD *)a3);
  result = *(DyldSharedCache **)a3;
  if (*(_QWORD *)a3)
  {
    v12 = 0uLL;
    DyldSharedCache::getUUID(result, &v12);
    v5 = *(fsobj_id *)(a3 + 32);
    return (DyldSharedCache *)dyld3::kdebug_trace_dyld_cache(*(unsigned __int8 (**)[16])(a3 + 40), v5, *(void **)a3, &v12, v6, v7, v8, v9);
  }
  return result;
}

uint64_t DyldSharedCache::swiftOpt(DyldSharedCache *this)
{
  uint64_t v2;

  if (*((_DWORD *)this + 4) < 0x181u)
    return 0;
  v2 = *((_QWORD *)this + 47);
  if (v2)
    return (uint64_t)this + v2;
  else
    return 0;
}

dyld3::MachOLoaded *DyldSharedCache::objcSelectorHashTable(DyldSharedCache *this)
{
  dyld3::MachOLoaded *result;
  uint64_t v2;
  char *v3;
  BOOL v4;
  uint64_t v5;

  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    v5 = *(_QWORD *)((char *)this + *((_QWORD *)this + 58) + 24);
    v3 = (char *)this + v5;
    v4 = v5 == 0;
  }
  else
  {
    result = DyldSharedCache::oldObjcOpt(this);
    if (!result)
      return result;
    v2 = *((int *)result + 2);
    v3 = (char *)result + v2;
    v4 = (_DWORD)v2 == 0;
  }
  if (v4)
    return 0;
  else
    return (dyld3::MachOLoaded *)v3;
}

dyld3::MachOLoaded *DyldSharedCache::objcProtocolHashTable(DyldSharedCache *this)
{
  dyld3::MachOLoaded *result;
  uint64_t v2;
  char *v3;
  BOOL v4;
  uint64_t v5;

  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    v5 = *(_QWORD *)((char *)this + *((_QWORD *)this + 58) + 40);
    v3 = (char *)this + v5;
    v4 = v5 == 0;
  }
  else
  {
    result = DyldSharedCache::oldObjcOpt(this);
    if (!result)
      return result;
    v2 = *((int *)result + 9);
    v3 = (char *)result + v2;
    v4 = (_DWORD)v2 == 0;
  }
  if (v4)
    return 0;
  else
    return (dyld3::MachOLoaded *)v3;
}

dyld3::MachOLoaded *DyldSharedCache::objcClassHashTable(DyldSharedCache *this)
{
  dyld3::MachOLoaded *result;
  uint64_t v2;
  char *v3;
  BOOL v4;
  uint64_t v5;

  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    v5 = *(_QWORD *)((char *)this + *((_QWORD *)this + 58) + 32);
    v3 = (char *)this + v5;
    v4 = v5 == 0;
  }
  else
  {
    result = DyldSharedCache::oldObjcOpt(this);
    if (!result)
      return result;
    v2 = *((int *)result + 8);
    v3 = (char *)result + v2;
    v4 = (_DWORD)v2 == 0;
  }
  if (v4)
    return 0;
  else
    return (dyld3::MachOLoaded *)v3;
}

dyld3::MachOLoaded *DyldSharedCache::objcHeaderInfoRW(DyldSharedCache *this)
{
  dyld3::MachOLoaded *result;
  uint64_t v2;
  char *v3;
  BOOL v4;
  uint64_t v5;

  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    v5 = *(_QWORD *)((char *)this + *((_QWORD *)this + 58) + 16);
    v3 = (char *)this + v5;
    v4 = v5 == 0;
  }
  else
  {
    result = DyldSharedCache::oldObjcOpt(this);
    if (!result)
      return result;
    v2 = *((int *)result + 6);
    v3 = (char *)result + v2;
    v4 = (_DWORD)v2 == 0;
  }
  if (v4)
    return 0;
  else
    return (dyld3::MachOLoaded *)v3;
}

dyld3::MachOLoaded *DyldSharedCache::objcHeaderInfoRO(DyldSharedCache *this)
{
  dyld3::MachOLoaded *result;
  uint64_t v2;
  char *v3;
  BOOL v4;
  uint64_t v5;

  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    v5 = *(_QWORD *)((char *)this + *((_QWORD *)this + 58) + 8);
    v3 = (char *)this + v5;
    v4 = v5 == 0;
  }
  else
  {
    result = DyldSharedCache::oldObjcOpt(this);
    if (!result)
      return result;
    v2 = *((int *)result + 3);
    v3 = (char *)result + v2;
    v4 = (_DWORD)v2 == 0;
  }
  if (v4)
    return 0;
  else
    return (dyld3::MachOLoaded *)v3;
}

uint64_t DyldSharedCache::imagesCount(DyldSharedCache *this)
{
  uint64_t v1;

  v1 = 28;
  if (*((_DWORD *)this + 4) > 0x1C3u)
    v1 = 452;
  return *(unsigned int *)((char *)this + v1);
}

uint64_t DyldSharedCache::patchTable(DyldSharedCache *this)
{
  return (uint64_t)this + *((_QWORD *)this + 19) - *(_QWORD *)((char *)this + *((unsigned int *)this + 4));
}

dyld4::ProcessConfig::Security *dyld4::ProcessConfig::Security::Security(dyld4::ProcessConfig::Security *this, const char ***a2, dyld4::SyscallDelegate *a3)
{
  int v6;
  BOOL v7;
  const char *v8;
  unsigned int AMFI;
  int16x8_t v10;
  const char **v11;
  uint64_t v12;
  unsigned int v13;
  _QWORD v15[5];

  v6 = dyld4::SyscallDelegate::internalInstall(a3);
  *((_BYTE *)this + 1) = v6;
  *(_BYTE *)this = v6;
  if (v6)
    v7 = _simple_getenv(a2[14], "DYLD_SKIP_MAIN") != 0;
  else
    v7 = 0;
  *((_BYTE *)this + 25) = v7;
  *((_BYTE *)this + 26) = _simple_getenv(a2[14], "DYLD_JUST_BUILD_CLOSURE") != 0;
  if (*((_DWORD *)a2 + 36) == 1)
  {
    if (*((_BYTE *)this + 1))
    {
      v8 = _simple_getenv(a2[15], "dyld_flags");
      if (v8)
        *((_DWORD *)a2 + 22) = hexToUInt64(v8, 0);
    }
  }
  AMFI = dyld4::ProcessConfig::Security::getAMFI(this, (const dyld4::ProcessConfig::Process *)a2, a3);
  *((_BYTE *)this + 16) = AMFI & 1;
  v10.i64[0] = *(_QWORD *)&vshl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(AMFI) & 0xFF00FF00FF00FFLL), (uint16x4_t)0xFFFDFFFEFFFFFFFCLL) & 0xFF01FF01FF01FF01;
  *(_DWORD *)((char *)this + 17) = vmovn_s16(v10).u32[0];
  *((_BYTE *)this + 21) = (AMFI & 0x20) != 0;
  *((_BYTE *)this + 22) = (AMFI & 0x40) != 0;
  *((_BYTE *)this + 23) = (AMFI & 0x80) != 0;
  *((_BYTE *)this + 24) = BYTE1(AMFI) & 1;
  *((_WORD *)this + 1) = 0;
  *((_QWORD *)this + 1) = 0;
  v11 = *a2;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = ___ZN5dyld413ProcessConfig8SecurityC2ERNS0_7ProcessERNS_15SyscallDelegateE_block_invoke;
  v15[3] = &__block_descriptor_tmp_26;
  v15[4] = this;
  dyld3::MachOFile::forDyldEnv(v11, (uint64_t)v15);
  v13 = *((_DWORD *)a2 + 15);
  if (v13 <= 0xA
    && ((1 << v13) & 0x442) != 0
    && !*((_BYTE *)this + 17)
    && !*((_BYTE *)this + 18)
    && !*((_BYTE *)this + 19))
  {
    dyld4::ProcessConfig::Security::pruneEnvVars(v12, (uint64_t)a2);
  }
  return this;
}

uint64_t dyld4::SyscallDelegate::internalInstall(dyld4::SyscallDelegate *this)
{
  return MEMORY[0xFFFFF4084] & 1;
}

void dyld3::MachOFile::forDyldEnv(_DWORD *a1, uint64_t a2)
{
  _QWORD v4[5];
  vm_address_t *v5;

  Diagnostics::Diagnostics((Diagnostics *)&v5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile10forDyldEnvEU13block_pointerFvPKcRbE_block_invoke;
  v4[3] = &unk_1E4F7EA00;
  v4[4] = a2;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v5, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v5);
  mach_o::Error::~Error(&v5);
}

unint64_t dyld4::ProcessConfig::Security::getAMFI(dyld4::ProcessConfig::Security *this, const dyld4::ProcessConfig::Process *a2, dyld4::SyscallDelegate *a3)
{
  int isRestricted;
  uint64_t isFairPlayEncrypted;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  unint64_t v13;
  uint64_t v14;
  const char *v15;
  BOOL v16;
  unsigned int v18[2];

  *(_QWORD *)v18 = 0;
  isRestricted = dyld3::MachOFile::isRestricted(*(dyld3::MachOFile **)a2);
  isFairPlayEncrypted = dyld3::MachOFile::isFairPlayEncrypted(*(dyld3::MachOFile **)a2, &v18[1], v18);
  v13 = dyld4::SyscallDelegate::amfiFlags(a3, isRestricted, isFairPlayEncrypted, v8, v9, v10, v11, v12);
  v14 = *((_QWORD *)a2 + 11);
  v15 = _simple_getenv(*((const char ***)a2 + 14), "DYLD_AMFI_FAKE");
  if (v15)
    v16 = (v14 & 2) == 0;
  else
    v16 = 1;
  if (!v16 && *((_BYTE *)this + 1))
    return hexToUInt64(v15, 0);
  return v13;
}

uint64_t dyld3::MachOFile::isRestricted(dyld3::MachOFile *this)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile12isRestrictedEv_block_invoke;
  v3[3] = &unk_1E4F7EAE8;
  v3[4] = &v4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t dyld4::ProcessConfig::Logging::Logging(uint64_t a1, uint64_t a2, uint64_t a3, dyld4::SyscallDelegate *a4)
{
  BOOL v8;
  int v9;
  BOOL v10;
  int v11;
  BOOL v12;
  int v13;
  BOOL v14;
  int v15;
  BOOL v16;
  int v17;
  BOOL v18;
  int v19;
  BOOL v20;
  int v21;
  BOOL v22;
  int v23;
  BOOL v24;
  int v25;
  BOOL v26;
  int v27;
  BOOL v28;
  BOOL v29;
  const char *v30;
  int v31;
  const char *v32;
  const char *v33;
  size_t v34;

  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  if (!*(_BYTE *)(a3 + 17))
  {
    *(_BYTE *)(a1 + 1) = 0;
    goto LABEL_14;
  }
  v8 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_SEGMENTS") != 0;
  v9 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 1) = v8;
  if (!v9)
  {
LABEL_14:
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 2) = 0;
    goto LABEL_15;
  }
  v10 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_LIBRARIES") != 0;
  v11 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)a1 = v10;
  if (!v11)
  {
    *(_WORD *)(a1 + 2) = 0;
    goto LABEL_20;
  }
  v12 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_BINDINGS") != 0;
  v13 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 2) = v12;
  if (!v13)
  {
LABEL_15:
    *(_WORD *)(a1 + 3) = 0;
    goto LABEL_16;
  }
  v14 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_INITIALIZERS") != 0;
  v15 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 3) = v14;
  if (!v15)
  {
LABEL_20:
    *(_WORD *)(a1 + 4) = 0;
    goto LABEL_21;
  }
  v16 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_APIS") != 0;
  v17 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 4) = v16;
  if (!v17)
  {
LABEL_16:
    *(_WORD *)(a1 + 5) = 0;
    goto LABEL_17;
  }
  v18 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_NOTIFICATIONS") != 0;
  v19 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 5) = v18;
  if (!v19)
  {
LABEL_21:
    *(_WORD *)(a1 + 6) = 0;
    goto LABEL_22;
  }
  v20 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_INTERPOSING") != 0;
  v21 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 6) = v20;
  if (!v21)
  {
LABEL_17:
    *(_WORD *)(a1 + 7) = 0;
    goto LABEL_18;
  }
  v22 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_LOADERS") != 0;
  v23 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 7) = v22;
  if (!v23)
  {
LABEL_22:
    v28 = 0;
    *(_WORD *)(a1 + 8) = 0;
    goto LABEL_23;
  }
  v24 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_SEARCHING") != 0;
  v25 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 8) = v24;
  if (!v25)
  {
LABEL_18:
    v28 = 0;
    *(_BYTE *)(a1 + 9) = 0;
LABEL_23:
    v29 = 1;
    goto LABEL_24;
  }
  v26 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_ENV") != 0;
  v27 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 9) = v26;
  if (!v27)
  {
    v28 = 0;
    goto LABEL_23;
  }
  v28 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_TO_STDERR") != 0;
  v29 = *(_BYTE *)(a3 + 17) == 0;
LABEL_24:
  *(_BYTE *)(a1 + 16) = v28;
  *(_DWORD *)(a1 + 12) = 2;
  *(_BYTE *)(a1 + 17) = 0;
  if (!v29)
  {
    if (*(_BYTE *)(a3 + 19))
    {
      v30 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_TO_FILE");
      if (v30)
      {
        v31 = dyld4::SyscallDelegate::openLogFile(a4, v30);
        if (v31 != -1)
        {
          *(_BYTE *)(a1 + 17) = 1;
          *(_DWORD *)(a1 + 12) = v31;
        }
      }
    }
  }
  if (*(_BYTE *)(a3 + 17))
  {
    v32 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_LINKS_WITH");
    if (v32)
    {
      v33 = v32;
      v34 = _platform_strlen(v32);
      *(_QWORD *)(a1 + 24) = v33;
      *(_QWORD *)(a1 + 32) = v34;
    }
  }
  return a1;
}

const char *_simple_getenv(const char **a1, char *__s)
{
  size_t v4;
  size_t v5;
  const char *result;
  const char *v7;
  size_t v8;
  const char *v9;
  char *v10;
  const char *v11;

  v4 = _platform_strlen(__s);
  if (!a1)
    return 0;
  v5 = v4;
  result = *a1;
  if (!*a1)
    return result;
  while (1)
  {
    if (_platform_strlen(result) >= v5)
    {
      v7 = *a1;
      if (v5)
      {
        v8 = v5;
        v9 = *a1;
        v10 = __s;
        while (*(unsigned __int8 *)v9 == *v10)
        {
          ++v10;
          ++v9;
          if (!--v8)
            goto LABEL_8;
        }
        goto LABEL_9;
      }
LABEL_8:
      if (v7[v5] == 61)
        return &v7[v5 + 1];
    }
LABEL_9:
    v11 = a1[1];
    ++a1;
    result = v11;
    if (!v11)
      return result;
  }
}

uint64_t dyld4::ProcessConfig::PathOverrides::PathOverrides(uint64_t a1, uint64_t a2, const dyld4::ProcessConfig::Security *a3, uint64_t a4, uint64_t a5, uint64_t a6, lsl::Allocator *a7)
{
  char **v14;
  char *v15;
  char **v16;
  char *v17;
  const char **v18;
  const char *v19;
  char v20;
  const char **v21;
  const char *v22;
  _DWORD *v23;
  _DWORD *v24;
  const char *v25;
  _QWORD v27[5];
  _QWORD v28[8];
  __int128 __s;
  uint64_t v30;
  char v31;

  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 136) = *((_BYTE *)a3 + 20) == 0;
  if (*((_BYTE *)a3 + 18))
  {
    strcpy((char *)&__s, "dyld config: ");
    v14 = *(char ***)(a2 + 112);
    v15 = *v14;
    if (*v14)
    {
      v16 = v14 + 1;
      do
      {
        dyld4::ProcessConfig::PathOverrides::addEnvVar((char **)a1, (const dyld4::ProcessConfig::Process *)a2, a3, a7, v15, 0, (char *)&__s);
        v17 = *v16++;
        v15 = v17;
      }
      while (v17);
    }
    if (_platform_strlen((const char *)&__s) > 0xF)
      qword_1EE805DE8 = (uint64_t)lsl::Allocator::strdup(a7, (const char *)&__s);
  }
  else if (*(_BYTE *)(a4 + 8))
  {
    v18 = *(const char ***)(a2 + 112);
    v19 = *v18;
    if (*v18)
    {
      v20 = 0;
      v21 = v18 + 1;
      do
      {
        v20 |= _platform_strncmp(v19, "DYLD_", 5uLL) == 0;
        v22 = *v21++;
        v19 = v22;
      }
      while (v22);
      if ((v20 & 1) != 0)
        dyld4::console((dyld4 *)"Note: DYLD_*_PATH env vars disabled by AMFI\n", (const char *)a2);
    }
  }
  if (*((_BYTE *)a3 + 23))
  {
    v23 = *(_DWORD **)a2;
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 0x40000000;
    v28[2] = ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke;
    v28[3] = &__block_descriptor_tmp_71;
    v28[4] = a1;
    v28[5] = a2;
    v28[6] = a3;
    v28[7] = a7;
    dyld3::MachOFile::forDyldEnv(v23, (uint64_t)v28);
  }
  else if (*(_BYTE *)(a4 + 8))
  {
    *(_QWORD *)&__s = 0;
    *((_QWORD *)&__s + 1) = &__s;
    v30 = 0x2000000000;
    v31 = 0;
    v24 = *(_DWORD **)a2;
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 0x40000000;
    v27[2] = ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke_2;
    v27[3] = &unk_1E4F7C020;
    v27[4] = &__s;
    dyld3::MachOFile::forDyldEnv(v24, (uint64_t)v27);
    if (*(_BYTE *)(*((_QWORD *)&__s + 1) + 24))
      dyld4::console((dyld4 *)"Note: LC_DYLD_ENVIRONMENT env vars disabled by AMFI\n", v25);
    _Block_object_dispose(&__s, 8);
  }
  if (*(_QWORD *)(a5 + 96))
    *(_QWORD *)(a1 + 120) = *(_QWORD *)(a5 + 88);
  dyld4::ProcessConfig::PathOverrides::processVersionedPaths((_QWORD *)a1, a2, a6, a5, *(_DWORD *)(a2 + 60), *(_QWORD *)(a2 + 136), (uint64_t)a7);
  return a1;
}

size_t dyld4::ProcessConfig::PathOverrides::addEnvVar(char **this, const dyld4::ProcessConfig::Process *a2, const dyld4::ProcessConfig::Security *a3, lsl::Allocator *a4, char *__s, int a6, char *a7)
{
  size_t result;
  char *v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  dyld4::ProcessConfig::PathOverrides *v27;
  char **v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  int v33;
  uint64_t v34;
  _QWORD v35[9];
  char v36;
  _QWORD v37[3];
  char v38;

  result = (size_t)_platform_strchr(__s, 61);
  if (!result)
    return result;
  v15 = (char *)(result + 1);
  if (a6 && _platform_strchr((char *)(result + 1), 64))
  {
    v16 = _platform_strlen(__s);
    __chkstk_darwin(v16, v17, v18, v19, v20, v21, v22, v23, v34);
    v25 = (char *)&v35[-1] - ((v24 + 1039) & 0xFFFFFFFFFFFFFFF0);
    v37[0] = 0;
    v37[1] = v37;
    v37[2] = 0x2000000000;
    v38 = 0;
    *v25 = 0;
    v36 = 0;
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 0x40000000;
    v35[2] = ___ZN5dyld413ProcessConfig13PathOverrides9addEnvVarERKNS0_7ProcessERKNS0_8SecurityERN3lsl9AllocatorEPKcbPc_block_invoke;
    v35[3] = &unk_1E4F7C0F0;
    v35[4] = v37;
    v35[5] = a3;
    v35[6] = v25;
    v35[7] = v26;
    v35[8] = a2;
    dyld4::ProcessConfig::PathOverrides::forEachInColonList((uint64_t)v15, 0, &v36, (uint64_t)v35);
    v15 = lsl::Allocator::strdup(a4, v25);
    _Block_object_dispose(v37, 8);
  }
  result = _platform_strncmp(__s, "DYLD_LIBRARY_PATH", 0x11uLL);
  if (!(_DWORD)result)
  {
    if (a6)
      v28 = this + 6;
    else
      v28 = this;
    goto LABEL_27;
  }
  result = _platform_strncmp(__s, "DYLD_FRAMEWORK_PATH", 0x13uLL);
  if (!(_DWORD)result)
  {
    v29 = a6 == 0;
    v30 = 8;
    v31 = 56;
LABEL_24:
    if (!v29)
      v30 = v31;
    v28 = (char **)((char *)this + v30);
    goto LABEL_27;
  }
  result = _platform_strncmp(__s, "DYLD_FALLBACK_FRAMEWORK_PATH", 0x1CuLL);
  if (!(_DWORD)result)
  {
    v29 = a6 == 0;
    v30 = 24;
    v31 = 72;
    goto LABEL_24;
  }
  result = _platform_strncmp(__s, "DYLD_FALLBACK_LIBRARY_PATH", 0x1AuLL);
  if (!(_DWORD)result)
  {
    v29 = a6 == 0;
    v30 = 16;
    v31 = 64;
    goto LABEL_24;
  }
  result = _platform_strncmp(__s, "DYLD_VERSIONED_FRAMEWORK_PATH", 0x1CuLL);
  if (!(_DWORD)result)
  {
    v29 = a6 == 0;
    v30 = 40;
    v31 = 80;
    goto LABEL_24;
  }
  result = _platform_strncmp(__s, "DYLD_VERSIONED_LIBRARY_PATH", 0x1AuLL);
  if (!(_DWORD)result)
  {
    v29 = a6 == 0;
    v30 = 32;
    v31 = 88;
    goto LABEL_24;
  }
  v27 = (dyld4::ProcessConfig::PathOverrides *)_platform_strncmp(__s, "DYLD_INSERT_LIBRARIES", 0x15uLL);
  if (!(_DWORD)v27)
  {
    result = (size_t)dyld4::ProcessConfig::PathOverrides::setString(v27, a4, this + 12, v15);
    v32 = this[12];
    if (*v32)
    {
      v33 = 1;
      *((_DWORD *)this + 35) = 1;
      while (1)
      {
        if (*v32 == 58)
        {
          *((_DWORD *)this + 35) = ++v33;
        }
        else if (!*v32)
        {
          goto LABEL_28;
        }
        ++v32;
      }
    }
    goto LABEL_28;
  }
  result = _platform_strncmp(__s, "DYLD_IMAGE_SUFFIX", 0x11uLL);
  if (!(_DWORD)result)
  {
    v28 = this + 13;
    goto LABEL_27;
  }
  result = _platform_strncmp(__s, "DYLD_ROOT_PATH", 0xEuLL);
  if (!(_DWORD)result)
  {
    result = dyld3::MachOFile::isSimulatorPlatform(*((_DWORD *)a2 + 15), 0);
    if ((_DWORD)result)
    {
      v28 = this + 14;
LABEL_27:
      result = (size_t)dyld4::ProcessConfig::PathOverrides::setString((dyld4::ProcessConfig::PathOverrides *)result, a4, v28, v15);
    }
  }
LABEL_28:
  if (a7)
  {
    result = _platform_strncmp(__s, "DYLD_", 5uLL);
    if (!(_DWORD)result)
    {
      strlcat(a7, __s, 0x800uLL);
      return strlcat(a7, " ", 0x800uLL);
    }
  }
  return result;
}

uint64_t dyld4::ProcessConfig::PathOverrides::processVersionedPaths(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  _QWORD v17[9];
  int v18;
  _QWORD v19[9];
  int v20;
  char v21;

  v21 = 0;
  v13 = a1[4];
  v14 = a1[11];
  if (v13 | v14)
  {
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 0x40000000;
    v19[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke;
    v19[3] = &__block_descriptor_tmp_81;
    v19[4] = a1;
    v19[5] = a3;
    v19[6] = a4;
    v19[7] = a7;
    v20 = a5;
    v19[8] = a6;
    dyld4::ProcessConfig::PathOverrides::forEachInColonList(v13, v14, &v21, (uint64_t)v19);
  }
  result = a1[5];
  v16 = a1[10];
  if (result | v16)
  {
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    v17[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_3;
    v17[3] = &__block_descriptor_tmp_84;
    v17[4] = a1;
    v17[5] = a3;
    v17[6] = a4;
    v17[7] = a7;
    v18 = a5;
    v17[8] = a6;
    return dyld4::ProcessConfig::PathOverrides::forEachInColonList(result, v16, &v21, (uint64_t)v17);
  }
  return result;
}

dyld4::RuntimeState *dyld4::RuntimeState::RuntimeState(dyld4::RuntimeState *this, const dyld4::ProcessConfig *a2, dyld4::RuntimeLocks *a3, lsl::Allocator *a4)
{
  *(_QWORD *)this = &unk_1E4F7AE98;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a4;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = a4;
  *((_QWORD *)this + 5) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = a4;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = lsl::Allocator::memoryManager(a4);
  *((_QWORD *)this + 17) = a3;
  *((_OWORD *)this + 9) = 0u;
  *((_QWORD *)this + 20) = a4;
  *((_QWORD *)this + 21) = 0;
  *((_OWORD *)this + 11) = 0u;
  *((_QWORD *)this + 24) = a4;
  *((_QWORD *)this + 25) = 0;
  *((_OWORD *)this + 13) = 0u;
  *((_QWORD *)this + 28) = a4;
  *((_QWORD *)this + 29) = 0;
  *((_OWORD *)this + 15) = 0u;
  *((_QWORD *)this + 32) = a4;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((_QWORD *)this + 35) = 0;
  *((_QWORD *)this + 36) = a4;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((_QWORD *)this + 39) = 0;
  *((_QWORD *)this + 40) = a4;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *((_QWORD *)this + 67) = 0;
  dyld4::FileManager::FileManager((dyld4::RuntimeState *)((char *)this + 544), *((lsl::Allocator **)this + 2), *((const dyld4::SyscallDelegate **)this + 1));
  *((_DWORD *)this + 146) = 0;
  *(_OWORD *)((char *)this + 568) = 0u;
  *((_QWORD *)this + 74) = 0;
  *(_OWORD *)((char *)this + 600) = 0u;
  *((_QWORD *)this + 77) = a4;
  *((_OWORD *)this + 39) = 0u;
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *(_OWORD *)((char *)this + 665) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *((_QWORD *)this + 90) = 0;
  *((_QWORD *)this + 91) = a4;
  *((_QWORD *)this + 92) = 0;
  *(_OWORD *)((char *)this + 744) = 0u;
  *((_QWORD *)this + 95) = a4;
  *((_OWORD *)this + 48) = 0u;
  *((_QWORD *)this + 98) = 0;
  *((_QWORD *)this + 99) = a4;
  *((_QWORD *)this + 102) = 0;
  *((_OWORD *)this + 50) = 0u;
  *((_QWORD *)this + 103) = a4;
  *((_QWORD *)this + 106) = 0;
  *((_OWORD *)this + 52) = 0u;
  *((_QWORD *)this + 107) = a4;
  *((_QWORD *)this + 110) = 0;
  *((_OWORD *)this + 54) = 0u;
  *((_QWORD *)this + 111) = a4;
  *((_QWORD *)this + 114) = 0;
  *((_OWORD *)this + 56) = 0u;
  *((_QWORD *)this + 115) = a4;
  *((_QWORD *)this + 118) = 0;
  *((_OWORD *)this + 58) = 0u;
  *((_QWORD *)this + 119) = a4;
  *((_OWORD *)this + 60) = 0u;
  *((_OWORD *)this + 61) = 0u;
  *((_OWORD *)this + 62) = 0u;
  *((_OWORD *)this + 63) = 0u;
  *((_OWORD *)this + 64) = 0u;
  *((_DWORD *)this + 261) = 256;
  *(_OWORD *)((char *)this + 1048) = 0u;
  *((_QWORD *)this + 133) = a4;
  *((_QWORD *)this + 135) = 0;
  *((_QWORD *)this + 134) = 0;
  *((_QWORD *)this + 136) = 0;
  *((_QWORD *)this + 137) = a4;
  *((_QWORD *)this + 139) = 0;
  *((_QWORD *)this + 138) = 0;
  *((_DWORD *)this + 282) = 0;
  *((_QWORD *)this + 140) = 0;
  *((_QWORD *)this + 143) = -1;
  *((_QWORD *)this + 142) = -1;
  *((_QWORD *)this + 144) = 0xFFFFFFFFLL;
  *((_QWORD *)this + 146) = 0;
  *((_WORD *)this + 580) = 0;
  return this;
}

double dyld4::RuntimeLocks::RuntimeLocks(dyld4::RuntimeLocks *this)
{
  double result;

  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  return result;
}

dyld4::FileManager *dyld4::FileManager::FileManager(dyld4::FileManager *this, lsl::Allocator *a2, const dyld4::SyscallDelegate *a3)
{
  _QWORD *v5;

  *(_QWORD *)this = a3;
  *((_QWORD *)this + 1) = a2;
  v5 = lsl::Allocator::aligned_alloc(a2, 8uLL, 0x28uLL);
  *v5 = 0;
  v5[1] = a2;
  v5[3] = 0;
  *((_BYTE *)v5 + 32) = 0;
  *((_QWORD *)this + 2) = v5;
  return this;
}

uint64_t dyld3::MachOFile::isSimulatorPlatform(int a1, int *a2)
{
  uint64_t result;
  int v4;

  result = 0;
  switch(a1)
  {
    case 7:
      if (!a2)
        return 1;
      v4 = 2;
      break;
    case 8:
      if (!a2)
        return 1;
      v4 = 3;
      break;
    case 9:
      if (!a2)
        return 1;
      v4 = 4;
      break;
    case 12:
      if (!a2)
        return 1;
      v4 = 11;
      break;
    default:
      return result;
  }
  *a2 = v4;
  return 1;
}

uint64_t dyld3::kdebug_trace_dyld_cache(unsigned __int8 (*this)[16], fsobj_id a2, void *a3, void *a4, unsigned __int8 *a5, void *a6, void *a7, void *a8)
{
  uint64_t result;
  fsobj_id v12;
  fsid v13;
  fsobj_id v14;
  char v15[1024];

  v14 = a2;
  result = kdebug_is_enabled(0x1F050028u, *(_QWORD *)&a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    result = dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)&dword_1A5C55000);
    if ((result & 1) == 0)
    {
      bzero(v15, 0x400uLL);
      if (fsgetpath(v15, 0x400uLL, (fsid_t *)&v14, (uint64_t)this) == -1)
        v15[0] = 0;
      v12 = v14;
      v13 = (fsid)a3;
      return dyld3::kdebug_trace_dyld_region((dyld3 *)0xA, 0, 0, v15, (void **)a4, this, v12, v13, *(const void **)&v14);
    }
  }
  return result;
}

uint64_t dyld3::loadDyldCache(uint64_t a1, _QWORD *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (*(_BYTE *)(a1 + 4))
    return dyld3::mapSplitCachePrivate((unsigned int *)a1, (uint64_t)a2);
  if (dyld3::reuseExistingCache(a1, (uint64_t)a2))
    return a2[2] == 0;
  return dyld3::mapSplitCacheSystemWide(a1, (uint64_t)a2);
}

uint64_t dyld3::reuseExistingCache(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  char *v5;
  uint64_t v6;
  BOOL v7;
  char v8;
  uint64_t v9;
  const char *v10;
  const char *v11;
  char *__s1;
  char v13[1024];

  __s1 = 0;
  if (__shared_region_check_np((uint64_t *)&__s1))
    return 0;
  v5 = __s1;
  if (_platform_strcmp(__s1, "dyld_v1   arm64"))
  {
    result = 0;
    *(_QWORD *)(a2 + 16) = "existing shared cache in memory is not compatible";
  }
  else
  {
    *(_QWORD *)a2 = v5;
    *(_QWORD *)(a2 + 8) = DyldSharedCache::slide((DyldSharedCache *)v5);
    v6 = *((_QWORD *)v5 + 13);
    v7 = v6 == 2 && *((_DWORD *)v5 + 114) == 0;
    if (v6)
      v8 = v7;
    else
      v8 = 1;
    *(_BYTE *)(a2 + 48) = v8;
    v9 = *((_QWORD *)v5 + 62) + *(_QWORD *)a2;
    if (_platform_strncmp((const char *)v9, "dyld_data    v0", 0x10uLL))
      dyld4::console((dyld4 *)"mapped cache does not contain dynamic config data\n", v10);
    else
      *(_OWORD *)(a2 + 32) = *(_OWORD *)(v9 + 16);
    if (*(_BYTE *)(a1 + 6))
    {
      if (fsgetpath(v13, 0x400uLL, (fsid_t *)(a2 + 32), *(_QWORD *)(a2 + 40)) >= 1)
        dyld4::console((dyld4 *)"re-using existing shared cache (%s):\n", v11, v13);
      dyld3::verboseSharedCacheMappings((dyld3 *)v5, (const DyldSharedCache *)v11);
    }
    return 1;
  }
  return result;
}

int __shared_region_check_np(uint64_t *a1)
{
  char v1;
  int result;

  result = mac_syscall(SYS_shared_region_check_np, a1);
  if (v1)
    return cerror_nocancel(result);
  return result;
}

uint64_t DyldSharedCache::slide(DyldSharedCache *this)
{
  return (uint64_t)this - *(_QWORD *)((char *)this + *((unsigned int *)this + 4));
}

__n128 lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,dyld4::Atlas::SharedCache>@<Q0>(lsl::Allocator *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v5;
  __int128 v6;
  __n128 result;

  v5 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0xB0uLL);
  *v5 = *(_QWORD *)a2;
  dyld4::FileRecord::FileRecord((uint64_t)(v5 + 1), (dyld4::FileRecord *)(a2 + 8));
  v6 = *(_OWORD *)(a2 + 88);
  v5[13] = *(_QWORD *)(a2 + 104);
  *(_OWORD *)(v5 + 11) = v6;
  v5[15] = 0;
  v5[16] = 0;
  *((_BYTE *)v5 + 136) = 0;
  v5[14] = 0;
  dyld4::Atlas::Mapper::Pointer<dyld3::MachOLoaded>::swap(v5 + 14, (uint64_t *)(a2 + 112));
  v5[18] = 0;
  if (v5 != (_QWORD *)a2)
  {
    v5[18] = *(_QWORD *)(a2 + 144);
    *(_QWORD *)(a2 + 144) = 0;
  }
  result = *(__n128 *)(a2 + 152);
  *((_BYTE *)v5 + 168) = *(_BYTE *)(a2 + 168);
  *(__n128 *)(v5 + 19) = result;
  *a3 = v5;
  return result;
}

void dyld4::ProcessConfig::DyldCache::setPlatformOSVersion(dyld4::ProcessConfig::DyldCache *this, const dyld4::ProcessConfig::Process *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  const char *v7;
  _DWORD *ImageFromPath;
  const char *v9;
  _QWORD v10[6];

  v3 = *(_QWORD *)this;
  v4 = *((_DWORD *)a2 + 15);
  if (*(_DWORD *)(v3 + 16) < 0x170u)
  {
    if (v4 == 10)
      v7 = "/System/DriverKit/usr/lib/system/libdyld.dylib";
    else
      v7 = "/usr/lib/system/libdyld.dylib";
    ImageFromPath = (_DWORD *)DyldSharedCache::getImageFromPath((DyldSharedCache *)v3, v7);
    if (ImageFromPath)
    {
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 0x40000000;
      v10[2] = ___ZN5dyld413ProcessConfig9DyldCache20setPlatformOSVersionERKNS0_7ProcessE_block_invoke;
      v10[3] = &__block_descriptor_tmp_60;
      v10[4] = this;
      v10[5] = a2;
      dyld3::MachOFile::forEachSupportedPlatform(ImageFromPath, (uint64_t)v10);
    }
    else
    {
      dyld4::console((dyld4 *)"initializeCachePlatformOSVersion(): libdyld.dylib not found for OS version info\n", v9);
    }
  }
  else if (v4 == *(_DWORD *)(v3 + 216))
  {
    v5 = *(_DWORD *)(v3 + 364);
    *((_DWORD *)this + 36) = v4;
    *((_DWORD *)this + 37) = v5;
  }
  else
  {
    *((_QWORD *)this + 18) = *(_QWORD *)(v3 + 368);
  }
}

BOOL dyld4::SyscallDelegate::realpathdir(dyld4::SyscallDelegate *this, dyld3 *a2, char *a3)
{
  int v4;
  int v5;
  _BOOL8 v6;

  v4 = dyld3::open(a2, (const char *)0x100000, 0);
  if (v4 == -1)
    return 0;
  v5 = v4;
  v6 = fcntl(v4, 50, a3) == 0;
  close(v5);
  return v6;
}

void dyld4::CacheFinder::~CacheFinder(dyld4::SyscallDelegate **this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;

  if (*((_BYTE *)this + 48))
  {
    v8 = (int *)(this + 2);
    jettison(&v8, a2, a3, a4, a5, a6, a7, a8);
  }
  else if (*(_DWORD *)this != -1)
  {
    dyld4::SyscallDelegate::close(this[1], *(_DWORD *)this);
  }
}

int **jettison(int **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  int **v9;

  v8 = *result;
  if (*result)
  {
    v9 = result;
    switch(*v8)
    {
      case 0:
        goto LABEL_7;
      case 1:
        goto LABEL_6;
      case 2:
        goto LABEL_5;
      case 3:
        goto LABEL_4;
      case 4:
        closefd_optional(v8 + 7, (int)"prereboot os graft point");
LABEL_4:
        closefd_optional(v8 + 6, (int)"group dir");
LABEL_5:
        closefd_optional(v8 + 4, (int)"os graft point");
        closefd_optional(v8 + 5, (int)"app graft point");
LABEL_6:
        closefd_optional(v8 + 3, (int)"xART");
LABEL_7:
        closefd_optional(v8 + 1, (int)"preboot");
        result = (int **)closefd(v8 + 2, (int)"shared cache");
        *v9 = 0;
        break;
      default:
        dyld_halt("unsupported payload version: 0x%x", a2, a3, a4, a5, a6, a7, a8, *v8);
    }
  }
  return result;
}

uint64_t closefd(int *a1, int a2)
{
  uint64_t result;
  char ***v5;
  char *v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  result = close(*a1);
  if ((_DWORD)result)
  {
    v5 = boot_get();
    v6 = (*v5)[1];
    v7 = (unint64_t)(*v5)[2];
    v8 = *__error();
    __error();
    ignition_halt(v6, v8, v7, "failed to close %s: fd = %d: %d", v9, v10, v11, v12, a2);
  }
  *a1 = -1;
  return result;
}

_QWORD *boot_destroy(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t i;
  char **v11;
  unint64_t v12;

  v8 = *result;
  if (*result)
  {
    v9 = result;
    for (i = 0; i != 9; ++i)
    {
      v11 = (&__roots)[i];
      v12 = (unint64_t)v11[2];
      if ((v12 & 0x8000000000000000) != 0)
        dyld_halt("invalid offset: %lld", a2, a3, a4, a5, a6, a7, a8, (int)v11[2]);
      closefd_optional((int *)(v8 + v12), (int)*v11);
    }
    result = (_QWORD *)ignition_test_BRA(4);
    *v9 = 0;
  }
  return result;
}

int *closefd_optional(int *result, int a2)
{
  _DWORD *v3;
  char ***v4;
  char *v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if ((*result & 0x80000000) == 0)
  {
    v3 = result;
    result = (int *)close(*result);
    if ((_DWORD)result)
    {
      v4 = boot_get();
      v5 = (*v4)[1];
      v6 = (unint64_t)(*v4)[2];
      v7 = *__error();
      __error();
      ignition_halt(v5, v7, v6, "failed to close %s [optional]: fd = %d: %d", v8, v9, v10, v11, a2);
    }
    *v3 = -1;
  }
  return result;
}

int close(int a1)
{
  char v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;

  LODWORD(v9) = mac_syscall(SYS_close, a1);
  if (v1)
    LODWORD(v9) = cerror(v9, v2, v3, v4, v5, v6, v7, v8);
  return v9;
}

size_t dyld4::PrebuiltLoaderSet::forEachMustBeMissingPath(size_t result, uint64_t a2)
{
  size_t v3;
  const char *v4;
  int v5;
  char v6;

  v3 = result;
  v6 = 0;
  v4 = (const char *)(result + *(unsigned int *)(result + 36));
  v5 = -1;
  do
  {
    if (++v5 >= *(_DWORD *)(v3 + 32))
      break;
    (*(void (**)(uint64_t, const char *, char *))(a2 + 16))(a2, v4, &v6);
    result = _platform_strlen(v4);
    v4 += result + 1;
  }
  while (!v6);
  return result;
}

uint64_t ___ZNK5dyld417PrebuiltLoaderSet7isValidERNS_12RuntimeStateE_block_invoke(_QWORD *a1, dyld3 *a2, _BYTE *a3)
{
  uint64_t v6;
  uint64_t result;
  const char *v8;

  v6 = a1[5];
  result = dyld4::SyscallDelegate::fileExists(*(_QWORD *)(a1[6] + 8), a2, 0, 0);
  if ((_DWORD)result)
  {
    if (*(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 207))
      result = dyld4::console((dyld4 *)"not using PrebuiltLoaderSet %p because existence of file '%s' invalids the PrebuiltLoaderSet\n", v8, v6, a2);
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

uint64_t dyld4::APIs::dyld_get_program_sdk_version(dyld4::APIs *this)
{
  uint64_t SdkVersion;
  uint64_t v3;

  SdkVersion = dyld4::APIs::getSdkVersion(this, *(const mach_header **)(*((_QWORD *)this + 1) + 8));
  v3 = SdkVersion;
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_get_program_sdk_version() => 0x%08X\n", SdkVersion);
  return v3;
}

BOOL dyld4::APIs::_dyld_has_preoptimized_swift_protocol_conformances(dyld4::APIs *this, mach_header *a2)
{
  _BOOL8 result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;

  result = dyld3::MachOAnalyzer::hasSwift((dyld3::MachOAnalyzer *)a2);
  if (result)
  {
    v5 = *((_QWORD *)this + 127);
    if (!v5)
      return 0;
    result = dyld4::PrebuiltLoaderSet::hasOptimizedSwift(*((dyld4::PrebuiltLoaderSet **)this + 127));
    if (!result)
      return result;
    v8 = *(unsigned int *)(v5 + 12);
    if ((_DWORD)v8)
    {
      v9 = 0;
      v10 = v8 - 1;
      do
      {
        if (*(_DWORD *)(v5 + 12) <= (unsigned __int16)v9)
          dyld4::RuntimeState::findPrebuiltLoader(result, v6, v7);
        v11 = dyld4::Loader::analyzer((dyld4::Loader *)(v5 + *(unsigned int *)(v5 + *(unsigned int *)(v5 + 16) + 4 * (unsigned __int16)v9)), this) == (_QWORD)a2;
        result = v11;
        v11 = v11 || v10 == v9++;
      }
      while (!v11);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL dyld3::MachOAnalyzer::hasSwift(dyld3::MachOAnalyzer *this)
{
  BOOL v2;

  v2 = 0;
  dyld3::MachOAnalyzer::hasSwiftOrObjC(this, &v2);
  return v2;
}

uint64_t dyld4::APIs::_dyld_launch_mode(dyld4::APIs *this)
{
  unint64_t v1;
  int v2;
  int v3;
  uint64_t v4;
  unint64_t v5;
  BOOL v6;
  int v7;
  unsigned int v8;
  uint64_t v9;

  v1 = *((_QWORD *)this + 3);
  v2 = *(_WORD *)(v1 + 4) & 1;
  if (*((_BYTE *)this + 1040))
  {
    v3 = v2 | 4;
    if (!*((_BYTE *)this + 1160))
      v3 = *(_WORD *)(v1 + 4) & 1;
  }
  else
  {
    v3 = *(_WORD *)(v1 + 4) & 1;
  }
  v4 = *((_QWORD *)this + 1);
  v5 = *(_QWORD *)(v4 + 240);
  v6 = v1 <= v5 || v5 == 0;
  v7 = v3 | 8;
  if (v6)
    v7 = v3;
  if (v2)
    v8 = v7;
  else
    v8 = v3;
  if (*((_QWORD *)this + 22))
    v9 = v8 | 0x20;
  else
    v9 = v8;
  if (v5)
  {
    if (*(_QWORD *)(v5 + 104) == 1)
      v9 = v9 | 0x40;
    else
      v9 = v9;
  }
  if (*(_BYTE *)(v4 + 204))
    dyld4::RuntimeState::log(this, "_dyld_launch_mode() => 0x%08X\n", v9);
  return v9;
}

uint64_t dyld4::APIs::_dyld_swift_optimizations_version(dyld4::APIs *this)
{
  return 1;
}

BOOL dyld4::APIs::dyld_has_inserted_or_interposing_libraries(dyld4::APIs *this)
{
  uint64_t v1;
  _BOOL8 v2;

  v1 = *((_QWORD *)this + 1);
  if (*((_QWORD *)this + 22))
    v2 = 1;
  else
    v2 = *(_DWORD *)(v1 + 540) != 0;
  if (*(_BYTE *)(v1 + 204))
    dyld4::RuntimeState::log(this, "dyld_has_inserted_or_interposing_libraries() => %d\n", v2);
  return v2;
}

BOOL dyld4::APIs::dyld_process_is_restricted(dyld4::APIs *this)
{
  uint64_t v1;
  uint64_t v3;
  int v4;
  int v5;
  _BOOL8 v6;

  v1 = *((_QWORD *)this + 1);
  if (!*(_BYTE *)(v1 + 204))
    return *(_BYTE *)(v1 + 186) == 0;
  dyld4::RuntimeState::log(this, "dyld_process_is_restricted()");
  v3 = *((_QWORD *)this + 1);
  v4 = *(unsigned __int8 *)(v3 + 204);
  v5 = *(unsigned __int8 *)(v3 + 186);
  v6 = v5 == 0;
  if (v4)
    dyld4::RuntimeState::log(this, " => %d\n", v5 == 0);
  return v6;
}

uint64_t dyld3::MachOFile::hasConstObjCSection(dyld3::MachOFile *this)
{
  if ((dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_selrefs") & 1) != 0
    || (dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_classrefs") & 1) != 0
    || (dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_protorefs") & 1) != 0)
  {
    return 1;
  }
  else
  {
    return dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_superrefs");
  }
}

uint64_t dyld3::MachOFile::hasSection(dyld3::MachOFile *this, const char *a2, const char *a3)
{
  uint64_t v3;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile10hasSectionEPKcS2__block_invoke;
  v5[3] = &unk_1E4F7E960;
  v5[5] = a2;
  v5[6] = a3;
  v5[4] = &v6;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v5);
  v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke(uint64_t a1, dyld3::FatFile *this, unint64_t a3)
{
  dyld3::FatFile *v6;
  vm_address_t *v7;
  _QWORD v8[4];
  __int128 v9;
  dyld3::FatFile *v10;

  v6 = (dyld3::FatFile *)dyld3::FatFile::isFatFile(this, this);
  if (v6)
  {
    v7 = (vm_address_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke_2;
    v8[3] = &unk_1E4F7D1E8;
    v9 = *(_OWORD *)(a1 + 40);
    v10 = this;
    dyld3::FatFile::forEachSlice(v6, v7, a3, (uint64_t)v8);
  }
}

_DWORD *dyld3::FatFile::isFatFile(_DWORD *this, const void *a2)
{
  if ((*this | 0x1000000) != 0xBFBAFECA)
    return 0;
  return this;
}

uint64_t dyld4::APIs::_dyld_for_objc_header_opt_rw(dyld4::APIs *this)
{
  uint64_t v1;
  uint64_t v2;
  int v3;

  v1 = *((_QWORD *)this + 1);
  if (!*(_QWORD *)(v1 + 240))
  {
    if (*(_BYTE *)(v1 + 204))
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_rw(): no dyld shared cache\n");
    return 0;
  }
  v2 = *(_QWORD *)(v1 + 296);
  v3 = *(unsigned __int8 *)(v1 + 204);
  if (!v2)
  {
    if (v3)
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_rw(): no objC RW header\n");
    return 0;
  }
  if (v3)
    dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_rw() => 0x%llx\n", v2);
  return v2;
}

uint64_t dyld4::APIs::_dyld_for_objc_header_opt_ro(dyld4::APIs *this)
{
  uint64_t v1;
  uint64_t v2;
  int v3;

  v1 = *((_QWORD *)this + 1);
  if (!*(_QWORD *)(v1 + 240))
  {
    if (*(_BYTE *)(v1 + 204))
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_ro(): no dyld shared cache\n");
    return 0;
  }
  v2 = *(_QWORD *)(v1 + 288);
  v3 = *(unsigned __int8 *)(v1 + 204);
  if (!v2)
  {
    if (v3)
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_ro(): no objC RO header\n");
    return 0;
  }
  if (v3)
    dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_ro() => 0x%llx\n", v2);
  return v2;
}

const os_unfair_lock *dyld4::APIs::_dyld_register_for_bulk_image_loads(lsl::Lock **this, void (*a2)(unsigned int, const mach_header **, const char **))
{
  lsl::Lock *v4;
  const dyld4::Loader *ImageContaining;
  lsl::Lock *v6;
  lsl::Lock *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[6];
  lsl::Lock *v12;

  if (*((_BYTE *)this[1] + 204))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_register_for_bulk_image_loads(%p)\n", a2);
  v4 = this[17];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = ___ZN5dyld44APIs35_dyld_register_for_bulk_image_loadsEPFvjPPK11mach_headerPPKcE_block_invoke;
  v11[3] = &__block_descriptor_tmp_122;
  v11[4] = this;
  v11[5] = a2;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v11);
  ImageContaining = (const dyld4::Loader *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a2);
  v6 = this[16];
  v7 = this[17];
  lsl::MemoryManager::lockGuard(v6, &v12);
  v8 = *((_QWORD *)v6 + 3);
  if (!v8)
  {
    lsl::MemoryManager::writeProtect(v6, 0);
    v8 = *((_QWORD *)v6 + 3);
  }
  *((_QWORD *)v6 + 3) = v8 + 1;
  lsl::Lock::unlock(v12);
  if (*(_QWORD *)v7)
  {
    (*(void (**)(_QWORD, _QWORD *, _QWORD))(**(_QWORD **)v7 + 104))(*(_QWORD *)v7, (_QWORD *)v7 + 2, 0);
    dyld4::RuntimeState::addNotifyBulkLoadImage((dyld4::RuntimeState *)this, ImageContaining, a2);
    (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)v7 + 112))(*(_QWORD *)v7, (_QWORD *)v7 + 2);
  }
  else
  {
    dyld4::RuntimeState::addNotifyBulkLoadImage((dyld4::RuntimeState *)this, ImageContaining, a2);
  }
  lsl::MemoryManager::lockGuard(v6, &v12);
  v9 = *((_QWORD *)v6 + 3) - 1;
  *((_QWORD *)v6 + 3) = v9;
  if (!v9)
    lsl::MemoryManager::writeProtect(v6, 1);
  return lsl::Lock::unlock(v12);
}

uint64_t dyld4::RuntimeState::addNotifyBulkLoadImage(dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(unsigned int, const mach_header **, const char **))
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 824, *((_QWORD *)this + 105) + 1);
  v7 = *((_QWORD *)this + 104);
  v8 = *((_QWORD *)this + 105);
  *((_QWORD *)this + 105) = v8 + 1;
  *(_QWORD *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 1096, *((_QWORD *)this + 139) + 1);
      v9 = *((_QWORD *)this + 138);
      v10 = *((_QWORD *)this + 139);
      *((_QWORD *)this + 139) = v10 + 1;
      *(_QWORD *)(v9 + 8 * v10) = a2;
    }
  }
  return result;
}

void dyld4::APIs::_dyld_objc_register_callbacks(dyld4::RuntimeState *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  lsl::Lock *v9;
  uint64_t v10;
  dyld4::PrebuiltLoaderSet *v11;
  char *v12;

  if (*(_BYTE *)(*((_QWORD *)a1 + 1) + 204))
    dyld4::RuntimeState::log(a1, "_dyld_objc_register_callbacks(%lu, %p, %p, %p, %p)\n", *a2, (const void *)a2[1], (const void *)a2[2], (const void *)a2[31], (const void *)a2[4]);
  v4 = *a2;
  if (*a2 == 2)
  {
    v5 = a2[3];
    v6 = a2[4];
    v10 = a2[1];
    v7 = a2[2];
    v9 = a1;
    v8 = 0;
  }
  else
  {
    if (v4 != 3)
    {
      if (v4 == 1)
        v12 = "_dyld_objc_register_callbacks v1 is no longer supported";
      else
        v12 = "_dyld_objc_register_callbacks unknown version";
      dyld4::halt(v12, 0);
    }
    v5 = a2[3];
    v6 = a2[4];
    v8 = a2[1];
    v7 = a2[2];
    v9 = a1;
    v10 = 0;
  }
  dyld4::RuntimeState::setObjCNotifiers(v9, v5, v6, v10, v7, v8);
  v11 = (dyld4::PrebuiltLoaderSet *)*((_QWORD *)a1 + 127);
  if (v11)
    dyld4::PrebuiltLoaderSet::logDuplicateObjCClasses(v11, (dyld4::Loader **)a1);
}

const os_unfair_lock *dyld4::RuntimeState::setObjCNotifiers(lsl::Lock *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  lsl::Lock *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  lsl::Lock *v17[5];

  v12 = (lsl::Lock *)*((_QWORD *)a1 + 16);
  lsl::MemoryManager::lockGuard(v12, v17);
  v13 = *((_QWORD *)v12 + 3);
  if (!v13)
  {
    lsl::MemoryManager::writeProtect(v12, 0);
    v13 = *((_QWORD *)v12 + 3);
  }
  *((_QWORD *)v12 + 3) = v13 + 1;
  lsl::Lock::unlock(v17[0]);
  *((_QWORD *)a1 + 86) = a2;
  *((_QWORD *)a1 + 87) = a3;
  *((_QWORD *)a1 + 88) = a4;
  *((_QWORD *)a1 + 89) = a5;
  *((_QWORD *)a1 + 90) = a6;
  v14 = (_QWORD *)*((_QWORD *)a1 + 17);
  v17[0] = (lsl::Lock *)_NSConcreteStackBlock;
  v17[1] = (lsl::Lock *)0x40000000;
  v17[2] = (lsl::Lock *)___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke;
  v17[3] = (lsl::Lock *)&__block_descriptor_tmp_172;
  v17[4] = a1;
  dyld4::RuntimeLocks::withLoadersReadLock(v14, (uint64_t)v17);
  lsl::MemoryManager::lockGuard(v12, v17);
  v15 = *((_QWORD *)v12 + 3) - 1;
  *((_QWORD *)v12 + 3) = v15;
  if (!v15)
    lsl::MemoryManager::writeProtect(v12, 1);
  return lsl::Lock::unlock(v17[0]);
}

uint64_t lsl::MemoryManager::writeProtect(lsl::MemoryManager *this, int a2)
{
  char v2;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  vm_prot_t v7;
  vm_size_t *v8;
  uint64_t result;
  _QWORD v10[4];
  char v11;

  v2 = a2;
  v4 = *((_QWORD *)this + 4);
  if (v4 && *(_DWORD *)(v4 + 16) >= 0x205u && *(_DWORD *)(v4 + 516))
  {
    v5 = 0;
    v6 = v4 - *(_QWORD *)(v4 + 224);
    if (a2)
      v7 = 1;
    else
      v7 = 19;
    v8 = (vm_size_t *)(*(unsigned int *)(v4 + 512) + v4 + 8);
    do
    {
      vm_protect(mach_task_self_, v6 + *(v8 - 1), *v8, 0, v7);
      ++v5;
      v8 += 2;
    }
    while (v5 < *(unsigned int *)(v4 + 516));
  }
  result = *((_QWORD *)this + 2);
  if (result)
  {
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    v10[2] = ___ZN3lsl13MemoryManager12writeProtectEb_block_invoke;
    v10[3] = &__block_descriptor_tmp_7;
    v11 = v2;
    return lsl::Allocator::forEachVMAllocatedBuffer(result, (uint64_t)v10);
  }
  return result;
}

int mprotect(void *a1, size_t a2, int a3)
{
  char v3;
  int result;

  result = mac_syscall(SYS_mprotect, a1, a2, a3);
  if (v3)
    return cerror_nocancel(result);
  return result;
}

void dyld4::APIs::_dyld_images_for_addresses(dyld4::RuntimeState *a1, unsigned int a2, char **a3, _QWORD *a4)
{
  _QWORD *v4;
  char **v5;
  char *v8;
  uint64_t i;
  char *v10;
  dyld3::MachOFile *v11;
  BOOL v12;
  unint64_t v14;
  void *v15;
  char *v16;
  BOOL v17;
  dyld3::MachOFile *v18;

  v4 = a4;
  v5 = a3;
  if (*(_BYTE *)(*((_QWORD *)a1 + 1) + 204))
    dyld4::RuntimeState::log(a1, "_dyld_images_for_addresses(%d, %p, %p)\n", a2, a3, a4);
  v18 = 0;
  v17 = 0;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  if (a2)
  {
    v8 = 0;
    for (i = a2; i; --i)
    {
      v10 = *v5;
      bzero(v4, 0x20uLL);
      v11 = v18;
      if (v18)
        v12 = v10 >= (char *)v18;
      else
        v12 = 0;
      if (v12 && v10 <= v8)
        goto LABEL_15;
      if ((dyld4::APIs::findImageMappedAt(a1, v10, &v18, &v17, (const char **)&v16, &v15, &v14, 0, 0) & 1) == 0)
      {
        v18 = 0;
        goto LABEL_17;
      }
      v11 = v18;
      v8 = (char *)v18 + v14;
      if (v18)
      {
LABEL_15:
        v4[2] = v10 - (char *)v11;
        v4[3] = v11;
        dyld3::MachOFile::getUuid(v11, (unsigned __int8 *)v4);
      }
LABEL_17:
      ++v5;
      v4 += 4;
    }
  }
}

const os_unfair_lock *dyld4::APIs::_dyld_register_func_for_add_image(lsl::Lock **this, void (*a2)(const mach_header *, uint64_t))
{
  lsl::Lock *v4;
  const dyld4::Loader *ImageContaining;
  lsl::Lock *v6;
  lsl::Lock *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[6];
  lsl::Lock *v12;

  if (*((_BYTE *)this[1] + 204))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_register_func_for_add_image(%p)\n", a2);
  v4 = this[17];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = ___ZN5dyld44APIs33_dyld_register_func_for_add_imageEPFvPK11mach_headerlE_block_invoke;
  v11[3] = &__block_descriptor_tmp_45_0;
  v11[4] = this;
  v11[5] = a2;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v11);
  ImageContaining = (const dyld4::Loader *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a2);
  v6 = this[16];
  v7 = this[17];
  lsl::MemoryManager::lockGuard(v6, &v12);
  v8 = *((_QWORD *)v6 + 3);
  if (!v8)
  {
    lsl::MemoryManager::writeProtect(v6, 0);
    v8 = *((_QWORD *)v6 + 3);
  }
  *((_QWORD *)v6 + 3) = v8 + 1;
  lsl::Lock::unlock(v12);
  if (*(_QWORD *)v7)
  {
    (*(void (**)(_QWORD, _QWORD *, _QWORD))(**(_QWORD **)v7 + 104))(*(_QWORD *)v7, (_QWORD *)v7 + 2, 0);
    dyld4::RuntimeState::addNotifyAddFunc((dyld4::RuntimeState *)this, ImageContaining, a2);
    (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)v7 + 112))(*(_QWORD *)v7, (_QWORD *)v7 + 2);
  }
  else
  {
    dyld4::RuntimeState::addNotifyAddFunc((dyld4::RuntimeState *)this, ImageContaining, a2);
  }
  lsl::MemoryManager::lockGuard(v6, &v12);
  v9 = *((_QWORD *)v6 + 3) - 1;
  *((_QWORD *)v6 + 3) = v9;
  if (!v9)
    lsl::MemoryManager::writeProtect(v6, 1);
  return lsl::Lock::unlock(v12);
}

const os_unfair_lock *dyld4::APIs::_dyld_register_func_for_remove_image(lsl::Lock **this, void (*a2)(const mach_header *, uint64_t))
{
  const dyld4::Loader *ImageContaining;
  lsl::Lock *v5;
  lsl::Lock *v6;
  uint64_t v7;
  uint64_t v8;
  lsl::Lock *v10;

  if (*((_BYTE *)this[1] + 204))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_register_func_for_remove_image(%p)\n", a2);
  ImageContaining = (const dyld4::Loader *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a2);
  v5 = this[16];
  v6 = this[17];
  lsl::MemoryManager::lockGuard(v5, &v10);
  v7 = *((_QWORD *)v5 + 3);
  if (!v7)
  {
    lsl::MemoryManager::writeProtect(v5, 0);
    v7 = *((_QWORD *)v5 + 3);
  }
  *((_QWORD *)v5 + 3) = v7 + 1;
  lsl::Lock::unlock(v10);
  if (*(_QWORD *)v6)
  {
    (*(void (**)(_QWORD, _QWORD *, _QWORD))(**(_QWORD **)v6 + 104))(*(_QWORD *)v6, (_QWORD *)v6 + 2, 0);
    dyld4::RuntimeState::addNotifyRemoveFunc((dyld4::RuntimeState *)this, ImageContaining, a2);
    (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)v6 + 112))(*(_QWORD *)v6, (_QWORD *)v6 + 2);
  }
  else
  {
    dyld4::RuntimeState::addNotifyRemoveFunc((dyld4::RuntimeState *)this, ImageContaining, a2);
  }
  lsl::MemoryManager::lockGuard(v5, &v10);
  v8 = *((_QWORD *)v5 + 3) - 1;
  *((_QWORD *)v5 + 3) = v8;
  if (!v8)
    lsl::MemoryManager::writeProtect(v5, 1);
  return lsl::Lock::unlock(v10);
}

uint64_t dyld4::RuntimeState::addNotifyRemoveFunc(dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(const mach_header *, uint64_t))
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 760, *((_QWORD *)this + 97) + 1);
  v7 = *((_QWORD *)this + 96);
  v8 = *((_QWORD *)this + 97);
  *((_QWORD *)this + 97) = v8 + 1;
  *(_QWORD *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 1096, *((_QWORD *)this + 139) + 1);
      v9 = *((_QWORD *)this + 138);
      v10 = *((_QWORD *)this + 139);
      *((_QWORD *)this + 139) = v10 + 1;
      *(_QWORD *)(v9 + 8 * v10) = a2;
    }
  }
  return result;
}

uint64_t dyld4::RuntimeState::addNotifyAddFunc(dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(const mach_header *, uint64_t))
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 728, *((_QWORD *)this + 93) + 1);
  v7 = *((_QWORD *)this + 92);
  v8 = *((_QWORD *)this + 93);
  *((_QWORD *)this + 93) = v8 + 1;
  *(_QWORD *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 1096, *((_QWORD *)this + 139) + 1);
      v9 = *((_QWORD *)this + 138);
      v10 = *((_QWORD *)this + 139);
      *((_QWORD *)this + 139) = v10 + 1;
      *(_QWORD *)(v9 + 8 * v10) = a2;
    }
  }
  return result;
}

uint64_t dyld4::RuntimeState::exitTLV(dyld4::RuntimeState *this)
{
  uint64_t result;
  uint64_t v3;

  result = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 19) + 64))(*((_QWORD *)this + 19), *((_QWORD *)this + 142));
  if (result)
  {
    v3 = result;
    (*(void (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 19) + 72))(*((_QWORD *)this + 19), *((_QWORD *)this + 142), 0);
    return (**(uint64_t (***)(dyld4::RuntimeState *, uint64_t))this)(this, v3);
  }
  return result;
}

void dyld4::RuntimeState::addTLVTerminationFunc(dyld4::RuntimeState *this, void (*a2)(void *), void *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;

  v6 = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 19) + 64))(*((_QWORD *)this + 19), *((_QWORD *)this + 142));
  if (!v6)
  {
    v6 = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 19) + 8))(*((_QWORD *)this + 19), 128);
    bzero(v6, 0x80uLL);
    (*(void (**)(_QWORD, _QWORD, _QWORD *))(**((_QWORD **)this + 19) + 72))(*((_QWORD *)this + 19), *((_QWORD *)this + 142), v6);
  }
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6);
  v8 = v7[1];
  if (v8 == 7)
  {
    v9 = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 19) + 8))(*((_QWORD *)this + 19), 128);
    bzero(v9, 0x80uLL);
    *v7 = v9;
    v8 = v9[1];
    v7 = v9;
  }
  v7[1] = v8 + 1;
  v10 = &v7[2 * v8];
  v10[2] = a2;
  v10[3] = a3;
}

void dyld4::PrebuiltLoaderSet::logDuplicateObjCClasses(dyld4::PrebuiltLoaderSet *this, dyld4::Loader **a2)
{
  uint64_t v2;
  uint64_t *v4;
  dyld3::MachOFile *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[6];
  _QWORD v13[5];
  _QWORD v14[5];
  _QWORD v15[5];
  vm_address_t v16;
  vm_size_t v17;
  uint64_t v18;
  vm_address_t address;
  vm_size_t size;

  if (this)
  {
    v2 = *((unsigned int *)this + 11);
    if ((_DWORD)v2)
    {
      if ((*((_BYTE *)this + 52) & 1) != 0 && *((_BYTE *)a2[1] + 203))
      {
        v4 = (uint64_t *)((char *)this + v2);
        v5 = (dyld3::MachOFile *)dyld4::Loader::loadAddress(a2[3], (const dyld4::RuntimeState *)a2);
        v14[0] = 0;
        v14[1] = v14;
        v14[2] = 0x8802000000;
        v14[3] = __Block_byref_object_copy__64;
        v14[4] = __Block_byref_object_dispose__65;
        dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map((uint64_t)v15);
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 0x40000000;
        v13[2] = ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke;
        v13[3] = &unk_1E4F7D660;
        v13[4] = v14;
        dyld3::MachOAnalyzer::forEachObjCDuplicateClassToIgnore(v5, (uint64_t)v13);
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 0x40000000;
        v12[2] = ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke_2;
        v12[3] = &unk_1E4F7D688;
        v12[4] = v14;
        v12[5] = a2;
        prebuilt_objc::forEachClass(v4, (uint64_t)v12, v6, v7, v8, v9, v10, v11);
        _Block_object_dispose(v14, 8);
        v18 = 0;
        if (address)
          vm_deallocate(mach_task_self_, address, size);
        v15[4] = 0;
        if (v16)
          vm_deallocate(mach_task_self_, v16, v17);
      }
    }
  }
}

_QWORD *dyld4::JustInTimeLoader::makeLaunchLoader(dyld4::JustInTimeLoader *this, Diagnostics *a2, dyld4::RuntimeState *a3, const dyld3::MachOAnalyzer *a4, const char *a5, const mach_o::Layout *a6)
{
  uint64_t v9;
  __int128 v11[2];

  memset(v11, 0, sizeof(v11));
  v9 = dyld4::Loader::getOnDiskBinarySliceOffset(a2, a3, a4, (const char *)a4);
  dyld4::SyscallDelegate::fileExists(*((_QWORD *)a2 + 1), a4, (uint64_t)v11, 0);
  return dyld4::JustInTimeLoader::make((uint64_t)a2, a3, (const char *)a4, v11, v9, 1, 0, 0, 0);
}

uint64_t dyld4::Loader::getOnDiskBinarySliceOffset(dyld4::Loader *this, dyld4::RuntimeState *a2, const dyld3::MachOAnalyzer *a3, const char *a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[7];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  void (*v19)(uint64_t);
  vm_address_t *v20;

  v15 = 0;
  v16 = &v15;
  v17 = 0x3002000000;
  v18 = __Block_byref_object_copy__164;
  v19 = __Block_byref_object_dispose__165;
  Diagnostics::Diagnostics((Diagnostics *)&v20);
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v7 = *((_QWORD *)this + 1);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke;
  v10[3] = &unk_1E4F7D210;
  v10[5] = &v11;
  v10[6] = a2;
  v10[4] = &v15;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(v7, (vm_address_t *)v16 + 5, a3, 0, (uint64_t)v10);
  v8 = v12[3];
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  mach_o::Error::~Error(&v20);
  return v8;
}

uint64_t dyld4::APIs::NSVersionOfRunTimeLibrary(dyld4::APIs *this, const char *a2)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD v7[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = -1;
  v4 = (_QWORD *)*((_QWORD *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld44APIs25NSVersionOfRunTimeLibraryEPKc_block_invoke;
  v7[3] = &unk_1E4F7D888;
  v7[5] = this;
  v7[6] = a2;
  v7[4] = &v8;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "NSVersionOfRunTimeLibrary(%s) => 0x%08X\n", a2, *((_DWORD *)v9 + 6));
  v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t dyld4::APIs::_dyld_after_fork_dlopen_parent(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::releaseDlopenLockInForkParent(this[17]);
}

uint64_t dyld4::APIs::_dyld_before_fork_dlopen(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::takeDlopenLockBeforeFork(this[17]);
}

unint64_t dyld4::APIs::_dyld_atfork_prepare(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::takeLockBeforeFork(this[17]);
}

unint64_t dyld4::APIs::_dyld_atfork_parent(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::releaseLockInForkParent(this[17]);
}

uint64_t dyld4::APIs::dlerror(dyld4::APIs *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dlerror()");
  if (*((_QWORD *)this + 143) == -1)
    return 0;
  result = *((_QWORD *)this + 19);
  if (!result)
    return result;
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 64))(result);
  if (!v3 || (v4 = v3, !*(_BYTE *)(v3 + 8)))
  {
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
      dyld4::RuntimeState::log(this, " => NULL\n");
    return 0;
  }
  *(_BYTE *)(v3 + 8) = 0;
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, " => '%s'\n", (const char *)(v3 + 9));
  return v4 + 9;
}

_BYTE *dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(_BYTE *this)
{
  uint64_t v1;

  if (!this[8])
  {
    v1 = *(_QWORD *)(*(_QWORD *)this + 8);
    if (*(_BYTE *)(v1 + 158))
    {
      if (*(_QWORD *)(v1 + 240))
      {
        this[8] = 1;
        return (_BYTE *)dyld4::ProcessConfig::DyldCache::makeDataConstWritable((char **)(v1 + 240), v1 + 200, v1, 1);
      }
    }
  }
  return this;
}

void dyld4::APIs::dyld_get_image_versions(dyld4::RuntimeState *a1, unsigned int *a2, const void *a3)
{
  if (*(_BYTE *)(*((_QWORD *)a1 + 1) + 204))
    dyld4::RuntimeState::log(a1, "dyld_get_image_versions(%p, %p)\n", a2, a3);
  dyld4::APIs::forEachImageVersion((uint64_t)a1, a2, (uint64_t)a3);
}

uint64_t dyld4::APIs::_dyld_get_image_vmaddr_slide(dyld4::APIs *this, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD v7[6];
  int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v4 = (_QWORD *)*((_QWORD *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld44APIs28_dyld_get_image_vmaddr_slideEj_block_invoke;
  v7[3] = &unk_1E4F7D810;
  v8 = a2;
  v7[4] = &v9;
  v7[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_get_image_vmaddr_slide(%u) => 0x%lX\n", a2, v10[3]);
  v5 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v5;
}

unint64_t dyld4::RuntimeLocks::releaseLockInForkParent(dyld4::RuntimeLocks *this)
{
  unint64_t result;

  result = *(_QWORD *)this;
  if (result)
  {
    (*(void (**)(unint64_t, char *))(*(_QWORD *)result + 112))(result, (char *)this + 8);
    (*(void (**)(_QWORD, char *))(**(_QWORD **)this + 112))(*(_QWORD *)this, (char *)this + 16);
    (*(void (**)(_QWORD, char *))(**(_QWORD **)this + 112))(*(_QWORD *)this, (char *)this + 24);
    result = (***(uint64_t (****)(_QWORD))this)(*(_QWORD *)this);
    if (result >= 6)
    {
      (*(void (**)(_QWORD, char *))(**(_QWORD **)this + 192))(*(_QWORD *)this, (char *)this + 40);
      return (*(uint64_t (**)(_QWORD, char *))(**(_QWORD **)this + 192))(*(_QWORD *)this, (char *)this + 44);
    }
  }
  return result;
}

unint64_t dyld4::RuntimeLocks::takeLockBeforeFork(dyld4::RuntimeLocks *this)
{
  unint64_t result;

  result = *(_QWORD *)this;
  if (result)
  {
    (*(void (**)(unint64_t, char *, _QWORD))(*(_QWORD *)result + 104))(result, (char *)this + 8, 0);
    (*(void (**)(_QWORD, char *, _QWORD))(**(_QWORD **)this + 104))(*(_QWORD *)this, (char *)this + 16, 0);
    (*(void (**)(_QWORD, char *, _QWORD))(**(_QWORD **)this + 104))(*(_QWORD *)this, (char *)this + 24, 0);
    result = (***(uint64_t (****)(_QWORD))this)(*(_QWORD *)this);
    if (result >= 6)
    {
      (*(void (**)(_QWORD, char *, _QWORD))(**(_QWORD **)this + 184))(*(_QWORD *)this, (char *)this + 40, 0);
      return (*(uint64_t (**)(_QWORD, char *, _QWORD))(**(_QWORD **)this + 184))(*(_QWORD *)this, (char *)this + 44, 0);
    }
  }
  return result;
}

BOOL dyld4::APIs::dlopen_preflight(dyld4::APIs *this, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v10;
  DyldSharedCache *v11;
  int v12;
  BOOL v13;
  _BOOL8 v14;
  uint64_t v15;
  const char *v16;
  const char *v17;
  const char *v18;
  dyld4::Loader *v19;
  _QWORD v21[8];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t (*v25)(uint64_t, uint64_t);
  void (*v26)(uint64_t);
  vm_address_t *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  char v31;
  char v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  char *v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  char __s2[1024];

  v34 = 520617988;
  v35 = 0;
  v36 = a2;
  v37 = 0u;
  v38 = 0u;
  v39 = 0u;
  v40 = 0u;
  v41 = 0u;
  v42 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v34, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v10 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v10 + 204))
  {
    dyld4::RuntimeState::log(this, "dlopen_preflight(%s)\n", a2);
    v10 = *((_QWORD *)this + 1);
  }
  v33 = 0;
  v11 = *(DyldSharedCache **)(v10 + 240);
  if (v11)
  {
    if ((DyldSharedCache::hasImagePath(*(DyldSharedCache **)(v10 + 240), a2, &v33) & 1) != 0)
    {
LABEL_12:
      v39 = xmmword_1A5CBAC50;
      v14 = 1;
      goto LABEL_19;
    }
    v10 = *((_QWORD *)this + 1);
  }
  if (dyld4::SyscallDelegate::realpath((dyld4::SyscallDelegate *)v10, (dyld3 *)a2, __s2))
  {
    v12 = _platform_strcmp(a2, __s2);
    v13 = !v11 || v12 == 0;
    if (!v13 && DyldSharedCache::hasImagePath(v11, __s2, &v33))
      goto LABEL_12;
  }
  v32 = 0;
  v28 = 0;
  v29 = &v28;
  v30 = 0x2000000000;
  v31 = 0;
  v22 = 0;
  v23 = &v22;
  v24 = 0x3002000000;
  v25 = __Block_byref_object_copy__6;
  v26 = __Block_byref_object_dispose__6;
  Diagnostics::Diagnostics((Diagnostics *)&v27);
  v15 = *((_QWORD *)this + 1);
  v16 = (const char *)*(unsigned int *)(v15 + 68);
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 0x40000000;
  v21[2] = ___ZN5dyld44APIs16dlopen_preflightEPKc_block_invoke;
  v21[3] = &unk_1E4F7DBA0;
  v21[6] = this;
  v21[7] = a2;
  v21[4] = &v28;
  v21[5] = &v22;
  dyld4::ProcessConfig::PathOverrides::forEachPathVariant(v15 + 400, (dyld4::Utils *)a2, v16, 0, 1, &v32, (uint64_t)v21);
  if (!*((_BYTE *)v29 + 24) && Diagnostics::hasError((Diagnostics *)(v23 + 5)))
  {
    v18 = (const char *)Diagnostics::errorMessage((Diagnostics *)(v23 + 5));
    dyld4::APIs::setErrorString((vm_address_t *)this, "dlopen_preflight(%s) => false, %s", a2, v18);
  }
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
  {
    v19 = dyld4::Loader::leafName((dyld4::Loader *)a2, v17);
    dyld4::RuntimeState::log(this, "      dlopen_preflight(%s) => %d\n", (const char *)v19, *((unsigned __int8 *)v29 + 24));
  }
  v14 = *((_BYTE *)v29 + 24) != 0;
  v39 = *((unsigned __int8 *)v29 + 24);
  _Block_object_dispose(&v22, 8);
  mach_o::Error::~Error(&v27);
  _Block_object_dispose(&v28, 8);
LABEL_19:
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v34);
  return v14;
}

void dyld4::RuntimeState::findPrebuiltLoader(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_3("atIndex", "PrebuiltLoader.h", a3, "loaderIndex < loadersArrayCount");
}

void dyld4::Atlas::SharedCache::SharedCache()
{
  __assert_rtn("SharedCache", "ProcessAtlas.cpp", 898, "_mapper");
}

const char *dyld4::APIs::dyld_shared_cache_file_path(dyld4::APIs *this)
{
  uint64_t v1;
  const char *v2;

  v1 = *((_QWORD *)this + 1);
  v2 = *(const char **)(v1 + 280);
  if (*(_BYTE *)(v1 + 204))
    dyld4::RuntimeState::log(this, "dyld_shared_cache_file_path() => %s\n", v2);
  return v2;
}

int64_t dyld3::kdebug_trace_dyld_marker(void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10)
{
  void *v11;
  void *v13;
  void *v15;
  int64_t result;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  int64_t v23;
  int64_t v24;
  int64_t v25;
  int64_t v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;

  v11 = a6;
  v13 = a4;
  v15 = (void *)a2;
  result = kdebug_is_enabled(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)result)
    return result;
  if (a3)
  {
    v23 = kdebug_trace_string(a1, 0, a3, v18, v19, v20, v21, v22);
    if (v23 == -1)
      v15 = 0;
    else
      v15 = (void *)v23;
  }
  if (a5)
  {
    v24 = kdebug_trace_string(a1, 0, a5, v18, v19, v20, v21, v22);
    if (v24 == -1)
      v13 = 0;
    else
      v13 = (void *)v24;
  }
  if (a7)
  {
    v25 = kdebug_trace_string(a1, 0, a7, v18, v19, v20, v21, v22);
    if (v25 == -1)
      v11 = 0;
    else
      v11 = (void *)v25;
  }
  if (a10)
  {
    v26 = kdebug_trace_string(a1, 0, a10, v18, v19, v20, v21, v22);
    if (v26 == -1)
      v30 = 0;
    else
      v30 = (void *)v26;
    result = kdebug_trace(a1, v15, v13, v11, v30, v27, v28, v29);
    if (v30)
      result = kdebug_trace_string(a1, v30, 0, v31, v32, v33, v34, v35);
    if (!a7)
      goto LABEL_25;
    goto LABEL_23;
  }
  result = kdebug_trace(a1, v15, v13, v11, a9, v20, v21, v22);
  if (a7)
  {
LABEL_23:
    if (v11)
      result = kdebug_trace_string(a1, v11, 0, v31, v32, v33, v34, v35);
  }
LABEL_25:
  if (a5 && v13)
    result = kdebug_trace_string(a1, v13, 0, v31, v32, v33, v34, v35);
  if (a3)
  {
    if (v15)
      return kdebug_trace_string(a1, v15, 0, v31, v32, v33, v34, v35);
  }
  return result;
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_0("children", "BTree.h", a3, "!leaf() && \"Leaf nodes do not contain children\"");
}

void lsl::Lock::unlock()
{
  __assert_rtn("unlock", "Allocator.cpp", 116, "_runtimeState != nullptr");
}

void _dyld_start(uint64_t a1, unsigned int *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, uint64_t a9)
{
  start((dyld4::KernelArgs *)&a9, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t dyld4::restartWithDyldInCache(dyld4 *this, const dyld4::KernelArgs *a2, const dyld3::MachOFile *a3, const DyldSharedCache *a4, void *a5)
{
  return ((uint64_t (*)(void))a4)();
}

const os_unfair_lock *lsl::PreallocatedAllocatorLayout<278528ull>::init(lsl::AllocatorLayout *a1, const char **a2, const char **a3, void *a4)
{
  uint64_t v8;
  _BYTE v10[24];
  uint64_t v11;
  lsl::Lock *v12;

  lsl::MemoryManager::MemoryManager((lsl::MemoryManager *)v10, a2, a3, a4);
  lsl::MemoryManager::lockGuard((lsl::Lock *)v10, &v12);
  v8 = v11;
  if (!v11)
  {
    lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v10, 0);
    v8 = v11;
  }
  v11 = v8 + 1;
  lsl::Lock::unlock(v12);
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 10) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  lsl::AllocatorLayout::init(a1, 0x44000uLL, a2, a3, a4);
  lsl::MemoryManager::lockGuard((lsl::Lock *)v10, &v12);
  if (!--v11)
    lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v10, 1);
  return lsl::Lock::unlock(v12);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  mach_o::Error::~Error((vm_address_t **)(a1 + 40));
}

uint64_t ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke(_QWORD *a1, unsigned int *a2)
{
  uint64_t v3;
  vm_address_t *v4;
  uint64_t v5;
  __int128 v7;
  uint64_t v8;

  v3 = a1[5];
  v4 = (vm_address_t *)(*(_QWORD *)(a1[4] + 8) + 40);
  v5 = a1[6];
  v8 = 0;
  v7 = 0uLL;
  return dyld3::MachOLoaded::fixupAllChainedFixups(v3, v4, a2, v5, &v7, 0);
}

uint64_t ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke_2(uint64_t result, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 56) & 2) != 0)
    return dyld4::SyscallDelegate::mprotect((dyld4::SyscallDelegate *)&dyld4::sSyscallDelegate, (void *)(*(_QWORD *)(result + 32) + *(_QWORD *)(a2 + 16)), *(_QWORD *)(a2 + 24), 1);
  return result;
}

void lsl::Lock::Guard::~Guard(lsl::Lock **this)
{
  lsl::Lock::unlock(*this);
}

__n128 __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void dyld4::start(dyld4::KernelArgs *,void *,void *)::$_0::operator()(uint64_t a1)
{
  lsl::AllocatorLayout *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  lsl::Allocator *v11;
  size_t v12;
  lsl::AllocatorLayout *v13;
  uint64_t v14;
  const char **v15;
  const char **v16;
  lsl::Allocator *v17;
  dyld4::ProcessConfig *v18;
  dyld4::RuntimeState *v19;
  dyld4::RuntimeState *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const dyld3::MachOAnalyzer *v28;
  lsl::Allocator *v29;
  __int128 v30;
  int8x16_t v31;
  char v32;

  v2 = (lsl::AllocatorLayout *)lsl::Allocator::setBestFit(*(_QWORD *)a1, 1);
  v3 = lsl::AllocatorLayout::minSize(v2);
  __chkstk_darwin(v3, v3 + 0x10000, v4, v5, v6, v7, v8, v9, v30);
  v11 = (lsl::Allocator *)((char *)&v30 - v10);
  bzero((char *)&v30 - v10, v12);
  v14 = lsl::AllocatorLayout::minSize(v13);
  v17 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v11, (char *)(v14 + 0x10000), v15, v16);
  v18 = (dyld4::ProcessConfig *)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)a1, 8uLL, 0x220uLL);
  dyld4::ProcessConfig::ProcessConfig(v18, **(const dyld4::KernelArgs ***)(a1 + 8), (dyld4::SyscallDelegate *)&dyld4::sSyscallDelegate, *(lsl::Allocator **)a1);
  v19 = (dyld4::RuntimeState *)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)a1, 8uLL, 0x498uLL);
  v20 = dyld4::RuntimeState::RuntimeState(v19, v18, *(dyld4::RuntimeLocks **)(a1 + 24), *(lsl::Allocator **)a1);
  *(_QWORD *)v20 = &off_1E4F7AEB8;
  **(_QWORD **)(a1 + 16) = v20;
  v21 = lsl::Allocator::memoryManager(*(lsl::Allocator **)a1);
  lsl::MemoryManager::setDyldCacheAddr(v21, *(void **)(*(_QWORD *)(**(_QWORD **)(a1 + 16) + 8) + 240));
  dyld4::ExternallyViewableState::init((uint64_t *)(**(_QWORD **)(a1 + 16) + 568), *(lsl::Allocator **)(**(_QWORD **)(a1 + 16) + 16), v17, (dyld4::FileManager *)(**(_QWORD **)(a1 + 16) + 544), *(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 16) + 8) + 68));
  v22 = **(_QWORD **)(a1 + 16);
  v23 = **(_QWORD **)(a1 + 32);
  v24 = *(_QWORD *)(v22 + 8);
  v25 = *(_QWORD *)(v24 + 240);
  if (v25)
  {
    v26 = *(_QWORD *)(v24 + 264);
    v30 = *(_OWORD *)(v24 + 248);
    v31.i64[0] = *(_QWORD *)(v24 + 280);
    v31.i64[1] = v25;
    v32 = 0;
    dyld4::ExternallyViewableState::setSharedCacheInfo(v22 + 568, v17, v26, (uint64_t)&v30, *(unsigned __int8 *)(v24 + 398));
    v24 = *(_QWORD *)(v22 + 8);
  }
  v30 = *(_OWORD *)(v24 + 80);
  v31.i64[0] = *(_QWORD *)(v24 + 72);
  v31.i64[1] = v23;
  v32 = 0;
  dyld4::ExternallyViewableState::setDyld(v22 + 568, v17, (uint64_t)&v30);
  v27 = *(_QWORD *)(v22 + 8);
  v30 = *(_OWORD *)(v27 + 32);
  v31 = vextq_s8(*(int8x16_t *)(v27 + 8), *(int8x16_t *)(v27 + 8), 8uLL);
  v32 = 0;
  dyld4::ExternallyViewableState::addImageInfo(v22 + 568, v17, (uint64_t)&v30);
  *(_DWORD *)(v22 + 1044) = 1;
  dyld4::ExternallyViewableState::setInitialImageCount((dyld4::ExternallyViewableState *)(v22 + 568), 1u);
  if ((dyld3::MachOFile::isSimulatorPlatform(*(_DWORD *)(*(_QWORD *)(v22 + 8) + 68), 0) & 1) == 0)
    dyld4::ExternallyViewableState::commit((const os_unfair_lock *)(v22 + 568), *(lsl::Allocator **)(v22 + 16), v17, v29);
  **(_QWORD **)(a1 + 40) = dyld4::prepare(**(dyld4 ***)(a1 + 16), **(vm_address_t ***)(a1 + 32), v28);
  lsl::Allocator::~Allocator(v17);
}

double __Block_byref_object_copy__20(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__21(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

void ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke(uint64_t a1, const char *a2)
{
  dyld4::Loader *Loader;
  dyld4::Loader *v5;
  uint64_t v6;
  dyld4::Loader **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  dyld4::RuntimeState *v12;
  const char *v13;
  char *v14;
  dyld4::RuntimeState *v15;
  vm_address_t *v16;

  Diagnostics::Diagnostics((Diagnostics *)&v16);
  Loader = dyld4::Loader::getLoader(&v16, *(DyldSharedCache ****)(a1 + 40), a2, a1 + 48);
  if (Loader)
  {
    v5 = Loader;
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(dyld4::Loader ***)(v6 + 40);
    v8 = *(_QWORD *)(v6 + 56);
    if (v8)
    {
      v9 = 8 * v8;
      while (*v7 != Loader)
      {
        ++v7;
        v9 -= 8;
        if (!v9)
          goto LABEL_6;
      }
      v15 = *(dyld4::RuntimeState **)(a1 + 40);
      if (*(_BYTE *)(*((_QWORD *)v15 + 1) + 200))
        dyld4::RuntimeState::log(v15, "skipping duplicate inserted dylib '%s'\n", a2);
    }
    else
    {
LABEL_6:
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((_QWORD *)(v6 + 40), 1);
      v10 = *(_QWORD *)(v6 + 40);
      v11 = *(_QWORD *)(v6 + 56);
      *(_QWORD *)(v6 + 56) = v11 + 1;
      *(_QWORD *)(v10 + 8 * v11) = v5;
      dyld4::RuntimeState::notifyDebuggerLoad(*(dyld4::RuntimeState **)(a1 + 40), v5);
      if ((*((_WORD *)v5 + 2) & 1) != 0)
        dyld4::RuntimeState::add(*(dyld4::RuntimeState **)(a1 + 40), v5);
    }
  }
  else if (Diagnostics::hasError((Diagnostics *)&v16))
  {
    v12 = *(dyld4::RuntimeState **)(a1 + 40);
    if (!*(_BYTE *)(*((_QWORD *)v12 + 1) + 189))
    {
      v13 = (const char *)Diagnostics::errorMessageCStr((Diagnostics *)&v16);
      dyld4::RuntimeState::log(v12, "terminating because inserted dylib '%s' could not be loaded: %s\n", a2, v13);
      v14 = (char *)Diagnostics::errorMessage((Diagnostics *)&v16);
      dyld4::halt(v14, 0);
    }
  }
  mach_o::Error::~Error(&v16);
}

__n128 __Block_byref_object_copy__26(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__27(uint64_t a1)
{
  dyld4::BumpAllocator::~BumpAllocator((vm_address_t *)(a1 + 40));
}

void ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v4;
  uint64_t v5;
  dyld4::RuntimeState *v7;

  v4 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 240) + a2);
  v5 = *(_QWORD *)(a1 + 40) + a4;
  if (*v4 != v5)
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(_BYTE **)(a1 + 48));
    v7 = *(dyld4::RuntimeState **)(a1 + 32);
    if (*(_BYTE *)(*((_QWORD *)v7 + 1) + 202))
      dyld4::RuntimeState::log(v7, "cache patch: %p = 0x%0lX\n", v4, v5);
    *v4 = v5;
  }
}

void dyld4::fake_main(dyld4 *this, int a2, const char *const *a3, const char *const *a4, const char *const *a5)
{
  _exit(0);
}

uint64_t dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_OWORD *)(a1 + 16) = 0u;
  v2 = (_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A5CBAC60;
  v3 = 32;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((_QWORD *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1);
    v4 = *(_QWORD *)(a1 + 16);
    v5 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }
  while (v3);
  dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::reserve((_QWORD *)(a1 + 56), 0x20uLL);
  return a1;
}

_QWORD *dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  const void **v3;
  vm_address_t v4;
  vm_size_t v5;
  unint64_t v6;
  vm_size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;

  v2 = result[1];
  if (v2 < a2)
  {
    v3 = (const void **)result;
    v4 = result[3];
    v5 = result[4];
    v6 = 2 * v2;
    if (v6 <= a2)
      v6 = a2;
    v7 = (vm_page_size + 4 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    result = memmove((void *)v3[3], *v3, 4 * (_QWORD)v3[2]);
    v11 = (const void *)((unint64_t)v3[4] >> 2);
    *v3 = v3[3];
    v3[1] = v11;
    if (v4)
      return (_QWORD *)vm_deallocate(mach_task_self_, v4, v5);
  }
  return result;
}

_QWORD *dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::reserve(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  const void **v3;
  vm_address_t v4;
  vm_size_t v5;
  unint64_t v6;
  vm_size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v2 = result[1];
  if (v2 < a2)
  {
    v3 = (const void **)result;
    v4 = result[3];
    v5 = result[4];
    v6 = 2 * v2;
    if (v6 <= a2)
      v6 = a2;
    v7 = (vm_page_size + 24 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    result = memmove((void *)v3[3], *v3, 24 * (_QWORD)v3[2]);
    v11 = (unint64_t)v3[4] / 0x18;
    *v3 = v3[3];
    v3[1] = (const void *)v11;
    if (v4)
      return (_QWORD *)vm_deallocate(mach_task_self_, v4, v5);
  }
  return result;
}

void OUTLINED_FUNCTION_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 184, a4);
}

uint64_t dyld4::KernelArgs::findEnvp(dyld4::KernelArgs *this)
{
  return (uint64_t)this + 8 * *((_QWORD *)this + 1) + 24;
}

uint64_t ___ZN5dyld413ProcessConfig8SecurityC2ERNS0_7ProcessERNS_15SyscallDelegateE_block_invoke(uint64_t a1, char *__s1)
{
  uint64_t v3;
  uint64_t result;
  char *v5;
  __int16 v6;

  v3 = *(_QWORD *)(a1 + 32);
  result = _platform_strncmp(__s1, "DYLD_DLSYM_RESULT=", 0x12uLL);
  if ((_DWORD)result)
    return result;
  result = _platform_strcmp(__s1 + 18, "null");
  if (!(_DWORD)result)
  {
    v6 = 1;
LABEL_10:
    *(_WORD *)(v3 + 2) = v6;
    return result;
  }
  result = _platform_strcmp(__s1 + 18, "abort");
  if (!(_DWORD)result)
  {
    v6 = 257;
    goto LABEL_10;
  }
  result = _platform_strncmp(__s1 + 18, "null-allow:", 0xBuLL);
  if ((_DWORD)result)
  {
    result = _platform_strncmp(__s1 + 18, "abort-allow:", 0xCuLL);
    if ((_DWORD)result)
    {
      result = _platform_strncmp(__s1 + 18, "allow:", 6uLL);
      if ((_DWORD)result)
        return result;
      *(_WORD *)(v3 + 2) = 0;
      v5 = __s1 + 24;
    }
    else
    {
      *(_WORD *)(v3 + 2) = 257;
      v5 = __s1 + 30;
    }
  }
  else
  {
    *(_WORD *)(v3 + 2) = 1;
    v5 = __s1 + 29;
  }
  *(_QWORD *)(v3 + 8) = v5;
  return result;
}

void dyld4::ProcessConfig::Security::pruneEnvVars(uint64_t a1, uint64_t a2)
{
  const char **v2;
  const char *v3;
  int v5;
  const char **v6;
  const char *v7;
  _QWORD *v8;
  uint64_t v9;

  v2 = *(const char ***)(a2 + 112);
  v3 = *v2;
  if (*v2)
  {
    v5 = 0;
    v6 = v2 + 1;
    do
    {
      if (_platform_strncmp(v3, "DYLD_", 5uLL))
        *v2++ = v3;
      else
        ++v5;
      v7 = *v6++;
      v3 = v7;
    }
    while (v7);
    *v2 = 0;
    if (v5 > 0)
    {
      v8 = v2 + 1;
      *(_QWORD *)(a2 + 120) = v2 + 1;
      do
      {
        v9 = v8[v5];
        *v8++ = v9;
      }
      while (v9);
      bzero(v8, 8 * v5);
    }
  }
  else
  {
    *v2 = 0;
  }
}

ssize_t dyld4::console(dyld4 *this, const char *a2, ...)
{
  int v3;
  pid_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  pid_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va;

  va_start(va, a2);
  if (getpid() == 1)
  {
    v3 = open("/dev/console", 131073, 0);
    v4 = getpid();
    _simple_dprintf(2, "dyld[%d]: ", v5, v6, v7, v8, v9, v10, v4);
    _simple_vdprintf(v3, (char *)this, (int *)va);
    return close(v3);
  }
  else
  {
    v12 = getpid();
    _simple_dprintf(2, "dyld[%d]: ", v13, v14, v15, v16, v17, v18, v12);
    return _simple_vdprintf(2, (char *)this, (int *)va);
  }
}

uint64_t ___ZN5dyld413ProcessConfig9DyldCacheC2ERNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke(uint64_t a1, int a2, uint64_t a3, vm_size_t size)
{
  return vm_protect(mach_task_self_, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) + a3, size, 0, 19);
}

uint64_t dyld4::ProcessConfig::DyldCache::setupDyldCommPage(dyld4::ProcessConfig::DyldCache *this, dyld4::ProcessConfig::Process *a2, const dyld4::ProcessConfig::Security *a3, dyld4::SyscallDelegate *a4)
{
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  v7 = dyld4::SyscallDelegate::bootVolumeWritable(a4);
  v8 = *((_QWORD *)a2 + 11);
  v9 = 0x800000000;
  if (!v7)
    v9 = 0;
  v10 = v8 & 0xFFFFFFF7FFFFFFFFLL | v9;
  *((_QWORD *)a2 + 11) = v10;
  if (!*((_BYTE *)a3 + 1))
  {
    v10 = v8 & 0xFFFFFFE7FFFFFFB8 | 1;
    *((_QWORD *)a2 + 11) = v10;
  }
  return dyld4::SyscallDelegate::setDyldCommPageFlags((uint64_t)a4, v10);
}

uint64_t ___ZN5dyld413ProcessConfig9DyldCache20setPlatformOSVersionERKNS0_7ProcessE_block_invoke(uint64_t result, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(result + 32);
  v4 = *(_QWORD *)(result + 40);
  if (*(_DWORD *)(v4 + 60) == a2)
    goto LABEL_5;
  if (a2 == 6 && *(_BYTE *)(v4 + 149))
  {
    a2 = 6;
LABEL_5:
    *(_DWORD *)(v3 + 144) = a2;
    *(_DWORD *)(v3 + 148) = a3;
  }
  return result;
}

BOOL dyld4::ProcessConfig::DyldCache::findMachHeaderImageIndex(DyldSharedCache **this, const mach_header *a2, unsigned int *a3)
{
  return DyldSharedCache::findMachHeaderImageIndex(*this, a2, a3);
}

uint64_t dyld4::ProcessConfig::DyldCache::getIndexedImagePath(DyldSharedCache **this, int a2)
{
  return DyldSharedCache::getIndexedImagePath(*this, a2);
}

uint64_t dyld4::ProcessConfig::DyldCache::getIndexedImageEntry(DyldSharedCache **this, int a2, unint64_t *a3, unint64_t *a4)
{
  return DyldSharedCache::getIndexedImageEntry(*this, a2, a3, a4);
}

size_t ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke(uint64_t a1, char *__s)
{
  return dyld4::ProcessConfig::PathOverrides::addEnvVar(*(char ***)(a1 + 32), *(const dyld4::ProcessConfig::Process **)(a1 + 40), *(const dyld4::ProcessConfig::Security **)(a1 + 48), *(lsl::Allocator **)(a1 + 56), __s, 1, 0);
}

uint64_t ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke_2(uint64_t a1, char *__s1)
{
  uint64_t result;

  result = _platform_strncmp(__s1, "DYLD_", 5uLL);
  if (!(_DWORD)result)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  return result;
}

size_t dyld4::ProcessConfig::PathOverrides::checkVersionedPath(dyld4::ProcessConfig::PathOverrides *a1, int a2, DyldSharedCache **a3, lsl::Allocator *a4, dyld3 *a5, int a6, uint64_t a7)
{
  size_t result;
  char *v15;
  dyld3::MachOFile *IndexedImageEntry;
  char *v17;
  unsigned int v18;
  char *__source;
  unint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unint64_t v24[128];
  char __s2[1024];
  char v26[1024];

  v23 = 0;
  result = dyld4::SyscallDelegate::getDylibInfo(a2, a5, a6, a7, (uint64_t)&v23, (uint64_t)v26);
  if (!(_DWORD)result)
    return result;
  v21 = 0;
  v22 = 0;
  result = dyld4::SyscallDelegate::getDylibInfo(a2, (dyld3 *)v26, a6, a7, (uint64_t)&v22, (uint64_t)__s2);
  if ((result & 1) == 0)
  {
    if (!*a3
      || !DyldSharedCache::hasImagePath(*a3, v26, &v21)
      || (v24[0] = 0,
          v20 = 0,
          IndexedImageEntry = (dyld3::MachOFile *)DyldSharedCache::getIndexedImageEntry(*a3, v21, v24, &v20),
          __source = 0,
          v18 = 0,
          !dyld3::MachOFile::getDylibInstallName(IndexedImageEntry, (const char **)&__source, &v18, &v22)))
    {
      v17 = v26;
      return (size_t)dyld4::ProcessConfig::PathOverrides::addPathOverride(a1, a4, v17, (const char *)a5);
    }
    result = strlcpy(__s2, __source, 0x400uLL);
  }
  if (v23 > v22)
  {
    v15 = (char *)a1 + 128;
    do
    {
      v15 = *(char **)v15;
      if (!v15)
      {
        v17 = __s2;
        return (size_t)dyld4::ProcessConfig::PathOverrides::addPathOverride(a1, a4, v17, (const char *)a5);
      }
    }
    while (_platform_strcmp(*((const char **)v15 + 1), __s2));
    LODWORD(v20) = 0;
    result = dyld4::SyscallDelegate::getDylibInfo(a2, *((dyld3 **)v15 + 2), a6, a7, (uint64_t)&v20, (uint64_t)v24);
    if ((_DWORD)result)
    {
      if (v23 > v20)
      {
        result = (size_t)lsl::Allocator::strdup(a4, (const char *)a5);
        *((_QWORD *)v15 + 2) = result;
      }
    }
  }
  return result;
}

char *dyld4::ProcessConfig::PathOverrides::addPathOverride(dyld4::ProcessConfig::PathOverrides *this, lsl::Allocator *a2, const char *a3, const char *a4)
{
  _QWORD *v8;
  char *result;
  _QWORD *i;
  _QWORD *v11;
  _QWORD *v12;

  v8 = lsl::Allocator::malloc(a2, 0x18uLL);
  *v8 = 0;
  v8[1] = lsl::Allocator::strdup(a2, a3);
  result = lsl::Allocator::strdup(a2, a4);
  v8[2] = result;
  v12 = (_QWORD *)*((_QWORD *)this + 16);
  v11 = (_QWORD *)((char *)this + 128);
  for (i = v12; i; i = (_QWORD *)*i)
    v11 = i;
  *v11 = v8;
  return result;
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachInColonList(uint64_t result, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  uint64_t v6;
  char *v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  _QWORD v21[2];

  v6 = 0;
  v21[0] = result;
  v21[1] = a2;
  while (2)
  {
    v7 = (char *)v21[v6];
    if (!v7)
      goto LABEL_10;
    v8 = _platform_strlen((const char *)v21[v6]);
    __chkstk_darwin(v8, v9, v10, v11, v12, v13, v14, v15, v20);
    v17 = (char *)&v21[-1] - ((v16 + 16) & 0xFFFFFFFFFFFFFFF0);
    v18 = v7 + 1;
    v19 = v7;
    while (*(v18 - 1) == 58)
    {
      memmove(v17, v19, v7 - v19);
      v7[v17 - v19] = 0;
      result = (*(uint64_t (**)(uint64_t, char *, _BYTE *))(a4 + 16))(a4, v17, a3);
      v19 = v18;
      if (*a3)
        return result;
LABEL_8:
      ++v18;
      ++v7;
    }
    if (*(v18 - 1))
      goto LABEL_8;
    result = (*(uint64_t (**)(uint64_t, char *, _BYTE *))(a4 + 16))(a4, v19, a3);
    if (!*a3)
    {
LABEL_10:
      if (++v6 == 2)
        return result;
      continue;
    }
    return result;
  }
}

uint64_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke(uint64_t a1, char *a2)
{
  uint64_t v2;
  _QWORD v4[5];
  __int128 v5;
  __int128 v6;
  int v7;

  v2 = *(_QWORD *)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_80;
  v4[4] = v2;
  v5 = *(_OWORD *)(a1 + 40);
  v7 = *(_DWORD *)(a1 + 72);
  v6 = *(_OWORD *)(a1 + 56);
  return dyld4::SyscallDelegate::forEachInDirectory(v5, a2, 0, (uint64_t)v4);
}

size_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_2(uint64_t a1, dyld3 *a2)
{
  return dyld4::ProcessConfig::PathOverrides::checkVersionedPath(*(dyld4::ProcessConfig::PathOverrides **)(a1 + 32), *(_QWORD *)(a1 + 40), *(DyldSharedCache ***)(a1 + 48), *(lsl::Allocator **)(a1 + 56), a2, *(_DWORD *)(a1 + 72), *(_QWORD *)(a1 + 64));
}

uint64_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_3(uint64_t a1, char *a2)
{
  uint64_t v2;
  _QWORD v4[5];
  __int128 v5;
  __int128 v6;
  int v7;

  v2 = *(_QWORD *)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_4;
  v4[3] = &__block_descriptor_tmp_83;
  v4[4] = v2;
  v5 = *(_OWORD *)(a1 + 40);
  v7 = *(_DWORD *)(a1 + 72);
  v6 = *(_OWORD *)(a1 + 56);
  return dyld4::SyscallDelegate::forEachInDirectory(v5, a2, 1, (uint64_t)v4);
}

unint64_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_4(uint64_t a1, char *__s)
{
  dyld4::ProcessConfig::PathOverrides *v4;
  unint64_t result;
  char *v6;
  char __dst[1024];

  v4 = *(dyld4::ProcessConfig::PathOverrides **)(a1 + 32);
  result = _platform_strlen(__s);
  if (result >= 0xA)
  {
    result = _platform_strcmp(&__s[result - 10], ".framework");
    if (!(_DWORD)result)
    {
      strlcpy(__dst, __s, 0x400uLL);
      v6 = strrchr(__s, 47);
      strlcat(__dst, v6, 0x400uLL);
      *strrchr(__dst, 46) = 0;
      return dyld4::ProcessConfig::PathOverrides::checkVersionedPath(v4, *(_QWORD *)(a1 + 40), *(DyldSharedCache ***)(a1 + 48), *(lsl::Allocator **)(a1 + 56), (dyld3 *)__dst, *(_DWORD *)(a1 + 72), *(_QWORD *)(a1 + 64));
    }
  }
  return result;
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides20forEachInsertedDylibEU13block_pointerFvPKcRbE_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), a2, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
}

char *dyld4::ProcessConfig::PathOverrides::setString(dyld4::ProcessConfig::PathOverrides *this, lsl::Allocator *a2, char **a3, const char *__s)
{
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *result;
  uint64_t v19;

  if (*a3)
  {
    _platform_strlen(*a3);
    v7 = _platform_strlen(__s);
    __chkstk_darwin(v7, v8, v9, v10, v11, v12, v13, v14, v19);
    v16 = (char *)&v19 - v15;
    v17 = strcpy((char *)&v19 - v15, *a3);
    *(_WORD *)&v16[_platform_strlen(v17)] = 58;
    strcat(v16, __s);
    result = lsl::Allocator::strdup(a2, v16);
  }
  else
  {
    result = lsl::Allocator::strdup(a2, __s);
  }
  *a3 = result;
  return result;
}

uint64_t ___ZN5dyld413ProcessConfig13PathOverrides9addEnvVarERKNS0_7ProcessERKNS0_8SecurityERN3lsl9AllocatorEPKcbPc_block_invoke(uint64_t result, char *__s1)
{
  uint64_t v3;
  int v4;
  size_t v5;
  const char *v6;
  char *v7;
  char *v8;

  v3 = result;
  if (*(_BYTE *)(*(_QWORD *)(result + 40) + 16) || *__s1 != 64)
  {
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24))
      strlcat(*(char **)(result + 48), ":", *(_QWORD *)(result + 56));
    if (_platform_strncmp(__s1, "@executable_path/", 0x11uLL))
    {
      v4 = _platform_strncmp(__s1, "@loader_path/", 0xDuLL);
      v5 = *(_QWORD *)(v3 + 56);
      v6 = *(const char **)(*(_QWORD *)(v3 + 64) + 8);
      v7 = *(char **)(v3 + 48);
      if (v4)
      {
LABEL_12:
        result = strlcpy(v7, v6, v5);
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = 1;
        return result;
      }
      strlcat(v7, v6, v5);
      v8 = *(char **)(v3 + 48);
      result = (uint64_t)strrchr(v8, 47);
      if (!result)
        return result;
      v7 = (char *)(result + 1);
      v6 = __s1 + 13;
    }
    else
    {
      strlcat(*(char **)(v3 + 48), *(const char **)(*(_QWORD *)(v3 + 64) + 8), *(_QWORD *)(v3 + 56));
      v8 = *(char **)(v3 + 48);
      result = (uint64_t)strrchr(v8, 47);
      if (!result)
        return result;
      v7 = (char *)(result + 1);
      v6 = __s1 + 17;
    }
    v5 = *(_QWORD *)(v3 + 56) + v8 - v7;
    goto LABEL_12;
  }
  return result;
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachDylibFallback(uint64_t a1, unsigned int a2, int a3, _BYTE *a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v9;
  int v10;
  _QWORD v11[6];

  result = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(a1 + 64);
  if (result | v9)
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = ___ZNK5dyld413ProcessConfig13PathOverrides20forEachDylibFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke;
    v11[3] = &unk_1E4F7C118;
    v11[4] = a5;
    v11[5] = a4;
    return dyld4::ProcessConfig::PathOverrides::forEachInColonList(result, v9, a4, (uint64_t)v11);
  }
  if (a3 && a2 <= 0xC)
  {
    if (((1 << a2) & 0x83D) != 0)
    {
      if (*(_DWORD *)(a1 + 136) != 2)
      {
        result = (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))(a5, "/usr/local/lib", 15, a4);
        if (*a4)
          return result;
      }
    }
    else if (((1 << a2) & 0x13C0) == 0)
    {
      if (a2 == 1)
      {
        v10 = *(_DWORD *)(a1 + 136);
        if (v10 == 1)
          return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))(a5, "/usr/lib", 15, a4);
        if (!v10)
        {
          result = (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))(a5, "/usr/local/lib", 15, a4);
          if (!*a4)
            return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))(a5, "/usr/lib", 15, a4);
        }
      }
      return result;
    }
    if (*(_DWORD *)(a1 + 136) != 2)
      return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))(a5, "/usr/lib", 15, a4);
  }
  return result;
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides20forEachDylibFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), a2, 14, *(_QWORD *)(a1 + 40));
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides24forEachFrameworkFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), a2, 14, *(_QWORD *)(a1 + 40));
}

size_t dyld4::ProcessConfig::PathOverrides::addSuffix(dyld4::ProcessConfig::PathOverrides *this, const char *a2, const char *a3, char *__dst)
{
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  const char *v12;

  strlcpy(__dst, a2, 0x400uLL);
  v7 = strrchr(__dst, 47);
  if (v7)
    v8 = v7 + 1;
  else
    v8 = __dst;
  v9 = strrchr(v8, 46);
  if (v9)
  {
    v10 = v9;
    strlcpy(v9, a3, 0x400uLL);
    v11 = &v10[_platform_strlen(a3)];
    v12 = &a2[v10 - __dst];
  }
  else
  {
    v11 = __dst;
    v12 = a3;
  }
  return strlcat(v11, v12, 0x400uLL);
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachImageSuffixEPKcNS1_4TypeERbU13block_pointerFvS3_S4_S5_E_block_invoke(uint64_t a1, const char *a2)
{
  const char *v4;
  size_t v5;
  dyld4::ProcessConfig::PathOverrides *v6;
  uint64_t v8;

  v4 = *(const char **)(a1 + 48);
  v5 = _platform_strlen(v4);
  v6 = (dyld4::ProcessConfig::PathOverrides *)_platform_strlen(a2);
  dyld4::ProcessConfig::PathOverrides::addSuffix(v6, v4, a2, (char *)&v8 - (((unint64_t)v6 + v5 + 23) & 0xFFFFFFFFFFFFFFF0));
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke(uint64_t a1, char *__s)
{
  uint64_t v4;
  size_t v5;
  size_t v6;
  char *v7;
  uint64_t v9;

  v4 = *(_QWORD *)(a1 + 40);
  v5 = _platform_strlen(__s) + *(_QWORD *)(a1 + 48);
  v6 = v5 + 8;
  v7 = (char *)&v9 - ((v5 + 23) & 0xFFFFFFFFFFFFFFF0);
  strlcpy(v7, __s, v5 + 8);
  strlcat(v7, "/", v6);
  strlcat(v7, *(const char **)(a1 + 56), v6);
  return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(v4, (uint64_t)v7, 0, *(_BYTE **)(a1 + 64), *(_QWORD *)(a1 + 32));
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_2(uint64_t a1, char *__s)
{
  uint64_t v4;
  size_t v5;
  size_t v6;
  char *v7;
  uint64_t v9;

  v4 = *(_QWORD *)(a1 + 40);
  v5 = _platform_strlen(__s) + *(_QWORD *)(a1 + 48);
  v6 = v5 + 8;
  v7 = (char *)&v9 - ((v5 + 23) & 0xFFFFFFFFFFFFFFF0);
  strlcpy(v7, __s, v5 + 8);
  strlcat(v7, "/", v6);
  strlcat(v7, *(const char **)(a1 + 56), v6);
  return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(v4, (uint64_t)v7, 0, *(_BYTE **)(a1 + 64), *(_QWORD *)(a1 + 32));
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_3(uint64_t a1, char *__s, uint64_t a3)
{
  uint64_t v6;
  size_t v7;
  size_t v8;
  char *v9;
  uint64_t result;
  uint64_t v11;

  v6 = *(_QWORD *)(a1 + 40);
  v7 = _platform_strlen(__s) + *(_QWORD *)(a1 + 48);
  v8 = v7 + 8;
  v9 = (char *)&v11 - ((v7 + 23) & 0xFFFFFFFFFFFFFFF0);
  strlcpy(v9, __s, v7 + 8);
  strlcat(v9, "/", v8);
  strlcat(v9, *(const char **)(a1 + 56), v8);
  result = _platform_strcmp(*(const char **)(a1 + 64), v9);
  if ((_DWORD)result)
    return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(v6, (uint64_t)v9, a3, *(_BYTE **)(a1 + 72), *(_QWORD *)(a1 + 32));
  return result;
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_4(uint64_t a1, char *__s, uint64_t a3)
{
  uint64_t v6;
  size_t v7;
  size_t v8;
  char *v9;
  uint64_t result;
  uint64_t v11;

  v6 = *(_QWORD *)(a1 + 40);
  v7 = _platform_strlen(__s) + *(_QWORD *)(a1 + 48);
  v8 = v7 + 8;
  v9 = (char *)&v11 - ((v7 + 23) & 0xFFFFFFFFFFFFFFF0);
  strlcpy(v9, __s, v7 + 8);
  strlcat(v9, "/", v8);
  strlcat(v9, *(const char **)(a1 + 56), v8);
  result = _platform_strcmp(v9, *(const char **)(a1 + 64));
  if ((_DWORD)result)
    return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(v6, (uint64_t)v9, a3, *(_BYTE **)(a1 + 72), *(_QWORD *)(a1 + 32));
  return result;
}

_QWORD *dyld4::PseudoDylib::create(lsl::Allocator *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *result;

  if (!a3)
    dyld4::PseudoDylib::create();
  if (!a5)
    dyld4::PseudoDylib::create();
  if (a2 <= a3 || a2 - a4 >= a3)
    dyld4::PseudoDylib::create();
  result = lsl::Allocator::aligned_alloc(a1, 8uLL, 0x28uLL);
  *result = a3;
  result[1] = a4;
  result[2] = a5;
  result[3] = a6;
  result[4] = a2;
  return result;
}

const char *dyld4::PseudoDylib::loadableAtPath(dyld4::PseudoDylib *this, const char *__s2)
{
  uint64_t (*v3)(_QWORD, _QWORD, const char *);

  v3 = *(uint64_t (**)(_QWORD, _QWORD, const char *))(*((_QWORD *)this + 2) + 48);
  if (v3)
    return (const char *)v3(*((_QWORD *)this + 3), *(_QWORD *)this, __s2);
  if (_platform_strcmp(*((const char **)this + 4), __s2))
    return 0;
  return __s2;
}

uint64_t dyld4::PseudoDylib::disposeString(uint64_t (***this)(char *), char *a2)
{
  return (*this[2])(a2);
}

uint64_t dyld4::PseudoDylib::initialize(dyld4::PseudoDylib *this)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*((_QWORD *)this + 2) + 8))(*((_QWORD *)this + 3), *(_QWORD *)this);
}

uint64_t dyld4::PseudoDylib::lookupSymbols(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
    dyld4::PseudoDylib::lookupSymbols();
  if (a3 != a7)
    dyld4::PseudoDylib::lookupSymbols();
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(a1[2] + 24))(a1[3], *a1, a2, a3, a4);
}

uint64_t dyld4::PseudoDylib::finalizeRequestedSymbols(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v3)(_QWORD, _QWORD, uint64_t, uint64_t);

  v3 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t))(a1[2] + 56);
  if (v3)
    return v3(a1[3], *a1, a2, a3);
  else
    return 0;
}

uint64_t dyld4::PseudoDylib::lookupAddress(dyld4::PseudoDylib *this, const void *a2, dl_info *a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, const void *, dl_info *))(*((_QWORD *)this + 2) + 32))(*((_QWORD *)this + 3), *(_QWORD *)this, a2, a3);
}

uint64_t dyld4::PseudoDylib::findUnwindSections(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3)
    dyld4::PseudoDylib::findUnwindSections();
  if (!a4)
    dyld4::PseudoDylib::findUnwindSections();
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t))(a1[2] + 40))(a1[3], *a1, a2, a3);
}

uint64_t (***dyld4::RuntimeLocks::resetLockInForkChild(dyld4::RuntimeLocks *this))(_QWORD)
{
  uint64_t (***result)(_QWORD);

  result = *(uint64_t (****)(_QWORD))this;
  if (result)
  {
    result = (uint64_t (***)(_QWORD))(**result)(result);
    if ((unint64_t)result >= 2)
    {
      (*(void (**)(_QWORD, char *))(**(_QWORD **)this + 152))(*(_QWORD *)this, (char *)this + 8);
      (*(void (**)(_QWORD, char *))(**(_QWORD **)this + 152))(*(_QWORD *)this, (char *)this + 16);
      result = (uint64_t (***)(_QWORD))(*(uint64_t (**)(_QWORD, char *))(**(_QWORD **)this + 152))(*(_QWORD *)this, (char *)this + 24);
      *((_QWORD *)this + 5) = 0;
    }
  }
  return result;
}

uint64_t (***dyld4::RuntimeLocks::resetDlopenLockInForkChild(dyld4::RuntimeLocks *this))(_QWORD)
{
  uint64_t (***result)(_QWORD);

  result = *(uint64_t (****)(_QWORD))this;
  if (result)
  {
    result = (uint64_t (***)(_QWORD))(**result)(result);
    if ((unint64_t)result >= 2)
      return (uint64_t (***)(_QWORD))(*(uint64_t (**)(_QWORD, char *))(**(_QWORD **)this + 152))(*(_QWORD *)this, (char *)this + 32);
  }
  return result;
}

uint64_t dyld4::RuntimeState::appLoadAddress(dyld4::RuntimeState *this, unsigned int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 127);
  if (!v2)
    dyld4::RuntimeState::appLoadAddress();
  if (*(_DWORD *)(v2 + 12) <= a2)
    dyld4::RuntimeState::appLoadAddress();
  return *(_QWORD *)(*((_QWORD *)this + 129) + 8 * a2);
}

uint64_t dyld4::RuntimeState::cachedDylibLoadAddress(dyld4::RuntimeState *this, unsigned int a2)
{
  uint64_t v2;
  unint64_t v4;
  unint64_t v5;

  v2 = *((_QWORD *)this + 1);
  if (*(_DWORD *)(v2 + 392) <= a2)
    dyld4::RuntimeState::cachedDylibLoadAddress();
  v4 = 0;
  v5 = 0;
  return DyldSharedCache::getIndexedImageEntry(*(DyldSharedCache **)(v2 + 240), a2, &v5, &v4);
}

void dyld4::RuntimeState::printLinkageChain(dyld4::RuntimeState *a1, uint64_t *a2, const char *a3)
{
  uint64_t *v6;
  char v7;
  char *v8;
  char __dst[8];
  char v10[2048];

  v10[0] = 0;
  if (a2)
  {
    v6 = a2;
    while (v6 == a2)
    {
LABEL_10:
      v8 = dyld4::Loader::leafName((dyld4::Loader *)v6[1], a1);
      strlcat(v10, v8, 0x800uLL);
      v6 = (uint64_t *)*v6;
      if (!v6)
        goto LABEL_16;
    }
    __dst[0] = 0;
    v7 = *((_BYTE *)v6 + 16);
    if ((v7 & 2) != 0)
    {
      strlcat(__dst, "r", 8uLL);
      v7 = *((_BYTE *)v6 + 16);
      if ((v7 & 1) == 0)
      {
LABEL_6:
        if ((v7 & 4) == 0)
          goto LABEL_7;
        goto LABEL_14;
      }
    }
    else if ((v6[2] & 1) == 0)
    {
      goto LABEL_6;
    }
    strlcat(__dst, "w", 8uLL);
    v7 = *((_BYTE *)v6 + 16);
    if ((v7 & 4) == 0)
    {
LABEL_7:
      if ((v7 & 8) == 0)
      {
LABEL_9:
        strlcat(v10, " -", 0x800uLL);
        strlcat(v10, __dst, 0x800uLL);
        strlcat(v10, "-> ", 0x800uLL);
        goto LABEL_10;
      }
LABEL_8:
      strlcat(__dst, "d", 8uLL);
      goto LABEL_9;
    }
LABEL_14:
    strlcat(__dst, "u", 8uLL);
    if ((v6[2] & 8) == 0)
      goto LABEL_9;
    goto LABEL_8;
  }
LABEL_16:
  dyld4::RuntimeState::log(a1, "%s: %s\n", a3, v10);
}

void dyld4::RuntimeState::log(dyld4::RuntimeState *this, char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  dyld4::RuntimeState::vlog(this, a2, va);
}

uint64_t dyld4::RuntimeState::recursiveMarkNonDelayed(uint64_t a1, dyld4::Loader *a2, uint64_t *a3, char **a4)
{
  uint64_t result;
  uint64_t v9;
  size_t v10;
  const void *v11;
  char *v12;
  char *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  dyld4::Loader **v18;
  char *v19;
  char *v20;
  uint64_t v21;
  char v22;
  char __dst[72];

  result = dyld4::Loader::isDelayInit(a2, (dyld4::RuntimeState *)a1);
  if ((_DWORD)result)
  {
    dyld4::Loader::setDelayInit(a2, (dyld4::RuntimeState *)a1, 0);
    v9 = *(_QWORD *)(a1 + 8);
    v10 = *(_QWORD *)(v9 + 232);
    if (v10)
    {
      v11 = *(const void **)(v9 + 224);
      v12 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)a1);
      if (v10 == _platform_strlen(v12) && !_platform_memcmp(v11, v12, v10))
      {
        if (*(_BYTE *)(a1 + 680))
          strcpy(__dst, "no longer delayed(");
        else
          strcpy(__dst, "not delayed at launch(");
        v13 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)a1);
        strlcat(__dst, v13, 0x40uLL);
        strlcat(__dst, ")", 0x40uLL);
        dyld4::RuntimeState::printLinkageChain((dyld4::RuntimeState *)a1, a3, __dst);
      }
    }
    result = dyld4::Loader::dependentCount(a2);
    if ((_DWORD)result)
    {
      v14 = result;
      v15 = 0;
      do
      {
        v22 = 0;
        result = dyld4::Loader::dependent(a2, (dyld4::RuntimeState *)a1, v15, &v22);
        if (result && (v22 & 8) == 0)
        {
          *(_QWORD *)__dst = 0;
          *(_QWORD *)&__dst[8] = result;
          __dst[16] = v22;
          *a4 = __dst;
          result = dyld4::RuntimeState::recursiveMarkNonDelayed(a1, result, a3, __dst);
        }
        v15 = (v15 + 1);
      }
      while (v14 != (_DWORD)v15);
    }
    v16 = *(_QWORD *)(a1 + 968);
    if (v16)
    {
      v17 = 16 * v16;
      v18 = (dyld4::Loader **)(*(_QWORD *)(a1 + 960) + 8);
      do
      {
        if (*(v18 - 1) == a2)
        {
          if (*(_BYTE *)(*(_QWORD *)(a1 + 8) + 200))
          {
            v19 = dyld4::Loader::leafName(*v18, (const dyld4::RuntimeState *)a1);
            v20 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)a1);
            dyld4::RuntimeState::log((dyld4::RuntimeState *)a1, "%s has weak-def (or flat lookup) symbol used by %s, so cannot be delayed\n", v19, v20);
          }
          *(_QWORD *)__dst = 0;
          *(_QWORD *)&__dst[8] = *v18;
          v21 = *(_QWORD *)&__dst[8];
          __dst[16] = mach_o::LinkedDylibAttributes::regular;
          *a4 = __dst;
          result = dyld4::RuntimeState::recursiveMarkNonDelayed(a1, v21, a3, __dst);
        }
        v18 += 2;
        v17 -= 16;
      }
      while (v17);
    }
  }
  return result;
}

uint64_t dyld4::RuntimeState::partitionDelayLoads(uint64_t result, dyld4::Loader **a2, uint64_t a3, dyld4::Loader **a4, uint64_t a5, uint64_t a6)
{
  dyld4::Loader **v10;
  dyld4::RuntimeState *v11;
  uint64_t v12;
  uint64_t v13;
  dyld4::Loader **v14;
  dyld4::Loader *v15;
  uint64_t v16;
  dyld4::Loader *v17;
  uint64_t v19;
  dyld4::Loader **v20;
  dyld4::Loader *v21;
  dyld3::MachOFile *v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  dyld4::Loader *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  dyld4::Loader *v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  dyld4::Loader *v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  dyld4::Loader *v48;
  char v49;

  v10 = a2;
  v11 = (dyld4::RuntimeState *)result;
  v12 = 8 * a3;
  if (a3)
  {
    v13 = 8 * a3;
    v14 = a2;
    do
    {
      v15 = *v14++;
      result = dyld4::Loader::setDelayInit(v15, v11, 1);
      v13 -= 8;
    }
    while (v13);
  }
  if (a5)
  {
    v16 = 8 * a5;
    do
    {
      v17 = *a4++;
      v47 = 0;
      v48 = v17;
      v49 = mach_o::LinkedDylibAttributes::regular;
      result = dyld4::RuntimeState::recursiveMarkNonDelayed((uint64_t)v11, v17, (uint64_t *)&v47, &v47);
      v16 -= 8;
    }
    while (v16);
  }
  if (*((_QWORD *)v11 + 22))
  {
    if (*(_BYTE *)(*((_QWORD *)v11 + 1) + 190) && a3 != 0)
    {
      v19 = v12;
      v20 = v10;
      do
      {
        v21 = *v20;
        result = dyld4::Loader::mf(*v20, v11);
        if ((*((_WORD *)v21 + 2) & 2) == 0)
        {
          v22 = (dyld3::MachOFile *)result;
          result = dyld3::MachOFile::isDylib((dyld3::MachOFile *)result);
          if ((_DWORD)result)
          {
            result = dyld3::MachOFile::hasInterposingTuples(v22);
            if ((_DWORD)result)
            {
              if (*(_BYTE *)(*((_QWORD *)v11 + 1) + 200))
              {
                v23 = dyld4::Loader::leafName(v21, v11);
                dyld4::RuntimeState::log(v11, "has interposing tuples so cannot be delayed: %s\n", v23);
              }
              v47 = 0;
              v48 = v21;
              v49 = mach_o::LinkedDylibAttributes::regular;
              result = dyld4::RuntimeState::recursiveMarkNonDelayed((uint64_t)v11, v21, (uint64_t *)&v47, &v47);
            }
          }
        }
        ++v20;
        v19 -= 8;
      }
      while (v19);
    }
  }
  v24 = a6;
  if (*((_QWORD *)v11 + 10))
  {
    v25 = 0;
    do
    {
      v26 = *(dyld4::Loader **)(*((_QWORD *)v11 + 9) + 8 * v25);
      result = dyld4::Loader::isDelayInit(v26, v11);
      if ((result & 1) == 0)
      {
        lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)v11 + 32, *((_QWORD *)v11 + 6) + 1);
        v27 = *((_QWORD *)v11 + 5);
        v28 = *((_QWORD *)v11 + 6);
        *((_QWORD *)v11 + 6) = v28 + 1;
        *(_QWORD *)(v27 + 8 * v28) = v26;
        if (*(_BYTE *)(*((_QWORD *)v11 + 1) + 200))
        {
          v29 = dyld4::Loader::leafName(v26, v11);
          dyld4::RuntimeState::log(v11, "move delayed to loaded: %s\n", v29);
        }
        v31 = *((_QWORD *)v11 + 9);
        v30 = *((_QWORD *)v11 + 10);
        result = v31 + 8 * v25;
        v32 = v31 + 8 * v30;
        if (v32 != result + 8)
        {
          result = (uint64_t)memmove((void *)result, (const void *)(result + 8), v32 - (result + 8));
          v30 = *((_QWORD *)v11 + 10);
        }
        *((_QWORD *)v11 + 10) = v30 - 1;
        if (v24)
        {
          result = lsl::Vector<dyld4::Loader const*>::reserve(v24, *(_QWORD *)(v24 + 16) + 1);
          v33 = *(_QWORD *)(v24 + 8);
          v34 = *(_QWORD *)(v24 + 16);
          *(_QWORD *)(v24 + 16) = v34 + 1;
          *(_QWORD *)(v33 + 8 * v34) = v26;
        }
        --v25;
      }
      ++v25;
    }
    while (v25 < *((_QWORD *)v11 + 10));
  }
  if (*((_QWORD *)v11 + 6))
  {
    v35 = 0;
    do
    {
      v36 = *(dyld4::Loader **)(*((_QWORD *)v11 + 5) + 8 * v35);
      result = dyld4::Loader::isDelayInit(v36, v11);
      if ((result & 1) != 0)
      {
        lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)v11 + 64, *((_QWORD *)v11 + 10) + 1);
        v37 = *((_QWORD *)v11 + 9);
        v38 = *((_QWORD *)v11 + 10);
        *((_QWORD *)v11 + 10) = v38 + 1;
        *(_QWORD *)(v37 + 8 * v38) = v36;
        if (*(_BYTE *)(*((_QWORD *)v11 + 1) + 200))
        {
          v39 = dyld4::Loader::leafName(v36, v11);
          dyld4::RuntimeState::log(v11, "move loaded to delayed: %s\n", v39);
        }
        v41 = *((_QWORD *)v11 + 5);
        v40 = *((_QWORD *)v11 + 6);
        result = v41 + 8 * v35;
        v42 = v41 + 8 * v40;
        if (v42 != result + 8)
        {
          result = (uint64_t)memmove((void *)result, (const void *)(result + 8), v42 - (result + 8));
          v40 = *((_QWORD *)v11 + 6);
        }
        v43 = v40 - 1;
        *((_QWORD *)v11 + 6) = v43;
        --v35;
      }
      else
      {
        v43 = *((_QWORD *)v11 + 6);
      }
      ++v35;
    }
    while (v35 < v43);
  }
  if (v24 && a3)
  {
    do
    {
      v44 = *v10;
      result = dyld4::Loader::isDelayInit(*v10, v11);
      if ((result & 1) == 0)
      {
        result = lsl::Vector<dyld4::Loader const*>::reserve(v24, *(_QWORD *)(v24 + 16) + 1);
        v45 = *(_QWORD *)(v24 + 8);
        v46 = *(_QWORD *)(v24 + 16);
        *(_QWORD *)(v24 + 16) = v46 + 1;
        *(_QWORD *)(v45 + 8 * v46) = v44;
      }
      ++v10;
      v12 -= 8;
    }
    while (v12);
  }
  return result;
}

void ___ZN5dyld412RuntimeState13setMainLoaderEPKNS_6LoaderE_block_invoke(_QWORD *a1, uint64_t a2)
{
  dyld4::RuntimeState *v3;
  vm_size_t v4;
  uint64_t v5;
  int v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = (dyld4::RuntimeState *)a1[5];
  v4 = (*(_QWORD *)(a2 + 8) + vm_page_size - 1) & -(uint64_t)vm_page_size;
  if (!v4)
  {
    if (*(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24))
      v4 = 0;
    else
      v4 = a1[7];
  }
  if (*(_BYTE *)(*((_QWORD *)v3 + 1) + 201))
  {
    v5 = a1[6] + *(_QWORD *)(a2 + 16);
    v6 = *(_DWORD *)(a2 + 52);
    v7 = (const char *)dyld3::MachOLoaded::segmentName((dyld3::MachOLoaded *)a1[7], *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24));
    v8 = 120;
    if ((v6 & 4) == 0)
      v8 = 46;
    v9 = 119;
    if ((v6 & 2) == 0)
      v9 = 46;
    v11 = v8;
    v10 = 114;
    if ((v6 & 1) == 0)
      v10 = 46;
    dyld4::RuntimeState::log(v3, "%14s (%c%c%c) 0x%012llX->0x%012llX \n", v7, v10, v9, v11, v5, v4 + v5);
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
}

void dyld4::RuntimeState::vlog(dyld4::RuntimeState *this, char *a2, char *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  int v13;
  size_t v14;
  int v15;
  char __str[2048];

  os_unfair_lock_lock((os_unfair_lock_t)(*((_QWORD *)this + 17) + 44));
  if (!*((_BYTE *)this + 1157))
    dyld4::RuntimeState::setUpLogging(this);
  if (*((_BYTE *)this + 1156))
  {
    if (snprintf(__str, 0x800uLL, "<%d>%s[%d]: ", 13, *(const char **)(*((_QWORD *)this + 1) + 136), *(_DWORD *)(*((_QWORD *)this + 1) + 152)) >= 1)
    {
      v12 = _platform_strlen(__str);
      if (vsnprintf(&__str[v12], 2048 - v12, a2, a3) >= 1)
      {
        v13 = *((_DWORD *)this + 288);
        v14 = _platform_strlen(__str);
        sendto(v13, __str, v14, 0, 0, 0);
      }
    }
  }
  else
  {
    v15 = *((_DWORD *)this + 288);
    if (v15 != -1)
    {
      _simple_dprintf(v15, "dyld[%d]: ", v6, v7, v8, v9, v10, v11, *(_DWORD *)(*((_QWORD *)this + 1) + 152));
      _simple_vdprintf(*((_DWORD *)this + 288), a2, (int *)a3);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(*((_QWORD *)this + 17) + 44));
}

const os_unfair_lock *dyld4::RuntimeState::setUpLogging(dyld4::RuntimeState *this)
{
  lsl::Lock *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v7;
  char v8;
  int v9;
  uint64_t v10;
  stat v11;
  _WORD v12[49];
  uint64_t v13;

  v2 = (lsl::Lock *)*((_QWORD *)this + 16);
  lsl::MemoryManager::lockGuard(v2, (lsl::Lock **)&v11);
  v3 = *((_QWORD *)v2 + 3);
  if (!v3)
  {
    lsl::MemoryManager::writeProtect(v2, 0);
    v3 = *((_QWORD *)v2 + 3);
  }
  *((_QWORD *)v2 + 3) = v3 + 1;
  lsl::Lock::unlock(*(lsl::Lock **)&v11.st_dev);
  v4 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v4 + 216) || *(_BYTE *)(v4 + 217))
  {
    *((_DWORD *)this + 288) = *(_DWORD *)(v4 + 212);
    *((_WORD *)this + 578) = 256;
    goto LABEL_6;
  }
  if (*(_DWORD *)(v4 + 152) == 1)
  {
    v7 = dyld4::SyscallDelegate::open((dyld4::SyscallDelegate *)v4, (dyld3 *)"/dev/console", (const char *)0x20001, 0);
LABEL_13:
    v8 = 0;
    *((_DWORD *)this + 288) = v7;
LABEL_14:
    *((_BYTE *)this + 1156) = v8;
    *((_BYTE *)this + 1157) = 1;
    goto LABEL_15;
  }
  if ((dyld4::SyscallDelegate::fstat((dyld4::SyscallDelegate *)v4, *(_DWORD *)(v4 + 212), &v11) & 0x80000000) == 0)
  {
    v7 = *(_DWORD *)(*((_QWORD *)this + 1) + 212);
    goto LABEL_13;
  }
  v10 = *((_QWORD *)this + 19);
  if (v10 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 96))(v10) & 1) != 0)
  {
    v8 = 1;
    goto LABEL_14;
  }
LABEL_15:
  if (!*((_BYTE *)this + 1156))
    goto LABEL_6;
  v9 = dyld4::SyscallDelegate::socket(*((dyld4::SyscallDelegate **)this + 1), 1, 2, 0);
  *((_DWORD *)this + 288) = v9;
  if (v9 != -1)
  {
    dyld4::SyscallDelegate::fcntl(*((dyld4::SyscallDelegate **)this + 1), v9, 2, (void *)1);
    strcpy((char *)&v12[1], "/var/run/syslog");
    HIBYTE(v12[0]) = 1;
    v13 = 0;
    memset(&v12[9], 0, 80);
    if (dyld4::SyscallDelegate::connect(*((dyld4::SyscallDelegate **)this + 1), *((_DWORD *)this + 288), (const sockaddr *)v12, 0x6Au) == -1)
    {
      dyld4::SyscallDelegate::close(*((dyld4::SyscallDelegate **)this + 1), *((_DWORD *)this + 288));
      *((_DWORD *)this + 288) = -1;
    }
    else if (*((_DWORD *)this + 288) != -1)
    {
      goto LABEL_6;
    }
  }
  *((_BYTE *)this + 1156) = 0;
LABEL_6:
  lsl::MemoryManager::lockGuard(v2, (lsl::Lock **)&v11);
  v5 = *((_QWORD *)v2 + 3) - 1;
  *((_QWORD *)v2 + 3) = v5;
  if (!v5)
    lsl::MemoryManager::writeProtect(v2, 1);
  return lsl::Lock::unlock(*(lsl::Lock **)&v11.st_dev);
}

uint64_t dyld4::RuntimeState::addMissingFlatLazySymbol(dyld4::RuntimeState *this, const dyld4::Loader *a2, const char *a3, unint64_t *a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;

  result = lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)this + 920, *((_QWORD *)this + 117) + 1);
  v9 = *((_QWORD *)this + 116);
  v10 = *((_QWORD *)this + 117);
  *((_QWORD *)this + 117) = v10 + 1;
  v11 = (_QWORD *)(v9 + 24 * v10);
  *v11 = a2;
  v11[1] = a3;
  v11[2] = a4;
  return result;
}

uint64_t dyld4::RuntimeState::removeMissingFlatLazySymbols(uint64_t result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  __int128 v14;

  v2 = *(_QWORD **)(result + 928);
  v3 = *(_QWORD *)(result + 936);
  v4 = &v2[3 * v3];
  v5 = v2;
  if (v3)
  {
    v6 = *(_QWORD *)(a2 + 8);
    v5 = *(_QWORD **)(result + 928);
    while (1)
    {
      if (v6)
      {
        v7 = 8 * v6;
        v8 = *(_QWORD **)a2;
        while (*v8 != *v5)
        {
          ++v8;
          v7 -= 8;
          if (!v7)
          {
            v8 = (_QWORD *)(*(_QWORD *)a2 + 8 * v6);
            break;
          }
        }
      }
      else
      {
        v8 = *(_QWORD **)a2;
      }
      if (v6 != ((uint64_t)v8 - *(_QWORD *)a2) >> 3)
        break;
      v5 += 3;
      if (v5 == v4)
        goto LABEL_24;
    }
  }
  if (v5 == v4)
  {
LABEL_24:
    v5 = &v2[3 * v3];
  }
  else
  {
    v9 = v5 + 3;
    if (v5 + 3 != v4)
    {
      do
      {
        v10 = *(_QWORD **)a2;
        v11 = *(_QWORD *)(a2 + 8);
        if (v11)
        {
          v12 = 8 * v11;
          v13 = *(_QWORD **)a2;
          while (*v13 != *v9)
          {
            ++v13;
            v12 -= 8;
            if (!v12)
            {
              v13 = &v10[v11];
              break;
            }
          }
        }
        else
        {
          v13 = *(_QWORD **)a2;
        }
        if (v11 == v13 - v10)
        {
          v14 = *(_OWORD *)v9;
          v5[2] = v9[2];
          *(_OWORD *)v5 = v14;
          v5 += 3;
        }
        v9 += 3;
      }
      while (v9 != v4);
      v2 = *(_QWORD **)(result + 928);
      v3 = *(_QWORD *)(result + 936);
    }
  }
  *(_QWORD *)(result + 936) = v3 + 0x5555555555555555 * (&v2[3 * v3] - v5);
  return result;
}

double __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__0(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

uint64_t dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](_QWORD *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = a1[2];
  v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5)
      dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve(a1, a2 + 1);
    a1[2] = v5;
  }
  return *a1 + 32 * a2;
}

dyld3::MachOFile *dyld4::RuntimeState::checkHiddenCacheAddr(dyld3::MachOFile *result, uint64_t a2, uint64_t a3, const unsigned __int8 *a4, uint64_t *a5)
{
  dyld3::MachOFile *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  char v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _WORD v17[5];

  if (a2)
  {
    if ((*(_WORD *)(a2 + 4) & 1) == 0)
    {
      v8 = result;
      memset(v17, 0, sizeof(v17));
      result = (dyld3::MachOFile *)dyld4::JustInTimeLoader::overridesDylibInCache(a2, &v17[1], v17);
      if ((_DWORD)result)
      {
        v15 = 0;
        v16 = 0;
        result = (dyld3::MachOFile *)DyldSharedCache::getIndexedImageEntry(*(DyldSharedCache **)(*((_QWORD *)v8 + 1) + 240), v17[0], &v16, &v15);
        if (result)
        {
          v14 = 0;
          v13 = 0;
          result = (dyld3::MachOFile *)dyld3::MachOLoaded::hasExportedSymbol(result, a4, 0, &v14, &v13);
          if ((_DWORD)result)
          {
            v9 = v14;
            result = (dyld3::MachOFile *)dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace(a5, 1);
            v10 = *a5;
            v11 = a5[2];
            a5[2] = v11 + 1;
            v12 = (_QWORD *)(v10 + 16 * v11);
            *v12 = v9;
            v12[1] = a3;
          }
        }
      }
    }
  }
  return result;
}

void dyld4::RuntimeState::appendInterposingTuples(uint64_t **this, const dyld4::Loader *a2, const unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v4;
  unsigned int v8;
  unint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  const unsigned __int8 *v12;
  char *v13;
  uint64_t Address;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  char v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  char *v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t *v40;
  char *v41;
  vm_address_t **v42[2];
  uint64_t **v43;
  _QWORD v44[12];
  _QWORD v45[10];
  _QWORD v46[12];
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t (*v50)(uint64_t, uint64_t);
  void (*v51)(uint64_t);
  uint64_t v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  double (*v56)(uint64_t, uint64_t);
  _QWORD *(*v57)(_QWORD *);
  uint64_t *v58;
  uint64_t v59;
  uint64_t v60;
  vm_address_t v61;
  vm_size_t v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  __n128 (*v66)(uint64_t, uint64_t);
  uint64_t (*v67)();
  char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;

  if (*((_BYTE *)this[1] + 190))
  {
    v63 = 0;
    v64 = &v63;
    v65 = 0x4002000000;
    v66 = __Block_byref_object_copy__47;
    v67 = __Block_byref_object_dispose__48;
    v68 = (char *)v42 - v4;
    v69 = a4;
    v70 = 0;
    if (a4)
    {
      v8 = a4;
      do
      {
        v9 = v64[7];
        if (v9 >= v64[6])
          dyld4::RuntimeState::appendInterposingTuples((uint64_t)this, (uint64_t)a2, (uint64_t)a3);
        v10 = v64[5];
        v64[7] = v9 + 1;
        v11 = (_OWORD *)(v10 + 32 * v9);
        *v11 = 0uLL;
        v11[1] = 0uLL;
        --v8;
      }
      while (v8);
    }
    v42[1] = (vm_address_t **)v42;
    v53 = 0;
    v54 = &v53;
    v12 = &a3[16 * a4];
    v55 = 0x5002000000;
    v56 = __Block_byref_object_copy__49;
    v57 = __Block_byref_object_dispose__50;
    v58 = &v71;
    v59 = 32;
    v61 = 0;
    v62 = 0;
    v60 = 0;
    v47 = 0;
    v48 = &v47;
    v50 = __Block_byref_object_copy__51;
    v51 = __Block_byref_object_dispose__52;
    v49 = 0x3002000000;
    v42[0] = (vm_address_t **)&v52;
    Diagnostics::Diagnostics((Diagnostics *)&v52);
    v13 = (char *)dyld4::Loader::analyzer(a2, (dyld4::RuntimeState *)this);
    if ((dyld3::MachOFile::hasChainedFixups((dyld3::MachOFile *)v13) & 1) != 0)
    {
      v46[0] = _NSConcreteStackBlock;
      v46[1] = 0x40000000;
      v46[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke;
      v46[3] = &unk_1E4F7C9F8;
      v46[8] = v13;
      v46[9] = a2;
      v46[4] = &v47;
      v46[5] = &v53;
      v46[10] = a3;
      v46[11] = v12;
      v46[6] = &v63;
      v46[7] = this;
      dyld3::MachOAnalyzer::withChainStarts(v13, (vm_address_t *)v48 + 5, 0, (uint64_t)v46);
    }
    else
    {
      Address = dyld3::MachOFile::preferredLoadAddress((dyld3::MachOFile *)v13);
      v45[0] = _NSConcreteStackBlock;
      v45[1] = 0x40000000;
      v45[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_3;
      v45[3] = &unk_1E4F7CA20;
      v45[6] = a3;
      v45[7] = v12;
      v45[4] = &v63;
      v45[5] = v13;
      v45[8] = &v13[-Address];
      v45[9] = a2;
      dyld3::MachOAnalyzer::forEachRebase((dyld3::MachOFile *)v13, (vm_address_t *)v48 + 5, 0, (uint64_t)v45);
      v44[0] = _NSConcreteStackBlock;
      v44[1] = 0x40000000;
      v44[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_4;
      v44[3] = &unk_1E4F7CA48;
      v44[8] = v13;
      v44[9] = a3;
      v44[10] = v12;
      v44[11] = a2;
      v44[4] = &v47;
      v44[5] = &v63;
      v44[6] = &v53;
      v44[7] = this;
      dyld3::MachOAnalyzer::forEachBind((dyld3::MachOFile *)v13, (vm_address_t *)v48 + 5, (uint64_t)v44, (uint64_t)&__block_literal_global);
    }
    v15 = v64[7];
    if (v15)
    {
      v16 = v64[5];
      v17 = v16 + 32 * v15;
      v43 = this + 24;
      do
      {
        v18 = *(_QWORD *)(v16 + 16);
        if (v18)
        {
          v19 = *(_QWORD *)(v16 + 8);
          if (v19)
          {
            v20 = this[22];
            if (!v20)
              goto LABEL_20;
            v21 = 0;
            v22 = this[21];
            v23 = 16 * (_QWORD)v20;
            do
            {
              if (v22[1] == v18)
              {
                v21 = *v22;
                *v22 = v19;
              }
              v22 += 2;
              v23 -= 16;
            }
            while (v23);
            if (v21)
            {
              v24 = 0;
            }
            else
            {
LABEL_20:
              lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)(this + 20), (unint64_t)v20 + 1);
              v21 = 0;
              v25 = this[21];
              v26 = this[22];
              this[22] = (uint64_t *)((char *)v26 + 1);
              v27 = &v25[2 * (_QWORD)v26];
              *v27 = v19;
              v27[1] = v18;
              v24 = 1;
            }
            if (*((_BYTE *)this[1] + 206))
            {
              v28 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)this);
              dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "%s has interposed '%s' to replacing binds to 0x%08lX with 0x%08lX\n", v28, *(const char **)(v16 + 24), *(_QWORD *)(v16 + 16), *(_QWORD *)(v16 + 8));
            }
            v29 = *(_QWORD *)(v16 + 16);
            lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)v43, (unint64_t)this[26] + 1);
            v30 = this[25];
            v31 = this[26];
            this[26] = (uint64_t *)((char *)v31 + 1);
            v32 = &v30[3 * (_QWORD)v31];
            *v32 = (uint64_t)a2;
            if ((v24 & 1) != 0)
            {
              v32[1] = v29;
              v32[2] = v29;
            }
            else
            {
              v32[1] = v21;
              v32[2] = v29;
              if (*((_BYTE *)this[1] + 206))
                dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "   '%s' was previously interposed, so chaining 0x%08lX to call through to 0x%08lX\n", *(const char **)(v16 + 24), *(_QWORD *)(v16 + 8), v21);
            }
            v33 = v54[7];
            if (v33)
            {
              v34 = (_QWORD *)v54[5];
              v35 = 16 * v33;
              do
              {
                if (v34[1] == *(_QWORD *)(v16 + 16))
                {
                  v36 = *(_QWORD *)(v16 + 8);
                  v37 = *v34;
                  lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)(this + 20), (unint64_t)this[22] + 1);
                  v38 = this[21];
                  v39 = this[22];
                  this[22] = (uint64_t *)((char *)v39 + 1);
                  v40 = &v38[2 * (_QWORD)v39];
                  *v40 = v36;
                  v40[1] = v37;
                  if (*((_BYTE *)this[1] + 206))
                  {
                    v41 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)this);
                    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "%s has interposed '%s' so need to patch cache uses of 0x%08lX\n", v41, *(const char **)(v16 + 24), *v34);
                  }
                }
                v34 += 2;
                v35 -= 16;
              }
              while (v35);
            }
          }
        }
        v16 += 32;
      }
      while (v16 != v17);
    }
    _Block_object_dispose(&v47, 8);
    mach_o::Error::~Error(v42[0]);
    _Block_object_dispose(&v53, 8);
    v60 = 0;
    if (v61)
      vm_deallocate(mach_task_self_, v61, v62);
    _Block_object_dispose(&v63, 8);
  }
}

__n128 __Block_byref_object_copy__47(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

double __Block_byref_object_copy__49(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__50(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

uint64_t __Block_byref_object_copy__51(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__52(uint64_t a1)
{
  mach_o::Error::~Error((vm_address_t **)(a1 + 40));
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke(uint64_t a1, unsigned int *a2)
{
  dyld3::MachOFile *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  vm_address_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  vm_address_t *v13;
  uint64_t v14;
  _QWORD v15[7];
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  _QWORD v19[10];
  _QWORD v20[7];
  uint64_t v21;
  vm_address_t address;
  vm_size_t size;
  _QWORD v24[7];
  uint64_t v25;
  vm_address_t v26;
  vm_size_t v27;
  char v28;
  char v29;

  v24[0] = 0;
  v24[1] = v24;
  v24[2] = 0x5002000000;
  v24[3] = __Block_byref_object_copy__53;
  v24[4] = __Block_byref_object_dispose__54;
  v24[5] = &v29;
  v24[6] = 128;
  v26 = 0;
  v27 = 0;
  v25 = 0;
  v20[0] = 0;
  v20[1] = v20;
  v20[2] = 0x5002000000;
  v20[3] = __Block_byref_object_copy__55;
  v20[4] = __Block_byref_object_dispose__56;
  v20[5] = &v28;
  v20[6] = 128;
  address = 0;
  size = 0;
  v21 = 0;
  v5 = *(_QWORD *)(a1 + 56);
  v4 = *(dyld3::MachOFile **)(a1 + 64);
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)(a1 + 40);
  v8 = (vm_address_t *)(*(_QWORD *)(v6 + 8) + 40);
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 0x40000000;
  v19[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57;
  v19[3] = &unk_1E4F7C9A8;
  v9 = *(_QWORD *)(a1 + 72);
  v19[8] = v5;
  v19[9] = v9;
  v19[4] = v6;
  v19[5] = v24;
  v19[6] = v7;
  v19[7] = v20;
  dyld3::MachOAnalyzer::forEachChainedFixupTarget(v4, v8, (uint64_t)v19);
  if (!Diagnostics::hasError((Diagnostics *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40)))
  {
    v10 = dyld3::MachOFile::preferredLoadAddress(*(dyld3::MachOFile **)(a1 + 64));
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v15[1] = 0x40000000;
    v12 = *(_OWORD *)(a1 + 64);
    v16 = *(_OWORD *)(a1 + 80);
    v13 = (vm_address_t *)(v11 + 40);
    v15[0] = _NSConcreteStackBlock;
    v15[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2;
    v15[3] = &unk_1E4F7C9D0;
    v17 = v10;
    v14 = *(_QWORD *)(a1 + 48);
    v18 = v12;
    v15[4] = v14;
    v15[5] = v24;
    v15[6] = v20;
    dyld3::MachOLoaded::forEachFixupInAllChains(v12, v13, a2, 0, (uint64_t)v15);
  }
  _Block_object_dispose(v20, 8);
  v21 = 0;
  if (address)
    vm_deallocate(mach_task_self_, address, size);
  _Block_object_dispose(v24, 8);
  v25 = 0;
  if (v26)
    vm_deallocate(mach_task_self_, v26, v27);
}

double __Block_byref_object_copy__53(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__54(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

double __Block_byref_object_copy__55(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__56(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  dyld4::RuntimeState *v10;
  const char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD v21[2];
  uint64_t v22;

  v22 = 0;
  memset(v21, 0, sizeof(v21));
  v10 = *(dyld4::RuntimeState **)(a1 + 64);
  dyld4::Loader::resolveSymbol(*(dyld4::Loader **)(a1 + 72), v10, (vm_address_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), a2, a3, a5, 0, 0, (uint64_t)v21);
  if (Diagnostics::hasError((Diagnostics *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40)))
  {
    v11 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 72), v10);
    dyld4::RuntimeState::log(v10, "warning could not apply interposing tuples in %s\n", v11);
    *a6 = 1;
  }
  else
  {
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v13 = (char *)dyld4::Loader::resolvedAddress(v10, (uint64_t)v21) + a4;
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((_QWORD *)(v12 + 40), 1);
    v14 = *(_QWORD *)(v12 + 40);
    v15 = *(_QWORD *)(v12 + 56);
    *(_QWORD *)(v12 + 56) = v15 + 1;
    *(_QWORD *)(v14 + 8 * v15) = v13;
    v16 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v17 = *(_QWORD *)(v16 + 56);
    if (!v17)
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    dyld4::RuntimeState::checkHiddenCacheAddr(v10, *(uint64_t *)&v21[0], *(_QWORD *)(*(_QWORD *)(v16 + 40) + 8 * v17 - 8), (const unsigned __int8 *)a3, (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));
    v18 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((_QWORD *)(v18 + 40), 1);
    v19 = *(_QWORD *)(v18 + 40);
    v20 = *(_QWORD *)(v18 + 56);
    *(_QWORD *)(v18 + 56) = v20 + 1;
    *(_QWORD *)(v19 + 8 * v20) = a3;
  }
}

uint64_t dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](_QWORD *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = a1[2];
  v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5)
      dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(a1, a2 + 1);
    a1[2] = v5;
  }
  return *a1 + 8 * a2;
}

double __Block_byref_object_copy__74(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__75(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

void ___ZN5dyld412RuntimeState22buildInterposingTablesEv_block_invoke_2(uint64_t a1, uint64_t a2, unint64_t a3)
{
  dyld4::RuntimeState::appendInterposingTuples(*(uint64_t ***)(a1 + 32), *(const dyld4::Loader **)(a1 + 40), (const unsigned __int8 *)(*(_QWORD *)(a1 + 48) + a2), a3 >> 4);
}

_QWORD *dyld4::RuntimeState::setLaunchMissingDylib(_QWORD *this, const char *a2, const char *a3)
{
  this[81] = 1;
  this[82] = a3;
  this[83] = a2;
  this[84] = 0;
  return this;
}

_QWORD *dyld4::RuntimeState::setLaunchMissingSymbol(_QWORD *this, const char *a2, const char *a3, const char *a4)
{
  this[81] = 4;
  this[82] = a4;
  this[83] = a3;
  this[84] = a2;
  return this;
}

BOOL dyld4::RuntimeState::hasMissingFlatLazySymbols(dyld4::RuntimeState *this)
{
  return *((_QWORD *)this + 117) != 0;
}

void dyld4::RuntimeState::setVMAccountingSuspending(dyld4::RuntimeState *this, int a2)
{
  int v4;
  BOOL v5;
  int v6;
  int *v7;
  size_t v8;
  int v9;
  int v10;

  if (*((unsigned __int8 *)this + 1161) != a2)
  {
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 202))
      dyld4::RuntimeState::log(this, "set vm.footprint_suspend=%d\n", a2);
    v9 = 0;
    v10 = a2;
    v8 = 4;
    v4 = sysctlbyname("vm.footprint_suspend", &v9, &v8, &v10, 4uLL);
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 202))
      v5 = v4 == 0;
    else
      v5 = 1;
    if (!v5)
    {
      v6 = v4;
      v7 = __error();
      dyld4::RuntimeState::log(this, "vm.footprint_suspend => %d, errno=%d\n", v6, *v7);
    }
    *((_BYTE *)this + 1161) = a2;
  }
}

_QWORD *dyld4::Reaper::markDirectlyDlopenedImagesAsUsed(_QWORD *this)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _BYTE *v6;
  uint64_t v7;

  v1 = *(_QWORD *)(*this + 1080);
  if (v1)
  {
    v2 = *(_QWORD **)(*this + 1072);
    v3 = &v2[2 * v1];
    do
    {
      if (v2[1])
      {
        v4 = (_QWORD *)this[1];
        v5 = v4[2];
        if (v5)
        {
          v6 = (_BYTE *)(*v4 + 8);
          v7 = 16 * v5;
          while (*((_QWORD *)v6 - 1) != *v2)
          {
            v6 += 16;
            v7 -= 16;
            if (!v7)
              goto LABEL_10;
          }
          *v6 = 1;
        }
      }
LABEL_10:
      v2 += 2;
    }
    while (v2 != v3);
  }
  return this;
}

_QWORD *dyld4::Reaper::markDynamicNeverUnloadImagesAsUsed(_QWORD *this)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  _BYTE *v9;

  v1 = *(_QWORD *)(*this + 1112);
  if (v1)
  {
    v2 = *(_QWORD **)(*this + 1104);
    v3 = &v2[v1];
    v4 = (uint64_t *)this[1];
    v5 = *v4;
    v6 = v4[2];
    v7 = (_BYTE *)(v5 + 8);
    do
    {
      if (v6)
      {
        v8 = 16 * v6;
        v9 = v7;
        while (*((_QWORD *)v9 - 1) != *v2)
        {
          v9 += 16;
          v8 -= 16;
          if (!v8)
            goto LABEL_9;
        }
        *v9 = 1;
      }
LABEL_9:
      ++v2;
    }
    while (v2 != v3);
  }
  return this;
}

uint64_t dyld4::Reaper::markDependentsOf(dyld4::RuntimeState **this, const dyld4::Loader *a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  dyld4::RuntimeState *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  dyld4::RuntimeState *v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;

  result = dyld4::Loader::dependentCount(a2);
  if ((_DWORD)result)
  {
    v5 = result;
    v6 = 0;
    do
    {
      result = dyld4::Loader::dependent(a2, *this, v6, 0);
      v7 = this[1];
      v8 = *((_QWORD *)v7 + 2);
      if (v8)
      {
        v9 = (_BYTE *)(*(_QWORD *)v7 + 8);
        v10 = 16 * v8;
        while (*v9 || *((_QWORD *)v9 - 1) != result)
        {
          v9 += 16;
          v10 -= 16;
          if (!v10)
            goto LABEL_10;
        }
        *v9 = 1;
      }
LABEL_10:
      v6 = (v6 + 1);
    }
    while ((_DWORD)v6 != v5);
  }
  v11 = *((_QWORD *)*this + 121);
  if (v11)
  {
    v12 = *((_QWORD *)*this + 120);
    v13 = v12 + 16 * v11;
    do
    {
      if (*(const dyld4::Loader **)v12 == a2)
      {
        v14 = this[1];
        v15 = *((_QWORD *)v14 + 2);
        if (v15)
        {
          v16 = (_BYTE *)(*(_QWORD *)v14 + 8);
          v17 = 16 * v15;
          while (*((_QWORD *)v16 - 1) != *(_QWORD *)(v12 + 8))
          {
            v16 += 16;
            v17 -= 16;
            if (!v17)
              goto LABEL_14;
          }
          *v16 = 1;
        }
      }
LABEL_14:
      v12 += 16;
    }
    while (v12 != v13);
  }
  return result;
}

uint64_t dyld4::Reaper::markDependentOfInUseImages(uint64_t this)
{
  _QWORD *v1;
  uint64_t v2;
  dyld4::RuntimeState **v3;
  uint64_t v4;
  const dyld4::Loader **v5;

  v1 = *(_QWORD **)(this + 8);
  v2 = v1[2];
  if (v2)
  {
    v3 = (dyld4::RuntimeState **)this;
    v4 = 16 * v2;
    v5 = (const dyld4::Loader **)(*v1 + 8);
    do
    {
      if (*(_BYTE *)v5)
        this = dyld4::Reaper::markDependentsOf(v3, *(v5 - 1));
      v5 += 2;
      v4 -= 16;
    }
    while (v4);
  }
  return this;
}

uint64_t dyld4::Reaper::garbageCollect(dyld4::Reaper *this)
{
  uint64_t *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  uint64_t result;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  uint64_t v16;
  int v17;
  int v18;
  unsigned __int8 *v19;
  int v20;

  dyld4::Reaper::markDirectlyDlopenedImagesAsUsed(this);
  dyld4::Reaper::markDynamicNeverUnloadImagesAsUsed(this);
  v2 = (uint64_t *)*((_QWORD *)this + 1);
  v3 = v2[2];
  if (v3)
  {
    v4 = 0;
    v5 = *v2;
    v6 = 16 * v3;
    v7 = (unsigned __int8 *)(v5 + 8);
    do
    {
      v8 = *v7;
      v7 += 16;
      v4 += v8;
      v6 -= 16;
    }
    while (v6);
  }
  else
  {
    v4 = 0;
  }
  do
  {
    while (1)
    {
      v9 = v4;
      result = dyld4::Reaper::markDependentOfInUseImages((uint64_t)this);
      v11 = (uint64_t *)*((_QWORD *)this + 1);
      v12 = v11[2];
      if (v12)
        break;
      v4 = 0;
      if (!v9)
        goto LABEL_15;
    }
    v4 = 0;
    v13 = *v11;
    v14 = 16 * v12;
    v15 = (unsigned __int8 *)(v13 + 8);
    v16 = 16 * v12;
    do
    {
      v17 = *v15;
      v15 += 16;
      v4 += v17;
      v16 -= 16;
    }
    while (v16);
  }
  while (v4 != v9);
  v18 = 0;
  v19 = (unsigned __int8 *)(v13 + 8);
  do
  {
    v20 = *v19;
    v19 += 16;
    v18 += v20;
    v14 -= 16;
  }
  while (v14);
  LODWORD(v12) = v12 - v18;
LABEL_15:
  *((_DWORD *)this + 4) = v12;
  return result;
}

void dyld4::Reaper::finalizeDeadImages(dyld4::Reaper *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _QWORD v10[6];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  double (*v14)(uint64_t, uint64_t);
  _QWORD *(*v15)(_QWORD *);
  char *v16;
  uint64_t v17;
  uint64_t v18;
  vm_address_t v19;
  vm_size_t v20;

  v1 = *((unsigned int *)this + 4);
  if ((_DWORD)v1 && *(_QWORD *)(*(_QWORD *)this + 152))
  {
    v11 = 0;
    v12 = &v11;
    v13 = 0x5002000000;
    v14 = __Block_byref_object_copy__84;
    v15 = __Block_byref_object_dispose__85;
    v3 = *((unsigned int *)this + 4);
    v16 = (char *)&v10[-1] - ((16 * v1 + 23) & 0x1FFFFFFFF0);
    v17 = v3;
    v19 = 0;
    v20 = 0;
    v18 = 0;
    v4 = (uint64_t *)*((_QWORD *)this + 1);
    v5 = v4[2];
    if (v5)
    {
      v6 = *v4;
      v7 = 16 * v5;
      do
      {
        if (!*(_BYTE *)(v6 + 8))
        {
          v8 = (_DWORD *)dyld4::Loader::analyzer(*(dyld4::Loader **)v6, *(dyld4::RuntimeState **)this);
          if ((*(_WORD *)(*(_QWORD *)v6 + 4) & 2) == 0)
          {
            v10[0] = _NSConcreteStackBlock;
            v10[1] = 0x40000000;
            v10[2] = ___ZN5dyld46Reaper18finalizeDeadImagesEv_block_invoke;
            v10[3] = &unk_1E4F7CAD8;
            v10[4] = &v11;
            v10[5] = v8;
            dyld3::MachOFile::forEachSegment(v8, (uint64_t)v10);
          }
        }
        v6 += 16;
        v7 -= 16;
      }
      while (v7);
      if (v12[7])
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)this + 152) + 88))(*(_QWORD *)(*(_QWORD *)this + 152), v12[5]);
    }
    _Block_object_dispose(&v11, 8);
    v18 = 0;
    if (v19)
      vm_deallocate(mach_task_self_, v19, v20);
  }
}

double __Block_byref_object_copy__84(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__85(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

void dyld4::RuntimeState::garbageCollectInner(dyld4::RuntimeState *this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  lsl::AllocatorLayout *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  lsl::Allocator *v14;
  size_t v15;
  uint64_t v16;
  lsl::AllocatorLayout *v17;
  uint64_t v18;
  const char **v19;
  const char **v20;
  lsl::Allocator *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  lsl::Allocator *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[2];
  int v36;
  _QWORD v37[6];
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  __n128 (*v41)(uint64_t, uint64_t);
  uint64_t (*v42)();
  char *v43;
  uint64_t v44;
  uint64_t v45;

  v2 = *((_QWORD *)this + 6);
  v38 = 0;
  v39 = &v38;
  v40 = 0x4002000000;
  v41 = __Block_byref_object_copy__87;
  v42 = __Block_byref_object_dispose__88;
  v43 = (char *)&v29 - ((16 * v2 + 23) & 0xFFFFFFFFFFFFFFF0);
  v44 = v2;
  v45 = 0;
  v3 = (_QWORD *)*((_QWORD *)this + 17);
  v37[0] = _NSConcreteStackBlock;
  v37[1] = 0x40000000;
  v37[2] = ___ZN5dyld412RuntimeState19garbageCollectInnerEv_block_invoke;
  v37[3] = &unk_1E4F7CB00;
  v37[4] = &v38;
  v37[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v3, (uint64_t)v37);
  v35[0] = this;
  v35[1] = v39 + 5;
  v36 = 0;
  dyld4::Reaper::garbageCollect((dyld4::Reaper *)v35);
  dyld4::Reaper::finalizeDeadImages((dyld4::Reaper *)v35);
  v4 = v39[7];
  v6 = lsl::AllocatorLayout::minSize(v5);
  __chkstk_darwin(v6, v6 + 8 * v4 + 64, v7, v8, v9, v10, v11, v12, v29);
  v14 = (lsl::Allocator *)((char *)&v29 - v13);
  bzero((char *)&v29 - v13, v15);
  v16 = v39[7];
  v18 = lsl::AllocatorLayout::minSize(v17);
  v21 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v14, (char *)(v18 + 8 * v16 + 64), v19, v20);
  v31 = v21;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v31, v39[7]);
  v22 = v39[7];
  if (v22)
  {
    v23 = 16 * v22;
    v24 = v39[5] + 8;
    v25 = (unsigned __int8 *)v24;
    do
    {
      v26 = *v25;
      v25 += 16;
      if (!v26)
      {
        lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v31, v33 + 1);
        v27 = *(_QWORD *)(v24 - 8);
        v28 = v33++;
        *(_QWORD *)(v32 + 8 * v28) = v27;
      }
      v24 = (uint64_t)v25;
      v23 -= 16;
    }
    while (v23);
  }
  if (v33)
  {
    v29 = v32;
    v30 = v33;
    dyld4::RuntimeState::notifyUnload((uint64_t)this, &v29);
    v29 = v32;
    v30 = v33;
    dyld4::RuntimeState::removeLoaders((lsl::Allocator **)this, (uint64_t)&v29);
  }
  if (v32)
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v31, 0);
  lsl::Allocator::~Allocator(v21);
  _Block_object_dispose(&v38, 8);
}

__n128 __Block_byref_object_copy__87(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void ___ZN5dyld412RuntimeState19garbageCollectInnerEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  uint64_t *v9;
  __n128 v10;

  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(_QWORD *)(v3 + 48);
  if (v4)
  {
    v6 = *(_QWORD *)(v3 + 40);
    v7 = 8 * v4;
    do
    {
      v8 = *(_WORD *)(*(_QWORD *)v6 + 4);
      if ((v8 & 2) == 0)
      {
        v9 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
        v10.n128_u64[0] = *(_QWORD *)v6;
        v10.n128_u8[8] = (v8 & 0x20) != 0;
        dyld3::Array<dyld4::Reaper::LoaderAndUse>::push_back(v9, &v10, a3);
      }
      v6 += 8;
      v7 -= 8;
    }
    while (v7);
  }
}

__n128 dyld3::Array<dyld4::Reaper::LoaderAndUse>::push_back(uint64_t *a1, __n128 *a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  __n128 result;

  v3 = a1[2];
  if (v3 >= a1[1])
    dyld4::RuntimeState::appendInterposingTuples((uint64_t)a1, (uint64_t)a2, a3);
  v4 = *a1;
  a1[2] = v3 + 1;
  result = *a2;
  *(__n128 *)(v4 + 16 * v3) = *a2;
  return result;
}

void dyld4::RuntimeState::notifyUnload(uint64_t a1, uint64_t *a2)
{
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  dyld4::Loader **v13;
  uint64_t v14;
  dyld4::Loader *v15;
  void (*v16)(uint64_t, uint64_t);
  uint64_t v17;
  uint64_t Address;
  const void *v19;
  const char *v20;
  uint64_t v21;
  dyld4::Loader **v22;
  uint64_t v23;
  unsigned int *v24;
  dyld4::Loader *v25;
  dyld3::MachOFile *v26;
  dyld3 *v27;
  stat *v28;
  int v29;
  unsigned __int8 (*st_ino)[16];
  fsobj_id st_dev;
  void *v32;
  fsid v33;
  fsobj_id v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _OWORD *v42;
  uint64_t v43;
  _OWORD *v44;
  uint64_t v45;
  lsl::Lock *v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  lsl::Lock *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  BOOL v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  BOOL v61;
  uint64_t v62;
  uint64_t v63;
  const void *v64;
  _QWORD v65[2];
  void (*v66)(_QWORD *);
  void *v67;
  uint64_t v68;
  uint64_t *v69;
  stat v70;
  _QWORD v71[6];
  char v72[8];
  uint64_t v73;

  v4 = *(_QWORD **)(a1 + 136);
  v71[0] = _NSConcreteStackBlock;
  v71[1] = 0x40000000;
  v71[2] = ___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke;
  v71[3] = &__block_descriptor_tmp_96;
  v71[4] = a1;
  v71[5] = a2;
  dyld4::RuntimeLocks::withNotifiersReadLock(v4, (uint64_t)v71);
  if (*(_QWORD *)(a1 + 688))
  {
    v12 = a2[1];
    if (v12)
    {
      v13 = (dyld4::Loader **)*a2;
      v14 = 8 * v12;
      do
      {
        v15 = *v13;
        if ((*((_WORD *)*v13 + 2) & 4) != 0)
        {
          v16 = *(void (**)(uint64_t, uint64_t))(a1 + 688);
          v17 = dyld4::Loader::path(*v13, (const dyld4::RuntimeState *)a1);
          Address = dyld4::Loader::loadAddress(v15, (const dyld4::RuntimeState *)a1);
          v16(v17, Address);
          if (*(_BYTE *)(*(_QWORD *)(a1 + 8) + 205))
          {
            v19 = (const void *)dyld4::Loader::loadAddress(v15, (const dyld4::RuntimeState *)a1);
            v20 = (const char *)dyld4::Loader::path(v15, (const dyld4::RuntimeState *)a1);
            dyld4::RuntimeState::log((dyld4::RuntimeState *)a1, "objc-unmapped-notifier called with image %p %s\n", v19, v20);
          }
        }
        ++v13;
        v14 -= 8;
      }
      while (v14);
    }
  }
  if (kdebug_is_enabled(0x1F050000u, v5, v6, v7, v8, v9, v10, v11))
  {
    v21 = a2[1];
    if (v21)
    {
      v22 = (dyld4::Loader **)*a2;
      v23 = 8 * v21;
      do
      {
        v25 = *v22++;
        v24 = (unsigned int *)v25;
        *(_QWORD *)v72 = 0;
        v73 = 0;
        v26 = (dyld3::MachOFile *)dyld4::Loader::loadAddress(v25, (const dyld4::RuntimeState *)a1);
        dyld3::MachOFile::getUuid(v26, (unsigned __int8 *)v72);
        v27 = (dyld3 *)dyld4::Loader::path(v25, (const dyld4::RuntimeState *)a1);
        v29 = dyld3::stat(v27, &v70, v28);
        if (v29)
          st_ino = 0;
        else
          st_ino = (unsigned __int8 (*)[16])v70.st_ino;
        if (v29)
          st_dev = 0;
        else
          st_dev = (fsobj_id)v70.st_dev;
        v32 = (void *)dyld4::Loader::path((dyld4::Loader *)v24, (const dyld4::RuntimeState *)a1);
        v33 = (fsid)dyld4::Loader::loadAddress((dyld4::Loader *)v24, (const dyld4::RuntimeState *)a1);
        v34 = st_dev;
        dyld3::kdebug_trace_dyld_image((dyld3 *)5, v32, (void **)v72, st_ino, v34, v33, (const void *)v24[6], v35, v64);
        v23 -= 8;
      }
      while (v23);
    }
  }
  if (dyld4::SyscallDelegate::dtraceUserProbesEnabled(*(dyld4::SyscallDelegate **)(a1 + 8)))
  {
    v36 = a2[1];
    if (v36)
    {
      v37 = (uint64_t *)*a2;
      v38 = *a2 + 8 * v36;
      v39 = *(_QWORD *)(a1 + 896);
      v40 = *(_QWORD *)(a1 + 904);
      do
      {
        v41 = *v37;
        v42 = (_OWORD *)(v39 + 16 * v40);
        if (v40)
        {
          v43 = 16 * v40;
          while (*(_QWORD *)v39 != v41)
          {
            v39 += 16;
            v43 -= 16;
            if (!v43)
            {
              v44 = v42;
              goto LABEL_34;
            }
          }
          dyld4::SyscallDelegate::dtraceUnregisterUserProbe(*(dyld4::SyscallDelegate **)(a1 + 8), *(unsigned int *)(v39 + 8));
        }
        v44 = v42;
        if ((_OWORD *)v39 != v42)
        {
          v45 = v39 + 16;
          v44 = (_OWORD *)v39;
          while ((_OWORD *)v45 != v42)
          {
            if (*(_QWORD *)v45 == v41)
              dyld4::SyscallDelegate::dtraceUnregisterUserProbe(*(dyld4::SyscallDelegate **)(a1 + 8), *(unsigned int *)(v45 + 8));
            else
              *v44++ = *(_OWORD *)v45;
            v45 += 16;
          }
        }
LABEL_34:
        v39 = *(_QWORD *)(a1 + 896);
        v40 = *(_QWORD *)(a1 + 904) - ((v39 + 16 * *(_QWORD *)(a1 + 904) - (uint64_t)v44) >> 4);
        *(_QWORD *)(a1 + 904) = v40;
        ++v37;
      }
      while (v37 != (uint64_t *)v38);
    }
  }
  dyld4::RuntimeState::removeMissingFlatLazySymbols(a1, (uint64_t)a2);
  v46 = *(lsl::Lock **)(a1 + 128);
  v47 = *(_QWORD **)(a1 + 136);
  v65[0] = _NSConcreteStackBlock;
  v65[1] = 0x40000000;
  v66 = (void (*)(_QWORD *))___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke_2;
  v67 = &__block_descriptor_tmp_98;
  v68 = a1;
  v69 = a2;
  lsl::MemoryManager::lockGuard(v46, (lsl::Lock **)&v70);
  v48 = *((_QWORD *)v46 + 3);
  if (!v48)
  {
    lsl::MemoryManager::writeProtect(v46, 0);
    v48 = *((_QWORD *)v46 + 3);
  }
  *((_QWORD *)v46 + 3) = v48 + 1;
  lsl::Lock::unlock(*(lsl::Lock **)&v70.st_dev);
  if (*v47)
  {
    (*(void (**)(_QWORD, _QWORD *, _QWORD))(*(_QWORD *)*v47 + 104))(*v47, v47 + 1, 0);
    v66(v65);
    (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)*v47 + 112))(*v47, v47 + 1);
  }
  else
  {
    ___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke_2(v65);
  }
  lsl::MemoryManager::lockGuard(v46, (lsl::Lock **)&v70);
  v49 = *((_QWORD *)v46 + 3) - 1;
  *((_QWORD *)v46 + 3) = v49;
  if (!v49)
    lsl::MemoryManager::writeProtect(v46, 1);
  lsl::Lock::unlock(*(lsl::Lock **)&v70.st_dev);
  v50 = *(lsl::Lock **)(a1 + 128);
  v51 = *(_QWORD **)(a1 + 136);
  lsl::MemoryManager::lockGuard(v50, (lsl::Lock **)&v70);
  v52 = *((_QWORD *)v50 + 3);
  if (!v52)
  {
    lsl::MemoryManager::writeProtect(v50, 0);
    v52 = *((_QWORD *)v50 + 3);
  }
  *((_QWORD *)v50 + 3) = v52 + 1;
  lsl::Lock::unlock(*(lsl::Lock **)&v70.st_dev);
  if (*v51)
  {
    (*(void (**)(_QWORD, _QWORD *, _QWORD))(*(_QWORD *)*v51 + 104))(*v51, v51 + 1, 0);
    v53 = a2[1];
    if (v53)
    {
      v54 = *a2;
      v55 = 8 * v53;
      do
      {
        if (*(_QWORD *)v54)
          v56 = (*(_WORD *)(*(_QWORD *)v54 + 4) & 1) == 0;
        else
          v56 = 0;
        if (v56)
        {
          v57 = *(_QWORD *)(*(_QWORD *)v54 + 104);
          if (v57)
          {
            if ((*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(v57 + 16) + 16))(*(_QWORD *)(v57 + 24), *(_QWORD *)v57))
            {
              (**(void (***)(void))(v57 + 16))();
            }
          }
        }
        v54 += 8;
        v55 -= 8;
      }
      while (v55);
    }
    (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)*v51 + 112))(*v51, v51 + 1);
  }
  else
  {
    v58 = a2[1];
    if (v58)
    {
      v59 = *a2;
      v60 = 8 * v58;
      do
      {
        if (*(_QWORD *)v59)
          v61 = (*(_WORD *)(*(_QWORD *)v59 + 4) & 1) == 0;
        else
          v61 = 0;
        if (v61)
        {
          v62 = *(_QWORD *)(*(_QWORD *)v59 + 104);
          if (v62)
          {
            if ((*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(v62 + 16) + 16))(*(_QWORD *)(v62 + 24), *(_QWORD *)v62))
            {
              (**(void (***)(void))(v62 + 16))();
            }
          }
        }
        v59 += 8;
        v60 -= 8;
      }
      while (v60);
    }
  }
  lsl::MemoryManager::lockGuard(v50, (lsl::Lock **)&v70);
  v63 = *((_QWORD *)v50 + 3) - 1;
  *((_QWORD *)v50 + 3) = v63;
  if (!v63)
    lsl::MemoryManager::writeProtect(v50, 1);
  lsl::Lock::unlock(*(lsl::Lock **)&v70.st_dev);
  dyld4::RuntimeState::notifyDebuggerUnload((lsl::Allocator **)a1, a2);
}

void dyld4::RuntimeState::removeLoaders(lsl::Allocator **a1, uint64_t a2)
{
  uint64_t v2;
  dyld4::Loader **v4;
  uint64_t v5;
  dyld4::Loader *v6;
  __int16 v7;

  v2 = *(_QWORD *)(a2 + 8);
  if (v2)
  {
    v4 = *(dyld4::Loader ***)a2;
    v5 = 8 * v2;
    do
    {
      v6 = *v4;
      v7 = *((_WORD *)*v4 + 2);
      if ((v7 & 0x42) == 0)
      {
        if ((v7 & 1) != 0)
        {
          dyld4::Loader::unmap(*v4, (dyld4::RuntimeState *)a1, 0);
        }
        else if ((*((_BYTE *)v6 + 42) & 0x20) == 0)
        {
          dyld4::Loader::unmap(*v4, (dyld4::RuntimeState *)a1, 0);
          *(_DWORD *)v6 = 2053923954;
          lsl::Allocator::free(a1[2], v6);
        }
      }
      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
}

size_t ___ZN5dyld412RuntimeState12notifyDtraceERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke(_QWORD *a1, unsigned int a2)
{
  const dyld4::RuntimeState *v3;
  uint64_t v4;
  char *v5;
  dyld4::Loader *v6;
  uint64_t v7;
  char *v8;
  size_t result;

  v3 = (const dyld4::RuntimeState *)a1[5];
  v4 = a1[6] + 80 * *(_QWORD *)a1[6];
  v5 = (char *)(v4 + 8);
  v7 = a1[7];
  v6 = (dyld4::Loader *)a1[8];
  *(int64x2_t *)(v4 + 72) = vdupq_n_s64(v7 + (unint64_t)a2);
  v8 = dyld4::Loader::leafName(v6, v3);
  result = strlcpy(v5, v8, 0x40uLL);
  ++*(_QWORD *)a1[6];
  if ((*(_BYTE *)(a1[8] + 4) & 0x20) == 0)
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
  return result;
}

void dyld4::RuntimeState::notifyDebuggerUnload(lsl::Allocator **a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  size_t v13;
  lsl::AllocatorLayout *v14;
  char *v15;
  const char **v16;
  const char **v17;
  lsl::Allocator *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t Address;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t *v39[2];

  v4 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)a1);
  __chkstk_darwin(v4, v4, v5, v6, v7, v8, v9, v10, v38);
  v12 = (char *)&v39[-1] - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v12, v13);
  v15 = (char *)lsl::AllocatorLayout::minSize(v14);
  v18 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v12, v15, v16, v17);
  __chkstk_darwin((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25, v38);
  v29 = (uint64_t *)((char *)&v39[-1] - ((v28 + 23) & 0xFFFFFFFFFFFFFFF0));
  v30 = a2[1];
  if (!v30)
    ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1((uint64_t)v39, v26, v27);
  v31 = 0;
  v32 = *a2;
  v33 = 8 * v30;
  do
  {
    Address = dyld4::Loader::loadAddress(*(dyld4::Loader **)(v32 + 8 * v31), (const dyld4::RuntimeState *)a1);
    if (v30 == v31)
      dyld4::RuntimeState::appendInterposingTuples(Address, v35, v36);
    v37 = (uint64_t *)(v31 + 1);
    v29[v31++] = Address;
    v33 -= 8;
  }
  while (v33);
  v39[0] = v29;
  v39[1] = v37;
  dyld4::ExternallyViewableState::removeImages((uint64_t)(a1 + 71), a1[2], v18, v39);
  lsl::Allocator::~Allocator(v18);
}

uint64_t ___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke(uint64_t result)
{
  const dyld4::RuntimeState *v1;
  uint64_t v2;
  const void **v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  dyld4::Loader **v7;
  uint64_t v8;
  dyld4::Loader *v9;
  dyld3::MachOLoaded *Address;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t Slide;
  const void **v19;
  uint64_t v20;
  int v21;
  dyld3::MachOLoaded *v22;
  uint64_t v23;
  const void *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;

  v20 = result;
  v1 = *(const dyld4::RuntimeState **)(result + 32);
  v2 = *((_QWORD *)v1 + 97);
  if (v2)
  {
    v3 = (const void **)*((_QWORD *)v1 + 96);
    v19 = &v3[v2];
    do
    {
      v4 = *(_QWORD *)(v20 + 40);
      v5 = *(_QWORD *)(v4 + 8);
      if (v5)
      {
        v6 = *v3;
        v7 = *(dyld4::Loader ***)v4;
        v8 = 8 * v5;
        do
        {
          v9 = *v7;
          Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*v7, v1);
          v21 = 520552476;
          v22 = Address;
          v23 = 0;
          v24 = v6;
          v25 = 0u;
          v26 = 0u;
          v27 = 0u;
          v28 = 0u;
          v29 = 0u;
          dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v21, v11, v12, v13, v14, v15, v16, v17);
          if (*(_BYTE *)(*((_QWORD *)v1 + 1) + 205))
            dyld4::RuntimeState::log(v1, "remove notifier %p called with mh=%p\n", v6, Address);
          if ((*((_WORD *)v9 + 2) & 2) != 0)
            Slide = *(_QWORD *)(*((_QWORD *)v1 + 1) + 264);
          else
            Slide = dyld3::MachOLoaded::getSlide(Address);
          ((void (*)(dyld3::MachOLoaded *, uint64_t))v6)(Address, Slide);
          result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v21);
          ++v7;
          v8 -= 8;
        }
        while (v8);
      }
      ++v3;
    }
    while (v3 != v19);
  }
  return result;
}

_QWORD *dyld4::RuntimeState::removeDynamicDependencies(_QWORD *this, const dyld4::Loader *a2)
{
  _QWORD *v3;
  _OWORD *v4;
  uint64_t v5;
  _OWORD *v6;
  _OWORD *v7;
  uint64_t v8;
  _OWORD *v10;
  dyld3::MachOFile *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  const dyld4::Loader **v17;
  uint64_t v18;
  const char *v19;

  v3 = this;
  v4 = (_OWORD *)this[120];
  v5 = this[121];
  v6 = &v4[v5];
  v7 = v4;
  if (v5)
  {
    v8 = 0;
    while (1)
    {
      v7 = &v4[v8];
      if (*(const dyld4::Loader **)&v4[v8] == a2 || *((_QWORD *)&v4[v8] + 1) == (_QWORD)a2)
        break;
      if (v5 == ++v8)
      {
        v7 = &v4[v5];
        goto LABEL_20;
      }
    }
  }
  v10 = v7 + 1;
  if (v7 != v6 && v10 != v6)
  {
    do
    {
      if (*(const dyld4::Loader **)v10 != a2 && *((_QWORD *)v10 + 1) != (_QWORD)a2)
        *v7++ = *v10;
      ++v10;
    }
    while (v10 != v6);
    v4 = (_OWORD *)this[120];
    v5 = this[121];
  }
LABEL_20:
  this[121] = v5 - (&v4[v5] - v7);
  if (this[46])
  {
    v13 = (dyld3::MachOFile *)dyld4::Loader::analyzer(a2, (dyld4::RuntimeState *)this);
    if ((dyld3::MachOFile::hasWeakDefs(v13) & 1) != 0
      || (this = (_QWORD *)dyld3::MachOFile::usesWeakDefs(v13), (_DWORD)this))
    {
      this = (_QWORD *)dyld3::MachOFile::mappedSize(v13);
      v14 = v3[46];
      v15 = *(_QWORD *)(v14 + 72);
      if (v15)
      {
        v16 = (char *)this + (_QWORD)v13;
        v17 = (const dyld4::Loader **)(*(_QWORD *)(v14 + 56) + 8);
        v18 = 24 * v15;
        do
        {
          if (*v17 == a2)
            *v17 = 0;
          v19 = (const char *)*(v17 - 1);
          if (v19 >= (const char *)v13 && v19 < v16)
          {
            this = lsl::Allocator::strdup((lsl::Allocator *)v3[2], v19);
            *(v17 - 1) = (const dyld4::Loader *)this;
          }
          v17 += 3;
          v18 -= 24;
        }
        while (v18);
      }
    }
  }
  return this;
}

uint64_t dyld4::RuntimeState::addNotifyLoadImage(dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(const mach_header *, const char *, BOOL))
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 792, *((_QWORD *)this + 101) + 1);
  v7 = *((_QWORD *)this + 100);
  v8 = *((_QWORD *)this + 101);
  *((_QWORD *)this + 101) = v8 + 1;
  *(_QWORD *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 1096, *((_QWORD *)this + 139) + 1);
      v9 = *((_QWORD *)this + 138);
      v10 = *((_QWORD *)this + 139);
      *((_QWORD *)this + 139) = v10 + 1;
      *(_QWORD *)(v9 + 8 * v10) = a2;
    }
  }
  return result;
}

__n128 __Block_byref_object_copy__102(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *a1;
  if (v4)
    dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(v4, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 16))(a2, a1);
}

uint64_t dyld4::RuntimeState::_finalizeListTLV(dyld4::RuntimeState *this, uint64_t *a2)
{
  _QWORD v5[5];
  _QWORD v6[5];

  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke;
  v6[3] = &__block_descriptor_tmp_110;
  v6[4] = this;
  dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(a2, (uint64_t)v6);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke_2;
  v5[3] = &__block_descriptor_tmp_111;
  v5[4] = this;
  return dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(a2, (uint64_t)v5);
}

uint64_t ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  void (*v5)(_QWORD);
  uint64_t v6;

  v2 = *(_QWORD *)(a2 + 8);
  if (v2)
  {
    v3 = *(_QWORD *)(result + 32);
    v4 = (_QWORD *)(a2 + 16 * v2 + 8);
    do
    {
      v5 = (void (*)(_QWORD))*(v4 - 1);
      if (v5)
        v5(*v4);
      result = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 152) + 64))(*(_QWORD *)(v3 + 152), *(_QWORD *)(v3 + 1136));
      if (result)
      {
        v6 = result;
        (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v3 + 152) + 72))(*(_QWORD *)(v3 + 152), *(_QWORD *)(v3 + 1136), 0);
        result = (**(uint64_t (***)(uint64_t, uint64_t))v3)(v3, v6);
      }
      v4 -= 2;
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 152) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 152));
}

uint64_t dyld4::RuntimeState::saveAppPrebuiltLoaderSet(dyld4::RuntimeState *this, const dyld4::PrebuiltLoaderSet *a2)
{
  unsigned int *Only;
  unsigned int *v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL4 HasBootToken;
  dyld4::SyscallDelegate *v11;
  BOOL v12;
  vm_address_t *v13;
  vm_address_t *v14;
  char *v15;
  __int128 v16;
  char v17;

  v15 = &v17;
  v16 = xmmword_1A5CBB330;
  if ((dyld4::RuntimeState::buildBootToken((uint64_t)this, (uint64_t *)&v15) & 1) != 0)
  {
    if (*((_QWORD *)this + 126))
    {
      Diagnostics::Diagnostics((Diagnostics *)&v14);
      Only = (unsigned int *)dyld4::SyscallDelegate::mapFileReadOnly(*((_QWORD *)this + 1), (vm_address_t *)&v14, *((dyld3 **)this + 126), 0, 0, 0, 0);
      if (!Only)
      {
LABEL_9:
        Diagnostics::Diagnostics((Diagnostics *)&v13);
        v8 = dyld4::SyscallDelegate::saveFileWithAttribute(*((_QWORD *)this + 1), (vm_address_t *)&v13, *((const std::__fs::filesystem::path **)this + 126), a2, *((unsigned int *)a2 + 2), "com.apple.dyld", (uint64_t)&v15);
        if ((_DWORD)v8)
        {
          if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
            dyld4::RuntimeState::log(this, "wrote PrebuiltLoaderSet to file '%s'\n");
        }
        else if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
        {
          Diagnostics::errorMessage((Diagnostics *)&v13);
          dyld4::RuntimeState::log(this, "tried but failed (%s) to write PrebuiltLoaderSet to file '%s'\n");
        }
        mach_o::Error::~Error(&v13);
        goto LABEL_20;
      }
      v5 = Only;
      v6 = Only[2];
      if ((_DWORD)v6 != *((_DWORD *)a2 + 2) || _platform_memcmp(Only, a2, Only[2]))
      {
        dyld4::SyscallDelegate::unmapFile(*((dyld4::SyscallDelegate **)this + 1), v5, v6);
LABEL_7:
        dyld4::SyscallDelegate::unlink(*((dyld4::SyscallDelegate **)this + 1), *((const char **)this + 126));
        if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
          dyld4::RuntimeState::log(this, "deleting existing out of date PrebuiltLoaderSet file '%s'\n", *((const char **)this + 126));
        goto LABEL_9;
      }
      HasBootToken = dyld4::RuntimeState::fileAlreadyHasBootToken((uint64_t)this, v7, (uint64_t)&v15);
      v11 = (dyld4::SyscallDelegate *)*((_QWORD *)this + 1);
      if (HasBootToken)
      {
        if (*((_BYTE *)v11 + 207))
        {
          dyld4::RuntimeState::log(this, "PrebuiltLoaderSet already saved as file '%s'\n", *((const char **)this + 126));
          v11 = (dyld4::SyscallDelegate *)*((_QWORD *)this + 1);
        }
        dyld4::SyscallDelegate::unmapFile(v11, v5, v5[2]);
      }
      else
      {
        if (*((_BYTE *)v11 + 207))
        {
          dyld4::RuntimeState::log(this, "updating boot attribute on existing PrebuiltLoaderSet file '%s'\n", *((const char **)this + 126));
          v11 = (dyld4::SyscallDelegate *)*((_QWORD *)this + 1);
        }
        v12 = dyld4::SyscallDelegate::setFileAttribute((int)v11, *((char **)this + 126), "com.apple.dyld", (uint64_t)&v15);
        dyld4::SyscallDelegate::unmapFile(*((dyld4::SyscallDelegate **)this + 1), v5, v5[2]);
        if (!v12)
          goto LABEL_7;
      }
      v8 = 1;
LABEL_20:
      mach_o::Error::~Error(&v14);
      return v8;
    }
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
      dyld4::RuntimeState::log(this, "no path to save PrebuiltLoaderSet file\n");
  }
  else if (*(_BYTE *)(*((_QWORD *)this + 1) + 207))
  {
    dyld4::RuntimeState::log(this, "could not save PrebuiltLoaderSet because main executable is not codesigned\n");
  }
  return 0;
}

dyld4::DyldCacheDataConstScopedWriter *dyld4::DyldCacheDataConstScopedWriter::DyldCacheDataConstScopedWriter(dyld4::DyldCacheDataConstScopedWriter *this, dyld4::RuntimeState *a2)
{
  *(_QWORD *)this = a2;
  *((_BYTE *)this + 8) = 0;
  dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(this);
  return this;
}

uint64_t dyld4::RuntimeState::rebindMissingFlatLazySymbols(std::span<dyld4::Loader const*,18446744073709551615ul> const&)::$_0::operator()(dyld4::Loader ****a1, uint64_t a2)
{
  const dyld4::RuntimeState *v2;
  dyld4::Loader *v3;
  dyld4::Loader **v4;
  dyld4::Loader **v7;
  uint64_t v8;
  dyld4::Loader *v9;
  const dyld4::RuntimeState *v11;
  uint64_t v12;
  char *v13;
  dyld4::Loader *v14[5];

  v2 = (const dyld4::RuntimeState *)a1[2];
  v3 = *(dyld4::Loader **)(a2 + 8);
  v14[0] = 0;
  v14[1] = v3;
  v14[2] = 0;
  v14[3] = 0;
  v14[4] = (dyld4::Loader *)2;
  v4 = (*a1)[1];
  if (!v4)
    return 0;
  v7 = **a1;
  v8 = 8 * (_QWORD)v4;
  while (1)
  {
    v9 = *v7;
    if ((dyld4::Loader::hiddenFromFlat(*v7, 0) & 1) == 0)
    {
      if (dyld4::Loader::hasExportedSymbol((uint64_t)v9, (vm_address_t *)a1[1], v2, *(const unsigned __int8 **)(a2 + 8), 1u, 1, (uint64_t *)v14, 0))break;
    }
    ++v7;
    v8 -= 8;
    if (!v8)
      return 0;
  }
  v11 = dyld4::Loader::resolvedAddress(v2, (uint64_t)v14);
  if (*(_BYTE *)(*((_QWORD *)v2 + 1) + 202))
  {
    v12 = *(_QWORD *)(a2 + 16);
    v13 = dyld4::Loader::leafName(v9, v2);
    dyld4::RuntimeState::log(v2, "fixup: *0x%012lX = 0x%012lX <%s>\n", v12, v11, v13);
  }
  **(_QWORD **)(a2 + 16) = v11;
  dyld4::RuntimeState::addDynamicReference(v2, *(const dyld4::Loader **)a2, v14[0]);
  return 1;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;

  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      v4 = *(uint64_t *)((char *)a2 + a3 - 48);
      v5 = *(uint64_t *)((char *)a2 + a3 - 40);
      v6 = *(uint64_t *)((char *)a2 + a3 - 24);
      v8 = *(uint64_t *)((char *)a2 + a3 - 64);
      v7 = *(uint64_t *)((char *)a2 + a3 - 56);
      v9 = *(uint64_t *)((char *)a2 + a3 - 16);
      v10 = *(uint64_t *)((char *)a2 + a3 - 8);
      v11 = v7 + v9;
      v12 = 0x9DDFEA08EB382D69
          * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))));
      v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      v14 = v8 + a3 + v7 + v4;
      v15 = v14 + v5;
      v16 = __ROR8__(v14, 44) + v8 + a3 + __ROR8__(v5 + v8 + a3 - 0x622015F714C7D297 * (v12 ^ (v12 >> 47)), 21);
      v17 = v7 + v9 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      v18 = v17 + v6 + v9;
      v19 = __ROR8__(v18, 44);
      v20 = v18 + v10;
      v21 = v19 + v17 + __ROR8__(v17 + v5 + v10, 21);
      v23 = *a2;
      v22 = a2 + 4;
      v24 = v23 - 0x4B6D499041670D8DLL * v5;
      v25 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        v26 = *(v22 - 3);
        v27 = v24 + v15 + v11 + v26;
        v28 = v22[2];
        v29 = v22[3];
        v30 = v22[1];
        v11 = v30 + v15 - 0x4B6D499041670D8DLL * __ROR8__(v11 + v16 + v28, 42);
        v31 = v13 + v20;
        v32 = *(v22 - 2);
        v33 = *(v22 - 1);
        v34 = *(v22 - 4) - 0x4B6D499041670D8DLL * v16;
        v35 = v34 + v20 + v33;
        v36 = v34 + v26 + v32;
        v15 = v36 + v33;
        v37 = __ROR8__(v36, 44) + v34;
        v38 = (0xB492B66FBE98F273 * __ROR8__(v27, 37)) ^ v21;
        v24 = 0xB492B66FBE98F273 * __ROR8__(v31, 33);
        v16 = v37 + __ROR8__(v35 + v38, 21);
        v39 = v24 + v21 + *v22;
        v20 = v39 + v30 + v28 + v29;
        v21 = __ROR8__(v39 + v30 + v28, 44) + v39 + __ROR8__(v11 + v32 + v39 + v29, 21);
        v22 += 8;
        v13 = v38;
        v25 += 64;
      }
      while (v25);
      v40 = v24
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) ^ ((0x9DDFEA08EB382D69 * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) >> 47));
      v41 = 0x9DDFEA08EB382D69
          * (v40 ^ (v38
                  - 0x4B6D499041670D8DLL * (v11 ^ (v11 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) ^ ((0x9DDFEA08EB382D69 * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) >> 47))));
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) ^ ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) >> 47));
    }
    else
    {
      return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:nn180100](a2, a3);
    }
  }
  else if (a3 > 0x10)
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:nn180100](a2, a3);
  }
  else
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:nn180100](a2, a3);
  }
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:nn180100](_DWORD *a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t result;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  if (a2 < 9)
  {
    if (a2 < 4)
    {
      result = 0x9AE16A3B2F90404FLL;
      if (a2)
      {
        v8 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }
    else
    {
      v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      v7 = 0x9DDFEA08EB382D69 * (((8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    }
  }
  else
  {
    v3 = *(_QWORD *)((char *)a1 + a2 - 8);
    v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)))) >> 47))) ^ v3;
  }
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:nn180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v2 = a1[1];
  v3 = 0xB492B66FBE98F273 * *a1;
  v4 = __ROR8__(0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)a1 + a2 - 8), 30) + __ROR8__(v3 - v2, 43);
  v5 = v3 + a2 + __ROR8__(v2 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)a1 + a2 - 8);
  v6 = 0x9DDFEA08EB382D69 * (v5 ^ (v4 - 0x3C5A37A36834CED9 * *(_QWORD *)((char *)a1 + a2 - 16)));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:nn180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v2 = *(_QWORD *)((char *)a1 + a2 - 16);
  v3 = *a1 - 0x3C5A37A36834CED9 * (v2 + a2);
  v5 = a1[2];
  v4 = a1[3];
  v6 = __ROR8__(v3 + v4, 52);
  v7 = v3 + a1[1];
  v8 = __ROR8__(v7, 7);
  v9 = v7 + v5;
  v10 = *(_QWORD *)((char *)a1 + a2 - 32) + v5;
  v11 = v8 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v2 + a2), 37) + v6 + __ROR8__(v9, 31);
  v12 = *(_QWORD *)((char *)a1 + a2 - 24) + v10 + v2;
  v13 = 0xC3A5C85C97CB3127 * (v12 + *(_QWORD *)((char *)a1 + a2 - 8) + v4 + v11)
      - 0x651E95C4D06FBFB1
      * (v9
       + v4
       + __ROR8__(v10, 37)
       + __ROR8__(*(_QWORD *)((char *)a1 + a2 - 24) + v10, 7)
       + __ROR8__(*(_QWORD *)((char *)a1 + a2 - 8) + v4 + v10, 52)
       + __ROR8__(v12, 31));
  return 0x9AE16A3B2F90404FLL
       * ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) ^ ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) >> 47));
}

_QWORD *dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  const void **v3;
  vm_address_t v4;
  vm_size_t v5;
  unint64_t v6;
  vm_size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;

  v2 = result[1];
  if (v2 < a2)
  {
    v3 = (const void **)result;
    v4 = result[3];
    v5 = result[4];
    v6 = 2 * v2;
    if (v6 <= a2)
      v6 = a2;
    v7 = (vm_page_size + 32 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    result = memmove((void *)v3[3], *v3, 32 * (_QWORD)v3[2]);
    v11 = (const void *)((unint64_t)v3[4] >> 5);
    *v3 = v3[3];
    v3[1] = v11;
    if (v4)
      return (_QWORD *)vm_deallocate(mach_task_self_, v4, v5);
  }
  return result;
}

_QWORD *dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  const void **v4;
  vm_address_t v5;
  vm_size_t v6;
  unint64_t v7;
  vm_size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;

  v2 = result[1];
  v3 = result[2] + a2;
  if (v3 > v2)
  {
    v4 = (const void **)result;
    v5 = result[3];
    v6 = result[4];
    v7 = 2 * v2;
    if (v7 > v3)
      v3 = v7;
    v8 = (vm_page_size + 16 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    result = memmove((void *)v4[3], *v4, 16 * (_QWORD)v4[2]);
    v12 = (const void *)((unint64_t)v4[4] >> 4);
    *v4 = v4[3];
    v4[1] = v12;
    if (v5)
      return (_QWORD *)vm_deallocate(mach_task_self_, v5, v6);
  }
  return result;
}

void ___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  dyld4::RuntimeState *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  const void **v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char **v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  dyld4::Loader **v36;
  dyld4::Loader *v37;
  uint64_t Address;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const dyld4::RuntimeState *v45;
  unint64_t v46;
  uint64_t *v47;
  dyld4::RuntimeState *v48;
  uint64_t v49;
  __int16 v50;
  void (*v51)(unint64_t, uint64_t, _QWORD *);
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const void *v55;
  const void *v56;
  const char *v57;
  uint64_t v58;
  dyld4::Loader **v59;
  uint64_t v60;
  dyld4::Loader *v61;
  uint64_t v62;
  _QWORD v63[6];
  char v64;
  uint64_t v65;
  uint64_t v66;
  dyld4::Loader *v67;
  int DoesObjCFixups;
  uint64_t v69;
  uint64_t *v70;
  uint64_t v71;
  __n128 (*v72)(uint64_t, uint64_t);
  uint64_t (*v73)();
  char *v74;
  unint64_t v75;
  uint64_t v76;

  v8 = *(dyld4::RuntimeState **)(a1 + 32);
  if (*((_QWORD *)v8 + 87) && *((_QWORD *)v8 + 34))
  {
    a1 = *((_QWORD *)v8 + 19);
    if (a1)
    {
      a1 = (**(uint64_t (***)(unint64_t))a1)(a1);
      if (a1 >= 3)
        a1 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v8 + 19) + 160))(*((_QWORD *)v8 + 19));
    }
    v9 = *((_QWORD *)v8 + 34);
    if (v9)
    {
      v10 = (_QWORD *)*((_QWORD *)v8 + 33);
      v11 = &v10[4 * v9];
      do
      {
        a1 = (*((uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))v8 + 87))(*v10, v10[1], v10[2], v10[3]);
        v10 += 4;
      }
      while (v10 != v11);
    }
    if (*(_BYTE *)(*((_QWORD *)v8 + 1) + 205))
      dyld4::RuntimeState::log(v8, "objc-patch-class-notifier called with %lld patches:\n", *((_QWORD *)v8 + 34));
    *((_QWORD *)v8 + 34) = 0;
  }
  v12 = *((_QWORD *)v8 + 6);
  v13 = 8 * v12;
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v62);
  v14 = (const void **)((char *)&v63[-1] - ((8 * v12 + 23) & 0xFFFFFFFFFFFFFFF0));
  __chkstk_darwin(v15, v16, v17, v18, v19, v20, v21, v22, v62);
  v24 = (const char **)((char *)&v63[-1] - v23);
  __chkstk_darwin(v25, v26, v27, v28, v29, v30, v31, v32, v62);
  v69 = 0;
  v70 = &v69;
  v71 = 0x4002000000;
  v72 = __Block_byref_object_copy__166;
  v73 = __Block_byref_object_dispose__167;
  v74 = (char *)&v63[-1] - (v33 & 0xFFFFFFFFFFFFFFE0 | 0x10);
  v75 = v12;
  v76 = 0;
  if (v12)
  {
    HIDWORD(v62) = 0;
    v34 = 0;
    v35 = 0;
    v36 = (dyld4::Loader **)*((_QWORD *)v8 + 5);
    do
    {
      v37 = *v36;
      Address = dyld4::Loader::loadAddress(*v36, v8);
      if ((*((_WORD *)v37 + 2) & 4) != 0)
      {
        v41 = Address;
        v42 = dyld4::Loader::path(v37, v8);
        if (v35 >= v12)
          dyld4::RuntimeState::appendInterposingTuples(v42, v43, v44);
        v24[v35] = (const char *)v42;
        if (v34 >= v12)
          dyld4::RuntimeState::appendInterposingTuples(v42, v43, v44);
        v45 = v8;
        v46 = v12;
        v14[v34] = (const void *)v41;
        v47 = v70 + 5;
        v65 = v41;
        v48 = v45;
        v66 = dyld4::Loader::path(v37, v45);
        v67 = v37;
        DoesObjCFixups = dyld4::Loader::dyldDoesObjCFixups(v37);
        dyld3::Array<_dyld_objc_notify_mapped_info>::push_back(v47, (uint64_t)&v65, v49);
        Address = dyld4::Loader::hasConstantSegmentsToProtect(v37);
        v50 = *((_WORD *)v37 + 2);
        if ((_DWORD)Address && (v50 & 0x80) != 0)
        {
          dyld4::Loader::makeSegmentsReadWrite(v37, v48);
          v50 = *((_WORD *)v37 + 2);
        }
        ++v35;
        ++v34;
        HIDWORD(v62) |= (v50 & 2) >> 1;
        v12 = v46;
        v8 = v48;
      }
      ++v36;
      v13 -= 8;
    }
    while (v13);
    if (v34)
    {
      v65 = (uint64_t)v8;
      LOBYTE(v66) = 0;
      if (*((_QWORD *)v8 + 88))
      {
        if ((v62 & 0x100000000) != 0)
          Address = (uint64_t)dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(&v65);
        if (!v70[7])
          ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(Address, v39, v40);
        (*((void (**)(unint64_t, uint64_t))v8 + 88))(v34, v70[5]);
      }
      else
      {
        v51 = (void (*)(unint64_t, uint64_t, _QWORD *))*((_QWORD *)v8 + 90);
        if (v51)
        {
          v63[0] = _NSConcreteStackBlock;
          v63[1] = 0x40000000;
          v63[2] = ___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke_168;
          v63[3] = &unk_1E4F7CC48;
          v64 = BYTE4(v62) & 1;
          v63[4] = &v69;
          v63[5] = &v65;
          if (!v70[7])
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(Address, v39, v40);
          v51(v34, v70[5], v63);
        }
      }
      if (*(_BYTE *)(*((_QWORD *)v8 + 1) + 205))
      {
        dyld4::RuntimeState::log(v8, "objc-mapped-notifier called with %lld images:\n", v34);
        do
        {
          if (!v35)
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(v52, v53, v54);
          v56 = *v14++;
          v55 = v56;
          v57 = *v24++;
          dyld4::RuntimeState::log(v8, " objc-mapped: %p %s\n", v55, v57);
          --v35;
          --v34;
        }
        while (v34);
      }
      v58 = *((_QWORD *)v8 + 6);
      if (v58)
      {
        v59 = (dyld4::Loader **)*((_QWORD *)v8 + 5);
        v60 = 8 * v58;
        do
        {
          v61 = *v59;
          if ((*((_WORD *)*v59 + 2) & 4) != 0
            && dyld4::Loader::hasConstantSegmentsToProtect(*v59)
            && (*((_WORD *)v61 + 2) & 0x80) != 0)
          {
            dyld4::Loader::makeSegmentsReadOnly(v61, v8);
          }
          ++v59;
          v60 -= 8;
        }
        while (v60);
      }
      if ((_BYTE)v66)
        dyld4::ProcessConfig::DyldCache::makeDataConstWritable((char **)(*(_QWORD *)(v65 + 8) + 240), *(_QWORD *)(v65 + 8) + 200, *(_QWORD *)(v65 + 8), 0);
    }
  }
  _Block_object_dispose(&v69, 8);
}

__n128 __Block_byref_object_copy__166(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

_QWORD *dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  const void **v3;
  vm_address_t v4;
  vm_size_t v5;
  unint64_t v6;
  vm_size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v2 = result[1];
  if (v2 < a2)
  {
    v3 = (const void **)result;
    v4 = result[3];
    v5 = result[4];
    v6 = 2 * v2;
    if (v6 <= a2)
      v6 = a2;
    v7 = (vm_page_size + 48 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    result = memmove((void *)v3[3], *v3, 48 * (_QWORD)v3[2]);
    v11 = (unint64_t)v3[4] / 0x30;
    *v3 = v3[3];
    v3[1] = (const void *)v11;
    if (v4)
      return (_QWORD *)vm_deallocate(mach_task_self_, v4, v5);
  }
  return result;
}

void OUTLINED_FUNCTION_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 56, a4);
}

void OUTLINED_FUNCTION_2(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 64, a4);
}

void OUTLINED_FUNCTION_3(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 336, a4);
}

void OUTLINED_FUNCTION_4(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 54, a4);
}

uint64_t lsl::readPVLEUInt64(uint64_t *a1, uint64_t *__dst)
{
  unsigned __int8 *v2;
  _BYTE *v4;
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;

  *__dst = 0;
  v2 = (unsigned __int8 *)a1[1];
  if (!v2)
    return 0;
  v4 = (_BYTE *)*a1;
  v5 = *(unsigned __int8 *)*a1;
  v6 = __clz(__rbit32(v5));
  if (!*(_BYTE *)*a1)
    v6 = 8;
  v7 = v6 + 1;
  if ((unint64_t)v2 < v7)
    return 0;
  if (v6 == 8)
  {
    *__dst = *(_QWORD *)(v4 + 1);
    v10 = a1[1] - 9;
    v11 = *a1 + 9;
  }
  else
  {
    v12 = 7 - v6;
    v13 = (v5 >> (v6 + 1)) & ~(-1 << (7 - v6));
    if (v6)
    {
      memmove(__dst, v4 + 1, v6);
      v14 = *__dst;
      v4 = (_BYTE *)*a1;
      v2 = (unsigned __int8 *)a1[1];
    }
    else
    {
      v14 = 0;
    }
    *__dst = (v14 << v12) | v13;
    v10 = (uint64_t)&v2[-v7];
    v11 = (uint64_t)&v4[v7];
  }
  *a1 = v11;
  a1[1] = v10;
  return 1;
}

char *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  char *v5;
  char v7;
  uint64_t v8;
  uint64_t v9;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      lsl::Vector<std::byte>::reserve(a4, *(_QWORD *)(a4 + 16) + 1);
      v7 = *v5++;
      v8 = *(_QWORD *)(a4 + 8);
      v9 = *(_QWORD *)(a4 + 16);
      *(_QWORD *)(a4 + 16) = v9 + 1;
      *(_BYTE *)(v8 + v9) = v7;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

os_unfair_lock *lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(os_unfair_lock *this, void *a2)
{
  os_unfair_lock *v2;
  unsigned int v3;
  dyld4::Atlas::Mapper *v4;
  void *v5;

  v2 = this;
  do
    v3 = __ldaxr(&this->_os_unfair_lock_opaque);
  while (__stlxr(v3 - 1, &this->_os_unfair_lock_opaque));
  if (!v3)
  {
    v4 = *(dyld4::Atlas::Mapper **)&this[2]._os_unfair_lock_opaque;
    if (v4)
    {
      dyld4::Atlas::Mapper::~Mapper(v4);
      lsl::Allocator::freeObject(*(const os_unfair_lock **)&v2[2]._os_unfair_lock_opaque, v5);
    }
    return (os_unfair_lock *)lsl::Allocator::freeObject(v2, a2);
  }
  return this;
}

uint64_t SwiftHashTable::hash<PointerHashTableBuilderKey>(uint64_t a1, objc **a2)
{
  unint64_t v4;
  unint64_t v5;
  int v6;
  unsigned int v7;

  v4 = objc::lookup8((objc *)(a2 + 1), (const unsigned __int8 *)4, *(_QWORD *)(a1 + 24));
  v5 = objc::lookup8(*a2, (const unsigned __int8 *)(8 * *((_DWORD *)a2 + 2)), *(_QWORD *)(a1 + 24));
  v6 = *(_DWORD *)(a1 + 8);
  if (v6 == 64)
    v7 = 0;
  else
    v7 = (v5 ^ v4) >> v6;
  return v7 ^ *(_DWORD *)(a1 + 4 * *(unsigned __int8 *)(a1 + ((v5 ^ v4) & *(unsigned int *)(a1 + 12)) + 1056) + 32);
}

BOOL SwiftHashTable::equal<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v3;

  v3 = a2[1];
  return v3 == *(_DWORD *)(a3 + 8) && _platform_memcmp((const void *)(a1 + *a2), *(const void **)a3, 8 * v3) == 0;
}

uint64_t SwiftHashTable::checkbyte<PointerHashTableBuilderKey>(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 8) & 0x1F | (32 * (**(_DWORD **)a2 & 7u));
}

const char *getForeignFullIdentity(const char *a1)
{
  const char *v1;
  const char *v2;
  size_t v3;
  uint64_t v4;
  const char *v5;
  const char *v6;
  int v7;
  unsigned int v8;
  BOOL v9;
  const char *v10;
  const char *v11;
  size_t v12;

  v1 = a1;
  v2 = &a1[_platform_strlen(a1)];
  v3 = _platform_strlen(v2 + 1);
  if (v3)
  {
    v4 = (uint64_t)&v2[v3 + 1];
    v5 = v2;
    do
    {
      v6 = (const char *)v4;
      v7 = v5[1];
      v8 = v7 - 82;
      v9 = v7 == 78;
      v10 = v5 + 2;
      if (v9)
      {
        v11 = v6;
      }
      else
      {
        v10 = v1;
        v11 = v2;
      }
      if (v8 < 2)
      {
        v2 = v6;
      }
      else
      {
        v1 = v10;
        v2 = v11;
      }
      v12 = _platform_strlen(v6 + 1);
      v4 = (uint64_t)&v6[v12 + 1];
      v5 = v6;
    }
    while (v12);
  }
  return v1;
}

BOOL dyld4::PrebuiltSwift::findProtocolConformances(dyld4::PrebuiltSwift *this, vm_address_t *a2, dyld4::PrebuiltObjC *a3, dyld4::RuntimeState *a4)
{
  _QWORD *v6;
  BOOL v7;
  uint64_t v9;
  dyld4::Loader **v10;
  uint64_t v11;
  dyld4::Loader *v12;
  dyld3::MachOFile *v13;
  uint64_t Address;
  dyld3::MachOFile *v15;
  int v16;
  const dyld3::MachOAnalyzer *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD v22[16];
  char v23;
  _BYTE v24[7];
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  __n128 (*v28)(uint64_t, uint64_t);
  uint64_t (*v29)();
  uint64_t v30;
  _QWORD v31[8];
  int v32;
  _QWORD v33[6];
  int v34;
  _DWORD v35[3];

  if (!*((_QWORD *)a3 + 2))
  {
    Diagnostics::error(a2, "Skipped optimizing Swift protocols due to missing objc class optimisations from the on-disk binary");
    return 0;
  }
  v6 = (_QWORD *)*((_QWORD *)a4 + 1);
  v19 = v6[39];
  if (!v19)
  {
    Diagnostics::error(a2, "Skipped optimizing Swift protocols due to missing objc class optimisations");
    return 0;
  }
  if (v6[36])
    v7 = v6[37] == 0;
  else
    v7 = 1;
  if (v7)
  {
    Diagnostics::error(a2, "Skipped optimizing Swift protocols due to missing objc header infos");
    return 0;
  }
  v9 = *((_QWORD *)a4 + 6);
  if (v9)
  {
    v18 = v6[34];
    v10 = (dyld4::Loader **)*((_QWORD *)a4 + 5);
    v11 = 8 * v9;
    do
    {
      v12 = *v10;
      if ((*((_WORD *)*v10 + 2) & 1) == 0)
      {
        v13 = (dyld3::MachOFile *)dyld4::Loader::mf(*v10, a4);
        Address = dyld3::MachOFile::preferredLoadAddress(v13);
        v15 = (dyld3::MachOFile *)dyld4::Loader::analyzer(v12, a4);
        v16 = dyld3::MachOFile::pointerSize(v15);
        v33[0] = _NSConcreteStackBlock;
        v33[1] = 0x40000000;
        v33[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke;
        v33[3] = &__block_descriptor_tmp_2;
        v34 = v16;
        v33[4] = Address;
        v33[5] = v15;
        v31[0] = _NSConcreteStackBlock;
        v31[1] = 0x40000000;
        v31[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2;
        v31[3] = &__block_descriptor_tmp_5;
        v31[4] = Address;
        v31[5] = v12;
        v32 = v16;
        v31[6] = v15;
        v31[7] = a4;
        v25 = 0;
        v26 = &v25;
        v27 = 0x4802000000;
        v28 = __Block_byref_object_copy__1;
        v29 = __Block_byref_object_dispose__1;
        v17 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(v12, a4);
        metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)&v30, v17);
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000;
        v22[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_6;
        v22[3] = &unk_1E4F7CD20;
        v22[8] = v13;
        v22[9] = a2;
        v22[6] = &v25;
        v22[7] = this;
        v22[4] = v33;
        v22[5] = v31;
        v22[10] = Address;
        v22[11] = v12;
        v22[12] = a4;
        v22[13] = a3;
        v22[14] = v19;
        v22[15] = v18;
        v23 = 1;
        *(_DWORD *)&v24[3] = *(_DWORD *)((char *)v35 + 3);
        *(_DWORD *)v24 = v35[0];
        metadata_visitor::SwiftVisitor::forEachProtocolConformance((metadata_visitor::SwiftVisitor *)(v26 + 5), (uint64_t)v22);
        _Block_object_dispose(&v25, 8);
      }
      ++v10;
      v11 -= 8;
    }
    while (v11);
  }
  return !Diagnostics::hasError((Diagnostics *)a2);
}

BOOL ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*a2)
    return 0;
  v4 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)(a2 + 8));
  if (!v5)
    std::__throw_bad_optional_access[abi:nn180100]();
  v6 = *(_QWORD *)(a1 + 40);
  v7 = v4 - *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(a1 + 48) == 8)
    v8 = *(_QWORD *)(v6 + v7);
  else
    v8 = *(unsigned int *)(v6 + v7);
  return v8 == 0;
}

uint64_t ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2@<X0>(metadata_visitor::ResolvedValue *this@<X1>, uint64_t a2@<X0>, uint64_t a3@<X8>)
{
  int v5;
  uint64_t result;
  char v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  dyld4::RuntimeState *v12;
  uint64_t v13;
  dyld4::Loader **v14;
  uint64_t v15;
  dyld4::Loader *v16;
  unsigned __int8 v17;
  unint64_t v18;
  void *v19;

  v5 = *(unsigned __int8 *)this;
  result = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)((char *)this + 8));
  if (v5)
  {
    if (v7)
    {
      v8 = (char *)(result - *(_QWORD *)(a2 + 32));
      *(_QWORD *)a3 = *(_QWORD *)(a2 + 40);
LABEL_4:
      *(_QWORD *)(a3 + 8) = v8;
      *(_BYTE *)(a3 + 16) = 1;
      return result;
    }
LABEL_16:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  if (!v7)
    goto LABEL_16;
  v9 = result - *(_QWORD *)(a2 + 32);
  v10 = *(_QWORD *)(a2 + 48);
  if (*(_DWORD *)(a2 + 64) == 8)
  {
    v11 = *(char **)(v10 + v9);
    if (!v11)
      goto LABEL_14;
  }
  else
  {
    v11 = (char *)*(unsigned int *)(v10 + v9);
    if (!*(_DWORD *)(v10 + v9))
      goto LABEL_14;
  }
  v12 = *(dyld4::RuntimeState **)(a2 + 56);
  v13 = *((_QWORD *)v12 + 6);
  if (v13)
  {
    v14 = (dyld4::Loader **)*((_QWORD *)v12 + 5);
    v15 = 8 * v13;
    while (1)
    {
      v16 = *v14;
      v18 = 0;
      v19 = 0;
      v17 = 0;
      result = dyld4::Loader::contains(v16, v12, v11, (const void **)&v19, &v18, &v17);
      if ((result & 1) != 0)
        break;
      ++v14;
      v15 -= 8;
      if (!v15)
        goto LABEL_14;
    }
    result = dyld4::Loader::loadAddress(v16, v12);
    v8 = &v11[-result];
    *(_QWORD *)a3 = v16;
    goto LABEL_4;
  }
LABEL_14:
  *(_BYTE *)a3 = 0;
  *(_BYTE *)(a3 + 16) = 0;
  return result;
}

__n128 __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_6(uint64_t a1, metadata_visitor::SwiftConformance *a2, _BYTE *a3)
{
  uint64_t v6;
  uint64_t VMAddress;
  char v8;
  unint64_t v9;
  unsigned int v10;
  vm_address_t *v11;
  const dyld3::MachOAnalyzer *v12;
  dyld3::MachOFile *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int hasImportInfo;
  const metadata_visitor::SwiftVisitor *v18;
  BindTarget *v19;
  Loader *ClassName;
  uint64_t *v21;
  unsigned int *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  size_t v27;
  const char *ForeignFullIdentity;
  size_t v29;
  size_t v30;
  Loader *v31;
  Loader *var0;
  dyld3::MachOFile *v33;
  _QWORD v34[6];
  __int128 v35;
  uint64_t v36;
  BindTarget v37;
  uint64_t v38;
  Loader *v39;
  _QWORD v40[6];
  BindTarget v41;
  uint64_t v42;
  Loader *v43;
  BindTarget v44;
  __int128 v45;
  uint64_t v46;
  char v47;
  uint64_t v48;
  BindTarget v49;
  BindTarget v50;
  __int128 v51;
  BindTarget v52;
  uint64_t v53;
  BindTarget v54;
  BindTarget v55;
  char v56;
  BindTarget v57;
  uint64_t v58;
  BindTarget v59;
  char v60;
  char v61[32];
  _QWORD v62[3];
  _BYTE v63[32];
  char v64[32];

  v6 = *(_QWORD *)(a1 + 56);
  if (metadata_visitor::SwiftConformance::isNull(a2)
    && (dyld3::MachOFile::enforceFormat(*(_DWORD **)(a1 + 64), 14) & 1) == 0)
  {
    v11 = *(vm_address_t **)(a1 + 72);
    metadata_visitor::SwiftConformance::getLocation(a2);
    Diagnostics::error(v11, "Skipped optimizing Swift protocols due to null conformance at 0x%llx");
    goto LABEL_17;
  }
  metadata_visitor::SwiftConformance::getProtocolPointer(a2, (const metadata_visitor::SwiftVisitor *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), (uint64_t)v64);
  if (((*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))() & 1) != 0)
    return;
  metadata_visitor::SwiftConformance::getTypeRef(a2, (const metadata_visitor::SwiftVisitor *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), (uint64_t)v63);
  metadata_visitor::SwiftConformance::getProtocolConformanceFlags(a2, (const metadata_visitor::SwiftVisitor *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), v62);
  metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getTargetPointer((metadata_visitor::ResolvedValue *)v63, (const metadata_visitor::SwiftVisitor *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), (uint64_t)v61);
  if (((*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))() & 1) != 0)
    return;
  LOBYTE(v59.var0) = 0;
  v60 = 0;
  (*(void (**)(BindTarget *__return_ptr))(*(_QWORD *)(a1 + 40) + 16))(&v44);
  v60 = v45;
  v59 = v44;
  if (!(_BYTE)v45)
  {
    Diagnostics::error(*(vm_address_t **)(a1 + 72), "Skipped optimizing Swift protocols, could not find image for type conformance pointer");
    goto LABEL_17;
  }
  LOBYTE(v57.var0) = 0;
  LOBYTE(v58) = 0;
  (*(void (**)(BindTarget *__return_ptr))(*(_QWORD *)(a1 + 40) + 16))(&v44);
  LOBYTE(v58) = v45;
  v57 = v44;
  if (!(_BYTE)v45)
  {
    Diagnostics::error(*(vm_address_t **)(a1 + 72), "Skipped optimizing Swift protocols, could not find image for type protocol pointer");
    goto LABEL_17;
  }
  VMAddress = objc_visitor::Protocol::getVMAddress(a2);
  if (!v8)
    goto LABEL_41;
  v9 = VMAddress - *(_QWORD *)(a1 + 80);
  v10 = metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags::typeReferenceKind((metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags *)v62);
  if (v10 < 2)
  {
    LOBYTE(v55.var0) = 0;
    v56 = 0;
    if (v59.var0 == *(Loader **)(a1 + 88))
    {
      v44.var0 = *(Loader **)(a1 + 80);
      v14 = 1;
      LOBYTE(v44.var1) = 1;
      v50.var0 = (Loader *)v59.var1;
      LOBYTE(v50.var1) = 1;
      v23 = operator+((uint64_t)&v44, (uint64_t)&v50);
      metadata_visitor::Visitor::getValueFor(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40, v23, v24, &v44);
      v50 = v44;
      *(_QWORD *)&v51 = v45;
      if (metadata_visitor::SwiftConformance::TypeContextDescriptor::isForeignMetadata((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v50))
      {
        hasImportInfo = metadata_visitor::SwiftConformance::TypeContextDescriptor::hasImportInfo((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v50);
        v18 = (const metadata_visitor::SwiftVisitor *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
        v19 = &v50;
        goto LABEL_27;
      }
    }
    else
    {
      v12 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer((dyld4::Loader *)v59.var0, *(dyld4::RuntimeState **)(a1 + 96));
      metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)&v44, v12);
      v13 = (dyld3::MachOFile *)dyld4::Loader::mf((dyld4::Loader *)v59.var0, *(const dyld4::RuntimeState **)(a1 + 96));
      v54.var0 = (Loader *)dyld3::MachOFile::preferredLoadAddress(v13);
      v14 = 1;
      LOBYTE(v54.var1) = 1;
      v50.var0 = (Loader *)v59.var1;
      LOBYTE(v50.var1) = 1;
      v15 = operator+((uint64_t)&v54, (uint64_t)&v50);
      metadata_visitor::Visitor::getValueFor((uint64_t)&v44, v15, v16, &v50);
      v52 = v50;
      v53 = v51;
      if (metadata_visitor::SwiftConformance::TypeContextDescriptor::isForeignMetadata((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v52))
      {
        hasImportInfo = metadata_visitor::SwiftConformance::TypeContextDescriptor::hasImportInfo((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v52);
        v18 = (const metadata_visitor::SwiftVisitor *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
        v19 = &v52;
LABEL_27:
        metadata_visitor::SwiftConformance::TypeContextDescriptor::getName((metadata_visitor::SwiftConformance::TypeContextDescriptor *)v19, v18, &v55);
        v56 = 1;
LABEL_29:
        if (!v14)
        {
LABEL_37:
          if (!v60)
            goto LABEL_41;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v50, &v59);
          if (!(_BYTE)v58)
            goto LABEL_41;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v50.var1, &v57);
          v52.var0 = *(Loader **)(a1 + 88);
          v52.var1 = v9;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v54, &v52);
          LOBYTE(v49.var0) = 0;
          v44 = v50;
          *(_QWORD *)&v45 = v54.var0;
          dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert(v6, (uint64_t)&v44, &v49);
          return;
        }
        v25 = (char *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v55);
        v52.var0 = (Loader *)metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)&v55);
        v52.var1 = v26;
        v27 = _platform_strlen(v25);
        if (hasImportInfo)
        {
          ForeignFullIdentity = getForeignFullIdentity(v25);
          v30 = v29;
          v44.var0 = (Loader *)(ForeignFullIdentity - v25);
          LOBYTE(v44.var1) = 1;
          operator+=((uint64_t)&v52, (uint64_t)&v44);
          v25 = (char *)ForeignFullIdentity;
        }
        else
        {
          v30 = v27;
        }
        if (!(v30 >> 16))
        {
          v31 = *(Loader **)(a1 + 88);
          v54.var0 = v31;
          if (!LOBYTE(v52.var1))
            goto LABEL_41;
          var0 = v52.var0;
          v33 = (dyld3::MachOFile *)dyld4::Loader::mf((dyld4::Loader *)v31, *(const dyld4::RuntimeState **)(a1 + 96));
          v54.var1 = (unint64_t)var0 - dyld3::MachOFile::preferredLoadAddress(v33);
          v50.var0 = (Loader *)v25;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v50.var1, &v54);
          *(_QWORD *)&v51 = v30;
          if (!(_BYTE)v58)
            goto LABEL_41;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)((char *)&v51 + 8), &v57);
          v49.var0 = *(Loader **)(a1 + 88);
          v49.var1 = v9;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v48, &v49);
          v47 = 0;
          v44 = v50;
          v45 = v51;
          v46 = v48;
          dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert(v6 + 208, (uint64_t)&v44, &v47);
          goto LABEL_37;
        }
        Diagnostics::error(*(vm_address_t **)(a1 + 72), "Protocol conformance exceeded name length of 16-bits");
LABEL_17:
        *a3 = 1;
        return;
      }
    }
    v14 = 0;
    hasImportInfo = 0;
    goto LABEL_29;
  }
  if (v10 == 2)
  {
    ClassName = (Loader *)metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName((metadata_visitor::SwiftConformance::SwiftTypeRefPointer *)v63, (const metadata_visitor::SwiftVisitor *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));
    v55.var0 = *(Loader **)(a1 + 88);
    v55.var1 = v9;
    dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v52, &v55);
    v44.var0 = 0;
    v44.var1 = (unint64_t)&v44;
    *(_QWORD *)&v45 = 0x2000000000;
    BYTE8(v45) = 0;
    v50.var0 = ClassName;
    v50.var1 = _platform_strlen((const char *)ClassName);
    v21 = *(uint64_t **)(a1 + 104);
    v40[0] = _NSConcreteStackBlock;
    v40[1] = 0x40000000;
    v40[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2_11;
    v40[3] = &unk_1E4F7CCD0;
    v40[4] = &v44;
    v40[5] = v6;
    v41 = v57;
    v42 = v58;
    v43 = v52.var0;
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>((uint64_t)(v21 + 17), v21 + 19, v21 + 24, v21[29], (const void **)&v50.var0, (uint64_t)v40);
    v22 = *(unsigned int **)(a1 + 112);
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 0x40000000;
    v34[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_3;
    v34[3] = &unk_1E4F7CCF8;
    v35 = *(_OWORD *)(a1 + 120);
    v36 = *(_QWORD *)(a1 + 96);
    v34[4] = &v44;
    v34[5] = v6;
    v37 = v57;
    v38 = v58;
    v39 = v52.var0;
    objc::ObjectHashTable::forEachObject(v22, (char *)ClassName, (uint64_t)v34);
    if (!*(_BYTE *)(v44.var1 + 24))
    {
      Diagnostics::error(*(vm_address_t **)(a1 + 72), "Skipped optimizing Swift protocols, could not find image for ObjCClassName pointer at all");
      *a3 = 1;
    }
    _Block_object_dispose(&v44, 8);
  }
  else if (v10 == 3)
  {
    if (v60)
    {
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v55, &v59);
      if ((_BYTE)v58)
      {
        dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v55.var1, &v57);
        v50.var0 = *(Loader **)(a1 + 88);
        v50.var1 = v9;
        dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v52, &v50);
        LOBYTE(v54.var0) = 0;
        v44 = v55;
        *(_QWORD *)&v45 = v52.var0;
        dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert(v6 + 104, (uint64_t)&v44, &v54);
        return;
      }
    }
LABEL_41:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
}

uint64_t operator+(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 8) || !*(_BYTE *)(a2 + 8))
    std::__throw_bad_optional_access[abi:nn180100]();
  return *(_QWORD *)a2 + *(_QWORD *)a1;
}

uint64_t operator+=(uint64_t result, uint64_t a2)
{
  if (!*(_BYTE *)(result + 8) || !*(_BYTE *)(a2 + 8))
    std::__throw_bad_optional_access[abi:nn180100]();
  *(_QWORD *)result += *(_QWORD *)a2;
  *(_BYTE *)(result + 8) = 1;
  return result;
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  vm_address_t v15;
  vm_size_t v16;
  unint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _OWORD v50[2];
  vm_size_t size;

  v6 = *(_QWORD *)(a1 + 8);
  if (v6 == *(_QWORD *)a1)
  {
    v7 = 2 * *(_QWORD *)(a1 + 32);
    *(_QWORD *)a1 = 2 * v6;
    size = 0;
    memset(v50, 0, sizeof(v50));
    dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v50, v7);
    for (; v7; --v7)
    {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v50, 1);
      v8 = (*(_QWORD *)&v50[1])++;
      *(_QWORD *)(*(_QWORD *)&v50[0] + 8 * v8) = -1;
    }
    if (*(_QWORD *)(a1 + 72))
    {
      v9 = 0;
      do
      {
        if ((*(_BYTE *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v9)+ 40) & 6) == 0)
        {
          v10 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v9);
          v12 = dyld4::HashForeignConformanceKey::hash(v10, *(dyld4::RuntimeState **)(a1 + 96), v11);
          v13 = (*(_QWORD *)&v50[1] - 1) & v12;
          if (*(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v50, v13) != -1)
          {
            v14 = 1;
            do
              v13 = (*(_QWORD *)&v50[1] - 1) & (v13 + v14++);
            while (*(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v50, v13) != -1);
          }
          *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v50, v13) = v9;
        }
        ++v9;
      }
      while (v9 != *(_QWORD *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v50)
    {
      *(_QWORD *)&v50[1] = 0;
      if (*((_QWORD *)&v50[1] + 1))
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v50[1] + 1), size);
    }
    else
    {
      v15 = *(_QWORD *)(a1 + 40);
      if (v15)
        vm_deallocate(mach_task_self_, v15, *(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)&v50[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v50 + 8);
      v16 = size;
      *(_QWORD *)(a1 + 40) = *((_QWORD *)&v50[1] + 1);
      *(_QWORD *)(a1 + 48) = v16;
    }
  }
  v17 = (*(_QWORD *)(a1 + 32) - 1) & dyld4::HashForeignConformanceKey::hash(a2, *(dyld4::RuntimeState **)(a1 + 96), (uint64_t)a3);
  v18 = *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17);
  if (v18 == -1)
  {
LABEL_22:
    v19 = (_QWORD *)(a1 + 56);
    v22 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17) = v22;
    ++*(_QWORD *)(a1 + 8);
    v23 = *(_OWORD *)(a2 + 16);
    v50[0] = *(_OWORD *)a2;
    v50[1] = v23;
    v24 = *(_QWORD *)(a2 + 32);
    v25 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v28 = *(_QWORD *)(a1 + 56);
    v29 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v29 + 1;
    v30 = v28 + 48 * v29;
    *(_OWORD *)v30 = v50[0];
    *(_OWORD *)(v30 + 16) = v50[1];
    *(_QWORD *)(v30 + 32) = v24;
    *(_QWORD *)(v30 + 40) = 0;
    *a3 = 0;
    v31 = *(_QWORD *)(a1 + 72);
    if (!v31)
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert((uint64_t)v25, v26, v27);
  }
  else
  {
    v19 = (_QWORD *)(a1 + 56);
    v20 = 1;
    while (1)
    {
      v21 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v18);
      if (dyld4::EqualForeignConformanceKey::equal(v21, a2, *(dyld4::RuntimeState **)(a1 + 96)))
        break;
      v17 = (*(_QWORD *)(a1 + 32) - 1) & (v17 + v20++);
      v18 = *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17);
      if (v18 == -1)
        goto LABEL_22;
    }
    while (1)
    {
      v32 = *(_BYTE *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v18)+ 40);
      v33 = (_QWORD *)(a1 + 56);
      if ((v32 & 3) == 0)
        break;
      v18 = *(_QWORD *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[](v33, v18)+ 40) >> 3;
    }
    v34 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[](v33, v18);
    v37 = *(_QWORD *)(v34 + 40);
    if ((v37 & 7) != 0)
    {
      if ((v37 & 4) == 0)
        dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert(v34, v35, v36);
      v38 = v37 & 0xFFFFFFFFFFFFFFF9 | 2;
      *(_QWORD *)(v34 + 40) = v38;
      v39 = v38 & 3 | (8 * *(_QWORD *)(a1 + 72));
    }
    else
    {
      v40 = v37 | 1;
      *(_QWORD *)(v34 + 40) = v40;
      v39 = v40 & 7 | (8 * *(_QWORD *)(a1 + 72));
    }
    *(_QWORD *)(v34 + 40) = v39;
    v41 = *(_OWORD *)(a2 + 16);
    v50[0] = *(_OWORD *)a2;
    v50[1] = v41;
    v42 = *(_QWORD *)(a2 + 32);
    v43 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v46 = *(_QWORD *)(a1 + 56);
    v47 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v47 + 1;
    v48 = v46 + 48 * v47;
    *(_OWORD *)v48 = v50[0];
    *(_OWORD *)(v48 + 16) = v50[1];
    *(_QWORD *)(v48 + 32) = v42;
    *(_QWORD *)(v48 + 40) = 4;
    *a3 = 1;
    v31 = *(_QWORD *)(a1 + 72);
    if (!v31)
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert((uint64_t)v43, v44, v45);
  }
  return *v19 + 48 * v31 - 48;
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  vm_address_t v14;
  vm_size_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _OWORD v47[2];
  vm_size_t size;

  v6 = *(_QWORD *)(a1 + 8);
  if (v6 == *(_QWORD *)a1)
  {
    v7 = 2 * *(_QWORD *)(a1 + 32);
    *(_QWORD *)a1 = 2 * v6;
    size = 0;
    memset(v47, 0, sizeof(v47));
    dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v47, v7);
    for (; v7; --v7)
    {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v47, 1);
      v8 = (*(_QWORD *)&v47[1])++;
      *(_QWORD *)(*(_QWORD *)&v47[0] + 8 * v8) = -1;
    }
    if (*(_QWORD *)(a1 + 72))
    {
      v9 = 0;
      do
      {
        if ((*(_BYTE *)(dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v9)+ 24) & 6) == 0)
        {
          v10 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v9);
          v11 = dyld4::HashTypeConformanceKey::hash(v10);
          v12 = (*(_QWORD *)&v47[1] - 1) & v11;
          if (*(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v47, v12) != -1)
          {
            v13 = 1;
            do
              v12 = (*(_QWORD *)&v47[1] - 1) & (v12 + v13++);
            while (*(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v47, v12) != -1);
          }
          *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v47, v12) = v9;
        }
        ++v9;
      }
      while (v9 != *(_QWORD *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v47)
    {
      *(_QWORD *)&v47[1] = 0;
      if (*((_QWORD *)&v47[1] + 1))
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v47[1] + 1), size);
    }
    else
    {
      v14 = *(_QWORD *)(a1 + 40);
      if (v14)
        vm_deallocate(mach_task_self_, v14, *(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)&v47[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v47 + 8);
      v15 = size;
      *(_QWORD *)(a1 + 40) = *((_QWORD *)&v47[1] + 1);
      *(_QWORD *)(a1 + 48) = v15;
    }
  }
  v16 = (*(_QWORD *)(a1 + 32) - 1) & dyld4::HashTypeConformanceKey::hash(a2);
  v17 = *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v16);
  if (v17 == -1)
  {
LABEL_22:
    v18 = (_QWORD *)(a1 + 56);
    v21 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v16) = v21;
    ++*(_QWORD *)(a1 + 8);
    v47[0] = *(_OWORD *)a2;
    v22 = *(_QWORD *)(a2 + 16);
    v23 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v26 = *(_QWORD *)(a1 + 56);
    v27 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v27 + 1;
    v28 = v26 + 32 * v27;
    *(_OWORD *)v28 = v47[0];
    *(_QWORD *)(v28 + 16) = v22;
    *(_QWORD *)(v28 + 24) = 0;
    *a3 = 0;
    v29 = *(_QWORD *)(a1 + 72);
    if (!v29)
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert((uint64_t)v23, v24, v25);
  }
  else
  {
    v18 = (_QWORD *)(a1 + 56);
    v19 = 1;
    while (1)
    {
      v20 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v17);
      if (dyld4::EqualTypeConformanceKey::equal(v20, a2))
        break;
      v16 = (*(_QWORD *)(a1 + 32) - 1) & (v16 + v19++);
      v17 = *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v16);
      if (v17 == -1)
        goto LABEL_22;
    }
    while (1)
    {
      v30 = *(_BYTE *)(dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v17)+ 24);
      v31 = (_QWORD *)(a1 + 56);
      if ((v30 & 3) == 0)
        break;
      v17 = *(_QWORD *)(dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](v31, v17)+ 24) >> 3;
    }
    v32 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](v31, v17);
    v35 = *(_QWORD *)(v32 + 24);
    if ((v35 & 7) != 0)
    {
      if ((v35 & 4) == 0)
        dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert(v32, v33, v34);
      v36 = v35 & 0xFFFFFFFFFFFFFFF9 | 2;
      *(_QWORD *)(v32 + 24) = v36;
      v37 = v36 & 3 | (8 * *(_QWORD *)(a1 + 72));
    }
    else
    {
      v38 = v35 | 1;
      *(_QWORD *)(v32 + 24) = v38;
      v37 = v38 & 7 | (8 * *(_QWORD *)(a1 + 72));
    }
    *(_QWORD *)(v32 + 24) = v37;
    v47[0] = *(_OWORD *)a2;
    v39 = *(_QWORD *)(a2 + 16);
    v40 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v43 = *(_QWORD *)(a1 + 56);
    v44 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v44 + 1;
    v45 = v43 + 32 * v44;
    *(_OWORD *)v45 = v47[0];
    *(_QWORD *)(v45 + 16) = v39;
    *(_QWORD *)(v45 + 24) = 4;
    *a3 = 1;
    v29 = *(_QWORD *)(a1 + 72);
    if (!v29)
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert((uint64_t)v40, v41, v42);
  }
  return *v18 + 32 * v29 - 32;
}

uint64_t ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2_11(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  const BindTarget **v4;
  const BindTarget *v5;
  uint64_t v6;
  uint64_t v7;
  const BindTarget *v8;
  __int128 v9;
  uint64_t v10;
  char v11;
  __int128 v12;

  v2 = *(_QWORD *)(a2 + 16);
  if (v2)
  {
    v3 = result;
    v4 = *(const BindTarget ***)a2;
    v5 = (const BindTarget *)(result + 48);
    v6 = *(_QWORD *)(result + 40) + 104;
    v7 = 8 * v2;
    do
    {
      v8 = *v4;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = 1;
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v12, v8 + 1);
      if (!*(_BYTE *)(v3 + 64))
        std::__throw_bad_optional_access[abi:nn180100]();
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)((char *)&v12 + 8), v5);
      v11 = 0;
      v9 = v12;
      v10 = *(_QWORD *)(v3 + 72);
      result = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert(v6, (uint64_t)&v9, &v11);
      ++v4;
      v7 -= 8;
    }
    while (v7);
  }
  return result;
}

unint64_t ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_3(unint64_t result, uint64_t a2)
{
  unint64_t v2;
  const dyld4::RuntimeState *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  dyld4::Loader **v7;
  uint64_t v8;
  dyld4::Loader *v9;
  dyld3::MachOFile *v10;
  unint64_t Address;
  __int128 v13;
  uint64_t v14;
  char v15;
  __int128 v16;
  BindTarget v17;

  if (!*(_BYTE *)(result + 56))
    goto LABEL_13;
  v2 = result;
  v3 = *(const dyld4::RuntimeState **)(result + 64);
  v4 = *((_QWORD *)v3 + 6);
  if (!v4)
    return result;
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_QWORD *)(result + 48) + a2;
  v7 = (dyld4::Loader **)*((_QWORD *)v3 + 5);
  v8 = 8 * v4;
  while (1)
  {
    v9 = *v7;
    v10 = (dyld3::MachOFile *)dyld4::Loader::mf(*v7, v3);
    Address = dyld3::MachOFile::preferredLoadAddress(v10);
    result = dyld3::MachOFile::mappedSize(v10);
    if (v6 >= Address && result + Address > v6)
      break;
    ++v7;
    v8 -= 8;
    if (!v8)
      return result;
  }
  v17.var0 = (Loader *)v9;
  v17.var1 = v6 - Address;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) = 1;
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v16, &v17);
  if (!*(_BYTE *)(v2 + 88))
LABEL_13:
    std::__throw_bad_optional_access[abi:nn180100]();
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)((char *)&v16 + 8), (const BindTarget *)(v2 + 72));
  v15 = 0;
  v13 = v16;
  v14 = *(_QWORD *)(v2 + 96);
  return dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert(v5 + 104, (uint64_t)&v13, &v15);
}

BOOL dyld4::PrebuiltSwift::make(dyld4::PrebuiltSwift *this, vm_address_t *a2, dyld4::PrebuiltObjC *a3, dyld4::RuntimeState *a4)
{
  _BOOL8 result;

  result = dyld4::PrebuiltSwift::findProtocolConformances(this, a2, a3, a4);
  if (result)
    *((_BYTE *)this + 312) = 1;
  return result;
}

void std::__throw_bad_optional_access[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_optional_access was thrown in -fno-exceptions mode");
}

uint64_t dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[](_QWORD *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = a1[2];
  v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5)
      dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve(a1, a2 + 1);
    a1[2] = v5;
  }
  return *a1 + 48 * a2;
}

void dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, const void **a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  const void *v18;
  const void **v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  unint64_t v31;
  int v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  size_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t *v50;
  int64x2_t v51;
  uint64_t v52;

  v48 = a6;
  v49 = a3;
  if (a3[2])
  {
    v8 = prebuilt_objc::hashStringKey((uint64_t)a5);
    v11 = a2[2];
    v12 = (v11 - 1) & v8;
    if (v11 <= v12)
LABEL_9:
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v8, v9, v10);
    v13 = *a2;
    v14 = v49[2];
    v15 = *v49;
    v16 = 1;
    v19 = a5;
    v18 = *a5;
    v17 = (size_t)v19[1];
    while (1)
    {
      v20 = *(_QWORD *)(v13 + 8 * v12);
      if (v20 == -1)
        break;
      if (v14 <= v20)
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v8, v9, v10);
      v21 = v15 + 56 * v20;
      if (*(_QWORD *)(v21 + 8) == v17)
      {
        v8 = _platform_memcmp(*(const void **)v21, v18, v17);
        if (!(_DWORD)v8)
        {
          v27 = v15 + 56 * v20;
          v30 = *(_QWORD *)(v27 + 48);
          v29 = (_QWORD *)(v27 + 48);
          v28 = v30;
          if ((v30 & 7) != 0)
          {
            if (v14 <= v28 >> 3)
LABEL_15:
              dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v8, v9, v10);
            v31 = v28 >> 3;
            v32 = 2;
            while (1)
            {
              v33 = *(_QWORD *)(v15 + 56 * v31 + 48);
              if ((v33 & 3) == 0)
                break;
              v31 = v33 >> 3;
              ++v32;
              if (v14 <= v33 >> 3)
                goto LABEL_15;
            }
            __chkstk_darwin(v8, v9, v10, v22, v23, v24, v25, v26, v47);
            v36 = (uint64_t *)((char *)&v47 - v35);
            if (v34 >= 0x200)
              v37 = 512;
            else
              v37 = v34;
            bzero((char *)&v47 - v35, v37);
            *v36 = v15 + 56 * v20 + 16;
            v41 = v49[2];
            if (v41 <= *v29 >> 3)
LABEL_23:
              dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v38, v39, v40);
            v42 = *v29 >> 3;
            v43 = *v49;
            v44 = 2;
            while (1)
            {
              v45 = v43 + 56 * v42;
              v46 = *(_QWORD *)(v45 + 48);
              v36[v44 - 1] = v45 + 16;
              if ((v46 & 3) == 0)
                break;
              v42 = v46 >> 3;
              ++v44;
              if (v41 <= v46 >> 3)
                goto LABEL_23;
            }
            v50 = v36;
            v51.i64[0] = v44;
            v51.i64[1] = v44;
            (*(void (**)(uint64_t, uint64_t **))(v48 + 16))(v48, &v50);
          }
          else
          {
            v52 = v15 + 56 * v20 + 16;
            v50 = &v52;
            v51 = vdupq_n_s64(1uLL);
            (*(void (**)(uint64_t, uint64_t **))(v48 + 16))(v48, &v50);
          }
          return;
        }
      }
      v12 = (v11 - 1) & (v12 + v16++);
      if (v11 <= v12)
        goto LABEL_9;
    }
  }
}

void OUTLINED_FUNCTION_1_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 58, a4);
}

void OUTLINED_FUNCTION_2_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 57, a4);
}

void OUTLINED_FUNCTION_3_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 864, a4);
}

BOOL *dyld4::Loader::InitialOptions::InitialOptions(BOOL *this, const dyld4::Loader *a2)
{
  *this = (*((_BYTE *)a2 + 4) & 2) != 0;
  this[1] = (*((_BYTE *)a2 + 4) & 4) != 0;
  this[2] = (*((_BYTE *)a2 + 4) & 8) != 0;
  this[3] = (*((_BYTE *)a2 + 4) & 0x10) != 0;
  this[4] = (*((_BYTE *)a2 + 4) & 0x20) != 0;
  this[5] = (*((_BYTE *)a2 + 4) & 0x40) != 0;
  this[6] = (*((_WORD *)a2 + 2) & 0x80) != 0;
  this[7] = *((_BYTE *)a2 + 5) & 1;
  this[8] = (*((_WORD *)a2 + 2) & 0x400) != 0;
  this[9] = (*((_WORD *)a2 + 2) & 0x800) != 0;
  this[10] = (*((_WORD *)a2 + 2) & 0x1000) != 0;
  this[11] = (*((_WORD *)a2 + 2) & 0x2000) != 0;
  return this;
}

uint64_t dyld4::Loader::path(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::path();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::path(this, a2);
  else
    return dyld4::JustInTimeLoader::path(this, a2);
}

uint64_t dyld4::Loader::mf(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::mf();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::mf(this, a2);
  else
    return dyld4::JustInTimeLoader::mf(this, a2);
}

uint64_t dyld4::Loader::loadAddress(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::loadAddress();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::loadAddress(this, a2);
  else
    return dyld4::JustInTimeLoader::mf(this, a2);
}

BOOL dyld4::Loader::matchesPath(dyld4::Loader *this, const dyld4::RuntimeState *a2, char *a3)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::matchesPath();
  if ((*((_WORD *)this + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::matchesPath(this, a2, a3);
  else
    return dyld4::JustInTimeLoader::matchesPath(this, a2, a3);
}

uint64_t dyld4::Loader::dependent(dyld4::JustInTimeLoader *a1, dyld4::RuntimeState *a2, uint64_t a3, char *a4)
{
  if (*(_DWORD *)a1 != 1815378276)
    dyld4::Loader::dependent();
  if ((*((_WORD *)a1 + 2) & 1) != 0)
    return dyld4::PrebuiltLoader::dependent(a1, a2, a3, a4);
  else
    return dyld4::JustInTimeLoader::dependent(a1, (int)a2, a3, a4);
}

void dyld4::Loader::applyFixups(uint64_t a1, Diagnostics *a2, uint64_t a3, dyld4::DyldCacheDataConstLazyScopedWriter *a4, char a5, uint64_t a6)
{
  if (*(_DWORD *)a1 != 1815378276)
    dyld4::Loader::applyFixups();
  if ((*(_WORD *)(a1 + 4) & 1) != 0)
    dyld4::PrebuiltLoader::applyFixups(a1, a2, a3, a4);
  else
    dyld4::JustInTimeLoader::applyFixups(a1, (vm_address_t *)a2, a3, a4, a5, a6);
}

void dyld4::Loader::unmap(dyld4::Loader *this, dyld4::RuntimeState *a2, char a3)
{
  if (*(_DWORD *)this != 1815378276)
    dyld4::Loader::unmap();
  if ((*((_WORD *)this + 2) & 1) != 0)
    dyld4::PrebuiltLoader::unmap((uint64_t)this, a2);
  else
    dyld4::JustInTimeLoader::unmap(this, (dyld4::SyscallDelegate **)a2, a3);
}

dyld4::Loader *dyld4::Loader::leafName(dyld4::Loader *this, const char *a2)
{
  char *v3;

  v3 = strrchr((char *)this, 47);
  if (v3)
    return (dyld4::Loader *)(v3 + 1);
  else
    return this;
}

char *dyld4::Loader::leafName(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  char *v2;
  char *v3;

  v2 = (char *)dyld4::Loader::path(this, a2);
  v3 = strrchr(v2, 47);
  if (v3)
    return v3 + 1;
  else
    return v2;
}

uint64_t dyld4::Loader::appendHexByte(uint64_t this, _QWORD *a2, char **a3)
{
  _BYTE *v3;
  char v4;
  _BYTE *v5;
  char v6;

  v3 = (_BYTE *)(*a2)++;
  if (this >= 0xA0)
    v4 = 55;
  else
    v4 = 48;
  *v3 = v4 + (this >> 4);
  v5 = (_BYTE *)(*a2)++;
  if ((this & 0xFu) >= 0xA)
    v6 = 55;
  else
    v6 = 48;
  *v5 = v6 + (this & 0xF);
  return this;
}

unsigned __int8 *dyld4::Loader::uuidToStr(unsigned __int8 *this, unsigned __int8 *a2, char *a3)
{
  unsigned int v3;
  char v4;
  unsigned int v5;
  char v6;
  unsigned int v7;
  char v8;
  unsigned int v9;
  char v10;
  unsigned int v11;
  char v12;
  unsigned int v13;
  char v14;
  unsigned int v15;
  char v16;
  unsigned int v17;
  char v18;
  unsigned int v19;
  char v20;
  unsigned int v21;
  char v22;
  unsigned int v23;
  char v24;
  unsigned int v25;
  char v26;
  unsigned int v27;
  char v28;
  unsigned int v29;
  char v30;
  unsigned int v31;
  char v32;
  unsigned int v33;
  char v34;
  unsigned int v35;
  char v36;
  unsigned int v37;
  char v38;
  unsigned int v39;
  char v40;
  unsigned int v41;
  char v42;
  unsigned int v43;
  char v44;
  unsigned int v45;
  char v46;
  unsigned int v47;
  char v48;
  unsigned int v49;
  char v50;
  unsigned int v51;
  char v52;
  unsigned int v53;
  char v54;
  unsigned int v55;
  char v56;
  unsigned int v57;
  char v58;
  unsigned int v59;
  char v60;
  unsigned int v61;
  char v62;
  unsigned int v63;
  char v64;
  unsigned int v65;
  char v66;

  v3 = *this;
  if (v3 >= 0xA0)
    v4 = 55;
  else
    v4 = 48;
  *a2 = v4 + (*this >> 4);
  v5 = v3 & 0xF;
  if (v5 >= 0xA)
    v6 = 55;
  else
    v6 = 48;
  a2[1] = v6 + v5;
  v7 = this[1];
  if (v7 >= 0xA0)
    v8 = 55;
  else
    v8 = 48;
  a2[2] = v8 + (this[1] >> 4);
  v9 = v7 & 0xF;
  if (v9 >= 0xA)
    v10 = 55;
  else
    v10 = 48;
  a2[3] = v10 + v9;
  v11 = this[2];
  if (v11 >= 0xA0)
    v12 = 55;
  else
    v12 = 48;
  a2[4] = v12 + (this[2] >> 4);
  v13 = v11 & 0xF;
  if (v13 >= 0xA)
    v14 = 55;
  else
    v14 = 48;
  a2[5] = v14 + v13;
  v15 = this[3];
  if (v15 >= 0xA0)
    v16 = 55;
  else
    v16 = 48;
  a2[6] = v16 + (this[3] >> 4);
  v17 = v15 & 0xF;
  if (v17 >= 0xA)
    v18 = 55;
  else
    v18 = 48;
  a2[7] = v18 + v17;
  a2[8] = 45;
  v19 = this[4];
  if (v19 >= 0xA0)
    v20 = 55;
  else
    v20 = 48;
  a2[9] = v20 + (this[4] >> 4);
  v21 = v19 & 0xF;
  if (v21 >= 0xA)
    v22 = 55;
  else
    v22 = 48;
  a2[10] = v22 + v21;
  v23 = this[5];
  if (v23 >= 0xA0)
    v24 = 55;
  else
    v24 = 48;
  a2[11] = v24 + (this[5] >> 4);
  v25 = v23 & 0xF;
  if (v25 >= 0xA)
    v26 = 55;
  else
    v26 = 48;
  a2[12] = v26 + v25;
  a2[13] = 45;
  v27 = this[6];
  if (v27 >= 0xA0)
    v28 = 55;
  else
    v28 = 48;
  a2[14] = v28 + (this[6] >> 4);
  v29 = v27 & 0xF;
  if (v29 >= 0xA)
    v30 = 55;
  else
    v30 = 48;
  a2[15] = v30 + v29;
  v31 = this[7];
  if (v31 >= 0xA0)
    v32 = 55;
  else
    v32 = 48;
  a2[16] = v32 + (this[7] >> 4);
  v33 = v31 & 0xF;
  if (v33 >= 0xA)
    v34 = 55;
  else
    v34 = 48;
  a2[17] = v34 + v33;
  a2[18] = 45;
  v35 = this[8];
  if (v35 >= 0xA0)
    v36 = 55;
  else
    v36 = 48;
  a2[19] = v36 + (this[8] >> 4);
  v37 = v35 & 0xF;
  if (v37 >= 0xA)
    v38 = 55;
  else
    v38 = 48;
  a2[20] = v38 + v37;
  v39 = this[9];
  if (v39 >= 0xA0)
    v40 = 55;
  else
    v40 = 48;
  a2[21] = v40 + (this[9] >> 4);
  v41 = v39 & 0xF;
  if (v41 >= 0xA)
    v42 = 55;
  else
    v42 = 48;
  a2[22] = v42 + v41;
  a2[23] = 45;
  v43 = this[10];
  if (v43 >= 0xA0)
    v44 = 55;
  else
    v44 = 48;
  a2[24] = v44 + (this[10] >> 4);
  v45 = v43 & 0xF;
  if (v45 >= 0xA)
    v46 = 55;
  else
    v46 = 48;
  a2[25] = v46 + v45;
  v47 = this[11];
  if (v47 >= 0xA0)
    v48 = 55;
  else
    v48 = 48;
  a2[26] = v48 + (this[11] >> 4);
  v49 = v47 & 0xF;
  if (v49 >= 0xA)
    v50 = 55;
  else
    v50 = 48;
  a2[27] = v50 + v49;
  v51 = this[12];
  if (v51 >= 0xA0)
    v52 = 55;
  else
    v52 = 48;
  a2[28] = v52 + (this[12] >> 4);
  v53 = v51 & 0xF;
  if (v53 >= 0xA)
    v54 = 55;
  else
    v54 = 48;
  a2[29] = v54 + v53;
  v55 = this[13];
  if (v55 >= 0xA0)
    v56 = 55;
  else
    v56 = 48;
  a2[30] = v56 + (this[13] >> 4);
  v57 = v55 & 0xF;
  if (v57 >= 0xA)
    v58 = 55;
  else
    v58 = 48;
  a2[31] = v58 + v57;
  v59 = this[14];
  if (v59 >= 0xA0)
    v60 = 55;
  else
    v60 = 48;
  a2[32] = v60 + (this[14] >> 4);
  v61 = v59 & 0xF;
  if (v61 >= 0xA)
    v62 = 55;
  else
    v62 = 48;
  a2[33] = v62 + v61;
  v63 = this[15];
  if (v63 >= 0xA0)
    v64 = 55;
  else
    v64 = 48;
  a2[34] = v64 + (this[15] >> 4);
  v65 = v63 & 0xF;
  if (v65 >= 0xA)
    v66 = 55;
  else
    v66 = 48;
  *(_WORD *)(a2 + 35) = (v66 + v65);
  return this;
}

unsigned __int8 *dyld4::Loader::getUuidStr(unsigned __int8 *this, char *a2, char *a3)
{
  if ((*((_WORD *)this + 2) & 0x400) != 0)
    return dyld4::Loader::uuidToStr(this + 8, (unsigned __int8 *)a2, a3);
  *(_QWORD *)a2 = 0x64697575206F6ELL;
  return this;
}

void dyld4::Loader::logLoad(dyld4::Loader *this, dyld4::RuntimeState *a2, char *a3)
{
  char v5[64];

  if ((*((_WORD *)this + 2) & 0x400) != 0)
    dyld4::Loader::uuidToStr((unsigned __int8 *)this + 8, (unsigned __int8 *)v5, a3);
  else
    strcpy(v5, "no uuid");
  dyld4::RuntimeState::log(a2, "<%s> %s\n", v5, a3);
}

uint64_t ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke_2(uint64_t result, uint64_t a2, _BYTE *a3)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  *a3 = 1;
  return result;
}

char *dyld4::Loader::expandAndNormalizeAtExecutablePath(dyld4::Loader *this, const char *__s1, char *a3, char *a4)
{
  char *result;
  int v8;
  const char *v9;
  int v10;
  const char *v12;
  char *v13;
  char *v14;

  if (_platform_strncmp(__s1, "@executable_path", 0x10uLL))
    return 0;
  v10 = *((unsigned __int8 *)__s1 + 16);
  v9 = __s1 + 16;
  v8 = v10;
  if (v10 != 47 && v8 != 0)
    return 0;
  strlcpy(a3, (const char *)this, 0x400uLL);
  result = strrchr(a3, 47);
  if (result)
  {
    if (*v9 == 47)
    {
      do
      {
        v12 = v9;
        v13 = result;
        if (_platform_strncmp(v9, "/..", 3uLL))
          break;
        v14 = v13 - 1;
        do
        {
          result = v14;
          if (v14 <= a3)
            break;
          --v14;
        }
        while (*result != 47);
        v9 += 3;
      }
      while (result != a3);
    }
    else
    {
      v13 = result + 1;
      v12 = v9;
    }
    strlcpy(v13, v12, a3 - v13 + 1024);
    return (char *)1;
  }
  return result;
}

uint64_t ___ZN5dyld46Loader12validateFileER11DiagnosticsRKNS_12RuntimeStateEiPKcRKNS0_19CodeSignatureInFileERKNS0_18FileValidationInfoE_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(result + 40);
  v3 = *(_QWORD *)(v2 + 32);
  v4 = *(_QWORD *)(v2 + 40);
  v5 = *(unsigned int *)(v2 + 48);
  if (*(_QWORD *)a2 == v3 && *(_QWORD *)(a2 + 8) == v4 && *(_DWORD *)(a2 + 16) == v5)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  return result;
}

uint64_t dyld4::getUuidFromFd(dyld4::SyscallDelegate **this, dyld4::RuntimeState *a2, off_t a3, unsigned __int8 *a4, char *a5)
{
  int v7;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  _BYTE *v19;
  char *v20;
  uint64_t v21;
  _BYTE __buf[20];
  unsigned int v23;
  unsigned __int8 v24[8];
  uint64_t v25;

  v7 = (int)a2;
  *(_QWORD *)a4 = 0x64697575206F6ELL;
  result = dyld4::SyscallDelegate::pread(this[1], (int)a2, __buf, 0x1CuLL, a3);
  if (result == 28)
  {
    result = dyld3::MachOFile::hasMachOMagic((dyld3::MachOFile *)__buf);
    if ((_DWORD)result)
    {
      v17 = v23 + 32;
      __chkstk_darwin(result, v10, v11, v12, v13, v14, v15, v16, v21);
      v19 = &__buf[-((v18 + 47) & 0x1FFFFFFF0) - 4];
      result = dyld4::SyscallDelegate::pread(this[1], v7, v19, v17, a3);
      if (result == v17)
      {
        *(_QWORD *)v24 = 0;
        v25 = 0;
        result = dyld3::MachOFile::getUuid((dyld3::MachOFile *)v19, v24);
        if ((_DWORD)result)
          return (uint64_t)dyld4::Loader::uuidToStr(v24, a4, v20);
      }
    }
  }
  return result;
}

double __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__2(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

uint64_t ___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v9;
  const dyld4::RuntimeState *v10;
  const void *v11;
  const char *v12;
  uint64_t v13;
  lsl::Lock *v14;
  uint64_t v15;
  uint64_t v16;
  int v18;
  uint64_t v19;
  uint64_t v20;
  const void *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  lsl::Lock *v27;

  v9 = *(_QWORD *)(a1 + 40);
  v10 = *(const dyld4::RuntimeState **)(a1 + 48);
  v11 = (const void *)(v9 + a2);
  if (*(_BYTE *)(*((_QWORD *)v10 + 1) + 203))
  {
    v12 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 32), v10);
    dyld4::RuntimeState::log(v10, "running initializer %p in %s\n", v11, v12);
    v9 = *(_QWORD *)(a1 + 40);
  }
  v18 = 520552448;
  v19 = v9;
  v20 = 0;
  v21 = v11;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v18, a2, a3, a4, a5, a6, a7, a8);
  v13 = *(_QWORD *)(a1 + 48);
  if (*(_BYTE *)(v13 + 680))
  {
    v14 = *(lsl::Lock **)(v13 + 128);
    lsl::MemoryManager::lockGuard(v14, &v27);
    v15 = *((_QWORD *)v14 + 3) - 1;
    *((_QWORD *)v14 + 3) = v15;
    if (!v15)
      lsl::MemoryManager::writeProtect(v14, 1);
    lsl::Lock::unlock(v27);
    ((void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v11)(*(unsigned int *)(*(_QWORD *)(v13 + 8) + 104), *(_QWORD *)(*(_QWORD *)(v13 + 8) + 112), *(_QWORD *)(*(_QWORD *)(v13 + 8) + 120), *(_QWORD *)(*(_QWORD *)(v13 + 8) + 128), *(_QWORD *)(v13 + 144));
    lsl::MemoryManager::lockGuard(v14, &v27);
    v16 = *((_QWORD *)v14 + 3);
    if (!v16)
    {
      lsl::MemoryManager::writeProtect(v14, 0);
      v16 = *((_QWORD *)v14 + 3);
    }
    *((_QWORD *)v14 + 3) = v16 + 1;
    lsl::Lock::unlock(v27);
  }
  else
  {
    ((void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v11)(*(unsigned int *)(*(_QWORD *)(v13 + 8) + 104), *(_QWORD *)(*(_QWORD *)(v13 + 8) + 112), *(_QWORD *)(*(_QWORD *)(v13 + 8) + 120), *(_QWORD *)(*(_QWORD *)(v13 + 8) + 128), *(_QWORD *)(v13 + 144));
  }
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v18);
}

void ___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke_2(_QWORD *a1, unsigned int a2)
{
  dyld4::Loader *v3;
  const void *v4;
  const dyld4::RuntimeState *v5;
  const char *v6;

  v3 = (dyld4::Loader *)a1[4];
  v4 = (const void *)(a1[5] + a2);
  (*(void (**)(_QWORD, const void *, _QWORD))(**(_QWORD **)(a1[6] + 152) + 80))(*(_QWORD *)(a1[6] + 152), v4, 0);
  v5 = (const dyld4::RuntimeState *)a1[6];
  if (*(_BYTE *)(*((_QWORD *)v5 + 1) + 203))
  {
    v6 = (const char *)dyld4::Loader::path(v3, v5);
    dyld4::RuntimeState::log(v5, "registering old style destructor %p for %s\n", v4, v6);
  }
}

void dyld4::Loader::runInitializersBottomUp(dyld4::Loader *a1, dyld4::RuntimeState *a2, uint64_t *a3, uint64_t *a4)
{
  int isDelayInit;
  uint64_t v9;
  char v10;
  uint64_t v11;
  dyld4::Loader **v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  char v22;
  uint64_t v23;

  isDelayInit = dyld4::Loader::isDelayInit(a1, a2);
  v10 = isDelayInit;
  if (!isDelayInit)
  {
    if ((dyld4::Loader::beginInitializers(a1, a2) & 1) != 0)
      return;
    goto LABEL_8;
  }
  v11 = a4[2];
  if (!v11)
  {
LABEL_6:
    v23 = (uint64_t)a1;
    dyld3::Array<dyld4::Loader const*>::push_back(a4, &v23, v9);
LABEL_8:
    v14 = dyld4::Loader::dependentCount(a1);
    if (v14)
    {
      v15 = v14;
      v16 = 0;
      do
      {
        v22 = 0;
        v23 = 0;
        v17 = dyld4::Loader::dependent(a1, a2, v16, &v22);
        v23 = v17;
        if (v17)
        {
          if ((v22 & 4) != 0)
          {
            v19 = a3[2];
            if (v19)
            {
              v20 = (_QWORD *)*a3;
              v21 = 8 * v19;
              while (*v20 != v17)
              {
                ++v20;
                v21 -= 8;
                if (!v21)
                  goto LABEL_17;
              }
            }
            else
            {
LABEL_17:
              dyld3::Array<dyld4::Loader const*>::push_back(a3, &v23, v18);
            }
          }
          else
          {
            dyld4::Loader::runInitializersBottomUp();
          }
        }
        v16 = (v16 + 1);
      }
      while ((_DWORD)v16 != v15);
    }
    if ((v10 & 1) == 0)
    {
      dyld4::RuntimeState::notifyObjCInit(a2, a1);
      dyld4::Loader::runInitializers(a1, a2);
    }
    return;
  }
  v12 = (dyld4::Loader **)*a4;
  v13 = 8 * v11;
  while (*v12 != a1)
  {
    ++v12;
    v13 -= 8;
    if (!v13)
      goto LABEL_6;
  }
}

void dyld4::Loader::logSegmentsFromSharedCache(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  const char *v4;
  uint64_t v5;
  _DWORD *Address;
  _QWORD v7[6];

  v4 = (const char *)dyld4::Loader::path(this, a2);
  dyld4::RuntimeState::log(a2, "Using mapping in dyld cache for %s\n", v4);
  v5 = *(_QWORD *)(*((_QWORD *)a2 + 1) + 264);
  Address = (_DWORD *)dyld4::Loader::loadAddress(this, a2);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld46Loader26logSegmentsFromSharedCacheERNS_12RuntimeStateE_block_invoke;
  v7[3] = &__block_descriptor_tmp_119;
  v7[4] = a2;
  v7[5] = v5;
  dyld3::MachOFile::forEachSegment(Address, (uint64_t)v7);
}

void ___ZNK5dyld46Loader26logSegmentsFromSharedCacheERNS_12RuntimeStateE_block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_DWORD *)(a2 + 52);
  v3 = 120;
  if ((v2 & 4) == 0)
    v3 = 46;
  v4 = 119;
  if ((v2 & 2) == 0)
    v4 = 46;
  v5 = 114;
  if ((*(_DWORD *)(a2 + 52) & 1) == 0)
    v5 = 46;
  dyld4::RuntimeState::log(*(dyld4::RuntimeState **)(a1 + 32), "%14s (%c%c%c) 0x%012llX->0x%012llX \n", *(const char **)(a2 + 40), v5, v4, v3, *(_QWORD *)(a1 + 40) + *(_QWORD *)(a2 + 16), *(_QWORD *)(a1 + 40) + *(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 24));
}

void dyld4::Loader::addWeakDefsToMap(dyld4::RuntimeState *a1, uint64_t a2)
{
  uint64_t v2;
  dyld4::Loader **v4;
  uint64_t v5;
  dyld4::Loader *v6;
  uint64_t Address;
  dyld3::MachOFile *v8;
  uint64_t v9;
  _QWORD v10[7];
  vm_address_t *v11;

  v2 = *(_QWORD *)(a2 + 8);
  if (v2)
  {
    v4 = *(dyld4::Loader ***)a2;
    v5 = 8 * v2;
    do
    {
      v6 = *v4;
      Address = dyld4::Loader::loadAddress(*v4, a1);
      if ((*(_BYTE *)(Address + 25) & 0x80) != 0)
      {
        v8 = (dyld3::MachOFile *)Address;
        if ((dyld4::Loader::hiddenFromFlat(v6, 0) & 1) == 0)
        {
          Diagnostics::Diagnostics((Diagnostics *)&v11);
          v9 = dyld3::MachOFile::preferredLoadAddress(v8);
          v10[0] = _NSConcreteStackBlock;
          v10[1] = 0x40000000;
          v10[2] = ___ZN5dyld46Loader16addWeakDefsToMapERNS_12RuntimeStateERKNSt3__14spanIPKS0_Lm18446744073709551615EEE_block_invoke;
          v10[3] = &__block_descriptor_tmp_121;
          v10[4] = a1;
          v10[5] = v6;
          v10[6] = v9;
          dyld3::MachOLoaded::forEachGlobalSymbol(v8, (vm_address_t *)&v11, (uint64_t)v10);
          mach_o::Error::~Error(&v11);
        }
      }
      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
}

__n128 __Block_byref_object_copy__122(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 40);
  v3 = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

unint64_t ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke(unint64_t result)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  dyld4::Loader *v4;
  uint64_t v5;
  uint64_t v6;
  dyld4::Loader **v7;
  uint64_t v8;
  dyld4::Loader *v9;
  _QWORD v11[2];

  v1 = result;
  v2 = 0;
  v4 = *(dyld4::Loader **)(result + 48);
  v3 = *(_QWORD *)(result + 56);
  v11[0] = v3 + 32;
  v11[1] = v3 + 64;
  while (1)
  {
    v5 = v11[v2];
    v6 = *(_QWORD *)(v5 + 16);
    if (v6)
      break;
LABEL_11:
    if (++v2 == 2)
      return result;
  }
  v7 = *(dyld4::Loader ***)(v5 + 8);
  v8 = 8 * v6;
  while (1)
  {
    v9 = *v7;
    result = dyld4::Loader::hiddenFromFlat(*v7, 0);
    if (!(_DWORD)result || v9 == v4)
    {
      result = dyld4::Loader::hasExportedSymbol((uint64_t)v9, *(vm_address_t **)(v1 + 64), *(const dyld4::RuntimeState **)(v1 + 56), *(const unsigned __int8 **)(v1 + 72), 1u, 1, (uint64_t *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 40), 0);
      if ((result & 1) != 0)
        break;
    }
    ++v7;
    v8 -= 8;
    if (!v8)
      goto LABEL_11;
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v1 + 40) + 8) + 24) = 1;
  return result;
}

void dyld4::Loader::tooNewErrorAddendum(dyld4::Loader *this, Diagnostics *a2, dyld4::RuntimeState *a3)
{
  _DWORD *v6;
  _QWORD v7[7];
  _QWORD v8[6];
  _QWORD v9[3];
  int v10;
  _QWORD v11[3];
  int v12;

  v11[0] = 0;
  v11[1] = v11;
  v11[2] = 0x2000000000;
  v12 = 0;
  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x2000000000;
  v10 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke;
  v8[3] = &unk_1E4F7D068;
  v8[4] = v11;
  v8[5] = v9;
  dyld3::MachOFile::forEachSupportedPlatform(&dword_1A5C55000, (uint64_t)v8);
  v6 = (_DWORD *)dyld4::Loader::mf(this, a3);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke_2;
  v7[3] = &unk_1E4F7D090;
  v7[4] = v11;
  v7[5] = v9;
  v7[6] = a2;
  dyld3::MachOFile::forEachSupportedPlatform(v6, (uint64_t)v7);
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(v11, 8);
}

uint64_t ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke(uint64_t result, int a2, int a3)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = a3;
  return result;
}

uint64_t ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke_2(uint64_t result, int a2, dyld3::MachOFile *this)
{
  uint64_t v3;
  vm_address_t *v4;
  const char *v5;
  char v6[32];

  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) == a2)
  {
    v3 = result;
    if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) < this)
    {
      dyld3::MachOFile::packedVersionToString(this, v6, (char *)this);
      v4 = *(vm_address_t **)(v3 + 48);
      v5 = dyld3::MachOFile::platformName(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24));
      return Diagnostics::error(v4, " (built for %s %s which is newer than running OS)", v5, v6);
    }
  }
  return result;
}

uint64_t ___ZNK5dyld46Loader17hasExportedSymbolER11DiagnosticsRNS_12RuntimeStateEPKcNS0_18ExportedSymbolModeENS0_12ResolverModeEPNS0_14ResolvedSymbolEPN5dyld35ArrayIPKS0_EE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  dyld3::MachOFile ***v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[6];
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = *(_QWORD *)(a1 + 40);
  v4 = (dyld3::MachOFile ***)mach_o::SymbolTable::SymbolTable(&v12, a2);
  v5 = *(_QWORD *)(a1 + 48);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld46Loader17hasExportedSymbolER11DiagnosticsRNS_12RuntimeStateEPKcNS0_18ExportedSymbolModeENS0_12ResolverModeEPNS0_14ResolvedSymbolEPN5dyld35ArrayIPKS0_EE_block_invoke_2;
  v8[3] = &unk_1E4F7D0B8;
  v9 = *(_OWORD *)(a1 + 56);
  v6 = *(_QWORD *)(a1 + 80);
  v10 = *(_QWORD *)(a1 + 72);
  v11 = v6;
  v8[4] = *(_QWORD *)(a1 + 32);
  v8[5] = v3;
  return mach_o::SymbolTable::forEachGlobalSymbol(v4, v5, (uint64_t)v8);
}

void dyld4::Loader::applyInterposingToDyldCache(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  DyldSharedCache *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t IndexedImageEntry;
  dyld3::MachOFile *v9;
  int v10;
  int Address;
  _QWORD v12[7];
  int v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int v17;
  _BYTE v18[16];

  v2 = *(DyldSharedCache **)(*((_QWORD *)this + 1) + 240);
  if (v2 && *((_QWORD *)this + 22))
  {
    dyld4::DyldCacheDataConstScopedWriter::DyldCacheDataConstScopedWriter((dyld4::DyldCacheDataConstScopedWriter *)v18, this);
    dyld4::RuntimeState::setVMAccountingSuspending(this, 1);
    v4 = *((_QWORD *)this + 22);
    if (v4)
    {
      v5 = *((_QWORD *)this + 21);
      v6 = 16 * v4;
      do
      {
        v17 = 0;
        v7 = *(_QWORD *)(v5 + 8) - (_QWORD)v2;
        if (DyldSharedCache::addressInText(v2, v7, &v17))
        {
          v15 = 0;
          v16 = 0;
          IndexedImageEntry = DyldSharedCache::getIndexedImageEntry(v2, v17, &v16, &v15);
          if (IndexedImageEntry)
          {
            v9 = (dyld3::MachOFile *)IndexedImageEntry;
            v10 = DyldSharedCache::unslidLoadAddress(v2) + v7;
            Address = dyld3::MachOFile::preferredLoadAddress(v9);
            v12[0] = _NSConcreteStackBlock;
            v12[1] = 0x40000000;
            v12[2] = ___ZN5dyld46Loader27applyInterposingToDyldCacheERNS_12RuntimeStateE_block_invoke;
            v12[3] = &__block_descriptor_tmp_152;
            v12[4] = v5;
            v12[5] = v2;
            v13 = v10 - Address;
            v14 = v17;
            v12[6] = this;
            DyldSharedCache::forEachPatchableExport(v2, v17, (uint64_t)v12);
          }
        }
        v5 += 16;
        v6 -= 16;
      }
      while (v6);
    }
    dyld4::RuntimeState::setVMAccountingSuspending(this, 0);
    dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)v18);
  }
}

void ___ZN5dyld46Loader27applyInterposingToDyldCacheERNS_12RuntimeStateE_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  dyld4::RuntimeState *v7;

  v5 = (uint64_t *)(*(_QWORD *)(a1 + 32) + a2);
  v6 = *(_QWORD *)(a1 + 40) + a4;
  v7 = *(dyld4::RuntimeState **)(a1 + 48);
  if (*(_BYTE *)(*((_QWORD *)v7 + 1) + 206))
    dyld4::RuntimeState::log(v7, "interpose: *%p = 0x%0llX (dyld cache patch) to %s\n", v5, v6, *(const char **)(a1 + 56));
  *v5 = v6;
}

void dyld4::Loader::applyCachePatchesToOverride(uint64_t a1, const dyld4::RuntimeState *a2, dyld4::Loader *this, unsigned int a4, uint64_t a5, uint64_t a6)
{
  DyldSharedCache *v12;
  uint64_t Address;
  int v14;
  _QWORD v15[12];
  int v16;
  __int16 v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  char v25;

  v12 = *(DyldSharedCache **)(*((_QWORD *)a2 + 1) + 240);
  Address = dyld4::Loader::loadAddress(this, a2);
  v14 = *((_WORD *)this + 3) & 0x7FFF;
  if (DyldSharedCache::shouldPatchClientOfImage(v12, a4, v14))
  {
    if (DyldSharedCache::patchInfoVersion(v12) - 2 >= 3)
      dyld4::Loader::applyCachePatchesToOverride();
    v22 = 0;
    v23 = &v22;
    v24 = 0x2000000000;
    v25 = 0;
    v18 = 0;
    v19 = &v18;
    v20 = 0x2000000000;
    v21 = a5;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000;
    v15[2] = ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke;
    v15[3] = &unk_1E4F7D170;
    v15[6] = a1;
    v15[7] = a2;
    v17 = a4;
    v16 = v14;
    v15[8] = v12;
    v15[9] = a6;
    v15[4] = &v18;
    v15[5] = &v22;
    v15[10] = Address;
    v15[11] = this;
    DyldSharedCache::forEachPatchableExport(v12, a4, (uint64_t)v15);
    if (*(_QWORD *)v19[3] != -1)
      dyld4::Loader::applyCachePatchesToOverride();
    if (*((_BYTE *)v23 + 24))
      dyld4::RuntimeState::setVMAccountingSuspending(a2, 0);
    _Block_object_dispose(&v18, 8);
    _Block_object_dispose(&v22, 8);
  }
}

void ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke(uint64_t a1, int a2, uint64_t a3, int a4)
{
  dyld4::Loader *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[14];
  __int16 v18;

  v7 = *(dyld4::Loader **)(a1 + 48);
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v9 = *(uint64_t **)(v8 + 24);
  *(_QWORD *)(v8 + 24) = v9 + 1;
  if (a4 != 8)
  {
    if (a4 != 1)
    {
      if (*v9)
        goto LABEL_5;
      goto LABEL_9;
    }
    v10 = *v9;
    if (*v9 == 2)
      return;
LABEL_4:
    if (v10)
    {
LABEL_5:
      v11 = *v9 + dyld4::Loader::loadAddress(v7, *(const dyld4::RuntimeState **)(a1 + 56));
LABEL_10:
      v12 = *(unsigned __int16 *)(a1 + 100);
      v13 = *(_DWORD *)(a1 + 96);
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 0x40000000;
      v17[2] = ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2;
      v17[3] = &unk_1E4F7D148;
      v17[4] = *(_QWORD *)(a1 + 40);
      v17[5] = v7;
      v15 = *(_QWORD *)(a1 + 56);
      v14 = *(_QWORD *)(a1 + 64);
      v16 = *(_QWORD *)(a1 + 80);
      v17[6] = *(_QWORD *)(a1 + 72);
      v17[7] = v15;
      v17[8] = v16;
      v17[9] = v11;
      v18 = v12;
      v17[10] = v14;
      v17[11] = a3;
      v17[12] = *(_QWORD *)(a1 + 88);
      v17[13] = v9;
      DyldSharedCache::forEachPatchableUseOfExportInImage(v14, v12, a2, v13, (uint64_t)v17);
      return;
    }
LABEL_9:
    v11 = 195903495;
    goto LABEL_10;
  }
  v10 = *v9;
  if (*v9 != 1)
    goto LABEL_4;
}

void ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  dyld4::Loader *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  const char *IndexedImagePath;
  const dyld4::RuntimeState *v19;
  const char *v20;
  const char *v21;
  dyld4::RuntimeState *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  const char *v28;

  v9 = *(dyld4::Loader **)(a1 + 40);
  dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(_BYTE **)(a1 + 48));
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    dyld4::RuntimeState::setVMAccountingSuspending(*(dyld4::RuntimeState **)(a1 + 56), 1);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  v10 = *(_QWORD *)(a1 + 56);
  v11 = (uint64_t *)(*(_QWORD *)(a1 + 64) + a2);
  v12 = *(_QWORD *)(a1 + 72);
  if ((a5 & (v12 == 195903495)) != 0)
    v13 = 0;
  else
    v13 = v12 + a4;
  v14 = *(_QWORD *)(v10 + 176);
  if (v14)
  {
    v15 = *(_QWORD *)(v10 + 168);
    v16 = 16 * v14;
    v17 = (_QWORD *)(v15 + 8);
    do
    {
      if (*v17 == v13)
        v13 = *(v17 - 1);
      v17 += 2;
      v16 -= 16;
    }
    while (v16);
  }
  if ((a5 & 1) == 0 && v12 == 195903495)
  {
    IndexedImagePath = (const char *)DyldSharedCache::getIndexedImagePath(*(DyldSharedCache **)(a1 + 80), *(unsigned __int16 *)(a1 + 112));
    v19 = *(const dyld4::RuntimeState **)(a1 + 56);
    v20 = *(const char **)(a1 + 88);
    v21 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 96), v19);
    dyld4::RuntimeState::log(v19, "symbol '%s' missing from root that overrides %s. Use of that symbol in %s is being set to 0xBAD4007.\n", v20, IndexedImagePath, v21);
  }
  if (*v11 != v13)
  {
    *v11 = v13;
    v22 = *(dyld4::RuntimeState **)(a1 + 56);
    if (*(_BYTE *)(*((_QWORD *)v22 + 1) + 202))
    {
      v23 = a2;
      v24 = (char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 96), *(const dyld4::RuntimeState **)(a1 + 56));
      v25 = strrchr(v24, 47);
      if (v25)
        v24 = v25 + 1;
      v26 = (char *)dyld4::Loader::path(v9, *(const dyld4::RuntimeState **)(a1 + 56));
      v27 = strrchr(v26, 47);
      if (v27)
        v28 = v27 + 1;
      else
        v28 = v26;
      dyld4::RuntimeState::log(v22, "cache fixup: *0x%012lX = 0x%012lX (*%s+0x%012lX = %s+0x%012lX)\n", v11, v13, v24, v23, v28, **(_QWORD **)(a1 + 104));
    }
  }
}

void dyld4::Loader::applyCachePatchesTo(dyld4::Loader *this, dyld4::RuntimeState *a2, const dyld4::Loader *a3, dyld4::DyldCacheDataConstLazyScopedWriter *a4)
{
  uint64_t CatalystMacTwinPatches;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  dyld4::RuntimeState *v13;

  LOWORD(v13) = 0;
  v12 = 0;
  if (dyld4::Loader::overridesDylibInCache((uint64_t)this, &v12, &v13))
  {
    if (v12)
      dyld4::Loader::applyCachePatchesToOverride((uint64_t)this, a2, a3, (unsigned __int16)v13, v12, (uint64_t)a4);
    if ((*((_WORD *)this + 2) & 1) == 0)
    {
      if (*(_BYTE *)(*((_QWORD *)a2 + 1) + 157))
      {
        CatalystMacTwinPatches = dyld4::JustInTimeLoader::getCatalystMacTwinPatches(this);
        if (CatalystMacTwinPatches)
        {
          v10 = CatalystMacTwinPatches;
          v11 = dyld4::Loader::indexOfUnzipperedTwin(a2, (const dyld4::RuntimeState *)(unsigned __int16)v13, v9);
          if (v11 != 0xFFFF)
            dyld4::Loader::applyCachePatchesToOverride((uint64_t)this, a2, a3, v11, v10, (uint64_t)a4);
        }
      }
    }
  }
}

uint64_t dyld4::Loader::indexOfUnzipperedTwin(dyld4::Loader *this, const dyld4::RuntimeState *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  _WORD *v6;
  const char *IndexedImagePath;
  unsigned int v10;

  v3 = *((_QWORD *)this + 1);
  if (!*(_BYTE *)(v3 + 157))
    return (unsigned __int16)-1;
  v5 = *((_QWORD *)this + 124);
  if (!v5)
  {
    IndexedImagePath = (const char *)dyld4::ProcessConfig::DyldCache::getIndexedImagePath((DyldSharedCache **)(v3 + 240), (int)a2);
    if (!_platform_strncmp(IndexedImagePath, "/System/iOSSupport/", 0x13uLL))
    {
      v10 = 0;
      if ((dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(*((_QWORD *)this + 1) + 240), IndexedImagePath + 18, &v10) & 1) != 0)return (unsigned __int16)v10;
    }
    return (unsigned __int16)-1;
  }
  if (*(_DWORD *)(v5 + 12) <= a2)
    dyld4::RuntimeState::findPrebuiltLoader((uint64_t)this, (uint64_t)a2, a3);
  v6 = (_WORD *)(v5 + *(unsigned int *)(v5 + *(unsigned int *)(v5 + 16) + 4 * a2));
  if ((v6[2] & 1) == 0 || (v6[22] & 4) == 0)
    return (unsigned __int16)-1;
  return (unsigned __int16)v6[30];
}

uint64_t ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke(uint64_t result, unsigned int a2, uint64_t a3, int a4)
{
  uint64_t v5;
  dyld4::Loader *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[11];

  v5 = result;
  v6 = *(dyld4::Loader **)(result + 48);
  v7 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
  v8 = *(uint64_t **)(v7 + 24);
  *(_QWORD *)(v7 + 24) = v8 + 1;
  if (a4 != 8)
  {
    if (a4 != 1)
    {
      if (*v8)
        goto LABEL_5;
      goto LABEL_9;
    }
    v9 = *v8;
    if (*v8 == 2)
      return result;
LABEL_4:
    if (v9)
    {
LABEL_5:
      v10 = *v8 + dyld4::Loader::loadAddress(v6, *(const dyld4::RuntimeState **)(result + 56));
LABEL_10:
      v11 = *(unsigned __int16 *)(v5 + 80);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 0x40000000;
      v15[2] = ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2;
      v15[3] = &unk_1E4F7D198;
      v12 = *(_QWORD *)(v5 + 64);
      v13 = *(_QWORD *)(v5 + 72);
      v15[4] = *(_QWORD *)(v5 + 40);
      v15[5] = v6;
      v14 = *(_QWORD *)(v5 + 56);
      v15[6] = v13;
      v15[7] = v14;
      v15[8] = v12;
      v15[9] = v10;
      v15[10] = v8;
      return DyldSharedCache::forEachPatchableGOTUseOfExport(v12, v11, a2, (uint64_t)v15);
    }
LABEL_9:
    v10 = 195903495;
    goto LABEL_10;
  }
  v9 = *v8;
  if (*v8 != 1)
    goto LABEL_4;
  return result;
}

void ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  dyld4::Loader *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  dyld4::RuntimeState *v13;
  char *v14;
  char *v15;
  const char *v16;

  v9 = *(dyld4::Loader **)(a1 + 40);
  dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(_BYTE **)(a1 + 48));
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    dyld4::RuntimeState::setVMAccountingSuspending(*(dyld4::RuntimeState **)(a1 + 56), 1);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  v10 = *(_QWORD *)(a1 + 72);
  v11 = (uint64_t *)(*(_QWORD *)(a1 + 64) + a2);
  if ((a5 & (v10 == 195903495)) != 0)
    v12 = 0;
  else
    v12 = v10 + a4;
  if (*v11 != v12)
  {
    *v11 = v12;
    v13 = *(dyld4::RuntimeState **)(a1 + 56);
    if (*(_BYTE *)(*((_QWORD *)v13 + 1) + 202))
    {
      v14 = (char *)dyld4::Loader::path(v9, *(const dyld4::RuntimeState **)(a1 + 56));
      v15 = strrchr(v14, 47);
      if (v15)
        v16 = v15 + 1;
      else
        v16 = v14;
      dyld4::RuntimeState::log(v13, "cache GOT fixup: *0x%012lX = 0x%012lX (*cache+0x%012lX = %s+0x%012lX)\n", v11, v12, a2, v16, **(_QWORD **)(a1 + 80));
    }
  }
}

uint64_t __Block_byref_object_copy__164(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__165(uint64_t a1)
{
  mach_o::Error::~Error((vm_address_t **)(a1 + 40));
}

uint64_t ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke_2(uint64_t a1, int a2, int a3, char *__s2, uint64_t a5, _BYTE *a6)
{
  uint64_t result;

  result = _platform_memcmp(*(const void **)(a1 + 40), __s2, 0x40uLL);
  if (!(_DWORD)result)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = &__s2[-*(_QWORD *)(a1 + 48)];
    *a6 = 1;
  }
  return result;
}

void dyld4::Loader::recursivelyLogChainToLinksWith(dyld4::Loader *a1, dyld4::RuntimeState *a2, const char *a3, dyld4::Loader *a4, uint64_t *a5, _QWORD *a6, uint64_t *a7)
{
  uint64_t v14;
  dyld4::Loader **v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21[2];
  char v22;
  char v23;

  if (a1 == a4)
  {
    dyld4::RuntimeState::printLinkageChain(a2, a5, a3);
  }
  else
  {
    v14 = a7[2];
    if (v14)
    {
      v15 = (dyld4::Loader **)*a7;
      v16 = 8 * v14;
      while (*v15 != a1)
      {
        ++v15;
        v16 -= 8;
        if (!v16)
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      v21[0] = (uint64_t)a1;
      dyld3::Array<dyld4::Loader const*>::push_back(a7, v21, (uint64_t)a3);
      v17 = dyld4::Loader::dependentCount(a1);
      if (v17)
      {
        v18 = v17;
        v19 = 0;
        do
        {
          v23 = 0;
          v20 = dyld4::Loader::dependent(a1, a2, v19, &v23);
          if (v20)
          {
            v21[0] = 0;
            v21[1] = v20;
            v22 = v23;
            *a6 = v21;
            dyld4::Loader::recursivelyLogChainToLinksWith(v20, a2, a3, a4, a5, v21, a7);
          }
          v19 = (v19 + 1);
        }
        while (v18 != (_DWORD)v19);
      }
    }
  }
}

void dyld4::Loader::logChainToLinksWith(dyld4::Loader *this, dyld4::RuntimeState *a2, const char *a3)
{
  uint64_t v6;
  dyld4::Loader **v7;
  uint64_t v8;
  dyld4::Loader *v9;
  uint64_t v10;
  size_t v11;
  const void *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  dyld4::Loader **v24;
  uint64_t v25;
  uint64_t v26;
  size_t v27;
  const void *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34[2];
  char v35;
  uint64_t v36[3];

  v6 = *((_QWORD *)a2 + 6);
  if (v6)
  {
    v7 = (dyld4::Loader **)*((_QWORD *)a2 + 5);
    v8 = 8 * v6;
    while (1)
    {
      v9 = *v7;
      v10 = *((_QWORD *)a2 + 1);
      v12 = *(const void **)(v10 + 224);
      v11 = *(_QWORD *)(v10 + 232);
      v13 = (char *)dyld4::Loader::path(*v7, a2);
      v14 = strrchr(v13, 47);
      if (v14)
        v13 = v14 + 1;
      if (v11 == _platform_strlen(v13))
      {
        v15 = _platform_memcmp(v12, v13, v11);
        if (!(_DWORD)v15)
          break;
      }
      ++v7;
      v8 -= 8;
      if (!v8)
        goto LABEL_8;
    }
    if (v9)
      goto LABEL_19;
  }
LABEL_8:
  v23 = *((_QWORD *)a2 + 10);
  if (v23)
  {
    v24 = (dyld4::Loader **)*((_QWORD *)a2 + 9);
    v25 = 8 * v23;
    while (1)
    {
      v9 = *v24;
      v26 = *((_QWORD *)a2 + 1);
      v28 = *(const void **)(v26 + 224);
      v27 = *(_QWORD *)(v26 + 232);
      v29 = (char *)dyld4::Loader::path(*v24, a2);
      v30 = strrchr(v29, 47);
      if (v30)
        v29 = v30 + 1;
      if (v27 == _platform_strlen(v29))
      {
        v15 = _platform_memcmp(v28, v29, v27);
        if (!(_DWORD)v15)
          break;
      }
      ++v24;
      v25 -= 8;
      if (!v25)
        return;
    }
    if (v9)
    {
LABEL_19:
      __chkstk_darwin(v15, v16, v17, v18, v19, v20, v21, v22, v33);
      v31 = *((_QWORD *)a2 + 10) + *((_QWORD *)a2 + 6);
      v36[0] = (uint64_t)&v34[-1] - v32;
      v36[1] = v31;
      v36[2] = 0;
      v34[0] = 0;
      v34[1] = (uint64_t)this;
      v35 = mach_o::LinkedDylibAttributes::regular;
      dyld4::Loader::recursivelyLogChainToLinksWith(this, a2, a3, v9, v34, v34, v36);
    }
  }
}

_DWORD *dyld4::fixupChain32(_DWORD *this, unsigned int *a2, const mwl_info_hdr *a3, const dyld_chained_starts_in_segment *a4, const unsigned int *a5)
{
  unint64_t v5;
  int v6;
  uint32_t mwli_chains_offset;
  int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;

  while (1)
  {
    v5 = *this;
    if ((v5 & 0x80000000) != 0)
      break;
    v6 = v5 & 0x3FFFFFF;
    mwli_chains_offset = a3->mwli_chains_offset;
    if ((v5 & 0x3FFFFFF) <= mwli_chains_offset)
    {
      v10 = a2[6];
      goto LABEL_7;
    }
    v8 = v6 - ((mwli_chains_offset + 0x4000000) >> 1);
LABEL_8:
    v11 = (v5 >> 26) & 0x1F;
    *this = v8;
    this += v11;
    if (!(_DWORD)v11)
      return this;
  }
  v9 = a2[3];
  if ((v5 & 0xFFFFF) < v9)
  {
    v10 = (v5 >> 20) & 0x3F;
    v6 = *(&a4->size + (v5 & 0xFFFFF));
LABEL_7:
    v8 = v6 + v10;
    goto LABEL_8;
  }
  return (_DWORD *)fprintf(__stderrp, "out of range bind ordinal %u (max %u)", v5 & 0xFFFFF, v9);
}

void dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(dyld4::RuntimeState &)const::$_0::operator()(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  dyld4::Loader *v21;
  dyld4::RuntimeState *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  dyld4::Loader **v33;
  uint64_t v34;
  dyld4::Loader *v35;
  dyld4::Loader **v36;
  uint64_t v37;
  dyld4::Loader *v38;
  uint64_t v39[2];
  uint64_t v40;
  uint64_t v41[3];
  uint64_t v42[2];
  uint64_t v43;

  __chkstk_darwin(a1[1], *a1, a3, a4, a5, a6, a7, a8, v39[0]);
  v42[0] = (uint64_t)v39 - v10;
  v42[1] = v9;
  v43 = 0;
  __chkstk_darwin(v11, v12, v13, v14, v15, v16, v17, v18, v39[0]);
  v41[0] = (uint64_t)v39 - ((v19 + 23) & 0xFFFFFFFFFFFFFFF0);
  v41[1] = v20;
  v41[2] = 0;
  dyld4::Loader::runInitializersBottomUp(v21, v22, v42, v41);
  __chkstk_darwin(v23, v24, v25, v26, v27, v28, v29, v30, v39[0]);
  v39[0] = (uint64_t)v39 - v32;
  v39[1] = v31;
  v40 = 0;
  if (v43)
  {
    v33 = (dyld4::Loader **)v42[0];
    v34 = 8 * v43;
    do
    {
      v35 = *v33++;
      dyld4::Loader::runInitializersBottomUp(v35, (dyld4::RuntimeState *)*a1, v39, v41);
      v34 -= 8;
    }
    while (v34);
    if (v40)
    {
      v43 = 0;
      v36 = (dyld4::Loader **)v39[0];
      v37 = 8 * v40;
      do
      {
        v38 = *v36++;
        dyld4::Loader::runInitializersBottomUp(v38, (dyld4::RuntimeState *)*a1, v42, v41);
        v37 -= 8;
      }
      while (v37);
    }
  }
}

const char **dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t a4, const char **a5)
{
  char *v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  unint64_t v21;
  const char **v22;
  unint64_t v23;
  char v25;

  if (!a3[2])
    return (const char **)*a3;
  v8 = (char *)*a5;
  v9 = _platform_strlen(*a5);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v25, (uint64_t *)v8, v9);
  v13 = a2[2];
  v14 = v13 - 1;
  v15 = v10 & (v13 - 1);
  if (v13 <= v15)
LABEL_8:
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v10, v11, v12);
  v16 = *a2;
  v17 = a3[2];
  v18 = *a3;
  v19 = 1;
  v20 = *a5;
  while (1)
  {
    v21 = *(unsigned int *)(v16 + 4 * v15);
    if ((_DWORD)v21 == -1)
      return (const char **)(v18 + 24 * v17);
    if (v17 <= v21)
      dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>();
    v22 = (const char **)(v18 + 24 * v21);
    v10 = _platform_strcmp(*v22, v20);
    if (!(_DWORD)v10)
      return v22;
    v23 = v15 + v19++;
    v15 = v23 & v14;
    if (v13 <= (v23 & v14))
      goto LABEL_8;
  }
}

uint64_t dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::insert(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  char *v8;
  size_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  vm_address_t v13;
  vm_size_t v14;
  char *v15;
  size_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  const char **v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  _OWORD v28[2];
  vm_size_t size;
  char v30;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 == *(_QWORD *)a1)
  {
    v5 = 2 * *(_QWORD *)(a1 + 32);
    *(_QWORD *)a1 = 2 * v4;
    size = 0;
    memset(v28, 0, sizeof(v28));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v28, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v28, 1);
      v6 = (*(_QWORD *)&v28[1])++;
      *(_DWORD *)(*(_QWORD *)&v28[0] + 4 * v6) = -1;
    }
    if (*(_QWORD *)(a1 + 72))
    {
      v7 = 0;
      do
      {
        v8 = *(char **)dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v7);
        v9 = _platform_strlen(v8);
        v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v30, (uint64_t *)v8, v9);
        v11 = (*(_QWORD *)&v28[1] - 1) & v10;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v28, v11) != -1)
        {
          v12 = 1;
          do
            v11 = (*(_QWORD *)&v28[1] - 1) & (v11 + v12++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v28, v11) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v28, v11) = v7++;
      }
      while (v7 != *(_QWORD *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v28)
    {
      *(_QWORD *)&v28[1] = 0;
      if (*((_QWORD *)&v28[1] + 1))
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v28[1] + 1), size);
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 40);
      if (v13)
        vm_deallocate(mach_task_self_, v13, *(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)&v28[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v28 + 8);
      v14 = size;
      *(_QWORD *)(a1 + 40) = *((_QWORD *)&v28[1] + 1);
      *(_QWORD *)(a1 + 48) = v14;
    }
  }
  v15 = *(char **)a2;
  v16 = _platform_strlen(*(const char **)a2);
  v17 = (*(_QWORD *)(a1 + 32) - 1) & std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)v28, (uint64_t *)v15, v16);
  v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17);
  if ((_DWORD)v18 == -1)
  {
LABEL_20:
    v21 = *(_QWORD *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17) = v21;
    ++*(_QWORD *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v22 = *(_QWORD *)(a1 + 56);
    v23 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v23 + 1;
    v24 = v22 + 24 * v23;
    v25 = *a2;
    *(_QWORD *)(v24 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v24 = v25;
    v26 = *(_QWORD *)(a1 + 72);
    if (!v26)
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    return *(_QWORD *)(a1 + 56) + 24 * v26 - 24;
  }
  else
  {
    v19 = 1;
    while (1)
    {
      v20 = (const char **)dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v18);
      if (!_platform_strcmp(*v20, *(const char **)a2))
        return dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v18);
      v17 = (*(_QWORD *)(a1 + 32) - 1) & (v17 + v19++);
      v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17);
      if ((_DWORD)v18 == -1)
        goto LABEL_20;
    }
  }
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[](_QWORD *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = a1[2];
  v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5)
      dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::reserve(a1, a2 + 1);
    a1[2] = v5;
  }
  return *a1 + 24 * a2;
}

uint64_t dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](_QWORD *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = a1[2];
  v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5)
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(a1, a2 + 1);
    a1[2] = v5;
  }
  return *a1 + 4 * a2;
}

_QWORD *dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  const void **v4;
  vm_address_t v5;
  vm_size_t v6;
  unint64_t v7;
  vm_size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;

  v2 = result[1];
  v3 = result[2] + a2;
  if (v3 > v2)
  {
    v4 = (const void **)result;
    v5 = result[3];
    v6 = result[4];
    v7 = 2 * v2;
    if (v7 > v3)
      v3 = v7;
    v8 = (vm_page_size + 24 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    result = memmove((void *)v4[3], *v4, 24 * (_QWORD)v4[2]);
    v12 = (unint64_t)v4[4] / 0x18;
    *v4 = v4[3];
    v4[1] = (const void *)v12;
    if (v5)
      return (_QWORD *)vm_deallocate(mach_task_self_, v5, v6);
  }
  return result;
}

mach_o::Error *mach_o::Error::Error(mach_o::Error *this, char *__s, ...)
{
  vm_address_t v4;
  va_list va;

  va_start(va, __s);
  *(_QWORD *)this = 0;
  v4 = _simple_salloc();
  *(_QWORD *)this = v4;
  _simple_vsprintf(v4, __s, (int *)va);
  return this;
}

uint64_t dyld4::JustInTimeLoader::mf(dyld4::JustInTimeLoader *this, const dyld4::RuntimeState *a2)
{
  return *((_QWORD *)this + 4);
}

uint64_t dyld4::JustInTimeLoader::path(dyld4::JustInTimeLoader *this, const dyld4::RuntimeState *a2)
{
  if (*((_WORD *)this + 20))
    return (uint64_t)this + *((unsigned __int16 *)this + 20);
  else
    return 0;
}

BOOL dyld4::JustInTimeLoader::matchesPath(dyld4::JustInTimeLoader *this, const dyld4::RuntimeState *a2, char *__s1)
{
  uint64_t v5;
  const char *v6;
  char *v7;
  dyld4::PseudoDylib *v8;
  char *v9;

  v5 = *((_QWORD *)this + 5);
  if ((_WORD)v5)
    v6 = (char *)this + (unsigned __int16)*((_QWORD *)this + 5);
  else
    v6 = 0;
  if (!_platform_strcmp(__s1, v6))
    return 1;
  if ((v5 & 0x100000) != 0)
  {
    v7 = dyld3::MachOFile::installName(*((dyld3::MachOFile **)this + 4));
    if (!_platform_strcmp(__s1, v7))
      return 1;
  }
  v8 = (dyld4::PseudoDylib *)*((_QWORD *)this + 13);
  if (!v8)
    return 0;
  v9 = (char *)dyld4::PseudoDylib::loadableAtPath(v8, __s1);
  if (v9 == __s1 || v9 == 0)
    return v9 != 0;
  dyld4::PseudoDylib::disposeString(*((uint64_t (****)(char *))this + 13), v9);
  return 1;
}

_QWORD *dyld4::JustInTimeLoader::makePatchTable(dyld4::JustInTimeLoader *this, dyld4::RuntimeState *a2, unsigned int a3)
{
  uint64_t v3;
  _QWORD *v7;
  int v8;
  _QWORD *v9;
  uint64_t IndexedImageEntry;
  char *IndexedImagePath;
  char *v12;
  dyld3::MachOFile *v13;
  uint64_t *v14;
  vm_address_t *v16;
  uint64_t *v17;
  unsigned int v18;
  unint64_t v19;
  mach_o::ChainedFixupPointerOnDisk *v20;
  mach_o::ChainedFixupPointerOnDisk **v21;
  mach_o::ChainedFixupPointerOnDisk *v22;
  mach_o::ChainedFixupPointerOnDisk **v23;
  mach_o::ChainedFixupPointerOnDisk **v24;
  mach_o::ChainedFixupPointerOnDisk *v25;
  mach_o::ChainedFixupPointerOnDisk **v26;
  unint64_t v27;
  unint64_t v28;
  mach_o::ChainedFixupPointerOnDisk *v29;
  mach_o::ChainedFixupPointerOnDisk *v30;
  uint64_t v31;
  unsigned __int16 v32[4];
  int v33;
  uint64_t v34;
  _QWORD v35[12];
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  double (*v39)(uint64_t, uint64_t);
  uint64_t (*v40)(uint64_t);
  _QWORD v41[5];
  vm_address_t v42;
  vm_size_t v43;
  uint64_t v44;
  vm_address_t v45;
  vm_size_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  int v50;
  mach_o::ChainedFixupPointerOnDisk *v51;
  char v52;
  uint64_t v53;
  unsigned int v54;
  unint64_t v55;
  unint64_t v56;
  vm_address_t *v57[5];
  vm_address_t *v58[2];
  void **v59;
  uint64_t v60;
  uint64_t v61;
  double (*v62)(uint64_t, uint64_t);
  dyld3::MachOFile *v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  vm_address_t v67;
  vm_size_t v68;
  vm_address_t *v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  double (*v73)(uint64_t, uint64_t);
  uint64_t (*v74)(uint64_t);
  _QWORD v75[5];
  vm_address_t v76;
  vm_size_t v77;
  uint64_t v78;
  vm_address_t address;
  vm_size_t size;

  v3 = *((_QWORD *)a2 + 1);
  if (!*(_QWORD *)(v3 + 368))
    dyld4::JustInTimeLoader::makePatchTable();
  v7 = (_QWORD *)(v3 + 368);
  v8 = PatchTable::patchableExportCount((int **)(v3 + 368), a3);
  if (!v8)
    return 0;
  v9 = lsl::Allocator::malloc(*((lsl::Allocator **)a2 + 2), 8 * (v8 + 1));
  v47 = 0;
  v48 = &v47;
  v49 = 0x2000000000;
  v50 = 0;
  v34 = *((_QWORD *)this + 4);
  IndexedImageEntry = DyldSharedCache::getIndexedImageEntry(*(DyldSharedCache **)(*((_QWORD *)a2 + 1) + 240), a3);
  v36 = 0;
  v37 = &v36;
  v38 = 0x8802000000;
  v39 = __Block_byref_object_copy__3;
  v40 = __Block_byref_object_dispose__3;
  dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map((uint64_t)v41);
  IndexedImagePath = (char *)DyldSharedCache::getIndexedImagePath(*(DyldSharedCache **)(*((_QWORD *)a2 + 1) + 240), a3);
  if (IndexedImagePath)
  {
    v12 = IndexedImagePath;
    if (!strstr(IndexedImagePath, "libdispatch.dylib") && !strstr(v12, "libxpc.dylib"))
    {
      if (_platform_strcmp(v12, "/usr/lib/libodmodule.dylib"))
      {
        if (_platform_strcmp(v12, "/usr/lib/log/liblog_odtypes.dylib"))
        {
          v16 = (vm_address_t *)*((_QWORD *)this + 4);
          v17 = v37;
          if (dyld3::MachOFile::hasChainedFixups((dyld3::MachOFile *)v16))
          {
            *(_QWORD *)v32 = v17;
            Diagnostics::Diagnostics((Diagnostics *)&v69);
            v59 = 0;
            v60 = (uint64_t)&v59;
            v61 = 0x5002000000;
            v62 = __Block_byref_object_copy__22;
            v63 = (dyld3::MachOFile *)__Block_byref_object_dispose__23;
            v64 = &v70;
            v65 = 32;
            v67 = 0;
            v68 = 0;
            v66 = 0;
            v57[0] = (vm_address_t *)_NSConcreteStackBlock;
            v57[1] = (vm_address_t *)1174405120;
            v57[2] = (vm_address_t *)___ZN5dyld4L19getObjCPatchClassesEPKN5dyld313MachOAnalyzerERNS0_3MapIPKvbNS_11HashPointerENS_12EqualPointerEEE_block_invoke;
            v57[3] = (vm_address_t *)&unk_1E4F7A730;
            v58[0] = v69;
            v58[1] = v16;
            v57[4] = (vm_address_t *)&v59;
            dyld3::MachOAnalyzer::forEachBindTarget((dyld3::MachOFile *)v16, (vm_address_t *)&v69, 0, (uint64_t)v57, (uint64_t)&__block_literal_global_0);
            if (!Diagnostics::hasError((Diagnostics *)&v69))
            {
              v55 = 0;
              v56 = 0;
              if (dyld3::MachOFile::findObjCDataSection((dyld3::MachOFile *)v16, "__objc_classlist", &v56, &v55))
              {
                v18 = dyld3::MachOFile::pointerSize((dyld3::MachOFile *)v16);
                v19 = v55 / v18;
                if (v55 % v18)
                {
                  Diagnostics::error((vm_address_t *)&v69, "Invalid objc class section size");
                }
                else
                {
                  v27 = v55;
                  v28 = v18;
                  v31 = *(_QWORD *)v32 + 40;
                  v33 = dyld3::MachOAnalyzer::chainedPointerFormat((dyld3::MachOAnalyzer *)v16);
                  v20 = (mach_o::ChainedFixupPointerOnDisk *)((char *)v16 + v56);
                  if ((_DWORD)v28 == 8)
                  {
                    if (v27 >= v28)
                    {
                      do
                      {
                        v54 = 0;
                        v53 = 0;
                        if (mach_o::ChainedFixupPointerOnDisk::isBind(v20, v33, &v54, (unint64_t *)&v53))
                        {
                          if (*(_QWORD *)(v60 + 56) > (unint64_t)v54)
                          {
                            v21 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(v60 + 40), v54);
                            v22 = *v21;
                            if (*v21)
                            {
                              v51 = *v21;
                              v52 = 1;
                              v29 = v22;
                              dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v31, &v51);
                              v54 = 0;
                              v53 = 0;
                              if (mach_o::ChainedFixupPointerOnDisk::isBind(v29, v33, &v54, (unint64_t *)&v53))
                              {
                                if (*(_QWORD *)(v60 + 56) > (unint64_t)v54)
                                {
                                  v23 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(v60 + 40), v54);
                                  if (*v23)
                                  {
                                    v51 = *v23;
                                    v52 = 1;
                                    dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v31, &v51);
                                  }
                                }
                              }
                            }
                          }
                        }
                        v20 = (mach_o::ChainedFixupPointerOnDisk *)((char *)v20 + 8);
                        --v19;
                      }
                      while (v19);
                    }
                  }
                  else if (v27 >= v28)
                  {
                    do
                    {
                      v54 = 0;
                      v53 = 0;
                      if (mach_o::ChainedFixupPointerOnDisk::isBind(v20, v33, &v54, (unint64_t *)&v53))
                      {
                        if (*(_QWORD *)(v60 + 56) > (unint64_t)v54)
                        {
                          v24 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(v60 + 40), v54);
                          v25 = *v24;
                          if (*v24)
                          {
                            v51 = *v24;
                            v52 = 1;
                            v30 = v25;
                            dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v31, &v51);
                            v54 = 0;
                            v53 = 0;
                            if (mach_o::ChainedFixupPointerOnDisk::isBind(v30, v33, &v54, (unint64_t *)&v53))
                            {
                              if (*(_QWORD *)(v60 + 56) > (unint64_t)v54)
                              {
                                v26 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(v60 + 40), v54);
                                if (*v26)
                                {
                                  v51 = *v26;
                                  v52 = 1;
                                  dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v31, &v51);
                                }
                              }
                            }
                          }
                        }
                      }
                      v20 = (mach_o::ChainedFixupPointerOnDisk *)((char *)v20 + 4);
                      --v19;
                    }
                    while (v19);
                  }
                }
              }
            }
            mach_o::Error::~Error(v58);
            _Block_object_dispose(&v59, 8);
            v66 = 0;
            if (v67)
              vm_deallocate(mach_task_self_, v67, v68);
            mach_o::Error::~Error(&v69);
          }
        }
      }
    }
  }
  v70 = 0;
  v71 = &v70;
  v72 = 0x8802000000;
  v73 = __Block_byref_object_copy__3;
  v74 = __Block_byref_object_dispose__3;
  dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map((uint64_t)v75);
  v13 = (dyld3::MachOFile *)*((_QWORD *)this + 4);
  v14 = v71 + 5;
  Diagnostics::Diagnostics((Diagnostics *)v57);
  v59 = _NSConcreteStackBlock;
  v60 = 0x40000000;
  v61 = (uint64_t)___ZN5dyld4L19getSingletonPatchesEPKN5dyld313MachOAnalyzerERNS0_3MapIPKvbNS_11HashPointerENS_12EqualPointerEEE_block_invoke;
  v62 = (double (*)(uint64_t, uint64_t))&__block_descriptor_tmp_102_0;
  v63 = v13;
  v64 = v14;
  dyld3::MachOFile::forEachSingletonPatch(v13, (uint64_t)v57, (uint64_t)&v59);
  mach_o::Error::~Error(v57);
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 0x40000000;
  v35[2] = ___ZNK5dyld416JustInTimeLoader14makePatchTableERNS_12RuntimeStateEj_block_invoke;
  v35[3] = &unk_1E4F7D260;
  v35[8] = a2;
  v35[9] = IndexedImageEntry;
  v35[4] = &v70;
  v35[5] = &v36;
  v35[6] = &v47;
  v35[7] = this;
  v35[10] = v9;
  v35[11] = v34;
  PatchTable::forEachPatchableExport(v7, a3, (uint64_t)v35);
  v9[*((unsigned int *)v48 + 6)] = -1;
  _Block_object_dispose(&v70, 8);
  v78 = 0;
  if (address)
    vm_deallocate(mach_task_self_, address, size);
  v75[4] = 0;
  if (v76)
    vm_deallocate(mach_task_self_, v76, v77);
  _Block_object_dispose(&v36, 8);
  v44 = 0;
  if (v45)
    vm_deallocate(mach_task_self_, v45, v46);
  v41[4] = 0;
  if (v42)
    vm_deallocate(mach_task_self_, v42, v43);
  _Block_object_dispose(&v47, 8);
  return v9;
}

double __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;
  uint64_t v4;

  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 88) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  v3 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = v3;
  *(_QWORD *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_QWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  v4 = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 128) = v4;
  *(_QWORD *)(a2 + 128) = 0;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  return result;
}

uint64_t __Block_byref_object_dispose__3(uint64_t result)
{
  _QWORD *v1;
  vm_address_t v2;
  vm_address_t v3;

  v1 = (_QWORD *)result;
  *(_QWORD *)(result + 112) = 0;
  v2 = *(_QWORD *)(result + 120);
  if (v2)
    result = vm_deallocate(mach_task_self_, v2, *(_QWORD *)(result + 128));
  v1[9] = 0;
  v3 = v1[10];
  if (v3)
    return vm_deallocate(mach_task_self_, v3, v1[11]);
  return result;
}

void ___ZNK5dyld416JustInTimeLoader14makePatchTableERNS_12RuntimeStateEj_block_invoke(uint64_t a1, unsigned int a2, const unsigned __int8 *a3, int a4)
{
  uint64_t v8;
  int hasExportedSymbol;
  uint64_t v10;
  uint64_t Address;
  dyld3::MachOAnalyzer *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  dyld3::MachOAnalyzer *v19;
  uint64_t v20;
  dyld3::MachOAnalyzer *v21;
  dyld3::MachOAnalyzer *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  dyld3::MachOAnalyzer **v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  dyld3::MachOAnalyzer **v30;
  dyld4::Loader *v31;
  uint64_t v32;
  vm_address_t *v33;
  uint64_t v34;

  v8 = *(_QWORD *)(a1 + 56);
  Diagnostics::Diagnostics((Diagnostics *)&v33);
  hasExportedSymbol = dyld4::Loader::hasExportedSymbol(v8, (vm_address_t *)&v33, *(const dyld4::RuntimeState **)(a1 + 64), a3, 0, 1, (uint64_t *)&v31, 0);
  v10 = 0;
  if (hasExportedSymbol)
  {
    Address = dyld4::Loader::loadAddress(v31, *(const dyld4::RuntimeState **)(a1 + 64));
    v12 = (dyld3::MachOAnalyzer *)(Address + v32);
    if (a4 == 8)
    {
      v19 = (dyld3::MachOAnalyzer *)Address;
      v20 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v34 = Address + v32;
      if (dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>(v20 + 40, (_QWORD *)(v20 + 56), (_QWORD *)(v20 + 96), 0, &v34) != *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 96)+ 16 * *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 112))
      {
        v21 = *(dyld3::MachOAnalyzer **)(a1 + 72);
        if (!dyld3::MachOAnalyzer::isSwiftClass(v19, v12))
        {
          v22 = (dyld3::MachOAnalyzer *)((char *)v21 + a2);
          if (!dyld3::MachOAnalyzer::isSwiftClass(v21, v22))
          {
            v23 = *(_QWORD *)(a1 + 64);
            lsl::Vector<dyld4::InterposeTupleAll>::reserve(v23 + 224, *(_QWORD *)(v23 + 240) + 1);
            v24 = *(_QWORD *)(v23 + 232);
            v25 = *(_QWORD *)(v23 + 240);
            *(_QWORD *)(v23 + 240) = v25 + 1;
            v26 = (dyld3::MachOAnalyzer **)(v24 + 16 * v25);
            *v26 = v22;
            v26[1] = v12;
            v27 = *(_QWORD *)(a1 + 64);
            lsl::Vector<dyld4::ObjCClassReplacement>::reserve(v27 + 256, *(_QWORD *)(v27 + 272) + 1);
            v28 = *(_QWORD *)(v27 + 264);
            v29 = *(_QWORD *)(v27 + 272);
            *(_QWORD *)(v27 + 272) = v29 + 1;
            v30 = (dyld3::MachOAnalyzer **)(v28 + 32 * v29);
            *v30 = v21;
            v30[1] = v22;
            v30[2] = v19;
            v30[3] = v12;
            v10 = 1;
            goto LABEL_10;
          }
        }
      }
    }
    else if (a4 == 1)
    {
      v13 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v34 = Address + v32;
      if (dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>(v13 + 40, (_QWORD *)(v13 + 56), (_QWORD *)(v13 + 96), 0, &v34) != *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 96)+ 16 * *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 112))
      {
        v14 = *(_QWORD *)(a1 + 64);
        v15 = *(_QWORD *)(a1 + 72) + a2;
        lsl::Vector<dyld4::InterposeTupleAll>::reserve(v14 + 288, *(_QWORD *)(v14 + 304) + 1);
        v16 = *(_QWORD *)(v14 + 296);
        v17 = *(_QWORD *)(v14 + 304);
        *(_QWORD *)(v14 + 304) = v17 + 1;
        v18 = (_QWORD *)(v16 + 16 * v17);
        *v18 = v15;
        v18[1] = v12;
        v10 = 2;
        goto LABEL_10;
      }
    }
    v10 = (uint64_t)v12 - *(_QWORD *)(a1 + 88);
  }
LABEL_10:
  *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24))++) = v10;
  mach_o::Error::~Error(&v33);
}

uint64_t dyld4::JustInTimeLoader::dependent(dyld4::JustInTimeLoader *this, int a2, unsigned int a3, char *a4)
{
  unint64_t v4;
  char *v8;

  v4 = *((_QWORD *)this + 5);
  if (a3 >= (unsigned __int16)(v4 >> 39))
    dyld4::JustInTimeLoader::dependent();
  if (a4)
  {
    if ((v4 & 0x800000) != 0)
      v8 = &mach_o::LinkedDylibAttributes::regular;
    else
      v8 = (char *)dyld4::JustInTimeLoader::dependentAttrs(this, a3);
    *a4 = *v8;
  }
  return *((_QWORD *)this + a3 + 58);
}

void ___ZN5dyld416JustInTimeLoader17cacheWeakDefFixupERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEjjRKNS_6Loader14ResolvedSymbolE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char **v5;
  char *v6;
  dyld4::RuntimeState *v7;

  v5 = (char **)(*(_QWORD *)(a1 + 32) + a2);
  v6 = (char *)dyld4::Loader::resolvedAddress(*(const dyld4::RuntimeState **)(a1 + 40), *(_QWORD *)(a1 + 48)) + a4;
  if (*v5 != v6)
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(_BYTE **)(a1 + 56));
    v7 = *(dyld4::RuntimeState **)(a1 + 40);
    if (*(_BYTE *)(*((_QWORD *)v7 + 1) + 202))
      dyld4::RuntimeState::log(v7, "cache patch: %p = 0x%0lX\n", v5, v6);
    *v5 = v6;
  }
}

void dyld4::JustInTimeLoader::applyFixups(uint64_t a1, vm_address_t *a2, uint64_t a3, dyld4::DyldCacheDataConstLazyScopedWriter *a4, char a5, uint64_t a6)
{
  dyld3::MachOFile *v10;
  uint64_t v11;
  dyld4::Loader **v12;
  uint64_t v13;
  dyld4::Loader *v14;
  _QWORD v15[6];
  _QWORD v16[8];
  _QWORD v17[9];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  double (*v21)(uint64_t, uint64_t);
  _QWORD *(*v22)(_QWORD *);
  char *v23;
  uint64_t v24;
  uint64_t v25;
  vm_address_t address;
  vm_size_t size;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  double (*v31)(uint64_t, uint64_t);
  _QWORD *(*v32)(_QWORD *);
  char *v33;
  uint64_t v34;
  uint64_t v35;
  vm_address_t v36;
  vm_size_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  double (*v41)(uint64_t, uint64_t);
  _QWORD *(*v42)(_QWORD *);
  char *v43;
  uint64_t v44;
  uint64_t v45;
  vm_address_t v46;
  vm_size_t v47;
  _QWORD v48[6];
  char v49;
  char v50;
  char v51;

  if ((*(_WORD *)(a1 + 4) & 2) != 0)
  {
    if (*(_BYTE *)(a3 + 1158))
    {
      v11 = *(_QWORD *)(a3 + 48);
      if (v11)
      {
        v12 = *(dyld4::Loader ***)(a3 + 40);
        v13 = 8 * v11;
        do
        {
          v14 = *v12++;
          dyld4::Loader::applyCachePatchesTo(v14, (dyld4::RuntimeState *)a3, (const dyld4::Loader *)a1, a4);
          v13 -= 8;
        }
        while (v13);
      }
    }
    *(_QWORD *)(a1 + 40) |= 0x20000uLL;
  }
  else if (!*(_QWORD *)(a1 + 104))
  {
    v48[0] = _NSConcreteStackBlock;
    v48[1] = 0x40000000;
    v48[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke;
    v48[3] = &__block_descriptor_tmp_21;
    v48[4] = a3;
    v48[5] = a4;
    v38 = 0;
    v39 = &v38;
    v40 = 0x5002000000;
    v41 = __Block_byref_object_copy__22;
    v42 = __Block_byref_object_dispose__23;
    v43 = &v51;
    v44 = 512;
    v46 = 0;
    v47 = 0;
    v45 = 0;
    v28 = 0;
    v29 = &v28;
    v30 = 0x5002000000;
    v31 = __Block_byref_object_copy__22;
    v32 = __Block_byref_object_dispose__23;
    v33 = &v50;
    v34 = 32;
    v36 = 0;
    v37 = 0;
    v35 = 0;
    v18 = 0;
    v19 = &v18;
    v20 = 0x5002000000;
    v21 = __Block_byref_object_copy__24;
    v22 = __Block_byref_object_dispose__25;
    v23 = &v49;
    v24 = 4;
    address = 0;
    size = 0;
    v25 = 0;
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    v17[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_26;
    v17[3] = &unk_1E4F7D338;
    v17[6] = a1;
    v17[7] = a3;
    v17[4] = &v38;
    v17[5] = &v18;
    v17[8] = a6;
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    v16[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_2;
    v16[3] = &unk_1E4F7D360;
    v16[6] = a1;
    v16[7] = a3;
    v16[4] = &v28;
    v16[5] = &v18;
    dyld4::Loader::forEachBindTarget((dyld4::Loader *)a1, a2, (dyld4::RuntimeState *)a3, (uint64_t)v48, a5, (uint64_t)v17, (uint64_t)v16);
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      dyld4::Loader::applyFixupsGeneric((dyld4::Loader *)a1, a2, (dyld4::RuntimeState *)a3, *(_QWORD *)(a1 + 48), (uint64_t)(v39 + 5), (uint64_t)(v29 + 5), 1, (uint64_t)(v19 + 5));
      if (*(_DWORD *)(*(_QWORD *)(a3 + 8) + 68) == 1)
      {
        if (*(_QWORD *)(a3 + 104))
        {
          v10 = *(dyld3::MachOFile **)(a1 + 32);
          if ((dyld3::MachOFile::inDyldCache(v10) & 1) == 0)
          {
            v15[0] = _NSConcreteStackBlock;
            v15[1] = 0x40000000;
            v15[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_3;
            v15[3] = &__block_descriptor_tmp_38;
            v15[4] = v10;
            v15[5] = a3;
            dyld3::MachOFile::forEachSupportedPlatform(v10, (uint64_t)v15);
          }
        }
      }
      if (dyld4::Loader::hasConstantSegmentsToProtect((dyld4::Loader *)a1))
        dyld4::Loader::makeSegmentsReadOnly((dyld4::Loader *)a1, (dyld4::RuntimeState *)a3);
      if (Diagnostics::noError((Diagnostics *)a2))
        *(_QWORD *)(a1 + 40) |= 0x20000uLL;
    }
    _Block_object_dispose(&v18, 8);
    v25 = 0;
    if (address)
      vm_deallocate(mach_task_self_, address, size);
    _Block_object_dispose(&v28, 8);
    v35 = 0;
    if (v36)
      vm_deallocate(mach_task_self_, v36, v37);
    _Block_object_dispose(&v38, 8);
    v45 = 0;
    if (v46)
      vm_deallocate(mach_task_self_, v46, v47);
  }
}

double __Block_byref_object_copy__22(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__23(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

double __Block_byref_object_copy__24(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__25(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

uint64_t ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_3(uint64_t result, int a2, unsigned int a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  dyld3::MachOLoaded *Address;
  unint64_t v8;
  unint64_t v9[5];

  if (a2 == 1 && a3 <= 0xA0900)
  {
    v9[3] = v3;
    v9[4] = v4;
    v5 = result;
    v9[0] = 0;
    result = dyld3::MachOLoaded::findSectionContent(*(dyld3::MachOLoaded **)(result + 32), "__DATA", "__dyld", v9);
    if (result)
    {
      v6 = (_QWORD *)result;
      v8 = 0;
      Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*(dyld4::Loader **)(*(_QWORD *)(v5 + 40) + 104), *(const dyld4::RuntimeState **)(v5 + 40));
      result = dyld3::MachOLoaded::findSectionContent(Address, "__TPRO_CONST", "__dyld4", &v8);
      if (result)
      {
        *v6 = 0;
        v6[1] = *(_QWORD *)(result + 56);
      }
    }
  }
  return result;
}

void dyld4::JustInTimeLoader::unmap(dyld4::JustInTimeLoader *this, dyld4::SyscallDelegate **a2, char a3)
{
  __int16 v3;
  const char *v7;
  size_t v8;
  char *v9;
  const char *v10;

  v3 = *((_WORD *)this + 2);
  if ((v3 & 2) == 0 && !*((_QWORD *)this + 13))
  {
    if ((v3 & 0x20) != 0 && (a3 & 1) == 0)
    {
      if (*((_WORD *)this + 20))
        v7 = (char *)this + *((unsigned __int16 *)this + 20);
      else
        v7 = 0;
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "trying to unmap %s\n", v7);
    }
    if ((a3 & 1) == 0 && (*((_WORD *)this + 2) & 0x20) != 0)
      dyld4::JustInTimeLoader::unmap();
    v8 = dyld3::MachOFile::mappedSize(*((dyld3::MachOFile **)this + 4));
    v9 = (char *)*((_QWORD *)this + 4);
    dyld4::SyscallDelegate::unmapFile(a2[1], v9, v8);
    if (*((_BYTE *)a2[1] + 201))
    {
      if (*((_WORD *)this + 20))
        v10 = (char *)this + *((unsigned __int16 *)this + 20);
      else
        v10 = 0;
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "unmapped 0x%012lX->0x%012lX for %s\n", v9, &v9[v8], v10);
    }
  }
}

uint64_t dyld4::JustInTimeLoader::hasBeenFixedUp(dyld4::JustInTimeLoader *this, dyld4::RuntimeState *a2)
{
  return (*((unsigned __int8 *)this + 42) >> 1) & 1;
}

void dyld4::JustInTimeLoader::getFileValidationInfo(dyld4::JustInTimeLoader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v5;
  _DWORD *v6;
  uint64_t *v7;
  __int128 v8;
  _QWORD v9[5];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  __n128 (*v13)(uint64_t, uint64_t);
  uint64_t (*v14)();
  uint64_t v15;

  v10 = 0;
  v11 = &v10;
  v12 = 0x6002000000;
  v13 = __Block_byref_object_copy__71;
  v14 = __Block_byref_object_dispose__72;
  bzero(&v15, 0x38uLL);
  if (*((_BYTE *)this + 80))
  {
    v5 = v11;
    *((_BYTE *)v11 + 92) = 1;
    v5[5] = *((_QWORD *)this + 6);
    v5[7] = *((_QWORD *)this + 7);
    v5[8] = *((_QWORD *)this + 9);
  }
  if ((*((_WORD *)this + 2) & 2) != 0)
  {
    v7 = v11;
  }
  else
  {
    v6 = (_DWORD *)*((_QWORD *)this + 4);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = ___ZNK5dyld416JustInTimeLoader21getFileValidationInfoERNS_12RuntimeStateE_block_invoke;
    v9[3] = &unk_1E4F7D3F0;
    v9[4] = &v10;
    dyld3::MachOAnalyzer::forEachCDHash(v6, (uint64_t)v9);
    v7 = v11;
    v11[6] = *((_QWORD *)this + 8);
  }
  v8 = *(_OWORD *)(v7 + 7);
  *(_OWORD *)a2 = *(_OWORD *)(v7 + 5);
  *(_OWORD *)(a2 + 16) = v8;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(v7 + 9);
  *(_QWORD *)(a2 + 48) = v7[11];
  _Block_object_dispose(&v10, 8);
}

__n128 __Block_byref_object_copy__71(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  result = *(__n128 *)(a2 + 40);
  v3 = *(_OWORD *)(a2 + 56);
  v4 = *(_OWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v4;
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 ___ZNK5dyld416JustInTimeLoader21getFileValidationInfoERNS_12RuntimeStateE_block_invoke(uint64_t a1, __n128 *a2)
{
  uint64_t v2;
  __n128 result;

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 93) = 1;
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  result = *a2;
  *(_DWORD *)(v2 + 88) = a2[1].n128_u32[0];
  *(__n128 *)(v2 + 72) = result;
  return result;
}

uint64_t dyld4::JustInTimeLoader::getCatalystMacTwinPatches(dyld4::JustInTimeLoader *this)
{
  return *((_QWORD *)this + 12);
}

__n128 __Block_byref_object_copy__75(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

dyld4::Loader *dyld4::JustInTimeLoader::makeJustInTimeLoaderDyldCache(vm_address_t *a1, dyld4::RuntimeState *a2, char *a3, int a4, int a5)
{
  __int16 v5;
  mach_o::Header *IndexedImageEntry;
  uint64_t v10;
  char v11;
  int v12;
  __int16 v13;
  dyld4::Loader *v14;
  dyld4::Loader *v15;
  uint64_t v16;
  unsigned int v18;
  __int128 v19;
  unint64_t v20;
  char v21;
  unint64_t v22;
  unint64_t v23;

  v5 = a5;
  v23 = 0;
  v22 = 0;
  IndexedImageEntry = (mach_o::Header *)dyld4::ProcessConfig::DyldCache::getIndexedImageEntry((DyldSharedCache **)(*((_QWORD *)a2 + 1) + 240), a5, &v23, &v22);
  v10 = *((_QWORD *)a2 + 1);
  v11 = *(_BYTE *)(v10 + 397);
  v19 = v22;
  v20 = v23;
  v21 = v11;
  if ((dyld3::MachOFile::loadableIntoProcess(IndexedImageEntry, *(_DWORD *)(v10 + 68), a3, *(unsigned __int8 *)(v10 + 168)) & 1) != 0)
  {
    if (_platform_strncmp(a3, "/System/iOSSupport/", 0x13uLL))
    {
      v12 = 0;
      v13 = 0;
    }
    else
    {
      v18 = 0;
      v12 = dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(*((_QWORD *)a2 + 1) + 240), a3 + 18, &v18);
      v13 = v18;
      if (!v12)
        v13 = 0;
    }
    v15 = (dyld4::Loader *)dyld4::JustInTimeLoader::make((uint64_t)a2, IndexedImageEntry, a3, &v19, 0, 1, 0, v12, v13);
    v14 = v15;
    *((_WORD *)v15 + 3) = *((_WORD *)v15 + 3) & 0x8000 | v5 & 0x7FFF;
    v16 = *((_QWORD *)a2 + 1);
    if (*(_BYTE *)(v16 + 201))
    {
      dyld4::Loader::logSegmentsFromSharedCache(v15, a2);
      v16 = *((_QWORD *)a2 + 1);
    }
    if (*(_BYTE *)(v16 + 200))
      dyld4::Loader::logLoad(v14, a2, a3);
  }
  else
  {
    Diagnostics::error(a1, "wrong platform to load into process");
    return 0;
  }
  return v14;
}

_QWORD *dyld4::JustInTimeLoader::makePseudoDylibLoader(vm_address_t *a1, uint64_t a2, const char *a3, uint64_t a4, mach_o::Header **a5)
{
  mach_o::Header *v9;
  _QWORD *result;
  __int128 v11[2];

  v9 = *a5;
  memset(v11, 0, sizeof(v11));
  if ((dyld3::MachOFile::loadableIntoProcess(v9, *(_DWORD *)(*(_QWORD *)(a2 + 8) + 68), a3, 0) & 1) != 0)
  {
    result = dyld4::JustInTimeLoader::make(a2, v9, a3, v11, 0, 0, 0, 0, 0);
    result[13] = a5;
  }
  else
  {
    Diagnostics::error(a1, "wrong platform to load into process");
    return 0;
  }
  return result;
}

void __destroy_helper_block_8_40c17_ZTS11Diagnostics(uint64_t a1)
{
  mach_o::Error::~Error((vm_address_t **)(a1 + 40));
}

uint64_t dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t v10;
  vm_address_t v11;
  vm_size_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD v21[2];
  vm_size_t size;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 == *(_QWORD *)a1)
  {
    v5 = 2 * *(_QWORD *)(a1 + 32);
    *(_QWORD *)a1 = 2 * v4;
    size = 0;
    memset(v21, 0, sizeof(v21));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v21, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v21, 1);
      v6 = (*(_QWORD *)&v21[1])++;
      *(_DWORD *)(*(_QWORD *)&v21[0] + 4 * v6) = -1;
    }
    if (*(_QWORD *)(a1 + 72))
    {
      v7 = 0;
      do
      {
        v8 = (_QWORD *)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v7);
        v9 = (*(_QWORD *)&v21[1] - 1) & *v8;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v21, v9) != -1)
        {
          v10 = 1;
          do
            v9 = (*(_QWORD *)&v21[1] - 1) & (v9 + v10++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v21, v9) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v21, v9) = v7++;
      }
      while (v7 != *(_QWORD *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v21)
    {
      *(_QWORD *)&v21[1] = 0;
      if (*((_QWORD *)&v21[1] + 1))
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v21[1] + 1), size);
    }
    else
    {
      v11 = *(_QWORD *)(a1 + 40);
      if (v11)
        vm_deallocate(mach_task_self_, v11, *(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)&v21[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v21 + 8);
      v12 = size;
      *(_QWORD *)(a1 + 40) = *((_QWORD *)&v21[1] + 1);
      *(_QWORD *)(a1 + 48) = v12;
    }
  }
  v13 = (*(_QWORD *)(a1 + 32) - 1) & *a2;
  v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v13);
  if ((_DWORD)v14 == -1)
  {
LABEL_20:
    v16 = *(_QWORD *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v13) = v16;
    ++*(_QWORD *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v17 = *(_QWORD *)(a1 + 56);
    v18 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v18 + 1;
    *(_OWORD *)(v17 + 16 * v18) = *(_OWORD *)a2;
    v19 = *(_QWORD *)(a1 + 72);
    if (!v19)
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    return *(_QWORD *)(a1 + 56) + 16 * v19 - 16;
  }
  else
  {
    v15 = 1;
    while (*(_QWORD *)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v14) != *a2)
    {
      v13 = (*(_QWORD *)(a1 + 32) - 1) & (v13 + v15++);
      v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v13);
      if ((_DWORD)v14 == -1)
        goto LABEL_20;
    }
    return dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v14);
  }
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[](_QWORD *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = a1[2];
  v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5)
      dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::reserve(a1, a2 + 1);
    a1[2] = v5;
  }
  return *a1 + 16 * a2;
}

_QWORD *dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::reserve(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  const void **v3;
  vm_address_t v4;
  vm_size_t v5;
  unint64_t v6;
  vm_size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;

  v2 = result[1];
  if (v2 < a2)
  {
    v3 = (const void **)result;
    v4 = result[3];
    v5 = result[4];
    v6 = 2 * v2;
    if (v6 <= a2)
      v6 = a2;
    v7 = (vm_page_size + 16 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    result = memmove((void *)v3[3], *v3, 16 * (_QWORD)v3[2]);
    v11 = (const void *)((unint64_t)v3[4] >> 4);
    *v3 = v3[3];
    v3[1] = v11;
    if (v4)
      return (_QWORD *)vm_deallocate(mach_task_self_, v4, v5);
  }
  return result;
}

uint64_t ___ZN5dyld4L19getSingletonPatchesEPKN5dyld313MachOAnalyzerERNS0_3MapIPKvbNS_11HashPointerENS_12EqualPointerEEE_block_invoke(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v10;

  if (a2 == 1)
  {
    v9 = v3;
    v10 = v4;
    v6 = *(_QWORD *)(result + 32);
    v5 = *(_QWORD *)(result + 40);
    v7 = v6 + a3;
    v8 = 1;
    return dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v5, &v7);
  }
  return result;
}

uint64_t dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_OWORD *)(a1 + 16) = 0u;
  v2 = (_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A5CBAC60;
  v3 = 32;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((_QWORD *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1);
    v4 = *(_QWORD *)(a1 + 16);
    v5 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }
  while (v3);
  dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::reserve((_QWORD *)(a1 + 56), 0x20uLL);
  return a1;
}

uint64_t dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4, _QWORD *a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  v5 = a3[2];
  if (!v5)
    return *a3;
  v6 = a2[2];
  v7 = (v6 - 1) & *a5;
  if (v6 <= v7)
LABEL_8:
    dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>();
  v8 = *a3;
  v9 = 1;
  while (1)
  {
    v10 = *(unsigned int *)(*a2 + 4 * v7);
    if ((_DWORD)v10 == -1)
      return v8 + 16 * v5;
    if (v5 <= v10)
      dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>();
    if (*(_QWORD *)(v8 + 16 * v10) == *a5)
      return v8 + 16 * v10;
    v7 = (v7 + v9++) & (v6 - 1);
    if (v6 <= v7)
      goto LABEL_8;
  }
}

uint64_t lsl::Vector<dyld4::ObjCClassReplacement>::reserve(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  if (*(_QWORD *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      v2 = 16;
    }
    return lsl::Vector<dyld4::ObjCClassReplacement>::reserveExact(result, v2);
  }
  return result;
}

uint64_t lsl::Vector<dyld4::ObjCClassReplacement>::reserveExact(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  _OWORD *v8;
  _OWORD *v9;
  __int128 v10;
  _QWORD *v11;

  if (*(_QWORD *)(result + 24) < a2)
  {
    v3 = result;
    result = lsl::Allocator::realloc(*(lsl::Allocator **)result, *(_QWORD **)(result + 8), 32 * a2);
    if ((result & 1) == 0)
    {
      result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)v3, 0x10uLL, 32 * a2);
      v4 = result;
      v5 = *(_QWORD *)(v3 + 16);
      if (v5)
      {
        v6 = 0;
        for (i = 0; i < v5; ++i)
        {
          v8 = (_OWORD *)(result + v6);
          v9 = (_OWORD *)(*(_QWORD *)(v3 + 8) + v6);
          v10 = v9[1];
          *v8 = *v9;
          v8[1] = v10;
          v5 = *(_QWORD *)(v3 + 16);
          v6 += 32;
        }
      }
      v11 = *(_QWORD **)(v3 + 8);
      if (v11)
      {
        result = (uint64_t)lsl::Allocator::free(*(lsl::Allocator **)v3, v11);
        v5 = *(_QWORD *)(v3 + 16);
      }
      if (v5 >= a2)
        v5 = a2;
      *(_QWORD *)(v3 + 8) = v4;
      *(_QWORD *)(v3 + 16) = v5;
    }
    *(_QWORD *)(v3 + 24) = a2;
  }
  return result;
}

unint64_t *dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(unint64_t *a1, vm_address_t *this, uint64_t a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v4 = *(_DWORD *)(a3 + 32);
  if (v4 == 1)
  {
    if (*(_QWORD *)a3)
      v8 = *(unsigned __int16 *)(*(_QWORD *)a3 + 6);
    else
      v8 = 0x7FFFLL;
    v9 = *(_QWORD *)(a3 + 16);
    *a1 = (v8 | (HIBYTE(v9) << 16)) & 0x8000000000FFFFFFLL | ((v9 & 0x7FFFFFFFFFLL) << 24);
    v10 = v9 & 0x7FFFFFFFFFLL;
    if ((v9 & 0x4000000000) != 0)
      v10 = v9 & 0x7FFFFFFFFFLL | 0xFFFF8000000000;
    if ((v10 | v9 & 0xFF00000000000000) != *(_QWORD *)(a3 + 16))
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef();
  }
  else if (v4 == 2)
  {
    v5 = *(_QWORD *)(a3 + 16);
    v6 = __ROR8__(v5, 56);
    *a1 = v6 | 0x8000000000000000;
    if ((v6 & 0x4000000000000000) != 0)
      v7 = (v6 | 0x8000000000000000) >> 8;
    else
      v7 = ((v6 | 0x8000000000000000) >> 8) & 0x7FFFFFFFFFFFFFLL;
    if ((v7 | (v6 << 56)) != *(_QWORD *)(a3 + 16))
      Diagnostics::error(this, "unencodeable absolute value (0x%llx) for symbol '%s'", *(_QWORD *)(a3 + 16), *(const char **)(a3 + 8));
  }
  return a1;
}

uint64_t dyld4::PrebuiltLoader::loadAddress(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2)
{
  int v2;

  v2 = *((__int16 *)this + 3);
  if (v2 < 0)
    return dyld4::RuntimeState::appLoadAddress(a2, v2 & 0x7FFF);
  else
    return dyld4::RuntimeState::cachedDylibLoadAddress(a2, *((unsigned __int16 *)this + 3));
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset(dyld4::PrebuiltLoader::BindTargetRef *this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *(_QWORD *)this;
  v2 = *(_QWORD *)this >> 24;
  if ((*(_QWORD *)this & 0x4000000000000000) != 0)
    v2 |= 0xFFFF8000000000uLL;
  v3 = v2 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)BYTE2(*(_QWORD *)this) << 56);
  v4 = ((unint64_t)v1 >> 8) | 0x80000000000000;
  if ((v1 & 0x4000000000000000) == 0)
    v4 = ((unint64_t)v1 >> 8) & 0x7FFFFFFFFFFFFFLL;
  v5 = v4 | (v1 << 56);
  if (v1 < 0)
    return v5;
  else
    return v3;
}

unint64_t *dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(unint64_t *this, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  v2 = __ROR8__(a2, 56);
  *this = v2 | 0x8000000000000000;
  v3 = ((v2 | 0x8000000000000000) >> 8) & 0x7FFFFFFFFFFFFFLL;
  if ((v2 & 0x4000000000000000) != 0)
    v3 = (v2 | 0x8000000000000000) >> 8;
  if ((v3 | (v2 << 56)) != a2)
    dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef();
  return this;
}

unint64_t *dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(unint64_t *this, const BindTarget *a2)
{
  uint64_t v2;
  unint64_t var1;
  uint64_t v4;

  if (a2->var0)
    v2 = *((unsigned __int16 *)a2->var0 + 3);
  else
    v2 = 0x7FFFLL;
  var1 = a2->var1;
  *this = (v2 | (HIBYTE(var1) << 16)) & 0x8000000000FFFFFFLL | ((var1 & 0x7FFFFFFFFFLL) << 24);
  v4 = var1 & 0x7FFFFFFFFFLL;
  if ((var1 & 0x4000000000) != 0)
    v4 = var1 & 0x7FFFFFFFFFLL | 0xFFFF8000000000;
  if ((v4 | var1 & 0xFF00000000000000) != a2->var1)
    dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef();
  return this;
}

uint64_t dyld4::PrebuiltLoader::path(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2)
{
  unint64_t v2;

  if ((*((_WORD *)this + 2) & 2) == 0)
  {
    v2 = *((_WORD *)this + 3) & 0x7FFF;
    if (*((_QWORD *)a2 + 42) > v2)
      return *(_QWORD *)(*((_QWORD *)a2 + 41) + 8 * v2);
  }
  if (*((_WORD *)this + 16))
    return (uint64_t)this + *((unsigned __int16 *)this + 16);
  return 0;
}

BOOL dyld4::PrebuiltLoader::matchesPath(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2, const char *__s1)
{
  unint64_t v5;
  const char *v6;

  if ((*((_WORD *)this + 2) & 2) != 0 || (v5 = *((_WORD *)this + 3) & 0x7FFF, *((_QWORD *)a2 + 42) <= v5))
  {
    if (*((_WORD *)this + 16))
      v6 = (char *)this + *((unsigned __int16 *)this + 16);
    else
      v6 = 0;
  }
  else
  {
    v6 = *(const char **)(*((_QWORD *)a2 + 41) + 8 * v5);
  }
  return !_platform_strcmp(__s1, v6)
      || *((_WORD *)this + 20) && !_platform_strcmp(__s1, (const char *)this + *((unsigned __int16 *)this + 20));
}

uint64_t dyld4::PrebuiltLoader::dependent(_WORD *a1, dyld4::RuntimeState *a2, uint64_t a3, char *a4)
{
  char *v6;
  uint64_t result;
  uint64_t v8;
  int v9;
  __int16 v10;
  __int16 v11;

  if ((unsigned __int16)a1[24] <= a3)
    dyld4::PrebuiltLoader::dependent();
  if (a4)
  {
    if (a1[18])
      v6 = (char *)a1 + (unsigned __int16)a1[18] + a3;
    else
      v6 = &mach_o::LinkedDylibAttributes::regular;
    *a4 = *v6;
  }
  v11 = *(_WORD *)((char *)&a1[a3] + (unsigned __int16)a1[17]);
  if (v11 == 0x7FFF)
    return 0;
  result = dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v11, a2, a3);
  if ((a1[2] & 2) != 0 && (*(_WORD *)(result + 44) & 4) == 0 && *(_BYTE *)(*((_QWORD *)a2 + 1) + 157))
  {
    v9 = *(unsigned __int16 *)(result + 60);
    if (v9 != 0xFFFF)
    {
      v10 = v9 & 0x7FFF;
      return dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v10, a2, v8);
    }
  }
  return result;
}

uint64_t dyld4::PrebuiltLoader::unmap(uint64_t this, dyld4::RuntimeState *a2)
{
  __int16 v2;
  char *v3;

  v2 = *(_WORD *)(this + 6);
  if (v2 >= 0)
    v3 = (char *)a2 + 1000;
  else
    v3 = (char *)a2 + 1024;
  *(_BYTE *)(*(_QWORD *)v3 + (v2 & 0x7FFF)) = 2;
  return this;
}

void dyld4::PrebuiltLoader::applyFixups(uint64_t a1, Diagnostics *a2, uint64_t a3, dyld4::DyldCacheDataConstLazyScopedWriter *a4)
{
  int v7;
  uint64_t v8;
  dyld4::Loader **v10;
  uint64_t v11;
  dyld4::Loader *v12;
  int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  dyld4::PrebuiltLoader::BindTargetRef *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  dyld4::Loader *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  dyld4::PrebuiltLoader::BindTargetRef *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  dyld4::Loader *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  dyld4::RuntimeState *v41;
  const char *v42;
  unint64_t v43;
  const dyld3::MachOAnalyzer *v44;
  uint64_t v45;
  uint64_t v46;
  vm_address_t *v47;
  _QWORD v48[3];
  _QWORD v49[2];
  uint64_t v50;
  vm_address_t address;
  vm_size_t size;
  _QWORD v53[2];
  uint64_t v54;
  vm_address_t v55;
  vm_size_t v56;
  _WORD v57[132];
  char v58;

  if ((*(_WORD *)(a1 + 4) & 2) != 0)
  {
    if (*(unsigned __int8 *)(a3 + 1158) | *(unsigned __int8 *)(a3 + 1159) && (v8 = *(_QWORD *)(a3 + 48)) != 0)
    {
      v10 = *(dyld4::Loader ***)(a3 + 40);
      v11 = 8 * v8;
      do
      {
        v12 = *v10++;
        dyld4::Loader::applyCachePatchesTo(v12, (dyld4::RuntimeState *)a3, (const dyld4::Loader *)a1, a4);
        v11 -= 8;
      }
      while (v11);
      v7 = (*(unsigned __int16 *)(a1 + 4) >> 1) & 1;
    }
    else
    {
      v7 = 1;
    }
  }
  else
  {
    v7 = 0;
  }
  v13 = *(__int16 *)(a1 + 6);
  v14 = (uint64_t *)(a3 + 1024);
  if (v13 >= 0)
    v14 = (uint64_t *)(a3 + 1000);
  v15 = *v14;
  if (!v7 || v13 < 0)
  {
    v45 = *(_WORD *)(a1 + 6) & 0x7FFF;
    v46 = v15;
    v47 = (vm_address_t *)a2;
    v53[0] = &v58;
    v53[1] = 512;
    v55 = 0;
    v56 = 0;
    v54 = 0;
    v16 = *(unsigned int *)(a1 + 52);
    if ((_DWORD)v16)
    {
      v17 = (dyld4::PrebuiltLoader::BindTargetRef *)(a1 + *(unsigned __int16 *)(a1 + 50));
      v18 = 8 * v16;
      do
      {
        v19 = dyld4::PrebuiltLoader::BindTargetRef::value(v17, (dyld4::RuntimeState *)a3, a3);
        if (*(_BYTE *)(*(_QWORD *)(a3 + 8) + 202))
        {
          v20 = *(_QWORD *)v17;
          v21 = dyld4::Loader::leafName((dyld4::Loader *)a1, (const dyld4::RuntimeState *)a3);
          if (v20 < 0)
          {
            dyld4::RuntimeState::log((dyld4::RuntimeState *)a3, "<%s/bind#%llu> -> %p\n");
          }
          else
          {
            if ((*(_QWORD *)v17 & 0x8000000000000000) != 0)
              dyld4::PrebuiltLoader::BindTargetRef::loaderRef((uint64_t)v21, v22, v23);
            v57[0] = *(_QWORD *)v17;
            v24 = (dyld4::Loader *)dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)v57, (const dyld4::RuntimeState *)a3, v23);
            dyld4::Loader::leafName(v24, (const dyld4::RuntimeState *)a3);
            dyld4::RuntimeState::log((dyld4::RuntimeState *)a3, "<%s/bind#%llu> -> %p (%s+0x%08llX)\n");
          }
        }
        dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v53, 1);
        v25 = v54++;
        *(_QWORD *)(v53[0] + 8 * v25) = v19;
        v17 = (dyld4::PrebuiltLoader::BindTargetRef *)((char *)v17 + 8);
        v18 -= 8;
      }
      while (v18);
    }
    if (!Diagnostics::hasError(a2))
    {
      v49[0] = v57;
      v49[1] = 32;
      address = 0;
      size = 0;
      v50 = 0;
      v27 = *(unsigned int *)(a1 + 96);
      if ((_DWORD)v27)
      {
        v28 = (dyld4::PrebuiltLoader::BindTargetRef *)(a1 + *(unsigned int *)(a1 + 92));
        v29 = 8 * v27;
        do
        {
          if ((*(_QWORD *)v28 & 0x800000000000FFFFLL) == 0x7FFF)
          {
            if (*(_BYTE *)(*(_QWORD *)(a3 + 8) + 202))
            {
              v30 = dyld4::Loader::leafName((dyld4::Loader *)a1, (const dyld4::RuntimeState *)a3);
              dyld4::RuntimeState::log((dyld4::RuntimeState *)a3, "<%s/bind#%llu> -> missing-weak-bind\n", v30, v50);
            }
            dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v49, 1);
            v31 = v50++;
            *(_QWORD *)(v49[0] + 8 * v31) = -1;
          }
          else
          {
            v32 = dyld4::PrebuiltLoader::BindTargetRef::value(v28, (dyld4::RuntimeState *)a3, v26);
            if (*(_BYTE *)(*(_QWORD *)(a3 + 8) + 202))
            {
              v33 = *(_QWORD *)v28;
              v34 = dyld4::Loader::leafName((dyld4::Loader *)a1, (const dyld4::RuntimeState *)a3);
              if (v33 < 0)
              {
                dyld4::RuntimeState::log((dyld4::RuntimeState *)a3, "<%s/bind#%llu> -> %p\n");
              }
              else
              {
                if ((*(_QWORD *)v28 & 0x8000000000000000) != 0)
                  dyld4::PrebuiltLoader::BindTargetRef::loaderRef((uint64_t)v34, v35, v36);
                LOWORD(v48[0]) = *(_QWORD *)v28;
                v37 = (dyld4::Loader *)dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)v48, (const dyld4::RuntimeState *)a3, v36);
                dyld4::Loader::leafName(v37, (const dyld4::RuntimeState *)a3);
                dyld4::RuntimeState::log((dyld4::RuntimeState *)a3, "<%s/bind#%llu> -> %p (%s+0x%08llX)\n");
              }
            }
            dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v49, 1);
            v38 = v50++;
            *(_QWORD *)(v49[0] + 8 * v38) = v32;
          }
          v28 = (dyld4::PrebuiltLoader::BindTargetRef *)((char *)v28 + 8);
          v29 -= 8;
        }
        while (v29);
      }
      if (!Diagnostics::hasError((Diagnostics *)v47))
      {
        if (!a1
          || !*(_WORD *)(a1 + 42)
          || (v39 = a1 + *(unsigned __int16 *)(a1 + 42), !*(_BYTE *)(v39 + 52))
          || (v40 = *(_QWORD *)v39, *(_QWORD *)v39 == -1))
        {
          v41 = (dyld4::RuntimeState *)dyld4::Loader::analyzer((dyld4::Loader *)a1, (dyld4::RuntimeState *)a3);
          if ((*(_WORD *)(a1 + 4) & 2) != 0 || (v43 = *(_WORD *)(a1 + 6) & 0x7FFF, *(_QWORD *)(a3 + 336) <= v43))
          {
            if (*(_WORD *)(a1 + 32))
              v44 = (const dyld3::MachOAnalyzer *)(a1 + *(unsigned __int16 *)(a1 + 32));
            else
              v44 = 0;
          }
          else
          {
            v44 = *(const dyld3::MachOAnalyzer **)(*(_QWORD *)(a3 + 328) + 8 * v43);
          }
          v40 = dyld4::Loader::getOnDiskBinarySliceOffset((dyld4::Loader *)a3, v41, v44, v42);
        }
        memset(v48, 0, sizeof(v48));
        dyld4::Loader::applyFixupsGeneric((dyld4::Loader *)a1, v47, (dyld4::RuntimeState *)a3, v40, (uint64_t)v53, (uint64_t)v49, 1, (uint64_t)v48);
        dyld4::PrebuiltLoader::applyObjCFixups((dyld4::PrebuiltLoader *)a1, (dyld4::RuntimeState *)a3);
        if (dyld4::Loader::hasConstantSegmentsToProtect((dyld4::Loader *)a1))
          dyld4::Loader::makeSegmentsReadOnly((dyld4::Loader *)a1, (dyld4::RuntimeState *)a3);
        *(_BYTE *)(v46 + v45) = 6;
      }
      v50 = 0;
      if (address)
        vm_deallocate(mach_task_self_, address, size);
    }
    v54 = 0;
    if (v55)
      vm_deallocate(mach_task_self_, v55, v56);
  }
  else
  {
    *(_BYTE *)(v15 + (*(_WORD *)(a1 + 6) & 0x7FFF)) = 6;
  }
}

_WORD *dyld4::PrebuiltLoader::recursiveMarkBeingValidated(_WORD *this, const dyld4::RuntimeState *a2, _BOOL4 a3)
{
  __int16 v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  _WORD *v9;
  uint64_t v10;
  char v11;
  _WORD *v12;
  __int16 v13;
  char *v14;
  __int16 v15;
  char *v16;

  v3 = this[3];
  if (v3 >= 0)
    v4 = (char *)a2 + 1000;
  else
    v4 = (char *)a2 + 1024;
  v5 = *(_QWORD *)v4;
  v6 = v3 & 0x7FFF;
  if (!*(_BYTE *)(v5 + v6))
  {
    v7 = a3;
    v9 = this;
    if (!a3 || (this[2] & 2) == 0)
    {
      *(_BYTE *)(v5 + v6) = 1;
      if (this[24])
      {
        v10 = 0;
        v11 = 0;
        do
        {
          this = (_WORD *)dyld4::PrebuiltLoader::dependent(v9, a2, v10, 0);
          if (this)
          {
            v12 = this;
            if ((this[2] & 1) == 0)
              dyld4::PrebuiltLoader::recursiveMarkBeingValidated();
            this = (_WORD *)dyld4::PrebuiltLoader::recursiveMarkBeingValidated((dyld4::PrebuiltLoader *)this, a2, v7);
            v13 = v12[3];
            if (v13 >= 0)
              v14 = (char *)a2 + 1000;
            else
              v14 = (char *)a2 + 1024;
            v11 |= *(unsigned __int8 *)(*(_QWORD *)v14 + (v13 & 0x7FFF)) == 255;
          }
          v10 = (v10 + 1);
        }
        while (v10 < (unsigned __int16)v9[24]);
        if ((v11 & 1) != 0)
        {
          v15 = v9[3];
          if (v15 >= 0)
            v16 = (char *)a2 + 1000;
          else
            v16 = (char *)a2 + 1024;
          *(_BYTE *)(*(_QWORD *)v16 + (v15 & 0x7FFF)) = -1;
        }
      }
    }
  }
  return this;
}

double dyld4::PrebuiltLoader::PrebuiltLoader(dyld4::PrebuiltLoader *this, const dyld4::Loader *a2)
{
  double result;
  _BYTE v4[12];

  dyld4::Loader::InitialOptions::InitialOptions((dyld4::Loader::InitialOptions *)v4, a2);
  dyld4::Loader::Loader((uint64_t)this, v4, 1, 0, 0, 0);
  *(_QWORD *)&result = 1;
  *((_QWORD *)this + 13) = 1;
  return result;
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_5(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  dyld4::RuntimeState *v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  dyld4::RuntimeState *v12;
  _DWORD *v13;
  uint64_t v14;

  v5 = *(_QWORD *)(a3 + 16);
  if (v5)
  {
    v6 = v5 - **(_QWORD **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v6) & 1) == 0)
    {
      v7 = *(dyld4::RuntimeState **)(a1 + 56);
      v8 = (_DWORD *)(**(_QWORD **)(a1 + 48) + v6);
      v9 = *v8 | 1;
      if (*(_BYTE *)(*((_QWORD *)v7 + 1) + 202))
        dyld4::RuntimeState::log(v7, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v8, v9);
      *v8 = v9;
    }
  }
  v10 = *(_QWORD *)(a3 + 24);
  if (v10)
  {
    v11 = v10 - **(_QWORD **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v11) & 1) == 0)
    {
      v12 = *(dyld4::RuntimeState **)(a1 + 56);
      v13 = (_DWORD *)(**(_QWORD **)(a1 + 48) + v11);
      v14 = *v13 | 1;
      if (*(_BYTE *)(*((_QWORD *)v12 + 1) + 202))
        dyld4::RuntimeState::log(v12, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v13, v14);
      *v13 = v14;
    }
  }
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_6(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  dyld4::RuntimeState *v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  dyld4::RuntimeState *v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  dyld4::RuntimeState *v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  dyld4::RuntimeState *v22;
  _DWORD *v23;
  uint64_t v24;

  v5 = a3[3];
  if (v5)
  {
    v6 = v5 - **(_QWORD **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v6) & 1) == 0)
    {
      v7 = *(dyld4::RuntimeState **)(a1 + 56);
      v8 = (_DWORD *)(**(_QWORD **)(a1 + 48) + v6);
      v9 = *v8 | 1;
      if (*(_BYTE *)(*((_QWORD *)v7 + 1) + 202))
        dyld4::RuntimeState::log(v7, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v8, v9);
      *v8 = v9;
    }
  }
  v10 = a3[4];
  if (v10)
  {
    v11 = v10 - **(_QWORD **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v11) & 1) == 0)
    {
      v12 = *(dyld4::RuntimeState **)(a1 + 56);
      v13 = (_DWORD *)(**(_QWORD **)(a1 + 48) + v11);
      v14 = *v13 | 1;
      if (*(_BYTE *)(*((_QWORD *)v12 + 1) + 202))
        dyld4::RuntimeState::log(v12, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v13, v14);
      *v13 = v14;
    }
  }
  v15 = a3[5];
  if (v15)
  {
    v16 = v15 - **(_QWORD **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v16) & 1) == 0)
    {
      v17 = *(dyld4::RuntimeState **)(a1 + 56);
      v18 = (_DWORD *)(**(_QWORD **)(a1 + 48) + v16);
      v19 = *v18 | 1;
      if (*(_BYTE *)(*((_QWORD *)v17 + 1) + 202))
        dyld4::RuntimeState::log(v17, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v18, v19);
      *v18 = v19;
    }
  }
  v20 = a3[6];
  if (v20)
  {
    v21 = v20 - **(_QWORD **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v21) & 1) == 0)
    {
      v22 = *(dyld4::RuntimeState **)(a1 + 56);
      v23 = (_DWORD *)(**(_QWORD **)(a1 + 48) + v21);
      v24 = *v23 | 1;
      if (*(_BYTE *)(*((_QWORD *)v22 + 1) + 202))
        dyld4::RuntimeState::log(v22, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v23, v24);
      *v23 = v24;
    }
  }
}

void dyld4::PrebuiltLoader::serialize(vm_address_t *a1, const dyld4::RuntimeState *a2, uint64_t a3, __int16 a4, uint64_t a5, dyld4::PrebuiltObjC *a6, int a7, dyld4::BumpAllocator *this)
{
  uint64_t v14;
  dyld3::MachOFile *v15;
  __int16 FixupsLoadCommandFileOffset;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  __int16 v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  __int16 v29;
  unsigned __int16 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  size_t v38;
  char *v39;
  char v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  BOOL v46;
  uint64_t v47;
  __int16 v48;
  uint64_t v49;
  uint64_t v50;
  unsigned __int16 v51;
  Diagnostics *v52;
  dyld3::MachOFile *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  const void *SectionLocations;
  int v61;
  int v63;
  __int16 v64;
  uint64_t v65;
  uint64_t v66;
  dyld4::Loader **v67;
  uint64_t v68;
  dyld4::Loader *v69;
  uint64_t v70;
  char *v71;
  dyld4::Loader **v72;
  uint64_t v73;
  dyld4::Loader *v74;
  uint64_t v75;
  dyld3::MachOFile *v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  Diagnostics *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  const void *v86;
  size_t v87;
  uint64_t v88;
  int v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  const char *v100;
  dyld4::PrebuiltObjC *v101;
  uint64_t v102;
  vm_address_t *v103;
  dyld3::MachOFile *v104;
  dyld4::RuntimeState *v105;
  __int16 v106;
  _QWORD *v107;
  _QWORD v108[6];
  _QWORD v109[8];
  uint64_t v110;
  uint64_t *v111;
  uint64_t v112;
  double (*v113)(uint64_t, uint64_t);
  _QWORD *(*v114)(_QWORD *);
  _OWORD *v115;
  uint64_t v116;
  uint64_t v117;
  vm_address_t v118;
  vm_size_t v119;
  _QWORD v120[8];
  _OWORD v121[2];
  __int128 v122;
  uint64_t v123;

  v103 = a1;
  v14 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, 0x1C0uLL);
  dyld4::PrebuiltLoader::PrebuiltLoader((dyld4::PrebuiltLoader *)(*(_QWORD *)this + v14), (const dyld4::Loader *)a3);
  *(_WORD *)(*(_QWORD *)this + v14 + 6) = a4;
  v15 = (dyld3::MachOFile *)dyld4::JustInTimeLoader::mf((dyld4::JustInTimeLoader *)a3, a2);
  FixupsLoadCommandFileOffset = dyld3::MachOFile::getFixupsLoadCommandFileOffset(v15);
  v17 = *(_QWORD *)this;
  v18 = *(_QWORD *)this + v14;
  *(_WORD *)(v18 + 38) = FixupsLoadCommandFileOffset;
  *(_WORD *)(v18 + 32) = *((_DWORD *)this + 4) - v17 - v14;
  v105 = a2;
  v19 = (const char *)dyld4::JustInTimeLoader::path((dyld4::JustInTimeLoader *)a3, a2);
  v20 = _platform_strlen(v19) + 1;
  v21 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, v20);
  memmove((void *)(*(_QWORD *)this + v21), v19, v20);
  *(_WORD *)(*(_QWORD *)this + v14 + 40) = 0;
  v22 = dyld3::MachOFile::installName(v15);
  v104 = v15;
  if (dyld3::MachOFile::isDylib(v15) && _platform_strcmp(v22, v19))
  {
    v23 = *((_QWORD *)this + 2) - *(_QWORD *)this;
    *(_WORD *)(*(_QWORD *)this + v14 + 40) = v23 - v14;
    v24 = _platform_strlen(v22) + 1;
    dyld4::BumpAllocator::zeroFill(this, v24);
    memmove((void *)(*(_QWORD *)this + v23), v22, v24);
  }
  if ((*(_WORD *)(a3 + 4) & 2) != 0)
  {
    if (dyld4::ProcessConfig::DyldCache::isOverridablePath((dyld4::ProcessConfig::DyldCache *)(*((_QWORD *)v105 + 1) + 240), v19))
    {
      v25 = 2;
    }
    else
    {
      v25 = 0;
    }
  }
  else
  {
    v25 = 0;
  }
  *(_WORD *)(*(_QWORD *)this + v14 + 44) = *(_WORD *)(*(_QWORD *)this + v14 + 44) & 0xFFFD | v25;
  v26 = dyld4::JustInTimeLoader::dependentCount((dyld4::JustInTimeLoader *)a3);
  v27 = *(_QWORD *)this;
  *(_WORD *)(*(_QWORD *)this + v14 + 48) = v26;
  v28 = *((_QWORD *)this + 2);
  v100 = v19;
  v101 = a6;
  v99 = a5;
  if ((((_BYTE)v28 - (_BYTE)v27) & 1) != 0)
  {
    dyld4::BumpAllocator::zeroFill(this, 2 - (((_BYTE)v28 - (_BYTE)v27) & 1));
    v28 = *((_QWORD *)this + 2);
    v27 = *(_QWORD *)this;
  }
  v29 = v28 - v27;
  v30 = v29 - v14;
  *(_WORD *)(v27 + v14 + 34) = v29 - v14;
  v31 = dyld4::BumpAllocator::zeroFill(this, 2 * v26);
  __chkstk_darwin(v31, v26 + 1, v32, v33, v34, v35, v36, v37, v98);
  v39 = (char *)&v98 - ((v38 + 15) & 0x1FFFFFFF0);
  if ((v40 & 1) != 0 || (bzero((char *)&v98 - ((v38 + 15) & 0x1FFFFFFF0), v38), v26))
  {
    v41 = 0;
    v42 = 0;
    v102 = v14;
    v43 = v14 + v30;
    do
    {
      v44 = dyld4::JustInTimeLoader::dependent((dyld4::JustInTimeLoader *)a3, (int)v105, v41, &v39[v41]);
      v45 = v39[v41];
      v46 = v45 != mach_o::LinkedDylibAttributes::regular;
      if (v44)
      {
        v47 = *(_QWORD *)this + v43;
        v48 = *(_WORD *)(v44 + 6);
      }
      else
      {
        if ((v45 & 1) == 0)
          dyld4::PrebuiltLoader::serialize();
        v47 = *(_QWORD *)this + v43;
        v48 = 0x7FFF;
      }
      *(_WORD *)(v47 + 2 * v41) = v48;
      v42 |= v46;
      ++v41;
    }
    while (v26 != v41);
    v49 = *(_QWORD *)this;
    v14 = v102;
    v50 = *(_QWORD *)this + v102;
    *(_WORD *)(v50 + 36) = 0;
    if ((v42 & 1) != 0)
    {
      v51 = *((_QWORD *)this + 2) - (v14 + v49);
      *(_WORD *)(v50 + 36) = v51;
      dyld4::BumpAllocator::zeroFill(this, v26);
      memmove((void *)(*(_QWORD *)this + v14 + v51), v39, v26);
      v49 = *(_QWORD *)this;
    }
  }
  else
  {
    v49 = *(_QWORD *)this;
    *(_WORD *)(*(_QWORD *)this + v14 + 36) = 0;
  }
  dyld4::JustInTimeLoader::getExportsTrie((dyld4::JustInTimeLoader *)a3, (unint64_t *)(v49 + v14 + 64), (unsigned int *)(v49 + v14 + 72));
  v52 = (Diagnostics *)v103;
  v53 = v104;
  *(_WORD *)(*(_QWORD *)this + v14 + 44) = *(_WORD *)(*(_QWORD *)this + v14 + 44) & 0xFFFE | dyld3::MachOFile::hasInitializer(v104, v103);
  if (!Diagnostics::hasError(v52))
  {
    *(_QWORD *)(*(_QWORD *)this + v14 + 80) = 0;
    if ((*(_BYTE *)(a3 + 4) & 2) == 0)
    {
      LODWORD(v121[0]) = 0;
      LODWORD(v110) = 0;
      if (dyld3::MachOFile::hasCodeSignature(v53, (unsigned int *)v121, (unsigned int *)&v110))
      {
        v54 = *(_QWORD *)this + v14;
        *(_DWORD *)(v54 + 80) = v121[0];
        *(_DWORD *)(v54 + 84) = v110;
      }
      if ((*(_WORD *)(a3 + 4) & 2) == 0)
        goto LABEL_28;
    }
    if (*(_BYTE *)(*((_QWORD *)v105 + 1) + 397))
    {
LABEL_28:
      if (((*((_DWORD *)this + 4) - *(_DWORD *)this) & 7) != 0)
        dyld4::BumpAllocator::zeroFill(this, 8 - ((*((_DWORD *)this + 4) - *(_DWORD *)this) & 7));
      v123 = 0;
      v122 = 0u;
      memset(v121, 0, sizeof(v121));
      dyld4::JustInTimeLoader::getFileValidationInfo((dyld4::JustInTimeLoader *)a3, (uint64_t)v121);
      v55 = *((_QWORD *)this + 2) - *(_QWORD *)this;
      *(_WORD *)(*(_QWORD *)this + v14 + 42) = v55 - v14;
      if ((unint64_t)(v55 - v14) >= 0x10000)
        dyld4::PrebuiltLoader::serialize();
      dyld4::BumpAllocator::zeroFill(this, 0x38uLL);
      v56 = *(_QWORD *)this + v55;
      v57 = v121[0];
      v58 = v121[1];
      v59 = v122;
      *(_QWORD *)(v56 + 48) = v123;
      *(_OWORD *)(v56 + 16) = v58;
      *(_OWORD *)(v56 + 32) = v59;
      *(_OWORD *)v56 = v57;
    }
    *(_DWORD *)(*(_QWORD *)this + v14 + 76) = dyld3::MachOFile::mappedSize(v53);
    v120[0] = _NSConcreteStackBlock;
    v120[1] = 0x40000000;
    v120[2] = ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke;
    v120[3] = &__block_descriptor_tmp_46_2;
    v120[4] = this;
    v120[5] = v14;
    v120[6] = this;
    v120[7] = v14;
    dyld4::JustInTimeLoader::withRegions(v53, (uint64_t)v120);
    SectionLocations = (const void *)dyld4::JustInTimeLoader::getSectionLocations((dyld4::JustInTimeLoader *)a3);
    memmove((void *)(*(_QWORD *)this + v14 + 104), SectionLocations, 0x158uLL);
    v61 = *(_DWORD *)(*((_QWORD *)v105 + 1) + 64);
    if (v61 == 1 || v61 == 6)
      v63 = (*(unsigned __int16 *)(a3 + 4) >> 1) & 1;
    else
      v63 = 0;
    if (v63 == 1)
    {
      if (dyld3::MachOFile::builtForPlatform(v53, 6, 0))
        v64 = 4;
      else
        v64 = 0;
    }
    else
    {
      v64 = 0;
    }
    *(_WORD *)(*(_QWORD *)this + v14 + 44) = *(_WORD *)(*(_QWORD *)this + v14 + 44) & 0xFFFB | v64;
    *(_WORD *)(*(_QWORD *)this + v14 + 44) &= ~8u;
    v65 = *(_QWORD *)this + v14;
    *(_DWORD *)(v65 + 60) = 0xFFFF;
    if (v63)
    {
      if ((*(_WORD *)(v65 + 44) & 4) != 0)
      {
        if (!_platform_strncmp(v100, "/System/iOSSupport/", 0x13uLL))
        {
          v70 = *((_QWORD *)v105 + 6);
          if (v70)
          {
            v71 = (char *)(v100 + 18);
            v72 = (dyld4::Loader **)*((_QWORD *)v105 + 5);
            v73 = 8 * v70;
            while (1)
            {
              v74 = *v72;
              if (dyld4::Loader::matchesPath(*v72, v105, v71))
                break;
              ++v72;
              v73 -= 8;
              if (!v73)
                goto LABEL_58;
            }
            v75 = *(_QWORD *)this + v14;
            *(_WORD *)(v75 + 60) = *((_WORD *)v74 + 3) & 0x7FFF;
            *(_WORD *)(v75 + 44) |= 8u;
          }
        }
      }
      else
      {
        strcpy((char *)v121, "/System/iOSSupport");
        strlcat((char *)v121, v100, 0x400uLL);
        v66 = *((_QWORD *)v105 + 6);
        if (v66)
        {
          v67 = (dyld4::Loader **)*((_QWORD *)v105 + 5);
          v68 = 8 * v66;
          while (1)
          {
            v69 = *v67;
            if (dyld4::Loader::matchesPath(*v67, v105, (char *)v121))
              break;
            ++v67;
            v68 -= 8;
            if (!v68)
              goto LABEL_58;
          }
          *(_WORD *)(*(_QWORD *)this + v14 + 60) = *((_WORD *)v69 + 3) & 0x7FFF;
        }
      }
    }
LABEL_58:
    v110 = 0;
    v111 = &v110;
    v112 = 0x5002000000;
    v113 = __Block_byref_object_copy__4;
    v114 = __Block_byref_object_dispose__4;
    v115 = v121;
    v116 = 16;
    v118 = 0;
    v119 = 0;
    v117 = 0;
    v76 = v104;
    if ((*(_BYTE *)(a3 + 4) & 2) == 0)
    {
      v77 = *((_QWORD *)this + 2);
      v78 = *(_QWORD *)this;
      if ((((_BYTE)v77 - *(_QWORD *)this) & 7) != 0)
      {
        dyld4::BumpAllocator::zeroFill(this, 8 - (((_BYTE)v77 - *(_QWORD *)this) & 7));
        v77 = *((_QWORD *)this + 2);
        v78 = *(_QWORD *)this;
      }
      v79 = v77 - (v14 + v78);
      *(_WORD *)(v78 + v14 + 50) = v79;
      if (v79 >= 0x10000)
        dyld4::PrebuiltLoader::serialize();
      *(_DWORD *)(v78 + v14 + 52) = 0;
      v109[0] = _NSConcreteStackBlock;
      v109[1] = 0x40000000;
      v109[2] = ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51;
      v109[3] = &__block_descriptor_tmp_55;
      v80 = (Diagnostics *)v103;
      v109[4] = v103;
      v109[5] = this;
      v109[6] = this;
      v109[7] = v14;
      v108[0] = _NSConcreteStackBlock;
      v108[1] = 0x40000000;
      v108[2] = ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_2;
      v108[3] = &unk_1E4F7D610;
      v108[4] = &v110;
      v108[5] = v103;
      dyld4::Loader::forEachBindTarget((dyld4::Loader *)a3, v103, v105, v99, 1, (uint64_t)v109, (uint64_t)v108);
      if (Diagnostics::hasError(v80))
        goto LABEL_79;
      if (v111[7])
      {
        v81 = *((_QWORD *)this + 2);
        v82 = *(_QWORD *)this;
        if ((((_BYTE)v81 - *(_QWORD *)this) & 7) != 0)
        {
          dyld4::BumpAllocator::zeroFill(this, 8 - (((_BYTE)v81 - *(_QWORD *)this) & 7));
          v81 = *((_QWORD *)this + 2);
          v82 = *(_QWORD *)this;
        }
        v83 = v82 + v14;
        *(_DWORD *)(v83 + 92) = v81 - (v14 + v82);
        *(_DWORD *)(v83 + 96) = v111[7];
        v84 = v111;
        v85 = v111[7];
        if (!v85)
        {
          dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v111 + 5, 1uLL);
          v84[7] = 1;
          v76 = v104;
          v85 = v111[7];
          v81 = *((_QWORD *)this + 2);
          v82 = *(_QWORD *)this;
        }
        v86 = (const void *)v84[5];
        v87 = 8 * v85;
        v88 = v81 - v82;
        dyld4::BumpAllocator::zeroFill(this, 8 * v85);
        memmove((void *)(*(_QWORD *)this + v88), v86, v87);
      }
    }
    v89 = dyld4::PrebuiltObjC::serializeFixups(v101, (const dyld4::Loader *)a3, this);
    v90 = v89 - v14;
    if (!v89)
      v90 = 0;
    v91 = *(_QWORD *)this + v14;
    *(_DWORD *)(v91 + 56) = v90;
    *(_OWORD *)(v91 + 8) = *(_OWORD *)(a3 + 8);
    v92 = *(_QWORD *)this + v14;
    *(_DWORD *)(v92 + 24) = *((_DWORD *)v76 + 2);
    *(_DWORD *)(v92 + 88) = 0;
    v107 = 0;
    v106 = 0;
    if (dyld4::JustInTimeLoader::overridesDylibInCache(a3, &v107, &v106))
    {
      v93 = v107;
      if (v107)
      {
        v94 = *((_QWORD *)this + 2) - *(_QWORD *)this;
        *(_DWORD *)(*(_QWORD *)this + v14 + 88) = v94 - v14;
        if (*v93 == -1)
        {
          v97 = 8;
        }
        else
        {
          v95 = 1;
          do
            v96 = v93[v95++];
          while (v96 != -1);
          v97 = (v95 * 8);
        }
        dyld4::BumpAllocator::zeroFill(this, v97);
        memmove((void *)(*(_QWORD *)this + v94), v93, v97);
      }
    }
LABEL_79:
    _Block_object_dispose(&v110, 8);
    v117 = 0;
    if (v118)
      vm_deallocate(mach_task_self_, v118, v119);
  }
}

uint64_t dyld4::BumpAllocator::zeroFill(dyld4::BumpAllocator *this, unint64_t a2)
{
  uint64_t v4;
  vm_size_t v5;
  uint64_t result;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  vm_address_t address;

  v5 = *((_QWORD *)this + 1);
  v4 = *((_QWORD *)this + 2);
  result = *(_QWORD *)this;
  if (v5 - v4 + result < a2)
  {
    v7 = 0x100000;
    if (v5 > 0x100000)
      v7 = v5;
    if (v7 < a2)
      v7 = (a2 & 0xFFFFFFFFFFF00000) + 0x100000;
    address = 0;
    v5 += v7;
    vm_allocate(mach_task_self_, &address, v5, 1006632961);
    result = address;
    if (!address)
      dyld4::BumpAllocator::zeroFill();
    v8 = *((_QWORD *)this + 2);
    v9 = v8 - *(_QWORD *)this;
    if (*(_QWORD *)this)
    {
      memmove((void *)address, *(const void **)this, v8 - *(_QWORD *)this);
      vm_deallocate(mach_task_self_, *(_QWORD *)this, *((_QWORD *)this + 1));
      result = address;
    }
    v4 = result + v9;
    *((_QWORD *)this + 1) = v5;
    *((_QWORD *)this + 2) = result + v9;
    *(_QWORD *)this = result;
  }
  v10 = v4 + a2;
  if (v10 > result + v5)
    dyld4::BumpAllocator::zeroFill();
  *((_QWORD *)this + 2) = v10;
  return result;
}

void *dyld4::BumpAllocator::append(dyld4::BumpAllocator *this, const void *a2, unint64_t a3)
{
  uint64_t v6;

  v6 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, a3);
  return memmove((void *)(*(_QWORD *)this + v6), a2, a3);
}

dyld4::BumpAllocator *dyld4::BumpAllocator::align(dyld4::BumpAllocator *this, unsigned int a2)
{
  unint64_t v2;

  v2 = (*((_QWORD *)this + 2) - *(_QWORD *)this) % (unint64_t)a2;
  if (v2)
    return (dyld4::BumpAllocator *)dyld4::BumpAllocator::zeroFill(this, a2 - v2);
  return this;
}

double __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__4(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

uint64_t ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result;
  dyld4::BumpAllocator *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;

  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(&v10, *(vm_address_t **)(a1 + 32), a2);
  result = Diagnostics::hasError(*(Diagnostics **)(a1 + 32));
  if ((_DWORD)result)
  {
    *a3 = 1;
  }
  else
  {
    v6 = *(dyld4::BumpAllocator **)(a1 + 40);
    v7 = *((_QWORD *)v6 + 2) - *(_QWORD *)v6;
    result = dyld4::BumpAllocator::zeroFill(v6, 8uLL);
    *(_QWORD *)(*(_QWORD *)v6 + v7) = v10;
    v8 = **(_QWORD **)(a1 + 48) + *(_QWORD *)(a1 + 56);
    v9 = *(_DWORD *)(v8 + 52);
    *(_DWORD *)(v8 + 52) = v9 + 1;
    if (v9 == -1)
      ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51_cold_1();
  }
  return result;
}

void dyld4::PrebuiltLoader::withLayout(dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4)
{
  dyld3::MachOLoaded *v6;

  v6 = (dyld3::MachOLoaded *)dyld4::Loader::analyzer(a1, a3);
  dyld3::MachOAnalyzer::withVMLayout(v6, a2, a4);
}

uint64_t dyld4::PrebuiltLoaderSet::findLoader(dyld4::PrebuiltLoaderSet *this, const dyld4::RuntimeState *a2, const char *a3)
{
  _BOOL8 Index;
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 v8;

  v8 = 0;
  Index = dyld4::PrebuiltLoaderSet::findIndex((uint64_t)this, a2, a3, &v8);
  if (!Index)
    return 0;
  if (*((_DWORD *)this + 3) <= v8)
    dyld4::RuntimeState::findPrebuiltLoader(Index, v5, v6);
  return (uint64_t)this + *(unsigned int *)((char *)this + 4 * v8 + *((unsigned int *)this + 4));
}

BOOL dyld4::PrebuiltLoaderSet::findIndex(uint64_t this, const dyld4::RuntimeState *a2, const char *__s2, unsigned __int16 *a4)
{
  unsigned int v4;
  uint64_t v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  _WORD *v12;
  unint64_t v13;
  const char *v14;
  uint64_t v15;
  char *v16;

  v4 = *(_DWORD *)(this + 12);
  if (v4)
  {
    v7 = this;
    v8 = 0;
    v10 = *((_QWORD *)a2 + 41);
    v9 = *((_QWORD *)a2 + 42);
    v11 = 1;
    while (1)
    {
      if (v4 <= (unsigned __int16)v8)
        dyld4::RuntimeState::findPrebuiltLoader(this, (uint64_t)a2, (uint64_t)__s2);
      v12 = (_WORD *)(v7 + *(unsigned int *)(v7 + *(unsigned int *)(v7 + 16) + 4 * (unsigned __int16)v8));
      if ((v12[2] & 2) != 0 || (v13 = v12[3] & 0x7FFF, v9 <= v13))
      {
        v15 = (unsigned __int16)v12[16];
        v16 = (char *)v12 + v15;
        v14 = (_DWORD)v15 ? v16 : 0;
      }
      else
      {
        v14 = *(const char **)(v10 + 8 * v13);
      }
      this = _platform_strcmp(v14, __s2);
      if (!(_DWORD)this)
        break;
      v11 = ++v8 < v4;
      if (v4 == v8)
        return 0;
    }
    *a4 = v8;
  }
  else
  {
    return 0;
  }
  return v11;
}

uint64_t dyld4::PrebuiltLoaderSet::objcSelectorMap(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1;

  v1 = *((unsigned int *)this + 10);
  if ((_DWORD)v1)
    return (uint64_t)this + v1;
  else
    return 0;
}

uint64_t dyld4::PrebuiltLoaderSet::objcClassMap(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1;

  v1 = *((unsigned int *)this + 11);
  if ((_DWORD)v1)
    return (uint64_t)this + v1;
  else
    return 0;
}

uint64_t dyld4::PrebuiltLoaderSet::objcProtocolMap(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1;

  v1 = *((unsigned int *)this + 12);
  if ((_DWORD)v1)
    return (uint64_t)this + v1;
  else
    return 0;
}

double __Block_byref_object_copy__64(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;
  uint64_t v4;

  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 88) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  v3 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = v3;
  *(_QWORD *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_QWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  v4 = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 128) = v4;
  *(_QWORD *)(a2 + 128) = 0;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  return result;
}

uint64_t __Block_byref_object_dispose__65(uint64_t result)
{
  _QWORD *v1;
  vm_address_t v2;
  vm_address_t v3;

  v1 = (_QWORD *)result;
  *(_QWORD *)(result + 112) = 0;
  v2 = *(_QWORD *)(result + 120);
  if (v2)
    result = vm_deallocate(mach_task_self_, v2, *(_QWORD *)(result + 128));
  v1[9] = 0;
  v3 = v1[10];
  if (v3)
    return vm_deallocate(mach_task_self_, v3, v1[11]);
  return result;
}

uint64_t ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t result;
  const char *v4;
  char v5;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40;
  v4 = a2;
  v5 = 0;
  result = dyld3::Map<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::insert(v2, &v4);
  *(_BYTE *)(result + 8) = 1;
  return result;
}

void ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke_2(uint64_t a1, dyld4::PrebuiltLoader::BindTargetRef *this, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _WORD *v8;
  uint64_t v9;
  dyld4::RuntimeState *v10;
  unint64_t v11;
  const char *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  dyld4::PrebuiltLoader::BindTargetRef **v18;
  uint64_t v19;
  dyld4::PrebuiltLoader::BindTargetRef *v20;
  _WORD *v21;
  uint64_t v22;
  dyld4::RuntimeState *v23;
  unint64_t v24;
  const char *v25;
  const void *v26;
  __int16 v27;
  __int16 v28;
  const char *v29;

  if (*(_QWORD *)(a3 + 16) != 1)
  {
    v29 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value(this, *(dyld4::RuntimeState **)(a1 + 40), a3);
    v5 = dyld3::MapBase<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::find<char const*>(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40, (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 56), (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 96), 0, &v29);
    if (v5 == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 96)
             + 16 * *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 112))
    {
      if (!*(_QWORD *)(a3 + 16))
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v5, v6, v7);
      if ((***(_QWORD ***)a3 & 0x8000000000000000) != 0)
        dyld4::PrebuiltLoader::BindTargetRef::loaderRef(v5, v6, v7);
      v28 = ***(_QWORD ***)a3;
      v8 = (_WORD *)dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v28, *(const dyld4::RuntimeState **)(a1 + 40), v7);
      v10 = *(dyld4::RuntimeState **)(a1 + 40);
      if ((v8[2] & 2) != 0 || (v11 = v8[3] & 0x7FFF, *((_QWORD *)v10 + 42) <= v11))
      {
        if (v8[16])
          v12 = (char *)v8 + (unsigned __int16)v8[16];
        else
          v12 = 0;
      }
      else
      {
        v12 = *(const char **)(*((_QWORD *)v10 + 41) + 8 * v11);
      }
      if (!*(_QWORD *)(a3 + 16))
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>((uint64_t)v8, (uint64_t)v10, v9);
      v13 = dyld4::PrebuiltLoader::BindTargetRef::value(**(dyld4::PrebuiltLoader::BindTargetRef ***)a3, v10, v9);
      v16 = *(_QWORD *)(a3 + 16);
      if (v16 != 1)
      {
        v17 = (const void *)v13;
        v18 = (dyld4::PrebuiltLoader::BindTargetRef **)(*(_QWORD *)a3 + 8);
        v19 = 8 * v16 - 8;
        do
        {
          v20 = *v18;
          if ((*(_QWORD *)*v18 & 0x8000000000000000) != 0)
            dyld4::PrebuiltLoader::BindTargetRef::loaderRef(v13, v14, v15);
          v27 = *(_QWORD *)*v18;
          v21 = (_WORD *)dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v27, *(const dyld4::RuntimeState **)(a1 + 40), v15);
          v23 = *(dyld4::RuntimeState **)(a1 + 40);
          if ((v21[2] & 2) != 0 || (v24 = v21[3] & 0x7FFF, *((_QWORD *)v23 + 42) <= v24))
          {
            if (v21[16])
              v25 = (char *)v21 + (unsigned __int16)v21[16];
            else
              v25 = 0;
          }
          else
          {
            v25 = *(const char **)(*((_QWORD *)v23 + 41) + 8 * v24);
          }
          v26 = (const void *)dyld4::PrebuiltLoader::BindTargetRef::value(v20, v23, v22);
          dyld4::RuntimeState::log(*(dyld4::RuntimeState **)(a1 + 40), "Class %s is implemented in both %s (%p) and %s (%p). One of the two will be used. Which one is undefined.\n", v29, v12, v17, v25, v26);
          ++v18;
          v19 -= 8;
        }
        while (v19);
      }
    }
  }
}

vm_address_t dyld4::PrebuiltLoaderSet::makeLaunchSet(vm_address_t *this, Diagnostics *a2, dyld4::RuntimeState *a3, const dyld4::MissingPaths *a4)
{
  BOOL v5;
  uint64_t v9;
  uint64_t v10;
  _BOOL8 hasMissingFlatLazySymbols;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  vm_address_t v19;
  uint64_t v21;
  char *v22;
  unint64_t v23;
  int v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  __int16 v29;
  __int16 v31;
  _QWORD *v32;
  uint64_t v33;
  int v34;
  DyldSharedCache *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  dyld4::BumpAllocator *v49;
  int v50;
  int v51;
  uint64_t v52;
  dyld4::BumpAllocator *v53;
  int v54;
  int v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  dyld4::BumpAllocator *v59;
  int v60;
  int v61;
  uint64_t v62;
  vm_address_t **v63;
  vm_address_t *v64;
  uint64_t *v65;
  _DWORD *v66;
  vm_address_t *v67;
  uint64_t v68;
  _QWORD *v69;
  uint64_t v70;
  __int128 v71;
  uint64_t v72;
  _QWORD v73[7];
  _QWORD v74[6];
  vm_address_t *v75;
  vm_address_t **v76;
  uint64_t v77;
  double (*v78)(uint64_t, uint64_t);
  _QWORD *(*v79)(_QWORD *);
  __n128 *v80;
  uint64_t v81;
  uint64_t v82;
  vm_address_t v83;
  vm_size_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  __n128 (*v88)(uint64_t, uint64_t);
  uint64_t (*v89)(uint64_t);
  vm_address_t v90;
  vm_size_t v91;
  uint64_t v92;
  _QWORD v93[13];
  _QWORD v94[13];
  _QWORD v95[9];
  uint64_t v96;
  char v97;
  _QWORD v98[55];
  char v99;
  char v100;
  uint64_t v101;
  char v102;
  __n128 v103[16];

  if (*((_QWORD *)a2 + 22))
    v5 = 0;
  else
    v5 = *((_QWORD *)a2 + 30) == 0;
  if (!v5 || *((_QWORD *)a2 + 38) != 0)
  {
    Diagnostics::error(this, "cannot make PrebuiltLoaderSet for program that uses interposing", a3, a4);
    return 0;
  }
  if (dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp((dyld4::ProcessConfig::PathOverrides *)(*((_QWORD *)a2 + 1) + 400)))
  {
    Diagnostics::error(this, "cannot make PrebuiltLoaderSet for program that uses DYLD_* env vars", v9, v10);
    return 0;
  }
  hasMissingFlatLazySymbols = dyld4::RuntimeState::hasMissingFlatLazySymbols(a2);
  if (hasMissingFlatLazySymbols)
  {
    Diagnostics::error(this, "cannot make PrebuiltLoaderSet for program that has missing flat lazy symbols", v13, v14);
    return 0;
  }
  __chkstk_darwin(hasMissingFlatLazySymbols, v12, v13, v14, v15, v16, v17, v18, v72);
  v22 = (char *)&v73[-1] - ((v21 + 23) & 0xFFFFFFFFFFFFFFF0);
  v23 = *((_QWORD *)a2 + 6);
  if (!v23)
  {
    v25 = 0;
LABEL_29:
    v72 = (uint64_t)&v72;
    dyld4::PrebuiltObjC::PrebuiltObjC((dyld4::PrebuiltObjC *)v98);
    dyld4::PrebuiltSwift::PrebuiltSwift((dyld4::PrebuiltSwift *)v93);
    Diagnostics::Diagnostics((Diagnostics *)v103);
    dyld4::PrebuiltObjC::make((dyld4::PrebuiltObjC *)v98, (Diagnostics *)v103, a2);
    if (!Diagnostics::hasError((Diagnostics *)v103))
    {
      Diagnostics::Diagnostics((Diagnostics *)&v75);
      dyld4::PrebuiltSwift::make((dyld4::PrebuiltSwift *)v93, (vm_address_t *)&v75, (dyld4::PrebuiltObjC *)v98, a2);
      mach_o::Error::~Error(&v75);
    }
    mach_o::Error::~Error((vm_address_t **)v103);
    v85 = 0;
    v86 = &v85;
    v87 = 0x4002000000;
    v88 = __Block_byref_object_copy__76;
    v89 = __Block_byref_object_dispose__77;
    v91 = 0;
    v92 = 0;
    v90 = 0;
    dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)&v90, 0x50uLL);
    v33 = v86[5];
    v32 = v86 + 5;
    *(_QWORD *)v33 = 0x173A676E73703464;
    *(_DWORD *)(v33 + 12) = v25;
    *(_OWORD *)(v33 + 16) = xmmword_1A5CBB3F0;
    *(_OWORD *)(v33 + 40) = 0u;
    *(_OWORD *)(v33 + 56) = 0u;
    *(_DWORD *)(v33 + 72) = 0;
    dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 4 * v25);
    v35 = *(DyldSharedCache **)(*((_QWORD *)a2 + 1) + 240);
    if (v35)
    {
      *(_DWORD *)(*v32 + 28) = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
      v103[0] = 0uLL;
      DyldSharedCache::getUUID(v35, v103);
      v36 = v86 + 5;
      v37 = v86[7] - v86[5];
      dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 0x10uLL);
      *(__n128 *)(*v36 + v37) = v103[0];
    }
    v75 = 0;
    v76 = &v75;
    v77 = 0x5002000000;
    v78 = __Block_byref_object_copy__78;
    v79 = __Block_byref_object_dispose__79;
    v80 = v103;
    v81 = 16;
    v83 = 0;
    v84 = 0;
    v82 = 0;
    v74[0] = _NSConcreteStackBlock;
    v74[1] = 0x40000000;
    v74[2] = ___ZN5dyld417PrebuiltLoaderSet13makeLaunchSetER11DiagnosticsRNS_12RuntimeStateERKNS_12MissingPathsE_block_invoke;
    v74[3] = &unk_1E4F7D6B0;
    v74[4] = &v75;
    v74[5] = this;
    if (v25)
    {
      v38 = 0;
      while (1)
      {
        *(_DWORD *)(*v32 + *(unsigned int *)(*v32 + 16) + 4 * v38) = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
        dyld4::PrebuiltLoader::serialize(this, a2, *(_QWORD *)&v22[8 * v38], v38 & 0x7FFF | 0x8000, (uint64_t)v74, (dyld4::PrebuiltObjC *)v98, v34, (dyld4::BumpAllocator *)(v86 + 5));
        if (Diagnostics::hasError((Diagnostics *)this))
          break;
        if (v25 == ++v38)
          goto LABEL_37;
      }
      v19 = 0;
    }
    else
    {
LABEL_37:
      if (v100)
      {
        if (v98[14])
        {
          *(_DWORD *)(*v32 + 40) = dyld4::PrebuiltObjC::serializeSelectorMap((dyld4::PrebuiltObjC *)v98, (dyld4::BumpAllocator *)(v86 + 5));
          v39 = *((_DWORD *)v86 + 10);
          v40 = *((_DWORD *)v86 + 14);
          v41 = ((_BYTE)v40 - (_BYTE)v39) & 7;
          if ((((_BYTE)v40 - (_BYTE)v39) & 7) != 0)
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v41);
        }
        if (v98[26])
        {
          *(_DWORD *)(*v32 + 44) = dyld4::PrebuiltObjC::serializeClassMap((dyld4::PrebuiltObjC *)v98, (dyld4::BumpAllocator *)(v86 + 5));
          v42 = *((_DWORD *)v86 + 10);
          v43 = *((_DWORD *)v86 + 14);
          v44 = ((_BYTE)v43 - (_BYTE)v42) & 7;
          if ((((_BYTE)v43 - (_BYTE)v42) & 7) != 0)
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v44);
        }
        if (v98[39])
        {
          *(_DWORD *)(*v32 + 48) = dyld4::PrebuiltObjC::serializeProtocolMap((dyld4::PrebuiltObjC *)v98, (dyld4::BumpAllocator *)(v86 + 5));
          v45 = *((_DWORD *)v86 + 10);
          v46 = *((_DWORD *)v86 + 14);
          v47 = ((_BYTE)v46 - (_BYTE)v45) & 7;
          if ((((_BYTE)v46 - (_BYTE)v45) & 7) != 0)
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v47);
        }
        if (!v102)
          std::__throw_bad_optional_access[abi:nn180100]();
        v48 = *v32;
        *(_QWORD *)(*v32 + 56) = v101;
        if (v99)
          *(_DWORD *)(v48 + 52) |= 1u;
      }
      if (v97)
      {
        if (v93[9])
        {
          v49 = (dyld4::BumpAllocator *)(v86 + 5);
          *(_DWORD *)(*v32 + 64) = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
          dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::serialize(v93, v49);
          v50 = *((_DWORD *)v86 + 10);
          v51 = *((_DWORD *)v86 + 14);
          v52 = ((_BYTE)v51 - (_BYTE)v50) & 7;
          if ((((_BYTE)v51 - (_BYTE)v50) & 7) != 0)
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v52);
        }
        if (v94[9])
        {
          v53 = (dyld4::BumpAllocator *)(v86 + 5);
          *(_DWORD *)(*v32 + 68) = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
          dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::serialize(v94, v53);
          v54 = *((_DWORD *)v86 + 10);
          v55 = *((_DWORD *)v86 + 14);
          v56 = ((_BYTE)v55 - (_BYTE)v54) & 7;
          if ((((_BYTE)v55 - (_BYTE)v54) & 7) != 0)
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v56);
        }
        if (v96)
        {
          v57 = (_QWORD *)v95[7];
          v58 = 48 * v96;
          do
          {
            *v57 = 0;
            v57 += 6;
            v58 -= 48;
          }
          while (v58);
          v59 = (dyld4::BumpAllocator *)(v86 + 5);
          *(_DWORD *)(*v32 + 72) = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
          dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::serialize(v95, v59);
          v60 = *((_DWORD *)v86 + 10);
          v61 = *((_DWORD *)v86 + 14);
          v62 = ((_BYTE)v61 - (_BYTE)v60) & 7;
          if ((((_BYTE)v61 - (_BYTE)v60) & 7) != 0)
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v62);
        }
      }
      v63 = v76;
      v64 = v76[7];
      v65 = v86;
      v66 = (_DWORD *)*v32;
      if (v64)
      {
        v66[6] = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
        v67 = v63[5];
        v68 = 16 * (_QWORD)v64;
        do
        {
          v69 = v86 + 5;
          v70 = v86[7] - v86[5];
          dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 0x10uLL);
          v71 = *(_OWORD *)v67;
          v67 += 2;
          *(_OWORD *)(*v69 + v70) = v71;
          v66 = (_DWORD *)*v32;
          ++*(_DWORD *)(*v32 + 20);
          v68 -= 16;
        }
        while (v68);
        v65 = v86;
      }
      if (*((_QWORD *)a3 + 2) != *(_QWORD *)a3)
      {
        v66[9] = *((_DWORD *)v65 + 14) - *((_DWORD *)v65 + 10);
        v73[0] = _NSConcreteStackBlock;
        v73[1] = 0x40000000;
        v73[2] = ___ZN5dyld417PrebuiltLoaderSet13makeLaunchSetER11DiagnosticsRNS_12RuntimeStateERKNS_12MissingPathsE_block_invoke_3;
        v73[3] = &unk_1E4F7D6D8;
        v73[4] = &v85;
        v73[5] = v32;
        v73[6] = 0;
        dyld4::MissingPaths::forEachPath((size_t)a3, (uint64_t)v73);
        v65 = v86;
        v66 = (_DWORD *)*v32;
      }
      v66[2] = *((_DWORD *)v65 + 14) - *((_DWORD *)v65 + 10);
      v19 = dyld4::BumpAllocator::finalize((dyld4::BumpAllocator *)(v86 + 5));
    }
    _Block_object_dispose(&v75, 8);
    v82 = 0;
    if (v83)
      vm_deallocate(mach_task_self_, v83, v84);
    _Block_object_dispose(&v85, 8);
    if (v90)
      vm_deallocate(mach_task_self_, v90, v91);
    dyld4::PrebuiltSwift::~PrebuiltSwift((dyld4::PrebuiltSwift *)v93);
    dyld4::PrebuiltObjC::~PrebuiltObjC((dyld4::PrebuiltObjC *)v98);
    return v19;
  }
  v24 = 0;
  v25 = 0;
  v26 = (uint64_t *)*((_QWORD *)a2 + 5);
  v27 = 8 * v23;
  while (1)
  {
    v28 = *v26;
    v29 = *(_WORD *)(*v26 + 4);
    if (*v26 && (v29 & 1) == 0)
      break;
LABEL_26:
    ++v26;
    v27 -= 8;
    if (!v27)
      goto LABEL_29;
  }
  if ((v29 & 2) != 0)
  {
    dyld4::JustInTimeLoader::path((dyld4::JustInTimeLoader *)v28, a2);
    Diagnostics::error(this, "cannot make PrebuiltLoader for dylib that is in dyld cache (%s)");
    return 0;
  }
  if ((*(_BYTE *)(v28 + 42) & 0x40) == 0)
  {
    if (v25 >= v23)
      ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
    *(_QWORD *)&v22[8 * v25++] = v28;
    v31 = v24++ | 0x8000;
    *(_WORD *)(v28 + 6) = v31;
    goto LABEL_26;
  }
  dyld4::JustInTimeLoader::path((dyld4::JustInTimeLoader *)v28, a2);
  Diagnostics::error(this, "cannot make PrebuiltLoader for dylib that overrides dylib in dyld cache (%s)");
  return 0;
}

__n128 __Block_byref_object_copy__76(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t __Block_byref_object_dispose__77(uint64_t result)
{
  vm_address_t v1;
  _QWORD *v2;

  v2 = (_QWORD *)(result + 40);
  v1 = *(_QWORD *)(result + 40);
  if (v1)
  {
    result = vm_deallocate(mach_task_self_, v1, *(_QWORD *)(result + 48));
    v2[1] = 0;
    v2[2] = 0;
    *v2 = 0;
  }
  return result;
}

double __Block_byref_object_copy__78(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__79(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

double ___ZN5dyld417PrebuiltLoaderSet13makeLaunchSetER11DiagnosticsRNS_12RuntimeStateERKNS_12MissingPathsE_block_invoke(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  double result;
  __int128 v9;

  *(_QWORD *)&v9 = __PAIR64__(a3, a2);
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((unint64_t *)&v9 + 1, *(vm_address_t **)(a1 + 40), a4);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((_QWORD *)(v5 + 40), 1);
  v6 = *(_QWORD *)(v5 + 40);
  v7 = *(_QWORD *)(v5 + 56);
  *(_QWORD *)(v5 + 56) = v7 + 1;
  result = *(double *)&v9;
  *(_OWORD *)(v6 + 16 * v7) = v9;
  return result;
}

void *dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::serialize(_QWORD *a1, dyld4::BumpAllocator *this)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;

  v4 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(_QWORD *)(*(_QWORD *)this + v4) = *a1;
  v5 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(_QWORD *)(*(_QWORD *)this + v5) = a1[1];
  v6 = a1[4];
  v7 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(_QWORD *)(*(_QWORD *)this + v7) = v6;
  v8 = (const void *)a1[2];
  v6 *= 8;
  v9 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, v6);
  memmove((void *)(*(_QWORD *)this + v9), v8, v6);
  v10 = a1[9];
  v11 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(_QWORD *)(*(_QWORD *)this + v11) = v10;
  v12 = (const void *)a1[7];
  v10 *= 32;
  v13 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, v10);
  return memmove((void *)(*(_QWORD *)this + v13), v12, v10);
}

void *dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::serialize(_QWORD *a1, dyld4::BumpAllocator *this)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;

  v4 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(_QWORD *)(*(_QWORD *)this + v4) = *a1;
  v5 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(_QWORD *)(*(_QWORD *)this + v5) = a1[1];
  v6 = a1[4];
  v7 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(_QWORD *)(*(_QWORD *)this + v7) = v6;
  v8 = (const void *)a1[2];
  v6 *= 8;
  v9 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, v6);
  memmove((void *)(*(_QWORD *)this + v9), v8, v6);
  v10 = a1[9];
  v11 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(_QWORD *)(*(_QWORD *)this + v11) = v10;
  v12 = (const void *)a1[7];
  v10 *= 48;
  v13 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, v10);
  return memmove((void *)(*(_QWORD *)this + v13), v12, v10);
}

size_t dyld4::MissingPaths::forEachPath(size_t result, uint64_t a2)
{
  const char *v2;
  size_t v4;

  v2 = *(const char **)result;
  if (*(_QWORD *)result < *(_QWORD *)(result + 16))
  {
    v4 = result;
    do
    {
      (*(void (**)(uint64_t, const char *))(a2 + 16))(a2, v2);
      result = _platform_strlen(v2);
      v2 += result + 1;
    }
    while ((unint64_t)v2 < *(_QWORD *)(v4 + 16));
  }
  return result;
}

vm_address_t dyld4::BumpAllocator::finalize(dyld4::BumpAllocator *this)
{
  unint64_t v2;
  vm_address_t v3;
  vm_size_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = *(_QWORD *)this;
  v4 = (~*(_QWORD *)this + *((_QWORD *)this + 2) + vm_page_size) & -(uint64_t)vm_page_size;
  if (v2 > v4)
  {
    vm_deallocate(mach_task_self_, v4 + v3, v2 - v4);
    *((_QWORD *)this + 1) = v4;
    *((_QWORD *)this + 2) = 0;
  }
  vm_protect(mach_task_self_, v3, v4, 0, 1);
  *(_QWORD *)this = 0;
  return v3;
}

uint64_t dyld4::PrebuiltLoaderSet::deallocate(vm_address_t address)
{
  return vm_deallocate(mach_task_self_, address, (vm_page_size + *(unsigned int *)(address + 8) - 1) & -(uint64_t)vm_page_size);
}

void *dyld4::MissingPaths::addPath(dyld4::MissingPaths *this, const char *__s)
{
  unint64_t v4;
  uint64_t v5;

  v4 = _platform_strlen(__s) + 1;
  v5 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  dyld4::BumpAllocator::zeroFill(this, v4);
  return memmove((void *)(*(_QWORD *)this + v5), __s, v4);
}

dyld4::PrebuiltObjC *dyld4::PrebuiltObjC::PrebuiltObjC(dyld4::PrebuiltObjC *this)
{
  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::Map((uint64_t)this + 40);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::MultiMap((uint64_t)this + 136, 0);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::MultiMap((uint64_t)this + 240, 0);
  dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)this + 344);
  *((_WORD *)this + 220) = 0;
  *((_BYTE *)this + 448) = 0;
  *((_BYTE *)this + 456) = 0;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 30) = 0u;
  *((_QWORD *)this + 62) = 0;
  return this;
}

uint64_t dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::Map(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_OWORD *)(a1 + 16) = 0u;
  v2 = (_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A5CBAC60;
  v3 = 32;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((_QWORD *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1);
    v4 = *(_QWORD *)(a1 + 16);
    v5 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }
  while (v3);
  dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve((_QWORD *)(a1 + 56), 0x20uLL);
  return a1;
}

uint64_t dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::MultiMap(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  *(_OWORD *)(a1 + 16) = 0u;
  v4 = (_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A5CBAC60;
  v5 = 32;
  dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve((_QWORD *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v4, 1);
    v6 = *(_QWORD *)(a1 + 16);
    v7 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = v7 + 1;
    *(_QWORD *)(v6 + 8 * v7) = -1;
    --v5;
  }
  while (v5);
  dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::reserve((_QWORD *)(a1 + 56), 0x20uLL);
  *(_QWORD *)(a1 + 96) = a2;
  return a1;
}

_QWORD *dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::reserve(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  const void **v3;
  vm_address_t v4;
  vm_size_t v5;
  unint64_t v6;
  vm_size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v2 = result[1];
  if (v2 < a2)
  {
    v3 = (const void **)result;
    v4 = result[3];
    v5 = result[4];
    v6 = 2 * v2;
    if (v6 <= a2)
      v6 = a2;
    v7 = (vm_page_size + 56 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    result = memmove((void *)v3[3], *v3, 56 * (_QWORD)v3[2]);
    v11 = (unint64_t)v3[4] / 0x38;
    *v3 = v3[3];
    v3[1] = (const void *)v11;
    if (v4)
      return (_QWORD *)vm_deallocate(mach_task_self_, v4, v5);
  }
  return result;
}

dyld4::PrebuiltSwift *dyld4::PrebuiltSwift::PrebuiltSwift(dyld4::PrebuiltSwift *this)
{
  uint64_t v2;

  v2 = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap((uint64_t)this, 0);
  dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap(v2 + 104, 0);
  dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap((uint64_t)this + 208, 0);
  *((_BYTE *)this + 312) = 0;
  return this;
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  *(_OWORD *)(a1 + 16) = 0u;
  v4 = (_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A5CBAC60;
  v5 = 32;
  dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve((_QWORD *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v4, 1);
    v6 = *(_QWORD *)(a1 + 16);
    v7 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = v7 + 1;
    *(_QWORD *)(v6 + 8 * v7) = -1;
    --v5;
  }
  while (v5);
  dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve((_QWORD *)(a1 + 56), 0x20uLL);
  *(_QWORD *)(a1 + 96) = a2;
  return a1;
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  *(_OWORD *)(a1 + 16) = 0u;
  v4 = (_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A5CBAC60;
  v5 = 32;
  dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve((_QWORD *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v4, 1);
    v6 = *(_QWORD *)(a1 + 16);
    v7 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = v7 + 1;
    *(_QWORD *)(v6 + 8 * v7) = -1;
    --v5;
  }
  while (v5);
  dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve((_QWORD *)(a1 + 56), 0x20uLL);
  *(_QWORD *)(a1 + 96) = a2;
  return a1;
}

void dyld4::PrebuiltSwift::~PrebuiltSwift(dyld4::PrebuiltSwift *this)
{
  vm_address_t v2;
  vm_address_t v3;
  vm_address_t v4;
  vm_address_t v5;
  vm_address_t v6;
  vm_address_t v7;

  *((_QWORD *)this + 35) = 0;
  v2 = *((_QWORD *)this + 36);
  if (v2)
    vm_deallocate(mach_task_self_, v2, *((_QWORD *)this + 37));
  *((_QWORD *)this + 30) = 0;
  v3 = *((_QWORD *)this + 31);
  if (v3)
    vm_deallocate(mach_task_self_, v3, *((_QWORD *)this + 32));
  *((_QWORD *)this + 22) = 0;
  v4 = *((_QWORD *)this + 23);
  if (v4)
    vm_deallocate(mach_task_self_, v4, *((_QWORD *)this + 24));
  *((_QWORD *)this + 17) = 0;
  v5 = *((_QWORD *)this + 18);
  if (v5)
    vm_deallocate(mach_task_self_, v5, *((_QWORD *)this + 19));
  *((_QWORD *)this + 9) = 0;
  v6 = *((_QWORD *)this + 10);
  if (v6)
    vm_deallocate(mach_task_self_, v6, *((_QWORD *)this + 11));
  *((_QWORD *)this + 4) = 0;
  v7 = *((_QWORD *)this + 5);
  if (v7)
    vm_deallocate(mach_task_self_, v7, *((_QWORD *)this + 6));
}

void dyld4::PrebuiltObjC::~PrebuiltObjC(dyld4::PrebuiltObjC *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  vm_address_t v6;
  vm_address_t v7;
  vm_address_t v8;
  vm_address_t v9;
  vm_address_t v10;
  vm_address_t v11;
  vm_address_t v12;
  vm_address_t v13;
  vm_address_t v14;
  vm_address_t v15;
  vm_address_t v16;
  uint64_t v17;
  uint64_t v18;
  vm_address_t v19;

  if (*((_QWORD *)this + 60))
  {
    v2 = 0;
    v3 = 0;
    do
    {
      v4 = *((_QWORD *)this + 58);
      v5 = (_QWORD *)(v4 + v2);
      *(_QWORD *)(v4 + v2 + 136) = 0;
      v6 = *(_QWORD *)(v4 + v2 + 144);
      if (v6)
        vm_deallocate(mach_task_self_, v6, v5[19]);
      v5[12] = 0;
      v7 = v5[13];
      if (v7)
        vm_deallocate(mach_task_self_, v7, *(_QWORD *)(v4 + v2 + 112));
      ++v3;
      v2 += 160;
    }
    while (v3 != *((_QWORD *)this + 60));
  }
  *((_QWORD *)this + 60) = 0;
  v8 = *((_QWORD *)this + 61);
  if (v8)
    vm_deallocate(mach_task_self_, v8, *((_QWORD *)this + 62));
  *((_QWORD *)this + 52) = 0;
  v9 = *((_QWORD *)this + 53);
  if (v9)
    vm_deallocate(mach_task_self_, v9, *((_QWORD *)this + 54));
  *((_QWORD *)this + 47) = 0;
  v10 = *((_QWORD *)this + 48);
  if (v10)
    vm_deallocate(mach_task_self_, v10, *((_QWORD *)this + 49));
  *((_QWORD *)this + 39) = 0;
  v11 = *((_QWORD *)this + 40);
  if (v11)
    vm_deallocate(mach_task_self_, v11, *((_QWORD *)this + 41));
  *((_QWORD *)this + 34) = 0;
  v12 = *((_QWORD *)this + 35);
  if (v12)
    vm_deallocate(mach_task_self_, v12, *((_QWORD *)this + 36));
  *((_QWORD *)this + 26) = 0;
  v13 = *((_QWORD *)this + 27);
  if (v13)
    vm_deallocate(mach_task_self_, v13, *((_QWORD *)this + 28));
  *((_QWORD *)this + 21) = 0;
  v14 = *((_QWORD *)this + 22);
  if (v14)
    vm_deallocate(mach_task_self_, v14, *((_QWORD *)this + 23));
  *((_QWORD *)this + 14) = 0;
  v15 = *((_QWORD *)this + 15);
  if (v15)
    vm_deallocate(mach_task_self_, v15, *((_QWORD *)this + 16));
  *((_QWORD *)this + 9) = 0;
  v16 = *((_QWORD *)this + 10);
  if (v16)
    vm_deallocate(mach_task_self_, v16, *((_QWORD *)this + 11));
  if (*((_QWORD *)this + 2))
  {
    v17 = 0;
    v18 = 0;
    do
    {
      dyld4::PrebuiltObjC::ObjCOptimizerImage::~ObjCOptimizerImage((dyld4::PrebuiltObjC::ObjCOptimizerImage *)(*(_QWORD *)this + v17));
      ++v18;
      v17 += 568;
    }
    while (v18 != *((_QWORD *)this + 2));
  }
  *((_QWORD *)this + 2) = 0;
  v19 = *((_QWORD *)this + 3);
  if (v19)
    vm_deallocate(mach_task_self_, v19, *((_QWORD *)this + 4));
}

void dyld4::PrebuiltObjC::ObjCOptimizerImage::~ObjCOptimizerImage(dyld4::PrebuiltObjC::ObjCOptimizerImage *this)
{
  vm_address_t v2;
  vm_address_t v3;
  vm_address_t v4;
  vm_address_t v5;
  vm_address_t v6;
  vm_address_t v7;
  vm_address_t v8;
  vm_address_t v9;
  vm_address_t v10;
  vm_address_t v11;

  *((_QWORD *)this + 58) = 0;
  v2 = *((_QWORD *)this + 59);
  if (v2)
    vm_deallocate(mach_task_self_, v2, *((_QWORD *)this + 60));
  *((_QWORD *)this + 53) = 0;
  v3 = *((_QWORD *)this + 54);
  if (v3)
    vm_deallocate(mach_task_self_, v3, *((_QWORD *)this + 55));
  *((_QWORD *)this + 46) = 0;
  v4 = *((_QWORD *)this + 47);
  if (v4)
    vm_deallocate(mach_task_self_, v4, *((_QWORD *)this + 48));
  *((_QWORD *)this + 41) = 0;
  v5 = *((_QWORD *)this + 42);
  if (v5)
    vm_deallocate(mach_task_self_, v5, *((_QWORD *)this + 43));
  *((_QWORD *)this + 36) = 0;
  v6 = *((_QWORD *)this + 37);
  if (v6)
    vm_deallocate(mach_task_self_, v6, *((_QWORD *)this + 38));
  *((_QWORD *)this + 29) = 0;
  v7 = *((_QWORD *)this + 30);
  if (v7)
    vm_deallocate(mach_task_self_, v7, *((_QWORD *)this + 31));
  *((_QWORD *)this + 24) = 0;
  v8 = *((_QWORD *)this + 25);
  if (v8)
    vm_deallocate(mach_task_self_, v8, *((_QWORD *)this + 26));
  *((_QWORD *)this + 17) = 0;
  v9 = *((_QWORD *)this + 18);
  if (v9)
    vm_deallocate(mach_task_self_, v9, *((_QWORD *)this + 19));
  *((_QWORD *)this + 12) = 0;
  v10 = *((_QWORD *)this + 13);
  if (v10)
    vm_deallocate(mach_task_self_, v10, *((_QWORD *)this + 14));
  *((_QWORD *)this + 7) = 0;
  v11 = *((_QWORD *)this + 8);
  if (v11)
    vm_deallocate(mach_task_self_, v11, *((_QWORD *)this + 9));
  mach_o::Error::~Error((vm_address_t **)this + 4);
}

uint64_t dyld3::Map<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::insert(uint64_t a1, const char **a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  char *v8;
  size_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  vm_address_t v13;
  vm_size_t v14;
  char *v15;
  size_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  const char **v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD v26[2];
  vm_size_t size;
  char v28;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 == *(_QWORD *)a1)
  {
    v5 = 2 * *(_QWORD *)(a1 + 32);
    *(_QWORD *)a1 = 2 * v4;
    size = 0;
    memset(v26, 0, sizeof(v26));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v26, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v26, 1);
      v6 = (*(_QWORD *)&v26[1])++;
      *(_DWORD *)(*(_QWORD *)&v26[0] + 4 * v6) = -1;
    }
    if (*(_QWORD *)(a1 + 72))
    {
      v7 = 0;
      do
      {
        v8 = *(char **)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v7);
        v9 = _platform_strlen(v8);
        v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v28, (uint64_t *)v8, v9);
        v11 = (*(_QWORD *)&v26[1] - 1) & v10;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v11) != -1)
        {
          v12 = 1;
          do
            v11 = (*(_QWORD *)&v26[1] - 1) & (v11 + v12++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v11) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v11) = v7++;
      }
      while (v7 != *(_QWORD *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v26)
    {
      *(_QWORD *)&v26[1] = 0;
      if (*((_QWORD *)&v26[1] + 1))
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v26[1] + 1), size);
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 40);
      if (v13)
        vm_deallocate(mach_task_self_, v13, *(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)&v26[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v26 + 8);
      v14 = size;
      *(_QWORD *)(a1 + 40) = *((_QWORD *)&v26[1] + 1);
      *(_QWORD *)(a1 + 48) = v14;
    }
  }
  v15 = (char *)*a2;
  v16 = _platform_strlen(*a2);
  v17 = (*(_QWORD *)(a1 + 32) - 1) & std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)v26, (uint64_t *)v15, v16);
  v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17);
  if ((_DWORD)v18 == -1)
  {
LABEL_20:
    v21 = *(_QWORD *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17) = v21;
    ++*(_QWORD *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v22 = *(_QWORD *)(a1 + 56);
    v23 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v23 + 1;
    *(_OWORD *)(v22 + 16 * v23) = *(_OWORD *)a2;
    v24 = *(_QWORD *)(a1 + 72);
    if (!v24)
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    return *(_QWORD *)(a1 + 56) + 16 * v24 - 16;
  }
  else
  {
    v19 = 1;
    while (1)
    {
      v20 = (const char **)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v18);
      if (!_platform_strcmp(*v20, *a2))
        return dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v18);
      v17 = (*(_QWORD *)(a1 + 32) - 1) & (v17 + v19++);
      v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17);
      if ((_DWORD)v18 == -1)
        goto LABEL_20;
    }
  }
}

uint64_t dyld3::MapBase<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::find<char const*>(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t a4, const char **a5)
{
  char *v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  unint64_t v21;
  unint64_t v22;
  char v24;

  if (!a3[2])
    return *a3;
  v8 = (char *)*a5;
  v9 = _platform_strlen(*a5);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v24, (uint64_t *)v8, v9);
  v13 = a2[2];
  v14 = v13 - 1;
  v15 = v10 & (v13 - 1);
  if (v13 <= v15)
LABEL_8:
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v10, v11, v12);
  v16 = *a2;
  v17 = a3[2];
  v18 = *a3;
  v19 = 1;
  v20 = *a5;
  while (1)
  {
    v21 = *(unsigned int *)(v16 + 4 * v15);
    if ((_DWORD)v21 == -1)
      return v18 + 16 * v17;
    if (v17 <= v21)
      dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>();
    v10 = _platform_strcmp(*(const char **)(v18 + 16 * v21), v20);
    if (!(_DWORD)v10)
      return v18 + 16 * v21;
    v22 = v15 + v19++;
    v15 = v22 & v14;
    if (v13 <= (v22 & v14))
      goto LABEL_8;
  }
}

void OUTLINED_FUNCTION_2_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 153, a4);
}

BOOL dyld4::SyscallDelegate::getCWD(dyld4::SyscallDelegate *this, char *a2)
{
  int v3;
  int v4;
  int v5;

  v3 = open(".", 0x100000, 0);
  if (v3 == -1)
    return 0;
  v4 = v3;
  v5 = fcntl(v3, 50, a2);
  close(v4);
  return v5 != -1;
}

uint64_t dyld4::SyscallDelegate::openLogFile(dyld4::SyscallDelegate *this, const char *a2)
{
  return open(a2, 521, 420);
}

uint64_t dyld4::SyscallDelegate::dtraceRegisterUserProbes(dyld4::SyscallDelegate *this, dof_ioctl_data *a2)
{
  uint64_t result;
  int v4;
  dof_ioctl_data *v5;

  result = open("/dev/dtracehelper", 2);
  if ((_DWORD)result != -1)
  {
    v4 = result;
    v5 = a2;
    ioctl(result, 0x80086804uLL, &v5);
    return close(v4);
  }
  return result;
}

uint64_t dyld4::SyscallDelegate::dtraceUnregisterUserProbe(dyld4::SyscallDelegate *this, uint64_t a2)
{
  uint64_t result;
  int v4;

  result = open("/dev/dtracehelper", 2, 0);
  if ((_DWORD)result != -1)
  {
    v4 = result;
    ioctl(result, 0x20006802uLL, a2);
    return close(v4);
  }
  return result;
}

BOOL dyld4::SyscallDelegate::hasExistingDyldCache(dyld4::SyscallDelegate *this, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  int v7;
  unint64_t v8;
  unint64_t v9;

  v7 = __shared_region_check_np(a2);
  if (!v7)
  {
    v8 = *(_QWORD *)(*a2 + 496) + *a2;
    if (_platform_strncmp((const char *)v8, "dyld_data    v0", 0x10uLL))
    {
      v9 = 0;
      *a3 = 0;
    }
    else
    {
      *a3 = *(_QWORD *)(v8 + 16);
      v9 = *(_QWORD *)(v8 + 24);
    }
    *a4 = v9;
  }
  return v7 == 0;
}

uint64_t dyld4::SyscallDelegate::forEachInDirectory(int a1, char *a2, int a3, uint64_t a4)
{
  uint64_t result;
  int v8;
  int v9;
  int v10;
  char *v11;
  uint64_t v12;
  unsigned int v13;
  _WORD v14[2];
  int v15;
  _BYTE v16[1024];
  _BYTE v17[512];

  result = open(a2, 0x100000, 0);
  if ((_DWORD)result != -1)
  {
    v8 = result;
    bzero(v14, 0x18uLL);
    v14[0] = 5;
    v15 = -2147483639;
    v9 = getattrlistbulk(v8, v14, v17, 0x200uLL, 0);
    if (v9 < 1)
      return close(v8);
    v10 = v9;
    while (1)
    {
      v11 = v17;
      do
      {
        v12 = *((int *)v11 + 6);
        if ((v11[4] & 8) == 0)
          goto LABEL_15;
        v13 = *((_DWORD *)v11 + 8);
        if (v13 == 2)
        {
          if (!a3)
            goto LABEL_15;
        }
        else if (v13 != 1 || (a3 & 1) != 0)
        {
          goto LABEL_15;
        }
        v16[0] = 0;
        if (dyld4::Utils::concatenatePaths((dyld4::Utils *)v16, a2, (const char *)0x400) > 0x3FF
          || dyld4::Utils::concatenatePaths((dyld4::Utils *)v16, "/", (const char *)0x400) > 0x3FF
          || dyld4::Utils::concatenatePaths((dyld4::Utils *)v16, &v11[v12 + 24], (const char *)0x400) > 0x3FF)
        {
          return close(v8);
        }
        (*(void (**)(uint64_t, _BYTE *, char *))(a4 + 16))(a4, v16, &v11[v12 + 24]);
LABEL_15:
        v11 += *(unsigned int *)v11;
        --v10;
      }
      while (v10);
      v10 = getattrlistbulk(v8, v14, v17, 0x200uLL, 0);
      if (v10 <= 0)
        return close(v8);
    }
  }
  return result;
}

uint64_t dyld4::SyscallDelegate::getDylibInfo(int a1, dyld3 *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  _QWORD v14[10];
  int v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t (*v23)(uint64_t, uint64_t);
  void (*v24)(uint64_t);
  vm_address_t *v25;

  v20 = 0;
  v21 = &v20;
  v22 = 0x3002000000;
  v23 = __Block_byref_object_copy__5;
  v24 = __Block_byref_object_dispose__5;
  Diagnostics::Diagnostics((Diagnostics *)&v25);
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = ___ZNK5dyld415SyscallDelegate12getDylibInfoEPKcN5dyld38PlatformERKNS3_11GradedArchsERjPc_block_invoke;
  v14[3] = &unk_1E4F7D700;
  v15 = a3;
  v14[6] = a4;
  v14[7] = a2;
  v14[8] = a5;
  v14[9] = a6;
  v14[4] = &v20;
  v14[5] = &v16;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(a1, (vm_address_t *)v21 + 5, a2, 0, (uint64_t)v14);
  v12 = *((unsigned __int8 *)v17 + 24);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  mach_o::Error::~Error(&v25);
  return v12;
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
  mach_o::Error::~Error((vm_address_t **)(a1 + 40));
}

uint64_t ___ZNK5dyld415SyscallDelegate12getDylibInfoEPKcN5dyld38PlatformERKNS3_11GradedArchsERjPc_block_invoke(uint64_t a1, dyld3::FatFile *this, unint64_t a3)
{
  dyld3::MachOFile *v3;
  uint64_t result;
  unsigned int v6[2];
  char *__source;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;

  v3 = this;
  v10 = 0;
  v8 = a3;
  v9 = 0;
  if (dyld3::FatFile::isFatFileWithSlice(this, (vm_address_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), a3, *(const dyld3::GradedArchs **)(a1 + 48), 1, &v9, &v8, &v10))
  {
    v3 = (dyld3::MachOFile *)((char *)v3 + v9);
  }
  else
  {
    result = dyld3::MachOFile::isMachO(v3, (vm_address_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v8);
    if (!(_DWORD)result)
      return result;
  }
  result = dyld3::MachOFile::isDylib(v3);
  if ((_DWORD)result)
  {
    result = dyld3::MachOFile::loadableIntoProcess(v3, *(_DWORD *)(a1 + 80), *(const char **)(a1 + 56), 0);
    if ((_DWORD)result)
    {
      *(_QWORD *)v6 = 0;
      __source = 0;
      result = dyld3::MachOFile::getDylibInstallName(v3, (const char **)&__source, &v6[1], v6);
      if ((_DWORD)result)
      {
        **(_DWORD **)(a1 + 64) = v6[0];
        result = strlcpy(*(char **)(a1 + 72), __source, 0x400uLL);
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
      }
    }
  }
  return result;
}

BOOL dyld4::SyscallDelegate::dirExists(dyld4::SyscallDelegate *this, dyld3 *a2, stat *a3)
{
  stat v5;

  return !dyld3::stat(a2, &v5, a3) && (v5.st_mode & 0xF000) == 0x4000;
}

BOOL dyld4::SyscallDelegate::mkdirs(dyld4::SyscallDelegate *this, const char *__s)
{
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  stat *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v19;
  stat v20;

  v3 = _platform_strlen(__s);
  __chkstk_darwin(v3, v4, v5, v6, v7, v8, v9, v10, v19);
  v12 = (char *)&v19 - ((v11 + 16) & 0xFFFFFFFFFFFFFFF0);
  strcpy(v12, __s);
  v13 = strrchr(v12, 47);
  v15 = v13;
  if (v13)
  {
    v13[1] = 0;
    if (dyld3::stat((dyld3 *)v12, &v20, v14))
    {
      v16 = _platform_strchr(v12 + 1, 47);
      if (v16)
      {
        v17 = v16;
        do
        {
          *v17 = 0;
          mkdir(v12, 0x1EDu);
          *v17 = 47;
          v17 = _platform_strchr(v17 + 1, 47);
        }
        while (v17);
      }
    }
  }
  return v15 != 0;
}

BOOL dyld4::SyscallDelegate::sandboxBlockedStat(dyld4::SyscallDelegate *this, const char *a2)
{
  unsigned int v2;
  pid_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = a2;
  v3 = getpid();
  return (int)sandbox_check(v3, (vm_address_t *)"file-read-metadata", 1073741825, v4, v5, v6, v7, v8, v2) > 0;
}

BOOL dyld4::SyscallDelegate::sandboxBlockedOpen(dyld4::SyscallDelegate *this, const char *a2)
{
  unsigned int v2;
  pid_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = a2;
  v3 = getpid();
  return (int)sandbox_check(v3, (vm_address_t *)"file-read-data", 1073741825, v4, v5, v6, v7, v8, v2) > 0;
}

uint64_t ___ZNK5dyld415SyscallDelegate15mapFileReadOnlyER11DiagnosticsPKcPmPNS_6FileIDEPbPc_block_invoke(uint64_t result, int a2, int a3, dyld3::MachOAnalyzer *this)
{
  uint64_t v5;

  if (a2 == 16777228 && (a3 & 0xFFFFFF) == 2)
  {
    v5 = result;
    result = dyld3::MachOAnalyzer::isOSBinary(this, *(_DWORD *)(result + 48), (uint64_t)this - *(_QWORD *)(result + 32));
    if ((_DWORD)result)
      **(_BYTE **)(v5 + 40) = 1;
  }
  return result;
}

uint64_t dyld4::SyscallDelegate::unmapFile(dyld4::SyscallDelegate *this, void *a2, size_t a3)
{
  return munmap(a2, a3);
}

BOOL dyld4::SyscallDelegate::setFileAttribute(int a1, char *a2, const char *a3, uint64_t a4)
{
  _BOOL4 v8;

  if (chmod(a2, 0x180u))
    return 0;
  if (setxattr(a2, a3, *(const void **)a4, *(_QWORD *)(a4 + 16), 0, 4))
    v8 = setxattr(a2, a3, *(const void **)a4, *(_QWORD *)(a4 + 16), 0, 0) == 0;
  else
    v8 = 1;
  return !chmod(a2, 0x100u) && v8;
}

uint64_t dyld4::SyscallDelegate::saveFileWithAttribute(int a1, vm_address_t *a2, const std::__fs::filesystem::path *__source, const void *a4, size_t a5, const char *a6, uint64_t a7)
{
  unsigned int v13;
  char v14;
  unsigned int v15;
  char v16;
  char v17;
  char v18;
  char v19;
  unsigned int v20;
  char v21;
  char v22;
  char v23;
  int v24;
  int v25;
  std::error_code *v26;
  int v27;
  char __sourcea[16];
  std::__fs::filesystem::path __dst[42];

  strlcpy((char *)__dst, (const char *)__source, 0x400uLL);
  v13 = getpid();
  __sourcea[0] = 46;
  if (HIBYTE(v13) >= 0xA0u)
    v14 = 55;
  else
    v14 = 48;
  __sourcea[1] = v14 + (v13 >> 28);
  v15 = HIBYTE(v13) & 0xF;
  if (v15 >= 0xA)
    v16 = 55;
  else
    v16 = 48;
  __sourcea[2] = v16 + v15;
  if (BYTE2(v13) >= 0xA0u)
    v17 = 55;
  else
    v17 = 48;
  __sourcea[3] = v17 + ((v13 >> 20) & 0xF);
  if ((HIWORD(v13) & 0xF) >= 0xAu)
    v18 = 55;
  else
    v18 = 48;
  __sourcea[4] = v18 + (BYTE2(v13) & 0xF);
  if (BYTE1(v13) >= 0xA0u)
    v19 = 55;
  else
    v19 = 48;
  __sourcea[5] = v19 + ((unsigned __int16)v13 >> 12);
  v20 = (v13 >> 8) & 0xF;
  if (v20 >= 0xA)
    v21 = 55;
  else
    v21 = 48;
  __sourcea[6] = v21 + v20;
  if (v13 >= 0xA0u)
    v22 = 55;
  else
    v22 = 48;
  __sourcea[7] = v22 + ((v13 & 0xF0) >> 4);
  if ((v13 & 0xF) >= 0xA)
    v23 = 55;
  else
    v23 = 48;
  __sourcea[8] = v23 + (v13 & 0xF);
  __sourcea[9] = 0;
  strlcat((char *)__dst, __sourcea, 0x400uLL);
  v24 = open_dprotected_np((const char *)__dst, 513, 4, 0, 384);
  if (v24 == -1)
  {
    __error();
    Diagnostics::error(a2, "open/open_dprotected_np(%s) failed, errno=%d");
  }
  else
  {
    v25 = v24;
    if (ftruncate(v24, a5) == -1)
    {
      __error();
      Diagnostics::error(a2, "ftruncate(%lu) failed, errno=%d");
    }
    else if (write(v25, a4, a5) == a5)
    {
      if (fsetxattr(v25, a6, *(const void **)a7, *(_QWORD *)(a7 + 16), 0, 0) == -1)
      {
        __error();
        Diagnostics::error(a2, "fsetxattr(%s) failed, errno=%d");
      }
      else if (fchmod(v25, 0x100u) == -1)
      {
        __error();
        Diagnostics::error(a2, "fchmod(S_IRUSR) failed, errno=%d");
      }
      else if (close(v25) == -1)
      {
        __error();
        Diagnostics::error(a2, "close() failed, errno=%d");
      }
      else
      {
        rename(__dst, __source, v26);
        if (v27 != -1)
          return 1;
        __error();
        Diagnostics::error(a2, "rename(%s, %s) failed, errno=%d");
      }
    }
    else
    {
      __error();
      Diagnostics::error(a2, "write() failed, errno=%d");
    }
  }
  return 0;
}

BOOL dyld4::SyscallDelegate::sandboxBlockedMmap(dyld4::SyscallDelegate *this, const char *a2)
{
  unsigned int v2;
  pid_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = a2;
  v3 = getpid();
  return (int)sandbox_check(v3, (vm_address_t *)"file-map-executable", 1073741825, v4, v5, v6, v7, v8, v2) > 0;
}

uint64_t dyld4::SyscallDelegate::setDyldCommPageFlags(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return sysctlbyname("kern.dyld_flags", 0, 0, &v3, 8uLL);
}

BOOL dyld4::SyscallDelegate::bootVolumeWritable(dyld4::SyscallDelegate *this)
{
  statfs v2;

  return statfs64("/", &v2)
      || *(_DWORD *)v2.f_fstypename ^ 0x73667061 | v2.f_fstypename[4]
      || (~v2.f_flags & 0x40000001) != 0;
}

ssize_t dyld4::SyscallDelegate::pread(dyld4::SyscallDelegate *this, int __fd, void *__buf, size_t __nbyte, off_t a5)
{
  return pread(__fd, __buf, __nbyte, a5);
}

uint64_t dyld4::SyscallDelegate::unlink(dyld4::SyscallDelegate *this, const char *a2)
{
  return unlink(a2);
}

uint64_t dyld4::SyscallDelegate::socket(dyld4::SyscallDelegate *this, int a2, int a3, int a4)
{
  return socket(a2, a3, a4);
}

uint64_t dyld4::SyscallDelegate::connect(dyld4::SyscallDelegate *this, int a2, const sockaddr *a3, socklen_t a4)
{
  return connect(a2, a3, a4);
}

uint64_t dyld4::SyscallDelegate::mremap_encrypted(dyld4::SyscallDelegate *this, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mremap_encrypted(a2, a3, a4, a5, a6, a6, a7, a8);
}

uint64_t PatchTable::patchableExportCount(int **this, unsigned int a2)
{
  int *v2;
  int v3;

  v2 = *this;
  v3 = **this;
  if ((v3 == 4 || v3 == 3 || v3 == 2) && *((_QWORD *)v2 + 2) > (unint64_t)a2)
    return *(unsigned int *)((char *)&v2[4 * a2 + 3] + *((_QWORD *)v2 + 1) - (_QWORD)this[1]);
  else
    return 0;
}

BOOL PatchTable::imageHasClient(PatchTable *this, unsigned int a2, int a3)
{
  return (**(_DWORD **)this - 2) <= 2 && PatchTableV2::imageHasClient(this, a2, a3);
}

BOOL PatchTableV2::imageHasClient(PatchTableV2 *this, unsigned int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  int *v7;
  uint64_t v8;
  int v9;
  _BOOL8 result;
  BOOL v11;

  v3 = *(_QWORD *)this;
  if (*(_QWORD *)(*(_QWORD *)this + 16) <= (unint64_t)a2)
    return 0;
  v4 = *((_QWORD *)this + 1);
  v5 = (unsigned int *)(v3 + *(_QWORD *)(v3 + 8) - v4 + 16 * a2);
  v6 = v5[1];
  if (!v6)
    return 0;
  v7 = (int *)(v3 + *(_QWORD *)(v3 + 40) - v4 + 12 * *v5);
  v8 = 12 * v6 - 12;
  do
  {
    v9 = *v7;
    v7 += 3;
    result = v9 == a3;
    v11 = v9 == a3 || v8 == 0;
    v8 -= 12;
  }
  while (!v11);
  return result;
}

_QWORD *PatchTable::forEachPatchableExport(_QWORD *result, unsigned int a2, uint64_t a3)
{
  if ((*(_DWORD *)*result - 2) <= 2)
    return PatchTableV2::forEachPatchableExport(result, a2, a3);
  return result;
}

_QWORD *PatchTableV2::forEachPatchableExport(_QWORD *result, unsigned int a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v8;
  char *v9;
  _DWORD *v10;
  uint64_t v11;

  v3 = (_QWORD *)*result;
  if (*(_QWORD *)(*result + 16) > (unint64_t)a2)
  {
    v4 = result[1];
    v5 = (uint64_t)&v3[2 * a2] + v3[1] - v4;
    v6 = *(unsigned int *)(v5 + 12);
    if ((_DWORD)v6)
    {
      v8 = v3[12];
      v9 = (char *)v3 + v3[11] - v4;
      v10 = (_DWORD *)((char *)v3 + v3[3] + 8 * *(unsigned int *)(v5 + 8) - v4 + 4);
      v11 = 8 * v6;
      do
      {
        if (v8 < (*v10 & 0xFFFFFFFu))
          abort();
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD, char *, _QWORD))(a3 + 16))(a3, *(v10 - 1), &v9[*v10 & 0xFFFFFFF], *v10 >> 28);
        v10 += 2;
        v11 -= 8;
      }
      while (v11);
    }
  }
  return result;
}

PatchTableV2 *PatchTable::forEachPatchableUseOfExportInImage(PatchTableV2 *a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  int v5;

  v5 = **(_DWORD **)a1;
  if (v5 == 4)
    return (PatchTableV2 *)PatchTableV4::forEachPatchableUseOfExportInImage(a1, a2, a3, a4, a5);
  if (v5 == 3 || v5 == 2)
    return (PatchTableV2 *)PatchTableV2::forEachPatchableUseOfExportInImage(a1, a2, a3, a4, a5);
  return a1;
}

char *PatchTableV2::forEachPatchableUseOfExportInImage(PatchTableV2 *a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *result;
  uint64_t v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  int8x16_t v18;
  unsigned __int32 v19;

  v7 = *(_QWORD *)a1;
  v8 = *((_QWORD *)a1 + 1);
  v9 = *(_QWORD *)(*(_QWORD *)a1 + 24);
  v10 = *(_QWORD *)(*(_QWORD *)a1 + 72);
  result = PatchTableV2::clientsExportsForImageAndClient(a1, a2, a4);
  if (v12)
  {
    v13 = (unsigned int *)(result + 8);
    v14 = 12 * v12;
    while (*(_DWORD *)(v7 + v9 - v8 + 8 * *(v13 - 2)) != a3)
    {
      v13 += 3;
      v14 -= 12;
      if (!v14)
        return result;
    }
    v15 = *v13;
    if ((_DWORD)v15)
    {
      v16 = (unsigned int *)(v10 + 8 * *(v13 - 1) - v8 + v7 + 4);
      v17 = 8 * v15;
      do
      {
        dyld3::MachOFile::PointerMetaData::PointerMetaData(&v19);
        v18 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(*v16), (uint32x4_t)xmmword_1A5CBB420), (int8x16_t)xmmword_1A5CBB430);
        *(int8x8_t *)v18.i8 = vorr_s8(*(int8x8_t *)v18.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL));
        v19 = v18.i32[0] | v19 & 0xF0000000 | v18.i32[1] | HIWORD(*v16);
        result = (char *)(*(uint64_t (**)(uint64_t, _QWORD))(a5 + 16))(a5, *(v16 - 1));
        v16 += 2;
        v17 -= 8;
      }
      while (v17);
    }
  }
  return result;
}

char *PatchTableV4::forEachPatchableUseOfExportInImage(PatchTableV2 *a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *result;
  uint64_t v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;

  v7 = *(_QWORD *)a1;
  v8 = *((_QWORD *)a1 + 1);
  v9 = *(_QWORD *)(*(_QWORD *)a1 + 24);
  v10 = *(_QWORD *)(*(_QWORD *)a1 + 72);
  result = PatchTableV2::clientsExportsForImageAndClient(a1, a2, a4);
  if (v12)
  {
    v13 = (unsigned int *)(result + 8);
    v14 = 12 * v12;
    while (*(_DWORD *)(v7 + v9 - v8 + 8 * *(v13 - 2)) != a3)
    {
      v13 += 3;
      v14 -= 12;
      if (!v14)
        return result;
    }
    v15 = *v13;
    if ((_DWORD)v15)
    {
      v16 = (unsigned int *)(v7 + v10 - v8 + 8 * *(v13 - 1));
      v17 = &v16[2 * v15];
      do
      {
        dyld3::MachOFile::PointerMetaData::PointerMetaData(&v21);
        dyld_cache_patchable_location_v4::getPMD((uint64_t)v16, &v21);
        v18 = *v16;
        v19 = v16[1];
        v16 += 2;
        if ((v19 & 1) != 0)
          v20 = (v19 >> 9) & 0x1F;
        else
          v20 = v19 >> 9;
        result = (char *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD))(a5 + 16))(a5, v18, v21, v20, (v19 >> 8) & 1);
      }
      while (v16 != v17);
    }
  }
  return result;
}

_QWORD *PatchTable::forEachPatchableCacheUseOfExport(_QWORD *result, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;

  v6 = *(_DWORD *)*result;
  if (v6 == 4)
    return PatchTableV4::forEachPatchableCacheUseOfExport(result, a2, a3, a4, a5, a6);
  if (v6 == 3 || v6 == 2)
    return PatchTableV2::forEachPatchableCacheUseOfExport(result, a2, a3, a4, a5, a6);
  return result;
}

_QWORD *PatchTableV2::forEachPatchableCacheUseOfExport(_QWORD *result, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v8;
  uint64_t v9;
  unsigned int *v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int *v13;
  char *v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int *v17;
  char *v18;
  uint64_t v19;
  unsigned int *v20;
  unsigned int *v21;
  char *v22;
  unsigned int v23;
  int8x16_t v24;
  char *v25;
  unsigned int *v27;
  char *v29;
  unsigned __int32 v30;

  v8 = (_QWORD *)*result;
  if (*(_QWORD *)(*result + 16) > (unint64_t)a2)
  {
    v9 = result[1];
    v10 = (unsigned int *)((char *)&v8[2 * a2] + v8[1] - v9);
    v12 = *v10;
    v11 = v10[1];
    v13 = (unsigned int *)((char *)v8 + 12 * v12 + v8[5] - v9);
    if (v11)
    {
      v14 = (char *)v8 + v8[3] - v9;
      v25 = (char *)v8 + v8[7] - v9;
      v29 = (char *)v8 + v8[9] - v9;
      v27 = &v13[3 * v11];
      do
      {
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD))(a5 + 16))(a5, *v13);
        v15 = v13[2];
        if (v15)
        {
          v16 = (unsigned int *)&v25[12 * v13[1]];
          v17 = &v16[3 * v15];
          v18 = (char *)result - a4;
          do
          {
            if (*(_DWORD *)&v14[8 * *v16] == a3)
            {
              v19 = v16[2];
              if ((_DWORD)v19)
              {
                v20 = (unsigned int *)&v29[8 * v16[1]];
                v21 = &v20[2 * v19];
                do
                {
                  v22 = &v18[*v20];
                  dyld3::MachOFile::PointerMetaData::PointerMetaData(&v30);
                  v23 = v20[1];
                  v24 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v23), (uint32x4_t)xmmword_1A5CBB420), (int8x16_t)xmmword_1A5CBB430);
                  *(int8x8_t *)v24.i8 = vorr_s8(*(int8x8_t *)v24.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
                  v30 = v24.i32[0] | v30 & 0xF0000000 | v24.i32[1] | HIWORD(v23);
                  result = (_QWORD *)(*(uint64_t (**)(uint64_t, char *))(a6 + 16))(a6, v22);
                  v20 += 2;
                }
                while (v20 != v21);
              }
            }
            v16 += 3;
          }
          while (v16 != v17);
        }
        v13 += 3;
      }
      while (v13 != v27);
    }
  }
  return result;
}

_QWORD *PatchTableV4::forEachPatchableCacheUseOfExport(_QWORD *result, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v8;
  uint64_t v9;
  unsigned int *v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int *v13;
  char *v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int *v17;
  char *v18;
  uint64_t v19;
  unsigned int *v20;
  unsigned int *v21;
  char *v22;
  unsigned int v23;
  uint64_t v24;
  char *v25;
  unsigned int *v27;
  char *v29;
  unsigned int v30;

  v8 = (_QWORD *)*result;
  if (*(_QWORD *)(*result + 16) > (unint64_t)a2)
  {
    v9 = result[1];
    v10 = (unsigned int *)((char *)&v8[2 * a2] + v8[1] - v9);
    v12 = *v10;
    v11 = v10[1];
    v13 = (unsigned int *)((char *)v8 + 12 * v12 + v8[5] - v9);
    if (v11)
    {
      v14 = (char *)v8 + v8[3] - v9;
      v25 = (char *)v8 + v8[7] - v9;
      v29 = (char *)v8 + v8[9] - v9;
      v27 = &v13[3 * v11];
      do
      {
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD))(a5 + 16))(a5, *v13);
        v15 = v13[2];
        if (v15)
        {
          v16 = (unsigned int *)&v25[12 * v13[1]];
          v17 = &v16[3 * v15];
          v18 = (char *)result - a4;
          do
          {
            if (*(_DWORD *)&v14[8 * *v16] == a3)
            {
              v19 = v16[2];
              if ((_DWORD)v19)
              {
                v20 = (unsigned int *)&v29[8 * v16[1]];
                v21 = &v20[2 * v19];
                do
                {
                  v22 = &v18[*v20];
                  dyld3::MachOFile::PointerMetaData::PointerMetaData(&v30);
                  dyld_cache_patchable_location_v4::getPMD((uint64_t)v20, &v30);
                  v23 = v20[1];
                  if ((v23 & 1) != 0)
                    v24 = (v23 >> 9) & 0x1F;
                  else
                    v24 = v23 >> 9;
                  result = (_QWORD *)(*(uint64_t (**)(uint64_t, char *, _QWORD, uint64_t, _QWORD))(a6 + 16))(a6, v22, v30, v24, (v23 >> 8) & 1);
                  v20 += 2;
                }
                while (v20 != v21);
              }
            }
            v16 += 3;
          }
          while (v16 != v17);
        }
        v13 += 3;
      }
      while (v13 != v27);
    }
  }
  return result;
}

uint64_t PatchTable::forEachPatchableGOTUseOfExport(uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  int v4;

  v4 = **(_DWORD **)result;
  if (v4 == 4)
    return (uint64_t)PatchTableV4::forEachPatchableGOTUseOfExport((_QWORD *)result, a2, a3, a4);
  if (v4 == 3)
    return PatchTableV3::forEachPatchableGOTUseOfExport(result, a2, a3, a4);
  return result;
}

uint64_t PatchTableV3::forEachPatchableGOTUseOfExport(uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  _QWORD *v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  int8x16_t v18;
  unsigned __int32 v19;

  v4 = *(_QWORD **)result;
  if (*(_QWORD *)(*(_QWORD *)result + 112) > (unint64_t)a2)
  {
    v5 = *(_QWORD *)(result + 8);
    v6 = (unsigned int *)((char *)&v4[a2] + v4[13] - v5);
    v7 = v6[1];
    if ((_DWORD)v7)
    {
      v9 = 0;
      v10 = (uint64_t)v4 + 12 * *v6 + v4[15] - v5;
      v11 = v7 - 1;
      while (1)
      {
        v12 = v9 + v11;
        if (v9 + v11 < 0 != __OFADD__(v9, v11))
          ++v12;
        v13 = v12 >> 1;
        result = *(unsigned int *)((char *)&v4[*(unsigned int *)(v10 + 12 * v13)] + v4[3] - v5);
        if ((_DWORD)result == a3)
          break;
        if (result <= a3)
          v9 = v13 + 1;
        else
          v11 = v13 - 1;
        if (v9 > v11)
          return result;
      }
      v14 = v10 + 12 * v13;
      v15 = *(unsigned int *)(v14 + 8);
      if ((_DWORD)v15)
      {
        v16 = (unsigned int *)((char *)v4 + v4[17] + 16 * *(unsigned int *)(v14 + 4) - v5 + 8);
        v17 = 16 * v15;
        do
        {
          dyld3::MachOFile::PointerMetaData::PointerMetaData(&v19);
          v18 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(*v16), (uint32x4_t)xmmword_1A5CBB420), (int8x16_t)xmmword_1A5CBB430);
          *(int8x8_t *)v18.i8 = vorr_s8(*(int8x8_t *)v18.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL));
          v19 = v18.i32[0] | v19 & 0xF0000000 | v18.i32[1] | HIWORD(*v16);
          result = (*(uint64_t (**)(uint64_t, _QWORD))(a4 + 16))(a4, *((_QWORD *)v16 - 1));
          v16 += 4;
          v17 -= 16;
        }
        while (v17);
      }
    }
  }
  return result;
}

_QWORD *PatchTableV4::forEachPatchableGOTUseOfExport(_QWORD *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  _QWORD *v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;

  v4 = (_QWORD *)*result;
  if (*(_QWORD *)(*result + 112) > (unint64_t)a2)
  {
    v5 = result[1];
    v6 = (unsigned int *)((char *)&v4[a2] + v4[13] - v5);
    v7 = v6[1];
    if ((_DWORD)v7)
    {
      v9 = 0;
      v10 = (uint64_t)v4 + 12 * *v6 + v4[15] - v5;
      v11 = v4[17] - v5;
      v12 = (char *)v4 + v4[3] - v5;
      v13 = (char *)v4 + v11;
      v14 = v7 - 1;
      while (1)
      {
        v15 = v9 + v14;
        if (v9 + v14 < 0 != __OFADD__(v9, v14))
          ++v15;
        v16 = v15 >> 1;
        v17 = *(_DWORD *)&v12[8 * *(unsigned int *)(v10 + 12 * v16)];
        if (v17 == a3)
          break;
        if (v17 <= a3)
          v9 = v16 + 1;
        else
          v14 = v16 - 1;
        if (v9 > v14)
          return result;
      }
      v18 = v10 + 12 * v16;
      v19 = *(unsigned int *)(v18 + 8);
      if ((_DWORD)v19)
      {
        v20 = (uint64_t)&v13[16 * *(unsigned int *)(v18 + 4)];
        v21 = v20 + 16 * v19;
        do
        {
          dyld3::MachOFile::PointerMetaData::PointerMetaData(&v24);
          dyld_cache_patchable_location_v4_got::getPMD(v20, &v24);
          v22 = *(_DWORD *)(v20 + 8);
          if ((v22 & 1) != 0)
            v23 = (v22 >> 9) & 0x1F;
          else
            v23 = v22 >> 9;
          result = (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(a4 + 16))(a4, *(_QWORD *)v20, v24, v23, (v22 >> 8) & 1);
          v20 += 16;
        }
        while (v20 != v21);
      }
    }
  }
  return result;
}

char *PatchTableV2::clientsExportsForImageAndClient(PatchTableV2 *this, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v4;
  unsigned int *v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  uint64_t v9;
  uint64_t i;

  v3 = *(_QWORD **)this;
  if (*(_QWORD *)(*(_QWORD *)this + 16) <= (unint64_t)a2)
    return 0;
  v4 = *((_QWORD *)this + 1);
  v5 = (unsigned int *)((char *)&v3[2 * a2] + v3[1] - v4);
  v6 = v5[1];
  if (!(_DWORD)v6)
    return 0;
  v7 = *v5;
  v8 = (char *)v3 + v3[7] - v4;
  v9 = 12 * v6;
  for (i = (uint64_t)v3 + v3[5] + 12 * v7 - v4 + 8; *(_DWORD *)(i - 8) != a3; i += 12)
  {
    v9 -= 12;
    if (!v9)
      return 0;
  }
  return &v8[12 * *(unsigned int *)(i - 4)];
}

uint64_t dyld_cache_patchable_location_v4::getPMD(uint64_t result, unsigned int *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  if ((*(_DWORD *)(result + 4) & 1) != 0)
  {
    HIDWORD(v5) = *((unsigned __int16 *)a2 + 1);
    LODWORD(v5) = *(_DWORD *)(result + 4);
    v4 = v5 >> 16;
    *a2 = v4;
    v6 = v4 & 0xFF00FFFF | (((*(_DWORD *)(result + 4) >> 1) & 0x7F) << 17);
    *a2 = v6;
    v7 = v6 & 0xFEFFFFFF | ((*(_DWORD *)(result + 4) & 1) << 24);
    *a2 = v7;
    v8 = v7 & 0xF9FFFFFF | (*(_DWORD *)(result + 4) << 11) & 0x4000000;
    *a2 = v8;
    v3 = v8 & 0xF7FFFFFF | (*(_DWORD *)(result + 4) << 13) & 0x8000000;
  }
  else
  {
    v2 = *a2;
    *a2 &= 0xFFFF0000;
    v3 = v2 & 0xF0000000 | (((*(_DWORD *)(result + 4) >> 1) & 0x7F) << 17);
  }
  *a2 = v3;
  return result;
}

uint64_t dyld_cache_patchable_location_v4_got::getPMD(uint64_t result, unsigned int *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  if ((*(_DWORD *)(result + 8) & 1) != 0)
  {
    HIDWORD(v5) = *((unsigned __int16 *)a2 + 1);
    LODWORD(v5) = *(_DWORD *)(result + 8);
    v4 = v5 >> 16;
    *a2 = v4;
    v6 = v4 & 0xFF00FFFF | (((*(_DWORD *)(result + 8) >> 1) & 0x7F) << 17);
    *a2 = v6;
    v7 = v6 & 0xFEFFFFFF | ((*(_DWORD *)(result + 8) & 1) << 24);
    *a2 = v7;
    v8 = v7 & 0xF9FFFFFF | (*(_DWORD *)(result + 8) << 11) & 0x4000000;
    *a2 = v8;
    v3 = v8 & 0xF7FFFFFF | (*(_DWORD *)(result + 8) << 13) & 0x8000000;
  }
  else
  {
    v2 = *a2;
    *a2 &= 0xFFFF0000;
    v3 = v2 & 0xF0000000 | (((*(_DWORD *)(result + 8) >> 1) & 0x7F) << 17);
  }
  *a2 = v3;
  return result;
}

uint64_t dyld4::FileManager::fsidForUUID(dyld4::FileManager *this, const UUID *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  _BYTE v50[15];
  unsigned __int8 v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  _QWORD v60[3];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  _BYTE v68[23];

  v5 = *((_QWORD *)this + 2);
  v53 = 0u;
  v54 = 0u;
  v55 = 0u;
  v56 = 0u;
  v57 = 0u;
  v58 = 0u;
  v59 = 0u;
  memset(v60, 0, sizeof(v60));
  v52 = v5;
  v6 = lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)&v52, (uint64_t)a2, a3);
  v7 = *(_QWORD *)v6;
  v8 = *(_OWORD *)(v6 + 104);
  v9 = *(_OWORD *)(v6 + 88);
  v10 = *(_QWORD *)(v6 + 120);
  v11 = *(_QWORD *)(v6 + 128);
  v46 = *(_OWORD *)(v6 + 72);
  v47 = v9;
  v48 = v8;
  v49 = v10;
  v12 = *(_OWORD *)(v6 + 56);
  v13 = *(_OWORD *)(v6 + 40);
  v14 = *(_OWORD *)(v6 + 24);
  v42 = *(_OWORD *)(v6 + 8);
  v43 = v14;
  v44 = v13;
  v45 = v12;
  *(_QWORD *)&v50[7] = *(_QWORD *)(v6 + 135);
  *(_QWORD *)v50 = v11;
  LOBYTE(v10) = *(_BYTE *)(v6 + 143);
  v41 = v7;
  v51 = v10;
  v67 = 0u;
  memset(v68, 0, sizeof(v68));
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v53 = 0u;
  v54 = 0u;
  v55 = 0u;
  v56 = 0u;
  v57 = 0u;
  v58 = 0u;
  v59 = 0u;
  v52 = v5;
  memset(v60, 0, sizeof(v60));
  if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v41, (uint64_t)&v52))
  {
    while (1)
    {
      v17 = 0;
      v18 = *((_QWORD *)&v42 + v51 - 1) + 24 * v50[v51 - 1];
      do
      {
        v19 = *(unsigned __int8 *)(v18 + 8 + v17);
        v20 = (*a2)[v17];
      }
      while (v19 == v20 && v17++ != 15);
      if (v19 == v20)
        break;
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)&v41, v15, v16);
      if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v41, (uint64_t)&v52))goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    dyld4::FileManager::reloadFSInfos(this);
    v22 = *((_QWORD *)this + 2);
    v53 = 0u;
    v54 = 0u;
    v55 = 0u;
    v56 = 0u;
    v57 = 0u;
    v58 = 0u;
    v59 = 0u;
    memset(v60, 0, sizeof(v60));
    v52 = v22;
    v25 = lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)&v52, v23, v24);
    v26 = *(_QWORD *)v25;
    v27 = *(_OWORD *)(v25 + 104);
    v28 = *(_OWORD *)(v25 + 88);
    v29 = *(_QWORD *)(v25 + 120);
    v30 = *(_QWORD *)(v25 + 128);
    v46 = *(_OWORD *)(v25 + 72);
    v47 = v28;
    v48 = v27;
    v49 = v29;
    v31 = *(_OWORD *)(v25 + 56);
    v32 = *(_OWORD *)(v25 + 40);
    v33 = *(_OWORD *)(v25 + 24);
    v42 = *(_OWORD *)(v25 + 8);
    v43 = v33;
    v44 = v32;
    v45 = v31;
    *(_QWORD *)&v50[7] = *(_QWORD *)(v25 + 135);
    *(_QWORD *)v50 = v30;
    LOBYTE(v29) = *(_BYTE *)(v25 + 143);
    v41 = v26;
    v51 = v29;
    v67 = 0u;
    memset(v68, 0, sizeof(v68));
    v65 = 0u;
    v66 = 0u;
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    v53 = 0u;
    v54 = 0u;
    v55 = 0u;
    v56 = 0u;
    v57 = 0u;
    v58 = 0u;
    v59 = 0u;
    v52 = v22;
    memset(v60, 0, sizeof(v60));
    if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v41, (uint64_t)&v52))return 0;
    while (1)
    {
      v36 = 0;
      v18 = *((_QWORD *)&v42 + v51 - 1) + 24 * v50[v51 - 1];
      do
      {
        v37 = *(unsigned __int8 *)(v18 + 8 + v36);
        v38 = (*a2)[v36];
      }
      while (v37 == v38 && v36++ != 15);
      if (v37 == v38)
        break;
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)&v41, v34, v35);
      if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v41, (uint64_t)&v52))return 0;
    }
  }
  return *(_QWORD *)v18;
}

char *dyld4::FileManager::getPath@<X0>(char *this@<X0>, fsid_t a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  char *v6;
  char __s[1024];

  if (*(_QWORD *)&a2 && a3)
  {
    v6 = this;
    if (dyld4::SyscallDelegate::fsgetpath(*(dyld4::SyscallDelegate **)this, __s, 0x400uLL, a2, a3) == -1)
      this = 0;
    else
      this = lsl::Allocator::strdup(*((lsl::Allocator **)v6 + 1), __s);
    *a4 = this;
  }
  else
  {
    *a4 = 0;
  }
  return this;
}

uint64_t lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *(unsigned __int8 *)(result + 143);
  v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 143))
  {
    v5 = *((unsigned __int8 *)v4 + 32);
    v6 = result + 128;
    ++*(_BYTE *)(result + 128 + (v3 - 1));
    if (v3 == v5)
    {
      v7 = *((unsigned __int8 *)v4 + 32);
      if (v7)
      {
        for (i = 0; i != v7; ++i)
        {
          if (*(_BYTE *)(v6 + (v7 + ~(_BYTE)i)) != (*(_BYTE *)(*(_QWORD *)(result
                                                                                           + 8
                                                                                           + 8
                                                                                           * (v7 + ~(_BYTE)i))
                                                                               + 240) & 0x7F))
            break;
          *(_BYTE *)(result + 143) = v7 + ~(_BYTE)i;
        }
      }
    }
    else
    {
      v15 = *(unsigned __int8 *)(result + 143);
      if (v15 != *((unsigned __int8 *)v4 + 32))
      {
        v16 = result + 8;
        do
        {
          v17 = *(_QWORD *)(v16 + 8 * (v15 - 1));
          if (*(char *)(v17 + 240) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
          *(_QWORD *)(v16 + 8 * v15) = *(_QWORD *)(v17
                                                                    + 8
                                                                    * *(unsigned __int8 *)(v6
                                                                                         + v15
                                                                                         - 1)
                                                                    + 168);
          *(_BYTE *)(v6 + v15) = 0;
          LOBYTE(v15) = *(_BYTE *)(result + 143) + 1;
          *(_BYTE *)(result + 143) = v15;
        }
        while (*((unsigned __int8 *)v4 + 32) != v15);
      }
    }
  }
  else
  {
    v9 = *v4;
    *(_BYTE *)(result + 143) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      v10 = 0;
      v11 = result + 8;
      do
      {
        *(_QWORD *)(v11 + 8 * v10) = v9;
        *(_BYTE *)(result + 128 + v10) = 0;
        v12 = *(unsigned __int8 *)(result + 143);
        v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          v14 = *(_QWORD *)(v11 + 8 * v12);
          if (*(char *)(v14 + 240) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
          v9 = *(_QWORD *)(v14 + 168);
        }
        v10 = v12 + 1;
        *(_BYTE *)(result + 143) = v10;
      }
      while (v13 > v10);
    }
  }
  return result;
}

void OUTLINED_FUNCTION_0_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 140, a4);
}

double lsl::MemoryManager::MemoryManager(lsl::MemoryManager *this, const char **a2, const char **a3, void *a4)
{
  double result;

  *((_QWORD *)this + 8) = 0;
  result = 0.0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 4) = a4;
  return result;
}

uint64_t lsl::MemoryManager::setDyldCacheAddr(uint64_t this, void *a2)
{
  *(_QWORD *)(this + 32) = a2;
  return this;
}

__n128 lsl::MemoryManager::adoptLock(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

size_t lsl::appendHexToString<unsigned long long>(char *a1, uint64_t a2)
{
  int8x8_t v2;
  char *v3;
  char v5[136];
  int8x8x2_t v6;

  v6.val[0] = (int8x8_t)vsra_n_u8((uint8x8_t)vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)0xA0A0A0A0A0A0A0A0, (uint8x8_t)a2), (int8x8_t)0x3030303030303030, (int8x8_t)0x5757575757575757), (uint8x8_t)a2, 4uLL);
  v2 = vand_s8((int8x8_t)a2, (int8x8_t)0xF0F0F0F0F0F0F0FLL);
  v6.val[1] = vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)0xA0A0A0A0A0A0A0ALL, (uint8x8_t)v2), (int8x8_t)0x3030303030303030, (int8x8_t)0x5757575757575757), v2);
  v3 = v5;
  vst2_s8(v3, v6);
  v3 += 16;
  *v3 = 0;
  return strlcat(a1, v5, 0x400uLL);
}

size_t lsl::appendHexToString<int>(char *a1, __int32 a2, int8x8_t a3)
{
  int8x8_t v3;
  int16x4_t v4;
  int8x8_t v6;
  char v7;

  a3.i32[0] = a2;
  v3 = vzip1_s8(a3, a3);
  v4 = (int16x4_t)vand_s8(v3, (int8x8_t)0xF000F000F000FLL);
  v6 = vtrn1_s8((int8x8_t)vsra_n_u16((uint16x4_t)vbsl_s8((int8x8_t)vcgt_u16((uint16x4_t)0xA000A000A000A0, (uint16x4_t)(*(_QWORD *)&v3 & 0xFF00FF00FF00FFLL)), (int8x8_t)0x30003000300030, (int8x8_t)0x57005700570057), (uint16x4_t)(*(_QWORD *)&v3 & 0xFF00FF00FF00FFLL), 4uLL), (int8x8_t)vadd_s16((int16x4_t)vbsl_s8((int8x8_t)vcgt_u16((uint16x4_t)0xA000A000A000ALL, (uint16x4_t)v4), (int8x8_t)0x30003000300030, (int8x8_t)0x57005700570057), v4));
  v7 = 0;
  return strlcat(a1, (const char *)&v6, 0x400uLL);
}

uint64_t lsl::Allocator::forEachVMAllocatedBuffer(uint64_t result, uint64_t a2)
{
  _QWORD *v2;
  unint64_t v4;
  uint64_t v5;
  _QWORD v6[2];

  v2 = *(_QWORD **)(result + 8);
  if (v2)
  {
    while (1)
    {
      v4 = v2[4];
      if ((unint64_t)v2 < v4)
        break;
      v5 = v2[5];
      if ((unint64_t)(v2 + 6) > v5 + v4)
        goto LABEL_5;
LABEL_6:
      v2 = (_QWORD *)v2[2];
      if (!v2)
        return result;
    }
    v5 = v2[5];
LABEL_5:
    v6[0] = v2[4];
    v6[1] = v5;
    result = (*(uint64_t (**)(uint64_t, _QWORD *))(a2 + 16))(a2, v6);
    goto LABEL_6;
  }
  return result;
}

uint64_t ___ZN3lsl13MemoryManager12writeProtectEb_block_invoke(uint64_t a1, vm_address_t *a2)
{
  vm_prot_t v2;

  if (*(_BYTE *)(a1 + 32))
    v2 = 1;
  else
    v2 = 3;
  return vm_protect(mach_task_self_, *a2, a2[1], 0, v2);
}

_OWORD *lsl::Allocator::stackAllocatorInternal(lsl::Allocator *this, char *a2, const char **a3, const char **a4)
{
  char *v5;
  char *v6;
  _OWORD *v7;

  if (!this)
    lsl::Allocator::stackAllocatorInternal();
  if (!a2)
    lsl::Allocator::stackAllocatorInternal();
  if ((unint64_t)a2 < 0xB0
    || (v5 = (char *)(((unint64_t)this + 15) & 0xFFFFFFFFFFFFFFF0),
        v6 = (char *)(v5 - (char *)this),
        v6 > a2 - 176))
  {
    lsl::Allocator::stackAllocatorInternal();
  }
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  v7 = v5 + 80;
  lsl::AllocatorLayout::init((lsl::AllocatorLayout *)v5, a2 - v6, a3, a4, 0);
  return v7;
}

lsl::Allocator::Pool *lsl::AllocatorLayout::init(lsl::AllocatorLayout *this, unint64_t a2, const char **a3, const char **a4, void *a5)
{
  lsl::Allocator::Pool *result;

  if (a2 <= 0xAF)
    lsl::AllocatorLayout::init();
  *((_QWORD *)this + 8) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 4) = a5;
  result = lsl::Allocator::Pool::Pool((unint64_t)this + 128, (uint64_t)this + 80, 0, (unint64_t)this, a2, (unint64_t *)this + 22, a2 - 176);
  *((_QWORD *)this + 10) = result;
  *((_QWORD *)this + 11) = result;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_BYTE *)this + 112) = 0;
  *((_QWORD *)this + 15) = this;
  return result;
}

uint64_t lsl::AllocatorLayout::allocator(lsl::AllocatorLayout *this)
{
  return (uint64_t)this + 80;
}

uint64_t lsl::Allocator::owned(lsl::Allocator *this, unint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = (_QWORD *)*((_QWORD *)this + 1);
  if (!v3)
    return 0;
  while (1)
  {
    v4 = v3[4];
    if (v4 <= a2 && a2 + a3 <= v3[5] + v4)
      break;
    v3 = (_QWORD *)v3[2];
    if (!v3)
      return 0;
  }
  return 1;
}

uint64_t ___ZN3lsl9AllocatorD2Ev_block_invoke(uint64_t a1, vm_address_t *a2)
{
  return vm_deallocate(mach_task_self_, *a2, a2[1]);
}

uint64_t lsl::Allocator::memoryManager(lsl::Allocator *this)
{
  return *((_QWORD *)this + 5);
}

void lsl::Allocator::~Allocator(lsl::Allocator *this)
{
  _QWORD v1[5];

  v1[0] = _NSConcreteStackBlock;
  v1[1] = 0x40000000;
  v1[2] = ___ZN3lsl9AllocatorD2Ev_block_invoke;
  v1[3] = &__block_descriptor_tmp_16;
  v1[4] = this;
  lsl::Allocator::forEachVMAllocatedBuffer((uint64_t)this, (uint64_t)v1);
}

lsl::Allocator::Pool *lsl::Allocator::Pool::aligned_alloc_best_fit(lsl::Allocator::Pool *this, uint64_t a2, unint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v10;
  lsl::Allocator::Pool *v11;

  if (a2 != 16)
    return (lsl::Allocator::Pool *)lsl::Allocator::Pool::aligned_alloc(this, a2, a3);
  v4 = (_QWORD *)**((_QWORD **)this + 3);
  if ((v4 & 1) != 0 || !v4)
    return (lsl::Allocator::Pool *)lsl::Allocator::Pool::aligned_alloc(this, a2, a3);
  v5 = 0;
  v6 = -1;
  do
  {
    v7 = v4[1];
    if ((v7 & 1) == 0)
    {
      v8 = (v7 & 0xFFFFFFFFFFFFFFFCLL) - (_QWORD)v4 - 16;
      if (v8 >= a3)
      {
        if (v8 - a3 < v6)
        {
          v5 = v4;
          v6 = v8 - a3;
        }
        if (v8 == a3)
        {
          v5 = v4;
          goto LABEL_16;
        }
      }
    }
    v4 = (_QWORD *)*v4;
  }
  while ((v4 & 1) == 0 && v4);
  if (!v5)
  {
    a2 = 16;
    return (lsl::Allocator::Pool *)lsl::Allocator::Pool::aligned_alloc(this, a2, a3);
  }
LABEL_16:
  v10 = v5[1];
  if ((v10 & 1) != 0)
    lsl::Allocator::Pool::aligned_alloc_best_fit();
  v11 = (lsl::Allocator::Pool *)(v5 + 2);
  v5[1] = v10 | 1;
  if ((v10 & 0xFFFFFFFFFFFFFFFCLL) - (unint64_t)v5 - 16 > a3)
    lsl::Allocator::AllocationMetadata::returnToNext((lsl::Allocator::AllocationMetadata *)v5, a3);
  if (v11 == this)
    lsl::Allocator::Pool::aligned_alloc_best_fit();
  return v11;
}

_QWORD *lsl::Allocator::Pool::aligned_alloc(lsl::Allocator::Pool *this, uint64_t a2, uint64_t a3)
{
  lsl::Allocator::AllocationMetadata *v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v6 = (lsl::Allocator::AllocationMetadata *)*((_QWORD *)this + 3);
  if ((lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(v6, 1) != this)
    lsl::Allocator::Pool::aligned_alloc();
  v7 = (*((_QWORD *)v6 + 1) & 0xFFFFFFFFFFFFFFFCLL) - (_QWORD)v6 - 16;
  v8 = 0;
  if (v7 >= a3 + 16)
  {
    v9 = ((unint64_t)v6 + a2 + 15) & -a2;
    if (v9 - ((uint64_t)v6 + 16) <= v7 - (a3 + 16))
    {
      if ((lsl::Allocator::AllocationMetadata *)((char *)v6 + 16) != (lsl::Allocator::AllocationMetadata *)v9)
      {
        lsl::Allocator::AllocationMetadata::reserve(v6, (unsigned __int16)(v9 - (_WORD)v6 - 32), 0);
        v6 = (lsl::Allocator::AllocationMetadata *)*((_QWORD *)this + 3);
      }
      v8 = (_QWORD *)((char *)v6 + 16);
      lsl::Allocator::AllocationMetadata::reserve(v6, a3, 1u);
      if ((lsl::Allocator::AllocationMetadata *)((char *)v6 + 16) == this)
        lsl::Allocator::Pool::aligned_alloc();
    }
  }
  return v8;
}

const os_unfair_lock *lsl::Allocator::freeObject(const os_unfair_lock *this, void *a2)
{
  os_unfair_lock *v2;
  lsl::Allocator **v3;

  if (this)
  {
    v2 = (os_unfair_lock *)this;
    v3 = (lsl::Allocator **)lsl::Allocator::AllocationMetadata::pool((lsl::Allocator::AllocationMetadata *)&this[-4], 1);
    return lsl::Allocator::free(*v3, v2);
  }
  return this;
}

uint64_t lsl::Allocator::AllocationMetadata::forPtr(lsl::Allocator::AllocationMetadata *this, void *a2)
{
  return (uint64_t)this - 16;
}

unint64_t lsl::Allocator::AllocationMetadata::pool(lsl::Allocator::AllocationMetadata *this, int a2)
{
  lsl::Allocator::AllocationMetadata *i;
  uint64_t v4;
  unint64_t result;

  for (i = *(lsl::Allocator::AllocationMetadata **)this;
        i && (i & 1) == 0;
        i = *(lsl::Allocator::AllocationMetadata **)i)
  {
    if (a2)
    {
      v4 = *((_QWORD *)this + 1);
      if ((v4 & 1) == 0 && (((v4 & 0xFFFFFFFFFFFFFFFCLL) - (_QWORD)this) & 0xFFFFFFFFFFFFFFF8) != 0x10)
      {
        result = *((_QWORD *)this + 2);
        if (result)
          return result;
      }
    }
    this = i;
  }
  return (unint64_t)i & 0xFFFFFFFFFFFFFFFELL;
}

_QWORD *lsl::Allocator::AllocationMetadata::deallocate(lsl::Allocator::AllocationMetadata *this)
{
  uint64_t v1;
  lsl::Allocator::Pool *v3;

  v1 = *((_QWORD *)this + 1);
  if ((v1 & 1) == 0)
    lsl::Allocator::AllocationMetadata::deallocate();
  v3 = (lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(this, 1);
  *((_QWORD *)this + 1) = v1 & 0xFFFFFFFFFFFFFFFCLL;
  return lsl::Allocator::AllocationMetadata::coalesce(this, v3);
}

uint64_t lsl::Allocator::realloc(lsl::Allocator *this, _QWORD *a2, unint64_t a3)
{
  lsl::Lock *v6;
  lsl::Allocator::AllocationMetadata *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;

  v6 = (lsl::Lock *)*((_QWORD *)this + 5);
  lsl::Lock::lock(v6);
  if (!a2)
    goto LABEL_6;
  v7 = (lsl::Allocator::AllocationMetadata *)(a2 - 2);
  v8 = 16;
  if (a3 > 0x10)
    v8 = a3;
  v9 = (v8 + 15) & 0xFFFFFFFFFFFFFFF0;
  v10 = (*(a2 - 1) & 0xFFFFFFFFFFFFFFFCLL) - (_QWORD)v7;
  if (v10 - 16 >= v9)
  {
    if (v10 - 16 > v9)
      lsl::Allocator::AllocationMetadata::returnToNext(v7, v9);
    goto LABEL_9;
  }
  if (lsl::Allocator::AllocationMetadata::consumeFromNext(v7, v9))
  {
LABEL_9:
    *((_QWORD *)this + 2) += v9 - v10 + 16;
    v11 = 1;
    goto LABEL_10;
  }
LABEL_6:
  v11 = 0;
LABEL_10:
  lsl::Lock::unlock(v6);
  return v11;
}

uint64_t lsl::Allocator::AllocationMetadata::consumeFromNext(lsl::Allocator::AllocationMetadata *this, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  char *v7;
  char *v8;
  unint64_t v9;
  uint64_t result;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v2 & 2) != 0)
    v4 = 0;
  else
    v4 = v2 & 0xFFFFFFFFFFFFFFFCLL;
  v5 = *(_QWORD *)(v4 + 8);
  if ((v5 & 1) != 0)
    return 0;
  v7 = (char *)this + a2 + 16;
  v8 = &v7[-v3];
  v9 = (v5 & 0xFFFFFFFFFFFFFFFCLL) - v4;
  if (v9 - 16 >= (unint64_t)&v7[-v3])
  {
    lsl::Allocator::AllocationMetadata::AllocationMetadata((unint64_t)v7, this, v9 - 16 - (_QWORD)&v7[-v3], v5 & 3, v2 & 3);
    return 1;
  }
  result = 0;
  if ((v5 & 2) == 0 && v8 == (char *)v9)
  {
    *((_QWORD *)this + 1) = v5 | 1;
    *(_QWORD *)(v5 & 0xFFFFFFFFFFFFFFFCLL) = this;
    return 1;
  }
  return result;
}

_QWORD *lsl::Allocator::AllocationMetadata::returnToNext(lsl::Allocator::AllocationMetadata *this, uint64_t a2)
{
  lsl::Allocator::Pool *v4;
  uint64_t v5;
  lsl::Allocator::AllocationMetadata *v6;

  v4 = (lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(this, 1);
  lsl::Allocator::AllocationMetadata::AllocationMetadata((unint64_t)this + a2 + 16, this, (*((_QWORD *)this + 1) & 0xFFFFFFFFFFFFFFFCLL) - ((_QWORD)this + a2) - 32, 0, *((_QWORD *)this + 1) & 3);
  v5 = *((_QWORD *)this + 1);
  if ((v5 & 2) != 0)
    v6 = 0;
  else
    v6 = (lsl::Allocator::AllocationMetadata *)(v5 & 0xFFFFFFFFFFFFFFFCLL);
  return lsl::Allocator::AllocationMetadata::coalesce(v6, v4);
}

unint64_t lsl::Allocator::size(lsl::Allocator *this, _QWORD *a2)
{
  if (a2)
    return (*(a2 - 1) & 0xFFFFFFFFFFFFFFFCLL) - (_QWORD)a2;
  else
    return 0;
}

lsl::Allocator::Pool *lsl::Allocator::Pool::Pool(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  _OWORD *v8;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = a4;
  *(_QWORD *)(a1 + 40) = a5;
  if ((unint64_t)a6 < a4 || (unint64_t)a6 + a7 > a5 + a4)
    lsl::Allocator::Pool::Pool();
  *a6 = a1 | 1;
  a6[1] = ((unint64_t)a6 + (a7 & 0xFFFFFFFFFFFFFFF0)) | 2;
  *(_QWORD *)(a1 + 24) = a6;
  v8 = lsl::Allocator::Pool::aligned_alloc((lsl::Allocator::Pool *)a1, 16, 48);
  *v8 = 0u;
  v8[1] = 0u;
  v8[2] = 0u;
  *(_QWORD *)(a1 + 8) = v8;
  return (lsl::Allocator::Pool *)a1;
}

unint64_t lsl::Allocator::AllocationMetadata::reserve(lsl::Allocator::AllocationMetadata *this, uint64_t a2, unsigned int a3)
{
  uint64_t v3;

  v3 = *((_QWORD *)this + 1);
  if ((v3 & 1) != 0)
    lsl::Allocator::AllocationMetadata::reserve();
  return lsl::Allocator::AllocationMetadata::AllocationMetadata((unint64_t)this + a2 + 16, this, (v3 & 0xFFFFFFFFFFFFFFFCLL) - ((_QWORD)this + a2) - 32, 2, a3);
}

uint64_t lsl::Allocator::setBestFit(uint64_t this, char a2)
{
  *(_BYTE *)(this + 32) = a2;
  return this;
}

unint64_t lsl::Allocator::AllocationMetadata::AllocationMetadata(unint64_t this, lsl::Allocator::AllocationMetadata *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  v10 = lsl::Allocator::AllocationMetadata::pool(a2, 1);
  if (!v10)
    lsl::Allocator::AllocationMetadata::AllocationMetadata();
  *(_QWORD *)this = a2;
  if ((a4 & 2) != 0)
  {
    *(_QWORD *)(v10 + 24) = this;
  }
  else
  {
    v11 = *((_QWORD *)a2 + 1);
    if ((v11 & 2) != 0)
      v12 = 0;
    else
      v12 = (_QWORD *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
    *v12 = this;
  }
  *((_QWORD *)a2 + 1) = this | a5;
  v13 = (this + 16 + a3) | a4;
  *(_QWORD *)(this + 8) = v13;
  if ((v13 & 1) == 0 && (((v13 & 0xFFFFFFFFFFFFFFFCLL) - this) & 0xFFFFFFFFFFFFFFF8) != 0x10)
    *(_QWORD *)(this + 16) = v10;
  if ((v13 & 2) == 0)
    *(_QWORD *)(v13 & 0xFFFFFFFFFFFFFFFCLL) = this;
  return this;
}

_QWORD *lsl::Allocator::AllocationMetadata::setPoolHint(_QWORD *this, lsl::Allocator::Pool *a2)
{
  uint64_t v2;
  _QWORD *v3;
  lsl::Allocator::AllocationMetadata *v4;

  v2 = this[1];
  if ((v2 & 1) == 0)
  {
    v3 = this;
    if ((((v2 & 0xFFFFFFFFFFFFFFFCLL) - (_QWORD)this) & 0xFFFFFFFFFFFFFFF8) != 0x10)
    {
      if (!a2)
      {
        if ((*this & 1) != 0)
          v4 = 0;
        else
          v4 = (lsl::Allocator::AllocationMetadata *)*this;
        this = (_QWORD *)lsl::Allocator::AllocationMetadata::pool(v4, 1);
        a2 = (lsl::Allocator::Pool *)this;
        if (!this)
          lsl::Allocator::AllocationMetadata::setPoolHint();
      }
      v3[2] = a2;
    }
  }
  return this;
}

_QWORD *lsl::Allocator::AllocationMetadata::coalesce(lsl::Allocator::AllocationMetadata *this, lsl::Allocator::Pool *a2)
{
  uint64_t v3;
  uint64_t v4;
  lsl::Allocator::AllocationMetadata *v5;
  BOOL v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v3 = *((_QWORD *)this + 1);
  if ((v3 & 2) == 0 && (v3 & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    v4 = *(_QWORD *)((v3 & 0xFFFFFFFFFFFFFFFCLL) + 8);
    if ((v4 & 1) == 0)
    {
      *((_QWORD *)this + 1) = v4;
      if ((v4 & 2) == 0)
        *(_QWORD *)(v4 & 0xFFFFFFFFFFFFFFFCLL) = this;
      v3 = v4;
    }
  }
  v5 = *(lsl::Allocator::AllocationMetadata **)this;
  if (*(_QWORD *)this)
    v6 = (*(_QWORD *)this & 1) == 0;
  else
    v6 = 0;
  if (!v6 || (*((_BYTE *)v5 + 8) & 1) != 0)
  {
    v5 = this;
  }
  else
  {
    *((_QWORD *)v5 + 1) = v3;
    if ((v3 & 2) == 0)
    {
      v7 = *((_QWORD *)this + 1);
      if ((v7 & 2) != 0)
        v8 = 0;
      else
        v8 = (_QWORD *)(v7 & 0xFFFFFFFFFFFFFFFCLL);
      *v8 = v5;
    }
  }
  result = lsl::Allocator::AllocationMetadata::setPoolHint(v5, a2);
  if ((*((_BYTE *)v5 + 8) & 2) != 0)
    *((_QWORD *)a2 + 3) = v5;
  return result;
}

uint64_t lsl::AllocatorLayout::minSize(lsl::AllocatorLayout *this)
{
  return 256;
}

size_t OUTLINED_FUNCTION_0_1(uint64_t a1, const char *a2)
{
  char *v2;

  return strlcat(v2, a2, 0x400uLL);
}

size_t OUTLINED_FUNCTION_1_1(uint64_t a1, uint64_t a2)
{
  char *v2;

  return lsl::appendHexToString<unsigned long long>(v2, a2);
}

uint64_t dyld3::mapSplitCachePrivate(unsigned int *a1, uint64_t a2)
{
  unsigned int *v3;
  uint64_t v4;
  const char *v5;
  const char *v6;
  uint64_t i;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t v10;
  const char *v11;
  const char *v12;
  dyld3 *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  int *v23;
  uint64_t v24;
  char *v26;
  size_t v27;
  const DyldSharedCache *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  char v41;
  _DWORD **v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  _DWORD *v46;
  int v47;
  uint64_t v48;
  int v49;
  unint64_t v50;
  uint64_t v51;
  vm_address_t v52;
  vm_size_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  unsigned int v59;
  uint64_t v60;
  char *v61;
  size_t v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  char *v76;
  unsigned int v77;
  uint64_t v78;
  char *v79;
  _DWORD *v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  unsigned int v85;
  const char *v86;
  uint64_t v87;
  __int128 *v88;
  uint64_t v89;
  const mwl_region *v90;
  uint64_t v91;
  uint64_t v92;
  mwl_region *v93;
  __int128 v94;
  __int128 v95;
  uint64_t v96;
  const char *v97;
  int v98;
  uint64_t v99;
  uint64_t *v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  uint64_t v108;
  int v109;
  uint64_t v110;
  unint64_t v111;
  char v112;
  unsigned int v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  BOOL v117;
  unint64_t v118;
  uint64_t v119;
  unsigned __int16 v120;
  unint64_t v121;
  uint64_t v122;
  char v123;
  int v124;
  unsigned int v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  unint64_t v129;
  uint64_t v130;
  int v131;
  const char *v132;
  unint64_t v133;
  unint64_t v134;
  int v135;
  unint64_t v136;
  uint64_t v137;
  _QWORD *v138;
  unint64_t v139;
  int *v140;
  uint64_t v141;
  uint64_t *v142;
  uint64_t *v143;
  _BYTE *v144;
  uint64_t v145;
  vm_address_t *v146;
  uint64_t v147;
  unsigned int *v148;
  unsigned int v149;
  unsigned int *v150;
  int *v151;
  uint64_t v152;
  uint64_t v153;
  int v154;
  uint64_t v155;
  int v156;
  int v157;
  uint64_t v158;
  _QWORD v159[5];
  char *v160;
  vm_size_t v161;
  uint64_t v162;
  char *v163;
  vm_size_t v164;
  _QWORD v165[5];
  _OWORD v166[256];
  _QWORD v167[48];
  char v168;
  int v169;
  unsigned int v170;
  uint64_t v171;
  _QWORD v172[3];
  char v173;
  fsid_t v174;
  uint64_t v175;
  char v176;
  uint64_t v177[3];
  uint64_t v178;
  _BYTE v179[352];
  unsigned int v180;
  _QWORD v181[49];
  _BYTE v182[56];
  uint64_t v183;
  _OWORD v184[16];

  v3 = a1;
  v168 = 0;
  v169 = 0;
  memset(v184, 0, sizeof(v184));
  LOBYTE(v4) = 0;
  if (!dyld3::preflightMainCacheFile(a1, a2, (uint64_t)v167, (char *)v184, v166))
    return v4 & 1;
  if (*((_BYTE *)v3 + 6) && fsgetpath((char *)v181, 0x400uLL, (fsid_t *)(a2 + 32), *(_QWORD *)(a2 + 40)) >= 1)
    dyld4::console((dyld4 *)"mapped dyld cache file private to process (%s):\n", v5, v181);
  v152 = v170;
  if (v170 && !v168)
  {
    LOBYTE(v4) = 0;
    v6 = "shared cache is too old, missing subcache suffixes";
LABEL_8:
    *(_QWORD *)(a2 + 16) = v6;
    return v4 & 1;
  }
  for (i = 0; i != 7168; i += 56)
  {
    v8 = &v181[i];
    *((_BYTE *)v8 + 389) = 0;
    *((_DWORD *)v8 + 98) = 0;
  }
  if (v152 >= 2)
  {
    v9 = &v183;
    v10 = v152 - 1;
    v11 = (const char *)v166;
    while (1)
    {
      memset(v172, 0, sizeof(v172));
      v173 = 0;
      v174 = 0;
      v175 = 0;
      v176 = 0;
      if (!dyld3::preflightSubCacheFile(v3, (uint64_t)v172, (uint64_t)v9, (char *)v184, v11))
        break;
      if (*((_BYTE *)v3 + 6))
      {
        bzero(v177, 0x400uLL);
        if (fsgetpath((char *)v177, 0x400uLL, &v174, v175) >= 1)
          dyld4::console((dyld4 *)"mapped dyld cache file private to process (%s):\n", v12, v177);
      }
      v9 += 56;
      v11 += 32;
      if (!--v10)
        goto LABEL_18;
    }
LABEL_32:
    LOBYTE(v4) = 0;
    return v4 & 1;
  }
LABEL_18:
  v13 = (dyld3 *)memmove(v181, v167, 0x1C0uLL);
  v145 = v167[0];
  dyld3::deallocateExistingSharedCache(v13);
  *(_QWORD *)a2 = v181[0];
  *(_QWORD *)(a2 + 8) = 0;
  v148 = v3;
  if ((_DWORD)v152)
  {
    v14 = 0;
    v15 = v181;
    while (1)
    {
      v16 = &v181[56 * v14];
      v17 = *((unsigned int *)v16 + 96);
      if ((_DWORD)v17)
        break;
LABEL_24:
      ++v14;
      v15 += 56;
      if (v14 == v152)
      {
        v22 = *(_QWORD *)(a2 + 8);
        v3 = v148;
        goto LABEL_35;
      }
    }
    v18 = *((_DWORD *)v16 + 98);
    v19 = *v16;
    v20 = *v16 - v145 + 0x180000000;
    v21 = v15;
    while (mmap((void *)(v20 + *(_QWORD *)(a2 + 8) + *v21 - v19), v21[1], *((_DWORD *)v21 + 11) & 7, 18, v18, v21[2]) != (void *)-1)
    {
      v21 += 6;
      if (!--v17)
        goto LABEL_24;
    }
    if (!*(_QWORD *)(a2 + 16))
      *(_QWORD *)(a2 + 16) = "mmap() the shared cache region failed";
    v23 = (int *)v182;
    v24 = v152;
    do
    {
      if (*v23 != -1)
        close(*v23);
      v23 += 112;
      --v24;
    }
    while (v24);
    goto LABEL_32;
  }
  v22 = 0;
LABEL_35:
  v26 = (char *)(v22 + v171);
  v27 = (vm_page_size + 31) & -(uint64_t)vm_page_size;
  if (mmap((void *)(v22 + v171), v27, 3, 4114, -1, 0) != v26)
  {
    mmap((void *)0x180000000, 0x180000000uLL, 0, 4114, 0, 0);
    LOBYTE(v4) = 0;
    *(_QWORD *)a2 = 0;
    v6 = "could not mmap() dynamic config memory";
    goto LABEL_8;
  }
  strcpy(v26, "dyld_data    v0");
  *((_OWORD *)v26 + 1) = *(_OWORD *)(a2 + 32);
  mprotect(v26, v27, 1);
  if (*((_BYTE *)v3 + 6))
    dyld3::verboseSharedCacheMappings(*(dyld3 **)a2, v28);
  if (!(_DWORD)v152)
  {
    LOBYTE(v4) = 1;
    return v4 & 1;
  }
  v146 = (vm_address_t *)&v163;
  v143 = &v162;
  v144 = v179;
  v142 = &v178;
  v4 = 1;
  v29 = 0;
  do
  {
    v147 = v29;
    v30 = (uint64_t)memmove(v177, &v181[56 * v29], 0x1C0uLL);
    if (*((_BYTE *)v148 + 8))
    {
      v165[0] = _NSConcreteStackBlock;
      v165[1] = 0x40000000;
      v165[2] = ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke;
      v165[3] = &__block_descriptor_tmp_8;
      v165[4] = a2;
      v30 = DyldSharedCache::forEachRegion(v177[0], (uint64_t)v165);
    }
    v38 = *((unsigned __int8 *)v148 + 12);
    v39 = v180;
    v153 = v180;
    if (v38)
    {
      v40 = 0;
      v41 = 1;
      if (v180)
      {
        v42 = (_DWORD **)v144;
        do
        {
          if (*(v42 - 1))
          {
            ++v40;
            if (**v42 != 5)
              v41 = 0;
          }
          v42 += 6;
          --v39;
        }
        while (v39);
      }
      v39 = v153;
      if (v40 <= 5 && (v41 & 1) != 0)
      {
        v160 = (char *)v172;
        v161 = 8;
        v43 = v143;
        v143[1] = 0;
        v43[2] = 0;
        *v43 = 0;
        v44 = v39;
        if ((_DWORD)v39)
        {
          v150 = (unsigned int *)&v179[48 * v147 + 8];
          v151 = (int *)&v181[56 * v147 + 49];
          v45 = (uint64_t)v142;
          v149 = v4;
          do
          {
            if (*(_QWORD *)v45)
            {
              v46 = *(_DWORD **)(v45 + 8);
              if (*v46 != 5)
                __assert_rtn("mapSplitCachePrivate", "SharedCacheRuntime.cpp", 1115, "slideInfoHeader->version == 5");
              v47 = *v151;
              v156 = *(_DWORD *)(v45 + 20);
              v157 = v47;
              v158 = *(_QWORD *)(v45 - 8);
              v155 = *(_QWORD *)(v45 - 24);
              v48 = *(_QWORD *)(a2 + 8);
              v49 = v46[2];
              v154 = v46[1];
              v30 = (uint64_t)DyldSharedCache::mappingName((DyldSharedCache *)*v150, 0);
              v50 = v162 + 1;
              if (v162 + 1 > v161)
              {
                v51 = v30;
                v52 = (vm_address_t)v163;
                v53 = v164;
                if (2 * v161 > v50)
                  v50 = 2 * v161;
                v164 = (vm_page_size + 48 * v50 - 1) & -(uint64_t)vm_page_size;
                if (vm_allocate(mach_task_self_, v146, v164, 1006632961))
                  __assert_rtn("growTo", "Array.h", 184, "0");
                memmove(v163, v160, 48 * v162);
                v160 = v163;
                v161 = v164 / 0x30;
                v30 = v51;
                if (v52)
                {
                  vm_deallocate(mach_task_self_, v52, v53);
                  v30 = v51;
                }
              }
              v54 = v156 & 7;
              v55 = v48 + v155;
              v56 = (v49 * v154);
              v57 = v162++;
              v58 = &v160[48 * v57];
              *(_DWORD *)v58 = v157;
              *((_DWORD *)v58 + 1) = v54;
              *((_QWORD *)v58 + 1) = v158;
              *((_QWORD *)v58 + 2) = v55;
              *((_QWORD *)v58 + 3) = v56;
              *((_QWORD *)v58 + 4) = v30;
              *((_QWORD *)v58 + 5) = v46;
              v4 = v149;
            }
            v45 += 48;
            --v44;
          }
          while (v44);
          v59 = 4 * v162 + 4;
          if (v162)
          {
            v60 = 48 * v162;
            v61 = v160 + 40;
            do
            {
              if (**(_DWORD **)v61 != 5)
                __assert_rtn("mapSplitCachePrivate", "SharedCacheRuntime.cpp", 1142, "slideInfoHeader->version == 5");
              v59 = (v59 + 2 * *(_DWORD *)(*(_QWORD *)v61 + 8) + 25) & 0xFFFFFFFC;
              v61 += 48;
              v60 -= 48;
            }
            while (v60);
          }
        }
        else
        {
          v59 = 4;
        }
        v62 = (v59 + 47) & 0xFFFFFFF8;
        __chkstk_darwin(v30, v31, v32, v33, v34, v35, v36, v37, (uint64_t)v142);
        v63 = (uint64_t **)((char *)&v142 - ((v62 + 15) & 0x1FFFFFFF0));
        bzero(v63, v62);
        *v63 = 0xD400000000007;
        *((_DWORD *)v63 + 2) = v62;
        *(_QWORD *)((char *)v63 + 12) = 0x2800000000;
        *((_DWORD *)v63 + 5) = v59;
        v72 = *(_QWORD *)(a2 + 8);
        v73 = v145;
        v63[3] = v72;
        v63[4] = v73;
        v74 = v162;
        *((_DWORD *)v63 + 10) = v162;
        if (v74)
        {
          v75 = 0;
          v76 = &v160[48 * v74];
          v77 = 4 * v74 + 4;
          v78 = v72 + v73;
          v79 = v160;
          do
          {
            v80 = (_DWORD *)*((_QWORD *)v79 + 5);
            if (*v80 != 5)
              __assert_rtn("mapSplitCachePrivate", "SharedCacheRuntime.cpp", 1168, "slideInfoHeader->version == 5");
            *((_DWORD *)v63 + v75 + 11) = v77;
            v81 = v77 + 40;
            v82 = (uint64_t)v63 + v81;
            v83 = 2 * v80[2] + 22;
            *(_DWORD *)v82 = v83;
            *(_DWORD *)(v82 + 4) = 868352;
            *(_QWORD *)(v82 + 8) = *((_QWORD *)v79 + 2) - v78;
            *(_DWORD *)(v82 + 16) = 0;
            v84 = v80[2];
            *(_WORD *)(v82 + 20) = v84;
            if ((_DWORD)v84)
            {
              v80 += 6;
              v81 += (uint64_t)v63 + 22;
              do
              {
                v85 = *(unsigned __int16 *)v80;
                v80 = (_DWORD *)((char *)v80 + 2);
                v82 = v85;
                *(_WORD *)v81 = v85;
                v81 += 2;
                --v84;
              }
              while (v84);
            }
            ++v75;
            v77 = (v77 + v83 + 3) & 0xFFFFFFFC;
            v79 += 48;
          }
          while (v79 != v76);
          __chkstk_darwin(v84, (uint64_t)v80, v81, v82, 868352, v69, v70, v71, (uint64_t)v142);
          v90 = (const mwl_region *)((char *)&v142 - (v89 & 0xFFFFFFFFFFFFFFE0 | 0x10));
          v91 = 0;
          v92 = 48 * v87;
          v93 = (mwl_region *)v90;
          do
          {
            if (v87 == v91)
              __assert_rtn("push_back", "Array.h", 64, "_usedCount < _allocCount");
            ++v91;
            v94 = *v88;
            v95 = v88[1];
            v88 += 3;
            *(_OWORD *)&v93->mwlr_fd = v94;
            *(_OWORD *)&v93->mwlr_address = v95;
            ++v93;
            v92 -= 48;
          }
          while (v92);
        }
        else
        {
          __chkstk_darwin(v64, v65, v66, v67, v68, v69, v70, v71, (uint64_t)v142);
          v90 = (const mwl_region *)((char *)&v142 - (v96 & 0xFFFFFFFFFFFFFFE0 | 0x10));
          LODWORD(v91) = 0;
        }
        if (*((_BYTE *)v148 + 6))
          dyld4::console((dyld4 *)"Setting up kernel page-in linking for subcache %d\n", v86, v147);
        v98 = __map_with_linking_np(v90, v91, (const mwl_info_hdr *)((char *)&v142 - ((v62 + 15) & 0x1FFFFFFF0)), v62);
        if (v98 && *((_BYTE *)v148 + 6))
          dyld4::console((dyld4 *)"__map_with_linking_np(subcache %d) failed, falling back to linking in-process\n", v97, v147);
        v162 = 0;
        if (v163)
          vm_deallocate(mach_task_self_, (vm_address_t)v163, v164);
        if (!v98)
          goto LABEL_131;
        v39 = v153;
      }
    }
    if ((_DWORD)v39)
    {
      v99 = 0;
      while (!v177[6 * v99 + 3])
      {
LABEL_130:
        if (++v99 == v39)
          goto LABEL_131;
      }
      v100 = &v177[6 * v99];
      v101 = v100[4];
      if (v101)
      {
        v102 = *(_DWORD *)v101;
        if (*(_DWORD *)v101 == 5)
        {
          v132 = "invalid pointer kind in cache file";
          goto LABEL_128;
        }
        v103 = *v100;
        if (v102 != 3)
        {
          if (v102 == 2)
          {
            v104 = *(unsigned int *)(v101 + 12);
            if ((_DWORD)v104)
            {
              v105 = 0;
              v106 = *(_DWORD *)(v101 + 4);
              v107 = v101 + *(unsigned int *)(v101 + 8);
              v108 = v101 + *(unsigned int *)(v101 + 16);
              do
              {
                v109 = *(__int16 *)(v107 + 2 * v105);
                if (v109 != 0x4000)
                {
                  v110 = v103 + (v106 * v105);
                  if (v109 < 0)
                  {
                    v120 = v109 & 0x3FFF;
                    v121 = *(_QWORD *)(v101 + 24);
                    v122 = *(_QWORD *)(v101 + 32);
                    v123 = __clz(__rbit64(v121)) - 2;
                    do
                    {
                      v124 = *(__int16 *)(v108 + 2 * v120);
                      v125 = 4 * (v124 & 0x3FFF);
                      v126 = *(_QWORD *)(a2 + 8) + v122;
                      do
                      {
                        v127 = *(_QWORD *)(v110 + v125);
                        v128 = (v127 & v121) >> v123;
                        v129 = v127 & ~v121;
                        v117 = v129 == 0;
                        v130 = v126 + v129;
                        if (v117)
                          v130 = 0;
                        *(_QWORD *)(v110 + v125) = v130;
                        v125 += v128;
                      }
                      while ((_DWORD)v128);
                      ++v120;
                    }
                    while ((v124 & 0x80000000) == 0);
                  }
                  else
                  {
                    v111 = *(_QWORD *)(v101 + 24);
                    v112 = __clz(__rbit64(v111)) - 2;
                    v113 = 4 * (v109 & 0x3FFF);
                    v114 = *(_QWORD *)(v101 + 32) + *(_QWORD *)(a2 + 8);
                    do
                    {
                      v115 = *(_QWORD *)(v110 + v113);
                      v116 = (v115 & v111) >> v112;
                      v118 = v115 & ~v111;
                      v117 = v118 == 0;
                      v119 = v114 + v118;
                      if (v117)
                        v119 = 0;
                      *(_QWORD *)(v110 + v113) = v119;
                      v113 += v116;
                    }
                    while ((_DWORD)v116);
                  }
                }
                ++v105;
              }
              while (v105 != v104);
              v131 = 1;
              v39 = v153;
              goto LABEL_129;
            }
            goto LABEL_125;
          }
          v132 = "invalid slide info in cache file";
LABEL_128:
          v131 = 0;
          *(_QWORD *)(a2 + 16) = v132;
          goto LABEL_129;
        }
        v133 = *(unsigned int *)(v101 + 8);
        if ((_DWORD)v133)
        {
          v134 = 0;
          v135 = *(_DWORD *)(v101 + 4);
          while (1)
          {
            v136 = *(unsigned __int16 *)(v101 + 2 * v134 + 24);
            if ((_DWORD)v136 != 0xFFFF)
              break;
LABEL_123:
            ++v134;
            v131 = 1;
            v39 = v153;
            if (v134 >= v133)
              goto LABEL_129;
          }
          v137 = v4;
          v138 = (_QWORD *)(v103 + (v135 * v134));
          v139 = v136 >> 3;
          while (1)
          {
            v138 += v139;
            if ((*v138 & 0x8000000000000000) != 0)
              break;
            v139 = (*v138 >> 51) & 0x7FFLL;
            v172[0] = *v138;
            *v138 = *(_QWORD *)(a2 + 8)
                  + mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget((mach_o::ChainedFixupPointerOnDisk::Arm64e *)v172);
            if (!v139)
            {
              v133 = *(unsigned int *)(v101 + 8);
              v4 = v137;
              goto LABEL_123;
            }
          }
          v132 = "invalid pointer kind in cache file";
          LODWORD(v4) = v137;
          v39 = v153;
          goto LABEL_128;
        }
      }
LABEL_125:
      v131 = 1;
LABEL_129:
      v4 = v4 & v131;
      goto LABEL_130;
    }
LABEL_131:
    if (*((_BYTE *)v148 + 8))
    {
      v159[0] = _NSConcreteStackBlock;
      v159[1] = 0x40000000;
      v159[2] = ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke_2;
      v159[3] = &__block_descriptor_tmp_9;
      v159[4] = a2;
      DyldSharedCache::forEachRegion(v177[0], (uint64_t)v159);
    }
    v29 = v147 + 1;
  }
  while (v147 + 1 != v152);
  v140 = (int *)v182;
  v141 = v152;
  do
  {
    if (*v140 != -1)
      close(*v140);
    v140 += 112;
    --v141;
  }
  while (v141);
  return v4 & 1;
}

uint64_t dyld3::mapSplitCacheSystemWide(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t result;
  uint64_t v6;
  const char *v7;
  uint64_t i;
  _BYTE *v9;
  uint64_t *v10;
  uint64_t v11;
  const char *v12;
  vm_size_t v13;
  vm_address_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  _DWORD *v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unint64_t v40;
  char *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  unsigned int v46;
  char *v47;
  vm_size_t v48;
  char *v49;
  uint64_t v50;
  int v51;
  _BYTE *v52;
  uint64_t v53;
  _OWORD *v54;
  char *v55;
  __int128 v56;
  vm_address_t v57;
  char *v58;
  int v59;
  int *v60;
  char v61;
  const char *v62;
  char v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  vm_address_t v67[3];
  char v68;
  uint64_t v69;
  uint64_t v70;
  char v71;
  _OWORD v72[256];
  _BYTE v73[389];
  char v74;
  int v75;
  unsigned int v76;
  uint64_t v77;
  _BYTE v78[392];
  _DWORD v79[14];
  uint64_t v80;
  char v81[264];

  v74 = 0;
  v75 = 0;
  memset(v81, 0, 256);
  v4 = dyld3::preflightMainCacheFile((unsigned int *)a1, a2, (uint64_t)v73, v81, v72);
  result = 0;
  if (v4)
  {
    v6 = v76;
    if (v76 && !v74)
    {
      result = 0;
      v7 = "shared cache is too old, missing subcache suffixes";
LABEL_13:
      *(_QWORD *)(a2 + 16) = v7;
      return result;
    }
    for (i = 0; i != 57344; i += 448)
    {
      v9 = &v78[i];
      v9[389] = 0;
      *((_DWORD *)v9 + 98) = 0;
    }
    if (v6 < 2)
    {
LABEL_11:
      v67[0] = 0;
      v13 = (vm_page_size + 31) & -(uint64_t)vm_page_size;
      if (vm_allocate(mach_task_self_, v67, v13, 1))
      {
        result = 0;
        v7 = "Could not vm_allocate fixed range for dynamic config data";
        goto LABEL_13;
      }
      v14 = v67[0];
      strcpy((char *)v67[0], "dyld_data    v0");
      *(_OWORD *)(v14 + 16) = *(_OWORD *)(a2 + 32);
      memmove(v78, v73, 0x1C0uLL);
      __chkstk_darwin((v6 + 1), v15, v16, v17, v18, v19, v20, v21, v64);
      v30 = (char *)&v64 - v29;
      v66 = v31;
      if ((_DWORD)v6)
      {
        v32 = 0;
        v33 = 0;
        v34 = v79[6];
        v35 = v30 + 4;
        do
        {
          v36 = *(_DWORD *)&v78[v32 + 384];
          v33 += v36;
          if (v32)
            v37 = 0;
          else
            v37 = v34;
          *(v35 - 1) = *(_DWORD *)&v78[v32 + 392];
          *v35 = v36;
          v35[1] = v37;
          v32 += 448;
          v35 += 3;
        }
        while (448 * v6 != v32);
        v38 = v6;
      }
      else
      {
        v38 = 0;
        v33 = 0;
      }
      v39 = &v30[12 * v38];
      *(_QWORD *)v39 = 0x1FFFFFFFFLL;
      *((_DWORD *)v39 + 2) = 0;
      __chkstk_darwin(v22, (uint64_t)v30, v23, v24, v25, v26, v27, v28, v64);
      v47 = (char *)&v64 - (v33 + 1) * (unint64_t)v46;
      if (*(_BYTE *)(a1 + 6))
      {
        v65 = v40;
        v48 = v13;
        v49 = v41;
        dyld4::console((dyld4 *)"Mapping the shared cache system wide\n", v41);
        v41 = v49;
        v13 = v48;
        v40 = v65;
      }
      if ((_DWORD)v6)
      {
        v50 = 0;
        v51 = 0;
        v52 = v78;
        do
        {
          v53 = *(unsigned int *)&v78[448 * v50 + 384];
          v54 = v52;
          if ((_DWORD)v53)
          {
            do
            {
              v55 = &v47[48 * v51++];
              v56 = v54[1];
              *(_OWORD *)v55 = *v54;
              *((_OWORD *)v55 + 1) = v56;
              *((_OWORD *)v55 + 2) = v54[2];
              v54 += 3;
              --v53;
            }
            while (v53);
          }
          ++v50;
          v52 += 448;
        }
        while (v50 != v38);
      }
      v57 = v67[0];
      v58 = &v47[48 * v33];
      *(_QWORD *)v58 = v77;
      *((_QWORD *)v58 + 1) = v13;
      *((_QWORD *)v58 + 3) = 0;
      *((_QWORD *)v58 + 4) = 0;
      *((_QWORD *)v58 + 2) = v57;
      *((_QWORD *)v58 + 5) = 0x100000001;
      v59 = __shared_region_map_and_slide_2_np((void *)v40, v41, (void *)(v33 + 1), v47, v42, v43, v44, v45);
      vm_deallocate(mach_task_self_, v67[0], v13);
      if ((_DWORD)v6)
      {
        v60 = v79;
        do
        {
          if (*v60 != -1)
            close(*v60);
          v60 += 112;
          --v38;
        }
        while (v38);
      }
      v61 = dyld3::reuseExistingCache(a1, a2);
      if (v59)
      {
        if ((v61 & 1) != 0)
        {
          return 1;
        }
        else
        {
          result = 0;
          if (!*(_QWORD *)(a2 + 16))
            *(_QWORD *)(a2 + 16) = "syscall to map cache into shared region failed";
        }
      }
      else
      {
        if (*(_BYTE *)(a1 + 6))
          v63 = v61;
        else
          v63 = 1;
        if ((v63 & 1) == 0)
          dyld4::console((dyld4 *)"mapped dyld cache file system wide\n", v62);
        return 1;
      }
    }
    else
    {
      v10 = &v80;
      v11 = v6 - 1;
      v12 = (const char *)v72;
      while (1)
      {
        memset(v67, 0, sizeof(v67));
        v68 = 0;
        v69 = 0;
        v70 = 0;
        v71 = 0;
        if ((dyld3::preflightSubCacheFile((unsigned int *)a1, (uint64_t)v67, (uint64_t)v10, v81, v12) & 1) == 0)
          return 0;
        v10 += 56;
        v12 += 32;
        if (!--v11)
          goto LABEL_11;
      }
    }
  }
  return result;
}

uint64_t dyld3::deallocateExistingSharedCache(dyld3 *this)
{
  uint64_t result;
  uint64_t v2;

  v2 = 0;
  result = __shared_region_check_np(&v2);
  if (!(_DWORD)result)
    return __shared_region_check_np(0);
  return result;
}

uint64_t dyld3::preflightMainCacheFile(unsigned int *a1, uint64_t a2, uint64_t a3, char *__dst, _OWORD *a5)
{
  dyld3 *v9;
  int v10;
  int v11;
  const char *v12;
  int v13;
  stat *v14;
  int v15;
  uint64_t result;
  const char *v17;
  stat v18;
  stat v19;
  stat v20;
  char __source[264];
  char __dsta[256];

  v9 = (dyld3 *)*a1;
  v10 = *((unsigned __int8 *)a1 + 9);
  v11 = *((unsigned __int8 *)a1 + 10);
  strcpy(__source, "dyld_shared_cache_arm64");
  strlcpy(__dst, __source, 0x100uLL);
  if (!v10)
  {
    strlcpy(__dsta, __source, 0x100uLL);
    strlcat(__dsta, ".development", 0x400uLL);
    if (!dyld3::fstatat(v9, __dsta, &v20, 0))
    {
      v13 = dyld3::fstatat(v9, __source, &v19, 0);
      if (v11 || v13)
      {
        strlcpy(__source, __dsta, 0x100uLL);
      }
      else if (!dyld3::stat((dyld3 *)"/System/Library/Caches/com.apple.dyld/enable-dylibs-to-override-cache", &v18, v14)&& v18.st_size <= 1023)
      {
        strlcat(__source, ".development", 0x100uLL);
      }
    }
  }
  v15 = dyld3::openat((dyld3 *)*a1, __source, v12);
  if (v15 == -1)
  {
    if (*__error() == 2)
    {
      result = 0;
      *(_BYTE *)(a2 + 24) = 0;
      v17 = "no shared cache file";
    }
    else
    {
      result = 0;
      v17 = "shared cache file open() failed";
    }
    *(_QWORD *)(a2 + 16) = v17;
  }
  else
  {
    *(_BYTE *)(a2 + 24) = 1;
    return dyld3::preflightCacheFile((uint64_t)a1, a2, a3, v15, a5);
  }
  return result;
}

uint64_t dyld3::preflightSubCacheFile(unsigned int *a1, uint64_t a2, uint64_t a3, char *__source, const char *a5)
{
  dyld3 *v9;
  const char *v10;
  int v11;
  uint64_t result;
  const char *v13;
  char __dst[256];

  v9 = (dyld3 *)*a1;
  strlcpy(__dst, __source, 0x100uLL);
  strlcat(__dst, a5, 0x100uLL);
  v11 = dyld3::openat(v9, __dst, v10);
  if (v11 == -1)
  {
    if (*__error() == 2)
    {
      result = 0;
      *(_BYTE *)(a2 + 24) = 0;
      v13 = "no shared cache file";
    }
    else
    {
      result = 0;
      v13 = "shared cache file open() failed";
    }
    *(_QWORD *)(a2 + 16) = v13;
  }
  else
  {
    *(_BYTE *)(a2 + 24) = 1;
    return dyld3::preflightCacheFile((uint64_t)a1, a2, a3, v11, 0);
  }
  return result;
}

void dyld3::verboseSharedCacheMappings(dyld3 *this, const DyldSharedCache *a2)
{
  _QWORD v3[5];

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZN5dyld3L26verboseSharedCacheMappingsEPK15DyldSharedCache_block_invoke;
  v3[3] = &__block_descriptor_tmp_37;
  v3[4] = DyldSharedCache::slide(this);
  DyldSharedCache::forEachRange((char *)this, (uint64_t)v3, 0);
}

uint64_t ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke(uint64_t result, int a2, uint64_t a3, vm_size_t size, uint64_t a5, uint64_t a6, char a7)
{
  if ((a7 & 4) != 0)
    return vm_protect(mach_task_self_, *(_QWORD *)(*(_QWORD *)(result + 32) + 8) + a3, size, 0, 19);
  return result;
}

uint64_t ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke_2(uint64_t result, int a2, uint64_t a3, vm_size_t size, uint64_t a5, uint64_t a6, char a7)
{
  if ((a7 & 4) != 0)
    return vm_protect(mach_task_self_, *(_QWORD *)(*(_QWORD *)(result + 32) + 8) + a3, size, 0, 1);
  return result;
}

uint64_t dyld3::preflightCacheFile(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _OWORD *a5)
{
  const char *v10;
  off_t st_size;
  __darwin_ino64_t st_ino;
  uint64_t v15;
  int v16;
  unsigned int v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  int v22;
  unsigned int v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t *v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  BOOL v51;
  char v52;
  void *v53;
  stat v54;
  _BYTE __buf[24];
  uint64_t v56;
  _QWORD v57[7];
  _QWORD v58[2];
  unsigned int v59;
  unsigned int v60;
  _BYTE v61[16];
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  char v68;
  __int128 v69;
  uint64_t v70;
  unsigned int v71;
  int v72;
  unsigned int __offseta;
  unsigned int __offset_4;
  int v75;
  uint64_t v76;
  uint64_t v77;

  if (fstat64(a4, &v54))
  {
    v10 = "shared cache file stat() failed";
LABEL_10:
    *(_QWORD *)(a2 + 16) = v10;
LABEL_11:
    close(a4);
    return 0;
  }
  st_size = v54.st_size;
  st_ino = v54.st_ino;
  *(_QWORD *)(a2 + 32) = v54.st_dev;
  *(_QWORD *)(a2 + 40) = st_ino;
  if (pread(a4, v58, 0x4000uLL, 0) != 0x4000)
  {
    v10 = "shared cache file pread() failed";
    goto LABEL_10;
  }
  if (v58[0] != 0x2031765F646C7964 || v58[1] != 0x34366D72612020)
  {
    v10 = "shared cache file has wrong magic";
    goto LABEL_10;
  }
  v15 = v59;
  if (v59 >= 0xE0)
  {
    v16 = *(_DWORD *)(a1 + 16);
    if (v67 == v16)
    {
      if ((v68 & 2) != 0)
      {
LABEL_22:
        v10 = "shared cache file is for a different platform";
        goto LABEL_10;
      }
    }
    else if (!v72 || v72 != v16)
    {
      goto LABEL_22;
    }
  }
  v17 = v60;
  if (v60 - 9 <= 0xFFFFFFF7)
  {
    v10 = "shared cache file mappings are invalid";
    goto LABEL_10;
  }
  v18 = (char *)v58 + v59;
  v19 = v60 - 1;
  v20 = *((_QWORD *)v18 + 2);
  if (v20)
  {
    v21 = "shared cache text file offset is invalid";
    goto LABEL_28;
  }
  if (v63 + v62 != st_size)
  {
    v21 = "shared cache code signature size is invalid";
LABEL_28:
    *(_QWORD *)(a2 + 16) = v21;
    if (v17 >= 2)
    {
LABEL_29:
      v22 = *((_DWORD *)v18 + 6) | 4;
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if (v60 >= 2)
  {
    if (*(_DWORD *)&v18[32 * v19 + 24] != 1)
      *(_QWORD *)(a2 + 16) = "shared cache linkedit permissions are invalid";
    goto LABEL_29;
  }
LABEL_30:
  v22 = *((_DWORD *)v18 + 6);
LABEL_31:
  if (v22 != 5)
    *(_QWORD *)(a2 + 16) = "shared cache text permissions are invalid";
  if (*(_QWORD *)(a2 + 16))
    goto LABEL_11;
  v23 = 1;
  while (v17 != v23)
  {
    v24 = &v18[32 * v23 - 32];
    v26 = *(_QWORD *)v24;
    v25 = *((_QWORD *)v24 + 1);
    if ((unint64_t)(v25 + v26) <= *(_QWORD *)&v18[32 * v23])
    {
      v20 += v25;
      v27 = *(_QWORD *)&v18[32 * v23++ + 16];
      if (v20 == v27)
        continue;
    }
    v10 = "shared cache mappings overlap";
    goto LABEL_10;
  }
  v57[0] = 0;
  v57[1] = v62;
  v57[2] = v63;
  if (fcntl(a4, 97, v57) == -1)
  {
    v10 = "code signature registration for shared cache failed";
    goto LABEL_10;
  }
  if (v57[0] < v62)
  {
    v10 = "code signature does not cover entire shared cache file";
    goto LABEL_10;
  }
  v28 = mmap(0, 0x4000uLL, 5, 2, a4, 0);
  if (v28 == (void *)-1)
  {
    v10 = "first page of shared cache not mmap()able";
    goto LABEL_10;
  }
  v53 = v28;
  if (_platform_memcmp(v28, v58, 0x4000uLL))
  {
    v10 = "first page of mmap()ed shared cache not valid";
    goto LABEL_10;
  }
  munmap(v53, 0x4000uLL);
  v29 = v60;
  *(_DWORD *)(a3 + 384) = v60;
  if ((_DWORD)v29)
  {
    v30 = 0;
    v31 = 0;
    v32 = v59;
    v33 = *(unsigned __int8 *)(a1 + 8);
    v34 = 48 * v29;
    do
    {
      v36 = *(_DWORD *)&v61[v15];
      v35 = *(_DWORD *)&v61[v15 + 4];
      if (v32 > 0x138)
      {
        v40 = (_QWORD *)((char *)&v58[v30] + v71);
        v38 = v40[3];
        v39 = v40[4];
        v41 = v40[5];
        v37 = ~((_DWORD)v41 << 6) & 0x40;
        if ((v41 & 4) != 0)
        {
          if (v33)
            v36 |= 0x200u;
          else
            v35 |= 2u;
        }
      }
      else if (v31 == 48)
      {
        v37 = 0;
        v38 = v64;
        v39 = v65;
      }
      else
      {
        v38 = 0;
        v39 = 0;
        v37 = 0;
      }
      v42 = a3 + v31;
      *(_OWORD *)v42 = *(_OWORD *)((char *)v58 + v15);
      v43 = *(_QWORD *)((char *)&v58[2] + v15);
      *(_QWORD *)(v42 + 24) = 0;
      *(_QWORD *)(v42 + 32) = 0;
      *(_QWORD *)(v42 + 16) = v43;
      *(_DWORD *)(v42 + 40) = v36;
      *(_DWORD *)(v42 + 44) = v35;
      if (v39)
      {
        if (v17 <= 1)
        {
          *(_DWORD *)(a3 + 392) = a4;
          std::__throw_bad_optional_access[abi:nn180100]();
        }
        v44 = v38 - *(_QWORD *)&v18[32 * v19 + 16] + *(_QWORD *)&v18[32 * v19];
        *(_QWORD *)(v42 + 24) = v39;
        *(_QWORD *)(v42 + 32) = v44;
        *(_DWORD *)(v42 + 40) = v36 | v37 | 0x20;
        *(_DWORD *)(v42 + 44) = v35 | v37 | 0x20;
      }
      v31 += 48;
      v15 += 32;
      v30 += 7;
    }
    while (v34 != v31);
    *(_DWORD *)(a3 + 392) = a4;
  }
  if (__offset_4 > 0x7F)
  {
    v10 = "shared cache file subcache count exceeds limit";
    goto LABEL_10;
  }
  if (!a5 && __offset_4)
  {
    v10 = "no shared cache subcache indices";
    goto LABEL_10;
  }
  v45 = v59;
  *(_BYTE *)(a3 + 389) = v59 > 0x1C8;
  if (v45 >= 0x1C9)
  {
    if (pread(a4, __buf, 0x1C00uLL, __offseta) != 7168)
    {
      v10 = "shared cache file pread() failed, could not read subcache entries";
      goto LABEL_10;
    }
    v46 = __offset_4;
    if (__offset_4)
    {
      v47 = &v56;
      do
      {
        v48 = *((_OWORD *)v47 + 1);
        *a5 = *(_OWORD *)v47;
        a5[1] = v48;
        a5 += 2;
        v47 += 7;
        --v46;
      }
      while (v46);
    }
  }
  *(_OWORD *)(a3 + 400) = v69;
  *(_QWORD *)(a3 + 416) = v70;
  *(_BYTE *)(a3 + 388) = *(_BYTE *)(a1 + 11);
  *(_DWORD *)(a3 + 424) = DyldSharedCache::numSubCaches((DyldSharedCache *)v58) + 1;
  v49 = v77;
  v50 = v66;
  *(_QWORD *)(a3 + 432) = v76 + v69;
  *(_QWORD *)(a3 + 440) = v49;
  v51 = v50 == 2 && v75 == 0;
  if (v50)
    v52 = v51;
  else
    v52 = 1;
  *(_BYTE *)(a2 + 48) = v52;
  return 1;
}

uint64_t dyld3::openat(dyld3 *this, const char *a2, const char *a3)
{
  int v4;
  uint64_t result;

  v4 = (int)this;
  for (result = openat((int)this, a2, 0, 0); (_DWORD)result == -1; result = openat(v4, a2, 0, 0))
  {
    if (*__error() != 35 && *__error() != 4)
      return 0xFFFFFFFFLL;
  }
  return result;
}

ssize_t ___ZN5dyld3L26verboseSharedCacheMappingsEPK15DyldSharedCache_block_invoke(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return dyld4::console((dyld4 *)"        0x%08llX->0x%08llX init=%x, max=%x %s\n", a2, *(_QWORD *)(a1 + 32) + a3, a4 + *(_QWORD *)(a1 + 32) + a3 - 1, a7, a8, a2);
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, unsigned int a2, char a3)
{
  return lsl::CRC32cSW::sCRC32cTable[(a2 ^ a3)] ^ (a2 >> 8);
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, uint64_t a2, __int16 a3)
{
  __int16 v4;

  v4 = a3;
  return (*(uint64_t (**)(lsl::CRC32cSW *, uint64_t, __int16 *, uint64_t))(*(_QWORD *)this + 32))(this, a2, &v4, 2);
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a3;
  return (*(uint64_t (**)(lsl::CRC32cSW *, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)this + 32))(this, a2, &v4, 8);
}

BOOL dyld4::RemoteNotificationResponder::active(dyld4::RemoteNotificationResponder *this)
{
  unint64_t v1;
  _DWORD *v2;
  uint64_t v4;
  unint64_t v5;

  v1 = *((unsigned int *)this + 10);
  if (!(_DWORD)v1)
    return 0;
  v2 = (_DWORD *)*((_QWORD *)this + 4);
  if (*v2)
    return 1;
  v4 = 1;
  do
  {
    v5 = v4;
    if (v1 == v4)
      break;
  }
  while (!v2[v4++]);
  return v5 < v1;
}

uint64_t dyld4::RemoteNotificationResponder::notifyMonitorOfImageListChanges(dyld4::RemoteNotificationResponder *this, uint64_t a2, uint64_t a3, const mach_header **a4, const char **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  const char **v9;
  const mach_header **v10;
  mach_msg_size_t v11;
  _BOOL8 v12;
  dyld4::RemoteNotificationResponder *v13;
  int v14;
  int v15;
  uint64_t v16;
  const char **v17;
  const char *v18;
  mach_msg_size_t v19;
  mach_port_t v20;
  uint64_t v21;
  mach_msg_header_t *v22;
  unsigned int v23;
  char *v24;
  uint64_t v25;
  char *v26;
  const char *v27;
  char *v28;
  int v29;
  const mach_header *v30;
  mach_msg_id_t v31;
  uint64_t v33[2];
  dyld4::RemoteNotificationResponder *v34;

  while (1)
  {
    v8 = a6;
    v9 = a5;
    v10 = a4;
    v11 = a3;
    v12 = a2;
    v13 = this;
    v14 = 32 * a3;
    v15 = 0;
    if ((_DWORD)a3)
    {
      v16 = a3;
      v17 = a5;
      do
      {
        v18 = *v17++;
        this = (dyld4::RemoteNotificationResponder *)_platform_strlen(v18);
        v15 += (_DWORD)this + 1;
        --v16;
      }
      while (v16);
    }
    v19 = (v14 + 48 + v15 + 127) & 0xFFFFFF80;
    if ((v19 | 0x44) <= 0x8000)
      break;
    dyld4::RemoteNotificationResponder::notifyMonitorOfImageListChanges(v13, v12, v11 >> 1, v10, v9, v8);
    a3 = v11 - (v11 >> 1);
    a4 = &v10[v11 >> 1];
    a5 = &v9[v11 >> 1];
    this = v13;
    a2 = v12;
    a6 = v8;
  }
  v33[1] = (uint64_t)v33;
  v34 = v13;
  __chkstk_darwin((uint64_t)this, a2, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v33[0]);
  v22 = (mach_msg_header_t *)((char *)v33 - ((v21 + 15) & 0x1FFFFFFF0));
  v22[1].msgh_bits = 1;
  v22[1].msgh_size = v11;
  v22[1].msgh_remote_port = 48;
  v22[1].msgh_local_port = v20;
  *(_QWORD *)&v22[1].msgh_voucher_port = v8;
  if (v11)
  {
    v23 = (_DWORD)v22 + (v20 & 0xFFFFFFF0);
    v24 = (char *)&v22[2];
    v25 = v11;
    v26 = (char *)v22 + (v20 & 0xFFFFFFF0);
    do
    {
      v27 = *v9++;
      v28 = strcpy(v26, v27);
      v29 = _platform_strlen(v28);
      bzero(v24, 0x10uLL);
      dyld3::MachOFile::getUuid((dyld3::MachOFile *)*v10, (unsigned __int8 *)v24);
      v30 = *v10++;
      *((_QWORD *)v24 + 2) = v30;
      *((_DWORD *)v24 + 6) = (_DWORD)v26 - v23;
      *((_DWORD *)v24 + 7) = v29;
      v26 += (v29 + 1);
      v24 += 32;
      --v25;
    }
    while (v25);
  }
  if (v12)
    v31 = 0x2000;
  else
    v31 = 4096;
  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)v34, v31, v19, v22);
}

uint64_t dyld4::RemoteNotificationResponder::notifyMonitorOfMainCalled(dyld4::RemoteNotificationResponder *this)
{
  mach_msg_header_t v3[3];
  mach_msg_header_t v4;

  dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3);
  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 16385, 0x18u, &v4);
}

uint64_t dyld4::RemoteNotificationResponder::notifyMonitorOfDyldBeforeInitializers(dyld4::RemoteNotificationResponder *this)
{
  mach_msg_header_t v2;

  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 16386, 0x18u, &v2);
}

uint64_t dyld4::APIs::_dyld_get_dlopen_image_header(dyld4::Loader **this, dyld4::Loader *a2)
{
  void *v2;
  const dyld4::Loader *v3;
  dyld4::Loader *ImageContaining;

  v3 = a2;
  if (*((_BYTE *)this[1] + 204))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_get_dlopen_image_header(%p)\n", a2);
  if (v3 == (const dyld4::Loader *)-5)
  {
    ImageContaining = this[3];
  }
  else
  {
    if (v3)
    {
      if (v3 == (const dyld4::Loader *)-3)
      {
        ImageContaining = (dyld4::Loader *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, v2);
        if (ImageContaining)
          return dyld4::Loader::analyzer(ImageContaining, (dyld4::RuntimeState *)this);
      }
      v3 = (const dyld4::Loader *)((unint64_t)v3 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_1A5C55000);
    }
    if (!dyld4::APIs::validLoader(this, v3))
      return 0;
    ImageContaining = v3;
  }
  return dyld4::Loader::analyzer(ImageContaining, (dyld4::RuntimeState *)this);
}

uint64_t dyld4::APIs::dyld_get_program_sdk_watch_os_version(dyld4::APIs *this)
{
  unsigned int *v2;
  uint64_t v3;
  _QWORD v5[6];
  _QWORD v6[3];
  char v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x2000000000;
  v7 = 0;
  v2 = *(unsigned int **)(*((_QWORD *)this + 1) + 8);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs37dyld_get_program_sdk_watch_os_versionEv_block_invoke;
  v5[3] = &unk_1E4F7D8B0;
  v5[4] = v6;
  v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_get_program_sdk_watch_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs37dyld_get_program_sdk_watch_os_versionEv_block_invoke(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4;

  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24))
  {
    v4 = result;
    result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result == 4)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 24) = 1;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24) = a3;
    }
  }
  return result;
}

uint64_t dyld4::APIs::dyld_get_program_min_watch_os_version(dyld4::APIs *this)
{
  unsigned int *v2;
  uint64_t v3;
  _QWORD v5[6];
  _QWORD v6[3];
  char v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x2000000000;
  v7 = 0;
  v2 = *(unsigned int **)(*((_QWORD *)this + 1) + 8);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs37dyld_get_program_min_watch_os_versionEv_block_invoke;
  v5[3] = &unk_1E4F7D8D8;
  v5[4] = v6;
  v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_get_program_min_watch_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs37dyld_get_program_min_watch_os_versionEv_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5;

  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24))
  {
    v5 = result;
    result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result == 4)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 8) + 24) = 1;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 40) + 8) + 24) = a4;
    }
  }
  return result;
}

uint64_t dyld4::APIs::dyld_get_program_sdk_bridge_os_version(dyld4::APIs *this)
{
  unsigned int *v2;
  uint64_t v3;
  _QWORD v5[6];
  _QWORD v6[3];
  char v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x2000000000;
  v7 = 0;
  v2 = *(unsigned int **)(*((_QWORD *)this + 1) + 8);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs38dyld_get_program_sdk_bridge_os_versionEv_block_invoke;
  v5[3] = &unk_1E4F7D900;
  v5[4] = v6;
  v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_get_program_sdk_bridge_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs38dyld_get_program_sdk_bridge_os_versionEv_block_invoke(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4;

  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24))
  {
    v4 = result;
    result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result == 5)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 24) = 1;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24) = a3;
    }
  }
  return result;
}

uint64_t dyld4::APIs::dyld_get_program_min_bridge_os_version(dyld4::APIs *this)
{
  unsigned int *v2;
  uint64_t v3;
  _QWORD v5[6];
  _QWORD v6[3];
  char v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x2000000000;
  v7 = 0;
  v2 = *(unsigned int **)(*((_QWORD *)this + 1) + 8);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs38dyld_get_program_min_bridge_os_versionEv_block_invoke;
  v5[3] = &unk_1E4F7D928;
  v5[4] = v6;
  v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_get_program_min_bridge_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs38dyld_get_program_min_bridge_os_versionEv_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5;

  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24))
  {
    v5 = result;
    result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result == 5)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 8) + 24) = 1;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 40) + 8) + 24) = a4;
    }
  }
  return result;
}

uint64_t dyld4::APIs::dyld_get_sdk_version(dyld4::APIs *this, const mach_header *a2)
{
  uint64_t SdkVersion;
  uint64_t v5;

  SdkVersion = dyld4::APIs::getSdkVersion(this, a2);
  v5 = SdkVersion;
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_get_sdk_version(%p) => 0x%08X\n", a2, SdkVersion);
  return v5;
}

uint64_t dyld4::APIs::dyld_get_min_os_version(dyld4::APIs *this, const mach_header *a2)
{
  uint64_t v4;
  _QWORD v6[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  _QWORD v11[3];
  char v12;

  v11[0] = 0;
  v11[1] = v11;
  v11[2] = 0x2000000000;
  v12 = 0;
  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZN5dyld44APIs23dyld_get_min_os_versionEPK11mach_header_block_invoke;
  v6[3] = &unk_1E4F7D978;
  v6[5] = &v7;
  v6[6] = this;
  v6[4] = v11;
  dyld4::APIs::forEachImageVersion((uint64_t)this, &a2->magic, (uint64_t)v6);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_get_min_os_version(%p) => 0x%08X\n", a2, *((_DWORD *)v8 + 6));
  v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(v11, 8);
  return v4;
}

uint64_t ___ZN5dyld44APIs23dyld_get_min_os_versionEPK11mach_header_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v8;
  int v9;

  v4 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
  if (!*(_BYTE *)(v4 + 24))
  {
    v5 = result;
    v6 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 48) + 8) + 68);
    if (v6 == (_DWORD)a2)
    {
      *(_BYTE *)(v4 + 24) = 1;
      result = dyld3::MachOFile::basePlatform(a2);
      v8 = a4 + 458752;
      v9 = a4 + 589824;
      if ((_DWORD)result != 5)
        v9 = a4;
      if ((_DWORD)result != 4)
        v8 = v9;
      goto LABEL_10;
    }
    if ((_DWORD)a2 == 7 && v6 == 6)
    {
      *(_BYTE *)(v4 + 24) = 1;
      v8 = 786432;
LABEL_10:
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 40) + 8) + 24) = v8;
    }
  }
  return result;
}

uint64_t dyld4::APIs::dyld_is_simulator_platform(dyld4::APIs *this, int a2)
{
  uint64_t isSimulatorPlatform;
  uint64_t v5;

  isSimulatorPlatform = dyld3::MachOFile::isSimulatorPlatform(a2, 0);
  v5 = isSimulatorPlatform;
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_is_simulator_platform(%d) => %d\n", a2, isSimulatorPlatform);
  return v5;
}

unint64_t dyld4::APIs::mapFromVersionSet(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v4;
  uint64_t v5;
  int *v6;

  v3 = HIDWORD(a2);
  if ((_DWORD)a2 == -1)
  {
    v4 = dyld3::MachOFile::basePlatform(a3);
    LODWORD(a2) = v4;
    v5 = 0;
    while (dyld3::sVersionMap[v5] < v3)
    {
      v5 += 9;
      if (v5 == 423)
      {
        LODWORD(a2) = 0;
        v3 = 0;
        return a2 | (v3 << 32);
      }
    }
    v3 = 0;
    switch(v4)
    {
      case 1:
        v6 = &dyld3::sVersionMap[v5 + 1];
        goto LABEL_13;
      case 2:
        v6 = &dyld3::sVersionMap[v5 + 2];
        goto LABEL_13;
      case 3:
        v6 = &dyld3::sVersionMap[v5 + 4];
        goto LABEL_13;
      case 4:
        v6 = &dyld3::sVersionMap[v5 + 3];
        goto LABEL_13;
      case 5:
        v6 = &dyld3::sVersionMap[v5 + 5];
        goto LABEL_13;
      case 11:
        v6 = &dyld3::sVersionMap[v5 + 7];
LABEL_13:
        v3 = *v6;
        break;
      default:
        return a2 | (v3 << 32);
    }
  }
  return a2 | (v3 << 32);
}

uint64_t dyld4::APIs::dyld_minos_at_least(dyld4::RuntimeState *a1, unsigned int *a2, unint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;

  v6 = dyld4::APIs::mapFromVersionSet((uint64_t)a1, a3, *(unsigned int *)(*((_QWORD *)a1 + 1) + 68));
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___ZN5dyld44APIs19dyld_minos_at_leastEPK11mach_header20dyld_build_version_t_block_invoke;
  v9[3] = &unk_1E4F7D9C8;
  v9[4] = &v10;
  v9[5] = v6;
  dyld4::APIs::forEachImageVersion((uint64_t)a1, a2, (uint64_t)v9);
  if (*(_BYTE *)(*((_QWORD *)a1 + 1) + 204))
    dyld4::RuntimeState::log(a1, "dyld_minos_at_least(%p, <%d,0x%08X>) => %d\n", a2, a3, HIDWORD(a3), *((unsigned __int8 *)v11 + 24));
  v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

uint64_t ___ZN5dyld44APIs19dyld_minos_at_leastEPK11mach_header20dyld_build_version_t_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7;
  uint64_t result;

  v7 = dyld3::MachOFile::basePlatform(a2);
  result = dyld3::MachOFile::basePlatform(*(unsigned int *)(a1 + 40));
  if (v7 == (_DWORD)result)
  {
    result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result)
    {
      if (*(_DWORD *)(a1 + 44) <= a4)
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    }
  }
  return result;
}

unint64_t dyld4::APIs::dyld_get_program_sdk_version_token(dyld4::APIs *this)
{
  return *(unsigned int *)(*((_QWORD *)this + 1) + 68) | ((unint64_t)*(unsigned int *)(*((_QWORD *)this + 1)
                                                                                              + 48) << 32);
}

unint64_t dyld4::APIs::dyld_get_program_minos_version_token(dyld4::APIs *this)
{
  return *(unsigned int *)(*((_QWORD *)this + 1) + 68) | ((unint64_t)*(unsigned int *)(*((_QWORD *)this + 1)
                                                                                              + 56) << 32);
}

uint64_t dyld4::APIs::dyld_version_token_get_platform(dyld4::APIs *this, uint64_t a2)
{
  return a2;
}

BOOL dyld4::APIs::dyld_version_token_at_least(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v4;
  unsigned int v5;
  _BOOL8 result;

  v4 = dyld4::APIs::mapFromVersionSet(a1, a3, a2);
  result = 0;
  if ((_DWORD)a2)
  {
    v5 = HIDWORD(v4);
    if (dyld3::MachOFile::basePlatform(a2) == (_DWORD)v4 && HIDWORD(a2) >= v5)
      return 1;
  }
  return result;
}

uint64_t dyld4::APIs::linkedDylibVersion(dyld4::APIs *this, const dyld3::MachOFile *a2, const char *a3)
{
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs18linkedDylibVersionEPKN5dyld39MachOFileEPKc_block_invoke;
  v5[3] = &unk_1E4F7D9F0;
  v5[4] = &v6;
  v5[5] = a3;
  dyld3::MachOFile::forEachDependentDylib(a2, (uint64_t)v5);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs18linkedDylibVersionEPKN5dyld39MachOFileEPKc_block_invoke(uint64_t a1, char *__s1, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, _BYTE *a8)
{
  uint64_t result;

  result = _platform_strcmp(__s1, *(const char **)(a1 + 40));
  if (!(_DWORD)result)
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a7;
    *a8 = 1;
  }
  return result;
}

uint64_t dyld4::APIs::dyld_get_program_min_os_version(dyld4::APIs *this)
{
  return (*(uint64_t (**)(dyld4::APIs *, _QWORD))(*(_QWORD *)this + 392))(this, *(_QWORD *)(*((_QWORD *)this + 1) + 8));
}

void dyld4::APIs::_dyld_objc_notify_register(dyld4::APIs *this, void (*a2)(unsigned int, const char *const *, const mach_header *const *), void (*a3)(const char *, const mach_header *), void (*a4)(const char *, const mach_header *))
{
  dyld4::halt("_dyld_objc_notify_register is unsupported", 0);
}

uint64_t __Block_byref_object_copy__6(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
  mach_o::Error::~Error((vm_address_t **)(a1 + 40));
}

uint64_t dyld4::APIs::dlopen_audited(dyld4::APIs *this, const char *a2)
{
  return (*(uint64_t (**)(dyld4::APIs *, const char *))(*(_QWORD *)this + 112))(this, a2);
}

uint64_t dyld4::APIs::addressLookupsDisabled(dyld4::APIs *this, const char *__s2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  int v7;
  int v8;
  BOOL v9;
  void (*v10)(const char *);
  uint64_t v11;
  uint64_t v13[4];

  v4 = *((_QWORD *)this + 1);
  if (__s2 && (v5 = *(char **)(v4 + 176)) != 0)
  {
    v6 = strstr(v5, __s2);
    if (v6)
    {
      v7 = *(v6 - 1);
      v8 = v6[_platform_strlen(__s2)];
      v9 = v8 == 58 || v8 == 0;
      if (v9 && v7 == 58)
        return 0;
    }
  }
  else if (*(_BYTE *)(v4 + 170))
  {
    goto LABEL_14;
  }
  v10 = (void (*)(const char *))*((_QWORD *)this + 123);
  if (v10)
    v10(__s2);
LABEL_14:
  v11 = *((_QWORD *)this + 1);
  if (!*(_BYTE *)(v11 + 170))
    return 0;
  if (*(_BYTE *)(v11 + 171))
  {
    v13[0] = 10;
    v13[1] = 0;
    v13[2] = 0;
    v13[3] = (uint64_t)__s2;
    dyld4::halt("symbol address lookup (dlsym) disabled in process", v13);
  }
  return 1;
}

__n128 __Block_byref_object_copy__96(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 40);
  v3 = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

BOOL dyld4::APIs::_dyld_shared_cache_optimized(dyld4::APIs *this)
{
  uint64_t v1;
  uint64_t v2;
  _BOOL8 v3;

  v1 = *((_QWORD *)this + 1);
  v2 = *(_QWORD *)(v1 + 240);
  if (v2)
    v3 = *(_QWORD *)(v2 + 104) == 1;
  else
    v3 = 0;
  if (*(_BYTE *)(v1 + 204))
    dyld4::RuntimeState::log(this, "_dyld_shared_cache_optimized() => %d\n", v3);
  return v3;
}

const os_unfair_lock *dyld4::APIs::_dyld_register_for_image_loads(lsl::Lock **this, void (*a2)(const mach_header *, const char *, BOOL))
{
  lsl::Lock *v4;
  const dyld4::Loader *ImageContaining;
  lsl::Lock *v6;
  lsl::Lock *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[6];
  lsl::Lock *v12;

  if (*((_BYTE *)this[1] + 204))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_register_for_image_loads(%p)\n", a2);
  v4 = this[17];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = ___ZN5dyld44APIs30_dyld_register_for_image_loadsEPFvPK11mach_headerPKcbE_block_invoke;
  v11[3] = &__block_descriptor_tmp_118;
  v11[4] = this;
  v11[5] = a2;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v11);
  ImageContaining = (const dyld4::Loader *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a2);
  v6 = this[16];
  v7 = this[17];
  lsl::MemoryManager::lockGuard(v6, &v12);
  v8 = *((_QWORD *)v6 + 3);
  if (!v8)
  {
    lsl::MemoryManager::writeProtect(v6, 0);
    v8 = *((_QWORD *)v6 + 3);
  }
  *((_QWORD *)v6 + 3) = v8 + 1;
  lsl::Lock::unlock(v12);
  if (*(_QWORD *)v7)
  {
    (*(void (**)(_QWORD, _QWORD *, _QWORD))(**(_QWORD **)v7 + 104))(*(_QWORD *)v7, (_QWORD *)v7 + 2, 0);
    dyld4::RuntimeState::addNotifyLoadImage((dyld4::RuntimeState *)this, ImageContaining, a2);
    (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)v7 + 112))(*(_QWORD *)v7, (_QWORD *)v7 + 2);
  }
  else
  {
    dyld4::RuntimeState::addNotifyLoadImage((dyld4::RuntimeState *)this, ImageContaining, a2);
  }
  lsl::MemoryManager::lockGuard(v6, &v12);
  v9 = *((_QWORD *)v6 + 3) - 1;
  *((_QWORD *)v6 + 3) = v9;
  if (!v9)
    lsl::MemoryManager::writeProtect(v6, 1);
  return lsl::Lock::unlock(v12);
}

uint64_t ___ZN5dyld44APIs30_dyld_register_for_image_loadsEPFvPK11mach_headerPKcbE_block_invoke(uint64_t result)
{
  const dyld4::RuntimeState *v1;
  uint64_t v2;
  uint64_t v3;
  dyld4::Loader **v4;
  uint64_t v5;
  dyld4::Loader *v6;
  const void *Address;
  const void *v8;
  uint64_t (*v9)(const void *, uint64_t, BOOL);
  uint64_t v10;

  v1 = *(const dyld4::RuntimeState **)(result + 32);
  v2 = *((_QWORD *)v1 + 6);
  if (v2)
  {
    v3 = result;
    v4 = (dyld4::Loader **)*((_QWORD *)v1 + 5);
    v5 = 8 * v2;
    do
    {
      v6 = *v4;
      Address = (const void *)dyld4::Loader::loadAddress(*v4, v1);
      v8 = Address;
      if (*(_BYTE *)(*((_QWORD *)v1 + 1) + 205))
        dyld4::RuntimeState::log(v1, "add notifier %p called with mh=%p\n", *(const void **)(v3 + 40), Address);
      v9 = *(uint64_t (**)(const void *, uint64_t, BOOL))(v3 + 40);
      v10 = dyld4::Loader::path(v6, v1);
      result = v9(v8, v10, (*((_WORD *)v6 + 2) & 0x20) == 0);
      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
  return result;
}

uint64_t dyld4::findCacheInDirAndMap(dyld4 *this, dyld4::RuntimeState *a2, char *a3, const char *a4, unint64_t *a5)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v5 = *((_QWORD *)this + 1);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZN5dyld4L20findCacheInDirAndMapERNS_12RuntimeStateEPKhPKcRm_block_invoke;
  v8[3] = &unk_1E4F7DD60;
  v8[4] = &v9;
  v8[5] = a2;
  v8[6] = a4;
  dyld4::SyscallDelegate::forEachInDirectory(v5, a3, 0, (uint64_t)v8);
  v6 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v6;
}

uint64_t (***dyld4::APIs::_dyld_fork_child(dyld4::RuntimeLocks **this))(_QWORD)
{
  mach_task_self_ = task_self_trap();
  dyld4::ExternallyViewableState::fork_child((uint64_t)(this + 71));
  return dyld4::RuntimeLocks::resetLockInForkChild(this[17]);
}

uint64_t (***dyld4::APIs::_dyld_after_fork_dlopen_child(dyld4::RuntimeLocks **this))(_QWORD)
{
  return dyld4::RuntimeLocks::resetDlopenLockInForkChild(this[17]);
}

uint64_t ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke_2(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;

  result = objc::objc_headeropt_rw_t<unsigned long>::isLoaded(*(unsigned int **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 296), a3);
  if ((_DWORD)result)
    return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return result;
}

uint64_t ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke_2(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;

  result = objc::objc_headeropt_rw_t<unsigned long>::isLoaded(*(unsigned int **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 296), a3);
  if ((_DWORD)result)
    return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return result;
}

uint64_t dyld4::APIs::_dyld_visit_objc_classes(dyld4::RuntimeState *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t result;
  _QWORD v12[6];

  v10 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v10 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_visit_objc_classes()\n");
    v10 = *((_QWORD *)this + 1);
  }
  result = *(_QWORD *)(v10 + 312);
  if (result)
  {
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    v12[2] = ___ZN5dyld44APIs24_dyld_visit_objc_classesEU13block_pointerFvPKvE_block_invoke;
    v12[3] = &unk_1E4F7DD38;
    v12[4] = a2;
    v12[5] = this;
    return objc::ObjectHashTable::forEachObject(result, (uint64_t)v12, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t ___ZN5dyld44APIs24_dyld_visit_objc_classesEU13block_pointerFvPKvE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v4 = a4[2];
  if (v4)
  {
    v5 = result;
    v6 = *a4;
    v7 = 16 * v4;
    do
    {
      v6 += 16;
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v5 + 32) + 16))();
      v7 -= 16;
    }
    while (v7);
  }
  return result;
}

uint64_t dyld4::APIs::_dyld_is_preoptimized_objc_image_loaded(dyld4::APIs *this, unsigned int a2)
{
  uint64_t v4;
  unsigned int *v5;
  uint64_t isLoaded;
  uint64_t v7;

  v4 = *((_QWORD *)this + 1);
  if (!*(_QWORD *)(v4 + 240))
  {
    if (*(_BYTE *)(v4 + 204))
      dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) : no dyld shared cache\n");
    return 0;
  }
  v5 = *(unsigned int **)(v4 + 296);
  if (!v5)
  {
    if (*(_BYTE *)(v4 + 204))
      dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) : no objC RW header\n");
    return 0;
  }
  if (*v5 <= a2)
  {
    if (*(_BYTE *)(v4 + 204))
      dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) : imageID is invalid\n");
    return 0;
  }
  isLoaded = objc::objc_headeropt_rw_t<unsigned long>::isLoaded(v5, a2);
  v7 = isLoaded;
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) => %d\n", a2, isLoaded);
  return v7;
}

uint64_t dyld4::APIs::_dyld_objc_uses_large_shared_cache(dyld4::APIs *this)
{
  return 1;
}

uint64_t dyld4::APIs::_dyld_pseudodylib_register_callbacks(dyld4::RuntimeState *this, const void *a2)
{
  uint64_t v3;
  lsl::Lock *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t **v9[3];
  uint64_t v10;
  const void *v11;
  lsl::Lock *v12;

  v11 = a2;
  v3 = *((_QWORD *)this + 1);
  if (!*(_BYTE *)(v3 + 192))
  {
    if (*(_BYTE *)(v3 + 204))
      dyld4::RuntimeState::log(this, "_dyld_pseudodylib_register_callbacks() => nullptr: blocked by security policy");
    return 0;
  }
  v9[2] = (uint64_t **)this;
  v10 = 0;
  v4 = (lsl::Lock *)*((_QWORD *)this + 16);
  v5 = (_QWORD *)*((_QWORD *)this + 17);
  v9[0] = (uint64_t **)&v11;
  v9[1] = (uint64_t **)&v10;
  lsl::MemoryManager::lockGuard(v4, &v12);
  v6 = *((_QWORD *)v4 + 3);
  if (!v6)
  {
    lsl::MemoryManager::writeProtect(v4, 0);
    v6 = *((_QWORD *)v4 + 3);
  }
  *((_QWORD *)v4 + 3) = v6 + 1;
  lsl::Lock::unlock(v12);
  if (*v5)
  {
    (*(void (**)(_QWORD, _QWORD *, _QWORD))(*(_QWORD *)*v5 + 104))(*v5, v5 + 1, 0);
    dyld4::APIs::_dyld_pseudodylib_register_callbacks(_dyld_pseudodylib_callbacks const*)::$_0::operator()(v9);
    (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 112))(*v5, v5 + 1);
  }
  else
  {
    dyld4::APIs::_dyld_pseudodylib_register_callbacks(_dyld_pseudodylib_callbacks const*)::$_0::operator()(v9);
  }
  lsl::MemoryManager::lockGuard(v4, &v12);
  v7 = *((_QWORD *)v4 + 3) - 1;
  *((_QWORD *)v4 + 3) = v7;
  if (!v7)
    lsl::MemoryManager::writeProtect(v4, 1);
  lsl::Lock::unlock(v12);
  result = v10;
  if (!v10)
  {
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    {
      dyld4::RuntimeState::log(this, "_dyld_pseudodylib_register_callbacks(%p): callbacks struct version not recognized", v11);
      return v10;
    }
    return 0;
  }
  return result;
}

void dyld4::APIs::_dyld_pseudodylib_deregister_callbacks(dyld4::RuntimeState *this, _QWORD *a2)
{
  uint64_t v3;
  lsl::Lock *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  lsl::Lock *v9;

  v3 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v3 + 192))
  {
    if (a2)
    {
      v5 = (lsl::Lock *)*((_QWORD *)this + 16);
      v6 = (_QWORD *)*((_QWORD *)this + 17);
      lsl::MemoryManager::lockGuard(v5, &v9);
      v7 = *((_QWORD *)v5 + 3);
      if (!v7)
      {
        lsl::MemoryManager::writeProtect(v5, 0);
        v7 = *((_QWORD *)v5 + 3);
      }
      *((_QWORD *)v5 + 3) = v7 + 1;
      lsl::Lock::unlock(v9);
      if (*v6)
      {
        (*(void (**)(_QWORD, _QWORD *, _QWORD))(*(_QWORD *)*v6 + 104))(*v6, v6 + 1, 0);
        lsl::Allocator::free(*((lsl::Allocator **)this + 2), a2);
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)*v6 + 112))(*v6, v6 + 1);
      }
      else
      {
        lsl::Allocator::free(*((lsl::Allocator **)this + 2), a2);
      }
      lsl::MemoryManager::lockGuard(v5, &v9);
      v8 = *((_QWORD *)v5 + 3) - 1;
      *((_QWORD *)v5 + 3) = v8;
      if (!v8)
        lsl::MemoryManager::writeProtect(v5, 1);
      lsl::Lock::unlock(v9);
    }
  }
  else if (*(_BYTE *)(v3 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_pseudodylib_deregister_callbacks(): blocked by security policy");
  }
}

_QWORD *dyld4::APIs::_dyld_pseudodylib_register(dyld4::RuntimeState *this, dyld3::MachOFile *a2, uint64_t a3, const void *a4, const void *a5)
{
  uint64_t v6;
  char *v11;
  const char *v12;
  lsl::Lock *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;
  lsl::Lock *v32;

  v6 = *((_QWORD *)this + 1);
  if (!*(_BYTE *)(v6 + 192))
  {
    if (*(_BYTE *)(v6 + 204))
      dyld4::RuntimeState::log(this, "_dyld_pseudodylib_register() => nullptr: blocked by security policy");
    return 0;
  }
  v11 = dyld3::MachOFile::installName(a2);
  if (!v11)
  {
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
      dyld4::RuntimeState::log(this, "_dyld_register_pseudodylib(%p, %lx, %p, %p): registered range does not contain an install name");
    return 0;
  }
  v12 = v11;
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_register_pseudodylib(%p, %lx, %p, %p): [%p, %p) \"%s\"\n", a2, a3, a4, a5, a2, (char *)a2 + a3, v11);
  v13 = (lsl::Lock *)*((_QWORD *)this + 16);
  v14 = (_QWORD *)*((_QWORD *)this + 17);
  lsl::MemoryManager::lockGuard(v13, &v32);
  v15 = *((_QWORD *)v13 + 3);
  if (!v15)
  {
    lsl::MemoryManager::writeProtect(v13, 0);
    v15 = *((_QWORD *)v13 + 3);
  }
  v31 = a3;
  *((_QWORD *)v13 + 3) = v15 + 1;
  lsl::Lock::unlock(v32);
  if (*v14)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)*v14 + 104))(*v14);
    v16 = *((_QWORD *)this + 79);
    if (v16)
    {
      v17 = (uint64_t *)*((_QWORD *)this + 78);
      v18 = 8 * v16;
      while (1)
      {
        v19 = *v17;
        if (!_platform_strcmp(*(const char **)(*v17 + 32), v12))
          break;
        ++v17;
        v18 -= 8;
        if (!v18)
          goto LABEL_12;
      }
      v21 = 0;
      v20 = v31;
    }
    else
    {
LABEL_12:
      v20 = v31;
      v21 = dyld4::PseudoDylib::create(*((lsl::Allocator **)this + 2), (unint64_t)v12, (unint64_t)a2, v31, (uint64_t)a4, (uint64_t)a5);
      lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 616, *((_QWORD *)this + 79) + 1);
      v19 = 0;
      v22 = *((_QWORD *)this + 78);
      v23 = *((_QWORD *)this + 79);
      *((_QWORD *)this + 79) = v23 + 1;
      *(_QWORD *)(v22 + 8 * v23) = v21;
    }
    (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)*v14 + 112))(*v14, v14 + 1);
  }
  else
  {
    v24 = *((_QWORD *)this + 79);
    if (v24)
    {
      v25 = (uint64_t *)*((_QWORD *)this + 78);
      v26 = 8 * v24;
      while (1)
      {
        v19 = *v25;
        if (!_platform_strcmp(*(const char **)(*v25 + 32), v12))
          break;
        ++v25;
        v26 -= 8;
        if (!v26)
          goto LABEL_22;
      }
      v21 = 0;
      v20 = v31;
    }
    else
    {
LABEL_22:
      v20 = v31;
      v21 = dyld4::PseudoDylib::create(*((lsl::Allocator **)this + 2), (unint64_t)v12, (unint64_t)a2, v31, (uint64_t)a4, (uint64_t)a5);
      lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 616, *((_QWORD *)this + 79) + 1);
      v19 = 0;
      v27 = *((_QWORD *)this + 78);
      v28 = *((_QWORD *)this + 79);
      *((_QWORD *)this + 79) = v28 + 1;
      *(_QWORD *)(v27 + 8 * v28) = v21;
    }
  }
  lsl::MemoryManager::lockGuard(v13, &v32);
  v29 = *((_QWORD *)v13 + 3) - 1;
  *((_QWORD *)v13 + 3) = v29;
  if (!v29)
    lsl::MemoryManager::writeProtect(v13, 1);
  lsl::Lock::unlock(v32);
  if (v19)
  {
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
      dyld4::RuntimeState::log(this, "_dyld_register_pseudodylib(\"%s\", %p, %lx): identifier conflicts with existing registration covering [%p, %p)", v12, a2, v20, *(const void **)v19, (const void *)(*(_QWORD *)v19 + *(_QWORD *)(v19 + 8)));
    if (v21)
      dyld4::APIs::_dyld_pseudodylib_register();
  }
  return v21;
}

void dyld4::APIs::_dyld_pseudodylib_deregister(lsl::Allocator **this, uint64_t a2)
{
  lsl::Lock *v4;
  lsl::Allocator *v5;
  uint64_t v6;
  lsl::Allocator *v7;
  lsl::Allocator *v8;
  size_t v9;
  lsl::Allocator *v10;
  uint64_t v11;
  int v12;
  lsl::Allocator *v13;
  lsl::Allocator *v14;
  size_t v15;
  lsl::Allocator *v16;
  uint64_t v17;
  uint64_t v18;
  lsl::Lock *v19;

  if (*((_BYTE *)this[1] + 204))
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_deregister_pseudodylib(<handle for \"%s\">)\n", *(const char **)(a2 + 32));
  v4 = this[16];
  v5 = this[17];
  lsl::MemoryManager::lockGuard(v4, &v19);
  v6 = *((_QWORD *)v4 + 3);
  if (!v6)
  {
    lsl::MemoryManager::writeProtect(v4, 0);
    v6 = *((_QWORD *)v4 + 3);
  }
  *((_QWORD *)v4 + 3) = v6 + 1;
  lsl::Lock::unlock(v19);
  if (*(_QWORD *)v5)
  {
    (*(void (**)(_QWORD, _QWORD *, _QWORD))(**(_QWORD **)v5 + 104))(*(_QWORD *)v5, (_QWORD *)v5 + 1, 0);
    v7 = this[79];
    if (v7)
    {
      v8 = this[78];
      v9 = 8 * (_QWORD)v7 - 8;
      v10 = v8;
      while (1)
      {
        v11 = *(_QWORD *)v10;
        v10 = (lsl::Allocator *)((char *)v10 + 8);
        if (v11 == a2)
          break;
        v9 -= 8;
        v8 = v10;
        if (v9 == -8)
          goto LABEL_10;
      }
      if (v9)
      {
        memmove(v8, (char *)v8 + 8, v9);
        v7 = this[79];
      }
      this[79] = (lsl::Allocator *)((char *)v7 - 1);
      lsl::Allocator::free(this[2], (_QWORD *)a2);
      v12 = 1;
    }
    else
    {
LABEL_10:
      v12 = 0;
    }
    (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)v5 + 112))(*(_QWORD *)v5, (_QWORD *)v5 + 1);
  }
  else
  {
    v13 = this[79];
    if (v13)
    {
      v14 = this[78];
      v15 = 8 * (_QWORD)v13 - 8;
      v16 = v14;
      while (1)
      {
        v17 = *(_QWORD *)v16;
        v16 = (lsl::Allocator *)((char *)v16 + 8);
        if (v17 == a2)
          break;
        v15 -= 8;
        v14 = v16;
        if (v15 == -8)
          goto LABEL_15;
      }
      if (v15)
      {
        memmove(v14, (char *)v14 + 8, v15);
        v13 = this[79];
      }
      this[79] = (lsl::Allocator *)((char *)v13 - 1);
      lsl::Allocator::free(this[2], (_QWORD *)a2);
      v12 = 1;
    }
    else
    {
LABEL_15:
      v12 = 0;
    }
  }
  lsl::MemoryManager::lockGuard(v4, &v19);
  v18 = *((_QWORD *)v4 + 3) - 1;
  *((_QWORD *)v4 + 3) = v18;
  if (!v18)
    lsl::MemoryManager::writeProtect(v4, 1);
  lsl::Lock::unlock(v19);
  if (!v12)
  {
    if (*((_BYTE *)this[1] + 204))
      dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_deregister_pseudodylib(<handle for \"%s\">): no registered pseudo-dylib for handle", *(const char **)(a2 + 32));
  }
}

uint64_t dyld4::APIs::_dyld_has_fix_for_radar(dyld4::APIs *this, const char *a2)
{
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_has_fix_for_radar(%s)\n", a2);
  return 0;
}

void dyld4::APIs::_dyld_register_driverkit_main(dyld4::APIs *this, void (*a2)(void))
{
  uint64_t v4;

  v4 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v4 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_register_driverkit_main(%p)\n", a2);
    v4 = *((_QWORD *)this + 1);
  }
  if (*(_DWORD *)(v4 + 68) == 10)
  {
    if (*((_QWORD *)this + 132))
      dyld4::halt("_dyld_register_driverkit_main() may only be called once", 0);
    *((_QWORD *)this + 132) = a2;
  }
  else
  {
    dyld4::RuntimeState::log(this, "_dyld_register_driverkit_main() can only be called in DriverKit processes\n");
  }
}

uint64_t dyld4::APIs::_dyld_shared_cache_is_locally_built(dyld4::APIs *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *((_QWORD *)this + 1);
  v2 = *(_QWORD *)(v1 + 240);
  if (v2)
    v3 = (*(unsigned __int8 *)(v2 + 221) >> 2) & 1;
  else
    v3 = 0;
  if (*(_BYTE *)(v1 + 204))
    dyld4::RuntimeState::log(this, "_dyld_shared_cache_is_locally_built() => %d\n", v3);
  return v3;
}

uint64_t dyld4::APIs::dyld_need_closure(dyld4::APIs *this, const char *a2, const char *a3)
{
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "dyld_need_closure()\n", a3);
  return 0;
}

void dyld4::APIs::_dyld_missing_symbol_abort(dyld4::APIs *this)
{
  dyld4::halt("missing symbol called", 0);
}

uint64_t dyld4::APIs::_dyld_dlsym_blocked(dyld4::APIs *this)
{
  return *(unsigned __int8 *)(*((_QWORD *)this + 1) + 170);
}

void dyld4::APIs::_tlv_bootstrap(dyld4::APIs *this)
{
  dyld4::halt("_tlv_bootstrap called", 0);
}

void dyld4::APIs::obsolete(dyld4::APIs *this)
{
  dyld4::halt("obsolete dyld API called", 0);
}

uint64_t dyld4::APIs::NSCreateObjectFileImageFromFile(dyld4::APIs *this, const char *a2, __NSObjectFileImage **a3)
{
  dyld4::APIs *v3;
  const void *v4;
  unint64_t v5;
  __NSObjectFileImage **v6;

  v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, __NSObjectFileImage **))(*(_QWORD *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSCreateObjectFileImageFromMemory(v3, v4, v5, v6);
}

uint64_t dyld4::APIs::NSCreateObjectFileImageFromMemory(dyld4::APIs *this, const void *a2, uint64_t a3, __NSObjectFileImage **a4)
{
  dyld4::APIs *v4;
  __NSObjectFileImage *v5;
  const char *v6;
  unsigned int v7;

  v4 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const void *, uint64_t, __NSObjectFileImage **))(*(_QWORD *)this + 800))(this, a2, a3, a4);
  return dyld4::APIs::NSLinkModule(v4, v5, v6, v7);
}

uint64_t dyld4::APIs::NSLinkModule(dyld4::APIs *this, __NSObjectFileImage *a2, const char *a3)
{
  dyld4::APIs *v3;
  __NSModule *v4;
  unsigned int v5;

  v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *, const char *))(*(_QWORD *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSUnLinkModule(v3, v4, v5);
}

uint64_t dyld4::APIs::NSUnLinkModule(dyld4::APIs *this, __NSModule *a2)
{
  dyld4::APIs *v2;
  __NSObjectFileImage *v3;

  v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSModule *))(*(_QWORD *)this + 800))(this, a2);
  return dyld4::APIs::NSDestroyObjectFileImage(v2, v3);
}

uint64_t dyld4::APIs::NSDestroyObjectFileImage(dyld4::APIs *this, __NSObjectFileImage *a2)
{
  dyld4::APIs *v2;
  __NSObjectFileImage *v3;
  const char *v4;

  v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *))(*(_QWORD *)this + 800))(this, a2);
  return dyld4::APIs::NSIsSymbolDefinedInObjectFileImage(v2, v3, v4);
}

uint64_t dyld4::APIs::NSIsSymbolDefinedInObjectFileImage(dyld4::APIs *this, __NSObjectFileImage *a2, const char *a3)
{
  dyld4::APIs *v3;
  __NSObjectFileImage *v4;
  const char *v5;
  const char *v6;
  unint64_t *v7;

  v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *, const char *))(*(_QWORD *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSGetSectionDataInObjectFileImage(v3, v4, v5, v6, v7);
}

uint64_t dyld4::APIs::NSGetSectionDataInObjectFileImage(dyld4::APIs *this, __NSObjectFileImage *a2, const char *a3, const char *a4, unint64_t *a5)
{
  dyld4::APIs *v5;
  __NSModule *v6;

  v5 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *, const char *, const char *, unint64_t *))(*(_QWORD *)this + 800))(this, a2, a3, a4, a5);
  return dyld4::APIs::NSNameOfModule(v5, v6);
}

void dyld4::APIs::NSNameOfModule(dyld4::APIs *this, __NSModule *a2)
{
  (*(void (**)(dyld4::APIs *, __NSModule *))(*(_QWORD *)this + 800))(this, a2);
  JUMPOUT(0x1A5C9E498);
}

uint64_t dyld4::APIs::NSIsSymbolNameDefined(dyld4::APIs *this, const char *a2)
{
  dyld4::APIs *v2;
  const char *v3;
  const char *v4;

  v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(_QWORD *)this + 800))(this, a2);
  return dyld4::APIs::NSIsSymbolNameDefinedWithHint(v2, v3, v4);
}

uint64_t dyld4::APIs::NSIsSymbolNameDefinedWithHint(dyld4::APIs *this, const char *a2, const char *a3)
{
  dyld4::APIs *v3;
  const mach_header *v4;
  const char *v5;

  v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, const char *))(*(_QWORD *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSIsSymbolNameDefinedInImage(v3, v4, v5);
}

uint64_t dyld4::APIs::NSIsSymbolNameDefinedInImage(dyld4::APIs *this, const mach_header *a2, const char *a3)
{
  dyld4::APIs *v3;
  const char *v4;

  v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const mach_header *, const char *))(*(_QWORD *)this
                                                                                                  + 800))(this, a2, a3);
  return dyld4::APIs::NSLookupAndBindSymbol(v3, v4);
}

uint64_t dyld4::APIs::NSLookupAndBindSymbol(dyld4::APIs *this, const char *a2)
{
  dyld4::APIs *v2;
  const char *v3;
  const char *v4;

  v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(_QWORD *)this + 800))(this, a2);
  return dyld4::APIs::NSLookupAndBindSymbolWithHint(v2, v3, v4);
}

uint64_t dyld4::APIs::NSLookupAndBindSymbolWithHint(dyld4::APIs *this, const char *a2, const char *a3)
{
  dyld4::APIs *v3;
  __NSModule *v4;
  const char *v5;

  v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, const char *))(*(_QWORD *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSLookupSymbolInModule(v3, v4, v5);
}

uint64_t dyld4::APIs::NSLookupSymbolInModule(dyld4::APIs *this, __NSModule *a2, const char *a3)
{
  dyld4::APIs *v3;
  const mach_header *v4;
  const char *v5;
  unsigned int v6;

  v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSModule *, const char *))(*(_QWORD *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSLookupSymbolInImage(v3, v4, v5, v6);
}

uint64_t dyld4::APIs::NSLookupSymbolInImage(dyld4::APIs *this, const mach_header *a2, const char *a3)
{
  dyld4::APIs *v3;
  __NSSymbol *v4;

  v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const mach_header *, const char *))(*(_QWORD *)this
                                                                                                  + 800))(this, a2, a3);
  return dyld4::APIs::NSAddressOfSymbol(v3, v4);
}

uint64_t dyld4::APIs::NSAddressOfSymbol(dyld4::APIs *this, __NSSymbol *a2)
{
  dyld4::APIs *v2;
  __NSSymbol *v3;

  v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSSymbol *))(*(_QWORD *)this + 800))(this, a2);
  return dyld4::APIs::NSModuleForSymbol(v2, v3);
}

uint64_t dyld4::APIs::NSModuleForSymbol(dyld4::APIs *this, __NSSymbol *a2)
{
  dyld4::APIs *v2;
  NSLinkEditErrors *v3;
  int *v4;
  const char **v5;
  const char **v6;

  v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSSymbol *))(*(_QWORD *)this + 800))(this, a2);
  return dyld4::APIs::NSLinkEditError(v2, v3, v4, v5, v6);
}

uint64_t dyld4::APIs::NSLinkEditError(dyld4::APIs *this, NSLinkEditErrors *a2, int *a3, const char **a4, const char **a5)
{
  dyld4::APIs *v5;
  const char *v6;

  v5 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, NSLinkEditErrors *, int *, const char **, const char **))(*(_QWORD *)this + 800))(this, a2, a3, a4, a5);
  return dyld4::APIs::NSAddLibrary(v5, v6);
}

uint64_t dyld4::APIs::NSAddLibrary(dyld4::APIs *this, const char *a2)
{
  dyld4::APIs *v2;
  const char *v3;

  v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(_QWORD *)this + 800))(this, a2);
  return dyld4::APIs::NSAddLibraryWithSearching(v2, v3);
}

uint64_t dyld4::APIs::NSAddLibraryWithSearching(dyld4::APIs *this, const char *a2)
{
  dyld4::APIs *v2;
  const char *v3;
  unsigned int v4;

  v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(_QWORD *)this + 800))(this, a2);
  return dyld4::APIs::NSAddImage(v2, v3, v4);
}

uint64_t dyld4::APIs::NSAddImage(dyld4::APIs *this, const char *a2)
{
  dyld4::APIs *v2;
  const void *v3;

  v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(_QWORD *)this + 800))(this, a2);
  return dyld4::APIs::_dyld_image_containing_address(v2, v3);
}

uint64_t dyld4::APIs::_dyld_image_containing_address(dyld4::APIs *this, const void *a2)
{
  dyld4::APIs *v2;
  const char *v3;
  void **v4;
  __NSModule **v5;

  v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const void *))(*(_QWORD *)this + 800))(this, a2);
  return dyld4::APIs::_dyld_lookup_and_bind(v2, v3, v4, v5);
}

uint64_t dyld4::APIs::_dyld_lookup_and_bind(dyld4::APIs *this, const char *a2, void **a3, __NSModule **a4)
{
  dyld4::APIs *v4;
  const char *v5;
  const char *v6;
  void **v7;
  __NSModule **v8;

  v4 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, void **, __NSModule **))(*(_QWORD *)this + 800))(this, a2, a3, a4);
  return dyld4::APIs::_dyld_lookup_and_bind_with_hint(v4, v5, v6, v7, v8);
}

void dyld4::APIs::_dyld_lookup_and_bind_with_hint(dyld4::APIs *this, const char *a2, const char *a3, void **a4, __NSModule **a5)
{
  (*(void (**)(dyld4::APIs *, const char *, const char *, void **, __NSModule **))(*(_QWORD *)this + 800))(this, a2, a3, a4, a5);
  JUMPOUT(0x1A5C9E618);
}

const os_unfair_lock *dyld4::APIs::_dyld_register_dlsym_notifier(dyld4::APIs *this, void (*a2)(const char *))
{
  lsl::Lock *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  lsl::Lock *v9;

  v4 = (lsl::Lock *)*((_QWORD *)this + 16);
  v5 = (_QWORD *)*((_QWORD *)this + 17);
  lsl::MemoryManager::lockGuard(v4, &v9);
  v6 = *((_QWORD *)v4 + 3);
  if (!v6)
  {
    lsl::MemoryManager::writeProtect(v4, 0);
    v6 = *((_QWORD *)v4 + 3);
  }
  *((_QWORD *)v4 + 3) = v6 + 1;
  lsl::Lock::unlock(v9);
  if (*v5)
  {
    (*(void (**)(_QWORD, _QWORD *, _QWORD))(*(_QWORD *)*v5 + 104))(*v5, v5 + 2, 0);
    *((_QWORD *)this + 123) = a2;
    (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 112))(*v5, v5 + 2);
  }
  else
  {
    *((_QWORD *)this + 123) = a2;
  }
  lsl::MemoryManager::lockGuard(v4, &v9);
  v7 = *((_QWORD *)v4 + 3) - 1;
  *((_QWORD *)v4 + 3) = v7;
  if (!v7)
    lsl::MemoryManager::writeProtect(v4, 1);
  return lsl::Lock::unlock(v9);
}

const void *dyld4::APIs::_dyld_get_swift_prespecialized_data(dyld4::APIs *this)
{
  uint64_t v1;
  DyldSharedCache *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;

  v1 = *((_QWORD *)this + 1);
  if ((*(_BYTE *)(v1 + 97) & 1) != 0)
    return 0;
  if (*(_BYTE *)(v1 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_get_swift_prespecialized_data()\n");
    v1 = *((_QWORD *)this + 1);
  }
  v3 = *(DyldSharedCache **)(v1 + 240);
  if (!v3)
    return 0;
  v4 = DyldSharedCache::swiftOpt(v3);
  if (!v4)
    return 0;
  if (*(_DWORD *)v4 < 2u)
    return 0;
  v5 = *(_QWORD *)(v4 + 32);
  if (!v5)
    return 0;
  v6 = *((_QWORD *)this + 1);
  v7 = (const void *)(*(_QWORD *)(v6 + 240) + v5);
  if (*(_BYTE *)(v6 + 204))
    dyld4::RuntimeState::log(this, "_dyld_get_swift_prespecialized_data() => %p\n", v7);
  return v7;
}

BOOL dyld4::APIs::_dyld_is_pseudodylib(dyld4::APIs *this, unint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;

  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_is_pseudodylib(%p)\n", (const void *)a2);
  if (a2)
    v4 = a2 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_1A5C55000;
  else
    v4 = 0;
  result = dyld4::APIs::validLoader((lsl::Allocator **)this, (const dyld4::Loader *)v4);
  if ((_DWORD)result)
  {
    result = 0;
    if (v4)
    {
      if ((*(_WORD *)(v4 + 4) & 1) == 0)
        return *(_QWORD *)(v4 + 104) != 0;
    }
  }
  return result;
}

char *dyld4::APIs::_dyld_find_pointer_hash_table_entry(dyld4::APIs *this, unsigned int *a2, DyldSharedCache *a3, unint64_t a4, const void **a5)
{
  uint64_t v10;
  DyldSharedCache *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  DyldSharedCache *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  DyldSharedCache *v24;
  int v26;
  unsigned int Potential;
  objc *v28;
  int v29;
  _QWORD v30[64];

  v10 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v10 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry(%p, %p, %lu, %p)\n", a2, a3, a4, a5);
    v10 = *((_QWORD *)this + 1);
  }
  v11 = *(DyldSharedCache **)(v10 + 240);
  if (!v11)
    return 0;
  v12 = DyldSharedCache::swiftOpt(v11);
  if (!v12 || *(_DWORD *)v12 < 3u)
    return 0;
  v13 = 0;
  while (1)
  {
    v14 = *(_QWORD *)(v12 + 40 + v13);
    if (!v14)
      goto LABEL_16;
    if ((unsigned int *)(*(_QWORD *)(*((_QWORD *)this + 1) + 240) + v14) == a2)
      break;
    v13 += 8;
    if (v13 == 64)
      goto LABEL_16;
  }
  if (!a2)
  {
LABEL_16:
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
      dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() invalid table pointer %p\n");
    return 0;
  }
  if (!*(_QWORD *)(v12 + 32))
    return 0;
  v15 = *((_QWORD *)this + 1);
  if (a4 >= 0x40)
  {
    if (*(_BYTE *)(v15 + 204))
      dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() exceeded key pointers limit: %lu\n");
    return 0;
  }
  v18 = *(DyldSharedCache **)(v15 + 240);
  v19 = (unint64_t)v18 + DyldSharedCache::mappedSize(v18);
  v20 = *((_QWORD *)this + 1);
  if (v18 > a3 || v19 <= (unint64_t)a3)
  {
    if (!*(_BYTE *)(v20 + 204))
      return 0;
    goto LABEL_40;
  }
  v22 = *(_QWORD *)(v20 + 240);
  v30[0] = (char *)a3 - v22;
  if (a4)
  {
    v23 = 0;
    while (1)
    {
      v24 = (DyldSharedCache *)a5[v23];
      if (v24 < v18 || (unint64_t)v24 >= v19)
        break;
      v30[++v23] = (char *)v24 - v22;
      if (a4 == v23)
      {
        v26 = v23 + 1;
        goto LABEL_35;
      }
    }
    if (!*(_BYTE *)(v20 + 204))
      return 0;
LABEL_40:
    dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() key %p not in shared cache\n");
    return 0;
  }
  v26 = 1;
LABEL_35:
  v28 = (objc *)v30;
  v29 = v26;
  Potential = SwiftHashTable::getPotentialTarget<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(a2, &v28);
  v16 = 0;
  if (Potential != a2[4])
    v16 = (char *)v18 + (*(_QWORD *)((_BYTE *)a2 + Potential + 8) & 0x7FFFFFFFFFFFFFFFLL);
  if (*(_BYTE *)(*((_QWORD *)this + 1) + 204))
    dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() => %p\n", v16);
  return v16;
}

void ___ZN5dyld4L20findCacheInDirAndMapERNS_12RuntimeStateEPKhPKcRm_block_invoke(uint64_t a1, dyld3 *a2, DyldSharedCache *this)
{
  off_t st_size;
  int v6;
  int v7;
  void *v8;
  void *v9;
  DyldSharedCache *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  stat v15;

  if (!DyldSharedCache::isSubCachePath(this, (const char *)a2)
    && !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    if (stat64((const char *)a2, &v15) == -1)
    {
      v9 = 0;
      st_size = 0x100000;
    }
    else
    {
      if (v15.st_size >= 0x100000uLL)
        st_size = 0x100000;
      else
        st_size = v15.st_size;
      v6 = dyld3::open(a2, 0, 0);
      if (v6 < 0)
      {
        v9 = 0;
      }
      else
      {
        v7 = v6;
        v8 = mmap(0, st_size, 1, 2, v6, 0);
        close(v7);
        if (v8 == (void *)-1)
          v9 = 0;
        else
          v9 = v8;
      }
    }
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v9;
    v10 = *(DyldSharedCache **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v10)
    {
      *(_QWORD *)&v15.st_dev = 0;
      v15.st_ino = 0;
      DyldSharedCache::getUUID(v10, (__n128 *)&v15);
      v11 = *(uint64_t **)(a1 + 40);
      v13 = *v11;
      v12 = v11[1];
      if (*(_QWORD *)&v15.st_dev == v13 && v15.st_ino == v12)
      {
        **(_QWORD **)(a1 + 48) = st_size;
      }
      else
      {
        munmap(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), st_size);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      }
    }
  }
}

uint64_t objc::ObjectHashTable::forEachObject(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int64x2_t *v19;
  unint64_t *v20;
  __int16 *v21;
  uint64_t v22;
  unint64_t v23;
  int64x2_t v24;
  uint64_t *v25;
  int64x2_t v26;
  uint64_t v27;
  __int16 v28;

  v8 = *(_DWORD *)(result + 4);
  if (v8)
  {
    v10 = result;
    v11 = 0;
    v24 = vdupq_n_s64(1uLL);
    do
    {
      v12 = v10 + (*(_DWORD *)(v10 + 16) + 1) + v8 + 1056;
      v13 = v11;
      v14 = *(int *)(v12 + 4 * v11);
      if ((_DWORD)v14)
      {
        v15 = v10 + v14;
        v16 = *(_QWORD *)(v12 + 4 * v8 + 8 * v13);
        if ((v16 & 1) != 0)
        {
          __chkstk_darwin(result, a2, v15, a4, a5, a6, a7, a8, v24.i64[0]);
          if (v17)
          {
            v19 = &v24 - v17;
            do
            {
              v19->i64[0] = 0;
              v19->i16[4] = 0;
              ++v19;
            }
            while (v19 != &v24);
          }
          if (v17)
          {
            v20 = (unint64_t *)(v10
                                     + *(unsigned int *)(v10 + 4)
                                     + (*(_DWORD *)(v10 + 16) + 1)
                                     + 4 * *(unsigned int *)(v10 + 4)
                                     + 8 * *(unsigned int *)(v10 + 4)
                                     + 8 * ((*(_QWORD *)(v18 + 8 * v13) >> 1) & 0x7FFFFFFFFFFFLL)
                                     + 1060);
            v21 = &v24.i16[-8 * v17 + 4];
            v22 = v17;
            do
            {
              v23 = *v20++;
              *((_QWORD *)v21 - 1) = (v23 >> 1) & 0x7FFFFFFFFFFFLL;
              *v21 = HIWORD(v23);
              v21 += 8;
              --v22;
            }
            while (v22);
          }
          v25 = &v24.i64[-2 * v17];
          v26.i64[0] = v17;
          v26.i64[1] = v17;
          result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v13);
        }
        else
        {
          v27 = (v16 >> 1) & 0x7FFFFFFFFFFFLL;
          v28 = HIWORD(v16);
          v25 = &v27;
          v26 = v24;
          result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t **))(a2 + 16))(a2, v13, v15, &v25);
        }
      }
      v11 = v13 + 1;
      v8 = *(_DWORD *)(v10 + 4);
    }
    while ((_DWORD)v13 + 1 != v8);
  }
  return result;
}

void dyld4::APIs::dlopen_from(char const*,int,void *)::$_0::operator()(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  _QWORD **v7;
  _DWORD *v8;
  int v9;
  dyld4::Loader *v10;
  _DWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  lsl::AllocatorLayout *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  lsl::Allocator *v23;
  size_t v24;
  uint64_t v25;
  lsl::AllocatorLayout *v26;
  uint64_t v27;
  const char **v28;
  const char **v29;
  lsl::Allocator *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  dyld4::Loader *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t *v43;
  uint64_t v44;
  dyld4::Loader *v45;
  _BOOL8 v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  dyld4::Loader **v55;
  unint64_t v56;
  unint64_t v57;
  dyld4::Loader **v58;
  uint64_t v59;
  dyld4::Loader *v60;
  const char *v61;
  int v62;
  const char *v63;
  uint64_t v64;
  const dyld4::Loader **v65;
  uint64_t v66;
  const dyld4::Loader *v67;
  uint64_t v68;
  dyld4::Loader *v69;
  dyld4::Loader *v70;
  char *v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  dyld4::Loader **v77;
  uint64_t v78;
  const dyld3::MachOAnalyzer *v79;
  const char *v80;
  int v81;
  const char *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  _BYTE v88[16];
  lsl::Allocator *v89;
  dyld4::Loader **v90;
  unint64_t v91;
  uint64_t v92;
  __int128 v93;
  _QWORD *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD **v97;
  uint64_t v98;
  uint64_t v99;
  char v100;
  BOOL v101;
  BOOL v102;
  char v103;
  _QWORD **v104;
  uint64_t v105;
  uint64_t v106;
  _QWORD *v107;
  uint64_t v108;
  _QWORD v109[2];
  vm_address_t *v110;
  dyld4::Loader **v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  uint64_t v118;
  dyld4::Loader **v119;
  uint64_t v120;

  v2 = *(_QWORD *)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 48);
  v4 = *(_QWORD *)(*(_QWORD *)a1 + 240);
  v5 = *(_QWORD *)(*(_QWORD *)a1 + 304);
  Diagnostics::Diagnostics((Diagnostics *)&v110);
  v6 = *(_QWORD *)(v2 + 24);
  v109[0] = 0;
  v109[1] = v6;
  v7 = (_QWORD **)v109;
  v107 = v109;
  v8 = *(_DWORD **)(a1 + 16);
  v108 = **(_QWORD **)(a1 + 8);
  LOBYTE(v9) = v108;
  v106 = 0;
  v99 = 0;
  LODWORD(v8) = *v8;
  *(_DWORD *)((char *)&v99 + 3) = (v8 & 4) != 0;
  WORD2(v99) = (v8 & 0x80) != 0;
  BYTE5(v99) = (v8 & 0x10) != 0;
  HIBYTE(v99) = 1;
  v100 = 1;
  v101 = *(_DWORD *)(*(_QWORD *)(v2 + 8) + 68) == 1;
  v102 = (int)v8 < 0;
  if (v108)
  {
    v9 = HIBYTE(*(unsigned __int16 *)(v108 + 4)) & 1;
    v7 = &v107;
  }
  v103 = v9;
  v104 = v7;
  v105 = 0;
  **(_QWORD **)(a1 + 24) = dyld4::Loader::getLoader(&v110, (DyldSharedCache ***)v2, **(const char ***)(a1 + 32), (uint64_t)&v99);
  v10 = **(dyld4::Loader ***)(a1 + 24);
  if (!v10)
  {
    v80 = **(const char ***)(a1 + 32);
    v81 = **(_DWORD **)(a1 + 16);
    v82 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v110);
    dyld4::APIs::setErrorString((vm_address_t *)v2, "dlopen(%s, 0x%04X): %s", v80, v81, v82);
    goto LABEL_69;
  }
  if ((**(_BYTE **)(a1 + 16) & 4) == 0 && dyld4::Loader::hiddenFromFlat(v10, 0))
    dyld4::Loader::hiddenFromFlat(**(dyld4::Loader ***)(a1 + 24), 1);
  v11 = *(_DWORD **)(a1 + 16);
  if ((*v11 & 0x10) == 0)
  {
    v12 = *(uint64_t **)(a1 + 24);
    if ((*v11 & 0x80) != 0 && (*(_WORD *)(*v12 + 4) & 0x63) == 0)
    {
      *(_QWORD *)(*v12 + 40) |= 0x200000uLL;
      v11 = *(_DWORD **)(a1 + 16);
      v12 = *(uint64_t **)(a1 + 24);
    }
    v97 = v104;
    v98 = 0;
    v98 = *v12;
    *(_QWORD *)&v93 = 256;
    DWORD2(v93) = 0;
    v95 = 0;
    v96 = 0;
    v94 = 0;
    BYTE4(v93) = (*v11 & 0x80) != 0;
    BYTE7(v93) = 1;
    BYTE11(v93) = *(_BYTE *)(*v12 + 5) & 1;
    v94 = &v97;
    dyld4::Loader::loadDependents(*v12, (vm_address_t *)&v110, (dyld4::RuntimeState *)v2, &v93);
    v13 = *(_QWORD *)(v2 + 48);
    v15 = lsl::AllocatorLayout::minSize(v14);
    __chkstk_darwin(v15, v15 - v3 + 8 * v13 + 64, v16, v17, v18, v19, v20, v21, v87);
    v23 = (lsl::Allocator *)&v88[-v22 - 8];
    bzero(&v88[-v22 - 8], v24);
    v25 = *(_QWORD *)(v2 + 48);
    v27 = lsl::AllocatorLayout::minSize(v26);
    v30 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v23, (char *)(v27 - v3 + 8 * v25 + 64), v28, v29);
    v89 = v30;
    v90 = 0;
    v91 = 0;
    v92 = 0;
    lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v89, *(_QWORD *)(v2 + 48) - v3);
    if (v3 != *(_QWORD *)(v2 + 48))
    {
      v31 = v91;
      v32 = v3;
      do
      {
        v33 = *(_QWORD *)(v2 + 40);
        lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v89, v31 + 1);
        v34 = *(dyld4::Loader **)(v33 + 8 * v32);
        v35 = v91;
        v31 = ++v91;
        v90[v35] = v34;
        ++v32;
      }
      while (v32 != *(_QWORD *)(v2 + 48));
    }
    dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter((uint64_t)v88, v2);
    if (Diagnostics::noError((Diagnostics *)&v110) && v91)
    {
      if (*(_BYTE *)(*(_QWORD *)(v2 + 8) + 161))
      {
        v111 = v90;
        *(_QWORD *)&v112 = v91;
        dyld4::Loader::addWeakDefsToMap((dyld4::RuntimeState *)v2, (uint64_t)&v111);
      }
      LODWORD(v111) = 520552460;
      v112 = 0u;
      v113 = 0u;
      v114 = 0u;
      v115 = 0u;
      v116 = 0u;
      v117 = 0u;
      v118 = 0;
      dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v111, v36, v37, v38, v39, v40, v41, v42);
      if (v91)
      {
        v43 = (uint64_t *)v90;
        v44 = 8 * v91;
        do
        {
          v45 = (dyld4::Loader *)*v43;
          dyld4::Loader::applyFixups(*v43, (Diagnostics *)&v110, v2, (dyld4::DyldCacheDataConstLazyScopedWriter *)v88, (**(_DWORD **)(a1 + 16) & 2) == 0, *(_QWORD *)(a1 + 56));
          if (Diagnostics::hasError((Diagnostics *)&v110))
            break;
          dyld4::Loader::applyCachePatches(v45, (dyld4::RuntimeState *)v2, (dyld4::DyldCacheDataConstLazyScopedWriter *)v88);
          ++v43;
          v44 -= 8;
        }
        while (v44);
      }
      dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v111);
      v46 = Diagnostics::noError((Diagnostics *)&v110);
      if (v46)
      {
        __chkstk_darwin(v46, v47, v48, v49, v50, v51, v52, v53, v87);
        v55 = (dyld4::Loader **)&v88[-((v54 + 23) & 0xFFFFFFFFFFFFFFF0) - 8];
        v56 = v91;
        v111 = v55;
        v112 = v91;
        if (v91)
        {
          v57 = 0;
          v58 = v90;
          v59 = 8 * v91;
          do
          {
            v60 = *v58;
            if ((*((_WORD *)*v58 + 2) & 0x22) == 0x20)
            {
              if (v57 >= v56)
                ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
              *((_QWORD *)&v112 + 1) = v57 + 1;
              v111[v57++] = v60;
            }
            ++v58;
            v59 -= 8;
          }
          while (v59);
          if (v57)
          {
            dyld4::RuntimeState::addPermanentRanges(v2, (uint64_t)&v111);
            v56 = v91;
          }
        }
        v119 = v90;
        v120 = v56;
        dyld4::RuntimeState::notifyDtrace(v2, (uint64_t)&v119);
        v119 = v90;
        v120 = v91;
        dyld4::RuntimeState::rebindMissingFlatLazySymbols(v2, &v119);
      }
    }
    if (Diagnostics::noError((Diagnostics *)&v110))
      dyld4::RuntimeState::incDlRefCount(v2, **(const dyld4::Loader ***)(a1 + 24));
    if (!Diagnostics::hasError((Diagnostics *)&v110))
      goto LABEL_49;
    v61 = **(const char ***)(a1 + 32);
    v62 = **(_DWORD **)(a1 + 16);
    v63 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v110);
    dyld4::APIs::setErrorString((vm_address_t *)v2, "dlopen(%s, 0x%04X): %s", v61, v62, v63);
    v111 = v90;
    *(_QWORD *)&v112 = v91;
    dyld4::RuntimeState::removeMissingFlatLazySymbols(v2, (uint64_t)&v111);
    v65 = v90;
    v64 = v91;
    if (*(_QWORD *)(v2 + 368))
    {
      if (!v91)
      {
LABEL_43:
        if (*(_QWORD *)(v2 + 48) > v3)
          *(_QWORD *)(v2 + 48) = v3;
        **(_QWORD **)(a1 + 40) = 0;
        **(_QWORD **)(a1 + 24) = 0;
        *(_QWORD *)(v2 + 272) = 0;
        if (*(_QWORD *)(v2 + 240) > v4)
          *(_QWORD *)(v2 + 240) = v4;
        if (*(_QWORD *)(v2 + 304) > v5)
          *(_QWORD *)(v2 + 304) = v5;
LABEL_49:
        if (**(_QWORD **)(a1 + 24) && (**(_BYTE **)(a1 + 16) & 0x10) == 0 && Diagnostics::noError((Diagnostics *)&v110))
        {
          v119 = **(dyld4::Loader ****)(a1 + 24);
          dyld4::RuntimeState::partitionDelayLoads(v2, v90, v91, (dyld4::Loader **)&v119, 1, *(_QWORD *)(a1 + 64));
          if (*(_QWORD *)(*(_QWORD *)(v2 + 8) + 232))
          {
            strcpy((char *)&v111, "dlopen");
            v70 = **(dyld4::Loader ***)(a1 + 8);
            if (v70)
            {
              v71 = dyld4::Loader::leafName(v70, (const dyld4::RuntimeState *)v2);
              strlcpy((char *)&v111, v71, 0x100uLL);
              strlcat((char *)&v111, ": dlopen(", 0x100uLL);
              v72 = dyld4::Loader::leafName(**(dyld4::Loader ***)(a1 + 24), (const dyld4::RuntimeState *)v2);
              strlcat((char *)&v111, v72, 0x100uLL);
              strlcat((char *)&v111, ")", 0x100uLL);
            }
            dyld4::Loader::logChainToLinksWith(**(dyld4::Loader ***)(a1 + 24), (dyld4::RuntimeState *)v2, (const char *)&v111);
          }
          v73 = *(_QWORD *)(a1 + 64);
          v74 = *(_QWORD *)(v73 + 16);
          if (v74)
          {
            v111 = *(dyld4::Loader ***)(v73 + 8);
            *(_QWORD *)&v112 = v74;
            dyld4::RuntimeState::notifyDebuggerLoad((lsl::AllocatorLayout *)v2, (uint64_t)&v111);
            v75 = *(_QWORD *)(a1 + 64);
            v76 = *(_QWORD *)(v75 + 16);
            if (v76)
            {
              v77 = *(dyld4::Loader ***)(v75 + 8);
              v78 = 8 * v76;
              do
              {
                if ((*((_WORD *)*v77 + 2) & 0x1000) != 0)
                {
                  v79 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*v77, (dyld4::RuntimeState *)v2);
                  dyld4::RuntimeState::setUpTLVs((dyld4::RuntimeState *)v2, v79);
                }
                ++v77;
                v78 -= 8;
              }
              while (v78);
            }
          }
          dyld4::RuntimeState::doSingletonPatching((dyld4::RuntimeState *)v2, (dyld4::DyldCacheDataConstLazyScopedWriter *)v88);
          dyld4::RuntimeState::notifyObjCPatching((dyld4::RuntimeState *)v2);
        }
        dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)v88);
        if (v90)
          lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v89, 0);
        lsl::Allocator::~Allocator(v30);
        goto LABEL_69;
      }
      v66 = 8 * v91;
      do
      {
        v67 = *v65++;
        dyld4::RuntimeState::removeDynamicDependencies((_QWORD *)v2, v67);
        v66 -= 8;
      }
      while (v66);
      v65 = v90;
      v64 = v91;
    }
    if (v64)
    {
      v68 = 8 * v64;
      do
      {
        v69 = *v65++;
        dyld4::Loader::unmap(v69, (dyld4::RuntimeState *)v2, 1);
        v68 -= 8;
      }
      while (v68);
    }
    goto LABEL_43;
  }
  v83 = dyld4::RuntimeState::incDlRefCount(v2, **(const dyld4::Loader ***)(a1 + 24));
  v86 = **(_QWORD **)(a1 + 24);
  if ((v86 & 1) != 0)
    dyld4::APIs::dlopen_from(v83, v84, v85);
  **(_QWORD **)(a1 + 40) = v86 ^ (unint64_t)&dword_1A5C55000 | **(unsigned __int8 **)(a1 + 48);
LABEL_69:
  mach_o::Error::~Error(&v110);
}

uint64_t ***dyld4::APIs::_dyld_pseudodylib_register_callbacks(_dyld_pseudodylib_callbacks const*)::$_0::operator()(uint64_t ***result)
{
  uint64_t ***v1;
  uint64_t **v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t **v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  v1 = result;
  v2 = result[2];
  v3 = **result;
  v4 = *v3;
  if (*v3 == 3)
  {
    v14 = *(_OWORD *)(v3 + 1);
    v8 = *(_OWORD *)(v3 + 5);
    v11 = *(_OWORD *)(v3 + 3);
    v6 = *(_OWORD *)(v3 + 7);
    result = (uint64_t ***)lsl::Allocator::aligned_alloc((lsl::Allocator *)v2[2], 8uLL, 0x40uLL);
    *(_OWORD *)result = v14;
    *((_OWORD *)result + 1) = v11;
    *((_OWORD *)result + 2) = v8;
    *((_OWORD *)result + 3) = v6;
  }
  else if (v4 == 2)
  {
    v5 = (uint64_t **)v3[7];
    v15 = *(_OWORD *)(v3 + 1);
    v9 = *(_OWORD *)(v3 + 5);
    v12 = *(_OWORD *)(v3 + 3);
    result = (uint64_t ***)lsl::Allocator::aligned_alloc((lsl::Allocator *)v2[2], 8uLL, 0x40uLL);
    *(_OWORD *)result = v15;
    *((_OWORD *)result + 1) = v12;
    *((_OWORD *)result + 2) = v9;
    result[6] = v5;
    result[7] = 0;
  }
  else
  {
    if (v4 != 1)
      return result;
    v13 = *(_OWORD *)(v3 + 1);
    v7 = *(_OWORD *)(v3 + 5);
    v10 = *(_OWORD *)(v3 + 3);
    result = (uint64_t ***)lsl::Allocator::aligned_alloc((lsl::Allocator *)v2[2], 8uLL, 0x40uLL);
    *(_OWORD *)result = v13;
    *((_OWORD *)result + 1) = v10;
    *((_OWORD *)result + 2) = v7;
    result[6] = 0;
    result[7] = 0;
  }
  *v1[1] = (uint64_t *)result;
  return result;
}

uint64_t SwiftHashTable::getPotentialTarget<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(unsigned int *a1, objc **a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;

  v3 = SwiftHashTable::getIndex<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(a1, a2);
  if ((_DWORD)v3 == -1)
  {
    v7 = a1 + 4;
  }
  else
  {
    v6 = *a1;
    if (v6 <= v3)
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v3, v4, v5);
    v7 = (unsigned int *)((char *)&a1[v3 + 264] + a1[5] + v6);
  }
  return *v7;
}

uint64_t SwiftHashTable::getIndex<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(unsigned int *a1, objc **a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = SwiftHashTable::hash<PointerHashTableBuilderKey>((uint64_t)a1, a2);
  if (*a1 <= v4)
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v4, v5, v6);
  v7 = v4;
  v8 = *((unsigned __int8 *)a1 + v4 + a1[5] + 1056);
  v9 = SwiftHashTable::checkbyte<PointerHashTableBuilderKey>((uint64_t)a1, (uint64_t)a2);
  if (v8 != (_DWORD)v9)
    return 0xFFFFFFFFLL;
  v12 = *a1;
  if (v12 <= v7)
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v9, v10, v11);
  v13 = *(unsigned int *)((char *)&a1[v7 + 264] + a1[5] + v12);
  if ((_DWORD)v13 == -1)
    return 0xFFFFFFFFLL;
  if (SwiftHashTable::equal<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>((uint64_t)a1, (unsigned int *)((char *)a1 + v13), (uint64_t)a2))
  {
    return v7;
  }
  return 0xFFFFFFFFLL;
}

void OUTLINED_FUNCTION_3_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 112, a4);
}

void mach_o::Header::platformAndVersions(mach_o::Header *this@<X0>, uint64_t a2@<X8>)
{
  __int128 v4;
  uint64_t *v5;
  _QWORD v6[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  __n128 (*v10)(__n128 *, __n128 *);
  uint64_t (*v11)();
  _BYTE v12[24];

  v7 = 0;
  v8 = &v7;
  v9 = 0x4002000000;
  v10 = __Block_byref_object_copy__7;
  v11 = __Block_byref_object_dispose__7;
  mach_o::Platform::Platform((mach_o::Platform *)v12, 0);
  *(_QWORD *)&v4 = 0x1000000010000;
  *((_QWORD *)&v4 + 1) = 0x1000000010000;
  *(_OWORD *)&v12[8] = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke;
  v6[3] = &unk_1E4F7DD88;
  v6[4] = &v7;
  mach_o::Header::forEachPlatformLoadCommand(this, (uint64_t)v6);
  v5 = v8;
  *(_QWORD *)a2 = v8[5];
  *(_OWORD *)(a2 + 8) = *((_OWORD *)v5 + 3);
  _Block_object_dispose(&v7, 8);
}

__n128 __Block_byref_object_copy__7(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  result = a2[3];
  a1[3] = result;
  return result;
}

void mach_o::Header::forEachPlatformLoadCommand(mach_o::Error *a1, uint64_t a2)
{
  _QWORD v2[7];
  _QWORD v3[3];
  char v4;
  vm_address_t *v5;

  v3[0] = 0;
  v3[1] = v3;
  v3[2] = 0x2000000000;
  v4 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = ___ZNK6mach_o6Header26forEachPlatformLoadCommandEU13block_pointerFvNS_8PlatformENS_9Version32ES2_E_block_invoke;
  v2[3] = &unk_1E4F7DDB0;
  v2[5] = v3;
  v2[6] = a1;
  v2[4] = a2;
  mach_o::Header::forEachLoadCommand(a1, (uint64_t)v2, (mach_o::Error *)&v5);
  mach_o::Error::~Error(&v5);
  _Block_object_dispose(v3, 8);
}

void ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke(uint64_t a1, uint64_t *a2, int a3, int a4)
{
  uint64_t *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  vm_address_t *v9;

  v4 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v5 = *a2;
  v6 = a3;
  v7 = a4;
  v8 = 0x1000000010000;
  mach_o::PlatformAndVersions::zip(v4, &v5, (mach_o::Error *)&v9);
  if (v9)
    ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke_cold_1();
  mach_o::Error::~Error(&v9);
}

uint64_t ___ZNK6mach_o6Header26forEachPlatformLoadCommandEU13block_pointerFvNS_8PlatformENS_9Version32ES2_E_block_invoke(uint64_t result, int *a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22[8];

  v3 = result;
  v4 = *(_QWORD *)(result + 48);
  v5 = *a2;
  if (*a2 <= 46)
  {
    if (v5 == 36)
    {
      v11 = a2[2];
      v12 = a2[3];
      if (v12)
        v13 = v12;
      else
        v13 = v11;
      v14 = *(_QWORD *)(result + 32);
      v21 = 0x1E4F7A7F8;
      result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(v14 + 16))(v14, &v21, v11, v13);
    }
    else
    {
      if (v5 != 37)
        return result;
      v7 = *(_QWORD *)(result + 32);
      if ((*(_DWORD *)(v4 + 4) | 0x1000000) == 0x1000007)
      {
        v20 = 0x1E4F7AA28;
        result = (*(uint64_t (**)(uint64_t, uint64_t *, _QWORD, _QWORD))(v7 + 16))(v7, &v20, a2[2], a2[3]);
      }
      else
      {
        v19 = 0x1E4F7A788;
        result = (*(uint64_t (**)(uint64_t, uint64_t *, _QWORD, _QWORD))(v7 + 16))(v7, &v19, a2[2], a2[3]);
      }
    }
  }
  else
  {
    switch(v5)
    {
      case '/':
        v8 = *(_QWORD *)(result + 32);
        if (*(_DWORD *)(v4 + 4) == 16777223)
        {
          v18 = 0x1E4F7AAD0;
          v9 = &v18;
        }
        else
        {
          v17 = 0x1E4F7A7C0;
          v9 = &v17;
        }
        result = (*(uint64_t (**)(uint64_t, uint64_t *, _QWORD, _QWORD))(v8 + 16))(v8, v9, a2[2], a2[3]);
        break;
      case '0':
        v10 = *(_QWORD *)(result + 32);
        if ((*(_DWORD *)(v4 + 4) | 0x1000000) == 0x1000007)
        {
          v16 = 0x1E4F7AC90;
          result = (*(uint64_t (**)(uint64_t, uint64_t *, _QWORD, _QWORD))(v10 + 16))(v10, &v16, a2[2], a2[3]);
        }
        else
        {
          v15 = 0x1E4F7A868;
          result = (*(uint64_t (**)(uint64_t, uint64_t *, _QWORD, _QWORD))(v10 + 16))(v10, &v15, a2[2], a2[3]);
        }
        break;
      case '2':
        v6 = *(_QWORD *)(result + 32);
        mach_o::Platform::Platform((mach_o::Platform *)v22, a2[2]);
        result = (*(uint64_t (**)(uint64_t, char *, _QWORD, _QWORD))(v6 + 16))(v6, v22, a2[3], a2[4]);
        break;
      default:
        return result;
    }
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8) + 24) = 1;
  return result;
}

uint64_t mach_o::Header::getDylibInstallName(mach_o::Error *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;
  vm_address_t *v11;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK6mach_o6Header19getDylibInstallNameEPPKcPNS_9Version32ES5__block_invoke;
  v6[3] = &unk_1E4F7DDD8;
  v6[6] = a4;
  v6[7] = a2;
  v6[4] = &v7;
  v6[5] = a3;
  mach_o::Header::forEachLoadCommand(a1, (uint64_t)v6, (mach_o::Error *)&v11);
  mach_o::Error::~Error(&v11);
  v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t ___ZNK6mach_o6Header19getDylibInstallNameEPPKcPNS_9Version32ES5__block_invoke(uint64_t result, _DWORD *a2, _BYTE *a3)
{
  _DWORD *v3;

  if (*a2 == 13)
  {
    v3 = *(_DWORD **)(result + 48);
    **(_DWORD **)(result + 40) = a2[5];
    *v3 = a2[4];
    **(_QWORD **)(result + 56) = (char *)a2 + a2[2];
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

uint64_t mach_o::Header::linkedDylibCount(mach_o::Header *this, BOOL *a2)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;

  if (a2)
    *a2 = 1;
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK6mach_o6Header16linkedDylibCountEPb_block_invoke;
  v4[3] = &unk_1E4F7DE00;
  v4[4] = &v5;
  v4[5] = a2;
  mach_o::Header::forEachLinkedDylib(this, (uint64_t)v4);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void mach_o::Header::forEachLinkedDylib(mach_o::Error *a1, uint64_t a2)
{
  _BOOL4 isExclaveKit;
  int v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  _QWORD v10[7];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  vm_address_t *v19[3];
  int v20;
  int v21;

  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___ZNK6mach_o6Header18forEachLinkedDylibEU13block_pointerFvPKcNS_21LinkedDylibAttributesENS_9Version32ES4_RbE_block_invoke;
  v10[3] = &unk_1E4F7A768;
  v10[4] = a2;
  v10[5] = &v15;
  v10[6] = &v11;
  mach_o::Header::forEachLoadCommand(a1, (uint64_t)v10, (mach_o::Error *)v19);
  mach_o::Error::~Error(v19);
  if (!*((_DWORD *)v16 + 6) && !*((_BYTE *)v12 + 24))
  {
    mach_o::Header::platformAndVersions(a1, (uint64_t)v19);
    if (v19[0] == (vm_address_t *)&mach_o::PlatformInfo_driverKit::singleton)
    {
      if (*((_DWORD *)a1 + 3) != 6
        || ((v19[0] = 0,
             v20 = 0x10000,
             v21 = 0x10000,
             !mach_o::Header::getDylibInstallName(a1, (uint64_t)v19, (uint64_t)&v21, (uint64_t)&v20))
          ? (v8 = 0)
          : (v8 = (const char *)v19[0]),
            _platform_strncmp(v8, "/System/DriverKit/usr/lib/system/", 0x21uLL)))
      {
        v7 = "/System/DriverKit/usr/lib/libSystem.B.dylib";
        goto LABEL_23;
      }
    }
    else
    {
      mach_o::Header::platformAndVersions(a1, (uint64_t)v19);
      isExclaveKit = mach_o::Platform::isExclaveKit((mach_o::Platform *)v19);
      v5 = *((_DWORD *)a1 + 3);
      if (isExclaveKit)
      {
        if (v5 != 6
          || ((v19[0] = 0,
               v20 = 0x10000,
               v21 = 0x10000,
               !mach_o::Header::getDylibInstallName(a1, (uint64_t)v19, (uint64_t)&v21, (uint64_t)&v20))
            ? (v6 = 0)
            : (v6 = (const char *)v19[0]),
              _platform_strncmp(v6, "/System/ExclaveKit/usr/lib/system/", 0x22uLL)))
        {
          v7 = "/System/ExclaveKit/usr/lib/libSystem.dylib";
LABEL_23:
          (*(void (**)(uint64_t, const char *, _QWORD, uint64_t, uint64_t, uint64_t *))(a2 + 16))(a2, v7, 0, 0x10000, 0x10000, v12 + 3);
        }
      }
      else if (v5 != 6
             || ((v19[0] = 0,
                  v20 = 0x10000,
                  v21 = 0x10000,
                  !mach_o::Header::getDylibInstallName(a1, (uint64_t)v19, (uint64_t)&v21, (uint64_t)&v20))
               ? (v9 = 0)
               : (v9 = (const char *)v19[0]),
                 _platform_strncmp(v9, "/usr/lib/system/", 0x10uLL)))
      {
        v7 = "/usr/lib/libSystem.B.dylib";
        goto LABEL_23;
      }
    }
  }
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
}

uint64_t ___ZNK6mach_o6Header16linkedDylibCountEPb_block_invoke(uint64_t result, uint64_t a2, char a3)
{
  _BYTE *v3;
  BOOL v4;

  v3 = *(_BYTE **)(result + 40);
  if (v3)
    v4 = a3 == 0;
  else
    v4 = 1;
  if (!v4)
    *v3 = 0;
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24);
  return result;
}

uint64_t ___ZNK6mach_o6Header18forEachLinkedDylibEU13block_pointerFvPKcNS_21LinkedDylibAttributesENS_9Version32ES4_RbE_block_invoke(uint64_t result, mach_o::Header *this, _BYTE *a3)
{
  uint64_t v7;
  char *v8;
  uint64_t v9;
  unsigned __int8 CommandToDylibKind;

  if ((*(_DWORD *)this + 2147483624) <= 0xB && ((1 << (*(_DWORD *)this - 24)) & 0x881) != 0
    || *(_DWORD *)this == 12)
  {
    v7 = result;
    v8 = (char *)this + *((unsigned int *)this + 2);
    v9 = *(_QWORD *)(result + 32);
    CommandToDylibKind = mach_o::Header::loadCommandToDylibKind(this, (const dylib_command *)this);
    result = (*(uint64_t (**)(uint64_t, char *, _QWORD, _QWORD, _QWORD, _BYTE *))(v9 + 16))(v9, v8, CommandToDylibKind, *((unsigned int *)this + 5), *((unsigned int *)this + 4), a3);
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 40) + 8) + 24);
    if (*a3)
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v7 + 48) + 8) + 24) = 1;
  }
  return result;
}

unint64_t prebuilt_objc::findSelector(dyld4::RuntimeState *a1, _QWORD *a2, const char *a3)
{
  dyld4::PrebuiltLoader::BindTargetRef *v5;
  uint64_t v6;
  const char *v8;

  v8 = a3;
  v5 = (dyld4::PrebuiltLoader::BindTargetRef *)dyld3::MapBase<prebuilt_objc::ObjCStringKeyOnDisk,void,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::const_find<char const*>((uint64_t)a2, a2, a2 + 3, a1, &v8);
  if (v5 == (dyld4::PrebuiltLoader::BindTargetRef *)(a2[3] + 8 * a2[5]))
    return 0;
  else
    return dyld4::PrebuiltLoader::BindTargetRef::value(v5, a1, v6);
}

void prebuilt_objc::forEachClass(dyld4::RuntimeState *a1, _QWORD *a2, const char *a3, uint64_t a4)
{
  _QWORD v4[5];
  const char *v5;

  v5 = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN13prebuilt_objc12forEachClassEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke;
  v4[3] = &unk_1E4F7DE28;
  v4[4] = a4;
  dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry<char const*>((uint64_t)a2, a2, a2 + 3, a1, &v5, (uint64_t)v4);
}

uint64_t ___ZN13prebuilt_objc12forEachClassEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18[3];

  if (*(_QWORD *)(a2 + 16))
  {
    __chkstk_darwin(result, a2, a3, a4, a5, a6, a7, a8, v18[0]);
    v12 = (char *)v18 - ((v11 + 23) & 0xFFFFFFFFFFFFFFF0);
    v13 = v9[2];
    v18[0] = (uint64_t)v12;
    v18[1] = v13;
    if (v13)
    {
      v14 = 0;
      v15 = *v9;
      v16 = 8 * v13;
      do
      {
        if (v13 == v14)
          dyld4::RuntimeState::appendInterposingTuples(v8, (uint64_t)v9, v10);
        v17 = v14 + 1;
        *(_QWORD *)&v12[8 * v14] = *(_QWORD *)(v15 + 8 * v14);
        ++v14;
        v16 -= 8;
      }
      while (v16);
    }
    else
    {
      v17 = 0;
    }
    v18[2] = v17;
    return (*(uint64_t (**)(_QWORD, uint64_t *, uint64_t))(*(_QWORD *)(v8 + 32) + 16))(*(_QWORD *)(v8 + 32), v18, v10);
  }
  return result;
}

void prebuilt_objc::forEachProtocol(dyld4::RuntimeState *a1, _QWORD *a2, const char *a3, uint64_t a4)
{
  _QWORD v4[5];
  const char *v5;

  v5 = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN13prebuilt_objc15forEachProtocolEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke;
  v4[3] = &unk_1E4F7DE50;
  v4[4] = a4;
  dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry<char const*>((uint64_t)a2, a2, a2 + 3, a1, &v5, (uint64_t)v4);
}

uint64_t ___ZN13prebuilt_objc15forEachProtocolEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18[3];

  if (*(_QWORD *)(a2 + 16))
  {
    __chkstk_darwin(result, a2, a3, a4, a5, a6, a7, a8, v18[0]);
    v12 = (char *)v18 - ((v11 + 23) & 0xFFFFFFFFFFFFFFF0);
    v13 = v9[2];
    v18[0] = (uint64_t)v12;
    v18[1] = v13;
    if (v13)
    {
      v14 = 0;
      v15 = *v9;
      v16 = 8 * v13;
      do
      {
        if (v13 == v14)
          dyld4::RuntimeState::appendInterposingTuples(v8, (uint64_t)v9, v10);
        v17 = v14 + 1;
        *(_QWORD *)&v12[8 * v14] = *(_QWORD *)(v15 + 8 * v14);
        ++v14;
        v16 -= 8;
      }
      while (v16);
    }
    else
    {
      v17 = 0;
    }
    v18[2] = v17;
    return (*(uint64_t (**)(_QWORD, uint64_t *, uint64_t))(*(_QWORD *)(v8 + 32) + 16))(*(_QWORD *)(v8 + 32), v18, v10);
  }
  return result;
}

uint64_t prebuilt_objc::forEachClass(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  _QWORD v12[5];
  _QWORD v13[3];
  uint64_t v14[3];

  v8 = *a1;
  v13[0] = a1 + 1;
  v13[1] = v8;
  v9 = &a1[v8];
  v10 = v9[1];
  v13[2] = v8;
  v14[0] = (uint64_t)(v9 + 2);
  v14[1] = v10;
  v14[2] = v10;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = ___ZN13prebuilt_objc12forEachClassEPKvU13block_pointerFvRKN5dyld414PrebuiltLoader13BindTargetRefERKN5dyld35ArrayIPS5_EEE_block_invoke;
  v12[3] = &unk_1E4F7DE78;
  v12[4] = a2;
  return dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry((uint64_t)v13, (uint64_t)v13, v14, (uint64_t)v12, a5, a6, a7, a8);
}

uint64_t ___ZN13prebuilt_objc12forEachClassEPKvU13block_pointerFvRKN5dyld414PrebuiltLoader13BindTargetRefERKN5dyld35ArrayIPS5_EEE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18[3];

  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v18[0]);
  v13 = (char *)v18 - ((v12 + 23) & 0xFFFFFFFFFFFFFFF0);
  v18[0] = (uint64_t)v13;
  v18[1] = v11;
  if (v11)
  {
    v14 = 0;
    v15 = *v10;
    do
    {
      if (v11 == v14)
        dyld4::RuntimeState::appendInterposingTuples(v8, v9, (uint64_t)v10);
      v16 = v14 + 1;
      *(_QWORD *)&v13[8 * v14] = *(_QWORD *)(v15 + 8 * v14);
      ++v14;
      v12 -= 8;
    }
    while (v12);
  }
  else
  {
    v16 = 0;
  }
  v18[2] = v16;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t *))(*(_QWORD *)(v8 + 32) + 16))(*(_QWORD *)(v8 + 32), v9, v18);
}

unint64_t prebuilt_objc::hashStringKey(uint64_t a1)
{
  return murmurHash(*(uint64_t **)a1, *(_DWORD *)(a1 + 8), 0);
}

dyld4::PrebuiltObjC::ObjCOptimizerImage *dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage(dyld4::PrebuiltObjC::ObjCOptimizerImage *this, const dyld4::JustInTimeLoader *a2, uint64_t a3, int a4)
{
  *(_QWORD *)this = a2;
  *((_DWORD *)this + 2) = a4;
  *((_QWORD *)this + 2) = a3;
  *((_BYTE *)this + 24) = 1;
  Diagnostics::Diagnostics((dyld4::PrebuiltObjC::ObjCOptimizerImage *)((char *)this + 32));
  *((_QWORD *)this + 19) = 0;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)this + 160);
  dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)this + 256);
  *((_QWORD *)this + 48) = 0;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::Map((uint64_t)this + 392);
  *((_QWORD *)this + 69) = 0;
  *((_DWORD *)this + 140) = 0;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 535) = 0u;
  return this;
}

_QWORD *dyld4::PrebuiltObjC::ObjCOptimizerImage::visitReferenceToObjCSelector(uint64_t a1, objc::StringHashTable *this, uint64_t *a3, int a4, int a5, unint64_t a6, char a7, char *__s)
{
  uint64_t Index;
  unint64_t Absolute;
  _QWORD *result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  const BindTarget *v21;
  BindTarget *v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  Loader *var0;
  Loader *v27;
  BindTarget v28;
  uint64_t v29;
  uint64_t v30;
  BindTarget v31;

  Index = objc::StringHashTable::tryGetIndex(this, __s);
  if ((Index & 0xFF00000000) != 0)
  {
    Absolute = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute((dyld4::PrebuiltLoader::BindTargetRef *)*(int *)((char *)this + 4 * Index + *((unsigned int *)this + 1) + *((_DWORD *)this + 4) + 1 + 1056));
    result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((_QWORD *)(a1 + 352), 1);
    v17 = *(_QWORD *)(a1 + 352);
    v18 = *(_QWORD *)(a1 + 368);
    *(_QWORD *)(a1 + 368) = v18 + 1;
    *(_QWORD *)(v17 + 8 * v18) = Absolute;
    return result;
  }
  v31.var0 = (Loader *)__s;
  v31.var1 = _platform_strlen(__s);
  v19 = dyld3::MapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::find<prebuilt_objc::ObjCStringKey>((uint64_t)a3, a3 + 2, a3 + 7, 0, (uint64_t)&v31);
  if (v19 == a3[7] + 32 * a3[9])
  {
    v29 = 0;
    v30 = 0;
    v28 = v31;
    v22 = (BindTarget *)dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(a1 + 392, (uint64_t)&v28);
    if ((v23 & 1) != 0)
    {
      v28.var0 = *(Loader **)a1;
      if (!a7)
        std::__throw_bad_optional_access[abi:nn180100]();
      v28.var1 = a6;
      v22[1] = v28;
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v27, &v28);
      result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((_QWORD *)(a1 + 352), 1);
      v24 = *(_QWORD *)(a1 + 352);
      v25 = *(_QWORD *)(a1 + 368);
      *(_QWORD *)(a1 + 368) = v25 + 1;
      var0 = v27;
      goto LABEL_8;
    }
    v21 = v22 + 1;
    v20 = (_QWORD *)(a1 + 352);
  }
  else
  {
    v20 = (_QWORD *)(a1 + 352);
    v21 = (const BindTarget *)(v19 + 16);
  }
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v28, v21);
  result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v20, 1);
  v24 = *(_QWORD *)(a1 + 352);
  v25 = *(_QWORD *)(a1 + 368);
  *(_QWORD *)(a1 + 368) = v25 + 1;
  var0 = v28.var0;
LABEL_8:
  *(_QWORD *)(v24 + 8 * v25) = var0;
  return result;
}

uint64_t dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  vm_address_t v12;
  vm_size_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD *v25;
  __int128 v26;
  uint64_t v27;
  _OWORD v29[2];
  vm_size_t size;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 == *(_QWORD *)a1)
  {
    v5 = 2 * *(_QWORD *)(a1 + 32);
    *(_QWORD *)a1 = 2 * v4;
    size = 0;
    memset(v29, 0, sizeof(v29));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v29, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v29, 1);
      v6 = (*(_QWORD *)&v29[1])++;
      *(_DWORD *)(*(_QWORD *)&v29[0] + 4 * v6) = -1;
    }
    if (*(_QWORD *)(a1 + 72))
    {
      v7 = 0;
      do
      {
        v8 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v7);
        v9 = murmurHash(*(uint64_t **)v8, *(_DWORD *)(v8 + 8), 0);
        v10 = (*(_QWORD *)&v29[1] - 1) & v9;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v29, v10) != -1)
        {
          v11 = 1;
          do
            v10 = (*(_QWORD *)&v29[1] - 1) & (v10 + v11++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v29, v10) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v29, v10) = v7++;
      }
      while (v7 != *(_QWORD *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v29)
    {
      *(_QWORD *)&v29[1] = 0;
      if (*((_QWORD *)&v29[1] + 1))
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v29[1] + 1), size);
    }
    else
    {
      v12 = *(_QWORD *)(a1 + 40);
      if (v12)
        vm_deallocate(mach_task_self_, v12, *(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)&v29[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v29 + 8);
      v13 = size;
      *(_QWORD *)(a1 + 40) = *((_QWORD *)&v29[1] + 1);
      *(_QWORD *)(a1 + 48) = v13;
    }
  }
  v14 = (*(_QWORD *)(a1 + 32) - 1) & murmurHash(*(uint64_t **)a2, *(_DWORD *)(a2 + 8), 0);
  v15 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v14);
  if ((_DWORD)v15 == -1)
  {
LABEL_21:
    v19 = *(_QWORD *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v14) = v19;
    ++*(_QWORD *)(a1 + 8);
    v20 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v23 = *(_QWORD *)(a1 + 56);
    v24 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v24 + 1;
    v25 = (_OWORD *)(v23 + 32 * v24);
    v26 = *(_OWORD *)(a2 + 16);
    *v25 = *(_OWORD *)a2;
    v25[1] = v26;
    v27 = *(_QWORD *)(a1 + 72);
    if (!v27)
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert((uint64_t)v20, v21, v22);
    return *(_QWORD *)(a1 + 56) + 32 * v27 - 32;
  }
  else
  {
    v16 = 1;
    while (1)
    {
      v17 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v15);
      v18 = *(_QWORD *)(v17 + 8);
      if (v18 == *(_QWORD *)(a2 + 8) && !_platform_memcmp(*(const void **)v17, *(const void **)a2, v18))
        return dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v15);
      v14 = (*(_QWORD *)(a1 + 32) - 1) & (v14 + v16++);
      v15 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v14);
      if ((_DWORD)v15 == -1)
        goto LABEL_21;
    }
  }
}

_QWORD *dyld4::PrebuiltObjC::ObjCOptimizerImage::visitClass(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8, uint64_t a9, char a10, char *a11)
{
  uint64_t v14;
  char *v15;
  char *v16;
  _QWORD *result;
  uint64_t v18;
  uint64_t v19;
  char **v20;
  _QWORD v21[10];

  v21[0] = _NSConcreteStackBlock;
  v21[1] = 0x40000000;
  v21[2] = ___ZN5dyld4L22checkForDuplicateClassE9VMAddressPKcPKN4objc14ClassHashTableERN5dyld33MapItNSt3__14pairIS0_PKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS8_IS2_NSB_10BindTargetENS7_11HashCStringENS7_12EqualCStringEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
  v21[3] = &__block_descriptor_tmp_36_1;
  v21[4] = a5;
  v21[5] = a6;
  v21[6] = a11;
  v21[7] = a2;
  v21[8] = a3;
  v21[9] = a1;
  objc::ObjectHashTable::forEachObject(a4, a11, (uint64_t)v21);
  if (!a10 || !*(_BYTE *)(a1 + 24) || !a8)
    std::__throw_bad_optional_access[abi:nn180100]();
  v14 = *(_QWORD *)(a1 + 16);
  v15 = (char *)(a9 - v14);
  v16 = (char *)(a7 - v14);
  result = dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCObject,4294967295ull>::verifySpace((_QWORD *)(a1 + 40), 1);
  v18 = *(_QWORD *)(a1 + 40);
  v19 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = v19 + 1;
  v20 = (char **)(v18 + 40 * v19);
  *v20 = a11;
  v20[1] = v15;
  v20[2] = (char *)1;
  v20[3] = v16;
  v20[4] = (char *)1;
  return result;
}

void dyld4::PrebuiltObjC::ObjCOptimizerImage::visitProtocol(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, char a7, char *a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  void **v21;
  uint64_t v22;
  uint64_t v23;
  char **v24;
  void **v25;
  uint64_t v26;
  uint64_t (*v27)(uint64_t, uint64_t, unsigned __int16, _BYTE *);
  void *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  char v34;

  v16 = *(_QWORD *)(a1 + 136);
  dyld3::OverflowSafeArray<BOOL,4294967295ull>::verifySpace((_QWORD *)(a1 + 120), 1);
  v17 = *(_QWORD *)(a1 + 120);
  v18 = *(_QWORD *)(a1 + 136);
  *(_QWORD *)(a1 + 136) = v18 + 1;
  *(_BYTE *)(v17 + v18) = 0;
  v31 = 0;
  v32 = &v31;
  v33 = 0x2000000000;
  v34 = 0;
  v25 = _NSConcreteStackBlock;
  v26 = 0x40000000;
  v27 = ___ZN5dyld4L23protocolIsInSharedCacheEPKcPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEE_block_invoke;
  v28 = &unk_1E4F7E040;
  v29 = &v31;
  v30 = a3;
  objc::ObjectHashTable::forEachObject(a2, a8, (uint64_t)&v25);
  LODWORD(a3) = *((unsigned __int8 *)v32 + 24);
  _Block_object_dispose(&v31, 8);
  if (!(_DWORD)a3)
  {
    if (!a7 || !*(_BYTE *)(a1 + 24) || !a5)
      std::__throw_bad_optional_access[abi:nn180100]();
    v19 = *(_QWORD *)(a1 + 16);
    v20 = (char *)(a6 - v19);
    v21 = (void **)(a4 - v19);
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCObject,4294967295ull>::verifySpace((_QWORD *)(a1 + 80), 1);
    v22 = *(_QWORD *)(a1 + 80);
    v23 = *(_QWORD *)(a1 + 96);
    *(_QWORD *)(a1 + 96) = v23 + 1;
    v24 = (char **)(v22 + 40 * v23);
    *v24 = a8;
    v24[1] = v20;
    v24[2] = (char *)1;
    v24[3] = (char *)v21;
    v24[4] = (char *)1;
    v25 = v21;
    v26 = 1;
    LODWORD(v27) = 0;
    *(_DWORD *)(dyld3::Map<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::insert(a1 + 256, (uint64_t)&v25)+ 16) = v16;
  }
}

__n128 dyld4::PrebuiltObjC::commitImage(dyld4::PrebuiltObjC *this, const dyld4::PrebuiltObjC::ObjCOptimizerImage *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  uint64_t v7;
  __n128 result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  __n128 *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;

  v4 = *((_QWORD *)a2 + 29);
  if (v4)
  {
    v5 = (unint64_t *)*((_QWORD *)a2 + 27);
    v6 = &v5[3 * v4];
    do
    {
      v14 = *v5;
      v15 = 0;
      v7 = dyld3::Map<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::insert((uint64_t)this + 344, &v14);
      result = *(__n128 *)(v5 + 1);
      *(__n128 *)(v7 + 8) = result;
      v5 += 3;
    }
    while (v5 != v6);
  }
  v9 = *((_QWORD *)a2 + 58);
  if (v9)
  {
    v10 = *((_QWORD *)a2 + 56);
    v11 = v10 + 32 * v9;
    v12 = (char *)this + 40;
    do
    {
      v14 = *(_OWORD *)v10;
      v15 = 0;
      v16 = 0;
      v13 = (__n128 *)dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert((uint64_t)v12, (uint64_t)&v14);
      result = *(__n128 *)(v10 + 16);
      v13[1] = result;
      v10 += 32;
    }
    while (v10 != v11);
  }
  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeSelectorMap(dyld4::PrebuiltObjC *this, dyld4::BumpAllocator *a2)
{
  uint64_t v2;

  v2 = (*((_DWORD *)a2 + 4) - *(_DWORD *)a2);
  dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,void>((uint64_t)this + 40, a2, (uint64_t)&__block_literal_global_1);
  return v2;
}

void *dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,void>(uint64_t a1, dyld4::BumpAllocator *this, uint64_t a3)
{
  void *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(a1 + 32);
  dyld4::BumpAllocator::append(this, &v11, 8uLL);
  dyld4::BumpAllocator::append(this, *(const void **)(a1 + 16), 4 * v11);
  v11 = *(_QWORD *)(a1 + 72);
  result = dyld4::BumpAllocator::append(this, &v11, 8uLL);
  v7 = *(_QWORD *)(a1 + 72);
  if (v7)
  {
    v8 = *(_QWORD *)(a1 + 56);
    v9 = v8 + 32 * v7;
    do
    {
      v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v8, v8 + 16);
      result = dyld4::BumpAllocator::append(this, &v10, 8uLL);
      v8 += 32;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeClassMap(dyld4::PrebuiltObjC *this, dyld4::BumpAllocator *a2)
{
  uint64_t v2;

  v2 = (*((_DWORD *)a2 + 4) - *(_DWORD *)a2);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation>((uint64_t)this + 136, a2, (uint64_t)&__block_literal_global_13, (uint64_t)&__block_literal_global_16);
  return v2;
}

void *dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation>(uint64_t a1, dyld4::BumpAllocator *this, uint64_t a3, uint64_t a4)
{
  void *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[3];
  uint64_t v13;

  v13 = *(_QWORD *)(a1 + 32);
  dyld4::BumpAllocator::append(this, &v13, 8uLL);
  dyld4::BumpAllocator::append(this, *(const void **)(a1 + 16), 8 * v13);
  v13 = *(_QWORD *)(a1 + 72);
  result = dyld4::BumpAllocator::append(this, &v13, 8uLL);
  v9 = *(_QWORD *)(a1 + 72);
  if (v9)
  {
    v10 = *(_QWORD *)(a1 + 56);
    v11 = v10 + 56 * v9;
    do
    {
      v12[0] = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v10, v10 + 16);
      v12[1] = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, v10, v10 + 16);
      v12[2] = *(_QWORD *)(v10 + 48);
      result = dyld4::BumpAllocator::append(this, v12, 0x18uLL);
      v10 += 56;
    }
    while (v10 != v11);
  }
  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeProtocolMap(dyld4::PrebuiltObjC *this, dyld4::BumpAllocator *a2)
{
  uint64_t v2;

  v2 = (*((_DWORD *)a2 + 4) - *(_DWORD *)a2);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation>((uint64_t)this + 240, a2, (uint64_t)&__block_literal_global_18, (uint64_t)&__block_literal_global_20);
  return v2;
}

uint64_t dyld4::PrebuiltObjC::generateHashTables(dyld4::PrebuiltObjC *this)
{
  char *v2;
  char v4;

  v2 = (char *)this + 344;
  dyld4::generateClassOrProtocolHashTable(0, (uint64_t *)this, (uint64_t)this + 344, (uint64_t)this + 136, (_BYTE *)this + 440);
  return dyld4::generateClassOrProtocolHashTable(1, (uint64_t *)this, (uint64_t)v2, (uint64_t)this + 240, &v4);
}

uint64_t dyld4::generateClassOrProtocolHashTable(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  size_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  size_t v33;
  uint64_t v34;
  int v35;
  _QWORD *v36;
  uint64_t *v37;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v44;
  uint64_t *v45;
  char v47[17];
  const char *v48;
  size_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _BYTE v54[9];

  v35 = result;
  v5 = a2[2];
  if (v5)
  {
    v7 = 0;
    v36 = (_QWORD *)(a3 + 56);
    v37 = (uint64_t *)(a3 + 16);
    v8 = a2[2];
    do
    {
      v9 = v8 - 1;
      if (v5 <= v9)
        ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(result, (uint64_t)a2, a3);
      v42 = v7;
      v44 = v9;
      result = Diagnostics::hasError((Diagnostics *)(*a2 + 568 * v9 + 32));
      if ((result & 1) == 0)
      {
        if (a2[2] <= v44)
          ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(result, (uint64_t)a2, a3);
        v10 = *a2;
        v45 = (uint64_t *)(*a2 + 568 * v44);
        if (v35 == 1)
        {
          v22 = v10 + 568 * v44;
          v23 = *(_QWORD *)(v22 + 96);
          if (v23)
          {
            v24 = (_QWORD *)(v10 + 568 * v44);
            v41 = v24 + 32;
            v40 = v24 + 34;
            v25 = v24 + 39;
            v39 = v24 + 41;
            v26 = v24 + 15;
            v27 = 40 * v23;
            v28 = *(_QWORD *)(v22 + 80) + 16;
            do
            {
              if (!*(_BYTE *)v28 || !*(_BYTE *)(v28 + 16))
LABEL_31:
                std::__throw_bad_optional_access[abi:nn180100]();
              v29 = *v45;
              v30 = *(_QWORD *)(v28 + 8);
              v32 = *(const char **)(v28 - 16);
              v31 = *(_QWORD *)(v28 - 8);
              v33 = _platform_strlen(v32);
              v54[0] = 0;
              v48 = v32;
              v49 = v33;
              v50 = v29;
              v51 = v31;
              v52 = v29;
              v53 = v30;
              result = dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(a4, (uint64_t)&v48, v54);
              if (!v54[0])
              {
                v34 = dyld3::MapBase<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::find<VMOffset>((_BOOL8)v41, v40, v25, 0, v28 + 8);
                if (v34 == *v25 + 24 * *v39)
                  dyld4::generateClassOrProtocolHashTable();
                result = dyld3::OverflowSafeArray<BOOL,4294967295ull>::operator[](v26, *(unsigned int *)(v34 + 16));
                *(_BYTE *)result = 1;
              }
              v28 += 40;
              v27 -= 40;
            }
            while (v27);
          }
        }
        else if (!v35)
        {
          v11 = v10 + 568 * v44;
          v12 = *(_QWORD *)(v11 + 56);
          if (v12)
          {
            v13 = *(_QWORD *)(v11 + 40);
            v14 = 40 * v12;
            while (1)
            {
              if (!*(_BYTE *)(v13 + 16) || !*(_BYTE *)(v13 + 32))
                goto LABEL_31;
              v15 = *v45;
              v16 = *(_QWORD *)(v13 + 24);
              v18 = *(const char **)v13;
              v17 = *(_QWORD *)(v13 + 8);
              v19 = _platform_strlen(*(const char **)v13);
              v54[0] = 0;
              v48 = v18;
              v49 = v19;
              v50 = v15;
              v51 = v17;
              v52 = v15;
              v53 = v16;
              result = dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(a4, (uint64_t)&v48, v54);
              if (v54[0])
                goto LABEL_15;
              v20 = result;
              result = (uint64_t)dyld3::MapBase<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::const_find<char const*>(a3, v37, v36, 0, (const char **)v13);
              if (result != *(_QWORD *)(a3 + 56) + 24 * *(_QWORD *)(a3 + 72))
                break;
LABEL_16:
              v13 += 40;
              v14 -= 40;
              if (!v14)
                goto LABEL_26;
            }
            v21 = *(_OWORD *)(result + 8);
            *(_QWORD *)(v20 + 16) = v15;
            *(_QWORD *)(v20 + 24) = v17;
            *(_OWORD *)(v20 + 32) = v21;
            v47[0] = 0;
            v48 = v18;
            v49 = v19;
            v50 = v15;
            v51 = v17;
            v52 = v15;
            v53 = v16;
            result = dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(a4, (uint64_t)&v48, v47);
LABEL_15:
            *a5 = 1;
            goto LABEL_16;
          }
        }
      }
LABEL_26:
      v7 = v42 + 1;
      v5 = a2[2];
      v8 = v44;
    }
    while (v42 + 1 != v5);
  }
  return result;
}

void dyld4::PrebuiltObjC::generatePerImageFixups(vm_address_t *this, dyld4::RuntimeState *a2)
{
  uint64_t v3;
  unsigned __int16 v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  vm_address_t *v9;
  int v10;
  int v11;
  vm_address_t v12;
  vm_address_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v3 = *((_QWORD *)a2 + 6);
  if (v3)
  {
    v4 = 0;
    v5 = *((_QWORD *)a2 + 5);
    v6 = 8 * v3;
    do
    {
      if ((*(_WORD *)(*(_QWORD *)v5 + 4) & 1) == 0)
      {
        v7 = *(__int16 *)(*(_QWORD *)v5 + 6);
        if ((v7 & 0x80000000) == 0)
          dyld4::PrebuiltObjC::generatePerImageFixups();
        v8 = v7 & 0x7FFF;
        if (v4 <= v8)
          v4 = v8;
      }
      v5 += 8;
      v6 -= 8;
    }
    while (v6);
  }
  else
  {
    v4 = 0;
  }
  v9 = this + 58;
  if (this[59] < (unsigned __int16)(v4 + 1))
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo(this + 58, (unsigned __int16)(v4 + 1));
  v10 = 0;
  do
  {
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::default_constuct_back(this + 58);
    v11 = (unsigned __int16)v10++;
  }
  while (v11 != v4);
  v12 = this[2];
  if (v12)
  {
    v13 = *this;
    v14 = *this + 568 * v12;
    do
    {
      if (!Diagnostics::hasError((Diagnostics *)(v13 + 32)))
      {
        v15 = dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::operator[](v9, *(_WORD *)(*(_QWORD *)v13 + 6) & 0x7FFF);
        v16 = (_QWORD *)v15;
        *(_OWORD *)v15 = *(_OWORD *)(v13 + 488);
        v17 = *(_OWORD *)(v13 + 504);
        v18 = *(_OWORD *)(v13 + 520);
        v19 = *(_OWORD *)(v13 + 536);
        *(_OWORD *)(v15 + 60) = *(_OWORD *)(v13 + 548);
        *(_OWORD *)(v15 + 32) = v18;
        *(_OWORD *)(v15 + 48) = v19;
        *(_OWORD *)(v15 + 16) = v17;
        v20 = *(_QWORD *)(v13 + 136);
        if (v20)
        {
          dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve((_QWORD *)(v15 + 80), v20);
          v21 = *(_QWORD *)(v13 + 136);
          if (v21)
          {
            v22 = *(char **)(v13 + 120);
            do
            {
              v23 = *v22++;
              dyld3::OverflowSafeArray<BOOL,4294967295ull>::verifySpace(v16 + 10, 1);
              v24 = v16[10];
              v25 = v16[12];
              v16[12] = v25 + 1;
              *(_BYTE *)(v24 + v25) = v23;
              --v21;
            }
            while (v21);
          }
        }
        v26 = *(_QWORD *)(v13 + 368);
        if (v26)
        {
          dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v16 + 15, v26);
          v27 = *(_QWORD *)(v13 + 368);
          if (v27)
          {
            v28 = *(uint64_t **)(v13 + 352);
            v29 = 8 * v27;
            do
            {
              dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v16 + 15, 1);
              v30 = v16[15];
              v31 = v16[17];
              v16[17] = v31 + 1;
              v32 = *v28++;
              *(_QWORD *)(v30 + 8 * v31) = v32;
              v29 -= 8;
            }
            while (v29);
          }
        }
      }
      v13 += 568;
    }
    while (v13 != v14);
  }
}

double dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::default_constuct_back(vm_address_t *a1)
{
  vm_address_t v2;
  unint64_t v3;
  vm_address_t v4;
  _OWORD *v5;
  double result;

  v2 = a1[2];
  v3 = v2 + 1;
  if (v2 + 1 > a1[1])
  {
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo(a1, v3);
    v2 = a1[2];
    v3 = v2 + 1;
  }
  v4 = *a1;
  a1[2] = v3;
  v5 = (_OWORD *)(v4 + 160 * v2);
  result = 0.0;
  v5[8] = 0u;
  v5[9] = 0u;
  v5[6] = 0u;
  v5[7] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  *v5 = 0u;
  v5[1] = 0u;
  return result;
}

uint64_t dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::operator[](vm_address_t *a1, vm_address_t a2)
{
  vm_address_t v4;
  vm_address_t v5;

  v4 = a1[2];
  v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5 && a1[1] < v5)
      dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo(a1, a2 + 1);
    a1[2] = v5;
  }
  return *a1 + 160 * a2;
}

_QWORD *dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  const void **v3;
  vm_address_t v4;
  vm_size_t v5;
  unint64_t v6;
  vm_size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;

  v2 = result[1];
  if (v2 < a2)
  {
    v3 = (const void **)result;
    v4 = result[3];
    v5 = result[4];
    v6 = 2 * v2;
    if (v6 <= a2)
      v6 = a2;
    v7 = (v6 + vm_page_size - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    result = memmove((void *)v3[3], *v3, (size_t)v3[2]);
    v11 = v3[4];
    *v3 = v3[3];
    v3[1] = v11;
    if (v4)
      return (_QWORD *)vm_deallocate(mach_task_self_, v4, v5);
  }
  return result;
}

void dyld4::forEachSelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[6];

  if (*(_DWORD *)(a3 + 40))
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = ___ZN5dyld4L32forEachSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
    v4[3] = &unk_1E4F7E068;
    v4[4] = a4;
    v4[5] = a2;
    objc_visitor::Visitor::forEachSelectorReference(a1, (uint64_t)v4);
  }
}

void dyld4::forEachClassSelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[6];
  _QWORD v5[6];
  _QWORD v6[7];

  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
  v6[3] = &unk_1E4F7E090;
  v6[5] = a1;
  v6[6] = a2;
  v6[4] = a4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2;
  v5[3] = &unk_1E4F7E0B8;
  v5[4] = v6;
  v5[5] = a1;
  if (*(_BYTE *)(a3 + 60))
  {
    if (*(_DWORD *)(a3 + 44))
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      v4[2] = ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3;
      v4[3] = &unk_1E4F7E0E0;
      v4[4] = v5;
      v4[5] = a1;
      objc_visitor::Visitor::forEachClassAndMetaClass(a1, (uint64_t)v4);
    }
  }
}

void dyld4::forEachCategorySelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[6];
  _QWORD v5[6];
  _QWORD v6[7];

  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
  v6[3] = &unk_1E4F7E108;
  v6[5] = a1;
  v6[6] = a2;
  v6[4] = a4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2;
  v5[3] = &unk_1E4F7E130;
  v5[4] = v6;
  v5[5] = a1;
  if (*(_BYTE *)(a3 + 61))
  {
    if (*(_DWORD *)(a3 + 48))
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      v4[2] = ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3;
      v4[3] = &unk_1E4F7E158;
      v4[4] = v5;
      v4[5] = a1;
      objc_visitor::Visitor::forEachCategory(a1, (uint64_t)v4);
    }
  }
}

void dyld4::forEachProtocolSelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[6];
  _QWORD v5[6];
  _QWORD v6[7];

  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
  v6[3] = &unk_1E4F7E180;
  v6[5] = a1;
  v6[6] = a2;
  v6[4] = a4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2;
  v5[3] = &unk_1E4F7E1A8;
  v5[4] = v6;
  v5[5] = a1;
  if (*(_BYTE *)(a3 + 62))
  {
    if (*(_DWORD *)(a3 + 52))
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      v4[2] = ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3;
      v4[3] = &unk_1E4F7E1D0;
      v4[4] = v5;
      v4[5] = a1;
      objc_visitor::Visitor::forEachProtocol(a1, (uint64_t)v4);
    }
  }
}

void dyld4::PrebuiltObjC::make(dyld4::PrebuiltObjC *this, Diagnostics *a2, dyld4::RuntimeState *a3)
{
  uint64_t v3;
  uint64_t v4;
  Diagnostics *v5;
  BOOL v6;
  dyld4::RuntimeState *v8;
  uint64_t v10;
  unsigned int *v11;
  dyld3::MachOFile *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  dyld4::Loader **v20;
  dyld4::Loader *v21;
  dyld3::MachOFile *v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  vm_address_t v28;
  uint64_t v29;
  dyld4::PrebuiltObjC::ObjCOptimizerImage *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  vm_address_t v34;
  uint64_t v35;
  dyld4::Loader **v36;
  vm_address_t v37;
  unint64_t v38;
  _BOOL4 v39;
  _QWORD *v40;
  uint64_t v41;
  __int16 v42;
  unsigned __int8 v43;
  int *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  vm_address_t v48;
  uint64_t v49;
  vm_address_t v50;
  const dyld3::MachOAnalyzer *v51;
  uint64_t v52;
  vm_address_t v53;
  unint64_t v54;
  const dyld3::MachOAnalyzer *v55;
  dyld3::MachOFile *v56;
  int v57;
  const dyld3::MachOAnalyzer *v58;
  vm_address_t v59;
  Diagnostics *v60;
  dyld4::RuntimeState *v61;
  uint64_t v62;
  uint64_t v63;
  vm_address_t v64;
  uint64_t v65;
  vm_address_t v66;
  dyld3::MachOFile *v67;
  uint64_t v68;
  Diagnostics *v69;
  dyld4::RuntimeState *v70;
  uint64_t v71;
  uint64_t v72;
  dyld4::PrebuiltObjC *v73;
  uint64_t v74;
  int *v75;
  _QWORD v77[2];
  uint64_t (*v78)(uint64_t, const char *, unint64_t *, unsigned int *);
  void *v79;
  dyld3::MachOFile *v80;
  dyld4::Loader **v81;
  int v82;
  _BYTE v83[32];
  uint64_t v84;
  vm_address_t v85;
  vm_size_t v86;
  uint64_t v87;
  vm_address_t address;
  vm_size_t size;
  void **v90;
  uint64_t v91;
  uint64_t v92;
  __n128 (*v93)(uint64_t, uint64_t);
  void ***v94;
  _QWORD v95[2];
  uint64_t v96;
  char v97;
  uint64_t v98;
  _BYTE *v99;
  char *v100;
  void **v101;
  uint64_t v102;
  uint64_t v103;
  __n128 (*v104)(uint64_t, uint64_t);
  void ***v105;
  dyld4::Loader *v106;
  Diagnostics *v107;
  dyld4::RuntimeState *v108;
  void **v109;
  uint64_t v110;
  uint64_t v111;
  void *v112;
  vm_address_t v113;
  uint64_t v114;
  char *v115;
  void **v116;
  uint64_t v117;
  uint64_t v118;
  void *v119;
  _QWORD *v120;
  void ***v121;
  void ***v122;
  void **v123;
  uint64_t v124;
  uint64_t v125;
  void *v126;
  _QWORD *v127;
  void ***v128;
  void ***v129;
  _QWORD v130[7];
  _QWORD v131[6];
  _QWORD v132[5];
  uint64_t v133;
  uint64_t *v134;
  uint64_t v135;
  char v136;

  v3 = *((_QWORD *)a3 + 1);
  v4 = *(_QWORD *)(v3 + 304);
  v5 = *(Diagnostics **)(v3 + 320);
  v71 = *(_QWORD *)(v3 + 312);
  if (v71)
    v6 = v4 == 0;
  else
    v6 = 1;
  if (!v6 && v5 != 0)
  {
    v8 = a3;
    v74 = *(_QWORD *)(v3 + 296);
    v75 = *(int **)(v3 + 288);
    v72 = *(_QWORD *)(v3 + 352);
    v10 = DyldSharedCache::objcOptPtrs(*(DyldSharedCache **)(v3 + 240));
    if (v10)
    {
      v11 = (unsigned int *)v10;
      v12 = (dyld3::MachOFile *)dyld4::Loader::loadAddress(*((dyld4::Loader **)v8 + 3), v8);
      if (dyld3::MachOFile::pointerSize(v12) == 8)
        v13 = *(_QWORD *)v11;
      else
        v13 = *v11;
      *((_QWORD *)this + 56) = v13 - *(_QWORD *)(*((_QWORD *)v8 + 1) + 240);
      *((_BYTE *)this + 456) = 1;
    }
    v14 = *((_QWORD *)v8 + 10);
    if (v14)
    {
      v15 = *((_QWORD *)v8 + 9);
      v16 = 8 * v14;
      while (!*(_QWORD *)v15 || (*(_WORD *)(*(_QWORD *)v15 + 4) & 1) != 0)
      {
        v15 += 8;
        v16 -= 8;
        if (!v16)
          goto LABEL_20;
      }
    }
    else
    {
LABEL_20:
      v68 = v4;
      v69 = v5;
      v73 = this;
      dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::Map((uint64_t)v83);
      v18 = *((_QWORD *)v8 + 6);
      if (v18)
      {
        v19 = 8 * v18;
        v20 = (dyld4::Loader **)*((_QWORD *)v8 + 5);
        v70 = v8;
        do
        {
          v21 = *v20;
          v22 = (dyld3::MachOFile *)dyld4::Loader::mf(*v20, v8);
          v23 = dyld3::MachOFile::pointerSize(v22);
          v90 = 0;
          v91 = (uint64_t)&v90;
          v92 = 0x4002000000;
          v93 = __Block_byref_object_copy__8;
          v94 = (void ***)__Block_byref_object_dispose__8;
          LOBYTE(v95[0]) = 0;
          LOBYTE(v96) = 0;
          v101 = _NSConcreteStackBlock;
          v102 = 0x40000000;
          v103 = (uint64_t)___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke;
          v104 = (__n128 (*)(uint64_t, uint64_t))&unk_1E4F7E220;
          v107 = a2;
          v108 = v8;
          v105 = &v90;
          v106 = v21;
          dyld3::MachOFile::forEachSection(v22, (uint64_t)&v101);
          v24 = *(_QWORD *)(v91 + 40);
          v25 = *(unsigned __int8 *)(v91 + 48);
          v26 = *(unsigned __int8 *)(v91 + 56);
          _Block_object_dispose(&v90, 8);
          if (v26)
          {
            if ((*((_WORD *)v21 + 2) & 2) != 0)
            {
              v38 = dyld3::MachOFile::preferredLoadAddress(v22);
              v39 = dyld3::MachOFile::is64(v22);
              if (!v75)
                dyld4::PrebuiltObjC::make();
              if (!v74)
                dyld4::PrebuiltObjC::make();
              if (v39)
              {
                v40 = objc::objc_headeropt_ro_t<unsigned long long>::get(v75, v72, v38);
                if (!v40)
                  goto LABEL_72;
                v42 = objc::objc_headeropt_ro_t<unsigned long long>::index(v75, (unint64_t)v40, v41);
                if (*(_DWORD *)(v74 + 4) != 8)
                  dyld4::PrebuiltObjC::make();
                v43 = v42;
              }
              else
              {
                v44 = objc::objc_headeropt_ro_t<unsigned int>::get(v75, v72, v38);
                if (!v44)
                  goto LABEL_72;
                v42 = objc::objc_headeropt_ro_t<unsigned long long>::index(v75, (unint64_t)v44, v45);
                if (*(_DWORD *)(v74 + 4) != 4)
                  dyld4::PrebuiltObjC::make();
                v43 = v42;
              }
              LOWORD(v90) = v42 & 0xFF00 | v43;
              v91 = v38;
              LOBYTE(v92) = 1;
              v93 = (__n128 (*)(uint64_t, uint64_t))v21;
              dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::insert((uint64_t)v83, (unsigned __int16 *)&v90);
            }
            else
            {
              if (dyld4::Loader::matchesPath(v21, v8, "/usr/lib/libobjc.A.dylib"))
                goto LABEL_72;
              v27 = dyld3::MachOFile::preferredLoadAddress(v22);
              dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage,4294967295ull>::verifySpace((vm_address_t *)v73, 1);
              v28 = *(_QWORD *)v73;
              v29 = *((_QWORD *)v73 + 2);
              *((_QWORD *)v73 + 2) = v29 + 1;
              v30 = dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage((dyld4::PrebuiltObjC::ObjCOptimizerImage *)(v28 + 568 * v29), v21, v27, v23);
              v33 = *((_QWORD *)v73 + 2);
              if (!v33)
                dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert((uint64_t)v30, v31, v32);
              v34 = *(_QWORD *)v73;
              v35 = v33 - 1;
              v36 = (dyld4::Loader **)(*(_QWORD *)v73 + 568 * (v33 - 1));
              *v36 = v21;
              if (!v25)
LABEL_82:
                std::__throw_bad_optional_access[abi:nn180100]();
              v37 = v34 + 568 * v35;
              *(_QWORD *)(v37 + 488) = v24;
              v77[0] = _NSConcreteStackBlock;
              v77[1] = 0x40000000;
              v78 = ___ZN5dyld412PrebuiltObjC4makeER11DiagnosticsRNS_12RuntimeStateE_block_invoke;
              v79 = &__block_descriptor_tmp_27_0;
              v82 = v23;
              v80 = v22;
              v81 = v36;
              ___ZN5dyld412PrebuiltObjC4makeER11DiagnosticsRNS_12RuntimeStateE_block_invoke((uint64_t)v77, "__objc_selrefs", (unint64_t *)(v37 + 496), (unsigned int *)(v37 + 528));
              v78((uint64_t)v77, "__objc_classlist", (unint64_t *)(v37 + 504), (unsigned int *)(v37 + 532));
              v78((uint64_t)v77, "__objc_catlist", (unint64_t *)(v37 + 512), (unsigned int *)(v37 + 536));
              v78((uint64_t)v77, "__objc_protolist", (unint64_t *)(v37 + 520), (unsigned int *)(v37 + 540));
              v8 = v70;
            }
          }
          ++v20;
          v19 -= 8;
        }
        while (v19);
      }
      v46 = *((_QWORD *)v73 + 2);
      if (v46)
      {
        v47 = 0;
        v48 = *(_QWORD *)v73;
        v49 = 568 * v46;
        do
        {
          v50 = v48 + v47;
          if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
          {
            if (*(_DWORD *)(v50 + 532))
            {
              v101 = 0;
              v102 = (uint64_t)&v101;
              v103 = 0x4802000000;
              v104 = __Block_byref_object_copy__69;
              v105 = (void ***)__Block_byref_object_dispose__70;
              v51 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*(dyld4::Loader **)v50, v8);
              metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)&v106, v51);
              if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
              {
                v52 = *(_QWORD *)(*((_QWORD *)v8 + 1) + 272);
                v90 = _NSConcreteStackBlock;
                v91 = 0x40000000;
                v92 = (uint64_t)___ZN5dyld4L19optimizeObjCClassesERNS_12RuntimeStateEPKN4objc14ClassHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS7_IPKcNSB_10BindTargetENS6_11HashCStringENS6_12EqualCStringEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
                v93 = (__n128 (*)(uint64_t, uint64_t))&unk_1E4F7E248;
                v94 = &v101;
                v95[0] = v48 + v47;
                v95[1] = v8;
                v96 = v52;
                v97 = 1;
                v98 = v71;
                v99 = v83;
                v100 = (char *)v73 + 344;
                objc_visitor::Visitor::forEachClass((unsigned int *)(v102 + 40), (uint64_t)&v90);
              }
              _Block_object_dispose(&v101, 8);
            }
            if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
            {
              v53 = v48 + v47;
              v54 = *(unsigned int *)(v48 + v47 + 540);
              if ((_DWORD)v54)
              {
                dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve((_QWORD *)(v53 + 120), v54);
                v90 = 0;
                v91 = (uint64_t)&v90;
                v92 = 0x4802000000;
                v93 = __Block_byref_object_copy__69;
                v94 = (void ***)__Block_byref_object_dispose__70;
                v55 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*(dyld4::Loader **)v53, v8);
                metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)v95, v55);
                if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
                {
                  v101 = _NSConcreteStackBlock;
                  v102 = 0x40000000;
                  v103 = (uint64_t)___ZN5dyld4L21optimizeObjCProtocolsERNS_12RuntimeStateEPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
                  v104 = (__n128 (*)(uint64_t, uint64_t))&unk_1E4F7E270;
                  v105 = &v90;
                  v106 = (dyld4::Loader *)(v48 + v47);
                  v107 = v69;
                  v108 = (dyld4::RuntimeState *)v83;
                  objc_visitor::Visitor::forEachProtocol((unsigned int *)(v91 + 40), (uint64_t)&v101);
                }
                _Block_object_dispose(&v90, 8);
              }
              if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
              {
                v56 = (dyld3::MachOFile *)dyld4::JustInTimeLoader::mf(*(dyld4::JustInTimeLoader **)v50, v8);
                v57 = dyld3::MachOFile::pointerSize(v56);
                v133 = 0;
                v134 = &v133;
                v135 = 0x2000000000;
                v136 = 0;
                v132[0] = _NSConcreteStackBlock;
                v132[1] = 0x40000000;
                v132[2] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
                v132[3] = &unk_1E4F7E298;
                v132[4] = &v133;
                dyld3::MachOFile::forEachSection(v56, (uint64_t)v132);
                if (*((_BYTE *)v134 + 24))
                {
                  Diagnostics::error((vm_address_t *)(v48 + v47 + 32), "Old objc section");
                }
                else if ((dyld3::MachOFile::isArch(v56, "x86_64") || dyld3::MachOFile::isArch(v56, "x86_64h"))
                       && dyld3::MachOFile::hasObjCMessageReferences(v56))
                {
                  Diagnostics::error((vm_address_t *)(v48 + v47 + 32), "Cannot handle message refs");
                }
                else
                {
                  v90 = 0;
                  v91 = (uint64_t)&v90;
                  v92 = 0x4802000000;
                  v93 = __Block_byref_object_copy__69;
                  v94 = (void ***)__Block_byref_object_dispose__70;
                  v58 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*(dyld4::Loader **)v50, v8);
                  metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)v95, v58);
                  if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
                  {
                    v59 = v48 + v47;
                    v60 = *(Diagnostics **)(v48 + v47 + 496);
                    v61 = (Diagnostics *)((char *)v60 + (*(_DWORD *)(v48 + v47 + 528) * v57));
                    v101 = _NSConcreteStackBlock;
                    v102 = 0x40000000;
                    v103 = (uint64_t)___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_2;
                    v104 = (__n128 (*)(uint64_t, uint64_t))&unk_1E4F7E2C0;
                    v105 = &v90;
                    v106 = (dyld4::Loader *)(v48 + v47);
                    v107 = v60;
                    v108 = v61;
                    v131[0] = _NSConcreteStackBlock;
                    v131[1] = 0x40000000;
                    v131[2] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_3;
                    v131[3] = &unk_1E4F7E2E8;
                    v131[4] = &v101;
                    v131[5] = &v90;
                    if (*(_DWORD *)(v50 + 532))
                    {
                      v123 = 0;
                      v124 = (uint64_t)&v123;
                      v125 = 0x2000000000;
                      LOBYTE(v126) = 0;
                      v130[0] = _NSConcreteStackBlock;
                      v130[1] = 0x40000000;
                      v130[2] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_4;
                      v130[3] = &unk_1E4F7E310;
                      v130[5] = &v90;
                      v130[4] = v131;
                      v130[6] = &v123;
                      objc_visitor::Visitor::forEachClassAndMetaClass((unsigned int *)(v91 + 40), (uint64_t)v130);
                      v62 = v124;
                      *(_BYTE *)(v59 + 548) = *(_BYTE *)(v124 + 24);
                      *(_BYTE *)(v59 + 545) = *(_BYTE *)(v62 + 24);
                      _Block_object_dispose(&v123, 8);
                    }
                    if (*(_DWORD *)(v59 + 536))
                    {
                      v116 = 0;
                      v117 = (uint64_t)&v116;
                      v118 = 0x2000000000;
                      LOBYTE(v119) = 0;
                      v123 = _NSConcreteStackBlock;
                      v124 = 0x40000000;
                      v125 = (uint64_t)___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_5;
                      v126 = &unk_1E4F7E338;
                      v128 = &v90;
                      v127 = v131;
                      v129 = &v116;
                      objc_visitor::Visitor::forEachCategory((unsigned int *)(v91 + 40), (uint64_t)&v123);
                      v63 = v117;
                      v64 = v48 + v47;
                      *(_BYTE *)(v64 + 549) = *(_BYTE *)(v117 + 24);
                      *(_BYTE *)(v64 + 546) = *(_BYTE *)(v63 + 24);
                      _Block_object_dispose(&v116, 8);
                    }
                    if (*(_DWORD *)(v53 + 540))
                    {
                      v109 = 0;
                      v110 = (uint64_t)&v109;
                      v111 = 0x2000000000;
                      LOBYTE(v112) = 0;
                      v116 = _NSConcreteStackBlock;
                      v117 = 0x40000000;
                      v118 = (uint64_t)___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_6;
                      v119 = &unk_1E4F7E360;
                      v120 = v131;
                      v121 = &v90;
                      v122 = &v109;
                      objc_visitor::Visitor::forEachProtocol((unsigned int *)(v91 + 40), (uint64_t)&v116);
                      v65 = v110;
                      v66 = v48 + v47;
                      *(_BYTE *)(v66 + 550) = *(_BYTE *)(v110 + 24);
                      *(_BYTE *)(v66 + 547) = *(_BYTE *)(v65 + 24);
                      _Block_object_dispose(&v109, 8);
                    }
                    v109 = _NSConcreteStackBlock;
                    v110 = 0x40000000;
                    v111 = (uint64_t)___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_7;
                    v112 = &__block_descriptor_tmp_92_0;
                    v113 = v48 + v47;
                    v114 = v68;
                    v115 = (char *)v73 + 40;
                    if (!*(_BYTE *)(v48 + v47 + 24))
                      goto LABEL_82;
                    dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique(v8, *(dyld4::Loader **)(v48 + v47), *(_QWORD *)(v48 + v47 + 16), v59 + 488, (uint64_t)&v109);
                  }
                  _Block_object_dispose(&v90, 8);
                }
                _Block_object_dispose(&v133, 8);
                if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
                  dyld4::PrebuiltObjC::commitImage(v73, (const dyld4::PrebuiltObjC::ObjCOptimizerImage *)(v48 + v47));
              }
            }
          }
          v47 += 568;
        }
        while (v49 != v47);
      }
      dyld4::PrebuiltObjC::generateHashTables(v73);
      v67 = (dyld3::MachOFile *)dyld4::Loader::mf(*((dyld4::Loader **)v8 + 3), v8);
      dyld3::MachOFile::pointerSize(v67);
      dyld4::PrebuiltObjC::generatePerImageFixups((vm_address_t *)v73, v8);
      *((_BYTE *)v73 + 441) = 1;
LABEL_72:
      v87 = 0;
      if (address)
        vm_deallocate(mach_task_self_, address, size);
      v84 = 0;
      if (v85)
        vm_deallocate(mach_task_self_, v85, v86);
    }
  }
}

uint64_t dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::insert(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned __int16 *v8;
  unint64_t v9;
  uint64_t v10;
  vm_address_t v11;
  vm_size_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v25[2];
  vm_size_t size;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 == *(_QWORD *)a1)
  {
    v5 = 2 * *(_QWORD *)(a1 + 32);
    *(_QWORD *)a1 = 2 * v4;
    size = 0;
    memset(v25, 0, sizeof(v25));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v25, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v25, 1);
      v6 = (*(_QWORD *)&v25[1])++;
      *(_DWORD *)(*(_QWORD *)&v25[0] + 4 * v6) = -1;
    }
    if (*(_QWORD *)(a1 + 72))
    {
      v7 = 0;
      do
      {
        v8 = (unsigned __int16 *)dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v7);
        v9 = (LODWORD(v25[1]) - 1) & *v8;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v25, v9) != -1)
        {
          v10 = 1;
          do
            v9 = (*(_QWORD *)&v25[1] - 1) & (v9 + v10++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v25, v9) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v25, v9) = v7++;
      }
      while (v7 != *(_QWORD *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v25)
    {
      *(_QWORD *)&v25[1] = 0;
      if (*((_QWORD *)&v25[1] + 1))
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v25[1] + 1), size);
    }
    else
    {
      v11 = *(_QWORD *)(a1 + 40);
      if (v11)
        vm_deallocate(mach_task_self_, v11, *(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)&v25[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v25 + 8);
      v12 = size;
      *(_QWORD *)(a1 + 40) = *((_QWORD *)&v25[1] + 1);
      *(_QWORD *)(a1 + 48) = v12;
    }
  }
  v13 = (*(_DWORD *)(a1 + 32) - 1) & (unint64_t)*a2;
  v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v13);
  if ((_DWORD)v14 == -1)
  {
LABEL_20:
    v16 = *(_QWORD *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v13) = v16;
    ++*(_QWORD *)(a1 + 8);
    v17 = dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::verifySpace(a1 + 56, 1);
    v20 = *(_QWORD *)(a1 + 56);
    v21 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v21 + 1;
    v22 = v20 + 32 * v21;
    *(_WORD *)v22 = *a2;
    *(_OWORD *)(v22 + 8) = *(_OWORD *)(a2 + 4);
    *(_QWORD *)(v22 + 24) = *((_QWORD *)a2 + 3);
    v23 = *(_QWORD *)(a1 + 72);
    if (!v23)
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert(v17, v18, v19);
    return *(_QWORD *)(a1 + 56) + 32 * v23 - 32;
  }
  else
  {
    v15 = 1;
    while (*(unsigned __int16 *)dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v14) != *a2)
    {
      v13 = (*(_QWORD *)(a1 + 32) - 1) & (v13 + v15++);
      v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v13);
      if ((_DWORD)v14 == -1)
        goto LABEL_20;
    }
    return dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v14);
  }
}

uint64_t ___ZN5dyld412PrebuiltObjC4makeER11DiagnosticsRNS_12RuntimeStateE_block_invoke(uint64_t a1, const char *a2, unint64_t *a3, unsigned int *a4)
{
  uint64_t result;
  unsigned int v8;
  unint64_t v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;

  v11 = 0;
  v12 = 0;
  result = dyld3::MachOFile::findObjCDataSection(*(dyld3::MachOFile **)(a1 + 32), a2, &v12, &v11);
  if ((_DWORD)result)
  {
    v8 = v11;
    v9 = *(unsigned int *)(a1 + 48);
    if (v11 % v9)
      return Diagnostics::error((vm_address_t *)(*(_QWORD *)(a1 + 40) + 32), "Invalid objc pointer section size");
    *a3 = v12;
    v10 = v8 / v9;
  }
  else
  {
    v10 = 0;
    *a3 = 0;
  }
  *a4 = v10;
  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeFixups(dyld4::PrebuiltObjC *this, const dyld4::Loader *a2, dyld4::BumpAllocator *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  if (!*((_BYTE *)this + 441))
    return 0;
  if ((*((__int16 *)a2 + 3) & 0x80000000) == 0)
    dyld4::PrebuiltObjC::serializeFixups();
  v4 = (_QWORD *)dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::operator[]((vm_address_t *)this + 58, *((_WORD *)a2 + 3) & 0x7FFF);
  if (!*v4)
    return 0;
  v5 = v4;
  v6 = *((_QWORD *)a3 + 2);
  v7 = v6 - *(_QWORD *)a3;
  v8 = (v6 - *(_DWORD *)a3);
  dyld4::BumpAllocator::append(a3, v4, 0x50uLL);
  v9 = v5[12];
  if (v9)
  {
    if (v9 != *((_DWORD *)v5 + 13))
      dyld4::PrebuiltObjC::serializeFixups();
    v10 = *((_DWORD *)a3 + 4) - *(_QWORD *)a3 - v7;
    *(_DWORD *)(*(_QWORD *)a3 + v8 + 64) = (unsigned __int16)(*((_WORD *)a3 + 8) - *(_QWORD *)a3 - v7);
    dyld4::BumpAllocator::zeroFill(a3, v9);
    dyld4::BumpAllocator::align(a3, 8u);
    memmove((void *)(*(_QWORD *)a3 + v7 + (unsigned __int16)v10), (const void *)v5[10], v5[12]);
  }
  v11 = v5[17];
  if (v11)
  {
    v12 = *((_DWORD *)a3 + 4) - *(_QWORD *)a3 - v7;
    v13 = *(_QWORD *)a3 + v8;
    *(_DWORD *)(v13 + 68) = (unsigned __int16)(*((_WORD *)a3 + 8) - *(_QWORD *)a3 - v7);
    *(_DWORD *)(v13 + 72) = v11;
    dyld4::BumpAllocator::zeroFill(a3, 8 * v11);
    memmove((void *)(*(_QWORD *)a3 + v7 + (unsigned __int16)v12), (const void *)v5[15], 8 * v5[17]);
  }
  return v7;
}

uint64_t ___ZN5dyld4L22checkForDuplicateClassE9VMAddressPKcPKN4objc14ClassHashTableERN5dyld33MapItNSt3__14pairIS0_PKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS8_IS2_NSB_10BindTargetENS7_11HashCStringENS7_12EqualCStringEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke(uint64_t a1, uint64_t a2, unsigned __int16 a3, _BYTE *a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  unsigned __int16 v14;

  v14 = a3;
  result = dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::find<unsigned short>(*(_QWORD *)(a1 + 32), (_QWORD *)(*(_QWORD *)(a1 + 32) + 16), (_QWORD *)(*(_QWORD *)(a1 + 32) + 56), 0, &v14);
  if (result != *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56) + 32 * *(_QWORD *)(*(_QWORD *)(a1 + 32) + 72))
  {
    v8 = result;
    v9 = *(_QWORD *)(result + 24);
    result = (uint64_t)dyld3::MapBase<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::find<char const*>(*(_QWORD *)(a1 + 40), (uint64_t *)(*(_QWORD *)(a1 + 40) + 16), (_QWORD *)(*(_QWORD *)(a1 + 40) + 56), 0, (const char **)(a1 + 48));
    if (result == *(_QWORD *)(*(_QWORD *)(a1 + 40) + 56) + 24 * *(_QWORD *)(*(_QWORD *)(a1 + 40) + 72))
    {
      if (!*(_BYTE *)(a1 + 64) || !*(_BYTE *)(v8 + 16))
        std::__throw_bad_optional_access[abi:nn180100]();
      v10 = a2 - *(_QWORD *)(v8 + 8) + *(_QWORD *)(a1 + 56);
      v11 = *(_QWORD *)(a1 + 72) + 160;
      *(_QWORD *)&v12 = *(_QWORD *)(a1 + 48);
      *((_QWORD *)&v12 + 1) = v9;
      v13 = v10;
      result = dyld3::Map<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::insert(v11, &v12);
    }
    *a4 = 1;
  }
  return result;
}

uint64_t dyld3::Map<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::insert(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  char *v8;
  size_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  vm_address_t v13;
  vm_size_t v14;
  char *v15;
  size_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  const char **v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  _OWORD v31[2];
  vm_size_t size;
  char v33;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 == *(_QWORD *)a1)
  {
    v5 = 2 * *(_QWORD *)(a1 + 32);
    *(_QWORD *)a1 = 2 * v4;
    size = 0;
    memset(v31, 0, sizeof(v31));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v31, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v31, 1);
      v6 = (*(_QWORD *)&v31[1])++;
      *(_DWORD *)(*(_QWORD *)&v31[0] + 4 * v6) = -1;
    }
    if (*(_QWORD *)(a1 + 72))
    {
      v7 = 0;
      do
      {
        v8 = *(char **)dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v7);
        v9 = _platform_strlen(v8);
        v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v33, (uint64_t *)v8, v9);
        v11 = (*(_QWORD *)&v31[1] - 1) & v10;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v31, v11) != -1)
        {
          v12 = 1;
          do
            v11 = (*(_QWORD *)&v31[1] - 1) & (v11 + v12++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v31, v11) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v31, v11) = v7++;
      }
      while (v7 != *(_QWORD *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v31)
    {
      *(_QWORD *)&v31[1] = 0;
      if (*((_QWORD *)&v31[1] + 1))
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v31[1] + 1), size);
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 40);
      if (v13)
        vm_deallocate(mach_task_self_, v13, *(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)&v31[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v31 + 8);
      v14 = size;
      *(_QWORD *)(a1 + 40) = *((_QWORD *)&v31[1] + 1);
      *(_QWORD *)(a1 + 48) = v14;
    }
  }
  v15 = *(char **)a2;
  v16 = _platform_strlen(*(const char **)a2);
  v17 = (*(_QWORD *)(a1 + 32) - 1) & std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)v31, (uint64_t *)v15, v16);
  v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17);
  if ((_DWORD)v18 == -1)
  {
LABEL_20:
    v21 = *(_QWORD *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17) = v21;
    ++*(_QWORD *)(a1 + 8);
    v22 = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v25 = *(_QWORD *)(a1 + 56);
    v26 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v26 + 1;
    v27 = v25 + 24 * v26;
    v28 = *a2;
    *(_QWORD *)(v27 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v27 = v28;
    v29 = *(_QWORD *)(a1 + 72);
    if (!v29)
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert((uint64_t)v22, v23, v24);
    return *(_QWORD *)(a1 + 56) + 24 * v29 - 24;
  }
  else
  {
    v19 = 1;
    while (1)
    {
      v20 = (const char **)dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v18);
      if (!_platform_strcmp(*v20, *(const char **)a2))
        return dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v18);
      v17 = (*(_QWORD *)(a1 + 32) - 1) & (v17 + v19++);
      v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v17);
      if ((_DWORD)v18 == -1)
        goto LABEL_20;
    }
  }
}

uint64_t dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::find<unsigned short>(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4, unsigned __int16 *a5)
{
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v5 = a3[2];
  if (!v5)
    return *a3;
  v6 = *a5;
  v7 = a2[2];
  v8 = (v7 - 1) & v6;
  if (v7 <= v8)
LABEL_8:
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(a1, (uint64_t)a2, (uint64_t)a3);
  v9 = *a3;
  v10 = 1;
  while (1)
  {
    v11 = *(unsigned int *)(*a2 + 4 * v8);
    if ((_DWORD)v11 == -1)
      return v9 + 32 * v5;
    if (v5 <= v11)
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(a1, (uint64_t)a2, (uint64_t)a3);
    if (*(unsigned __int16 *)(v9 + 32 * v11) == (_DWORD)v6)
      return v9 + 32 * v11;
    v8 = (v8 + v10++) & (v7 - 1);
    if (v7 <= v8)
      goto LABEL_8;
  }
}

const char **dyld3::MapBase<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::find<char const*>(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t a4, const char **a5)
{
  char *v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  unint64_t v21;
  const char **v22;
  unint64_t v23;
  char v25;

  if (!a3[2])
    return (const char **)*a3;
  v8 = (char *)*a5;
  v9 = _platform_strlen(*a5);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v25, (uint64_t *)v8, v9);
  v13 = a2[2];
  v14 = v13 - 1;
  v15 = v10 & (v13 - 1);
  if (v13 <= v15)
LABEL_8:
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v10, v11, v12);
  v16 = *a2;
  v17 = a3[2];
  v18 = *a3;
  v19 = 1;
  v20 = *a5;
  while (1)
  {
    v21 = *(unsigned int *)(v16 + 4 * v15);
    if ((_DWORD)v21 == -1)
      return (const char **)(v18 + 24 * v17);
    if (v17 <= v21)
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(v10, v11, v12);
    v22 = (const char **)(v18 + 24 * v21);
    v10 = _platform_strcmp(*v22, v20);
    if (!(_DWORD)v10)
      return v22;
    v23 = v15 + v19++;
    v15 = v23 & v14;
    if (v13 <= (v23 & v14))
      goto LABEL_8;
  }
}

uint64_t ___ZN5dyld4L23protocolIsInSharedCacheEPKcPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEE_block_invoke(uint64_t a1, uint64_t a2, unsigned __int16 a3, _BYTE *a4)
{
  uint64_t result;
  unsigned __int16 v7;

  v7 = a3;
  result = dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::find<unsigned short>(*(_QWORD *)(a1 + 40), (_QWORD *)(*(_QWORD *)(a1 + 40) + 16), (_QWORD *)(*(_QWORD *)(a1 + 40) + 56), 0, &v7);
  if (result != *(_QWORD *)(*(_QWORD *)(a1 + 40) + 56) + 32 * *(_QWORD *)(*(_QWORD *)(a1 + 40) + 72))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    *a4 = 1;
  }
  return result;
}

uint64_t dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  vm_address_t v14;
  vm_size_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  __int128 v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _OWORD v46[2];
  vm_size_t size[2];

  v6 = *(_QWORD *)(a1 + 8);
  if (v6 == *(_QWORD *)a1)
  {
    v7 = 2 * *(_QWORD *)(a1 + 32);
    *(_QWORD *)a1 = 2 * v6;
    size[0] = 0;
    memset(v46, 0, sizeof(v46));
    dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v46, v7);
    for (; v7; --v7)
    {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v46, 1);
      v8 = (*(_QWORD *)&v46[1])++;
      *(_QWORD *)(*(_QWORD *)&v46[0] + 8 * v8) = -1;
    }
    if (*(_QWORD *)(a1 + 72))
    {
      v9 = 0;
      do
      {
        if ((*(_BYTE *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v9)+ 48) & 6) == 0)
        {
          v10 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v9);
          v11 = murmurHash(*(uint64_t **)v10, *(_DWORD *)(v10 + 8), 0);
          v12 = (*(_QWORD *)&v46[1] - 1) & v11;
          if (*(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v46, v12) != -1)
          {
            v13 = 1;
            do
              v12 = (*(_QWORD *)&v46[1] - 1) & (v12 + v13++);
            while (*(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v46, v12) != -1);
          }
          *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v46, v12) = v9;
        }
        ++v9;
      }
      while (v9 != *(_QWORD *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v46)
    {
      *(_QWORD *)&v46[1] = 0;
      if (*((_QWORD *)&v46[1] + 1))
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v46[1] + 1), size[0]);
    }
    else
    {
      v14 = *(_QWORD *)(a1 + 40);
      if (v14)
        vm_deallocate(mach_task_self_, v14, *(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)&v46[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v46 + 8);
      v15 = size[0];
      *(_QWORD *)(a1 + 40) = *((_QWORD *)&v46[1] + 1);
      *(_QWORD *)(a1 + 48) = v15;
    }
  }
  v16 = (*(_QWORD *)(a1 + 32) - 1) & murmurHash(*(uint64_t **)a2, *(_DWORD *)(a2 + 8), 0);
  v17 = *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v16);
  if (v17 == -1)
  {
LABEL_23:
    v18 = (_QWORD *)(a1 + 56);
    v22 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v16) = v22;
    ++*(_QWORD *)(a1 + 8);
    v23 = *(_OWORD *)(a2 + 16);
    v46[0] = *(_OWORD *)a2;
    v46[1] = v23;
    *(_OWORD *)size = *(_OWORD *)(a2 + 32);
    v24 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v27 = *(_QWORD *)(a1 + 56);
    v28 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v28 + 1;
    v29 = v27 + 56 * v28;
    *(_OWORD *)v29 = v46[0];
    *(_OWORD *)(v29 + 16) = v46[1];
    *(_OWORD *)(v29 + 32) = *(_OWORD *)size;
    *(_QWORD *)(v29 + 48) = 0;
    *a3 = 0;
    v30 = *(_QWORD *)(a1 + 72);
    if (!v30)
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert((uint64_t)v24, v25, v26);
  }
  else
  {
    v18 = (_QWORD *)(a1 + 56);
    v19 = 1;
    while (1)
    {
      v20 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v17);
      v21 = *(_QWORD *)(v20 + 8);
      if (v21 == *(_QWORD *)(a2 + 8) && !_platform_memcmp(*(const void **)v20, *(const void **)a2, v21))
        break;
      v16 = (*(_QWORD *)(a1 + 32) - 1) & (v16 + v19++);
      v17 = *(_QWORD *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v16);
      if (v17 == -1)
        goto LABEL_23;
    }
    while (1)
    {
      v31 = *(_BYTE *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v17)+ 48);
      v32 = (_QWORD *)(a1 + 56);
      if ((v31 & 3) == 0)
        break;
      v17 = *(_QWORD *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[](v32, v17)+ 48) >> 3;
    }
    v33 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[](v32, v17);
    v34 = *(_QWORD *)(v33 + 48);
    if ((v34 & 7) != 0)
    {
      if ((v34 & 4) == 0)
        dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert();
      v35 = v34 & 0xFFFFFFFFFFFFFFF9 | 2;
      *(_QWORD *)(v33 + 48) = v35;
      v36 = v35 & 3 | (8 * *(_QWORD *)(a1 + 72));
    }
    else
    {
      v37 = v34 | 1;
      *(_QWORD *)(v33 + 48) = v37;
      v36 = v37 & 7 | (8 * *(_QWORD *)(a1 + 72));
    }
    *(_QWORD *)(v33 + 48) = v36;
    v38 = *(_OWORD *)(a2 + 16);
    v46[0] = *(_OWORD *)a2;
    v46[1] = v38;
    *(_OWORD *)size = *(_OWORD *)(a2 + 32);
    v39 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v42 = *(_QWORD *)(a1 + 56);
    v43 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v43 + 1;
    v44 = v42 + 56 * v43;
    *(_OWORD *)v44 = v46[0];
    *(_OWORD *)(v44 + 16) = v46[1];
    *(_OWORD *)(v44 + 32) = *(_OWORD *)size;
    *(_QWORD *)(v44 + 48) = 4;
    *a3 = 1;
    v30 = *(_QWORD *)(a1 + 72);
    if (!v30)
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert((uint64_t)v39, v40, v41);
  }
  return *v18 + 56 * v30 - 56;
}

unint64_t dyld3::OverflowSafeArray<BOOL,4294967295ull>::operator[](_QWORD *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = a1[2];
  v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5)
      dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve(a1, a2 + 1);
    a1[2] = v5;
  }
  return *a1 + a2;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[](_QWORD *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = a1[2];
  v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5)
      dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::reserve(a1, a2 + 1);
    a1[2] = v5;
  }
  return *a1 + 56 * a2;
}

_QWORD *dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::verifySpace(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  const void **v4;
  vm_address_t v5;
  vm_size_t v6;
  unint64_t v7;
  vm_size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;

  v2 = result[1];
  v3 = result[2] + a2;
  if (v3 > v2)
  {
    v4 = (const void **)result;
    v5 = result[3];
    v6 = result[4];
    v7 = 2 * v2;
    if (v7 > v3)
      v3 = v7;
    v8 = (vm_page_size + 56 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    result = memmove((void *)v4[3], *v4, 56 * (_QWORD)v4[2]);
    v12 = (unint64_t)v4[4] / 0x38;
    *v4 = v4[3];
    v4[1] = (const void *)v12;
    if (v5)
      return (_QWORD *)vm_deallocate(mach_task_self_, v5, v6);
  }
  return result;
}

const char **dyld3::MapBase<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::const_find<char const*>(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t a4, const char **a5)
{
  char *v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  unint64_t v21;
  const char **v22;
  unint64_t v23;
  char v25;

  if (!a3[2])
    return (const char **)*a3;
  v8 = (char *)*a5;
  v9 = _platform_strlen(*a5);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v25, (uint64_t *)v8, v9);
  v13 = a2[2];
  v14 = v13 - 1;
  v15 = v10 & (v13 - 1);
  if (v13 <= v15)
LABEL_8:
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v10, v11, v12);
  v16 = *a2;
  v17 = a3[2];
  v18 = *a3;
  v19 = 1;
  v20 = *a5;
  while (1)
  {
    v21 = *(unsigned int *)(v16 + 4 * v15);
    if ((_DWORD)v21 == -1)
      return (const char **)(v18 + 24 * v17);
    if (v17 <= v21)
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v10, v11, v12);
    v22 = (const char **)(v18 + 24 * v21);
    v10 = _platform_strcmp(*v22, v20);
    if (!(_DWORD)v10)
      return v22;
    v23 = v15 + v19++;
    v15 = v23 & v14;
    if (v13 <= (v23 & v14))
      goto LABEL_8;
  }
}

uint64_t dyld3::MapBase<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::find<VMOffset>(_BOOL8 a1, _QWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;

  if (!a3[2])
    return *a3;
  if (!*(_BYTE *)(a5 + 8))
    std::__throw_bad_optional_access[abi:nn180100]();
  v8 = a2[2];
  v9 = (v8 - 1) & *(_QWORD *)a5;
  if (v8 <= v9)
LABEL_9:
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(a1, (uint64_t)a2, (uint64_t)a3);
  v10 = 1;
  while (1)
  {
    v11 = *(unsigned int *)(*a2 + 4 * v9);
    v12 = a3[2];
    if ((_DWORD)v11 == -1)
      return *a3 + 24 * v12;
    if (v12 <= v11)
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(a1, (uint64_t)a2, (uint64_t)a3);
    a1 = dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual::equal(*a3 + 24 * v11, a5);
    if (a1)
      break;
    v13 = a2[2];
    v9 = (v13 - 1) & (v9 + v10++);
    if (v13 <= v9)
      goto LABEL_9;
  }
  if (a3[2] <= v11)
    ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(a1, (uint64_t)a2, (uint64_t)a3);
  return *a3 + 24 * v11;
}

BOOL dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual::equal(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 8) || !*(_BYTE *)(a2 + 8))
    std::__throw_bad_optional_access[abi:nn180100]();
  return *(_QWORD *)a1 == *(_QWORD *)a2;
}

uint64_t ___ZN5dyld4L32forEachSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke(uint64_t a1, uint64_t a2, char a3, uint64_t a4, char a5)
{
  if (!a3 || !a5)
    std::__throw_bad_optional_access[abi:nn180100]();
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke(uint64_t a1, int *a2)
{
  char v4;
  char v5;
  char v6;
  char v7;
  _QWORD v9[3];

  objc_visitor::Method::getNameVMAddr(a2, *(_QWORD *)(a1 + 40));
  v5 = v4;
  objc_visitor::Method::getNameField(a2, *(_QWORD *)(a1 + 40), v9);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  v7 = v6;
  objc_visitor::Method::getName(a2, *(_QWORD *)(a1 + 40));
  if (!v5 || !v7)
    std::__throw_bad_optional_access[abi:nn180100]();
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2(uint64_t a1, objc_visitor::MethodList *this)
{
  uint64_t result;
  int v5;
  int i;
  double Method;
  uint64_t v8;

  result = objc_visitor::MethodList::numMethods(this);
  if ((_DWORD)result)
  {
    result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if ((result & 1) == 0)
    {
      result = objc_visitor::MethodList::numMethods(this);
      if ((_DWORD)result)
      {
        v5 = result;
        for (i = 0; i != v5; ++i)
        {
          Method = objc_visitor::MethodList::getMethod(this, *(_QWORD *)(a1 + 40), i, (uint64_t)&v8);
          result = (*(uint64_t (**)(double))(*(_QWORD *)(a1 + 32) + 16))(Method);
        }
      }
    }
  }
  return result;
}

uint64_t ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  objc_visitor::Class::getBaseMethods(a2, *(int **)(a1 + 40), (uint64_t)&v4);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke(uint64_t a1, int *a2)
{
  char v4;
  char v5;
  char v6;
  char v7;
  _QWORD v9[3];

  objc_visitor::Method::getNameVMAddr(a2, *(_QWORD *)(a1 + 40));
  v5 = v4;
  objc_visitor::Method::getNameField(a2, *(_QWORD *)(a1 + 40), v9);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  v7 = v6;
  objc_visitor::Method::getName(a2, *(_QWORD *)(a1 + 40));
  if (!v5 || !v7)
    std::__throw_bad_optional_access[abi:nn180100]();
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2(uint64_t a1, objc_visitor::MethodList *this)
{
  uint64_t result;
  int v5;
  int i;
  double Method;
  uint64_t v8;

  result = objc_visitor::MethodList::numMethods(this);
  if ((_DWORD)result)
  {
    result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if ((result & 1) == 0)
    {
      result = objc_visitor::MethodList::numMethods(this);
      if ((_DWORD)result)
      {
        v5 = result;
        for (i = 0; i != v5; ++i)
        {
          Method = objc_visitor::MethodList::getMethod(this, *(_QWORD *)(a1 + 40), i, (uint64_t)&v8);
          result = (*(uint64_t (**)(double))(*(_QWORD *)(a1 + 32) + 16))(Method);
        }
      }
    }
  }
  return result;
}

uint64_t ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3(uint64_t a1, lsl::Allocator::Pool *a2)
{
  uint64_t v5;
  _BYTE v6[32];

  objc_visitor::Category::getInstanceMethods(a2, *(int **)(a1 + 40), (uint64_t)v6);
  objc_visitor::Category::getClassMethods(a2, *(int **)(a1 + 40), (uint64_t)&v5);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke(uint64_t a1, int *a2)
{
  char v4;
  char v5;
  char v6;
  char v7;
  _QWORD v9[3];

  objc_visitor::Method::getNameVMAddr(a2, *(_QWORD *)(a1 + 40));
  v5 = v4;
  objc_visitor::Method::getNameField(a2, *(_QWORD *)(a1 + 40), v9);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  v7 = v6;
  objc_visitor::Method::getName(a2, *(_QWORD *)(a1 + 40));
  if (!v5 || !v7)
    std::__throw_bad_optional_access[abi:nn180100]();
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2(uint64_t a1, objc_visitor::MethodList *this)
{
  uint64_t result;
  int v5;
  int i;
  double Method;
  uint64_t v8;

  result = objc_visitor::MethodList::numMethods(this);
  if ((_DWORD)result)
  {
    result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if ((result & 1) == 0)
    {
      result = objc_visitor::MethodList::numMethods(this);
      if ((_DWORD)result)
      {
        v5 = result;
        for (i = 0; i != v5; ++i)
        {
          Method = objc_visitor::MethodList::getMethod(this, *(_QWORD *)(a1 + 40), i, (uint64_t)&v8);
          result = (*(uint64_t (**)(double))(*(_QWORD *)(a1 + 32) + 16))(Method);
        }
      }
    }
  }
  return result;
}

uint64_t ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3(uint64_t a1, lsl::Allocator::Pool *a2)
{
  uint64_t v5;
  _BYTE v6[32];
  _BYTE v7[32];
  _BYTE v8[32];

  objc_visitor::Category::getClassMethods(a2, *(int **)(a1 + 40), (uint64_t)v8);
  objc_visitor::Protocol::getClassMethods(a2, *(int **)(a1 + 40), (uint64_t)v7);
  objc_visitor::Protocol::getOptionalInstanceMethods(a2, *(int **)(a1 + 40), (uint64_t)v6);
  objc_visitor::Protocol::getOptionalClassMethods(a2, *(int **)(a1 + 40), (uint64_t)&v5);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

__n128 __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void ___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke(_QWORD *a1, uint64_t a2, char a3, _BYTE *a4)
{
  vm_address_t *v8;
  dyld4::RuntimeState *v9;
  dyld4::Loader *v10;
  _QWORD v11[6];

  if (!_platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL)
    && !_platform_strcmp(*(const char **)(a2 + 80), "__objc_imageinfo"))
  {
    if ((a3 & 1) == 0 && *(_QWORD *)(a2 + 72) == 8)
    {
      v8 = (vm_address_t *)a1[6];
      v9 = (dyld4::RuntimeState *)a1[7];
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 0x40000000;
      v11[2] = ___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke_2;
      v11[3] = &unk_1E4F7E1F8;
      v10 = (dyld4::Loader *)a1[5];
      v11[4] = a1[4];
      v11[5] = a2;
      dyld4::Loader::withLayout(v10, v8, v9, (uint64_t)v11);
    }
    *a4 = 1;
  }
}

uint64_t ___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke_2(uint64_t result, mach_o::Layout *this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  v2 = *(_QWORD *)(result + 40);
  v3 = (_QWORD *)(*((_QWORD *)this + 1) + 48 * ((unsigned __int16)*(_DWORD *)(v2 + 56) >> 4));
  v4 = *(_QWORD *)(v2 + 64);
  if ((*(_BYTE *)(v3[4] + v4 - *v3 + 4) & 0x80) == 0)
  {
    v5 = result;
    result = mach_o::Layout::textUnslidVMAddr(this);
    v6 = *(_QWORD *)(*(_QWORD *)(v5 + 32) + 8);
    v7 = *(unsigned __int8 *)(v6 + 56);
    *(_QWORD *)(v6 + 40) = v4 - result;
    *(_BYTE *)(v6 + 48) = 1;
    if (!v7)
      *(_BYTE *)(v6 + 56) = 1;
  }
  return result;
}

_QWORD *objc::objc_headeropt_ro_t<unsigned long long>::get(int *a1, uint64_t a2, unint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  _QWORD *v7;
  char *v8;

  if (*a1 < 0)
    return 0;
  v3 = 0;
  v4 = *a1;
  while (1)
  {
    v5 = v3 + v4;
    if (v3 + v4 < 0 != __OFADD__(v3, v4))
      ++v5;
    if (*a1 <= (v5 >> 1))
      objc::objc_headeropt_ro_t<unsigned long long>::get((uint64_t)a1, a2, a3);
    v6 = v5 >> 1;
    v7 = (_QWORD *)((char *)a1 + (a1[1] * (v5 >> 1)) + 8);
    v8 = (char *)v7 + a2 - (_QWORD)a1 + *v7;
    if (v8 == (char *)a3)
      break;
    if ((unint64_t)v8 <= a3)
      v3 = v6 + 1;
    else
      v4 = v6 - 1;
    if (v3 > v4)
      return 0;
  }
  return v7;
}

unint64_t objc::objc_headeropt_ro_t<unsigned long long>::index(_DWORD *a1, unint64_t a2, uint64_t a3)
{
  _DWORD *v3;
  unint64_t v4;

  if (!*a1)
    objc::objc_headeropt_ro_t<unsigned long long>::get((uint64_t)a1, a2, a3);
  v3 = a1 + 2;
  if ((unint64_t)(a1 + 2) > a2
    || (v4 = a1[1], (unint64_t)v3 + (v4 * *a1) <= a2))
  {
    objc::objc_headeropt_ro_t<unsigned long long>::index();
  }
  return (a2 - (unint64_t)v3) / v4;
}

int *objc::objc_headeropt_ro_t<unsigned int>::get(int *a1, uint64_t a2, unint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int *v7;
  char *v8;

  if (*a1 < 0)
    return 0;
  v3 = 0;
  v4 = *a1;
  while (1)
  {
    v5 = v3 + v4;
    if (v3 + v4 < 0 != __OFADD__(v3, v4))
      ++v5;
    if (*a1 <= (v5 >> 1))
      objc::objc_headeropt_ro_t<unsigned long long>::get((uint64_t)a1, a2, a3);
    v6 = v5 >> 1;
    v7 = (int *)((char *)a1 + (a1[1] * (v5 >> 1)) + 8);
    v8 = (char *)v7 + a2 - (_QWORD)a1 + *v7;
    if (v8 == (char *)a3)
      break;
    if ((unint64_t)v8 <= a3)
      v3 = v6 + 1;
    else
      v4 = v6 - 1;
    if (v3 > v4)
      return 0;
  }
  return v7;
}

__n128 __Block_byref_object_copy__69(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void ___ZN5dyld4L21optimizeObjCProtocolsERNS_12RuntimeStateEPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke(uint64_t a1, lsl::Allocator::Pool *a2, _BYTE *a3)
{
  uint64_t VMAddress;
  char v7;
  char v8;
  uint64_t NameVMAddr;
  char v10;
  char v11;
  char *Name;
  _BYTE v13[24];

  objc_visitor::Protocol::getISAVMAddr(a2, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40, (uint64_t)v13);
  if (v13[16])
  {
    Diagnostics::error((vm_address_t *)(*(_QWORD *)(a1 + 40) + 32), "Protocol ISA must be null");
    *a3 = 1;
  }
  else
  {
    VMAddress = objc_visitor::Protocol::getVMAddress(a2);
    v8 = v7;
    NameVMAddr = objc_visitor::Protocol::getNameVMAddr(a2, (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
    v11 = v10;
    Name = (char *)objc_visitor::Protocol::getName(a2, (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
    if (!v8 || !v11)
      std::__throw_bad_optional_access[abi:nn180100]();
    dyld4::PrebuiltObjC::ObjCOptimizerImage::visitProtocol(*(_QWORD *)(a1 + 40), *(unsigned int **)(a1 + 48), *(_QWORD *)(a1 + 56), VMAddress, 1, NameVMAddr, 1, Name);
  }
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result;
  const char *v8;

  result = _platform_strcmp(*(const char **)(a2 + 40), "__OBJC");
  if (!(_DWORD)result)
  {
    v8 = *(const char **)(a2 + 80);
    result = _platform_strcmp(v8, "__module_info");
    if (!(_DWORD)result
      || (result = _platform_strcmp(v8, "__protocol"), !(_DWORD)result)
      || (result = _platform_strcmp(v8, "__message_refs"), !(_DWORD)result))
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_2(_QWORD *a1, int *a2, _BYTE *a3)
{
  uint64_t result;
  char v6;
  uint64_t v7;
  unint64_t v8;

  result = (uint64_t)objc_visitor::Method::getNameSelRefVMAddr(a2, *(_QWORD *)(a1[4] + 8) + 40);
  v7 = a1[5];
  if (!*(_BYTE *)(v7 + 24) || !v6)
    std::__throw_bad_optional_access[abi:nn180100]();
  v8 = result - *(_QWORD *)(v7 + 16);
  if (v8 < a1[6] || v8 >= a1[7])
  {
    result = Diagnostics::error((vm_address_t *)(v7 + 32), "Cannot handle relative method list pointing outside of __objc_selrefs");
    *a3 = 1;
  }
  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_3(uint64_t a1, objc_visitor::MethodList *this, _BYTE *a3)
{
  uint64_t result;
  int v7;
  int i;
  double Method;
  uint64_t v10;

  result = objc_visitor::MethodList::numMethods(this);
  if ((_DWORD)result)
  {
    result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if ((_DWORD)result)
    {
      result = objc_visitor::MethodList::numMethods(this);
      if ((_DWORD)result)
      {
        v7 = result;
        for (i = 0; i != v7; ++i)
        {
          Method = objc_visitor::MethodList::getMethod(this, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40, i, (uint64_t)&v10);
          result = (*(uint64_t (**)(double))(*(_QWORD *)(a1 + 32) + 16))(Method);
        }
      }
    }
    else
    {
      *a3 = 1;
    }
  }
  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  objc_visitor::Class::getBaseMethods(a2, (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), (uint64_t)&v4);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_5(uint64_t a1, lsl::Allocator::Pool *a2, _BYTE *a3)
{
  uint64_t result;
  uint64_t v7;
  _BYTE v8[32];

  objc_visitor::Category::getInstanceMethods(a2, (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), (uint64_t)v8);
  objc_visitor::Category::getClassMethods(a2, (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), (uint64_t)&v7);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (!*a3)
    return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_6(uint64_t a1, lsl::Allocator::Pool *a2, _BYTE *a3)
{
  uint64_t result;
  uint64_t v7;
  _BYTE v8[32];
  _BYTE v9[32];
  _BYTE v10[32];

  objc_visitor::Category::getClassMethods(a2, (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), (uint64_t)v10);
  objc_visitor::Protocol::getClassMethods(a2, (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), (uint64_t)v9);
  objc_visitor::Protocol::getOptionalInstanceMethods(a2, (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), (uint64_t)v8);
  objc_visitor::Protocol::getOptionalClassMethods(a2, (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), (uint64_t)&v7);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (!*a3)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    if (!*a3)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
      if (!*a3)
        return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    }
  }
  return result;
}

uint64_t dyld3::MapBase<prebuilt_objc::ObjCStringKeyOnDisk,void,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::const_find<char const*>(uint64_t a1, _QWORD *a2, _QWORD *a3, dyld4::RuntimeState *a4, const char **a5)
{
  char *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  dyld4::PrebuiltLoader::BindTargetRef *v19;
  unint64_t v20;
  const char *v22[2];

  if (!a3[2])
    return *a3;
  v9 = (char *)*a5;
  v10 = _platform_strlen(*a5);
  v11 = murmurHash((uint64_t *)v9, v10, 0);
  v14 = a2[2];
  v15 = (v14 - 1) & v11;
  if (v14 <= v15)
LABEL_8:
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v11, v12, v13);
  v16 = 1;
  while (1)
  {
    v17 = *(unsigned int *)(*a2 + 4 * v15);
    v18 = a3[2];
    if ((_DWORD)v17 == -1)
      return *a3 + 8 * v18;
    if (v18 <= v17)
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v11, v12, v13);
    v19 = (dyld4::PrebuiltLoader::BindTargetRef *)(*a3 + 8 * v17);
    v22[0] = *a5;
    v22[1] = (const char *)_platform_strlen(v22[0]);
    v11 = prebuilt_objc::EqualObjCStringKeyOnDisk::equal(v19, (uint64_t)v22, a4);
    if ((_DWORD)v11)
      break;
    v20 = a2[2];
    v15 = (v20 - 1) & (v15 + v16++);
    if (v20 <= v15)
      goto LABEL_8;
  }
  if (a3[2] <= v17)
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v11, v12, v13);
  return *a3 + 8 * v17;
}

BOOL prebuilt_objc::EqualObjCStringKeyOnDisk::equal(dyld4::PrebuiltLoader::BindTargetRef *a1, uint64_t a2, dyld4::RuntimeState *a3)
{
  const char *v4;
  size_t v5;

  v4 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value(a1, a3, (uint64_t)a3);
  v5 = _platform_strlen(v4);
  return v5 == *(_QWORD *)(a2 + 8) && _platform_memcmp(v4, *(const void **)a2, v5) == 0;
}

void dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry<char const*>(uint64_t a1, _QWORD *a2, uint64_t *a3, dyld4::RuntimeState *a4, const char **a5, uint64_t a6)
{
  char *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  dyld4::PrebuiltLoader::BindTargetRef *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  unint64_t v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  size_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  const char *v50;
  int64x2_t v51;
  uint64_t v52;

  if (a3[2])
  {
    v11 = (char *)*a5;
    v12 = _platform_strlen(*a5);
    v13 = murmurHash((uint64_t *)v11, v12, 0);
    v16 = a2[2];
    v17 = (v16 - 1) & v13;
    if (v16 <= v17)
LABEL_8:
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v13, v14, v15);
    v18 = 1;
    while (1)
    {
      v19 = *(_QWORD *)(*a2 + 8 * v17);
      if (v19 == -1)
        break;
      if (a3[2] <= v19)
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v13, v14, v15);
      v20 = (dyld4::PrebuiltLoader::BindTargetRef *)(*a3 + 24 * v19);
      v50 = *a5;
      v51.i64[0] = _platform_strlen(v50);
      v13 = prebuilt_objc::EqualObjCStringKeyOnDisk::equal(v20, (uint64_t)&v50, a4);
      if ((_DWORD)v13)
      {
        v27 = a3[2];
        if (v27 <= v19)
          dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v13, v14, v15);
        v28 = *a3;
        v29 = *a3 + 24 * v19;
        v32 = *(_QWORD *)(v29 + 16);
        v31 = (_QWORD *)(v29 + 16);
        v30 = v32;
        if ((v32 & 7) != 0)
        {
          if (v27 <= v30 >> 3)
LABEL_15:
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v13, v14, v15);
          v33 = v30 >> 3;
          v34 = 2;
          while (1)
          {
            v35 = *(_QWORD *)(v28 + 24 * v33 + 16);
            if ((v35 & 3) == 0)
              break;
            v33 = v35 >> 3;
            ++v34;
            if (v27 <= v35 >> 3)
              goto LABEL_15;
          }
          __chkstk_darwin(v13, v14, v15, v21, v22, v23, v24, v25, v49);
          v38 = (char *)&v49 - v37;
          if (v36 >= 0x200)
            v39 = 512;
          else
            v39 = v36;
          bzero((char *)&v49 - v37, v39);
          *(_QWORD *)v38 = v28 + 24 * v19 + 8;
          v43 = a3[2];
          if (v43 <= *v31 >> 3)
LABEL_23:
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v40, v41, v42);
          v44 = *v31 >> 3;
          v45 = *a3;
          v46 = 2;
          while (1)
          {
            v47 = v45 + 24 * v44;
            v48 = *(_QWORD *)(v47 + 16);
            *(_QWORD *)&v38[8 * v46 - 8] = v47 + 8;
            if ((v48 & 3) == 0)
              break;
            v44 = v48 >> 3;
            ++v46;
            if (v43 <= v48 >> 3)
              goto LABEL_23;
          }
          v50 = v38;
          v51.i64[0] = v46;
          v51.i64[1] = v46;
          (*(void (**)(uint64_t, const char **))(a6 + 16))(a6, &v50);
        }
        else
        {
          v52 = v28 + 24 * v19 + 8;
          v50 = (const char *)&v52;
          v51 = vdupq_n_s64(1uLL);
          (*(void (**)(uint64_t, const char **))(a6 + 16))(a6, &v50);
        }
        return;
      }
      v26 = a2[2];
      v17 = (v26 - 1) & (v17 + v18++);
      if (v26 <= v17)
        goto LABEL_8;
    }
  }
}

uint64_t dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  size_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  int64x2_t v36;
  uint64_t *v37;
  int64x2_t v38;
  uint64_t v39;

  v8 = a3[2];
  if (v8)
  {
    v11 = *a3;
    v12 = *a3 + 24 * v8;
    v36 = vdupq_n_s64(1uLL);
    do
    {
      v13 = *(_QWORD *)(v11 + 16);
      if ((v13 & 7) != 0)
      {
        if ((v13 & 1) != 0)
        {
          v14 = a3[2];
          if (v14 <= v13 >> 3)
LABEL_22:
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(result, a2, (uint64_t)a3);
          v15 = v13 >> 3;
          v16 = 2;
          v17 = 16;
          while (1)
          {
            v18 = *(_QWORD *)(*a3 + 24 * v15 + 16);
            if ((v18 & 3) == 0)
              break;
            v15 = v18 >> 3;
            v17 += 8;
            ++v16;
            if (v14 <= v18 >> 3)
              goto LABEL_22;
          }
          __chkstk_darwin(result, a2, (uint64_t)a3, a4, a5, a6, a7, a8, v36.i64[0]);
          v21 = (v20 + 15) & 0xFFFFFFFFFFFFFFF0;
          v22 = (uint64_t *)((char *)v36.i64 - v21);
          if (v19 >= 0x200)
            v23 = 512;
          else
            v23 = v19;
          bzero((char *)&v36 - v21, v23);
          *v22 = v11 + 8;
          v27 = a3[2];
          v28 = *(_QWORD *)(v11 + 16);
          if (v27 <= v28 >> 3)
LABEL_23:
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v24, v25, v26);
          v29 = v28 >> 3;
          v30 = *a3;
          v31 = 1;
          while (1)
          {
            v32 = v30 + 24 * v29;
            v34 = *(_QWORD *)(v32 + 16);
            v33 = (unint64_t *)(v32 + 16);
            v22[v31] = (uint64_t)(v33 - 1);
            if ((v34 & 3) == 0)
              break;
            v35 = *v33;
            v29 = *v33 >> 3;
            ++v31;
            if (v27 <= v35 >> 3)
              goto LABEL_23;
          }
          v37 = v22;
          v38.i64[0] = v31 + 1;
          v38.i64[1] = v31 + 1;
          result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t **))(a4 + 16))(a4, v11, &v37);
        }
      }
      else
      {
        v39 = v11 + 8;
        v37 = &v39;
        v38 = v36;
        result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t **))(a4 + 16))(a4, v11, &v37);
      }
      v11 += 24;
    }
    while (v11 != v12);
  }
  return result;
}

uint64_t dyld3::MapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::find<prebuilt_objc::ObjCStringKey>(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;

  if (!a3[2])
    return *a3;
  v8 = murmurHash(*(uint64_t **)a5, *(_DWORD *)(a5 + 8), 0);
  v11 = a2[2];
  v12 = v11 - 1;
  v13 = v8 & (v11 - 1);
  if (v11 <= v13)
LABEL_9:
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(v8, v9, v10);
  v14 = *a2;
  v15 = a3[2];
  v16 = *a3;
  v17 = 1;
  v20 = a5;
  v19 = *(uint64_t **)a5;
  v18 = *(_QWORD *)(v20 + 8);
  while (1)
  {
    v21 = *(unsigned int *)(v14 + 4 * v13);
    if ((_DWORD)v21 == -1)
      return v16 + 32 * v15;
    if (v15 <= v21)
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(v8, v9, v10);
    v22 = v16 + 32 * v21;
    if (*(_QWORD *)(v22 + 8) == v18)
    {
      v8 = _platform_memcmp(*(const void **)v22, v19, v18);
      if (!(_DWORD)v8)
        return v22;
    }
    v23 = v13 + v17++;
    v13 = v23 & v12;
    if (v11 <= (v23 & v12))
      goto LABEL_9;
  }
}

_QWORD *dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCObject,4294967295ull>::verifySpace(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  const void **v4;
  vm_address_t v5;
  vm_size_t v6;
  unint64_t v7;
  vm_size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;

  v2 = result[1];
  v3 = result[2] + a2;
  if (v3 > v2)
  {
    v4 = (const void **)result;
    v5 = result[3];
    v6 = result[4];
    v7 = 2 * v2;
    if (v7 > v3)
      v3 = v7;
    v8 = (vm_page_size + 40 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    result = memmove((void *)v4[3], *v4, 40 * (_QWORD)v4[2]);
    v12 = (unint64_t)v4[4] / 0x28;
    *v4 = v4[3];
    v4[1] = (const void *)v12;
    if (v5)
      return (_QWORD *)vm_deallocate(mach_task_self_, v5, v6);
  }
  return result;
}

_QWORD *dyld3::OverflowSafeArray<BOOL,4294967295ull>::verifySpace(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  const void **v4;
  vm_address_t v5;
  vm_size_t v6;
  unint64_t v7;
  vm_size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;

  v2 = result[1];
  v3 = result[2] + a2;
  if (v3 > v2)
  {
    v4 = (const void **)result;
    v5 = result[3];
    v6 = result[4];
    v7 = 2 * v2;
    if (v7 > v3)
      v3 = v7;
    v8 = (v3 + vm_page_size - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    result = memmove((void *)v4[3], *v4, (size_t)v4[2]);
    v12 = v4[4];
    *v4 = v4[3];
    v4[1] = v12;
    if (v5)
      return (_QWORD *)vm_deallocate(mach_task_self_, v5, v6);
  }
  return result;
}

uint64_t dyld3::Map<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::insert(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  vm_address_t v11;
  vm_size_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  _OWORD v27[2];
  vm_size_t size;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 == *(_QWORD *)a1)
  {
    v5 = 2 * *(_QWORD *)(a1 + 32);
    *(_QWORD *)a1 = 2 * v4;
    size = 0;
    memset(v27, 0, sizeof(v27));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v27, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v27, 1);
      v6 = (*(_QWORD *)&v27[1])++;
      *(_DWORD *)(*(_QWORD *)&v27[0] + 4 * v6) = -1;
    }
    if (*(_QWORD *)(a1 + 72))
    {
      v7 = 0;
      while (1)
      {
        v8 = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v7);
        if (!*(_BYTE *)(v8 + 8))
          break;
        v9 = (*(_QWORD *)&v27[1] - 1) & *(_QWORD *)v8;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v27, v9) != -1)
        {
          v10 = 1;
          do
            v9 = (*(_QWORD *)&v27[1] - 1) & (v9 + v10++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v27, v9) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v27, v9) = v7++;
        if (v7 == *(_QWORD *)(a1 + 72))
          goto LABEL_11;
      }
LABEL_26:
      std::__throw_bad_optional_access[abi:nn180100]();
    }
LABEL_11:
    if ((_OWORD *)(a1 + 16) == v27)
    {
      *(_QWORD *)&v27[1] = 0;
      if (*((_QWORD *)&v27[1] + 1))
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v27[1] + 1), size);
    }
    else
    {
      v11 = *(_QWORD *)(a1 + 40);
      if (v11)
        vm_deallocate(mach_task_self_, v11, *(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)&v27[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v27 + 8);
      v12 = size;
      *(_QWORD *)(a1 + 40) = *((_QWORD *)&v27[1] + 1);
      *(_QWORD *)(a1 + 48) = v12;
    }
  }
  if (!*(_BYTE *)(a2 + 8))
    goto LABEL_26;
  v13 = (*(_QWORD *)(a1 + 32) - 1) & *(_QWORD *)a2;
  v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v13);
  if ((_DWORD)v14 == -1)
  {
LABEL_22:
    v17 = *(_QWORD *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v13) = v17;
    ++*(_QWORD *)(a1 + 8);
    v18 = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace((_QWORD *)(a1 + 56), 1);
    v21 = *(_QWORD *)(a1 + 56);
    v22 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v22 + 1;
    v23 = v21 + 24 * v22;
    v24 = *(_OWORD *)a2;
    *(_DWORD *)(v23 + 16) = *(_DWORD *)(a2 + 16);
    *(_OWORD *)v23 = v24;
    v25 = *(_QWORD *)(a1 + 72);
    if (!v25)
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert((uint64_t)v18, v19, v20);
    return *(_QWORD *)(a1 + 56) + 24 * v25 - 24;
  }
  else
  {
    v15 = 1;
    while (1)
    {
      v16 = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v14);
      if (dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual::equal(v16, a2))
        return dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((_QWORD *)(a1 + 56), v14);
      v13 = (*(_QWORD *)(a1 + 32) - 1) & (v13 + v15++);
      v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((_QWORD *)(a1 + 16), v13);
      if ((_DWORD)v14 == -1)
        goto LABEL_22;
    }
  }
}

uint64_t dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo(vm_address_t *a1, unint64_t a2)
{
  vm_address_t v3;
  vm_size_t v4;
  vm_address_t *v5;
  unint64_t v6;
  vm_size_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  vm_address_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 *v14;
  vm_address_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  unint64_t v25;

  v3 = a1[3];
  v4 = a1[4];
  v5 = a1 + 3;
  v6 = 2 * a1[1];
  if (v6 <= a2)
    v6 = a2;
  v7 = (vm_page_size + 160 * v6 - 1) & -(uint64_t)vm_page_size;
  a1[4] = v7;
  result = vm_allocate(mach_task_self_, v5, v7, 1006632961);
  if ((_DWORD)result)
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(result, v9, v10);
  v11 = a1[3];
  if (a1[2])
  {
    v12 = 0;
    v13 = 0;
    do
    {
      v14 = (__int128 *)(*a1 + v12);
      v15 = v11 + v12;
      v16 = v14[1];
      v17 = v14[2];
      v18 = v14[4];
      *(_OWORD *)(v15 + 48) = v14[3];
      *(_OWORD *)(v15 + 64) = v18;
      *(_OWORD *)(v15 + 16) = v16;
      *(_OWORD *)(v15 + 32) = v17;
      v19 = *v14;
      *(_OWORD *)(v15 + 80) = 0uLL;
      *(_OWORD *)(v15 + 96) = 0uLL;
      *(_OWORD *)v15 = v19;
      *(_QWORD *)(v15 + 112) = 0;
      v20 = *((_QWORD *)v14 + 10);
      *(_OWORD *)(v15 + 88) = *(__int128 *)((char *)v14 + 88);
      v21 = *((_QWORD *)v14 + 13);
      *(_QWORD *)(v15 + 80) = v20;
      v22 = *((_QWORD *)v14 + 14);
      *(_QWORD *)(v15 + 104) = v21;
      *(_QWORD *)(v15 + 112) = v22;
      *((_QWORD *)v14 + 14) = 0;
      v14[5] = 0uLL;
      v14[6] = 0uLL;
      *(_QWORD *)(v15 + 152) = 0;
      *(_OWORD *)(v15 + 136) = 0uLL;
      *(_OWORD *)(v15 + 120) = 0uLL;
      v23 = v14[8];
      *(_QWORD *)(v15 + 120) = *((_QWORD *)v14 + 15);
      *(_OWORD *)(v15 + 128) = v23;
      v24 = *((_QWORD *)v14 + 19);
      *(_QWORD *)(v15 + 144) = *((_QWORD *)v14 + 18);
      *(_QWORD *)(v15 + 152) = v24;
      *((_QWORD *)v14 + 19) = 0;
      *(__int128 *)((char *)v14 + 136) = 0uLL;
      *(__int128 *)((char *)v14 + 120) = 0uLL;
      ++v13;
      v12 += 160;
    }
    while (v13 != a1[2]);
    v11 = *v5;
  }
  v25 = a1[4] / 0xA0;
  *a1 = v11;
  a1[1] = v25;
  if (v3)
    return vm_deallocate(mach_task_self_, v3, v4);
  return result;
}

uint64_t dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::Map(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_OWORD *)(a1 + 16) = 0u;
  v2 = (_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A5CBAC60;
  v3 = 32;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((_QWORD *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1);
    v4 = *(_QWORD *)(a1 + 16);
    v5 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }
  while (v3);
  dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::reserve(a1 + 56, 0x20uLL);
  return a1;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::reserve(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;
  vm_address_t v4;
  vm_size_t v5;
  vm_address_t *v6;
  unint64_t v7;
  vm_size_t v8;
  uint64_t v9;
  uint64_t v10;
  vm_address_t v11;
  uint64_t v12;
  uint64_t v13;
  _OWORD *v14;
  _OWORD *v15;
  __int128 v16;
  uint64_t v17;

  v2 = *(_QWORD *)(result + 8);
  if (v2 < a2)
  {
    v3 = (_QWORD *)result;
    v4 = *(_QWORD *)(result + 24);
    v5 = *(_QWORD *)(result + 32);
    v6 = (vm_address_t *)(result + 24);
    v7 = 2 * v2;
    if (v7 <= a2)
      v7 = a2;
    v8 = (vm_page_size + 32 * v7 - 1) & -(uint64_t)vm_page_size;
    *(_QWORD *)(result + 32) = v8;
    result = vm_allocate(mach_task_self_, v6, v8, 1006632961);
    if ((_DWORD)result)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(result, v9, v10);
    v11 = v3[3];
    if (v3[2])
    {
      v12 = 0;
      v13 = 0;
      do
      {
        v14 = (_OWORD *)(v11 + v12);
        v15 = (_OWORD *)(*v3 + v12);
        v16 = v15[1];
        *v14 = *v15;
        v14[1] = v16;
        ++v13;
        v12 += 32;
      }
      while (v13 != v3[2]);
      v11 = *v6;
    }
    v17 = v3[4] >> 5;
    *v3 = v11;
    v3[1] = v17;
    if (v4)
      return vm_deallocate(mach_task_self_, v4, v5);
  }
  return result;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[](_QWORD *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = a1[2];
  v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5)
      dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::reserve((uint64_t)a1, a2 + 1);
    a1[2] = v5;
  }
  return *a1 + 32 * a2;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::verifySpace(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  vm_address_t v5;
  vm_size_t v6;
  vm_address_t *v7;
  unint64_t v8;
  vm_size_t v9;
  uint64_t v10;
  uint64_t v11;
  vm_address_t v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD *v15;
  _OWORD *v16;
  __int128 v17;
  uint64_t v18;

  v2 = *(_QWORD *)(result + 8);
  v3 = *(_QWORD *)(result + 16) + a2;
  if (v3 > v2)
  {
    v4 = (_QWORD *)result;
    v5 = *(_QWORD *)(result + 24);
    v6 = *(_QWORD *)(result + 32);
    v7 = (vm_address_t *)(result + 24);
    v8 = 2 * v2;
    if (v8 > v3)
      v3 = v8;
    v9 = (vm_page_size + 32 * v3 - 1) & -(uint64_t)vm_page_size;
    *(_QWORD *)(result + 32) = v9;
    result = vm_allocate(mach_task_self_, v7, v9, 1006632961);
    if ((_DWORD)result)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(result, v10, v11);
    v12 = v4[3];
    if (v4[2])
    {
      v13 = 0;
      v14 = 0;
      do
      {
        v15 = (_OWORD *)(v12 + v13);
        v16 = (_OWORD *)(*v4 + v13);
        v17 = v16[1];
        *v15 = *v16;
        v15[1] = v17;
        ++v14;
        v13 += 32;
      }
      while (v14 != v4[2]);
      v12 = *v7;
    }
    v18 = v4[4] >> 5;
    *v4 = v12;
    v4[1] = v18;
    if (v5)
      return vm_deallocate(mach_task_self_, v5, v6);
  }
  return result;
}

void dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage,4294967295ull>::verifySpace(vm_address_t *a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  vm_address_t v5;
  vm_size_t v6;
  vm_address_t *v7;
  unint64_t v8;
  vm_size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  vm_address_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;

  v2 = a1[1];
  v3 = a1[2] + a2;
  if (v3 > v2)
  {
    v5 = a1[3];
    v6 = a1[4];
    v7 = a1 + 3;
    v8 = 2 * v2;
    if (v8 > v3)
      v3 = v8;
    v9 = (vm_page_size + 568 * v3 - 1) & -(uint64_t)vm_page_size;
    a1[4] = v9;
    v10 = vm_allocate(mach_task_self_, v7, v9, 1006632961);
    if ((_DWORD)v10)
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v10, v11, v12);
    v13 = a1[3];
    if (a1[2])
    {
      v14 = 0;
      v15 = 0;
      do
      {
        dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage(v13 + v14, (__int128 *)(*a1 + v14));
        ++v15;
        v14 += 568;
      }
      while (v15 != a1[2]);
      v13 = *v7;
    }
    v16 = a1[4] / 0x238;
    *a1 = v13;
    a1[1] = v16;
    if (v5)
      vm_deallocate(mach_task_self_, v5, v6);
  }
}

__n128 dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __n128 result;

  v2 = *a2;
  v3 = a2[1];
  *(_QWORD *)(a1 + 32) = *((_QWORD *)a2 + 4);
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
  *(_OWORD *)(a1 + 48) = a2[3];
  v4 = *((_QWORD *)a2 + 9);
  *(_QWORD *)(a1 + 64) = *((_QWORD *)a2 + 8);
  *(_QWORD *)(a1 + 72) = v4;
  *((_QWORD *)a2 + 9) = 0;
  *(__int128 *)((char *)a2 + 56) = 0u;
  *(__int128 *)((char *)a2 + 40) = 0u;
  *(_QWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_QWORD *)(a1 + 80) = *((_QWORD *)a2 + 10);
  *(_OWORD *)(a1 + 88) = *(__int128 *)((char *)a2 + 88);
  v5 = *((_QWORD *)a2 + 14);
  *(_QWORD *)(a1 + 104) = *((_QWORD *)a2 + 13);
  *(_QWORD *)(a1 + 112) = v5;
  *((_QWORD *)a2 + 14) = 0;
  a2[5] = 0u;
  a2[6] = 0u;
  *(_QWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_QWORD *)(a1 + 120) = *((_QWORD *)a2 + 15);
  *(_OWORD *)(a1 + 128) = a2[8];
  v6 = *((_QWORD *)a2 + 19);
  *(_QWORD *)(a1 + 144) = *((_QWORD *)a2 + 18);
  *(_QWORD *)(a1 + 152) = v6;
  *((_QWORD *)a2 + 19) = 0;
  *(__int128 *)((char *)a2 + 136) = 0u;
  *(__int128 *)((char *)a2 + 120) = 0u;
  v7 = a2[10];
  *(_QWORD *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 160) = v7;
  *(_QWORD *)(a1 + 176) = *((_QWORD *)a2 + 22);
  *(_OWORD *)(a1 + 184) = *(__int128 *)((char *)a2 + 184);
  v8 = *((_QWORD *)a2 + 26);
  *(_QWORD *)(a1 + 200) = *((_QWORD *)a2 + 25);
  *(_QWORD *)(a1 + 208) = v8;
  *((_QWORD *)a2 + 26) = 0;
  a2[11] = 0u;
  a2[12] = 0u;
  *(_QWORD *)(a1 + 248) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_QWORD *)(a1 + 216) = *((_QWORD *)a2 + 27);
  *(_OWORD *)(a1 + 224) = a2[14];
  v9 = *((_QWORD *)a2 + 31);
  *(_QWORD *)(a1 + 240) = *((_QWORD *)a2 + 30);
  *(_QWORD *)(a1 + 248) = v9;
  *((_QWORD *)a2 + 31) = 0;
  *(__int128 *)((char *)a2 + 232) = 0u;
  *(__int128 *)((char *)a2 + 216) = 0u;
  v10 = a2[16];
  *(_QWORD *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 256) = v10;
  v11 = *((_QWORD *)a2 + 35);
  *(_QWORD *)(a1 + 272) = *((_QWORD *)a2 + 34);
  *(_QWORD *)(a1 + 280) = v11;
  *(_OWORD *)(a1 + 288) = a2[18];
  *(_QWORD *)(a1 + 304) = *((_QWORD *)a2 + 38);
  *((_QWORD *)a2 + 38) = 0;
  a2[17] = 0u;
  a2[18] = 0u;
  *(_QWORD *)(a1 + 344) = 0;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_QWORD *)(a1 + 312) = *((_QWORD *)a2 + 39);
  *(_OWORD *)(a1 + 320) = a2[20];
  v12 = *((_QWORD *)a2 + 43);
  *(_QWORD *)(a1 + 336) = *((_QWORD *)a2 + 42);
  *(_QWORD *)(a1 + 344) = v12;
  *((_QWORD *)a2 + 43) = 0;
  *(__int128 *)((char *)a2 + 328) = 0u;
  *(__int128 *)((char *)a2 + 312) = 0u;
  *(_QWORD *)(a1 + 384) = 0;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  v13 = *((_QWORD *)a2 + 45);
  *(_QWORD *)(a1 + 352) = *((_QWORD *)a2 + 44);
  *(_QWORD *)(a1 + 360) = v13;
  *(_OWORD *)(a1 + 368) = a2[23];
  *(_QWORD *)(a1 + 384) = *((_QWORD *)a2 + 48);
  *((_QWORD *)a2 + 48) = 0;
  a2[22] = 0u;
  a2[23] = 0u;
  v14 = *(__int128 *)((char *)a2 + 392);
  *(_QWORD *)(a1 + 440) = 0;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 392) = v14;
  *(_QWORD *)(a1 + 408) = *((_QWORD *)a2 + 51);
  *(_OWORD *)(a1 + 416) = a2[26];
  v15 = *((_QWORD *)a2 + 55);
  *(_QWORD *)(a1 + 432) = *((_QWORD *)a2 + 54);
  *(_QWORD *)(a1 + 440) = v15;
  *((_QWORD *)a2 + 55) = 0;
  *(__int128 *)((char *)a2 + 408) = 0u;
  *(__int128 *)((char *)a2 + 424) = 0u;
  *(_QWORD *)(a1 + 480) = 0;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  v16 = *((_QWORD *)a2 + 57);
  *(_QWORD *)(a1 + 448) = *((_QWORD *)a2 + 56);
  *(_QWORD *)(a1 + 456) = v16;
  *(_OWORD *)(a1 + 464) = a2[29];
  *(_QWORD *)(a1 + 480) = *((_QWORD *)a2 + 60);
  *((_QWORD *)a2 + 60) = 0;
  a2[28] = 0u;
  a2[29] = 0u;
  v17 = *(__int128 *)((char *)a2 + 552);
  v19 = *(__int128 *)((char *)a2 + 504);
  v18 = *(__int128 *)((char *)a2 + 520);
  *(_OWORD *)(a1 + 536) = *(__int128 *)((char *)a2 + 536);
  *(_OWORD *)(a1 + 552) = v17;
  *(_OWORD *)(a1 + 504) = v19;
  *(_OWORD *)(a1 + 520) = v18;
  result = *(__n128 *)((char *)a2 + 488);
  *(__n128 *)(a1 + 488) = result;
  return result;
}

void OUTLINED_FUNCTION_4_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 785, a4);
}

uint64_t dyld3::kdebug_trace_dyld_image(dyld3 *this, void *a2, void **a3, unsigned __int8 (*a4)[16], fsobj_id a5, fsid a6, const void *a7, uint64_t a8, const void *a9)
{
  int v12;
  fsobj_id v13;

  v12 = (int)a7;
  v13 = a5;
  return dyld3::kdebug_trace_dyld_region(this, 16777228, v12, a2, a3, a4, v13, a6, a9);
}

uint64_t dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges(dyld4::ExternallyViewableState *this, uint64_t a2, uint64_t a3, const mach_header **a4, const char **a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE v17[56];
  int v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v18 = 520552496;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v18, a2, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v17, *(_DWORD *)(*((_QWORD *)this + 3) + 200));
  if (dyld4::RemoteNotificationResponder::active((dyld4::RemoteNotificationResponder *)v17))
  {
    v15 = atomic_load((unint64_t *)(*((_QWORD *)this + 3) + 184));
    dyld4::RemoteNotificationResponder::notifyMonitorOfImageListChanges((dyld4::RemoteNotificationResponder *)v17, a2, a3, a4, a5, v15, v13, v14);
  }
  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v17);
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v18);
}

uint64_t dyld4::ExternallyViewableState::removeImagesOld(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  size_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;

  v5 = (_QWORD *)result;
  atomic_store(0, (unint64_t *)(*(_QWORD *)(result + 24) + 8));
  v6 = *(_QWORD *)(result + 24);
  *(_QWORD *)(v6 + 96) = 0;
  v7 = *(_QWORD *)(a4 + 8);
  if (v7)
  {
    v32 = a5;
    v10 = *(uint64_t **)a4;
    v11 = *(_QWORD *)a4 + 8 * v7;
    do
    {
      v12 = *v10;
      v35 = *v10;
      v13 = v5[4];
      v14 = *(_QWORD *)(v13 + 16);
      if (v14)
      {
        v15 = *(_QWORD *)(v13 + 8) + 24;
        v16 = 24 * v14;
        v17 = (_QWORD *)v15;
        while (*(v17 - 3) != v12)
        {
          v17 += 3;
          v15 += 24;
          v16 -= 24;
          if (!v16)
            goto LABEL_11;
        }
        dyld3::Array<dyld4::Loader const*>::push_back(a2, v17 - 2, (uint64_t)a3);
        dyld3::Array<dyld4::Loader const*>::push_back(a3, &v35, v18);
        v19 = *(_OWORD *)(v17 - 3);
        v34 = *(v17 - 1);
        v33 = v19;
        v20 = v5[4];
        v21 = *(_QWORD *)(v20 + 16);
        v22 = *(_QWORD *)(v20 + 8) + 24 * v21;
        if (v17 != (_QWORD *)v22)
        {
          memmove(v17 - 3, v17, v22 - v15);
          v21 = *(_QWORD *)(v20 + 16);
        }
        *(_QWORD *)(v20 + 16) = v21 - 1;
      }
LABEL_11:
      v23 = v5[5];
      v24 = *(_QWORD *)(v23 + 16);
      if (v24)
      {
        v25 = *(_QWORD **)(v23 + 8);
        v26 = 24 * v24 - 24;
        v27 = v25;
        while (1)
        {
          v28 = *v27;
          v27 += 3;
          if (v28 == v35)
            break;
          v26 -= 24;
          v25 = v27;
          if (v26 == -24)
            goto LABEL_19;
        }
        if (v26)
        {
          memmove(v25, v25 + 3, v26);
          v24 = *(_QWORD *)(v23 + 16);
        }
        *(_QWORD *)(v23 + 16) = v24 - 1;
      }
LABEL_19:
      result = (*(uint64_t (**)(uint64_t, uint64_t, __int128 *))(v5[3] + 16))(1, 1, &v33);
      ++v10;
    }
    while (v10 != (uint64_t *)v11);
    v6 = v5[3];
    a5 = v32;
  }
  v29 = v5[4];
  *(_DWORD *)(v6 + 4) = *(_QWORD *)(v29 + 16);
  atomic_store(*(_QWORD *)(v29 + 8), (unint64_t *)(v6 + 8));
  atomic_store(a5, (unint64_t *)(v5[3] + 184));
  v30 = v5[5];
  v31 = v5[3];
  *(_QWORD *)(v31 + 88) = *(_QWORD *)(v30 + 16);
  *(_QWORD *)(v31 + 96) = *(_QWORD *)(v30 + 8);
  return result;
}

void dyld4::ExternallyViewableState::removeImages(uint64_t a1, lsl::Allocator *a2, lsl::Allocator *a3, uint64_t **a4)
{
  os_unfair_lock_s *v8;
  uint64_t v9;
  lsl::Allocator *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  const os_unfair_lock *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char **v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const mach_header **v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v40;
  const mach_header **v41[2];
  uint64_t v42;
  const char **v43[2];
  uint64_t v44;

  v8 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  dyld4::ExternallyViewableState::ensureSnapshot((uint64_t *)a1, a3);
  v11 = a4[1];
  if (v11)
  {
    v12 = *a4;
    v13 = 8 * (_QWORD)v11;
    do
    {
      v14 = *v12++;
      dyld4::Atlas::ProcessSnapshot::removeImageAtAddress(*(dyld4::Atlas::ProcessSnapshot **)a1, v14, v9);
      v13 -= 8;
    }
    while (v13);
  }
  dyld4::ExternallyViewableState::commit((const os_unfair_lock *)a1, *(dyld4::Atlas::ProcessSnapshot **)a1, a2, v10);
  v15 = dyld4::ExternallyViewableState::release((const os_unfair_lock *)a1, a3);
  __chkstk_darwin((uint64_t)v15, v16, v17, v18, v19, v20, v21, v22, v40);
  v43[0] = (const char **)((char *)&v41[-1] - ((v23 + 23) & 0xFFFFFFFFFFFFFFF0));
  v43[1] = v24;
  v44 = 0;
  __chkstk_darwin(v25, v26, v27, v28, v29, v30, v31, v32, v40);
  v41[0] = (const mach_header **)((char *)&v41[-1] - v34);
  v41[1] = v33;
  v42 = 0;
  v35 = mach_absolute_time();
  dyld4::ExternallyViewableState::removeImagesOld(a1, (uint64_t *)v43, (uint64_t *)v41, (uint64_t)a4, v35);
  if (*(_DWORD *)(*(_QWORD *)(a1 + 24) + 200) == 1229016646 && v42 != 0)
  {
    if (!v44)
      dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>();
    dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges((dyld4::ExternallyViewableState *)a1, 1, *((unsigned int *)a4 + 2), v41[0], v43[0], v36, v37, v38);
  }
  os_unfair_lock_unlock(v8);
}

uint64_t dyld4::ExternallyViewableState::disableCrashReportBacktrace(uint64_t this)
{
  *(_QWORD *)(*(_QWORD *)(this + 24) + 64) = 1;
  return this;
}

uint64_t dyld4::ExternallyViewableState::fork_child(uint64_t this)
{
  uint64_t v1;

  v1 = *(_QWORD *)(this + 24);
  *(_QWORD *)(v1 + 72) = 0;
  *(_QWORD *)(v1 + 80) = 0;
  return this;
}

uint64_t dyld4::ExternallyViewableState::notifyMonitorOfMainCalled(dyld4::ExternallyViewableState *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  _BYTE v10[56];
  int v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  v11 = 520552496;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v11, a2, a3, a4, a5, a6, a7, a8);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v10, *(_DWORD *)(*((_QWORD *)this + 3) + 200));
  if (dyld4::RemoteNotificationResponder::active((dyld4::RemoteNotificationResponder *)v10))
    dyld4::RemoteNotificationResponder::notifyMonitorOfMainCalled((dyld4::RemoteNotificationResponder *)v10);
  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v10);
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v11);
}

uint64_t dyld4::ExternallyViewableState::notifyMonitorOfDyldBeforeInitializers(dyld4::ExternallyViewableState *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  _BYTE v10[56];
  int v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  v11 = 520552496;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v11, a2, a3, a4, a5, a6, a7, a8);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v10, *(_DWORD *)(*((_QWORD *)this + 3) + 200));
  if (dyld4::RemoteNotificationResponder::active((dyld4::RemoteNotificationResponder *)v10))
    dyld4::RemoteNotificationResponder::notifyMonitorOfDyldBeforeInitializers((dyld4::RemoteNotificationResponder *)v10);
  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v10);
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v11);
}

uint64_t dyld4::ExternallyViewableState::switchDyldLoadAddress(uint64_t this, const dyld3::MachOFile *a2)
{
  *((_QWORD *)sProcessInfo + 4) = this;
  return this;
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
  dyld4::halt((char *)__format, 0);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  _simple_vdprintf(2, (char *)a2, (int *)va);
  return 0;
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return write(2, __ptr, __nitems * __size);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  va_list va;

  va_start(va, __format);
  return vsnprintf(__str, __size, __format, va);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  size_t v4;
  errno_t v5;

  if (!__s)
    return 22;
  if (__n >= __smax)
    v4 = __smax;
  else
    v4 = __n;
  if (__n <= __smax)
    v5 = 0;
  else
    v5 = 84;
  _platform_memset(__s, __c, v4);
  return v5;
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  if (!__n)
    return 0;
  while (*__s != __c)
  {
    ++__s;
    if (!--__n)
      return 0;
  }
  return __s;
}

uint64_t mach_o::DebugNoteFileInfo::dump(const char **this)
{
  const char *v2;
  const char *v3;

  fprintf(__stdoutp, "scrDir:      %s\n", this[1]);
  fprintf(__stdoutp, "scrName:     %s\n", this[3]);
  fprintf(__stdoutp, "objPath:     %s\n", this[5]);
  fprintf(__stdoutp, "objModTime:  0x%08X\n", *(_DWORD *)this);
  fprintf(__stdoutp, "objSubType:  0X%02X\n", *((unsigned __int8 *)this + 4));
  if (this[8])
    v2 = this[7];
  else
    v2 = "N/A";
  fprintf(__stdoutp, "libPath:     %s\n", v2);
  if (this[10])
    v3 = this[9];
  else
    v3 = "N/A";
  return fprintf(__stdoutp, "origlibPath: %s\n", v3);
}

_QWORD *lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&,lsl::Vector<dyld4::Atlas::Mapper::Mapping> &>@<X0>(lsl::Allocator *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  lsl::Allocator::AllocationMetadata *v7;
  _QWORD *v8;

  v7 = (lsl::Allocator::AllocationMetadata *)lsl::Allocator::aligned_alloc(a1, 8uLL, 0x30uLL);
  v8 = lsl::Vector<dyld4::Atlas::Mapper::Mapping>::Vector(v7, a3, a2);
  v8[4] = 0;
  v8[5] = a2;
  return lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(a4, v7);
}

void dyld4::Atlas::Mapper::mapperForMachO(dyld4::Atlas::Mapper *this@<X0>, lsl::Allocator *a2@<X1>, dyld4::FileRecord *a3@<X2>, const UUID *a4@<X3>, _QWORD *a5@<X8>)
{
  dyld3 *Path;
  int v11;
  int v12;
  _DWORD *v13;
  const void *v14;
  _DWORD *v15;
  dyld3::FatFile *v16;
  const void *v17;
  _QWORD *v18;
  dyld3::FatFile *v19;
  off_t st_size;
  unint64_t v21;
  dyld3::MachOFile *v22;
  dyld3::MachOFile *v23;
  uint64_t v24;
  int v25;
  int v26;
  _DWORD *v28;
  _QWORD v29[8];
  int v30;
  _QWORD v31[8];
  _QWORD v32[4];
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  stat v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  uint64_t *(*v43)(uint64_t, uint64_t);
  const os_unfair_lock *(*v44)(const os_unfair_lock *);
  dyld4::Atlas::Mapper *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  Path = (dyld3 *)dyld4::FileRecord::getPath(a2);
  v11 = dyld3::open(Path, 0, 0);
  if (v11 == -1)
    goto LABEL_20;
  v12 = v11;
  if (fstat64(v11, &v37) == -1 || (v13 = mmap(0, v37.st_size, 1, 8194, v12, 0), v13 == (_DWORD *)-1))
  {
    v11 = v12;
LABEL_20:
    close(v11);
    *a5 = 0;
    return;
  }
  v15 = v13;
  v33 = 0;
  v34 = &v33;
  v35 = 0x2000000000;
  v36 = 0;
  v16 = (dyld3::FatFile *)dyld3::FatFile::isFatFile(v13, v14);
  v32[0] = 0;
  v32[1] = v32;
  v32[2] = 0x2000000000;
  v32[3] = 0;
  v18 = (_QWORD *)&loc_1A5CBA000;
  if (v16)
  {
    v19 = v16;
    st_size = v37.st_size;
    Diagnostics::Diagnostics((Diagnostics *)&v41);
    v31[0] = _NSConcreteStackBlock;
    v31[1] = 0x40000000;
    v31[2] = ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke;
    v31[3] = &unk_1E4F7E3A8;
    v31[4] = &v33;
    v31[5] = v32;
    v31[6] = a3;
    v31[7] = v19;
    v21 = st_size;
    v18 = &loc_1A5CBA000;
    dyld3::FatFile::forEachSlice(v19, (vm_address_t *)&v41, v21, (uint64_t)v31);
    Diagnostics::clearError((vm_address_t **)&v41);
    mach_o::Error::~Error((vm_address_t **)&v41);
  }
  if (!v34[3])
  {
    v22 = (dyld3::MachOFile *)dyld3::MachOFile::isMachO(v15, v17);
    if (v22)
    {
      v23 = v22;
      v41 = 0uLL;
      dyld3::MachOFile::getUuid(v22, (unsigned __int8 *)&v41);
      v24 = 0;
      v38 = v41;
      do
      {
        v25 = *((unsigned __int8 *)a3 + v24);
        v26 = *((unsigned __int8 *)&v38 + v24);
      }
      while (v25 == v26 && v24++ != 15);
      if (v25 == v26)
        v34[3] = (uint64_t)v23;
    }
  }
  v28 = (_DWORD *)v34[3];
  if (v28)
  {
    *(_QWORD *)&v41 = 0;
    *((_QWORD *)&v41 + 1) = &v41;
    v42 = 0x4802000000;
    v43 = __Block_byref_object_copy__9;
    v44 = __Block_byref_object_dispose__9;
    v45 = this;
    v46 = 0;
    v47 = 0;
    v48 = 0;
    *(_QWORD *)&v38 = 0;
    *((_QWORD *)&v38 + 1) = &v38;
    v39 = 0x2000000000;
    v40 = 0;
    v29[0] = _NSConcreteStackBlock;
    v29[1] = v18[389];
    v29[2] = ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke_3;
    v29[3] = &unk_1E4F7E3D0;
    v29[4] = &v38;
    v29[5] = &v41;
    v29[6] = v32;
    v29[7] = a4;
    v30 = v12;
    dyld3::MachOFile::forEachSegment(v28, (uint64_t)v29);
    munmap(v15, v37.st_size);
    lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&,lsl::Vector<dyld4::Atlas::Mapper::Mapping> &>(this, (uint64_t)this, *((_QWORD *)&v41 + 1) + 40, a5);
    _Block_object_dispose(&v38, 8);
    _Block_object_dispose(&v41, 8);
    if (v46)
      lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize((const os_unfair_lock *)&v45, 0);
  }
  else
  {
    munmap(v15, v37.st_size);
    close(v12);
    *a5 = 0;
  }
  _Block_object_dispose(v32, 8);
  _Block_object_dispose(&v33, 8);
}

BOOL ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke(_QWORD *a1, int a2, int a3, dyld3::MachOFile *this, uint64_t a5, _BYTE *a6)
{
  _BOOL8 result;
  uint64_t v10;
  int v11;
  int v12;
  __int128 v14;
  unsigned __int8 v15[16];

  memset(v15, 0, sizeof(v15));
  result = dyld3::MachOFile::getUuid(this, v15);
  v10 = 0;
  v14 = *(_OWORD *)v15;
  do
  {
    v11 = *(unsigned __int8 *)(a1[6] + v10);
    v12 = v15[v10 - 8];
  }
  while (v11 == v12 && v10++ != 15);
  if (v11 == v12)
  {
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = this;
    *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = (char *)this - a1[7];
    *a6 = 1;
  }
  return result;
}

uint64_t *__Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = (uint64_t *)(a2 + 40);
  *(_OWORD *)(a1 + 40) = 0u;
  result = (uint64_t *)(a1 + 40);
  *((_OWORD *)result + 1) = 0u;
  if (result != v2)
  {
    v4 = *result;
    *result = *v2;
    *v2 = v4;
    v6 = result[1];
    v5 = result[2];
    v7 = v2[2];
    result[1] = v2[1];
    result[2] = v7;
    v2[2] = v5;
    v8 = result[3];
    result[3] = v2[3];
    v2[3] = v8;
    v2[1] = v6;
  }
  return result;
}

const os_unfair_lock *__Block_byref_object_dispose__9(const os_unfair_lock *result)
{
  if (*(_QWORD *)&result[12]._os_unfair_lock_opaque)
    return lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize(result + 10, 0);
  return result;
}

uint64_t ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t result;
  uint64_t v10;

  if (!_platform_strncmp(*(const char **)(a2 + 40), "__TEXT", 0x10uLL))
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a1 + 56) - *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) + *(_QWORD *)a2;
  v6 = *(_QWORD *)(a2 + 24);
  v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + *(_QWORD *)(a2 + 16);
  v8 = *(_DWORD *)(a1 + 64);
  result = lsl::Vector<dyld4::ObjCClassReplacement>::reserve(v4 + 40, *(_QWORD *)(v4 + 56) + 1);
  v10 = *(_QWORD *)(v4 + 48) + 32 * *(_QWORD *)(v4 + 56);
  *(_QWORD *)v10 = v5;
  *(_QWORD *)(v10 + 8) = v6;
  *(_QWORD *)(v10 + 16) = v7;
  *(_DWORD *)(v10 + 24) = v8;
  ++*(_QWORD *)(v4 + 56);
  return result;
}

uint64_t dyld4::Atlas::Mapper::unmap(dyld4::Atlas::Mapper *this, unint64_t a2, uint64_t a3)
{
  return munmap((void *)(-(uint64_t)vm_page_size & a2), a2 + a3 - (-(uint64_t)vm_page_size & a2));
}

void dyld4::Atlas::Image::~Image(dyld4::Atlas::Image *this)
{
  void *v2;
  os_unfair_lock *v3;

  dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)this + 112);
  v3 = (os_unfair_lock *)*((_QWORD *)this + 11);
  if (v3)
    lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v3, v2);
  dyld4::FileRecord::~FileRecord((dyld4::Atlas::Image *)((char *)this + 8));
}

_QWORD *lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&>@<X0>(lsl::Allocator *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v5;

  v5 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0x30uLL);
  *v5 = a2;
  *(_OWORD *)(v5 + 1) = 0u;
  *(_OWORD *)(v5 + 3) = 0u;
  v5[5] = a2;
  return lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(a3, (lsl::Allocator::AllocationMetadata *)v5);
}

double dyld4::Atlas::ProcessSnapshot::removeImageAtAddress(dyld4::Atlas::ProcessSnapshot *this, uint64_t a2, uint64_t a3)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double result;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  __int16 v21;
  unsigned __int8 v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[24];
  __int16 v29;
  unsigned __int8 v30;
  char *v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  _QWORD v36[4];

  v4 = (char *)this + 16;
  v31 = (char *)this + 16;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v35 = 0u;
  memset(v36, 0, 27);
  v5 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)&v31, a2, a3);
  v6 = *(_QWORD *)v5;
  v15 = *(_OWORD *)(v5 + 8);
  v7 = *(_OWORD *)(v5 + 72);
  v8 = *(_OWORD *)(v5 + 56);
  v9 = *(_OWORD *)(v5 + 40);
  v16 = *(_OWORD *)(v5 + 24);
  v17 = v9;
  v18 = v8;
  v19 = v7;
  v10 = *(_QWORD *)(v5 + 88);
  v21 = *(_WORD *)(v5 + 96);
  v20 = v10;
  LOBYTE(v10) = *(_BYTE *)(v5 + 98);
  v14 = v6;
  v22 = v10;
  *(_OWORD *)&v28[2] = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v35 = 0u;
  memset(v36, 0, 27);
  v31 = v4;
  if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&v14, (uint64_t)&v31))
  {
    while (*(_QWORD *)(*(_QWORD *)(*((_QWORD *)&v15 + v22 - 1) + 8 * *((unsigned __int8 *)&v20 + v22 - 1)) + 160) != a2)
    {
      lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)&v14, v11, v12);
      *(_OWORD *)&v28[2] = 0u;
      v31 = v4;
      v32 = 0u;
      v33 = 0u;
      v34 = 0u;
      v35 = 0u;
      memset(v36, 0, 27);
      if (!lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&v14, (uint64_t)&v31))return result;
    }
    v25 = v16;
    v26 = v17;
    v27 = v18;
    *(_OWORD *)v28 = v19;
    v24 = v15;
    *(_QWORD *)&v28[16] = v20;
    v29 = v21;
    v23 = v14;
    v30 = v22;
    *(_QWORD *)&result = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::erase((uint64_t)v4, (uint64_t)&v23, v12, (uint64_t)&v31).n128_u64[0];
  }
  return result;
}

uint64_t *std::optional<unsigned long long>::swap[abi:nn180100](uint64_t *result, uint64_t *a2)
{
  uint64_t v2;

  if ((*((_BYTE *)result + 8) != 0) != (*((_BYTE *)a2 + 8) != 0))
  {
    if (*((_BYTE *)result + 8))
    {
      *a2 = *result;
      *((_BYTE *)a2 + 8) = 1;
      if (*((_BYTE *)result + 8))
        *((_BYTE *)result + 8) = 0;
    }
    else
    {
      *result = *a2;
      *((_BYTE *)result + 8) = 1;
      if (*((_BYTE *)a2 + 8))
        *((_BYTE *)a2 + 8) = 0;
    }
  }
  else if (*((_BYTE *)result + 8))
  {
    v2 = *result;
    *result = *a2;
    *a2 = v2;
  }
  return result;
}

_QWORD *std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char const*,std::__identity,lsl::ConstCharStarCompare>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  int v6;
  char *v7;
  char *v8;
  int v9;
  int v10;
  int v11;

  if (a2 != a1)
  {
    v3 = a2 - a1;
    a2 = a1;
    do
    {
      v4 = v3 >> 1;
      v5 = &a2[v3 >> 1];
      v6 = *(char *)*v5;
      if (v6 < *(char *)*a3)
      {
LABEL_9:
        a2 = v5 + 1;
        v4 = v3 + ~v4;
      }
      else
      {
        v7 = (char *)(*v5 + 1);
        v8 = (char *)(*a3 + 1);
        v9 = *(unsigned __int8 *)*a3;
        while (v9 && (char)v9 >= (char)v6)
        {
          if ((_BYTE)v6)
          {
            v10 = *v7++;
            v6 = v10;
            v11 = *v8++;
            v9 = v11;
            if (v6 >= v11)
              continue;
          }
          goto LABEL_9;
        }
      }
      v3 = v4;
    }
    while (v4);
  }
  return a2;
}

_QWORD *std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char [4],std::__identity,lsl::ConstCharStarCompare>(_QWORD *a1, _QWORD *a2, unsigned __int8 *a3)
{
  unint64_t v3;
  unsigned __int8 *v4;
  int v5;
  int v6;
  unint64_t v7;
  _QWORD *v8;
  int v9;
  char *v10;
  unsigned __int8 *v11;
  int v12;
  int v13;
  int v14;

  if (a2 != a1)
  {
    v3 = a2 - a1;
    v6 = *a3;
    v4 = a3 + 1;
    v5 = v6;
    a2 = a1;
    do
    {
      v7 = v3 >> 1;
      v8 = &a2[v3 >> 1];
      v9 = *(char *)*v8;
      if (v9 < (char)v5)
      {
LABEL_9:
        a2 = v8 + 1;
        v7 = v3 + ~v7;
      }
      else
      {
        v10 = (char *)(*v8 + 1);
        v11 = v4;
        v12 = v5;
        while (v12 && (char)v12 >= (char)v9)
        {
          if ((_BYTE)v9)
          {
            v13 = *v10++;
            v9 = v13;
            v14 = (char)*v11++;
            v12 = v14;
            if (v9 >= v14)
              continue;
          }
          goto LABEL_9;
        }
      }
      v3 = v7;
    }
    while (v7);
  }
  return a2;
}

char *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<unsigned char *,unsigned char *,std::back_insert_iterator<lsl::Vector<char>>>(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  char *v5;
  char v7;
  uint64_t v8;
  uint64_t v9;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      v7 = *v5++;
      lsl::Vector<std::byte>::reserve(a4, *(_QWORD *)(a4 + 16) + 1);
      v8 = *(_QWORD *)(a4 + 8);
      v9 = *(_QWORD *)(a4 + 16);
      *(_QWORD *)(a4 + 16) = v9 + 1;
      *(_BYTE *)(v8 + v9) = v7;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

const os_unfair_lock *lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize(const os_unfair_lock *result, unint64_t a2)
{
  _QWORD *v2;
  const os_unfair_lock *v3;

  if (*(_QWORD *)&result[6]._os_unfair_lock_opaque < a2)
    return (const os_unfair_lock *)lsl::Vector<dyld4::ObjCClassReplacement>::reserve((uint64_t)result, a2);
  if (a2)
  {
    *(_QWORD *)&result[4]._os_unfair_lock_opaque = a2;
    *(_QWORD *)&result[6]._os_unfair_lock_opaque = a2;
    return (const os_unfair_lock *)lsl::Allocator::realloc(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, *(_QWORD **)&result[2]._os_unfair_lock_opaque, 32 * a2);
  }
  else
  {
    v3 = result + 2;
    v2 = *(_QWORD **)&result[2]._os_unfair_lock_opaque;
    if (v2)
      result = lsl::Allocator::free(*(lsl::Allocator **)&result->_os_unfair_lock_opaque, v2);
    *(_QWORD *)&v3->_os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[2]._os_unfair_lock_opaque = 0;
    *(_QWORD *)&v3[4]._os_unfair_lock_opaque = 0;
  }
  return result;
}

_QWORD *lsl::Vector<dyld4::Atlas::Mapper::Mapping>::Vector(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  void **v5;
  uint64_t v6;

  *a1 = a3;
  a1[1] = 0;
  v5 = (void **)(a1 + 1);
  a1[2] = 0;
  a1[3] = 0;
  lsl::Vector<dyld4::ObjCClassReplacement>::reserve((uint64_t)a1, *(_QWORD *)(a2 + 16));
  a1[2] = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(a2 + 16);
  if (v6)
    memmove(*v5, *(const void **)(a2 + 8), 32 * v6);
  return a1;
}

_QWORD *std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<char const**>,std::__wrap_iter<char const**>,char const*,std::__identity,lsl::ConstCharStarCompare>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  int v6;
  char *v7;
  char *v8;
  int v9;
  int v10;
  int v11;

  if (a2 != result)
  {
    v3 = a2 - result;
    do
    {
      v4 = v3 >> 1;
      v5 = &result[v3 >> 1];
      v6 = *(char *)*v5;
      if (v6 < *(char *)*a3)
      {
LABEL_9:
        result = v5 + 1;
        v4 = v3 + ~v4;
      }
      else
      {
        v7 = (char *)(*v5 + 1);
        v8 = (char *)(*a3 + 1);
        v9 = *(unsigned __int8 *)*a3;
        while (v9 && (char)v9 >= (char)v6)
        {
          if ((_BYTE)v6)
          {
            v10 = *v7++;
            v6 = v10;
            v11 = *v8++;
            v9 = v11;
            if (v6 >= v11)
              continue;
          }
          goto LABEL_9;
        }
      }
      v3 = v4;
    }
    while (v4);
  }
  return result;
}

__n128 lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::erase@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  int v8;
  unsigned int v9;
  const os_unfair_lock **v10;
  const os_unfair_lock **v11;
  const os_unfair_lock *v12;
  const os_unfair_lock *v13;
  const os_unfair_lock *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __n128 result;
  const os_unfair_lock *v23;

  v7 = *(unsigned __int8 *)(a2 + 98);
  v8 = *(unsigned __int8 *)(a1 + 32);
  v9 = v7;
  if ((_DWORD)v7 != v8)
  {
    v10 = (const os_unfair_lock **)(*(_QWORD *)(a2 + 8 + 8 * (v7 - 1)) + 8 * *(unsigned __int8 *)(a2 + 88 + v7 - 1));
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++(a2, a2, a3);
    v11 = (const os_unfair_lock **)(*(_QWORD *)(a2 + 8 + 8 * (*(unsigned __int8 *)(a2 + 98) - 1))
                                  + 8 * *(unsigned __int8 *)(a2 + 88 + *(unsigned __int8 *)(a2 + 98) - 1));
    v23 = 0;
    if (&v23 == v10)
    {
      v12 = 0;
    }
    else
    {
      v12 = *v10;
      v23 = *v10;
      *v10 = 0;
    }
    if (v11 != v10)
    {
      v13 = *v10;
      *v10 = *v11;
      *v11 = v13;
    }
    if (&v23 != v11)
    {
      v14 = *v11;
      *v11 = v12;
      v23 = v14;
    }
    lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(&v23);
    v9 = *(unsigned __int8 *)(a2 + 98);
  }
  v15 = v9 - 1;
  v16 = *(_QWORD *)(a2 + 8 + 8 * v15);
  if ((*(char *)(v16 + 248) & 0x80000000) == 0)
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::erase();
  lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase(v16, *(unsigned __int8 *)(a2 + 88 + v15));
  lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure((unsigned __int8 *)a2, v17);
  if ((_DWORD)v7 != v8)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--(a2, v18, v19);
  --*(_QWORD *)(a1 + 24);
  v20 = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
  v21 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a4 + 56) = v21;
  result = *(__n128 *)(a2 + 72);
  *(__n128 *)(a4 + 72) = result;
  *(_QWORD *)a4 = *(_QWORD *)a2;
  *(_OWORD *)(a4 + 8) = v20;
  *(_QWORD *)(a4 + 88) = *(_QWORD *)(a2 + 88);
  *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
  *(_BYTE *)(a4 + 98) = *(_BYTE *)(a2 + 98);
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase(uint64_t result, unsigned int a2)
{
  int v2;
  uint64_t v3;
  uint64_t *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *(char *)(result + 248);
  if ((v2 & 0x80000000) == 0)
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase();
  v3 = v2 & 0x7F;
  if (v3 <= a2)
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase();
  v4 = (uint64_t *)(result + 8 * a2);
  v5 = v4 + 1;
  if (v4 + 1 != (uint64_t *)(result + 8 * (v2 & 0x7F)))
  {
    v6 = *v4;
    v7 = 8 * v3 - 8 * a2 - 8;
    do
    {
      *(v5 - 1) = *v5;
      *v5++ = v6;
      v7 -= 8;
    }
    while (v7);
  }
  *(_BYTE *)(result + 248) = v2 - 1;
  return result;
}

unsigned __int8 *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure(unsigned __int8 *__dst, uint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  char *v12;
  int v13;
  int v14;
  int v15;
  char v16;
  char v17;
  char v18;
  int v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  unsigned __int8 v26;
  char *v27;
  uint64_t v28;
  unsigned __int8 *v29;
  _QWORD *v30;
  uint64_t v31;

  v2 = __dst[98];
  v3 = *(_QWORD *)__dst;
  if (v2 != *(unsigned __int8 *)(*(_QWORD *)__dst + 32))
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure();
  v4 = __dst;
  if (v2 >= 2)
  {
    v5 = 0;
    v6 = __dst + 8;
    v7 = __dst + 88;
    do
    {
      v8 = (v2 - v5 - 2);
      v9 = v8 + 1;
      if (*(char *)(*(_QWORD *)&v6[8 * v8 + 8] + 248) >= 0)
        v10 = 7;
      else
        v10 = 15;
      if ((*(_BYTE *)(*(_QWORD *)&v6[8 * v8 + 8] + 248) & 0x7Fu) >= v10)
        break;
      v11 = v7[v8];
      v12 = *(char **)&v6[8 * v8];
      v13 = v12[248];
      if ((_DWORD)v11 == (v13 & 0x7F))
      {
        v14 = 0;
        if (v7[v8])
          goto LABEL_10;
      }
      else
      {
        if (v13 < 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)v12, a2, v11);
        if (*(char *)(*(_QWORD *)&v12[8 * v11 + 128] + 248) >= 0)
          v19 = -7;
        else
          v19 = -15;
        v14 = v19 + (*(_BYTE *)(*(_QWORD *)&v12[8 * v11 + 128] + 248) & 0x7F);
        if (v7[v8])
        {
LABEL_10:
          if (v13 < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)v12, a2, v11);
          v15 = *(char *)(*(_QWORD *)&v12[8 * v11 + 112] + 248);
          v16 = v15 & 0x7F;
          if (v15 >= 0)
            v17 = -7;
          else
            v17 = -15;
          v18 = v17 + v16;
          goto LABEL_21;
        }
      }
      v18 = 0;
LABEL_21:
      if (v14 < 1 || v14 < v18)
      {
        if (v18 < 1 || v14 >= v18)
        {
          if ((_DWORD)v11 == (v13 & 0x7F))
          {
            if (v13 < 0)
              lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)v12, a2, v11);
            v7[v8] = v11 - 1;
            v7[v9] += (*(_BYTE *)(*(_QWORD *)&v12[8 * (v11 - 1) + 120] + 248) & 0x7F) + 1;
            __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge(*(char **)&v6[8 * v8], *(lsl::Allocator **)(v3 + 8), (v11 - 1));
            v24 = *(_QWORD *)&v6[8 * v8];
            if (*(char *)(v24 + 248) < 0)
              lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)__dst, a2, v23);
            *(_QWORD *)&v6[8 * v9] = *(_QWORD *)(v24 + 8 * v7[v8] + 120);
          }
          else
          {
            __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge(v12, *(lsl::Allocator **)(v3 + 8), v11);
          }
        }
        else
        {
          if (v13 < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)v12, a2, v11);
          v20 = *(_BYTE *)(*(_QWORD *)&v12[8 * v11 + 120] + 248);
          __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromLeft(v12, v7[v8], v11);
          v22 = *(_QWORD *)&v6[8 * v8];
          if (*(char *)(v22 + 248) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)__dst, a2, v21);
          v7[v9] += (*(_BYTE *)(*(_QWORD *)(v22 + 8 * v7[v8] + 120) + 248) & 0x7F) - (v20 & 0x7F);
        }
      }
      else
      {
        __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromRight(v12, v7[v8], v11);
      }
      ++v5;
      v3 = *(_QWORD *)v4;
      v2 = *(unsigned __int8 *)(*(_QWORD *)v4 + 32);
    }
    while ((int)(v2 - 1) > v5);
  }
  v25 = v4 + 8;
  if ((*(_BYTE *)(*((_QWORD *)v4 + 1) + 248) & 0x7F) != 0)
  {
    v26 = *(_BYTE *)(v3 + 32);
  }
  else
  {
    v27 = (char *)(v4 + 88);
    if (v4[88])
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure();
    v28 = v4[98];
    if (&v27[v28] != (char *)(v4 + 89))
    {
      memmove(v27, v4 + 89, v28 - 1);
      v28 = v4[98];
    }
    v29 = (unsigned __int8 *)&v25[v28];
    if (v29 != v4 + 16)
    {
      memmove(v4 + 8, v4 + 16, v29 - (v4 + 16));
      LOBYTE(v28) = v4[98];
    }
    v4[98] = v28 - 1;
    __dst = (unsigned __int8 *)lsl::Allocator::free(*(lsl::Allocator **)(v3 + 8), *(_QWORD **)v3);
    v30 = *(_QWORD **)v4;
    v26 = *(_BYTE *)(*(_QWORD *)v4 + 32) - 1;
    *(_BYTE *)(*(_QWORD *)v4 + 32) = v26;
    if (v4[98])
      *v30 = *v25;
    else
      *v30 = 0;
  }
  if (v26)
  {
    v31 = 0;
    do
    {
      if ((*(_BYTE *)(v25[(v26 + ~(_BYTE)v31)] + 248) & 0x7F) != v4[(v26 + ~(_BYTE)v31)
                                                                                      + 88])
        break;
      --v4[98];
      ++v31;
    }
    while (v26 != v31);
  }
  return __dst;
}

char *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromRight(char *result, uint64_t a2, uint64_t a3)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  char *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  if (result[248] < 0)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, a2, a3);
  v3 = &result[8 * a2];
  v5 = *((_QWORD *)v3 + 15);
  v4 = *((_QWORD *)v3 + 16);
  v6 = *(unsigned __int8 *)(v5 + 248);
  v7 = *(char *)(v4 + 248);
  v8 = v7 & 0x7F;
  v9 = v8 + (v6 & 0x7F);
  v10 = v8 - (v9 >> 1);
  v11 = (char *)(v5 + 8 * (v6 & 0x7F));
  if (v3 != v11)
  {
    v12 = *(_QWORD *)v11;
    *(_QWORD *)v11 = *(_QWORD *)v3;
    *(_QWORD *)v3 = v12;
  }
  v13 = v9 >> 1;
  v14 = ((v7 & 0x7F) - (v9 >> 1));
  v15 = (char *)(v4 + 8 * v10 - 8);
  if (v15 != v3)
  {
    v16 = *(_QWORD *)v3;
    *(_QWORD *)v3 = *(_QWORD *)v15;
    *(_QWORD *)v15 = v16;
  }
  v17 = 8 * v14;
  if ((_DWORD)v8 != v13)
  {
    v18 = (uint64_t *)(v5 + 8 * (v6 & 0x7F) + 8);
    v19 = 8 * v14;
    v20 = (uint64_t *)v4;
    do
    {
      if (v20 != v18)
      {
        v21 = *v18;
        *v18 = *v20;
        *v20 = v21;
      }
      ++v20;
      ++v18;
      v19 -= 8;
    }
    while (v19);
  }
  if (v9 >= 2)
  {
    v22 = 8 * v8;
    v23 = (uint64_t *)v4;
    do
    {
      if (v17)
      {
        v24 = *v23;
        *v23 = v23[v14];
        v23[v14] = v24;
      }
      ++v23;
      v22 -= 8;
    }
    while (v17 != v22);
  }
  if ((v6 & 0x80) == 0)
  {
    if (v7 < 0)
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, a2, v17);
    if ((_DWORD)v8 != v13)
    {
      result = (char *)memmove((void *)(v5 + 8 * v6 + 128), (const void *)(v4 + 120), v17);
      v7 = *(char *)(v4 + 248);
      if (v7 < 0)
        lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v25, v26);
    }
    v27 = v7 + 1;
    if (v27 != v14)
      result = (char *)memmove((void *)(v4 + 120), (const void *)(v4 + 120 + 8 * v14), 8 * v27 - 8 * v14);
  }
  *(_BYTE *)(v5 + 248) += v10;
  *(_BYTE *)(v4 + 248) -= v10;
  return result;
}

_QWORD *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromLeft(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if ((char)result[31] < 0)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, a2, a3);
  v3 = a2 - 1;
  v4 = result[v3 + 15];
  v5 = result[a2 + 15];
  LOBYTE(v6) = *(_BYTE *)(v4 + 248);
  v7 = v6 & 0x7F;
  v8 = *(unsigned __int8 *)(v5 + 248);
  v9 = (v8 & 0x7F) + (v6 & 0x7F);
  v10 = ((v6 & 0x7F) - (v9 >> 1));
  if ((v8 & 0x7F) != 0)
  {
    v11 = 8 * (v8 & 0x7F);
    v12 = v5 + 8 * v10;
    do
    {
      if (v5 != v12)
      {
        v13 = *(_QWORD *)(v12 + v11 - 8);
        *(_QWORD *)(v12 + v11 - 8) = *(_QWORD *)(v5 + v11 - 8);
        *(_QWORD *)(v5 + v11 - 8) = v13;
      }
      v11 -= 8;
    }
    while (v11);
  }
  v14 = v4 + 8 * v7;
  if (v14 - 8 * v10 + 8 != v14)
  {
    v15 = 8 - 8 * v10;
    v16 = (uint64_t *)v5;
    do
    {
      v17 = (uint64_t *)(v14 + v15);
      if ((uint64_t *)(v14 + v15) != v16)
      {
        v18 = *v16;
        *v16 = *v17;
        *v17 = v18;
      }
      ++v16;
      v15 += 8;
    }
    while (v15);
  }
  v19 = &result[v3];
  v20 = (uint64_t *)(v5 + 8 * v10 - 8);
  if (v19 != v20)
  {
    v21 = *v20;
    *v20 = *v19;
    *v19 = v21;
  }
  v22 = (uint64_t *)(v4 + 8 * ((int)v7 - (int)v10));
  if (v22 != v19)
  {
    v23 = *v19;
    *v19 = *v22;
    *v22 = v23;
  }
  if (((char)v6 & 0x80000000) == 0)
  {
    if ((v8 & 0x80) != 0)
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, a2, a3);
    result = memmove((void *)(v5 + 120 + 8 * v8 + 8 + 8 * v10 + 8 * ~v8), (const void *)(v5 + 120), 8 * v8 + 8);
    v6 = *(char *)(v4 + 248);
    if (v6 < 0)
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v24, v25);
    if (*(char *)(v5 + 248) < 0)
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v24, v25);
    if ((_DWORD)v7 != v9 >> 1)
    {
      result = memmove((void *)(v5 + 120), (const void *)(v4 + 8 * *(unsigned __int8 *)(v4 + 248) + 128 - 8 * v10), 8 * v10);
      LOBYTE(v6) = *(_BYTE *)(v4 + 248);
    }
  }
  *(_BYTE *)(v4 + 248) = v6 - v10;
  *(_BYTE *)(v5 + 248) += v10;
  return result;
}

const os_unfair_lock *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge(char *a1, lsl::Allocator *this, unsigned int a3)
{
  uint64_t v3;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unsigned int v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  uint64_t v19;
  size_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;

  if (a1[248] < 0)
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge();
  v3 = a1[248];
  if (a1[248] <= a3)
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge();
  v5 = a1;
  v6 = &a1[8 * a3 + 120];
  v8 = *(_QWORD *)v6;
  v7 = *((_QWORD *)v6 + 1);
  v9 = &a1[8 * a3];
  v10 = *(unsigned __int8 *)(*(_QWORD *)v6 + 248);
  v11 = v10 & 0x7F;
  v12 = (char *)(*(_QWORD *)v6 + 8 * v11);
  if (v9 != v12)
  {
    v13 = *(_QWORD *)v12;
    *(_QWORD *)v12 = *(_QWORD *)v9;
    *(_QWORD *)v9 = v13;
  }
  v14 = v3 + 1;
  v15 = v9 + 8;
  if (v9 + 8 != &a1[8 * v3])
  {
    v16 = *(_QWORD *)v9;
    v17 = 8 * v3 - 8 * a3 - 8;
    do
    {
      *(v15 - 1) = *v15;
      *v15++ = v16;
      v17 -= 8;
    }
    while (v17);
  }
  v18 = v6 + 16;
  v19 = (uint64_t)&a1[8 * v14 + 120];
  v20 = v19 - (_QWORD)(v6 + 16);
  if ((char *)v19 != v6 + 16)
  {
    a1 = (char *)memmove(v6 + 8, v18, v20);
    v10 = *(unsigned __int8 *)(v8 + 248);
    v11 = v10 & 0x7F;
  }
  v21 = *(unsigned __int8 *)(v7 + 248);
  v22 = v21 & 0x7F;
  if ((v21 & 0x7F) != 0)
  {
    v23 = (uint64_t *)(v8 + 8 * v11 + 8);
    v24 = 8 * v22;
    v25 = (uint64_t *)v7;
    do
    {
      if (v25 != v23)
      {
        v26 = *v23;
        *v23 = *v25;
        *v25 = v26;
      }
      ++v25;
      ++v23;
      v24 -= 8;
    }
    while (v24);
  }
  if ((v10 & 0x80) == 0)
  {
    if ((v21 & 0x80) != 0)
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)a1, (uint64_t)v18, v20);
    memmove((void *)(v8 + 8 * v10 + 128), (const void *)(v7 + 120), 8 * v21 + 8);
    LOBYTE(v10) = *(_BYTE *)(v8 + 248);
    LOBYTE(v22) = *(_BYTE *)(v7 + 248) & 0x7F;
  }
  *(_BYTE *)(v8 + 248) = v22 + v10 + 1;
  --v5[248];
  return lsl::Allocator::free(this, (_QWORD *)v7);
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator--(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  char v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;

  v3 = *(unsigned __int8 *)(result + 116);
  v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 116))
  {
    if ((_DWORD)v3 == *((unsigned __int8 *)v4 + 32))
    {
      v5 = result + 104;
      v6 = v3 - 1;
      v7 = (char *)(result + 104 + v3 - 1);
      v8 = *v7;
      if (!*(_BYTE *)(result + 104 + (v3 - 1)))
      {
        if (!*v7)
        {
          do
          {
            LODWORD(v3) = v3 - 1;
            *(_BYTE *)(result + 116) = v3;
            v6 = v3 - 1;
            v8 = *(_BYTE *)(v5 + v6);
          }
          while (!v8);
        }
        v7 = (char *)(v5 + v6);
      }
    }
    else
    {
      v16 = result + 8;
      v17 = result + 104;
      do
      {
        v18 = *(_QWORD *)(v16 + 8 * (v3 - 1));
        if (*(char *)(v18 + 248) < 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
        v19 = *(_QWORD *)(v18 + 8 * *(unsigned __int8 *)(v17 + v3 - 1) + 160);
        *(_QWORD *)(v16 + 8 * v3) = v19;
        *(_BYTE *)(v17 + v3) = *(_BYTE *)(v19 + 248) & 0x7F;
        LOBYTE(v3) = *(_BYTE *)(result + 116) + 1;
        *(_BYTE *)(result + 116) = v3;
      }
      while (*((unsigned __int8 *)v4 + 32) != v3);
      v20 = v17 + v3;
      v21 = *(_BYTE *)(v20 - 1);
      v7 = (char *)(v20 - 1);
      v8 = v21;
    }
  }
  else
  {
    v9 = *v4;
    *(_BYTE *)(result + 116) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      v10 = 0;
      v11 = result + 8;
      do
      {
        *(_QWORD *)(v11 + 8 * v10) = v9;
        *(_BYTE *)(result + 104 + v10) = *(_BYTE *)(v9 + 248) & 0x7F;
        v12 = *(unsigned __int8 *)(result + 116);
        v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          v14 = *(_QWORD *)(v11 + 8 * v12);
          if (*(char *)(v14 + 248) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(result, a2, a3);
          v9 = *(_QWORD *)(v14 + 8 * *(unsigned __int8 *)(v14 + 248) + 160);
        }
        v10 = v12 + 1;
        *(_BYTE *)(result + 116) = v10;
      }
      while (v13 > v10);
      v15 = v10 - 1;
    }
    else
    {
      v15 = -1;
    }
    v7 = (char *)(result + v15 + 104);
    v8 = *v7;
  }
  *v7 = v8 - 1;
  return result;
}

unsigned __int8 *lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::prepareForInsertion(unsigned __int8 *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned __int8 v22;
  uint64_t v23;

  v3 = result[116];
  if ((_DWORD)v3 != *(unsigned __int8 *)(*(_QWORD *)result + 32))
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion((uint64_t)result, a2, a3);
  v4 = result;
  v5 = result + 8;
  if (*(char *)(*(_QWORD *)&result[8 * v3] + 248) >= 0)
    v6 = 10;
  else
    v6 = 15;
  if ((*(_BYTE *)(*(_QWORD *)&result[8 * v3] + 248) & 0x7F) == v6)
  {
    if (!result[116])
      goto LABEL_15;
    v7 = 0;
    v8 = 0;
    do
    {
      if (*(char *)(v5[v7] + 248) >= 0)
        v9 = 10;
      else
        v9 = 15;
      if ((*(_BYTE *)(v5[v7] + 248) & 0x7F) != v9)
        v8 = v7;
      ++v7;
    }
    while (v3 != v7);
    if (!v8)
    {
LABEL_15:
      if (*(char *)(*v5 + 248) >= 0)
        v10 = 10;
      else
        v10 = 15;
      if ((*(_BYTE *)(*v5 + 248) & 0x7F) == v10)
      {
        result = (unsigned __int8 *)lsl::Allocator::aligned_alloc(*(lsl::Allocator **)(*(_QWORD *)result + 8), 0x100uLL, 0x100uLL);
        v11 = **(_QWORD **)v4;
        result[248] = 0;
        *(_OWORD *)result = 0u;
        *((_OWORD *)result + 1) = 0u;
        *((_OWORD *)result + 2) = 0u;
        *((_OWORD *)result + 3) = 0u;
        *((_OWORD *)result + 4) = 0u;
        *((_OWORD *)result + 5) = 0u;
        *((_OWORD *)result + 6) = 0u;
        *((_OWORD *)result + 7) = 0u;
        *((_OWORD *)result + 8) = 0u;
        *((_OWORD *)result + 9) = 0u;
        *((_QWORD *)result + 20) = v11;
        **(_QWORD **)v4 = result;
        if (v4[116] && (result = (unsigned __int8 *)memmove(v4 + 105, v4 + 104, v4[116]), v4[116]))
        {
          result = (unsigned __int8 *)memmove(v5 + 1, v5, 8 * v4[116]);
          LOBYTE(v3) = v4[116] + 1;
        }
        else
        {
          LOBYTE(v3) = 1;
        }
        v8 = 0;
        v4[104] = 0;
        v12 = *(uint64_t **)v4;
        *((_QWORD *)v4 + 1) = **(_QWORD **)v4;
        ++*((_BYTE *)v12 + 32);
        v4[116] = v3;
      }
      else
      {
        v8 = 0;
      }
    }
    if (v8 + 1 < v3)
    {
      v13 = v4 + 104;
      v14 = v8;
      do
      {
        v15 = v14;
        result = (unsigned __int8 *)lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::splitChild((char *)v5[v14], v13[v14], *(lsl::Allocator **)(*(_QWORD *)v4 + 8));
        v18 = v5[v14];
        if (*(char *)(v18 + 248) < 0)
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v16, v17);
        v19 = v13[v14];
        v20 = *(_QWORD *)(v18 + 8 * v19 + 160);
        v21 = v4[v14 + 105];
        if (v21 > (*(_BYTE *)(v20 + 248) & 0x7Fu))
        {
          v22 = v19 + 1;
          v13[v14] = v22;
          v4[v14 + 105] = v21 + (~*(_BYTE *)(v20 + 248) | 0x80);
          v23 = v5[v14];
          if (*(char *)(v23 + 248) < 0)
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v16, v17);
          *(_QWORD *)&v4[8 * v14 + 16] = *(_QWORD *)(v23 + 8 * v22 + 160);
        }
        ++v14;
      }
      while (v15 + 2 < v4[116]);
    }
  }
  return result;
}

char *lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::splitChild(char *a1, uint64_t a2, lsl::Allocator *this)
{
  uint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char v7;
  int v8;
  int v9;
  int v10;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *result;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char v20;
  unsigned __int8 v21;
  uint64_t v22;
  int v23;
  char v24;
  int v25;
  char v26;
  int v27;
  int v28;
  int v29;

  if (a1[248] < 0)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)a1, a2, (uint64_t)this);
  v3 = a1[248];
  if (v3 >= 0xA)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)a1, a2, (uint64_t)this);
  v4 = a1;
  v5 = a1 + 160;
  v6 = (uint64_t)&a1[8 * a2 + 160];
  v7 = *(_BYTE *)(*(_QWORD *)v6 + 248);
  v8 = v7;
  v9 = v7 & 0x7F;
  if (v7 >= 0)
    v10 = 10;
  else
    v10 = 15;
  if (v9 != v10)
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)a1, a2, (uint64_t)this);
  v12 = a2;
  if (v8 >= 0)
    v13 = 5;
  else
    v13 = 7;
  v14 = &a1[16 * a2];
  if ((_DWORD)v3 != (_DWORD)a2)
  {
    a1 = (char *)memmove(&a1[16 * a2 + 16], &a1[16 * a2], 16 * v3 - 16 * a2);
    a2 = v4[248];
  }
  if ((a2 & 0x80) != 0)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)a1, a2, (uint64_t)this);
  v15 = &v5[8 * a2];
  if (v15 != (char *)v6)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), (size_t)&v15[-v6]);
    LOBYTE(a2) = v4[248];
  }
  v4[248] = a2 + 1;
  *(_OWORD *)v14 = *(_OWORD *)(*(_QWORD *)v6 + 16 * v13);
  result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  v19 = result;
  v20 = *(_BYTE *)(*(_QWORD *)v6 + 248);
  result[248] = v20 & 0x80;
  if (v20 < 0)
  {
    *((_OWORD *)result + 13) = 0uLL;
    *((_OWORD *)result + 14) = 0uLL;
    *((_OWORD *)result + 11) = 0uLL;
    *((_OWORD *)result + 12) = 0uLL;
    *((_OWORD *)result + 10) = 0uLL;
  }
  *((_OWORD *)result + 8) = 0uLL;
  *((_OWORD *)result + 9) = 0uLL;
  *((_OWORD *)result + 6) = 0uLL;
  *((_OWORD *)result + 7) = 0uLL;
  *((_OWORD *)result + 4) = 0uLL;
  *((_OWORD *)result + 5) = 0uLL;
  *((_OWORD *)result + 2) = 0uLL;
  *((_OWORD *)result + 3) = 0uLL;
  *(_OWORD *)result = 0uLL;
  *((_OWORD *)result + 1) = 0uLL;
  if (v4[248] < 0)
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v17, v18);
  v21 = v9 + ~(_BYTE)v13;
  *(_QWORD *)&v5[8 * v12 + 8] = result;
  if (v21)
    result = (char *)memmove(result, (const void *)(*(_QWORD *)v6 + 16 * v13 + 16), 16 * v21);
  v22 = *(_QWORD *)v6;
  v23 = *(char *)(*(_QWORD *)v6 + 248);
  if ((v23 & 0x80000000) == 0)
  {
    if (v19[248] < 0)
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++((uint64_t)result, v17, v18);
    result = (char *)memmove(v19 + 160, (const void *)(v22 + 8 * v13 + 168), 8 * v21 + 8);
    v22 = *(_QWORD *)v6;
    LOBYTE(v23) = *(_BYTE *)(*(_QWORD *)v6 + 248);
  }
  *(_BYTE *)(v22 + 248) = v23 + ~v21;
  v24 = v19[248] + v21;
  v19[248] = v24;
  if (v24 >= 0)
    v25 = 10;
  else
    v25 = 15;
  if ((v24 & 0x7F) == v25
    || ((v26 = *(_BYTE *)(v22 + 248), v27 = v26, v28 = v26 & 0x7F, v27 >= 0) ? (v29 = 10) : (v29 = 15), v28 == v29))
  {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)result, v17, v18);
  }
  return result;
}

void OUTLINED_FUNCTION_1_2(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 166, a4);
}

void OUTLINED_FUNCTION_2_2(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 167, a4);
}

void OUTLINED_FUNCTION_3_2(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 201, a4);
}

void OUTLINED_FUNCTION_4_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 165, a4);
}

void OUTLINED_FUNCTION_5(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 580, a4);
}

void OUTLINED_FUNCTION_6(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 148, a4);
}

void OUTLINED_FUNCTION_7(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 147, a4);
}

unsigned int *DyldSharedCache::forEachTPRORegion(unsigned int *result, uint64_t a2)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  BOOL v10;
  char v11;

  v2 = result[4];
  if (v2 >= 0x205)
  {
    v3 = result;
    v4 = result[129];
    if ((_DWORD)v4)
    {
      v6 = *(_QWORD *)((char *)result + v2);
      v7 = (uint64_t *)((char *)result + result[128]);
      v8 = &v7[2 * v4];
      do
      {
        v11 = 0;
        v9 = *v7;
        v7 += 2;
        result = (unsigned int *)(*(uint64_t (**)(uint64_t, char *))(a2 + 16))(a2, (char *)v3 + v9 - v6);
        if (v11)
          v10 = 1;
        else
          v10 = v7 >= v8;
      }
      while (!v10);
    }
  }
  return result;
}

uint64_t DyldSharedCache::numSubCaches(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x18Du)
    return *((unsigned int *)this + 99);
  else
    return 0;
}

unsigned int *DyldSharedCache::forEachDylib(unsigned int *result, uint64_t a2)
{
  uint64_t *v2;
  unsigned int *v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char v11;

  v2 = (uint64_t *)((char *)result + result[4]);
  if (!v2[2])
  {
    v3 = result;
    if (result[113])
    {
      v5 = 0;
      v6 = *v2;
      v7 = (uint64_t)result + result[112] + 16;
      do
      {
        v8 = *(_QWORD *)(v7 - 8);
        v9 = (char *)v3 + *(unsigned int *)(v7 + 8);
        v10 = (char *)v3 + *(_QWORD *)(v7 - 16) - v6;
        v11 = 0;
        result = (unsigned int *)(*(uint64_t (**)(uint64_t, char *, char *, unint64_t, _QWORD, uint64_t, char *))(a2 + 16))(a2, v10, v9, v5, *(_QWORD *)v7, v8, &v11);
        if (v11)
          break;
        v7 += 32;
        ++v5;
      }
      while (v5 < v3[113]);
    }
  }
  return result;
}

uint64_t DyldSharedCache::getImageFromPath(DyldSharedCache *this, const char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v7;

  v3 = *((unsigned int *)this + 4);
  v4 = 24;
  if (v3 > 0x1C3)
    v4 = 448;
  v5 = *(unsigned int *)((char *)this + v4);
  v7 = 0;
  if (DyldSharedCache::hasImagePath(this, a2, &v7))
    return (uint64_t)this + *(_QWORD *)((char *)this + 32 * v7 + v5) - *(_QWORD *)((char *)this + v3);
  else
    return 0;
}

uint64_t DyldSharedCache::getIndexedImageEntry(DyldSharedCache *this, int a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *((unsigned int *)this + 4);
  v3 = 24;
  if (v2 > 0x1C3)
    v3 = 448;
  return (uint64_t)this
       + *(_QWORD *)((char *)this + 32 * a2 + *(unsigned int *)((char *)this + v3))
       - *(_QWORD *)((char *)this + v2);
}

uint64_t DyldSharedCache::addressInText(DyldSharedCache *this, uint64_t a2, unsigned int *a3)
{
  uint64_t v3;
  unsigned int v4;
  unint64_t v5;
  char *v6;
  char *v7;
  unint64_t v8;

  v3 = *((_QWORD *)this + 18);
  if (v3 < 1)
    return 0;
  v4 = 0;
  v5 = *(_QWORD *)((char *)this + *((unsigned int *)this + 4)) + a2;
  v6 = (char *)this + *((_QWORD *)this + 17);
  v7 = &v6[32 * v3];
  while (1)
  {
    v8 = *((_QWORD *)v6 + 2);
    if (v8 <= v5 && v5 < v8 + *((unsigned int *)v6 + 6))
      break;
    v6 += 32;
    ++v4;
    if (v6 >= v7)
      return 0;
  }
  *a3 = v4;
  return 1;
}

uint64_t ___ZNK15DyldSharedCache10mappedSizeEv_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
  if (!*(_QWORD *)(v4 + 24))
    *(_QWORD *)(v4 + 24) = a3;
  v5 = *(_QWORD *)(*(_QWORD *)(result + 40) + 8);
  if ((unint64_t)(a4 + a3) > *(_QWORD *)(v5 + 24))
    *(_QWORD *)(v5 + 24) = a4 + a3;
  return result;
}

BOOL DyldSharedCache::findMachHeaderImageIndex(DyldSharedCache *this, const mach_header *a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  unint64_t v9;
  _BOOL8 result;
  uint64_t *v11;
  uint64_t v12;

  v3 = *((unsigned int *)this + 4);
  if (v3 <= 0x1C3)
    v4 = 24;
  else
    v4 = 448;
  v5 = 28;
  if (v3 > 0x1C3)
    v5 = 452;
  v6 = *(unsigned int *)((char *)this + v5);
  if (!(_DWORD)v6)
    return 0;
  v7 = (char *)a2 - (char *)this + *(_QWORD *)((char *)this + v3);
  v8 = *(unsigned int *)((char *)this + v4);
  if (*(_QWORD *)((char *)this + v8) != v7)
  {
    v9 = 0;
    v11 = (uint64_t *)((char *)this + v8 + 32);
    while (v6 - 1 != v9)
    {
      v12 = *v11;
      v11 += 4;
      ++v9;
      if (v12 == v7)
      {
        result = v9 < v6;
        goto LABEL_13;
      }
    }
    return 0;
  }
  LODWORD(v9) = 0;
  result = 1;
LABEL_13:
  *a3 = v9;
  return result;
}

uint64_t DyldSharedCache::patchInfoVersion(DyldSharedCache *this)
{
  uint64_t v1;

  v1 = *((unsigned int *)this + 4);
  if (v1 >= 0x181)
    return *(unsigned int *)((char *)this + *((_QWORD *)this + 19) - *(_QWORD *)((char *)this + v1));
  else
    return 1;
}

dyld3::MachOFile *DyldSharedCache::forEachPatchableExport(dyld3::MachOFile *result, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  dyld3::MachOFile *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  char *v12;
  _QWORD *v13;
  char *v14;
  unsigned int v15;
  uint64_t v16;
  char *v17;
  char *v18;
  int v19;
  char *v20;
  unint64_t v21;
  char *v22;
  _QWORD v23[2];

  v3 = *((_QWORD *)result + 19);
  if (v3)
  {
    v5 = result;
    v6 = *((unsigned int *)result + 4);
    if (v6 < 0x181 || *(_DWORD *)((char *)result + v3 - *(_QWORD *)((char *)result + v6)) == 1)
    {
      v7 = 24;
      if (v6 > 0x1C3)
        v7 = 448;
      v8 = (char *)result + *(_QWORD *)((char *)result + 32 * a2 + *(unsigned int *)((char *)result + v7));
      v9 = *(char **)((char *)result + v6);
      result = (dyld3::MachOFile *)(v8 - v9);
      if (v8 != v9)
      {
        v10 = a2;
        result = (dyld3::MachOFile *)dyld3::MachOFile::preferredLoadAddress(result);
        v11 = *(_QWORD *)((char *)v5 + *((unsigned int *)v5 + 4));
        v12 = (char *)v5 - v11;
        v13 = (_QWORD *)((char *)v5 + *((_QWORD *)v5 + 19) - v11);
        if (v13[1] >= v10)
        {
          v14 = &v12[8 * v10 + *v13];
          v15 = *((_DWORD *)v14 + 1);
          if (v13[3] >= (unint64_t)(v15 + *(_DWORD *)v14))
          {
            if (v15)
            {
              v16 = 0;
              v17 = &v12[v13[2]];
              v18 = &v12[v13[6]];
              v19 = v11 - (_DWORD)result;
              do
              {
                v20 = &v17[16 * v16 + 16 * *(unsigned int *)v14];
                v21 = *((unsigned int *)v20 + 3);
                if (v13[7] <= v21)
                  v22 = (char *)&unk_1A5CBE413;
                else
                  v22 = &v18[v21];
                result = (dyld3::MachOFile *)(*(uint64_t (**)(uint64_t, _QWORD, char *, _QWORD))(a3 + 16))(a3, (*(_DWORD *)v20 + v19), v22, 0);
                ++v16;
              }
              while (v16 != *((_DWORD *)v14 + 1));
            }
          }
        }
      }
    }
    else
    {
      v23[0] = (char *)result + v3 - *(_QWORD *)((char *)result + v6);
      v23[1] = v3;
      return (dyld3::MachOFile *)PatchTable::forEachPatchableExport(v23, a2, a3);
    }
  }
  return result;
}

BOOL DyldSharedCache::shouldPatchClientOfImage(DyldSharedCache *this, unsigned int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  _QWORD v7[2];

  v3 = *((_QWORD *)this + 19);
  if (!v3)
    return 0;
  v4 = *((unsigned int *)this + 4);
  if (v4 < 0x181)
    return 0;
  v5 = (_DWORD *)((char *)this + v3 - *(_QWORD *)((char *)this + v4));
  if (*v5 == 1)
    return 0;
  v7[0] = v5;
  v7[1] = v3;
  return PatchTable::imageHasClient((PatchTable *)v7, a2, a3);
}

void DyldSharedCache::forEachPatchableUseOfExportInImage(uint64_t a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int Address;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int *v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  dyld3::MachOFile *v33;
  uint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t *v38;
  int v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  int8x16_t v43;
  uint64_t v44;
  int v45;
  unsigned int *v46;
  _QWORD *v47;
  unsigned int *v48;
  unsigned __int32 v50;
  _QWORD v51[9];
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  double (*v63)(uint64_t, uint64_t);
  _QWORD *(*v64)(_QWORD *);
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  vm_address_t v68;
  vm_size_t v69;
  _QWORD v70[17];

  v5 = *(_QWORD *)(a1 + 152);
  if (v5)
  {
    v9 = *(unsigned int *)(a1 + 16);
    if (v9 < 0x181 || *(_DWORD *)(v5 + a1 - *(_QWORD *)(a1 + v9)) == 1)
    {
      v10 = 24;
      if (v9 > 0x1C3)
        v10 = 448;
      v11 = *(_QWORD *)(a1 + *(unsigned int *)(a1 + v10) + 32 * a2) + a1;
      v12 = *(_QWORD *)(v9 + a1);
      if (v11 != v12)
      {
        v13 = *(_QWORD *)(a1 + v9);
        v14 = a2;
        Address = dyld3::MachOFile::preferredLoadAddress((dyld3::MachOFile *)(v11 - v12));
        v16 = *(_QWORD *)(a1 + *(unsigned int *)(a1 + 16));
        v17 = (_QWORD *)(*(_QWORD *)(a1 + 152) + a1 - v16);
        if (v17[1] >= v14)
        {
          v18 = a1 - v16;
          v19 = (unsigned int *)(a1 - v16 + *v17 + 8 * v14);
          v20 = v19[1];
          v48 = v19 + 1;
          if (v17[3] >= (unint64_t)(v20 + *v19))
          {
            v61 = &v60;
            v62 = 0x5002000000;
            v63 = __Block_byref_object_copy__10;
            v64 = __Block_byref_object_dispose__10;
            v65 = v70;
            v66 = 8;
            v68 = 0;
            v69 = 0;
            v67 = 0;
            v56 = 0;
            v57 = &v56;
            v58 = 0x2000000000;
            v59 = 0;
            v60 = 0;
            v52 = 0;
            v53 = &v52;
            v54 = 0x2000000000;
            v55 = -1;
            if (v20)
            {
              v21 = 0;
              v22 = Address - v13 + a3;
              v23 = v18 + v17[2];
              v24 = v18 + v17[4];
              v46 = v19;
              v47 = v17;
              v45 = v22;
              v44 = v23;
              do
              {
                v25 = v21 + *v19;
                if (*(_DWORD *)(v23 + 16 * v25) == v22)
                {
                  v26 = v23 + 16 * v25;
                  v28 = *(_DWORD *)(v26 + 4);
                  v27 = (unsigned int *)(v26 + 4);
                  v29 = v27[1];
                  if (v17[5] < (unint64_t)(v29 + v28))
                    break;
                  if (v29)
                  {
                    v30 = 0;
                    do
                    {
                      v31 = v30 + *v27;
                      v32 = (_DWORD *)(v24 + 8 * v31);
                      v33 = (dyld3::MachOFile *)v57[3];
                      v34 = v61;
                      if (v33 && (v35 = v61[7]) != 0)
                      {
                        v36 = *v32;
                        v37 = 16 * v35;
                        v38 = (unint64_t *)(v61[5] + 8);
                        while (*(v38 - 1) > v36 || *v38 <= v36)
                        {
                          v38 += 2;
                          v37 -= 16;
                          if (!v37)
                            goto LABEL_21;
                        }
                      }
                      else
                      {
LABEL_21:
                        v57[3] = 0;
                        *((_DWORD *)v53 + 6) = -1;
                        v34[7] = 0;
                        v51[0] = _NSConcreteStackBlock;
                        v51[1] = 0x40000000;
                        v51[2] = ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke;
                        v51[3] = &unk_1E4F7E498;
                        v51[7] = v13;
                        v51[8] = v24 + 8 * v31;
                        v51[4] = &v60;
                        v51[5] = &v56;
                        v51[6] = &v52;
                        DyldSharedCache::forEachDylib((unsigned int *)a1, (uint64_t)v51);
                        v33 = (dyld3::MachOFile *)v57[3];
                      }
                      if (!v33)
                        DyldSharedCache::forEachPatchableUseOfExportInImage();
                      v39 = *((_DWORD *)v53 + 6);
                      if (v39 == -1)
                        DyldSharedCache::forEachPatchableUseOfExportInImage();
                      if (!v61[7])
                        DyldSharedCache::forEachPatchableUseOfExportInImage();
                      if (v39 == a4)
                      {
                        v40 = v13 + *v32;
                        v41 = v40 - dyld3::MachOFile::preferredLoadAddress(v33);
                        dyld3::MachOFile::PointerMetaData::PointerMetaData(&v50);
                        v42 = *(_DWORD *)(v24 + 8 * v31 + 4);
                        v43 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v42), (uint32x4_t)xmmword_1A5CBB420), (int8x16_t)xmmword_1A5CBB430);
                        *(int8x8_t *)v43.i8 = vorr_s8(*(int8x8_t *)v43.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL));
                        v50 = v43.i32[0] | v50 & 0xF0000000 | v43.i32[1] | HIWORD(v42);
                        (*(void (**)(uint64_t, uint64_t))(a5 + 16))(a5, v41);
                      }
                      ++v30;
                    }
                    while (v30 != v27[1]);
                    v17 = v47;
                    v20 = *v48;
                    v19 = v46;
                    v22 = v45;
                    v23 = v44;
                  }
                }
                ++v21;
              }
              while (v21 != v20);
            }
            _Block_object_dispose(&v52, 8);
            _Block_object_dispose(&v56, 8);
            _Block_object_dispose(&v60, 8);
            v67 = 0;
            if (v68)
              vm_deallocate(mach_task_self_, v68, v69);
          }
        }
      }
    }
    else
    {
      v70[0] = v5 + a1 - *(_QWORD *)(a1 + v9);
      v70[1] = v5;
      PatchTable::forEachPatchableUseOfExportInImage((PatchTableV2 *)v70, a2, a3, a4, a5);
    }
  }
}

double __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;

  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__10(_QWORD *result)
{
  vm_address_t v1;

  result[7] = 0;
  v1 = result[8];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[9]);
  return result;
}

void ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke(uint64_t a1, _DWORD *a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, _BYTE *a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  _QWORD v17[6];

  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  v17[2] = ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2;
  v17[3] = &unk_1E4F7E470;
  v11 = *(_QWORD *)(a1 + 56);
  v17[4] = *(_QWORD *)(a1 + 32);
  v17[5] = v11;
  dyld3::MachOFile::forEachSegment(a2, (uint64_t)v17);
  v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v13 = *(_QWORD *)(v12 + 56);
  if (v13)
  {
    v14 = **(unsigned int **)(a1 + 64);
    v15 = 16 * v13;
    v16 = (unint64_t *)(*(_QWORD *)(v12 + 40) + 8);
    while (*(v16 - 1) > v14 || *v16 <= v14)
    {
      v16 += 2;
      v15 -= 16;
      if (!v15)
        goto LABEL_6;
    }
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a2;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = a4;
    *a7 = 1;
  }
  else
  {
LABEL_6:
    *(_QWORD *)(v12 + 56) = 0;
  }
}

void *___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2(void *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  vm_address_t v8;
  vm_size_t v9;
  unint64_t v10;
  vm_size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;

  if ((*(_BYTE *)(a2 + 52) & 2) != 0)
  {
    v2 = *((_QWORD *)result + 5);
    v3 = *(_QWORD *)(*((_QWORD *)result + 4) + 8);
    v5 = *(_QWORD *)(a2 + 16);
    v4 = *(_QWORD *)(a2 + 24);
    v6 = *(_QWORD *)(v3 + 48);
    v7 = *(_QWORD *)(v3 + 56) + 1;
    if (v7 > v6)
    {
      v8 = *(_QWORD *)(v3 + 64);
      v9 = *(_QWORD *)(v3 + 72);
      v10 = 2 * v6;
      if (v10 > v7)
        v7 = v10;
      v11 = (vm_page_size + 16 * v7 - 1) & -(uint64_t)vm_page_size;
      *(_QWORD *)(v3 + 72) = v11;
      if (vm_allocate(mach_task_self_, (vm_address_t *)(v3 + 64), v11, 1006632961))
        ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2_cold_1();
      result = memmove(*(void **)(v3 + 64), *(const void **)(v3 + 40), 16 * *(_QWORD *)(v3 + 56));
      v12 = *(_QWORD *)(v3 + 72) >> 4;
      *(_QWORD *)(v3 + 40) = *(_QWORD *)(v3 + 64);
      *(_QWORD *)(v3 + 48) = v12;
      if (v8)
        result = (void *)vm_deallocate(mach_task_self_, v8, v9);
    }
    v13 = *(_QWORD *)(v3 + 40);
    v14 = *(_QWORD *)(v3 + 56);
    *(_QWORD *)(v3 + 56) = v14 + 1;
    v15 = (_QWORD *)(v13 + 16 * v14);
    *v15 = v5 - v2;
    v15[1] = v5 - v2 + v4;
  }
  return result;
}

dyld3::MachOFile *DyldSharedCache::forEachPatchableUseOfExport(dyld3::MachOFile *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4;
  dyld3::MachOFile *v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  char *v19;
  unsigned int *v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  char *v24;
  char *v25;
  uint64_t v26;
  char *v27;
  unsigned int *v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  char *v32;
  unsigned int v33;
  int8x16_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  _QWORD v38[2];
  _QWORD v39[5];

  v4 = *((_QWORD *)result + 19);
  if (v4)
  {
    v8 = result;
    v9 = *((unsigned int *)result + 4);
    if (v9 > 0x180)
    {
      v10 = *(_DWORD *)((char *)result + v4 - *(_QWORD *)((char *)result + v9));
      DyldSharedCache::forEachPatchableGOTUseOfExport((uint64_t)result, a2, a3, a4);
      if (v10 != 1)
      {
        v39[1] = 0x40000000;
        v39[2] = ___ZNK15DyldSharedCache27forEachPatchableUseOfExportEjjU13block_pointerFvyN5dyld39MachOFile15PointerMetaDataEybE_block_invoke;
        v39[3] = &__block_descriptor_tmp_36_2;
        v39[4] = v8;
        v35 = *((_QWORD *)v8 + 19);
        v36 = *(_QWORD *)((char *)v8 + *((unsigned int *)v8 + 4));
        v38[0] = (char *)v8 + v35 - v36;
        v38[1] = v35;
        v39[0] = _NSConcreteStackBlock;
        return (dyld3::MachOFile *)PatchTable::forEachPatchableCacheUseOfExport(v38, a2, a3, v36, (uint64_t)v39, a4);
      }
    }
    else
    {
      DyldSharedCache::forEachPatchableGOTUseOfExport((uint64_t)result, a2, a3, a4);
    }
    v11 = *((unsigned int *)v8 + 4);
    v12 = 24;
    if (v11 > 0x1C3)
      v12 = 448;
    v13 = (char *)v8 + *(_QWORD *)((char *)v8 + 32 * a2 + *(unsigned int *)((char *)v8 + v12));
    v14 = *(char **)((char *)v8 + v11);
    result = (dyld3::MachOFile *)(v13 - v14);
    if (v13 != v14)
    {
      v15 = *(_DWORD *)((char *)v8 + v11);
      v16 = a2;
      result = (dyld3::MachOFile *)dyld3::MachOFile::preferredLoadAddress(result);
      v17 = *(_QWORD *)((char *)v8 + *((unsigned int *)v8 + 4));
      v18 = (_QWORD *)((char *)v8 + *((_QWORD *)v8 + 19) - v17);
      if (v18[1] >= v16)
      {
        v19 = (char *)v8 - v17;
        v20 = (unsigned int *)((char *)v8 + 8 * v16 + *v18 - v17);
        v21 = v20[1];
        if (v18[3] >= (unint64_t)(v21 + *v20))
        {
          if (v21)
          {
            v22 = 0;
            v23 = (_DWORD)result - v15 + a3;
            v24 = &v19[v18[2]];
            v25 = &v19[v18[4]];
            v37 = v23;
            do
            {
              v26 = v22 + *v20;
              if (*(_DWORD *)&v24[16 * v26] == v23)
              {
                v27 = &v24[16 * v26];
                v29 = *((_DWORD *)v27 + 1);
                v28 = (unsigned int *)(v27 + 4);
                v30 = v28[1];
                if (v18[5] < (unint64_t)(v30 + v29))
                  return result;
                if (v30)
                {
                  v31 = 0;
                  do
                  {
                    v32 = &v25[8 * v31 + 8 * *v28];
                    dyld3::MachOFile::PointerMetaData::PointerMetaData(v38);
                    v33 = *((_DWORD *)v32 + 1);
                    v34 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v33), (uint32x4_t)xmmword_1A5CBB420), (int8x16_t)xmmword_1A5CBB430);
                    *(int8x8_t *)v34.i8 = vorr_s8(*(int8x8_t *)v34.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
                    LODWORD(v38[0]) = v34.i32[0] | v38[0] & 0xF0000000 | v34.i32[1] | HIWORD(v33);
                    result = (dyld3::MachOFile *)(*(uint64_t (**)(uint64_t, _QWORD))(a4 + 16))(a4, *(unsigned int *)v32);
                    ++v31;
                  }
                  while (v31 != v28[1]);
                  v21 = v20[1];
                  v23 = v37;
                }
              }
              ++v22;
            }
            while (v22 != v21);
          }
        }
      }
    }
  }
  return result;
}

uint64_t DyldSharedCache::forEachPatchableGOTUseOfExport(uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _QWORD v7[2];

  v4 = *(_QWORD *)(result + 152);
  if (v4)
  {
    v5 = *(unsigned int *)(result + 16);
    if (v5 >= 0x181)
    {
      v6 = (_DWORD *)(v4 + result - *(_QWORD *)(result + v5));
      if (*v6 != 1)
      {
        v7[0] = v6;
        v7[1] = v4;
        return PatchTable::forEachPatchableGOTUseOfExport((uint64_t)v7, a2, a3, a4);
      }
    }
  }
  return result;
}

dyld3::MachOFile *___ZNK15DyldSharedCache27forEachPatchableUseOfExportEjjU13block_pointerFvyN5dyld39MachOFile15PointerMetaDataEybE_block_invoke(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  dyld3::MachOFile *result;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(unsigned int *)(v2 + 16);
  v4 = 24;
  if (v3 > 0x1C3)
    v4 = 448;
  v5 = *(_QWORD *)(v2 + *(unsigned int *)(v2 + v4) + 32 * a2) + v2;
  v6 = *(_QWORD *)(v3 + v2);
  result = (dyld3::MachOFile *)(v5 - v6);
  if (v5 != v6)
    return (dyld3::MachOFile *)dyld3::MachOFile::preferredLoadAddress(result);
  return result;
}

BOOL DyldSharedCache::isSubCachePath(DyldSharedCache *this, const char *a2)
{
  char *v2;

  v2 = _platform_strchr((char *)this, 46);
  return v2 && _platform_strcmp(v2, ".development");
}

dyld3::MachOLoaded *DyldSharedCache::oldObjcOpt(DyldSharedCache *this)
{
  unint64_t v2;
  uint64_t v3;
  char *v4;
  char *v5;
  dyld3::MachOLoaded *v6;
  _DWORD *v7;
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;

  v14 = 0;
  if (!DyldSharedCache::hasImagePath(this, "/usr/lib/libobjc.A.dylib", &v14))
    return 0;
  v2 = *((unsigned int *)this + 4);
  v3 = 24;
  if (v2 > 0x1C3)
    v3 = 448;
  v4 = (char *)this + *(_QWORD *)((char *)this + 32 * v14 + *(unsigned int *)((char *)this + v3));
  v5 = *(char **)((char *)this + v2);
  v6 = (dyld3::MachOLoaded *)(v4 - v5);
  if (v4 != v5)
  {
    v10 = 0;
    v11 = &v10;
    v12 = 0x2000000000;
    v13 = 0;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = ___ZNK15DyldSharedCache10oldObjcOptEv_block_invoke;
    v9[3] = &unk_1E4F7E4E0;
    v9[4] = &v10;
    v9[5] = dyld3::MachOLoaded::getSlide(v6);
    dyld3::MachOFile::forEachSection(v6, (uint64_t)v9);
    v7 = (_DWORD *)v11[3];
    if (v7)
    {
      if ((*v7 - 15) >= 2)
        v6 = 0;
      else
        v6 = (dyld3::MachOLoaded *)v11[3];
    }
    else
    {
      v6 = 0;
    }
    _Block_object_dispose(&v10, 8);
  }
  return v6;
}

uint64_t ___ZNK15DyldSharedCache10oldObjcOptEv_block_invoke(uint64_t a1, uint64_t a2, int a3, _BYTE *a4)
{
  uint64_t result;

  result = _platform_strcmp(*(const char **)(a2 + 40), "__TEXT");
  if (!(_DWORD)result)
  {
    result = _platform_strcmp(*(const char **)(a2 + 80), "__objc_opt_ro");
    if (!(_DWORD)result)
    {
      if (a3)
        *a4 = 1;
      else
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a1 + 40) + *(_QWORD *)(a2 + 64);
    }
  }
  return result;
}

uint64_t DyldSharedCache::objcOptPtrs(DyldSharedCache *this)
{
  unint64_t v2;
  uint64_t v3;
  dyld3::MachOLoaded *v4;
  uint64_t Slide;
  uint64_t v6;
  _QWORD v8[6];
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;

  v14 = 0;
  if (!DyldSharedCache::hasImagePath(this, "/usr/lib/libobjc.A.dylib", &v14))
    return 0;
  v2 = *((unsigned int *)this + 4);
  v3 = 24;
  if (v2 > 0x1C3)
    v3 = 448;
  v4 = (DyldSharedCache *)((char *)this
                         + *(_QWORD *)((char *)this + 32 * v14 + *(unsigned int *)((char *)this + v3))
                         - *(_QWORD *)((char *)this + v2));
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  Slide = dyld3::MachOLoaded::getSlide(v4);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK15DyldSharedCache11objcOptPtrsEv_block_invoke;
  v8[3] = &unk_1E4F7E508;
  v9 = dyld3::MachOFile::pointerSize(v4);
  v8[4] = &v10;
  v8[5] = Slide;
  dyld3::MachOFile::forEachSection(v4, (uint64_t)v8);
  v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t ___ZNK15DyldSharedCache11objcOptPtrsEv_block_invoke(uint64_t a1, uint64_t a2, int a3, _BYTE *a4)
{
  const char *v8;
  uint64_t result;

  v8 = *(const char **)(a2 + 40);
  if (!_platform_strncmp(v8, "__DATA", 6uLL) || (result = _platform_strncmp(v8, "__AUTH", 6uLL), !(_DWORD)result))
  {
    result = _platform_strcmp(*(const char **)(a2 + 80), "__objc_opt_ptrs");
    if (!(_DWORD)result)
    {
      if (*(_QWORD *)(a2 + 72) == *(_DWORD *)(a1 + 48) && !a3)
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a1 + 40) + *(_QWORD *)(a2 + 64);
      else
        *a4 = 1;
    }
  }
  return result;
}

uint64_t objc_visitor::Class::getSuperclassField@<X0>(uint64_t a1@<X0>, int *a2@<X1>, _QWORD *a3@<X8>)
{
  int v5;
  uint64_t v6;
  char *v7;

  v5 = *a2;
  v6 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v5 == 4)
    v7 = (char *)(v6 + 4);
  else
    v7 = (char *)(v6 + 8);
  return metadata_visitor::Visitor::getField((uint64_t)a2, v7, a3);
}

uint64_t objc_visitor::Class::isUnfixedBackwardDeployingStableSwift(uint64_t a1, int *a2)
{
  uint64_t result;
  uint64_t v5;

  result = objc_visitor::Class::isSwiftLegacy(a1, a2);
  if ((_DWORD)result)
  {
    v5 = objc_visitor::Class::swiftClassFlags(a1, a2);
    return (v5 & 0xFF00000000) != 0 && (v5 & 1) == 0;
  }
  return result;
}

uint64_t objc_visitor::Class::isSwiftLegacy(uint64_t a1, int *a2)
{
  int v3;
  uint64_t v4;
  char *v5;
  char v6;
  char v7;
  _QWORD v9[3];
  uint64_t *v10[3];

  v3 = *a2;
  v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v3 == 4)
    v5 = (char *)(v4 + 16);
  else
    v5 = (char *)(v4 + 32);
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v10);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v10, v9);
  v6 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  if (!v7)
    std::__throw_bad_optional_access[abi:nn180100]();
  return v6 & 1;
}

uint64_t objc_visitor::Class::swiftClassFlags(uint64_t a1, int *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;

  if ((objc_visitor::Class::isSwiftStable(a1, a2) & 1) == 0
    && !objc_visitor::Class::isSwiftLegacy(a1, a2))
  {
    return 0;
  }
  v4 = *a2;
  v5 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  v6 = 40;
  if (v4 == 4)
    v6 = 20;
  return *(unsigned int *)(v5 + v6) | 0x100000000;
}

uint64_t objc_visitor::Class::isSwiftStable(uint64_t a1, int *a2)
{
  int v3;
  uint64_t v4;
  char *v5;
  unint64_t v6;
  char v7;
  _QWORD v9[3];
  uint64_t *v10[3];

  v3 = *a2;
  v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v3 == 4)
    v5 = (char *)(v4 + 16);
  else
    v5 = (char *)(v4 + 32);
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v10);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v10, v9);
  v6 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  if (!v7)
    std::__throw_bad_optional_access[abi:nn180100]();
  return (v6 >> 1) & 1;
}

uint64_t objc_visitor::Class::isRootClass(uint64_t a1, int *a2)
{
  __n128 v3;

  objc_visitor::Class::getClassData(a1, a2, &v3);
  return (*(_DWORD *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v3) >> 1) & 1;
}

uint64_t objc_visitor::Class::getName(uint64_t a1, int *a2)
{
  int v3;
  uint64_t v4;
  char *v5;
  _QWORD v7[3];
  uint64_t *v8[3];
  __n128 v9;

  objc_visitor::Class::getClassData(a1, a2, &v9);
  v3 = *a2;
  v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v9);
  if (v3 == 4)
    v5 = (char *)(v4 + 16);
  else
    v5 = (char *)(v4 + 24);
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v7);
}

uint64_t objc_visitor::Class::getNameVMAddr(uint64_t a1, int *a2)
{
  int v3;
  uint64_t v4;
  char *v5;
  _QWORD v7[3];
  uint64_t *v8[3];
  __n128 v9;

  objc_visitor::Class::getClassData(a1, a2, &v9);
  v3 = *a2;
  v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v9);
  if (v3 == 4)
    v5 = (char *)(v4 + 16);
  else
    v5 = (char *)(v4 + 24);
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v7);
}

uint64_t objc_visitor::Class::getVMAddress(objc_visitor::Class *this)
{
  return metadata_visitor::ResolvedValue::vmAddress((objc_visitor::Class *)((char *)this + 8));
}

uint64_t objc_visitor::Category::getInstanceMethods@<X0>(lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5;
  uint64_t v6;
  char *v7;
  uint64_t *v9[3];

  v5 = *a2;
  v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4)
    v7 = (char *)(v6 + 8);
  else
    v7 = (char *)(v6 + 16);
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Category::getClassMethods@<X0>(lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5;
  uint64_t v6;
  char *v7;
  uint64_t *v9[3];

  v5 = *a2;
  v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4)
    v7 = (char *)(v6 + 12);
  else
    v7 = (char *)(v6 + 24);
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Protocol::getISAVMAddr@<X0>(lsl::Allocator::Pool *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char *v5;
  uint64_t result;
  char v7;
  uint64_t v8;
  _BYTE v9[24];
  char v10;
  uint64_t *v11[3];

  v5 = (char *)lsl::Allocator::Pool::allocator(a1);
  metadata_visitor::Visitor::getField(a2, v5, v11);
  result = metadata_visitor::Visitor::resolveOptionalRebase(a2, v11, (uint64_t)v9);
  v7 = v10;
  if (v10)
  {
    result = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
    *(_QWORD *)a3 = result;
    *(_QWORD *)(a3 + 8) = v8;
    v7 = 1;
  }
  else
  {
    *(_BYTE *)a3 = 0;
  }
  *(_BYTE *)(a3 + 16) = v7;
  return result;
}

uint64_t objc_visitor::Protocol::getName(lsl::Allocator::Pool *a1, int *a2)
{
  int v3;
  uint64_t v4;
  char *v5;
  _QWORD v7[3];
  uint64_t *v8[3];

  v3 = *a2;
  v4 = lsl::Allocator::Pool::allocator(a1);
  if (v3 == 4)
    v5 = (char *)(v4 + 4);
  else
    v5 = (char *)(v4 + 8);
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v7);
}

uint64_t objc_visitor::Protocol::getNameVMAddr(lsl::Allocator::Pool *a1, int *a2)
{
  int v3;
  uint64_t v4;
  char *v5;
  _QWORD v7[3];
  uint64_t *v8[3];

  v3 = *a2;
  v4 = lsl::Allocator::Pool::allocator(a1);
  if (v3 == 4)
    v5 = (char *)(v4 + 4);
  else
    v5 = (char *)(v4 + 8);
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v7);
}

uint64_t objc_visitor::Protocol::getClassMethods@<X0>(lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5;
  uint64_t v6;
  char *v7;
  uint64_t *v9[3];

  v5 = *a2;
  v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4)
    v7 = (char *)(v6 + 16);
  else
    v7 = (char *)(v6 + 32);
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Protocol::getOptionalInstanceMethods@<X0>(lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5;
  uint64_t v6;
  char *v7;
  uint64_t *v9[3];

  v5 = *a2;
  v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4)
    v7 = (char *)(v6 + 20);
  else
    v7 = (char *)(v6 + 40);
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Protocol::getOptionalClassMethods@<X0>(lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5;
  uint64_t v6;
  char *v7;
  uint64_t *v9[3];

  v5 = *a2;
  v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4)
    v7 = (char *)(v6 + 24);
  else
    v7 = (char *)(v6 + 48);
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

int *objc_visitor::Method::getNameSelRefVMAddr(int *result, uint64_t a2)
{
  int v2;
  metadata_visitor::ResolvedValue *v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  _QWORD v8[3];

  v2 = *result;
  if (*result)
  {
    if (v2 == 1)
      objc_visitor::Method::getNameSelRefVMAddr();
    if (v2 == 2)
      objc_visitor::Method::getNameSelRefVMAddr();
  }
  else
  {
    v4 = (metadata_visitor::ResolvedValue *)(result + 2);
    v5 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    v6 = metadata_visitor::ResolvedValue::vmAddress(v4);
    if (!v7)
      std::__throw_bad_optional_access[abi:nn180100]();
    metadata_visitor::Visitor::getValueFor(a2, v6 + v5, 1, v8);
    return (int *)metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v8);
  }
  return result;
}

uint64_t objc_visitor::ProtocolList::numProtocols(lsl::Allocator::Pool *a1, _DWORD *a2)
{
  unsigned int *v3;

  if (!*((_BYTE *)a1 + 24))
    return 0;
  v3 = (unsigned int *)lsl::Allocator::Pool::allocator(a1);
  if (!v3)
    objc_visitor::ProtocolList::numProtocols();
  if (*a2 == 4)
    return *v3;
  else
    return *(_QWORD *)v3;
}

uint64_t objc_visitor::ProtocolList::getProtocolField@<X0>(lsl::Allocator::Pool *a1@<X0>, _DWORD *a2@<X1>, unint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  char *v9;

  if (!*((_BYTE *)a1 + 24))
    objc_visitor::ProtocolList::getProtocolField();
  if (objc_visitor::ProtocolList::numProtocols(a1, a2) <= a3)
    objc_visitor::ProtocolList::getProtocolField();
  if (!*((_BYTE *)a1 + 24))
    std::__throw_bad_optional_access[abi:nn180100]();
  v8 = lsl::Allocator::Pool::allocator(a1);
  if (!v8)
    objc_visitor::ProtocolList::getProtocolField();
  if (*a2 == 4)
    v9 = (char *)(v8 + 4 * a3 + 4);
  else
    v9 = (char *)(v8 + 8 * a3 + 8);
  return metadata_visitor::Visitor::getField((uint64_t)a2, v9, a4);
}

size_t objc_visitor::ProtocolList::dump(lsl::Allocator::Pool *a1, _DWORD *a2)
{
  uint64_t v4;
  FILE *v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  const void *v9;
  size_t result;
  unint64_t v11;
  FILE *v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  const void *v16;
  _QWORD v17[3];
  uint64_t *v18[3];

  if (!*((_BYTE *)a1 + 24))
    return fwrite("no value\n", 9uLL, 1uLL, __stdoutp);
  v4 = objc_visitor::ProtocolList::numProtocols(a1, a2);
  v5 = __stdoutp;
  v6 = metadata_visitor::ResolvedValue::vmAddress(a1);
  if (!v7)
    goto LABEL_9;
  v8 = v6;
  v9 = (const void *)lsl::Allocator::Pool::allocator(a1);
  result = fprintf(v5, "Protocol list (count %lld): vmAddr 0x%llx at %p\n", v4, v8, v9);
  if (v4)
  {
    v11 = 0;
    while (1)
    {
      objc_visitor::ProtocolList::getProtocolField(a1, a2, v11, v18);
      metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v18, v17);
      v12 = __stdoutp;
      v13 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v17);
      if (!v14)
        break;
      v15 = v13;
      v16 = (const void *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v17);
      result = fprintf(v12, "  Protocol[%lld]: vmAddr 0x%llx at %p\n", v11++, v15, v16);
      if (v4 == v11)
        return result;
    }
LABEL_9:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return result;
}

void objc_visitor::Visitor::findSection(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  _DWORD *v6;
  uint64_t *v7;
  __int128 v8;
  _QWORD v9[9];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  __n128 (*v13)(uint64_t, uint64_t);
  uint64_t (*v14)();
  char v15;
  char v16;

  v6 = *(_DWORD **)(a1 + 8);
  v10 = 0;
  v11 = &v10;
  v12 = 0x5002000000;
  v13 = __Block_byref_object_copy__11;
  v14 = __Block_byref_object_dispose__11;
  v15 = 0;
  v16 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___ZNK12objc_visitor7Visitor11findSectionENSt3__14spanIPKcLm18446744073709551615EEES4__block_invoke;
  v9[3] = &unk_1E4F7E530;
  v9[6] = a2;
  v9[7] = a3;
  v9[8] = a4;
  v9[4] = &v10;
  v9[5] = a1;
  dyld3::MachOFile::forEachSection(v6, (uint64_t)v9);
  v7 = v11;
  v8 = *(_OWORD *)(v11 + 7);
  *(_OWORD *)a5 = *(_OWORD *)(v11 + 5);
  *(_OWORD *)(a5 + 16) = v8;
  *(_QWORD *)(a5 + 32) = v7[9];
  _Block_object_dispose(&v10, 8);
}

__n128 __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 40);
  v3 = *(_OWORD *)(a2 + 56);
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

double ___ZNK12objc_visitor7Visitor11findSectionENSt3__14spanIPKcLm18446744073709551615EEES4__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v4;
  uint64_t v8;
  const char **v9;
  uint64_t v10;
  const char *v11;
  double result;
  uint64_t v13;
  uint64_t Slide;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;

  v4 = *(_QWORD *)(a1 + 56);
  if (v4)
  {
    v8 = *(_QWORD *)(a1 + 40);
    v9 = *(const char ***)(a1 + 48);
    v10 = 8 * v4;
    v11 = *(const char **)(a2 + 40);
    while (_platform_strncmp(v11, *v9, 0x10uLL))
    {
      ++v9;
      v10 -= 8;
      if (!v10)
        return result;
    }
    if (!_platform_strncmp(*(const char **)(a2 + 80), *(const char **)(a1 + 64), 0x10uLL))
    {
      v13 = *(_QWORD *)(a2 + 64);
      Slide = dyld3::MachOLoaded::getSlide(*(dyld3::MachOLoaded **)(v8 + 8));
      metadata_visitor::ResolvedValue::ResolvedValue(&v17, Slide + v13, *(_QWORD *)(a2 + 64), 1);
      v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v16 = *(_QWORD *)(a2 + 72);
      result = *(double *)&v17;
      *(_OWORD *)(v15 + 40) = v17;
      *(_QWORD *)(v15 + 56) = v18;
      *(_QWORD *)(v15 + 64) = v16;
      *(_BYTE *)(v15 + 72) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t objc_visitor::Visitor::forEachClass(unsigned int *a1, int a2, lsl::Allocator::Pool *this, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[8];
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  BOOL v18;
  char v19;
  _BYTE v20[8];
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  BOOL v25;
  uint64_t *v26[4];

  v4 = *((_QWORD *)this + 3);
  v5 = *a1;
  v6 = v4 / v5;
  if (v4 % v5)
    objc_visitor::Visitor::forEachClass();
  result = lsl::Allocator::Pool::allocator(this);
  if (v4 >= v5)
  {
    v11 = result;
    v12 = 0;
    do
    {
      while (1)
      {
        metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v11 + v12 * *a1), v26);
        v25 = 0;
        metadata_visitor::Visitor::resolveBindOrRebase((uint64_t)a1, v26, &v25, &v23);
        v21 = v23;
        v22 = v24;
        v20[0] = 0;
        v20[1] = v25;
        v19 = 0;
        result = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, char *))(a4 + 16))(a4, v20, 0, &v19);
        if (v19 || !a2)
          break;
        v18 = 0;
        objc_visitor::Class::getISA((uint64_t)v20, (uint64_t)a1, &v18, &v16);
        v14 = v16;
        v15 = v17;
        v13[0] = 1;
        v13[1] = v18;
        result = (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t, char *))(a4 + 16))(a4, v13, 1, &v19);
        if (!v19 && ++v12 != v6)
          continue;
        return result;
      }
      ++v12;
    }
    while (v12 != v6 && !v19);
  }
  return result;
}

void objc_visitor::Visitor::forEachClass(unsigned int *a1, uint64_t a2)
{
  _QWORD v2[5];

  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = ___ZN12objc_visitor7Visitor12forEachClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke;
  v2[3] = &unk_1E4F7E558;
  v2[4] = a2;
  objc_visitor::Visitor::forEachClass(a1, 0, (uint64_t)v2);
}

uint64_t ___ZN12objc_visitor7Visitor12forEachClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void objc_visitor::Visitor::forEachCategory(unsigned int *a1, uint64_t a2)
{
  uint64_t v4;
  char v5;
  const char *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v15;
  __int128 v16;
  uint64_t v17;
  char v18;
  __int128 v19;
  uint64_t v20;
  uint64_t *v21[3];
  _BYTE v22[24];
  unint64_t v23;
  char v24;
  __int16 v25;

  v4 = 0;
  v25 = 256;
  do
  {
    v5 = *((_BYTE *)&v25 + v4);
    if (v5)
      v6 = "__objc_catlist2";
    else
      v6 = "__objc_catlist";
    objc_visitor::Visitor::findSection((uint64_t)a1, (uint64_t)objc_visitor::Visitor::findObjCDataSection(char const*)const::objcDataSegments, 3, (uint64_t)v6, (uint64_t)v22);
    if (v24)
    {
      v7 = v23;
      v8 = *a1;
      v9 = v23 / v8;
      if (v23 % v8)
        objc_visitor::Visitor::forEachCategory();
      v10 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v22);
      if (v7 >= v8)
      {
        v11 = v10;
        v12 = 0;
        v13 = v9 - 1;
        do
        {
          metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v11 + v12 * *a1), v21);
          metadata_visitor::Visitor::resolveRebase((uint64_t)a1, v21, &v19);
          v16 = v19;
          v17 = v20;
          v18 = v5;
          v15 = 0;
          (*(void (**)(uint64_t, __int128 *, char *))(a2 + 16))(a2, &v16, &v15);
          if (v15)
            break;
        }
        while (v13 != v12++);
      }
    }
    ++v4;
  }
  while (v4 != 2);
}

void objc_visitor::Visitor::forEachProtocol(unsigned int *a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t *v17[3];
  _BYTE v18[24];
  unint64_t v19;
  char v20;

  objc_visitor::Visitor::findSection((uint64_t)a1, (uint64_t)objc_visitor::Visitor::findObjCDataSection(char const*)const::objcDataSegments, 3, (uint64_t)"__objc_protolist", (uint64_t)v18);
  if (v20)
  {
    v4 = v19;
    v5 = *a1;
    v6 = v19 / v5;
    if (v19 % v5)
      objc_visitor::Visitor::forEachProtocol();
    v7 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v18);
    if (v4 >= v5)
    {
      v8 = v7;
      v9 = 0;
      v10 = v6 - 1;
      do
      {
        metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v8 + v9 * *a1), v17);
        metadata_visitor::Visitor::resolveRebase((uint64_t)a1, v17, &v15);
        v13 = v15;
        v14 = v16;
        v12 = 0;
        (*(void (**)(uint64_t, __int128 *, char *))(a2 + 16))(a2, &v13, &v12);
        if (v12)
          break;
      }
      while (v10 != v9++);
    }
  }
}

void metadata_visitor::SwiftVisitor::forEachProtocolConformance(metadata_visitor::SwiftVisitor *a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  BOOL v6;
  char v7;
  _QWORD v8[3];
  _BYTE v9[32];
  int v10;

  metadata_visitor::SwiftVisitor::getSwiftConformances(a1, (uint64_t)v9);
  if (v10)
  {
    v4 = 0;
    v5 = v10 - 1;
    do
    {
      metadata_visitor::SwiftConformanceList::getConformance((metadata_visitor::SwiftConformanceList *)v9, a1, v4, v8);
      v7 = 0;
      (*(void (**)(uint64_t, _QWORD *, char *))(a2 + 16))(a2, v8, &v7);
      if (v7)
        v6 = 1;
      else
        v6 = v5 == v4;
      ++v4;
    }
    while (!v6);
  }
}

void metadata_visitor::SwiftVisitor::getSwiftConformances(metadata_visitor::SwiftVisitor *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v3;
  char v4;
  __int128 v5;
  uint64_t v6;
  unint64_t v7;
  unsigned __int8 v8;

  metadata_visitor::SwiftVisitor::findSection(this, "__TEXT", "__swift5_proto", (uint64_t)&v5);
  LODWORD(v3) = v8;
  if (v8)
  {
    if ((v7 & 3) != 0)
      metadata_visitor::SwiftVisitor::getSwiftConformances();
    v3 = v7 >> 2;
    *(_OWORD *)a2 = v5;
    *(_QWORD *)(a2 + 16) = v6;
    v4 = 1;
  }
  else
  {
    v4 = 0;
    *(_BYTE *)a2 = 0;
  }
  *(_BYTE *)(a2 + 24) = v4;
  *(_DWORD *)(a2 + 32) = v3;
}

uint64_t metadata_visitor::SwiftConformanceList::getConformance@<X0>(metadata_visitor::SwiftConformanceList *this@<X0>, const metadata_visitor::Visitor *a2@<X1>, unsigned int a3@<W2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  char v10;

  v8 = *(int *)(lsl::Allocator::Pool::allocator(this) + 4 * a3);
  v9 = metadata_visitor::ResolvedValue::vmAddress(this);
  if (!v10)
    std::__throw_bad_optional_access[abi:nn180100]();
  return metadata_visitor::Visitor::getValueFor((uint64_t)a2, v8 + 4 * a3 + v9, 1, a4);
}

void metadata_visitor::SwiftVisitor::findSection(metadata_visitor::SwiftVisitor *this@<X0>, const char *a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  _DWORD *v5;
  uint64_t *v6;
  __int128 v7;
  _QWORD v8[8];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  __n128 (*v12)(uint64_t, uint64_t);
  uint64_t (*v13)();
  char v14;
  char v15;

  v5 = (_DWORD *)*((_QWORD *)this + 1);
  v9 = 0;
  v10 = &v9;
  v11 = 0x5002000000;
  v12 = __Block_byref_object_copy__12;
  v13 = __Block_byref_object_dispose__12;
  v14 = 0;
  v15 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK16metadata_visitor12SwiftVisitor11findSectionEPKcS2__block_invoke;
  v8[3] = &unk_1E4F7E5D0;
  v8[6] = a2;
  v8[7] = a3;
  v8[4] = &v9;
  v8[5] = this;
  dyld3::MachOFile::forEachSection(v5, (uint64_t)v8);
  v6 = v10;
  v7 = *(_OWORD *)(v10 + 7);
  *(_OWORD *)a4 = *(_OWORD *)(v10 + 5);
  *(_OWORD *)(a4 + 16) = v7;
  *(_QWORD *)(a4 + 32) = v6[9];
  _Block_object_dispose(&v9, 8);
}

__n128 __Block_byref_object_copy__12(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 40);
  v3 = *(_OWORD *)(a2 + 56);
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

double ___ZNK16metadata_visitor12SwiftVisitor11findSectionEPKcS2__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v7;
  double result;
  uint64_t v9;
  uint64_t Slide;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;

  v7 = *(_QWORD *)(a1 + 40);
  if (!_platform_strcmp(*(const char **)(a2 + 40), *(const char **)(a1 + 48))
    && !_platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 56)))
  {
    v9 = *(_QWORD *)(a2 + 64);
    Slide = dyld3::MachOLoaded::getSlide(*(dyld3::MachOLoaded **)(v7 + 8));
    metadata_visitor::ResolvedValue::ResolvedValue(&v13, Slide + v9, *(_QWORD *)(a2 + 64), 1);
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v12 = v14;
    result = *(double *)&v13;
    *(_OWORD *)(v11 + 40) = v13;
    *(_QWORD *)(v11 + 56) = v12;
    *(_QWORD *)(v11 + 64) = 0;
    *(_BYTE *)(v11 + 72) = 1;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 64) = *(_QWORD *)(a2 + 72);
    *a4 = 1;
  }
  return result;
}

uint64_t metadata_visitor::SwiftConformance::getProtocolPointer@<X0>(metadata_visitor::SwiftConformance *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  char *v5;
  __int128 v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;

  v5 = (char *)lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, &v9);
  v7 = v9;
  v8 = v10;
  return metadata_visitor::SwiftConformance::SwiftRelativePointer::getTargetPointer((metadata_visitor::SwiftConformance::SwiftRelativePointer *)&v7, a2, a3);
}

uint64_t metadata_visitor::SwiftConformance::SwiftRelativePointer::getTargetPointer@<X0>(metadata_visitor::SwiftConformance::SwiftRelativePointer *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  int v6;
  uint64_t v7;
  char v8;
  char v9;

  v6 = *(_DWORD *)lsl::Allocator::Pool::allocator(this);
  v7 = metadata_visitor::ResolvedValue::vmAddress(this);
  if ((v6 & 1) != 0)
  {
    if (v8)
    {
      v9 = 0;
      v6 &= ~1u;
      goto LABEL_6;
    }
LABEL_7:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  if (!v8)
    goto LABEL_7;
  v9 = 1;
LABEL_6:
  *(_BYTE *)a3 = v9;
  return metadata_visitor::Visitor::getValueFor((uint64_t)a2, v7 + v6, 1, (_QWORD *)(a3 + 8));
}

uint64_t metadata_visitor::SwiftConformance::getProtocolConformanceFlags@<X0>(metadata_visitor::SwiftConformance *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, _QWORD *a3@<X8>)
{
  char *v5;

  v5 = (char *)(lsl::Allocator::Pool::allocator(this) + 12);
  return metadata_visitor::Visitor::getField((uint64_t)a2, v5, a3);
}

double metadata_visitor::SwiftConformance::getTypeRef@<D0>(metadata_visitor::SwiftConformance *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  double result;
  _QWORD v10[3];
  __int128 v11;
  uint64_t v12;

  v6 = lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, (char *)(v6 + 4), &v11);
  v7 = lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, (char *)(v7 + 12), v10);
  v8 = (*(_DWORD *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v10) >> 3) & 7;
  result = *(double *)&v11;
  *(_OWORD *)a3 = v11;
  *(_QWORD *)(a3 + 16) = v12;
  *(_DWORD *)(a3 + 24) = v8;
  return result;
}

uint64_t metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags::typeReferenceKind(metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags *this)
{
  return (*(_DWORD *)lsl::Allocator::Pool::allocator(this) >> 3) & 7;
}

BOOL metadata_visitor::SwiftConformance::isNull(metadata_visitor::SwiftConformance *this)
{
  return *(_OWORD *)lsl::Allocator::Pool::allocator(this) == 0;
}

uint64_t metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName(metadata_visitor::SwiftConformance::SwiftTypeRefPointer *this, const metadata_visitor::SwiftVisitor *a2)
{
  uint64_t v4;
  uint64_t v5;
  char v6;
  _QWORD v8[3];

  if (*((_DWORD *)this + 6) != 2)
    metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName();
  v4 = *(int *)lsl::Allocator::Pool::allocator(this);
  v5 = metadata_visitor::ResolvedValue::vmAddress(this);
  if (!v6)
    std::__throw_bad_optional_access[abi:nn180100]();
  metadata_visitor::Visitor::getValueFor((uint64_t)a2, v5 + v4, 1, v8);
  return lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v8);
}

metadata_visitor::ResolvedValue *metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getTargetPointer@<X0>(metadata_visitor::ResolvedValue *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  metadata_visitor::ResolvedValue *v5;
  signed int v6;
  uint64_t v7;
  char v8;
  char v9;
  int v10;
  char v11;

  v5 = this;
  switch(*((_DWORD *)this + 6))
  {
    case 0:
    case 2:
      v6 = *(_DWORD *)lsl::Allocator::Pool::allocator(this);
      v7 = metadata_visitor::ResolvedValue::vmAddress(v5);
      if (!v8)
        goto LABEL_7;
      v9 = 1;
      goto LABEL_6;
    case 1:
    case 3:
      v10 = *(_DWORD *)lsl::Allocator::Pool::allocator(this);
      v7 = metadata_visitor::ResolvedValue::vmAddress(v5);
      if (!v11)
LABEL_7:
        std::__throw_bad_optional_access[abi:nn180100]();
      v9 = 0;
      v6 = v10 & 0xFFFFFFFE;
LABEL_6:
      *(_BYTE *)a3 = v9;
      this = (metadata_visitor::ResolvedValue *)metadata_visitor::Visitor::getValueFor((uint64_t)a2, v7 + v6, 1, (_QWORD *)(a3 + 8));
      break;
    default:
      return this;
  }
  return this;
}

BOOL metadata_visitor::SwiftConformance::TypeContextDescriptor::isForeignMetadata(metadata_visitor::SwiftConformance::TypeContextDescriptor *this)
{
  return (*(_DWORD *)lsl::Allocator::Pool::allocator(this) & 0x30000) == 0x20000;
}

uint64_t metadata_visitor::SwiftConformance::TypeContextDescriptor::hasImportInfo(metadata_visitor::SwiftConformance::TypeContextDescriptor *this)
{
  return (*(unsigned __int8 *)(lsl::Allocator::Pool::allocator(this) + 2) >> 2) & 1;
}

uint64_t metadata_visitor::SwiftConformance::TypeContextDescriptor::getName@<X0>(metadata_visitor::SwiftConformance::TypeContextDescriptor *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  _QWORD v10[3];

  v5 = lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, (char *)(v5 + 8), v10);
  v6 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v10);
  v7 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v10);
  if (!v8)
    std::__throw_bad_optional_access[abi:nn180100]();
  return metadata_visitor::Visitor::getValueFor((uint64_t)a2, v7 + v6, 1, a3);
}

uint64_t dyld3::fstatat(dyld3 *this, const char *a2, stat *a3, stat *a4)
{
  int v4;
  const char *v5;
  const char *v6;
  int v7;
  uint64_t result;

  v4 = (int)a4;
  v5 = (const char *)a3;
  v6 = a2;
  v7 = (int)this;
  while (1)
  {
    result = fstatat64((int)this, a2, a3, (int)a4);
    if ((_DWORD)result != -1)
      break;
    if (*__error() != 35 && *__error() != 4)
      return 0xFFFFFFFFLL;
    LODWORD(this) = v7;
    a2 = v6;
    a3 = (stat *)v5;
    LODWORD(a4) = v4;
  }
  return result;
}

BOOL dyld3::FatFile::isValidSlice(dyld3::FatFile *this, vm_address_t *a2, unint64_t a3, unsigned int a4, int a5, int a6, unint64_t a7, unint64_t a8)
{
  char *v12;
  _BOOL8 result;
  int v14;
  uint64_t v15;

  if (a3 < a7 || a3 - a7 < a8)
  {
    Diagnostics::error(a2, "slice %d extends beyond end of file");
  }
  else
  {
    v12 = (char *)this + a7;
    result = dyld3::MachOFile::isMachO((dyld3::FatFile *)((char *)this + a7), a2, a8);
    if (!result)
      return result;
    if (*((_DWORD *)v12 + 1) == a5)
    {
      v14 = *((_DWORD *)v12 + 2);
      if (((v14 ^ a6) & 0xFFFFFF) != 0)
      {
        Diagnostics::error(a2, "cpu subtype in slice (0x%08X) does not match fat header (0x%08X)");
      }
      else
      {
        if (a5 == 33554444 || a5 == 16777228 || (v15 = 4095, a5 == 12) && v14 == 12 && *((_DWORD *)v12 + 3) != 11)
          v15 = 0x3FFFLL;
        if ((v15 & a7) == 0)
          return 1;
        if (_platform_strncmp(v12, "!<arch>", 7uLL))
          Diagnostics::error(a2, "slice is not page aligned");
        else
          Diagnostics::error(a2, "file is static library");
      }
    }
    else
    {
      Diagnostics::error(a2, "cpu type in slice (0x%08X) does not match fat header (0x%08X)");
    }
  }
  return 0;
}

void dyld3::FatFile::forEachSlice(dyld3::FatFile *this, vm_address_t *a2, unint64_t a3, int a4, uint64_t a5)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char *v27;
  _DWORD *v28;
  uint64_t v29;
  unint64_t v31;
  unint64_t v32;
  unsigned int v33;
  char v38;
  vm_address_t *v39;
  char v40;

  if (*(_DWORD *)this == -1078264118)
  {
    v10 = *((_DWORD *)this + 1);
    v11 = bswap32(v10);
    if (v11 >= 0x80)
    {
      Diagnostics::error(a2, "fat header too large: %u entries", v11);
      return;
    }
    if (((32 * v11) | 8uLL) <= a3)
    {
      v38 = 0;
      if (v10)
      {
        v19 = 0;
        v20 = v11 - 1;
        v21 = (char *)this + 12;
        do
        {
          v22 = bswap32(*((_DWORD *)v21 - 1));
          v23 = bswap32(*(_DWORD *)v21);
          v24 = bswap64(*(_QWORD *)(v21 + 4));
          v25 = bswap64(*(_QWORD *)(v21 + 12));
          if (!a4 || dyld3::FatFile::isValidSlice(this, a2, a3, v19, v22, v23, v24, v25))
            (*(void (**)(uint64_t, uint64_t, uint64_t, char *, unint64_t, char *))(a5 + 16))(a5, v22, v23, (char *)this + v24, v25, &v38);
          if (v38)
            break;
          v21 += 32;
        }
        while (v20 != v19++);
      }
      return;
    }
LABEL_21:
    Diagnostics::error(a2, "fat header malformed, architecture slices extend beyond end of file");
    return;
  }
  if (*(_DWORD *)this != -1095041334)
  {
    Diagnostics::error(a2, "not a fat file");
    return;
  }
  v8 = *((_DWORD *)this + 1);
  v9 = bswap32(v8);
  if (v9 >= 0xCD)
  {
    Diagnostics::error(a2, "fat header too large: %u entries", v9);
    return;
  }
  if (20 * (unint64_t)(v9 + 1) + 8 > a3)
    goto LABEL_21;
  v40 = 0;
  if (!v8)
    goto LABEL_34;
  v33 = v8;
  v12 = 0;
  v13 = (unsigned int *)((char *)this + 20);
  while (1)
  {
    v14 = bswap32(*(v13 - 3));
    v15 = bswap32(*(v13 - 2));
    v16 = bswap32(*(v13 - 1));
    v17 = bswap32(*v13);
    Diagnostics::Diagnostics((Diagnostics *)&v39);
    if (!a4 || dyld3::FatFile::isValidSlice(this, (vm_address_t *)&v39, a3, v12, v14, v15, v16, v17))
      (*(void (**)(uint64_t, uint64_t, uint64_t, char *, unint64_t, char *))(a5 + 16))(a5, v14, v15, (char *)this + v16, v17, &v40);
    if (v40)
      break;
    if (Diagnostics::hasError((Diagnostics *)&v39))
    {
      v18 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v39);
      Diagnostics::appendError(a2, "%s, ", v18);
    }
    v13 += 5;
    mach_o::Error::~Error(&v39);
    if (v9 == ++v12)
      goto LABEL_33;
  }
  mach_o::Error::~Error(&v39);
LABEL_33:
  if (v33 != -872415232)
  {
LABEL_34:
    v27 = (char *)this + 8;
    v28 = (_DWORD *)((char *)this + 20 * v9 + 8);
    v29 = bswap32(v28[1]);
    if (*v28 == 201326593 && v29 <= 1)
    {
      v31 = bswap32(*(_DWORD *)&v27[20 * v9 + 12]);
      v32 = bswap32(*(_DWORD *)&v27[20 * v9 + 8]);
      if (!a4 || dyld3::FatFile::isValidSlice(this, a2, a3, v9, 16777228, v29, v32, v31))
        (*(void (**)(uint64_t, uint64_t, uint64_t, char *, unint64_t, char *))(a5 + 16))(a5, 16777228, v29, (char *)this + v32, v31, &v40);
    }
  }
}

void dyld3::FatFile::forEachSlice(dyld3::FatFile *a1, vm_address_t *a2, unint64_t a3, uint64_t a4)
{
  dyld3::FatFile::forEachSlice(a1, a2, a3, 1, a4);
}

char *dyld3::FatFile::archNames(dyld3::FatFile *this, char *a2, unint64_t a3)
{
  _QWORD v7[6];
  _QWORD v8[3];
  char v9;
  vm_address_t *v10;

  *a2 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v10);
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  v9 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld37FatFile9archNamesEPcy_block_invoke;
  v7[3] = &unk_1E4F7E5F8;
  v7[4] = v8;
  v7[5] = a2;
  dyld3::FatFile::forEachSlice(this, (vm_address_t *)&v10, a3, 0, (uint64_t)v7);
  _Block_object_dispose(v8, 8);
  mach_o::Error::~Error(&v10);
  return a2;
}

size_t ___ZNK5dyld37FatFile9archNamesEPcy_block_invoke(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  const char *v7;
  size_t result;

  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    strlcat(*(char **)(a1 + 40), ",", 0x100uLL);
  v6 = 0;
  v7 = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v6 + 1]) != a2
       || (a3 & 0xFFFFFF) != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v6 + 3))
  {
    v6 += 2;
    if (v6 == 26)
      goto LABEL_9;
  }
  v7 = (&dyld3::MachOFile::_s_archInfos)[v6];
LABEL_9:
  result = strlcat(*(char **)(a1 + 40), v7, 0x100uLL);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  return result;
}

BOOL dyld3::FatFile::isFatFileWithSlice(dyld3::FatFile *this, vm_address_t *a2, unint64_t a3, const dyld3::GradedArchs *a4, char a5, unint64_t *a6, unint64_t *a7, BOOL *a8)
{
  BOOL hasError;
  _BOOL8 v11;
  int v12;
  _QWORD v14[9];
  char v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  int v19;

  *a8 = 0;
  if ((*(_DWORD *)this | 0x1000000) != 0xBFBAFECA)
    return 0;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = ___ZNK5dyld37FatFile18isFatFileWithSliceER11DiagnosticsyRKNS_11GradedArchsEbRyS6_Rb_block_invoke;
  v14[3] = &unk_1E4F7E620;
  v15 = a5;
  v14[4] = &v16;
  v14[5] = this;
  v14[6] = a4;
  v14[7] = a6;
  v14[8] = a7;
  dyld3::FatFile::forEachSlice(this, a2, a3, 1, (uint64_t)v14);
  hasError = Diagnostics::hasError((Diagnostics *)a2);
  v11 = 0;
  if (!hasError)
  {
    v12 = *((_DWORD *)v17 + 6);
    if (!v12)
      *a8 = 1;
    v11 = v12 != 0;
  }
  _Block_object_dispose(&v16, 8);
  return v11;
}

uint64_t ___ZNK5dyld37FatFile18isFatFileWithSliceER11DiagnosticsyRKNS_11GradedArchsEbRyS6_Rb_block_invoke(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;

  v8 = *(_QWORD *)(a1 + 40);
  result = dyld3::GradedArchs::grade(*(dyld3::GradedArchs **)(a1 + 48), a2, a3, *(_BYTE *)(a1 + 72));
  if ((_DWORD)result)
  {
    if ((int)result > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    {
      v10 = *(_QWORD **)(a1 + 64);
      **(_QWORD **)(a1 + 56) = a4 - v8;
      *v10 = a5;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    }
  }
  return result;
}

uint64_t dyld3::GradedArchs::forEachArch(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t i;
  int v7;
  BOOL v8;
  uint64_t v9;
  const char *v10;

  v5 = result;
  for (i = 0; i != 4; ++i)
  {
    v7 = *(_DWORD *)(v5 + 12 * i);
    if (!v7)
      break;
    if (*(_BYTE *)(v5 + 12 * i + 8))
      v8 = a2 == 0;
    else
      v8 = 0;
    if (!v8)
    {
      v9 = 0;
      while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v9 + 1]) != v7
           || (*(_DWORD *)(v5 + 12 * i + 4) & 0xFFFFFF) != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v9 + 3))
      {
        v9 += 2;
        if (v9 == 26)
        {
          v10 = "unknown";
          goto LABEL_13;
        }
      }
      v10 = (&dyld3::MachOFile::_s_archInfos)[v9];
LABEL_13:
      result = (*(uint64_t (**)(uint64_t, const char *))(a3 + 16))(a3, v10);
    }
  }
  return result;
}

uint64_t dyld3::MachOFile::maskedCpuSubtype(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 2) & 0xFFFFFF;
}

_QWORD *dyld3::MachOFile::packedVersionToString(dyld3::MachOFile *this, _BYTE *a2, char *a3)
{
  __int16 v3;
  _BYTE *v4;
  _QWORD *result;
  _BYTE *v6;
  _BYTE *v7;

  v3 = (__int16)this;
  v7 = a2;
  dyld3::appendNumber(&v7, (char **)(this >> 16));
  v4 = v7;
  *v7 = 46;
  v7 = v4 + 1;
  result = dyld3::appendNumber(&v7, (char **)HIBYTE(v3));
  if ((_BYTE)v3)
  {
    v6 = v7;
    *v7 = 46;
    v7 = v6 + 1;
    result = dyld3::appendNumber(&v7, (char **)v3);
  }
  *v7 = 0;
  return result;
}

_QWORD *dyld3::appendNumber(_QWORD *this, char **a2)
{
  _BYTE *v2;
  _BYTE *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;

  if (a2 >> 4 > 0x270)
  {
    v3 = (_BYTE *)(*this)++;
    *v3 = a2 / 0x2710 + 48;
    LODWORD(a2) = a2 % 0x2710;
    if (a2 < 0x3E8)
    {
      v4 = (_BYTE *)(*this)++;
      *v4 = 48;
      goto LABEL_10;
    }
LABEL_9:
    v5 = (_BYTE *)(*this)++;
    *v5 = a2 / 0x3E8 + 48;
    LODWORD(a2) = a2 % 0x3E8;
LABEL_10:
    if (a2 < 0x64)
    {
      v6 = (_BYTE *)(*this)++;
      *v6 = 48;
      goto LABEL_13;
    }
LABEL_12:
    v7 = (_BYTE *)(*this)++;
    *v7 = a2 / 0x64 + 48;
    LODWORD(a2) = a2 % 0x64;
LABEL_13:
    if (a2 < 0xA)
    {
      v8 = (_BYTE *)(*this)++;
      *v8 = 48;
      if (!(_DWORD)a2)
        goto LABEL_6;
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  if (a2 >= 0x3E8)
    goto LABEL_9;
  if (a2 > 0x63)
    goto LABEL_12;
  if (a2 >= 0xA)
  {
LABEL_16:
    v9 = (_BYTE *)(*this)++;
    *v9 = a2 / 0xA + 48;
    LODWORD(a2) = a2 % 0xA;
    if (!(_DWORD)a2)
      goto LABEL_6;
    goto LABEL_17;
  }
  if (!(_DWORD)a2)
  {
LABEL_6:
    v2 = (_BYTE *)(*this)++;
    *v2 = 48;
    return this;
  }
LABEL_17:
  v10 = (_BYTE *)(*this)++;
  *v10 = (_BYTE)a2 + 48;
  return this;
}

BOOL dyld3::MachOFile::isFileSet(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 12;
}

const char *dyld3::MachOFile::platformName(int a1)
{
  uint64_t v2;
  const char *result;

  v2 = 0;
  result = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_platformInfos)[v2 + 1]) != a1)
  {
    v2 += 2;
    if (v2 == 48)
      return result;
  }
  return (&dyld3::MachOFile::_s_platformInfos)[v2];
}

_DWORD *dyld3::MachOFile::isMachO(_DWORD *this, const void *a2)
{
  if (*this >> 1 != 2138504551)
    return 0;
  return this;
}

thread_command dyld3::MachOFile::entryAddrFromThreadCmd(dyld3::MachOFile *this, const thread_command *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v5;
  const thread_command *v6;

  if (a2->cmd != 5)
    dyld3::MachOFile::entryAddrFromThreadCmd();
  v2 = 0;
  v3 = *((_DWORD *)this + 1);
  if (v3 <= 16777222)
  {
    if (v3 == 7)
    {
      v5 = 10;
    }
    else
    {
      if (v3 != 12)
        return (thread_command)v2;
      v5 = 15;
    }
  }
  else if (v3 == 33554444 || v3 == 16777228)
  {
    v5 = 32;
  }
  else
  {
    if (v3 != 16777223)
      return (thread_command)v2;
    v5 = 16;
  }
  v6 = a2 + 2;
  if (*(_DWORD *)this == -17958193 || dyld3::MachOFile::isArch(this, "arm64_32"))
    return v6[v5];
  else
    return (thread_command)*(&v6->cmd + v5);
}

uint64_t dyld3::MachOFile::usesWeakDefs(dyld3::MachOFile *this)
{
  return *((_BYTE *)this + 26) & 1;
}

uint64_t dyld3::MachOFile::hasInterposingTuples(dyld3::MachOFile *this)
{
  int v2;
  uint64_t v3;
  _QWORD v5[5];
  vm_address_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;
  _QWORD v11[7];
  int v12;
  int v13;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v6);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile20hasInterposingTuplesEv_block_invoke;
  v5[3] = &unk_1E4F7EB10;
  v5[4] = &v7;
  if (*(_DWORD *)this == -17958193)
    v2 = 8;
  else
    v2 = 4;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = ___ZNK5dyld39MachOFile25forEachInterposingSectionER11DiagnosticsU13block_pointerFvyyRbE_block_invoke;
  v11[3] = &unk_1E4F7EAC0;
  v11[5] = this;
  v11[6] = &v6;
  v12 = 2 * v2;
  v13 = v2;
  v11[4] = v5;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v11);
  v3 = *((unsigned __int8 *)v8 + 24);
  mach_o::Error::~Error(&v6);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t ___ZNK5dyld39MachOFile20hasInterposingTuplesEv_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  *a4 = 1;
  return result;
}

uint64_t dyld3::MachOFile::allowsAlternatePlatform(dyld3::MachOFile *this)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile23allowsAlternatePlatformEv_block_invoke;
  v3[3] = &unk_1E4F7EB88;
  v3[4] = &v4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t ___ZNK5dyld39MachOFile23allowsAlternatePlatformEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result;

  result = _platform_strcmp(*(const char **)(a2 + 80), "__allow_alt_plat");
  if (!(_DWORD)result)
  {
    result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

int *dyld3::MachOFile::compatibleSlice(vm_address_t *a1, unint64_t *a2, dyld3::FatFile *this, unint64_t a4, const char *a5, unsigned int a6, int a7, dyld3::GradedArchs *a8, unsigned __int8 a9)
{
  int *v14;
  unsigned int v17;
  uint64_t v18;
  const char *v19;
  uint64_t i;
  uint64_t v22;
  const char *v23;
  _QWORD v24[5];
  BOOL v25;
  unint64_t v26;
  unint64_t v27;
  char v28[8];
  uint64_t v29;
  size_t (*v30)(uint64_t, char *);
  void *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  int v36;

  v14 = (int *)this;
  v17 = *(_DWORD *)this;
  if ((*(_DWORD *)this | 0x1000000) == 0xBFBAFECA)
  {
    v26 = 0;
    v27 = 0;
    if (!dyld3::FatFile::isFatFileWithSlice(this, a1, a4, a8, a7, &v27, &v26, &v25))
    {
      LOBYTE(v33) = 0;
      *(_QWORD *)v28 = _NSConcreteStackBlock;
      v29 = 0x40000000;
      v30 = ___ZN5dyld3L12getArchNamesERKNS_11GradedArchsEbPc_block_invoke;
      v31 = &__block_descriptor_tmp_211;
      v32 = &v33;
      dyld3::GradedArchs::forEachArch((uint64_t)a8, a7, (uint64_t)v28);
      dyld3::FatFile::archNames((dyld3::FatFile *)v14, v28, a4);
      Diagnostics::error(a1, "fat file, but missing compatible architecture (have '%s', need '%s')");
      return 0;
    }
    v14 = (int *)((char *)v14 + v27);
    *a2 = v26;
    v17 = *v14;
  }
  else
  {
    *a2 = a4;
  }
  if (v17 >> 1 != 2138504551 || !dyld3::MachOFile::isMachO((dyld3::MachOFile *)v14, a1, a4))
  {
    if (Diagnostics::noError((Diagnostics *)a1))
      Diagnostics::error(a1, "not a mach-o file");
    return 0;
  }
  if (!dyld3::GradedArchs::grade(a8, v14[1], v14[2], a7))
  {
    LOBYTE(v33) = 0;
    *(_QWORD *)v28 = _NSConcreteStackBlock;
    v29 = 0x40000000;
    v30 = ___ZN5dyld3L12getArchNamesERKNS_11GradedArchsEbPc_block_invoke;
    v31 = &__block_descriptor_tmp_211;
    v32 = &v33;
    dyld3::GradedArchs::forEachArch((uint64_t)a8, a7, (uint64_t)v28);
    for (i = 0; i != 26; i += 2)
    {
      if (LODWORD((&dyld3::MachOFile::_s_archInfos)[i + 1]) == v14[1]
        && (v14[2] & 0xFFFFFF) == *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * i + 3))
      {
        break;
      }
    }
    Diagnostics::error(a1, "mach-o file, but is an incompatible architecture (have '%s', need '%s')");
    return 0;
  }
  if ((dyld3::MachOFile::loadableIntoProcess(v14, a6, a5, a9) & 1) == 0)
  {
    v33 = 0;
    v34 = &v33;
    v35 = 0x2000000000;
    v36 = 0;
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000;
    v24[2] = ___ZN5dyld39MachOFile15compatibleSliceER11DiagnosticsRyPKvmPKcNS_8PlatformEbRKNS_11GradedArchsEb_block_invoke;
    v24[3] = &unk_1E4F7EBB0;
    v24[4] = &v33;
    dyld3::MachOFile::forEachSupportedPlatform(v14, (uint64_t)v24);
    v18 = 0;
    v19 = "unknown";
    while (LODWORD((&dyld3::MachOFile::_s_platformInfos)[v18 + 1]) != *((_DWORD *)v34 + 6))
    {
      v18 += 2;
      if (v18 == 48)
        goto LABEL_24;
    }
    v19 = (&dyld3::MachOFile::_s_platformInfos)[v18];
LABEL_24:
    v22 = 0;
    v23 = "unknown";
    while (LODWORD((&dyld3::MachOFile::_s_platformInfos)[v22 + 1]) != a6)
    {
      v22 += 2;
      if (v22 == 48)
        goto LABEL_29;
    }
    v23 = (&dyld3::MachOFile::_s_platformInfos)[v22];
LABEL_29:
    Diagnostics::error(a1, "mach-o file (%s), but incompatible platform (have '%s', need '%s')", a5, v19, v23);
    _Block_object_dispose(&v33, 8);
    return 0;
  }
  return v14;
}

uint64_t ___ZN5dyld39MachOFile15compatibleSliceER11DiagnosticsRyPKvmPKcNS_8PlatformEbRKNS_11GradedArchsEb_block_invoke(uint64_t result, int a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
  return result;
}

uint64_t dyld3::MachOFile::getFixupsLoadCommandFileOffset(dyld3::MachOFile *this)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  vm_address_t *v9;

  Diagnostics::Diagnostics((Diagnostics *)&v9);
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile30getFixupsLoadCommandFileOffsetEv_block_invoke;
  v4[3] = &unk_1E4F7EC78;
  v4[4] = &v5;
  v4[5] = this;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v9, (uint64_t)v4);
  v2 = 0;
  if (!Diagnostics::hasError((Diagnostics *)&v9))
    v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  mach_o::Error::~Error(&v9);
  return v2;
}

uint64_t ___ZNK5dyld39MachOFile30getFixupsLoadCommandFileOffsetEv_block_invoke(uint64_t result, int *a2)
{
  int v2;
  BOOL v3;

  v2 = *a2;
  if (*a2 == -2147483614 || (v2 != 34 ? (v3 = v2 == -2147483596) : (v3 = 1), v3))
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = (_DWORD)a2 - *(_DWORD *)(result + 40);
  return result;
}

BOOL dyld3::MachOFile::hasInitializer(dyld3::MachOFile *this, vm_address_t *a2)
{
  _BOOL8 v4;
  _QWORD v6[5];
  _QWORD v7[5];
  _QWORD v8[5];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke;
  v8[3] = &unk_1E4F7ECA0;
  v8[4] = &v9;
  dyld3::MachOFile::forEachLoadCommand(this, a2, (uint64_t)v8);
  if (*((_BYTE *)v10 + 24)
    || (v7[0] = _NSConcreteStackBlock,
        v7[1] = 0x40000000,
        v7[2] = ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_2,
        v7[3] = &unk_1E4F7ECC8,
        v7[4] = &v9,
        dyld3::MachOFile::forEachInitializerPointerSection(this, (uint64_t)a2, (uint64_t)v7),
        *((_BYTE *)v10 + 24)))
  {
    v4 = 1;
  }
  else
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_3;
    v6[3] = &unk_1E4F7ECF0;
    v6[4] = &v9;
    dyld3::MachOFile::forEachSection(this, (uint64_t)v6);
    v4 = *((_BYTE *)v10 + 24) != 0;
  }
  _Block_object_dispose(&v9, 8);
  return v4;
}

uint64_t ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke(uint64_t result, _DWORD *a2, _BYTE *a3)
{
  if (*a2 == 26 || *a2 == 17)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  *a4 = 1;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_3(uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  if (*(_BYTE *)(a2 + 92) == 22)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
    *a4 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke_2(uint64_t result, int a2, uint64_t a3, unsigned int a4)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  if (a2 == 1 && a4 >> 8 <= 0xA08)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = 1;
  return result;
}

uint64_t dyld3::MachOFile::forEachCodeDirectoryBlob(uint64_t result, _DWORD *a2, unint64_t a3, uint64_t a4)
{
  unsigned int v5;
  unint64_t v6;
  uint64_t v9;
  uint64_t (*v10)(dyld3 *, const CS_CodeDirectory *);
  _DWORD *v11;
  int v12;
  unsigned int *v13;
  int v14;
  BOOL v15;
  unint64_t v16;
  _DWORD *v17;
  unsigned int v18;
  uint64_t (*v19)(dyld3 *, const CS_CodeDirectory *);

  if (a3 >= 0xC && *a2 == -1072898310)
  {
    v5 = a2[2];
    v6 = bswap32(v5);
    if (v6 <= (a3 - 12) >> 3)
    {
      v9 = result;
      result = dyld3::MachOFile::builtForPlatform((_DWORD *)result, 4, 0);
      v10 = dyld3::hash_rank;
      if ((_DWORD)result)
        v10 = dyld3::hash_rank_watchOS_dylibs;
      v19 = v10;
      if (v5)
      {
        v11 = 0;
        if (*(_DWORD *)(v9 + 12) == 2)
          v12 = result;
        else
          v12 = 0;
        v13 = a2 + 4;
        do
        {
          v14 = *(v13 - 1);
          if (v14)
            v15 = (v14 - 0x100000) > 0x5000000;
          else
            v15 = 0;
          if (!v15)
          {
            v16 = bswap32(*v13);
            if (a3 - 88 >= v16)
            {
              v17 = (_DWORD *)((char *)a2 + v16);
              if (a3 - v16 >= bswap32(*(_DWORD *)((char *)a2 + v16 + 4)))
              {
                if (v12)
                {
                  result = (*(uint64_t (**)(uint64_t, _DWORD *))(a4 + 16))(a4, v17);
                }
                else if (*v17 == 34397946)
                {
                  if (!v11
                    || (v18 = ((uint64_t (*)(_DWORD *))v19)(v17),
                        result = ((uint64_t (*)(_DWORD *))v19)(v11),
                        v18 > result))
                  {
                    v11 = v17;
                  }
                }
              }
            }
          }
          v13 += 2;
          --v6;
        }
        while (v6);
        if (v11)
          return (*(uint64_t (**)(uint64_t, _DWORD *))(a4 + 16))(a4, v11);
      }
    }
  }
  return result;
}

uint64_t dyld3::hash_rank_watchOS_dylibs(dyld3 *this, const CS_CodeDirectory *a2)
{
  uint64_t v2;

  v2 = 0;
  while (dyld3::hashPriorities_watchOS_dylibs[v2] != *((unsigned __int8 *)this + 37))
  {
    if (++v2 == 4)
      return 0;
  }
  return (v2 + 1);
}

uint64_t dyld3::hash_rank(dyld3 *this, const CS_CodeDirectory *a2)
{
  uint64_t v2;

  v2 = 0;
  while (dyld3::hashPriorities[v2] != *((unsigned __int8 *)this + 37))
  {
    if (++v2 == 4)
      return 0;
  }
  return (v2 + 1);
}

uint64_t dyld3::MachOFile::forEachCDHashOfCodeSignature(uint64_t a1, _DWORD *a2, unint64_t a3, uint64_t a4)
{
  _QWORD v5[5];

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile28forEachCDHashOfCodeSignatureEPKvmU13block_pointerFvPKhE_block_invoke;
  v5[3] = &unk_1E4F7EE50;
  v5[4] = a4;
  return dyld3::MachOFile::forEachCodeDirectoryBlob(a1, a2, a3, (uint64_t)v5);
}

uint64_t ___ZNK5dyld39MachOFile28forEachCDHashOfCodeSignatureEPKvmU13block_pointerFvPKhE_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  size_t v4;
  int v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  void (**v18)(void *, _QWORD *, __int128 *);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  __int128 v29;
  int v30;
  __int128 v31;
  int v32;

  v3 = result;
  v4 = bswap32(*(_DWORD *)(a2 + 4));
  v5 = *(unsigned __int8 *)(a2 + 37);
  if ((v5 - 2) < 2)
  {
    v6 = ccsha256_di();
  }
  else
  {
    if (v5 == 1)
    {
      v18 = (void (**)(void *, _QWORD *, __int128 *))ccsha1_di();
      __chkstk_darwin((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25, v29);
      v27 = (_QWORD *)((char *)&v29 - v26);
      ccdigest_init(v28, (__int128 *)((char *)&v29 - v26));
      ccdigest_update((uint64_t)v18, v27, v4, (char *)a2);
      v18[7](v18, v27, &v31);
      cc_clear((rsize_t)v18[2] + (_QWORD)v18[1] + 12, v27);
      return (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 32) + 16))();
    }
    if (v5 != 4)
      return result;
    v6 = ccsha384_di();
  }
  v14 = (uint64_t)v6;
  __chkstk_darwin((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13, v29);
  v16 = (_QWORD *)((char *)&v29 - v15);
  ccdigest_init(v17, (__int128 *)((char *)&v29 - v15));
  ccdigest_update(v14, v16, v4, (char *)a2);
  (*(void (**)(uint64_t, _QWORD *, __int128 *))(v14 + 56))(v14, v16, &v29);
  cc_clear(*(_QWORD *)(v14 + 8) + *(_QWORD *)(v14 + 16) + 12, v16);
  v32 = v30;
  v31 = v29;
  return (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 32) + 16))();
}

_DWORD *dyld3::MachOFile::PointerMetaData::PointerMetaData(_DWORD *this)
{
  *this &= 0xF0000000;
  return this;
}

uint64_t dyld3::MachOFile::hasObjCMessageReferences(dyld3::MachOFile *this)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile24hasObjCMessageReferencesEv_block_invoke;
  v3[3] = &unk_1E4F7EF28;
  v3[4] = &v4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t ___ZNK5dyld39MachOFile24hasObjCMessageReferencesEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result;

  result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
  if (!(_DWORD)result)
  {
    result = _platform_strcmp(*(const char **)(a2 + 80), "__objc_msgrefs");
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t dyld3::MachOFile::findObjCDataSection(dyld3::MachOFile *this, const char *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v6;
  _QWORD v8[9];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld39MachOFile19findObjCDataSectionEPKcRyS3__block_invoke;
  v8[3] = &unk_1E4F7EF50;
  v8[4] = &v9;
  v8[5] = a2;
  v8[6] = a3;
  v8[7] = dyld3::MachOFile::preferredLoadAddress(this);
  v8[8] = a4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v8);
  v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

uint64_t ___ZNK5dyld39MachOFile19findObjCDataSectionEPKcRyS3__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  const char *v7;
  uint64_t result;

  v7 = *(const char **)(a2 + 40);
  if (!_platform_strcmp(v7, "__DATA")
    || !_platform_strcmp(v7, "__DATA_CONST")
    || (result = _platform_strcmp(v7, "__DATA_DIRTY"), !(_DWORD)result))
  {
    result = _platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 40));
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      **(_QWORD **)(a1 + 48) = *(_QWORD *)(a2 + 64) - *(_QWORD *)(a1 + 56);
      **(_QWORD **)(a1 + 64) = *(_QWORD *)(a2 + 72);
      *a4 = 1;
    }
  }
  return result;
}

void dyld3::MachOFile::forEachSingletonPatch(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3)
{
  int v5;
  _QWORD v6[7];
  int v7;

  if (*(_DWORD *)a1 == -17958193)
    v5 = 16;
  else
    v5 = 8;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK5dyld39MachOFile21forEachSingletonPatchER11DiagnosticsU13block_pointerFvNS0_18SingletonPatchKindEyE_block_invoke;
  v6[3] = &unk_1E4F7EFA0;
  v7 = v5;
  v6[5] = a2;
  v6[6] = dyld3::MachOFile::preferredLoadAddress(a1);
  v6[4] = a3;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v6);
}

uint64_t ___ZNK5dyld39MachOFile21forEachSingletonPatchER11DiagnosticsU13block_pointerFvNS0_18SingletonPatchKindEyE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;

  result = _platform_strcmp(*(const char **)(a2 + 80), "__const_cfobj2");
  if (!(_DWORD)result)
  {
    *a4 = 1;
    v8 = *(_QWORD *)(a2 + 72);
    v9 = *(unsigned int *)(a1 + 56);
    if (v8 % v9)
    {
      return Diagnostics::error(*(vm_address_t **)(a1 + 40), "Incorrect patching size (%lld).  Should be a multiple of (2 * ptrSize)");
    }
    else if (*(_DWORD *)(a2 + 104) == (_DWORD)v9)
    {
      if (v8)
      {
        v10 = 0;
        do
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
          v10 += *(unsigned int *)(a1 + 56);
        }
        while (v10 != *(_QWORD *)(a2 + 72));
      }
    }
    else
    {
      return Diagnostics::error(*(vm_address_t **)(a1 + 40), "reserved2 is unsupported value %d.  Expected %d");
    }
  }
  return result;
}

size_t ___ZN5dyld3L12getArchNamesERKNS_11GradedArchsEbPc_block_invoke(uint64_t a1, char *__source)
{
  char *v4;

  v4 = *(char **)(a1 + 32);
  if (*v4)
  {
    strlcat(v4, "' or '", 0x100uLL);
    v4 = *(char **)(a1 + 32);
  }
  return strlcat(v4, __source, 0x100uLL);
}

uint64_t dyld3::MachOLoaded::hasExportedSymbol(dyld3::MachOFile *a1, const unsigned __int8 *a2, uint64_t a3, _QWORD *a4, _BYTE *a5)
{
  uint64_t ExportedSymbol;
  dyld3::MachOLoaded *v11;
  _QWORD v13[7];
  int v14;
  dyld3::MachOLoaded *v15;
  uint64_t v16;
  unsigned int v17;
  vm_address_t *v18;

  Diagnostics::Diagnostics((Diagnostics *)&v18);
  ExportedSymbol = dyld3::MachOLoaded::findExportedSymbol(a1, (vm_address_t *)&v18, a2, 0, (uint64_t)&v14, a3);
  if ((_DWORD)ExportedSymbol)
  {
    switch(v14)
    {
      case 2:
        *a4 = ((uint64_t (*)(void))((char *)v15 + v17))();
        *a5 = 1;
        break;
      case 1:
        *a4 = v16;
        *a5 = 0;
        break;
      case 0:
        v11 = v15;
        *a4 = (char *)v15 + v16;
        *a5 = 0;
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 0x40000000;
        v13[2] = ___ZNK5dyld311MachOLoaded17hasExportedSymbolEPKcU13block_pointerFPKS0_S4_jEPPvPb_block_invoke;
        v13[3] = &__block_descriptor_tmp_36_3;
        v13[4] = dyld3::MachOLoaded::getSlide(v11);
        v13[5] = a4;
        v13[6] = a5;
        dyld3::MachOFile::forEachSection(v15, (uint64_t)v13);
        break;
    }
  }
  mach_o::Error::~Error(&v18);
  return ExportedSymbol;
}

uint64_t dyld3::MachOLoaded::findExportedSymbol(dyld3::MachOFile *a1, vm_address_t *a2, const unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  const char *v12;
  _BOOL8 v13;
  unsigned int *v14;
  _DWORD *v15;
  const unsigned __int8 **v16;
  Diagnostics *v17;
  const unsigned __int8 **v18;
  const unsigned __int8 *v19;
  const unsigned __int8 *v20;
  char v21;
  const unsigned __int8 *v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  unint64_t v27;
  int v28;
  const unsigned __int8 **v29;
  uint64_t v30;
  _QWORD v31[10];
  char v32;
  _QWORD v33[7];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _QWORD v41[11];
  char v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  char v46;
  const unsigned __int8 **v47;
  const unsigned __int8 ***v48;
  uint64_t v49;
  int v50;
  _OWORD v51[5];
  __int128 v52;
  __int128 v53;

  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v51);
  if (Diagnostics::hasError((Diagnostics *)a2))
    return 0;
  if (*((_QWORD *)&v51[0] + 1))
  {
    v14 = (unsigned int *)(*((_QWORD *)&v51[0] + 1) + 12);
    v15 = (_DWORD *)(*((_QWORD *)&v51[0] + 1) + 8);
    if (!a1)
    {
LABEL_18:
      v23 = v51[2];
      v37 = v51[3];
      v38 = v51[4];
      v39 = v52;
      v40 = v53;
      v24 = v51[1];
      v34 = v51[0];
      *(_QWORD *)(a5 + 8) = 0;
      v33[0] = _NSConcreteStackBlock;
      v35 = v24;
      v33[1] = 0x40000000;
      v33[2] = ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_2;
      v33[3] = &__block_descriptor_tmp_43;
      v33[4] = a1;
      v33[5] = a3;
      v33[6] = a5;
      v36 = v23;
      dyld3::MachOLoaded::forEachGlobalSymbol(a1, a2, (uint64_t)v33);
      v25 = *(_QWORD *)(a5 + 8);
      if (!v25)
      {
        v47 = 0;
        v48 = &v47;
        v49 = 0x2000000000;
        v50 = 0;
        v31[0] = _NSConcreteStackBlock;
        v31[1] = 0x40000000;
        v31[2] = ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_3;
        v31[3] = &unk_1E4F7F098;
        v31[4] = a6;
        v31[5] = &v47;
        v31[6] = a1;
        v31[7] = a2;
        v32 = a4;
        v31[8] = a3;
        v31[9] = a5;
        dyld3::MachOFile::forEachDependentDylib(a1, (uint64_t)v31);
        _Block_object_dispose(&v47, 8);
        v25 = *(_QWORD *)(a5 + 8);
      }
      return v25 != 0;
    }
  }
  else
  {
    if (!*(_QWORD *)&v51[0])
      goto LABEL_18;
    v14 = (unsigned int *)(*(_QWORD *)&v51[0] + 44);
    v15 = (_DWORD *)(*(_QWORD *)&v51[0] + 40);
    if (!a1)
      goto LABEL_18;
  }
  v16 = (const unsigned __int8 **)((char *)a1 + *((_QWORD *)&v52 + 1) - v52 + (*v15 - v53));
  v17 = (Diagnostics *)((char *)v16 + *v14);
  v18 = dyld3::MachOFile::trieWalk(a2, v16, v17, a3, v12);
  if (!v18)
  {
    v47 = 0;
    v48 = &v47;
    v49 = 0x2000000000;
    v50 = 0;
    v43 = 0;
    v44 = &v43;
    v45 = 0x2000000000;
    v46 = 0;
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 0x40000000;
    v41[2] = ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke;
    v41[3] = &unk_1E4F7F050;
    v41[4] = a6;
    v41[5] = &v47;
    v41[8] = a2;
    v41[9] = a3;
    v42 = a4;
    v41[10] = a5;
    v41[6] = &v43;
    v41[7] = a1;
    dyld3::MachOFile::forEachDependentDylib(a1, (uint64_t)v41);
    v13 = *((_BYTE *)v44 + 24) != 0;
    _Block_object_dispose(&v43, 8);
    _Block_object_dispose(&v47, 8);
    return v13;
  }
  v47 = v18;
  v21 = dyld3::MachOFile::read_uleb128(a2, &v47, (const unsigned __int8 **)v17, v19);
  if ((v21 & 8) != 0)
  {
    if (a6)
    {
      v27 = dyld3::MachOFile::read_uleb128(a2, &v47, (const unsigned __int8 **)v17, v20);
      v28 = v27;
      if (*(_BYTE *)v47)
        v29 = v47;
      else
        v29 = (const unsigned __int8 **)a3;
      if (v27 && v27 <= dyld3::MachOFile::dependentDylibCount(a1, 0))
      {
        v30 = (*(uint64_t (**)(uint64_t, dyld3::MachOFile *, _QWORD))(a6 + 16))(a6, a1, (v28 - 1));
        if (v30)
          return dyld3::MachOLoaded::findExportedSymbol(v30, a2, v29, a4, a5, a6);
        if ((a4 & 1) == 0)
          Diagnostics::error(a2, "dependent dylib %lld not found for re-exported symbol %s");
      }
      else
      {
        Diagnostics::error(a2, "re-export ordinal %lld out of range for %s");
      }
    }
    return 0;
  }
  *(_DWORD *)a5 = 0;
  *(_WORD *)(a5 + 4) = 0;
  *(_QWORD *)(a5 + 8) = a1;
  *(_QWORD *)(a5 + 16) = dyld3::MachOFile::read_uleb128(a2, &v47, (const unsigned __int8 **)v17, v20);
  *(_DWORD *)(a5 + 24) = 0;
  *(_QWORD *)(a5 + 32) = a3;
  v13 = 0;
  if (Diagnostics::hasError((Diagnostics *)a2))
    return v13;
  if ((v21 & 3) == 2)
  {
    v13 = 1;
    *(_DWORD *)a5 = 1;
    return v13;
  }
  if ((v21 & 3) == 1)
  {
    v13 = 1;
    *(_BYTE *)(a5 + 4) = 1;
    return v13;
  }
  if ((v21 & 3) != 0)
  {
    Diagnostics::error(a2, "unsupported exported symbol kind. flags=%llu at node offset=0x%0lX");
    return 0;
  }
  *(_DWORD *)a5 = 0;
  if ((v21 & 0x10) != 0)
    *(_DWORD *)(a5 + 24) = dyld3::MachOFile::read_uleb128(a2, &v47, (const unsigned __int8 **)v17, v22);
  v13 = 1;
  if ((v21 & 4) != 0)
    *(_BYTE *)(a5 + 5) = 1;
  return v13;
}

uint64_t ___ZNK5dyld311MachOLoaded17hasExportedSymbolEPKcU13block_pointerFPKS0_S4_jEPPvPb_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  unint64_t v4;
  unint64_t v5;

  v4 = *(_QWORD *)(result + 32) + *(_QWORD *)(a2 + 64);
  v5 = **(_QWORD **)(result + 40);
  if (v4 <= v5 && *(_QWORD *)(a2 + 72) + v4 > v5)
  {
    **(_BYTE **)(result + 48) = (*(_DWORD *)(a2 + 92) & 0x80000400) != 0;
    *a4 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  uint64_t v8;

  v8 = result;
  if (a4)
  {
    result = *(_QWORD *)(result + 32);
    if (result)
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(result + 16))(result, *(_QWORD *)(v8 + 56), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v8 + 40) + 8) + 24));
      if (result)
      {
        result = dyld3::MachOLoaded::findExportedSymbol(result, *(_QWORD *)(v8 + 64), *(_QWORD *)(v8 + 72), *(unsigned __int8 *)(v8 + 88), *(_QWORD *)(v8 + 80), *(_QWORD *)(v8 + 32));
        if ((_DWORD)result)
        {
          *a8 = 1;
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v8 + 48) + 8) + 24) = 1;
        }
      }
    }
  }
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 40) + 8) + 24);
  return result;
}

uint64_t dyld3::MachOLoaded::forEachGlobalSymbol(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  int v8;
  unsigned int *v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE v22[24];
  _DWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;

  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v22);
  result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    result = dyld3::MachOFile::is64(a1);
    if (v23)
    {
      v7 = result;
      if (v24)
      {
        v8 = *(_DWORD *)(v24 + 16);
        v9 = (unsigned int *)(v24 + 20);
      }
      else
      {
        v8 = 0;
        v9 = v23 + 3;
      }
      v10 = *v9;
      v11 = v23[5];
      if ((_DWORD)v10)
      {
        v12 = v25 + v26 + (v23[4] - v27);
        v13 = v25 + v26 + (v23[2] - v27);
        v14 = 1;
        v15 = v8;
        while (1)
        {
          v16 = (v15 + v14 - 1);
          if (v7)
          {
            v17 = *(unsigned int *)(v13 + 16 * v16);
            if (v17 <= v11)
            {
              v18 = v13 + 16 * v16;
              if ((*(_BYTE *)(v18 + 4) & 0xEF) == 0xF)
              {
                v19 = v12 + v17;
                v20 = *(_QWORD *)(v18 + 8);
LABEL_15:
                result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v19, v20);
              }
            }
          }
          else
          {
            v21 = *(unsigned int *)(v13 + 12 * v16);
            if (v21 <= v11 && (*(_BYTE *)(v13 + 12 * v16 + 4) & 0xEF) == 0xF)
            {
              v19 = v12 + v21;
              v20 = *(unsigned int *)(v13 + 12 * v16 + 8);
              goto LABEL_15;
            }
          }
          if (v14 >= v10)
            return result;
          ++v14;
        }
      }
    }
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_2(uint64_t a1, char *__s1, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _BYTE *a7)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  result = _platform_strcmp(__s1, *(const char **)(a1 + 40));
  if (!(_DWORD)result)
  {
    v11 = *(_QWORD *)(a1 + 32);
    v12 = *(_QWORD *)(a1 + 48);
    *(_DWORD *)v12 = 0;
    *(_BYTE *)(v12 + 4) = 0;
    *(_QWORD *)(v12 + 8) = v11;
    v14 = *(_QWORD *)(a1 + 40);
    v13 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(v13 + 16) = a3 - *(_QWORD *)(a1 + 136);
    *(_DWORD *)(v13 + 24) = 0;
    *(_QWORD *)(v13 + 32) = v14;
    *a7 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_3(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  uint64_t v8;

  v8 = result;
  if (a4)
  {
    result = *(_QWORD *)(result + 32);
    if (result)
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(result + 16))(result, *(_QWORD *)(v8 + 48), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v8 + 40) + 8) + 24));
      if (result)
      {
        result = dyld3::MachOLoaded::findExportedSymbol(result, *(_QWORD *)(v8 + 56), *(_QWORD *)(v8 + 64), *(unsigned __int8 *)(v8 + 80), *(_QWORD *)(v8 + 72), *(_QWORD *)(v8 + 32));
        if ((_DWORD)result)
          *a8 = 1;
      }
    }
  }
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 40) + 8) + 24);
  return result;
}

uint64_t dyld3::MachOLoaded::segmentName(dyld3::MachOLoaded *this, int a2)
{
  uint64_t v2;
  _QWORD v4[5];
  int v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld311MachOLoaded11segmentNameEj_block_invoke;
  v4[3] = &unk_1E4F7F0E8;
  v5 = a2;
  v4[4] = &v6;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v4);
  v2 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t ___ZNK5dyld311MachOLoaded11segmentNameEj_block_invoke(uint64_t result, uint64_t a2, _BYTE *a3)
{
  if (*(_DWORD *)(result + 40) == (unsigned __int16)*(_DWORD *)(a2 + 56) >> 4)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_QWORD *)(a2 + 40);
    *a3 = 1;
  }
  return result;
}

uint64_t dyld3::MachOLoaded::findSectionContent(dyld3::MachOLoaded *this, const char *a2, const char *a3, unint64_t *a4)
{
  uint64_t v4;
  _QWORD v6[9];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK5dyld311MachOLoaded18findSectionContentEPKcS2_Ry_block_invoke;
  v6[3] = &unk_1E4F7F138;
  v6[6] = a3;
  v6[7] = a2;
  v6[8] = a4;
  v6[4] = &v7;
  v6[5] = this;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v6);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t ___ZNK5dyld311MachOLoaded18findSectionContentEPKcS2_Ry_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  dyld3::MachOFile *v7;
  uint64_t result;
  char *v9;
  uint64_t v10;

  v7 = *(dyld3::MachOFile **)(a1 + 40);
  result = _platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 48));
  if (!(_DWORD)result)
  {
    result = _platform_strcmp(*(const char **)(a2 + 40), *(const char **)(a1 + 56));
    if (!(_DWORD)result)
    {
      **(_QWORD **)(a1 + 64) = *(_QWORD *)(a2 + 72);
      result = dyld3::MachOFile::isPreload(v7);
      if ((_DWORD)result)
      {
        v9 = (char *)v7 + *(unsigned int *)(a2 + 88);
      }
      else
      {
        v10 = *(_QWORD *)(a2 + 64);
        result = dyld3::MachOLoaded::getSlide(v7);
        v9 = (char *)(result + v10);
      }
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v9;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t mach_o::Layout::textUnslidVMAddr(mach_o::Layout *this)
{
  uint64_t v1;
  _DWORD *v2;
  uint64_t v3;

  v1 = *((_QWORD *)this + 2);
  if (!v1)
    return 0;
  v2 = (_DWORD *)*((_QWORD *)this + 1);
  v3 = 48 * v1;
  while (v2[11] != 1)
  {
    v2 += 12;
    v3 -= 48;
    if (!v3)
      return 0;
  }
  return *(_QWORD *)v2;
}

uint64_t mach_o::SymbolTable::forEachGlobalSymbol(dyld3::MachOFile ***a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  dyld3::MachOFile *v6;
  int v7;
  int v8;
  unsigned int *v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;

  result = dyld3::MachOFile::is64(**a1);
  v6 = (*a1)[3];
  if (*((_BYTE *)v6 + 220))
  {
    v7 = result;
    v8 = *((unsigned __int8 *)v6 + 156);
    if (*((_BYTE *)v6 + 156))
    {
      v8 = *((_DWORD *)v6 + 37);
      v9 = (unsigned int *)((char *)v6 + 152);
    }
    else
    {
      v9 = (unsigned int *)((char *)v6 + 216);
    }
    v10 = *v9;
    v11 = *((_DWORD *)v6 + 60);
    v12 = *((_QWORD *)v6 + 29);
    v13 = *((_QWORD *)v6 + 25);
    v22 = 0;
    if ((_DWORD)v10)
    {
      v14 = v8;
      v15 = 1;
      while (1)
      {
        v16 = (v14 + v15 - 1);
        if (v7)
        {
          v17 = *(unsigned int *)(v13 + 16 * v16);
          if (v17 > v11)
            goto LABEL_15;
          v18 = v13 + 16 * v16;
          if ((*(_BYTE *)(v18 + 4) & 0xEF) != 0xF)
            goto LABEL_15;
          v19 = v12 + v17;
          v20 = *(_QWORD *)(v18 + 8);
        }
        else
        {
          v21 = *(unsigned int *)(v13 + 12 * v16);
          if (v21 > v11 || (*(_BYTE *)(v13 + 12 * v16 + 4) & 0xEF) != 0xF)
            goto LABEL_15;
          v19 = v12 + v21;
          v20 = *(unsigned int *)(v13 + 12 * v16 + 8);
        }
        result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v19, v20);
LABEL_15:
        if (v15 < v10)
        {
          ++v15;
          if (!v22)
            continue;
        }
        return result;
      }
    }
  }
  return result;
}

uint64_t ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  char v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;

  v4 = a1 + 32;
  v3 = *(_QWORD *)(a1 + 32);
  v7 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 8) + 8) + 24);
  v8 = -3;
  v9 = a2;
  v10 = 0;
  v11 = 0;
  v6 = 0;
  result = (*(uint64_t (**)(void))(v3 + 16))();
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t mach_o::Fixups::parseOrgArm64eChainedFixups(dyld3::MachOFile ***a1, vm_address_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  dyld3::MachOFile *v11;
  char v12;
  char v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  const unsigned __int8 **v17;
  const unsigned __int8 *v18;
  const unsigned __int8 **v19;
  _BYTE *v20;
  unsigned int v21;
  uint64_t v22;
  const unsigned __int8 **v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  const unsigned __int8 **v29;
  char v30;

  v30 = 0;
  result = dyld3::MachOFile::dependentDylibCount(**a1, 0);
  v11 = (*a1)[3];
  if (*((_BYTE *)v11 + 316))
  {
    v27 = result;
    v25 = a3;
    v26 = a5;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v28 = 0;
    v29 = (const unsigned __int8 **)*((_QWORD *)v11 + 37);
    v17 = (const unsigned __int8 **)((char *)v29 + *((unsigned int *)v11 + 76));
    while (2)
    {
      if (Diagnostics::noError((Diagnostics *)a2))
      {
        v19 = v29;
        if (v29 < v17)
        {
          v20 = (char *)v29 + 1;
          v21 = *(unsigned __int8 *)v29;
          v29 = (const unsigned __int8 **)((char *)v29 + 1);
          v22 = v21 & 0xF;
          switch(v21 >> 4)
          {
            case 0u:
              goto LABEL_6;
            case 1u:
              v13 = 1;
              v22 = v16;
              v14 = v21 & 0xF;
              goto LABEL_31;
            case 2u:
              v14 = dyld3::MachOFile::read_uleb128(a2, &v29, v17, v18);
              goto LABEL_12;
            case 3u:
              if ((v21 & 0xF) != 0)
                v14 = v21 | 0xFFFFFFF0;
              else
                v14 = 0;
LABEL_12:
              v13 = 1;
              goto LABEL_30;
            case 4u:
              if (*v20)
              {
                v23 = (const unsigned __int8 **)((char *)v19 + 2);
                do
                {
                  v29 = v23;
                  v24 = *(unsigned __int8 *)v23;
                  v23 = (const unsigned __int8 **)((char *)v23 + 1);
                }
                while (v24);
                v19 = (const unsigned __int8 **)((char *)v23 - 2);
              }
              v12 = v21 & 1;
              v29 = (const unsigned __int8 **)((char *)v19 + 2);
              v22 = v16;
              v15 = v20;
              goto LABEL_31;
            case 5u:
              goto LABEL_31;
            case 6u:
              v28 = dyld3::MachOFile::read_sleb128(a2, &v29, v17, v18);
              goto LABEL_30;
            case 7u:
              dyld3::MachOFile::read_uleb128(a2, &v29, v17, v18);
              v22 = v16;
              goto LABEL_31;
            case 9u:
              if (a4)
                (*(void (**)(uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _BYTE *, uint64_t, _QWORD, char *))(a4 + 16))(a4, v13 & 1, v27, v14, v16, v15, v28, v12 & 1, &v30);
              goto LABEL_30;
            case 0xDu:
              if ((v21 & 0xF) == 1)
              {
                if (v26)
                  (*(void (**)(void))(v26 + 16))();
              }
              else if ((v21 & 0xF) != 0)
              {
                Diagnostics::error(a2, "bad BIND_OPCODE_THREADED sub-opcode 0x%02X");
              }
              else if ((unint64_t)dyld3::MachOFile::read_uleb128(a2, &v29, v17, v18) < 0x10000)
              {
                if (v25)
                  (*(void (**)(void))(v25 + 16))();
              }
              else
              {
                Diagnostics::error(a2, "BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB size too large");
LABEL_6:
                v30 = 1;
              }
              goto LABEL_30;
            default:
              Diagnostics::error(a2, "bad bind opcode 0x%02X");
LABEL_30:
              v22 = v16;
LABEL_31:
              v16 = v22;
              if (v30)
                return Diagnostics::hasError((Diagnostics *)a2);
              continue;
          }
        }
      }
      return Diagnostics::hasError((Diagnostics *)a2);
    }
  }
  return result;
}

uint64_t ___ZNK6mach_o6Fixups25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

__n128 __Block_byref_object_copy__53_0(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

unint64_t mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget(mach_o::ChainedFixupPointerOnDisk::Arm64e *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this;
  if ((*(_QWORD *)this & 0x4000000000000000) != 0)
    mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget();
  if ((v1 & 0x8000000000000000) != 0)
    mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget();
  return v1 & 0x7FFFFFFFFFFLL | ((unint64_t)(v1 >> 43) << 56);
}

unint64_t mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend(mach_o::ChainedFixupPointerOnDisk::Arm64e *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this;
  if ((*(_QWORD *)this & 0x4000000000000000) == 0)
    mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend();
  if ((v1 & 0x8000000000000000) != 0)
    mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend();
  if ((v1 & 0x4000000000000) != 0)
    return HIDWORD(v1) | 0xFFFFFFFFFFFC0000;
  else
    return HIDWORD(v1) & 0x7FFFF;
}

uint64_t mach_o::ChainedFixupPointerOnDisk::isRebase(mach_o::ChainedFixupPointerOnDisk *this, int a2, uint64_t a3, unint64_t *a4)
{
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  switch(a2)
  {
    case 1:
    case 7:
    case 9:
    case 10:
    case 12:
      if ((*(_QWORD *)this & 0x4000000000000000) != 0)
        return 0;
      if ((*(_QWORD *)this & 0x8000000000000000) != 0)
      {
        v7 = *(_QWORD *)this;
      }
      else
      {
        v7 = mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget(this);
        if (a2 == 10 || a2 == 1)
          v7 -= a3;
      }
      goto LABEL_19;
    case 2:
    case 6:
      v8 = *(_QWORD *)this;
      if ((*(_QWORD *)this & 0x8000000000000000) != 0)
        return 0;
      v9 = v8 >> 36;
      v10 = v8 & 0xFFFFFFFFFLL;
      if (a2 == 2)
        v11 = a3;
      else
        v11 = 0;
      v7 = v10 - v11 + (v9 << 56);
      goto LABEL_19;
    case 3:
      v12 = *(_DWORD *)this;
      if ((*(_DWORD *)this & 0x80000000) == 0)
        goto LABEL_16;
      return 0;
    case 5:
      v12 = *(_DWORD *)this;
LABEL_16:
      v7 = (v12 & 0x3FFFFFF) - a3;
      goto LABEL_19;
    case 8:
    case 11:
      v7 = *(_QWORD *)this & 0x3FFFFFFFLL;
      goto LABEL_19;
    case 13:
      v7 = *(_QWORD *)this & 0x3FFFFFFFFLL;
LABEL_19:
      *a4 = v7;
      return 1;
    default:
      mach_o::ChainedFixupPointerOnDisk::isRebase();
  }
}

uint64_t mach_o::ChainedFixupPointerOnDisk::isBind(mach_o::ChainedFixupPointerOnDisk *this, int a2, unsigned int *a3, unint64_t *a4)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;

  *a4 = 0;
  v5 = 0;
  switch(a2)
  {
    case 1:
    case 7:
    case 9:
    case 10:
    case 12:
      v6 = *(_QWORD *)this;
      if ((*(_QWORD *)this & 0x4000000000000000) == 0)
        return 0;
      if (a2 == 12)
        v7 = 0xFFFFFF;
      else
        v7 = 0xFFFF;
      *a3 = v7 & v6;
      if (v6 < 0)
        return 1;
      v8 = mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend(this);
      goto LABEL_13;
    case 2:
    case 6:
      if ((*(_QWORD *)this & 0x8000000000000000) == 0)
        return 0;
      *a3 = *(_QWORD *)this & 0xFFFFFF;
      v8 = *((unsigned __int8 *)this + 3);
      goto LABEL_13;
    case 3:
      if ((*(_DWORD *)this & 0x80000000) == 0)
        return 0;
      *a3 = *(_DWORD *)this & 0xFFFFF;
      v8 = ((unint64_t)*(unsigned int *)this >> 20) & 0x3F;
LABEL_13:
      *a4 = v8;
      return 1;
    case 8:
    case 11:
      return v5;
    default:
      mach_o::ChainedFixupPointerOnDisk::isBind();
  }
}

uint64_t dyld3::MachOAnalyzer::forEachRebase(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  Diagnostics *v4;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  int v17;
  const unsigned __int8 **LinkEditContent;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  const unsigned __int8 *v26;
  const unsigned __int8 **v27;
  unsigned __int8 v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  BOOL v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  unint64_t v45;
  BOOL v46;
  uint64_t v47;
  const unsigned __int8 *v48;
  unint64_t uleb128;
  const unsigned __int8 *v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  const char *v57;
  uint64_t v58;
  unint64_t v59;
  BOOL v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  const unsigned __int8 **v65;
  unsigned int v66;
  uint64_t *v67;
  Diagnostics *v68;
  uint64_t v69;
  uint64_t *v70;
  uint64_t v71;
  const unsigned __int8 **v72;
  char v73;
  _QWORD v74[9];
  uint64_t v75;
  const unsigned __int8 **v76[5];

  v4 = (Diagnostics *)a2;
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v74);
  result = Diagnostics::hasError(v4);
  if ((result & 1) == 0)
  {
    __chkstk_darwin(result, v7, v8, v9, v10, v11, v12, v13, v63);
    v15 = &v63 - 8 * v14;
    v76[0] = (const unsigned __int8 **)_NSConcreteStackBlock;
    v76[1] = (const unsigned __int8 **)0x40000000;
    v16[2] = ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    v16[3] = &__block_descriptor_tmp_58_0;
    v16[4] = v15;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v76);
    result = Diagnostics::hasError(v4);
    if ((result & 1) == 0)
    {
      result = dyld3::MachOFile::is64(a1);
      if ((_DWORD)result)
        v17 = 2;
      else
        v17 = 1;
      if (v74[0])
      {
        v69 = a3;
        v70 = v15;
        v66 = v17;
        v67 = &v63;
        LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v75, *(_DWORD *)(v74[0] + 8));
        v64 = *(unsigned int *)(v74[0] + 12);
        v72 = (const unsigned __int8 **)((char *)LinkEditContent + v64);
        v65 = LinkEditContent;
        v76[0] = LinkEditContent;
        v19 = dyld3::MachOFile::pointerSize(a1);
        v20 = 0;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v73 = 0;
        v24 = v19;
        v25 = "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB";
        v68 = v4;
        while (2)
        {
          result = Diagnostics::noError(v4);
          if ((_DWORD)result)
          {
            v27 = v76[0];
            if (v76[0] < v72)
            {
              v28 = *(_BYTE *)v76[0]++;
              v29 = v28 & 0xF;
              switch(v28 >> 4)
              {
                case 0:
                  v62 = (char *)v27 + 1;
                  if ((char *)v72 - v62 >= 16)
                    return Diagnostics::error((vm_address_t *)v4, "rebase opcodes terminated early at offset %d of %d", (int)v62 - (int)v65, v64);
                  return result;
                case 1:
                  switch((_DWORD)v29)
                  {
                    case 1:
                      v23 = v66;
                      break;
                    case 3:
                      v23 = 3;
                      break;
                    case 2:
                      v23 = 4;
                      break;
                    default:
                      v23 = 0;
                      break;
                  }
                  goto LABEL_47;
                case 2:
                  result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v26);
                  v21 = result;
                  v20 = 1;
                  v22 = v29;
                  goto LABEL_47;
                case 3:
                  result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v26);
                  v21 += result;
                  goto LABEL_47;
                case 4:
                  v21 += (v24 * v29);
                  goto LABEL_47;
                case 5:
                  if ((v28 & 0xF) == 0)
                    goto LABEL_47;
                  v30 = 1;
                  v31 = v23;
                  v32 = v22;
                  v33 = v20;
                  v34 = v70;
                  v35 = v69;
                  do
                  {
                    result = (*(uint64_t (**)(uint64_t, const char *, _QWORD *, uint64_t *, uint64_t, uint64_t, _QWORD, uint64_t, _DWORD, char *))(v35 + 16))(v35, "REBASE_OPCODE_DO_REBASE_IMM_TIMES", v74, v34, v33 & 1, v24, v32, v21, v31, &v73);
                    v21 += v24;
                    if (v73)
                      v36 = 1;
                    else
                      v36 = v30 >= v29;
                    ++v30;
                  }
                  while (!v36);
                  v4 = v68;
                  v20 = v33;
                  v22 = v32;
                  v25 = "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB";
                  v23 = v31;
                  if (v73)
                    return result;
                  continue;
                case 6:
                  result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v26);
                  if (result)
                  {
                    v37 = result;
                    v38 = 1;
                    v39 = v20;
                    v40 = v23;
                    v41 = v22;
                    v42 = v39;
                    v43 = v70;
                    v44 = v69;
                    do
                    {
                      result = (*(uint64_t (**)(uint64_t, const char *, _QWORD *, uint64_t *, uint64_t, uint64_t, _QWORD, uint64_t, _DWORD, char *))(v44 + 16))(v44, "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB", v74, v43, v42 & 1, v24, v41, v21, v40, &v73);
                      v21 += v24;
                      v45 = v38++;
                      if (v73)
                        v46 = 0;
                      else
                        v46 = v37 > v45;
                    }
                    while (v46);
                    v4 = v68;
                    v47 = v42;
                    v22 = v41;
                    v25 = "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB";
                    v23 = v40;
                    v20 = v47;
                  }
                  goto LABEL_47;
                case 7:
                  (*(void (**)(uint64_t, const char *, _QWORD *, uint64_t *, uint64_t, uint64_t, _QWORD, uint64_t, _DWORD, char *))(v69 + 16))(v69, "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB", v74, v70, v20 & 1, v24, v22, v21, v23, &v73);
                  result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v48);
                  v21 += v24 + result;
                  goto LABEL_47;
                case 8:
                  uleb128 = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v26);
                  result = Diagnostics::hasError(v4);
                  if ((result & 1) == 0)
                  {
                    result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v50);
                    if (uleb128)
                    {
                      v71 = result + v24;
                      v51 = 1;
                      v52 = v20;
                      v53 = v23;
                      v54 = v22;
                      v55 = v52;
                      v56 = v70;
                      v57 = v25;
                      v58 = v69;
                      do
                      {
                        result = (*(uint64_t (**)(uint64_t, const char *, _QWORD *, uint64_t *, uint64_t, uint64_t, _QWORD, uint64_t, _DWORD, char *))(v58 + 16))(v58, v57, v74, v56, v55 & 1, v24, v54, v21, v53, &v73);
                        v59 = v51++;
                        v21 += v71;
                        if (v73)
                          v60 = 0;
                        else
                          v60 = uleb128 > v59;
                      }
                      while (v60);
                      v4 = v68;
                      v61 = v55;
                      v22 = v54;
                      v23 = v53;
                      v20 = v61;
                      v25 = v57;
                    }
                  }
                  goto LABEL_47;
                default:
                  result = Diagnostics::error((vm_address_t *)v4, "unknown rebase opcode 0x%02X", v28 & 0xF0);
LABEL_47:
                  if (v73)
                    return result;
                  continue;
              }
            }
          }
          break;
        }
      }
      else if (v74[2])
      {
        return dyld3::MachOFile::isFileSet(a1);
      }
    }
  }
  return result;
}

void dyld3::MachOAnalyzer::forEachRebase(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  _QWORD v6[12];
  _QWORD v7[8];
  _QWORD v8[4];
  _QWORD v9[4];
  _QWORD v10[4];
  _QWORD v11[4];
  _QWORD v12[4];
  _QWORD v13[3];
  char v14;

  v13[0] = 0;
  v13[1] = v13;
  v13[2] = 0x2000000000;
  v14 = 0;
  v12[0] = 0;
  v12[1] = v12;
  v12[2] = 0x2000000000;
  v12[3] = 0;
  v11[0] = 0;
  v11[1] = v11;
  v11[2] = 0x2000000000;
  v11[3] = 0;
  v10[0] = 0;
  v10[1] = v10;
  v10[2] = 0x2000000000;
  v10[3] = 0;
  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x2000000000;
  v9[3] = 0;
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  v8[3] = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke;
  v7[3] = &unk_1E4F7F308;
  v7[4] = v11;
  v7[5] = v10;
  v7[6] = v9;
  v7[7] = v8;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v7);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke_2;
  v6[3] = &unk_1E4F7F330;
  v6[6] = v12;
  v6[7] = v11;
  v6[8] = v10;
  v6[9] = v9;
  v6[10] = v8;
  v6[11] = a1;
  v6[4] = a3;
  v6[5] = v13;
  dyld3::MachOAnalyzer::forEachRebase(a1, a2, (uint64_t)v6);
  _Block_object_dispose(v8, 8);
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(v10, 8);
  _Block_object_dispose(v11, 8);
  _Block_object_dispose(v12, 8);
  _Block_object_dispose(v13, 8);
}

uint64_t ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*(_DWORD *)(a2 + 92) == 7)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_QWORD *)(a2 + 64);
    v4 = *(_QWORD *)(a2 + 72) + *(_QWORD *)(a2 + 64);
    v5 = *(_QWORD *)(result + 40);
LABEL_3:
    *(_QWORD *)(*(_QWORD *)(v5 + 8) + 24) = v4;
    return result;
  }
  if ((*(_DWORD *)(a2 + 92) & 0x80000000) != 0)
  {
    result = _platform_strcmp(*(const char **)(a2 + 80), "__stub_helper");
    if (!(_DWORD)result)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8) + 24) = *(_QWORD *)(a2 + 64);
      v4 = *(_QWORD *)(a2 + 72) + *(_QWORD *)(a2 + 64);
      v5 = *(_QWORD *)(v3 + 56);
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, uint64_t a8, unsigned int a9)
{
  _QWORD *v14;
  dyld3::MachOAnalyzer *v15;
  BOOL v16;
  uint64_t v17;
  const char **v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;

  if (a9 > 4 || ((1 << a9) & 0x19) == 0)
  {
    v14 = (_QWORD *)result;
    v15 = *(dyld3::MachOAnalyzer **)(result + 88);
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24))
      v16 = 1;
    else
      v16 = a7 == 0;
    if (!v16)
    {
      v17 = a7;
      v18 = (const char **)(a4 + 40);
      while (_platform_strcmp(*v18, "__TEXT"))
      {
        v18 += 8;
        if (!--v17)
          goto LABEL_15;
      }
      *(_QWORD *)(*(_QWORD *)(v14[6] + 8) + 24) = *(v18 - 3);
      *(_BYTE *)(*(_QWORD *)(v14[5] + 8) + 24) = 1;
    }
LABEL_15:
    v19 = *(_QWORD *)(a4 + ((unint64_t)a7 << 6) + 16) + a8;
    if (v19 >= *(_QWORD *)(*(_QWORD *)(v14[7] + 8) + 24) && v19 < *(_QWORD *)(*(_QWORD *)(v14[8] + 8) + 24))
    {
      v20 = *(_QWORD *)(*(_QWORD *)(v14[6] + 8) + 24);
      v21 = v19 - v20;
      if (a6 == 8)
        v22 = *(_QWORD *)((char *)v15 + v21);
      else
        v22 = *(unsigned int *)((char *)v15 + v21);
      if (v22 >= *(_QWORD *)(*(_QWORD *)(v14[9] + 8) + 24) && v22 < *(_QWORD *)(*(_QWORD *)(v14[10] + 8) + 24))
        dyld3::MachOAnalyzer::contentIsRegularStub(v15, (const unsigned __int8 *)v15 + v22 - v20);
    }
    return (*(uint64_t (**)(void))(v14[4] + 16))();
  }
  return result;
}

BOOL dyld3::MachOAnalyzer::contentIsRegularStub(dyld3::MachOAnalyzer *this, const unsigned __int8 *a2)
{
  _BOOL8 result;
  int v4;
  int v5;
  uint64_t v6;

  result = 0;
  v4 = *((_DWORD *)this + 1);
  if (v4 > 16777222)
  {
    if (v4 == 16777228)
    {
      if (*a2 == 80 && !a2[1] && !a2[2])
      {
        v5 = 24;
        goto LABEL_20;
      }
      return 0;
    }
    if (v4 != 16777223)
      return result;
    if (*a2 != 104)
      return 0;
    v5 = 233;
    v6 = 5;
  }
  else
  {
    if (v4 != 7)
    {
      if (v4 != 12)
        return result;
      if (!*a2 && a2[1] == 192 && a2[2] == 159)
      {
        v5 = 229;
LABEL_20:
        v6 = 3;
        return a2[v6] == v5;
      }
      return 0;
    }
    if (*a2 != 104 || a2[5] != 255)
      return 0;
    v5 = 38;
    v6 = 2;
  }
  return a2[v6] == v5;
}

void dyld3::MachOAnalyzer::forEachRebase(dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4)
{
  _QWORD v4[5];
  char v5;

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsbU13block_pointerFvyRbE_block_invoke;
  v4[3] = &unk_1E4F7F358;
  v5 = a3;
  v4[4] = a4;
  dyld3::MachOAnalyzer::forEachRebase(a1, a2, (uint64_t)v4);
}

uint64_t ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsbU13block_pointerFvyRbE_block_invoke(uint64_t result, uint64_t a2, int a3)
{
  if (!a3 || !*(_BYTE *)(result + 40))
    return (*(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16))();
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachBind(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  const unsigned __int8 **LinkEditContent;
  const unsigned __int8 **v19;
  char v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  const unsigned __int8 **v24;
  const unsigned __int8 *v25;
  const unsigned __int8 **v26;
  _BYTE *v27;
  unsigned __int8 v28;
  int v29;
  const unsigned __int8 **v30;
  int v31;
  const unsigned __int8 **v32;
  char v33;
  uint64_t v34;
  unsigned __int8 *v35;
  uint64_t v36;
  const unsigned __int8 **v37;
  uint64_t v38;
  const unsigned __int8 *v39;
  const unsigned __int8 **v40;
  unsigned int v41;
  unsigned __int8 *v42;
  uint64_t v43;
  const unsigned __int8 **v44;
  int v45;
  uint64_t v46;
  const unsigned __int8 *v47;
  const unsigned __int8 **v48;
  unsigned int v49;
  unint64_t v50;
  const unsigned __int8 *v51;
  uint64_t v52;
  unsigned int v53;
  unint64_t v54;
  uint64_t uleb128;
  uint64_t v56;
  uint64_t v57;
  const unsigned __int8 **v58;
  uint64_t v59;
  const unsigned __int8 *v60;
  const unsigned __int8 **v61;
  unsigned __int8 *v62;
  unsigned int v63;
  int v64;
  uint64_t v65;
  const unsigned __int8 **v66;
  int v67;
  const unsigned __int8 *v68;
  uint64_t v69;
  unsigned int v70;
  uint64_t v71;
  unint64_t v72;
  const unsigned __int8 *v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  const unsigned __int8 **v83;
  uint64_t v84;
  uint64_t v85;
  _BYTE *v86;
  uint64_t *v87;
  unsigned __int8 *v88;
  uint64_t v89;
  const unsigned __int8 **v90;
  uint64_t v91;
  uint64_t sleb128;
  uint64_t v93;
  unsigned int v94;
  const unsigned __int8 **v95;
  unsigned int v96;
  _QWORD v97[9];
  _BYTE v98[36];
  char v99;
  const unsigned __int8 **v100[5];

  v96 = dyld3::MachOFile::pointerSize(a1);
  v99 = 0;
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v97);
  result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    __chkstk_darwin(result, v9, v10, v11, v12, v13, v14, v15, v81);
    v100[0] = (const unsigned __int8 **)_NSConcreteStackBlock;
    v100[1] = (const unsigned __int8 **)0x40000000;
    v100[2] = (const unsigned __int8 **)___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    v100[3] = (const unsigned __int8 **)&__block_descriptor_tmp_58_0;
    v95 = (const unsigned __int8 **)(&v81 - 8 * v16);
    v100[4] = v95;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v100);
    result = Diagnostics::hasError((Diagnostics *)a2);
    if ((result & 1) == 0)
    {
      result = dyld3::MachOFile::dependentDylibCount(a1, 0);
      v94 = result;
      if (v97[0])
      {
        v87 = &v81;
        v85 = a4;
        v17 = *(_DWORD *)(v97[0] + 16);
        v86 = v98;
        LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)v98, v17);
        v100[0] = LinkEditContent;
        if (!v99)
        {
          LODWORD(v89) = 0;
          sleb128 = 0;
          LODWORD(v93) = 0;
          LODWORD(v91) = 0;
          uleb128 = 0;
          v88 = 0;
          LODWORD(v90) = 0;
          v56 = 0;
          v57 = 0;
          v58 = (const unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(v97[0] + 20));
          v59 = v96;
          while (2)
          {
            if (Diagnostics::noError((Diagnostics *)a2))
            {
              v61 = v100[0];
              if (v100[0] < v58)
              {
                v62 = (unsigned __int8 *)v100[0] + 1;
                v63 = *(unsigned __int8 *)v100[0]++;
                v64 = v63 & 0xF;
                v65 = v63 & 0xF;
                switch(v63 >> 4)
                {
                  case 0u:
                    v99 = 1;
                    goto LABEL_82;
                  case 1u:
                    LODWORD(v93) = 1;
                    v65 = v57;
                    uleb128 = v63 & 0xF;
                    goto LABEL_83;
                  case 2u:
                    uleb128 = dyld3::MachOFile::read_uleb128(a2, v100, v58, v60);
                    goto LABEL_70;
                  case 3u:
                    if ((v63 & 0xF) != 0)
                      uleb128 = v63 | 0xFFFFFFF0;
                    else
                      uleb128 = 0;
LABEL_70:
                    LODWORD(v93) = 1;
                    goto LABEL_82;
                  case 4u:
                    if (*v62)
                    {
                      v66 = (const unsigned __int8 **)((char *)v61 + 2);
                      do
                      {
                        v100[0] = v66;
                        v67 = *(unsigned __int8 *)v66;
                        v66 = (const unsigned __int8 **)((char *)v66 + 1);
                      }
                      while (v67);
                      v61 = (const unsigned __int8 **)((char *)v66 - 2);
                    }
                    LODWORD(v89) = v63 & 1;
                    v100[0] = (const unsigned __int8 **)((char *)v61 + 2);
                    v65 = v57;
                    v88 = v62;
                    goto LABEL_83;
                  case 5u:
                    goto LABEL_83;
                  case 6u:
                    sleb128 = dyld3::MachOFile::read_sleb128(a2, v100, v58, v60);
                    goto LABEL_82;
                  case 7u:
                    v56 = dyld3::MachOFile::read_uleb128(a2, v100, v58, v60);
                    LODWORD(v91) = 1;
                    v65 = v57;
                    LODWORD(v90) = v64;
                    goto LABEL_83;
                  case 8u:
                    v56 += dyld3::MachOFile::read_uleb128(a2, v100, v58, v60);
                    goto LABEL_82;
                  case 9u:
                    LOWORD(v80) = v89 & 1;
                    LOBYTE(v79) = v57;
                    BYTE4(v78) = (_BYTE)v90;
                    LODWORD(v78) = v96;
                    (*(void (**)(uint64_t, const char *, _QWORD *, const unsigned __int8 **, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", v97, v95, v91 & 1, v93 & 1, v94, uleb128, v78, v56, v79, v88, v80, sleb128, &v99);
                    v56 += v59;
                    goto LABEL_82;
                  case 0xAu:
                    LOWORD(v80) = v89 & 1;
                    LOBYTE(v79) = v57;
                    BYTE4(v78) = (_BYTE)v90;
                    LODWORD(v78) = v96;
                    (*(void (**)(uint64_t, const char *, _QWORD *, const unsigned __int8 **, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", v97, v95, v91 & 1, v93 & 1, v94, uleb128, v78, v56, v79, v88, v80, sleb128, &v99);
                    v56 += v59 + dyld3::MachOFile::read_uleb128(a2, v100, v58, v68);
                    goto LABEL_82;
                  case 0xBu:
                    LOWORD(v80) = v89 & 1;
                    LOBYTE(v79) = v57;
                    BYTE4(v78) = (_BYTE)v90;
                    v69 = v59;
                    v70 = v96;
                    LODWORD(v78) = v96;
                    (*(void (**)(uint64_t, const char *, _QWORD *, const unsigned __int8 **, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", v97, v95, v91 & 1, v93 & 1, v94, uleb128, v78, v56, v79, v88, v80, sleb128, &v99);
                    v71 = v70 + v70 * v64;
                    v59 = v69;
                    v56 += v71;
                    goto LABEL_82;
                  case 0xCu:
                    v84 = uleb128;
                    v72 = dyld3::MachOFile::read_uleb128(a2, v100, v58, v60);
                    v74 = dyld3::MachOFile::read_uleb128(a2, v100, v58, v73);
                    if (v72)
                    {
                      v83 = v58;
                      v82 = v59;
                      v75 = v74 + v59;
                      v76 = 1;
                      uleb128 = v84;
                      do
                      {
                        LOWORD(v80) = v89 & 1;
                        LOBYTE(v79) = v57;
                        BYTE4(v78) = (_BYTE)v90;
                        LODWORD(v78) = v96;
                        (*(void (**)(uint64_t, const char *, _QWORD *, const unsigned __int8 **, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", v97, v95, v91 & 1, v93 & 1, v94, uleb128, v78, v56, v79, v88, v80, sleb128, &v99);
                        v56 += v75;
                        if (v99)
                          break;
                        v77 = v76++;
                      }
                      while (v72 > v77);
                      v65 = v57;
                      v58 = v83;
                      v59 = v82;
                    }
                    else
                    {
                      v65 = v57;
                      uleb128 = v84;
                    }
                    goto LABEL_83;
                  default:
                    Diagnostics::error(a2, "bad bind opcode 0x%02X", *v62);
LABEL_82:
                    v65 = v57;
LABEL_83:
                    v57 = v65;
                    if (v99)
                      break;
                    continue;
                }
              }
            }
            break;
          }
        }
        result = Diagnostics::hasError((Diagnostics *)a2);
        if ((result & 1) == 0)
        {
          if (*(_DWORD *)(v97[0] + 36))
          {
            v19 = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)v86, *(_DWORD *)(v97[0] + 32));
            LODWORD(v90) = 0;
            v93 = 0;
            v20 = 0;
            LODWORD(sleb128) = 0;
            v21 = 0;
            v22 = 0;
            LODWORD(v91) = 0;
            v23 = 0;
            v100[0] = v19;
            v24 = (const unsigned __int8 **)((char *)v19 + *(unsigned int *)(v97[0] + 36));
            v99 = 0;
            v89 = v96;
            do
            {
              if (!Diagnostics::noError((Diagnostics *)a2))
                break;
              v26 = v100[0];
              if (v100[0] >= v24)
                break;
              v27 = (char *)v100[0] + 1;
              v28 = *(_BYTE *)v100[0]++;
              v29 = v28 & 0xF;
              switch(v28 >> 4)
              {
                case 0:
                  break;
                case 1:
                  v20 = 1;
                  v21 = v28 & 0xF;
                  break;
                case 2:
                  v21 = dyld3::MachOFile::read_uleb128(a2, v100, v24, v25);
                  goto LABEL_16;
                case 3:
                  if ((v28 & 0xF) != 0)
                    v21 = *(_DWORD *)&v28 | 0xFFFFFFF0;
                  else
                    v21 = 0;
LABEL_16:
                  v20 = 1;
                  break;
                case 4:
                  if (*v27)
                  {
                    v30 = (const unsigned __int8 **)((char *)v26 + 2);
                    do
                    {
                      v100[0] = v30;
                      v31 = *(unsigned __int8 *)v30;
                      v30 = (const unsigned __int8 **)((char *)v30 + 1);
                    }
                    while (v31);
                    v26 = (const unsigned __int8 **)((char *)v30 - 2);
                  }
                  LODWORD(v90) = v28 & 1;
                  v100[0] = (const unsigned __int8 **)((char *)v26 + 2);
                  v22 = v27;
                  break;
                case 6:
                  v93 = dyld3::MachOFile::read_sleb128(a2, v100, v24, v25);
                  break;
                case 7:
                  v23 = dyld3::MachOFile::read_uleb128(a2, v100, v24, v25);
                  LODWORD(sleb128) = 1;
                  LODWORD(v91) = v29;
                  break;
                case 9:
                  BYTE1(v80) = 1;
                  LOBYTE(v80) = v90 & 1;
                  LOBYTE(v79) = 1;
                  BYTE4(v78) = v91;
                  LODWORD(v78) = v96;
                  (*(void (**)(uint64_t, const char *, _QWORD *, const unsigned __int8 **, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", v97, v95, sleb128 & 1, v20 & 1, v94, v21, v78, v23, v79, v22, v80, v93, &v99);
                  v23 += v89;
                  break;
                default:
                  Diagnostics::error(a2, "bad lazy bind opcode 0x%02X", v28 & 0xF0);
                  break;
              }
            }
            while (!v99);
          }
          result = Diagnostics::hasError((Diagnostics *)a2);
          if ((result & 1) == 0 && *(_DWORD *)(v97[0] + 28))
          {
            v32 = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)v86, *(_DWORD *)(v97[0] + 24));
            v33 = 0;
            v34 = 0;
            LODWORD(sleb128) = 0;
            v35 = 0;
            LODWORD(v93) = 0;
            v36 = 0;
            v100[0] = v32;
            v37 = (const unsigned __int8 **)((char *)v32 + *(unsigned int *)(v97[0] + 28));
            v99 = 0;
            v91 = v96;
            v38 = 1;
            do
            {
              result = Diagnostics::noError((Diagnostics *)a2);
              if (!(_DWORD)result)
                break;
              v40 = v100[0];
              if (v100[0] >= v37)
                break;
              v42 = (unsigned __int8 *)v100[0] + 1;
              v41 = *(unsigned __int8 *)v100[0]++;
              v43 = v41 & 0xF;
              switch(v41 >> 4)
              {
                case 0u:
                  v99 = 1;
                  goto LABEL_50;
                case 1u:
                case 2u:
                case 3u:
                  result = Diagnostics::error(a2, "unexpected dylib ordinal in weak_bind");
                  goto LABEL_50;
                case 4u:
                  if (*v42)
                  {
                    v44 = (const unsigned __int8 **)((char *)v40 + 2);
                    do
                    {
                      v100[0] = v44;
                      v45 = *(unsigned __int8 *)v44;
                      v44 = (const unsigned __int8 **)((char *)v44 + 1);
                    }
                    while (v45);
                    v40 = (const unsigned __int8 **)((char *)v44 - 2);
                  }
                  v33 = v41 & 1;
                  v100[0] = (const unsigned __int8 **)((char *)v40 + 2);
                  if (v43 >= 8)
                    result = (*(uint64_t (**)(uint64_t, unsigned __int8 *))(v85 + 16))(v85, v42);
                  v43 = v38;
                  v35 = v42;
                  break;
                case 5u:
                  break;
                case 6u:
                  result = dyld3::MachOFile::read_sleb128(a2, v100, v37, v39);
                  v34 = result;
                  goto LABEL_50;
                case 7u:
                  LODWORD(v93) = v41 & 0xF;
                  result = dyld3::MachOFile::read_uleb128(a2, v100, v37, v39);
                  v36 = result;
                  LODWORD(sleb128) = 1;
                  goto LABEL_50;
                case 8u:
                  result = dyld3::MachOFile::read_uleb128(a2, v100, v37, v39);
                  v36 += result;
                  goto LABEL_50;
                case 9u:
                  LOWORD(v80) = v33 & 1;
                  LOBYTE(v79) = v38;
                  BYTE4(v78) = v93;
                  LODWORD(v78) = v96;
                  result = (*(uint64_t (**)(uint64_t, const char *, _QWORD *, const unsigned __int8 **, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", v97, v95, sleb128 & 1, 1, v94, 4294967293, v78, v36, v79, v35, v80, v34, &v99);
                  v46 = v91;
                  goto LABEL_49;
                case 0xAu:
                  LOWORD(v80) = v33 & 1;
                  LOBYTE(v79) = v38;
                  BYTE4(v78) = v93;
                  LODWORD(v78) = v96;
                  (*(void (**)(uint64_t, const char *, _QWORD *, const unsigned __int8 **, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", v97, v95, sleb128 & 1, 1, v94, 4294967293, v78, v36, v79, v35, v80, v34, &v99);
                  result = dyld3::MachOFile::read_uleb128(a2, v100, v37, v47);
                  v36 += v91 + result;
                  goto LABEL_50;
                case 0xBu:
                  LOWORD(v80) = v33 & 1;
                  LOBYTE(v79) = v38;
                  BYTE4(v78) = v93;
                  v48 = v37;
                  v49 = v96;
                  LODWORD(v78) = v96;
                  result = (*(uint64_t (**)(uint64_t, const char *, _QWORD *, const unsigned __int8 **, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", v97, v95, sleb128 & 1, 1, v94, 4294967293, v78, v36, v79, v35, v80, v34, &v99);
                  v46 = v49 + v49 * (_DWORD)v43;
                  v37 = v48;
LABEL_49:
                  v36 += v46;
                  goto LABEL_50;
                case 0xCu:
                  v50 = dyld3::MachOFile::read_uleb128(a2, v100, v37, v39);
                  result = dyld3::MachOFile::read_uleb128(a2, v100, v37, v51);
                  if (!v50)
                    goto LABEL_50;
                  v90 = v37;
                  v52 = result + v91;
                  v53 = 1;
                  do
                  {
                    LOWORD(v80) = v33 & 1;
                    LOBYTE(v79) = v38;
                    BYTE4(v78) = v93;
                    LODWORD(v78) = v96;
                    result = (*(uint64_t (**)(uint64_t, const char *, _QWORD *, const unsigned __int8 **, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", v97, v95, sleb128 & 1, 1, v94, 4294967293, v78, v36, v79, v35, v80, v34, &v99);
                    v36 += v52;
                    if (v99)
                      break;
                    v54 = v53++;
                  }
                  while (v50 > v54);
                  v43 = v38;
                  v37 = v90;
                  break;
                default:
                  result = Diagnostics::error(a2, "bad bind opcode 0x%02X", *v42);
LABEL_50:
                  v43 = v38;
                  break;
              }
              v38 = v43;
            }
            while (!v99);
          }
        }
      }
    }
  }
  return result;
}

void dyld3::MachOAnalyzer::forEachBind(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[5];
  _QWORD v5[7];
  _QWORD v6[4];
  _QWORD v7[3];
  char v8;

  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  v8 = 0;
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x2000000000;
  v6[3] = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke;
  v5[3] = &unk_1E4F7A6A0;
  v5[5] = v7;
  v5[6] = v6;
  v5[4] = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke_2;
  v4[3] = &unk_1E4F7F380;
  v4[4] = a4;
  dyld3::MachOAnalyzer::forEachBind(a1, a2, (uint64_t)v5, (uint64_t)v4);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(v7, 8);
}

uint64_t ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned __int8 a10)
{
  const char **v11;
  uint64_t v12;

  if (!*(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24))
  {
    v11 = (const char **)(a4 + 40);
    v12 = a10 + 1;
    while (_platform_strcmp(*v11, "__TEXT"))
    {
      v11 += 8;
      if (!--v12)
        return (*(uint64_t (**)(_QWORD))(a1[4] + 16))(a1[4]);
    }
    *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = *(v11 - 3);
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 1;
  }
  return (*(uint64_t (**)(_QWORD))(a1[4] + 16))(a1[4]);
}

uint64_t ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t dyld3::MachOAnalyzer::parseOrgArm64eChainedFixups(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const unsigned __int8 **v19;
  const unsigned __int8 **LinkEditContent;
  uint64_t v21;
  const unsigned __int8 **v22;
  const unsigned __int8 *v23;
  const unsigned __int8 **v24;
  _BYTE *v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  const unsigned __int8 **v30;
  int v31;
  unint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  _BYTE *v37;
  int v38;
  uint64_t sleb128;
  uint64_t uleb128;
  int v41;
  _QWORD v42[9];
  uint64_t v43;
  char v44;
  const unsigned __int8 **v45[5];

  v44 = 0;
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v42);
  result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    __chkstk_darwin(result, v11, v12, v13, v14, v15, v16, v17, v34);
    v19 = (const unsigned __int8 **)(&v34 - 8 * v18);
    v45[0] = (const unsigned __int8 **)_NSConcreteStackBlock;
    v45[1] = (const unsigned __int8 **)0x40000000;
    v45[2] = (const unsigned __int8 **)___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    v45[3] = (const unsigned __int8 **)&__block_descriptor_tmp_58_0;
    v45[4] = v19;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v45);
    result = Diagnostics::hasError((Diagnostics *)a2);
    if ((result & 1) == 0)
    {
      result = dyld3::MachOFile::dependentDylibCount(a1, 0);
      if (v42[0])
      {
        LODWORD(v34) = result;
        LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v43, *(_DWORD *)(v42[0] + 16));
        v38 = 0;
        sleb128 = 0;
        v41 = 0;
        v36 = 0;
        uleb128 = 0;
        v37 = 0;
        HIDWORD(v34) = 0;
        v35 = 0;
        v21 = 0;
        v45[0] = LinkEditContent;
        v22 = (const unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(v42[0] + 20));
        while (2)
        {
          if (Diagnostics::noError((Diagnostics *)a2))
          {
            v24 = v45[0];
            if (v45[0] < v22)
            {
              v25 = (char *)v45[0] + 1;
              v26 = *(unsigned __int8 *)v45[0];
              v27 = v26 & 0xF;
              ++v45[0];
              v28 = v26 & 0xF;
              switch(v26 >> 4)
              {
                case 0u:
                  goto LABEL_8;
                case 1u:
                  v41 = 1;
                  v28 = v21;
                  uleb128 = v26 & 0xF;
                  goto LABEL_34;
                case 2u:
                  uleb128 = dyld3::MachOFile::read_uleb128(a2, v45, v22, v23);
                  goto LABEL_15;
                case 3u:
                  LODWORD(v29) = v26 | 0xFFFFFFF0;
                  if ((v26 & 0xF) != 0)
                    v29 = v29;
                  else
                    v29 = 0;
                  uleb128 = v29;
LABEL_15:
                  v41 = 1;
                  goto LABEL_33;
                case 4u:
                  if (*v25)
                  {
                    v30 = (const unsigned __int8 **)((char *)v24 + 2);
                    do
                    {
                      v45[0] = v30;
                      v31 = *(unsigned __int8 *)v30;
                      v30 = (const unsigned __int8 **)((char *)v30 + 1);
                    }
                    while (v31);
                    v24 = (const unsigned __int8 **)((char *)v30 - 2);
                  }
                  v38 = v26 & 1;
                  v45[0] = (const unsigned __int8 **)((char *)v24 + 2);
                  v28 = v21;
                  v37 = v25;
                  goto LABEL_34;
                case 5u:
                  goto LABEL_34;
                case 6u:
                  sleb128 = dyld3::MachOFile::read_sleb128(a2, v45, v22, v23);
                  goto LABEL_33;
                case 7u:
                  v35 = dyld3::MachOFile::read_uleb128(a2, v45, v22, v23);
                  v36 = 1;
                  v28 = v21;
                  HIDWORD(v34) = v27;
                  goto LABEL_34;
                case 9u:
                  if (a4)
                  {
                    LOBYTE(v33) = v38 & 1;
                    (*(void (**)(uint64_t, _QWORD *, const unsigned __int8 **, _QWORD, _QWORD, uint64_t, _QWORD, _BYTE *, uint64_t, int, char *))(a4 + 16))(a4, v42, v19, v41 & 1, v34, uleb128, v21, v37, sleb128, v33, &v44);
                  }
                  goto LABEL_33;
                case 0xDu:
                  if (v27 == 1)
                  {
                    if (a5)
                      (*(void (**)(uint64_t, _QWORD *, const unsigned __int8 **, _QWORD, _QWORD, uint64_t, uint64_t, char *))(a5 + 16))(a5, v42, v19, BYTE4(v34), v36 & 1, v35, 1, &v44);
                  }
                  else if ((v26 & 0xF) != 0)
                  {
                    Diagnostics::error(a2, "bad BIND_OPCODE_THREADED sub-opcode 0x%02X");
                  }
                  else
                  {
                    v32 = dyld3::MachOFile::read_uleb128(a2, v45, v22, v23);
                    if (v32 < 0x10000)
                    {
                      if (a3)
                        (*(void (**)(uint64_t, unint64_t, char *))(a3 + 16))(a3, v32, &v44);
                    }
                    else
                    {
                      Diagnostics::error(a2, "BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB size too large");
LABEL_8:
                      v44 = 1;
                    }
                  }
                  goto LABEL_33;
                default:
                  Diagnostics::error(a2, "bad bind opcode 0x%02X");
LABEL_33:
                  v28 = v21;
LABEL_34:
                  v21 = v28;
                  if (v44)
                    return Diagnostics::hasError((Diagnostics *)a2);
                  continue;
              }
            }
          }
          return Diagnostics::hasError((Diagnostics *)a2);
        }
      }
    }
  }
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachChainedFixupTarget(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *LinkEditContent;
  uint64_t v16;
  _QWORD v17[5];
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[5];

  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)&v18);
  result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    __chkstk_darwin(result, v7, v8, v9, v10, v11, v12, v13, v16);
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000;
    v21[2] = ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    v21[3] = &__block_descriptor_tmp_58_0;
    v21[4] = &v17[-8 * v14 - 1];
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v21);
    result = Diagnostics::hasError((Diagnostics *)a2);
    if ((result & 1) == 0)
    {
      if (v18)
      {
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 0x40000000;
        v17[2] = ___ZNK5dyld313MachOAnalyzer25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke;
        v17[3] = &unk_1E4F7F3A8;
        v17[4] = a3;
        return dyld3::MachOAnalyzer::parseOrgArm64eChainedFixups(a1, a2, 0, (uint64_t)v17, 0);
      }
      else if (v19)
      {
        LinkEditContent = (unsigned int *)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v20, *(_DWORD *)(v19 + 8));
        return (uint64_t)dyld3::MachOFile::forEachChainedFixupTarget(a2, LinkEditContent, v19, a3);
      }
    }
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

double __Block_byref_object_copy__13(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  double result;
  uint64_t v4;

  v2 = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v2;
  result = 0.0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  v4 = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 96) = v4;
  *(_QWORD *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  return result;
}

_QWORD *__Block_byref_object_dispose__13(_QWORD *result)
{
  vm_address_t v1;

  result[10] = 0;
  v1 = result[11];
  if (v1)
    return (_QWORD *)vm_deallocate(mach_task_self_, v1, result[12]);
  return result;
}

void dyld3::MachOAnalyzer::forEachCDHash(_DWORD *a1, uint64_t a2)
{
  _DWORD *LinkEditContent;
  _BYTE v5[64];
  uint64_t v6;
  uint64_t v7;
  vm_address_t *v8;

  Diagnostics::Diagnostics((Diagnostics *)&v8);
  dyld3::MachOLoaded::getLinkEditPointers(a1, (vm_address_t *)&v8, (uint64_t)v5);
  if (!Diagnostics::hasError((Diagnostics *)&v8) && v6)
  {
    LinkEditContent = (_DWORD *)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v7, *(_DWORD *)(v6 + 8));
    dyld3::MachOFile::forEachCDHashOfCodeSignature((uint64_t)a1, LinkEditContent, *(unsigned int *)(v6 + 12), a2);
  }
  mach_o::Error::~Error(&v8);
}

uint64_t ___ZNK5dyld313MachOAnalyzer11neverUnloadEv_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  dyld3::MachOFile *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[7];

  v6 = *(dyld3::MachOFile **)(a1 + 40);
  result = (*(uint64_t (**)(void))(**(_QWORD **)(a1 + 48) + 16))();
  v9 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(*(_QWORD *)(v9 + 8) + 24))
  {
    v10 = *a4;
    v11 = *(_QWORD *)(a1 + 64);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    v12[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_4;
    v12[3] = &unk_1E4F7F560;
    v12[5] = *(_QWORD *)(a1 + 48);
    v12[6] = v10;
    v12[4] = v9;
    return dyld3::MachOAnalyzer::parseObjCClass(v6, v11, v10, v8, (uint64_t)v12);
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 40)
                                                                                                + 16))(**(_QWORD **)(a1 + 40), *(_QWORD *)(a1 + 48), a2, a3, a4, 1, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

BOOL dyld3::MachOAnalyzer::isSwiftClass(dyld3::MachOAnalyzer *this, _BYTE *a2)
{
  char v3;

  if (dyld3::MachOFile::pointerSize(this) == 8)
    v3 = a2[32];
  else
    v3 = a2[16];
  return (v3 & 3) != 0;
}

uint64_t dyld3::MachOAnalyzer::forEachObjCCategory(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10;
  uint64_t result;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;

  v10 = dyld3::MachOFile::pointerSize(a1);
  result = dyld3::MachOLoaded::getSlide(a1);
  v12 = result;
  v13 = (uint64_t *)((char *)a1 + a2);
  if (v10 == 8)
  {
    v28 = 0;
    if (a3)
    {
      v14 = a3 - 1;
      do
      {
        v15 = v14;
        v16 = *v13++;
        v17 = (uint64_t *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v16) + v12);
        v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v17);
        v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[1]);
        v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[2]);
        v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[3]);
        v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[4]);
        v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[5]);
        result = (*(uint64_t (**)(void))(*(_QWORD *)a5 + 16))();
        if (v28)
          break;
        v14 = v15 - 1;
      }
      while (v15);
    }
  }
  else
  {
    v28 = 0;
    if (a3)
    {
      v18 = a3 - 1;
      do
      {
        v19 = v18;
        v20 = *(_DWORD *)v13;
        v13 = (uint64_t *)((char *)v13 + 4);
        v21 = (unsigned int *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v20) + v12);
        v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v21);
        v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[1]);
        v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[2]);
        v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[3]);
        v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[4]);
        v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[5]);
        result = (*(uint64_t (**)(void))(*(_QWORD *)a5 + 16))();
        if (v28)
          break;
        v18 = v19 - 1;
      }
      while (v19);
    }
  }
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachObjCDuplicateClassToIgnore(dyld3::MachOFile *a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t result;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v4 = dyld3::MachOFile::pointerSize(a1);
  v9 = 0;
  result = dyld3::MachOLoaded::findSectionContent(a1, "__DATA", "__objc_dupclass", &v9);
  if (result)
  {
    if (v9 % v4)
      v6 = 1;
    else
      v6 = v9 == 0;
    if (!v6)
    {
      v7 = result;
      v8 = 0;
      do
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, *(_QWORD *)(v7 + v8) + 8);
        v8 += v4;
      }
      while (v8 != v9);
    }
  }
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachThreadLocalVariable(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[9];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  __n128 (*v12)(uint64_t, uint64_t);
  uint64_t (*v13)();
  uint64_t v14;
  uint64_t v15;

  v9 = 0;
  v10 = &v9;
  v11 = 0x3802000000;
  v12 = __Block_byref_object_copy__248;
  v13 = __Block_byref_object_dispose__249;
  v14 = 0;
  v15 = 0;
  if (dyld3::MachOFile::hasThreadLocalVariables(a1))
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = ___ZNK5dyld313MachOAnalyzer26forEachThreadLocalVariableER11DiagnosticsU13block_pointerFvPPFPvPNS0_9TLV_ThunkEEPmE_block_invoke;
    v8[3] = &unk_1E4F7F5B0;
    v8[6] = a1;
    v8[7] = a2;
    v8[4] = a3;
    v8[5] = &v9;
    v8[8] = dyld3::MachOFile::preferredLoadAddress(a1);
    dyld3::MachOFile::forEachSection(a1, (uint64_t)v8);
  }
  v6 = v10[5];
  _Block_object_dispose(&v9, 8);
  return v6;
}

__n128 __Block_byref_object_copy__248(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachThreadLocalVariableInSection<long long>(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  int v8;
  char *v9;
  char *v10;

  result = dyld3::MachOFile::preferredLoadAddress(a1);
  v8 = *(_QWORD *)(a3 + 72) / 0x18uLL;
  if (v8)
  {
    v9 = (char *)a1 + *(_QWORD *)(a3 + 64) - result;
    v10 = &v9[24 * v8];
    do
    {
      result = (*(uint64_t (**)(uint64_t, char *, char *))(a4 + 16))(a4, v9, v9 + 8);
      v9 += 24;
    }
    while (v9 < v10);
  }
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachThreadLocalVariableInSection<int>(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  int v8;
  char *v9;
  char *v10;

  result = dyld3::MachOFile::preferredLoadAddress(a1);
  v8 = *(_QWORD *)(a3 + 72) / 0xCuLL;
  if (v8)
  {
    v9 = (char *)a1 + *(_QWORD *)(a3 + 64) - result;
    v10 = &v9[12 * v8];
    do
    {
      result = (*(uint64_t (**)(uint64_t, char *, char *))(a4 + 16))(a4, v9, v9 + 4);
      v9 += 12;
    }
    while (v9 < v10);
  }
  return result;
}

void dyld3::MachOAnalyzer::forEachBindTarget(dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5)
{
  if (!dyld3::MachOFile::isPreload(a1))
  {
    if (dyld3::MachOFile::hasChainedFixups(a1))
    {
      dyld3::MachOAnalyzer::forEachBindTarget_ChainedFixups(a1, a2, a4);
    }
    else if (dyld3::MachOFile::hasOpcodeFixups(a1))
    {
      dyld3::MachOAnalyzer::forEachBindTarget_Opcodes(a1, a2, a3, a4, a5);
    }
  }
}

void dyld3::MachOAnalyzer::forEachBindTarget_ChainedFixups(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  _QWORD v6[6];
  _QWORD v7[6];
  _QWORD v8[3];
  int v9;

  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  v9 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke;
  v7[3] = &unk_1E4F7F6B8;
  v7[4] = a3;
  v7[5] = v8;
  dyld3::MachOAnalyzer::forEachChainedFixupTarget(a1, a2, (uint64_t)v7);
  if (Diagnostics::noError((Diagnostics *)a2)
    && dyld3::MachOFile::isMainExecutable(a1)
    && dyld3::MachOFile::hasWeakDefs(a1))
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2;
    v6[3] = &unk_1E4F7F6E0;
    v6[4] = a3;
    v6[5] = v8;
    dyld3::MachOFile::forEachTreatAsWeakDef((uint64_t)v6);
  }
  _Block_object_dispose(v8, 8);
}

void dyld3::MachOAnalyzer::forEachBindTarget_Opcodes(dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5)
{
  _QWORD v5[6];
  _QWORD v6[6];
  _QWORD v7[3];
  int v8;
  _QWORD v9[3];
  int v10;

  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x2000000000;
  v10 = -1;
  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  v8 = -1;
  v5[5] = v7;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke;
  v6[3] = &unk_1E4F7F668;
  v6[4] = a4;
  v6[5] = v9;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2;
  v5[3] = &unk_1E4F7F690;
  v5[4] = a5;
  dyld3::MachOAnalyzer::forEachBindUnified_Opcodes(a1, a2, a3, (uint64_t)v6, (uint64_t)v5);
  _Block_object_dispose(v7, 8);
  _Block_object_dispose(v9, 8);
}

__n128 __Block_byref_object_copy__251(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke(uint64_t result, uint64_t a2, _DWORD *a3)
{
  uint64_t v4;

  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) != *a3)
  {
    v4 = result;
    result = (*(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16))();
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24) = *a3;
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2(uint64_t result, uint64_t a2, _DWORD *a3)
{
  uint64_t v4;

  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) != *a3)
  {
    v4 = result;
    result = (*(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16))();
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24) = *a3;
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  _DWORD v10[2];
  uint64_t v11;
  uint64_t v12;
  char v13;
  char v14;

  v8 = a1 + 32;
  v7 = *(_QWORD *)(a1 + 32);
  v10[0] = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 8) + 24);
  v10[1] = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = 0;
  result = (*(uint64_t (**)(uint64_t, _DWORD *, uint64_t, uint64_t))(v7 + 16))(v7, v10, a6, a4);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  char v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;

  v4 = a1 + 32;
  v3 = *(_QWORD *)(a1 + 32);
  v7 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 8) + 8) + 24);
  v8 = -3;
  v9 = a2;
  v10 = 0;
  v11 = 0;
  v6 = 0;
  result = (*(uint64_t (**)(void))(v3 + 16))();
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t metadata_visitor::Visitor::getValueFor@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  if (!(_BYTE)a3 || !*(_BYTE *)(result + 24))
    std::__throw_bad_optional_access[abi:nn180100]();
  *a4 = *(_QWORD *)(result + 8) + a2 - *(_QWORD *)(result + 16);
  a4[1] = a2;
  a4[2] = a3;
  return result;
}

uint64_t (****mach_o::Platform::Platform(uint64_t (****this)(mach_o::PlatformInfo_macOS *__hidden this, unsigned __int16, BOOL), int a2))(mach_o::PlatformInfo_macOS *__hidden this, unsigned __int16, BOOL)
{
  uint64_t v2;
  uint64_t (***v3)(mach_o::PlatformInfo_macOS *__hidden, unsigned __int16, BOOL);
  int v4;

  v2 = 0;
  *this = 0;
  while (1)
  {
    v3 = mach_o::PlatformInfo::knownPlatformInfos[v2];
    v4 = *((_DWORD *)v3 + 2);
    if (!v4)
      mach_o::Platform::Platform();
    if (v4 == a2)
      break;
    if (++v2 == 31)
      return this;
  }
  *this = v3;
  return this;
}

BOOL mach_o::Platform::isExclaveKit(mach_o::Platform *this)
{
  return *(_QWORD *)this && *(_BYTE *)(*(_QWORD *)this + 50) != 0;
}

void mach_o::PlatformAndVersions::zip(uint64_t *a1@<X0>, uint64_t *a2@<X1>, mach_o::Error *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  const char *v9;
  const char *v10;
  uint64_t v11;
  vm_address_t *v12;

  if (!*a1)
  {
    *a1 = *a2;
LABEL_11:
    v8 = *(_OWORD *)(a2 + 1);
LABEL_12:
    *(_OWORD *)(a1 + 1) = v8;
LABEL_13:
    *(_QWORD *)a3 = 0;
    return;
  }
  if (*a2)
  {
    v12 = 0;
  }
  else
  {
    mach_o::Error::Error((mach_o::Error *)&v12, "unknown platform");
    if (v12)
    {
      mach_o::Error::Error(a3, "can't zip with invalid platform");
      mach_o::Error::~Error(&v12);
      return;
    }
  }
  mach_o::Error::~Error(&v12);
  v6 = *a1;
  v7 = *a2;
  if (*a1 == *a2)
    goto LABEL_11;
  if ((uint64_t (***)(mach_o::PlatformInfo_macOS *__hidden, unsigned __int16, BOOL))v6 == &mach_o::PlatformInfo_macOS::singleton)
  {
    if ((uint64_t (***)(mach_o::PlatformInfo *__hidden, unsigned __int16, BOOL))v7 == &mach_o::PlatformInfo_macCatalyst::singleton)
    {
      *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
      goto LABEL_18;
    }
    goto LABEL_22;
  }
  if ((uint64_t (***)(mach_o::PlatformInfo_macOS *__hidden, unsigned __int16, BOOL))v7 != &mach_o::PlatformInfo_macOS::singleton)
  {
    if ((uint64_t (***)(mach_o::PlatformInfo_macOS *__hidden, unsigned __int16, BOOL))v6 == &mach_o::PlatformInfo_zippered::singleton)
    {
      if ((uint64_t (***)(mach_o::PlatformInfo *__hidden, unsigned __int16, BOOL))v7 == &mach_o::PlatformInfo_macCatalyst::singleton)
      {
        *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
LABEL_18:
        a1[2] = a2[1];
        goto LABEL_13;
      }
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  if ((uint64_t (***)(mach_o::PlatformInfo *__hidden, unsigned __int16, BOOL))v6 == &mach_o::PlatformInfo_macCatalyst::singleton)
  {
    v8 = *(_OWORD *)(a2 + 1);
    v11 = a1[1];
    *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
LABEL_30:
    *((_QWORD *)&v8 + 1) = v11;
    goto LABEL_12;
  }
  if ((uint64_t (***)(mach_o::PlatformInfo_macOS *__hidden, unsigned __int16, BOOL))v6 == &mach_o::PlatformInfo_zippered::singleton)
  {
    v8 = *(_OWORD *)(a2 + 1);
    v11 = a1[2];
    *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
    goto LABEL_30;
  }
LABEL_21:
  if (!v6)
  {
    v9 = "unknown";
    if (v7)
      goto LABEL_23;
LABEL_25:
    v10 = "unknown";
    goto LABEL_26;
  }
LABEL_22:
  v9 = *(const char **)(v6 + 16);
  if (!v7)
    goto LABEL_25;
LABEL_23:
  v10 = *(const char **)(v7 + 16);
LABEL_26:
  mach_o::Error::Error(a3, "incompatible platforms: %s - %s", v9, v10);
}

uint64_t mach_o::PlatformInfo_macOS::versionForYear(mach_o::PlatformInfo_macOS *this, unsigned int a2, int a3)
{
  char v3;
  int v4;
  unsigned int v6;
  int v7;

  if (a2 == 2020)
    v3 = a3;
  else
    v3 = 1;
  if (a2 <= 0x7E4 && (v3 & 1) != 0)
  {
    if (a3)
      v4 = 655364;
    else
      v4 = 655360;
    return ((((_WORD)a2 - (_WORD)a3) << 8) + 11264) & 0xFF00 | v4;
  }
  else
  {
    v6 = a2 - *((unsigned __int16 *)this + 27);
    if (a3)
      v7 = (*(unsigned __int8 (**)(mach_o::PlatformInfo_macOS *, _QWORD))(*(_QWORD *)this + 16))(this, (unsigned __int16)--v6) << 8;
    else
      v7 = 0;
    return v7 | (v6 << 16);
  }
}

_WORD *mach_o::PlatformInfo_macOS::yearForVersion(_WORD *result, unsigned int a2, _WORD *a3, BOOL *a4)
{
  unsigned int v6;
  __int16 v7;
  unsigned int v8;

  if (a2 < 0xB0000)
  {
    v8 = (a2 + 16121856) >> 8;
    *a3 = v8 + 2004;
    *a4 = (a2 & 0xFC) != 0;
    if ((a2 & 0xFC) == 0)
      return result;
    v7 = v8 + 2003;
  }
  else
  {
    *a3 = result[27] + HIWORD(a2);
    v6 = BYTE1(a2);
    result = (_WORD *)(*(uint64_t (**)(_WORD *, _QWORD))(*(_QWORD *)result + 16))(result, HIWORD(a2));
    *a4 = v6 >= result;
    if (v6 < result)
      return result;
    v7 = *a3 + 1;
  }
  *a3 = v7;
  return result;
}

uint64_t mach_o::PlatformInfo_macOS::minorVersionForSpring(mach_o::PlatformInfo_macOS *this, unsigned int a2)
{
  if (a2 < 0xE)
    return 3;
  else
    return 4;
}

uint64_t mach_o::PlatformInfo::versionForYear(mach_o::PlatformInfo *this, int a2, int a3)
{
  int v3;
  int v4;

  v3 = a2 - *((unsigned __int16 *)this + 27);
  if (a3)
    v4 = (*(unsigned __int8 (**)(mach_o::PlatformInfo *, _QWORD))(*(_QWORD *)this + 16))(this, (unsigned __int16)--v3) << 8;
  else
    v4 = 0;
  return v4 | (v3 << 16);
}

uint64_t mach_o::PlatformInfo::yearForVersion(_WORD *a1, int a2, _WORD *a3, BOOL *a4)
{
  unsigned int v6;
  uint64_t result;

  *a3 = a1[27] + HIWORD(a2);
  v6 = BYTE1(a2);
  result = (*(uint64_t (**)(_WORD *, _QWORD))(*(_QWORD *)a1 + 16))(a1, HIWORD(a2));
  *a4 = v6 >= result;
  if (v6 >= result)
    ++*a3;
  return result;
}

uint64_t mach_o::PlatformInfo::minorVersionForSpring(mach_o::PlatformInfo *this)
{
  return 4;
}

uint64_t mach_o::PlatformInfo_bridgeOS::minorVersionForSpring(mach_o::PlatformInfo_bridgeOS *this, unsigned int a2)
{
  if (a2 < 9)
    return 3;
  else
    return 4;
}

uint64_t mach_o::PlatformInfo_firmware::versionForYear(mach_o::PlatformInfo_firmware *this)
{
  return 0x10000;
}

void mach_o::PlatformInfo_firmware::yearForVersion(uint64_t a1, uint64_t a2, _WORD *a3, _BYTE *a4)
{
  *a3 = 2020;
  *a4 = 0;
}

uint64_t mach_o::PlatformInfo_sepOS::versionForYear(mach_o::PlatformInfo_sepOS *this)
{
  return 0x10000;
}

void mach_o::PlatformInfo_sepOS::yearForVersion(uint64_t a1, uint64_t a2, _WORD *a3, _BYTE *a4)
{
  *a3 = 2020;
  *a4 = 0;
}

uint64_t mach_o::PlatformInfo_visionOS::minorVersionForSpring(mach_o::PlatformInfo_visionOS *this, int a2)
{
  if (a2 == 1)
    return 1;
  else
    return 4;
}

uint64_t amfi_load_trust_cache(char a1, uint64_t a2, int a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  _QWORD v9[2];
  int v10;
  int v11;
  void *v12;
  int v13;
  int v14;
  void *v15;
  int v16;
  int v17;

  v9[0] = 0xAAAAAAAAAAAAAAAALL;
  v11 = -1431655766;
  v14 = -1431655766;
  LOBYTE(v9[0]) = a1;
  v9[1] = a2;
  v10 = a3;
  v12 = a4;
  v13 = (int)a5;
  v15 = a6;
  v17 = -1431655766;
  v16 = (int)a7;
  return __sandbox_ms("AMFI", (void *)0x65, v9, a4, a5, a6, a7, a8);
}

uint32_t arc4random(void)
{
  int v0;
  char v1;
  char v2;
  uint64_t v3;
  unsigned __int8 v4;
  char v5;
  uint64_t v6;
  unsigned __int8 v7;
  int v8;
  uint64_t v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  int v13;
  uint64_t v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 v21;
  int v22;

  os_unfair_lock_lock(&arc4_lock);
  v0 = arc4_count;
  if (arc4_count > 0)
    v1 = rs_stired;
  else
    v1 = 0;
  if ((v1 & 1) == 0)
  {
    arc4_stir();
    v0 = arc4_count;
  }
  v2 = rs;
  v3 = (rs + 1);
  v4 = byte_1EE805C22[v3];
  v5 = byte_1EE805C21 + v4;
  v6 = (byte_1EE805C21 + v4);
  v7 = byte_1EE805C22[v6];
  byte_1EE805C22[v3] = v7;
  byte_1EE805C22[v6] = v4;
  v8 = byte_1EE805C22[(v7 + v4)];
  v9 = (v2 + 2);
  v10 = byte_1EE805C22[v9];
  v11 = v10 + v5;
  v12 = byte_1EE805C22[v11];
  byte_1EE805C22[v9] = v12;
  byte_1EE805C22[v11] = v10;
  v13 = byte_1EE805C22[(v12 + v10)];
  v14 = (v2 + 3);
  v15 = byte_1EE805C22[v14];
  v16 = v15 + v11;
  v17 = byte_1EE805C22[v16];
  byte_1EE805C22[v14] = v17;
  byte_1EE805C22[v16] = v15;
  v18 = byte_1EE805C22[(v17 + v15)];
  rs = v2 + 4;
  v19 = (v2 + 4);
  LOBYTE(v14) = byte_1EE805C22[v19];
  byte_1EE805C21 = v14 + v16;
  v20 = (v14 + v16);
  v21 = byte_1EE805C22[v20];
  byte_1EE805C22[v19] = v21;
  byte_1EE805C22[v20] = v14;
  v22 = byte_1EE805C22[(v21 + v14)];
  arc4_count = v0 - 4;
  os_unfair_lock_unlock(&arc4_lock);
  if ((v1 & 1) == 0)
  {
    arc4_fetch();
    rs_data_available = 1;
    __dmb(0xBu);
  }
  return (v8 << 24) | (v13 << 16) | (v18 << 8) | v22;
}

uint64_t arc4_fetch()
{
  uint64_t result;
  int v1;
  int v2;
  unint64_t v3;
  char *v4;
  size_t v5;
  BOOL v6;

  result = getentropy(&rdat, 0x80uLL);
  if ((_DWORD)result)
  {
    v1 = open("/dev/random", 0, 0);
    if (v1 == -1 || (v2 = v1, v3 = read(v1, &rdat, 0x80uLL), v3 == -1))
LABEL_8:
      abort();
    v4 = (char *)&rdat;
    v5 = 128;
    while (1)
    {
      v6 = v5 > v3;
      v5 -= v3;
      if (!v6)
        return close(v2);
      v4 += v3;
      v3 = read(v2, v4, v5);
      if (v3 == -1)
        goto LABEL_8;
    }
  }
  return result;
}

uint64_t arc4_stir()
{
  uint64_t result;
  int v1;
  unsigned __int8 v2;
  int v3;
  int v4;
  int v5;
  unsigned __int8 v6;
  unsigned __int8 v7;

  if (!rs_data_available)
    result = arc4_fetch();
  v1 = 0;
  rs_data_available = 0;
  __dmb(0xBu);
  v2 = rs - 1;
  v3 = byte_1EE805C21;
  do
  {
    v4 = byte_1EE805C22[++v2];
    v3 += v4 + rdat[v1 & 0x7F];
    byte_1EE805C22[v2] = byte_1EE805C22[v3];
    byte_1EE805C22[v3] = v4;
    ++v1;
  }
  while (v1 != 256);
  v5 = 1024;
  v6 = v2;
  do
  {
    v7 = byte_1EE805C22[++v6];
    v2 += v7;
    byte_1EE805C22[v6] = byte_1EE805C22[v2];
    byte_1EE805C22[v2] = v7;
    --v5;
  }
  while (v5);
  rs = v6;
  byte_1EE805C21 = v2;
  arc4_count = 1600000;
  rs_stired = 1;
  return result;
}

_BYTE *extract_next_subsystem_root_path(void *a1, char *__s)
{
  size_t v4;
  _BYTE *v5;
  _BYTE *v7;

  v4 = _platform_strlen(__s);
  v5 = _platform_memchr(__s, 58, v4);
  if (v5)
    v4 = v5 - __s;
  if (v4 > 0x3FF)
    return 0;
  v7 = v5;
  memmove(a1, __s, v4);
  *((_BYTE *)a1 + v4) = 0;
  if (v7)
    return v7 + 1;
  else
    return 0;
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  size_t v4;
  size_t v5;

  v4 = _platform_strlen(__s1);
  v5 = _platform_strlen(__s2);
  memmove(&__s1[v4], __s2, v5 + 1);
  return __s1;
}

uint64_t cryptex_graft_failure_exists(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;

  v8 = a2;
  v10 = configuration(a1, a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)v8 == 37 && *(_BYTE *)(v10 + 7034))
  {
    v8 = 0;
    *(_QWORD *)(a1 + 120) = 0;
  }
  return v8;
}

uint64_t cryptex_spec_next(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v3;
  char *v4;
  uint64_t result;

  v1 = *a1;
  if ((unint64_t)*a1 > 1)
    return 0;
  while (1)
  {
    v3 = v1;
    v4 = __specs[(*a1)++];
    result = (*((uint64_t (**)(void))v4 + 16))();
    if (result)
      break;
    v1 = 1;
    if (v3)
      return 0;
  }
  return result;
}

uint64_t _graft_payload_check()
{
  return 0;
}

uint64_t _graft_fire(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t trust_cache;
  pid_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  pid_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  pid_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  pid_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v75;
  int v76;
  _QWORD *v77;
  _QWORD v78[3];
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  uint64_t v84[2];

  v84[0] = 0;
  v5 = cryptex_spec_next(v84);
  if (!v5)
  {
    LODWORD(trust_cache) = -1;
    goto LABEL_17;
  }
  v13 = v5;
  do
  {
    bzero(v78, 0x488uLL);
    v79 = -1;
    v80 = -1;
    v81 = -1;
    v82 = -1;
    v83 = -1;
    v77 = 0;
    v75 = -1;
    v76 = -1;
    v77 = cryptex_init(v78, v13, a3, a1);
    v20 = cryptex_open((uint64_t)v77, &v75, v14, v15, v16, v17, v18, v19);
    if ((_DWORD)v20)
    {
      trust_cache = v20;
      v28 = getpid();
      dlog(-1, "libignition: %d: %12s: failed to open %s cryptex: %d\n", v29, v30, v31, v32, v33, v34, v28);
    }
    else
    {
      v35 = cryptex_graft(v77, &v76, v21, v22, v23, v24, v25, v26);
      if ((_DWORD)v35)
      {
        trust_cache = v35;
        v43 = getpid();
        dlog(-1, "libignition: %d: %12s: failed to graft %s cryptex: %d\n", v44, v45, v46, v47, v48, v49, v43);
      }
      else
      {
        trust_cache = cryptex_load_trust_cache(v77, v36, v37, v38, v39, v40, v41, v42);
        v50 = getpid();
        if ((_DWORD)trust_cache)
        {
          dlog(-1, "libignition: %d: %12s: failed to load trust cache: cryptex = %s: %d\n", v51, v52, v53, v54, v55, v56, v50);
          if (trust_cache >= 0x6A)
            goto LABEL_17;
          v57 = getpid();
          dlog(-1, "libignition: %d: %12s: failed to load trust cache for %s cryptex: %d\n", v58, v59, v60, v61, v62, v63, v57);
        }
        else
        {
          dlog(-1, "libignition: %d: %12s: loaded trust cache: cryptex = %s\n", v51, v52, v53, v54, v55, v56, v50);
          boot_set_root(a3, *(_QWORD *)(v13 + 80), &v76, v64, v65, v66, v67, v68);
          boot_set_root(a3, *(_QWORD *)(v13 + 88), &v75, v69, v70, v71, v72, v73);
        }
      }
    }
    closefd_optional(&v75, (int)"canonical root");
    closefd_optional(&v76, (int)"graft point");
    cryptex_destroy(&v77);
    if ((_DWORD)trust_cache)
    {
      if (trust_cache < 0x6A)
        return trust_cache;
LABEL_17:
      dyld_halt("error not set to valid posix code: %d", v6, v7, v8, v9, v10, v11, v12, trust_cache);
    }
    v13 = cryptex_spec_next(v84);
  }
  while (v13);
  return 0;
}

uint64_t _hello_payload_check()
{
  return 0;
}

uint64_t _goodbye_payload_check()
{
  return 0;
}

char **_cryptex_spec_iterate_select_app(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  pid_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v34;

  v8 = a1;
  v9 = configuration(a1, a2, a3, a4, a5, a6, a7, a8);
  v17 = arguments(v9, v10, v11, v12, v13, v14, v15, v16);
  boot_get();
  if ((*(_BYTE *)(*(_QWORD *)(v9 + 6792) + 67) & 0x40) == 0)
  {
    v18 = getpid();
    dlog(-1, "libignition: %d: livefs boot; skipping app cryptex\n", v19, v20, v21, v22, v23, v24, v18);
    v32 = *(_QWORD *)(v17 + 16);
    if ((unint64_t)(v32 - 1) >= 2)
    {
      if (v32)
        dyld_halt("unreachable", v25, v26, v27, v28, v29, v30, v31, v34);
      return &_cryptex_spec_app_livefs;
    }
  }
  return (char **)v8;
}

_QWORD *cryptex_init(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;

  v4 = 0;
  result[1] = a3;
  result[2] = a4;
  *result = a2;
  do
  {
    v5 = &result[v4];
    v5[4] = 0;
    *((_DWORD *)v5 + 10) = -1;
    v4 += 2;
  }
  while (v4 != 8);
  return result;
}

uint64_t cryptex_open(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  dyld4::JustInTimeLoader *v11;
  unint64_t v12;
  int v13;
  ssize_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  pid_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  pid_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  pid_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  pid_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  pid_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int *v84;
  pid_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  const char *v105;
  int v106;
  uint64_t v107;
  pid_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  pid_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  pid_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  pid_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  pid_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  int v153;
  dyld4::JustInTimeLoader *v154;
  uint64_t CatalystMacTwinPatches;
  pid_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  pid_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  pid_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  pid_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  char ***v185;
  char *v186;
  unint64_t v187;
  int v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  char ***v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  char ***v198;
  char *v199;
  unint64_t v200;
  int v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  char ***v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  dyld4::JustInTimeLoader *v213;
  int v214;
  _DWORD v215[256];
  int v216;
  _QWORD v217[3];
  int v218;
  char value[1032];

  v213 = *(dyld4::JustInTimeLoader **)a1;
  v214 = -1;
  v10 = configuration(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v11 = *(dyld4::JustInTimeLoader **)a1;
  bzero(value, 0x400uLL);
  memset(v217, 0, sizeof(v217));
  v12 = *((_QWORD *)v11 + 7);
  v216 = -1;
  v13 = openat(*(_DWORD *)(*(_QWORD *)(a1 + 8) + 16), *((const char **)v11 + 9), 0x200000);
  v218 = v13;
  if (v13 < 0)
  {
    bzero(v215, 0x400uLL);
    realpathfd(*(_DWORD *)(*(_QWORD *)(a1 + 8) + 16), (uint64_t)v215, (int)"rootmnt");
    v185 = boot_get();
    v186 = (*v185)[1];
    v187 = (unint64_t)(*v185)[2];
    v188 = *__error();
    __error();
    ignition_halt(v186, v188, v187, "failed to open canonical cryptex location: root = %s, subpath = %s: %d", v189, v190, v191, v192, (int)v215);
  }
  v14 = fgetxattr(v13, "com.apple.root.cryptex", value, 0x400uLL, 0, 0);
  v15 = __error();
  if (v14 < 0)
  {
    if (!*v15)
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v16, v17, v18, v19, v20, v21, v22, (int)"xattr_len");
  }
  else
  {
    *v15 = 0;
  }
  v23 = *__error();
  if (v23 == 93)
    goto LABEL_10;
  if (v23)
  {
    v198 = boot_get();
    v199 = (*v198)[1];
    v200 = (unint64_t)(*v198)[2];
    v201 = *__error();
    v202 = *((_QWORD *)v11 + 9);
    __error();
    ignition_halt(v199, v201, v200, "failed to read xattr: path = %s, attr = %s: %d", v203, v204, v205, v206, v202);
  }
  value[v14] = 0;
  if (!_platform_strlen(value))
  {
    v32 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: root xattr empty\n", v33, v34, v35, v36, v37, v38, v32);
LABEL_10:
    v39 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: no root xattr present\n", v40, v41, v42, v43, v44, v45, v39);
    v31 = 0;
    goto LABEL_11;
  }
  v217[0] = value;
  ++v12;
  v24 = getpid();
  dlog(-1, "libignition: %d: %12s: %s: found root xattr: %s\n", v25, v26, v27, v28, v29, v30, v24);
  v31 = 1;
LABEL_11:
  closefd(&v218, (int)"canonical cryptex");
  if (v12 > 3)
  {
    v193 = boot_get();
    ignition_halt((*v193)[1], 0, (unint64_t)(*v193)[2], "path count overflow: actual = %lu, expected <= %lu", v194, v195, v196, v197, v12);
  }
  v212 = v10;
  v46 = v12 - v31;
  if (v12 > v31)
  {
    v47 = &v217[v31];
    v48 = (uint64_t *)((char *)v11 + 32);
    do
    {
      v49 = *v48++;
      *v47++ = v49;
      --v46;
    }
    while (v46);
  }
  v50 = 0;
  while (1)
  {
    v51 = (const char *)v217[v50];
    v52 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: opening preboot subdirectory: %s\n", v53, v54, v55, v56, v57, v58, v52);
    v59 = openat(*(_DWORD *)(*(_QWORD *)(a1 + 8) + 24), v51, 537919488);
    v216 = v59;
    v60 = __error();
    if (v59 < 0)
    {
      if (!*v60)
        dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v61, v62, v63, v64, v65, v66, v67, (int)"pbobjdir");
    }
    else
    {
      *v60 = 0;
    }
    v68 = *__error();
    if (v68 == 2)
    {
      v84 = __error();
      if (v51 == value)
        dyld_halt("root object directory does not exist: %s", v77, v78, v79, v80, v81, v82, v83, (int)value);
      v69 = *v84;
      goto LABEL_24;
    }
    if (!v68)
      break;
    v69 = *__error();
    v70 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: failed to open preboot subdirectory: %s: %d\n", v71, v72, v73, v74, v75, v76, v70);
LABEL_24:
    if ((_DWORD)v69 == 2 && ++v50 < v12)
      continue;
    if (v59 < 0)
      goto LABEL_28;
    goto LABEL_27;
  }
  if (v51 == value)
  {
    strlcpy((char *)(a1 + 128), value, 0x400uLL);
    *(_QWORD *)(a1 + 1152) = a1 + 128;
  }
  v145 = getpid();
  dlog(-1, "libignition: %d: %12s: %s: opened preboot subdirectory: %s\n", v146, v147, v148, v149, v150, v151, v145);
  v69 = 0;
  if ((v59 & 0x80000000) == 0)
LABEL_27:
    *(_DWORD *)(a1 + 24) = xferfd(&v216);
LABEL_28:
  if (v69 >= 0x6A)
    goto LABEL_34;
  if ((_DWORD)v69)
  {
    v85 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: failed to open object directory: %d\n", v86, v87, v88, v89, v90, v91, v85);
    goto LABEL_31;
  }
  v94 = openat(*(_DWORD *)(*(_QWORD *)(a1 + 8) + 16), *((const char **)v213 + 9), 0x100000);
  v214 = v94;
  if ((v94 & 0x80000000) != 0)
  {
    v69 = *__error();
    v156 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: failed to open canonical root: %d\n", v157, v158, v159, v160, v161, v162, v156);
    if (!(_DWORD)v69)
      goto LABEL_63;
    goto LABEL_31;
  }
  v102 = 0;
  while (2)
  {
    v103 = *((_QWORD *)v213 + v102 + 12);
    if (!v103)
    {
      v108 = getpid();
      v94 = dlog(-1, "libignition: %d: %12s: %s: object spec not present: %lu\n", v109, v110, v111, v112, v113, v114, v108);
      goto LABEL_47;
    }
    v104 = configuration(v94, v95, v96, v97, v98, v99, v100, v101);
    v105 = *(const char **)(v103 + 16);
    v106 = *(_DWORD *)(v103 + 12);
    LODWORD(v217[0]) = -1;
    bzero(value, 0x400uLL);
    v107 = *(_QWORD *)(a1 + 1152);
    if (!v105)
      v105 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, char *))(v103 + 24))(v103, v104, value);
    v215[0] = openat(*(_DWORD *)(a1 + 24), v105, v106);
    if ((v215[0] & 0x80000000) == 0)
    {
      LODWORD(v217[0]) = xferfd(v215);
      goto LABEL_46;
    }
    v122 = *__error();
    if (v122 >= 0x6A)
      goto LABEL_76;
    if ((_DWORD)v122 != 2)
    {
      if ((_DWORD)v122)
      {
        v171 = getpid();
        dlog(-1, "libignition: %d: %12s: %s: failed to open object: name = %s, type = %s: %d\n", v172, v173, v174, v175, v176, v177, v171);
        goto LABEL_67;
      }
LABEL_46:
      object_setfd(v103, a1 + 32, v217);
      v123 = getpid();
      v94 = dlog(-1, "libignition: %d: %12s: %s: opened object: name = %s, type = %s, slot = %llu\n", v124, v125, v126, v127, v128, v129, v123);
LABEL_47:
      if (++v102 != 4)
        continue;
      v152 = *(_QWORD *)(v212 + 6952);
      if (v152)
      {
        v153 = *(_DWORD *)(v152 + 46);
        if ((v153 - 1) < 3)
        {
          v154 = v213;
          CatalystMacTwinPatches = dyld4::JustInTimeLoader::getCatalystMacTwinPatches(v213);
LABEL_62:
          *(_QWORD *)(a1 + 96) = CatalystMacTwinPatches;
          v163 = getpid();
          dlog(-1, "libignition: %d: %12s: %s: selected im4m spec: %s\n", v164, v165, v166, v167, v168, v169, v163);
          *(_QWORD *)(a1 + 104) = *((_QWORD *)v154 + 13);
          *(_QWORD *)(a1 + 112) = *((_QWORD *)v154 + 14);
          *(_QWORD *)(a1 + 120) = *((_QWORD *)v154 + 15);
          *a2 = xferfd(&v214);
          goto LABEL_63;
        }
        if (v153)
        {
          v207 = boot_get();
          ignition_halt((*v207)[1], 0, (unint64_t)(*v207)[2], "bogus secure boot level: 0x%x", v208, v209, v210, v211, v153);
        }
      }
      v154 = v213;
      CatalystMacTwinPatches = *((_QWORD *)v213 + 12);
      goto LABEL_62;
    }
    break;
  }
  v130 = getpid();
  dlog(-1, "libignition: %d: %12s: %s: object not present: name = %s, type = %s\n", v131, v132, v133, v134, v135, v136, v130);
  v137 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v103 + 32))(v103, v107, 2);
  if (!(_DWORD)v137)
  {
    v138 = getpid();
    v94 = dlog(-1, "libignition: %d: %12s: %s: object absence permitted: name = %s, type = %s, xattr path = %s\n", v139, v140, v141, v142, v143, v144, v138);
    goto LABEL_47;
  }
  v122 = v137;
  if (v137 >= 0x6A)
LABEL_76:
    dyld_halt("error not set to valid posix code: %d", v115, v116, v117, v118, v119, v120, v121, v122);
LABEL_67:
  v178 = getpid();
  dlog(-1, "libignition: %d: %12s: %s: failed to open object: %s: %d\n", v179, v180, v181, v182, v183, v184, v178);
  v69 = v122;
  if (!(_DWORD)v122)
  {
LABEL_63:
    closefd_optional(&v214, (int)"canonical root");
    return 0;
  }
LABEL_31:
  v92 = 0;
  v93 = a1 + 32;
  do
  {
    object_fd_close(v93 + v92);
    v92 += 16;
  }
  while (v92 != 64);
  closefd_optional(&v214, (int)"canonical root");
  if (v69 >= 0x6A)
LABEL_34:
    dyld_halt("error not set to valid posix code: %d", v77, v78, v79, v80, v81, v82, v83, v69);
  return v69;
}

uint64_t cryptex_graft(_QWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  int v11;
  const char *v12;
  uint64_t v13;
  void *v14;
  int v15;
  int v16;
  int v17;
  pid_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  uint64_t v29;
  pid_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  pid_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  pid_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  pid_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  pid_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  pid_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char ***v73;
  char *v74;
  unint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  pid_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  char ***v96;
  char *v97;
  unint64_t v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  int v105;
  int v106;
  _DWORD v107[2];
  uint64_t v108;
  int v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  _BYTE v139[28];
  _BYTE v140[1024];
  _BYTE v141[1024];
  _BYTE v142[1024];
  _BYTE v143[1024];
  int v144[3];

  arguments((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v144[0] = -1;
  bzero(v143, 0x400uLL);
  bzero(v142, 0x400uLL);
  bzero(v141, 0x400uLL);
  bzero(v140, 0x400uLL);
  v138 = 0u;
  memset(v139, 0, sizeof(v139));
  v136 = 0u;
  v137 = 0u;
  v134 = 0u;
  v135 = 0u;
  v132 = 0u;
  v133 = 0u;
  v130 = 0u;
  v131 = 0u;
  v128 = 0u;
  v129 = 0u;
  v126 = 0u;
  v127 = 0u;
  v125 = 0u;
  v124 = 0u;
  v123 = 0u;
  v122 = 0u;
  v121 = 0u;
  v120 = 0u;
  v119 = 0u;
  v118 = 0u;
  v117 = 0u;
  v116 = 0u;
  v115 = 0u;
  v114 = 0u;
  v113 = 0u;
  v112 = 0u;
  v111 = 0u;
  v110 = 0u;
  v10 = *a1;
  v11 = *(_DWORD *)(*a1 + 20);
  v107[0] = 1;
  v107[1] = v11;
  v108 = -1;
  v109 = -1;
  v12 = *(const char **)(v10 + 64);
  v106 = -1;
  v13 = a1[13];
  if (v13)
  {
    v14 = (void *)object_getfd(v13, (uint64_t)(a1 + 4));
    v15 = object_getfd(a1[14], (uint64_t)(a1 + 4));
    v16 = object_getfd(a1[12], (uint64_t)(a1 + 4));
    realpathfd((int)v14, (uint64_t)v143, (int)"dmg");
    realpathfd(v15, (uint64_t)v142, (int)"seal im4p");
    realpathfd(v16, (uint64_t)v140, (int)"chosen im4m");
    v17 = openat(*(_DWORD *)(a1[1] + 20), v12, 537919488);
    v144[0] = v17;
    if (v17 < 0)
    {
      v29 = *__error();
      v44 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: failed to open graft point: %s: %d\n", v45, v46, v47, v48, v49, v50, v44);
    }
    else
    {
      realpathfd(v17, (uint64_t)v141, (int)"uncovered graft point");
      v109 = v15;
      LODWORD(v108) = v16;
      *(_QWORD *)&v110 = *(unsigned int *)(*a1 + 12);
      v18 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: grafting: method = syscall, dmg = %s, seal = %s, graft point = %s, im4m = %s\n", v19, v20, v21, v22, v23, v24, v18);
      if (graftdmg(v14, v141, (void *)*(unsigned int *)(*a1 + 8), v107, v25, v26, v27, v28))
      {
        v29 = *__error();
        v30 = getpid();
        dlog(-1, "libignition: %d: %12s: %s: graftdmg: %d\n", v31, v32, v33, v34, v35, v36, v30);
      }
      else
      {
        v29 = 0;
      }
    }
  }
  else
  {
    v37 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: cryptex has no associated disk image\n", v38, v39, v40, v41, v42, v43, v37);
    v29 = 21;
  }
  v51 = (*(uint64_t (**)(_QWORD *, uint64_t))(*a1 + 136))(a1, v29);
  if ((_DWORD)v51)
  {
    v52 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: graft failed [%s]: %d\n", v53, v54, v55, v56, v57, v58, v52);
  }
  else
  {
    if ((_DWORD)v29 == 37)
    {
      v66 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: cryptex content already available: dmg = %s, graft point = %s, ignored error = %d\n", v67, v68, v69, v70, v71, v72, v66);
      v106 = openat(*(_DWORD *)(a1[1] + 20), v12, 537919488);
      if (v106 < 0)
      {
        v73 = boot_get();
        v74 = (*v73)[1];
        v75 = (unint64_t)(*v73)[2];
        v76 = *__error();
        v104 = *__error();
        ignition_halt(v74, v76, v75, "failed to open covered graft point: %d", v77, v78, v79, v80, v104);
      }
    }
    else if ((_DWORD)v29)
    {
      v81 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: cryptex not grafted; ignoring failure: dmg = %s, ignored error = %d\n",
        v82,
        v83,
        v84,
        v85,
        v86,
        v87,
        v81);
      v106 = open("/dev/null", 0);
      if (v106 < 0)
      {
        v96 = boot_get();
        v97 = (*v96)[1];
        v98 = (unint64_t)(*v96)[2];
        v99 = *__error();
        v105 = *__error();
        ignition_halt(v97, v99, v98, "failed to open /dev/null for fallback: %d", v100, v101, v102, v103, v105);
      }
    }
    else
    {
      v59 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: grafted cryptex: dmg = %s, graft point = %s, ignored error = %d\n", v60, v61, v62, v63, v64, v65, v59);
      v106 = xferfd(v144);
    }
    *a2 = xferfd(&v106);
  }
  closefd_optional(v144, (int)"uncovered graft point");
  closefd_optional(&v106, (int)"covered graft point");
  if (v51 >= 0x6A)
    dyld_halt("error not set to valid posix code: %d", v88, v89, v90, v91, v92, v93, v94, v51);
  return v51;
}

uint64_t cryptex_load_trust_cache(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *v9;
  unint64_t v10;
  pid_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  pid_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  pid_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  pid_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  pid_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  pid_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int length_uint32;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void *v82;
  void *v83;
  pid_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  pid_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  _OWORD v98[2];
  uint64_t v99;
  void **v100;
  _OWORD v101[2];
  uint64_t v102;
  uint64_t *v103;
  _BYTE v104[1024];

  v9 = (unint64_t *)arguments((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  v10 = *(_QWORD *)(a1[2] + 40) + 2;
  bzero(v104, 0x400uLL);
  v102 = 0;
  v103 = 0;
  memset(v101, 0, sizeof(v101));
  v99 = 0;
  v100 = 0;
  memset(v98, 0, sizeof(v98));
  if (*v9 < v10)
  {
    v11 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: ignition level insufficient: operation = load trust cache, actual = %llu, required >= %llu\n", v12, v13, v14, v15, v16, v17, v11);
    return 0;
  }
  if (!a1[15])
  {
    v28 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: cryptex already available; skipping trust cache load\n",
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v28);
    return 0;
  }
  v18 = object_getfd(a1[12], (uint64_t)(a1 + 4));
  v19 = object_getfd(a1[15], (uint64_t)(a1 + 4));
  v20 = v19;
  if (a1[144] && v19 < 0)
  {
    v21 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: trust cache not present in rooted cryptex\n", v22, v23, v24, v25, v26, v27, v21);
    return 0;
  }
  realpathfd(v19, (uint64_t)v104, (int)"trust cache");
  v37 = getpid();
  dlog(-1, "libignition: %d: %12s: %s: trust cache path = %s\n", v38, v39, v40, v41, v42, v43, v37);
  v44 = buff_map_fd_anon(v101, &v103, v20);
  if ((_DWORD)v44)
  {
    v35 = v44;
    v45 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: failed to read trust cache im4p: %d\n", v46, v47, v48, v49, v50, v51, v45);
  }
  else
  {
    v59 = buff_map_fd_anon(v98, &v100, v18);
    if ((_DWORD)v59)
    {
      v35 = v59;
      v67 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: failed to read manifest: %d\n", v68, v69, v70, v71, v72, v73, v67);
    }
    else
    {
      length_uint32 = buff_get_length_uint32((uint64_t)v103, v60, v61, v62, v63, v64, v65, v66);
      v82 = (void *)buff_get_length_uint32((uint64_t)v100, v75, v76, v77, v78, v79, v80, v81);
      if (!amfi_load_trust_cache)
        return 78;
      if (!amfi_load_trust_cache(*(_BYTE *)(*a1 + 16), *v103, length_uint32, *v100, v82, 0, 0, v83))
      {
        v91 = getpid();
        dlog(-1, "libignition: %d: %12s: %s: loaded cryptex trust cache\n", v92, v93, v94, v95, v96, v97, v91);
        return 0;
      }
      v35 = *__error();
      v84 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: failed to load trust cache: %d\n", v85, v86, v87, v88, v89, v90, v84);
    }
  }
  if (v35 >= 0x6A)
    dyld_halt("error not set to valid posix code: %d", v52, v53, v54, v55, v56, v57, v58, v35);
  return v35;
}

_QWORD *cryptex_destroy(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *result;
  if (*result)
  {
    v2 = result;
    closefd_optional((int *)(v1 + 24), (int)"object directory");
    v3 = 0;
    v4 = v1 + 32;
    do
    {
      result = (_QWORD *)object_fd_close(v4 + v3);
      v3 += 16;
    }
    while (v3 != 64);
    *v2 = 0;
  }
  return result;
}

uint64_t _graft_select_payload_check()
{
  return 0;
}

uint64_t _graft_fetch_payload_check()
{
  return 0;
}

uint64_t _preboot_payload_check(uint64_t a1, uint64_t a2)
{
  return (a2 + *(_QWORD *)(a1 + 32)) & ~(*(uint64_t *)(a1 + 32) >> 63);
}

uint64_t _preboot_fire(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t devnode_by_role;
  pid_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  pid_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v38;
  pid_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  pid_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  pid_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  pid_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  pid_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  pid_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  int v95;
  stat v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  int v117;
  uint64_t v118;
  char *v119;
  char v120[1024];
  char v121[256];

  configuration(a1, a2, a3, a4, a5, a6, a7, a8);
  memset(v121, 0, 255);
  bzero(v120, 0x400uLL);
  v119 = 0;
  v117 = 0;
  v115 = 0u;
  v116 = 0u;
  v113 = 0u;
  v114 = 0u;
  v111 = 0u;
  v112 = 0u;
  v109 = 0u;
  v110 = 0u;
  v107 = 0u;
  v108 = 0u;
  v105 = 0u;
  v106 = 0u;
  v103 = 0u;
  v104 = 0u;
  v101 = 0u;
  v102 = 0u;
  v99 = 0u;
  v100 = 0u;
  v97 = 0u;
  v98 = 0u;
  LOWORD(v98) = 1;
  v118 = 0x6300000063;
  memset(&v96, 0, sizeof(v96));
  v94 = -1;
  v95 = -1;
  v93 = -1;
  devnode_by_role = ignition_get_devnode_by_role(16, v121, v9, v10, v11, v12, v13, v14);
  v16 = getpid();
  if (!(_DWORD)devnode_by_role)
  {
    dlog(-1, "libignition: %d: %12s: preboot device: %s\n", v17, v18, v19, v20, v21, v22, v16);
    devnode_by_role = ignition_get_mount_point_by_role(16, v120, &v119);
    v23 = getpid();
    if ((_DWORD)devnode_by_role)
    {
      dlog(-1, "libignition: %d: %12s: failed to get preboot mount point: %d\n", v24, v25, v26, v27, v28, v29, v23);
      goto LABEL_6;
    }
    dlog(-1, "libignition: %d: %12s: preboot mount point: %s\n", v24, v25, v26, v27, v28, v29, v23);
    v38 = open(v119, 537919488);
    v95 = v38;
    if (v38 < 0)
    {
      v46 = getpid();
      dlog(-1, "libignition: %d: %12s: failed to open preboot mount point: %d\n", v47, v48, v49, v50, v51, v52, v46);
    }
    else
    {
      if (fstat64(v38, &v96))
      {
        devnode_by_role = *__error();
        v39 = getpid();
        dlog(-1, "libignition: %d: %12s: failed to stat preboot mount point: %d\n", v40, v41, v42, v43, v44, v45, v39);
        goto LABEL_6;
      }
      *(_QWORD *)&v97 = v121;
      v118 = *(_QWORD *)&v96.st_uid;
      v53 = getpid();
      dlog(-1, "libignition: %d: %12s: mounting preboot: dev = %s, uid = %u, gid = %u\n", v54, v55, v56, v57, v58, v59, v53);
      v60 = fmount_90140467("apfs", v95, 0x100000, v121);
      if ((_DWORD)v60 == 16)
      {
        v69 = getpid();
        dlog(-1, "libignition: %d: %12s: preboot already mounted: device = %s, mount point = %s\n", v70, v71, v72, v73, v74, v75, v69);
        v61 = xferfd(&v95);
        v94 = v61;
      }
      else
      {
        devnode_by_role = v60;
        if ((_DWORD)v60)
        {
          v86 = getpid();
          dlog(-1, "libignition: %d: %12s: failed to mount preboot: %d\n", v87, v88, v89, v90, v91, v92, v86);
          goto LABEL_6;
        }
        v61 = open(v119, 537919488);
        v94 = v61;
        if (v61 < 0)
        {
          devnode_by_role = *__error();
          v62 = getpid();
          dlog(-1, "libignition: %d: %12s: failed to open preboot mount: %d\n", v63, v64, v65, v66, v67, v68, v62);
          goto LABEL_6;
        }
      }
      v93 = dupfd(v61, (int)"preboot mount");
      boot_set_root(a3, (uint64_t)&_boot_root_preboot, &v94, v76, v77, v78, v79, v80);
      boot_set_root(a3, (uint64_t)&_boot_root_preboot_groupdir, &v93, v81, v82, v83, v84, v85);
    }
    devnode_by_role = 0;
    goto LABEL_6;
  }
  dlog(-1, "libignition: %d: %12s: failed to get preboot device: %d\n", v17, v18, v19, v20, v21, v22, v16);
LABEL_6:
  closefd_optional(&v95, (int)"mounted-over preboot");
  closefd_optional(&v94, (int)"preboot");
  if (devnode_by_role >= 0x6A)
    dyld_halt("error not set to valid posix code: %d", v30, v31, v32, v33, v34, v35, v36, devnode_by_role);
  return devnode_by_role;
}

uint64_t _cryptex1_sniff_payload_check()
{
  return 0;
}

uint64_t _cryptex1_sniff_fire(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  char ***v13;
  char *v14;
  unint64_t v15;
  int v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  stat v22;

  memset(&v22, 0, sizeof(v22));
  v3 = fstatat64(*(_DWORD *)(a3 + 24), "cryptex1", &v22, 0);
  v4 = __error();
  if (v3 < 0)
  {
    if (!*v4)
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v5, v6, v7, v8, v9, v10, v11, (int)"ret");
  }
  else
  {
    *v4 = 0;
  }
  result = *__error();
  if ((_DWORD)result)
  {
    if ((_DWORD)result != 2)
    {
      v13 = boot_get();
      v14 = (*v13)[1];
      v15 = (unint64_t)(*v13)[2];
      v16 = *__error();
      v17 = __error();
      ignition_halt(v14, v16, v15, "failed to stat cryptex1 canary: %d", v18, v19, v20, v21, *v17);
    }
    return 8;
  }
  return result;
}

char *object_derive_im4m_name(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v4;
  vm_address_t v5;
  vm_address_t *v6;
  const char *v7;

  v4 = *(_QWORD *)(a2 + 6800);
  v5 = _simple_salloc();
  v6 = (vm_address_t *)v5;
  if (v4)
    _simple_sprintf(v5, "apticket.%s.%llX.im4m");
  else
    _simple_sprintf(v5, "apticket.%s.im4m");
  v7 = (const char *)_simple_string((_BYTE **)v6);
  strlcpy(a3, v7, 0xFFuLL);
  _simple_sfree(v6);
  return a3;
}

uint64_t object_absence_policy_default(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t object_absence_policy_optional(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 2)
    return 0;
  else
    return a3;
}

uint64_t object_absence_policy_root_optional(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3;

  if (a3 == 2)
    v3 = 0;
  else
    v3 = a3;
  if (a2)
    return v3;
  else
    return a3;
}

uint64_t object_setfd(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t result;

  v5 = a2 + 16 * *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)v5)
    closefd((int *)(v5 + 8), (int)"object");
  *(_QWORD *)v5 = a1;
  result = xferfd(a3);
  *(_DWORD *)(v5 + 8) = result;
  return result;
}

uint64_t object_fd_close(uint64_t result)
{
  _QWORD *v1;

  if (*(_QWORD *)result)
  {
    v1 = (_QWORD *)result;
    result = closefd((int *)(result + 8), (int)"object");
    *v1 = 0;
  }
  return result;
}

uint64_t object_getfd(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 16 * *(_QWORD *)(a1 + 40) + 8);
}

void ignition_halt(void *a1, int a2, unint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  char ***v13;
  uint64_t *v14;
  vm_address_t v15;
  char *v16;
  _BYTE **v17;
  int v18;
  uint64_t v19;

  v13 = boot_get();
  v14 = configuration_unsafe();
  v15 = _simple_salloc();
  if (v15)
  {
    v17 = (_BYTE **)v15;
    _simple_vsprintf(v15, a4, &a9);
    v16 = (char *)_simple_string(v17);
  }
  else
  {
    v16 = "panic: [failed to allocate panic message]";
  }
  if (*((_BYTE *)v14 + 7032))
  {
    v18 = open("/dev/console", 1);
    if ((v18 & 0x80000000) == 0)
      fsync(v18);
    ignition_write_BRA_blob((const char ***)v13, v19, v16, a2);
  }
  abort_with_reason((void *)0x23, a1, v16, a3);
}

uint64_t dupfd2(int a1, int a2, int a3)
{
  uint64_t result;
  char ***v6;
  char *v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  result = dup2(a1, a2);
  if (a1 < 0)
  {
    v6 = boot_get();
    v7 = (*v6)[1];
    v8 = (unint64_t)(*v6)[2];
    v9 = *__error();
    __error();
    ignition_halt(v7, v9, v8, "failed to dup %s: src fd = %d, dst fd = %d: %d", v10, v11, v12, v13, a3);
  }
  return result;
}

uint64_t sleep_ns(unint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  kern_return_t v5;
  int v7;
  char ***v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = mach_absolute_time();
  if (_tbi)
  {
    v3 = *(_DWORD *)__tbi;
    v4 = *(_DWORD *)(__tbi + 4);
  }
  else
  {
    v5 = mach_timebase_info((mach_timebase_info_t)&dword_1EE806BF0);
    if (v5)
    {
      v7 = v5;
      v8 = boot_get();
      ignition_halt((*v8)[1], v7, (unint64_t)(*v8)[2], "mach_timebase_info: 0x%x", v9, v10, v11, v12, v7);
    }
    v3 = dword_1EE806BF0;
    __tbi = (uint64_t)&dword_1EE806BF0;
    v4 = dword_1EE806BF4;
    *(double *)&qword_1EE806C00 = (double)dword_1EE806BF0 / (double)dword_1EE806BF4;
    qword_1EE806BF8 = 0xFFFFFFFFFFFFFFFFLL / dword_1EE806BF0;
    _tbi = (uint64_t)&__tbi;
  }
  if (v3 != v4)
    a1 = a1 / v3 * v4;
  return mach_wait_until(a1 + v2);
}

int fmount_90140467(const char *a1, int a2, int a3, void *a4)
{
  void *v4;
  void *v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int result;
  statfs v18;

  v5 = v4;
  if (!a4)
    goto LABEL_4;
  bzero(&v18, 0x878uLL);
  if (fstatfs64(a2, &v18))
  {
LABEL_5:
    result = *__error();
    goto LABEL_6;
  }
  if (_platform_strcmp((const char *)a4, v18.f_mntfromname))
  {
LABEL_4:
    result = fmount(a1, a2, a3, v5);
    if (!result)
      return result;
    goto LABEL_5;
  }
  result = 16;
LABEL_6:
  if (result >= 0x6A)
    dyld_halt("error not set to valid posix code: %d", v10, v11, v12, v13, v14, v15, v16, result);
  return result;
}

ssize_t ignition_write_BRA_blob(const char ***a1, uint64_t a2, const char *a3, uint64_t a4)
{
  ssize_t result;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD v15[9];
  __int128 v16;

  v16 = 0u;
  memset(v15, 0, sizeof(v15));
  HIBYTE(v16) = -86;
  strlcpy((char *)v15 + 2, **a1, 0x18uLL);
  strlcpy((char *)&v15[1] + 10, *a1[1], 0x18uLL);
  *(_QWORD *)((char *)&v15[3] + 2) = a4;
  strlcpy((char *)&v15[3] + 10, "AAAAAAAA-BBBB-CCCC-DDDD-EEEEEEEEEEEE", 0x25uLL);
  strlcpy((char *)&v15[5] + 15, a3, 0x40uLL);
  result = sysctlbyname("security.mac.img4.ignition_failure_blob", 0, 0, v15, 0xA0uLL);
  if ((_DWORD)result)
  {
    v8 = __error();
    return _simple_dprintf(2, "failed to write BRA failure blob: %d\n", v9, v10, v11, v12, v13, v14, *v8);
  }
  return result;
}

uint64_t ignition_get_devnode_by_role(int a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  pid_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  pid_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _WORD v32[2];
  _BYTE v33[255];
  char v34;

  v34 = -86;
  v32[0] = -22014;
  v32[1] = a1;
  memset(v33, 0, sizeof(v33));
  if (a1 != 256)
  {
    if (a1 != 16)
      dyld_halt("unsupported role: 0x%x", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a1);
    if (fsctl("/", 0xC1044A50uLL, v32, 0))
    {
      v9 = *__error();
      v10 = getpid();
      dlog(-1, "libignition: %d: failed to lookup preboot: %d\n", v11, v12, v13, v14, v15, v16, v10);
      goto LABEL_7;
    }
LABEL_9:
    strlcpy(a2, v33, 0xFFuLL);
    return 0;
  }
  if (!fsctl("/", 0xC1044A50uLL, v32, 0))
    goto LABEL_9;
  v9 = *__error();
  v24 = getpid();
  dlog(-1, "libignition: %d: failed to lookup xART device: %d\n", v25, v26, v27, v28, v29, v30, v24);
LABEL_7:
  if (v9 >= 0x6A)
    dyld_halt("error not set to valid posix code: %d", v17, v18, v19, v20, v21, v22, v23, v9);
  return v9;
}

uint64_t ignition_get_mount_point_by_role(int a1, char *a2, char **a3)
{
  int v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  const char *i;
  char ***v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char ***v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  _BYTE v37[232];
  uint64_t v38;

  bzero(v37, 0x938uLL);
  v36 = 2360;
  v6 = sysctlbyname("vfs.generic.apfs.edt_fstab", v37, &v36, 0, 0);
  v7 = __error();
  if (v6 < 0)
  {
    if (!*v7)
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v8, v9, v10, v11, v12, v13, v14, (int)"ret");
  }
  else
  {
    *v7 = 0;
  }
  v15 = *__error();
  if (v15)
  {
    if (v15 == 12)
    {
      v36 = 0;
      sysctlbyname("vfs.generic.apfs.edt_fstab", 0, &v36, 0, 0);
      v26 = boot_get();
      ignition_halt((*v26)[1], 0, (unint64_t)(*v26)[2], "device tree fstab buffer not large enough: actual = %lu, expected >= %lu, required DEVICE_TREE_FSTAB_COUNT >= %lu", v27, v28, v29, v30, 2360);
    }
    result = *__error();
    if (result >= 0x6A)
      dyld_halt("error not set to valid posix code: %d", v17, v18, v19, v20, v21, v22, v23, result);
  }
  else
  {
    v24 = v36 / 0xEC;
    if (v36 % 0xEC)
    {
      v31 = boot_get();
      ignition_halt((*v31)[1], 0, (unint64_t)(*v31)[2], "non-integral fstab buffer returned; possible mismatch between kernel and userspace structs: total = %lu, expecte"
        "d element size = %lu",
        v32,
        v33,
        v34,
        v35,
        v36);
    }
    if (v36 < 0xEC)
    {
      return 2;
    }
    else
    {
      for (i = (const char *)&v38; *(_DWORD *)i != a1; i += 236)
      {
        if (!--v24)
          return 2;
      }
      strlcpy(a2, i - 200, 0x400uLL);
      result = 0;
      *a3 = a2;
    }
  }
  return result;
}

uint64_t _open_as(int a1, int *a2)
{
  unint64_t v4;
  int v5;
  int v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char ***v24;
  char *v25;
  unint64_t v26;
  int v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33[3];
  int v34;

  v4 = 0;
  v5 = *a2;
  *a2 = -1;
  do
  {
    v6 = open("/dev/null", a1, 0);
    v7 = __error();
    if (v6 < 0)
    {
      if (!*v7)
        dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v8, v9, v10, v11, v12, v13, v14, (int)"srcfd");
    }
    else
    {
      *v7 = 0;
    }
    v15 = *__error();
    if ((_DWORD)v15)
    {
      if ((_DWORD)v15 != 5)
      {
        v34 = v6;
        v15 = *__error();
        if (v6 < 0)
          goto LABEL_18;
        goto LABEL_16;
      }
      v15 = *__error();
      sleep_ns(0x2FAF080uLL);
      ++v4;
    }
  }
  while (v6 < 0 && v4 < 0xA);
  v34 = v6;
  if (v4 == 10)
  {
    *(_QWORD *)v33 = -1;
    if (pipe(v33))
    {
      v24 = boot_get();
      v25 = (*v24)[1];
      v26 = (unint64_t)(*v24)[2];
      v27 = *__error();
      v28 = __error();
      ignition_halt(v25, v27, v26, "failed to create pipe for 88828241 workaround: %d", v29, v30, v31, v32, *v28);
    }
    v6 = v33[0];
    v34 = v33[0];
    closefd(&v33[1], (int)"pipe write end");
    v15 = 0;
  }
  if ((v6 & 0x80000000) == 0)
  {
LABEL_16:
    *a2 = dupfd2(v6, v5, (int)"reserved src fd");
    if (v6 == v5)
      v34 = -1;
  }
LABEL_18:
  closefd_optional(&v34, (int)"reserved fd src");
  if (v15 >= 0x6A)
    dyld_halt("error not set to valid posix code: %d", v16, v17, v18, v19, v20, v21, v22, v15);
  return v15;
}

char ***boot_get()
{
  return __boot;
}

uint64_t boot_set_dylib_root(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return boot_set_root(a1, (uint64_t)&_boot_root_canonical_os, a2, a4, a5, a6, a7, a8);
}

uint64_t *configuration_unsafe()
{
  return &__config;
}

uint64_t _cryptex_graft_failure_app_livefs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v18;

  v8 = a2;
  v16 = *(_QWORD *)(arguments(a1, a2, a3, a4, a5, a6, a7, a8) + 16);
  if (v16 < 2)
    return 0;
  if (v16 != 2)
    dyld_halt("unreachable", v9, v10, v11, v12, v13, v14, v15, v18);
  return v8;
}

size_t dyld_tolower_cstr(const char *a1, uint64_t a2, unint64_t a3)
{
  size_t result;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;

  result = _platform_strlen(a1);
  if (result + 1 < a3)
    v7 = result + 1;
  else
    v7 = a3;
  if (v7)
    v8 = v7 - 1;
  else
    v8 = 0;
  if (v7 >= 2)
  {
    v9 = 0;
    do
    {
      v10 = a1[v9];
      if ((v10 - 65) <= 0x19)
        LOBYTE(v10) = aAbcdefghijklmn[v10 - 65];
      *(_BYTE *)(a2 + v9++) = v10;
    }
    while (v9 < v8);
  }
  if (v7)
    *(_BYTE *)(a2 + v7 - 1) = 0;
  return result;
}

unint64_t buff_get_length_uint32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (HIDWORD(result))
    dyld_halt("buffer length not expressible as unsigned 32-bit integer: %lu", a2, a3, a4, a5, a6, a7, a8, result);
  return result;
}

uint64_t buff_map_fd_anon(_QWORD *a1, _QWORD *a2, int a3)
{
  timespec v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  off_t st_size;
  void *v16;
  void *v17;
  ssize_t v18;
  stat v19;

  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v19.st_blksize = v6;
  *(timespec *)v19.st_qspare = v6;
  v19.st_birthtimespec = v6;
  *(timespec *)&v19.st_size = v6;
  v19.st_mtimespec = v6;
  v19.st_ctimespec = v6;
  *(timespec *)&v19.st_uid = v6;
  v19.st_atimespec = v6;
  *(timespec *)&v19.st_dev = v6;
  if (fstat64(a3, &v19))
    return *__error();
  st_size = v19.st_size;
  if (v19.st_size < 0)
    dyld_halt("value not representable as size_t", v7, v8, v9, v10, v11, v12, v13, v19.st_dev);
  v16 = mmap(0, v19.st_size, 3, 4098, -1, 0);
  if (v16 == (void *)-1)
    return *__error();
  v17 = v16;
  while (1)
  {
    v18 = pread(a3, v17, st_size, 0);
    if ((v18 & 0x8000000000000000) == 0)
      break;
    result = *__error();
    if ((_DWORD)result != 4)
      goto LABEL_13;
  }
  if (v18 == st_size)
    result = 0;
  else
    result = 5;
LABEL_13:
  *a1 = v17;
  a1[1] = st_size;
  a1[2] = 0;
  if (a2)
    *a2 = a1;
  return result;
}

uint64_t os_log_simple_type_from_asl(int a1)
{
  unsigned int v1;

  v1 = a1 & ~(a1 >> 31);
  if (v1 >= 7)
    v1 = 7;
  return os_log_simple_type_from_asl__level2ostype[v1];
}

uint64_t __os_log_simple_offset(uint64_t a1, char *a2, const void *a3, uint64_t a4, uint64_t a5, unsigned __int8 a6, uint64_t a7, uint64_t a8)
{
  pid_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  _QWORD v24[4];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  _BYTE buffer[16];
  uint64_t v32;
  int v33;

  v30 = 0;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v25 = 0u;
  v24[0] = a6;
  v24[1] = a7;
  v24[2] = a8;
  v24[3] = mach_continuous_time();
  v13 = getpid();
  *(_QWORD *)&v25 = v13;
  if (proc_pidinfo(v13, 17, 0, buffer, 56) == 56)
  {
    *((_QWORD *)&v25 + 1) = v32;
    *(_QWORD *)&v26 = v33;
    memmove((char *)&v28 + 8, buffer, 0x10uLL);
  }
  if (a1)
  {
    if (*(int *)(a1 + 24) >= 0)
      v14 = a1;
    else
      v14 = a4;
    *(_QWORD *)&v27 = a5 - v14;
    v15 = a2;
  }
  else
  {
    v15 = (char *)&v28 + 8;
  }
  memmove((char *)&v27 + 8, v15, 0x10uLL);
  memmove((char *)&v29 + 8, a3, 0x10uLL);
  return _os_log_simple_send((uint64_t)v24, v16, v17, v18, v19, v20, v21, v22);
}

uint64_t _os_log_simple_send(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  int fd;
  int v10;
  size_t v11;
  const char *v12;
  size_t v13;
  uint64_t result;
  size_t v15;
  BOOL v16;
  unint64_t v17;
  _WORD v18[2];
  char v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE v26[1944];

  fd = _simple_asl_get_fd(a1, a2, a3, a4, a5, a6, a7, a8);
  if (fd < 0)
    return 9;
  if ((MEMORY[0xFFFFFC105] & 4) != 0)
    return 0;
  v10 = fd;
  v11 = _platform_strlen(*(const char **)(a1 + 16)) + 1;
  v12 = *(const char **)(a1 + 8);
  if (v12)
    v13 = _platform_strlen(v12) + 1;
  else
    v13 = 0;
  v15 = v13 + v11 + 104;
  v16 = __CFADD__(v13, v11 + 104);
  result = 84;
  if (v11 < 0xFFFFFFFFFFFFFF98 && !v16)
  {
    if (v15 <= 0x800)
    {
      v18[0] = v11;
      v18[1] = v13;
      v19 = *(_BYTE *)a1;
      v20 = *(_OWORD *)(a1 + 24);
      v21 = *(_OWORD *)(a1 + 40);
      v22 = *(_OWORD *)(a1 + 56);
      memmove(&v23, (const void *)(a1 + 72), 0x10uLL);
      memmove(&v24, (const void *)(a1 + 88), 0x10uLL);
      memmove(&v25, (const void *)(a1 + 104), 0x10uLL);
      _platform_strlcpy(v26, *(char **)(a1 + 16), v11);
      if (v13)
        _platform_strlcpy(&v26[v11], *(char **)(a1 + 8), v13);
      v17 = sendto(v10, v18, v15, 0, 0, 0);
      if ((v17 & 0x8000000000000000) != 0)
      {
        return *__error();
      }
      else if (v17 >= v15)
      {
        return 0;
      }
      else
      {
        return 40;
      }
    }
    else
    {
      return 7;
    }
  }
  return result;
}

uint64_t _os_log_simple_shim(unsigned __int8 a1, uint64_t a2, uint64_t a3)
{
  return __os_log_simple_offset(0, UUID_NULL, UUID_NULL, 0, 0, a1, a2, a3);
}

uint64_t _simple_asl_connect()
{
  uint64_t v0;
  uint64_t v1;
  size_t v2;
  size_t v3;
  sockaddr v5;

  v0 = socket(1, 2, 0);
  v1 = v0;
  if ((_DWORD)v0 != -1)
  {
    fcntl(v0, 2, 1);
    v5.sa_family = 1;
    v2 = _platform_strlen("/var/run/syslog");
    if (v2 + 1 < 0x68)
      v3 = v2 + 1;
    else
      v3 = 104;
    memmove(v5.sa_data, "/var/run/syslog", v3);
    if (connect(v1, &v5, 0x6Au) == -1)
    {
      close(v1);
      return 0xFFFFFFFFLL;
    }
  }
  return v1;
}

uint64_t _simple_asl_get_fd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  unint64_t v8;

  if (qword_1EE806240 == -1)
    v8 = qword_1EE806248;
  else
    v8 = _os_alloc_once((unint64_t *)&qword_1EE806240, 32, (uint64_t)_simple_asl_init_context, a4, a5, a6, a7, a8);
  if (!*(_BYTE *)v8)
    return 0xFFFFFFFFLL;
  if (*(_QWORD *)(v8 + 24) != -1)
    _os_once((unint64_t *)(v8 + 24), 0, (uint64_t (*)(uint64_t))_simple_asl_connect_once, a4, a5, a6, a7, a8);
  return *(unsigned int *)(v8 + 16);
}

void _simple_asl_connect_once(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  unint64_t v8;

  if (qword_1EE806240 == -1)
    v8 = qword_1EE806248;
  else
    v8 = _os_alloc_once((unint64_t *)&qword_1EE806240, 32, (uint64_t)_simple_asl_init_context, a4, a5, a6, a7, a8);
  if (*(_DWORD *)(v8 + 16) == -1)
    *(_DWORD *)(v8 + 16) = _simple_asl_connect();
}

uint64_t _simple_asl_log(int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  unsigned __int8 v11;

  if (qword_1EE806240 != -1)
    _os_alloc_once((unint64_t *)&qword_1EE806240, 32, (uint64_t)_simple_asl_init_context, a4, a5, a6, a7, a8);
  v11 = os_log_simple_type_from_asl(a1);
  return _os_log_simple_shim(v11, a2, a3);
}

uint64_t _simple_asl_init_context(uint64_t result)
{
  *(_QWORD *)(result + 8) = "unknown";
  *(_DWORD *)(result + 16) = -1;
  return result;
}

ssize_t _simple_vdprintf(int a1, char *__s, int *a3)
{
  _BYTE v4[32];
  _QWORD v5[3];
  int v6;
  ssize_t (*v7)(_QWORD *);

  v6 = a1;
  v5[0] = v4;
  v5[1] = v4;
  v5[2] = v5;
  v7 = _flush_reset;
  __simple_bprintf((uint64_t)v5, 0, __s, a3);
  return _flush((ssize_t)v5);
}

ssize_t _flush_reset(_QWORD *a1)
{
  ssize_t result;

  result = _flush((ssize_t)a1);
  a1[1] = *a1;
  return result;
}

ssize_t _flush(ssize_t result)
{
  char *v1;
  int64_t v2;
  ssize_t v3;
  BOOL v4;

  v1 = *(char **)result;
  v2 = *(_QWORD *)(result + 8) - *(_QWORD *)result;
  if (v2 >= 1)
  {
    v3 = result;
    while (1)
    {
      while (1)
      {
        result = write(*(_DWORD *)(v3 + 24), v1, v2);
        if (result < 0)
          break;
        v4 = v2 <= result;
        v2 -= result;
        v1 += v2;
        if (v4)
          return result;
      }
      if (*__error() != 4)
      {
        result = (ssize_t)__error();
        if (*(_DWORD *)result != 35)
          break;
      }
    }
  }
  return result;
}

ssize_t _simple_dprintf(int a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return _simple_vdprintf(a1, a2, &a9);
}

void *_enlarge(uint64_t a1)
{
  vm_size_t *v2;
  void *result;
  size_t v4;
  vm_size_t v5;
  kern_return_t v6;
  vm_size_t v7;
  vm_address_t v8;
  vm_size_t v9;
  vm_address_t address;

  v2 = (vm_size_t *)(a1 + 16);
  address = *(_QWORD *)(a1 + 16) + 1;
  result = (void *)vm_allocate(mach_task_self_, &address, vm_page_size, 0);
  if ((_DWORD)result)
  {
    v4 = *(_QWORD *)(a1 + 16) - *(_QWORD *)a1 + 1;
    v5 = (v4 + vm_page_size) & -(uint64_t)vm_page_size;
    v6 = vm_allocate(mach_task_self_, &address, v5, 1);
    if (v6)
      _enlarge_cold_1(v6);
    v7 = address - *(_QWORD *)a1;
    result = memmove((void *)address, *(const void **)a1, v4);
    v8 = *(_QWORD *)a1;
    if (((vm_page_size - 1) & *(_QWORD *)a1) != 0)
    {
      v4 &= -(uint64_t)vm_page_size;
      v8 = (v8 + vm_page_size) & -(uint64_t)vm_page_size;
      *(_QWORD *)a1 = v8;
      v9 = v5 + address - 1;
    }
    else
    {
      v9 = *v2 + vm_page_size + v7;
    }
    *v2 = v9;
    if (v4)
      result = (void *)vm_deallocate(mach_task_self_, v8, v4);
    *(_QWORD *)a1 = address;
    v2 = (vm_size_t *)(a1 + 8);
  }
  else
  {
    v7 = vm_page_size;
  }
  *v2 += v7;
  return result;
}

uint64_t _simple_sprintf(uint64_t a1, char *__s, ...)
{
  va_list va;

  va_start(va, __s);
  __simple_bprintf(a1, 0, __s, (int *)va);
  return 0;
}

std::ios_base *__cdecl dec(std::ios_base *__str)
{
  uint64_t (*v1)(uint64_t);
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  int v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  BOOL v11;
  _BOOL4 v12;
  _BYTE *v13;
  unsigned __int8 *v14;
  _BYTE *v15;
  int v16;
  _BYTE *v17;
  std::ios_base *result;
  uint64_t v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  _BYTE *v23;
  int v24;
  _BYTE *v25;
  char v27;
  unsigned __int8 *v28;
  _BYTE *v29;
  int v30;
  _BYTE *v31;
  char v32;
  unsigned __int8 *v33;
  _BYTE *v34;
  int v35;
  char *v36;
  char v37;
  char v38;
  char v39;

  v5 = v1;
  v7 = (v2 >> 63) + v3;
  v8 = (unint64_t)v2 >> 63;
  v39 = 0;
  if (v2)
  {
    v9 = &v39;
    if (v2 >= 0)
      v10 = v2;
    else
      v10 = -v2;
    do
    {
      *--v9 = (v10 % 0xA) | 0x30;
      v11 = v10 >= 0xA;
      v10 /= 0xAuLL;
    }
    while (v11);
    v12 = v4 != 0;
    if (v2 < 0 && v4)
    {
      if (v1 && (v13 = (_BYTE *)v1(45)) != 0)
      {
        LODWORD(v8) = *v13;
        if (*v13)
        {
          v14 = v13 + 1;
          do
          {
            v15 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v15 >= __str->__precision_)
            {
              (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
              v15 = *(_BYTE **)&__str->__fmtflags_;
            }
            *(_QWORD *)&__str->__fmtflags_ = v15 + 1;
            *v15 = v8;
            v16 = *v14++;
            LODWORD(v8) = v16;
          }
          while (v16);
        }
      }
      else
      {
        v17 = *(_BYTE **)&__str->__fmtflags_;
        if ((unint64_t)v17 >= __str->__precision_)
        {
          (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
          v17 = *(_BYTE **)&__str->__fmtflags_;
        }
        LODWORD(v8) = 0;
        *(_QWORD *)&__str->__fmtflags_ = v17 + 1;
        *v17 = 45;
      }
      v12 = 1;
    }
  }
  else
  {
    v9 = &v38;
    v38 = 48;
    v12 = v4 != 0;
  }
  result = (std::ios_base *)_platform_strlen(v9);
  v19 = v7 - (_QWORD)result;
  if (v19 >= 1)
  {
    if (v12)
      v20 = 48;
    else
      v20 = 32;
    do
    {
      if (v5 && (result = (std::ios_base *)v5(v20)) != 0)
      {
        v21 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          v22 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            v23 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v23 >= __str->__precision_)
            {
              result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              v23 = *(_BYTE **)&__str->__fmtflags_;
            }
            *(_QWORD *)&__str->__fmtflags_ = v23 + 1;
            *v23 = v21;
            v24 = *v22++;
            v21 = v24;
          }
          while (v24);
        }
      }
      else
      {
        v25 = *(_BYTE **)&__str->__fmtflags_;
        if ((unint64_t)v25 >= __str->__precision_)
        {
          result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          v25 = *(_BYTE **)&__str->__fmtflags_;
        }
        *(_QWORD *)&__str->__fmtflags_ = v25 + 1;
        *v25 = v20;
      }
    }
    while (v19-- > 1);
  }
  if ((_DWORD)v8)
  {
    if (v5 && (result = (std::ios_base *)v5(45)) != 0)
    {
      v27 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        v28 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          v29 = *(_BYTE **)&__str->__fmtflags_;
          if ((unint64_t)v29 >= __str->__precision_)
          {
            result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            v29 = *(_BYTE **)&__str->__fmtflags_;
          }
          *(_QWORD *)&__str->__fmtflags_ = v29 + 1;
          *v29 = v27;
          v30 = *v28++;
          v27 = v30;
        }
        while (v30);
      }
    }
    else
    {
      v31 = *(_BYTE **)&__str->__fmtflags_;
      if ((unint64_t)v31 >= __str->__precision_)
      {
        result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        v31 = *(_BYTE **)&__str->__fmtflags_;
      }
      *(_QWORD *)&__str->__fmtflags_ = v31 + 1;
      *v31 = 45;
    }
  }
  while (1)
  {
    v37 = *v9;
    if (!*v9)
      break;
    if (v5 && (result = (std::ios_base *)v5(*(unsigned __int8 *)v9)) != 0)
    {
      v32 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        v33 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          v34 = *(_BYTE **)&__str->__fmtflags_;
          if ((unint64_t)v34 >= __str->__precision_)
          {
            result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            v34 = *(_BYTE **)&__str->__fmtflags_;
          }
          *(_QWORD *)&__str->__fmtflags_ = v34 + 1;
          *v34 = v32;
          v35 = *v33++;
          v32 = v35;
        }
        while (v35);
      }
    }
    else
    {
      v36 = *(char **)&__str->__fmtflags_;
      if ((unint64_t)v36 >= __str->__precision_)
      {
        result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        v36 = *(char **)&__str->__fmtflags_;
      }
      *(_QWORD *)&__str->__fmtflags_ = v36 + 1;
      *v36 = v37;
    }
    ++v9;
  }
  return result;
}

std::ios_base *__cdecl oct(std::ios_base *__str)
{
  uint64_t (*v1)(uint64_t);
  unint64_t v2;
  int v3;
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t);
  const char *v8;
  BOOL v9;
  uint64_t v10;
  std::ios_base *result;
  uint64_t v12;
  uint64_t v13;
  char v14;
  unsigned __int8 *v15;
  _BYTE *v16;
  int v17;
  _BYTE *v18;
  char v20;
  unsigned __int8 *v21;
  _BYTE *v22;
  int v23;
  char *v24;
  char v25;
  char v26;
  char v27;

  v5 = v4;
  v6 = v1;
  v27 = 0;
  if (v2)
  {
    v8 = &v27;
    do
    {
      *--v8 = v2 & 7 | 0x30;
      v9 = v2 >= 8;
      v2 >>= 3;
    }
    while (v9);
  }
  else
  {
    v8 = &v26;
    v26 = 48;
  }
  v10 = v3;
  result = (std::ios_base *)_platform_strlen(v8);
  v12 = v10 - (_QWORD)result;
  if (v12 >= 1)
  {
    if (v5)
      v13 = 48;
    else
      v13 = 32;
    do
    {
      if (v6 && (result = (std::ios_base *)v6(v13)) != 0)
      {
        v14 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          v15 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            v16 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v16 >= __str->__precision_)
            {
              result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              v16 = *(_BYTE **)&__str->__fmtflags_;
            }
            *(_QWORD *)&__str->__fmtflags_ = v16 + 1;
            *v16 = v14;
            v17 = *v15++;
            v14 = v17;
          }
          while (v17);
        }
      }
      else
      {
        v18 = *(_BYTE **)&__str->__fmtflags_;
        if ((unint64_t)v18 >= __str->__precision_)
        {
          result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          v18 = *(_BYTE **)&__str->__fmtflags_;
        }
        *(_QWORD *)&__str->__fmtflags_ = v18 + 1;
        *v18 = v13;
      }
    }
    while (v12-- > 1);
  }
  while (1)
  {
    v25 = *v8;
    if (!*v8)
      break;
    if (v6 && (result = (std::ios_base *)v6(*(unsigned __int8 *)v8)) != 0)
    {
      v20 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        v21 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          v22 = *(_BYTE **)&__str->__fmtflags_;
          if ((unint64_t)v22 >= __str->__precision_)
          {
            result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            v22 = *(_BYTE **)&__str->__fmtflags_;
          }
          *(_QWORD *)&__str->__fmtflags_ = v22 + 1;
          *v22 = v20;
          v23 = *v21++;
          v20 = v23;
        }
        while (v23);
      }
    }
    else
    {
      v24 = *(char **)&__str->__fmtflags_;
      if ((unint64_t)v24 >= __str->__precision_)
      {
        result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        v24 = *(char **)&__str->__fmtflags_;
      }
      *(_QWORD *)&__str->__fmtflags_ = v24 + 1;
      *v24 = v25;
    }
    ++v8;
  }
  return result;
}

_BYTE *udec(uint64_t a1, uint64_t (*a2)(uint64_t), unint64_t a3, int a4, int a5)
{
  const char *v8;
  BOOL v9;
  uint64_t v10;
  _BYTE *result;
  uint64_t v12;
  uint64_t v13;
  char v14;
  unsigned __int8 *v15;
  _BYTE *v16;
  int v17;
  _BYTE *v18;
  char v20;
  unsigned __int8 *v21;
  _BYTE *v22;
  int v23;
  char *v24;
  char v25;
  char v26;
  char v27;

  v27 = 0;
  if (a3)
  {
    v8 = &v27;
    do
    {
      *--v8 = (a3 % 0xA) | 0x30;
      v9 = a3 >= 0xA;
      a3 /= 0xAuLL;
    }
    while (v9);
  }
  else
  {
    v8 = &v26;
    v26 = 48;
  }
  v10 = a4;
  result = (_BYTE *)_platform_strlen(v8);
  v12 = v10 - (_QWORD)result;
  if (v12 >= 1)
  {
    if (a5)
      v13 = 48;
    else
      v13 = 32;
    do
    {
      if (a2 && (result = (_BYTE *)a2(v13)) != 0)
      {
        v14 = *result;
        if (*result)
        {
          v15 = result + 1;
          do
          {
            v16 = *(_BYTE **)(a1 + 8);
            if ((unint64_t)v16 >= *(_QWORD *)(a1 + 16))
            {
              result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
              v16 = *(_BYTE **)(a1 + 8);
            }
            *(_QWORD *)(a1 + 8) = v16 + 1;
            *v16 = v14;
            v17 = *v15++;
            v14 = v17;
          }
          while (v17);
        }
      }
      else
      {
        v18 = *(_BYTE **)(a1 + 8);
        if ((unint64_t)v18 >= *(_QWORD *)(a1 + 16))
        {
          result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
          v18 = *(_BYTE **)(a1 + 8);
        }
        *(_QWORD *)(a1 + 8) = v18 + 1;
        *v18 = v13;
      }
    }
    while (v12-- > 1);
  }
  while (1)
  {
    v25 = *v8;
    if (!*v8)
      break;
    if (a2 && (result = (_BYTE *)a2(*(unsigned __int8 *)v8)) != 0)
    {
      v20 = *result;
      if (*result)
      {
        v21 = result + 1;
        do
        {
          v22 = *(_BYTE **)(a1 + 8);
          if ((unint64_t)v22 >= *(_QWORD *)(a1 + 16))
          {
            result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
            v22 = *(_BYTE **)(a1 + 8);
          }
          *(_QWORD *)(a1 + 8) = v22 + 1;
          *v22 = v20;
          v23 = *v21++;
          v20 = v23;
        }
        while (v23);
      }
    }
    else
    {
      v24 = *(char **)(a1 + 8);
      if ((unint64_t)v24 >= *(_QWORD *)(a1 + 16))
      {
        result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
        v24 = *(char **)(a1 + 8);
      }
      *(_QWORD *)(a1 + 8) = v24 + 1;
      *v24 = v25;
    }
    ++v8;
  }
  return result;
}

_BYTE *ydec(uint64_t a1, uint64_t (*a2)(uint64_t), unint64_t a3, int a4, int a5)
{
  _BYTE *result;
  char *v8;
  unsigned __int8 v9;
  char v10;
  unsigned __int8 *v11;
  _BYTE *v12;
  int v13;
  unsigned __int8 *v14;
  unsigned __int8 v15;
  char *v16;
  unsigned __int8 v17;
  char v18;
  unsigned __int8 *v19;
  _BYTE *v20;
  int v21;
  unsigned __int8 *v22;
  unsigned __int8 v23;
  char v24;
  unsigned __int8 *v25;
  _BYTE *v26;
  int v27;
  _BYTE *v28;

  if (a3 < 0xA00000)
  {
    if (a3 >> 11 < 5)
    {
      result = udec(a1, a2, a3, a4, a5);
      if (a2 && (result = (_BYTE *)a2(98)) != 0)
      {
        v24 = *result;
        if (*result)
        {
          v25 = result + 1;
          do
          {
            v26 = *(_BYTE **)(a1 + 8);
            if ((unint64_t)v26 >= *(_QWORD *)(a1 + 16))
            {
              result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
              v26 = *(_BYTE **)(a1 + 8);
            }
            *(_QWORD *)(a1 + 8) = v26 + 1;
            *v26 = v24;
            v27 = *v25++;
            v24 = v27;
          }
          while (v27);
        }
      }
      else
      {
        v28 = *(_BYTE **)(a1 + 8);
        if ((unint64_t)v28 >= *(_QWORD *)(a1 + 16))
        {
          result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
          v28 = *(_BYTE **)(a1 + 8);
        }
        *(_QWORD *)(a1 + 8) = v28 + 1;
        *v28 = 98;
      }
    }
    else
    {
      result = udec(a1, a2, (a3 + 512) >> 10, a4, a5);
      v16 = "KB";
      v17 = 75;
      do
      {
        if (a2 && (result = (_BYTE *)a2(v17)) != 0)
        {
          v18 = *result;
          if (*result)
          {
            v19 = result + 1;
            do
            {
              v20 = *(_BYTE **)(a1 + 8);
              if ((unint64_t)v20 >= *(_QWORD *)(a1 + 16))
              {
                result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
                v20 = *(_BYTE **)(a1 + 8);
              }
              *(_QWORD *)(a1 + 8) = v20 + 1;
              *v20 = v18;
              v21 = *v19++;
              v18 = v21;
            }
            while (v21);
          }
        }
        else
        {
          v22 = *(unsigned __int8 **)(a1 + 8);
          if ((unint64_t)v22 >= *(_QWORD *)(a1 + 16))
          {
            result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
            v22 = *(unsigned __int8 **)(a1 + 8);
          }
          *(_QWORD *)(a1 + 8) = v22 + 1;
          *v22 = v17;
        }
        v23 = *++v16;
        v17 = v23;
      }
      while (v16 != "");
    }
  }
  else
  {
    result = udec(a1, a2, (a3 + 0x80000) >> 20, a4, a5);
    v8 = "MB";
    v9 = 77;
    do
    {
      if (a2 && (result = (_BYTE *)a2(v9)) != 0)
      {
        v10 = *result;
        if (*result)
        {
          v11 = result + 1;
          do
          {
            v12 = *(_BYTE **)(a1 + 8);
            if ((unint64_t)v12 >= *(_QWORD *)(a1 + 16))
            {
              result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
              v12 = *(_BYTE **)(a1 + 8);
            }
            *(_QWORD *)(a1 + 8) = v12 + 1;
            *v12 = v10;
            v13 = *v11++;
            v10 = v13;
          }
          while (v13);
        }
      }
      else
      {
        v14 = *(unsigned __int8 **)(a1 + 8);
        if ((unint64_t)v14 >= *(_QWORD *)(a1 + 16))
        {
          result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
          v14 = *(unsigned __int8 **)(a1 + 8);
        }
        *(_QWORD *)(a1 + 8) = v14 + 1;
        *v14 = v9;
      }
      v15 = *++v8;
      v9 = v15;
    }
    while (v8 != "");
  }
  return result;
}

uint64_t _os_unfair_lock_lock_slow(unsigned int *a1, int a2, void *a3, unsigned int a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  unsigned int v8;
  int v12;
  unsigned int v13;
  int v14;
  _BOOL4 v16;
  unsigned int v18;
  uint64_t v19;
  uint64_t result;

  if ((a2 & 0xFCFAFFFF) != 0)
  {
    qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Invalid options";
    qword_1EE805E00 = a2 & 0xFEFFFFFF;
    __break(1u);
LABEL_34:
    _os_unfair_lock_recursive_abort(v8);
  }
  v8 = a4;
  v12 = 0;
  do
  {
    while (1)
    {
      while (1)
      {
LABEL_3:
        v13 = *a1;
        if (!*a1)
        {
          while (1)
          {
            v13 = __ldaxr(a1);
            if (v13)
              break;
            if (!__stxr(v8 & ~v12, a1))
              return 1;
          }
          __clrex();
        }
        v14 = v13 | 1;
        v16 = (a2 & 0x1000000) == 0 || v14 != -1;
        if (v14 == v8 && v16)
          goto LABEL_34;
        if (v13 == (v13 & 0xFFFFFFFE))
          goto LABEL_23;
        do
        {
          v18 = __ldxr(a1);
          if (v18 != v13)
          {
            __clrex();
            goto LABEL_3;
          }
        }
        while (__stxr(v13 & 0xFFFFFFFE, a1));
        v13 &= ~1u;
LABEL_23:
        result = __ulock_wait2((void *)(a2 | 0x1000002u), a1, (void *)v13, a3, 0, a6, a7, a8);
        if ((result & 0x80000000) != 0)
          break;
        if ((_DWORD)result)
          v12 = 1;
      }
      v19 = -(int)result;
      if ((int)v19 > 13)
        break;
      if ((_DWORD)v19 != 4)
        goto LABEL_38;
    }
  }
  while ((_DWORD)v19 == 14);
  result = 0;
  if ((_DWORD)v19 != 60)
  {
    if ((_DWORD)v19 == 105)
      _os_unfair_lock_corruption_abort(v13);
LABEL_38:
    qword_1EE805DD0 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wait2 failure";
    qword_1EE805E00 = v19;
    __break(1u);
  }
  return result;
}

unsigned int *os_unfair_lock_lock_with_options(unsigned int *result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  unsigned int v8;

  v8 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (!__ldaxr(result))
  {
    if (!__stxr(v8, result))
      return result;
  }
  __clrex();
  return (unsigned int *)_os_unfair_lock_lock_slow(result, a2, 0, v8, a5, a6, a7, a8);
}

uint64_t _os_unfair_lock_unlock_slow(void *a1, int a2, unsigned int a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result;
  uint64_t v10;

  result = a3 | 1;
  if ((_DWORD)result != a2)
    _os_unfair_lock_unowned_abort(result);
  if ((a3 & 1) != 0)
  {
    v10 = a3;
    qword_1EE805DD0 = (uint64_t)"BUG IN LIBPLATFORM: unlock_slow with no waiters";
    qword_1EE805E00 = a3;
    __break(1u);
LABEL_9:
    qword_1EE805DD0 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wake failure";
    qword_1EE805E00 = v10;
    __break(1u);
  }
  else
  {
    while (1)
    {
      result = __ulock_wake((void *)0x1000002, a1, 0, a4, a5, a6, a7, a8);
      if ((result & 0x80000000) == 0)
        break;
      if ((_DWORD)result != -4)
      {
        v10 = -(int)result;
        if ((_DWORD)v10 != 2)
          goto LABEL_9;
        return result;
      }
    }
  }
  return result;
}

uint64_t _os_once_gate_broadcast(void *a1, unsigned int a2, int a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result;
  uint64_t v10;

  result = a2 | 1;
  if ((_DWORD)result != a3)
    _os_once_gate_unowned_abort(result);
  if ((a2 & 1) != 0)
  {
    v10 = a2;
    qword_1EE805DD0 = (uint64_t)"BUG IN LIBPLATFORM: unlock_slow with no waiters";
    qword_1EE805E00 = a2;
    __break(1u);
LABEL_9:
    qword_1EE805DD0 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wake failure";
    qword_1EE805E00 = v10;
    __break(1u);
  }
  else
  {
    while (1)
    {
      result = __ulock_wake((void *)0x1000102, a1, 0, a4, a5, a6, a7, a8);
      if ((result & 0x80000000) == 0)
        break;
      if ((_DWORD)result != -4)
      {
        v10 = -(int)result;
        if ((_DWORD)v10 != 2)
          goto LABEL_9;
        return result;
      }
    }
  }
  return result;
}

unint64_t *_os_once(unint64_t *result, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  unint64_t v8;
  uint64_t v9;

  v8 = atomic_load(result);
  if ((v8 & 3) == 1)
  {
    if (4 * MEMORY[0xFFFFFC180] - v8 - 15 <= 0xFFFFFFFFFFFFFFEFLL)
      *result = -1;
  }
  else
  {
    v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    while (!__ldaxr(result))
    {
      if (!__stxr(v9, result))
        return (unint64_t *)_os_once_callout(result, a2, a3, v9);
    }
    __clrex();
    return (unint64_t *)_os_once_gate_wait((uint64_t)result, a2, a3, v9, a5, a6, a7, a8);
  }
  return result;
}

uint64_t _os_once_callout(unint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t), int a4)
{
  uint64_t result;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  unint64_t v12;
  unsigned int v13;

  result = a3(a2);
  v12 = (4 * MEMORY[0xFFFFFC180]) | 1;
  do
    v13 = __ldxr(a1);
  while (__stlxr(v12, a1));
  if (v13 != a4)
    return _os_once_gate_broadcast(a1, v13, a4, v7, v8, v9, v10, v11);
  return result;
}

uint64_t _os_once_gate_wait(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t), unsigned int a4, void *a5, void *a6, void *a7, void *a8)
{
  unint64_t v8;
  unint64_t *v12;
  unint64_t v13;

  v8 = __ldxr((unint64_t *)result);
  if (v8 == -1)
  {
LABEL_19:
    __clrex();
    return result;
  }
  v12 = (unint64_t *)result;
  v13 = a4;
  while ((v8 & 3) != 1)
  {
    if (v8)
    {
      if ((v8 & 0xFFFFFFFFFFFFFFFELL) == v8)
      {
        __clrex();
      }
      else if (__stxr(v8 & 0xFFFFFFFFFFFFFFFELL, v12))
      {
        goto LABEL_12;
      }
      if ((v8 | 1) == a4)
        _os_once_gate_recursive_abort(a4);
      result = __ulock_wait((void *)0x1000002, v12, (void *)(v8 & 0xFFFFFFFE), 0, a5, a6, a7, a8);
      if ((result & 0x80000000) != 0 && (_DWORD)result != -4 && -(int)result != 14)
      {
        if (-(int)result == 105)
          _os_once_gate_corruption_abort(v8);
        qword_1EE805DD0 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wait failure";
        qword_1EE805E00 = -(int)result;
        __break(1u);
        return result;
      }
    }
    else if (!__stxr(v13, v12))
    {
      __dmb(9u);
      return _os_once_callout(v12, a2, a3, a4);
    }
LABEL_12:
    v8 = __ldxr(v12);
    if (v8 == -1)
      goto LABEL_19;
  }
  __clrex();
  __dmb(9u);
  if (4 * MEMORY[0xFFFFFC180] - v8 - 15 <= 0xFFFFFFFFFFFFFFEFLL)
    *v12 = -1;
  return result;
}

unint64_t _os_alloc_once(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  _QWORD v10[3];

  v10[0] = a1;
  v10[1] = a2;
  v10[2] = a3;
  _os_once(a1, (uint64_t)v10, _os_alloc, a4, a5, a6, a7, a8);
  return a1[1];
}

uint64_t _os_alloc(uint64_t a1)
{
  uint64_t v1;
  unint64_t *v3;
  unint64_t v4;
  uint64_t result;
  uint64_t (*v6)(void);

  v1 = (*(_DWORD *)(a1 + 8) + 15) & 0xFFFFFFF0;
  if (v1 - 1 >= 2 * vm_page_size - 16)
    _os_alloc_cold_1((*(_DWORD *)(a1 + 8) + 15) & 0xFFFFFFF0);
  v3 = (unint64_t *)_os_alloc_heap[0];
  if (!_os_alloc_heap[0])
    goto LABEL_5;
  do
    v4 = __ldxr(v3);
  while (__stxr(v4 + v1, v3));
  if (v4 + v1 <= 2 * vm_page_size - 16)
    result = (uint64_t)v3 + v4 + 16;
  else
LABEL_5:
    result = _os_alloc_slow(v3, v1);
  *(_QWORD *)(*(_QWORD *)a1 + 8) = result;
  v6 = *(uint64_t (**)(void))(a1 + 16);
  if (v6)
    return v6();
  return result;
}

uint64_t _os_alloc_slow(unint64_t *a1, uint64_t a2)
{
  mach_vm_address_t v4;
  uint64_t result;
  mach_vm_address_t v6;
  unint64_t v7;
  unint64_t v8;
  mach_vm_address_t address;

  v4 = vm_page_size;
  while (1)
  {
    address = v4;
    result = mach_vm_map(mach_task_self_, &address, 2 * v4, 0, 1224736769, 0, 0, 0, 3, 7, 1u);
    if ((_DWORD)result)
      break;
    v6 = address;
    while (1)
    {
      v7 = __ldxr(_os_alloc_heap);
      if ((unint64_t *)v7 != a1)
        break;
      if (!__stxr(v6, _os_alloc_heap))
      {
        *(_QWORD *)(v6 + 8) = a1;
        a1 = (unint64_t *)v6;
        goto LABEL_8;
      }
    }
    __clrex();
    mach_vm_deallocate(mach_task_self_, v6, 2 * vm_page_size);
    a1 = (unint64_t *)_os_alloc_heap[0];
    if (!_os_alloc_heap[0])
    {
      v4 = vm_page_size;
      continue;
    }
    do
LABEL_8:
      v8 = __ldxr(a1);
    while (__stxr(v8 + a2, a1));
    v4 = vm_page_size;
    if (v8 + a2 <= 2 * vm_page_size - 16)
      return (uint64_t)a1 + v8 + 16;
  }
  qword_1EE805DD0 = (uint64_t)"BUG IN LIBPLATFORM: Failed to allocate in os_alloc_once";
  qword_1EE805E00 = (int)result;
  __break(1u);
  return result;
}

uint64_t _os_semaphore_dispose(semaphore_t semaphore)
{
  uint64_t result;

  result = semaphore_destroy(mach_task_self_, semaphore);
  if ((_DWORD)result)
    _os_semaphore_dispose_cold_1(result);
  return result;
}

void *__cdecl _platform_memchr(void *__s, int __c, size_t __n)
{
  int8x16_t v3;
  uint64_t v4;
  unint64_t v5;
  int8x16_t v6;
  uint8x16_t v7;
  unint64_t v8;
  int8x16_t v9;
  BOOL v10;
  void *result;
  uint8x16_t v12;
  int8x16_t v13;
  uint64_t v14;
  unint64_t v15;
  int8x16_t v16;
  uint8x16_t i;
  int8x16_t v18;
  uint8x16_t v19;

  if (!__n)
    return 0;
  if ((__n & 0x8000000000000000) != 0)
  {
    v13 = vdupq_n_s8(__c);
    v14 = __s & 0xF;
    v15 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0;
    v16 = *(int8x16_t *)&algn_1A5CB3DF0[-v14];
    for (i = (uint8x16_t)vorrq_s8(vsubq_s8(*(int8x16_t *)v15, v13), v16); ; i = (uint8x16_t)vsubq_s8(v18, v13))
    {
      v16.i8[0] = vminvq_u8(i);
      if (!v16.i32[0])
        break;
      v18 = *(int8x16_t *)(v15 + 16);
      v15 += 16;
    }
    v19 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(i, (uint8x16_t)veorq_s8(v13, v13)), (int8x16_t)xmmword_1A5CB3DE0);
    v19.i8[0] = vminvq_u8(v19);
    return (void *)(v15 + v19.u32[0]);
  }
  else
  {
    v3 = vdupq_n_s8(__c);
    v4 = __s & 0xF;
    v5 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0;
    v6 = *(int8x16_t *)&algn_1A5CB3DF0[-v4];
    v7 = (uint8x16_t)vorrq_s8(vsubq_s8(*(int8x16_t *)v5, v3), v6);
    v8 = __n + v4;
    while (1)
    {
      v6.i8[0] = vminvq_u8(v7);
      if (!v6.i32[0])
        break;
      v10 = v8 > 0x10;
      v8 -= 16;
      if (!v10)
        return 0;
      v9 = *(int8x16_t *)(v5 + 16);
      v5 += 16;
      v7 = (uint8x16_t)vsubq_s8(v9, v3);
    }
    v12 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v7, (uint8x16_t)veorq_s8(v3, v3)), (int8x16_t)xmmword_1A5CB3DE0);
    v12.i8[0] = vminvq_u8(v12);
    result = (void *)(v5 + v12.u32[0]);
    if (v12.u32[0] >= v8)
      return 0;
  }
  return result;
}

void _pthread_exit(unint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  unint64_t StatusReg;
  uint64_t v18;

  __disable_threadsignal((void *)1, a2, a3, a4, a5, a6, a7, a8);
  _pthread_setcancelstate_exit(a1);
  for (i = *(_QWORD *)(a1 + 8); i; *(_QWORD *)(a1 + 8) = i)
  {
    (*(void (**)(_QWORD))i)(*(_QWORD *)(i + 8));
    i = *(_QWORD *)(i + 16);
  }
  ignition_test_BRA(a1);
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v18 = *(_QWORD *)(StatusReg + 72);
  *(_QWORD *)(StatusReg + 72) = 0;
  if (v18)
    goto LABEL_5;
  while (1)
  {
    LODWORD(v18) = _pthread_terminate_invoke(a1, (uint64_t)a2, v11, v12, v13, v14, v15, v16);
LABEL_5:
    _os_semaphore_dispose(v18);
  }
}

uint64_t _pthread_joiner_wake(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  void *v8;
  uint64_t result;

  v8 = (void *)(a1 + 52);
  do
    result = __ulock_wake((void *)0x1000002, v8, 0, a4, a5, a6, a7, a8);
  while ((_DWORD)result == -4);
  if ((_DWORD)result != -2)
  {
    if ((_DWORD)result)
      _pthread_joiner_wake_cold_1(result);
  }
  return result;
}

void pthread_exit(void *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  unint64_t StatusReg;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  if ((*(_WORD *)(StatusReg - 146) & 0x400) != 0)
  {
    qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPTHREAD: pthread_exit() called from a thread not created by pthread_create()";
    __break(1u);
  }
  else if ((_pthread_ptr_munge_token ^ *(_QWORD *)(StatusReg - 224)) == StatusReg - 224)
  {
    _pthread_exit(StatusReg - 224, a1, v1, v2, v3, v4, v5, v6);
  }
  abort_with_reason((void *)0x12, (void *)4, "pthread_t was corrupted", 0);
}

uint64_t _pthread_terminate_invoke(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v19;
  uint64_t vars0;

  if ((((unint64_t)&vars0 ^ a1) & -(uint64_t)vm_page_size) == 0)
    bzero(&v19, 0x3000uLL);
  v10 = _pthread_terminate(a1, a2, a3, a4, a5, a6, a7, a8);
  return _pthread_terminate(v10, v11, v12, v13, v14, v15, v16, v17);
}

uint64_t _pthread_terminate(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  unint64_t v10;
  char *v11;
  uint64_t v13;
  char *v14;
  void *v15;
  mach_port_name_t v16;
  mach_port_t v17;
  int v18;
  uint64_t v19;
  void *v20;
  char v21;
  char v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  uint64_t result;

  if (_pthread_introspection_hook)
    _pthread_introspection_hook_callout_thread_terminate(a1);
  v10 = *(_QWORD *)(a1 + 192);
  v11 = *(char **)(a1 + 200);
  if (v10 < a1 && (unint64_t)&v11[v10] > a1)
  {
    v14 = (char *)((a1 - v10) & -(uint64_t)vm_page_size);
    *(_QWORD *)(a1 + 192) = &v14[v10];
    *(_QWORD *)(a1 + 200) = v11 - v14;
  }
  else if ((_UNKNOWN *)a1 == &_main_thread)
  {
    v13 = qword_1ECCEE970 - unk_1ECCEE978;
    if (qword_1ECCEE970 == unk_1ECCEE978)
      v13 = 0x80000;
    v10 = qword_1ECCEE970 - v13;
    v14 = (char *)(((unint64_t)_pthread_current_stack_address() & -(uint64_t)vm_page_size) - v10);
  }
  else
  {
    v14 = 0;
  }
  v15 = (void *)*(unsigned int *)(a1 + 248);
  v16 = *(_DWORD *)(a1 + 288);
  if (v16)
  {
    *(_DWORD *)(a1 + 288) = 0;
    thread_destruct_special_reply_port(v16, 0);
  }
  v17 = *(_DWORD *)(a1 + 240);
  if (v17)
    mig_dealloc_reply_port(v17);
  os_unfair_lock_lock_with_options((unsigned int *)&_pthread_list_lock, 327680, a3, a4, a5, a6, a7, a8);
  *(_DWORD *)(a1 + 52) = -1;
  *(_QWORD *)(a1 + 40) = a2;
  v18 = _pthread_count--;
  v19 = *(_QWORD *)(a1 + 32);
  if (v19)
    v20 = (void *)_pthread_joiner_prepost_wake(a1);
  else
    v20 = 0;
  v21 = *(_BYTE *)(a1 + 49);
  v22 = v21 & 1;
  if ((v21 & 1) != 0)
  {
    *(_BYTE *)(a1 + 49) = v21 | 2;
  }
  else
  {
    v23 = *(_QWORD *)(a1 + 16);
    v24 = *(_QWORD **)(a1 + 24);
    if (v23)
    {
      *(_QWORD *)(v23 + 24) = v24;
      v24 = *(_QWORD **)(a1 + 24);
    }
    else
    {
      qword_1EE805DB8 = *(_QWORD *)(a1 + 24);
    }
    *v24 = v23;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_pthread_list_lock);
  if (v19)
  {
    _pthread_joiner_wake(a1, v25, v26, v27, v28, v29, v30, v31);
    os_unfair_lock_lock_with_options((unsigned int *)&_pthread_list_lock, 327680, v32, v33, v34, v35, v36, v37);
    if (*(_QWORD *)(a1 + 32))
    {
      *(_BYTE *)(a1 + 49) |= 2u;
      v22 = 1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_pthread_list_lock);
  }
  if ((_UNKNOWN *)a1 != &_main_thread && (v22 & 1) == 0)
  {
    if (_pthread_introspection_hook)
      _pthread_introspection_hook_callout_thread_destroy(a1);
    v14 = v11;
  }
  if (v18 <= 1)
    _exit(0);
  if (v14)
    v38 = (void *)v10;
  else
    v38 = 0;
  result = __bsdthread_terminate(v38, v14, v15, v20, v28, v29, v30, v31);
  qword_1EE805DD0 = (uint64_t)"BUG IN LIBPTHREAD: thread didn't terminate";
  qword_1EE805E00 = a1;
  __break(1u);
  return result;
}

char *_pthread_current_stack_address()
{
  char v1;

  return &v1;
}

uint64_t _pthread_introspection_hook_callout_thread_terminate(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t StatusReg;
  __int16 v4;
  uint64_t result;

  if ((_UNKNOWN *)a1 == &_main_thread)
  {
    v2 = qword_1ECCEE970 - unk_1ECCEE978 + qword_1ECCEE990;
    v1 = unk_1ECCEE978 - qword_1ECCEE990;
  }
  else
  {
    v1 = *(_QWORD *)(a1 + 192);
    v2 = *(_QWORD *)(a1 + 200) - (~(_DWORD)vm_page_mask & (vm_page_mask + 4320));
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v4 = *(_WORD *)(StatusReg - 174);
  *(_WORD *)(StatusReg - 174) = 3;
  result = _pthread_introspection_hook(3, a1, v1, v2);
  *(_WORD *)(StatusReg - 174) = v4;
  return result;
}

uint64_t _pthread_introspection_hook_callout_thread_destroy(uint64_t a1)
{
  vm_size_t v1;
  unint64_t StatusReg;
  __int16 v3;
  uint64_t result;

  v1 = ~(_DWORD)vm_page_mask & (vm_page_mask + 4320);
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v3 = *(_WORD *)(StatusReg - 174);
  *(_WORD *)(StatusReg - 174) = 4;
  result = _pthread_introspection_hook(4, a1, a1, v1);
  *(_WORD *)(StatusReg - 174) = v3;
  return result;
}

void _pthread_joiner_wake_cold_1(int a1)
{
  qword_1EE805DD0 = (uint64_t)"BUG IN LIBPTHREAD: pthread_join() wake failure";
  qword_1EE805E00 = -a1;
  __break(1u);
}

uint64_t _pthread_setcancelstate_exit(uint64_t result)
{
  unsigned __int16 *v1;
  unsigned __int16 v2;

  v1 = (unsigned __int16 *)(result + 166);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 & 0xFFDC | 0x22, v1));
  return result;
}

uint64_t _pthread_joiner_prepost_wake(uint64_t a1)
{
  uint64_t v2;
  char v3;
  uint64_t result;
  int v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_BYTE *)(a1 + 49);
  if ((v3 & 1) != 0)
  {
    result = *(unsigned int *)(v2 + 20);
    *(_BYTE *)(a1 + 49) = v3 & 0xFE;
  }
  else
  {
    result = 0;
    *(_BYTE *)(v2 + 24) = 1;
    *(_QWORD *)(a1 + 32) = 0;
  }
  if (*(_QWORD *)(v2 + 8))
  {
    v5 = atomic_load((unsigned __int16 *)(a1 + 166));
    if ((~v5 & 0x11) != 0)
      v6 = *(_QWORD *)(a1 + 40);
    else
      v6 = 1;
    **(_QWORD **)(v2 + 8) = v6;
  }
  return result;
}

void OUTLINED_FUNCTION_0_2(uint64_t a1, uint64_t a2, void *a3)
{
  abort_with_reason((void *)0x12, (void *)4, a3, 0);
}

void _pthread_exit_if_canceled_cold_1(uint64_t a1, uint64_t a2)
{
  OUTLINED_FUNCTION_0_2(a1, a2, "pthread_t was corrupted");
}

uint64_t mutex_seq_atomic_cmpxchgv_relaxed(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t result;

  v3 = *a2;
  v4 = *a3;
  while (1)
  {
    v5 = __ldxr(a1);
    if (v5 != v3)
      break;
    if (!__stxr(v4, a1))
    {
      result = 1;
      goto LABEL_6;
    }
  }
  result = 0;
  __clrex();
LABEL_6:
  *a2 = v5;
  return result;
}

uint64_t mutex_seq_atomic_cmpxchgv_acquire(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t result;

  v3 = *a2;
  v4 = *a3;
  while (1)
  {
    v5 = __ldaxr(a1);
    if (v5 != v3)
      break;
    if (!__stxr(v4, a1))
    {
      result = 1;
      goto LABEL_6;
    }
  }
  result = 0;
  __clrex();
LABEL_6:
  *a2 = v5;
  return result;
}

uint64_t mutex_seq_atomic_cmpxchgv_release(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t result;

  v3 = *a2;
  v4 = *a3;
  while (1)
  {
    v5 = __ldxr(a1);
    if (v5 != v3)
      break;
    if (!__stlxr(v4, a1))
    {
      result = 1;
      goto LABEL_6;
    }
  }
  result = 0;
  __clrex();
LABEL_6:
  *a2 = v5;
  return result;
}

vm_address_t *sandbox_warn(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  vm_address_t *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v10 = (vm_address_t *)_simple_salloc();
  _simple_vsprintf((uint64_t)v10, a1, &a9);
  v11 = _simple_string((_BYTE **)v10);
  _simple_asl_log(2, (uint64_t)"com.apple.libsystem.sandbox", v11, v12, v13, v14, v15, v16);
  v17 = _simple_string((_BYTE **)v10);
  _simple_dprintf(2, "%s\n", v18, v19, v20, v21, v22, v23, v17);
  return _simple_sfree(v10);
}

uint64_t __abort_with_payload(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_abort_with_payload, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __bsdthread_create(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_bsdthread_create, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __bsdthread_ctl(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_bsdthread_ctl, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __bsdthread_register(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_bsdthread_register, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __bsdthread_terminate(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_bsdthread_terminate, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

int __chmod(const char *a1, mode_t a2)
{
  char v2;
  int result;

  result = mac_syscall(SYS_chmod, a1, a2);
  if (v2)
    return cerror_nocancel(result);
  return result;
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  char v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;

  LODWORD(v9) = mac_syscall(SYS_connect, a1, a2, a3);
  if (v3)
    LODWORD(v9) = cerror(v9, (void *)a2, *(void **)&a3, v4, v5, v6, v7, v8);
  return v9;
}

uint64_t __disable_threadsignal(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS___disable_threadsignal, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

int __execve(const char *a1, char *const *a2, char *const *a3)
{
  char v3;
  int result;

  result = mac_syscall(SYS_execve, a1, a2, a3);
  if (v3)
    return cerror_nocancel(result);
  return result;
}

void _exit(int a1)
{
  char v1;
  int v2;

  mac_syscall(SYS_exit, a1);
  if (v1)
    cerror_nocancel(v2);
}

int __fchmod(int a1, mode_t a2)
{
  char v2;
  int result;

  result = mac_syscall(SYS_fchmod, a1, a2);
  if (v2)
    return cerror_nocancel(result);
  return result;
}

uint64_t __getdirentries64(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_getdirentries64, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

int __gettimeofday_with_mach(timeval *a1, void *a2)
{
  char v2;
  int result;

  result = mac_syscall(SYS_gettimeofday, a1, a2);
  if (v2)
    return cerror_nocancel(result);
  return result;
}

int __gettimeofday(timeval *a1, void *a2)
{
  char v2;
  int result;

  result = mac_syscall(SYS_gettimeofday, a1, a2);
  if (v2)
    return cerror_nocancel(result);
  return result;
}

int __ioctl(int a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t v9;

  LODWORD(v9) = mac_syscall(SYS_ioctl, a1, (unint64_t)a2, a3);
  if (v8)
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  return v9;
}

uint64_t __kqueue_workloop_ctl(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_kqueue_workloop_ctl, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  char v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  off_t result;

  result = mac_syscall(SYS_lseek, a1, a2, a3);
  if (v3)
    return cerror(result, (void *)a2, *(void **)&a3, v4, v5, v6, v7, v8);
  return result;
}

int __open_dprotected_np(const char *a1, int a2, int a3, int a4)
{
  char v4;
  int result;

  result = mac_syscall(SYS_open_dprotected_np, a1, a2, a3, a4);
  if (v4)
    return cerror_nocancel(result);
  return result;
}

int __openat_dprotected_np(int a1, const char *a2, int a3, int a4, int a5)
{
  char v5;
  int result;

  result = mac_syscall(SYS_openat_dprotected_np, a1, a2, a3, a4, a5);
  if (v5)
    return cerror_nocancel(result);
  return result;
}

int pipe(int a1[2])
{
  char v1;
  int v2;
  int v4;

  v4 = mac_syscall(SYS_pipe, a1);
  if (v1)
    return cerror_nocancel(v4);
  *a1 = v4;
  a1[1] = v2;
  return 0;
}

int __posix_spawn(pid_t *a1, char *a2, posix_spawn_file_actions_t *a3, posix_spawnattr_t *a4, char **a5, char **a6, void *a7, void *a8)
{
  char v8;
  uint64_t v9;

  LODWORD(v9) = mac_syscall(SYS_posix_spawn, a1, a2, a3, a4, a5, a6);
  if (v8)
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  return v9;
}

uint64_t __proc_info_extended_id(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_proc_info_extended_id, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __process_policy(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_process_policy, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __psynch_cvbroad(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_psynch_cvbroad, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __psynch_cvclrprepost(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_psynch_cvclrprepost, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __psynch_cvsignal(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_psynch_cvsignal, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __psynch_cvwait(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_psynch_cvwait, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __psynch_mutexdrop(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_psynch_mutexdrop, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __psynch_mutexwait(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_psynch_mutexwait, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __pthread_canceled(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS___pthread_canceled, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

int __pthread_kill(_opaque_pthread_t *a1, int a2)
{
  char v2;
  int result;

  result = mac_syscall(SYS___pthread_kill, a1, a2);
  if (v2)
    return cerror_nocancel(result);
  return result;
}

uint64_t __pthread_markcancel(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS___pthread_markcancel, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

int __pthread_sigmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  char v3;
  int result;

  result = mac_syscall(SYS___pthread_sigmask, a1, a2, a3);
  if (v3)
    return cerror_nocancel(result);
  return result;
}

void __rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  char v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;

  mac_syscall(SYS_rename, __from, __to, __ec);
  if (v3)
    cerror(v9, (void *)__to, __ec, v4, v5, v6, v7, v8);
}

uint64_t __semwait_signal_nocancel(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS___semwait_signal_nocancel, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

ssize_t sendto(int a1, const void *a2, size_t a3, int a4, const sockaddr *a5, socklen_t a6)
{
  char v6;
  void *v7;
  void *v8;
  ssize_t result;

  result = mac_syscall(SYS_sendto, a1, a2, a3, a4, a5, a6);
  if (v6)
    return cerror(result, (void *)a2, (void *)a3, *(void **)&a4, (void *)a5, *(void **)&a6, v7, v8);
  return result;
}

uint64_t __shared_region_map_and_slide_2_np(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_shared_region_map_and_slide_2_np, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

int __sigwait(const sigset_t *a1, int *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t v9;

  LODWORD(v9) = mac_syscall(SYS___sigwait, a1, a2);
  if (v8)
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  return v9;
}

int syscall(int a1, ...)
{
  char v1;
  uint64_t v2;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  va_list va;

  va_start(va, a1);
  v4 = va_arg(va, void *);
  v5 = va_arg(va, void *);
  v6 = va_arg(va, void *);
  v7 = va_arg(va, void *);
  v8 = va_arg(va, void *);
  v9 = va_arg(va, void *);
  v10 = va_arg(va, void *);
  LODWORD(v2) = mac_syscall(SYS_syscall, a1, v4, v5, v6, v7, v8, v9, v10);
  if (v1)
    LODWORD(v2) = cerror(v2, v4, v5, v6, v7, v8, v9, v10);
  return v2;
}

uint64_t __terminate_with_payload(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_terminate_with_payload, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __ulock_wait(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_ulock_wait, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __ulock_wait2(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_ulock_wait2, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __ulock_wake(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_ulock_wake, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

int __unlink(const char *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t v9;

  LODWORD(v9) = mac_syscall(SYS_unlink, a1);
  if (v8)
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  return v9;
}

uint64_t __workq_kernreturn(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_workq_kernreturn, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t __workq_open(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_workq_open, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

int dup2(int a1, int a2)
{
  char v2;
  int result;

  result = mac_syscall(SYS_dup2, a1, a2);
  if (v2)
    return cerror_nocancel(result);
  return result;
}

int fgetattrlist(int a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  char v5;
  int result;

  result = mac_syscall(SYS_fgetattrlist, a1, a2, a3, a4, a5);
  if (v5)
    return cerror_nocancel(result);
  return result;
}

ssize_t fgetxattr(int fd, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  char v6;
  ssize_t result;

  result = mac_syscall(SYS_fgetxattr, fd, name, value, size, position, options);
  if (v6)
    return cerror_nocancel(result);
  return result;
}

int fmount(const char *a1, int a2, int a3, void *a4)
{
  char v4;
  int result;

  result = mac_syscall(SYS_fmount, a1, a2, a3, a4);
  if (v4)
    return cerror_nocancel(result);
  return result;
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  char v4;
  int result;

  result = mac_syscall(SYS_fsctl, a1, a2, a3, a4);
  if (v4)
    return cerror_nocancel(result);
  return result;
}

int fsetxattr(int fd, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  char v6;
  int result;

  result = mac_syscall(SYS_fsetxattr, fd, name, value, size, position, options);
  if (v6)
    return cerror_nocancel(result);
  return result;
}

int fstatfs64(int a1, statfs *a2)
{
  char v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  int64_t v9;

  v9 = mac_syscall(SYS_fstatfs64, *(void **)&a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2)
    LODWORD(v9) = cerror_nocancel(v9);
  return v9;
}

int fsync(int a1)
{
  char v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;

  LODWORD(v9) = mac_syscall(SYS_fsync, a1);
  if (v1)
    LODWORD(v9) = cerror(v9, v2, v3, v4, v5, v6, v7, v8);
  return v9;
}

int ftruncate(int a1, off_t a2)
{
  char v2;
  int result;

  result = mac_syscall(SYS_ftruncate, a1, a2);
  if (v2)
    return cerror_nocancel(result);
  return result;
}

int getattrlistbulk(int a1, void *a2, void *a3, size_t a4, uint64_t a5)
{
  char v5;
  int result;

  result = mac_syscall(SYS_getattrlistbulk, a1, a2, a3, a4, a5);
  if (v5)
    return cerror_nocancel(result);
  return result;
}

int getentropy(void *buffer, size_t size)
{
  char v2;
  int result;

  result = mac_syscall(SYS_getentropy, buffer, size);
  if (v2)
    return cerror_nocancel(result);
  return result;
}

gid_t getgid(void)
{
  char v0;
  gid_t result;

  result = mac_syscall(SYS_getgid);
  if (v0)
    return cerror_nocancel(result);
  return result;
}

uid_t getuid(void)
{
  char v0;
  uid_t result;

  result = mac_syscall(SYS_getuid);
  if (v0)
    return cerror_nocancel(result);
  return result;
}

uint64_t graftdmg(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_graftdmg, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

int lstat64(const char *a1, stat *a2)
{
  char v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  int64_t v9;

  v9 = mac_syscall(SYS_lstat64, (void *)a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2)
    LODWORD(v9) = cerror_nocancel(v9);
  return v9;
}

int mkdir(const char *a1, mode_t a2)
{
  char v2;
  int result;

  result = mac_syscall(SYS_mkdir, a1, a2);
  if (v2)
    return cerror_nocancel(result);
  return result;
}

int mount(const char *a1, const char *a2, int a3, void *a4)
{
  char v4;
  int result;

  result = mac_syscall(SYS_mount, a1, a2, a3, a4);
  if (v4)
    return cerror_nocancel(result);
  return result;
}

uint64_t mremap_encrypted(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_mremap_encrypted, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t openbyid_np(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_openbyid_np, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

uint64_t os_fault_with_payload(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_os_fault_with_payload, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  char v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  ssize_t result;

  result = mac_syscall(SYS_pread, __fd, __buf, __nbyte, a4);
  if (v4)
    return cerror(result, __buf, (void *)__nbyte, (void *)a4, v5, v6, v7, v8);
  return result;
}

uint64_t proc_rlimit_control(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v8;
  uint64_t result;

  result = mac_syscall(SYS_proc_rlimit_control, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    return cerror_nocancel(result);
  return result;
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  char v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  ssize_t result;

  result = mac_syscall(SYS_pwrite, __fd, __buf, __nbyte, a4);
  if (v4)
    return cerror(result, (void *)__buf, (void *)__nbyte, (void *)a4, v5, v6, v7, v8);
  return result;
}

ssize_t read(int a1, void *a2, size_t a3)
{
  char v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  ssize_t result;

  result = mac_syscall(SYS_read, a1, a2, a3);
  if (v3)
    return cerror(result, a2, (void *)a3, v4, v5, v6, v7, v8);
  return result;
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  char v3;
  ssize_t result;

  result = mac_syscall(SYS_readlink, a1, a2, a3);
  if (v3)
    return cerror_nocancel(result);
  return result;
}

int setxattr(const char *path, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  char v6;
  int result;

  result = mac_syscall(SYS_setxattr, path, name, value, size, position, options);
  if (v6)
    return cerror_nocancel(result);
  return result;
}

int sigprocmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  char v3;
  int result;

  result = mac_syscall(SYS_sigprocmask, a1, a2, a3);
  if (v3)
    return cerror_nocancel(result);
  return result;
}

int socket(int a1, int a2, int a3)
{
  char v3;
  int result;

  mac_syscall(SYS_socket);
  if (v3)
    return cerror_nocancel(result);
  return result;
}

int statfs64(const char *a1, statfs *a2)
{
  char v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  int64_t v9;

  v9 = mac_syscall(SYS_statfs64, (void *)a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2)
    LODWORD(v9) = cerror_nocancel(v9);
  return v9;
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  char v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  ssize_t result;

  result = mac_syscall(SYS_write, __fd, __buf, __nbyte);
  if (v3)
    return cerror(result, (void *)__buf, (void *)__nbyte, v4, v5, v6, v7, v8);
  return result;
}

uint64_t ccdigest_final_64be(uint64_t a1, const void *a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  _QWORD *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  unint64_t v17;
  unsigned int v18;
  uint64_t v20;

  v7 = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 16);
  v8 = (uint64_t)a2 + v7 + 8;
  if (v6 <= *(unsigned int *)(v8 + v6))
    *(_DWORD *)(v8 + v6) = 0;
  v9 = (v7 + v6 + 19) & 0xFFFFFFFFFFFFFFF8;
  v10 = (uint64_t *)((char *)&v20 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero(v10, v9);
  memmove(v10, a2, v7 + v6 + 12);
  v11 = (char *)v10 + v7;
  v12 = (uint64_t)v10 + v7 + 8;
  v13 = (char *)(v12 + v6);
  v14 = *(unsigned int *)(v12 + v6);
  *v10 += (8 * v14);
  *(_DWORD *)(v12 + v6) = v14 + 1;
  *(_BYTE *)(v12 + v14) = 0x80;
  v15 = *(unsigned int *)(v12 + v6);
  if (v15 < 0x39)
  {
    if (v15 == 56)
      goto LABEL_9;
  }
  else
  {
    if (v15 <= 0x3F)
    {
      do
      {
        *(_DWORD *)v13 = v15 + 1;
        *(_BYTE *)(v12 + v15) = 0;
        v15 = *(unsigned int *)v13;
      }
      while (v15 < 0x40);
    }
    (*(void (**)(_QWORD *, uint64_t))(a1 + 48))(v10 + 1, 1);
    v15 = 0;
    v11 = (char *)v10 + *(_QWORD *)(a1 + 8);
    v12 = (uint64_t)(v11 + 8);
    v13 = &v11[*(_QWORD *)(a1 + 16) + 8];
    *(_DWORD *)v13 = 0;
  }
  do
  {
    *(_DWORD *)v13 = v15 + 1;
    *(_BYTE *)(v12 + v15) = 0;
    v15 = *(unsigned int *)v13;
  }
  while (v15 < 0x38);
LABEL_9:
  *((_QWORD *)v11 + 8) = bswap64(*v10);
  (*(void (**)(_QWORD *, uint64_t))(a1 + 48))(v10 + 1, 1);
  if (*(_QWORD *)a1 >= 4uLL)
  {
    v16 = 0;
    v17 = 0;
    v18 = 1;
    do
    {
      *(_DWORD *)(a3 + v16) = bswap32(*((_DWORD *)v10 + v17 + 2));
      v17 = v18++;
      v16 += 4;
    }
    while (v17 < *(_QWORD *)a1 >> 2);
  }
  return cc_clear(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16) + 12, v10);
}

_BYTE *ccdigest_init(uint64_t a1, _QWORD *a2)
{
  char v4;
  char v11;

  v4 = 0;
  v11 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      v4 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      v4 = 1;
    }
  }
  v11 = v4;
  memmove(a2 + 1, *(const void **)(a1 + 40), *(_QWORD *)(a1 + 8));
  *a2 = 0;
  *(_DWORD *)((char *)a2 + *(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16) + 8) = 0;
  return cc_disable_dit(&v11);
}

_BYTE *ccdigest_update(uint64_t a1, _QWORD *a2, size_t a3, char *__src)
{
  size_t v5;
  char v8;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  size_t v16;
  char *v17;
  uint64_t v18;
  size_t v20;
  size_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  size_t v27;
  char v29;

  v5 = a3;
  v8 = 0;
  v29 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      v8 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      v8 = 1;
    }
  }
  v29 = v8;
  v13 = *(_QWORD *)(a1 + 16);
  v14 = (uint64_t)a2 + *(_QWORD *)(a1 + 8) + 8;
  if (v13 <= *(unsigned int *)(v14 + v13))
    *(_DWORD *)(v14 + v13) = 0;
  if (a3)
  {
    v15 = a2 + 1;
    do
    {
      v16 = *(_QWORD *)(a1 + 16);
      v17 = (char *)v15 + *(_QWORD *)(a1 + 8);
      v18 = *(unsigned int *)&v17[v16];
      if (v5 > v16 && (_DWORD)v18 == 0)
      {
        if (v16 == 128)
        {
          v27 = v5 >> 7;
          v21 = v5 & 0xFFFFFFFFFFFFFF80;
        }
        else if (v16 == 64)
        {
          v27 = v5 >> 6;
          v21 = v5 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          v27 = v5 / v16;
          v21 = v5 / v16 * v16;
        }
        (*(void (**)(_QWORD *, size_t, char *))(a1 + 48))(a2 + 1, v27, __src);
        *a2 += 8 * v21;
      }
      else
      {
        v20 = v16 - v18;
        if (v20 >= v5)
          v21 = v5;
        else
          v21 = v20;
        memmove(&v17[v18], __src, v21);
        v22 = *(_QWORD *)(a1 + 16);
        v23 = (char *)v15 + *(_QWORD *)(a1 + 8);
        v24 = (*(_DWORD *)&v23[v22] + v21);
        *(_DWORD *)&v23[v22] = v24;
        if (v22 == v24)
        {
          (*(void (**)(_QWORD *, uint64_t))(a1 + 48))(a2 + 1, 1);
          v25 = *(_QWORD *)(a1 + 16);
          v26 = (char *)v15 + *(_QWORD *)(a1 + 8);
          *a2 += (8 * *(_DWORD *)&v26[v25]);
          *(_DWORD *)&v26[v25] = 0;
        }
      }
      __src += v21;
      v5 -= v21;
    }
    while (v5);
  }
  return cc_disable_dit(&v29);
}

int32x4_t *AccelerateCrypto_SHA256_compress(int32x4_t *result, uint64_t a2, int8x16_t *a3)
{
  int8x16_t *v3;
  int8x16_t v4;
  int8x16_t v5;
  int8x16_t v6;
  int8x16_t v7;
  int32x4_t v9;
  __int128 *v19;
  int v20;
  int32x4_t v22;
  int32x4_t v28;
  int32x4_t v30;
  int32x4_t v32;
  BOOL v44;
  uint64_t v45;
  int32x4_t *v46;
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t v52;

  if (a2)
  {
    v4 = *a3;
    v5 = a3[1];
    v6 = a3[2];
    v7 = a3[3];
    v3 = a3 + 4;
    _Q1 = (int32x4_t)vrev32q_s8(v5);
    v9 = *result;
    _Q2 = (int32x4_t)vrev32q_s8(v6);
    _Q17 = result[1];
    _Q3 = (int32x4_t)vrev32q_s8(v7);
    _Q18 = *result;
    _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v4), (int32x4_t)K256);
    _Q5 = vaddq_s32(_Q1, (int32x4_t)xmmword_1A5CB5590);
    _Q19 = _Q17;
    _Q6 = vaddq_s32(_Q2, (int32x4_t)xmmword_1A5CB55A0);
    _Q7 = vaddq_s32(_Q3, (int32x4_t)xmmword_1A5CB55B0);
    v19 = &xmmword_1A5CB55C0;
    v20 = 3;
    do
    {
      _Q20 = _Q18;
      v22 = (int32x4_t)*v19;
      __asm { SHA256SU0       V0.4S, V1.4S }
      v28 = (int32x4_t)v19[1];
      __asm { SHA256H         Q18, Q19, V4.4S }
      v30 = (int32x4_t)v19[2];
      __asm { SHA256SU1       V0.4S, V2.4S, V3.4S }
      v32 = (int32x4_t)v19[3];
      __asm { SHA256H2        Q19, Q20, V4.4S }
      v19 += 4;
      _Q4 = vaddq_s32(_Q0, v22);
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V1.4S, V2.4S
        SHA256H         Q18, Q19, V5.4S
        SHA256SU1       V1.4S, V3.4S, V0.4S
        SHA256H2        Q19, Q20, V5.4S
      }
      _Q5 = vaddq_s32(_Q1, v28);
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V2.4S, V3.4S
        SHA256H         Q18, Q19, V6.4S
        SHA256SU1       V2.4S, V0.4S, V1.4S
        SHA256H2        Q19, Q20, V6.4S
      }
      _Q6 = vaddq_s32(_Q2, v30);
      --v20;
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V3.4S, V0.4S
        SHA256H         Q18, Q19, V7.4S
        SHA256SU1       V3.4S, V1.4S, V2.4S
        SHA256H2        Q19, Q20, V7.4S
      }
      _Q7 = vaddq_s32(_Q3, v32);
    }
    while (!(_NF ^ _VF | _ZF));
    v44 = a2 <= 1;
    v45 = a2 - 1;
    if (!v44)
    {
      v46 = (int32x4_t *)(v19 - 16);
      do
      {
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V4.4S }
        v49 = v3[1];
        v50 = v3[2];
        __asm { SHA256H2        Q19, Q20, V4.4S }
        v52 = v3[3];
        _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(*v3), *v46);
        _Q20 = _Q18;
        v3 += 4;
        __asm { SHA256H         Q18, Q19, V5.4S }
        _Q1 = (int32x4_t)vrev32q_s8(v49);
        __asm { SHA256H2        Q19, Q20, V5.4S }
        _Q5 = vaddq_s32(_Q1, v46[1]);
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V6.4S }
        _Q2 = (int32x4_t)vrev32q_s8(v50);
        __asm { SHA256H2        Q19, Q20, V6.4S }
        _Q6 = vaddq_s32(_Q2, v46[2]);
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V7.4S }
        _Q3 = (int32x4_t)vrev32q_s8(v52);
        __asm { SHA256H2        Q19, Q20, V7.4S }
        _Q7 = vaddq_s32(_Q3, v46[3]);
        v9 = vaddq_s32(v9, _Q18);
        _Q17 = vaddq_s32(_Q17, _Q19);
        _Q20 = v9;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }
        _Q4 = vaddq_s32(_Q0, v46[4]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }
        _Q5 = vaddq_s32(_Q1, v46[5]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }
        _Q6 = vaddq_s32(_Q2, v46[6]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }
        _Q7 = vaddq_s32(_Q3, v46[7]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }
        _Q4 = vaddq_s32(_Q0, v46[8]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }
        _Q5 = vaddq_s32(_Q1, v46[9]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }
        _Q6 = vaddq_s32(_Q2, v46[10]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }
        _Q7 = vaddq_s32(_Q3, v46[11]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }
        _Q4 = vaddq_s32(_Q0, v46[12]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }
        _Q5 = vaddq_s32(_Q1, v46[13]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }
        _Q6 = vaddq_s32(_Q2, v46[14]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }
        _Q7 = vaddq_s32(_Q3, v46[15]);
        v44 = v45-- <= 1;
      }
      while (!v44);
    }
    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V4.4S
      SHA256H2        Q19, Q20, V4.4S
    }
    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V5.4S
      SHA256H2        Q19, Q20, V5.4S
    }
    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V6.4S
      SHA256H2        Q19, Q20, V6.4S
    }
    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V7.4S
      SHA256H2        Q19, Q20, V7.4S
    }
    *result = vaddq_s32(v9, _Q18);
    result[1] = vaddq_s32(_Q17, _Q19);
  }
  return result;
}

uint64_t *AccelerateCrypto_SHA512_compress(uint64_t *result, uint64_t a2, int8x16_t *a3)
{
  int8x16_t *v3;
  int8x16_t v4;
  int64x2_t v5;
  int64x2_t v6;
  int64x2_t v7;
  int64x2_t v8;
  int64x2_t v9;
  int64x2_t v10;
  int64x2_t v11;
  int64x2_t v12;
  __int128 *i8;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int64x2_t v23;
  int8x16_t v24;
  int64x2_t v25;
  uint64_t v26;
  int8x16_t v27;
  int64x2_t v28;
  uint64_t v29;
  uint64_t v30;
  int8x16_t v31;
  int64x2_t v32;
  int64x2_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int64x2_t v37;
  int8x16_t v38;
  int64x2_t v39;
  uint64_t v40;
  int8x16_t v41;
  int64x2_t v42;
  uint64_t v43;
  uint64_t v44;
  int8x16_t v45;
  int64x2_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int64x2_t v50;
  int8x16_t v51;
  int64x2_t v52;
  uint64_t v53;
  int8x16_t v54;
  int64x2_t v55;
  uint64_t v56;
  uint64_t v57;
  int8x16_t v58;
  int64x2_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int64x2_t v63;
  int8x16_t v64;
  int64x2_t v65;
  uint64_t v66;
  int8x16_t v67;
  int64x2_t v68;
  uint64_t v69;
  uint64_t v70;
  int8x16_t v71;
  int64x2_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int64x2_t v76;
  int8x16_t v77;
  int64x2_t v78;
  uint64_t v79;
  int8x16_t v80;
  int64x2_t v81;
  uint64_t v82;
  uint64_t v83;
  int8x16_t v84;
  int64x2_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int64x2_t v89;
  int8x16_t v90;
  int64x2_t v91;
  uint64_t v92;
  int8x16_t v93;
  int64x2_t v94;
  uint64_t v95;
  uint64_t v96;
  int8x16_t v97;
  int64x2_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  int64x2_t v102;
  int8x16_t v103;
  int64x2_t v104;
  uint64_t v105;
  int8x16_t v106;
  int64x2_t v107;
  int8x16_t v108;
  int64x2_t v109;
  uint64_t v110;
  int64x2_t v111;
  int8x16_t v112;
  int64x2_t v113;
  uint64_t v114;
  int8x16_t v115;
  int64x2_t v116;
  int8x16_t v117;
  int64x2_t v118;
  uint64_t v119;
  BOOL v120;
  __int128 *v121;
  int8x16_t *v122;
  int8x16_t v123;
  uint64_t v124;
  int64x2_t *v125;
  int64x2_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  int8x16_t v132;
  uint64_t v133;
  int64x2_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  int8x16_t v140;
  uint64_t v141;
  int64x2_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  int8x16_t v148;
  uint64_t v149;
  int64x2_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  int8x16_t v156;
  uint64_t v157;
  int64x2_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  int8x16_t v164;
  uint64_t v165;
  int64x2_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  int8x16_t v172;
  uint64_t v173;
  int64x2_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  int8x16_t v180;
  uint64_t v181;
  int64x2_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  int64x2_t v240;
  int64x2_t v241;
  int64x2_t v242;
  int64x2_t v243;
  int64x2_t v244;
  int64x2_t v245;
  int64x2_t v246;
  int64x2_t v247;

  if (a2)
  {
    v4 = *a3;
    v3 = a3 + 8;
    v5 = (int64x2_t)vrev64q_s8(v4);
    v6 = (int64x2_t)vrev64q_s8(v3[-7]);
    v7 = (int64x2_t)vrev64q_s8(v3[-6]);
    v8 = (int64x2_t)vrev64q_s8(v3[-5]);
    v9 = (int64x2_t)vrev64q_s8(v3[-4]);
    v10 = (int64x2_t)vrev64q_s8(v3[-3]);
    v11 = (int64x2_t)vrev64q_s8(v3[-2]);
    v12 = (int64x2_t)vrev64q_s8(v3[-1]);
    i8 = &xmmword_1A5CBC660;
    v240 = vaddq_s64((int64x2_t)sha512_K, v5);
    v241 = vaddq_s64(unk_1A5CBC5F0, v6);
    v242 = vaddq_s64(unk_1A5CBC600, v7);
    v243 = vaddq_s64(unk_1A5CBC610, v8);
    v244 = vaddq_s64((int64x2_t)xmmword_1A5CBC620, v9);
    v245 = vaddq_s64(unk_1A5CBC630, v10);
    v246 = vaddq_s64(unk_1A5CBC640, v11);
    v247 = vaddq_s64(unk_1A5CBC650, v12);
    while (1)
    {
      v14 = *result;
      v15 = result[1];
      v16 = result[2];
      v17 = result[3];
      v18 = result[4];
      v19 = result[5];
      v20 = result[6];
      v21 = result[7];
      v22 = 4;
      do
      {
        v23 = (int64x2_t)vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL);
        v24 = (int8x16_t)vshrq_n_u64((uint64x2_t)v12, 0x13uLL);
        v25 = vshlq_n_s64(v12, 3uLL);
        v26 = v21
            + v240.i64[0]
            + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41))
            + ((v19 ^ v20) & v18 ^ v20);
        v27 = (int8x16_t)vshrq_n_u64((uint64x2_t)v23, 1uLL);
        v28 = vshlq_n_s64(v23, 0x38uLL);
        v29 = v17 + v26;
        v30 = v26 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
        v31 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v12, 6uLL), v24), (int8x16_t)v25), (int8x16_t)vshrq_n_u64((uint64x2_t)v24, 0x2AuLL));
        v32 = (int64x2_t)*i8;
        v33 = (int64x2_t *)(i8 + 1);
        v5 = vaddq_s64(vaddq_s64(vaddq_s64(v5, (int64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v10, 8uLL)), (int64x2_t)veorq_s8(v31, (int8x16_t)vshlq_n_s64(v25, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v23, 7uLL), v27), (int8x16_t)v28), (int8x16_t)vshrq_n_u64((uint64x2_t)v27, 7uLL)), (int8x16_t)vshlq_n_s64(v28, 7uLL)));
        v34 = v20
            + v240.i64[1]
            + (__ROR8__(v29, 14) ^ __ROR8__(v29, 18) ^ __ROR8__(v29, 41))
            + ((v18 ^ v19) & v29 ^ v19);
        v35 = v16 + v34;
        v36 = v34 + (__ROR8__(v30, 28) ^ __ROR8__(v30, 34) ^ __ROR8__(v30, 39)) + ((v14 ^ v15) & v30 ^ v14 & v15);
        v240 = vaddq_s64(v32, v5);
        v37 = (int64x2_t)vextq_s8((int8x16_t)v6, (int8x16_t)v7, 8uLL);
        v38 = (int8x16_t)vshrq_n_u64((uint64x2_t)v5, 0x13uLL);
        v39 = vshlq_n_s64(v5, 3uLL);
        v40 = v19
            + v241.i64[0]
            + (__ROR8__(v35, 14) ^ __ROR8__(v35, 18) ^ __ROR8__(v35, 41))
            + ((v29 ^ v18) & v35 ^ v18);
        v41 = (int8x16_t)vshrq_n_u64((uint64x2_t)v37, 1uLL);
        v42 = vshlq_n_s64(v37, 0x38uLL);
        v43 = v15 + v40;
        v44 = v40 + (__ROR8__(v36, 28) ^ __ROR8__(v36, 34) ^ __ROR8__(v36, 39)) + ((v30 ^ v14) & v36 ^ v30 & v14);
        v45 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v5, 6uLL), v38), (int8x16_t)v39), (int8x16_t)vshrq_n_u64((uint64x2_t)v38, 0x2AuLL));
        v46 = *v33++;
        v6 = vaddq_s64(vaddq_s64(vaddq_s64(v6, (int64x2_t)vextq_s8((int8x16_t)v10, (int8x16_t)v11, 8uLL)), (int64x2_t)veorq_s8(v45, (int8x16_t)vshlq_n_s64(v39, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v37, 7uLL), v41), (int8x16_t)v42), (int8x16_t)vshrq_n_u64((uint64x2_t)v41, 7uLL)), (int8x16_t)vshlq_n_s64(v42, 7uLL)));
        v47 = v18
            + v241.i64[1]
            + (__ROR8__(v43, 14) ^ __ROR8__(v43, 18) ^ __ROR8__(v43, 41))
            + ((v35 ^ v29) & v43 ^ v29);
        v48 = v14 + v47;
        v49 = v47 + (__ROR8__(v44, 28) ^ __ROR8__(v44, 34) ^ __ROR8__(v44, 39)) + ((v36 ^ v30) & v44 ^ v36 & v30);
        v241 = vaddq_s64(v46, v6);
        v50 = (int64x2_t)vextq_s8((int8x16_t)v7, (int8x16_t)v8, 8uLL);
        v51 = (int8x16_t)vshrq_n_u64((uint64x2_t)v6, 0x13uLL);
        v52 = vshlq_n_s64(v6, 3uLL);
        v53 = v29
            + v242.i64[0]
            + (__ROR8__(v48, 14) ^ __ROR8__(v48, 18) ^ __ROR8__(v48, 41))
            + ((v43 ^ v35) & v48 ^ v35);
        v54 = (int8x16_t)vshrq_n_u64((uint64x2_t)v50, 1uLL);
        v55 = vshlq_n_s64(v50, 0x38uLL);
        v56 = v30 + v53;
        v57 = v53 + (__ROR8__(v49, 28) ^ __ROR8__(v49, 34) ^ __ROR8__(v49, 39)) + ((v44 ^ v36) & v49 ^ v44 & v36);
        v58 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v6, 6uLL), v51), (int8x16_t)v52), (int8x16_t)vshrq_n_u64((uint64x2_t)v51, 0x2AuLL));
        v59 = *v33++;
        v7 = vaddq_s64(vaddq_s64(vaddq_s64(v7, (int64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v12, 8uLL)), (int64x2_t)veorq_s8(v58, (int8x16_t)vshlq_n_s64(v52, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v50, 7uLL), v54), (int8x16_t)v55), (int8x16_t)vshrq_n_u64((uint64x2_t)v54, 7uLL)), (int8x16_t)vshlq_n_s64(v55, 7uLL)));
        v60 = v35
            + v242.i64[1]
            + (__ROR8__(v56, 14) ^ __ROR8__(v56, 18) ^ __ROR8__(v56, 41))
            + ((v48 ^ v43) & v56 ^ v43);
        v61 = v36 + v60;
        v62 = v60 + (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + ((v49 ^ v44) & v57 ^ v49 & v44);
        v242 = vaddq_s64(v59, v7);
        v63 = (int64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v9, 8uLL);
        v64 = (int8x16_t)vshrq_n_u64((uint64x2_t)v7, 0x13uLL);
        v65 = vshlq_n_s64(v7, 3uLL);
        v66 = v43
            + v243.i64[0]
            + (__ROR8__(v61, 14) ^ __ROR8__(v61, 18) ^ __ROR8__(v61, 41))
            + ((v56 ^ v48) & v61 ^ v48);
        v67 = (int8x16_t)vshrq_n_u64((uint64x2_t)v63, 1uLL);
        v68 = vshlq_n_s64(v63, 0x38uLL);
        v69 = v44 + v66;
        v70 = v66 + (__ROR8__(v62, 28) ^ __ROR8__(v62, 34) ^ __ROR8__(v62, 39)) + ((v57 ^ v49) & v62 ^ v57 & v49);
        v71 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v7, 6uLL), v64), (int8x16_t)v65), (int8x16_t)vshrq_n_u64((uint64x2_t)v64, 0x2AuLL));
        v72 = *v33++;
        v8 = vaddq_s64(vaddq_s64(vaddq_s64(v8, (int64x2_t)vextq_s8((int8x16_t)v12, (int8x16_t)v5, 8uLL)), (int64x2_t)veorq_s8(v71, (int8x16_t)vshlq_n_s64(v65, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v63, 7uLL), v67), (int8x16_t)v68), (int8x16_t)vshrq_n_u64((uint64x2_t)v67, 7uLL)), (int8x16_t)vshlq_n_s64(v68, 7uLL)));
        v73 = v48
            + v243.i64[1]
            + (__ROR8__(v69, 14) ^ __ROR8__(v69, 18) ^ __ROR8__(v69, 41))
            + ((v61 ^ v56) & v69 ^ v56);
        v74 = v49 + v73;
        v75 = v73 + (__ROR8__(v70, 28) ^ __ROR8__(v70, 34) ^ __ROR8__(v70, 39)) + ((v62 ^ v57) & v70 ^ v62 & v57);
        v243 = vaddq_s64(v72, v8);
        v76 = (int64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v10, 8uLL);
        v77 = (int8x16_t)vshrq_n_u64((uint64x2_t)v8, 0x13uLL);
        v78 = vshlq_n_s64(v8, 3uLL);
        v79 = v56
            + v244.i64[0]
            + (__ROR8__(v74, 14) ^ __ROR8__(v74, 18) ^ __ROR8__(v74, 41))
            + ((v69 ^ v61) & v74 ^ v61);
        v80 = (int8x16_t)vshrq_n_u64((uint64x2_t)v76, 1uLL);
        v81 = vshlq_n_s64(v76, 0x38uLL);
        v82 = v57 + v79;
        v83 = v79 + (__ROR8__(v75, 28) ^ __ROR8__(v75, 34) ^ __ROR8__(v75, 39)) + ((v70 ^ v62) & v75 ^ v70 & v62);
        v84 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v8, 6uLL), v77), (int8x16_t)v78), (int8x16_t)vshrq_n_u64((uint64x2_t)v77, 0x2AuLL));
        v85 = *v33++;
        v9 = vaddq_s64(vaddq_s64(vaddq_s64(v9, (int64x2_t)vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL)), (int64x2_t)veorq_s8(v84, (int8x16_t)vshlq_n_s64(v78, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v76, 7uLL), v80), (int8x16_t)v81), (int8x16_t)vshrq_n_u64((uint64x2_t)v80, 7uLL)), (int8x16_t)vshlq_n_s64(v81, 7uLL)));
        v86 = v61
            + v244.i64[1]
            + (__ROR8__(v82, 14) ^ __ROR8__(v82, 18) ^ __ROR8__(v82, 41))
            + ((v74 ^ v69) & v82 ^ v69);
        v87 = v62 + v86;
        v88 = v86 + (__ROR8__(v83, 28) ^ __ROR8__(v83, 34) ^ __ROR8__(v83, 39)) + ((v75 ^ v70) & v83 ^ v75 & v70);
        v244 = vaddq_s64(v85, v9);
        v89 = (int64x2_t)vextq_s8((int8x16_t)v10, (int8x16_t)v11, 8uLL);
        v90 = (int8x16_t)vshrq_n_u64((uint64x2_t)v9, 0x13uLL);
        v91 = vshlq_n_s64(v9, 3uLL);
        v92 = v69
            + v245.i64[0]
            + (__ROR8__(v87, 14) ^ __ROR8__(v87, 18) ^ __ROR8__(v87, 41))
            + ((v82 ^ v74) & v87 ^ v74);
        v93 = (int8x16_t)vshrq_n_u64((uint64x2_t)v89, 1uLL);
        v94 = vshlq_n_s64(v89, 0x38uLL);
        v95 = v70 + v92;
        v96 = v92 + (__ROR8__(v88, 28) ^ __ROR8__(v88, 34) ^ __ROR8__(v88, 39)) + ((v83 ^ v75) & v88 ^ v83 & v75);
        v97 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v9, 6uLL), v90), (int8x16_t)v91), (int8x16_t)vshrq_n_u64((uint64x2_t)v90, 0x2AuLL));
        v98 = *v33++;
        v10 = vaddq_s64(vaddq_s64(vaddq_s64(v10, (int64x2_t)vextq_s8((int8x16_t)v6, (int8x16_t)v7, 8uLL)), (int64x2_t)veorq_s8(v97, (int8x16_t)vshlq_n_s64(v91, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v89, 7uLL), v93), (int8x16_t)v94), (int8x16_t)vshrq_n_u64((uint64x2_t)v93, 7uLL)), (int8x16_t)vshlq_n_s64(v94, 7uLL)));
        v99 = v74
            + v245.i64[1]
            + (__ROR8__(v95, 14) ^ __ROR8__(v95, 18) ^ __ROR8__(v95, 41))
            + ((v87 ^ v82) & v95 ^ v82);
        v100 = v75 + v99;
        v101 = v99 + (__ROR8__(v96, 28) ^ __ROR8__(v96, 34) ^ __ROR8__(v96, 39)) + ((v88 ^ v83) & v96 ^ v88 & v83);
        v245 = vaddq_s64(v98, v10);
        v102 = (int64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v12, 8uLL);
        v103 = (int8x16_t)vshrq_n_u64((uint64x2_t)v10, 0x13uLL);
        v104 = vshlq_n_s64(v10, 3uLL);
        v105 = v82
             + v246.i64[0]
             + (__ROR8__(v100, 14) ^ __ROR8__(v100, 18) ^ __ROR8__(v100, 41))
             + ((v95 ^ v87) & v100 ^ v87);
        v106 = (int8x16_t)vshrq_n_u64((uint64x2_t)v102, 1uLL);
        v107 = vshlq_n_s64(v102, 0x38uLL);
        v21 = v83 + v105;
        v17 = v105 + (__ROR8__(v101, 28) ^ __ROR8__(v101, 34) ^ __ROR8__(v101, 39)) + ((v96 ^ v88) & v101 ^ v96 & v88);
        v108 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v10, 6uLL), v103), (int8x16_t)v104), (int8x16_t)vshrq_n_u64((uint64x2_t)v103, 0x2AuLL));
        v109 = *v33++;
        v11 = vaddq_s64(vaddq_s64(vaddq_s64(v11, (int64x2_t)vextq_s8((int8x16_t)v7, (int8x16_t)v8, 8uLL)), (int64x2_t)veorq_s8(v108, (int8x16_t)vshlq_n_s64(v104, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v102, 7uLL), v106), (int8x16_t)v107), (int8x16_t)vshrq_n_u64((uint64x2_t)v106, 7uLL)), (int8x16_t)vshlq_n_s64(v107, 7uLL)));
        v110 = v87
             + v246.i64[1]
             + (__ROR8__(v21, 14) ^ __ROR8__(v21, 18) ^ __ROR8__(v21, 41))
             + ((v100 ^ v95) & v21 ^ v95);
        v20 = v88 + v110;
        v16 = v110 + (__ROR8__(v17, 28) ^ __ROR8__(v17, 34) ^ __ROR8__(v17, 39)) + ((v101 ^ v96) & v17 ^ v101 & v96);
        v246 = vaddq_s64(v109, v11);
        v111 = (int64x2_t)vextq_s8((int8x16_t)v12, (int8x16_t)v5, 8uLL);
        v112 = (int8x16_t)vshrq_n_u64((uint64x2_t)v11, 0x13uLL);
        v113 = vshlq_n_s64(v11, 3uLL);
        v114 = v95
             + v247.i64[0]
             + (__ROR8__(v20, 14) ^ __ROR8__(v20, 18) ^ __ROR8__(v20, 41))
             + ((v21 ^ v100) & v20 ^ v100);
        v115 = (int8x16_t)vshrq_n_u64((uint64x2_t)v111, 1uLL);
        v116 = vshlq_n_s64(v111, 0x38uLL);
        v19 = v96 + v114;
        v15 = v114 + (__ROR8__(v16, 28) ^ __ROR8__(v16, 34) ^ __ROR8__(v16, 39)) + ((v17 ^ v101) & v16 ^ v17 & v101);
        v117 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v11, 6uLL), v112), (int8x16_t)v113), (int8x16_t)vshrq_n_u64((uint64x2_t)v112, 0x2AuLL));
        v118 = *v33;
        i8 = (__int128 *)v33[1].i8;
        v12 = vaddq_s64(vaddq_s64(vaddq_s64(v12, (int64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v9, 8uLL)), (int64x2_t)veorq_s8(v117, (int8x16_t)vshlq_n_s64(v113, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v111, 7uLL), v115), (int8x16_t)v116), (int8x16_t)vshrq_n_u64((uint64x2_t)v115, 7uLL)), (int8x16_t)vshlq_n_s64(v116, 7uLL)));
        v119 = v100
             + v247.i64[1]
             + (__ROR8__(v19, 14) ^ __ROR8__(v19, 18) ^ __ROR8__(v19, 41))
             + ((v20 ^ v21) & v19 ^ v21);
        v18 = v101 + v119;
        v14 = v119 + (__ROR8__(v15, 28) ^ __ROR8__(v15, 34) ^ __ROR8__(v15, 39)) + ((v16 ^ v17) & v15 ^ v16 & v17);
        v247 = vaddq_s64(v118, v12);
        v120 = __OFSUB__(v22--, 1);
      }
      while (!((v22 < 0) ^ v120 | (v22 == 0)));
      v121 = i8 - 40;
      if (!--a2)
        break;
      v123 = *v3;
      v122 = v3 + 1;
      v124 = v21 + v240.i64[0] + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41)) + ((v19 ^ v20) & v18 ^ v20);
      v126 = (int64x2_t)*v121;
      v125 = (int64x2_t *)(v121 + 1);
      v127 = v17 + v124;
      v128 = v124 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
      v5 = (int64x2_t)vrev64q_s8(v123);
      v129 = v20
           + v240.i64[1]
           + (__ROR8__(v127, 14) ^ __ROR8__(v127, 18) ^ __ROR8__(v127, 41))
           + ((v18 ^ v19) & v127 ^ v19);
      v130 = v16 + v129;
      v240 = vaddq_s64(v126, v5);
      v131 = v129 + (__ROR8__(v128, 28) ^ __ROR8__(v128, 34) ^ __ROR8__(v128, 39)) + ((v14 ^ v15) & v128 ^ v14 & v15);
      v132 = *v122++;
      v133 = v19
           + v241.i64[0]
           + (__ROR8__(v130, 14) ^ __ROR8__(v130, 18) ^ __ROR8__(v130, 41))
           + ((v127 ^ v18) & v130 ^ v18);
      v134 = *v125++;
      v135 = v15 + v133;
      v136 = v133 + (__ROR8__(v131, 28) ^ __ROR8__(v131, 34) ^ __ROR8__(v131, 39)) + ((v128 ^ v14) & v131 ^ v128 & v14);
      v6 = (int64x2_t)vrev64q_s8(v132);
      v137 = v18
           + v241.i64[1]
           + (__ROR8__(v135, 14) ^ __ROR8__(v135, 18) ^ __ROR8__(v135, 41))
           + ((v130 ^ v127) & v135 ^ v127);
      v138 = v14 + v137;
      v241 = vaddq_s64(v134, v6);
      v139 = v137
           + (__ROR8__(v136, 28) ^ __ROR8__(v136, 34) ^ __ROR8__(v136, 39))
           + ((v131 ^ v128) & v136 ^ v131 & v128);
      v140 = *v122++;
      v141 = v127
           + v242.i64[0]
           + (__ROR8__(v138, 14) ^ __ROR8__(v138, 18) ^ __ROR8__(v138, 41))
           + ((v135 ^ v130) & v138 ^ v130);
      v142 = *v125++;
      v143 = v128 + v141;
      v144 = v141
           + (__ROR8__(v139, 28) ^ __ROR8__(v139, 34) ^ __ROR8__(v139, 39))
           + ((v136 ^ v131) & v139 ^ v136 & v131);
      v7 = (int64x2_t)vrev64q_s8(v140);
      v145 = v130
           + v242.i64[1]
           + (__ROR8__(v143, 14) ^ __ROR8__(v143, 18) ^ __ROR8__(v143, 41))
           + ((v138 ^ v135) & v143 ^ v135);
      v146 = v131 + v145;
      v242 = vaddq_s64(v142, v7);
      v147 = v145
           + (__ROR8__(v144, 28) ^ __ROR8__(v144, 34) ^ __ROR8__(v144, 39))
           + ((v139 ^ v136) & v144 ^ v139 & v136);
      v148 = *v122++;
      v149 = v135
           + v243.i64[0]
           + (__ROR8__(v146, 14) ^ __ROR8__(v146, 18) ^ __ROR8__(v146, 41))
           + ((v143 ^ v138) & v146 ^ v138);
      v150 = *v125++;
      v151 = v136 + v149;
      v152 = v149
           + (__ROR8__(v147, 28) ^ __ROR8__(v147, 34) ^ __ROR8__(v147, 39))
           + ((v144 ^ v139) & v147 ^ v144 & v139);
      v8 = (int64x2_t)vrev64q_s8(v148);
      v153 = v138
           + v243.i64[1]
           + (__ROR8__(v151, 14) ^ __ROR8__(v151, 18) ^ __ROR8__(v151, 41))
           + ((v146 ^ v143) & v151 ^ v143);
      v154 = v139 + v153;
      v243 = vaddq_s64(v150, v8);
      v155 = v153
           + (__ROR8__(v152, 28) ^ __ROR8__(v152, 34) ^ __ROR8__(v152, 39))
           + ((v147 ^ v144) & v152 ^ v147 & v144);
      v156 = *v122++;
      v157 = v143
           + v244.i64[0]
           + (__ROR8__(v154, 14) ^ __ROR8__(v154, 18) ^ __ROR8__(v154, 41))
           + ((v151 ^ v146) & v154 ^ v146);
      v158 = *v125++;
      v159 = v144 + v157;
      v160 = v157
           + (__ROR8__(v155, 28) ^ __ROR8__(v155, 34) ^ __ROR8__(v155, 39))
           + ((v152 ^ v147) & v155 ^ v152 & v147);
      v9 = (int64x2_t)vrev64q_s8(v156);
      v161 = v146
           + v244.i64[1]
           + (__ROR8__(v159, 14) ^ __ROR8__(v159, 18) ^ __ROR8__(v159, 41))
           + ((v154 ^ v151) & v159 ^ v151);
      v162 = v147 + v161;
      v244 = vaddq_s64(v158, v9);
      v163 = v161
           + (__ROR8__(v160, 28) ^ __ROR8__(v160, 34) ^ __ROR8__(v160, 39))
           + ((v155 ^ v152) & v160 ^ v155 & v152);
      v164 = *v122++;
      v165 = v151
           + v245.i64[0]
           + (__ROR8__(v162, 14) ^ __ROR8__(v162, 18) ^ __ROR8__(v162, 41))
           + ((v159 ^ v154) & v162 ^ v154);
      v166 = *v125++;
      v167 = v152 + v165;
      v168 = v165
           + (__ROR8__(v163, 28) ^ __ROR8__(v163, 34) ^ __ROR8__(v163, 39))
           + ((v160 ^ v155) & v163 ^ v160 & v155);
      v10 = (int64x2_t)vrev64q_s8(v164);
      v169 = v154
           + v245.i64[1]
           + (__ROR8__(v167, 14) ^ __ROR8__(v167, 18) ^ __ROR8__(v167, 41))
           + ((v162 ^ v159) & v167 ^ v159);
      v170 = v155 + v169;
      v245 = vaddq_s64(v166, v10);
      v171 = v169
           + (__ROR8__(v168, 28) ^ __ROR8__(v168, 34) ^ __ROR8__(v168, 39))
           + ((v163 ^ v160) & v168 ^ v163 & v160);
      v172 = *v122++;
      v173 = v159
           + v246.i64[0]
           + (__ROR8__(v170, 14) ^ __ROR8__(v170, 18) ^ __ROR8__(v170, 41))
           + ((v167 ^ v162) & v170 ^ v162);
      v174 = *v125++;
      v175 = v160 + v173;
      v176 = v173
           + (__ROR8__(v171, 28) ^ __ROR8__(v171, 34) ^ __ROR8__(v171, 39))
           + ((v168 ^ v163) & v171 ^ v168 & v163);
      v11 = (int64x2_t)vrev64q_s8(v172);
      v177 = v162
           + v246.i64[1]
           + (__ROR8__(v175, 14) ^ __ROR8__(v175, 18) ^ __ROR8__(v175, 41))
           + ((v170 ^ v167) & v175 ^ v167);
      v178 = v163 + v177;
      v246 = vaddq_s64(v174, v11);
      v179 = v177
           + (__ROR8__(v176, 28) ^ __ROR8__(v176, 34) ^ __ROR8__(v176, 39))
           + ((v171 ^ v168) & v176 ^ v171 & v168);
      v180 = *v122;
      v3 = v122 + 1;
      v181 = v167
           + v247.i64[0]
           + (__ROR8__(v178, 14) ^ __ROR8__(v178, 18) ^ __ROR8__(v178, 41))
           + ((v175 ^ v170) & v178 ^ v170);
      v182 = *v125;
      i8 = (__int128 *)v125[1].i8;
      v183 = v168 + v181;
      v184 = v181
           + (__ROR8__(v179, 28) ^ __ROR8__(v179, 34) ^ __ROR8__(v179, 39))
           + ((v176 ^ v171) & v179 ^ v176 & v171);
      v12 = (int64x2_t)vrev64q_s8(v180);
      v185 = v170
           + v247.i64[1]
           + (__ROR8__(v183, 14) ^ __ROR8__(v183, 18) ^ __ROR8__(v183, 41))
           + ((v178 ^ v175) & v183 ^ v175);
      v247 = vaddq_s64(v182, v12);
      v186 = result[1] + v184;
      *result += v185
               + (__ROR8__(v184, 28) ^ __ROR8__(v184, 34) ^ __ROR8__(v184, 39))
               + ((v179 ^ v176) & v184 ^ v179 & v176);
      result[1] = v186;
      v187 = result[3] + v176;
      result[2] += v179;
      result[3] = v187;
      v188 = result[5] + v183;
      result[4] += v171 + v185;
      result[5] = v188;
      v189 = result[7] + v175;
      result[6] += v178;
      result[7] = v189;
    }
    v190 = v21 + v240.i64[0] + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41)) + ((v19 ^ v20) & v18 ^ v20);
    v191 = v17 + v190;
    v192 = v190 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
    v193 = v20
         + v240.i64[1]
         + (__ROR8__(v191, 14) ^ __ROR8__(v191, 18) ^ __ROR8__(v191, 41))
         + ((v18 ^ v19) & v191 ^ v19);
    v194 = v16 + v193;
    v195 = v193 + (__ROR8__(v192, 28) ^ __ROR8__(v192, 34) ^ __ROR8__(v192, 39)) + ((v14 ^ v15) & v192 ^ v14 & v15);
    v196 = v19
         + v241.i64[0]
         + (__ROR8__(v194, 14) ^ __ROR8__(v194, 18) ^ __ROR8__(v194, 41))
         + ((v191 ^ v18) & v194 ^ v18);
    v197 = v15 + v196;
    v198 = v196 + (__ROR8__(v195, 28) ^ __ROR8__(v195, 34) ^ __ROR8__(v195, 39)) + ((v192 ^ v14) & v195 ^ v192 & v14);
    v199 = v18
         + v241.i64[1]
         + (__ROR8__(v197, 14) ^ __ROR8__(v197, 18) ^ __ROR8__(v197, 41))
         + ((v194 ^ v191) & v197 ^ v191);
    v200 = v14 + v199;
    v201 = v199 + (__ROR8__(v198, 28) ^ __ROR8__(v198, 34) ^ __ROR8__(v198, 39)) + ((v195 ^ v192) & v198 ^ v195 & v192);
    v202 = v191
         + v242.i64[0]
         + (__ROR8__(v200, 14) ^ __ROR8__(v200, 18) ^ __ROR8__(v200, 41))
         + ((v197 ^ v194) & v200 ^ v194);
    v203 = v192 + v202;
    v204 = v202 + (__ROR8__(v201, 28) ^ __ROR8__(v201, 34) ^ __ROR8__(v201, 39)) + ((v198 ^ v195) & v201 ^ v198 & v195);
    v205 = v194
         + v242.i64[1]
         + (__ROR8__(v203, 14) ^ __ROR8__(v203, 18) ^ __ROR8__(v203, 41))
         + ((v200 ^ v197) & v203 ^ v197);
    v206 = v195 + v205;
    v207 = v205 + (__ROR8__(v204, 28) ^ __ROR8__(v204, 34) ^ __ROR8__(v204, 39)) + ((v201 ^ v198) & v204 ^ v201 & v198);
    v208 = v197
         + v243.i64[0]
         + (__ROR8__(v206, 14) ^ __ROR8__(v206, 18) ^ __ROR8__(v206, 41))
         + ((v203 ^ v200) & v206 ^ v200);
    v209 = v198 + v208;
    v210 = v208 + (__ROR8__(v207, 28) ^ __ROR8__(v207, 34) ^ __ROR8__(v207, 39)) + ((v204 ^ v201) & v207 ^ v204 & v201);
    v211 = v200
         + v243.i64[1]
         + (__ROR8__(v209, 14) ^ __ROR8__(v209, 18) ^ __ROR8__(v209, 41))
         + ((v206 ^ v203) & v209 ^ v203);
    v212 = v201 + v211;
    v213 = v211 + (__ROR8__(v210, 28) ^ __ROR8__(v210, 34) ^ __ROR8__(v210, 39)) + ((v207 ^ v204) & v210 ^ v207 & v204);
    v214 = v203
         + v244.i64[0]
         + (__ROR8__(v212, 14) ^ __ROR8__(v212, 18) ^ __ROR8__(v212, 41))
         + ((v209 ^ v206) & v212 ^ v206);
    v215 = v204 + v214;
    v216 = v214 + (__ROR8__(v213, 28) ^ __ROR8__(v213, 34) ^ __ROR8__(v213, 39)) + ((v210 ^ v207) & v213 ^ v210 & v207);
    v217 = v206
         + v244.i64[1]
         + (__ROR8__(v215, 14) ^ __ROR8__(v215, 18) ^ __ROR8__(v215, 41))
         + ((v212 ^ v209) & v215 ^ v209);
    v218 = v207 + v217;
    v219 = v217 + (__ROR8__(v216, 28) ^ __ROR8__(v216, 34) ^ __ROR8__(v216, 39)) + ((v213 ^ v210) & v216 ^ v213 & v210);
    v220 = v209
         + v245.i64[0]
         + (__ROR8__(v218, 14) ^ __ROR8__(v218, 18) ^ __ROR8__(v218, 41))
         + ((v215 ^ v212) & v218 ^ v212);
    v221 = v210 + v220;
    v222 = v220 + (__ROR8__(v219, 28) ^ __ROR8__(v219, 34) ^ __ROR8__(v219, 39)) + ((v216 ^ v213) & v219 ^ v216 & v213);
    v223 = v212
         + v245.i64[1]
         + (__ROR8__(v221, 14) ^ __ROR8__(v221, 18) ^ __ROR8__(v221, 41))
         + ((v218 ^ v215) & v221 ^ v215);
    v224 = v213 + v223;
    v225 = v223 + (__ROR8__(v222, 28) ^ __ROR8__(v222, 34) ^ __ROR8__(v222, 39)) + ((v219 ^ v216) & v222 ^ v219 & v216);
    v226 = v215
         + v246.i64[0]
         + (__ROR8__(v224, 14) ^ __ROR8__(v224, 18) ^ __ROR8__(v224, 41))
         + ((v221 ^ v218) & v224 ^ v218);
    v227 = v216 + v226;
    v228 = v226 + (__ROR8__(v225, 28) ^ __ROR8__(v225, 34) ^ __ROR8__(v225, 39)) + ((v222 ^ v219) & v225 ^ v222 & v219);
    v229 = v218
         + v246.i64[1]
         + (__ROR8__(v227, 14) ^ __ROR8__(v227, 18) ^ __ROR8__(v227, 41))
         + ((v224 ^ v221) & v227 ^ v221);
    v230 = v219 + v229;
    v231 = v229 + (__ROR8__(v228, 28) ^ __ROR8__(v228, 34) ^ __ROR8__(v228, 39)) + ((v225 ^ v222) & v228 ^ v225 & v222);
    v232 = v221
         + v247.i64[0]
         + (__ROR8__(v230, 14) ^ __ROR8__(v230, 18) ^ __ROR8__(v230, 41))
         + ((v227 ^ v224) & v230 ^ v224);
    v233 = v222 + v232;
    v234 = v232 + (__ROR8__(v231, 28) ^ __ROR8__(v231, 34) ^ __ROR8__(v231, 39)) + ((v228 ^ v225) & v231 ^ v228 & v225);
    v235 = v224
         + v247.i64[1]
         + (__ROR8__(v233, 14) ^ __ROR8__(v233, 18) ^ __ROR8__(v233, 41))
         + ((v230 ^ v227) & v233 ^ v227);
    v236 = result[1] + v234;
    *result += v235
             + (__ROR8__(v234, 28) ^ __ROR8__(v234, 34) ^ __ROR8__(v234, 39))
             + ((v231 ^ v228) & v234 ^ v231 & v228);
    result[1] = v236;
    v237 = result[3] + v228;
    result[2] += v231;
    result[3] = v237;
    v238 = result[5] + v233;
    result[4] += v225 + v235;
    result[5] = v238;
    v239 = result[7] + v227;
    result[6] += v230;
    result[7] = v239;
  }
  return result;
}

void *ccsha1_di()
{
  return &ccsha1_vng_arm_di;
}

int64x2_t *AccelerateCrypto_SHA512_compress_hwassist(int64x2_t *result, uint64_t a2, int8x16_t *a3)
{
  int64x2_t v3;
  int64x2_t v4;
  int64x2_t v5;
  int64x2_t v6;
  int64x2_t v26;
  int8x16_t v29;
  int64x2_t v35;
  int8x16_t v38;
  int64x2_t v44;
  int8x16_t v47;
  int64x2_t v53;
  int8x16_t v56;
  int64x2_t v62;
  int8x16_t v65;
  int64x2_t v71;
  int8x16_t v74;
  int64x2_t v80;
  int8x16_t v83;
  int64x2_t v89;
  int8x16_t v92;
  int64x2_t v98;
  int8x16_t v101;
  int64x2_t v107;
  int8x16_t v110;
  int64x2_t v116;
  int8x16_t v119;
  int64x2_t v125;
  int8x16_t v128;
  int64x2_t v134;
  int8x16_t v137;
  int64x2_t v143;
  int8x16_t v146;
  int64x2_t v152;
  int8x16_t v155;
  int64x2_t v161;
  int8x16_t v164;
  int64x2_t v170;
  int8x16_t v173;
  int64x2_t v179;
  int8x16_t v182;
  int64x2_t v188;
  int8x16_t v191;
  int64x2_t v197;
  int8x16_t v200;
  int64x2_t v206;
  int8x16_t v209;
  int64x2_t v215;
  int8x16_t v218;
  int64x2_t v224;
  int8x16_t v227;
  int64x2_t v233;
  int8x16_t v236;
  int64x2_t v242;
  int8x16_t v245;
  int64x2_t v251;
  int8x16_t v254;
  int64x2_t v260;
  int8x16_t v263;
  int64x2_t v269;
  int8x16_t v272;
  int64x2_t v278;
  int8x16_t v281;
  int64x2_t v287;
  int8x16_t v290;
  int64x2_t v296;
  int8x16_t v299;
  int64x2_t v305;
  int8x16_t v308;
  int8x16_t v313;
  int8x16_t v318;
  int8x16_t v323;
  int8x16_t v328;
  int8x16_t v333;
  int8x16_t v338;
  int64x2_t v343;

  if (a2)
  {
    v3 = *result;
    v4 = result[1];
    v5 = result[2];
    v6 = result[3];
    do
    {
      _Q24 = v3;
      _Q25 = v4;
      _Q0 = vrev64q_s8(*a3);
      _Q1 = vrev64q_s8(a3[1]);
      _Q2 = vrev64q_s8(a3[2]);
      _Q3 = vrev64q_s8(a3[3]);
      _Q4 = vrev64q_s8(a3[4]);
      _Q5 = vrev64q_s8(a3[5]);
      _Q6 = vrev64q_s8(a3[6]);
      _Q7 = vrev64q_s8(a3[7]);
      a3 += 8;
      _Q29 = vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL);
      _Q28 = vextq_s8((int8x16_t)v4, (int8x16_t)v5, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      v26 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      v29 = (int8x16_t)vaddq_s64(v4, v26);
      _Q29 = vextq_s8(v29, (int8x16_t)v5, 8uLL);
      _Q28 = vextq_s8((int8x16_t)v3, v29, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      v35 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      v38 = (int8x16_t)vaddq_s64(v3, v35);
      _Q29 = vextq_s8(v38, v29, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v38, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      v44 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      v47 = (int8x16_t)vaddq_s64(_Q27, v44);
      _Q29 = vextq_s8(v47, v38, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v47, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      v53 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      v56 = (int8x16_t)vaddq_s64(_Q26, v53);
      _Q29 = vextq_s8(v56, v47, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v56, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      v62 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      v65 = (int8x16_t)vaddq_s64(_Q25, v62);
      _Q29 = vextq_s8(v65, v56, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v65, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      v71 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      v74 = (int8x16_t)vaddq_s64(_Q24, v71);
      _Q29 = vextq_s8(v74, v65, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v74, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      v80 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      v83 = (int8x16_t)vaddq_s64(_Q27, v80);
      _Q29 = vextq_s8(v83, v74, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v83, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      v89 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      v92 = (int8x16_t)vaddq_s64(_Q26, v89);
      _Q29 = vextq_s8(v92, v83, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v92, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      v98 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      v101 = (int8x16_t)vaddq_s64(_Q25, v98);
      _Q29 = vextq_s8(v101, v92, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v101, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      v107 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      v110 = (int8x16_t)vaddq_s64(_Q24, v107);
      _Q29 = vextq_s8(v110, v101, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v110, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      v116 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      v119 = (int8x16_t)vaddq_s64(_Q27, v116);
      _Q29 = vextq_s8(v119, v110, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v119, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      v125 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      v128 = (int8x16_t)vaddq_s64(_Q26, v125);
      _Q29 = vextq_s8(v128, v119, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v128, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      v134 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      v137 = (int8x16_t)vaddq_s64(_Q25, v134);
      _Q29 = vextq_s8(v137, v128, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v137, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      v143 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      v146 = (int8x16_t)vaddq_s64(_Q24, v143);
      _Q29 = vextq_s8(v146, v137, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v146, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      v152 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      v155 = (int8x16_t)vaddq_s64(_Q27, v152);
      _Q29 = vextq_s8(v155, v146, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v155, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      v161 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      v164 = (int8x16_t)vaddq_s64(_Q26, v161);
      _Q29 = vextq_s8(v164, v155, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v164, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      v170 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      v173 = (int8x16_t)vaddq_s64(_Q25, v170);
      _Q29 = vextq_s8(v173, v164, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v173, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      v179 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      v182 = (int8x16_t)vaddq_s64(_Q24, v179);
      _Q29 = vextq_s8(v182, v173, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v182, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      v188 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      v191 = (int8x16_t)vaddq_s64(_Q27, v188);
      _Q29 = vextq_s8(v191, v182, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v191, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      v197 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      v200 = (int8x16_t)vaddq_s64(_Q26, v197);
      _Q29 = vextq_s8(v200, v191, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v200, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      v206 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      v209 = (int8x16_t)vaddq_s64(_Q25, v206);
      _Q29 = vextq_s8(v209, v200, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v209, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      v215 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      v218 = (int8x16_t)vaddq_s64(_Q24, v215);
      _Q29 = vextq_s8(v218, v209, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v218, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      v224 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      v227 = (int8x16_t)vaddq_s64(_Q27, v224);
      _Q29 = vextq_s8(v227, v218, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v227, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      v233 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      v236 = (int8x16_t)vaddq_s64(_Q26, v233);
      _Q29 = vextq_s8(v236, v227, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v236, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      v242 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      v245 = (int8x16_t)vaddq_s64(_Q25, v242);
      _Q29 = vextq_s8(v245, v236, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v245, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      v251 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      v254 = (int8x16_t)vaddq_s64(_Q24, v251);
      _Q29 = vextq_s8(v254, v245, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v254, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      v260 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      v263 = (int8x16_t)vaddq_s64(_Q27, v260);
      _Q29 = vextq_s8(v263, v254, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v263, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      v269 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      v272 = (int8x16_t)vaddq_s64(_Q26, v269);
      _Q29 = vextq_s8(v272, v263, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v272, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      v278 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      v281 = (int8x16_t)vaddq_s64(_Q25, v278);
      _Q29 = vextq_s8(v281, v272, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v281, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      v287 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      v290 = (int8x16_t)vaddq_s64(_Q24, v287);
      _Q29 = vextq_s8(v290, v281, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v290, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      v296 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      v299 = (int8x16_t)vaddq_s64(_Q27, v296);
      _Q29 = vextq_s8(v299, v290, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v299, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      v305 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      v308 = (int8x16_t)vaddq_s64(_Q26, v305);
      _Q29 = vextq_s8(v308, v299, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v308, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q27, Q25, V24.2D
      }
      v313 = (int8x16_t)vaddq_s64(_Q25, _Q30);
      _Q29 = vextq_s8(v313, v308, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v313, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q26, Q24, V27.2D
      }
      v318 = (int8x16_t)vaddq_s64(_Q24, _Q30);
      _Q29 = vextq_s8(v318, v313, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v318, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q25, Q27, V26.2D
      }
      v323 = (int8x16_t)vaddq_s64(_Q27, _Q30);
      _Q29 = vextq_s8(v323, v318, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v323, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q24, Q26, V25.2D
      }
      v328 = (int8x16_t)vaddq_s64(_Q26, _Q30);
      _Q29 = vextq_s8(v328, v323, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v328, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q27, Q25, V24.2D
      }
      v333 = (int8x16_t)vaddq_s64(_Q25, _Q30);
      _Q29 = vextq_s8(v333, v328, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v333, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q26, Q24, V27.2D
      }
      v338 = (int8x16_t)vaddq_s64(_Q24, _Q30);
      _Q29 = vextq_s8(v338, v333, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v338, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q25, Q27, V26.2D
      }
      v343 = vaddq_s64(_Q27, _Q30);
      _Q29 = vextq_s8((int8x16_t)v343, v338, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, (int8x16_t)v343, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q24, Q26, V25.2D
      }
      v3 = vaddq_s64(v3, _Q24);
      v4 = vaddq_s64(v4, _Q25);
      v5 = vaddq_s64(v5, vaddq_s64(_Q26, _Q30));
      v6 = vaddq_s64(v6, v343);
    }
    while (a2-- > 1);
    *result = v3;
    result[1] = v4;
    result[2] = v5;
    result[3] = v6;
  }
  return result;
}

int32x4_t *AccelerateCrypto_SHA1_compress(int32x4_t *result, uint64_t a2, int8x16_t *a3)
{
  int32x4_t v3;
  int8x16_t *v4;
  int8x16_t v5;
  int8x16_t v6;
  int8x16_t v7;
  int8x16_t v8;
  int32x4_t *v9;
  int32x4_t v10;
  int32x4_t v11;
  int32x4_t *v12;
  BOOL v105;
  uint64_t i;
  int8x16_t v107;
  int8x16_t v108;
  int8x16_t v109;
  int8x16_t v110;

  if (a2)
  {
    v5 = *a3;
    v6 = a3[1];
    v7 = a3[2];
    v8 = a3[3];
    v4 = a3 + 4;
    v10 = *result;
    v9 = result + 1;
    v11 = v10;
    v10.i32[0] = v9->i32[0];
    v12 = v9 - 1;
    v3.i32[0] = v10.i32[0];
    _Q1 = (int32x4_t)vrev32q_s8(v6);
    _Q2 = (int32x4_t)vrev32q_s8(v7);
    _Q3 = (int32x4_t)vrev32q_s8(v8);
    _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v5), *(int32x4_t *)K_XMM_AR);
    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)K_XMM_AR);
    _Q19 = v3;
    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)K_XMM_AR);
    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)K_XMM_AR);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
    _S20 = v11.i32[0];
    __asm
    {
      SHA1C           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }
    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)K_XMM_AR);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }
    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }
    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }
    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }
    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }
    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }
    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }
    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }
    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }
    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }
    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }
    _Q7 = vaddq_s32(_Q3, loc_1A5CB76A0);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }
    _Q4 = vaddq_s32(_Q0, loc_1A5CB76A0);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }
    _Q5 = vaddq_s32(_Q1, loc_1A5CB76A0);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }
    _Q6 = vaddq_s32(_Q2, loc_1A5CB76A0);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }
    _Q7 = vaddq_s32(_Q3, loc_1A5CB76A0);
    v105 = a2 <= 1;
    for (i = a2 - 1; !v105; --i)
    {
      v107 = *v4;
      v108 = v4[1];
      v109 = v4[2];
      v110 = v4[3];
      v4 += 4;
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V4.4S
        SHA1H           S19, S20
      }
      _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v107), *(int32x4_t *)K_XMM_AR);
      _Q1 = (int32x4_t)vrev32q_s8(v108);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
      }
      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)K_XMM_AR);
      _Q2 = (int32x4_t)vrev32q_s8(v109);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V6.4S
        SHA1H           S19, S20
      }
      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)K_XMM_AR);
      _Q3 = (int32x4_t)vrev32q_s8(v110);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
      }
      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)K_XMM_AR);
      _Q19 = vaddq_s32(v3, _Q19);
      v11 = vaddq_s32(v11, _Q18);
      v3 = _Q19;
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
      _S20 = v11.i32[0];
      __asm
      {
        SHA1C           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }
      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)K_XMM_AR);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }
      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }
      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }
      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }
      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }
      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }
      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }
      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }
      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }
      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }
      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }
      _Q7 = vaddq_s32(_Q3, loc_1A5CB76A0);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }
      _Q4 = vaddq_s32(_Q0, loc_1A5CB76A0);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }
      _Q5 = vaddq_s32(_Q1, loc_1A5CB76A0);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }
      _Q6 = vaddq_s32(_Q2, loc_1A5CB76A0);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }
      _Q7 = vaddq_s32(_Q3, loc_1A5CB76A0);
      v105 = i <= 1;
    }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V4.4S
      SHA1H           S19, S20
    }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
    }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V6.4S
      SHA1H           S19, S20
    }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
    }
    *v12 = vaddq_s32(v11, _Q18);
    result = v12 + 1;
    result->i32[0] = vaddq_s32(v3, _Q19).u32[0];
  }
  return result;
}

uint64_t ccsha512_final(uint64_t a1, const void *a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  size_t v10;
  _QWORD *v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  unint64_t v17;
  unsigned int v18;
  unint64_t v19;
  unsigned int v20;
  uint64_t v22;

  v7 = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 16);
  v8 = (uint64_t)a2 + v7 + 8;
  if (v6 <= *(unsigned int *)(v8 + v6))
    *(_DWORD *)(v8 + v6) = 0;
  v9 = v7 + 8 + v6;
  v10 = (v9 + 11) & 0xFFFFFFFFFFFFFFF8;
  v11 = (uint64_t *)((char *)&v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero(v11, v10);
  memmove(v11, a2, v9 + 4);
  v12 = (char *)v11 + v7 + 8;
  v13 = *(unsigned int *)&v12[v6];
  *v11 += (8 * v13);
  *(_DWORD *)&v12[v6] = v13 + 1;
  v12[v13] = 0x80;
  v14 = *(unsigned int *)&v12[v6];
  if (v6 - 16 < v14)
  {
    while (v6 > v14)
    {
      *(_DWORD *)&v12[v6] = v14 + 1;
      v12[v14] = 0;
      v14 = *(unsigned int *)&v12[v6];
    }
    (*(void (**)(_QWORD *, uint64_t))(a1 + 48))(v11 + 1, 1);
    LODWORD(v14) = 0;
    v7 = *(_QWORD *)(a1 + 8);
    v6 = *(_QWORD *)(a1 + 16);
    *(_DWORD *)((char *)v11 + v7 + v6 + 8) = 0;
  }
  v15 = (uint64_t)v11 + v7 + 8;
  v16 = (_DWORD *)(v15 + v6);
  if (v6 - 8 > v14)
  {
    v17 = v14;
    do
    {
      *v16 = v14 + 1;
      *(_BYTE *)(v15 + v17) = 0;
      v17 = *v16;
      LODWORD(v14) = *v16;
    }
    while (v6 - 8 > v17);
  }
  *((_QWORD *)v16 - 1) = bswap64(*v11);
  (*(void (**)(_QWORD *, uint64_t))(a1 + 48))(v11 + 1, 1);
  if (*(_QWORD *)a1 >= 8uLL)
  {
    v18 = 0;
    v19 = 0;
    v20 = 1;
    do
    {
      *(_QWORD *)(a3 + v18) = bswap64(v11[v19 + 1]);
      v19 = v20++;
      v18 += 8;
    }
    while (v19 < *(_QWORD *)a1 >> 3);
  }
  return cc_clear(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16) + 12, v11);
}

uint64_t cc_clear(rsize_t __n, void *__s)
{
  return memset_s(__s, __n, 0, __n);
}

void *ccsha256_di()
{
  return &ccsha256_vng_arm_di;
}

void *ccsha384_di()
{
  if (MEMORY[0xFFFFFC010] < 0)
    return &ccsha384_vng_arm_hw_di;
  else
    return &ccsha384_vng_arm_di;
}

_BYTE *cc_disable_dit(_BYTE *result)
{
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if (*result)
      __asm { MSR             DIT, #0 }
  }
  return result;
}

uint64_t mach_continuous_time(void)
{
  unint64_t StatusReg;
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  if (MEMORY[0xFFFFFC091])
  {
    if (MEMORY[0xFFFFFC090] == 3)
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 4, 15, 10, 6));
    }
    else if (MEMORY[0xFFFFFC090] == 2)
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 6));
    }
    else
    {
      __isb(0xFu);
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    }
    v1 = MEMORY[0xFFFFFC0A8];
  }
  else
  {
    do
    {
      v4 = MEMORY[0xFFFFFC098];
      v3 = mach_absolute_time();
    }
    while (v4 != MEMORY[0xFFFFFC098]);
    StatusReg = v3;
    v1 = v4;
  }
  return v1 + StatusReg;
}

mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  void *v12;
  uint64_t msgh_bits;
  void *v14;
  uint64_t msgh_voucher_port;
  uint64_t msgh_id;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  uint64_t v26;
  _QWORD v27[2];
  mach_msg_size_t v28;
  mach_msg_size_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;

  if (rcv_msg != 0 && (option & 2) != 0)
    v9 = option | 0x100000000;
  else
    v9 = option;
  if ((v9 & 0x100000000) != 0)
  {
    v27[0] = msg;
    v27[1] = rcv_msg;
    v28 = send_size;
    v29 = rcv_size;
    v30 = &v26;
    v31 = 0;
    v32 = 0x8000000000;
  }
  if ((v9 & 1) != 0)
    v10 = notify;
  else
    v10 = 0;
  if ((v9 & 0x4003) == 0x4002)
    msg->msgh_remote_port = notify;
  v11 = v9 | 0x400000000;
  v12 = (void *)timeout;
  msgh_bits = msg->msgh_bits;
  v14 = *(void **)&msg->msgh_remote_port;
  msgh_voucher_port = msg->msgh_voucher_port;
  msgh_id = msg->msgh_id;
  v18 = (v9 & 1) == 0 || (int)msgh_bits >= 0;
  if ((v9 & 0x100000000) != 0)
  {
    if (v18)
      v20 = 0;
    else
      v20 = msg[1].msgh_bits;
    v21 = (void *)(msgh_bits | 0x200000000);
    v22 = (void *)(msgh_voucher_port | (msgh_id << 32));
    v23 = (void *)(v20 | (*(_QWORD *)&rcv_name << 32));
    v24 = (void *)((v10 << 32) | 2);
    msg = (mach_msg_header_t *)v27;
  }
  else
  {
    if (v18)
      v19 = 0;
    else
      v19 = msg[1].msgh_bits;
    v21 = (void *)(msgh_bits | (*(_QWORD *)&send_size << 32));
    v22 = (void *)(msgh_voucher_port | (msgh_id << 32));
    v23 = (void *)(v19 | (*(_QWORD *)&rcv_name << 32));
    v24 = (void *)(rcv_size | (unint64_t)(v10 << 32));
  }
  return mach_msg2_internal(msg, v11, v21, v14, v22, v23, v24, v12);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
  mach_msg_bits_t msgh_bits;
  mach_msg_bits_t v3;
  int v4;
  mach_msg_size_t *p_msgh_size;
  mach_msg_size_t v6;
  mach_msg_size_t v7;
  mach_vm_size_t v8;
  uint64_t v9;
  mach_vm_address_t v10;
  unint64_t v11;
  mach_port_t v13;
  mach_port_name_t v14;
  mach_vm_address_t v15;
  uint64_t reply_port;
  int v17;
  mach_msg_header_t v18;
  uint64_t v19;
  mach_port_name_t v20;
  mach_vm_address_t v21;

  msgh_bits = a1->msgh_bits;
  mach_msg_destroy_port(a1->msgh_remote_port, a1->msgh_bits & 0x1F);
  mach_msg_destroy_port(a1->msgh_voucher_port, HIWORD(msgh_bits) & 0x1F);
  if ((msgh_bits & 0x80000000) != 0)
  {
    v3 = a1[1].msgh_bits;
    if (v3)
    {
      v4 = 0;
      p_msgh_size = &a1[1].msgh_size;
      do
      {
        v6 = p_msgh_size[2];
        switch(HIBYTE(v6))
        {
          case 0u:
            v7 = *p_msgh_size;
            p_msgh_size += 3;
            mach_msg_destroy_port(v7, BYTE2(v6));
            break;
          case 1u:
            if (p_msgh_size[2])
            {
              v8 = p_msgh_size[3];
              if ((_DWORD)v8)
                goto LABEL_17;
            }
            goto LABEL_31;
          case 2u:
            if (p_msgh_size[3])
            {
              v9 = 0;
              v10 = *(_QWORD *)p_msgh_size;
              do
              {
                mach_msg_destroy_port(*(unsigned int *)(v10 + 4 * v9), *((unsigned __int8 *)p_msgh_size + 10));
                v11 = p_msgh_size[3];
                ++v9;
              }
              while (v11 > v9);
              if (p_msgh_size[3] && *((_BYTE *)p_msgh_size + 8) != 0)
              {
                v8 = 4 * v11;
LABEL_17:
                mach_vm_deallocate(mach_task_self_, *(_QWORD *)p_msgh_size, v8);
              }
            }
            goto LABEL_31;
          case 3u:
            goto LABEL_31;
          case 4u:
            if ((v6 & 2) == 0)
            {
              v13 = mach_task_self_;
              v14 = p_msgh_size[3];
              v15 = *(_QWORD *)p_msgh_size;
              if (_kernelrpc_mach_port_unguard_trap(mach_task_self_, v14, *(_QWORD *)p_msgh_size) == 268435459)
              {
                v19 = 0x100000000;
                v20 = v14;
                v21 = v15;
                reply_port = mig_get_reply_port();
                *(_QWORD *)&v18.msgh_bits = 0x2C00001513;
                *(_QWORD *)&v18.msgh_remote_port = __PAIR64__(reply_port, v13);
                *(_QWORD *)&v18.msgh_voucher_port = 0xCA200000000;
                v17 = mach_msg2_internal(&v18, 0x200000003uLL, (void *)0x2C00001513, (void *)__PAIR64__(reply_port, v13), (void *)0xCA200000000, (void *)(reply_port << 32), (void *)0x2C, 0);
                if ((v17 - 268435458) > 0xE || ((1 << (v17 - 2)) & 0x4003) == 0)
                {
                  if (v17)
                  {
                    mig_dealloc_reply_port(v18.msgh_local_port);
                  }
                  else if (v18.msgh_id != 3334
                         || (v18.msgh_bits & 0x80000000) != 0
                         || *(_QWORD *)&v18.msgh_size != 36
                         || v20)
                  {
                    mach_msg_destroy(&v18);
                  }
                }
              }
              v6 = p_msgh_size[2];
            }
            mach_msg_destroy_port(p_msgh_size[3], BYTE2(v6));
LABEL_31:
            p_msgh_size += 4;
            break;
          default:
            break;
        }
        ++v4;
      }
      while (v4 != v3);
    }
  }
}

uint64_t mach_msg_destroy_port(uint64_t name, int a2)
{
  mach_port_name_t v2;
  mach_port_t v3;
  mach_port_t v4;
  uint64_t reply_port;
  int v6;
  mach_port_t v7;
  uint64_t v8;
  int v9;
  mach_msg_header_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  mach_port_name_t v14;

  if ((name - 1) <= 0xFFFFFFFD)
  {
    v2 = name;
    switch(a2)
    {
      case 16:
        name = mach_port_mod_refs(mach_task_self_, name, 1u, -1);
        break;
      case 17:
      case 18:
        v3 = mach_task_self_;
        goto LABEL_31;
      case 20:
        v4 = mach_task_self_;
        if (_kernelrpc_mach_port_insert_right_trap(mach_task_self_, name, name, 0x14u) == 268435459)
        {
          LODWORD(v11) = 1;
          HIDWORD(v11) = v2;
          v12 = 0x14000000000000;
          v13 = 0x100000000;
          v14 = v2;
          reply_port = mig_get_reply_port();
          *(_QWORD *)&v10.msgh_bits = 0x3480001513;
          *(_QWORD *)&v10.msgh_remote_port = __PAIR64__(reply_port, v4);
          *(_QWORD *)&v10.msgh_voucher_port = 0xC8E00000000;
          v6 = mach_msg2_internal(&v10, 0x200000003uLL, (void *)0x3480001513, (void *)__PAIR64__(reply_port, v4), (void *)0xC8E00000000, (void *)((reply_port << 32) | 1), (void *)0x2C, 0);
          if ((v6 - 268435458) > 0xE || ((1 << (v6 - 2)) & 0x4003) == 0)
          {
            if (v6)
            {
              mig_dealloc_reply_port(v10.msgh_local_port);
            }
            else if (v10.msgh_id != 3314
                   || (v10.msgh_bits & 0x80000000) != 0
                   || v10.msgh_size != 36
                   || v10.msgh_remote_port
                   || (_DWORD)v12)
            {
              mach_msg_destroy(&v10);
            }
          }
        }
        v3 = mach_task_self_;
LABEL_31:
        name = mach_port_deallocate(v3, v2);
        break;
      case 21:
        v7 = mach_task_self_;
        v13 = 0;
        v11 = 0x100000000;
        v12 = name | 0x1500000000;
        v8 = mig_get_reply_port();
        *(_QWORD *)&v10.msgh_bits = 0x2800001513;
        *(_QWORD *)&v10.msgh_remote_port = __PAIR64__(v8, v7);
        *(_QWORD *)&v10.msgh_voucher_port = 0xC8F00000000;
        v9 = mach_msg2_internal(&v10, 0x200000003uLL, (void *)0x2800001513, (void *)__PAIR64__(v8, v7), (void *)0xC8F00000000, (void *)(v8 << 32), (void *)0x30, 0);
        if ((v9 - 268435458) > 0xE || ((1 << (v9 - 2)) & 0x4003) == 0)
        {
          if (v9)
          {
            mig_dealloc_reply_port(v10.msgh_local_port);
          }
          else if (v10.msgh_id == 3315
                 && (v10.msgh_bits & 0x80000000) != 0
                 && (_DWORD)v11 == 1
                 && v10.msgh_size == 40
                 && !v10.msgh_remote_port
                 && !HIBYTE(HIDWORD(v12)))
          {
            v2 = HIDWORD(v11);
          }
          else
          {
            mach_msg_destroy(&v10);
          }
        }
        name = mach_port_deallocate(mach_task_self_, v2);
        break;
      default:
        return name;
    }
  }
  return name;
}

void mig_dealloc_reply_port(mach_port_t reply_port)
{
  unint64_t StatusReg;
  mach_port_name_t v2;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v2 = *(_DWORD *)(StatusReg + 16);
  if (v2 && _task_reply_port != v2)
  {
    *(_QWORD *)(StatusReg + 16) = _task_reply_port;
    mach_port_mod_refs(mach_task_self_, v2, 1u, -1);
    if (v2 != reply_port)
      mach_port_deallocate(mach_task_self_, reply_port);
    *(_QWORD *)(StatusReg + 16) = 0;
  }
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  void *v5;
  void *v6;
  int result;

  result = __proc_info((void *)2, *(void **)&pid, *(void **)&flavor, (void *)arg, buffer, *(void **)&buffersize, v5, v6);
  if (result == -1)
    return 0;
  return result;
}

int chmod(const char *a1, mode_t a2)
{
  int result;
  unint64_t StatusReg;
  int *v6;
  int v7;
  int *v9;
  int *v10;

  result = __chmod(a1, a2);
  if (result < 0)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v6 = *(int **)(StatusReg + 8);
    if (!v6)
      v6 = &errno;
    v7 = a2 & 0xC00;
    if (*v6 == 1 && v7 != 0)
    {
      if ((a2 & 0x400) == 0)
        goto LABEL_22;
      result = __chmod(a1, a2 ^ 0x400);
      if (result < 0)
      {
        v9 = *(int **)(StatusReg + 8);
        if (!v9)
          v9 = &errno;
        if (*v9 == 1)
        {
LABEL_22:
          if ((a2 & 0x800) == 0)
            goto LABEL_12;
          result = __chmod(a1, a2 ^ 0x800);
          if (result < 0)
          {
            v10 = *(int **)(StatusReg + 8);
            if (!v10)
              v10 = &errno;
            if (*v10 == 1)
            {
LABEL_12:
              if (v7 == 3072)
                return __chmod(a1, a2 ^ 0xC00);
            }
          }
        }
      }
    }
  }
  return result;
}

int fchmod(int a1, mode_t a2)
{
  int result;
  unint64_t StatusReg;
  int *v6;
  int v7;
  int *v9;
  int *v10;

  result = __fchmod(a1, a2);
  if (result < 0)
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v6 = *(int **)(StatusReg + 8);
    if (!v6)
      v6 = &errno;
    v7 = a2 & 0xC00;
    if (*v6 == 1 && v7 != 0)
    {
      if ((a2 & 0x400) == 0)
        goto LABEL_22;
      result = __fchmod(a1, a2 ^ 0x400);
      if (result < 0)
      {
        v9 = *(int **)(StatusReg + 8);
        if (!v9)
          v9 = &errno;
        if (*v9 == 1)
        {
LABEL_22:
          if ((a2 & 0x800) == 0)
            goto LABEL_12;
          result = __fchmod(a1, a2 ^ 0x800);
          if (result < 0)
          {
            v10 = *(int **)(StatusReg + 8);
            if (!v10)
              v10 = &errno;
            if (*v10 == 1)
            {
LABEL_12:
              if (v7 == 3072)
                return __fchmod(a1, a2 ^ 0xC00);
            }
          }
        }
      }
    }
  }
  return result;
}

int ioctl(int a1, unint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v8;
  va_list va;

  va_start(va, a2);
  v8 = va_arg(va, void *);
  return __ioctl(a1, (void *)a2, v8, v2, v3, v4, v5, v6);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  uint32_t numer;
  uint32_t denom;
  BOOL v4;
  kern_return_t result;

  numer = mach_timebase_info_cached_info.numer;
  denom = mach_timebase_info_cached_info.denom;
  if (mach_timebase_info_cached_info.numer)
    v4 = mach_timebase_info_cached_info.denom == 0;
  else
    v4 = 1;
  if (v4)
  {
    result = mach_timebase_info_trap(&mach_timebase_info_cached_info);
    if (result)
      return result;
    numer = mach_timebase_info_cached_info.numer;
    denom = mach_timebase_info_cached_info.denom;
  }
  result = 0;
  info->numer = numer;
  info->denom = denom;
  return result;
}

int unlink(const char *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  int result;
  unsigned int v9;

  result = __unlink(a1, v1, v2, v3, v4, v5, v6, v7);
  if (!result)
  {
    do
      v9 = __ldaxr((unsigned int *)&__remove_counter);
    while (__stlxr(v9 + 1, (unsigned int *)&__remove_counter));
  }
  return result;
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  int v3;
  unsigned int v4;

  __rename(__from, __to, __ec);
  if (!v3)
  {
    do
      v4 = __ldaxr((unsigned int *)&__remove_counter);
    while (__stlxr(v4 + 1, (unsigned int *)&__remove_counter));
  }
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  int *v4;

  if ((a4 & 4) == 0)
    return __open_dprotected_np(a1, a2, a3, a4);
  v4 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (!v4)
    v4 = &errno;
  *v4 = 22;
  return -1;
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  kern_return_t v4;
  uint64_t reply_port;
  kern_return_t v6;
  mach_msg_header_t v9;
  uint64_t v10;
  mach_port_name_t v11;
  uint64_t v12;

  v4 = _kernelrpc_mach_port_deallocate_trap(task, name);
  if (v4 == 268435459)
  {
    v12 = 0;
    v10 = 0x100000000;
    v11 = name;
    reply_port = mig_get_reply_port();
    *(_QWORD *)&v9.msgh_bits = 0x2400001513;
    *(_QWORD *)&v9.msgh_remote_port = __PAIR64__(reply_port, task);
    *(_QWORD *)&v9.msgh_voucher_port = 0xC8600000000;
    v6 = mach_msg2_internal(&v9, 0x200000003uLL, (void *)0x2400001513, (void *)__PAIR64__(reply_port, task), (void *)0xC8600000000, (void *)(reply_port << 32), (void *)0x2C, 0);
    v4 = v6;
    if ((v6 - 268435458) > 0xE || ((1 << (v6 - 2)) & 0x4003) == 0)
    {
      if (v6)
      {
        mig_dealloc_reply_port(v9.msgh_local_port);
        return v4;
      }
      if (v9.msgh_id == 71)
      {
        v4 = -308;
      }
      else if (v9.msgh_id == 3306)
      {
        v4 = -300;
        if ((v9.msgh_bits & 0x80000000) == 0 && *(_QWORD *)&v9.msgh_size == 36)
        {
          v4 = v11;
          if (!v11)
            return v4;
        }
      }
      else
      {
        v4 = -301;
      }
      mach_msg_destroy(&v9);
    }
  }
  return v4;
}

kern_return_t mach_port_destruct(ipc_space_t task, mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  kern_return_t v8;
  uint64_t reply_port;
  kern_return_t v10;
  mach_msg_header_t v13;
  uint64_t v14;
  mach_port_name_t v15;
  mach_port_delta_t v16;
  mach_port_context_t v17;

  v8 = _kernelrpc_mach_port_destruct_trap(task, name, srdelta, guard);
  if (v8 == 268435459)
  {
    v14 = 0x100000000;
    v15 = name;
    v16 = srdelta;
    v17 = guard;
    reply_port = mig_get_reply_port();
    *(_QWORD *)&v13.msgh_bits = 0x3000001513;
    *(_QWORD *)&v13.msgh_remote_port = __PAIR64__(reply_port, task);
    *(_QWORD *)&v13.msgh_voucher_port = 0xCA000000000;
    v10 = mach_msg2_internal(&v13, 0x200000003uLL, (void *)0x3000001513, (void *)__PAIR64__(reply_port, task), (void *)0xCA000000000, (void *)(reply_port << 32), (void *)0x2C, 0);
    v8 = v10;
    if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
    {
      if (v10)
      {
        mig_dealloc_reply_port(v13.msgh_local_port);
        return v8;
      }
      if (v13.msgh_id == 71)
      {
        v8 = -308;
      }
      else if (v13.msgh_id == 3332)
      {
        v8 = -300;
        if ((v13.msgh_bits & 0x80000000) == 0 && *(_QWORD *)&v13.msgh_size == 36)
        {
          v8 = v15;
          if (!v15)
            return v8;
        }
      }
      else
      {
        v8 = -301;
      }
      mach_msg_destroy(&v13);
    }
  }
  return v8;
}

uint64_t thread_destruct_special_reply_port(mach_port_name_t name, int a2)
{
  mach_port_t v3;
  mach_port_name_t v4;
  mach_port_delta_t v5;

  switch(a2)
  {
    case 2:
      return mach_port_deallocate(mach_task_self_, name);
    case 1:
      v3 = mach_task_self_;
      v4 = name;
      v5 = 0;
      return mach_port_destruct(v3, v4, v5, 0);
    case 0:
      v3 = mach_task_self_;
      v4 = name;
      v5 = -1;
      return mach_port_destruct(v3, v4, v5, 0);
  }
  return 4;
}

kern_return_t mach_vm_map(vm_map_t target_task, mach_vm_address_t *address, mach_vm_size_t size, mach_vm_offset_t mask, int flags, mem_entry_name_port_t object, memory_object_offset_t offset, BOOLean_t copy, vm_prot_t cur_protection, vm_prot_t max_protection, vm_inherit_t inheritance)
{
  vm_map_t v12;
  mach_vm_address_t *v14;
  mach_vm_size_t v15;
  mach_vm_offset_t v16;
  int v17;
  BOOLean_t v18;
  memory_object_offset_t v19;
  kern_return_t v20;
  kern_return_t v21;
  mach_vm_address_t *v22;
  mach_vm_address_t v23;
  uint64_t reply_port;
  kern_return_t v25;
  BOOL v26;
  mach_msg_header_t v29;
  int v30;
  mem_entry_name_port_t v31;
  __int128 v32;
  mach_vm_address_t v33;
  mach_vm_size_t v34;
  mach_vm_offset_t v35;
  int v36;
  memory_object_offset_t v37;
  BOOLean_t v38;
  vm_prot_t v39;
  vm_prot_t v40;
  vm_inherit_t v41;

  v12 = target_task;
  if (object)
    goto LABEL_9;
  if (max_protection != 7 || inheritance != 1)
    goto LABEL_9;
  v14 = address;
  v15 = size;
  v16 = mask;
  v17 = flags;
  v18 = copy;
  v19 = offset;
  v20 = _kernelrpc_mach_vm_map_trap(target_task, address, size, mask, flags, cur_protection);
  size = v15;
  mask = v16;
  flags = v17;
  offset = v19;
  v12 = target_task;
  copy = v18;
  address = v14;
  v21 = v20;
  if (v20 == 268435459)
  {
LABEL_9:
    v30 = 1;
    v31 = object;
    *(_QWORD *)&v32 = 0x13000000000000;
    v22 = address;
    v23 = *address;
    *((_QWORD *)&v32 + 1) = 0x100000000;
    v33 = v23;
    v34 = size;
    v35 = mask;
    v36 = flags;
    v37 = offset;
    v38 = copy;
    v39 = cur_protection;
    v40 = max_protection;
    v41 = inheritance;
    reply_port = mig_get_reply_port();
    *(_QWORD *)&v29.msgh_bits = 0x6480001513;
    *(_QWORD *)&v29.msgh_remote_port = __PAIR64__(reply_port, v12);
    *(_QWORD *)&v29.msgh_voucher_port = 0x12CB00000000;
    v25 = mach_msg2_internal(&v29, 0x200000003uLL, (void *)0x6480001513, (void *)__PAIR64__(reply_port, v12), (void *)0x12CB00000000, (void *)((reply_port << 32) | 1), (void *)0x34, 0);
    v21 = v25;
    if ((v25 - 268435458) > 0xE || ((1 << (v25 - 2)) & 0x4003) == 0)
    {
      if (!v25)
      {
        if (v29.msgh_id == 71)
        {
          v21 = -308;
        }
        else if (v29.msgh_id == 4911)
        {
          if ((v29.msgh_bits & 0x80000000) == 0)
          {
            if (v29.msgh_size == 44)
            {
              if (!v29.msgh_remote_port)
              {
                v21 = v32;
                if (!(_DWORD)v32)
                {
                  *v22 = *(_QWORD *)((char *)&v32 + 4);
                  return v21;
                }
                goto LABEL_27;
              }
            }
            else if (v29.msgh_size == 36)
            {
              if (v29.msgh_remote_port)
                v26 = 1;
              else
                v26 = (_DWORD)v32 == 0;
              if (v26)
                v21 = -300;
              else
                v21 = v32;
              goto LABEL_27;
            }
          }
          v21 = -300;
        }
        else
        {
          v21 = -301;
        }
LABEL_27:
        mach_msg_destroy(&v29);
        return v21;
      }
      mig_dealloc_reply_port(v29.msgh_local_port);
    }
  }
  return v21;
}

kern_return_t semaphore_destroy(task_t task, semaphore_t semaphore)
{
  uint64_t reply_port;
  kern_return_t v4;
  kern_return_t v5;
  mach_msg_header_t v8;
  int v9;
  semaphore_t v10;
  uint64_t v11;
  int v12;

  v11 = 0x11000000000000;
  v9 = 1;
  v10 = semaphore;
  v12 = 0;
  reply_port = mig_get_reply_port();
  *(_QWORD *)&v8.msgh_bits = 0x2880001513;
  *(_QWORD *)&v8.msgh_remote_port = __PAIR64__(reply_port, task);
  *(_QWORD *)&v8.msgh_voucher_port = 0xD5B00000000;
  v4 = mach_msg2_internal(&v8, 0x200000003uLL, (void *)0x2880001513, (void *)__PAIR64__(reply_port, task), (void *)0xD5B00000000, (void *)((reply_port << 32) | 1), (void *)0x2C, 0);
  v5 = v4;
  if ((v4 - 268435458) > 0xE || ((1 << (v4 - 2)) & 0x4003) == 0)
  {
    if (v4)
    {
      mig_dealloc_reply_port(v8.msgh_local_port);
      return v5;
    }
    if (v8.msgh_id == 71)
    {
      v5 = -308;
    }
    else if (v8.msgh_id == 3519)
    {
      v5 = -300;
      if ((v8.msgh_bits & 0x80000000) == 0 && *(_QWORD *)&v8.msgh_size == 36)
      {
        v5 = v11;
        if (!(_DWORD)v11)
          return v5;
      }
    }
    else
    {
      v5 = -301;
    }
    mach_msg_destroy(&v8);
  }
  return v5;
}

void ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1()
{
  __assert_rtn("push_back", "Array.h", 64, "_usedCount < _allocCount");
}

void dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0("growTo", "Array.h", a3, "0");
}

void dyld4::PseudoDylib::create()
{
  __assert_rtn("create", "DyldRuntimeState.cpp", 158, "addr && \"addr cannot be null\"");
}

{
  __assert_rtn("create", "DyldRuntimeState.cpp", 159, "callbacks && \"callbacks cannot be null\"");
}

{
  __assert_rtn("create", "DyldRuntimeState.cpp", 161, "identifier > addr && (identifier - size) < addr && \"identifier is not embedded within image?\"");
}

void dyld4::PseudoDylib::lookupSymbols()
{
  __assert_rtn("lookupSymbols", "DyldRuntimeState.cpp", 197, "names.size() == flags.size() && \"array sizes should match\"");
}

{
  __assert_rtn("lookupSymbols", "DyldRuntimeState.cpp", 196, "names.size() == addrs.size() && \"array sizes should match\"");
}

void dyld4::PseudoDylib::findUnwindSections()
{
  __assert_rtn("findUnwindSections", "DyldRuntimeState.cpp", 213, "found && \"found cannot be null\"");
}

{
  __assert_rtn("findUnwindSections", "DyldRuntimeState.cpp", 214, "info && \"info cannot be null\"");
}

void dyld4::RuntimeState::appLoadAddress()
{
  __assert_rtn("appLoadAddress", "DyldRuntimeState.cpp", 426, "_processPrebuiltLoaderSet != nullptr");
}

{
  __assert_rtn("appLoadAddress", "DyldRuntimeState.cpp", 427, "index < _processPrebuiltLoaderSet->loaderCount()");
}

void dyld4::RuntimeState::setAppLoadAddress()
{
  __assert_rtn("setAppLoadAddress", "DyldRuntimeState.cpp", 433, "_processPrebuiltLoaderSet != nullptr");
}

{
  __assert_rtn("setAppLoadAddress", "DyldRuntimeState.cpp", 434, "index < _processPrebuiltLoaderSet->loaderCount()");
}

void dyld4::RuntimeState::cachedDylibLoadAddress()
{
  __assert_rtn("cachedDylibLoadAddress", "DyldRuntimeState.cpp", 443, "index < this->config.dyldCache.dylibCount");
}

void dyld4::RuntimeState::setDyldLoader()
{
  __assert_rtn("setDyldLoader", "DyldRuntimeState.cpp", 676, "result.kind == Loader::ResolvedSymbol::Kind::bindToImage");
}

void dyld4::RuntimeState::appendInterposingTuples(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_2("push_back", "Array.h", a3, "_usedCount < _allocCount");
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1()
{
  __assert_rtn("back", "Array.h", 58, "_usedCount > 0");
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_1("operator[]", "Array.h", a3, "idx < _usedCount");
}

void ___ZZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEEENK3__0clEv_block_invoke_cold_1()
{
  __assert_rtn("operator()_block_invoke", "DyldRuntimeState.cpp", 1786, "objcImageIndex < loadersWithObjC");
}

void ___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke_168_cold_1()
{
  __assert_rtn("operator()_block_invoke", "DyldRuntimeState.cpp", 2098, "objcImageIndex < infos.count()");
}

void dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_4("setInitialStorage", "Array.h", a3, "_usedCount == 0");
}

void dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_1_0("back", "Array.h", a3, "_usedCount > 0");
}

{
  OUTLINED_FUNCTION_3_0("insert", "Map.h", a3, "tailNode.isDuplicateTail");
}

void dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_2_0("operator[]", "Array.h", a3, "idx < _usedCount");
}

void dyld4::Loader::path()
{
  __assert_rtn("path", "Loader.cpp", 137, "this->magic == kMagic");
}

void dyld4::Loader::mf()
{
  __assert_rtn("mf", "Loader.cpp", 169, "this->magic == kMagic");
}

void dyld4::Loader::loadAddress()
{
  __assert_rtn("loadAddress", "Loader.cpp", 186, "this->magic == kMagic");
}

void dyld4::Loader::contains()
{
  __assert_rtn("contains", "Loader.cpp", 204, "this->magic == kMagic");
}

void dyld4::Loader::matchesPath()
{
  __assert_rtn("matchesPath", "Loader.cpp", 221, "this->magic == kMagic");
}

void dyld4::Loader::fileID()
{
  __assert_rtn("fileID", "Loader.cpp", 238, "this->magic == kMagic");
}

void dyld4::Loader::dependentCount()
{
  __assert_rtn("dependentCount", "Loader.cpp", 250, "this->magic == kMagic");
}

void dyld4::Loader::dependent()
{
  __assert_rtn("dependent", "Loader.cpp", 266, "this->magic == kMagic");
}

void dyld4::Loader::loadDependents()
{
  __assert_rtn("loadDependents", "Loader.cpp", 282, "this->magic == kMagic");
}

void dyld4::Loader::getExportsTrie()
{
  __assert_rtn("getExportsTrie", "Loader.cpp", 298, "this->magic == kMagic");
}

void dyld4::Loader::hiddenFromFlat()
{
  __assert_rtn("hiddenFromFlat", "Loader.cpp", 314, "this->magic == kMagic");
}

void dyld4::Loader::representsCachedDylibIndex()
{
  __assert_rtn("representsCachedDylibIndex", "Loader.cpp", 331, "this->magic == kMagic");
}

void dyld4::Loader::overridesDylibInCache()
{
  __assert_rtn("overridesDylibInCache", "Loader.cpp", 342, "this->magic == kMagic");
}

void dyld4::Loader::applyFixups()
{
  __assert_rtn("applyFixups", "Loader.cpp", 357, "this->magic == kMagic");
}

void dyld4::Loader::withLayout()
{
  __assert_rtn("withLayout", "Loader.cpp", 374, "this->magic == kMagic");
}

void dyld4::Loader::dyldDoesObjCFixups()
{
  __assert_rtn("dyldDoesObjCFixups", "Loader.cpp", 390, "this->magic == kMagic");
}

void dyld4::Loader::getSectionLocations()
{
  __assert_rtn("getSectionLocations", "Loader.cpp", 406, "this->magic == kMagic");
}

void dyld4::Loader::unmap()
{
  __assert_rtn("unmap", "Loader.cpp", 418, "this->magic == kMagic");
}

void dyld4::Loader::hasBeenFixedUp()
{
  __assert_rtn("hasBeenFixedUp", "Loader.cpp", 431, "this->magic == kMagic");
}

void dyld4::Loader::beginInitializers()
{
  __assert_rtn("beginInitializers", "Loader.cpp", 448, "this->magic == kMagic");
}

void dyld4::Loader::runInitializers()
{
  __assert_rtn("runInitializers", "Loader.cpp", 465, "this->magic == kMagic");
}

void dyld4::Loader::isDelayInit()
{
  __assert_rtn("isDelayInit", "Loader.cpp", 482, "this->magic == kMagic");
}

void dyld4::Loader::setDelayInit()
{
  __assert_rtn("setDelayInit", "Loader.cpp", 498, "this->magic == kMagic");
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2_cold_1()
{
  __assert_rtn("forEachBindTarget_block_invoke_2", "Loader.cpp", 2369, "targetIndex == info.targetIndex");
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3_cold_1()
{
  __assert_rtn("forEachBindTarget_block_invoke_3", "Loader.cpp", 2378, "overrideBindTargetIndex == info.targetIndex");
}

void dyld4::Loader::applyCachePatchesToOverride()
{
  __assert_rtn("applyCachePatchesToOverride", "Loader.cpp", 3280, "cachePatch->overrideOffsetOfImpl == DylibPatch::endOfPatchTable");
}

{
  __assert_rtn("applyCachePatchesToOverride", "Loader.cpp", 3196, "(patchVersion == 2) || (patchVersion == 3) || (patchVersion == 4)");
}

void dyld4::Loader::applyCachePatches()
{
  __assert_rtn("applyCachePatches", "Loader.cpp", 3398, "cachePatch->overrideOffsetOfImpl == DylibPatch::endOfPatchTable");
}

void dyld4::dyld_map_with_linking_np()
{
  __assert_rtn("fixupPage", "Loader.cpp", 1920, "segInfo != nullptr");
}

void dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>()
{
  __assert_rtn("operator[]", "Array.h", 56, "idx < _usedCount");
}

void dyld4::JustInTimeLoader::makePatchTable()
{
  __assert_rtn("makePatchTable", "JustInTimeLoader.cpp", 337, "patchTable.hasValue()");
}

void dyld4::JustInTimeLoader::dependentAttrs()
{
  __assert_rtn("dependentAttrs", "JustInTimeLoader.cpp", 580, "!this->allDepsAreNormal");
}

{
  __assert_rtn("dependentAttrs", "JustInTimeLoader.cpp", 579, "depIndex < this->depCount");
}

void dyld4::JustInTimeLoader::dependent()
{
  __assert_rtn("dependent", "JustInTimeLoader.cpp", 589, "depIndex < this->depCount");
}

void dyld4::JustInTimeLoader::unmap()
{
  __assert_rtn("unmap", "JustInTimeLoader.cpp", 892, "force || !this->neverUnload");
}

void dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>()
{
  __assert_rtn("operator[]", "Array.h", 57, "idx < _usedCount");
}

void dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef()
{
  __assert_rtn("BindTargetRef", "PrebuiltLoader.cpp", 99, "(offset() == targetSymbol.targetRuntimeOffset) && \"large offset not support\"");
}

{
  __assert_rtn("BindTargetRef", "PrebuiltLoader.cpp", 189, "unpackAbsoluteValue() == absoluteValue && \"unencodeable absolute symbol value\"");
}

{
  __assert_rtn("BindTargetRef", "PrebuiltLoader.cpp", 202, "(offset() == bindTarget.runtimeOffset) && \"large offset not support\"");
}

void dyld4::PrebuiltLoader::setLoadAddress()
{
  __assert_rtn("setLoadAddress", "PrebuiltLoader.cpp", 907, "this->ref.app && \"shared cache addresses are fixed\"");
}

void dyld4::PrebuiltLoader::dependent()
{
  __assert_rtn("dependent", "PrebuiltLoader.cpp", 513, "depIndex < this->depCount");
}

void dyld4::PrebuiltLoader::recursiveMarkBeingValidated()
{
  __assert_rtn("recursiveMarkBeingValidated", "PrebuiltLoader.cpp", 570, "dep->isPrebuilt");
}

void dyld4::PrebuiltLoader::beginInitializers()
{
  __assert_rtn("beginInitializers", "PrebuiltLoader.cpp", 849, "ldrState == State::fixedUp");
}

void dyld4::PrebuiltLoader::serialize()
{
  __assert_rtn("serialize", "PrebuiltLoader.cpp", 1208, "depAttrs[depIndex].weakLink");
}

{
  __assert_rtn("serialize", "PrebuiltLoader.cpp", 1312, "p->bindTargetRefsOffset == off && \"uint16_t bindTargetRefsOffset overflow\"");
}

{
  __assert_rtn("serialize", "PrebuiltLoader.cpp", 1253, "p->fileValidationOffset == off && \"uint16_t fileValidationOffset overflow\"");
}

void dyld4::BumpAllocator::zeroFill()
{
  __assert_rtn("zeroFill", "PrebuiltLoader.cpp", 2417, "newAllocationAddr != 0");
}

{
  __assert_rtn("zeroFill", "PrebuiltLoader.cpp", 2427, "(uint8_t*)_usageEnd + reqSize <= (uint8_t*)_vmAllocationStart + _vmAllocationSize");
}

void ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_cold_2()
{
  __assert_rtn("serialize_block_invoke", "PrebuiltLoader.cpp", 1263, "p->regionsOffset == off && \"uint16_t regionsOffset overflow\"");
}

void ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51_cold_1()
{
  __assert_rtn("serialize_block_invoke", "PrebuiltLoader.cpp", 1323, "p->bindTargetRefsCount != 0 && \"bindTargetRefsCount overflow\"");
}

void dyld4::SyscallDelegate::getFileAttribute()
{
  __assert_rtn("resize", "Array.h", 77, "count <= _allocCount");
}

void dyld4::FileManager::uuidForFileSystem()
{
  __assert_rtn("operator()", "FileManager.cpp", 161, "i != _fsUUIDMap->end()");
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert()
{
  __assert_rtn("insert", "BTree.h", 147, "size() != capacity()");
}

{
  __assert_rtn("insert", "BTree.h", 148, "index != capacity()");
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion()
{
  __assert_rtn("prepareForInsertion", "BTree.h", 580, "_depth == _btree->_depth && \"prepareForInsertion only works on iterators leaf nodes\"");
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild()
{
  __assert_rtn("splitChild", "BTree.h", 165, "!leaf() && \"Leaf nodes do not have children to split\"");
}

{
  __assert_rtn("splitChild", "BTree.h", 201, "!newChild->full() && !child->full() && \"After split the child nodes should be full\"");
}

{
  __assert_rtn("splitChild", "BTree.h", 167, "children()[index]->full() && \"The child being split must be full\"");
}

{
  __assert_rtn("splitChild", "BTree.h", 166, "size() < capacity() && \"There must be room in this node for an additional child\"");
}

void lsl::Lock::lock()
{
  __assert_rtn("lock", "Allocator.cpp", 106, "_runtimeState != nullptr");
}

void lsl::MemoryManager::vm_allocate_bytes(char *a1, uint64_t a2, uint64_t *a3, __int32 a4)
{
  size_t appended;
  size_t v8;
  size_t v9;
  size_t v10;
  size_t v11;
  size_t v12;
  size_t v13;
  size_t v14;
  size_t v15;
  int8x8_t v16;

  strcpy(a1, "Could not vm_allocate 0x");
  appended = lsl::appendHexToString<unsigned long long>(a1, a2);
  v8 = OUTLINED_FUNCTION_0_1(appended, "\n\tRequested size: 0x");
  v9 = OUTLINED_FUNCTION_1_1(v8, a3[6]);
  v10 = OUTLINED_FUNCTION_0_1(v9, "\n\tRequested allgnment: 0x");
  v11 = OUTLINED_FUNCTION_1_1(v10, a3[5]);
  v12 = OUTLINED_FUNCTION_0_1(v11, "\n\tRequested target size: 0x");
  v13 = OUTLINED_FUNCTION_1_1(v12, a3[8]);
  v14 = OUTLINED_FUNCTION_0_1(v13, "\n\tRequested target allgnment: 0x");
  v15 = OUTLINED_FUNCTION_1_1(v14, a3[7]);
  OUTLINED_FUNCTION_0_1(v15, "\n\tkern return: 0x");
  lsl::appendHexToString<int>(a1, a4, v16);
  qword_1EE805DE8 = (uint64_t)a1;
  __assert_rtn("vm_allocate_bytes", "Allocator.cpp", 348, "0 && \"vm_allocate failed\"");
}

void lsl::Allocator::stackAllocatorInternal()
{
  __assert_rtn("stackAllocatorInternal", "Allocator.cpp", 470, "buffer != nullptr");
}

{
  __assert_rtn("stackAllocatorInternal", "Allocator.cpp", 471, "size != 0");
}

{
  __assert_rtn("stackAllocatorInternal", "Allocator.cpp", 474, "0");
}

void lsl::AllocatorLayout::init()
{
  __assert_rtn("consumeSpace", "Allocator.cpp", 432, "consumedSpace <= size");
}

void lsl::Allocator::aligned_alloc()
{
  __assert_rtn("aligned_alloc", "Allocator.cpp", 577, "result");
}

{
  __assert_rtn("aligned_alloc", "Allocator.cpp", 548, "std::popcount(alignment) == 1");
}

void lsl::Allocator::Pool::aligned_alloc_best_fit()
{
  __assert_rtn("aligned_alloc_best_fit", "Allocator.cpp", 798, "(uint64_t)result != (uint64_t)this");
}

{
  __assert_rtn("markAllocated", "Allocator.cpp", 1060, "!allocated()");
}

void lsl::Allocator::Pool::aligned_alloc()
{
  __assert_rtn("aligned_alloc", "Allocator.cpp", 749, "(uint64_t)result != (uint64_t)this");
}

{
  __assert_rtn("aligned_alloc", "Allocator.cpp", 718, "_lastFreeMetadata->pool() == this");
}

void lsl::Allocator::AllocationMetadata::deallocate()
{
  __assert_rtn("deallocate", "Allocator.cpp", 1052, "allocated()");
}

void lsl::Allocator::Pool::Pool()
{
  __assert_rtn("Pool", "Allocator.cpp", 709, "region.contains(freeRegion)");
}

void lsl::Allocator::AllocationMetadata::reserve()
{
  __assert_rtn("reserve", "Allocator.cpp", 968, "free()");
}

void lsl::Allocator::AllocationMetadata::AllocationMetadata()
{
  __assert_rtn("AllocationMetadata", "Allocator.cpp", 888, "pool");
}

void lsl::Allocator::AllocationMetadata::setPoolHint()
{
  __assert_rtn("setPoolHint", "Allocator.cpp", 930, "pool");
}

void dyld4::APIs::dlopen_from(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_3_1("handleFromLoader", "DyldAPIs.cpp", a3, "(((uintptr_t)ldr) & 1) == 0");
}

void objc::objc_headeropt_rw_t<unsigned long>::isLoaded()
{
  __assert_rtn("get", "OptimizerObjC.h", 830, "i < count");
}

void dyld4::objc_headeropt_rw_t::isLoaded()
{
  __assert_rtn("get", "DyldAPIs.cpp", 2721, "i < count");
}

void dyld4::EqualTypeConformanceLookupKey::equal()
{
  __assert_rtn("equal", "DyldRuntimeState.h", 209, "state != nullptr");
}

void dyld4::EqualMetadataConformanceLookupKey::equal()
{
  __assert_rtn("equal", "DyldRuntimeState.h", 216, "state != nullptr");
}

void dyld4::EqualForeignConformanceLookupKey::equal()
{
  __assert_rtn("equal", "DyldRuntimeState.h", 223, "state != nullptr");
}

void dyld4::APIs::_dyld_pseudodylib_register()
{
  __assert_rtn("_dyld_pseudodylib_register", "DyldAPIs.cpp", 3209, "result == nullptr && \"Existing pseudo-dylib, but result set anyway?\"");
}

void ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke_cold_1()
{
  __assert_rtn("platformAndVersions_block_invoke", "Header.cpp", 312, "err.noError()");
}

void mach_o::Header::loadCommandToDylibKind()
{
  __assert_rtn("loadCommandToDylibKind", "Header.cpp", 1260, "0 && \"not a dylib load command\"");
}

void dyld4::generateClassOrProtocolHashTable()
{
  __assert_rtn("generateClassOrProtocolHashTable", "PrebuiltObjC.cpp", 773, "protocolIndexIt != image.protocolIndexMap.end()");
}

void dyld4::PrebuiltObjC::generatePerImageFixups()
{
  __assert_rtn("generatePerImageFixups", "PrebuiltObjC.cpp", 874, "jl->ref.app");
}

void dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique()
{
  __assert_rtn("forEachSelectorReferenceToUnique", "PrebuiltObjC.cpp", 1094, "!diag.hasError()");
}

void dyld4::PrebuiltObjC::make()
{
  __assert_rtn("getPreoptimizedHeaderROIndex", "OptimizerObjC.h", 884, "headerInfoRO != nullptr");
}

{
  __assert_rtn("getPreoptimizedHeaderROIndex", "OptimizerObjC.h", 885, "headerInfoRW != nullptr");
}

{
  __assert_rtn("getPreoptimizedHeaderROIndex", "OptimizerObjC.h", 895, "hinfoRW->entsize == sizeof(header_info_rw<PointerType>)");
}

{
  __assert_rtn("getPreoptimizedHeaderROIndex", "OptimizerObjC.h", 906, "hinfoRW->entsize == sizeof(header_info_rw<PointerType>)");
}

void dyld4::PrebuiltObjC::serializeFixups()
{
  __assert_rtn("serializeFixups", "PrebuiltObjC.cpp", 1322, "jitLoader.ref.app");
}

{
  __assert_rtn("serializeFixups", "PrebuiltObjC.cpp", 1340, "fixups.protocolISAFixups.count() == fixups.binaryInfo.protocolListCount");
}

void dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert()
{
  __assert_rtn("insert", "Map.h", 864, "tailNode.isDuplicateTail");
}

void objc::objc_headeropt_ro_t<unsigned long long>::get(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_4_0("get", "OptimizerObjC.h", a3, "i < count");
}

void objc::objc_headeropt_ro_t<unsigned long long>::index()
{
  __assert_rtn("index", "OptimizerObjC.h", 792, "hi >= begin && hi < end");
}

void dyld4::Atlas::Mapper::~Mapper()
{
  __assert_rtn("~Mapper", "ProcessAtlas.cpp", 499, "_flatMapping == nullptr");
}

void dyld4::Atlas::Mapper::map()
{
  __assert_rtn("map", "ProcessAtlas.cpp", 527, "((uint64_t)addr + size) <= mapping.address + mapping.size");
}

void dyld4::Atlas::ProcessSnapshot::addSharedCacheImage()
{
  __assert_rtn("addSharedCacheImage", "ProcessAtlas.cpp", 1756, "i != images.end()");
}

void dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo()
{
  __assert_rtn("emitMappedFileInfo", "ProcessAtlas.cpp", 1905, "i != _volumeUUIDs.end()");
}

{
  __assert_rtn("emitMappedFileInfo", "ProcessAtlas.cpp", 1906, "*i == file.volume()");
}

void lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_7("insert", "BTree.h", a3, "size() != capacity()");
}

{
  OUTLINED_FUNCTION_6("insert", "BTree.h", a3, "index != capacity()");
}

void lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_5("prepareForInsertion", "BTree.h", a3, "_depth == _btree->_depth && \"prepareForInsertion only works on iterators leaf nodes\"");
}

void lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_4_1("splitChild", "BTree.h", a3, "!leaf() && \"Leaf nodes do not have children to split\"");
}

{
  OUTLINED_FUNCTION_3_2("splitChild", "BTree.h", a3, "!newChild->full() && !child->full() && \"After split the child nodes should be full\"");
}

{
  OUTLINED_FUNCTION_2_2("splitChild", "BTree.h", a3, "children()[index]->full() && \"The child being split must be full\"");
}

{
  OUTLINED_FUNCTION_1_2("splitChild", "BTree.h", a3, "size() < capacity() && \"There must be room in this node for an additional child\"");
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::erase()
{
  __assert_rtn("erase", "BTree.h", 834, "i.currentNode()->leaf()");
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase()
{
  __assert_rtn("erase", "BTree.h", 158, "size() > index");
}

{
  __assert_rtn("erase", "BTree.h", 157, "leaf()");
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure()
{
  __assert_rtn("rebalanceFromErasure", "BTree.h", 658, "_indexes[0] == 0");
}

{
  __assert_rtn("rebalanceFromErasure", "BTree.h", 617, "_depth == _btree->_depth && \"rebalanceFromErasure only works on iterators to leaf nodes\"");
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge()
{
  __assert_rtn("merge", "BTree.h", 253, "!leaf() && \"A leaf node does not have children to merge\"");
}

{
  __assert_rtn("merge", "BTree.h", 254, "index < size() && \"A node must have a successor node to merge with\"");
}

void DyldSharedCache::forEachPatchableUseOfExportInImage()
{
  __assert_rtn("forEachPatchableUseOfExportInImage", "DyldSharedCache.cpp", 1403, "userDylib != nullptr");
}

{
  __assert_rtn("forEachPatchableUseOfExportInImage", "DyldSharedCache.cpp", 1404, "userDylibImageIndex != ~0U");
}

{
  __assert_rtn("forEachPatchableUseOfExportInImage", "DyldSharedCache.cpp", 1405, "!dataRanges.empty()");
}

void ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2_cold_1()
{
  __assert_rtn("growTo", "Array.h", 184, "0");
}

void objc_visitor::MethodList::numMethods()
{
  __assert_rtn("numMethods", "ObjCVisitor.cpp", 904, "methodList != nullptr");
}

void objc_visitor::MethodList::usesRelativeOffsets()
{
  __assert_rtn("usesRelativeOffsets", "ObjCVisitor.cpp", 945, "methodList != nullptr");
}

void objc_visitor::Method::getNameField()
{
  __assert_rtn("getNameField", "ObjCVisitor.cpp", 1096, "0");
}

{
  __assert_rtn("getNameField", "ObjCVisitor.cpp", 1099, "0");
}

void objc_visitor::Method::getName()
{
  __assert_rtn("getName", "ObjCVisitor.cpp", 1162, "0");
}

void objc_visitor::Method::getNameVMAddr()
{
  __assert_rtn("getNameVMAddr", "ObjCVisitor.cpp", 1240, "0");
}

void objc_visitor::Method::getNameSelRefVMAddr()
{
  __assert_rtn("getNameSelRefVMAddr", "ObjCVisitor.cpp", 1313, "0");
}

{
  __assert_rtn("getNameSelRefVMAddr", "ObjCVisitor.cpp", 1316, "0");
}

void objc_visitor::ProtocolList::numProtocols()
{
  __assert_rtn("numProtocols", "ObjCVisitor.cpp", 1541, "protocolList != nullptr");
}

void objc_visitor::ProtocolList::getProtocolField()
{
  __assert_rtn("getProtocolField", "ObjCVisitor.cpp", 1552, "this->protocolListPos.has_value()");
}

{
  __assert_rtn("getProtocolField", "ObjCVisitor.cpp", 1557, "protocolList != nullptr");
}

{
  __assert_rtn("getProtocolField", "ObjCVisitor.cpp", 1553, "i < this->numProtocols(objcVisitor)");
}

void objc_visitor::Visitor::forEachClass()
{
  __assert_rtn("forEachClass", "ObjCVisitor.cpp", 1797, "(classListSection.sectSize % pointerSize) == 0");
}

void objc_visitor::Visitor::forEachCategory()
{
  __assert_rtn("forEachCategory", "ObjCVisitor.cpp", 1879, "(categoryListSection->sectSize % pointerSize) == 0");
}

void objc_visitor::Visitor::forEachProtocol()
{
  __assert_rtn("forEachProtocol", "ObjCVisitor.cpp", 1905, "(protocolListSection->sectSize % pointerSize) == 0");
}

void objc_visitor::Visitor::forEachSelectorReference()
{
  __assert_rtn("forEachSelectorReference", "ObjCVisitor.cpp", 1930, "(selRefsSection->sectSize % pointerSize) == 0");
}

void metadata_visitor::SwiftVisitor::getSwiftConformances()
{
  __assert_rtn("getSwiftConformances", "SwiftVisitor.cpp", 64, "(protoListSection->sectSize % 4) == 0");
}

void metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName()
{
  __assert_rtn("getClassName", "SwiftVisitor.cpp", 408, "this->kind == SwiftProtocolConformanceFlags::TypeReferenceKind::directObjCClassName");
}

void dyld3::MachOFile::entryAddrFromThreadCmd()
{
  __assert_rtn("entryAddrFromThreadCmd", "MachOFile.cpp", 1543, "cmd->cmd == LC_UNIXTHREAD");
}

void mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget()
{
  __assert_rtn("unpackTarget", "MachOLayout.cpp", 1970, "this->authBind.auth == 0");
}

{
  __assert_rtn("unpackTarget", "MachOLayout.cpp", 1969, "this->authBind.bind == 0");
}

void mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend()
{
  __assert_rtn("signExtendedAddend", "MachOLayout.cpp", 1976, "this->authBind.bind == 1");
}

{
  __assert_rtn("signExtendedAddend", "MachOLayout.cpp", 1977, "this->authBind.auth == 0");
}

void mach_o::ChainedFixupPointerOnDisk::isRebase()
{
  __assert_rtn("isRebase", "MachOLayout.cpp", 2161, "0 && \"unsupported pointer chain format\"");
}

void mach_o::ChainedFixupPointerOnDisk::isBind()
{
  __assert_rtn("isBind", "MachOLayout.cpp", 2212, "0 && \"unsupported pointer chain format\"");
}

void mach_o::ChainedFixupPointerOnDisk::strideSize()
{
  __assert_rtn("strideSize", "MachOLayout.cpp", 2235, "0 && \"unsupported pointer chain format\"");
}

void dyld3::MachOAnalyzer::chainedPointerFormat()
{
  __assert_rtn("chainedPointerFormat", "MachOAnalyzer.cpp", 3257, "this->cputype == CPU_TYPE_ARM64 && (this->maskedCpuSubtype() == CPU_SUBTYPE_ARM64E) && \"chainedPointerFormat() called on non-chained binary\"");
}

void dyld3::MachOAnalyzer::forEachRebase_Opcodes()
{
  __assert_rtn("forEachRebase_Opcodes", "MachOAnalyzer.cpp", 5226, "leInfo.dyldInfo != nullptr");
}

void mach_o::Platform::Platform()
{
  __assert_rtn("Platform", "Platform.cpp", 745, "p->value != 0 && \"PlatformInfo value uninitialized, this might be a problem with C++ static initializers order\"");
}

void _enlarge_cold_1(int a1)
{
  qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Failed to allocate memory for buffer";
  qword_1EE805E00 = a1;
  __break(1u);
}

void _os_unfair_lock_recursive_abort(unsigned int a1)
{
  qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Trying to recursively lock an os_unfair_lock";
  qword_1EE805E00 = a1;
  __break(1u);
}

void _os_unfair_lock_unowned_abort(unsigned int a1)
{
  qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Unlock of an os_unfair_lock not owned by current thread";
  qword_1EE805E00 = a1;
  __break(1u);
}

void _os_unfair_lock_corruption_abort(unsigned int a1)
{
  if (a1 - 512 <= 0x3FE00)
  {
    qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: os_unfair_lock is corrupt, or owner thread exited without unlocking";
    qword_1EE805E00 = a1;
    __break(1u);
  }
  qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: os_unfair_lock is corrupt";
  qword_1EE805E00 = a1;
  __break(1u);
}

void _os_once_gate_recursive_abort(unsigned int a1)
{
  qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Trying to recursively lock an os_once_t";
  qword_1EE805E00 = a1;
  __break(1u);
}

void _os_once_gate_unowned_abort(unsigned int a1)
{
  qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Unlock of an os_once_t not owned by current thread";
  qword_1EE805E00 = a1;
  __break(1u);
}

void _os_once_gate_corruption_abort(unsigned int a1)
{
  qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: os_once_t is corrupt";
  qword_1EE805E00 = a1;
  __break(1u);
}

void os_unfair_lock_assert_owner_cold_1(unsigned int a1)
{
  qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Assertion failed: Lock unexpectedly not owned by current thread";
  qword_1EE805E00 = a1;
  __break(1u);
}

void os_unfair_lock_assert_not_owner_cold_1(unsigned int a1)
{
  qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Assertion failed: Lock unexpectedly owned by current thread";
  qword_1EE805E00 = a1;
  __break(1u);
}

void _os_alloc_cold_1(uint64_t a1)
{
  qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Requested allocation size is invalid";
  qword_1EE805E00 = a1;
  __break(1u);
}

void _os_semaphore_dispose_cold_1(int a1)
{
  qword_1EE805DD0 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Destroying semaphore failed";
  qword_1EE805E00 = a1;
  __break(1u);
}

void abort_with_reason(void *a1, void *a2, void *a3, unint64_t a4)
{
  abort_with_payload_wrapper_internal(a1, a2, 0, 0, a3, a4);
}

void abort_with_payload_wrapper_internal(void *a1, void *a2, void *a3, void *a4, void *a5, unint64_t a6)
{
  void *v12;
  void *v13;
  uint64_t v14;
  sigset_t v15;

  v15 = 32;
  sigprocmask(2, &v15, 0);
  __abort_with_payload(a1, a2, a3, a4, a5, (void *)a6, v12, v13);
  v14 = getpid();
  terminate_with_payload(v14, a1, a2, a3, a4, a5, a6 | 0x200);
  __break(1u);
}

void abort_with_payload(void *a1, void *a2, void *a3, void *a4, void *a5, unint64_t a6)
{
  abort_with_payload_wrapper_internal(a1, a2, a3, a4, a5, a6);
}
