uint64_t SSEIsFeatureSupported(int a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t DeviceFeatures;
  uint64_t v10;
  unsigned int v11;

  v11 = 0;
  v10 = 0;
  init();
  if (_hasSSE)
  {
    v2 = SSEGetVersion(&v11);
    if ((_DWORD)v2)
    {
      v3 = v2;
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        SSEIsFeatureSupported_cold_4();
    }
    else
    {
      v3 = 0;
      switch(a1)
      {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 10:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
          return v3;
        case 7:
        case 11:
        case 15:
        case 26:
        case 27:
        case 28:
          v4 = HIWORD(v11);
          goto LABEL_8;
        case 12:
        case 25:
          v5 = v11 > 1;
          goto LABEL_26;
        case 13:
        case 14:
          v5 = v11 > 2;
          goto LABEL_26;
        case 16:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
          v4 = v11 >> 18;
          goto LABEL_8;
        case 17:
        case 40:
          v6 = v11;
          v7 = 393215;
          goto LABEL_25;
        case 29:
        case 30:
        case 31:
          v4 = v11 >> 17;
          goto LABEL_8;
        case 32:
        case 45:
        case 46:
        case 47:
        case 48:
          v4 = v11 >> 19;
LABEL_8:
          if (v4)
            return 0;
          else
            return 4294967279;
        case 33:
          v6 = v11;
          v7 = 655359;
          goto LABEL_25;
        case 34:
          DeviceFeatures = getDeviceFeatures(&v10);
          if ((_DWORD)DeviceFeatures)
          {
            v3 = DeviceFeatures;
            if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
              SSEIsFeatureSupported_cold_3();
          }
          else if ((v10 & 1) != 0)
          {
            return 0;
          }
          else
          {
            return 4294967279;
          }
          return v3;
        case 41:
        case 42:
          v5 = HIWORD(v11) > 4u;
          goto LABEL_26;
        case 43:
        case 44:
          v6 = v11;
          v7 = 458751;
          goto LABEL_25;
        case 49:
          v6 = v11;
          v7 = 589823;
LABEL_25:
          v5 = v6 > v7;
LABEL_26:
          if (v5)
            v3 = 0;
          else
            v3 = 4294967279;
          break;
        default:
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            SSEIsFeatureSupported_cold_2();
          return 4294967279;
      }
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEIsFeatureSupported_cold_1();
    return 4294967279;
  }
  return v3;
}

uint64_t SSEGetVersion(_DWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  size_t outputStructCnt;
  unsigned int outputStruct;
  uint64_t inputStruct;

  if (SSEGetVersion_protocolVersion)
  {
    v2 = 0;
    goto LABEL_10;
  }
  inputStruct = 0x153534563;
  outputStruct = 0;
  v3 = init();
  if ((_DWORD)v3)
  {
    v2 = v3;
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEGetVersion_cold_4();
  }
  else
  {
    outputStructCnt = 4;
    v4 = IOConnectCallStructMethod(_connect, 0, &inputStruct, 8uLL, &outputStruct, &outputStructCnt);
    if (!(_DWORD)v4)
    {
      if (outputStructCnt == 4)
      {
        v5 = outputStruct;
        if (outputStruct)
        {
          v2 = 0;
          if (outputStruct >= 0xA0000)
            v5 = 655360;
          SSEGetVersion_protocolVersion = v5;
          goto LABEL_10;
        }
        if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
          SSEGetVersion_cold_1();
      }
      else if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      {
        SSEGetVersion_cold_2();
      }
      v2 = 4294967290;
      goto LABEL_10;
    }
    v2 = v4;
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEGetVersion_cold_3();
  }
LABEL_10:
  if (a1)
    *a1 = SSEGetVersion_protocolVersion;
  return v2;
}

uint64_t getDeviceFeatures(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  size_t v7;
  uint64_t outputStruct;
  uint64_t inputStruct;
  unsigned int v10;

  if (a1)
  {
    if ((getDeviceFeatures_featuresValid & 1) != 0)
    {
LABEL_10:
      v5 = 0;
      *a1 = getDeviceFeatures_deviceFeatures;
      return v5;
    }
    v10 = 0;
    v2 = SSEGetVersion(&v10);
    if ((_DWORD)v2)
    {
      v5 = v2;
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        getDeviceFeatures_cold_5();
    }
    else
    {
      if (v10 < 0x30000)
      {
LABEL_9:
        getDeviceFeatures_featuresValid = 1;
        goto LABEL_10;
      }
      outputStruct = 0;
      inputStruct = 0x1E53534563;
      v3 = init();
      if ((_DWORD)v3)
      {
        v5 = v3;
        if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
          getDeviceFeatures_cold_4();
      }
      else
      {
        v7 = 8;
        v4 = IOConnectCallStructMethod(_connect, 0, &inputStruct, 8uLL, &outputStruct, &v7);
        if ((_DWORD)v4)
        {
          v5 = v4;
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            getDeviceFeatures_cold_3();
        }
        else
        {
          if (v7 == 8)
          {
            getDeviceFeatures_deviceFeatures = outputStruct;
            goto LABEL_9;
          }
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            getDeviceFeatures_cold_2();
          return 4294967290;
        }
      }
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      getDeviceFeatures_cold_1();
    return 4294967292;
  }
  return v5;
}

uint64_t init()
{
  uint64_t v0;
  mach_port_t v1;
  const __CFDictionary *v2;
  io_service_t MatchingService;
  io_object_t v4;
  uint64_t v5;
  IONotificationPort *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  size_t v17;
  _QWORD v18[2];
  int v19[2];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if ((_initialized & 1) == 0)
  {
    if (isRestoreMode_onceToken != -1)
      dispatch_once(&isRestoreMode_onceToken, &__block_literal_global_160);
    if ((isRestoreMode_restoreMode & 1) != 0 || _skipSEAvailabilityCheck)
    {
      _hasSSE = 1;
    }
    else
    {
      if (getMGAnswers_onceToken != -1)
        dispatch_once(&getMGAnswers_onceToken, &__block_literal_global_164);
      _hasSSE = getMGAnswers_cachedHasSE;
      if (!getMGAnswers_cachedHasSE)
      {
        _initialized = 1;
        if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
          init_cold_5();
        goto LABEL_13;
      }
    }
    v1 = *MEMORY[0x24BDD8B20];
    v2 = IOServiceMatching("AppleSSE");
    MatchingService = IOServiceGetMatchingService(v1, v2);
    if (!MatchingService)
    {
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        init_cold_1();
      v0 = 4294967276;
      goto LABEL_14;
    }
    v4 = MatchingService;
    v5 = IOServiceOpen(MatchingService, *MEMORY[0x24BDAEC58], 0, (io_connect_t *)&_connect);
    if ((_DWORD)v5)
    {
      v0 = v5;
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        init_cold_4();
      IOObjectRelease(v4);
      goto LABEL_14;
    }
    v6 = IONotificationPortCreate(v1);
    _notifyport = (uint64_t)v6;
    if (v6)
      goto LABEL_24;
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      init_cold_3();
    v6 = (IONotificationPort *)_notifyport;
    if (_notifyport)
    {
LABEL_24:
      v7 = dispatch_get_global_queue(21, 0);
      IONotificationPortSetDispatchQueue(v6, v7);

      if (IOServiceAddInterestNotification((IONotificationPortRef)_notifyport, v4, "IOGeneralInterest", (IOServiceInterestCallback)serviceNotificationHandler, 0, (io_object_t *)&_notifyobj)&& os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      {
        init_cold_2();
      }
    }
    if (getMGAnswers_onceToken != -1)
      dispatch_once(&getMGAnswers_onceToken, &__block_literal_global_164);
    if (getMGAnswers_cachedIsInternal)
    {
      if (isRestoreMode_onceToken != -1)
        dispatch_once(&isRestoreMode_onceToken, &__block_literal_global_160);
      if ((isRestoreMode_restoreMode & 1) == 0)
      {
        _logFile = (uint64_t)fopen("/var/mobile/Library/Logs/AppleSSE.log", "a");
        if (_logFile)
        {
          if (MEMORY[0x22078AA60]() < 1)
            chmod("/var/mobile/Library/Logs/AppleSSE.log", 0x1B6u);
          else
            fputs("\n", (FILE *)_logFile);
          v18[1] = 0;
          *(_QWORD *)v19 = 0x4100000001;
          v17 = 16;
          v18[0] = 0;
          sysctl(v19, 2u, v18, &v17, 0, 0);
          logLine("AppleSSE Log Starts - System Version %s", v8, v9, v10, v11, v12, v13, v14, (char)v18);
          logState(0, 0);
        }
      }
    }
    _initialized = 1;
    v15 = dispatch_get_global_queue(21, 0);
    dispatch_async(v15, &__block_literal_global);

    IOObjectRelease(v4);
    return 0;
  }
  if (_hasSSE)
    return 0;
LABEL_13:
  v0 = 4294967279;
LABEL_14:
  if (_notifyobj)
  {
    IOObjectRelease(_notifyobj);
    _notifyobj = 0;
  }
  if (_notifyport)
  {
    IONotificationPortDestroy((IONotificationPortRef)_notifyport);
    _notifyport = 0;
  }
  if (_connect)
  {
    IOServiceClose(_connect);
    _connect = 0;
  }
  return v0;
}

uint64_t logCmdCall(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a2 || (_DWORD)a3)
  {
    if (_logFile)
    {
      logLine("%s() -> %d", a2, a3, a4, a5, a6, a7, a8, result);
      return logState(a4, a5);
    }
  }
  return result;
}

uint64_t baaPrepare()
{
  if (baaInit_onceToken != -1)
    dispatch_once(&baaInit_onceToken, &__block_literal_global_197);
  if (_baaSupportClass)
    return objc_msgSend((id)_baaSupportClass, "prepare");
  else
    return 4294967290;
}

uint64_t getCertificatesFromBuffer(int *a1, unint64_t a2, _QWORD *a3, _DWORD *a4)
{
  id v8;
  int v9;
  int v10;
  unsigned int *v11;
  _DWORD *v12;
  uint64_t v13;
  unsigned int v14;
  id v15;
  uint64_t v16;

  v8 = (id)objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  if (!a1)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      getCertificatesFromBuffer_cold_1();
    goto LABEL_32;
  }
  if (!a2)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      getCertificatesFromBuffer_cold_2();
    goto LABEL_32;
  }
  if ((unint64_t)a1 > a2)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      getCertificatesFromBuffer_cold_3();
    goto LABEL_32;
  }
  if (!a3)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      getCertificatesFromBuffer_cold_4();
    goto LABEL_32;
  }
  if (!a4)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      getCertificatesFromBuffer_cold_5();
LABEL_32:
    v16 = 4294967292;
    goto LABEL_16;
  }
  if ((unint64_t)a1 < a2)
  {
    if (a2 - (unint64_t)a1 <= 3)
    {
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        getCertificatesFromBuffer_cold_6();
LABEL_21:
      v16 = 4294967290;
      goto LABEL_16;
    }
    v9 = *a1;
    if (*a1)
    {
      v10 = 0;
      v11 = (unsigned int *)(a1 + 1);
      while (a2 - (unint64_t)v11 > 3)
      {
        v14 = *v11;
        v12 = v11 + 1;
        v13 = v14;
        if ((uint64_t)(a2 - (_QWORD)v12) < v14)
        {
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            getCertificatesFromBuffer_cold_8();
          goto LABEL_21;
        }
        v15 = (id)objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytes:length:", v12, v13);
        objc_msgSend(v8, "addObject:", v15);

        v11 = (_DWORD *)((char *)v12 + v13);
        v10 += v13 + 4;
        if (!--v9)
          goto LABEL_15;
      }
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        getCertificatesFromBuffer_cold_7();
      goto LABEL_21;
    }
  }
  v10 = 0;
LABEL_15:
  v16 = 0;
  *a3 = v8;
  *a4 = v10;
LABEL_16:

  return v16;
}

uint64_t SSEGetEntangledAuthorizationRandom(int a1, const __CFData *a2, char a3, CFDataRef *a4, CFDataRef *a5)
{
  UInt8 *v10;
  UInt8 *v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  unint64_t v15;
  const __CFAllocator *v16;
  CFDataRef v17;
  CFDataRef v18;
  CFIndex v19;
  CFDataRef v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v26;
  int v27;
  _BYTE inputStruct[37];
  uint64_t v29;
  CFRange v30;

  v29 = *MEMORY[0x24BDAC8D0];
  v27 = a1;
  memset(inputStruct, 0, sizeof(inputStruct));
  v26 = 0;
  if (!a2)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEGetEntangledAuthorizationRandom_cold_1();
    goto LABEL_23;
  }
  if (!a4)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEGetEntangledAuthorizationRandom_cold_2();
    goto LABEL_23;
  }
  if (!a5)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEGetEntangledAuthorizationRandom_cold_3();
LABEL_23:
    v21 = 4294967292;
    goto LABEL_16;
  }
  v10 = (UInt8 *)malloc_type_calloc(0x108uLL, 1uLL, 0x2AD6A872uLL);
  if (v10)
  {
    v11 = v10;
    v12 = init();
    if ((_DWORD)v12)
    {
      v21 = v12;
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        SSEGetEntangledAuthorizationRandom_cold_13();
      goto LABEL_15;
    }
    strcpy(inputStruct, "cESS\"");
    *(_DWORD *)&inputStruct[8] = a1;
    if ((unint64_t)CFDataGetLength(a2) >= 0x19)
    {
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        SSEGetEntangledAuthorizationRandom_cold_5();
      v21 = 4294967292;
      goto LABEL_15;
    }
    v30.length = CFDataGetLength(a2);
    v30.location = 0;
    CFDataGetBytes(a2, v30, (UInt8 *)((unint64_t)inputStruct | 0xC));
    inputStruct[36] = a3;
    v26 = 264;
    v13 = IOConnectCallStructMethod(_connect, 0, inputStruct, 0x25uLL, v11, &v26);
    if ((_DWORD)v13)
    {
      v21 = v13;
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        SSEGetEntangledAuthorizationRandom_cold_12();
      goto LABEL_15;
    }
    v14 = v26;
    if (v26 <= 7)
    {
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        SSEGetEntangledAuthorizationRandom_cold_6();
    }
    else if (v26 >= 0x109)
    {
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        SSEGetEntangledAuthorizationRandom_cold_7();
    }
    else
    {
      v15 = *(unsigned int *)v11;
      if (v26 - 8 >= v15)
      {
        v16 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
        v17 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], v11 + 8, v15);
        if (!v17)
        {
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            SSEGetEntangledAuthorizationRandom_cold_9();
          v21 = 4294967291;
          goto LABEL_15;
        }
        v18 = v17;
        v19 = *((unsigned int *)v11 + 1);
        if ((uint64_t)(v14 - (*(unsigned int *)v11 + 8)) < v19)
        {
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            SSEGetEntangledAuthorizationRandom_cold_10();
          v21 = 4294967290;
        }
        else
        {
          v20 = CFDataCreate(v16, &v11[*(unsigned int *)v11 + 8], v19);
          if (v20)
          {
            v21 = 0;
            *a4 = v18;
            *a5 = v20;
LABEL_15:
            free(v11);
            goto LABEL_16;
          }
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            SSEGetEntangledAuthorizationRandom_cold_11();
          v21 = 4294967291;
        }
        CFRelease(v18);
        goto LABEL_15;
      }
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        SSEGetEntangledAuthorizationRandom_cold_8();
    }
    v21 = 4294967290;
    goto LABEL_15;
  }
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    SSEGetEntangledAuthorizationRandom_cold_4();
  v21 = 4294967291;
LABEL_16:
  logCmdCall((uint64_t)"SSEGetEntangledAuthorizationRandom", v21, 1, (uint64_t)&v27, (unint64_t)inputStruct | 0xC, v22, v23, v24);
  return v21;
}

uint64_t baaIssueNewCertificate()
{
  if (baaInit_onceToken != -1)
    dispatch_once(&baaInit_onceToken, &__block_literal_global_197);
  if (_baaSupportClass)
    return objc_msgSend((id)_baaSupportClass, "issueNewCertificate");
  else
    return 4294967290;
}

uint64_t SSEGetAttV2AuthKey(const __CFData *a1, const __CFData *a2, CFDataRef *a3)
{
  UInt8 *v6;
  UInt8 *v7;
  uint64_t v8;
  uint64_t v9;
  CFIndex v10;
  CFDataRef v11;
  uint64_t v12;
  size_t outputStructCnt;
  _BYTE inputStruct[20];
  __int128 v16;
  int v17;
  uint64_t v18;
  CFRange v19;
  CFRange v20;

  v18 = *MEMORY[0x24BDAC8D0];
  v17 = 0;
  v16 = 0u;
  *(_OWORD *)&inputStruct[4] = 0u;
  outputStructCnt = 0;
  if (!a1)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEGetAttV2AuthKey_cold_1();
    return 4294967292;
  }
  if (!a2)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEGetAttV2AuthKey_cold_2();
    return 4294967292;
  }
  if (!a3)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEGetAttV2AuthKey_cold_3();
    return 4294967292;
  }
  v6 = (UInt8 *)malloc_type_calloc(0x4000uLL, 1uLL, 0x7290607BuLL);
  if (v6)
  {
    v7 = v6;
    v8 = init();
    if ((_DWORD)v8)
    {
      v12 = v8;
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        SSEGetAttV2AuthKey_cold_11();
      goto LABEL_13;
    }
    strcpy(inputStruct, "cESS#");
    if ((unint64_t)CFDataGetLength(a1) >= 0x19)
    {
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        SSEGetAttV2AuthKey_cold_5();
    }
    else
    {
      v19.length = CFDataGetLength(a1);
      v19.location = 0;
      CFDataGetBytes(a1, v19, &inputStruct[8]);
      if ((unint64_t)CFDataGetLength(a2) < 9)
      {
        v20.length = CFDataGetLength(a2);
        v20.location = 0;
        CFDataGetBytes(a2, v20, (UInt8 *)&v16 + 12);
        outputStructCnt = 0x4000;
        v9 = IOConnectCallStructMethod(_connect, 0, inputStruct, 0x28uLL, v7, &outputStructCnt);
        if ((_DWORD)v9)
        {
          v12 = v9;
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            SSEGetAttV2AuthKey_cold_10();
          goto LABEL_13;
        }
        if (outputStructCnt <= 3)
        {
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            SSEGetAttV2AuthKey_cold_7();
        }
        else
        {
          v10 = *(unsigned int *)v7;
          if (outputStructCnt - 4 == v10)
          {
            v11 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], v7 + 4, v10);
            if (v11)
            {
              v12 = 0;
              *a3 = v11;
            }
            else
            {
              if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
                SSEGetAttV2AuthKey_cold_8();
              v12 = 4294967291;
            }
            goto LABEL_13;
          }
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            SSEGetAttV2AuthKey_cold_9();
        }
        v12 = 4294967290;
LABEL_13:
        free(v7);
        return v12;
      }
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        SSEGetAttV2AuthKey_cold_6();
    }
    v12 = 4294967292;
    goto LABEL_13;
  }
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    SSEGetAttV2AuthKey_cold_4();
  return 4294967291;
}

uint64_t SSESetSEPubKey(const __CFData *a1, const __CFData *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  unint64_t Length;
  id v8;
  unint64_t v9;
  unsigned int v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  UInt8 buffer[8];
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  CFRange v20;

  v19 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)buffer = 0;
  v16 = 0;
  v18 = 0;
  v17 = 0;
  if (!a1)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSESetSEPubKey_cold_1();
    return 4294967292;
  }
  if (!a2)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSESetSEPubKey_cold_2();
    return 4294967292;
  }
  v4 = (char *)malloc_type_calloc(0x4000uLL, 1uLL, 0xB0967022uLL);
  if (v4)
  {
    v5 = v4;
    v6 = init();
    if ((_DWORD)v6)
    {
      v13 = v6;
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        SSESetSEPubKey_cold_8();
    }
    else
    {
      Length = CFDataGetLength(a1);
      if (Length >= 0x19)
      {
        if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
          SSESetSEPubKey_cold_4();
      }
      else
      {
        v20.length = Length;
        v20.location = 0;
        CFDataGetBytes(a1, v20, buffer);
        if (CFDataGetLength(a2) >= 0x100000000)
        {
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            SSESetSEPubKey_cold_5();
        }
        else
        {
          v18 = CFDataGetLength(a2);
          v8 = (id)objc_msgSend(MEMORY[0x24BDBCEC8], "dataWithBytes:length:", buffer, 28);
          objc_msgSend(v8, "appendData:", a2);
          if (!((unint64_t)objc_msgSend(v8, "length") >> 32))
          {
            LODWORD(v9) = 0;
            while (1)
            {
              strcpy(v5, "cESS%");
              v10 = (objc_msgSend(v8, "length") - (unint64_t)v9) >> 2 > 0xFFA
                  ? 16364
                  : objc_msgSend(v8, "length") - v9;
              *((_DWORD *)v5 + 2) = objc_msgSend(v8, "length");
              *((_DWORD *)v5 + 3) = v9;
              *((_DWORD *)v5 + 4) = v10;
              v11 = objc_retainAutorelease(v8);
              objc_msgSend(v11, "bytes");
              __memcpy_chk();
              v12 = IOConnectCallStructMethod(_connect, 0, v5, v10 + 20, 0, 0);
              if ((_DWORD)v12)
                break;
              v9 = v9 + v10;
              if (objc_msgSend(v11, "length") <= v9)
              {

                v13 = 0;
                goto LABEL_15;
              }
            }
            v13 = v12;
            if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
              SSESetSEPubKey_cold_7();

            goto LABEL_15;
          }
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            SSESetSEPubKey_cold_6();

        }
      }
      v13 = 4294967292;
    }
LABEL_15:
    free(v5);
    return v13;
  }
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    SSESetSEPubKey_cold_3();
  return 4294967291;
}

uint64_t SSEPerformAuthKeySharing(const __CFData *a1, const __CFData *a2, const __CFData *a3, CFDataRef *a4, CFDataRef *a5)
{
  UInt8 *v10;
  UInt8 *v11;
  UInt8 *v12;
  UInt8 *v13;
  uint64_t v14;
  unint64_t Length;
  unint64_t v16;
  UInt8 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  size_t v21;
  unint64_t v22;
  const __CFAllocator *v23;
  CFDataRef v24;
  CFDataRef v25;
  CFIndex v26;
  CFDataRef v27;
  uint64_t v28;
  size_t outputStructCnt;
  CFRange v31;
  CFRange v32;
  CFRange v33;

  outputStructCnt = 0;
  if (!a1)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_1();
    return 4294967292;
  }
  if (!a2)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_2();
    return 4294967292;
  }
  if (!a3)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_3();
    return 4294967292;
  }
  if (!a4)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_4();
    return 4294967292;
  }
  if (!a5)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_5();
    return 4294967292;
  }
  v10 = (UInt8 *)malloc_type_calloc(0x4000uLL, 1uLL, 0xD2063E45uLL);
  if (!v10)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_6();
    return 4294967291;
  }
  v11 = v10;
  v12 = (UInt8 *)malloc_type_calloc(0x4000uLL, 1uLL, 0x43BFE140uLL);
  if (!v12)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_7();
    free(v11);
    return 4294967291;
  }
  v13 = v12;
  v14 = init();
  if ((_DWORD)v14)
  {
    v28 = v14;
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_18();
    goto LABEL_20;
  }
  strcpy((char *)v11, "cESS$");
  if ((unint64_t)CFDataGetLength(a1) >= 0x19)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_8();
    goto LABEL_47;
  }
  v31.length = CFDataGetLength(a1);
  v31.location = 0;
  CFDataGetBytes(a1, v31, v11 + 8);
  Length = CFDataGetLength(a2);
  if (Length >= 0x3FD9)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_9();
    goto LABEL_47;
  }
  v16 = Length;
  *((_DWORD *)v11 + 8) = Length;
  v32.location = 0;
  v32.length = Length;
  CFDataGetBytes(a2, v32, v11 + 40);
  v17 = &v11[v16 + 40];
  v18 = CFDataGetLength(a3);
  if (v11 - v17 + 0x4000 < v18)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_10();
LABEL_47:
    v28 = 4294967292;
    goto LABEL_20;
  }
  v19 = v18;
  *((_DWORD *)v11 + 9) = v18;
  v33.location = 0;
  v33.length = v18;
  CFDataGetBytes(a3, v33, v17);
  outputStructCnt = 0x4000;
  v20 = IOConnectCallStructMethod(_connect, 0, v11, &v17[v19] - v11, v13, &outputStructCnt);
  if ((_DWORD)v20)
  {
    v28 = v20;
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_17();
    goto LABEL_20;
  }
  v21 = outputStructCnt;
  if (outputStructCnt <= 7)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_11();
    goto LABEL_56;
  }
  if (outputStructCnt > 0x4000)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_12();
    goto LABEL_56;
  }
  v22 = *(unsigned int *)v13;
  if (outputStructCnt - 8 < v22)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_13();
LABEL_56:
    v28 = 4294967290;
    goto LABEL_20;
  }
  v23 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v24 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], v13 + 8, v22);
  if (!v24)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_14();
    v28 = 4294967291;
    goto LABEL_20;
  }
  v25 = v24;
  v26 = *((unsigned int *)v13 + 1);
  if ((uint64_t)(v21 - (*(unsigned int *)v13 + 8)) < v26)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_15();
    v28 = 4294967290;
    goto LABEL_66;
  }
  v27 = CFDataCreate(v23, &v13[*(unsigned int *)v13 + 8], v26);
  if (!v27)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      SSEPerformAuthKeySharing_cold_16();
    v28 = 4294967291;
LABEL_66:
    CFRelease(v25);
    goto LABEL_20;
  }
  v28 = 0;
  *a4 = v25;
  *a5 = v27;
LABEL_20:
  free(v11);
  free(v13);
  return v28;
}

void serviceNotificationHandler(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  NSObject *v5;
  NSObject *v6;
  _QWORD *v7;
  NSObject *v8;
  _QWORD v9[5];
  _QWORD v10[5];

  if (a3 == -469794813)
  {
    v5 = (id)_authKeyRevocationNtfQueue;
    v6 = v5;
    if (!v5)
      v6 = dispatch_get_global_queue(21, 0);
    v9[0] = MEMORY[0x24BDAC760];
    v9[1] = 3221225472;
    v9[2] = __serviceNotificationHandler_block_invoke_3;
    v9[3] = &__block_descriptor_40_e5_v8__0l;
    v9[4] = a4;
    v7 = v9;
    goto LABEL_10;
  }
  if (a3 == -469794814)
  {
    if (!_doNotIssueNewBAACertificate)
    {
      v8 = dispatch_get_global_queue(21, 0);
      dispatch_async(v8, &__block_literal_global_171);

    }
    goto LABEL_14;
  }
  if (a3 != -469794815)
  {
LABEL_14:
    v5 = 0;
    goto LABEL_15;
  }
  v5 = (id)_effacemenNtfQueue;
  v6 = v5;
  if (!v5)
    v6 = dispatch_get_global_queue(21, 0);
  v10[0] = MEMORY[0x24BDAC760];
  v10[1] = 3221225472;
  v10[2] = __serviceNotificationHandler_block_invoke;
  v10[3] = &__block_descriptor_40_e5_v8__0l;
  v10[4] = a4;
  v7 = v10;
LABEL_10:
  dispatch_async(v6, v7);
  if (!v5)

LABEL_15:
}

const char *__isRestoreMode_block_invoke()
{
  const char *result;
  char *__lasts;
  size_t v2;
  char __str[1024];
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  v2 = 1024;
  result = (const char *)sysctlbyname("kern.bootargs", __str, &v2, 0, 0);
  if (!(_DWORD)result)
  {
    __lasts = 0;
    result = strtok_r(__str, " \t", &__lasts);
    if (result)
    {
      while (1)
      {
        result = (const char *)strcmp(result, "rd=md0");
        if (!(_DWORD)result)
          break;
        result = strtok_r(0, " \t", &__lasts);
        if (!result)
          return result;
      }
      isRestoreMode_restoreMode = 1;
    }
  }
  return result;
}

void *__getMGAnswers_block_invoke()
{
  void *result;
  void *v1;
  uint64_t (*v2)(const __CFString *);
  uint64_t (*v3)(const __CFString *);

  result = dlopen("/usr/lib/libMobileGestalt.dylib", 1);
  if (result)
  {
    v1 = result;
    v2 = (uint64_t (*)(const __CFString *))dlsym(result, "MGGetBoolAnswer");
    if (v2)
    {
      v3 = v2;
      getMGAnswers_cachedHasSE = v2(CFSTR("0dnM19zBqLw5ZPhIo4GEkg"));
      getMGAnswers_cachedIsInternal = v3(CFSTR("InternalBuild"));
    }
    return (void *)dlclose(v1);
  }
  return result;
}

uint64_t __serviceNotificationHandler_block_invoke()
{
  uint64_t result;

  result = _effacemenNtfHandler;
  if (_effacemenNtfHandler)
    return (*(uint64_t (**)(void))(_effacemenNtfHandler + 16))();
  return result;
}

uint64_t __serviceNotificationHandler_block_invoke_3()
{
  uint64_t result;

  result = _authKeyRevocationNtfHandler;
  if (_authKeyRevocationNtfHandler)
    return (*(uint64_t (**)(void))(_authKeyRevocationNtfHandler + 16))();
  return result;
}

const char *logLine(const char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const char *v9;
  tm *v10;
  FILE *v11;
  const char *v12;
  time_t v13;
  char v14[16];
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (_logFile)
  {
    v9 = result;
    *(_OWORD *)v14 = 0u;
    v15 = 0u;
    v13 = time(0);
    v10 = localtime(&v13);
    strftime(v14, 0x20uLL, "%F %T (%z)", v10);
    v11 = (FILE *)_logFile;
    v12 = getprogname();
    fprintf(v11, "%s [%s]: ", v14, v12);
    vfprintf((FILE *)_logFile, v9, &a9);
    fputs("\n", (FILE *)_logFile);
    return (const char *)fflush((FILE *)_logFile);
  }
  return result;
}

uint64_t logState(uint64_t result, uint64_t a2)
{
  _DWORD *v3;
  uint64_t i;
  size_t outputStructCnt;
  __int128 outputStruct;
  __int128 v7;
  __int128 v8;
  uint64_t inputStruct;

  if (_logFile)
  {
    v3 = (_DWORD *)result;
    inputStruct = 0x953534563;
    v7 = 0u;
    v8 = 0u;
    outputStruct = 0u;
    outputStructCnt = 48;
    result = IOConnectCallStructMethod(_connect, 0, &inputStruct, 8uLL, &outputStruct, &outputStructCnt);
    if (!(_DWORD)result)
    {
      if (v3)
        fprintf((FILE *)_logFile, "\tuserID        = %u\n", *v3);
      if (a2)
      {
        fwrite("\tseid          = ", 0x11uLL, 1uLL, (FILE *)_logFile);
        for (i = 0; i != 24; ++i)
          fprintf((FILE *)_logFile, "%02x", *(unsigned __int8 *)(a2 + i));
        fputs("\n", (FILE *)_logFile);
      }
      fprintf((FILE *)_logFile, "\tsseKey hash   = %016llx\n", (_QWORD)outputStruct);
      fprintf((FILE *)_logFile, "\tauthRand hash = %016llx\n", *((_QWORD *)&outputStruct + 1));
      fprintf((FILE *)_logFile, "\tsubcounter    = %llu\n", (_QWORD)v7);
      fprintf((FILE *)_logFile, "\tentropy hash  = %016llx\n", *((_QWORD *)&v7 + 1));
      fprintf((FILE *)_logFile, "\tkeybag hash   = %016llx\n", (_QWORD)v8);
      fprintf((FILE *)_logFile, "\tnoPasscodeCnt = %u\n", DWORD2(v8));
      return fflush((FILE *)_logFile);
    }
  }
  return result;
}

void __baaInit_block_invoke()
{
  Class Class;

  if (isRestoreMode_onceToken != -1)
    dispatch_once(&isRestoreMode_onceToken, &__block_literal_global_160);
  if ((isRestoreMode_restoreMode & 1) == 0)
  {
    init();
    if (_hasSSE)
    {
      if (isEntitledForBAA_onceToken != -1)
        dispatch_once(&isEntitledForBAA_onceToken, &__block_literal_global_203);
      if (isEntitledForBAA_entitled == 1)
      {
        if (dlopen("/usr/lib/libAppleSSEExt.dylib", 1))
        {
          Class = objc_getClass("BAASupport");
          _baaSupportClass = (uint64_t)Class;
          if (!Class)
          {
            if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
              __baaInit_block_invoke_cold_2();
            Class = (Class)_baaSupportClass;
          }
          -[objc_class setDelegate:](Class, "setDelegate:", objc_opt_class());
        }
        else if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        {
          __baaInit_block_invoke_cold_1();
        }
      }
    }
  }
}

void __isEntitledForBAA_block_invoke()
{
  id v0;
  id v1;
  int v2;
  void *v3;
  void *v4;
  uint64_t (*v5)(_QWORD);
  uint64_t v6;
  const void *v7;
  uint64_t (*v8)(const void *, const __CFString *, _QWORD);
  uint64_t (*v9)(const void *, const __CFString *, _QWORD);
  void *v10;
  void *v11;
  _DWORD v12[2];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v0 = (id)objc_msgSend(MEMORY[0x24BDD1760], "processInfo");
  v1 = (id)objc_msgSend(v0, "processName");
  v2 = objc_msgSend(v1, "isEqualToString:", CFSTR("nfcd"));

  if (v2)
  {
    isEntitledForBAA_entitled = 1;
  }
  else
  {
    v3 = dlopen("/System/Library/Frameworks/Security.framework/Security", 1);
    if (v3)
    {
      v4 = v3;
      v5 = (uint64_t (*)(_QWORD))dlsym(v3, "SecTaskCreateFromSelf");
      if (v5)
      {
        v6 = v5(*MEMORY[0x24BDBD240]);
        if (v6)
        {
          v7 = (const void *)v6;
          v8 = (uint64_t (*)(const void *, const __CFString *, _QWORD))dlsym(v4, "SecTaskCopyValueForEntitlement");
          if (v8)
          {
            v9 = v8;
            v10 = (void *)v8(v7, CFSTR("com.apple.private.applesse.allow"), 0);
            v11 = (void *)v9(v7, CFSTR("com.apple.private.applesse.baa"), 0);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              if (objc_msgSend(v10, "BOOLValue"))
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  if (objc_msgSend(v11, "BOOLValue"))
                    isEntitledForBAA_entitled = 1;
                }
              }
            }

          }
          CFRelease(v7);
        }
      }
      dlclose(v4);
    }
  }
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
  {
    v12[0] = 67109120;
    v12[1] = isEntitledForBAA_entitled;
    _os_log_impl(&dword_21CC7F000, MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT, "isEntitledForBAA(): entitled = %u", (uint8_t *)v12, 8u);
  }
}

void OUTLINED_FUNCTION_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x30u);
}

void SSEIsFeatureSupported_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEIsFeatureSupported_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEIsFeatureSupported_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEIsFeatureSupported_cold_4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetVersion_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetVersion_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetVersion_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetVersion_cold_4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getDeviceFeatures_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getDeviceFeatures_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getDeviceFeatures_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getDeviceFeatures_cold_4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getDeviceFeatures_cold_5()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void init_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void init_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void init_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void init_cold_4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void init_cold_5()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getCertificatesFromBuffer_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getCertificatesFromBuffer_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getCertificatesFromBuffer_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getCertificatesFromBuffer_cold_4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getCertificatesFromBuffer_cold_5()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getCertificatesFromBuffer_cold_6()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getCertificatesFromBuffer_cold_7()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void getCertificatesFromBuffer_cold_8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_5()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_6()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_7()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_9()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_10()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_11()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_12()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetEntangledAuthorizationRandom_cold_13()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetAttV2AuthKey_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetAttV2AuthKey_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetAttV2AuthKey_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetAttV2AuthKey_cold_4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetAttV2AuthKey_cold_5()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetAttV2AuthKey_cold_6()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetAttV2AuthKey_cold_7()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetAttV2AuthKey_cold_8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetAttV2AuthKey_cold_9()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetAttV2AuthKey_cold_10()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEGetAttV2AuthKey_cold_11()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSESetSEPubKey_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSESetSEPubKey_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSESetSEPubKey_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSESetSEPubKey_cold_4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSESetSEPubKey_cold_5()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSESetSEPubKey_cold_6()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSESetSEPubKey_cold_7()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_4();
}

void SSESetSEPubKey_cold_8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_5()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_6()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_7()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_9()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_10()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_11()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_12()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_13()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_14()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_15()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_16()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_17()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void SSEPerformAuthKeySharing_cold_18()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void __baaInit_block_invoke_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

void __baaInit_block_invoke_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_1(&dword_21CC7F000, MEMORY[0x24BDACB70], v0, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_4();
}

std::vector<std::string> *SLAM::Error::Error(std::vector<std::string> *this, const char *a2, ...)
{
  std::string *value;
  std::vector<std::string>::pointer end;
  __int128 v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  std::string *v10;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  int v14;
  void *__p[2];
  std::string::size_type v17;
  va_list v18;
  std::__split_buffer<std::string> __v;
  va_list va;

  va_start(va, a2);
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  va_copy(v18, va);
  __v.__first_ = 0;
  vasprintf((char **)&__v, a2, va);
  if (__v.__first_)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, (char *)__v.__first_);
    free(__v.__first_);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "<FAILED TO VASPRINTF>");
  }
  value = this->__end_cap_.__value_;
  end = this->__end_;
  if (end >= value)
  {
    v6 = 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)this->__begin_) >> 3);
    v7 = v6 + 1;
    if (v6 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)this->__begin_) >> 3);
    if (2 * v8 > v7)
      v7 = 2 * v8;
    if (v8 >= 0x555555555555555)
      v9 = 0xAAAAAAAAAAAAAAALL;
    else
      v9 = v7;
    __v.__end_cap_.__value_ = (std::allocator<std::string> *)&this->__end_cap_;
    if (v9)
      v10 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&this->__end_cap_, v9);
    else
      v10 = 0;
    v11 = v10 + v6;
    __v.__first_ = v10;
    __v.__begin_ = v11;
    __v.__end_cap_.__value_ = &v10[v9];
    v12 = *(_OWORD *)__p;
    v11->__r_.__value_.__r.__words[2] = v17;
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
    __p[1] = 0;
    v17 = 0;
    __p[0] = 0;
    __v.__end_ = v11 + 1;
    std::vector<std::string>::__swap_out_circular_buffer(this, &__v);
    v13 = this->__end_;
    std::__split_buffer<std::string>::~__split_buffer(&__v);
    v14 = SHIBYTE(v17);
    this->__end_ = v13;
    if (v14 < 0)
      operator delete(__p[0]);
  }
  else
  {
    v5 = *(_OWORD *)__p;
    end->__r_.__value_.__r.__words[2] = v17;
    *(_OWORD *)&end->__r_.__value_.__l.__data_ = v5;
    this->__end_ = end + 1;
  }
  return this;
}

void sub_21CC876B4(_Unwind_Exception *a1, void *__p, uint64_t a3, int a4, __int16 a5, char a6, char a7, uint64_t a8, std::__split_buffer<std::string> *a9, void *__pa, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a17);
  if (a15 < 0)
    operator delete(__pa);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__pa);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void SLAM::SLAM::PerformScript(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  std::string v39;
  uint64_t v40;
  std::__shared_weak_count *v41;

  _ZNSt3__115allocate_sharedB8ne180100IN4SLAM21DefaultScriptProviderENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v40);
  v8 = v40;
  v9 = v41;
  v32 = v41;
  if (*(char *)(a1 + 23) < 0)
    std::string::__init_copy_ctor_external(&v39, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  else
    v39 = *(std::string *)a1;
  v10 = a2[1];
  v37 = *a2;
  v38 = (std::__shared_weak_count *)v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = a3[1];
  v35 = *a3;
  v36 = (std::__shared_weak_count *)v13;
  if (v13)
  {
    v14 = (unint64_t *)(v13 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  if (!v9)
  {
    v33 = v8;
    v34 = 0;
    if (v8)
      goto LABEL_16;
LABEL_45:
    std::terminate();
  }
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v17 = __ldxr(p_shared_owners);
  while (__stxr(v17 + 1, p_shared_owners));
  v33 = v8;
  v34 = v9;
  do
    v18 = __ldxr(p_shared_owners);
  while (__stxr(v18 + 1, p_shared_owners));
  if (!v8)
    goto LABEL_45;
LABEL_16:
  SLAM::SLAMPrivateInterface::PerformScript((uint64_t)&v39, &v37, &v35, &v33, a4);
  v19 = v34;
  if (v34)
  {
    v20 = (unint64_t *)&v34->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  if (v9)
  {
    v22 = (unint64_t *)&v9->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v24 = v36;
  if (v36)
  {
    v25 = (unint64_t *)&v36->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v27 = v38;
  if (v38)
  {
    v28 = (unint64_t *)&v38->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v39.__r_.__value_.__l.__data_);
  if (v32)
  {
    v30 = (unint64_t *)&v32->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
}

#error "21CC879C8: call analysis failed (funcsize=33)"

void SLAM::SLAMPrivateInterface::PerformScript(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  void (***v34)(_QWORD, std::string *);
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t *v39;
  std::string::size_type v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  std::string *v49;
  uint64_t v50;
  std::string *v51;
  uint64_t v52;
  uint64_t (***v53)();
  uint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  std::string v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  uint64_t v67;
  std::__shared_weak_count *v68;
  uint64_t v69;
  std::__shared_weak_count *v70;
  std::string *v71;
  uint64_t (**v72)();
  std::string::size_type v73;
  std::__shared_weak_count *v74;
  uint64_t (***v75)();
  std::string v76;
  std::string *v77;
  std::string v78;
  std::string *v79;
  uint64_t v80;

  v80 = *MEMORY[0x24BDAC8D0];
  std::allocate_shared[abi:ne180100]<SLAM::Logger,std::allocator<SLAM::Logger>,gsl::not_null<std::shared_ptr<SLAM::LogSink>> const&,void>(a3, &v69);
  *(_BYTE *)a5 = 0;
  *(_BYTE *)(a5 + 24) = 0;
  v10 = a2[1];
  v67 = *a2;
  v68 = (std::__shared_weak_count *)v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = v69;
  v63 = v69;
  v64 = v70;
  if (v70)
  {
    p_shared_owners = (unint64_t *)&v70->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
    v65 = v13;
    v66 = v64;
    if (v64)
    {
      v16 = (unint64_t *)&v64->__shared_owners_;
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }
  }
  else
  {
    v65 = v69;
    v66 = 0;
  }
  if (!v13)
    std::terminate();
  v18 = (std::__shared_weak_count *)a4[1];
  v61 = *a4;
  v62 = v18;
  if (v18)
  {
    v19 = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  SLAM::Impl::Impl(&v76, &v67, &v65, &v61);
  if (*(char *)(a1 + 23) < 0)
    std::string::__init_copy_ctor_external(&v60, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  else
    v60 = *(std::string *)a1;
  SLAM::Impl::PerformScript((SLAM::Impl *)&v76, (const char *)&v60, &v78);
  std::__optional_storage_base<SLAM::Error,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<SLAM::Error,false>>((std::vector<std::string> *)a5, (uint64_t)&v78);
  if ((_BYTE)v79)
  {
    v71 = &v78;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v71);
  }
  if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v60.__r_.__value_.__l.__data_);
  SLAM::Impl::~Impl((SLAM::Impl *)&v76);
  v21 = v62;
  if (v62)
  {
    v22 = (unint64_t *)&v62->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = v66;
  if (v66)
  {
    v25 = (unint64_t *)&v66->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v27 = v64;
  if (v64)
  {
    v28 = (unint64_t *)&v64->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  v30 = v68;
  if (v68)
  {
    v31 = (unint64_t *)&v68->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  if (*(_BYTE *)(a5 + 24))
  {
    v34 = (void (***)(_QWORD, std::string *))*a3;
    v33 = (std::__shared_weak_count *)a3[1];
    v78.__r_.__value_.__r.__words[0] = *a3;
    v78.__r_.__value_.__l.__size_ = (std::string::size_type)v33;
    if (v33)
    {
      v35 = (unint64_t *)&v33->__shared_owners_;
      do
        v36 = __ldxr(v35);
      while (__stxr(v36 + 1, v35));
    }
    ctu::join<std::__wrap_iter<std::string const*>>(*(std::string **)a5, *(std::string **)(a5 + 8), ", ", 2uLL, &v76);
    (**v34)(v34, &v76);
    if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v76.__r_.__value_.__l.__data_);
    if (v33)
    {
      v37 = (unint64_t *)&v33->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    v39 = (uint64_t *)v69;
    v40 = *a3;
    v41 = (std::__shared_weak_count *)a3[1];
    if (v41)
    {
      v42 = (unint64_t *)&v41->__shared_owners_;
      do
        v43 = __ldxr(v42);
      while (__stxr(v43 + 1, v42));
      v74 = v41;
      v75 = 0;
      v73 = v40;
      do
        v44 = __ldxr(v42);
      while (__stxr(v44 + 1, v42));
    }
    else
    {
      v74 = 0;
      v75 = 0;
      v73 = v40;
    }
    v72 = &off_24E0BF428;
    v75 = &v72;
    v45 = v39 + 2;
    if (v39[6])
      v46 = v39[4];
    else
      v46 = 0;
    v78.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0BF428;
    v78.__r_.__value_.__l.__size_ = v40;
    v78.__r_.__value_.__r.__words[2] = (std::string::size_type)v41;
    v79 = &v78;
    if (v41)
    {
      v47 = (unint64_t *)&v41->__shared_owners_;
      do
        v48 = __ldxr(v47);
      while (__stxr(v48 + 1, v47));
    }
    std::for_each[abi:ne180100]<boost::cb_details::iterator<boost::circular_buffer<std::string,std::allocator<std::string>>,boost::cb_details::const_traits<std::allocator<std::string>>>,std::function<void ()(std::string const&)>>(v45, v46, 0, (uint64_t)&v78, (uint64_t)&v76);
    v49 = v77;
    if (v77 == &v76)
    {
      v50 = 4;
      v49 = &v76;
    }
    else
    {
      if (!v77)
        goto LABEL_72;
      v50 = 5;
    }
    (*(void (**)(void))(v49->__r_.__value_.__r.__words[0] + 8 * v50))();
LABEL_72:
    v51 = v79;
    if (v79 == &v78)
    {
      v52 = 4;
      v51 = &v78;
    }
    else
    {
      if (!v79)
        goto LABEL_77;
      v52 = 5;
    }
    (*(void (**)(void))(v51->__r_.__value_.__r.__words[0] + 8 * v52))();
LABEL_77:
    v53 = v75;
    if (v75 == &v72)
    {
      v54 = 4;
      v53 = &v72;
    }
    else
    {
      if (!v75)
      {
LABEL_82:
        if (v41)
        {
          v55 = (unint64_t *)&v41->__shared_owners_;
          do
            v56 = __ldaxr(v55);
          while (__stlxr(v56 - 1, v55));
          if (!v56)
          {
            ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
            std::__shared_weak_count::__release_weak(v41);
          }
        }
        goto LABEL_87;
      }
      v54 = 5;
    }
    (*v53)[v54]();
    goto LABEL_82;
  }
LABEL_87:
  v57 = v70;
  if (v70)
  {
    v58 = (unint64_t *)&v70->__shared_owners_;
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
}

#error "21CC88004: call analysis failed (funcsize=44)"

void SLAM::SLAM::PerformRecovery(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;

  _ZNSt3__115allocate_sharedB8ne180100IN4SLAM21DefaultScriptProviderENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v38);
  v6 = v38;
  v7 = v39;
  v30 = v39;
  v8 = a1[1];
  v36 = *a1;
  v37 = (std::__shared_weak_count *)v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = a2[1];
  v34 = *a2;
  v35 = (std::__shared_weak_count *)v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v31 = v7;
  if (!v7)
  {
    v32 = v6;
    v33 = 0;
    if (v6)
      goto LABEL_13;
LABEL_40:
    std::terminate();
  }
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v15 = __ldxr(p_shared_owners);
  while (__stxr(v15 + 1, p_shared_owners));
  v32 = v6;
  v33 = v7;
  do
    v16 = __ldxr(p_shared_owners);
  while (__stxr(v16 + 1, p_shared_owners));
  if (!v6)
    goto LABEL_40;
LABEL_13:
  SLAM::SLAMPrivateInterface::PerformRecovery(&v36, &v34, &v32, a3);
  v17 = v33;
  if (v33)
  {
    v18 = (unint64_t *)&v33->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  if (v31)
  {
    v20 = (unint64_t *)&v31->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v22 = v35;
  if (v35)
  {
    v23 = (unint64_t *)&v35->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v37;
  if (v37)
  {
    v26 = (unint64_t *)&v37->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  if (v30)
  {
    v28 = (unint64_t *)&v30->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
}

#error "21CC882C4: call analysis failed (funcsize=40)"

void SLAM::SLAMPrivateInterface::PerformRecovery(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  void (***v32)(_QWORD, std::string *);
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t *v37;
  std::string::size_type v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  std::string *p_p;
  uint64_t v48;
  std::string *v49;
  uint64_t v50;
  uint64_t (***v51)();
  uint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  uint64_t v62;
  std::__shared_weak_count *v63;
  uint64_t v64;
  std::__shared_weak_count *v65;
  uint64_t v66;
  std::__shared_weak_count *v67;
  std::string *v68;
  uint64_t (**v69)();
  std::string::size_type v70;
  std::__shared_weak_count *v71;
  uint64_t (***v72)();
  std::string __p;
  std::string *v74;
  std::string v75;
  std::string *v76;
  uint64_t v77;

  v77 = *MEMORY[0x24BDAC8D0];
  std::allocate_shared[abi:ne180100]<SLAM::Logger,std::allocator<SLAM::Logger>,gsl::not_null<std::shared_ptr<SLAM::LogSink>> const&,void>(a2, &v66);
  *(_BYTE *)a4 = 0;
  *(_BYTE *)(a4 + 24) = 0;
  v8 = a1[1];
  v64 = *a1;
  v65 = (std::__shared_weak_count *)v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = v66;
  v60 = v66;
  v61 = v67;
  if (v67)
  {
    p_shared_owners = (unint64_t *)&v67->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    v62 = v11;
    v63 = v61;
    if (v61)
    {
      v14 = (unint64_t *)&v61->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
  }
  else
  {
    v62 = v66;
    v63 = 0;
  }
  if (!v11)
    std::terminate();
  v16 = (std::__shared_weak_count *)a3[1];
  v58 = *a3;
  v59 = v16;
  if (v16)
  {
    v17 = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  SLAM::Impl::Impl(&__p, &v64, &v62, &v58);
  SLAM::Impl::PerformRecovery((SLAM::Impl *)&__p, &v75);
  std::__optional_storage_base<SLAM::Error,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<SLAM::Error,false>>((std::vector<std::string> *)a4, (uint64_t)&v75);
  if ((_BYTE)v76)
  {
    v68 = &v75;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v68);
  }
  SLAM::Impl::~Impl((SLAM::Impl *)&__p);
  v19 = v59;
  if (v59)
  {
    v20 = (unint64_t *)&v59->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v63;
  if (v63)
  {
    v23 = (unint64_t *)&v63->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v61;
  if (v61)
  {
    v26 = (unint64_t *)&v61->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = v65;
  if (v65)
  {
    v29 = (unint64_t *)&v65->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  if (*(_BYTE *)(a4 + 24))
  {
    SLAM::Error::Add((std::vector<std::string> *)a4, "While performing recovery");
    v32 = (void (***)(_QWORD, std::string *))*a2;
    v31 = (std::__shared_weak_count *)a2[1];
    v75.__r_.__value_.__r.__words[0] = *a2;
    v75.__r_.__value_.__l.__size_ = (std::string::size_type)v31;
    if (v31)
    {
      v33 = (unint64_t *)&v31->__shared_owners_;
      do
        v34 = __ldxr(v33);
      while (__stxr(v34 + 1, v33));
    }
    ctu::join<std::__wrap_iter<std::string const*>>(*(std::string **)a4, *(std::string **)(a4 + 8), ", ", 2uLL, &__p);
    (**v32)(v32, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (v31)
    {
      v35 = (unint64_t *)&v31->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    v37 = (uint64_t *)v66;
    v38 = *a2;
    v39 = (std::__shared_weak_count *)a2[1];
    if (v39)
    {
      v40 = (unint64_t *)&v39->__shared_owners_;
      do
        v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
      v71 = v39;
      v72 = 0;
      v70 = v38;
      do
        v42 = __ldxr(v40);
      while (__stxr(v42 + 1, v40));
    }
    else
    {
      v71 = 0;
      v72 = 0;
      v70 = v38;
    }
    v69 = &off_24E0BF470;
    v72 = &v69;
    v43 = v37 + 2;
    if (v37[6])
      v44 = v37[4];
    else
      v44 = 0;
    v75.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0BF470;
    v75.__r_.__value_.__l.__size_ = v38;
    v75.__r_.__value_.__r.__words[2] = (std::string::size_type)v39;
    v76 = &v75;
    if (v39)
    {
      v45 = (unint64_t *)&v39->__shared_owners_;
      do
        v46 = __ldxr(v45);
      while (__stxr(v46 + 1, v45));
    }
    std::for_each[abi:ne180100]<boost::cb_details::iterator<boost::circular_buffer<std::string,std::allocator<std::string>>,boost::cb_details::const_traits<std::allocator<std::string>>>,std::function<void ()(std::string const&)>>(v43, v44, 0, (uint64_t)&v75, (uint64_t)&__p);
    p_p = v74;
    if (v74 == &__p)
    {
      v48 = 4;
      p_p = &__p;
    }
    else
    {
      if (!v74)
        goto LABEL_67;
      v48 = 5;
    }
    (*(void (**)(void))(p_p->__r_.__value_.__r.__words[0] + 8 * v48))();
LABEL_67:
    v49 = v76;
    if (v76 == &v75)
    {
      v50 = 4;
      v49 = &v75;
    }
    else
    {
      if (!v76)
        goto LABEL_72;
      v50 = 5;
    }
    (*(void (**)(void))(v49->__r_.__value_.__r.__words[0] + 8 * v50))();
LABEL_72:
    v51 = v72;
    if (v72 == &v69)
    {
      v52 = 4;
      v51 = &v69;
    }
    else
    {
      if (!v72)
      {
LABEL_77:
        if (v39)
        {
          v53 = (unint64_t *)&v39->__shared_owners_;
          do
            v54 = __ldaxr(v53);
          while (__stlxr(v54 - 1, v53));
          if (!v54)
          {
            ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
            std::__shared_weak_count::__release_weak(v39);
          }
        }
        goto LABEL_82;
      }
      v52 = 5;
    }
    (*v51)[v52]();
    goto LABEL_77;
  }
LABEL_82:
  v55 = v67;
  if (v67)
  {
    v56 = (unint64_t *)&v67->__shared_owners_;
    do
      v57 = __ldaxr(v56);
    while (__stlxr(v57 - 1, v56));
    if (!v57)
    {
      ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
      std::__shared_weak_count::__release_weak(v55);
    }
  }
}

void sub_21CC887AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;
  uint64_t v34;
  _QWORD *v36;
  uint64_t v37;

  v36 = *(_QWORD **)(v34 - 64);
  if (v36 == (_QWORD *)(v34 - 88))
  {
    v37 = 4;
    v36 = (_QWORD *)(v34 - 88);
  }
  else
  {
    if (!v36)
      goto LABEL_6;
    v37 = 5;
  }
  (*(void (**)(void))(*v36 + 8 * v37))();
LABEL_6:
  SLAM::SLAMPrivateInterface::PerformScript();
  if (*(_BYTE *)(v33 + 24))
  {
    a23 = v33;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  }
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a21);
  _Unwind_Resume(a1);
}

std::vector<std::string> *std::optional<SLAM::Error>::operator=[abi:ne180100]<SLAM::Error,void>(std::vector<std::string> *this, std::vector<std::string> *a2)
{
  if (LOBYTE(this[1].__begin_))
  {
    std::vector<std::string>::__vdeallocate(this);
    *(_OWORD *)&this->__begin_ = *(_OWORD *)&a2->__begin_;
    this->__end_cap_.__value_ = a2->__end_cap_.__value_;
    a2->__begin_ = 0;
    a2->__end_ = 0;
    a2->__end_cap_.__value_ = 0;
  }
  else
  {
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
    *this = *a2;
    a2->__begin_ = 0;
    a2->__end_ = 0;
    a2->__end_cap_.__value_ = 0;
    LOBYTE(this[1].__begin_) = 1;
  }
  return this;
}

std::vector<std::string> *SLAM::Error::Add(std::vector<std::string> *this, const char *a2, ...)
{
  std::string *value;
  std::vector<std::string>::pointer end;
  __int128 v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  std::string *v10;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  int v14;
  void *__p[2];
  std::string::size_type v17;
  va_list v18;
  std::__split_buffer<std::string> __v;
  va_list va;

  va_start(va, a2);
  va_copy(v18, va);
  __v.__first_ = 0;
  vasprintf((char **)&__v, a2, va);
  if (__v.__first_)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, (char *)__v.__first_);
    free(__v.__first_);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "<FAILED TO VASPRINTF>");
  }
  value = this->__end_cap_.__value_;
  end = this->__end_;
  if (end >= value)
  {
    v6 = 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)this->__begin_) >> 3);
    v7 = v6 + 1;
    if (v6 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)this->__begin_) >> 3);
    if (2 * v8 > v7)
      v7 = 2 * v8;
    if (v8 >= 0x555555555555555)
      v9 = 0xAAAAAAAAAAAAAAALL;
    else
      v9 = v7;
    __v.__end_cap_.__value_ = (std::allocator<std::string> *)&this->__end_cap_;
    if (v9)
      v10 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&this->__end_cap_, v9);
    else
      v10 = 0;
    v11 = v10 + v6;
    __v.__first_ = v10;
    __v.__begin_ = v11;
    __v.__end_cap_.__value_ = &v10[v9];
    v12 = *(_OWORD *)__p;
    v11->__r_.__value_.__r.__words[2] = v17;
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
    __p[1] = 0;
    v17 = 0;
    __p[0] = 0;
    __v.__end_ = v11 + 1;
    std::vector<std::string>::__swap_out_circular_buffer(this, &__v);
    v13 = this->__end_;
    std::__split_buffer<std::string>::~__split_buffer(&__v);
    v14 = SHIBYTE(v17);
    this->__end_ = v13;
    if (v14 < 0)
      operator delete(__p[0]);
  }
  else
  {
    v5 = *(_OWORD *)__p;
    end->__r_.__value_.__r.__words[2] = v17;
    *(_OWORD *)&end->__r_.__value_.__l.__data_ = v5;
    this->__end_ = end + 1;
  }
  return this;
}

void sub_21CC88AFC(_Unwind_Exception *a1, void *__p, uint64_t a3, int a4, __int16 a5, char a6, char a7, uint64_t a8, std::__split_buffer<std::string> *a9, void *__pa, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a17);
  if (a15 < 0)
    operator delete(__pa);
  _Unwind_Resume(a1);
}

void SLAM::Impl::PerformScript(SLAM::Impl *a1@<X0>, const char *a2@<X1>, std::string *a3@<X8>)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  void (***v10)(void ***__return_ptr, _QWORD, std::string *, void **, uint64_t);
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void **v24;
  void *v25[2];
  char v26;
  std::string v27;
  void *__p;
  void *v29;
  uint64_t v30;
  std::string v31;
  void *v32;
  _BYTE *v33;
  uint64_t v34;
  __int128 *v35;
  __int128 *v36;
  char v37;
  void **v38;
  __int128 *v39;
  char v40;
  __int128 *v41;
  __int128 *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  SLAM::Impl::GetChipId(a1, (uint64_t)&v35);
  if (!v37)
  {
    a3->__r_.__value_.__r.__words[0] = 0;
    a3->__r_.__value_.__l.__size_ = 0;
    a3->__r_.__value_.__r.__words[2] = 0;
    std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(a3, v35, v36, 0xAAAAAAAAAAAAAAABLL * (((char *)v36 - (char *)v35) >> 3));
    a3[1].__r_.__value_.__s.__data_[0] = 1;
    goto LABEL_50;
  }
  v6 = *(unsigned __int8 *)caulk::expected<unsigned char,SLAM::Error>::value((uint64_t)&v35);
  v7 = 1;
  if (v6 > 0xC7)
  {
    if (v6 == 200 || v6 == 210)
      goto LABEL_10;
  }
  else if (v6 == 100 || v6 == 115)
  {
    goto LABEL_10;
  }
  v7 = 2;
LABEL_10:
  SLAM::Impl::QueryMigrationInfo(a1, (uint64_t)&v41);
  if (v43)
  {
    v8 = caulk::expected<SLAM::MigrationInfo,SLAM::Error>::value((uint64_t)&v41);
    v32 = 0;
    v33 = 0;
    v34 = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v32, *(const void **)(v8 + 16), *(_QWORD *)(v8 + 24), *(_QWORD *)(v8 + 24) - *(_QWORD *)(v8 + 16));
    v10 = (void (***)(void ***__return_ptr, _QWORD, std::string *, void **, uint64_t))*((_QWORD *)a1 + 6);
    v9 = (std::__shared_weak_count *)*((_QWORD *)a1 + 7);
    v27.__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
    v27.__r_.__value_.__l.__size_ = (std::string::size_type)v9;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
    if (a2[23] < 0)
      std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    else
      v31 = *(std::string *)a2;
    __p = 0;
    v29 = 0;
    v30 = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v32, (uint64_t)v33, v33 - (_BYTE *)v32);
    (**v10)(&v38, v10, &v31, &__p, v7);
    if (__p)
    {
      v29 = __p;
      operator delete(__p);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v31.__r_.__value_.__l.__data_);
    if (v9)
    {
      v13 = (unint64_t *)&v9->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    if (v40)
    {
      v16 = *((_QWORD *)a1 + 8);
      v15 = (std::__shared_weak_count *)*((_QWORD *)a1 + 9);
      v27.__r_.__value_.__r.__words[0] = v16;
      v27.__r_.__value_.__l.__size_ = (std::string::size_type)v15;
      if (v15)
      {
        v17 = (unint64_t *)&v15->__shared_owners_;
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }
      if (a2[23] < 0)
        a2 = *(const char **)a2;
      v19 = (_QWORD *)caulk::expected<SLAM::Script,SLAM::Error>::value((uint64_t)&v38);
      SLAM::Logger::Log(v16, 1, (uint64_t)"PerformScript", 179, "Executing script %s ID 0x%llX", a2, *v19);
      if (v15)
      {
        v20 = (unint64_t *)&v15->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      v22 = caulk::expected<SLAM::Script,SLAM::Error>::value((uint64_t)&v38);
      v23 = caulk::expected<SLAM::MigrationInfo,SLAM::Error>::value((uint64_t)&v41);
      (*(void (**)(SLAM::Impl *, uint64_t, uint64_t))(*(_QWORD *)a1 + 16))(a1, v22, v23);
    }
    else
    {
      memset(&v27, 0, sizeof(v27));
      std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v27, (__int128 *)v38, v39, 0xAAAAAAAAAAAAAAABLL * (((char *)v39 - (char *)v38) >> 3));
      if (a2[23] < 0)
        a2 = *(const char **)a2;
      ctu::hex();
      if (v26 >= 0)
        v24 = v25;
      else
        v24 = (void **)v25[0];
      SLAM::Error::Add((std::vector<std::string> *)&v27, "with name %s, pkHash %s, platformCategory %d", a2, (const char *)v24, v7);
      if (v26 < 0)
        operator delete(v25[0]);
      *a3 = v27;
      memset(&v27, 0, sizeof(v27));
      a3[1].__r_.__value_.__s.__data_[0] = 1;
      v25[0] = &v27;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)v25);
    }
    caulk::__expected_detail::base<SLAM::Script,SLAM::Error>::~base((uint64_t)&v38);
    if (v32)
    {
      v33 = v32;
      operator delete(v32);
    }
  }
  else
  {
    a3->__r_.__value_.__r.__words[0] = 0;
    a3->__r_.__value_.__l.__size_ = 0;
    a3->__r_.__value_.__r.__words[2] = 0;
    std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(a3, v41, v42, 0xAAAAAAAAAAAAAAABLL * (((char *)v42 - (char *)v41) >> 3));
    a3[1].__r_.__value_.__s.__data_[0] = 1;
  }
  caulk::__expected_detail::base<SLAM::MigrationInfo,SLAM::Error>::~base((uint64_t)&v41);
LABEL_50:
  if (!v37)
  {
    v38 = (void **)&v35;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v38);
  }
}

void sub_21CC88F08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,char a36,char *a37)
{
  uint64_t v37;

  if (a17 < 0)
    operator delete(__p);
  __p = &a18;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  caulk::__expected_detail::base<SLAM::Script,SLAM::Error>::~base((uint64_t)&a37);
  if (a30)
  {
    a31 = (uint64_t)a30;
    operator delete(a30);
  }
  caulk::__expected_detail::base<SLAM::MigrationInfo,SLAM::Error>::~base(v37 - 128);
  if (!a36)
  {
    a37 = &a33;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a37);
  }
  _Unwind_Resume(a1);
}

uint64_t SLAM::Impl::PerformRecovery@<X0>(SLAM::Impl *this@<X0>, std::string *a2@<X8>)
{
  _QWORD v5[2];
  _QWORD *v6;
  __int128 *v7;
  __int128 *v8;
  char v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  SLAM::Impl::QueryMigrationInfo(this, (uint64_t)&v7);
  if (v9)
  {
    v5[0] = this;
    v5[1] = this;
    if ((_DWORD)v8 == -1)
      std::__throw_bad_variant_access[abi:ne180100]();
    v6 = v5;
    ((void (*)(_QWORD **, __int128 **))off_24E0BF358[v8])(&v6, &v7);
  }
  else
  {
    a2->__r_.__value_.__r.__words[0] = 0;
    a2->__r_.__value_.__l.__size_ = 0;
    a2->__r_.__value_.__r.__words[2] = 0;
    std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(a2, v7, v8, 0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (char *)v7) >> 3));
    a2[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return caulk::__expected_detail::base<SLAM::MigrationInfo,SLAM::Error>::~base((uint64_t)&v7);
}

void sub_21CC890D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  caulk::__expected_detail::base<SLAM::MigrationInfo,SLAM::Error>::~base((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t SLAM::Impl::QueryMigrationInfo@<X0>(SLAM::Impl *this@<X0>, uint64_t a2@<X8>)
{
  void (***v3)(__int128 *__return_ptr);
  char *v4;
  _BYTE *v5;
  unint64_t *v6;
  _QWORD *v7;
  unint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  BOOL v15;
  _QWORD *v16;
  const void *v17;
  __int128 v18;
  std::string::size_type v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  BOOL v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  BOOL v34;
  _QWORD *v35;
  unsigned int v36;
  __int128 **v37;
  __int128 **v38;
  __int128 **v39;
  __int128 **v40;
  __int128 **v41;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  _QWORD *v47;
  unint64_t v48;
  BOOL v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  _QWORD *v55;
  unint64_t v56;
  BOOL v57;
  _QWORD *v58;
  unsigned int v59;
  unint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  _QWORD *v65;
  _QWORD *v66;
  unint64_t v67;
  BOOL v68;
  _QWORD *v69;
  std::string v70;
  std::string v71;
  char v72;
  std::string __p;
  char v74;
  std::vector<std::string> v75;
  char v76;
  std::string *v77;
  std::string v78;
  std::string v79;
  char v80;
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  v3 = (void (***)(__int128 *__return_ptr))((char *)this + 8);
  v4 = (char *)operator new(0xEuLL);
  __p.__r_.__value_.__l.__size_ = (std::string::size_type)(v4 + 14);
  __p.__r_.__value_.__r.__words[2] = (std::string::size_type)(v4 + 14);
  *(_QWORD *)v4 = 0xA0080004A400;
  *((_WORD *)v4 + 4) = 20737;
  *(_DWORD *)(v4 + 10) = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v4;
  SLAM::TransceiverWrapper::TransceiveAndCheckSW(v3, (uint64_t)&v75);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v76)
  {
    caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v75);
    v5 = operator new(5uLL);
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)(v5 + 5);
    __p.__r_.__value_.__r.__words[2] = (std::string::size_type)(v5 + 5);
    *(_DWORD *)v5 = 240256;
    v5[4] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v5;
    SLAM::TransceiverWrapper::TransceiveAndCheckSW(v3, (uint64_t)&v75);
    if (__p.__r_.__value_.__r.__words[0])
    {
      __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v76)
    {
      v6 = (unint64_t *)caulk::expected<std::vector<unsigned char>,SLAM::Error>::value((uint64_t)&v75);
      v79.__r_.__value_.__r.__words[0] = 0xC000000000000000;
      SLAM::DERParseSequenceToMap(v6, (uint64_t *)&v79, 1, (uint64_t)&__p);
      if (!v74)
      {
        v39 = (__int128 **)SLAM::Error::Add((std::vector<std::string> *)&__p, "While parsing migration state");
        memset(&v79, 0, sizeof(v79));
        std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v79, *v39, v39[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v39[1] - (char *)*v39) >> 3));
        SLAM::Error::Unexpected((__int128 **)&v79, &v71);
        *(std::string *)a2 = v71;
        memset(&v71, 0, sizeof(v71));
        *(_BYTE *)(a2 + 48) = 0;
        v78.__r_.__value_.__r.__words[0] = (std::string::size_type)&v71;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v78);
        v71.__r_.__value_.__r.__words[0] = (std::string::size_type)&v79;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v71);
LABEL_60:
        caulk::__expected_detail::base<std::map<unsigned long long,DERItem>,SLAM::Error>::~base((uint64_t)&__p);
        return caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v75);
      }
      v7 = operator new(8uLL);
      v71.__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
      *v7 = 0x53DF02FE00CA80;
      v71.__r_.__value_.__l.__size_ = (std::string::size_type)(v7 + 1);
      v71.__r_.__value_.__r.__words[2] = (std::string::size_type)(v7 + 1);
      SLAM::TransceiverWrapper::TransceiveAndCheckSW(v3, (uint64_t)&v79);
      if (v71.__r_.__value_.__r.__words[0])
      {
        v71.__r_.__value_.__l.__size_ = v71.__r_.__value_.__r.__words[0];
        operator delete(v71.__r_.__value_.__l.__data_);
      }
      if (!v80)
      {
        v40 = (__int128 **)SLAM::Error::Add((std::vector<std::string> *)&v79, "While querying SLAM state");
        SLAM::Error::Unexpected(v40, &v71);
        *(std::string *)a2 = v71;
        memset(&v71, 0, sizeof(v71));
        *(_BYTE *)(a2 + 48) = 0;
        v78.__r_.__value_.__r.__words[0] = (std::string::size_type)&v71;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v78);
LABEL_59:
        caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v79);
        goto LABEL_60;
      }
      v8 = (unint64_t *)caulk::expected<std::vector<unsigned char>,SLAM::Error>::value((uint64_t)&v79);
      *(_OWORD *)&v78.__r_.__value_.__l.__data_ = xmmword_21CCD71C0;
      SLAM::DERParseSequenceToMap(v8, (uint64_t *)&v78, 2, (uint64_t)&v71);
      if (v72)
      {
        v9 = caulk::expected<std::map<unsigned long long,DERItem>,SLAM::Error>::value((uint64_t)&v71);
        v12 = *(_QWORD **)(v9 + 8);
        v10 = (_QWORD *)(v9 + 8);
        v11 = v12;
        if (v12)
        {
          v13 = v10;
          do
          {
            v14 = v11[4];
            v15 = v14 >= 0x8000000000000003;
            if (v14 >= 0x8000000000000003)
              v16 = v11;
            else
              v16 = v11 + 1;
            if (v15)
              v13 = v11;
            v11 = (_QWORD *)*v16;
          }
          while (*v16);
          if (v13 != v10 && v13[4] <= 0x8000000000000003 && v13[6] == 32)
          {
            v17 = (const void *)v13[5];
            memset(&v78, 0, sizeof(v78));
            std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v78, v17, (uint64_t)v17 + 32, 0x20uLL);
            v18 = *(_OWORD *)&v78.__r_.__value_.__l.__data_;
            v19 = v78.__r_.__value_.__r.__words[2];
            v20 = caulk::expected<std::map<unsigned long long,DERItem>,SLAM::Error>::value((uint64_t)&v71);
            v23 = *(_QWORD **)(v20 + 8);
            v21 = v20 + 8;
            v22 = v23;
            if (!v23)
              goto LABEL_62;
            v24 = (_QWORD *)v21;
            do
            {
              v25 = v22[4];
              v26 = v25 < 0;
              if (v25 < 0)
                v27 = v22;
              else
                v27 = v22 + 1;
              if (v26)
                v24 = v22;
              v22 = (_QWORD *)*v27;
            }
            while (*v27);
            if (v24 == (_QWORD *)v21 || v24[4] > 0x8000000000000000 || v24[6] != 1)
            {
LABEL_62:
              SLAM::Error::Unexpected((SLAM::Error *)"Missing or wrong length tag 0x%llx", (uint64_t)&v78, 0x8000000000000000);
              goto LABEL_63;
            }
            if (*(unsigned __int8 *)v24[5] < 2u)
            {
              v36 = 0;
            }
            else
            {
              v28 = caulk::expected<std::map<unsigned long long,DERItem>,SLAM::Error>::value((uint64_t)&v71);
              v31 = *(_QWORD **)(v28 + 8);
              v29 = v28 + 8;
              v30 = v31;
              if (!v31)
                goto LABEL_82;
              v32 = (_QWORD *)v29;
              do
              {
                v33 = v30[4];
                v34 = v33 >= 0x8000000000000004;
                if (v33 >= 0x8000000000000004)
                  v35 = v30;
                else
                  v35 = v30 + 1;
                if (v34)
                  v32 = v30;
                v30 = (_QWORD *)*v35;
              }
              while (*v35);
              if (v32 == (_QWORD *)v29 || v32[4] > 0x8000000000000004 || v32[6] != 2)
              {
LABEL_82:
                SLAM::Error::Unexpected((SLAM::Error *)"Missing or wrong length tag 0x%llx", (uint64_t)&v78, 0x8000000000000004);
                goto LABEL_63;
              }
              v36 = bswap32(*(unsigned __int16 *)v32[5]) >> 16;
            }
            v43 = caulk::expected<std::map<unsigned long long,DERItem>,SLAM::Error>::value((uint64_t)&__p);
            v46 = *(_QWORD **)(v43 + 8);
            v44 = v43 + 8;
            v45 = v46;
            if (!v46)
              goto LABEL_81;
            v47 = (_QWORD *)v44;
            do
            {
              v48 = v45[4];
              v49 = v48 >= 0xC000000000000009;
              if (v48 >= 0xC000000000000009)
                v50 = v45;
              else
                v50 = v45 + 1;
              if (v49)
                v47 = v45;
              v45 = (_QWORD *)*v50;
            }
            while (*v50);
            if (v47 != (_QWORD *)v44 && v47[4] <= 0xC000000000000009 && v47[6] == 2)
            {
              if (*(_WORD *)v47[5] == 23130)
              {
                *(_QWORD *)a2 = 0;
                *(_QWORD *)(a2 + 8) = 1;
LABEL_80:
                *(_OWORD *)(a2 + 16) = v18;
                *(_QWORD *)(a2 + 32) = v19;
                *(_DWORD *)(a2 + 40) = v36;
                *(_BYTE *)(a2 + 48) = 1;
                goto LABEL_58;
              }
              v51 = caulk::expected<std::map<unsigned long long,DERItem>,SLAM::Error>::value((uint64_t)&__p);
              v54 = *(_QWORD **)(v51 + 8);
              v52 = v51 + 8;
              v53 = v54;
              if (!v54)
                goto LABEL_99;
              v55 = (_QWORD *)v52;
              do
              {
                v56 = v53[4];
                v57 = v56 >= 0xC00000000000000BLL;
                if (v56 >= 0xC00000000000000BLL)
                  v58 = v53;
                else
                  v58 = v53 + 1;
                if (v57)
                  v55 = v53;
                v53 = (_QWORD *)*v58;
              }
              while (*v58);
              if (v55 != (_QWORD *)v52 && v55[4] <= 0xC00000000000000BLL && v55[6] == 2)
              {
                v59 = bswap32(*(unsigned __int16 *)v55[5]) >> 16;
                if (v59 != 13260)
                {
                  if (v59 == 52275)
                  {
                    v60 = 0;
                    v61 = 3;
                  }
                  else if (v59 == 42405)
                  {
                    v60 = 0;
                    v61 = 2;
                  }
                  else
                  {
                    v61 = 0;
                    v60 = 0;
                  }
                  goto LABEL_115;
                }
                v62 = caulk::expected<std::map<unsigned long long,DERItem>,SLAM::Error>::value((uint64_t)&v71);
                v65 = *(_QWORD **)(v62 + 8);
                v63 = v62 + 8;
                v64 = v65;
                if (v65)
                {
                  v66 = (_QWORD *)v63;
                  do
                  {
                    v67 = v64[4];
                    v68 = v67 >= 0x8000000000000002;
                    if (v67 >= 0x8000000000000002)
                      v69 = v64;
                    else
                      v69 = v64 + 1;
                    if (v68)
                      v66 = v64;
                    v64 = (_QWORD *)*v69;
                  }
                  while (*v69);
                  if (v66 != (_QWORD *)v63 && v66[4] <= 0x8000000000000002 && v66[6] == 8)
                  {
                    v60 = bswap64(*(_QWORD *)v66[5]);
                    v61 = 4;
LABEL_115:
                    *(_QWORD *)a2 = v60;
                    *(_DWORD *)(a2 + 8) = v61;
                    *(_DWORD *)(a2 + 12) = 0;
                    goto LABEL_80;
                  }
                }
                SLAM::Error::Unexpected((SLAM::Error *)"Missing or wrong length tag 0x%llx", (uint64_t)&v78, 0x8000000000000002);
              }
              else
              {
LABEL_99:
                SLAM::Error::Unexpected((SLAM::Error *)"Missing or wrong length tag 0x%llx", (uint64_t)&v78, 0xC00000000000000BLL);
              }
            }
            else
            {
LABEL_81:
              SLAM::Error::Unexpected((SLAM::Error *)"Missing or wrong length tag 0x%llx", (uint64_t)&v78, 0xC000000000000009);
            }
LABEL_63:
            *(std::string *)a2 = v78;
            memset(&v78, 0, sizeof(v78));
            *(_BYTE *)(a2 + 48) = 0;
            v70.__r_.__value_.__r.__words[0] = (std::string::size_type)&v78;
            std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v70);
            if ((_QWORD)v18)
              operator delete((void *)v18);
            goto LABEL_58;
          }
        }
        SLAM::Error::Unexpected((SLAM::Error *)"Missing or wrong length tag 0x%llx", (uint64_t)&v78, 0x8000000000000003);
        *(std::string *)a2 = v78;
        memset(&v78, 0, sizeof(v78));
        *(_BYTE *)(a2 + 48) = 0;
      }
      else
      {
        v41 = (__int128 **)SLAM::Error::Add((std::vector<std::string> *)&v71, "While parsing the respons from SLAM state");
        memset(&v78, 0, sizeof(v78));
        std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v78, *v41, v41[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v41[1] - (char *)*v41) >> 3));
        SLAM::Error::Unexpected((__int128 **)&v78, &v70);
        *(std::string *)a2 = v70;
        memset(&v70, 0, sizeof(v70));
        *(_BYTE *)(a2 + 48) = 0;
        v77 = &v70;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v77);
      }
      v70.__r_.__value_.__r.__words[0] = (std::string::size_type)&v78;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v70);
LABEL_58:
      caulk::__expected_detail::base<std::map<unsigned long long,DERItem>,SLAM::Error>::~base((uint64_t)&v71);
      goto LABEL_59;
    }
    v38 = (__int128 **)SLAM::Error::Add(&v75, "While querying migration state");
    SLAM::Error::Unexpected(v38, &__p);
  }
  else
  {
    v37 = (__int128 **)SLAM::Error::Add(&v75, "While selecting ISD");
    SLAM::Error::Unexpected(v37, &__p);
  }
  *(std::string *)a2 = __p;
  memset(&__p, 0, sizeof(__p));
  *(_BYTE *)(a2 + 48) = 0;
  v79.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v79);
  return caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v75);
}

void sub_21CC898B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  void *v24;
  uint64_t v25;

  if (v24)
    operator delete(v24);
  caulk::__expected_detail::base<std::map<unsigned long long,DERItem>,SLAM::Error>::~base((uint64_t)&__p);
  caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base(v25 - 88);
  caulk::__expected_detail::base<std::map<unsigned long long,DERItem>,SLAM::Error>::~base((uint64_t)&a19);
  caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&a24);
  _Unwind_Resume(a1);
}

uint64_t caulk::expected<SLAM::Script,SLAM::Error>::value(uint64_t result)
{
  __int128 **v1;
  void *exception;
  std::string v3;

  v1 = (__int128 **)result;
  if (!*(_BYTE *)(result + 72))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    memset(&v3, 0, sizeof(v3));
    std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v3, *v1, v1[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v1[1] - (char *)*v1) >> 3));
    caulk::bad_expected_access<SLAM::Error>::bad_expected_access((uint64_t)exception, (__int128 **)&v3);
  }
  return result;
}

void sub_21CC89A4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t caulk::expected<SLAM::MigrationInfo,SLAM::Error>::value(uint64_t result)
{
  __int128 **v1;
  void *exception;
  std::string v3;

  v1 = (__int128 **)result;
  if (!*(_BYTE *)(result + 48))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    memset(&v3, 0, sizeof(v3));
    std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v3, *v1, v1[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v1[1] - (char *)*v1) >> 3));
    caulk::bad_expected_access<SLAM::Error>::bad_expected_access((uint64_t)exception, (__int128 **)&v3);
  }
  return result;
}

void sub_21CC89B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t SLAM::Impl::GetChipId@<X0>(SLAM::Impl *this@<X0>, uint64_t a2@<X8>)
{
  void (***v4)(__int128 *__return_ptr);
  char *v5;
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  __int128 **v9;
  void *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  char v16;
  __int128 v18;
  uint64_t v19;
  _QWORD v20[2];
  void *p_p;
  _BYTE *v22;
  unint64_t v23;
  std::string __p;
  char v25;
  std::vector<std::string> v26;
  char v27;
  void **v28;

  v4 = (void (***)(__int128 *__return_ptr))((char *)this + 8);
  v5 = (char *)operator new(0xEuLL);
  __p.__r_.__value_.__l.__size_ = (std::string::size_type)(v5 + 14);
  __p.__r_.__value_.__r.__words[2] = (std::string::size_type)(v5 + 14);
  *(_QWORD *)v5 = 0xA0080004A400;
  *((_WORD *)v5 + 4) = 20737;
  *(_DWORD *)(v5 + 10) = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v5;
  SLAM::TransceiverWrapper::TransceiveAndCheckSW(v4, (uint64_t)&v26);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v27)
  {
    v6 = (char *)operator new(5uLL);
    v22 = v6 + 5;
    v23 = (unint64_t)(v6 + 5);
    *(_DWORD *)v6 = 2141178496;
    v6[4] = 0;
    p_p = v6;
    SLAM::TransceiverWrapper::TransceiveAndCheckSW(v4, (uint64_t)&__p);
    if (p_p)
    {
      v22 = p_p;
      operator delete(p_p);
    }
    if (v25)
    {
      p_p = 0;
      v22 = 0;
      v23 = 0;
      v20[0] = *(_QWORD *)caulk::expected<std::vector<unsigned char>,SLAM::Error>::value((uint64_t)&__p);
      v7 = (_QWORD *)caulk::expected<std::vector<unsigned char>,SLAM::Error>::value((uint64_t)&__p);
      v20[1] = v7[1] - *v7;
      v8 = DERDecodeItem((uint64_t)v20, (unint64_t *)&p_p);
      if ((_DWORD)v8)
      {
        SLAM::Error::Unexpected((SLAM::Error *)"Failed to decode CPLC data top level tag %d", (uint64_t)&v18, v8);
LABEL_24:
        *(_OWORD *)a2 = v18;
        *(_QWORD *)(a2 + 16) = v19;
        v19 = 0;
        v18 = 0uLL;
        *(_BYTE *)(a2 + 24) = 0;
        v28 = (void **)&v18;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v28);
        goto LABEL_25;
      }
      if (p_p != (void *)0x800000000000007FLL)
      {
        SLAM::Error::Unexpected((SLAM::Error *)"Unexpected CPLC data top level tag %llu", (uint64_t)&v18, p_p);
        goto LABEL_24;
      }
      if (v23 <= 3)
      {
        SLAM::Error::Unexpected((SLAM::Error *)"Unexpected length for CPLC data %zu", (uint64_t)&v18, v23);
        goto LABEL_24;
      }
      v16 = v22[3];
    }
    else
    {
      v10 = (void *)*((_QWORD *)this + 8);
      v11 = (std::__shared_weak_count *)*((_QWORD *)this + 9);
      p_p = v10;
      v22 = v11;
      if (v11)
      {
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
      }
      SLAM::Logger::Log((uint64_t)v10, 1, (uint64_t)"GetChipId", 477, "Failed to read CPLC data; defaulting to SN210V");
      if (v11)
      {
        v14 = (unint64_t *)&v11->__shared_owners_;
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
      v16 = -46;
    }
    *(_BYTE *)a2 = v16;
    *(_BYTE *)(a2 + 24) = 1;
LABEL_25:
    caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&__p);
    return caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v26);
  }
  v9 = (__int128 **)SLAM::Error::Add(&v26, "Failed to select ISD");
  SLAM::Error::Unexpected(v9, &__p);
  *(std::string *)a2 = __p;
  memset(&__p, 0, sizeof(__p));
  *(_BYTE *)(a2 + 24) = 0;
  p_p = &__p;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&p_p);
  return caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v26);
}

void sub_21CC89DF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19)
{
  uint64_t v19;

  caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&a19);
  caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base(v19 - 72);
  _Unwind_Resume(a1);
}

void sub_21CC89E50(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p)
    operator delete(__p);
  JUMPOUT(0x21CC89E48);
}

uint64_t caulk::expected<unsigned char,SLAM::Error>::value(uint64_t result)
{
  __int128 **v1;
  void *exception;
  std::string v3;

  v1 = (__int128 **)result;
  if (!*(_BYTE *)(result + 24))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    memset(&v3, 0, sizeof(v3));
    std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v3, *v1, v1[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v1[1] - (char *)*v1) >> 3));
    caulk::bad_expected_access<SLAM::Error>::bad_expected_access((uint64_t)exception, (__int128 **)&v3);
  }
  return result;
}

void sub_21CC89F00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void SLAM::Logger::Log(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char *a5, ...)
{
  void **v9;
  void (***v10)(_QWORD, std::string *);
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __s;
  void *__p[2];
  char v18;
  va_list v19;
  va_list va;

  va_start(va, a5);
  va_copy(v19, va);
  __s.__r_.__value_.__r.__words[0] = 0;
  vasprintf(&__s.__r_.__value_.__l.__data_, a5, va);
  if (__s.__r_.__value_.__r.__words[0])
  {
    std::string::basic_string[abi:ne180100]<0>(__p, __s.__r_.__value_.__l.__data_);
    free(__s.__r_.__value_.__l.__data_);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "<FAILED TO VASPRINTF>");
  }
  v9 = __p;
  if (v18 < 0)
    v9 = (void **)__p[0];
  SLAM::StringUtil::Format((SLAM::StringUtil *)"%s/%d : %s", &__s, a3, a4, v9);
  boost::circular_buffer<std::string,std::allocator<std::string>>::push_back_impl<std::string const&>(a1 + 16, &__s);
  if (a2 == 1)
  {
    v10 = *(void (****)(_QWORD, std::string *))a1;
    v11 = *(std::__shared_weak_count **)(a1 + 8);
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    (**v10)(v10, &__s);
    if (v11)
    {
      v14 = (unint64_t *)&v11->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__s.__r_.__value_.__l.__data_);
  if (v18 < 0)
    operator delete(__p[0]);
}

void sub_21CC8A084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  if (a19 < 0)
    operator delete(__p);
  if (a25 < 0)
    operator delete(a20);
  _Unwind_Resume(a1);
}

void SLAM::Impl::PerformScript(std::string::size_type a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  std::string::size_type v5;
  uint64_t v6;
  const void *v10;
  size_t v11;
  const void *v12;
  int v13;
  void **v14;
  void **v15;
  const char *p_p;
  __int128 **v17;
  std::string v18;
  char v19;
  void *__p;
  char v21;
  void *v22[2];
  char v23;
  __int128 v24;
  std::string::size_type v25;
  char v26;
  std::string *v27;

  v5 = *a2;
  v18.__r_.__value_.__r.__words[0] = a1;
  v18.__r_.__value_.__l.__size_ = a1;
  v18.__r_.__value_.__r.__words[2] = v5;
  v6 = *(unsigned int *)(a3 + 8);
  if ((_DWORD)v6 == -1)
    std::__throw_bad_variant_access[abi:ne180100]();
  v22[0] = &v18;
  ((void (*)(__int128 *__return_ptr, void **, uint64_t))off_24E0BF330[v6])(&v24, v22, a3);
  if (v26)
  {
    *(_OWORD *)&a4->__r_.__value_.__l.__data_ = v24;
    a4->__r_.__value_.__r.__words[2] = v25;
    v25 = 0;
    v24 = 0uLL;
    a4[1].__r_.__value_.__s.__data_[0] = 1;
  }
  else
  {
    v10 = *(const void **)(a3 + 16);
    v11 = *(_QWORD *)(a3 + 24) - (_QWORD)v10;
    v12 = (const void *)a2[1];
    if (v11 == a2[2] - (_QWORD)v12 && !memcmp(v10, v12, v11))
    {
      SLAM::Impl::ExecuteScript(a1, a2 + 5, &v18);
      if (v19)
      {
        v17 = (__int128 **)SLAM::Error::Add((std::vector<std::string> *)&v18, "While executing script 0x%llx", v5);
        a4->__r_.__value_.__r.__words[0] = 0;
        a4->__r_.__value_.__l.__size_ = 0;
        a4->__r_.__value_.__r.__words[2] = 0;
        std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(a4, *v17, v17[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v17[1] - (char *)*v17) >> 3));
        a4[1].__r_.__value_.__s.__data_[0] = 1;
        if (v19)
        {
          v22[0] = &v18;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)v22);
        }
      }
      else
      {
        a4->__r_.__value_.__s.__data_[0] = 0;
        a4[1].__r_.__value_.__s.__data_[0] = 0;
      }
    }
    else
    {
      ctu::hex();
      v13 = v23;
      v14 = (void **)v22[0];
      ctu::hex();
      v15 = v22;
      if (v13 < 0)
        v15 = v14;
      if (v21 >= 0)
        p_p = (const char *)&__p;
      else
        p_p = (const char *)__p;
      SLAM::Error::Error((std::vector<std::string> *)&v18, "Mismatched signing keys device %s script %s", (const char *)v15, p_p);
      *a4 = v18;
      memset(&v18, 0, sizeof(v18));
      a4[1].__r_.__value_.__s.__data_[0] = 1;
      v27 = &v18;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
      if (v21 < 0)
        operator delete(__p);
      if (v23 < 0)
        operator delete(v22[0]);
    }
  }
  if (v26)
  {
    v18.__r_.__value_.__r.__words[0] = (std::string::size_type)&v24;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v18);
  }
}

void sub_21CC8A2D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char *a11, uint64_t a12, uint64_t a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,char a30)
{
  if (a30)
  {
    a11 = &a27;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SLAM::Impl::ExecuteScript@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  std::__shared_weak_count *v16;
  void **v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::vector<std::string>::pointer p_p;
  unint64_t *v21;
  unint64_t v22;
  __int128 **v23;
  std::vector<std::string> __p;
  void **v25[2];
  std::vector<std::string> v26;
  char v27;

  v4 = *a2;
  v5 = a2[1];
  if (v5 != *a2)
  {
    v7 = result;
    LODWORD(v8) = 0;
    v9 = (v5 - *a2) >> 3;
    v10 = (_QWORD *)(result + 8);
    do
    {
      v11 = 0;
      while (1)
      {
        SLAM::TransceiverWrapper::Transceive(v10, v4, (uint64_t)&v26);
        if (!v27)
        {
          v23 = (__int128 **)SLAM::Error::Add(&v26, "While executing APDU %d", v11);
          a3->__r_.__value_.__r.__words[0] = 0;
          a3->__r_.__value_.__l.__size_ = 0;
          a3->__r_.__value_.__r.__words[2] = 0;
          std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(a3, *v23, v23[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v23[1] - (char *)*v23) >> 3));
          a3[1].__r_.__value_.__s.__data_[0] = 1;
          return caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v26);
        }
        v12 = (_QWORD *)caulk::expected<std::vector<unsigned char>,SLAM::Error>::value((uint64_t)&v26);
        v13 = v12[1];
        if ((unint64_t)(v13 - *v12) < 2)
        {
          v15 = 49068;
LABEL_27:
          SLAM::Error::Error(&__p, "Failed SW 0x%hX at idx %d", v15, v11);
          *(std::vector<std::string> *)a3 = __p;
          memset(&__p, 0, sizeof(__p));
          a3[1].__r_.__value_.__s.__data_[0] = 1;
          v25[0] = (void **)&__p;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](v25);
          return caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v26);
        }
        v14 = *(unsigned __int16 *)(v13 - 2);
        v15 = __rev16(v14);
        if ((v15 & 0xFFF0) == 0x63C0)
        {
          v8 = (v8 + 1);
          if (v9 > v8)
            break;
        }
        if (v14 != 144)
          goto LABEL_27;
        result = caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v26);
        v4 += 24;
        ++v11;
        if (v4 == v5)
          goto LABEL_24;
      }
      v17 = *(void ***)(v7 + 64);
      v16 = *(std::__shared_weak_count **)(v7 + 72);
      v25[0] = v17;
      v25[1] = (void **)&v16->__vftable;
      if (v16)
      {
        p_shared_owners = (unint64_t *)&v16->__shared_owners_;
        do
          v19 = __ldxr(p_shared_owners);
        while (__stxr(v19 + 1, p_shared_owners));
      }
      caulk::expected<std::vector<unsigned char>,SLAM::Error>::value((uint64_t)&v26);
      ctu::hex();
      p_p = (std::vector<std::string>::pointer)&__p;
      if (SHIBYTE(__p.__end_cap_.__value_) < 0)
        p_p = __p.__begin_;
      SLAM::Logger::Log((uint64_t)v17, 1, (uint64_t)"ExecuteScript", 292, "Warning APDU: %s idx %d replaying %d", (const char *)p_p, v11, v8);
      if (SHIBYTE(__p.__end_cap_.__value_) < 0)
        operator delete(__p.__begin_);
      if (v16)
      {
        v21 = (unint64_t *)&v16->__shared_owners_;
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      result = caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v26);
      v4 = *a2;
      v5 = a2[1];
    }
    while (*a2 != v5);
  }
LABEL_24:
  a3->__r_.__value_.__s.__data_[0] = 0;
  a3[1].__r_.__value_.__s.__data_[0] = 0;
  return result;
}

void sub_21CC8A598(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21,char a22)
{
  if (a18 < 0)
    operator delete(__p);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a20);
  caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void SLAM::TransceiverWrapper::Transceive(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  void **v10;
  unint64_t *v11;
  unint64_t v12;
  void (***v13)(void *, uint64_t);
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  void **v23;
  unint64_t *v24;
  unint64_t v25;
  void *__p[2];
  char v27;
  uint64_t v28;
  std::__shared_weak_count *v29;

  v7 = a1[3];
  v6 = (std::__shared_weak_count *)a1[4];
  v28 = v7;
  v29 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  ctu::hex();
  if (v27 >= 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  SLAM::Logger::Log(v7, 0, (uint64_t)"Transceive", 49, "> %s", (const char *)v10);
  if (v27 < 0)
    operator delete(__p[0]);
  if (v6)
  {
    v11 = (unint64_t *)&v6->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v13 = (void (***)(void *, uint64_t))a1[1];
  v14 = (std::__shared_weak_count *)a1[2];
  __p[0] = v13;
  __p[1] = v14;
  if (v14)
  {
    v15 = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  (**v13)(v13, a2);
  if (v14)
  {
    v17 = (unint64_t *)&v14->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  if (*(_BYTE *)(a3 + 24))
  {
    v20 = a1[3];
    v19 = (std::__shared_weak_count *)a1[4];
    v28 = v20;
    v29 = v19;
    if (v19)
    {
      v21 = (unint64_t *)&v19->__shared_owners_;
      do
        v22 = __ldxr(v21);
      while (__stxr(v22 + 1, v21));
    }
    caulk::expected<std::vector<unsigned char>,SLAM::Error>::value(a3);
    ctu::hex();
    if (v27 >= 0)
      v23 = __p;
    else
      v23 = (void **)__p[0];
    SLAM::Logger::Log(v20, 0, (uint64_t)"Transceive", 54, "< %s", (const char *)v23);
    if (v27 < 0)
      operator delete(__p[0]);
    if (v19)
    {
      v24 = (unint64_t *)&v19->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
}

void sub_21CC8A7DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  uint64_t v16;

  if (a15 < 0)
    operator delete(__p);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base(v16);
  _Unwind_Resume(a1);
}

uint64_t caulk::expected<std::vector<unsigned char>,SLAM::Error>::value(uint64_t result)
{
  __int128 **v1;
  void *exception;
  std::string v3;

  v1 = (__int128 **)result;
  if (!*(_BYTE *)(result + 24))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    memset(&v3, 0, sizeof(v3));
    std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v3, *v1, v1[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v1[1] - (char *)*v1) >> 3));
    caulk::bad_expected_access<SLAM::Error>::bad_expected_access((uint64_t)exception, (__int128 **)&v3);
  }
  return result;
}

void sub_21CC8A8E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t SLAM::Impl::PerformTermination@<X0>(SLAM::Impl *this@<X0>, std::string *a2@<X8>)
{
  void (***v3)(__int128 *__return_ptr);
  char v4;
  __int128 **v5;
  _DWORD *__p;
  std::vector<std::string> v8;
  char v9;

  v3 = (void (***)(__int128 *__return_ptr))((char *)this + 8);
  __p = operator new(4uLL);
  *__p = 371328;
  SLAM::TransceiverWrapper::TransceiveAndCheckSW(v3, (uint64_t)&v8);
  if (__p)
    operator delete(__p);
  if (v9)
  {
    v4 = 0;
    a2->__r_.__value_.__s.__data_[0] = 0;
  }
  else
  {
    v5 = (__int128 **)SLAM::Error::Add(&v8, "While terminating");
    a2->__r_.__value_.__r.__words[0] = 0;
    a2->__r_.__value_.__l.__size_ = 0;
    a2->__r_.__value_.__r.__words[2] = 0;
    std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(a2, *v5, v5[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v5[1] - (char *)*v5) >> 3));
    v4 = 1;
  }
  a2[1].__r_.__value_.__s.__data_[0] = v4;
  return caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v8);
}

void sub_21CC8A9E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t SLAM::TransceiverWrapper::TransceiveAndCheckSW@<X0>(void (***a1)(__int128 *__return_ptr)@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  char v14;
  void **v15;

  (**a1)(&v12);
  if (!v14)
  {
    *(_BYTE *)(a2 + 24) = 0;
    *(_OWORD *)a2 = v12;
    *(_QWORD *)(a2 + 16) = v13;
    v12 = 0uLL;
    v13 = 0;
    return caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v12);
  }
  v3 = (_QWORD *)caulk::expected<std::vector<unsigned char>,SLAM::Error>::value((uint64_t)&v12);
  v4 = v3[1];
  if ((unint64_t)(v4 - *v3) < 2)
  {
    v7 = 49068;
LABEL_9:
    SLAM::Error::Unexpected((SLAM::Error *)"Unexpected SW 0x%hX", (uint64_t)&v10, v7);
    *(_OWORD *)a2 = v10;
    *(_QWORD *)(a2 + 16) = v11;
    v11 = 0;
    v10 = 0uLL;
    *(_BYTE *)(a2 + 24) = 0;
    v15 = (void **)&v10;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v15);
    return caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v12);
  }
  v5 = *(unsigned __int16 *)(v4 - 2);
  if (v5 != 144)
  {
    v7 = __rev16(v5);
    goto LABEL_9;
  }
  v6 = v12;
  if (*((_QWORD *)&v12 + 1) - (_QWORD)v12 > 1uLL)
  {
    *((_QWORD *)&v12 + 1) -= 2;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)&v12, 0xFFFFFFFFFFFFFFFELL);
    v6 = v12;
  }
  *(_BYTE *)(a2 + 24) = v14;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = v6;
  v8 = v13;
  *(_QWORD *)(a2 + 8) = *((_QWORD *)&v12 + 1);
  *(_QWORD *)(a2 + 16) = v8;
  v13 = 0;
  v12 = 0uLL;
  return caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)&v12);
}

void sub_21CC8AB3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base((uint64_t)va);
  _Unwind_Resume(a1);
}

void SLAM::Error::Unexpected(__int128 **this@<X0>, std::string *a2@<X8>)
{
  std::string v4;
  std::string *v5;

  memset(&v4, 0, sizeof(v4));
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v4, *this, this[1], 0xAAAAAAAAAAAAAAABLL * (((char *)this[1] - (char *)*this) >> 3));
  *a2 = v4;
  memset(&v4, 0, sizeof(v4));
  v5 = &v4;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v5);
}

void SLAM::DERParseSequenceToMap(unint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[5];
  unint64_t v12;
  __int128 v13;
  _QWORD *(*v14)(_QWORD *, _QWORD *);
  void (*v15)(uint64_t);
  _QWORD **v16;
  _QWORD *v17[2];
  __int128 v18;
  uint64_t v19;
  unint64_t v20[3];
  void **v21;

  v5 = a1[1] - *a1;
  v20[0] = *a1;
  v20[1] = v5;
  if (a3)
  {
    v7 = 8 * a3;
    while (1)
    {
      v12 = 0;
      v13 = 0uLL;
      v8 = DERDecodeItem((uint64_t)v20, &v12);
      v9 = *a2;
      if ((_DWORD)v8 || v12 != v9)
        break;
      *(_OWORD *)v20 = v13;
      ++a2;
      v7 -= 8;
      if (!v7)
        goto LABEL_6;
    }
    SLAM::Error::Unexpected((SLAM::Error *)"Failed to decode ret %d tag 0x%llx exoected 0x%llx", (uint64_t)&v18, v8, v12, v9);
    *(_OWORD *)a4 = v18;
    *(_QWORD *)(a4 + 16) = v19;
    v19 = 0;
    v18 = 0uLL;
    *(_BYTE *)(a4 + 24) = 0;
    v21 = (void **)&v18;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v21);
  }
  else
  {
LABEL_6:
    v12 = 0;
    *(_QWORD *)&v13 = &v12;
    *((_QWORD *)&v13 + 1) = 0x4002000000;
    v14 = __Block_byref_object_copy_;
    v15 = __Block_byref_object_dispose_;
    v17[1] = 0;
    v16 = v17;
    v17[0] = 0;
    v11[0] = MEMORY[0x24BDAC760];
    v11[1] = 0x40000000;
    v11[2] = ___ZN4SLAML21DERParseSequenceToMapERNSt3__16vectorIhNS0_9allocatorIhEEEESt16initializer_listIyE_block_invoke;
    v11[3] = &unk_24E0BF388;
    v11[4] = &v12;
    v10 = DERDecodeSequenceContentWithBlock(v20, (uint64_t)v11);
    if ((_DWORD)v10)
    {
      SLAM::Error::Unexpected((SLAM::Error *)"DecodeSequenceContent returned %d", (uint64_t)&v18, v10);
      *(_OWORD *)a4 = v18;
      *(_QWORD *)(a4 + 16) = v19;
      v19 = 0;
      v18 = 0uLL;
      *(_BYTE *)(a4 + 24) = 0;
      v21 = (void **)&v18;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v21);
    }
    else
    {
      std::map<unsigned long long,DERItem>::map[abi:ne180100](a4, v13 + 40);
      *(_BYTE *)(a4 + 24) = 1;
    }
    _Block_object_dispose(&v12, 8);
    std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::destroy((uint64_t)&v16, v17[0]);
  }
}

void sub_21CC8AD88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,_QWORD *a23)
{
  uint64_t v23;

  _Block_object_dispose(&a17, 8);
  std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::destroy(v23, a23);
  _Unwind_Resume(a1);
}

uint64_t caulk::expected<std::map<unsigned long long,DERItem>,SLAM::Error>::value(uint64_t result)
{
  __int128 **v1;
  void *exception;
  std::string v3;

  v1 = (__int128 **)result;
  if (!*(_BYTE *)(result + 24))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    memset(&v3, 0, sizeof(v3));
    std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v3, *v1, v1[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v1[1] - (char *)*v1) >> 3));
    caulk::bad_expected_access<SLAM::Error>::bad_expected_access((uint64_t)exception, (__int128 **)&v3);
  }
  return result;
}

void sub_21CC8AE48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void SLAM::Error::Unexpected(SLAM::Error *this@<X0>, uint64_t a2@<X8>, ...)
{
  char *__s[2];
  uint64_t v5;
  void *__p[2];
  char v7;
  va_list v8;
  char **v9;
  va_list va;

  va_start(va, a2);
  va_copy(v8, va);
  __s[0] = 0;
  vasprintf(__s, (const char *)this, va);
  if (__s[0])
  {
    std::string::basic_string[abi:ne180100]<0>(__p, __s[0]);
    free(__s[0]);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "<FAILED TO VASPRINTF>");
  }
  SLAM::Error::Error((std::string **)__s, (uint64_t)__p);
  *(_OWORD *)a2 = *(_OWORD *)__s;
  *(_QWORD *)(a2 + 16) = v5;
  __s[1] = 0;
  v5 = 0;
  __s[0] = 0;
  v9 = __s;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v9);
  if (v7 < 0)
    operator delete(__p[0]);
}

void sub_21CC8AF38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SLAM::Impl::~Impl(SLAM::Impl *this)
{
  SLAM::Impl::~Impl(this);
  JUMPOUT(0x22078A808);
}

{
  *(_QWORD *)this = &off_24E0BF1E0;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 64);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 48);
  *((_QWORD *)this + 1) = &off_24E0BF268;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 32);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 16);
}

uint64_t std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v)
{
  std::string *v4;
  std::string *begin;
  std::string *end;
  std::string *value;

  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

void std::vector<std::string>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
}

void sub_21CC8B094(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 24;
  }
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100]((uint64_t)this, (void **)&this->__begin_->__r_.__value_.__l.__data_);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

void std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

_QWORD *SLAM::Impl::Impl(_QWORD *a1, uint64_t *a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;

  *a1 = &off_24E0BF1E0;
  v7 = *a2;
  v8 = (std::__shared_weak_count *)a2[1];
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = *a3;
  v12 = (std::__shared_weak_count *)a3[1];
  if (v12)
  {
    v13 = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  a1[1] = &off_24E0BF268;
  a1[2] = v7;
  a1[3] = v8;
  if (v8)
  {
    v15 = (unint64_t *)&v8->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  a1[4] = v11;
  a1[5] = v12;
  if (!v12)
    goto LABEL_15;
  v17 = (unint64_t *)&v12->__shared_owners_;
  do
    v18 = __ldxr(v17);
  while (__stxr(v18 + 1, v17));
  do
    v19 = __ldaxr(v17);
  while (__stlxr(v19 - 1, v17));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    if (!v8)
      goto LABEL_21;
  }
  else
  {
LABEL_15:
    if (!v8)
      goto LABEL_21;
  }
  v20 = (unint64_t *)&v8->__shared_owners_;
  do
    v21 = __ldaxr(v20);
  while (__stlxr(v21 - 1, v20));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
LABEL_21:
  v22 = a4[1];
  a1[6] = *a4;
  a1[7] = v22;
  if (v22)
  {
    v23 = (unint64_t *)(v22 + 8);
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  v25 = a3[1];
  a1[8] = *a3;
  a1[9] = v25;
  if (v25)
  {
    v26 = (unint64_t *)(v25 + 8);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  return a1;
}

void SLAM::TransceiverWrapper::~TransceiverWrapper(SLAM::TransceiverWrapper *this)
{
  char *v1;

  *(_QWORD *)this = &off_24E0BF268;
  v1 = (char *)this + 8;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)v1);
}

{
  char *v1;

  *(_QWORD *)this = &off_24E0BF268;
  v1 = (char *)this + 8;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)v1);
  JUMPOUT(0x22078A808);
}

__n128 std::__optional_storage_base<SLAM::Error,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<SLAM::Error,false>>(std::vector<std::string> *this, uint64_t a2)
{
  __n128 result;
  std::vector<std::string> *v5;

  if (LOBYTE(this[1].__begin_) == *(unsigned __int8 *)(a2 + 24))
  {
    if (LOBYTE(this[1].__begin_))
    {
      std::vector<std::string>::__vdeallocate(this);
      result = *(__n128 *)a2;
      *(_OWORD *)&this->__begin_ = *(_OWORD *)a2;
      this->__end_cap_.__value_ = *(std::string **)(a2 + 16);
      *(_QWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
    }
  }
  else if (LOBYTE(this[1].__begin_))
  {
    v5 = this;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v5);
    LOBYTE(this[1].__begin_) = 0;
  }
  else
  {
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
    result = *(__n128 *)a2;
    *this = *(std::vector<std::string> *)a2;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    LOBYTE(this[1].__begin_) = 1;
  }
  return result;
}

void std::vector<std::string>::__vdeallocate(std::vector<std::string> *this)
{
  if (this->__begin_)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)this);
    operator delete(this->__begin_);
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
  }
}

std::string *ctu::join<std::__wrap_iter<std::string const*>>@<X0>(std::string *__str@<X0>, std::string *a2@<X1>, void *a3@<X2>, size_t a4@<X3>, std::string *a5@<X8>)
{
  std::string *v8;
  std::string *i;
  std::string::size_type v11;
  void **v12;
  std::string::size_type v13;
  void **p_p;
  std::string::size_type v15;
  int v16;
  const std::string::value_type *v17;
  std::string::size_type size;
  void *__p;
  std::string::size_type v20;
  uint64_t v21;

  a5->__r_.__value_.__r.__words[0] = 0;
  a5->__r_.__value_.__l.__size_ = 0;
  a5->__r_.__value_.__r.__words[2] = 0;
  if (__str != a2)
  {
    v8 = __str;
    __str = std::string::operator=(a5, __str);
    for (i = v8 + 1; i != a2; ++i)
    {
      if (a3)
      {
        std::string::basic_string[abi:ne180100](&__p, a3, a4);
        v11 = HIBYTE(v21);
        v12 = (void **)__p;
        v13 = v20;
      }
      else
      {
        v13 = 0;
        v12 = 0;
        v11 = 0;
        __p = 0;
        v20 = 0;
        v21 = 0;
      }
      if ((v11 & 0x80u) == 0)
        p_p = &__p;
      else
        p_p = v12;
      if ((v11 & 0x80u) == 0)
        v15 = v11;
      else
        v15 = v13;
      std::string::append(a5, (const std::string::value_type *)p_p, v15);
      if (SHIBYTE(v21) < 0)
        operator delete(__p);
      v16 = SHIBYTE(i->__r_.__value_.__r.__words[2]);
      if (v16 >= 0)
        v17 = (const std::string::value_type *)i;
      else
        v17 = (const std::string::value_type *)i->__r_.__value_.__r.__words[0];
      if (v16 >= 0)
        size = HIBYTE(i->__r_.__value_.__r.__words[2]);
      else
        size = i->__r_.__value_.__l.__size_;
      __str = std::string::append(a5, v17, size);
    }
  }
  return __str;
}

void sub_21CC8B83C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (*(char *)(v15 + 23) < 0)
    operator delete(*(void **)v15);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__dst, void *__src, size_t __len)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v6 = __dst;
    if (!__len)
      goto LABEL_9;
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

uint64_t std::for_each[abi:ne180100]<boost::cb_details::iterator<boost::circular_buffer<std::string,std::allocator<std::string>>,boost::cb_details::const_traits<std::allocator<std::string>>>,std::function<void ()(std::string const&)>>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;

  if (a2 != a3)
  {
    v8 = a2;
    do
    {
      v10 = *(_QWORD *)(a4 + 24);
      if (!v10)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 48))(v10, v8);
      v11 = v8 + 24;
      if (v8 + 24 == a1[1])
        v11 = *a1;
      if (v11 == a1[3])
        v8 = 0;
      else
        v8 = v11;
    }
    while (v8 != a3);
  }
  return std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100](a5, a4);
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x22078A808);
}

uint64_t std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

void caulk::bad_expected_access<SLAM::Error>::~bad_expected_access(std::exception *a1)
{
  std::exception *v2;

  a1->__vftable = (std::exception_vtbl *)off_24E0BF300;
  v2 = a1 + 1;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v2);
  std::exception::~exception(a1);
}

uint64_t caulk::bad_expected_access<SLAM::Error>::bad_expected_access(uint64_t a1, __int128 **a2)
{
  *(_QWORD *)a1 = off_24E0BF300;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>((std::string *)(a1 + 8), *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3));
  return a1;
}

void sub_21CC8BB0C(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

uint64_t caulk::bad_expected_access<SLAM::Error>::~bad_expected_access(std::exception *a1)
{
  std::exception *v3;

  a1->__vftable = (std::exception_vtbl *)off_24E0BF300;
  v3 = a1 + 1;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v3);
  std::exception::~exception(a1);
  return MEMORY[0x22078A808]();
}

uint64_t caulk::__expected_detail::base<SLAM::MigrationInfo,SLAM::Error>::~base(uint64_t a1)
{
  void *v2;
  void **v4;

  if (*(_BYTE *)(a1 + 48))
  {
    v2 = *(void **)(a1 + 16);
    if (v2)
    {
      *(_QWORD *)(a1 + 24) = v2;
      operator delete(v2);
    }
  }
  else
  {
    v4 = (void **)a1;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v4);
  }
  return a1;
}

uint64_t caulk::__expected_detail::base<SLAM::Script,SLAM::Error>::~base(uint64_t a1)
{
  void **v3;

  if (*(_BYTE *)(a1 + 72))
  {
    caulk::__expected_detail::destroy<SLAM::Script,(void *)0>(a1);
  }
  else
  {
    v3 = (void **)a1;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  return a1;
}

void caulk::__expected_detail::destroy<SLAM::Script,(void *)0>(uint64_t a1)
{
  void *v2;
  void **v3;

  v3 = (void **)(a1 + 40);
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<unsigned char>>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::vector<unsigned char>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 24);
      v4 -= 24;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 16) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

std::string *std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(std::string *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  std::string *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>((uint64_t)&v6->__r_.__value_.__r.__words[2], a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

void sub_21CC8BD54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<std::string>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<std::string>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(uint64_t a1, __int128 *a2, __int128 *a3, std::string *this)
{
  std::string *v4;
  __int128 *v6;
  __int128 v7;
  _QWORD v9[3];
  char v10;
  std::string *v11;
  std::string *v12;

  v4 = this;
  v11 = this;
  v12 = this;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
        v4 = v12;
      }
      else
      {
        v7 = *v6;
        v4->__r_.__value_.__r.__words[2] = *((_QWORD *)v6 + 2);
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
      }
      v6 = (__int128 *)((char *)v6 + 24);
      v12 = ++v4;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_21CC8BE6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 1) < 0)
      operator delete(*(void **)(v1 - 24));
    v1 -= 24;
  }
}

void SLAM::StringUtil::Format(SLAM::StringUtil *this@<X0>, _QWORD *a2@<X8>, ...)
{
  char *__s;
  va_list va;

  va_start(va, a2);
  __s = 0;
  vasprintf(&__s, (const char *)this, va);
  if (__s)
  {
    std::string::basic_string[abi:ne180100]<0>(a2, __s);
    free(__s);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(a2, "<FAILED TO VASPRINTF>");
  }
}

void boost::circular_buffer<std::string,std::allocator<std::string>>::push_back_impl<std::string const&>(uint64_t a1, const std::string *a2)
{
  uint64_t v3;
  uint64_t v4;
  std::string *v5;
  __int128 v6;
  uint64_t v7;

  v3 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v3 - *(_QWORD *)a1) >> 3) == *(_QWORD *)(a1 + 32))
  {
    if (v3 != *(_QWORD *)a1)
    {
      std::string::operator=(*(std::string **)(a1 + 24), a2);
      v4 = *(_QWORD *)(a1 + 24) + 24;
      *(_QWORD *)(a1 + 24) = v4;
      if (v4 == *(_QWORD *)(a1 + 8))
      {
        v4 = *(_QWORD *)a1;
        *(_QWORD *)(a1 + 24) = *(_QWORD *)a1;
      }
      *(_QWORD *)(a1 + 16) = v4;
    }
  }
  else
  {
    v5 = *(std::string **)(a1 + 24);
    if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(v5, a2->__r_.__value_.__l.__data_, a2->__r_.__value_.__l.__size_);
    }
    else
    {
      v6 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
      v5->__r_.__value_.__r.__words[2] = a2->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
    }
    v7 = *(_QWORD *)(a1 + 24) + 24;
    *(_QWORD *)(a1 + 24) = v7;
    if (v7 == *(_QWORD *)(a1 + 8))
      *(_QWORD *)(a1 + 24) = *(_QWORD *)a1;
    ++*(_QWORD *)(a1 + 32);
  }
}

void std::__throw_bad_variant_access[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x24BEDB8D8] + 16;
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_0,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_1,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_2,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_3,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,SLAM::MigrationInfo::Idle,SLAM::MigrationInfo::SecureChannel,SLAM::MigrationInfo::Termination,SLAM::MigrationInfo::SLAM> const&>(uint64_t a1@<X8>)
{
  std::vector<std::string> v2;
  std::vector<std::string> *v3;

  SLAM::Error::Error(&v2, "Cannot proceed in OSU state");
  *(std::vector<std::string> *)a1 = v2;
  memset(&v2, 0, sizeof(v2));
  *(_BYTE *)(a1 + 24) = 1;
  v3 = &v2;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v3);
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_0,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_1,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_2,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_3,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,SLAM::MigrationInfo::Idle,SLAM::MigrationInfo::SecureChannel,SLAM::MigrationInfo::Termination,SLAM::MigrationInfo::SLAM> const&>(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[24] = 0;
}

void std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_0,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_1,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_2,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_3,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,SLAM::MigrationInfo::Idle,SLAM::MigrationInfo::SecureChannel,SLAM::MigrationInfo::Termination,SLAM::MigrationInfo::SLAM> const&>(uint64_t a1@<X8>)
{
  std::vector<std::string> v2;
  std::vector<std::string> *v3;

  SLAM::Error::Error(&v2, "Cannot proceed in SC state");
  *(std::vector<std::string> *)a1 = v2;
  memset(&v2, 0, sizeof(v2));
  *(_BYTE *)(a1 + 24) = 1;
  v3 = &v2;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v3);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_0,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_1,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_2,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_3,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,SLAM::MigrationInfo::Idle,SLAM::MigrationInfo::SecureChannel,SLAM::MigrationInfo::Termination,SLAM::MigrationInfo::SLAM> const&>@<X0>(SLAM::Impl ***a1@<X0>, std::string *a2@<X8>)
{
  SLAM::Impl *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v3 = **a1;
  v4 = *((_QWORD *)v3 + 8);
  v5 = (std::__shared_weak_count *)*((_QWORD *)v3 + 9);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  SLAM::Logger::Log(v4, 1, (uint64_t)"operator()", 198, "Recovering incomplete termination");
  if (v5)
  {
    v8 = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return SLAM::Impl::PerformTermination(v3, a2);
}

void sub_21CC8C1DC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_0,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_1,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_2,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_3,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,SLAM::MigrationInfo::Idle,SLAM::MigrationInfo::SecureChannel,SLAM::MigrationInfo::Termination,SLAM::MigrationInfo::SLAM> const&>();
  _Unwind_Resume(exception_object);
}

void std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_0,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_1,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_2,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_3,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,SLAM::MigrationInfo::Idle,SLAM::MigrationInfo::SecureChannel,SLAM::MigrationInfo::Termination,SLAM::MigrationInfo::SLAM> const&>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  SLAM::Impl *v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v4 = *a1;
  v6 = *(SLAM::Impl **)(*a1 + 8);
  v5 = *(_QWORD *)(*a1 + 16);
  v7 = *a2;
  v8 = *((_QWORD *)v6 + 8);
  v9 = (std::__shared_weak_count *)*((_QWORD *)v6 + 9);
  if (v5 == *a2)
  {
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
      v5 = *(_QWORD *)(v4 + 16);
    }
    SLAM::Logger::Log(v8, 1, (uint64_t)"operator()", 211, "Resuming interrupted script 0x%llx", v5);
    if (v9)
    {
      v12 = (unint64_t *)&v9->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
LABEL_21:
    a3->__r_.__value_.__s.__data_[0] = 0;
    a3[1].__r_.__value_.__s.__data_[0] = 0;
    return;
  }
  if (v9)
  {
    v14 = (unint64_t *)&v9->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    v7 = *a2;
    v5 = *(_QWORD *)(v4 + 16);
  }
  SLAM::Logger::Log(v8, 1, (uint64_t)"operator()", 206, "Recover interrupted script 0x%llx before running 0x%llx", v7, v5);
  if (v9)
  {
    v16 = (unint64_t *)&v9->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  SLAM::Impl::PerformRecovery(v6, a3);
  if (!a3[1].__r_.__value_.__s.__data_[0])
    goto LABEL_21;
}

void sub_21CC8C33C(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformRecovery(void)::$_0,SLAM::Impl::PerformRecovery(void)::$_1,SLAM::Impl::PerformRecovery(void)::$_2,SLAM::Impl::PerformRecovery(void)::$_3,SLAM::Impl::PerformRecovery(void)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,std::__variant_detail::_Trait::Idle,std::__variant_detail::_Trait::SecureChannel,std::__variant_detail::_Trait::Termination,std::__variant_detail::_Trait::SLAM> const&>(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[24] = 0;
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformRecovery(void)::$_0,SLAM::Impl::PerformRecovery(void)::$_1,SLAM::Impl::PerformRecovery(void)::$_2,SLAM::Impl::PerformRecovery(void)::$_3,SLAM::Impl::PerformRecovery(void)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,std::__variant_detail::_Trait::Idle,std::__variant_detail::_Trait::SecureChannel,std::__variant_detail::_Trait::Termination,std::__variant_detail::_Trait::SLAM> const&>(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[24] = 0;
}

void std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformRecovery(void)::$_0,SLAM::Impl::PerformRecovery(void)::$_1,SLAM::Impl::PerformRecovery(void)::$_2,SLAM::Impl::PerformRecovery(void)::$_3,SLAM::Impl::PerformRecovery(void)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,std::__variant_detail::_Trait::Idle,std::__variant_detail::_Trait::SecureChannel,std::__variant_detail::_Trait::Termination,std::__variant_detail::_Trait::SLAM> const&>(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[24] = 0;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformRecovery(void)::$_0,SLAM::Impl::PerformRecovery(void)::$_1,SLAM::Impl::PerformRecovery(void)::$_2,SLAM::Impl::PerformRecovery(void)::$_3,SLAM::Impl::PerformRecovery(void)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,std::__variant_detail::_Trait::Idle,std::__variant_detail::_Trait::SecureChannel,std::__variant_detail::_Trait::Termination,std::__variant_detail::_Trait::SLAM> const&>@<X0>(SLAM::Impl ***a1@<X0>, std::string *a2@<X8>)
{
  SLAM::Impl *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v3 = **a1;
  v4 = *((_QWORD *)v3 + 8);
  v5 = (std::__shared_weak_count *)*((_QWORD *)v3 + 9);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  SLAM::Logger::Log(v4, 1, (uint64_t)"operator()", 252, "Recovering incomplete termination");
  if (v5)
  {
    v8 = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return SLAM::Impl::PerformTermination(v3, a2);
}

void sub_21CC8C460(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_0,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_1,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_2,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_3,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,SLAM::MigrationInfo::Idle,SLAM::MigrationInfo::SecureChannel,SLAM::MigrationInfo::Termination,SLAM::MigrationInfo::SLAM> const&>();
  _Unwind_Resume(exception_object);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformRecovery(void)::$_0,SLAM::Impl::PerformRecovery(void)::$_1,SLAM::Impl::PerformRecovery(void)::$_2,SLAM::Impl::PerformRecovery(void)::$_3,SLAM::Impl::PerformRecovery(void)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,std::__variant_detail::_Trait::Idle,std::__variant_detail::_Trait::SecureChannel,std::__variant_detail::_Trait::Termination,std::__variant_detail::_Trait::SLAM> const&>@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, std::string *a3@<X8>)
{
  SLAM::Impl *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::string *p_p;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::string __p;
  std::string v28;
  char v29;
  _QWORD v30[5];
  uint64_t v31[4];
  char v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v5 = *(SLAM::Impl **)(*(_QWORD *)a1 + 8);
  v6 = *((_QWORD *)v5 + 6);
  v7 = (std::__shared_weak_count *)*((_QWORD *)v5 + 7);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v6 + 8))(v30, v6, *a2);
  if (v7)
  {
    v10 = (unint64_t *)&v7->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (v32)
  {
    SLAM::Impl::ExecuteScript((uint64_t)v5, v31, &v28);
    if (v29)
    {
      v13 = *((_QWORD *)v5 + 8);
      v12 = (std::__shared_weak_count *)*((_QWORD *)v5 + 9);
      if (v12)
      {
        v14 = (unint64_t *)&v12->__shared_owners_;
        do
          v15 = __ldxr(v14);
        while (__stxr(v15 + 1, v14));
      }
      v16 = *a2;
      ctu::join<std::__wrap_iter<std::string const*>>((std::string *)v28.__r_.__value_.__l.__data_, (std::string *)v28.__r_.__value_.__l.__size_, ", ", 2uLL, &__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      SLAM::Logger::Log(v13, 1, (uint64_t)"operator()", 267, "Failed recovery with scriptID 0x%llx, error was %s", v16, (const char *)p_p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (v12)
      {
        v18 = (unint64_t *)&v12->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      SLAM::Impl::PerformTermination(v5, a3);
      if (v29)
      {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v28;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
      }
    }
    else
    {
      a3->__r_.__value_.__s.__data_[0] = 0;
      a3[1].__r_.__value_.__s.__data_[0] = 0;
    }
  }
  else
  {
    v20 = *((_QWORD *)v5 + 8);
    v21 = (std::__shared_weak_count *)*((_QWORD *)v5 + 9);
    if (v21)
    {
      v22 = (unint64_t *)&v21->__shared_owners_;
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }
    SLAM::Logger::Log(v20, 1, (uint64_t)"operator()", 260, "Recovery script 0x%llx not found, terminating!", *a2);
    if (v21)
    {
      v24 = (unint64_t *)&v21->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    SLAM::Impl::PerformTermination(v5, a3);
  }
  return caulk::__expected_detail::base<SLAM::Script,SLAM::Error>::~base((uint64_t)v30);
}

void sub_21CC8C6DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24)
{
  caulk::__expected_detail::base<SLAM::Script,SLAM::Error>::~base((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_21CC8C7A4()
{
  std::__shared_weak_count *v0;
  unint64_t *p_shared_owners;
  unint64_t v2;

  if (v0)
  {
    p_shared_owners = (unint64_t *)&v0->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)(std::__shared_weak_count *))v0->__on_zero_shared)(v0);
      std::__shared_weak_count::__release_weak(v0);
    }
  }
  JUMPOUT(0x21CC8C79CLL);
}

uint64_t caulk::__expected_detail::base<std::vector<unsigned char>,SLAM::Error>::~base(uint64_t a1)
{
  void *v2;
  void **v4;

  if (*(_BYTE *)(a1 + 24))
  {
    v2 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v2;
      operator delete(v2);
    }
  }
  else
  {
    v4 = (void **)a1;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v4);
  }
  return a1;
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char v15;

  v5 = (char *)a1[1];
  v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    v6 = *a1;
    v7 = &v5[-*a1];
    v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0)
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = (unint64_t)operator new(v10);
    else
      v11 = 0;
    v12 = &v7[v11];
    v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      v11 = (unint64_t)v12;
    }
    else
    {
      v14 = &v5[~v6];
      do
      {
        v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
      operator delete(v5);
  }
}

char *std::vector<unsigned char>::__vallocate[abi:ne180100](_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    std::vector<std::string>::__throw_length_error[abi:ne180100]();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

_QWORD *__Block_byref_object_copy_(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  result[5] = a2[5];
  v2 = a2 + 6;
  v3 = a2[6];
  result[6] = v3;
  v4 = result + 6;
  v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(_QWORD *)(v3 + 16) = v4;
    a2[5] = v2;
    *v2 = 0;
    a2[7] = 0;
  }
  else
  {
    result[5] = v4;
  }
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::destroy(a1 + 40, *(_QWORD **)(a1 + 48));
}

uint64_t ___ZN4SLAML21DERParseSequenceToMapERNSt3__16vectorIhNS0_9allocatorIhEEEESt16initializer_listIyE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t **v2;
  uint64_t *v4;

  v2 = (uint64_t **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v4 = (uint64_t *)a2;
  *(_OWORD *)(std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v2, (unint64_t *)a2, (uint64_t)&std::piecewise_construct, &v4)+ 5) = *(_OWORD *)(a2 + 8);
  return 0;
}

void std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t **v9;
  unint64_t v10;
  uint64_t *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = v6[4];
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (uint64_t *)operator new(0x38uLL);
    v11[4] = **a4;
    v11[5] = 0;
    v11[6] = 0;
    std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t *std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t std::map<unsigned long long,DERItem>::map[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = a1 + 8;
  std::map<unsigned long long,DERItem>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long long,DERItem>,std::__tree_node<std::__value_type<unsigned long long,DERItem>,void *> *,long>>>((_OWORD *)a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_21CC8CD60(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

_OWORD *std::map<unsigned long long,DERItem>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long long,DERItem>,std::__tree_node<std::__value_type<unsigned long long,DERItem>,void *> *,long>>>(_OWORD *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = (_QWORD *)result + 1;
    do
    {
      result = std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::__emplace_hint_unique_key_args<unsigned long long,std::pair<unsigned long long const,DERItem> const&>(v5, v6, v4 + 4, (uint64_t)(v4 + 4));
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

_OWORD *std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::__emplace_hint_unique_key_args<unsigned long long,std::pair<unsigned long long const,DERItem> const&>(uint64_t **a1, _QWORD *a2, unint64_t *a3, uint64_t a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t v11;

  v6 = (void **)std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::__find_equal<unsigned long long>(a1, a2, &v11, &v10, a3);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x38uLL);
    v7[2] = *(_OWORD *)a4;
    *((_QWORD *)v7 + 6) = *(_QWORD *)(a4 + 16);
    std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::__insert_node_at(a1, v11, v8, (uint64_t *)v7);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::__find_equal<unsigned long long>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unint64_t *a5)
{
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    v8 = *a2;
    if ((_QWORD *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (_QWORD *)*a2;
      do
      {
        v10 = v9;
        v9 = (_QWORD *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (_QWORD *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (v10[4] < *a5)
      goto LABEL_17;
    v16 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = v16;
          v18 = v16[4];
          if (v15 >= v18)
            break;
          v16 = (_QWORD *)*v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = (_QWORD *)v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (_QWORD *)a2[1];
    do
    {
      a4 = v12;
      v12 = (_QWORD *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (_QWORD *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    v20 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = v20;
          v22 = v20[4];
          if (v6 >= v22)
            break;
          v20 = (_QWORD *)*v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = (_QWORD *)v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

std::string **SLAM::Error::Error(std::string **a1, uint64_t a2)
{
  std::string *v3;
  std::string v5;
  __int128 v6;

  *(_QWORD *)&v6 = *MEMORY[0x24BDAC8D0];
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v5, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v5 = *(std::string *)a2;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v3 = (std::string *)operator new(0x18uLL);
  *a1 = v3;
  a1[1] = v3;
  a1[2] = v3 + 1;
  a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((uint64_t)(a1 + 2), (__int128 *)&v5, &v6, v3);
  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v5.__r_.__value_.__l.__data_);
  return a1;
}

void sub_21CC8D104(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  _Unwind_Resume(exception_object);
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>(uint64_t a1, __int128 *a2, __int128 *a3, std::string *this)
{
  std::string *v4;
  __int128 *v6;
  __int128 v7;
  _QWORD v9[3];
  char v10;
  std::string *v11;
  std::string *v12;

  v4 = this;
  v11 = this;
  v12 = this;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
        v4 = v12;
      }
      else
      {
        v7 = *v6;
        v4->__r_.__value_.__r.__words[2] = *((_QWORD *)v6 + 2);
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
      }
      v6 = (__int128 *)((char *)v6 + 24);
      v12 = ++v4;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_21CC8D1E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t caulk::__expected_detail::base<std::map<unsigned long long,DERItem>,SLAM::Error>::~base(uint64_t a1)
{
  void **v3;

  if (*(_BYTE *)(a1 + 24))
  {
    std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::destroy(a1, *(_QWORD **)(a1 + 8));
  }
  else
  {
    v3 = (void **)a1;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  return a1;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100IN4SLAM21DefaultScriptProviderENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x30uLL);
  result = _ZNSt3__120__shared_ptr_emplaceIN4SLAM21DefaultScriptProviderENS_9allocatorIS2_EEEC2B8ne180100IJES4_Li0EEES4_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_21CC8D308(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceIN4SLAM21DefaultScriptProviderENS_9allocatorIS2_EEEC2B8ne180100IJES4_Li0EEES4_DpOT_(_QWORD *a1)
{
  char v3;

  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_24E0BF3B8;
  std::allocator<SLAM::DefaultScriptProvider>::construct[abi:ne180100]<SLAM::DefaultScriptProvider>((uint64_t)&v3, a1 + 3);
  return a1;
}

void sub_21CC8D360(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<SLAM::DefaultScriptProvider>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0BF3B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SLAM::DefaultScriptProvider>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0BF3B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SLAM::DefaultScriptProvider>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 24) + 16))(a1 + 24);
}

void std::allocator<SLAM::DefaultScriptProvider>::construct[abi:ne180100]<SLAM::DefaultScriptProvider>(uint64_t a1, _QWORD *a2)
{
  void *__p[2];
  char v4;

  std::string::basic_string[abi:ne180100]<0>(__p, "/usr/standalone/firmware/SLAM/SLAM.sefw");
  SLAM::DefaultScriptProvider::DefaultScriptProvider(a2, (uint64_t)__p);
  if (v4 < 0)
    operator delete(__p[0]);
}

void sub_21CC8D414(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::allocate_shared[abi:ne180100]<SLAM::Logger,std::allocator<SLAM::Logger>,gsl::not_null<std::shared_ptr<SLAM::LogSink>> const&,void>@<X0>(uint64_t *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x50uLL);
  result = std::__shared_ptr_emplace<SLAM::Logger>::__shared_ptr_emplace[abi:ne180100]<gsl::not_null<std::shared_ptr<SLAM::LogSink>> const&,std::allocator<SLAM::Logger>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_21CC8D474(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<SLAM::Logger>::__shared_ptr_emplace[abi:ne180100]<gsl::not_null<std::shared_ptr<SLAM::LogSink>> const&,std::allocator<SLAM::Logger>,0>(_QWORD *a1, uint64_t *a2)
{
  char v4;

  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_24E0BF3F0;
  std::allocator<SLAM::Logger>::construct[abi:ne180100]<SLAM::Logger,gsl::not_null<std::shared_ptr<SLAM::LogSink>> const&>((uint64_t)&v4, a1 + 3, a2);
  return a1;
}

void sub_21CC8D4D0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<SLAM::Logger>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0BF3F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SLAM::Logger>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0BF3F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SLAM::Logger>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 24;
  boost::circular_buffer<std::string,std::allocator<std::string>>::destroy((uint64_t *)(a1 + 40));
  return std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v1);
}

void std::allocator<SLAM::Logger>::construct[abi:ne180100]<SLAM::Logger,gsl::not_null<std::shared_ptr<SLAM::LogSink>> const&>(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v3 = (std::__shared_weak_count *)a3[1];
  v9 = *a3;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  SLAM::Logger::Logger(a2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_21CC8D5D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *SLAM::Logger::Logger(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  char *v6;

  v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  a1[6] = 0;
  v6 = (char *)operator new(0x1E0uLL);
  a1[2] = v6;
  a1[3] = v6 + 480;
  a1[4] = v6;
  a1[5] = v6;
  return a1;
}

void sub_21CC8D640(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void boost::circular_buffer<std::string,std::allocator<std::string>>::destroy(uint64_t *a1)
{
  boost::circular_buffer<std::string,std::allocator<std::string>>::destroy_content(a1);
  if (*a1)
    operator delete((void *)*a1);
}

void boost::circular_buffer<std::string,std::allocator<std::string>>::destroy_content(uint64_t *a1)
{
  unint64_t v2;
  uint64_t v3;

  if (a1[4])
  {
    v2 = 0;
    v3 = a1[2];
    do
    {
      if (*(char *)(v3 + 23) < 0)
      {
        operator delete(*(void **)v3);
        v3 = a1[2];
      }
      v3 += 24;
      a1[2] = v3;
      if (v3 == a1[1])
      {
        v3 = *a1;
        a1[2] = *a1;
      }
      ++v2;
    }
    while (v2 < a1[4]);
  }
}

_QWORD *std::__function::__func<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::~__func(_QWORD *a1)
{
  *a1 = &off_24E0BF428;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

void std::__function::__func<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::~__func(_QWORD *a1)
{
  *a1 = &off_24E0BF428;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x22078A808);
}

_QWORD *std::__function::__func<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = operator new(0x18uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *result = &off_24E0BF428;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

uint64_t std::__function::__func<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = *(_QWORD *)(result + 8);
  v2 = *(_QWORD *)(result + 16);
  *a2 = &off_24E0BF428;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

uint64_t std::__function::__func<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::destroy(uint64_t a1)
{
  return std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](a1 + 8);
}

void std::__function::__func<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::destroy_deallocate(void *a1)
{
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformScript(std::string,gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::operator()(uint64_t a1)
{
  void (***v2)(_QWORD);
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = *(void (****)(_QWORD))(a1 + 8);
  v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (**v2)(v2);
  if (v3)
  {
    v6 = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_21CC8D8A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_0,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_1,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_2,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_3,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,SLAM::MigrationInfo::Idle,SLAM::MigrationInfo::SecureChannel,SLAM::MigrationInfo::Termination,SLAM::MigrationInfo::SLAM> const&>();
  _Unwind_Resume(exception_object);
}

_QWORD *std::__function::__func<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::~__func(_QWORD *a1)
{
  *a1 = &off_24E0BF470;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

void std::__function::__func<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::~__func(_QWORD *a1)
{
  *a1 = &off_24E0BF470;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x22078A808);
}

_QWORD *std::__function::__func<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = operator new(0x18uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *result = &off_24E0BF470;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

uint64_t std::__function::__func<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = *(_QWORD *)(result + 8);
  v2 = *(_QWORD *)(result + 16);
  *a2 = &off_24E0BF470;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

uint64_t std::__function::__func<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::destroy(uint64_t a1)
{
  return std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](a1 + 8);
}

void std::__function::__func<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::destroy_deallocate(void *a1)
{
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0,std::allocator<SLAM::SLAMPrivateInterface::PerformRecovery(gsl::not_null<std::shared_ptr<SLAM::SEHandle>>,gsl::not_null<std::shared_ptr<SLAM::LogSink>>,gsl::not_null<std::shared_ptr<SLAM::ScriptProvider>>)::$_0>,void ()(std::string const&)>::operator()(uint64_t a1)
{
  void (***v2)(_QWORD);
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = *(void (****)(_QWORD))(a1 + 8);
  v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (**v2)(v2);
  if (v3)
  {
    v6 = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_21CC8DA5C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_0,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_1,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_2,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_3,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,SLAM::MigrationInfo::Idle,SLAM::MigrationInfo::SecureChannel,SLAM::MigrationInfo::Termination,SLAM::MigrationInfo::SLAM> const&>();
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(_QWORD *result, const void *a2, uint64_t a3, size_t __sz)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (__sz)
  {
    v6 = result;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21CC8DAD0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void OUTLINED_FUNCTION_0_0(std::__shared_weak_count *this)
{
  std::__shared_weak_count::__release_weak(this);
}

uint64_t OUTLINED_FUNCTION_1_0()
{
  uint64_t v0;

  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v0 + 16))(v0);
}

void OUTLINED_FUNCTION_2_0(unint64_t *a1@<X8>)
{
  unint64_t v1;

  v1 = __ldaxr(a1);
  __stlxr(v1 - 1, a1);
}

uint64_t OUTLINED_FUNCTION_4_0@<X0>(_QWORD *a1@<X1>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(_QWORD *))(*a1 + 8 * a2))(a1);
}

uint64_t OUTLINED_FUNCTION_7()
{
  uint64_t v0;

  return std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v0);
}

void SLAM::SLAMPrivateInterface::PerformScript()
{
  _QWORD *v0;
  _QWORD *v1;
  char v2;
  uint64_t v3;

  OUTLINED_FUNCTION_6();
  if (v2)
  {
    v3 = 4;
    goto LABEL_5;
  }
  if (v1)
  {
    v3 = 5;
    v0 = v1;
LABEL_5:
    OUTLINED_FUNCTION_4_0(v0, v3);
  }
  OUTLINED_FUNCTION_7();
  OUTLINED_FUNCTION_3_0();
}

void std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SLAM::overloaded<SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_0,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_1,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_2,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_3,SLAM::Impl::PerformScript(SLAM::Script const&,SLAM::MigrationInfo const&)::$_4>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SLAM::MigrationInfo::OSU,SLAM::MigrationInfo::Idle,SLAM::MigrationInfo::SecureChannel,SLAM::MigrationInfo::Termination,SLAM::MigrationInfo::SLAM> const&>()
{
  std::__shared_weak_count *v0;
  unint64_t *v1;
  uint64_t v2;
  int v3;

  OUTLINED_FUNCTION_5_0();
  do
    OUTLINED_FUNCTION_2_0(v1);
  while (v3);
  if (v2)
  {
    OUTLINED_FUNCTION_3_0();
  }
  else
  {
    OUTLINED_FUNCTION_1_0();
    OUTLINED_FUNCTION_0_0(v0);
  }
}

_QWORD *SLAM::DefaultScriptProvider::DefaultScriptProvider(_QWORD *a1, uint64_t a2)
{
  *a1 = &off_24E0BF4B8;
  applesauce::v1::mapped_file::mapped_file(a1 + 1, a2, 1);
  return a1;
}

_QWORD *SLAM::DefaultScriptProvider::GetScriptByID@<X0>(SLAM::DefaultScriptProvider *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  uint64_t v4;
  uint64_t v5;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v5 = a2;
  v6[0] = &off_24E0BF590;
  v6[1] = &v5;
  v7 = v6;
  SLAM::DefaultScriptProvider::FindScriptMatching((uint64_t)this, (uint64_t)v6, a3);
  result = v7;
  if (v7 == v6)
  {
    v4 = 4;
    result = v6;
  }
  else
  {
    if (!v7)
      return result;
    v4 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

void sub_21CC8DC8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void SLAM::DefaultScriptProvider::FindScriptMatching(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  std::vector<std::string> *p_p;
  uint64_t v14;
  void ***v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  uint64_t v23;
  __int128 v24;
  std::vector<std::string>::pointer end;
  std::string::pointer data;
  __int128 v27;
  std::string __p;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  void *v35[2];
  uint64_t v36;
  _QWORD v37[5];
  std::vector<std::string> v38;
  __n128 (*v39)(__n128 *, __n128 *);
  void (*v40)(uint64_t);
  const char *v41;
  _QWORD v42[3];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  _OWORD v47[2];
  __int128 v48;
  std::string *v49;
  std::string **v50;
  uint64_t v51;
  __n128 (*v52)(uint64_t, __n128 *);
  void (*v53)(uint64_t);
  uint64_t v54;
  char v55;
  char v56;
  std::string v57;
  __n128 (*v58)(uint64_t, uint64_t);
  uint64_t (*v59)();
  uint64_t v60;
  char v61;
  char v62;
  _QWORD v63[3];
  int v64;
  __int128 v65;
  __int128 v66;
  _QWORD v67[2];
  _QWORD v68[7];
  _BYTE v69[24];
  _BYTE *v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 < 7
    || (*(_DWORD *)SLAM::DefaultScriptProvider::FindScriptMatching(std::function<BOOL ()(SLAMScriptDERObj const&)>)::plist_header == *(_DWORD *)v6
      ? (v7 = *(unsigned __int16 *)&SLAM::DefaultScriptProvider::FindScriptMatching(std::function<BOOL ()(SLAMScriptDERObj const&)>)::plist_header[4] == *(unsigned __int16 *)(v6 + 4))
      : (v7 = 0),
        !v7))
  {
    v67[0] = *(_QWORD *)(a1 + 8);
    v67[1] = v5;
    v65 = 0u;
    v66 = 0u;
    v8 = DERParseSequence((uint64_t)v67, (unsigned __int16)slamSEFWItemSpecLen, (uint64_t)&slamSEFWItemSpec, (unint64_t)&v65, 0x20uLL);
    if ((_DWORD)v8)
    {
      SLAM::Error::Unexpected((SLAM::Error *)"Failed to parse top level %d", (uint64_t)&v57, v8);
LABEL_18:
      *(std::string *)a3 = v57;
      memset(&v57, 0, sizeof(v57));
      *(_BYTE *)(a3 + 72) = 0;
      *(_QWORD *)&v43 = &v57;
      v15 = (void ***)&v43;
      goto LABEL_19;
    }
    if (*((_QWORD *)&v65 + 1) != 4)
    {
      SLAM::Error::Unexpected((SLAM::Error *)"Unexpected SLAM version length %zu", (uint64_t)&v57, *((_QWORD *)&v65 + 1));
      goto LABEL_18;
    }
    v63[0] = 0;
    v63[1] = v63;
    v63[2] = 0x2020000000;
    v64 = 0;
    v9 = bswap32(*(_DWORD *)v65);
    v64 = v9;
    if ((v9 - 1) >= 2)
    {
      SLAM::Error::Unexpected((SLAM::Error *)"Unexpected SLAM SEFW version %u", (uint64_t)&v57, v9);
      *(std::string *)a3 = v57;
      memset(&v57, 0, sizeof(v57));
      *(_BYTE *)(a3 + 72) = 0;
      *(_QWORD *)&v43 = &v57;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v43);
LABEL_30:
      _Block_object_dispose(v63, 8);
      return;
    }
    v57.__r_.__value_.__r.__words[0] = 0;
    v57.__r_.__value_.__l.__size_ = (std::string::size_type)&v57;
    v57.__r_.__value_.__r.__words[2] = 0xA812000000;
    v58 = __Block_byref_object_copy__0;
    v59 = __Block_byref_object_dispose__0;
    v60 = 0;
    v61 = 0;
    v62 = 0;
    v49 = 0;
    v50 = &v49;
    v51 = 0x5012000000;
    v52 = __Block_byref_object_copy__5;
    v53 = __Block_byref_object_dispose__6;
    v54 = 0;
    v55 = 0;
    v56 = 0;
    v10 = MEMORY[0x24BDAC760];
    v68[0] = MEMORY[0x24BDAC760];
    v68[1] = 3321888768;
    v68[2] = ___ZN4SLAM21DefaultScriptProvider18FindScriptMatchingENSt3__18functionIFbRK16SLAMScriptDERObjEEE_block_invoke;
    v68[3] = &unk_24E0BF4E0;
    v11 = v69;
    v68[4] = v63;
    v68[5] = &v49;
    std::__function::__value_func<BOOL ()(SLAMScriptDERObj const&)>::__value_func[abi:ne180100]((uint64_t)v69, a2);
    v68[6] = &v57;
    v12 = DERDecodeSequenceContentWithBlock((unint64_t *)&v66, (uint64_t)v68);
    if ((_DWORD)v12)
    {
      SLAM::Error::Unexpected((SLAM::Error *)"Failed to decode script %d", (uint64_t)&v43, v12);
      *(_OWORD *)a3 = v43;
      *(_QWORD *)(a3 + 16) = v44;
      *(_QWORD *)&v44 = 0;
      v43 = 0uLL;
      *(_BYTE *)(a3 + 72) = 0;
      v38.__begin_ = (std::vector<std::string>::pointer)&v43;
      p_p = &v38;
LABEL_12:
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)p_p);
      goto LABEL_13;
    }
    if (*((_BYTE *)v50 + 72))
    {
      ctu::join<std::__wrap_iter<std::string const*>>(v50[6], v50[7], ", ", 2uLL, &__p);
      SLAM::Error::Error(&v38.__begin_, (uint64_t)&__p);
      v43 = 0uLL;
      *(_QWORD *)&v44 = 0;
      std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>((std::string *)&v43, (__int128 *)v38.__begin_, (__int128 *)v38.__end_, 0xAAAAAAAAAAAAAAABLL * (((char *)v38.__end_ - (char *)v38.__begin_) >> 3));
      *(_OWORD *)a3 = v43;
      *(_QWORD *)(a3 + 16) = v44;
      *(_QWORD *)&v44 = 0;
      v43 = 0uLL;
      *(_BYTE *)(a3 + 72) = 0;
      v35[0] = &v43;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)v35);
      v35[0] = &v38;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)v35);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    else
    {
      if (!*(_BYTE *)(v57.__r_.__value_.__l.__size_ + 160))
      {
        SLAM::Error::Error(&v38, "Could not find script within SEFW");
        v43 = 0uLL;
        *(_QWORD *)&v44 = 0;
        std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>((std::string *)&v43, (__int128 *)v38.__begin_, (__int128 *)v38.__end_, 0xAAAAAAAAAAAAAAABLL * (((char *)v38.__end_ - (char *)v38.__begin_) >> 3));
        *(_OWORD *)a3 = v43;
        *(_QWORD *)(a3 + 16) = v44;
        *(_QWORD *)&v44 = 0;
        v43 = 0uLL;
        *(_BYTE *)(a3 + 72) = 0;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v43;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v38;
        p_p = (std::vector<std::string> *)&__p;
        goto LABEL_12;
      }
      v16 = *(_OWORD *)(v57.__r_.__value_.__l.__size_ + 96);
      v17 = *(_OWORD *)(v57.__r_.__value_.__l.__size_ + 128);
      v18 = *(_OWORD *)(v57.__r_.__value_.__l.__size_ + 144);
      v47[0] = *(_OWORD *)(v57.__r_.__value_.__l.__size_ + 112);
      v47[1] = v17;
      v48 = v18;
      v19 = *(_OWORD *)(v57.__r_.__value_.__l.__size_ + 64);
      v45 = *(_OWORD *)(v57.__r_.__value_.__l.__size_ + 80);
      v46 = v16;
      v43 = *(_OWORD *)(v57.__r_.__value_.__l.__size_ + 48);
      v44 = v19;
      v38.__begin_ = 0;
      v38.__end_ = (std::vector<std::string>::pointer)&v38;
      v38.__end_cap_.__value_ = (std::string *)0x4812000000;
      v39 = __Block_byref_object_copy__11;
      v40 = __Block_byref_object_dispose__12;
      v41 = "";
      memset(v42, 0, sizeof(v42));
      v37[0] = v10;
      v37[1] = 3221225472;
      v37[2] = ___ZN4SLAM21DefaultScriptProvider18FindScriptMatchingENSt3__18functionIFbRK16SLAMScriptDERObjEEE_block_invoke_13;
      v37[3] = &unk_24E0BF518;
      v37[4] = &v38;
      v20 = DERDecodeSequenceContentWithBlock((unint64_t *)v47, (uint64_t)v37);
      if ((_DWORD)v20)
      {
        SLAM::Error::Unexpected((SLAM::Error *)"Failed to decode APDUs %d", (uint64_t)&__p, v20);
        *(std::string *)a3 = __p;
        memset(&__p, 0, sizeof(__p));
        *(_BYTE *)(a3 + 72) = 0;
        v35[0] = &__p;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)v35);
      }
      else
      {
        v35[1] = 0;
        v36 = 0;
        v35[0] = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v35, (const void *)v45, v45 + *((_QWORD *)&v45 + 1), *((size_t *)&v45 + 1));
        v21 = v48;
        if ((_QWORD)v48)
          v21 = bswap32(*(_DWORD *)v48);
        v22 = bswap64(*(_QWORD *)v43);
        v23 = v36;
        v24 = *(_OWORD *)v35;
        v35[1] = 0;
        v36 = 0;
        v35[0] = 0;
        end = v38.__end_;
        data = v38.__end_[2].__r_.__value_.__l.__data_;
        v27 = *(_OWORD *)&v38.__end_[2].__r_.__value_.__r.__words[1];
        *(_OWORD *)(a3 + 48) = v27;
        end[2].__r_.__value_.__l.__size_ = 0;
        end[2].__r_.__value_.__r.__words[2] = 0;
        end[2].__r_.__value_.__r.__words[0] = 0;
        v34 = v21;
        *(_QWORD *)a3 = v22;
        *(_OWORD *)(a3 + 8) = v24;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v22;
        __p.__r_.__value_.__r.__words[2] = 0;
        v29 = 0;
        *(_QWORD *)(a3 + 24) = v23;
        *(_QWORD *)(a3 + 32) = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27 - (_QWORD)data) >> 3);
        *(_QWORD *)(a3 + 40) = data;
        v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27 - (_QWORD)data) >> 3);
        v31 = 0;
        v32 = 0;
        v33 = 0;
        *(_DWORD *)(a3 + 64) = v21;
        *(_BYTE *)(a3 + 72) = 1;
        SLAM::Script::~Script((SLAM::Script *)&__p);
        if (v35[0])
        {
          v35[1] = v35[0];
          operator delete(v35[0]);
        }
      }
      _Block_object_dispose(&v38, 8);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v42;
      std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
    }
LABEL_13:
    if (v70 == v69)
    {
      v14 = 4;
    }
    else
    {
      if (!v70)
      {
LABEL_27:
        _Block_object_dispose(&v49, 8);
        if (v56)
        {
          *(_QWORD *)&v43 = &v55;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v43);
        }
        _Block_object_dispose(&v57, 8);
        goto LABEL_30;
      }
      v14 = 5;
      v11 = v70;
    }
    (*(void (**)(_QWORD *))(*v11 + 8 * v14))(v11);
    goto LABEL_27;
  }
  SLAM::Error::Error((std::vector<std::string> *)&v43, "Legacy (plist) SLAM SEFW path is no longer supported");
  memset(&v57, 0, sizeof(v57));
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v57, (__int128 *)v43, *((__int128 **)&v43 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)&v43 + 1) - v43) >> 3));
  *(std::string *)a3 = v57;
  memset(&v57, 0, sizeof(v57));
  *(_BYTE *)(a3 + 72) = 0;
  v49 = &v57;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v49);
  v49 = (std::string *)&v43;
  v15 = (void ***)&v49;
LABEL_19:
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](v15);
}

void sub_21CC8E33C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62,int a63)
{
  __int16 a64;
  _QWORD *v64;
  uint64_t v65;
  _QWORD *v67;
  uint64_t v68;

  _Block_object_dispose(&a30, 8);
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  v67 = *(_QWORD **)(v65 - 80);
  if (v67 == v64)
  {
    v68 = 4;
  }
  else
  {
    if (!v67)
      goto LABEL_6;
    v68 = 5;
    v64 = *(_QWORD **)(v65 - 80);
  }
  (*(void (**)(_QWORD *))(*v64 + 8 * v68))(v64);
LABEL_6:
  _Block_object_dispose(&a53, 8);
  if (a62)
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a39);
  _Block_object_dispose(&a64, 8);
  _Block_object_dispose((const void *)(v65 - 240), 8);
  _Unwind_Resume(a1);
}

_QWORD *SLAM::DefaultScriptProvider::GetScript@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  _QWORD *v9;
  _QWORD *result;
  uint64_t v11;
  int v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v12 = a4;
  v9 = operator new(0x20uLL);
  *v9 = &off_24E0BF5D8;
  v9[1] = a2;
  v9[2] = a3;
  v9[3] = &v12;
  v14 = v9;
  SLAM::DefaultScriptProvider::FindScriptMatching(a1, (uint64_t)v13, a5);
  result = v14;
  if (v14 == v13)
  {
    v11 = 4;
    result = v13;
  }
  else
  {
    if (!v14)
      return result;
    v11 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v11))();
}

void sub_21CC8E524(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

__n128 __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __n128 result;
  __int128 v6;
  __int128 v7;

  v2 = *(_OWORD *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  v4 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 96) = v4;
  *(_OWORD *)(a1 + 48) = v2;
  *(_OWORD *)(a1 + 64) = v3;
  result = *(__n128 *)(a2 + 112);
  v6 = *(_OWORD *)(a2 + 128);
  v7 = *(_OWORD *)(a2 + 144);
  *(_BYTE *)(a1 + 160) = *(_BYTE *)(a2 + 160);
  *(_OWORD *)(a1 + 128) = v6;
  *(_OWORD *)(a1 + 144) = v7;
  *(__n128 *)(a1 + 112) = result;
  return result;
}

__n128 __Block_byref_object_copy__5(uint64_t a1, __n128 *a2)
{
  __n128 result;

  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  if (a2[4].n128_u8[8])
  {
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    result = a2[3];
    *(__n128 *)(a1 + 48) = result;
    *(_QWORD *)(a1 + 64) = a2[4].n128_u64[0];
    a2[3].n128_u64[0] = 0;
    a2[3].n128_u64[1] = 0;
    a2[4].n128_u64[0] = 0;
    *(_BYTE *)(a1 + 72) = 1;
  }
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
  void **v1;

  if (*(_BYTE *)(a1 + 72))
  {
    v1 = (void **)(a1 + 48);
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v1);
  }
}

void sub_21CC8E75C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  uint64_t v16;
  uint64_t v17;

  *(_QWORD *)(v17 - 40) = v16;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v17 - 40));
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_56c46_ZTSNSt3__18functionIFbRK16SLAMScriptDERObjEEE(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<BOOL ()(SLAMScriptDERObj const&)>::__value_func[abi:ne180100](a1 + 56, a2 + 56);
}

_QWORD *__destroy_helper_block_ea8_56c46_ZTSNSt3__18functionIFbRK16SLAMScriptDERObjEEE(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 56);
  result = *(_QWORD **)(a1 + 80);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

__n128 __Block_byref_object_copy__11(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

uint64_t ___ZN4SLAM21DefaultScriptProvider18FindScriptMatchingENSt3__18functionIFbRK16SLAMScriptDERObjEEE_block_invoke_13(uint64_t a1, _QWORD *a2)
{
  uint64_t *v2;
  const void **v3;
  size_t v4;
  const void *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;

  if (*a2 != 4)
    return 2;
  v2 = *(uint64_t **)(*(_QWORD *)(a1 + 32) + 8);
  v5 = (const void *)a2[1];
  v4 = a2[2];
  v3 = (const void **)(a2 + 1);
  v9 = (uint64_t)v5 + v4;
  v6 = (_QWORD *)v2[7];
  if ((unint64_t)v6 >= v2[8])
  {
    v7 = std::vector<std::vector<unsigned char>>::__emplace_back_slow_path<unsigned char *&,unsigned char *>(v2 + 6, v3, &v9);
  }
  else
  {
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v6, v5, (uint64_t)v5 + v4, v4);
    v7 = (uint64_t)(v6 + 3);
    v2[7] = (uint64_t)(v6 + 3);
  }
  result = 0;
  v2[7] = v7;
  return result;
}

void sub_21CC8E8A4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v2 + 56) = v1;
  _Unwind_Resume(a1);
}

void SLAM::Script::~Script(SLAM::Script *this)
{
  void *v2;
  void **v3;

  v3 = (void **)((char *)this + 40);
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
}

void SLAM::DefaultScriptProvider::~DefaultScriptProvider(SLAM::DefaultScriptProvider *this)
{
  void *v2;

  *(_QWORD *)this = &off_24E0BF4B8;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
    munmap(v2, *((_QWORD *)this + 2));
  *((_QWORD *)this + 2) = 0;
}

{
  void *v2;

  *(_QWORD *)this = &off_24E0BF4B8;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
    munmap(v2, *((_QWORD *)this + 2));
  *((_QWORD *)this + 2) = 0;
  JUMPOUT(0x22078A808);
}

_QWORD *applesauce::v1::mapped_file::mapped_file(_QWORD *a1, uint64_t a2, __int16 a3)
{
  const char *v6;
  int v7;
  int v8;
  unint64_t st_size;
  int v10;
  int v11;
  void *v12;
  std::ios_base::failure *exception;
  int *v15;
  std::ios_base::failure *v16;
  int *v17;
  std::ios_base::failure *v18;
  int *v19;
  const void *v20;
  int v21;
  stat v22;

  *a1 = 0;
  a1[1] = 0;
  if (*(char *)(a2 + 23) >= 0)
    v6 = (const char *)a2;
  else
    v6 = *(const char **)a2;
  v7 = open(v6, 0);
  if (v7 < 0)
  {
    exception = (std::ios_base::failure *)__cxa_allocate_exception(0x20uLL);
    std::string::basic_string[abi:ne180100]<0>(&v22, "open()");
    v15 = __error();
  }
  v8 = v7;
  if (fstat(v7, &v22) < 0)
  {
    v16 = (std::ios_base::failure *)__cxa_allocate_exception(0x20uLL);
    std::string::basic_string[abi:ne180100]<0>(&v20, "fstat()");
    v17 = __error();
  }
  st_size = v22.st_size;
  a1[1] = v22.st_size;
  if ((a3 & 1) != 0)
  {
    v10 = 0x7FFFFFFF;
    if (st_size < 0x7FFFFFFF)
      v10 = st_size;
    v21 = v10;
    v20 = 0;
    fcntl(v8, 44, &v20);
    st_size = a1[1];
  }
  if ((a3 & 0x100) != 0)
    v11 = 1;
  else
    v11 = 1025;
  v12 = mmap(0, st_size, 1, v11, v8, 0);
  *a1 = v12;
  if (v12 == (void *)-1)
  {
    v18 = (std::ios_base::failure *)__cxa_allocate_exception(0x20uLL);
    std::string::basic_string[abi:ne180100]<0>(&v20, "mmap()");
    v19 = __error();
  }
  close(v8);
  return a1;
}

void sub_21CC8EB64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  int v21;
  void *v22;
  int v23;

  if (a15 < 0)
  {
    operator delete(__p);
    if ((v23 & 1) == 0)
    {
LABEL_6:
      close(v21);
      _Unwind_Resume(a1);
    }
  }
  else if (!v23)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v22);
  goto LABEL_6;
}

void applesauce::v1::`anonymous namespace'::io_failure_exception(const void **a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, std::ios_base::failure *a4@<X8>)
{
  size_t v8;
  std::string *v9;
  const void *v10;
  int v11;
  const std::string::value_type *v12;
  std::string::size_type v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  std::error_code __ec;
  std::string v19;
  std::string v20;
  std::string __msg;

  if (*((char *)a1 + 23) >= 0)
    v8 = *((unsigned __int8 *)a1 + 23);
  else
    v8 = (size_t)a1[1];
  v9 = &v19;
  std::string::basic_string[abi:ne180100]((uint64_t)&v19, v8 + 13);
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v9 = (std::string *)v19.__r_.__value_.__r.__words[0];
  if (v8)
  {
    if (*((char *)a1 + 23) >= 0)
      v10 = a1;
    else
      v10 = *a1;
    memmove(v9, v10, v8);
  }
  strcpy((char *)v9 + v8, " failed for '");
  v11 = *(char *)(a2 + 23);
  if (v11 >= 0)
    v12 = (const std::string::value_type *)a2;
  else
    v12 = *(const std::string::value_type **)a2;
  if (v11 >= 0)
    v13 = *(unsigned __int8 *)(a2 + 23);
  else
    v13 = *(_QWORD *)(a2 + 8);
  v14 = std::string::append(&v19, v12, v13);
  v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  v16 = std::string::append(&v20, "'");
  v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  __msg.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__msg.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  *(_QWORD *)&__ec.__val_ = a3;
  __ec.__cat_ = std::generic_category();
  std::ios_base::failure::failure(a4, &__msg, &__ec);
  if (SHIBYTE(__msg.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__msg.__r_.__value_.__l.__data_);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v20.__r_.__value_.__l.__data_);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
}

void sub_21CC8ED58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a17 < 0)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

uint64_t std::string::basic_string[abi:ne180100](uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (a2 > 0x16)
  {
    v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v4 = a2 | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v5 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

void std::__function::__func<SLAM::DefaultScriptProvider::GetScriptByID(unsigned long long)::$_0,std::allocator<SLAM::DefaultScriptProvider::GetScriptByID(unsigned long long)::$_0>,BOOL ()(SLAMScriptDERObj const&)>::~__func()
{
  JUMPOUT(0x22078A808);
}

_QWORD *std::__function::__func<SLAM::DefaultScriptProvider::GetScriptByID(unsigned long long)::$_0,std::allocator<SLAM::DefaultScriptProvider::GetScriptByID(unsigned long long)::$_0>,BOOL ()(SLAMScriptDERObj const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24E0BF590;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<SLAM::DefaultScriptProvider::GetScriptByID(unsigned long long)::$_0,std::allocator<SLAM::DefaultScriptProvider::GetScriptByID(unsigned long long)::$_0>,BOOL ()(SLAMScriptDERObj const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24E0BF590;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<SLAM::DefaultScriptProvider::GetScriptByID(unsigned long long)::$_0,std::allocator<SLAM::DefaultScriptProvider::GetScriptByID(unsigned long long)::$_0>,BOOL ()(SLAMScriptDERObj const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 8) == 8 && bswap64(**(_QWORD **)a2) == **(_QWORD **)(a1 + 8);
}

void std::__function::__func<SLAM::DefaultScriptProvider::GetScript(std::string,std::vector<unsigned char>,SLAM::PlatformCategory)::$_0,std::allocator<SLAM::DefaultScriptProvider::GetScript(std::string,std::vector<unsigned char>,SLAM::PlatformCategory)::$_0>,BOOL ()(SLAMScriptDERObj const&)>::~__func()
{
  JUMPOUT(0x22078A808);
}

__n128 std::__function::__func<SLAM::DefaultScriptProvider::GetScript(std::string,std::vector<unsigned char>,SLAM::PlatformCategory)::$_0,std::allocator<SLAM::DefaultScriptProvider::GetScript(std::string,std::vector<unsigned char>,SLAM::PlatformCategory)::$_0>,BOOL ()(SLAMScriptDERObj const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24E0BF5D8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<SLAM::DefaultScriptProvider::GetScript(std::string,std::vector<unsigned char>,SLAM::PlatformCategory)::$_0,std::allocator<SLAM::DefaultScriptProvider::GetScript(std::string,std::vector<unsigned char>,SLAM::PlatformCategory)::$_0>,BOOL ()(SLAMScriptDERObj const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24E0BF5D8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<SLAM::DefaultScriptProvider::GetScript(std::string,std::vector<unsigned char>,SLAM::PlatformCategory)::$_0,std::allocator<SLAM::DefaultScriptProvider::GetScript(std::string,std::vector<unsigned char>,SLAM::PlatformCategory)::$_0>,BOOL ()(SLAMScriptDERObj const&)>::operator()(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  size_t v5;
  _QWORD *v6;
  size_t v7;
  uint64_t v8;

  if (*(_QWORD *)(a2 + 88) == 4)
    v4 = bswap32(**(_DWORD **)(a2 + 80));
  else
    v4 = 1;
  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD **)(a1 + 8);
  if (*((char *)v6 + 23) < 0)
  {
    if (v5 != v6[1])
      return 0;
    v6 = (_QWORD *)*v6;
  }
  else if (v5 != *((unsigned __int8 *)v6 + 23))
  {
    return 0;
  }
  if (memcmp(v6, *(const void **)(a2 + 16), v5))
    return 0;
  v7 = *(_QWORD *)(a2 + 40);
  v8 = *(_QWORD *)(a1 + 16);
  if (v7 != *(_QWORD *)(v8 + 8) - *(_QWORD *)v8 || memcmp(*(const void **)v8, *(const void **)(a2 + 32), v7))
    return 0;
  return !v4 || **(_DWORD **)(a1 + 24) == v4;
}

uint64_t std::__function::__value_func<BOOL ()(SLAMScriptDERObj const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::vector<std::vector<unsigned char>>::__emplace_back_slow_path<unsigned char *&,unsigned char *>(uint64_t *a1, const void **a2, uint64_t *a3)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  const void *v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  _QWORD v19[2];
  char *v20;
  char *v21;
  uint64_t *v22;

  v4 = *a1;
  v5 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v6 = v5 + 1;
  if (v5 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<std::string>::__throw_length_error[abi:ne180100]();
  v9 = (uint64_t)(a1 + 2);
  v10 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v4) >> 3);
  if (2 * v10 > v6)
    v6 = 2 * v10;
  if (v10 >= 0x555555555555555)
    v11 = 0xAAAAAAAAAAAAAAALL;
  else
    v11 = v6;
  v22 = a1 + 2;
  if (v11)
    v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v9, v11);
  else
    v12 = 0;
  v13 = &v12[24 * v5];
  v19[0] = v12;
  v19[1] = v13;
  v20 = v13;
  v21 = &v12[24 * v11];
  v14 = *a2;
  v15 = *a3;
  v16 = *a3 - (_QWORD)*a2;
  *(_QWORD *)v13 = 0;
  *((_QWORD *)v13 + 1) = 0;
  *((_QWORD *)v13 + 2) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v13, v14, v15, v16);
  v20 += 24;
  std::vector<std::vector<unsigned char>>::__swap_out_circular_buffer(a1, v19);
  v17 = a1[1];
  std::__split_buffer<std::vector<unsigned char>>::~__split_buffer((uint64_t)v19);
  return v17;
}

void sub_21CC8F170(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<unsigned char>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<unsigned char>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<unsigned char>>,std::reverse_iterator<std::vector<unsigned char>*>,std::reverse_iterator<std::vector<unsigned char>*>,std::reverse_iterator<std::vector<unsigned char>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<unsigned char>>,std::reverse_iterator<std::vector<unsigned char>*>,std::reverse_iterator<std::vector<unsigned char>*>,std::reverse_iterator<std::vector<unsigned char>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::reverse_iterator<std::vector<unsigned char>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::reverse_iterator<std::vector<unsigned char>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::reverse_iterator<std::vector<unsigned char>*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::reverse_iterator<std::vector<unsigned char>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t std::__split_buffer<std::vector<unsigned char>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::vector<unsigned char>>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<std::vector<unsigned char>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0);
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  unsigned __int8 *v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  BOOL v10;
  unint64_t v11;
  char *v12;
  unsigned __int8 v13;
  _BYTE *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned int v24;
  BOOL v25;
  char v26;
  unint64_t v27;
  _BYTE *v28;

  v3 = *(_QWORD *)(result + 8);
  if (v3 < 2)
    return 3;
  v4 = *(_BYTE **)result;
  if (*(_QWORD *)result == -1)
    goto LABEL_68;
  v5 = &v4[v3];
  v6 = v4 + 1;
  v7 = v3 - 1;
  v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4)
        goto LABEL_69;
      v14 = v12 + 1;
      v15 = *v12;
      v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15)
            v17 = *v12;
          else
            v17 = v7 - 1;
          v10 = v5 >= v14;
          v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3)
              return 0;
LABEL_34:
            result = 0;
            *a3 = v15;
            return result;
          }
LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }
        return 3;
      }
      v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8)
        return 3;
      if ((v15 & 0x7F) == 0 || v16 < v19)
        return 3;
      if (v14 >= v5 || v14 < v4)
        goto LABEL_69;
      if (!*v14)
        return 3;
      v15 = 0;
      v21 = (v19 - 1);
      v22 = v7 - v21 - 2;
      v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (_BYTE *)-1)
      {
        if (v14 >= v5)
          goto LABEL_69;
        v10 = v16-- != 0;
        if (!v10)
          goto LABEL_70;
        v24 = *v14++;
        v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!(_DWORD)v19)
        {
          if (a3)
            v25 = 0;
          else
            v25 = v15 > v22;
          v26 = v25;
          result = 3;
          if (v15 < 0x80 || (v26 & 1) != 0)
            return result;
          if (v15 >= v22)
            v27 = v22;
          else
            v27 = v15;
          v10 = (unint64_t)v5 >= v23;
          v28 = &v5[-v23];
          if (!v10 || (unint64_t)v4 > v23 || v27 > (unint64_t)v28)
            goto LABEL_69;
          a2[1] = v23;
          a2[2] = v27;
          if (a3)
            goto LABEL_34;
          return 0;
        }
      }
    }
LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }
  v9 = *v6;
  v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10)
    return 3;
  v8 = 0;
  result = 3;
  while (v7 >= 2)
  {
    v11 = v8;
    if (v8 >> 57)
      break;
    if (v6 == (unsigned __int8 *)-1)
      goto LABEL_68;
    if (v6 >= v5 || v6 < v4)
      goto LABEL_69;
    v12 = (char *)(v6 + 1);
    --v7;
    v13 = *v6;
    v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54)
        return 3;
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  uint64_t result;
  unint64_t v4[2];

  v4[1] = *MEMORY[0x24BDAC8D0];
  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  result = DERParseInteger64(a1, v4);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v4[0]))
    {
      return 7;
    }
    else
    {
      result = 0;
      *a2 = v4[0];
    }
  }
  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2;
  unsigned __int8 *v3;
  uint64_t result;
  unint64_t v5;
  unsigned int v6;

  v2 = (unint64_t)a1[1];
  if (!v2)
    return 3;
  v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0)
    return 3;
  if (**a1)
  {
    if (v2 > 8)
      return 7;
    goto LABEL_10;
  }
  if (v2 >= 2)
  {
    if (((char)v3[1] & 0x80000000) == 0)
      return 3;
    if (v2 > 9)
      return 7;
  }
LABEL_10:
  v5 = 0;
  do
  {
    v6 = *v3++;
    v5 = v6 | (v5 << 8);
    --v2;
  }
  while (v2);
  result = 0;
  *a2 = v5;
  return result;
}

uint64_t DERDecodeSeqInit(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8[4];

  v8[3] = *MEMORY[0x24BDAC8D0];
  memset(v8, 170, 24);
  result = DERDecodeItemPartialBufferGetLength(a1, v8, 0);
  if (!(_DWORD)result)
  {
    v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }
      else
      {
        v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          result = 0;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }
      __break(0x5519u);
    }
    else
    {
      return 2;
    }
  }
  return result;
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = *result;
  v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }
  else
  {
    v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD v10[3];

  v10[2] = *MEMORY[0x24BDAC8D0];
  v10[0] = 0;
  v2 = *a1;
  v3 = a1[1];
  if (*a1 >= v3)
    return 1;
  v10[0] = *a1;
  v10[1] = v3 - v2;
  result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0);
  if (!(_DWORD)result)
  {
    v8 = a2[1];
    v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        result = 0;
        *a1 = v9;
        return result;
      }
      __break(0x5519u);
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t DERParseSequenceToObject(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  uint64_t result;
  unint64_t v12[4];

  v12[3] = *MEMORY[0x24BDAC8D0];
  memset(v12, 170, 24);
  result = DERDecodeItemPartialBufferGetLength(a1, v12, 0);
  if (!(_DWORD)result)
  {
    if (v12[0] == 0x2000000000000010)
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    else
      return 2;
  }
  return result;
}

uint64_t DERParseSequenceContentToObject(unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int16 v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t result;
  unsigned __int16 v17;
  __int16 v18;
  unint64_t v19;
  char *v21;
  uint64_t v23;
  unint64_t v24;
  __int16 *v25;
  unint64_t v26;
  __int16 v27;
  unint64_t v28;
  char *v29;
  unint64_t v31[3];
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v32 = 0;
  if (a6)
  {
    if (a6 > a5)
      goto LABEL_59;
    bzero((void *)a4, a6);
  }
  v10 = *a1;
  v11 = a1[1];
  if (__CFADD__(*a1, v11))
    goto LABEL_58;
  v12 = v10 + v11;
  if (v10 > v12)
LABEL_59:
    __break(0x5519u);
  v32 = *a1;
  v33 = v12;
  if (a2)
  {
    v13 = 0;
    v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      v15 = v32;
      v14 = v33;
      result = DERDecodeSeqNext(&v32, v31);
      if ((_DWORD)result)
        break;
      if (a2 <= v13)
        return 2;
      while (1)
      {
        if (24 * (__int16)v13 > (unint64_t)~a3)
          goto LABEL_58;
        v17 = v13;
        v18 = *(_WORD *)(a3 + 24 * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(_QWORD *)(a3 + 24 * v13 + 8))
          break;
        result = 2;
        if ((v18 & 1) != 0)
        {
          ++v13;
          if (a2 > (unsigned __int16)(v17 + 1))
            continue;
        }
        return result;
      }
      if ((v18 & 4) == 0)
      {
        v19 = *(_QWORD *)(a3 + 24 * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5)
          return 7;
        if (v19 > ~a4)
          goto LABEL_58;
        v21 = (char *)(a4 + v19);
        if (v21 >= v29 || (unint64_t)v21 < a4)
          goto LABEL_59;
        *(_OWORD *)v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((_QWORD *)v21 + 1) <= v14 - v15)
            {
              *(_QWORD *)v21 = v15;
              return 3;
            }
            goto LABEL_59;
          }
          if (v21 + 16 > v29)
            goto LABEL_59;
          v23 = *((_QWORD *)v21 + 1);
          v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }
          if (v14 < v15 || v24 > v14 - v15)
            goto LABEL_59;
          *(_QWORD *)v21 = v15;
          *((_QWORD *)v21 + 1) = v24;
        }
      }
      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            v10 = v31[1] + v31[2];
            v12 = *a1 + v28;
            goto LABEL_47;
          }
        }
LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }
      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        v10 = v32;
        v12 = v33;
        goto LABEL_47;
      }
    }
    if ((_DWORD)result == 1)
    {
      if (a2 <= v13)
      {
        return 0;
      }
      else
      {
        v25 = (__int16 *)(a3 + 24 * v13 + 16);
        v26 = a2 - (unint64_t)v13;
        result = 0;
        while (1)
        {
          v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0)
            break;
          if (!--v26)
            return result;
        }
        return 5;
      }
    }
  }
  else
  {
LABEL_47:
    if (v10 == v12)
      return 0;
    else
      return 3;
  }
  return result;
}

uint64_t DERParseSequence(uint64_t result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4)
    return DERParseSequenceToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  __break(0x5519u);
  return result;
}

unint64_t *DERParseSequenceContent(unint64_t *result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4)
    return (unint64_t *)DERParseSequenceContentToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSequenceWithBlock(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4[4];

  v4[3] = *MEMORY[0x24BDAC8D0];
  memset(v4, 170, 24);
  result = DERDecodeItemPartialBufferGetLength(a1, v4, 0);
  if (!(_DWORD)result)
  {
    if (v4[0] - 0x2000000000000012 >= 0xFFFFFFFFFFFFFFFELL)
      return DERDecodeSequenceContentWithBlock(&v4[1], a2);
    else
      return 2;
  }
  return result;
}

uint64_t DERDecodeSequenceContentWithBlock(unint64_t *a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t result;
  char v7;
  unint64_t v8[3];
  unint64_t v9[3];

  v9[2] = *MEMORY[0x24BDAC8D0];
  v9[0] = 0;
  v2 = *a1;
  v3 = a1[1];
  if (__CFADD__(*a1, v3))
  {
    __break(0x5513u);
LABEL_13:
    __break(0x5519u);
  }
  v4 = v2 + v3;
  if (v2 > v4)
    goto LABEL_13;
  v9[0] = *a1;
  v9[1] = v4;
  memset(v8, 170, sizeof(v8));
  v7 = 0;
  while (1)
  {
    LODWORD(result) = DERDecodeSeqNext(v9, v8);
    if ((_DWORD)result)
      break;
    LODWORD(result) = (*(uint64_t (**)(uint64_t, unint64_t *, char *))(a2 + 16))(a2, v8, &v7);
    if ((_DWORD)result)
      break;
    if (v7)
      return 0;
  }
  if (result <= 1)
    return 0;
  else
    return result;
}

unint64_t DEREncodeLengthSized(unint64_t result, unint64_t a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;

  if (result >= 0x80)
  {
    v5 = 0;
    v6 = result;
    do
    {
      --v5;
      v7 = v6 > 0xFF;
      v6 >>= 8;
    }
    while (v7);
    v8 = -v5;
    v9 = 7;
    if (-v5 < a3 && v8 <= 0x7E)
    {
      if (*a4)
      {
        v4 = 1 - v5;
        *(_BYTE *)a2 = -(char)v5 | 0x80;
        if (v8 < ~a2)
        {
          v10 = (_BYTE *)(a2 - v5);
          if (a2 - v5 != -2)
          {
            v11 = (_BYTE *)(a2 + *a4);
            while (v10 != (_BYTE *)-1)
            {
              if (v10 >= v11 || (unint64_t)v10 < a2)
                goto LABEL_23;
              *v10-- = result;
              v7 = result > 0xFF;
              result >>= 8;
              if (!v7)
              {
                if (v8 >= *a4)
                  goto LABEL_23;
                goto LABEL_19;
              }
            }
          }
        }
        __break(0x5513u);
      }
      goto LABEL_23;
    }
    return v9;
  }
  if (!a3)
    return 7;
  if (*a4)
  {
    *(_BYTE *)a2 = result;
    if (*a4)
    {
      v4 = 1;
LABEL_19:
      v9 = 0;
      *a4 = v4;
      return v9;
    }
  }
LABEL_23:
  __break(0x5519u);
  return result;
}

uint64_t DEREncodeTag(uint64_t result, unint64_t a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  unint64_t v11;

  v3 = result & 0x1FFFFFFFFFFFFFFFLL;
  if ((result & 0x1FFFFFFFFFFFFFFFuLL) < 0x1F)
  {
    if (*a3)
    {
      *(_BYTE *)a2 = HIBYTE(result) & 0xE0 | result;
      v8 = 1;
      goto LABEL_17;
    }
    return 7;
  }
  v4 = 0;
  v5 = result & 0x1FFFFFFFFFFFFFFFLL;
  do
  {
    ++v4;
    v6 = v5 > 0x7F;
    v5 >>= 7;
  }
  while (v6);
  v7 = *a3;
  if (v4 >= *a3)
    return 7;
  if (v4 >= ~a2 || (*(_BYTE *)a2 = HIBYTE(result) | 0x1F, a2 + v4 == -2))
  {
LABEL_20:
    __break(0x5513u);
    goto LABEL_21;
  }
  if (a2 + v4 >= a2)
  {
    v8 = v4 + 1;
    *(_BYTE *)(a2 + v4) = result & 0x7F;
    if (v3 >= 0x80)
    {
      v9 = (_BYTE *)(a2 + v4 - 1);
      v10 = (_BYTE *)(a2 + v7);
      while (v9 != (_BYTE *)-2)
      {
        if (v9 >= v10 || (unint64_t)v9 < a2)
          goto LABEL_21;
        v11 = v3 >> 14;
        v3 >>= 7;
        *v9-- = v3 | 0x80;
        if (!v11)
          goto LABEL_17;
      }
      goto LABEL_20;
    }
LABEL_17:
    if (v8 <= *a3)
    {
      result = 0;
      *a3 = v8;
      return result;
    }
  }
LABEL_21:
  __break(0x5519u);
  return result;
}

uint64_t DEREncodeSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5, unint64_t a6, unint64_t a7, unint64_t *a8)
{
  unint64_t v8;
  unint64_t v11;
  uint64_t result;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _BYTE *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  const void **v27;
  __int16 v28;
  unint64_t v30;
  unint64_t v31;
  char v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  size_t v36;
  unint64_t v37;
  size_t v39;
  BOOL v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v44;
  unint64_t v45[2];

  v45[1] = *MEMORY[0x24BDAC8D0];
  v8 = ~a6;
  if (~a6 < a7)
    goto LABEL_73;
  v11 = *a8;
  v44 = a7;
  v45[0] = 0;
  if (v11 < a7)
    goto LABEL_74;
  result = DEREncodeTag(a1, a6, &v44);
  if ((_DWORD)result)
    return result;
  if (v44 > v8)
    goto LABEL_73;
  v17 = a7 - v44;
  if (a7 < v44)
    goto LABEL_75;
  v18 = a6 + a7;
  v19 = a6 + v44;
  if (a6 + v44 < v18)
  {
    result = DERContentLengthOfEncodedSequence(a2, a3, a4, a5, v45);
    if ((_DWORD)result)
      return result;
    v44 = v17;
    if (v19 > a6 + v11 || v19 < a6 || v17 > a6 + v11 - v19)
      goto LABEL_74;
    v42 = a6 + v11;
    v20 = v45[0];
    result = DEREncodeLengthSized(v45[0], v19, v17, (uint64_t *)&v44);
    if ((_DWORD)result)
      return result;
    v21 = v42;
    if (__CFADD__(v19, v44))
    {
LABEL_73:
      __break(0x5513u);
      goto LABEL_74;
    }
    v22 = v17 - v44;
    if (v17 >= v44)
    {
      v23 = (_BYTE *)(v19 + v44);
      if (!__CFADD__(v19 + v44, v20))
      {
        if ((unint64_t)&v23[v20] > v18)
          return 7;
        if (a4)
        {
          v24 = 0;
          v25 = a2 + a3;
          v41 = 24 * a4;
          while (1)
          {
            if (v24 > ~a5)
              goto LABEL_73;
            v26 = *(_QWORD *)(a5 + v24);
            if (v26 > ~a2)
              goto LABEL_73;
            v27 = (const void **)(a2 + v26);
            v28 = *(_WORD *)(a5 + v24 + 16);
            if ((v28 & 0x200) != 0)
              break;
            if ((v28 & 1) == 0)
              goto LABEL_29;
            if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
              goto LABEL_74;
            if (v27[1])
            {
LABEL_29:
              v44 = v22;
              if ((unint64_t)v23 > v21 || (unint64_t)v23 < a6 || v22 > v21 - (unint64_t)v23)
                goto LABEL_74;
              result = DEREncodeTag(*(_QWORD *)(a5 + v24 + 8), (unint64_t)v23, &v44);
              if ((_DWORD)result)
                return result;
              if (__CFADD__(v23, v44))
                goto LABEL_73;
              v30 = v22 - v44;
              if (v22 < v44)
                goto LABEL_75;
              if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
                goto LABEL_74;
              v31 = (unint64_t)v27[1];
              v45[0] = v31;
              v32 = 1;
              if ((v28 & 0x100) != 0 && v31 && *(char *)*v27 < 0)
              {
                v32 = 0;
                v45[0] = ++v31;
              }
              v33 = (unint64_t)&v23[v44];
              v44 = v30;
              if (v33 > v42 || v33 < a6 || v30 > v42 - v33)
                goto LABEL_74;
              result = DEREncodeLengthSized(v31, v33, v30, (uint64_t *)&v44);
              if ((_DWORD)result)
                return result;
              v34 = v44;
              if (__CFADD__(v33, v44))
                goto LABEL_73;
              v35 = v30 - v44;
              if (v30 < v44)
                goto LABEL_75;
              v23 = (_BYTE *)(v33 + v44);
              if ((v32 & 1) == 0)
              {
                if (v23 == (_BYTE *)-1)
                  goto LABEL_73;
                if ((unint64_t)v23 >= v42 || (unint64_t)v23 < a6)
                  goto LABEL_74;
                *v23 = 0;
                --v35;
                if (v30 == v34)
                  goto LABEL_75;
                ++v23;
              }
              if ((unint64_t)v23 > v42)
                goto LABEL_74;
              if ((unint64_t)v23 < a6)
                goto LABEL_74;
              v36 = (size_t)v27[1];
              if (v36 > v42 - (unint64_t)v23)
                goto LABEL_74;
              result = (uint64_t)memmove(v23, *v27, v36);
              v21 = v42;
              v37 = (unint64_t)v27[1];
              if (__CFADD__(v23, v37))
                goto LABEL_73;
              v22 = v35 - v37;
              if (v35 < v37)
                goto LABEL_75;
              goto LABEL_69;
            }
LABEL_70:
            v24 += 24;
            if (v41 == v24)
              goto LABEL_71;
          }
          if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
            goto LABEL_74;
          if ((unint64_t)v23 > v21)
            goto LABEL_74;
          if ((unint64_t)v23 < a6)
            goto LABEL_74;
          v39 = (size_t)v27[1];
          if (v39 > v21 - (unint64_t)v23)
            goto LABEL_74;
          result = (uint64_t)memmove(v23, *v27, v39);
          v21 = v42;
          v37 = (unint64_t)v27[1];
          if (__CFADD__(v23, v37))
            goto LABEL_73;
          v40 = v22 >= v37;
          v22 -= v37;
          if (!v40)
            goto LABEL_75;
LABEL_69:
          v23 += v37;
          goto LABEL_70;
        }
LABEL_71:
        if ((unint64_t)&v23[-a6] <= *a8)
        {
          result = 0;
          *a8 = (unint64_t)&v23[-a6];
          return result;
        }
LABEL_74:
        __break(0x5519u);
      }
      goto LABEL_73;
    }
LABEL_75:
    __break(0x5515u);
    return result;
  }
  return 7;
}

unint64_t DERContentLengthOfEncodedSequence(unint64_t result, unint64_t a2, int a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  unsigned __int8 **v10;
  __int16 v11;
  unint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned __int8 *v20;
  unint64_t v21;
  uint64_t v22;

  v5 = 0;
  if (!a3)
  {
LABEL_38:
    result = 0;
LABEL_40:
    *a5 = v5;
    return result;
  }
  v6 = 0;
  v7 = result + a2;
  while (24 * (unint64_t)v6 <= ~a4)
  {
    v8 = *(_QWORD *)(a4 + 24 * v6);
    v9 = v8 > 0xFFFFFFFFFFFFFFEFLL || v8 + 16 > a2;
    if (v9)
    {
      v5 = 0;
      result = 7;
      goto LABEL_40;
    }
    if (v8 > ~result)
      break;
    v10 = (unsigned __int8 **)(result + v8);
    v11 = *(_WORD *)(a4 + 24 * v6 + 16);
    if ((v11 & 0x200) == 0)
    {
      if ((v11 & 1) != 0)
      {
        if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
          goto LABEL_43;
        if (!v10[1])
          goto LABEL_37;
      }
      v13 = *(_QWORD *)(a4 + 24 * v6 + 8) & 0x1FFFFFFFFFFFFFFFLL;
      v14 = 1;
      if (v13 >= 0x1F)
      {
        do
        {
          ++v14;
          v9 = v13 > 0x7F;
          v13 >>= 7;
        }
        while (v9);
      }
      v15 = __CFADD__(v5, v14);
      v16 = v5 + v14;
      if (v15)
        goto LABEL_42;
      if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
        goto LABEL_43;
      v17 = (unint64_t)v10[1];
      if ((*(_WORD *)(a4 + 24 * v6 + 16) & 0x100) != 0)
      {
        if (v17)
        {
          v17 += (unint64_t)**v10 >> 7;
          goto LABEL_24;
        }
LABEL_25:
        v18 = 1;
      }
      else
      {
LABEL_24:
        if (v17 < 0x80)
          goto LABEL_25;
        v18 = 1;
        v21 = v17;
        do
        {
          ++v18;
          v9 = v21 > 0xFF;
          v21 >>= 8;
        }
        while (v9);
      }
      v15 = __CFADD__(v16, v18);
      v22 = v16 + v18;
      if (v15)
        goto LABEL_42;
      v15 = __CFADD__(v22, v17);
      v5 = v22 + v17;
      if (v15)
        goto LABEL_42;
      goto LABEL_37;
    }
    if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
      goto LABEL_43;
    v20 = v10[1];
    v15 = __CFADD__(v5, v20);
    v5 += (uint64_t)v20;
    if (v15)
      goto LABEL_42;
LABEL_37:
    if (++v6 == a3)
      goto LABEL_38;
  }
  __break(0x5513u);
LABEL_42:
  __break(0x5500u);
LABEL_43:
  __break(0x5519u);
  return result;
}

uint64_t DEREncodeSequence(uint64_t result, unint64_t a2, unsigned int a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  if ((a2 | 0x7FFFFFFFFFFFFFFFLL) >= a2)
    return DEREncodeSequenceFromObject(result, a2, ~a2 & 0x7FFFFFFFFFFFFFFFLL, a3, a4, a5, *a6, a6);
  __break(0x5519u);
  return result;
}

unint64_t DERLengthOfEncodedSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t *a6)
{
  unint64_t result;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x24BDAC8D0];
  v17[0] = 0;
  result = DERContentLengthOfEncodedSequence(a2, a3, a4, a5, v17);
  if (!(_DWORD)result)
  {
    v9 = a1 & 0x1FFFFFFFFFFFFFFFLL;
    v10 = 1;
    if ((a1 & 0x1FFFFFFFFFFFFFFFuLL) >= 0x1F)
    {
      do
      {
        ++v10;
        v11 = v9 > 0x7F;
        v9 >>= 7;
      }
      while (v11);
    }
    v12 = 1;
    if (v17[0] >= 0x80uLL)
    {
      v13 = v17[0];
      do
      {
        ++v12;
        v11 = v13 > 0xFF;
        v13 >>= 8;
      }
      while (v11);
    }
    v14 = __CFADD__(v10, v12);
    v15 = v10 + v12;
    if (v14 || (v14 = __CFADD__(v15, v17[0]), v16 = v15 + v17[0], v14))
    {
      __break(0x5500u);
    }
    else
    {
      result = 0;
      *a6 = v16;
    }
  }
  return result;
}

uint64_t DERLengthOfEncodedSequence(uint64_t a1, unint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5[2];

  v5[1] = *MEMORY[0x24BDAC8D0];
  v5[0] = 0;
  if ((a2 | 0x7FFFFFFFFFFFFFFFLL) < a2)
    __break(0x5519u);
  if (DERLengthOfEncodedSequenceFromObject(a1, a2, ~a2 & 0x7FFFFFFFFFFFFFFFLL, a3, a4, v5))
    return 0;
  else
    return v5[0];
}

SERestoreInfo::SN300V2DeviceInfo *SERestoreInfo::SN300V2DeviceInfo::SN300V2DeviceInfo(SERestoreInfo::SN300V2DeviceInfo *this, const SERestoreInfo::BLOB *a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  SERestoreInfo::SEWrongDeviceInfo *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_24E0BF620;
  if (*((_DWORD *)v3 + 14) != 54)
  {
    exception = (SERestoreInfo::SEWrongDeviceInfo *)__cxa_allocate_exception(0x48uLL);
    SERestoreInfo::SEWrongDeviceInfo::SEWrongDeviceInfo(exception);
  }
  return this;
}

void sub_21CC90678(_Unwind_Exception *a1)
{
  SERestoreInfo::P73BaseDeviceInfo *v1;

  SERestoreInfo::P73BaseDeviceInfo::~P73BaseDeviceInfo(v1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::P73BaseDeviceInfo::~P73BaseDeviceInfo(SERestoreInfo::P73BaseDeviceInfo *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
  JUMPOUT(0x22078A808);
}

void SERestoreInfo::SN300V2DeviceInfo::~SN300V2DeviceInfo(SERestoreInfo::SN300V2DeviceInfo *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
  JUMPOUT(0x22078A808);
}

_QWORD *SERestoreInfo::P73BaseDeviceInfo::getOsKeyId@<X0>(SERestoreInfo::P73BaseDeviceInfo *this@<X0>, _QWORD *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(a2, *((const void **)this + 14), *((_QWORD *)this + 15), *((_QWORD *)this + 15) - *((_QWORD *)this + 14));
}

uint64_t SERestoreInfo::P73BaseDeviceInfo::getChipID(SERestoreInfo::P73BaseDeviceInfo *this)
{
  return *((unsigned int *)this + 14);
}

SERestoreInfo::SEWrongDeviceInfo *SERestoreInfo::SEWrongDeviceInfo::SEWrongDeviceInfo(SERestoreInfo::SEWrongDeviceInfo *this)
{
  void *__p[2];
  char v4;

  std::string::basic_string[abi:ne180100]<0>(__p, "Wrong DeviceInfo");
  SERestoreInfo::SEException::SEException((uint64_t)this, (__int128 *)__p, 2, CFSTR("SEUpdaterErrorDomain"));
  if (v4 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = &unk_24E0BF688;
  return this;
}

void SERestoreInfo::SEWrongDeviceInfo::~SEWrongDeviceInfo(std::exception *this)
{
  SERestoreInfo::SEException::~SEException(this);
  JUMPOUT(0x22078A808);
}

uint64_t SERestoreInfo::SEException::what(SERestoreInfo::SEException *this)
{
  uint64_t result;

  result = (uint64_t)this + 8;
  if (*((char *)this + 31) < 0)
    return *(_QWORD *)result;
  return result;
}

void AlohaVerificationOptions::print(AlohaVerificationOptions *this)
{
  SEUpdaterUtil::SELogObj *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  SEUpdaterUtil::SELogObj *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  SEUpdaterUtil::SELogObj *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  __int128 v29;

  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v29);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v29);
    v3 = (std::__shared_weak_count *)*((_QWORD *)&v29 + 1);
    if (*((_QWORD *)&v29 + 1))
    {
      v4 = (unint64_t *)(*((_QWORD *)&v29 + 1) + 8);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v6 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v7 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v2, (SEUpdaterUtil::SELogObj *)2, 0, 1, "print", (SEUpdaterUtil::SELogObj *)"Verify options:\n");
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v11 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v29);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v29);
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v29 + 1);
    if (*((_QWORD *)&v29 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v29 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    v11 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v15 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v16 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v11, (SEUpdaterUtil::SELogObj *)2, 0, 1, "print", (SEUpdaterUtil::SELogObj *)"  useDebugSSEInterface: %d\n", this->var0);
  if (v15)
  {
    v18 = (unint64_t *)&v15->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v20 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v29);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v29);
    v21 = (std::__shared_weak_count *)*((_QWORD *)&v29 + 1);
    if (*((_QWORD *)&v29 + 1))
    {
      v22 = (unint64_t *)(*((_QWORD *)&v29 + 1) + 8);
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    v20 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v24 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v25 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v20, (SEUpdaterUtil::SELogObj *)2, 0, 1, "print", (SEUpdaterUtil::SELogObj *)"  restoreEnvironment: %d\n", this->var1);
  if (v24)
  {
    v27 = (unint64_t *)&v24->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
}

void sub_21CC90C10(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

void verifyAlohaPairing(uint64_t *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  AlohaPairingVerifier *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  AlohaPairingVerifier *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  void *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;

  v6 = [AlohaPairingVerifier alloc];
  v7 = (std::__shared_weak_count *)a1[1];
  v15 = *a1;
  v16 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = -[AlohaPairingVerifier initWithController:options:](v6, "initWithController:options:", &v15, a2);
  v11 = v16;
  if (v16)
  {
    v12 = (unint64_t *)&v16->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  -[AlohaPairingVerifier performAlohaVerification](v10, "performAlohaVerification");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  _ObjCLog((SEUpdaterUtil::SELogObj *)2, "verifyAlohaPairing", CFSTR("Verified result -- %@\n"), v14);
  -[AlohaPairingVerifier invalidate](v10, "invalidate");
  if (v14)
  {
    *a3 = v14;
    CFRetain(v14);
  }
  else
  {
    *a3 = 0;
  }

}

void sub_21CC90D80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_21CC90E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void sub_21CC91238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  const void *v9;
  va_list va;
  uint64_t v11;
  const void *v12;
  va_list va1;
  uint64_t v14;
  const void *v15;
  va_list va2;
  va_list va3;

  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v9 = va_arg(va1, const void *);
  v11 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v12 = va_arg(va2, const void *);
  v14 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v15 = va_arg(va3, const void *);
  ctu::cf::detail::TakeOwnershipProxy<__CFData const>::~TakeOwnershipProxy((const void **)va);
  ctu::cf::detail::TakeOwnershipProxy<__CFData const>::~TakeOwnershipProxy((const void **)va1);
  ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)va2);
  ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)va3);

  _Unwind_Resume(a1);
}

uint64_t ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

void sub_21CC914FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t getSSEIOConnect(void)
{
  mach_port_t v0;
  const __CFDictionary *v1;
  io_service_t MatchingService;
  io_object_t v3;
  kern_return_t v4;

  if ((_MergedGlobals_0 & 1) == 0)
  {
    v0 = *MEMORY[0x24BDD8B18];
    v1 = IOServiceMatching("AppleSSE");
    MatchingService = IOServiceGetMatchingService(v0, v1);
    if (MatchingService)
    {
      v3 = MatchingService;
      v4 = IOServiceOpen(MatchingService, *MEMORY[0x24BDAEC58], 0, (io_connect_t *)&dword_25532372C);
      IOObjectRelease(v3);
      if (!v4)
        _MergedGlobals_0 = 1;
    }
  }
  return dword_25532372C;
}

void sub_21CC9185C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a5);

  ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

void sub_21CC91A10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_21CC91B6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t *SEUpdaterUtil::SELogObj::printLog(SEUpdaterUtil::SELogObj *this, SEUpdaterUtil::SELogObj *a2, int a3, int a4, const char *a5, SEUpdaterUtil::SELogObj *a6, ...)
{
  va_list va;

  va_start(va, a6);
  return SEUpdaterUtil::SELogObj::printLogv(this, a2, a3, a4, a5, a6, va);
}

_QWORD *SEUpdaterUtil::SELogObj::create_default_global@<X0>(_QWORD *a1@<X8>)
{
  SEUpdaterUtil::SELogObj *v3;

  v3 = (SEUpdaterUtil::SELogObj *)operator new();
  SEUpdaterUtil::SELogObj::SELogObj(v3);
  return std::shared_ptr<SEUpdaterUtil::SELogObj>::shared_ptr[abi:ne180100]<SEUpdaterUtil::SELogObj,void>(a1, v3);
}

void sub_21CC91C2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x22078A808](v1, 0x10B0C409C89B6A6);
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

_QWORD *std::shared_ptr<SEUpdaterUtil::SELogObj>::shared_ptr[abi:ne180100]<SEUpdaterUtil::SELogObj,void>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_24E0BF7B0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  std::shared_ptr<SEUpdaterUtil::SELogObj>::__enable_weak_this[abi:ne180100]<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,void>((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_21CC91D28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<SEUpdaterUtil::SELogObj>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void std::shared_ptr<SEUpdaterUtil::SELogObj>::__enable_weak_this[abi:ne180100]<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,void>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  if (a2)
  {
    v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
        do
          v9 = __ldxr(p_shared_weak_owners);
        while (__stxr(v9 + 1, p_shared_weak_owners));
        v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4)
        std::__shared_weak_count::__release_weak(v4);
      if (v5)
      {
        v10 = (unint64_t *)&v5->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
  }
}

void std::__shared_ptr_pointer<SEUpdaterUtil::SELogObj *,std::shared_ptr<SEUpdaterUtil::SELogObj>::__shared_ptr_default_delete<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj>,std::allocator<SEUpdaterUtil::SELogObj>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_pointer<SEUpdaterUtil::SELogObj *,std::shared_ptr<SEUpdaterUtil::SELogObj>::__shared_ptr_default_delete<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj>,std::allocator<SEUpdaterUtil::SELogObj>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    boost::circular_buffer<unsigned char,std::allocator<unsigned char>>::destroy((char **)(v1 + 56));
    ctu::SharedSynchronizable<SEUpdaterUtil::Error>::~SharedSynchronizable((_QWORD *)v1);
    JUMPOUT(0x22078A808);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<SEUpdaterUtil::SELogObj *,std::shared_ptr<SEUpdaterUtil::SELogObj>::__shared_ptr_default_delete<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj>,std::allocator<SEUpdaterUtil::SELogObj>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

uint64_t *std::unique_ptr<SEUpdaterUtil::SELogObj>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    boost::circular_buffer<unsigned char,std::allocator<unsigned char>>::destroy((char **)(v2 + 56));
    ctu::SharedSynchronizable<SEUpdaterUtil::Error>::~SharedSynchronizable((_QWORD *)v2);
    JUMPOUT(0x22078A808);
  }
  return result;
}

uint64_t *SEUpdaterUtil::SELogObj::printLogv(SEUpdaterUtil::SELogObj *this, SEUpdaterUtil::SELogObj *a2, int a3, int a4, const char *a5, SEUpdaterUtil::SELogObj *a6, va_list a7)
{
  const char *v13[6];

  v13[5] = *(const char **)MEMORY[0x24BDAC8D0];
  SEUpdaterUtil::SELogObj::FormatMsgv(a6, a7, v13);
  if (v13[0])
    SEUpdaterUtil::SELogObj::printFormattedLog(this, a2, a3, a4, (uint64_t)a5, v13);
  return std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100]((uint64_t *)v13);
}

void sub_21CC91FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t SEUpdaterUtil::SELogObj::FormatMsgv@<X0>(SEUpdaterUtil::SELogObj *this@<X0>, va_list a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t result;
  uint64_t v7;
  char *v8;
  _QWORD v9[3];
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = 0;
  result = vasprintf(&v8, (const char *)this, a2);
  if ((int)result < 1 || v8 == 0)
  {
    *a3 = 0;
    a3[4] = 0;
    return result;
  }
  v9[0] = &off_24E0BF720;
  v10 = v9;
  *a3 = v8;
  std::__function::__value_func<void ()(char const*)>::__value_func[abi:ne180100]((uint64_t)(a3 + 1), (uint64_t)v9);
  result = (uint64_t)v10;
  if (v10 == v9)
  {
    v7 = 4;
    result = (uint64_t)v9;
  }
  else
  {
    if (!v10)
      return result;
    v7 = 5;
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v7))();
}

void SEUpdaterUtil::SELogObj::printFormattedLog(SEUpdaterUtil::SELogObj *a1, SEUpdaterUtil::SELogObj *this, int a3, int a4, uint64_t a5, const char **a6)
{
  int v8;
  const char *v10;
  size_t v11;
  SEUpdaterUtil::SELogObj *v12;
  const char *v13;
  uint64_t v14[6];

  v8 = (int)this;
  v14[5] = *MEMORY[0x24BDAC8D0];
  v10 = *a6;
  if (!a4
    || (SEUpdaterUtil::SELogObj::createVerboseLogString(this, *a6, (const char *)1, a5, v14),
        std::unique_ptr<char const,std::function<void ()(char const*)>>::operator=[abi:ne180100]((uint64_t *)a6, v14),
        std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100](v14),
        (v10 = *a6) != 0))
  {
    v11 = strlen(v10);
    SEUpdaterUtil::SELogObj::addLog(a1, v10, v11);
    if (*((_DWORD *)a1 + 12) > v8)
    {
      if (a3)
      {
        SEUpdaterUtil::SELogObj::print(a1, "********************************************************************************\n");
        SEUpdaterUtil::SELogObj::print(a1, *a6);
        v12 = a1;
        v13 = "********************************************************************************\n";
      }
      else
      {
        v13 = *a6;
        v12 = a1;
      }
      SEUpdaterUtil::SELogObj::print(v12, v13);
    }
  }
}

void std::__function::__func<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1},std::allocator<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1}>,void ()(char const*)>::~__func()
{
  JUMPOUT(0x22078A808);
}

_QWORD *std::__function::__func<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1},std::allocator<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1}>,void ()(char const*)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24E0BF720;
  return result;
}

void std::__function::__func<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1},std::allocator<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1}>,void ()(char const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24E0BF720;
}

void std::__function::__func<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1},std::allocator<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1}>,void ()(char const*)>::operator()(uint64_t a1, void **a2)
{
  free(*a2);
}

uint64_t std::__function::__func<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1},std::allocator<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1}>,void ()(char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1},std::allocator<SEUpdaterUtil::SELogObj::FormatMsgv(char const*,char *)::{lambda(char const*)#1}>,void ()(char const*)>::target_type()
{
}

uint64_t std::__function::__value_func<void ()(char const*)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t SEUpdaterUtil::SELogObj::createVerboseLogString@<X0>(SEUpdaterUtil::SELogObj *this@<X0>, const char *a2@<X2>, const char *a3@<X3>, uint64_t a4@<X1>, _QWORD *a5@<X8>)
{
  int v7;
  void *exception;
  std::string *v11;
  timeval v12;
  std::string v13;
  timeval v14;
  std::string::size_type v15;

  if (this >= 5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v13, "Assertion: ");
    v11 = std::string::append(&v13, "level >= 0 && level < _LOG_LEVEL_MAX && \"level is not good\"");
    v12 = *(timeval *)&v11->__r_.__value_.__l.__data_;
    v15 = v11->__r_.__value_.__r.__words[2];
    v14 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v14);
  }
  v7 = (int)this;
  if (!(_DWORD)a3)
    return SEUpdaterUtil::SELogObj::FormatMsg((SEUpdaterUtil::SELogObj *)"[%s] %s: %s", a5, SEUpdaterUtil::logLevelNames[this], a4, a2);
  v14.tv_sec = 0;
  *(_QWORD *)&v14.tv_usec = 0;
  gettimeofday(&v14, 0);
  return SEUpdaterUtil::SELogObj::FormatMsg((SEUpdaterUtil::SELogObj *)"[%3.3ld.%1.1d] [%s] %s: %s", a5, v14.tv_sec, (v14.tv_usec / 1000), SEUpdaterUtil::logLevelNames[v7], a4, a2);
}

void sub_21CC9241C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;
  int v26;

  if (a25 < 0)
    operator delete(__p);
  if (a19 < 0)
  {
    operator delete(a14);
    if ((v26 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v26)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v25);
  goto LABEL_8;
}

uint64_t *std::unique_ptr<char const,std::function<void ()(char const*)>>::operator=[abi:ne180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;

  v4 = *a2;
  *a2 = 0;
  std::unique_ptr<char const,std::function<void ()(char const*)>>::reset[abi:ne180100](a1, v4);
  std::__function::__value_func<void ()(char const*)>::operator=[abi:ne180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

void SEUpdaterUtil::SELogObj::addLog(SEUpdaterUtil::SELogObj *this, const char *a2, uint64_t a3)
{
  _QWORD v4[7];
  _QWORD *v5;

  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 3221225472;
  v4[2] = ___ZN13SEUpdaterUtil8SELogObj6addLogEPKcm_block_invoke;
  v4[3] = &__block_descriptor_56_e5_v8__0l;
  v4[4] = this;
  v4[5] = a2;
  v4[6] = a3;
  v5 = v4;
  ctu::SharedSynchronizable<SEUpdaterUtil::SELogObj>::execute_wrapped_sync<void({block_pointer} {__strong}&)(void)>((uint64_t)this, (uint64_t)&v5);

}

void SEUpdaterUtil::SELogObj::print(SEUpdaterUtil::SELogObj *this, const char *a2)
{
  _QWORD v3[6];
  _QWORD *v4;

  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = ___ZN13SEUpdaterUtil8SELogObj5printEPKc_block_invoke;
  v3[3] = &__block_descriptor_48_e5_v8__0l;
  v3[4] = this;
  v3[5] = a2;
  v4 = v3;
  ctu::SharedSynchronizable<SEUpdaterUtil::SELogObj>::execute_wrapped_sync<void({block_pointer} {__strong}&)(void)>((uint64_t)this, (uint64_t)&v4);

}

uint64_t SEUpdaterUtil::SELogObj::FormatMsg@<X0>(SEUpdaterUtil::SELogObj *this@<X0>, _QWORD *a2@<X8>, ...)
{
  va_list va;

  va_start(va, a2);
  return SEUpdaterUtil::SELogObj::FormatMsgv(this, va, a2);
}

uint64_t *std::unique_ptr<char const,std::function<void ()(char const*)>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v4 = v2;
    v3 = result[4];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v4);
  }
  return result;
}

_QWORD *std::__function::__value_func<void ()(char const*)>::operator=[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = (_QWORD *)a1[3];
  a1[3] = 0;
  if (v4 == a1)
  {
    v5 = 4;
    v4 = a1;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  v6 = *(_QWORD *)(a2 + 24);
  if (v6)
  {
    if (v6 == a2)
    {
      a1[3] = a1;
      (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v6;
      *(_QWORD *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void ctu::SharedSynchronizable<SEUpdaterUtil::SELogObj>::execute_wrapped_sync<void({block_pointer} {__strong}&)(void)>(uint64_t a1, uint64_t a2)
{
  void *v3;
  id *v4;
  NSObject *v5;
  _QWORD v6[6];

  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 3221225472;
  v6[2] = ___ZNK3ctu20SharedSynchronizableIN13SEUpdaterUtil8SELogObjEE20execute_wrapped_syncIRU8__strongU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS9__block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = a1;
  v6[5] = a2;
  v3 = (void *)MEMORY[0x22078AC64](v6);
  v4 = (id *)(a1 + 16);
  if (*(_QWORD *)(a1 + 24))
  {
    dispatch::queue::operator*(v4);
    v5 = objc_claimAutoreleasedReturnValue();
    dispatch_async_and_wait(v5, v3);
  }
  else
  {
    dispatch::queue::operator*(v4);
    v5 = objc_claimAutoreleasedReturnValue();
    dispatch_sync(v5, v3);
  }

}

id dispatch::queue::operator*(id *a1)
{
  return *a1;
}

_QWORD *boost::circular_buffer<unsigned char,std::allocator<unsigned char>>::insert<char const*>(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BYTE *v4;
  _QWORD *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  _QWORD v14[2];

  v4 = (_BYTE *)(a4 - a3);
  if (a4 != a3)
  {
    v7 = result;
    v9 = *result;
    v8 = (char *)result[1];
    v14[0] = result;
    v14[1] = 0;
    result = (_QWORD *)boost::cb_details::iterator<boost::circular_buffer<unsigned char,std::allocator<unsigned char>>,boost::cb_details::nonconst_traits<std::allocator<unsigned char>>>::operator-<boost::cb_details::nonconst_traits<std::allocator<unsigned char>>>((uint64_t)v14, a2);
    if ((char *)result + v9 != v8)
    {
      v10 = v8 - ((char *)result + v9);
      v11 = &v4[-v10];
      if ((unint64_t)v4 < v10)
        v11 = 0;
      v12 = &v11[a3];
      if ((unint64_t)v4 >= v10)
        v13 = (_BYTE *)(v8 - ((char *)result + v9));
      else
        v13 = v4;
      v14[0] = v12;
      return boost::circular_buffer<unsigned char,std::allocator<unsigned char>>::insert_n<boost::cb_details::iterator_wrapper<char const*>>(v7, a2, v13, v14);
    }
  }
  return result;
}

uint64_t boost::cb_details::iterator<boost::circular_buffer<unsigned char,std::allocator<unsigned char>>,boost::cb_details::nonconst_traits<std::allocator<unsigned char>>>::operator-<boost::cb_details::nonconst_traits<std::allocator<unsigned char>>>(uint64_t a1, uint64_t a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v2 = *(unint64_t **)a1;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
  {
    v3 = *v2;
    v5 = v2[4];
    goto LABEL_5;
  }
  v4 = v2[2];
  if (v3 < v4)
  {
    v5 = v2[1] - v4;
LABEL_5:
    v6 = v3 + v5;
    goto LABEL_7;
  }
  v6 = *v2 + v3 - v4;
LABEL_7:
  v7 = *(_QWORD *)(a2 + 8);
  if (v7)
  {
    v8 = v2[2];
    if (v7 >= v8)
    {
      v10 = *v2 + v7 - v8;
      return v6 - v10;
    }
    v9 = v2[1] - v8;
  }
  else
  {
    v7 = *v2;
    v9 = v2[4];
  }
  v10 = v7 + v9;
  return v6 - v10;
}

_QWORD *boost::circular_buffer<unsigned char,std::allocator<unsigned char>>::insert_n<boost::cb_details::iterator_wrapper<char const*>>(_QWORD *result, uint64_t a2, _BYTE *a3, _QWORD *a4)
{
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  char v14;
  _BYTE *v15;
  _BYTE *v16;
  _BYTE *v17;
  _BYTE *v18;
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;

  v5 = (_BYTE *)*result;
  v4 = (_BYTE *)result[1];
  v6 = (_BYTE *)result[3];
  v7 = result[4] + *result;
  v8 = &v4[-v7];
  if (&v4[-v7] >= a3)
    v9 = a3;
  else
    v9 = &v4[-v7];
  v10 = *(_BYTE **)(a2 + 8);
  if (v10)
  {
    if (v6 != v10)
    {
      v11 = v4 - v6;
      v12 = (uint64_t)&v5[a3 - 1 - v4];
      if (v11 > (uint64_t)(a3 - 1))
        v12 = (uint64_t)(a3 - 1);
      v13 = &v6[v12];
      do
      {
        if (v6 == v5)
          v6 = (_BYTE *)result[1];
        v14 = *--v6;
        *v13 = v14;
        v5 = (_BYTE *)*result;
        if (v13 == (_BYTE *)*result)
          v13 = (_BYTE *)result[1];
        --v13;
      }
      while (v6 != *(_BYTE **)(a2 + 8));
    }
    if (a3)
    {
      v15 = a3;
      do
      {
        v16 = (_BYTE *)(*a4)++;
        *v10++ = *v16;
        v4 = (_BYTE *)result[1];
        if (v10 == v4)
          v10 = (_BYTE *)*result;
        --v15;
      }
      while (v15);
    }
    else
    {
      v4 = (_BYTE *)result[1];
    }
  }
  else
  {
    if (v9)
    {
      v17 = v9;
      do
      {
        v18 = (_BYTE *)(*a4)++;
        *v6++ = *v18;
        v4 = (_BYTE *)result[1];
        if (v6 == v4)
          v6 = (_BYTE *)*result;
        --v17;
      }
      while (v17);
    }
    if (v8 < a3)
    {
      v19 = a3 - v9;
      do
      {
        v20 = (_BYTE *)(*a4)++;
        *v6++ = *v20;
        v4 = (_BYTE *)result[1];
        if (v6 == v4)
          v6 = (_BYTE *)*result;
        --v19;
      }
      while (v19);
    }
  }
  v21 = result[3];
  v22 = a3;
  if ((uint64_t)&v4[-v21] <= (uint64_t)a3)
    v22 = (_BYTE *)(a3 - v4 + *result);
  result[3] = &v22[v21];
  v23 = result[2];
  v24 = a3 - v9;
  if ((uint64_t)&v4[-v23] <= a3 - v9)
    v24 = v24 - (_QWORD)v4 + *result;
  result[2] = v23 + v24;
  result[4] += v9;
  return result;
}

uint64_t ___ZN13SEUpdaterUtil8SELogObj5printEPKc_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 32))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), *(_QWORD *)(a1 + 40));
}

uint64_t *std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;

  std::unique_ptr<char const,std::function<void ()(char const*)>>::reset[abi:ne180100](a1, 0);
  v2 = (uint64_t *)a1[4];
  if (v2 == a1 + 1)
  {
    v3 = 4;
    v2 = a1 + 1;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

const void **ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **ctu::cf::detail::TakeOwnershipProxy<__CFData const>::~TakeOwnershipProxy(const void **a1)
{
  const void **v2;
  const void *v3;
  const void *v4;
  const void *v6;

  v2 = (const void **)a1[1];
  if (*a1)
  {
    v3 = *v2;
    *v2 = *a1;
    v6 = v3;
  }
  else
  {
    v4 = *v2;
    *v2 = 0;
    v6 = v4;
  }
  ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef(&v6);
  return a1;
}

const void **ctu::cf::detail::TakeOwnershipProxy<__CFError>::~TakeOwnershipProxy(const void **a1)
{
  const void **v2;
  const void *v3;
  const void *v4;
  const void *v6;

  v2 = (const void **)a1[1];
  if (*a1)
  {
    v3 = *v2;
    *v2 = *a1;
    v6 = v3;
  }
  else
  {
    v4 = *v2;
    *v2 = 0;
    v6 = v4;
  }
  ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::~SharedRef(&v6);
  return a1;
}

uint64_t DERParseDERSequenceSpecContent(unint64_t *a1, uint64_t a2, char *a3, size_t a4)
{
  unsigned int v7;
  unint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  _WORD *v12;
  __int16 v13;
  char *v14;
  unint64_t v15;
  unsigned int v16;
  __int16 *v17;
  uint64_t v18;
  __int16 v19;
  unint64_t v21;
  __int128 v22;
  unint64_t v23;
  unint64_t v24;

  if (a4)
    bzero(a3, a4);
  v23 = 0;
  v24 = 0;
  DERDecodeSeqContentInit(a1, &v23);
  if (!*(_WORD *)(a2 + 8))
  {
LABEL_20:
    if (v23 > v24)
      return 3;
    if (v23 < v24 && !*(_BYTE *)(a2 + 10))
      return 2;
    return 0;
  }
  v7 = 0;
  while (1)
  {
    v21 = 0;
    v22 = 0uLL;
    v8 = v23;
    result = DERDecodeSeqNext(&v23, &v21);
    if ((_DWORD)result)
      break;
    v10 = *(unsigned __int16 *)(a2 + 8);
    if (v7 >= v10)
    {
      if (!*(_BYTE *)(a2 + 10))
        return 2;
    }
    else
    {
      v11 = v7;
      v12 = (_WORD *)(*(_QWORD *)a2 + 24 * v7 + 16);
      while (1)
      {
        v13 = *v12;
        if ((*v12 & 2) != 0 || v21 == *((_QWORD *)v12 - 1))
          break;
        if ((v13 & 1) == 0)
          return 2;
        ++v11;
        v12 += 12;
        if (v10 == v11)
          goto LABEL_19;
      }
      if ((v13 & 4) == 0)
      {
        v14 = &a3[*((_QWORD *)v12 - 2)];
        *(_OWORD *)v14 = v22;
        if ((v13 & 8) != 0)
        {
          v15 = v22 - v8 + *((_QWORD *)v14 + 1);
          *(_QWORD *)v14 = v8;
          *((_QWORD *)v14 + 1) = v15;
        }
      }
      v7 = (unsigned __int16)v11 + 1;
      LODWORD(v10) = *(unsigned __int16 *)(a2 + 8);
      if (v7 == (_DWORD)v10)
        goto LABEL_20;
    }
LABEL_19:
    if (v7 >= v10)
      goto LABEL_20;
  }
  if ((_DWORD)result == 1)
  {
    v16 = *(unsigned __int16 *)(a2 + 8);
    if (v7 < v16)
    {
      v17 = (__int16 *)(*(_QWORD *)a2 + 24 * v7 + 16);
      v18 = v7 + 1;
      while (1)
      {
        v19 = *v17;
        v17 += 12;
        if ((v19 & 1) == 0)
          break;
        if (v16 == (unsigned __int16)v18++)
          return 0;
      }
      return 5;
    }
    return 0;
  }
  return result;
}

void SEUpdater::GetPackageInfo(uint64_t *a1@<X0>, std::string::size_type *a2@<X8>)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  std::string::size_type v18;
  std::string::size_type v19;
  std::string::size_type v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  std::string::size_type size;
  unint64_t v27;
  std::string::size_type v28;
  uint64_t v29;
  std::string::size_type v30;
  uint64_t v31;
  int64x2_t v32;
  char *v33;
  unint64_t v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *p_shared_owners;
  unint64_t v41;
  void *v42;
  std::string *v43;
  __int128 v44;
  void *v45;
  std::string *v46;
  void *v47;
  void *exception;
  uint64_t v49;
  int v50;
  std::string *v51;
  void *v52;
  uint64_t *v53;
  int v54;
  std::string v55;
  uint64_t *v56;
  uint64_t *v57;
  std::__shared_weak_count *v58;
  void *v59[2];
  char v60;
  _QWORD v61[5];
  void *__p[2];
  char v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  _QWORD v67[2];
  std::string v68;
  char *v69;
  _QWORD *v70;
  std::string v71;
  __n128 (*v72)(_QWORD *, uint64_t);
  void (*v73)(uint64_t);
  __int128 v74;
  _BYTE v75[32];
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v56, 0x2037uLL);
  v56 = (uint64_t *)&unk_24E0BF828;
  v4 = *a1;
  SEUpdater::CommandSelectISD::CommandSelectISD((SEUpdater::CommandSelectISD *)&v71);
  SEUpdater::P73BaseSEController::transceive(v4, (uint64_t)&v71, &v56, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  v71.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
  v5 = (std::__shared_weak_count *)v71.__r_.__value_.__r.__words[2];
  if (v71.__r_.__value_.__r.__words[2])
  {
    v6 = (unint64_t *)(v71.__r_.__value_.__r.__words[2] + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = v57[1];
  if ((unint64_t)(v8 - *v57) < 2
    || (*(unsigned __int8 *)(v8 - 1) | (*(unsigned __int8 *)(v8 - 2) << 8)) != 0x9000)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    v49 = v57[1];
    if ((unint64_t)(v49 - *v57) < 2)
      v50 = 43947;
    else
      v50 = *(unsigned __int8 *)(v49 - 1) | (*(unsigned __int8 *)(v49 - 2) << 8);
    std::to_string(&v55, v50);
    v51 = std::string::insert(&v55, 0, "Bad SW from SELECT: ");
    v71 = *v51;
    v51->__r_.__value_.__l.__size_ = 0;
    v51->__r_.__value_.__r.__words[2] = 0;
    v51->__r_.__value_.__r.__words[0] = 0;
    v52 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, (__int128 *)&v71, 8, CFSTR("SEUpdaterErrorDomain"));
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v71.__r_.__value_.__r.__words[0] = 0x4F0600000210AF80;
  LODWORD(v71.__r_.__value_.__r.__words[1]) = 1325554688;
  WORD2(v71.__r_.__value_.__r.__words[1]) = 132;
  v71.__r_.__value_.__s.__data_[14] = 0;
  SERestoreInfo::CApdu::CApdu(&v55, &v71, 0xFuLL, 0);
  v55.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0BFA08;
  v53 = a1;
  do
  {
    SEUpdater::P73BaseSEController::transceive(*a1, (uint64_t)&v55, &v56, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    v9 = v57[1];
    if ((unint64_t)(v9 - *v57) < 2)
      v10 = 43947;
    else
      v10 = *(unsigned __int8 *)(v9 - 1) | (*(unsigned __int8 *)(v9 - 2) << 8);
    SERestoreInfo::Apdu::SetP2((uint64_t)&v55, 3);
    if (v10 != 25360 && v10 != 36864)
    {
      v45 = __cxa_allocate_exception(0x48uLL);
      std::to_string(&v68, v10);
      v46 = std::string::insert(&v68, 0, "Bad SW from GET_STATUS: ");
      v71 = *v46;
      v46->__r_.__value_.__l.__size_ = 0;
      v46->__r_.__value_.__r.__words[2] = 0;
      v46->__r_.__value_.__r.__words[0] = 0;
      v47 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v45, (__int128 *)&v71, 8, CFSTR("SEUpdaterErrorDomain"));
    }
    v11 = *v57;
    v12 = v57[1] - *v57;
    if (v12 <= 1)
      __assert_rtn("getDataSize", "Apdu.hpp", 382, "len >= 2");
    v54 = v10;
    v13 = v12 - 2;
    if (v13)
    {
      v14 = v11 + v13;
      do
      {
        v67[0] = v11;
        v67[1] = v14 - v11;
        v64 = 0;
        v65 = 0;
        v66 = 0;
        v15 = DERDecodeItem((uint64_t)v67, &v64);
        std::string::basic_string[abi:ne180100]<0>(__p, "DERDecodeItem");
        SERestoreInfo::CallAndThrow<DERReturn>(v15, (uint64_t)__p);
        if (v63 < 0)
          operator delete(__p[0]);
        if (v64 != 0xE000000000000003)
        {
          v42 = __cxa_allocate_exception(0x10uLL);
          std::string::basic_string[abi:ne180100]<0>(&v68, "Assertion: ");
          v43 = std::string::append(&v68, "info.tag == (ASN1_PRIVATE | ASN1_CONSTRUCTED | 0x3)");
          v44 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
          v71.__r_.__value_.__r.__words[2] = v43->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v71.__r_.__value_.__l.__data_ = v44;
          v43->__r_.__value_.__l.__size_ = 0;
          v43->__r_.__value_.__r.__words[2] = 0;
          v43->__r_.__value_.__r.__words[0] = 0;
          MEMORY[0x22078A520](v42, &v71);
        }
        v71.__r_.__value_.__r.__words[0] = 0;
        v71.__r_.__value_.__l.__size_ = (std::string::size_type)&v71;
        v71.__r_.__value_.__r.__words[2] = 0x5802000000;
        v72 = __Block_byref_object_copy__1;
        v73 = __Block_byref_object_dispose__1;
        v74 = 0u;
        memset(v75, 0, sizeof(v75));
        v61[0] = MEMORY[0x24BDAC760];
        v61[1] = 0x40000000;
        v61[2] = ___ZN9SEUpdaterL11ParseE3TLVsERKN13SERestoreInfo5RApduERNSt3__16vectorINS_11PackageInfoENS4_9allocatorIS6_EEEE_block_invoke;
        v61[3] = &unk_24E0BFA48;
        v61[4] = &v71;
        v16 = DERDecodeSequenceContentWithBlock(&v65, (uint64_t)v61);
        std::string::basic_string[abi:ne180100]<0>(v59, "DERDecodeSequenceContentWithBlock");
        SERestoreInfo::CallAndThrow<DERReturn>(v16, (uint64_t)v59);
        if (v60 < 0)
          operator delete(v59[0]);
        v17 = v71.__r_.__value_.__l.__size_ + 40;
        v19 = a2[1];
        v18 = a2[2];
        if (v19 >= v18)
        {
          v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - *a2) >> 4);
          v22 = v21 + 1;
          if (v21 + 1 > 0x555555555555555)
            std::vector<std::string>::__throw_length_error[abi:ne180100]();
          v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v18 - *a2) >> 4);
          if (2 * v23 > v22)
            v22 = 2 * v23;
          if (v23 >= 0x2AAAAAAAAAAAAAALL)
            v24 = 0x555555555555555;
          else
            v24 = v22;
          v70 = a2 + 2;
          if (v24)
          {
            if (v24 > 0x555555555555555)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v25 = (char *)operator new(48 * v24);
          }
          else
          {
            v25 = 0;
          }
          v68.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
          v68.__r_.__value_.__l.__size_ = (std::string::size_type)&v25[48 * v21];
          v68.__r_.__value_.__r.__words[2] = v68.__r_.__value_.__l.__size_;
          v69 = &v25[48 * v24];
          std::allocator<SEUpdater::PackageInfo>::construct[abi:ne180100]<SEUpdater::PackageInfo,SEUpdater::PackageInfo const&>((_QWORD *)v68.__r_.__value_.__l.__size_, v17);
          size = v68.__r_.__value_.__l.__size_;
          v20 = v68.__r_.__value_.__r.__words[2] + 48;
          v68.__r_.__value_.__r.__words[2] += 48;
          v28 = *a2;
          v27 = a2[1];
          if (v27 == *a2)
          {
            v32 = vdupq_n_s64(v27);
          }
          else
          {
            v29 = 0;
            do
            {
              v30 = size + v29;
              v31 = v27 + v29;
              *(_QWORD *)(v30 - 48) = 0;
              *(_QWORD *)(v30 - 40) = 0;
              *(_QWORD *)(v30 - 32) = 0;
              *(_OWORD *)(v30 - 48) = *(_OWORD *)(v27 + v29 - 48);
              *(_QWORD *)(v30 - 32) = *(_QWORD *)(v27 + v29 - 32);
              *(_QWORD *)(v31 - 48) = 0;
              *(_QWORD *)(v31 - 40) = 0;
              *(_QWORD *)(v31 - 32) = 0;
              *(_QWORD *)(v30 - 24) = 0;
              *(_QWORD *)(v30 - 16) = 0;
              *(_QWORD *)(v30 - 8) = 0;
              *(_OWORD *)(v30 - 24) = *(_OWORD *)(v27 + v29 - 24);
              *(_QWORD *)(v30 - 8) = *(_QWORD *)(v27 + v29 - 8);
              *(_QWORD *)(v31 - 24) = 0;
              *(_QWORD *)(v31 - 16) = 0;
              *(_QWORD *)(v31 - 8) = 0;
              v29 -= 48;
            }
            while (v27 + v29 != v28);
            v32 = *(int64x2_t *)a2;
            v20 = v68.__r_.__value_.__r.__words[2];
            size += v29;
          }
          *a2 = size;
          a2[1] = v20;
          *(int64x2_t *)&v68.__r_.__value_.__r.__words[1] = v32;
          v33 = (char *)a2[2];
          a2[2] = (std::string::size_type)v69;
          v69 = v33;
          v68.__r_.__value_.__r.__words[0] = v32.i64[0];
          std::__split_buffer<SEUpdater::PackageInfo>::~__split_buffer((uint64_t)&v68);
        }
        else
        {
          std::allocator<SEUpdater::PackageInfo>::construct[abi:ne180100]<SEUpdater::PackageInfo,SEUpdater::PackageInfo const&>((_QWORD *)a2[1], v71.__r_.__value_.__l.__size_ + 40);
          v20 = v19 + 48;
          a2[1] = v19 + 48;
        }
        a2[1] = v20;
        v34 = v65;
        v35 = v66;
        _Block_object_dispose(&v71, 8);
        v68.__r_.__value_.__r.__words[0] = (std::string::size_type)&v75[8];
        std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v68);
        if ((_QWORD)v74)
        {
          *((_QWORD *)&v74 + 1) = v74;
          operator delete((void *)v74);
        }
        v11 = v34 + v35;
      }
      while (v34 + v35 != v14);
    }
    a1 = v53;
  }
  while (v54 == 25360);
  v55.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
  v36 = (std::__shared_weak_count *)v55.__r_.__value_.__r.__words[2];
  if (v55.__r_.__value_.__r.__words[2])
  {
    v37 = (unint64_t *)(v55.__r_.__value_.__r.__words[2] + 8);
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  v56 = (uint64_t *)&unk_24E0BF880;
  v39 = v58;
  if (v58)
  {
    p_shared_owners = (unint64_t *)&v58->__shared_owners_;
    do
      v41 = __ldaxr(p_shared_owners);
    while (__stlxr(v41 - 1, p_shared_owners));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
}

void sub_21CC93598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  uint64_t v52;
  unint64_t *p_shared_owners;
  unint64_t v55;

  if (*(char *)(v52 - 185) < 0)
    operator delete(*(void **)(v52 - 208));
  if (a17 < 0)
    operator delete(__p);
  if (a24)
  {
    p_shared_owners = (unint64_t *)&a24->__shared_owners_;
    do
      v55 = __ldaxr(p_shared_owners);
    while (__stlxr(v55 - 1, p_shared_owners));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))a24->__on_zero_shared)(a24);
      std::__shared_weak_count::__release_weak(a24);
    }
  }
  _Unwind_Resume(exception_object);
}

void SEUpdater::CommandSelectISD::~CommandSelectISD(SEUpdater::CommandSelectISD *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

uint64_t SERestoreInfo::Apdu::SetP2(uint64_t this, char a2)
{
  uint64_t *v2;
  uint64_t v3;

  v2 = *(uint64_t **)(this + 8);
  if (!v2 || (v3 = *v2, (unint64_t)(*(_QWORD *)(*(_QWORD *)(this + 8) + 8) - v3) <= 4))
    __assert_rtn("SetP2", "Apdu.hpp", 164, "bytes && bytes->size() >= sizeof(CApduHeader_t)");
  *(_BYTE *)(v3 + 3) = a2;
  return this;
}

void SEUpdater::CommandGetStatusProprietaryPackages::~CommandGetStatusProprietaryPackages(SEUpdater::CommandGetStatusProprietaryPackages *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SERestoreInfo::RApdu::~RApdu(SERestoreInfo::RApdu *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::GetInstanceInfo(uint64_t *a1@<X0>, std::string::size_type *a2@<X8>)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  std::string::size_type v18;
  std::string::size_type v19;
  std::string::size_type v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  std::string::size_type size;
  unint64_t v27;
  std::string::size_type v28;
  __int128 v29;
  int64x2_t v30;
  char *v31;
  unint64_t v32;
  uint64_t v33;
  SEUpdaterUtil::SELogObj *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *p_shared_owners;
  unint64_t v42;
  std::string::size_type v43;
  std::string::size_type v44;
  SEUpdaterUtil::SELogObj *v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  std::string *v51;
  int v52;
  std::string::size_type v53;
  std::string *v54;
  void **v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  SEUpdaterUtil::SELogObj *v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  unint64_t *v66;
  unint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  void *v74;
  std::string *v75;
  __int128 v76;
  void *v77;
  void *v78;
  void *v79;
  std::string *v80;
  void *v81;
  void *exception;
  uint64_t v83;
  int v84;
  std::string *v85;
  void *v86;
  uint64_t *v87;
  int v88;
  std::string v89;
  uint64_t *v90;
  uint64_t *v91;
  std::__shared_weak_count *v92;
  void *v93[2];
  char v94;
  void *v95[2];
  uint64_t (*v96)(uint64_t, uint64_t *);
  void *v97;
  std::string *v98;
  void *__p[2];
  char v100;
  SEUpdaterUtil::SELogObj *v101;
  std::__shared_weak_count *v102;
  uint64_t v103;
  _QWORD v104[2];
  std::string v105;
  char *v106;
  _QWORD *v107;
  std::string v108;
  __n128 (*v109)(_QWORD *, uint64_t);
  void (*v110)(_QWORD *);
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  uint64_t v115;
  uint64_t v116;

  v116 = *MEMORY[0x24BDAC8D0];
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v90, 0x2037uLL);
  v90 = (uint64_t *)&unk_24E0BF828;
  v4 = *a1;
  SEUpdater::CommandSelectISD::CommandSelectISD((SEUpdater::CommandSelectISD *)&v108);
  SEUpdater::P73BaseSEController::transceive(v4, (uint64_t)&v108, &v90, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  v108.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
  v5 = (std::__shared_weak_count *)v108.__r_.__value_.__r.__words[2];
  if (v108.__r_.__value_.__r.__words[2])
  {
    v6 = (unint64_t *)(v108.__r_.__value_.__r.__words[2] + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = v91[1];
  if ((unint64_t)(v8 - *v91) < 2
    || (*(unsigned __int8 *)(v8 - 1) | (*(unsigned __int8 *)(v8 - 2) << 8)) != 0x9000)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    v83 = v91[1];
    if ((unint64_t)(v83 - *v91) < 2)
      v84 = 43947;
    else
      v84 = *(unsigned __int8 *)(v83 - 1) | (*(unsigned __int8 *)(v83 - 2) << 8);
    std::to_string(&v89, v84);
    v85 = std::string::insert(&v89, 0, "Bad SW from SELECT: ");
    v108 = *v85;
    v85->__r_.__value_.__l.__size_ = 0;
    v85->__r_.__value_.__r.__words[2] = 0;
    v85->__r_.__value_.__r.__words[0] = 0;
    v86 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, (__int128 *)&v108, 8, CFSTR("SEUpdaterErrorDomain"));
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  *(_OWORD *)&v108.__r_.__value_.__l.__data_ = xmmword_21CCD7856;
  v108.__r_.__value_.__s.__data_[16] = 0;
  SERestoreInfo::CApdu::CApdu(&v89, &v108, 0x11uLL, 0);
  v89.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0BFA78;
  v87 = a1;
  do
  {
    SEUpdater::P73BaseSEController::transceive(*a1, (uint64_t)&v89, &v90, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    v9 = v91[1];
    if ((unint64_t)(v9 - *v91) < 2)
      v10 = 43947;
    else
      v10 = *(unsigned __int8 *)(v9 - 1) | (*(unsigned __int8 *)(v9 - 2) << 8);
    SERestoreInfo::Apdu::SetP2((uint64_t)&v89, 3);
    if (v10 != 25360 && v10 != 36864)
    {
      v79 = __cxa_allocate_exception(0x48uLL);
      std::to_string(&v105, v10);
      v80 = std::string::insert(&v105, 0, "Bad SW from GET_STATUS: ");
      v108 = *v80;
      v80->__r_.__value_.__l.__size_ = 0;
      v80->__r_.__value_.__r.__words[2] = 0;
      v80->__r_.__value_.__r.__words[0] = 0;
      v81 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v79, (__int128 *)&v108, 8, CFSTR("SEUpdaterErrorDomain"));
    }
    v11 = *v91;
    v12 = v91[1] - *v91;
    if (v12 <= 1)
      __assert_rtn("getDataSize", "Apdu.hpp", 382, "len >= 2");
    v88 = v10;
    v13 = v12 - 2;
    if (v13)
    {
      v14 = v11 + v13;
      do
      {
        v104[0] = v11;
        v104[1] = v14 - v11;
        v101 = 0;
        v102 = 0;
        v103 = 0;
        v15 = DERDecodeItem((uint64_t)v104, (unint64_t *)&v101);
        std::string::basic_string[abi:ne180100]<0>(__p, "DERDecodeItem");
        SERestoreInfo::CallAndThrow<DERReturn>(v15, (uint64_t)__p);
        if (v100 < 0)
          operator delete(__p[0]);
        if (v101 != (SEUpdaterUtil::SELogObj *)0xE000000000000003)
        {
          v74 = __cxa_allocate_exception(0x10uLL);
          std::string::basic_string[abi:ne180100]<0>(&v105, "Assertion: ");
          v75 = std::string::append(&v105, "info.tag == (ASN1_PRIVATE | ASN1_CONSTRUCTED | 0x3)");
          v76 = *(_OWORD *)&v75->__r_.__value_.__l.__data_;
          v108.__r_.__value_.__r.__words[2] = v75->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v108.__r_.__value_.__l.__data_ = v76;
          v75->__r_.__value_.__l.__size_ = 0;
          v75->__r_.__value_.__r.__words[2] = 0;
          v75->__r_.__value_.__r.__words[0] = 0;
          MEMORY[0x22078A520](v74, &v108);
        }
        v108.__r_.__value_.__r.__words[0] = 0;
        v108.__r_.__value_.__l.__size_ = (std::string::size_type)&v108;
        v108.__r_.__value_.__r.__words[2] = 0x7002000000;
        v109 = __Block_byref_object_copy__46;
        v110 = __Block_byref_object_dispose__47;
        v111 = 0u;
        v112 = 0u;
        v113 = 0u;
        v114 = 0u;
        v115 = 0;
        v95[0] = (void *)MEMORY[0x24BDAC760];
        v95[1] = (void *)0x40000000;
        v96 = ___ZN9SEUpdaterL11ParseE3TLVsERKN13SERestoreInfo5RApduERNSt3__16vectorINS_12InstanceInfoENS4_9allocatorIS6_EEEE_block_invoke;
        v97 = &unk_24E0BFAB8;
        v98 = &v108;
        v16 = DERDecodeSequenceContentWithBlock((unint64_t *)&v102, (uint64_t)v95);
        std::string::basic_string[abi:ne180100]<0>(v93, "DERDecodeSequenceContentWithBlock");
        SERestoreInfo::CallAndThrow<DERReturn>(v16, (uint64_t)v93);
        if (v94 < 0)
          operator delete(v93[0]);
        v17 = v108.__r_.__value_.__l.__size_ + 40;
        if (*(_QWORD *)(v108.__r_.__value_.__l.__size_ + 40) == *(_QWORD *)(v108.__r_.__value_.__l.__size_ + 48)
          || *(_QWORD *)(v108.__r_.__value_.__l.__size_ + 88) == *(_QWORD *)(v108.__r_.__value_.__l.__size_ + 96)
          || *(_QWORD *)(v108.__r_.__value_.__l.__size_ + 64) == *(_QWORD *)(v108.__r_.__value_.__l.__size_ + 72))
        {
          v77 = __cxa_allocate_exception(0x48uLL);
          std::string::basic_string[abi:ne180100]<0>(&v105, "Received incomplete E3 TLV from GetStatusApplications");
          v78 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v77, (__int128 *)&v105, 36, CFSTR("SEUpdaterErrorDomain"));
        }
        v19 = a2[1];
        v18 = a2[2];
        if (v19 >= v18)
        {
          v21 = 0x8E38E38E38E38E39 * ((uint64_t)(v19 - *a2) >> 3);
          v22 = v21 + 1;
          if (v21 + 1 > 0x38E38E38E38E38ELL)
            std::vector<std::string>::__throw_length_error[abi:ne180100]();
          v23 = 0x8E38E38E38E38E39 * ((uint64_t)(v18 - *a2) >> 3);
          if (2 * v23 > v22)
            v22 = 2 * v23;
          if (v23 >= 0x1C71C71C71C71C7)
            v24 = 0x38E38E38E38E38ELL;
          else
            v24 = v22;
          v107 = a2 + 2;
          if (v24)
          {
            if (v24 > 0x38E38E38E38E38ELL)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v25 = (char *)operator new(72 * v24);
          }
          else
          {
            v25 = 0;
          }
          v105.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
          v105.__r_.__value_.__l.__size_ = (std::string::size_type)&v25[72 * v21];
          v105.__r_.__value_.__r.__words[2] = v105.__r_.__value_.__l.__size_;
          v106 = &v25[72 * v24];
          std::allocator<SEUpdater::InstanceInfo>::construct[abi:ne180100]<SEUpdater::InstanceInfo,SEUpdater::InstanceInfo const&>((_QWORD *)v105.__r_.__value_.__l.__size_, v17);
          size = v105.__r_.__value_.__l.__size_;
          v20 = v105.__r_.__value_.__r.__words[2] + 72;
          v105.__r_.__value_.__r.__words[2] += 72;
          v28 = *a2;
          v27 = a2[1];
          if (v27 == *a2)
          {
            v30 = vdupq_n_s64(v27);
          }
          else
          {
            do
            {
              *(_QWORD *)(size - 72) = 0;
              *(_QWORD *)(size - 64) = 0;
              size -= 72;
              *(_QWORD *)(size + 16) = 0;
              v29 = *(_OWORD *)(v27 - 72);
              v27 -= 72;
              *(_OWORD *)size = v29;
              *(_QWORD *)(size + 16) = *(_QWORD *)(v27 + 16);
              *(_QWORD *)v27 = 0;
              *(_QWORD *)(v27 + 8) = 0;
              *(_QWORD *)(v27 + 16) = 0;
              *(_QWORD *)(size + 24) = 0;
              *(_QWORD *)(size + 32) = 0;
              *(_QWORD *)(size + 40) = 0;
              *(_OWORD *)(size + 24) = *(_OWORD *)(v27 + 24);
              *(_QWORD *)(size + 40) = *(_QWORD *)(v27 + 40);
              *(_QWORD *)(v27 + 24) = 0;
              *(_QWORD *)(v27 + 32) = 0;
              *(_QWORD *)(v27 + 40) = 0;
              *(_QWORD *)(size + 48) = 0;
              *(_QWORD *)(size + 56) = 0;
              *(_QWORD *)(size + 64) = 0;
              *(_OWORD *)(size + 48) = *(_OWORD *)(v27 + 48);
              *(_QWORD *)(size + 64) = *(_QWORD *)(v27 + 64);
              *(_QWORD *)(v27 + 48) = 0;
              *(_QWORD *)(v27 + 56) = 0;
              *(_QWORD *)(v27 + 64) = 0;
            }
            while (v27 != v28);
            v30 = *(int64x2_t *)a2;
            v20 = v105.__r_.__value_.__r.__words[2];
          }
          *a2 = size;
          a2[1] = v20;
          *(int64x2_t *)&v105.__r_.__value_.__r.__words[1] = v30;
          v31 = (char *)a2[2];
          a2[2] = (std::string::size_type)v106;
          v106 = v31;
          v105.__r_.__value_.__r.__words[0] = v30.i64[0];
          std::__split_buffer<SEUpdater::InstanceInfo>::~__split_buffer((uint64_t)&v105);
        }
        else
        {
          std::allocator<SEUpdater::InstanceInfo>::construct[abi:ne180100]<SEUpdater::InstanceInfo,SEUpdater::InstanceInfo const&>((_QWORD *)a2[1], v108.__r_.__value_.__l.__size_ + 40);
          v20 = v19 + 72;
          a2[1] = v19 + 72;
        }
        a2[1] = v20;
        v32 = (unint64_t)v102;
        v33 = v103;
        _Block_object_dispose(&v108, 8);
        if ((_QWORD)v114)
        {
          *((_QWORD *)&v114 + 1) = v114;
          operator delete((void *)v114);
        }
        if (*((_QWORD *)&v112 + 1))
        {
          *(_QWORD *)&v113 = *((_QWORD *)&v112 + 1);
          operator delete(*((void **)&v112 + 1));
        }
        if ((_QWORD)v111)
        {
          *((_QWORD *)&v111 + 1) = v111;
          operator delete((void *)v111);
        }
        v11 = v32 + v33;
      }
      while (v32 + v33 != v14);
    }
    a1 = v87;
  }
  while (v88 == 25360);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v34 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v108);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v108);
    v35 = (std::__shared_weak_count *)v108.__r_.__value_.__l.__size_;
    if (v108.__r_.__value_.__l.__size_)
    {
      v36 = (unint64_t *)(v108.__r_.__value_.__l.__size_ + 8);
      do
        v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
    v34 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v38 = (std::__shared_weak_count *)off_2553234C8;
  v105.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
  v105.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v39 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v40 = __ldxr(v39);
    while (__stxr(v40 + 1, v39));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v34, (SEUpdaterUtil::SELogObj *)3, 0, 1, "GetInstanceInfo", (SEUpdaterUtil::SELogObj *)"-- GET STATUS APPLICATIONS -- \n");
  if (v38)
  {
    p_shared_owners = (unint64_t *)&v38->__shared_owners_;
    do
      v42 = __ldaxr(p_shared_owners);
    while (__stlxr(v42 - 1, p_shared_owners));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  v43 = *a2;
  v44 = a2[1];
  if (*a2 != v44)
  {
    do
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v45 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v108);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v108);
        v46 = (std::__shared_weak_count *)v108.__r_.__value_.__l.__size_;
        if (v108.__r_.__value_.__l.__size_)
        {
          v47 = (unint64_t *)(v108.__r_.__value_.__l.__size_ + 8);
          do
            v48 = __ldaxr(v47);
          while (__stlxr(v48 - 1, v47));
          if (!v48)
          {
            ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
            std::__shared_weak_count::__release_weak(v46);
          }
        }
        v45 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v101 = v45;
      v102 = (std::__shared_weak_count *)off_2553234C8;
      if (off_2553234C8)
      {
        v49 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v50 = __ldxr(v49);
        while (__stxr(v50 + 1, v49));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      ctu::hex();
      if ((v108.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v51 = &v108;
      else
        v51 = (std::string *)v108.__r_.__value_.__r.__words[0];
      ctu::hex();
      v52 = SHIBYTE(v105.__r_.__value_.__r.__words[2]);
      v53 = v105.__r_.__value_.__r.__words[0];
      ctu::hex();
      v54 = &v105;
      if (v52 < 0)
        v54 = (std::string *)v53;
      v55 = v95;
      if (SHIBYTE(v96) < 0)
        v55 = (void **)v95[0];
      SEUpdaterUtil::SELogObj::printLog(v45, (SEUpdaterUtil::SELogObj *)3, 0, 1, "GetInstanceInfo", (SEUpdaterUtil::SELogObj *)"  Instance %s Module %s LC %s\n", (const char *)v51, (const char *)v54, (const char *)v55);
      if (SHIBYTE(v96) < 0)
        operator delete(v95[0]);
      if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v105.__r_.__value_.__l.__data_);
      if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v108.__r_.__value_.__l.__data_);
      v56 = v102;
      if (v102)
      {
        v57 = (unint64_t *)&v102->__shared_owners_;
        do
          v58 = __ldaxr(v57);
        while (__stlxr(v58 - 1, v57));
        if (!v58)
        {
          ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
          std::__shared_weak_count::__release_weak(v56);
        }
      }
      v43 += 72;
    }
    while (v43 != v44);
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v59 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v108);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v108);
    v60 = (std::__shared_weak_count *)v108.__r_.__value_.__l.__size_;
    if (v108.__r_.__value_.__l.__size_)
    {
      v61 = (unint64_t *)(v108.__r_.__value_.__l.__size_ + 8);
      do
        v62 = __ldaxr(v61);
      while (__stlxr(v62 - 1, v61));
      if (!v62)
      {
        ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
        std::__shared_weak_count::__release_weak(v60);
      }
    }
    v59 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v63 = (std::__shared_weak_count *)off_2553234C8;
  v105.__r_.__value_.__r.__words[0] = (std::string::size_type)v59;
  v105.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v64 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v65 = __ldxr(v64);
    while (__stxr(v65 + 1, v64));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v59, (SEUpdaterUtil::SELogObj *)3, 0, 1, "GetInstanceInfo", (SEUpdaterUtil::SELogObj *)"-- ----------------------- -- \n");
  if (v63)
  {
    v66 = (unint64_t *)&v63->__shared_owners_;
    do
      v67 = __ldaxr(v66);
    while (__stlxr(v67 - 1, v66));
    if (!v67)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }
  v89.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
  v68 = (std::__shared_weak_count *)v89.__r_.__value_.__r.__words[2];
  if (v89.__r_.__value_.__r.__words[2])
  {
    v69 = (unint64_t *)(v89.__r_.__value_.__r.__words[2] + 8);
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
      std::__shared_weak_count::__release_weak(v68);
    }
  }
  v90 = (uint64_t *)&unk_24E0BF880;
  v71 = v92;
  if (v92)
  {
    v72 = (unint64_t *)&v92->__shared_owners_;
    do
      v73 = __ldaxr(v72);
    while (__stlxr(v73 - 1, v72));
    if (!v73)
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
}

void sub_21CC94404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,std::__shared_weak_count *a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  std::__shared_weak_count *v57;
  unint64_t *p_shared_owners;
  unint64_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;

  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  __p = &unk_24E0BF880;
  v57 = a18;
  if (a18)
  {
    p_shared_owners = (unint64_t *)&a18->__shared_owners_;
    do
      v59 = __ldaxr(p_shared_owners);
    while (__stlxr(v59 - 1, p_shared_owners));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
  std::vector<SEUpdater::InstanceInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  a23 = &unk_24E0BF880;
  v60 = a25;
  if (a25)
  {
    v61 = (unint64_t *)&a25->__shared_owners_;
    do
      v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
      std::__shared_weak_count::__release_weak(v60);
    }
  }
  _Unwind_Resume(a1);
}

void SEUpdater::CommandGetStatusProprietaryInstance::~CommandGetStatusProprietaryInstance(SEUpdater::CommandGetStatusProprietaryInstance *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::GetAvailableMemory(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  SEUpdaterUtil::SELogObj *v11;
  std::__shared_weak_count *size;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  BOOL v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  SEUpdaterUtil::SELogObj *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  SEUpdaterUtil::SELogObj *v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  SEUpdaterUtil::SELogObj *v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  unint64_t *v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  void *v58;
  std::string *v59;
  __int128 v60;
  void *v61;
  std::string *v62;
  __int128 v63;
  void *exception;
  uint64_t v65;
  int v66;
  std::string *v67;
  void *v68;
  int v69;
  void *v70;
  std::string *v71;
  void *v72;
  std::string v73[2];
  uint64_t *v74;
  _QWORD *v75;
  std::__shared_weak_count *v76;
  std::string v77;
  std::string v78;
  void *__p[2];
  char v80;
  std::string v81;
  __int128 v82;
  std::string v83;
  void *v84;
  uint64_t v85;
  uint64_t v86;

  v86 = *MEMORY[0x24BDAC8D0];
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v74, 0x2037uLL);
  v74 = (uint64_t *)&unk_24E0BF828;
  v6 = *a1;
  SEUpdater::CommandSelectISD::CommandSelectISD((SEUpdater::CommandSelectISD *)v73);
  SEUpdater::P73BaseSEController::transceive(v6, (uint64_t)v73, &v74, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  v73[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
  v7 = (std::__shared_weak_count *)v73[0].__r_.__value_.__r.__words[2];
  if (v73[0].__r_.__value_.__r.__words[2])
  {
    v8 = (unint64_t *)(v73[0].__r_.__value_.__r.__words[2] + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = v75[1];
  if ((unint64_t)(v10 - *v75) < 2
    || (*(unsigned __int8 *)(v10 - 1) | (*(unsigned __int8 *)(v10 - 2) << 8)) != 0x9000)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    v65 = v75[1];
    if ((unint64_t)(v65 - *v75) < 2)
      v66 = 43947;
    else
      v66 = *(unsigned __int8 *)(v65 - 1) | (*(unsigned __int8 *)(v65 - 2) << 8);
    std::to_string(&v83, v66);
    v67 = std::string::insert(&v83, 0, "Bad SW from SELECT: ");
    v73[0] = *v67;
    v67->__r_.__value_.__l.__size_ = 0;
    v67->__r_.__value_.__r.__words[2] = 0;
    v67->__r_.__value_.__r.__words[0] = 0;
    v68 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, (__int128 *)v73, 8, CFSTR("SEUpdaterErrorDomain"));
  }
  *(_DWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  if ((*(_DWORD *)(*(_QWORD *)a2 + 184) + 1) <= 0x14)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v11 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(v73);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)v73);
      size = (std::__shared_weak_count *)v73[0].__r_.__value_.__l.__size_;
      if (v73[0].__r_.__value_.__l.__size_)
      {
        v13 = (unint64_t *)(v73[0].__r_.__value_.__l.__size_ + 8);
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
          std::__shared_weak_count::__release_weak(size);
        }
      }
      v11 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v15 = (std::__shared_weak_count *)off_2553234C8;
    v83.__r_.__value_.__r.__words[0] = (std::string::size_type)v11;
    v83.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v16 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v11, (SEUpdaterUtil::SELogObj *)3, 0, 1, "GetAvailableMemory", (SEUpdaterUtil::SELogObj *)"-- JCOP Train too low to GET DATA AVAILABLE MEMORY -- \n");
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v19 = __ldaxr(p_shared_owners);
      while (__stlxr(v19 - 1, p_shared_owners));
      goto LABEL_82;
    }
    goto LABEL_84;
  }
  v83.__r_.__value_.__r.__words[0] = 0x2ADF02FE00CA80;
  SERestoreInfo::CApdu::CApdu(v73, &v83, 8uLL, 0);
  v73[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0BFAE8;
  SEUpdater::P73BaseSEController::transceive(*a1, (uint64_t)v73, &v74, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  v20 = v75[1];
  v21 = v20 - *v75;
  v22 = v21 >= 2;
  v23 = v21 - 2;
  if (!v22)
  {
    v69 = 43947;
    goto LABEL_96;
  }
  v69 = *(unsigned __int8 *)(v20 - 1) | (*(unsigned __int8 *)(*v75 + v23) << 8);
  if (v69 != 36864)
  {
LABEL_96:
    v70 = __cxa_allocate_exception(0x48uLL);
    std::to_string(&v81, v69);
    v71 = std::string::insert(&v81, 0, "Bad SW from GET_DATA AVAILABLE MEMORY: ");
    v83 = *v71;
    v71->__r_.__value_.__l.__size_ = 0;
    v71->__r_.__value_.__r.__words[2] = 0;
    v71->__r_.__value_.__r.__words[0] = 0;
    v72 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v70, (__int128 *)&v83, 8, CFSTR("SEUpdaterErrorDomain"));
  }
  *(_QWORD *)&v82 = *v75;
  *((_QWORD *)&v82 + 1) = v23;
  memset(&v81, 0, sizeof(v81));
  v24 = DERDecodeItem((uint64_t)&v82, (unint64_t *)&v81);
  std::string::basic_string[abi:ne180100]<0>(__p, "DERDecodeItem");
  SERestoreInfo::CallAndThrow<DERReturn>(v24, (uint64_t)__p);
  if (v80 < 0)
    operator delete(__p[0]);
  if (v81.__r_.__value_.__r.__words[0] != 0xE00000000000001ELL)
  {
    v58 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v78, "Assertion: ");
    v59 = std::string::append(&v78, "info.tag == (ASN1_PRIVATE | ASN1_CONSTRUCTED | 0x1E)");
    v60 = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
    v83.__r_.__value_.__r.__words[2] = v59->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v83.__r_.__value_.__l.__data_ = v60;
    v59->__r_.__value_.__l.__size_ = 0;
    v59->__r_.__value_.__r.__words[2] = 0;
    v59->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v58, &v83);
  }
  v82 = *(_OWORD *)&v81.__r_.__value_.__r.__words[1];
  v25 = DERDecodeItem((uint64_t)&v82, (unint64_t *)&v81);
  std::string::basic_string[abi:ne180100]<0>(&v78, "DERDecodeItem");
  SERestoreInfo::CallAndThrow<DERReturn>(v25, (uint64_t)&v78);
  if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v78.__r_.__value_.__l.__data_);
  if (v81.__r_.__value_.__r.__words[0] != 0xC00000000000002ALL)
  {
    v61 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v77, "Assertion: ");
    v62 = std::string::append(&v77, "info.tag == (ASN1_PRIVATE | ASN1_PRIMITIVE | 0x2A)");
    v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v83.__r_.__value_.__r.__words[2] = v62->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v83.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0;
    v62->__r_.__value_.__r.__words[2] = 0;
    v62->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v61, &v83);
  }
  v83.__r_.__value_.__r.__words[0] = MEMORY[0x24BDAC760];
  v83.__r_.__value_.__l.__size_ = 0x40000000;
  v83.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN9SEUpdaterL13ParseDF2ATLVsERKN13SERestoreInfo5RApduERNS_15AvailableMemoryE_block_invoke;
  v84 = &__block_descriptor_tmp_52;
  v85 = a3;
  v26 = DERDecodeSequenceContentWithBlock(&v81.__r_.__value_.__l.__size_, (uint64_t)&v83);
  std::string::basic_string[abi:ne180100]<0>(&v77, "DERDecodeSequenceContentWithBlock");
  SERestoreInfo::CallAndThrow<DERReturn>(v26, (uint64_t)&v77);
  if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v77.__r_.__value_.__l.__data_);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v27 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v83);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v83);
    v28 = (std::__shared_weak_count *)v83.__r_.__value_.__l.__size_;
    if (v83.__r_.__value_.__l.__size_)
    {
      v29 = (unint64_t *)(v83.__r_.__value_.__l.__size_ + 8);
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v27 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v31 = (std::__shared_weak_count *)off_2553234C8;
  v81.__r_.__value_.__r.__words[0] = (std::string::size_type)v27;
  v81.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v32 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v33 = __ldxr(v32);
    while (__stxr(v33 + 1, v32));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v27, (SEUpdaterUtil::SELogObj *)3, 0, 1, "GetAvailableMemory", (SEUpdaterUtil::SELogObj *)"-- GET DATA AVAILABLE MEMORY -- \n");
  if (v31)
  {
    v34 = (unint64_t *)&v31->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v36 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v83);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v83);
    v37 = (std::__shared_weak_count *)v83.__r_.__value_.__l.__size_;
    if (v83.__r_.__value_.__l.__size_)
    {
      v38 = (unint64_t *)(v83.__r_.__value_.__l.__size_ + 8);
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
    v36 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v40 = (std::__shared_weak_count *)off_2553234C8;
  v81.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
  v81.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v41 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v42 = __ldxr(v41);
    while (__stxr(v42 + 1, v41));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v36, (SEUpdaterUtil::SELogObj *)3, 0, 1, "GetAvailableMemory", (SEUpdaterUtil::SELogObj *)"   OSU Mem Reserves PHEAP %u THEAP %u\n", *(_DWORD *)(a3 + 40), *(_DWORD *)(a3 + 36));
  if (v40)
  {
    v43 = (unint64_t *)&v40->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v45 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v83);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v83);
    v46 = (std::__shared_weak_count *)v83.__r_.__value_.__l.__size_;
    if (v83.__r_.__value_.__l.__size_)
    {
      v47 = (unint64_t *)(v83.__r_.__value_.__l.__size_ + 8);
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
    v45 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v49 = (std::__shared_weak_count *)off_2553234C8;
  v81.__r_.__value_.__r.__words[0] = (std::string::size_type)v45;
  v81.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v50 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v51 = __ldxr(v50);
    while (__stxr(v51 + 1, v50));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v45, (SEUpdaterUtil::SELogObj *)3, 0, 1, "GetAvailableMemory", (SEUpdaterUtil::SELogObj *)"-- ----------------------- -- \n");
  if (v49)
  {
    v52 = (unint64_t *)&v49->__shared_owners_;
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  v73[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
  v15 = (std::__shared_weak_count *)v73[0].__r_.__value_.__r.__words[2];
  if (v73[0].__r_.__value_.__r.__words[2])
  {
    v54 = (unint64_t *)(v73[0].__r_.__value_.__r.__words[2] + 8);
    do
      v19 = __ldaxr(v54);
    while (__stlxr(v19 - 1, v54));
LABEL_82:
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
LABEL_84:
  v74 = (uint64_t *)&unk_24E0BF880;
  v55 = v76;
  if (v76)
  {
    v56 = (unint64_t *)&v76->__shared_owners_;
    do
      v57 = __ldaxr(v56);
    while (__stlxr(v57 - 1, v56));
    if (!v57)
    {
      ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
      std::__shared_weak_count::__release_weak(v55);
    }
  }
}

void sub_21CC9505C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  a21 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void SEUpdater::CommandGetAvailableMemory::~CommandGetAvailableMemory(SEUpdater::CommandGetAvailableMemory *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

SERestoreInfo::Apdu *SERestoreInfo::Apdu::Apdu(SERestoreInfo::Apdu *this, size_t a2)
{
  unint64_t **v3;
  const char *v5;
  int v6;
  size_t v7;

  v7 = a2;
  *(_QWORD *)this = &unk_24E0BF880;
  v3 = (unint64_t **)((char *)this + 8);
  std::allocate_shared[abi:ne180100]<std::vector<unsigned char>,std::allocator<std::vector<unsigned char>>,unsigned long &,void>(&v7, (_QWORD *)this + 1);
  if (v7 >> 3 > 0x406)
  {
    v5 = "len <= MAX_APDU_LEN";
    v6 = 102;
    goto LABEL_8;
  }
  if (!*v3)
  {
    v5 = "bytes";
    v6 = 103;
LABEL_8:
    __assert_rtn("Apdu", "Apdu.hpp", v6, v5);
  }
  if (v7 <= 0x2036)
    std::vector<unsigned char>::reserve(*v3, 0x2037uLL);
  return this;
}

void sub_21CC953C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::Apdu::updateSize(uint64_t this, unint64_t a2)
{
  _QWORD *v2;
  unint64_t v3;

  v2 = *(_QWORD **)(this + 8);
  v3 = v2[1] - *v2;
  if (v3 < a2)
    __assert_rtn("updateSize", "Apdu.hpp", 125, "len <= bytes->size()");
  if (v3 > a2)
    v2[1] = *v2 + a2;
  return this;
}

_QWORD *SERestoreInfo::Apdu::assign(SERestoreInfo::Apdu *this, char *a2, unint64_t a3)
{
  if (!a2)
    __assert_rtn("assign", "Apdu.hpp", 133, "data");
  if (a3 >> 3 >= 0x407)
    __assert_rtn("assign", "Apdu.hpp", 134, "len <= MAX_APDU_LEN");
  return std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(*((_QWORD **)this + 1), a2, &a2[a3], a3);
}

void std::vector<unsigned char>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2;
  char *v5;
  _BYTE *v6;
  char *v7;
  _BYTE *v8;
  char *v9;
  char v10;

  v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0)
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    v5 = (char *)a1[1];
    v6 = operator new(__sz);
    v7 = &v5[(_QWORD)v6 - v2];
    v8 = v7;
    if (v5 != (char *)v2)
    {
      v9 = &v5[~v2];
      do
      {
        v10 = *--v5;
        (v9--)[(_QWORD)v6] = v10;
      }
      while (v5 != (char *)v2);
      v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
      operator delete((void *)v2);
  }
}

void SERestoreInfo::Apdu::~Apdu(SERestoreInfo::Apdu *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

_QWORD *std::allocate_shared[abi:ne180100]<std::vector<unsigned char>,std::allocator<std::vector<unsigned char>>,unsigned long &,void>@<X0>(size_t *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x30uLL);
  result = std::__shared_ptr_emplace<std::vector<unsigned char>>::__shared_ptr_emplace[abi:ne180100]<unsigned long &,std::allocator<std::vector<unsigned char>>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_21CC9563C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<std::vector<unsigned char>>::__shared_ptr_emplace[abi:ne180100]<unsigned long &,std::allocator<std::vector<unsigned char>>,0>(_QWORD *a1, size_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_24E0BF8B0;
  std::vector<unsigned char>::vector(a1 + 3, *a2);
  return a1;
}

void sub_21CC9568C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0BF8B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0BF8B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

_QWORD *std::vector<unsigned char>::vector(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_21CC95758(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(_QWORD *result, char *__src, char *a3, unint64_t a4)
{
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  size_t v11;
  _BYTE *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;

  v7 = result;
  v8 = result[2];
  v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0)
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    v10 = 2 * v8;
    if (2 * v8 <= a4)
      v10 = a4;
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](v7, v11);
    v9 = (char *)v7[1];
    goto LABEL_17;
  }
  v12 = (_BYTE *)result[1];
  v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    v16 = a3 - __src;
    if (v16)
      result = memmove(v9, __src, v16);
    v15 = &v9[v16];
    goto LABEL_20;
  }
  v14 = &__src[v13];
  if (v12 != v9)
  {
    result = memmove((void *)*result, __src, v13);
    v9 = (char *)v7[1];
  }
  if (a3 != v14)
    result = memmove(v9, v14, a3 - v14);
  v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

_QWORD *SEUpdater::CommandSelectISD::CommandSelectISD(SEUpdater::CommandSelectISD *this)
{
  _QWORD *result;
  uint64_t v2;
  __int16 v3;
  int v4;
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v2 = 0xA0080004A400;
  v3 = 20737;
  v4 = 0;
  result = SERestoreInfo::CApdu::CApdu(this, &v2, 0xEuLL, 0);
  *result = &unk_24E0BF900;
  return result;
}

_QWORD *SERestoreInfo::CApdu::CApdu(_QWORD *a1, const void *a2, size_t a3, uint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;

  v6 = SERestoreInfo::Apdu::Apdu(a1, a2, a3);
  v7 = (_QWORD *)v6[1];
  *v6 = &unk_24E0BF960;
  v9 = v7;
  v8 = *v7;
  v10 = v9[1] - v8;
  v11 = v10 - 5;
  v12 = v10 >= 6;
  v13 = v8 + 5;
  if (!v12)
  {
    v11 = 0;
    v13 = 0;
  }
  v6[4] = v13;
  v6[5] = v11;
  v6[3] = v8;
  SERestoreInfo::CApdu::validate(v6);
  a1[6] = a4;
  return a1;
}

void sub_21CC95970(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  *v1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

_QWORD *SERestoreInfo::CApdu::updateSize(SERestoreInfo::CApdu *this, unint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v2 = (uint64_t *)*((_QWORD *)this + 1);
  v3 = *v2;
  if (v2[1] - *v2 <= a2)
    __assert_rtn("updateSize", "Apdu.hpp", 295, "len < bytes->size()");
  v2[1] = v3 + a2;
  if (a2 >= 6)
    v4 = a2 - 5;
  else
    v4 = 0;
  if (a2 >= 6)
    v5 = v3 + 5;
  else
    v5 = 0;
  *((_QWORD *)this + 3) = v3;
  *((_QWORD *)this + 4) = v5;
  *((_QWORD *)this + 5) = v4;
  return SERestoreInfo::CApdu::validate(this);
}

_QWORD *SERestoreInfo::CApdu::assign(SERestoreInfo::CApdu *this, char *a2, unint64_t a3)
{
  _QWORD *result;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  uint64_t v9;

  result = SERestoreInfo::Apdu::assign(this, a2, a3);
  v5 = **((_QWORD **)this + 1);
  v6 = *(_QWORD *)(*((_QWORD *)this + 1) + 8) - v5;
  v7 = v6 >= 6;
  if (v6 >= 6)
    v8 = v6 - 5;
  else
    v8 = 0;
  if (v7)
    v9 = v5 + 5;
  else
    v9 = 0;
  *((_QWORD *)this + 4) = v9;
  *((_QWORD *)this + 5) = v8;
  *((_QWORD *)this + 3) = v5;
  return result;
}

_QWORD *SERestoreInfo::Apdu::Apdu(_QWORD *a1, const void *a2, size_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;

  *a1 = &unk_24E0BF880;
  a1[1] = 0;
  v6 = a1 + 1;
  a1[2] = 0;
  v7 = (_QWORD *)operator new();
  v8 = (uint64_t)v7;
  *v7 = 0;
  v7[1] = 0;
  v7[2] = 0;
  if (a3)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](v7, a3);
    v9 = *(char **)(v8 + 8);
    memmove(v9, a2, a3);
    *(_QWORD *)(v8 + 8) = &v9[a3];
  }
  std::shared_ptr<std::vector<unsigned char>>::reset[abi:ne180100]<std::vector<unsigned char>,void>(v6, v8);
  return a1;
}

void sub_21CC95B38(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v4;

  v4 = *(void **)v2;
  if (*(_QWORD *)v2)
  {
    *(_QWORD *)(v2 + 8) = v4;
    operator delete(v4);
  }
  MEMORY[0x22078A808](v2, 0x10C402FEFCB83);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *SERestoreInfo::CApdu::validate(_QWORD *this)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;

  v1 = this[3];
  v2 = (_QWORD *)this[1];
  if (v1 != *v2)
    __assert_rtn("validate", "Apdu.hpp", 303, "header == reinterpret_cast<CApduHeader_t*>(&((*bytes)[0]))");
  v3 = this[5];
  if (v3)
  {
    if (v3 + 5 != v2[1] - v1)
      __assert_rtn("validate", "Apdu.hpp", 306, "sizeof(CApduHeader_t) + payloadLen == bytes->size()");
    if (this[4] != v1 + 5)
      __assert_rtn("validate", "Apdu.hpp", 307, "payload == &((*bytes)[sizeof(CApduHeader_t)])");
  }
  else
  {
    if ((unint64_t)(v2[1] - v1) >= 6)
      __assert_rtn("validate", "Apdu.hpp", 311, "sizeof(CApduHeader_t) >= bytes->size()");
    if (this[4])
      __assert_rtn("validate", "Apdu.hpp", 312, "payload == nullptr");
  }
  return this;
}

void SERestoreInfo::CApdu::~CApdu(SERestoreInfo::CApdu *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void std::shared_ptr<std::vector<unsigned char>>::reset[abi:ne180100]<std::vector<unsigned char>,void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  std::shared_ptr<std::vector<unsigned char>>::shared_ptr[abi:ne180100]<std::vector<unsigned char>,void>(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

_QWORD *std::shared_ptr<std::vector<unsigned char>>::shared_ptr[abi:ne180100]<std::vector<unsigned char>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_24E0BF990;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21CC95DCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  a10 = 0;
  if (v10)
    std::default_delete<std::vector<unsigned char>>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<std::vector<unsigned char> *,std::shared_ptr<std::vector<unsigned char>>::__shared_ptr_default_delete<std::vector<unsigned char>,std::vector<unsigned char>>,std::allocator<std::vector<unsigned char>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

void std::__shared_ptr_pointer<std::vector<unsigned char> *,std::shared_ptr<std::vector<unsigned char>>::__shared_ptr_default_delete<std::vector<unsigned char>,std::vector<unsigned char>>,std::allocator<std::vector<unsigned char>>>::__on_zero_shared(uint64_t a1)
{
  std::default_delete<std::vector<unsigned char>>::operator()[abi:ne180100](a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<std::vector<unsigned char> *,std::shared_ptr<std::vector<unsigned char>>::__shared_ptr_default_delete<std::vector<unsigned char>,std::vector<unsigned char>>,std::allocator<std::vector<unsigned char>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::default_delete<std::vector<unsigned char>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a2)
  {
    v2 = *(void **)a2;
    if (*(_QWORD *)a2)
    {
      *(_QWORD *)(a2 + 8) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x22078A808);
  }
}

uint64_t SERestoreInfo::CallAndThrow<DERReturn>(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  void *exception;
  void *v5;

  if ((_DWORD)result)
  {
    v2 = result;
    exception = __cxa_allocate_exception(0x48uLL);
    v5 = (void *)SERestoreInfo::SEException::SEException(exception, a2, v2, CFSTR("libDERErrorDomain"));
  }
  return result;
}

__n128 __Block_byref_object_copy__1(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  *(_OWORD *)(a1 + 5) = *(_OWORD *)(a2 + 40);
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  result = *(__n128 *)(a2 + 64);
  *((__n128 *)a1 + 4) = result;
  a1[10] = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
  void *v2;
  void **v3;

  v3 = (void **)(a1 + 64);
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void SEUpdater::PackageInfo::~PackageInfo(SEUpdater::PackageInfo *this)
{
  void *v2;
  void **v3;

  v3 = (void **)((char *)this + 24);
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t ___ZN9SEUpdaterL11ParseE3TLVsERKN13SERestoreInfo5RApduERNSt3__16vectorINS_11PackageInfoENS4_9allocatorIS6_EEEE_block_invoke(uint64_t a1, _QWORD *a2)
{
  size_t v3;
  const void *v4;
  _QWORD *v5;
  void *v6;
  uint64_t *v7;
  const void **v8;
  size_t v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  __int128 v14;
  uint64_t v15;

  if (*a2 == 0x8000000000000004)
  {
    v7 = *(uint64_t **)(*(_QWORD *)(a1 + 32) + 8);
    v10 = (char *)a2[1];
    v9 = a2[2];
    v8 = (const void **)(a2 + 1);
    *(_QWORD *)&v14 = &v10[v9];
    v11 = (_QWORD *)v7[9];
    if ((unint64_t)v11 >= v7[10])
    {
      v12 = std::vector<std::vector<unsigned char>>::__emplace_back_slow_path<unsigned char *&,unsigned char *>(v7 + 8, v8, (uint64_t *)&v14);
    }
    else
    {
      *v11 = 0;
      v11[1] = 0;
      v11[2] = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v11, v10, (uint64_t)&v10[v9], v9);
      v12 = (uint64_t)(v11 + 3);
      v7[9] = (uint64_t)(v11 + 3);
    }
    v7[9] = v12;
  }
  else
  {
    if (*a2 != 0x400000000000000FLL)
      __assert_rtn("ParseE3TLVs_block_invoke", "QueryAppletStatus.cpp", 75, "0");
    v4 = (const void *)a2[1];
    v3 = a2[2];
    v15 = 0;
    v14 = 0uLL;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v14, v4, (uint64_t)v4 + v3, v3);
    v5 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
    v6 = (void *)v5[5];
    if (v6)
    {
      v5[6] = v6;
      operator delete(v6);
      v5[5] = 0;
      v5[6] = 0;
      v5[7] = 0;
    }
    *(_OWORD *)(v5 + 5) = v14;
    v5[7] = v15;
  }
  return 0;
}

void sub_21CC96120(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v2 + 72) = v1;
  _Unwind_Resume(a1);
}

_QWORD *std::allocator<SEUpdater::PackageInfo>::construct[abi:ne180100]<SEUpdater::PackageInfo,SEUpdater::PackageInfo const&>(_QWORD *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(a1, *(const void **)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return std::vector<std::vector<unsigned char>>::__init_with_size[abi:ne180100]<std::vector<unsigned char>*,std::vector<unsigned char>*>(a1 + 3, *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 3));
}

void sub_21CC96188(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<std::vector<unsigned char>>::__init_with_size[abi:ne180100]<std::vector<unsigned char>*,std::vector<unsigned char>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<unsigned char>>,std::vector<unsigned char>*,std::vector<unsigned char>*,std::vector<unsigned char>*>((uint64_t)(v6 + 2), a2, a3, (_QWORD *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_21CC96208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<unsigned char>>,std::vector<unsigned char>*,std::vector<unsigned char>*,std::vector<unsigned char>*>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v4, *(const void **)v6, *(_QWORD *)(v6 + 8), *(_QWORD *)(v6 + 8) - *(_QWORD *)v6);
      v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::vector<unsigned char>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_21CC962C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::vector<unsigned char>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::vector<unsigned char>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::vector<unsigned char>*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::vector<unsigned char>*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  if (v1 != v2)
  {
    v3 = **(_QWORD **)(a1 + 16);
    do
    {
      v5 = *(void **)(v3 - 24);
      v3 -= 24;
      v4 = v5;
      if (v5)
      {
        *(_QWORD *)(v1 - 16) = v4;
        operator delete(v4);
      }
      v1 = v3;
    }
    while (v3 != v2);
  }
}

void std::allocator<SEUpdater::PackageInfo>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v3;
  void **v4;

  v4 = (void **)(a2 + 24);
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v3 = *(void **)a2;
  if (*(_QWORD *)a2)
  {
    *(_QWORD *)(a2 + 8) = v3;
    operator delete(v3);
  }
}

uint64_t std::__split_buffer<SEUpdater::PackageInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 16) = i - 48;
    std::allocator<SEUpdater::PackageInfo>::destroy[abi:ne180100](v4, i - 48);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

__n128 __Block_byref_object_copy__46(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  *(_OWORD *)(a1 + 5) = *(_OWORD *)(a2 + 40);
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  *((_OWORD *)a1 + 4) = *(_OWORD *)(a2 + 64);
  a1[10] = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  a1[11] = 0;
  a1[12] = 0;
  a1[13] = 0;
  result = *(__n128 *)(a2 + 88);
  *(__n128 *)(a1 + 11) = result;
  a1[13] = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  return result;
}

void __Block_byref_object_dispose__47(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[8];
  if (v3)
  {
    a1[9] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[5];
  if (v4)
  {
    a1[6] = v4;
    operator delete(v4);
  }
}

void SEUpdater::InstanceInfo::~InstanceInfo(SEUpdater::InstanceInfo *this)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  v4 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v4;
    operator delete(v4);
  }
}

uint64_t ___ZN9SEUpdaterL11ParseE3TLVsERKN13SERestoreInfo5RApduERNSt3__16vectorINS_12InstanceInfoENS4_9allocatorIS6_EEEE_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  size_t v4;
  const void *v5;
  _QWORD *v6;
  void *v7;
  size_t v8;
  const void *v9;
  _QWORD *v10;
  void *v11;
  size_t v12;
  const void *v13;
  _QWORD *v14;
  void *v15;
  __int128 v17;
  uint64_t v18;

  v3 = *a2;
  if (*a2 == 0x400000000000000FLL)
  {
    v9 = (const void *)a2[1];
    v8 = a2[2];
    v18 = 0;
    v17 = 0uLL;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v17, v9, (uint64_t)v9 + v8, v8);
    v10 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
    v11 = (void *)v10[5];
    if (v11)
    {
      v10[6] = v11;
      operator delete(v11);
    }
    *(_OWORD *)(v10 + 5) = v17;
    v10[7] = v18;
  }
  else if (v3 == 0x8000000000000070)
  {
    v13 = (const void *)a2[1];
    v12 = a2[2];
    v18 = 0;
    v17 = 0uLL;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v17, v13, (uint64_t)v13 + v12, v12);
    v14 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
    v15 = (void *)v14[11];
    if (v15)
    {
      v14[12] = v15;
      operator delete(v15);
    }
    *(_OWORD *)(v14 + 11) = v17;
    v14[13] = v18;
  }
  else
  {
    if (v3 != 0x8000000000000004)
      __assert_rtn("ParseE3TLVs_block_invoke", "QueryAppletStatus.cpp", 145, "0");
    v5 = (const void *)a2[1];
    v4 = a2[2];
    v18 = 0;
    v17 = 0uLL;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v17, v5, (uint64_t)v5 + v4, v4);
    v6 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
    v7 = (void *)v6[8];
    if (v7)
    {
      v6[9] = v7;
      operator delete(v7);
    }
    *((_OWORD *)v6 + 4) = v17;
    v6[10] = v18;
  }
  return 0;
}

_QWORD *std::allocator<SEUpdater::InstanceInfo>::construct[abi:ne180100]<SEUpdater::InstanceInfo,SEUpdater::InstanceInfo const&>(_QWORD *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(a1, *(const void **)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(a1 + 3, *(const void **)(a2 + 24), *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24));
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(a1 + 6, *(const void **)(a2 + 48), *(_QWORD *)(a2 + 56), *(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48));
}

void sub_21CC966F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;
  void *v5;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v4;
    operator delete(v4);
  }
  v5 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void std::allocator<SEUpdater::InstanceInfo>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;

  v3 = *(void **)(a2 + 48);
  if (v3)
  {
    *(_QWORD *)(a2 + 56) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a2 + 24);
  if (v4)
  {
    *(_QWORD *)(a2 + 32) = v4;
    operator delete(v4);
  }
  v5 = *(void **)a2;
  if (*(_QWORD *)a2)
  {
    *(_QWORD *)(a2 + 8) = v5;
    operator delete(v5);
  }
}

uint64_t std::__split_buffer<SEUpdater::InstanceInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 16) = i - 72;
    std::allocator<SEUpdater::InstanceInfo>::destroy[abi:ne180100](v4, i - 72);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t ___ZN9SEUpdaterL13ParseDF2ATLVsERKN13SERestoreInfo5RApduERNS_15AvailableMemoryE_block_invoke(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;

  switch(*(_QWORD *)a2)
  {
    case 0:
      v2 = *(_DWORD **)(a1 + 32);
      goto LABEL_15;
    case 1:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 4);
      goto LABEL_15;
    case 2:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 8);
      goto LABEL_15;
    case 3:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 12);
      goto LABEL_15;
    case 4:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 16);
      goto LABEL_15;
    case 5:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 20);
      goto LABEL_15;
    case 6:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 24);
      goto LABEL_15;
    case 0xCLL:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 28);
      goto LABEL_15;
    case 0xDLL:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 32);
      goto LABEL_15;
    case 0xELL:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 36);
      goto LABEL_15;
    case 0xFLL:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 40);
      goto LABEL_15;
    case 0x10:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 44);
      goto LABEL_15;
    case 0x11:
      v2 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 48);
LABEL_15:
      *v2 = bswap32(**(_DWORD **)(a2 + 8));
      break;
    default:
      return 0;
  }
  return 0;
}

void std::vector<SEUpdater::PackageInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::allocator<SEUpdater::PackageInfo>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<SEUpdater::InstanceInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 72;
        std::allocator<SEUpdater::InstanceInfo>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

SEUpdaterUtil::Error *SEUpdaterUtil::Error::Error(SEUpdaterUtil::Error *this)
{
  NSObject *v2;
  NSObject *v3;

  v2 = dispatch_queue_create("Error", 0);
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = v2;
  if (v2)
  {
    v3 = v2;
    dispatch_retain(v2);
    *((_QWORD *)this + 3) = 0;
    dispatch_release(v3);
  }
  else
  {
    *((_QWORD *)this + 3) = 0;
  }
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  return this;
}

uint64_t SEUpdaterUtil::Error::CreateCFError(SEUpdaterUtil::Error *this)
{
  NSObject *v1;
  char *v2;
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD block[6];

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 0x40000000;
  v5[2] = ___ZN13SEUpdaterUtil5Error13CreateCFErrorEv_block_invoke;
  v5[3] = &unk_24E0BFB48;
  v5[4] = &v6;
  v5[5] = this;
  v10 = v5;
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableIN13SEUpdaterUtil5ErrorEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke;
  block[3] = &__block_descriptor_tmp_7;
  block[4] = this;
  block[5] = &v10;
  v2 = (char *)this + 16;
  v1 = *((_QWORD *)this + 2);
  if (*((_QWORD *)v2 + 1))
    dispatch_async_and_wait(v1, block);
  else
    dispatch_sync(v1, block);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void ___ZN13SEUpdaterUtil5Error13CreateCFErrorEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  __int128 *v2;
  __int128 *v3;
  const void *v5;
  __int128 v6;
  std::string __p;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(__int128 **)(v1 + 32);
  v3 = *(__int128 **)(v1 + 40);
  if (v2 != v3)
  {
    v5 = 0;
    while (1)
    {
      if (*((char *)v2 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v2, *((_QWORD *)v2 + 1));
      }
      else
      {
        v6 = *v2;
        __p.__r_.__value_.__r.__words[2] = *((_QWORD *)v2 + 2);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v6;
      }
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = SERestoreInfo::CreateCFError((const UInt8 *)&__p, *((_DWORD *)v2 + 6), v5, CFSTR("SEUpdaterErrorDomain"));
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        break;
      if (v5)
        goto LABEL_8;
LABEL_9:
      v5 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      v2 += 2;
      if (v2 == v3)
        return;
    }
    operator delete(__p.__r_.__value_.__l.__data_);
    if (!v5)
      goto LABEL_9;
LABEL_8:
    CFRelease(v5);
    goto LABEL_9;
  }
}

void sub_21CC96BE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SEUpdaterUtil::Error::getErrorCode(SEUpdaterUtil::Error *this)
{
  NSObject *v1;
  char *v2;
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  _QWORD *v10;
  _QWORD block[6];

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 0x40000000;
  v5[2] = ___ZN13SEUpdaterUtil5Error12getErrorCodeEv_block_invoke;
  v5[3] = &unk_24E0BFB70;
  v5[4] = &v6;
  v5[5] = this;
  v10 = v5;
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableIN13SEUpdaterUtil5ErrorEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke;
  block[3] = &__block_descriptor_tmp_7;
  block[4] = this;
  block[5] = &v10;
  v2 = (char *)this + 16;
  v1 = *((_QWORD *)this + 2);
  if (*((_QWORD *)v2 + 1))
    dispatch_async_and_wait(v1, block);
  else
    dispatch_sync(v1, block);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t ___ZN13SEUpdaterUtil5Error12getErrorCodeEv_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(result + 40);
  v3 = *(_QWORD *)(v1 + 32);
  v2 = *(_QWORD *)(v1 + 40);
  if (v3 != v2)
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_DWORD *)(v2 - 8);
  return result;
}

void SEUpdaterUtil::Error::addError(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v3;
  uint64_t v4;
  _QWORD v5[6];
  int v6;
  _QWORD *v7;
  _QWORD block[6];

  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 0x40000000;
  v5[2] = ___ZN13SEUpdaterUtil5Error8addErrorERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEi_block_invoke;
  v5[3] = &__block_descriptor_tmp_4;
  v5[4] = a1;
  v5[5] = a2;
  v6 = a3;
  v7 = v5;
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableIN13SEUpdaterUtil5ErrorEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke;
  block[3] = &__block_descriptor_tmp_7;
  block[4] = a1;
  block[5] = &v7;
  v4 = a1 + 16;
  v3 = *(NSObject **)(a1 + 16);
  if (*(_QWORD *)(v4 + 8))
    dispatch_async_and_wait(v3, block);
  else
    dispatch_sync(v3, block);
}

void ___ZN13SEUpdaterUtil5Error8addErrorERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEi_block_invoke(uint64_t a1)
{
  __int128 *v2;
  int64x2_t *v3;
  __int128 v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  __int128 v16;
  int64x2_t v17;
  int v18;
  std::string __p;
  int v20;
  uint64_t v21;
  int64x2_t v22;
  unint64_t v23;
  int64x2_t *v24;

  v3 = *(int64x2_t **)(a1 + 32);
  v2 = *(__int128 **)(a1 + 40);
  if (*((char *)v2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v2, *((_QWORD *)v2 + 1));
  }
  else
  {
    v4 = *v2;
    __p.__r_.__value_.__r.__words[2] = *((_QWORD *)v2 + 2);
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v4;
  }
  v5 = *(_DWORD *)(a1 + 48);
  v20 = v5;
  v6 = v3[3].u64[0];
  v7 = v3[2].u64[1];
  if (v7 >= v6)
  {
    v9 = v3[2].i64[0];
    v10 = (uint64_t)(v7 - v9) >> 5;
    v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 59)
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    if ((uint64_t)(v6 - v9) >> 4 > v11)
      v11 = (uint64_t)(v6 - v9) >> 4;
    if (v6 - v9 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    v24 = v3 + 3;
    if (v12 >> 59)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v13 = (char *)operator new(32 * v12);
    v14 = &v13[32 * v10];
    *(std::string *)v14 = __p;
    memset(&__p, 0, sizeof(__p));
    *((_DWORD *)v14 + 6) = v5;
    v15 = v14 + 32;
    if (v7 == v9)
    {
      v17 = vdupq_n_s64(v7);
    }
    else
    {
      do
      {
        v16 = *(_OWORD *)(v7 - 32);
        *((_QWORD *)v14 - 2) = *(_QWORD *)(v7 - 16);
        *((_OWORD *)v14 - 2) = v16;
        *(_QWORD *)(v7 - 24) = 0;
        *(_QWORD *)(v7 - 16) = 0;
        *(_QWORD *)(v7 - 32) = 0;
        *((_DWORD *)v14 - 2) = *(_DWORD *)(v7 - 8);
        v14 -= 32;
        v7 -= 32;
      }
      while (v7 != v9);
      v17 = v3[2];
      v6 = v3[3].u64[0];
    }
    v3[2].i64[0] = (uint64_t)v14;
    v3[2].i64[1] = (uint64_t)v15;
    v22 = v17;
    v3[3].i64[0] = (uint64_t)&v13[32 * v12];
    v23 = v6;
    v21 = v17.i64[0];
    std::__split_buffer<std::pair<std::string,int>>::~__split_buffer((uint64_t)&v21);
    v18 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    v3[2].i64[1] = (uint64_t)v15;
    if (v18 < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    v8 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *(_QWORD *)(v7 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
    *(_OWORD *)v7 = v8;
    *(_DWORD *)(v7 + 24) = v20;
    v3[2].i64[1] = v7 + 32;
  }
}

void sub_21CC96F1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<std::pair<std::string,int>>::~__split_buffer(uint64_t a1)
{
  void **v2;
  void **v3;
  void **v4;

  v3 = *(void ***)(a1 + 8);
  v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      v4 = v2 - 4;
      *(_QWORD *)(a1 + 16) = v2 - 4;
      if (*((char *)v2 - 9) < 0)
      {
        operator delete(*v4);
        v4 = *(void ***)(a1 + 16);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<std::pair<std::string,int>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 32)
  {
    if (*(char *)(i - 9) < 0)
      operator delete(*(void **)(i - 32));
  }
  a1[1] = v2;
}

_QWORD *RootCA::getRootKeyId@<X0>(int a1@<W0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  const void *v4;
  void *v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  std::string::size_type v13;
  std::string *v14;
  void *v15;
  void *exception;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  std::string::size_type size;
  std::string *v24;
  void *v25;
  std::string v26;
  std::string v27;
  std::string v28;
  std::string v29;
  std::string v30;

  if (a2 > 199)
  {
    if (a2 != 210 && a2 != 200)
    {
LABEL_12:
      if (a1 == 1)
      {
        *a3 = 0;
        a3[1] = 0;
        v4 = &unk_255323530;
      }
      else
      {
        if (a1)
        {
          exception = __cxa_allocate_exception(0x48uLL);
          std::to_string(&v27, a1);
          v18 = std::string::insert(&v27, 0, "Unknown RootCAId: ");
          v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
          v28.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v19;
          v18->__r_.__value_.__l.__size_ = 0;
          v18->__r_.__value_.__r.__words[2] = 0;
          v18->__r_.__value_.__r.__words[0] = 0;
          v20 = std::string::append(&v28, " for SEChipType ");
          v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
          v29.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v21;
          v20->__r_.__value_.__l.__size_ = 0;
          v20->__r_.__value_.__r.__words[2] = 0;
          v20->__r_.__value_.__r.__words[0] = 0;
          std::to_string(&v26, a2);
          if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v22 = &v26;
          else
            v22 = (std::string *)v26.__r_.__value_.__r.__words[0];
          if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            size = HIBYTE(v26.__r_.__value_.__r.__words[2]);
          else
            size = v26.__r_.__value_.__l.__size_;
          v24 = std::string::append(&v29, (const std::string::value_type *)v22, size);
          v30 = *v24;
          v24->__r_.__value_.__l.__size_ = 0;
          v24->__r_.__value_.__r.__words[2] = 0;
          v24->__r_.__value_.__r.__words[0] = 0;
          v25 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, (__int128 *)&v30, 16, CFSTR("SEUpdaterErrorDomain"));
        }
        *a3 = 0;
        a3[1] = 0;
        v4 = &unk_255323510;
      }
      goto LABEL_11;
    }
  }
  else if (a2 != 100 && a2 != 115)
  {
    goto LABEL_12;
  }
  if (a1 == 1)
  {
    *a3 = 0;
    a3[1] = 0;
    v4 = &unk_2553234F0;
  }
  else
  {
    if (a1)
    {
      v7 = __cxa_allocate_exception(0x48uLL);
      std::to_string(&v27, a1);
      v8 = std::string::insert(&v27, 0, "Unknown RootCAId: ");
      v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v28.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      v10 = std::string::append(&v28, " for SEChipType ");
      v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      v29.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v26, a2);
      if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v12 = &v26;
      else
        v12 = (std::string *)v26.__r_.__value_.__r.__words[0];
      if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v13 = HIBYTE(v26.__r_.__value_.__r.__words[2]);
      else
        v13 = v26.__r_.__value_.__l.__size_;
      v14 = std::string::append(&v29, (const std::string::value_type *)v12, v13);
      v30 = *v14;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      v15 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v7, (__int128 *)&v30, 16, CFSTR("SEUpdaterErrorDomain"));
    }
    *a3 = 0;
    a3[1] = 0;
    v4 = &_MergedGlobals;
  }
LABEL_11:
  a3[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(a3, v4, (uint64_t)v4 + 32, 0x20uLL);
}

void sub_21CC97288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  if (*(char *)(v33 - 41) < 0)
    operator delete(*(void **)(v33 - 64));
  if (a14 < 0)
    operator delete(__p);
  if (a33 < 0)
    operator delete(a28);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24E0BEBA8, MEMORY[0x24BEDAB00]);
}

void sub_21CC973F8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8C0] + 16);
  return result;
}

void _ObjcLogInternal(SEUpdaterUtil::SELogObj *a1, const char *a2, NSString *a3)
{
  NSString *v5;
  char *v6;
  __int128 *v7;
  uint64_t v8;
  SEUpdaterUtil::SELogObj *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  __int128 v18;
  __int128 *v19;
  char *v20;
  _QWORD v21[5];

  v21[4] = *MEMORY[0x24BDAC8D0];
  v5 = objc_retainAutorelease(a3);
  v6 = strdup(-[NSString UTF8String](v5, "UTF8String"));
  if (!v6)
    goto LABEL_23;
  *(_QWORD *)&v18 = &off_24E0BFBE0;
  v19 = &v18;
  v20 = v6;
  std::__function::__value_func<void ()(char const*)>::__value_func[abi:ne180100]((uint64_t)v21, (uint64_t)&v18);
  v7 = v19;
  if (v19 == &v18)
  {
    v8 = 4;
    v7 = &v18;
    goto LABEL_6;
  }
  if (v19)
  {
    v8 = 5;
LABEL_6:
    (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v9 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v18);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v18);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
    if (*((_QWORD *)&v18 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v9 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v13 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v14 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printFormattedLog(v9, a1, 0, 1, (uint64_t)a2, (const char **)&v20);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v20);
LABEL_23:

}

void sub_21CC975EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100]((uint64_t *)va);

  _Unwind_Resume(a1);
}

void _ObjCLog(SEUpdaterUtil::SELogObj *a1, const char *a2, NSString *a3, ...)
{
  NSString *v5;
  NSString *v6;
  va_list va;

  va_start(va, a3);
  v5 = a3;
  v6 = (NSString *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithFormat:arguments:", v5, va);
  _ObjcLogInternal(a1, a2, v6);

}

void sub_21CC976C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id _ObjCLogNSError(NSError *a1, uint64_t a2, const char *a3, NSString *a4, ...)
{
  NSError *v7;
  NSString *v8;
  NSString *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  void *v13;
  uint64_t v15;
  NSString *v16;
  _QWORD v17[2];
  _QWORD v18[3];
  va_list va;

  va_start(va, a4);
  v18[2] = *MEMORY[0x24BDAC8D0];
  v7 = a1;
  v8 = a4;
  v9 = (NSString *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithFormat:arguments:", v8, va);
  _ObjcLogInternal(0, a3, v9);
  if (v7)
  {
    v10 = *MEMORY[0x24BDD1398];
    v17[0] = *MEMORY[0x24BDD0FC8];
    v17[1] = v10;
    v18[0] = v9;
    v18[1] = v7;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v18, v17, 2);
    v11 = objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v15 = *MEMORY[0x24BDD0FC8];
    v16 = v9;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v16, &v15, 1);
    v11 = objc_claimAutoreleasedReturnValue();
  }
  v12 = (void *)v11;
  objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("helsinki"), a2, v11, va);
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  return v13;
}

void sub_21CC97828(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void _ObjCLogOutError(uint64_t *a1, uint64_t a2, const char *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v12;
  NSString *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  _QWORD v19[2];
  _QWORD v20[2];
  uint64_t v21;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x24BDAC8D0];
  v12 = a4;
  v13 = (NSString *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithFormat:arguments:", v12, &a9);
  _ObjcLogInternal(0, a3, v13);
  if (a1)
  {
    v14 = *a1;
    v15 = (void *)MEMORY[0x24BDD1540];
    if (*a1)
    {
      v16 = *MEMORY[0x24BDD1398];
      v19[0] = *MEMORY[0x24BDD0FC8];
      v19[1] = v16;
      v20[0] = v13;
      v20[1] = v14;
      objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v20, v19, 2);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "errorWithDomain:code:userInfo:", CFSTR("helsinki"), a2, v17);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v21 = *MEMORY[0x24BDD0FC8];
      v22[0] = v13;
      objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v22, &v21, 1);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "errorWithDomain:code:userInfo:", CFSTR("helsinki"), a2, v17);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
    }
    *a1 = (uint64_t)v18;

  }
}

void sub_21CC979D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void _ObjCLogWrapOutError(_QWORD *a1, void *a2, uint64_t a3, const char *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v13;
  id v14;
  NSString *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  NSString *v20;
  _QWORD v21[2];
  _QWORD v22[3];

  v22[2] = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  v14 = a5;
  v15 = (NSString *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithFormat:arguments:", v14, &a9);
  _ObjcLogInternal(0, a4, v15);
  if (a1)
  {
    if (v13)
    {
      v16 = *MEMORY[0x24BDD1398];
      v21[0] = *MEMORY[0x24BDD0FC8];
      v21[1] = v16;
      v22[0] = v15;
      v22[1] = v13;
      objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v22, v21, 2);
      v17 = objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v19 = *MEMORY[0x24BDD0FC8];
      v20 = v15;
      objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v20, &v19, 1);
      v17 = objc_claimAutoreleasedReturnValue();
    }
    v18 = (void *)v17;
    objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("helsinki"), a3, v17, &a9);
    *a1 = (id)objc_claimAutoreleasedReturnValue();

  }
}

void sub_21CC97B60(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void std::__function::__func<_ObjcLogInternal(int,char const*,NSString *)::$_0,std::allocator<_ObjcLogInternal(int,char const*,NSString *)::$_0>,void ()(char const*)>::~__func()
{
  JUMPOUT(0x22078A808);
}

_QWORD *std::__function::__func<_ObjcLogInternal(int,char const*,NSString *)::$_0,std::allocator<_ObjcLogInternal(int,char const*,NSString *)::$_0>,void ()(char const*)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24E0BFBE0;
  return result;
}

void std::__function::__func<_ObjcLogInternal(int,char const*,NSString *)::$_0,std::allocator<_ObjcLogInternal(int,char const*,NSString *)::$_0>,void ()(char const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24E0BFBE0;
}

void std::__function::__func<_ObjcLogInternal(int,char const*,NSString *)::$_0,std::allocator<_ObjcLogInternal(int,char const*,NSString *)::$_0>,void ()(char const*)>::operator()(uint64_t a1, void **a2)
{
  free(*a2);
}

uint64_t std::__function::__func<_ObjcLogInternal(int,char const*,NSString *)::$_0,std::allocator<_ObjcLogInternal(int,char const*,NSString *)::$_0>,void ()(char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<_ObjcLogInternal(int,char const*,NSString *)::$_0,std::allocator<_ObjcLogInternal(int,char const*,NSString *)::$_0>,void ()(char const*)>::target_type()
{
}

uint64_t SEUpdaterUtil::SN200VImage4Signer::getSigningAlgorithm(SEUpdaterUtil::SN200VImage4Signer *this)
{
  return 0;
}

_QWORD *SEUpdaterUtil::SN200VImage4Signer::getSigningKey@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SN200VImage4Signer::getSigningKey(void)const::signingKey, (uint64_t)&SEUpdaterUtil::SN200VImage4Signer::getSigningCert(void)const::signingCert, 0x79uLL);
}

_QWORD *SEUpdaterUtil::SN200VImage4Signer::getSigningCert@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SN200VImage4Signer::getSigningCert(void)const::signingCert, (uint64_t)"N13SEUpdaterUtil18SN200VImage4SignerE", 0x27DuLL);
}

void SEUpdaterUtil::SN200VImage4Signer::~SN200VImage4Signer(const void **this)
{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
}

{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
  JUMPOUT(0x22078A808);
}

const void **ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

_QWORD *std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(_QWORD *result, const void *a2, uint64_t a3, size_t __sz)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (__sz)
  {
    v6 = result;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21CC97E80(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *SERestoreInfo::BLOB::operator=(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;

  if (a2 != a1)
  {
    v4 = a2[2];
    a1[1] = a2[1];
    a1[2] = v4;
    v5 = (const void *)a1[3];
    if (v5)
    {
      CFRelease(v5);
      a1[3] = 0;
    }
    v6 = (const void *)a2[3];
    if (v6)
      a1[3] = CFRetain(v6);
  }
  return a1;
}

void SERestoreInfo::BLOB::~BLOB(SERestoreInfo::BLOB *this)
{
  SERestoreInfo::BLOB::~BLOB(this);
  JUMPOUT(0x22078A808);
}

{
  const void *v2;

  *(_QWORD *)this = &unk_24E0BFCD0;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 3) = 0;
  }
}

void SERestoreInfo::SEFirmwareBase::~SEFirmwareBase(SERestoreInfo::SEFirmwareBase *this)
{
  const void *v2;
  void **v3;

  *(_QWORD *)this = off_24E0C1688;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 1) = 0;
  }
  v3 = (void **)((char *)this + 16);
  std::vector<SERestoreInfo::BLOB>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void std::vector<SERestoreInfo::BLOB>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  void (**v8)(char *);
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 32;
      v7 = v4 - 32;
      do
      {
        v8 = *(void (***)(char *))v7;
        v7 -= 32;
        (*v8)(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void SEUpdaterUtil::P73BaseImage4Signer::doObjectPropertiesCB(SEUpdaterUtil::P73BaseImage4Signer *this, unsigned __int8 **a2, unsigned int *a3)
{
  uint64_t (*v4)(uint64_t);
  uint64_t v5;
  const char *v6;
  CFTypeID v7;
  const __CFDictionary *v8;
  CFTypeID v9;
  const __CFData *v10;
  uint64_t v11;
  const char *v12;
  CFTypeID v13;
  const __CFData *v14;
  uint64_t v15;
  const char *v16;
  CFTypeID v17;
  uint64_t v18;
  const char *v19;
  CFTypeID v20;
  uint64_t v21;
  const char *v22;
  CFTypeID v23;
  uint64_t v24;
  const char *v25;
  CFTypeID TypeID;
  CFTypeID v27;
  const __CFData *v28;
  uint64_t v29;
  const char *v30;
  CFTypeID v31;
  CFTypeID v32;
  const __CFData *v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  const char *v39;
  void *exception;
  std::string *v41;
  __int128 v42;
  void *v43;
  std::string *v44;
  __int128 v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  CFTypeRef cf;
  void *value;
  std::string v62;
  __int128 v63;
  std::string::size_type v64;

  if (!a2 || !a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v62, "Assertion: ");
    v41 = std::string::append(&v62, "outdata && outlength");
    v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
    v64 = v41->__r_.__value_.__r.__words[2];
    v63 = v42;
    v41->__r_.__value_.__l.__size_ = 0;
    v41->__r_.__value_.__r.__words[2] = 0;
    v41->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v63);
  }
  if (*((_QWORD *)this + 1))
    v4 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  else
    v4 = 0;
  if (!v4)
  {
    v43 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v62, "Assertion: ");
    v44 = std::string::append(&v62, "fRequestDict");
    v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    v64 = v44->__r_.__value_.__r.__words[2];
    v63 = v45;
    v44->__r_.__value_.__l.__size_ = 0;
    v44->__r_.__value_.__r.__words[2] = 0;
    v44->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v43, &v63);
  }
  v62.__r_.__value_.__r.__words[0] = 0;
  v5 = Img4EncodeItemBegin();
  SEUpdaterUtil::Img4EncodeCallAndThrow(v5, "Fail to Img4EncodeItemBegin: %d", v6);
  value = 0;
  if (!CFDictionaryGetValueIfPresent(*((CFDictionaryRef *)this + 1), CFSTR("SE,UpdatePayload"), (const void **)&value)
    || (v7 = CFGetTypeID(value), v7 != CFDictionaryGetTypeID()))
  {
    v46 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v63, "Missing kSETagMeasurementUpdatePayload or wrong type");
    v47 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v46, &v63, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  v8 = (const __CFDictionary *)value;
  if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("DevelopmentUpdatePayloadHash"), (const void **)&value))
  {
    v9 = CFGetTypeID(value);
    if (v9 == CFDataGetTypeID())
    {
      v10 = (const __CFData *)value;
      CFDataGetBytePtr((CFDataRef)value);
      CFDataGetLength(v10);
      v11 = Img4EncodeItemPropertyData();
      SEUpdaterUtil::Img4EncodeCallAndThrow(v11, "Fail to add sedh", v12);
    }
  }
  if (CFDictionaryGetValueIfPresent(v8, CFSTR("ProductionUpdatePayloadHash"), (const void **)&value))
  {
    v13 = CFGetTypeID(value);
    if (v13 == CFDataGetTypeID())
    {
      v14 = (const __CFData *)value;
      CFDataGetBytePtr((CFDataRef)value);
      CFDataGetLength(v14);
      v15 = Img4EncodeItemPropertyData();
      SEUpdaterUtil::Img4EncodeCallAndThrow(v15, "Fail to add seph", v16);
    }
  }
  cf = 0;
  if (CFDictionaryGetValueIfPresent(*((CFDictionaryRef *)this + 1), CFSTR("SEAC"), &cf))
  {
    v17 = CFGetTypeID(cf);
    if (v17 == CFNumberGetTypeID())
    {
      v18 = Img4EncodeItemPropertyBool();
      SEUpdaterUtil::Img4EncodeCallAndThrow(v18, "Failed to add seac", v19);
    }
  }
  if (CFDictionaryGetValueIfPresent(*((CFDictionaryRef *)this + 1), CFSTR("SERS"), &cf))
  {
    v20 = CFGetTypeID(cf);
    if (v20 == CFNumberGetTypeID())
    {
      v21 = Img4EncodeItemPropertyBool();
      SEUpdaterUtil::Img4EncodeCallAndThrow(v21, "Failed to add sers", v22);
    }
  }
  if (CFDictionaryGetValueIfPresent(*((CFDictionaryRef *)this + 1), CFSTR("SESA"), &cf))
  {
    v23 = CFGetTypeID(cf);
    if (v23 == CFNumberGetTypeID())
    {
      v24 = Img4EncodeItemPropertyBool();
      SEUpdaterUtil::Img4EncodeCallAndThrow(v24, "Failed to add sesa", v25);
    }
  }
  if (CFDictionaryGetValueIfPresent(*((CFDictionaryRef *)this + 1), CFSTR("SE,RapRTKitOS"), (const void **)&value))
  {
    TypeID = CFDictionaryGetTypeID();
    if (TypeID != CFGetTypeID(value))
    {
      v48 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v63, "Wrong type for kRoseTagMeasurementRTKitOS");
      v49 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v48, &v63, 2, CFSTR("SEUpdaterErrorDomain"));
    }
    if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("Digest"), (const void **)&value))
    {
      v50 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v63, "Missing kRoseTagDigest in kRoseTagMeasurementRTKitOS");
      v51 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v50, &v63, 2, CFSTR("SEUpdaterErrorDomain"));
    }
    v27 = CFDataGetTypeID();
    if (v27 != CFGetTypeID(value))
    {
      v52 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v63, "Wrong type for kRoseTagDigest");
      v53 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v52, &v63, 2, CFSTR("SEUpdaterErrorDomain"));
    }
    v28 = (const __CFData *)value;
    CFDataGetBytePtr((CFDataRef)value);
    CFDataGetLength(v28);
    v29 = Img4EncodeItemPropertyData();
    SEUpdaterUtil::Img4EncodeCallAndThrow(v29, "Failed to add rtod", v30);
  }
  if (CFDictionaryGetValueIfPresent(*((CFDictionaryRef *)this + 1), CFSTR("SE,RapSwBinDsp"), (const void **)&value))
  {
    v31 = CFDictionaryGetTypeID();
    if (v31 != CFGetTypeID(value))
    {
      v54 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v63, "Wrong type for kRoseTagMeasurementSwBinDsp1");
      v55 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v54, &v63, 2, CFSTR("SEUpdaterErrorDomain"));
    }
    if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("Digest"), (const void **)&value))
    {
      v56 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v63, "Missing kRoseTagDigest in kRoseTagMeasurementSwBinDsp1");
      v57 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v56, &v63, 2, CFSTR("SEUpdaterErrorDomain"));
    }
    v32 = CFDataGetTypeID();
    if (v32 != CFGetTypeID(value))
    {
      v58 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v63, "Wrong type for kRoseTagDigest");
      v59 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v58, &v63, 2, CFSTR("SEUpdaterErrorDomain"));
    }
    v33 = (const __CFData *)value;
    CFDataGetBytePtr((CFDataRef)value);
    CFDataGetLength(v33);
    v34 = Img4EncodeItemPropertyData();
    SEUpdaterUtil::Img4EncodeCallAndThrow(v34, "Failed to add rbdd", v35);
  }
  v36 = Img4EncodeItemEnd();
  SEUpdaterUtil::Img4EncodeCallAndThrow(v36, "Fail to Img4EncodeItemEnd", v37);
  v38 = Img4EncodeItemCopyBuffer();
  SEUpdaterUtil::Img4EncodeCallAndThrow(v38, "Fail to Img4EncodeItemCopyBuffer", v39);
  SEUpdaterUtil::SEImg4EncodeContext::~SEImg4EncodeContext((SEUpdaterUtil::SEImg4EncodeContext *)&v62);
}

void sub_21CC987B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  SEUpdaterUtil::SEImg4EncodeContext::~SEImg4EncodeContext((SEUpdaterUtil::SEImg4EncodeContext *)&a12);
  _Unwind_Resume(a1);
}

uint64_t ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

void SEUpdaterUtil::SEImg4EncodeContext::~SEImg4EncodeContext(SEUpdaterUtil::SEImg4EncodeContext *this)
{
  if (*(_QWORD *)this)
  {
    Img4EncodeItemDestroy();
    *(_QWORD *)this = 0;
  }
}

void SERestoreInfo::P73BaseDeviceInfo::parseManifest(SERestoreInfo::P73BaseDeviceInfo *this@<X0>, unsigned __int8 **a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t *v7;
  void *v8;
  void *v9;
  void *exception;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  void *v15;
  std::string *v16;
  void *v17;
  std::string v18;
  void *v19[2];
  char v20;
  void *__p[2];
  char v22;
  unint64_t v23[2];
  std::string v24;
  void *v25[2];
  char v26;
  _QWORD v27[2];
  unint64_t v28;
  unint64_t v29;

  v4 = *((_QWORD *)this + 2);
  v27[0] = *((_QWORD *)this + 1);
  v27[1] = v4;
  v5 = DERDecodeItem((uint64_t)v27, &v28);
  std::string::basic_string[abi:ne180100]<0>(v25, "Fail to parse MQR: cannot decode top level tag");
  SERestoreInfo::CallAndThrow<DERReturn>(v5, (uint64_t)v25);
  if (v26 < 0)
    operator delete(v25[0]);
  if (v28 != 0xE00000000000001ELL)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v24, "Fail to parse MQR: wrong top level tag");
    v11 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, (__int128 *)&v24, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  v23[0] = 0;
  v23[1] = 0;
  v6 = DERParseSequenceContent(&v29, 1u, (uint64_t)&P73BaseManifestQueryResponseDerSpec::ManifestResponseItemSpec, (unint64_t)v23, 0x10uLL);
  std::string::basic_string[abi:ne180100]<0>(__p, "Fail to parse MQR");
  SERestoreInfo::CallAndThrow<DERReturn>((uint64_t)v6, (uint64_t)__p);
  if (v22 < 0)
    operator delete(__p[0]);
  *((_OWORD *)a2 + 13) = 0u;
  *((_OWORD *)a2 + 14) = 0u;
  *((_OWORD *)a2 + 11) = 0u;
  *((_OWORD *)a2 + 12) = 0u;
  *((_OWORD *)a2 + 9) = 0u;
  *((_OWORD *)a2 + 10) = 0u;
  *((_OWORD *)a2 + 7) = 0u;
  *((_OWORD *)a2 + 8) = 0u;
  *((_OWORD *)a2 + 5) = 0u;
  *((_OWORD *)a2 + 6) = 0u;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  *(_OWORD *)a2 = 0u;
  v7 = DERParseSequenceContent(v23, 0xFu, (uint64_t)&P73BaseManifestQueryResponseDerSpec::ManifestResponseDataItemSpec, (unint64_t)a2, 0xF0uLL);
  std::string::basic_string[abi:ne180100]<0>(v19, "Fail to parse MQR.data");
  SERestoreInfo::CallAndThrow<DERReturn>((uint64_t)v7, (uint64_t)v19);
  if (v20 < 0)
    operator delete(v19[0]);
  if (a2[1] != (unsigned __int8 *)1
    || (unint64_t)a2[3] > 2
    || (unint64_t)a2[5] > 2
    || (unint64_t)a2[7] > 2
    || (unint64_t)a2[9] > 2
    || a2[15] != (unsigned __int8 *)1
    || (unint64_t)a2[25] > 2
    || a2[13] != (unsigned __int8 *)24
    || a2[17] != (unsigned __int8 *)20
    || a2[19] != (unsigned __int8 *)32
    || a2[21] != (unsigned __int8 *)32
    || a2[11] != (unsigned __int8 *)2
    || a2[23] != (unsigned __int8 *)1)
  {
    v8 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v24, "size of MQRD doesn't match");
    v9 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v8, (__int128 *)&v24, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  if (**a2 == 1)
  {
    if (a2[27] != (unsigned __int8 *)3 || a2[29] != (unsigned __int8 *)32)
      goto LABEL_30;
  }
  else
  {
    if (**a2)
    {
      v14 = **a2;
      v15 = __cxa_allocate_exception(0x48uLL);
      std::to_string(&v18, v14);
      v16 = std::string::insert(&v18, 0, "Unsupported manifest query version: ");
      v24 = *v16;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      v17 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v15, (__int128 *)&v24, 7, CFSTR("SEUpdaterErrorDomain"));
    }
    if ((unint64_t)a2[27] | (unint64_t)a2[29])
    {
LABEL_30:
      v12 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v24, "size of factoryPostflightState or cometRootKeyId doesn't match");
      v13 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v12, (__int128 *)&v24, 2, CFSTR("SEUpdaterErrorDomain"));
    }
  }
}

void sub_21CC98C68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

SERestoreInfo::P73BaseDeviceInfo *SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(SERestoreInfo::P73BaseDeviceInfo *this)
{
  *(_QWORD *)this = &off_24E0BFD58;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_QWORD *)this + 16) = 0;
  SERestoreInfo::P73BaseDeviceInfo::init(this);
  return this;
}

void sub_21CC98D88(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  v5 = v2;
  v7 = *v5;
  if (*v5)
  {
    v1[20] = v7;
    operator delete(v7);
  }
  v8 = (void *)v1[14];
  if (v8)
  {
    v1[15] = v8;
    operator delete(v8);
  }
  v9 = (void *)v1[11];
  if (v9)
  {
    v1[12] = v9;
    operator delete(v9);
  }
  v10 = *v4;
  if (*v4)
  {
    v1[9] = v10;
    operator delete(v10);
  }
  v11 = *v3;
  if (*v3)
  {
    v1[5] = v11;
    operator delete(v11);
  }
  _Unwind_Resume(exception_object);
}

double SERestoreInfo::P73BaseDeviceInfo::init(SERestoreInfo::P73BaseDeviceInfo *this)
{
  double result;
  char v3;
  char v4;
  char v5;
  char v6;
  char v7;

  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 2) = 1;
  v7 = 0;
  std::vector<unsigned char>::assign((char **)this + 4, 0x18uLL, &v7);
  v6 = 0;
  std::vector<unsigned char>::assign((char **)this + 8, 0x14uLL, &v6);
  v5 = 0;
  std::vector<unsigned char>::assign((char **)this + 11, 0x20uLL, &v5);
  v4 = 0;
  std::vector<unsigned char>::assign((char **)this + 14, 0x20uLL, &v4);
  *((_QWORD *)this + 17) = 0;
  *(_QWORD *)((char *)this + 20) = 0;
  *(_QWORD *)((char *)this + 12) = 0;
  *((_DWORD *)this + 7) = 23195;
  *((_DWORD *)this + 36) = 0;
  v3 = 0;
  std::vector<unsigned char>::assign((char **)this + 19, 0x20uLL, &v3);
  result = 0.0;
  *((_QWORD *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  return result;
}

SERestoreInfo::P73BaseDeviceInfo *SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(SERestoreInfo::P73BaseDeviceInfo *this, const SERestoreInfo::BLOB *a2)
{
  _OWORD v5[15];

  *(_QWORD *)this = &off_24E0BFD58;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_QWORD *)this + 16) = 0;
  SERestoreInfo::P73BaseDeviceInfo::init(this);
  memset(v5, 0, sizeof(v5));
  SERestoreInfo::P73BaseDeviceInfo::parseManifest(a2, (unsigned __int8 **)v5);
  SERestoreInfo::P73BaseDeviceInfo::updateDeviceInfo((uint64_t)this, (unsigned __int8 **)v5);
  return this;
}

void sub_21CC98F5C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void **v4;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  v6 = *v4;
  if (*v4)
  {
    v1[20] = v6;
    operator delete(v6);
  }
  v7 = (void *)v1[14];
  if (v7)
  {
    v1[15] = v7;
    operator delete(v7);
  }
  v8 = (void *)v1[11];
  if (v8)
  {
    v1[12] = v8;
    operator delete(v8);
  }
  v9 = *v3;
  if (*v3)
  {
    v1[9] = v9;
    operator delete(v9);
  }
  v10 = *v2;
  if (*v2)
  {
    v1[5] = v10;
    operator delete(v10);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *SERestoreInfo::P73BaseDeviceInfo::updateDeviceInfo(uint64_t a1, unsigned __int8 **a2)
{
  unsigned __int8 *v4;
  int v5;
  unsigned __int8 *v6;
  int v7;
  unsigned __int8 *v8;
  unsigned int v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  unsigned __int8 *v20;
  int v21;
  unsigned __int8 *v22;
  int v23;
  unsigned __int8 *v24;
  int v25;
  unsigned __int8 *v26;
  int v27;
  unsigned int v28;
  unsigned __int8 v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  __int128 *v35;
  __int128 *v36;
  __int128 *v37;
  BOOL v38;
  unsigned __int8 *v39;
  int v40;
  unsigned __int8 *v41;
  int v42;
  unsigned __int8 *v43;
  int v44;
  unsigned __int8 *v45;
  int v46;
  unsigned __int8 *v47;
  int v48;
  unsigned __int8 *v49;
  int v50;
  _QWORD *result;
  unint64_t v52;
  unsigned __int8 *v53;
  int v54;
  unsigned __int8 *v55;
  int v56;
  void *exception;
  void *v58;
  int v59;
  uint64_t i;
  unsigned int v61;
  uint64_t v62[3];
  uint64_t v63[3];
  uint64_t v64[3];
  uint64_t v65[3];
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  __int128 v70[2];
  int v71;
  uint64_t v72[3];
  int v73;
  uint64_t v74[3];
  int v75;
  uint64_t v76[4];

  v76[3] = *MEMORY[0x24BDAC8D0];
  v4 = a2[1];
  if (v4)
  {
    v5 = 0;
    v6 = *a2;
    do
    {
      v7 = *v6++;
      v5 = v7 | (v5 << 8);
      --v4;
    }
    while (v4);
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(a1 + 8) = v5;
  v8 = a2[3];
  if (v8)
  {
    v9 = 0;
    v10 = a2[2];
    do
    {
      v11 = *v10++;
      v9 = v11 | (v9 << 8);
      --v8;
    }
    while (v8);
  }
  else
  {
    v9 = 0;
  }
  *(_DWORD *)(a1 + 12) = v9;
  v12 = a2[5];
  if (v12)
  {
    v13 = 0;
    v14 = a2[4];
    do
    {
      v15 = *v14++;
      v13 = v15 | (v13 << 8);
      --v12;
    }
    while (v12);
  }
  else
  {
    v13 = 0;
  }
  *(_DWORD *)(a1 + 16) = v13;
  v16 = a2[7];
  if (v16)
  {
    v17 = 0;
    v18 = a2[6];
    do
    {
      v19 = *v18++;
      v17 = v19 | (v17 << 8);
      --v16;
    }
    while (v16);
  }
  else
  {
    v17 = 0;
  }
  *(_DWORD *)(a1 + 20) = v17;
  v20 = a2[9];
  if (v20)
  {
    v21 = 0;
    v22 = a2[8];
    do
    {
      v23 = *v22++;
      v21 = v23 | (v21 << 8);
      --v20;
    }
    while (v20);
  }
  else
  {
    v21 = 0;
  }
  *(_DWORD *)(a1 + 24) = v21;
  v24 = a2[15];
  if (!v24)
  {
    *(_DWORD *)(a1 + 56) = 0;
    goto LABEL_88;
  }
  v25 = 0;
  v26 = a2[14];
  do
  {
    v27 = *v26++;
    v25 = v27 | (v25 << 8);
    --v24;
  }
  while (v24);
  *(_DWORD *)(a1 + 56) = v25;
  if (v25 > 114)
  {
    if (v25 != 115)
    {
      if (v25 != 210 && v25 != 200)
      {
LABEL_88:
        exception = __cxa_allocate_exception(0x48uLL);
        std::string::basic_string[abi:ne180100]<0>(v70, "Unsupported chip ID");
        v58 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, v70, 2, CFSTR("SEUpdaterErrorDomain"));
      }
      goto LABEL_37;
    }
    v28 = 2;
  }
  else if ((v25 - 54) < 2)
  {
    v28 = 5;
  }
  else
  {
    if (v25 != 44)
    {
      if (v25 != 100)
        goto LABEL_88;
LABEL_37:
      v28 = 3;
      goto LABEL_41;
    }
    v28 = 4;
  }
LABEL_41:
  *(_DWORD *)(a1 + 180) = v28;
  v29 = atomic_load((unsigned __int8 *)&_MergedGlobals_1);
  if ((v29 & 1) == 0)
  {
    v61 = v28;
    v59 = __cxa_guard_acquire(&_MergedGlobals_1);
    v28 = v61;
    if (v59)
    {
      v69 = 0x1400000F00;
      std::map<unsigned int,unsigned int>::map[abi:ne180100](v65, (unsigned int *)&v69, 1);
      LODWORD(v70[0]) = 3;
      std::map<unsigned int,unsigned int>::map[abi:ne180100]((uint64_t *)v70 + 1, v65);
      v68 = 0x1400000300;
      std::map<unsigned int,unsigned int>::map[abi:ne180100](v64, (unsigned int *)&v68, 1);
      v71 = 4;
      std::map<unsigned int,unsigned int>::map[abi:ne180100](v72, v64);
      v67 = 0x1400000100;
      std::map<unsigned int,unsigned int>::map[abi:ne180100](v63, (unsigned int *)&v67, 1);
      v73 = 5;
      std::map<unsigned int,unsigned int>::map[abi:ne180100](v74, v63);
      v66 = 0x1400000000;
      std::map<unsigned int,unsigned int>::map[abi:ne180100](v62, (unsigned int *)&v66, 1);
      v75 = 6;
      std::map<unsigned int,unsigned int>::map[abi:ne180100](v76, v62);
      std::map<unsigned int,std::map<unsigned int,unsigned int>>::map[abi:ne180100]((uint64_t *)v70, 4);
      for (i = 7; i != -1; i -= 2)
        std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*(_QWORD **)&v70[i]);
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy((_QWORD *)v62[1]);
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy((_QWORD *)v63[1]);
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy((_QWORD *)v64[1]);
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy((_QWORD *)v65[1]);
      __cxa_guard_release(&_MergedGlobals_1);
      v28 = v61;
    }
  }
  v30 = qword_255323740;
  if (!qword_255323740)
  {
LABEL_48:
    v33 = -1;
    goto LABEL_64;
  }
  v31 = qword_255323740;
  while (1)
  {
    v32 = *(_DWORD *)(v31 + 32);
    if (v28 >= v32)
      break;
LABEL_47:
    v31 = *(_QWORD *)v31;
    if (!v31)
      goto LABEL_48;
  }
  if (v32 < v28)
  {
    v31 += 8;
    goto LABEL_47;
  }
  while (1)
  {
    while (1)
    {
      v34 = *(_DWORD *)(v30 + 32);
      if (v34 <= v28)
        break;
      v30 = *(_QWORD *)v30;
      if (!v30)
LABEL_86:
        std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
    }
    if (v34 >= v28)
      break;
    v30 = *(_QWORD *)(v30 + 8);
    if (!v30)
      goto LABEL_86;
  }
  std::map<unsigned int,unsigned int>::map[abi:ne180100]((uint64_t *)v70, (_QWORD *)(v30 + 40));
  v35 = *(__int128 **)&v70[0];
  v33 = -1;
  if (*(__int128 **)&v70[0] != (__int128 *)((char *)v70 + 8))
  {
    do
    {
      if (*((_DWORD *)v35 + 7) <= v9)
        v33 = *((_DWORD *)v35 + 8);
      v36 = (__int128 *)*((_QWORD *)v35 + 1);
      if (v36)
      {
        do
        {
          v37 = v36;
          v36 = *(__int128 **)v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          v37 = (__int128 *)*((_QWORD *)v35 + 2);
          v38 = *(_QWORD *)v37 == (_QWORD)v35;
          v35 = v37;
        }
        while (!v38);
      }
      v35 = v37;
    }
    while (v37 != (__int128 *)((char *)v70 + 8));
  }
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*((_QWORD **)&v70[0] + 1));
LABEL_64:
  *(_DWORD *)(a1 + 184) = v33;
  v39 = a2[25];
  if (v39)
  {
    v40 = 0;
    v41 = a2[24];
    do
    {
      v42 = *v41++;
      v40 = v42 | (v40 << 8);
      --v39;
    }
    while (v39);
  }
  else
  {
    v40 = 0;
  }
  *(_DWORD *)(a1 + 140) = v40;
  v43 = a2[23];
  if (v43)
  {
    v44 = 0;
    v45 = a2[22];
    do
    {
      v46 = *v45++;
      v44 = v46 | (v44 << 8);
      --v43;
    }
    while (v43);
  }
  else
  {
    v44 = 0;
  }
  *(_DWORD *)(a1 + 136) = v44;
  v47 = a2[27];
  if (v47)
  {
    v48 = 0;
    v49 = a2[26];
    do
    {
      v50 = *v49++;
      v48 = v50 | (v48 << 8);
      --v47;
    }
    while (v47);
    *(_DWORD *)(a1 + 144) = v48;
  }
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a1 + 32), (char *)a2[12], (char *)&a2[13][(_QWORD)a2[12]], (unint64_t)a2[13]);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a1 + 64), (char *)a2[16], (char *)&a2[17][(_QWORD)a2[16]], (unint64_t)a2[17]);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a1 + 88), (char *)a2[18], (char *)&a2[19][(_QWORD)a2[18]], (unint64_t)a2[19]);
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a1 + 112), (char *)a2[20], (char *)&a2[21][(_QWORD)a2[20]], (unint64_t)a2[21]);
  v52 = (unint64_t)a2[29];
  if (v52)
    result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a1 + 152), (char *)a2[28], (char *)&a2[28][v52], v52);
  v53 = a2[11];
  if (v53)
  {
    v54 = 0;
    v55 = a2[10];
    do
    {
      v56 = *v55++;
      v54 = v56 | (v54 << 8);
      --v53;
    }
    while (v53);
  }
  else
  {
    v54 = 0;
  }
  *(_DWORD *)(a1 + 28) = v54;
  return result;
}

void sub_21CC99510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _QWORD *a11, uint64_t a12, uint64_t a13, _QWORD *a14, uint64_t a15, uint64_t a16, _QWORD *a17, uint64_t a18, uint64_t a19, _QWORD *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  uint64_t v31;
  uint64_t i;

  for (i = 112; i != -16; i -= 32)
    std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*(_QWORD **)(v31 + i));
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(a11);
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(a14);
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(a17);
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(a20);
  __cxa_guard_abort(&_MergedGlobals_1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::P73BaseDeviceInfo::updateDict(SERestoreInfo::P73BaseDeviceInfo *this, __CFDictionary *a2, char a3)
{
  CFNumberRef v6;
  CFNumberRef v7;
  CFDataRef v8;
  CFDataRef v9;
  CFDataRef v10;
  CFDataRef v11;
  CFDataRef v12;
  CFDataRef v13;
  CFDataRef v14;
  CFDataRef v15;
  int valuePtr;

  valuePtr = *((_DWORD *)this + 14);
  v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt32Type, &valuePtr);
  if (!v6)
    __assert_rtn("_CFDictionarySetInteger32", "SERestoreInfoHelpers.hpp", 42, "num != nullptr");
  v7 = v6;
  CFDictionarySetValue(a2, CFSTR("SE,ChipID"), v6);
  CFRelease(v7);
  v8 = CFDataCreate(0, *((const UInt8 **)this + 4), *((_QWORD *)this + 5) - *((_QWORD *)this + 4));
  if (!v8)
    goto LABEL_9;
  v9 = v8;
  CFDictionarySetValue(a2, CFSTR("SE,ID"), v8);
  CFRelease(v9);
  v10 = CFDataCreate(0, *((const UInt8 **)this + 8), *((_QWORD *)this + 9) - *((_QWORD *)this + 8));
  if (!v10)
    goto LABEL_9;
  v11 = v10;
  CFDictionarySetValue(a2, CFSTR("SE,Nonce"), v10);
  CFRelease(v11);
  v12 = CFDataCreate(0, *((const UInt8 **)this + 11), *((_QWORD *)this + 12) - *((_QWORD *)this + 11));
  if (!v12)
    goto LABEL_9;
  v13 = v12;
  CFDictionarySetValue(a2, CFSTR("SE,RootKeyIdentifier"), v12);
  CFRelease(v13);
  if ((a3 & 1) != 0)
    return;
  v14 = CFDataCreate(0, *((const UInt8 **)this + 14), *((_QWORD *)this + 15) - *((_QWORD *)this + 14));
  if (!v14)
LABEL_9:
    __assert_rtn("_CFDictionarySetData", "SERestoreInfoHelpers.hpp", 59, "tmpData");
  v15 = v14;
  CFDictionarySetValue(a2, CFSTR("SE,OSUPubKeyID"), v14);
  CFRelease(v15);
}

void SERestoreInfo::P73BaseDeviceInfo::getStateName(int a1@<W0>, std::string *a2@<X8>)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t **v5;
  int *v6;
  int v7;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t **v10;
  BOOL v11;
  uint64_t **v12;
  uint64_t **v13;
  uint64_t *v14;
  int v15;
  char *v16;
  std::string *v17;
  _DWORD *v18;
  const std::string::value_type **v19;
  uint64_t i;
  uint64_t *v21;
  uint64_t *v22;
  int v23;
  int v24;
  __int128 v25;
  uint64_t **v27;
  uint64_t *v28;
  uint64_t v29;
  _DWORD v30[2];
  uint64_t v31[3];
  int v32;
  uint64_t v33[3];
  int v34;
  uint64_t v35[3];
  int v36;
  uint64_t v37[3];
  int v38;
  uint64_t v39[3];
  int v40;
  uint64_t v41[3];
  int v42;
  uint64_t v43[3];
  int v44;
  _QWORD v45[5];

  v45[3] = *MEMORY[0x24BDAC8D0];
  v30[0] = 23195;
  std::string::basic_string[abi:ne180100]<0>(v31, "EXPORT_REQUIRED");
  v32 = 47411;
  std::string::basic_string[abi:ne180100]<0>(v33, "IMPORT_REQUIRED");
  v34 = 47361;
  std::string::basic_string[abi:ne180100]<0>(v35, "UOS1");
  v36 = 47362;
  std::string::basic_string[abi:ne180100]<0>(v37, "UOS2");
  v38 = 42241;
  std::string::basic_string[abi:ne180100]<0>(v39, "UOS1_ERROR");
  v40 = 42242;
  std::string::basic_string[abi:ne180100]<0>(v41, "UOS2_ERROR");
  v42 = 47545;
  std::string::basic_string[abi:ne180100]<0>(v43, "EXPORT_FINISHED");
  v44 = 47377;
  std::string::basic_string[abi:ne180100]<0>(v45, "UOS1_KTP");
  v3 = 0;
  v4 = 0;
  v28 = 0;
  v29 = 0;
  v27 = &v28;
  v5 = &v28;
  while (1)
  {
    v6 = &v30[8 * v4];
    v7 = *v6;
    v8 = &v28;
    if (v5 == &v28)
      goto LABEL_8;
    v9 = v3;
    v10 = &v28;
    if (v3)
    {
      do
      {
        v8 = (uint64_t **)v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      do
      {
        v8 = (uint64_t **)v10[2];
        v11 = *v8 == (uint64_t *)v10;
        v10 = v8;
      }
      while (v11);
    }
    if (*((_DWORD *)v8 + 8) < v7)
    {
LABEL_8:
      if (v3)
        v12 = v8;
      else
        v12 = &v28;
      if (v3)
      {
        v13 = v8 + 1;
      }
      else
      {
        v8 = (uint64_t **)&v27;
        v13 = &v28;
      }
      if (v8[1])
        goto LABEL_30;
LABEL_24:
      v16 = (char *)operator new(0x40uLL);
      *((_DWORD *)v16 + 8) = v7;
      v17 = (std::string *)(v16 + 40);
      v18 = &v30[8 * v4];
      v19 = (const std::string::value_type **)(v18 + 2);
      if (*((char *)v6 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(v17, *v19, *((_QWORD *)v18 + 2));
      }
      else
      {
        *(_OWORD *)&v17->__r_.__value_.__l.__data_ = *(_OWORD *)v19;
        *((_QWORD *)v16 + 7) = *((_QWORD *)v18 + 3);
      }
      *(_QWORD *)v16 = 0;
      *((_QWORD *)v16 + 1) = 0;
      *((_QWORD *)v16 + 2) = v12;
      *v13 = (uint64_t *)v16;
      if (*v27)
      {
        v27 = (uint64_t **)*v27;
        v16 = (char *)*v13;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v28, (uint64_t *)v16);
      ++v29;
      goto LABEL_30;
    }
    v13 = &v28;
    v12 = &v28;
    if (!v3)
      goto LABEL_24;
    v14 = v3;
    while (1)
    {
      while (1)
      {
        v12 = (uint64_t **)v14;
        v15 = *((_DWORD *)v14 + 8);
        if (v15 <= v7)
          break;
        v14 = *v12;
        v13 = v12;
        if (!*v12)
          goto LABEL_24;
      }
      if (v15 >= v7)
        break;
      v14 = v12[1];
      if (!v14)
      {
        v13 = v12 + 1;
        goto LABEL_24;
      }
    }
LABEL_30:
    if (++v4 == 8)
      break;
    v5 = v27;
    v3 = v28;
  }
  for (i = 0; i != -32; i -= 4)
  {
    if (SHIBYTE(v45[i + 2]) < 0)
      operator delete((void *)v45[i]);
  }
  v21 = v28;
  if (!v28)
  {
LABEL_42:
    std::string::basic_string[abi:ne180100]<0>(a2, "UNK_STATE");
    goto LABEL_43;
  }
  v22 = v28;
  while (2)
  {
    v23 = *((_DWORD *)v22 + 8);
    if (v23 > a1)
    {
LABEL_41:
      v22 = (uint64_t *)*v22;
      if (!v22)
        goto LABEL_42;
      continue;
    }
    break;
  }
  if (v23 < a1)
  {
    ++v22;
    goto LABEL_41;
  }
  while (1)
  {
    while (1)
    {
      v24 = *((_DWORD *)v21 + 8);
      if (v24 <= a1)
        break;
      v21 = (uint64_t *)*v21;
      if (!v21)
LABEL_52:
        std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
    }
    if (v24 >= a1)
      break;
    v21 = (uint64_t *)v21[1];
    if (!v21)
      goto LABEL_52;
  }
  if (*((char *)v21 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(a2, (const std::string::value_type *)v21[5], v21[6]);
  }
  else
  {
    v25 = *(_OWORD *)(v21 + 5);
    a2->__r_.__value_.__r.__words[2] = v21[7];
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v25;
  }
LABEL_43:
  std::__tree<std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>,std::__map_value_compare<SERestoreInfo::AMS_UOS_ID,std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>,std::less<SERestoreInfo::AMS_UOS_ID>,true>,std::allocator<std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>>>::destroy((char *)v28);
}

void sub_21CC99B4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  char *v13;

  while (1)
  {
    if (*(v13 - 1) < 0)
      operator delete(*((void **)v13 - 3));
    v13 -= 32;
    if (v13 == &a13)
      _Unwind_Resume(exception_object);
  }
}

void SERestoreInfo::P73BaseDeviceInfo::getIm4State(SERestoreInfo::P73BaseDeviceInfo *this@<X0>, std::string *a2@<X8>)
{
  unsigned int v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t **v5;
  unsigned int *v6;
  unsigned int v7;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t **v10;
  BOOL v11;
  uint64_t **v12;
  uint64_t **v13;
  uint64_t *v14;
  unsigned int v15;
  char *v16;
  std::string *v17;
  _DWORD *v18;
  const std::string::value_type **v19;
  uint64_t i;
  uint64_t *v21;
  uint64_t *v22;
  unsigned int v23;
  unsigned int v24;
  __int128 v25;
  uint64_t **v27;
  uint64_t *v28;
  uint64_t v29;
  _DWORD v30[2];
  uint64_t v31[3];
  int v32;
  uint64_t v33[3];
  int v34;
  uint64_t v35[3];
  int v36;
  uint64_t v37[3];
  int v38;
  _QWORD v39[5];

  v2 = this;
  v39[3] = *MEMORY[0x24BDAC8D0];
  v30[0] = 23130;
  std::string::basic_string[abi:ne180100]<0>(v31, "Idle");
  v32 = 47545;
  std::string::basic_string[abi:ne180100]<0>(v33, "IM4M_validated");
  v34 = 26471;
  std::string::basic_string[abi:ne180100]<0>(v35, "IM4P_validated");
  v36 = 59367;
  std::string::basic_string[abi:ne180100]<0>(v37, "IM4P_Resent");
  v38 = 42405;
  std::string::basic_string[abi:ne180100]<0>(v39, "Im4_error");
  v3 = 0;
  v4 = 0;
  v28 = 0;
  v29 = 0;
  v27 = &v28;
  v5 = &v28;
  while (1)
  {
    v6 = &v30[8 * v4];
    v7 = *v6;
    v8 = &v28;
    if (v5 == &v28)
      goto LABEL_8;
    v9 = v3;
    v10 = &v28;
    if (v3)
    {
      do
      {
        v8 = (uint64_t **)v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      do
      {
        v8 = (uint64_t **)v10[2];
        v11 = *v8 == (uint64_t *)v10;
        v10 = v8;
      }
      while (v11);
    }
    if (*((_DWORD *)v8 + 8) < v7)
    {
LABEL_8:
      if (v3)
        v12 = v8;
      else
        v12 = &v28;
      if (v3)
      {
        v13 = v8 + 1;
      }
      else
      {
        v8 = (uint64_t **)&v27;
        v13 = &v28;
      }
      if (v8[1])
        goto LABEL_30;
LABEL_24:
      v16 = (char *)operator new(0x40uLL);
      *((_DWORD *)v16 + 8) = v7;
      v17 = (std::string *)(v16 + 40);
      v18 = &v30[8 * v4];
      v19 = (const std::string::value_type **)(v18 + 2);
      if (*((char *)v6 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(v17, *v19, *((_QWORD *)v18 + 2));
      }
      else
      {
        *(_OWORD *)&v17->__r_.__value_.__l.__data_ = *(_OWORD *)v19;
        *((_QWORD *)v16 + 7) = *((_QWORD *)v18 + 3);
      }
      *(_QWORD *)v16 = 0;
      *((_QWORD *)v16 + 1) = 0;
      *((_QWORD *)v16 + 2) = v12;
      *v13 = (uint64_t *)v16;
      if (*v27)
      {
        v27 = (uint64_t **)*v27;
        v16 = (char *)*v13;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v28, (uint64_t *)v16);
      ++v29;
      goto LABEL_30;
    }
    v13 = &v28;
    v12 = &v28;
    if (!v3)
      goto LABEL_24;
    v14 = v3;
    while (1)
    {
      while (1)
      {
        v12 = (uint64_t **)v14;
        v15 = *((_DWORD *)v14 + 8);
        if (v15 <= v7)
          break;
        v14 = *v12;
        v13 = v12;
        if (!*v12)
          goto LABEL_24;
      }
      if (v15 >= v7)
        break;
      v14 = v12[1];
      if (!v14)
      {
        v13 = v12 + 1;
        goto LABEL_24;
      }
    }
LABEL_30:
    if (++v4 == 5)
      break;
    v5 = v27;
    v3 = v28;
  }
  for (i = 0; i != -20; i -= 4)
  {
    if (SHIBYTE(v39[i + 2]) < 0)
      operator delete((void *)v39[i]);
  }
  v21 = v28;
  if (!v28)
  {
LABEL_42:
    std::string::basic_string[abi:ne180100]<0>(a2, "UNK_IM4_STATE");
    goto LABEL_43;
  }
  v22 = v28;
  while (2)
  {
    v23 = *((_DWORD *)v22 + 8);
    if (v23 > v2)
    {
LABEL_41:
      v22 = (uint64_t *)*v22;
      if (!v22)
        goto LABEL_42;
      continue;
    }
    break;
  }
  if (v23 < v2)
  {
    ++v22;
    goto LABEL_41;
  }
  while (1)
  {
    while (1)
    {
      v24 = *((_DWORD *)v21 + 8);
      if (v24 <= v2)
        break;
      v21 = (uint64_t *)*v21;
      if (!v21)
LABEL_52:
        std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
    }
    if (v24 >= v2)
      break;
    v21 = (uint64_t *)v21[1];
    if (!v21)
      goto LABEL_52;
  }
  if (*((char *)v21 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(a2, (const std::string::value_type *)v21[5], v21[6]);
  }
  else
  {
    v25 = *(_OWORD *)(v21 + 5);
    a2->__r_.__value_.__r.__words[2] = v21[7];
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v25;
  }
LABEL_43:
  std::__tree<std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>,std::__map_value_compare<SERestoreInfo::AMS_UOS_ID,std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>,std::less<SERestoreInfo::AMS_UOS_ID>,true>,std::allocator<std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>>>::destroy((char *)v28);
}

void sub_21CC99F28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  char *v13;

  while (1)
  {
    if (*(v13 - 1) < 0)
      operator delete(*((void **)v13 - 3));
    v13 -= 32;
    if (v13 == &a13)
      _Unwind_Resume(exception_object);
  }
}

uint64_t SERestoreInfo::P73BaseDeviceInfo::print(SERestoreInfo::P73BaseDeviceInfo *this)
{
  _BOOL4 isDev;
  const char *v3;
  uint64_t v4;
  _QWORD *v5;
  std::string *p_p;
  std::string::size_type size;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  std::string *v13;
  std::string::size_type v14;
  _QWORD *v15;
  std::string __p;
  _QWORD v18[11];
  char v19;
  uint64_t v20;

  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v18);
  isDev = SERestoreInfo::P73BaseDeviceInfo::isDev(this);
  if (isDev)
    v3 = "DEV ";
  else
    v3 = "PROD ";
  if (isDev)
    v4 = 4;
  else
    v4 = 5;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)v3, v4);
  v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"{ ", 2);
  SERestoreInfo::P73BaseDeviceInfo::getStateName(*((_DWORD *)this + 7), &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_DWORD *)((char *)&v18[1] + *(_QWORD *)(v18[0] - 24)) = *(_DWORD *)((_BYTE *)&v18[1] + *(_QWORD *)(v18[0] - 24)) & 0xFFFFFFB5 | 8;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" rsn=0x", 7);
  v8 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" csn=0x", 7);
  v9 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" fsn=0x", 7);
  v10 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" bsn=0x", 7);
  v11 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" FPState=0x", 11);
  std::ostream::operator<<();
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" ", 1);
  SERestoreInfo::P73BaseDeviceInfo::getIm4State((SERestoreInfo::P73BaseDeviceInfo *)*((unsigned int *)this + 35), &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v13 = &__p;
  else
    v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v14 = __p.__r_.__value_.__l.__size_;
  v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)v13, v14);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" }", 2);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  std::stringbuf::str();
  v18[0] = *MEMORY[0x24BEDB800];
  *(_QWORD *)((char *)v18 + *(_QWORD *)(v18[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
  v18[1] = MEMORY[0x24BEDB848] + 16;
  if (v19 < 0)
    operator delete((void *)v18[9]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x22078A778](&v20);
}

void sub_21CC9A204(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  std::ostringstream::~ostringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;

  v2 = MEMORY[0x24BEDB870];
  v3 = MEMORY[0x24BEDB870] + 64;
  *(_QWORD *)(a1 + 112) = MEMORY[0x24BEDB870] + 64;
  v4 = *(_QWORD *)(MEMORY[0x24BEDB800] + 8);
  v5 = *(_QWORD *)(MEMORY[0x24BEDB800] + 16);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 8) = MEMORY[0x24BEDB848] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_21CC9A300(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x22078A778](v1);
  _Unwind_Resume(a1);
}

BOOL SERestoreInfo::P73BaseDeviceInfo::isDev(SERestoreInfo::P73BaseDeviceInfo *this)
{
  int v2;
  _BOOL8 v3;
  const void *v4;
  size_t v5;
  _BYTE *v6;
  _BYTE *v8;
  _BYTE *v9;

  v2 = (*(uint64_t (**)(SERestoreInfo::P73BaseDeviceInfo *))(*(_QWORD *)this + 32))(this);
  v3 = 1;
  RootCA::getRootKeyId(1, v2, &v8);
  v4 = (const void *)*((_QWORD *)this + 11);
  v5 = *((_QWORD *)this + 12) - (_QWORD)v4;
  v6 = v8;
  if (v5 == v9 - v8)
    v3 = memcmp(v4, v8, v5) != 0;
  if (v6)
  {
    v9 = v6;
    operator delete(v6);
  }
  return v3;
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x24BEDB800];
  v3 = *MEMORY[0x24BEDB800];
  *(_QWORD *)a1 = *MEMORY[0x24BEDB800];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x24BEDB848] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x22078A778](a1 + 112);
  return a1;
}

BOOL SERestoreInfo::P73BaseDeviceInfo::isProdEval(SERestoreInfo::P73BaseDeviceInfo *this)
{
  _OWORD *v2;
  _OWORD *v3;
  uint64_t *v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BOOL8 v15;

  v2 = operator new(0x20uLL);
  *v2 = constinit;
  v2[1] = unk_21CCD8058;
  v3 = operator new(0x20uLL);
  *v3 = constinit_34;
  v3[1] = unk_21CCD8078;
  v4 = (uint64_t *)*((_QWORD *)this + 14);
  if (*((_QWORD *)this + 15) - (_QWORD)v4 == 32)
  {
    if (*v4 == *(_QWORD *)v2
      && v4[1] == *((_QWORD *)v2 + 1)
      && v4[2] == *((_QWORD *)v2 + 2)
      && v4[3] == *((_QWORD *)v2 + 3))
    {
      v15 = 1;
    }
    else
    {
      v8 = *v4;
      v9 = v4[1];
      v11 = v4[2];
      v10 = v4[3];
      v15 = v8 == *(_QWORD *)v3 && v9 == *((_QWORD *)v3 + 1) && v11 == *((_QWORD *)v3 + 2) && v10 == *((_QWORD *)v3 + 3);
    }
  }
  else
  {
    v15 = 0;
  }
  operator delete(v3);
  operator delete(v2);
  return v15;
}

void sub_21CC9A4F4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::vector<unsigned char>::assign(char **a1, unint64_t a2, char *a3)
{
  unint64_t v4;
  unint64_t v6;
  char *result;
  uint64_t v8;
  size_t v9;
  char *v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  unint64_t v15;
  char *v16;
  char *v17;

  v4 = a2;
  v6 = (unint64_t)a1[2];
  result = *a1;
  if (v6 - (unint64_t)result >= a2)
  {
    v12 = a1[1] - result;
    if (v12 >= a2)
      v13 = a2;
    else
      v13 = a1[1] - result;
    for (; v13; --v13)
      *result++ = *a3;
    v14 = a2 >= v12;
    v15 = a2 - v12;
    if (v15 != 0 && v14)
    {
      v16 = a1[1];
      v17 = &v16[v15];
      do
      {
        *v16++ = *a3;
        --v15;
      }
      while (v15);
      a1[1] = v17;
    }
    else
    {
      a1[1] = &(*a1)[a2];
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if ((v4 & 0x8000000000000000) != 0)
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    v8 = 2 * v6;
    if (2 * v6 <= v4)
      v8 = v4;
    if (v6 >= 0x3FFFFFFFFFFFFFFFLL)
      v9 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v9 = v8;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](a1, v9);
    v10 = a1[1];
    v11 = &v10[v4];
    do
    {
      *v10++ = *a3;
      --v4;
    }
    while (v4);
    a1[1] = v11;
  }
  return result;
}

uint64_t *std::map<unsigned int,unsigned int>::map[abi:ne180100](uint64_t *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v6;

  a1[1] = 0;
  v4 = a1 + 1;
  a1[2] = 0;
  *a1 = (uint64_t)(a1 + 1);
  if (a3)
  {
    v6 = 8 * a3;
    do
    {
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int const,unsigned int> const&>(a1, v4, *a2, *(_QWORD *)a2);
      a2 += 2;
      v6 -= 8;
    }
    while (v6);
  }
  return a1;
}

void sub_21CC9A774(_Unwind_Exception *a1)
{
  _QWORD **v1;

  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int const,unsigned int> const&>(uint64_t *result, uint64_t *a2, unsigned int a3, uint64_t a4)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  unsigned int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t **v14;
  uint64_t *v15;
  BOOL v16;
  uint64_t **v17;
  uint64_t *v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t *v21;
  unsigned int v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;

  v5 = (uint64_t **)a2;
  v6 = result;
  v7 = (uint64_t **)(result + 1);
  if (result + 1 != a2)
  {
    v8 = *((_DWORD *)a2 + 7);
    if (v8 <= a3)
    {
      if (v8 >= a3)
        return result;
      v13 = (uint64_t **)(a2 + 1);
      v12 = (uint64_t *)a2[1];
      if (v12)
      {
        do
        {
          v13 = (uint64_t **)v12;
          v12 = (uint64_t *)*v12;
          v5 = v13;
          v14 = v13;
        }
        while (v12);
      }
      else
      {
        v14 = (uint64_t **)a2;
        do
        {
          v20 = (uint64_t *)v14;
          v14 = (uint64_t **)v14[2];
        }
        while (*v14 != v20);
      }
      if (v14 == v7)
        goto LABEL_42;
      if (*((_DWORD *)v14 + 7) > a3)
        goto LABEL_42;
      v21 = *v7;
      v13 = (uint64_t **)(result + 1);
      v5 = (uint64_t **)(result + 1);
      if (!*v7)
        goto LABEL_42;
      while (1)
      {
        while (1)
        {
          v5 = (uint64_t **)v21;
          v22 = *((_DWORD *)v21 + 7);
          if (v22 <= a3)
            break;
          v21 = (uint64_t *)*v21;
          v13 = v5;
          if (!*v5)
            goto LABEL_42;
        }
        if (v22 >= a3)
          return result;
        v21 = (uint64_t *)v21[1];
        if (!v21)
        {
LABEL_30:
          v13 = v5 + 1;
          goto LABEL_42;
        }
      }
    }
  }
  v9 = (uint64_t *)*a2;
  if ((uint64_t *)*result == a2)
  {
    v11 = a2;
  }
  else
  {
    if (v9)
    {
      v10 = (uint64_t *)*a2;
      do
      {
        v11 = v10;
        v10 = (uint64_t *)v10[1];
      }
      while (v10);
    }
    else
    {
      v15 = a2;
      do
      {
        v11 = (uint64_t *)v15[2];
        v16 = *v11 == (_QWORD)v15;
        v15 = v11;
      }
      while (v16);
    }
    if (*((_DWORD *)v11 + 7) >= a3)
    {
      v18 = *v7;
      v13 = (uint64_t **)(result + 1);
      v5 = (uint64_t **)(result + 1);
      if (!*v7)
        goto LABEL_42;
      while (1)
      {
        while (1)
        {
          v5 = (uint64_t **)v18;
          v19 = *((_DWORD *)v18 + 7);
          if (v19 <= a3)
            break;
          v18 = (uint64_t *)*v18;
          v13 = v5;
          if (!*v5)
            goto LABEL_42;
        }
        if (v19 >= a3)
          return result;
        v18 = (uint64_t *)v18[1];
        if (!v18)
          goto LABEL_30;
      }
    }
  }
  if (v9)
    v17 = (uint64_t **)v11;
  else
    v17 = (uint64_t **)a2;
  if (v9)
    v13 = (uint64_t **)(v11 + 1);
  else
    v13 = (uint64_t **)a2;
  if (!*v13)
  {
    v5 = v17;
LABEL_42:
    v23 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v23 + 28) = a4;
    *v23 = 0;
    v23[1] = 0;
    v23[2] = (uint64_t)v5;
    *v13 = v23;
    v24 = *(_QWORD *)*v6;
    if (v24)
    {
      *v6 = v24;
      v25 = *v13;
    }
    else
    {
      v25 = v23;
    }
    result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v6[1], v25);
    ++v6[2];
  }
  return result;
}

void std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

uint64_t *std::map<unsigned int,std::map<unsigned int,unsigned int>>::map[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  unsigned int v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  BOOL v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;

  qword_255323748 = 0;
  qword_255323740 = 0;
  qword_255323738 = (uint64_t)&qword_255323740;
  if (a2)
  {
    v2 = result;
    v3 = 0;
    v4 = &result[4 * a2];
    v5 = &qword_255323740;
    while (1)
    {
      v6 = *(_DWORD *)v2;
      if (v5 == &qword_255323740)
        break;
      v7 = (uint64_t *)v3;
      if (v3)
      {
        do
        {
          v8 = v7;
          v7 = (uint64_t *)v7[1];
        }
        while (v7);
      }
      else
      {
        v9 = &qword_255323740;
        do
        {
          v8 = (uint64_t *)v9[2];
          v10 = *v8 == (_QWORD)v9;
          v9 = v8;
        }
        while (v10);
      }
      if (*((_DWORD *)v8 + 8) < v6)
        goto LABEL_11;
      if (!v3)
        goto LABEL_22;
      v12 = v3;
      while (1)
      {
        while (1)
        {
          v8 = (uint64_t *)v12;
          v13 = *(_DWORD *)(v12 + 32);
          if (v13 <= v6)
            break;
          v12 = *v8;
          v11 = v8;
          if (!*v8)
            goto LABEL_23;
        }
        if (v13 >= v6)
          break;
        v12 = v8[1];
        if (!v12)
        {
          v11 = v8 + 1;
          goto LABEL_23;
        }
      }
LABEL_26:
      v2 += 4;
      if (v2 == v4)
        return result;
      v5 = (uint64_t *)qword_255323738;
      v3 = qword_255323740;
    }
    v8 = &qword_255323740;
LABEL_11:
    if (v3)
    {
      v11 = v8 + 1;
      if (v8[1])
        goto LABEL_26;
    }
    else
    {
LABEL_22:
      v11 = &qword_255323740;
      v8 = &qword_255323740;
    }
LABEL_23:
    v14 = (uint64_t)operator new(0x40uLL);
    *(_DWORD *)(v14 + 32) = v6;
    std::map<unsigned int,unsigned int>::map[abi:ne180100]((uint64_t *)(v14 + 40), v2 + 1);
    *(_QWORD *)v14 = 0;
    *(_QWORD *)(v14 + 8) = 0;
    *(_QWORD *)(v14 + 16) = v8;
    *v11 = v14;
    if (*(_QWORD *)qword_255323738)
    {
      qword_255323738 = *(_QWORD *)qword_255323738;
      v14 = *v11;
    }
    result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)qword_255323740, (uint64_t *)v14);
    ++qword_255323748;
    goto LABEL_26;
  }
  return result;
}

void sub_21CC9AB18(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::__tree<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>>>::destroy(v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>>>::destroy(a1[1]);
    std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy((_QWORD *)a1[6]);
    operator delete(a1);
  }
}

uint64_t *std::map<unsigned int,unsigned int>::map[abi:ne180100](uint64_t *a1, _QWORD *a2)
{
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;

  a1[1] = 0;
  v3 = a1 + 1;
  a1[2] = 0;
  *a1 = (uint64_t)(a1 + 1);
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int const,unsigned int> const&>(a1, v3, *((_DWORD *)v5 + 7), *(_QWORD *)((char *)v5 + 28));
      v6 = (_QWORD *)v5[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v5[2];
          v8 = *v7 == (_QWORD)v5;
          v5 = v7;
        }
        while (!v8);
      }
      v5 = v7;
    }
    while (v7 != v4);
  }
  return a1;
}

void sub_21CC9AC18(_Unwind_Exception *a1)
{
  _QWORD **v1;

  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>,std::__map_value_compare<SERestoreInfo::AMS_UOS_ID,std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>,std::less<SERestoreInfo::AMS_UOS_ID>,true>,std::allocator<std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>,std::__map_value_compare<SERestoreInfo::AMS_UOS_ID,std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>,std::less<SERestoreInfo::AMS_UOS_ID>,true>,std::allocator<std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>>>::destroy(*(_QWORD *)a1);
    std::__tree<std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>,std::__map_value_compare<SERestoreInfo::AMS_UOS_ID,std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>,std::less<SERestoreInfo::AMS_UOS_ID>,true>,std::allocator<std::__value_type<SERestoreInfo::AMS_UOS_ID,std::string>>>::destroy(*((_QWORD *)a1 + 1));
    if (a1[63] < 0)
      operator delete(*((void **)a1 + 5));
    operator delete(a1);
  }
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x22078A5F8](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x24BEDB350]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x22078A604](v13);
  return a1;
}

void sub_21CC9AD7C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  _QWORD *v12;

  MEMORY[0x22078A604](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x21CC9AD5CLL);
}

void sub_21CC9ADC4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_21CC9AEF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

void SERestoreInfo::UpdateTableEntry::~UpdateTableEntry(SERestoreInfo::UpdateTableEntry *this)
{
  void *v2;
  void **v3;

  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  v3 = (void **)this;
  std::vector<std::vector<unsigned short>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

uint64_t SERestoreInfo::ImageBinary::print(int *a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  size_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void **v14;
  uint64_t v15;
  _QWORD *v16;
  const std::locale::facet *v17;
  void *__p[2];
  unsigned __int8 v20;
  _QWORD v21[11];
  char v22;
  uint64_t v23;
  std::locale v24;

  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v21);
  v4 = *(char *)(a2 + 23);
  if (v4 >= 0)
    v5 = a2;
  else
    v5 = *(_QWORD *)a2;
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a2 + 23);
  else
    v6 = *(_QWORD *)(a2 + 8);
  v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, v5, v6);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"[", 1);
  v8 = (_QWORD *)std::ostream::operator<<();
  v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"] ", 2);
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"{", 1);
  v11 = strlen(off_24E0BFDA8[*a1]);
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)off_24E0BFDA8[*a1], v11);
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"}: ", 3);
  std::string::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(__p, *((char **)a1 + 2), (char *)(*((_QWORD *)a1 + 2) + *((_QWORD *)a1 + 3)), *((_QWORD *)a1 + 3));
  if ((v20 & 0x80u) == 0)
    v14 = __p;
  else
    v14 = (void **)__p[0];
  if ((v20 & 0x80u) == 0)
    v15 = v20;
  else
    v15 = (uint64_t)__p[1];
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)v14, v15);
  std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(_QWORD *)(*v16 - 24)));
  v17 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v20 < 0)
    operator delete(__p[0]);
  std::stringbuf::str();
  v21[0] = *MEMORY[0x24BEDB800];
  *(_QWORD *)((char *)v21 + *(_QWORD *)(v21[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
  v21[1] = MEMORY[0x24BEDB848] + 16;
  if (v22 < 0)
    operator delete((void *)v21[9]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x22078A778](&v23);
}

void sub_21CC9B1E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  std::ostringstream::~ostringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::updateMeasurement(SERestoreInfo::P73BaseDeliveryObject *this, CFDictionaryRef theDict, __CFError **a3)
{
  BOOL v6;
  CFTypeID v7;
  __CFDictionary *v8;
  CFMutableDictionaryRef Mutable;
  size_t *v10;
  size_t v11;
  char *v12;
  void *v13;
  CFDataRef v14;
  _BOOL4 isDev;
  __CFString **v16;
  int v17;
  char v18;
  void *exception;
  std::string *v21;
  __int128 v22;
  void *__p[2];
  char v24;
  void *v25[2];
  char v26;
  std::string value;
  __int128 v28;
  char *v29;

  if (!theDict || !a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&value, "Assertion: ");
    v21 = std::string::append(&value, "outError && outMeasurementDict");
    v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v29 = (char *)v21->__r_.__value_.__r.__words[2];
    v28 = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v28);
  }
  value.__r_.__value_.__r.__words[0] = 0;
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("SE,UpdatePayload"), (const void **)&value.__r_.__value_.__l.__data_))
  {
    v6 = value.__r_.__value_.__r.__words[0] == 0;
  }
  else
  {
    v6 = 1;
  }
  if (!v6)
  {
    v7 = CFGetTypeID(value.__r_.__value_.__l.__data_);
    if (v7 == CFDictionaryGetTypeID())
    {
      if (value.__r_.__value_.__r.__words[0])
        v8 = (__CFDictionary *)CFRetain(value.__r_.__value_.__l.__data_);
      else
        v8 = 0;
LABEL_12:
      v10 = (size_t *)ccsha256_di();
      v28 = 0uLL;
      v29 = 0;
      v11 = *v10;
      if (*v10)
      {
        if ((v11 & 0x8000000000000000) != 0)
          std::vector<std::string>::__throw_length_error[abi:ne180100]();
        v12 = (char *)operator new(*v10);
        bzero(v12, v11);
        *(_QWORD *)&v28 = v12;
        *((_QWORD *)&v28 + 1) = &v12[v11];
        v29 = &v12[v11];
      }
      ccdigest();
      v13 = (void *)v28;
      v14 = CFDataCreate(0, (const UInt8 *)v28, *((_QWORD *)&v28 + 1) - v28);
      if (v14)
      {
        isDev = SERestoreInfo::P73BaseDeliveryObject::isDev(*((SERestoreInfo::P73BaseDeliveryObject **)this + 8), *((_QWORD *)this + 9));
        v16 = kSETagMeasurementDevHash;
        if (!isDev)
          v16 = kSETagMeasurementProdHash;
        CFDictionarySetValue(v8, *v16, v14);
        v17 = 0;
        if (v13)
LABEL_19:
          operator delete(v13);
      }
      else
      {
        std::string::basic_string[abi:ne180100]<0>(__p, "Fail to allocate tmpData");
        *a3 = SERestoreInfo::CreateCFError((const UInt8 *)__p, 3, 0, CFSTR("SEUpdaterErrorDomain"));
        if (v24 < 0)
          operator delete(__p[0]);
        v17 = 6;
        if (v13)
          goto LABEL_19;
      }
      if (v17 == 6)
      {
        v18 = 0;
        if (!v8)
        {
LABEL_23:
          if (v14)
            CFRelease(v14);
          return v18 & 1;
        }
      }
      else
      {
        v18 = 1;
        if (!v8)
          goto LABEL_23;
      }
      CFRelease(v8);
      goto LABEL_23;
    }
  }
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (Mutable)
  {
    v8 = Mutable;
    CFDictionarySetValue(theDict, CFSTR("SE,UpdatePayload"), Mutable);
    goto LABEL_12;
  }
  std::string::basic_string[abi:ne180100]<0>(v25, "Fail to allocate imageProps");
  *a3 = SERestoreInfo::CreateCFError((const UInt8 *)v25, 3, 0, CFSTR("SEUpdaterErrorDomain"));
  if (v26 < 0)
    operator delete(v25[0]);
  v18 = 0;
  return v18 & 1;
}

void sub_21CC9B500(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL SERestoreInfo::P73BaseDeliveryObject::isDev(SERestoreInfo::P73BaseDeliveryObject *this, uint64_t a2)
{
  BOOL v5;
  BOOL v6;
  BOOL v8;
  BOOL v9;
  BOOL v11;
  BOOL v12;
  BOOL v14;
  BOOL v15;
  BOOL v17;
  BOOL v18;
  BOOL v20;
  BOOL v21;
  BOOL v23;
  BOOL v24;

  if (a2 - (_QWORD)this != 32)
    return 0;
  if (*(_QWORD *)this == 0x7B77E47DEC309FF8
    && *((_QWORD *)this + 1) == 0x8BF8D2A44AE3A97CLL
    && *((_QWORD *)this + 2) == 0xAD34DB13A59CC364
    && *((_QWORD *)this + 3) == 0xAC0A2E6B4C223984)
  {
    return 1;
  }
  v5 = *(_QWORD *)this == 0x74975A216330E276 && *((_QWORD *)this + 1) == 0x1F7F7DD3B6FB8D34;
  v6 = v5 && *((_QWORD *)this + 2) == 0x3FA240FAC488FFFLL;
  if (v6 && *((_QWORD *)this + 3) == 0x21EC7881080683DALL)
    return 1;
  v8 = *(_QWORD *)this == 0xD314CD88B2A173ABLL && *((_QWORD *)this + 1) == 0xD0014B39DB0B4552;
  v9 = v8 && *((_QWORD *)this + 2) == 0xC3B3802C47832D1BLL;
  if (v9 && *((_QWORD *)this + 3) == 0x102CA645D536B9F3)
    return 1;
  v11 = *(_QWORD *)this == 0x43028028D9EE140FLL && *((_QWORD *)this + 1) == 0x764EF91F0B455B82;
  v12 = v11 && *((_QWORD *)this + 2) == 0x74D2E6CF8CD1659BLL;
  if (v12 && *((_QWORD *)this + 3) == 0xBD4FC5BCF7FB4792)
    return 1;
  v14 = *(_QWORD *)this == 0x19016EC184635976 && *((_QWORD *)this + 1) == 0xD25BD62A9019D9A3;
  v15 = v14 && *((_QWORD *)this + 2) == 0xFD6855BA8DAED7D1;
  if (v15 && *((_QWORD *)this + 3) == 0x3E6F156DACCAB98)
    return 1;
  v17 = *(_QWORD *)this == 0x4B4B6EEF8151F8B0 && *((_QWORD *)this + 1) == 0x80D0BF7EE34277A5;
  v18 = v17 && *((_QWORD *)this + 2) == 0xA6421FFAFBC6C2D3;
  if (v18 && *((_QWORD *)this + 3) == 0x11CF79E52F051694)
    return 1;
  v20 = *(_QWORD *)this == 0x3B369AD4F6E8946ALL && *((_QWORD *)this + 1) == 0x3A6B9A9BB3089AACLL;
  v21 = v20 && *((_QWORD *)this + 2) == 0x8FA19016C1B6DB7CLL;
  if (v21 && *((_QWORD *)this + 3) == 0x40ACEFB5D4F4787)
    return 1;
  v23 = *(_QWORD *)this == 0xFC41962122793EF7 && *((_QWORD *)this + 1) == 0xB912209BBCCC0208;
  v24 = v23 && *((_QWORD *)this + 2) == 0xA845838AEC9D85B0;
  if (v24 && *((_QWORD *)this + 3) == 0x1DAD2E5A3D9AD8A8)
    return 1;
  return *(_QWORD *)this == 0xCBD1BDB61BAAD564
      && *((_QWORD *)this + 1) == 0x957F8100699D3DAALL
      && *((_QWORD *)this + 2) == 0xB07184D6337E1DBCLL
      && *((_QWORD *)this + 3) == 0x710CE2BFF2A6DF1CLL;
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::updateVersionDict(SERestoreInfo::P73BaseDeliveryObject *this, __CFDictionary *a2, __CFError **a3)
{
  CFStringRef v5;
  _BOOL4 isDev;
  __CFString **v7;
  void *exception;
  std::string *v10;
  __int128 v11;
  std::string v12;
  __int128 v13;
  std::string::size_type v14;

  if (!a2 || !a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v12, "Assertion: ");
    v10 = std::string::append(&v12, "outError && outDict");
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v14 = v10->__r_.__value_.__r.__words[2];
    v13 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v13);
  }
  v5 = CFStringCreateWithBytes(0, *((const UInt8 **)this + 12), *((_QWORD *)this + 13), 0x8000100u, 0);
  isDev = SERestoreInfo::P73BaseDeliveryObject::isDev(*((SERestoreInfo::P73BaseDeliveryObject **)this + 8), *((_QWORD *)this + 9));
  v7 = kSETagVersionDev;
  if (!isDev)
    v7 = kSETagVersionProd;
  CFDictionarySetValue(a2, *v7, v5);
  if (v5)
    CFRelease(v5);
  return 1;
}

void sub_21CC9BA0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

BOOL SERestoreInfo::P73BaseDeliveryObject::matchID(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(uint64_t **)a2;
  if (*(_QWORD *)(a2 + 8) - *(_QWORD *)a2 != 32)
    return 0;
  v3 = *(uint64_t **)(a1 + 64);
  v4 = *v3;
  v5 = v3[1];
  v6 = *v2;
  v7 = v2[1];
  v9 = v3[2];
  v8 = v3[3];
  v11 = v2[2];
  v10 = v2[3];
  return v4 == v6 && v5 == v7 && v9 == v11 && v8 == v10;
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::print(SERestoreInfo::P73BaseDeliveryObject *this)
{
  _QWORD *v2;
  std::string *v3;
  std::string::size_type size;
  _QWORD *v5;
  const std::locale::facet *v6;
  _QWORD *v7;
  std::string *v8;
  std::string::size_type v9;
  _QWORD *v10;
  const std::locale::facet *v11;
  _QWORD *v12;
  const std::locale::facet *v13;
  std::string *v14;
  std::string::size_type v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  const std::locale::facet *v19;
  std::string *v20;
  std::string::size_type v21;
  int v22;
  _QWORD *v23;
  std::string *v24;
  std::string::size_type v25;
  _QWORD *v26;
  _OWORD *v27;
  uint64_t v28;
  std::string *v29;
  int v30;
  std::string *v31;
  uint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  uint64_t v35;
  std::locale::__imp *locale;
  std::locale::__imp *v37;
  int v38;
  std::locale::__imp *v39;
  _QWORD *v40;
  const std::locale::facet *v41;
  uint64_t i;
  void **v43;
  uint64_t v44;
  std::locale::__imp *v45;
  std::locale::__imp *v46;
  uint64_t v47;
  void **v48;
  uint64_t v49;
  _QWORD *v50;
  const std::locale::facet *v51;
  _QWORD *v52;
  const std::locale::facet *v53;
  int *v54;
  std::string *v55;
  std::string::size_type v56;
  int *v57;
  int *v58;
  BOOL v59;
  SERestoreInfo::P73BaseDeliveryObject *v61;
  std::string::size_type v62;
  std::string::size_type v63;
  std::string::size_type v64;
  unsigned __int16 ***v65;
  _OWORD *v66;
  unsigned __int16 ***v67;
  void *v68[2];
  char v69;
  std::string v70;
  void *v71[2];
  unsigned __int8 v72;
  _QWORD v73[11];
  char v74;
  uint64_t v75;
  std::string v76;
  void *v77[2];
  unsigned __int8 v78;
  std::locale v79;
  uint64_t v80;
  void *v81;
  char v82;
  uint64_t v83;
  std::locale v84;
  std::locale::__imp *v85;
  uint64_t v86;
  std::string __p[3];
  void *v88;
  char v89;
  uint64_t v90;
  std::string v91;
  uint64_t v92[3];
  uint64_t v93[3];
  uint64_t v94[3];
  _QWORD v95[5];

  v95[3] = *MEMORY[0x24BDAC8D0];
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v73);
  v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v73, (uint64_t)"Details: ", 9);
  std::string::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(__p, *((char **)this + 12), (char *)(*((_QWORD *)this + 12) + *((_QWORD *)this + 13)), *((_QWORD *)this + 13));
  if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v3 = __p;
  else
    v3 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
  if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p[0].__r_.__value_.__r.__words[2]);
  else
    size = __p[0].__r_.__value_.__l.__size_;
  v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)v3, size);
  std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(_QWORD *)(*v5 - 24)));
  v6 = std::locale::use_facet(&v79, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
  std::locale::~locale(&v79);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p[0].__r_.__value_.__l.__data_);
  v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v73, (uint64_t)"FactoryPostflight revision: ", 28);
  std::to_string(__p, *((unsigned __int8 *)this + 152));
  if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v8 = __p;
  else
    v8 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
  if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v9 = HIBYTE(__p[0].__r_.__value_.__r.__words[2]);
  else
    v9 = __p[0].__r_.__value_.__l.__size_;
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)v8, v9);
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(_QWORD *)(*v10 - 24)));
  v11 = std::locale::use_facet(&v79, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v79);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p[0].__r_.__value_.__l.__data_);
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v73, (uint64_t)"UpdateTable: ", 13);
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  v13 = std::locale::use_facet((const std::locale *)__p, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale((std::locale *)__p);
  std::ostream::put();
  std::ostream::flush();
  std::string::basic_string[abi:ne180100]<0>(&v70, "\t");
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v79);
  if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = &v70;
  else
    v14 = (std::string *)v70.__r_.__value_.__r.__words[0];
  if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = HIBYTE(v70.__r_.__value_.__r.__words[2]);
  else
    v15 = v70.__r_.__value_.__l.__size_;
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v79, (uint64_t)v14, v15);
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"BSN: ", 5);
  *(_DWORD *)((char *)v17 + *(_QWORD *)(*v17 - 24) + 8) = *(_DWORD *)((_BYTE *)v17 + *(_QWORD *)(*v17 - 24) + 8) & 0xFFFFFFB5 | 8;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"0x", 2);
  v18 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v18 + *(_QWORD *)(*v18 - 24)));
  v19 = std::locale::use_facet((const std::locale *)__p, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v19->__vftable[2].~facet_0)(v19, 10);
  std::locale::~locale((std::locale *)__p);
  std::ostream::put();
  std::ostream::flush();
  v61 = this;
  v67 = (unsigned __int16 ***)*((_QWORD *)this + 16);
  v65 = (unsigned __int16 ***)*((_QWORD *)this + 17);
  if (v67 != v65)
  {
    v63 = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
    v64 = *MEMORY[0x24BEDB800];
    v62 = MEMORY[0x24BEDB848] + 16;
    do
    {
      if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v76, v70.__r_.__value_.__l.__data_, v70.__r_.__value_.__l.__size_);
      else
        v76 = v70;
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)__p);
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v20 = &v76;
      else
        v20 = (std::string *)v76.__r_.__value_.__r.__words[0];
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v21 = HIBYTE(v76.__r_.__value_.__r.__words[2]);
      else
        v21 = v76.__r_.__value_.__l.__size_;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(__p, (uint64_t)v20, v21);
      if (v67[1] == *v67)
        std::vector<std::vector<unsigned short>>::__throw_out_of_range[abi:ne180100]();
      v22 = ***v67;
      v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(__p, (uint64_t)"|", 1);
      SERestoreInfo::P73BaseDeviceInfo::getStateName(v22, &v91);
      if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v24 = &v91;
      else
        v24 = (std::string *)v91.__r_.__value_.__r.__words[0];
      if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v25 = HIBYTE(v91.__r_.__value_.__r.__words[2]);
      else
        v25 = v91.__r_.__value_.__l.__size_;
      v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)v24, v25);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"| ", 2);
      if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v91.__r_.__value_.__l.__data_);
      v27 = operator new(0x10uLL);
      *v27 = xmmword_21CCD80D0;
      std::string::basic_string[abi:ne180100]<0>(&v91, "AMS");
      std::string::basic_string[abi:ne180100]<0>(v92, "RSN");
      std::string::basic_string[abi:ne180100]<0>(v93, "CSN");
      std::string::basic_string[abi:ne180100]<0>(v94, "FSN");
      std::string::basic_string[abi:ne180100]<0>(v95, "ACTION");
      v28 = 0;
      v66 = v27;
      do
      {
        v29 = &v91 + *((int *)v27 + v28);
        v30 = SHIBYTE(v29->__r_.__value_.__r.__words[2]);
        if (v30 >= 0)
          v31 = &v91 + *((int *)v27 + v28);
        else
          v31 = (std::string *)v29->__r_.__value_.__r.__words[0];
        if (v30 >= 0)
          v32 = HIBYTE(v29->__r_.__value_.__r.__words[2]);
        else
          v32 = v29->__r_.__value_.__l.__size_;
        v33 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(__p, (uint64_t)v31, v32);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)" { ", 3);
        v34 = *((int *)v27 + v28);
        if (0xAAAAAAAAAAAAAAABLL * (v67[1] - *v67) <= v34)
          std::vector<std::vector<unsigned short>>::__throw_out_of_range[abi:ne180100]();
        v35 = (uint64_t)&(*v67)[3 * (int)v34];
        v85 = 0;
        v84.__locale_ = 0;
        v86 = 0;
        std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&v84, *(const void **)v35, *(_QWORD *)(v35 + 8), (uint64_t)(*(_QWORD *)(v35 + 8) - *(_QWORD *)v35) >> 1);
        locale = v84.__locale_;
        v37 = v85;
        if (v84.__locale_ != v85)
        {
          v38 = 0;
          v39 = v84.__locale_;
          do
          {
            if (v38)
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(__p, (uint64_t)",", 1);
            *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1]
                      + *(_QWORD *)(__p[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1]
                                                                                           + *(_QWORD *)(__p[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(__p, (uint64_t)"0x", 2);
            v40 = (_QWORD *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)" ", 1);
            v39 = (std::locale::__imp *)((char *)v39 + 2);
            --v38;
          }
          while (v39 != v37);
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(__p, (uint64_t)"} ", 2);
        v27 = v66;
        if (locale)
          operator delete(locale);
        ++v28;
      }
      while (v28 != 4);
      std::ios_base::getloc((const std::ios_base *)((char *)__p + *(_QWORD *)(__p[0].__r_.__value_.__r.__words[0] - 24)));
      v41 = std::locale::use_facet(&v84, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v41->__vftable[2].~facet_0)(v41, 10);
      std::locale::~locale(&v84);
      std::ostream::put();
      std::ostream::flush();
      std::stringbuf::str();
      for (i = 0; i != -15; i -= 3)
      {
        if (SHIBYTE(v95[i + 2]) < 0)
          operator delete((void *)v95[i]);
      }
      operator delete(v66);
      __p[0].__r_.__value_.__r.__words[0] = v64;
      *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + *(_QWORD *)(v64 - 24)) = v63;
      __p[0].__r_.__value_.__l.__size_ = v62;
      if (v89 < 0)
        operator delete(v88);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x22078A778](&v90);
      if ((v78 & 0x80u) == 0)
        v43 = v77;
      else
        v43 = (void **)v77[0];
      if ((v78 & 0x80u) == 0)
        v44 = v78;
      else
        v44 = (uint64_t)v77[1];
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v79, (uint64_t)v43, v44);
      if ((char)v78 < 0)
        operator delete(v77[0]);
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v76.__r_.__value_.__l.__data_);
      v67 += 6;
    }
    while (v67 != v65);
  }
  std::stringbuf::str();
  v45 = (std::locale::__imp *)*MEMORY[0x24BEDB800];
  v79.__locale_ = v45;
  v46 = *(std::locale::__imp **)(MEMORY[0x24BEDB800] + 24);
  *(std::locale::__imp **)((char *)&v79.__locale_ + *((_QWORD *)v45 - 3)) = v46;
  v47 = MEMORY[0x24BEDB848];
  v80 = MEMORY[0x24BEDB848] + 16;
  if (v82 < 0)
    operator delete(v81);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x22078A778](&v83);
  if ((v72 & 0x80u) == 0)
    v48 = v71;
  else
    v48 = (void **)v71[0];
  if ((v72 & 0x80u) == 0)
    v49 = v72;
  else
    v49 = (uint64_t)v71[1];
  v50 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)v48, v49);
  std::ios_base::getloc((const std::ios_base *)((char *)v50 + *(_QWORD *)(*v50 - 24)));
  v51 = std::locale::use_facet((const std::locale *)__p, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v51->__vftable[2].~facet_0)(v51, 10);
  std::locale::~locale((std::locale *)__p);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v72 < 0)
    operator delete(v71[0]);
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v70.__r_.__value_.__l.__data_);
  v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v73, (uint64_t)"Binaries: ", 10);
  std::ios_base::getloc((const std::ios_base *)((char *)v52 + *(_QWORD *)(*v52 - 24)));
  v53 = std::locale::use_facet((const std::locale *)__p, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v53->__vftable[2].~facet_0)(v53, 10);
  std::locale::~locale((std::locale *)__p);
  std::ostream::put();
  std::ostream::flush();
  v54 = (int *)*((_QWORD *)v61 + 1);
  if (v54 != (int *)((char *)v61 + 16))
  {
    do
    {
      std::string::basic_string[abi:ne180100]<0>(v68, "\t");
      SERestoreInfo::ImageBinary::print(v54 + 10, (uint64_t)v68);
      if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v55 = __p;
      else
        v55 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
      if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v56 = HIBYTE(__p[0].__r_.__value_.__r.__words[2]);
      else
        v56 = __p[0].__r_.__value_.__l.__size_;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v73, (uint64_t)v55, v56);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p[0].__r_.__value_.__l.__data_);
      if (v69 < 0)
        operator delete(v68[0]);
      v57 = (int *)*((_QWORD *)v54 + 1);
      if (v57)
      {
        do
        {
          v58 = v57;
          v57 = *(int **)v57;
        }
        while (v57);
      }
      else
      {
        do
        {
          v58 = (int *)*((_QWORD *)v54 + 2);
          v59 = *(_QWORD *)v58 == (_QWORD)v54;
          v54 = v58;
        }
        while (!v59);
      }
      v54 = v58;
    }
    while (v58 != (int *)((char *)v61 + 16));
  }
  std::stringbuf::str();
  v73[0] = v45;
  *(_QWORD *)((char *)v73 + *((_QWORD *)v45 - 3)) = v46;
  v73[1] = v47 + 16;
  if (v74 < 0)
    operator delete((void *)v73[9]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x22078A778](&v75);
}

void sub_21CC9C4D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,uint64_t a36,char a37)
{
  if (a33 < 0)
    operator delete(__p);
  std::ostringstream::~ostringstream((uint64_t)&a37);
  _Unwind_Resume(a1);
}

BOOL SERestoreInfo::P73BaseDeliveryObject::isFpAvailable(SERestoreInfo::P73BaseDeliveryObject *this)
{
  char *v1;
  char *v2;
  int v3;
  _BOOL8 result;
  char *v5;
  char *v6;
  BOOL v7;

  v1 = (char *)*((_QWORD *)this + 1);
  v2 = (char *)this + 16;
  if (v1 == (char *)this + 16)
    return 0;
  do
  {
    v3 = *((_DWORD *)v1 + 10);
    result = v3 == 3;
    if (v3 == 3)
      break;
    v5 = (char *)*((_QWORD *)v1 + 1);
    if (v5)
    {
      do
      {
        v6 = v5;
        v5 = *(char **)v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        v6 = (char *)*((_QWORD *)v1 + 2);
        v7 = *(_QWORD *)v6 == (_QWORD)v1;
        v1 = v6;
      }
      while (!v7);
    }
    v1 = v6;
  }
  while (v6 != v2);
  return result;
}

unsigned __int16 ***SERestoreInfo::P73BaseDeliveryObject::findEntry(uint64_t a1, _DWORD *a2)
{
  unsigned __int16 ***v3;
  unsigned __int16 ***v4;
  unsigned __int16 ***v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  _BOOL4 v14;
  unsigned int v15;
  unsigned int v16;
  unsigned __int16 **v17;
  uint64_t v18;
  unint64_t v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  unsigned __int16 *v23;

  v3 = *(unsigned __int16 ****)(a1 + 8);
  v4 = *(unsigned __int16 ****)(a1 + 16);
  if (v3 == v4)
    return 0;
  v5 = 0;
  v6 = a2[7];
  v8 = a2[3];
  v7 = a2[4];
  v9 = (unsigned __int16)v7;
  v10 = (unsigned __int16)v8;
  v11 = a2[5];
  v14 = v6 != 23195 || v7 != v8 || v8 != v11;
  v15 = HIWORD(v7);
  v16 = HIWORD(v8);
  while (1)
  {
    v17 = *v3;
    v18 = (char *)v3[1] - (char *)*v3;
    if (!v18)
LABEL_41:
      std::vector<std::vector<unsigned short>>::__throw_out_of_range[abi:ne180100]();
    if (v6 == **v17)
    {
      v19 = 0xAAAAAAAAAAAAAAABLL * (v18 >> 3);
      if (v19 <= 1)
        goto LABEL_41;
      v20 = v17[4];
      if (v15)
      {
LABEL_19:
        v21 = v17[4];
      }
      else
      {
        v21 = v17[3];
        if (v21 != v20)
        {
          while (*v21 != v9)
          {
            if (++v21 == v20)
              goto LABEL_19;
          }
        }
      }
      if (v21 != v20)
      {
        if (v19 <= 2)
          goto LABEL_41;
        v22 = v17[7];
        if (v16)
        {
LABEL_26:
          v23 = v17[7];
        }
        else
        {
          v23 = v17[6];
          if (v23 != v22)
          {
            while (*v23 != v10)
            {
              if (++v23 == v22)
                goto LABEL_26;
            }
          }
        }
        if (v23 != v22)
          break;
      }
    }
LABEL_37:
    v3 += 6;
    if (v3 == v4)
      return v5;
  }
  if (!v14)
  {
    if (!v5)
      goto LABEL_36;
    if (0xAAAAAAAAAAAAAAABLL * (v5[1] - *v5) <= 3)
      std::vector<std::vector<unsigned short>>::__throw_out_of_range[abi:ne180100]();
    if (v19 <= 3)
      goto LABEL_41;
    if (*(*v5)[9] < *v17[9])
LABEL_36:
      v5 = v3;
    goto LABEL_37;
  }
  if (v19 <= 3)
    goto LABEL_41;
  if (v11 != *v17[9])
    goto LABEL_37;
  return v3;
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::findNextAction(uint64_t a1, _DWORD **a2)
{
  unsigned __int16 ***Entry;
  void *exception;
  void *v5;
  __int128 v6;

  Entry = SERestoreInfo::P73BaseDeliveryObject::findEntry(a1 + 120, *a2);
  if (!Entry)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v6, "No update table entry match found.");
    v5 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, &v6, 32, CFSTR("SEUpdaterErrorDomain"));
  }
  if (0xAAAAAAAAAAAAAAABLL * (Entry[1] - *Entry) <= 4)
    std::vector<std::vector<unsigned short>>::__throw_out_of_range[abi:ne180100]();
  return *(*Entry)[12];
}

void sub_21CC9CA24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::findFactoryPostflightAction(SERestoreInfo::P73BaseDeliveryObject *this)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t NextAction;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  _DWORD *v13[2];
  uint64_t v14;
  std::__shared_weak_count *v15;

  _ZNSt3__115allocate_sharedB8ne180100IN13SERestoreInfo17P73BaseDeviceInfoENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v14);
  v2 = v14;
  *(_DWORD *)(v14 + 20) = 0xFFFF;
  *(_QWORD *)(v2 + 12) = 0xFFFF0000FFFFLL;
  *(_DWORD *)(v2 + 28) = 23195;
  v3 = v15;
  v13[0] = (_DWORD *)v2;
  v13[1] = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  NextAction = SERestoreInfo::P73BaseDeliveryObject::findNextAction((uint64_t)this, v13);
  if (v3)
  {
    v7 = (unint64_t *)&v3->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  v9 = v15;
  if (v15)
  {
    v10 = (unint64_t *)&v15->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return NextAction;
}

void sub_21CC9CB3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::P73BaseFirmware::getDeliveryObject(SERestoreInfo::SEFirmwareBase *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  int v6;
  uint64_t v7;
  unsigned int v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  int v12;
  _QWORD *size;
  unint64_t *v14;
  unint64_t v15;
  std::string::size_type v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  int64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::string::size_type v26;
  __int128 v27;
  std::string::size_type v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t *v33;
  std::string::size_type v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  void *exception;
  std::string *v40;
  __int128 v41;
  std::__shared_weak_count *v42;
  __int128 v43;
  std::string v44;
  void *__p[2];
  std::string::size_type v46;

  if (!*((_QWORD *)a1 + 1))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v44, "Assertion: ");
    v40 = std::string::append(&v44, "fSource");
    v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
    v46 = v40->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v41;
    v40->__r_.__value_.__l.__size_ = 0;
    v40->__r_.__value_.__r.__words[2] = 0;
    v40->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, __p);
  }
  (*(void (**)(void **__return_ptr))(**(_QWORD **)a2 + 16))(__p);
  v6 = *(_DWORD *)(*(_QWORD *)a2 + 176);
  memset(&v44, 0, sizeof(v44));
  v7 = (*((_QWORD *)a1 + 3) - *((_QWORD *)a1 + 2)) >> 5;
  if ((_DWORD)v7)
  {
    v8 = 0;
    do
    {
      SERestoreInfo::SEFirmwareBase::get(a1, v8);
      v42 = (std::__shared_weak_count *)*((_QWORD *)&v43 + 1);
      v9 = (std::__shared_weak_count *)*((_QWORD *)&v43 + 1);
      if (*((_QWORD *)&v43 + 1))
      {
        v10 = (unint64_t *)(*((_QWORD *)&v43 + 1) + 8);
        do
          v11 = __ldxr(v10);
        while (__stxr(v11 + 1, v10));
      }
      if ((*(unsigned int (**)(_QWORD, void **))(*(_QWORD *)v43 + 32))(v43, __p))
      {
        v12 = *(_DWORD *)(v43 + 160);
        if (!v12 || v12 == v6)
        {
          size = (_QWORD *)v44.__r_.__value_.__l.__size_;
          if (v44.__r_.__value_.__l.__size_ >= v44.__r_.__value_.__r.__words[2])
          {
            v17 = (_QWORD *)v44.__r_.__value_.__r.__words[0];
            v18 = (uint64_t)(v44.__r_.__value_.__l.__size_ - v44.__r_.__value_.__r.__words[0]) >> 4;
            v19 = v18 + 1;
            if ((unint64_t)(v18 + 1) >> 60)
              std::vector<unsigned short>::__throw_length_error[abi:ne180100]();
            v20 = v44.__r_.__value_.__r.__words[2] - v44.__r_.__value_.__r.__words[0];
            if ((uint64_t)(v44.__r_.__value_.__r.__words[2] - v44.__r_.__value_.__r.__words[0]) >> 3 > v19)
              v19 = v20 >> 3;
            if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF0)
              v21 = 0xFFFFFFFFFFFFFFFLL;
            else
              v21 = v19;
            if (v21 >> 60)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v22 = (char *)operator new(16 * v21);
            v23 = &v22[16 * v18];
            *(_OWORD *)v23 = v43;
            if (v9)
            {
              p_shared_owners = (unint64_t *)&v9->__shared_owners_;
              do
                v25 = __ldxr(p_shared_owners);
              while (__stxr(v25 + 1, p_shared_owners));
              size = (_QWORD *)v44.__r_.__value_.__l.__size_;
            }
            if (size == v17)
            {
              v16 = (std::string::size_type)(v23 + 16);
              v44.__r_.__value_.__r.__words[0] = (std::string::size_type)&v22[16 * v18];
              v44.__r_.__value_.__l.__size_ = (std::string::size_type)(v23 + 16);
              v44.__r_.__value_.__r.__words[2] = (std::string::size_type)&v22[16 * v21];
            }
            else
            {
              v26 = (std::string::size_type)&v22[16 * v18];
              do
              {
                v27 = *((_OWORD *)size - 1);
                size -= 2;
                *(_OWORD *)(v26 - 16) = v27;
                v26 -= 16;
                *size = 0;
                size[1] = 0;
              }
              while (size != v17);
              v28 = v44.__r_.__value_.__l.__size_;
              v17 = (_QWORD *)v44.__r_.__value_.__r.__words[0];
              v16 = (std::string::size_type)(v23 + 16);
              v44.__r_.__value_.__r.__words[0] = v26;
              v44.__r_.__value_.__l.__size_ = (std::string::size_type)(v23 + 16);
              v44.__r_.__value_.__r.__words[2] = (std::string::size_type)&v22[16 * v21];
              while ((_QWORD *)v28 != v17)
              {
                v28 -= 16;
                std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v28);
              }
            }
            if (v17)
              operator delete(v17);
          }
          else
          {
            *(_QWORD *)v44.__r_.__value_.__l.__size_ = v43;
            size[1] = v9;
            if (v9)
            {
              v14 = (unint64_t *)&v9->__shared_owners_;
              do
                v15 = __ldxr(v14);
              while (__stxr(v15 + 1, v14));
            }
            v16 = (std::string::size_type)(size + 2);
          }
          v44.__r_.__value_.__l.__size_ = v16;
          v9 = v42;
        }
      }
      if (v9)
      {
        v29 = (unint64_t *)&v9->__shared_owners_;
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      if (*((_QWORD *)&v43 + 1))
      {
        v31 = (unint64_t *)(*((_QWORD *)&v43 + 1) + 8);
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          (*(void (**)(_QWORD))(**((_QWORD **)&v43 + 1) + 16))(*((_QWORD *)&v43 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v43 + 1));
        }
      }
      ++v8;
    }
    while (v8 != (_DWORD)v7);
    v34 = v44.__r_.__value_.__l.__size_;
    v33 = (uint64_t *)v44.__r_.__value_.__r.__words[0];
  }
  else
  {
    v33 = 0;
    v34 = 0;
  }
  if (v34 - (_QWORD)v33 == 16)
  {
    v36 = *v33;
    v35 = v33[1];
    *a3 = v36;
    a3[1] = v35;
    if (v35)
    {
      v37 = (unint64_t *)(v35 + 8);
      do
        v38 = __ldxr(v37);
      while (__stxr(v38 + 1, v37));
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  *(_QWORD *)&v43 = &v44;
  std::vector<std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v43);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_21CC9CEB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void **a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  a11 = &a16;
  std::vector<std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>::__destroy_vector::operator()[abi:ne180100](&a11);
  if (__p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void SERestoreInfo::P73BaseFirmware::updateMeasurementDict(SERestoreInfo::SEFirmwareBase *this, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t **v7;
  _OWORD *v8;
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  uint64_t *v26;
  uint64_t **v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t *v35;
  unsigned __int8 *v36;
  unsigned int v37;
  unsigned int v38;
  BOOL v39;
  uint64_t **v40;
  uint64_t *v41;
  uint64_t **v42;
  uint64_t v43;
  uint64_t *v44;
  char **v45;
  char **v46;
  const void *v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  uint64_t **v57;
  uint64_t *v58;
  uint64_t **v59;
  unsigned int **v60;
  SERestoreInfo::SEException *v61;
  SERestoreInfo::SEException *v62;
  void *exception;
  void *v64;
  __int128 v65;
  __int128 v66;
  uint64_t **v67;
  uint64_t *v68;
  uint64_t v69;
  int v70[2];
  __int128 __p;
  char v72;
  uint64_t v73;

  *(_QWORD *)v70 = 0;
  if (*a3)
  {
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)*a3 + 16))(&__p);
    v6 = (_QWORD *)operator new();
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v6, (const void *)__p, *((uint64_t *)&__p + 1), *((_QWORD *)&__p + 1) - __p);
    v67 = 0;
    v7 = *(uint64_t ***)v70;
    *(_QWORD *)v70 = v6;
    if (v7)
    {
      std::default_delete<std::vector<unsigned char>>::operator()[abi:ne180100]((uint64_t)v70, (uint64_t)v7);
      v67 = 0;
    }
    if ((_QWORD)__p)
    {
      *((_QWORD *)&__p + 1) = __p;
      operator delete((void *)__p);
    }
    if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)*a3 + 32))(*a3) == 54)
    {
      v8 = operator new(0x20uLL);
      *v8 = xmmword_21CCD8128;
      v8[1] = unk_21CCD8138;
      v9 = operator new(0x20uLL);
      *(_OWORD *)v9 = xmmword_21CCD8148;
      *((_OWORD *)v9 + 1) = unk_21CCD8158;
      v10 = **(uint64_t ***)v70;
      if (*(_QWORD *)(*(_QWORD *)v70 + 8) - **(_QWORD **)v70 == 32)
      {
        v11 = *v10;
        v12 = v10[1];
        v14 = v10[2];
        v13 = v10[3];
        v15 = v11 == *(_QWORD *)v8 && v12 == *((_QWORD *)v8 + 1);
        v18 = v15 && v14 == *((_QWORD *)v8 + 2) && v13 == *((_QWORD *)v8 + 3);
      }
      else
      {
        v18 = 0;
      }
      if (SERestoreInfo::SERestoreInfoLog::get(void)::onceToken != -1)
        dispatch_once(&SERestoreInfo::SERestoreInfoLog::get(void)::onceToken, &__block_literal_global_0);
      SERestoreInfo::SERestoreInfoLog::printLog((SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::instance, 2, "updateMeasurementDict", "KeyID 0x%X, overwriting with dev %d", bswap32(***(_DWORD ***)v70), v18);
      if (v18)
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(*(_QWORD **)v70, (char *)v9, (char *)v9 + 32, 0x20uLL);
      operator delete(v9);
      operator delete(v8);
    }
  }
  v68 = 0;
  v69 = 0;
  v67 = &v68;
  v19 = (*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 5;
  if (!(_DWORD)v19)
  {
LABEL_94:
    exception = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&__p, "No matching delivery object found.");
    v64 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, &__p, 24, CFSTR("SEUpdaterErrorDomain"));
  }
  v20 = 0;
  do
  {
    SERestoreInfo::SEFirmwareBase::get(this, v20);
    v21 = v66;
    v65 = v66;
    if (*((_QWORD *)&v66 + 1))
    {
      v22 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }
    if (*(_QWORD *)v70)
    {
      v25 = *(unsigned __int8 **)(v21 + 64);
      v24 = *(unsigned __int8 **)(v21 + 72);
      if (v24 - v25 != *(_QWORD *)(*(_QWORD *)v70 + 8) - **(_QWORD **)v70
        || memcmp(*(const void **)(v21 + 64), **(const void ***)v70, v24 - v25))
      {
        goto LABEL_70;
      }
    }
    else
    {
      v25 = *(unsigned __int8 **)(v21 + 64);
      v24 = *(unsigned __int8 **)(v21 + 72);
    }
    v26 = v68;
    if (v68)
    {
      v27 = &v68;
      do
      {
        if (v25 == v24)
        {
LABEL_47:
          v27 = (uint64_t **)v26;
        }
        else
        {
          v28 = (unsigned __int8 *)v26[4];
          v29 = v25 + 1;
          while (v28 != (unsigned __int8 *)v26[5])
          {
            v30 = *v28;
            v31 = *(v29 - 1);
            if (v30 < v31)
              break;
            ++v28;
            if (v31 < v30 || v29++ == v24)
              goto LABEL_47;
          }
          ++v26;
        }
        v26 = (uint64_t *)*v26;
      }
      while (v26);
      if (&v68 != v27)
      {
        v34 = v27[4];
        v33 = v27[5];
        if (v34 == v33)
        {
LABEL_60:
          if (*(_DWORD *)(v21 + 160) > *((_DWORD *)v27[7] + 40))
          {
            v40 = (uint64_t **)std::__tree<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::__map_value_compare<std::vector<unsigned char>,std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::less<std::vector<unsigned char>>,true>,std::allocator<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>>>::__find_equal<std::vector<unsigned char>>((uint64_t)&v67, &v73, v25, v24);
            v41 = *v40;
            if (!*v40)
            {
              v42 = v40;
              v41 = (uint64_t *)operator new(0x48uLL);
              *(_QWORD *)&__p = v41;
              *((_QWORD *)&__p + 1) = &v68;
              v72 = 0;
              v41[5] = 0;
              v41[6] = 0;
              v41[4] = 0;
              std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v41 + 4, *(const void **)(v21 + 64), *(_QWORD *)(v21 + 72), *(_QWORD *)(v21 + 72) - *(_QWORD *)(v21 + 64));
              v41[7] = 0;
              v41[8] = 0;
              v72 = 1;
              v43 = v73;
              *v41 = 0;
              v41[1] = 0;
              v41[2] = v43;
              *v42 = v41;
              v44 = v41;
              if (*v67)
              {
                v67 = (uint64_t **)*v67;
                v44 = *v42;
              }
              std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v68, v44);
              ++v69;
              *(_QWORD *)&__p = 0;
              std::unique_ptr<std::__tree_node<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,void *>>>>::reset[abi:ne180100]((uint64_t)&__p);
            }
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)(v41 + 7), &v65);
          }
          goto LABEL_70;
        }
        v35 = (uint64_t *)((char *)v34 + 1);
        v36 = v25;
        while (v36 != v24)
        {
          v37 = *v36;
          v38 = *((unsigned __int8 *)v35 - 1);
          if (v37 < v38)
            break;
          ++v36;
          v39 = v38 < v37 || v35 == v33;
          v35 = (uint64_t *)((char *)v35 + 1);
          if (v39)
            goto LABEL_60;
        }
      }
    }
    v45 = (char **)std::__tree<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::__map_value_compare<std::vector<unsigned char>,std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::less<std::vector<unsigned char>>,true>,std::allocator<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>>>::__find_equal<std::vector<unsigned char>>((uint64_t)&v67, &v73, v25, v24);
    if (!*v45)
    {
      v46 = v45;
      v47 = *(const void **)(v21 + 64);
      v48 = *(_QWORD *)(v21 + 72);
      v49 = (char *)operator new(0x48uLL);
      *(_QWORD *)&__p = v49;
      *((_QWORD *)&__p + 1) = &v68;
      v72 = 0;
      *((_QWORD *)v49 + 5) = 0;
      *((_QWORD *)v49 + 6) = 0;
      *((_QWORD *)v49 + 4) = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)v49 + 4, v47, v48, v48 - (_QWORD)v47);
      *(_OWORD *)(v49 + 56) = v65;
      v65 = 0uLL;
      v72 = 1;
      v50 = v73;
      *(_QWORD *)v49 = 0;
      *((_QWORD *)v49 + 1) = 0;
      *((_QWORD *)v49 + 2) = v50;
      *v46 = v49;
      if (*v67)
      {
        v67 = (uint64_t **)*v67;
        v49 = *v46;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v68, (uint64_t *)v49);
      ++v69;
      *(_QWORD *)&__p = 0;
      std::unique_ptr<std::__tree_node<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,void *>>>>::reset[abi:ne180100]((uint64_t)&__p);
    }
LABEL_70:
    v51 = (std::__shared_weak_count *)*((_QWORD *)&v65 + 1);
    if (*((_QWORD *)&v65 + 1))
    {
      v52 = (unint64_t *)(*((_QWORD *)&v65 + 1) + 8);
      do
        v53 = __ldaxr(v52);
      while (__stlxr(v53 - 1, v52));
      if (!v53)
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
      }
    }
    v54 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
    if (*((_QWORD *)&v66 + 1))
    {
      v55 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
      do
        v56 = __ldaxr(v55);
      while (__stlxr(v56 - 1, v55));
      if (!v56)
      {
        ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
        std::__shared_weak_count::__release_weak(v54);
      }
    }
    ++v20;
  }
  while (v20 != (_DWORD)v19);
  if (!v69)
    goto LABEL_94;
  v57 = v67;
  if (v67 != &v68)
  {
    do
    {
      *(_QWORD *)&__p = 0;
      (*(void (**)(uint64_t *, uint64_t, __int128 *))(*v57[7] + 16))(v57[7], a2, &__p);
      if ((_QWORD)__p)
      {
        v61 = (SERestoreInfo::SEException *)__cxa_allocate_exception(0x48uLL);
        v62 = SERestoreInfo::SEException::SEException(v61, (CFErrorRef)__p);
      }
      v58 = v57[1];
      if (v58)
      {
        do
        {
          v59 = (uint64_t **)v58;
          v58 = (uint64_t *)*v58;
        }
        while (v58);
      }
      else
      {
        do
        {
          v59 = (uint64_t **)v57[2];
          v15 = *v59 == (uint64_t *)v57;
          v57 = v59;
        }
        while (!v15);
      }
      v57 = v59;
    }
    while (v59 != &v68);
  }
  std::__tree<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::__map_value_compare<std::vector<unsigned char>,std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::less<std::vector<unsigned char>>,true>,std::allocator<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>>>::destroy(v68);
  v60 = *(unsigned int ***)v70;
  *(_QWORD *)v70 = 0;
  if (v60)
    std::default_delete<std::vector<unsigned char>>::operator()[abi:ne180100]((uint64_t)v70, (uint64_t)v60);
}

void sub_21CC9D564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  void *v24;
  uint64_t v26;

  operator delete(v24);
  v26 = a18;
  a18 = 0;
  if (v26)
    std::default_delete<std::vector<unsigned char>>::operator()[abi:ne180100]((uint64_t)&a18, v26);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::P73BaseFirmware::makeDeliveryObject@<X0>(DERItem *a1@<X1>, _QWORD *a2@<X8>)
{
  BOOL v3;
  unsigned int v4;
  char *v5;
  std::string::size_type v6;
  _BYTE *v7;
  char v8;
  uint64_t v9;
  char v10;
  char v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  char *v19;
  BOOL v20;
  int v21;
  int v22;
  BOOL v23;
  char *v24;
  unint64_t v25;
  char *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  __int16 v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  unsigned __int8 *v44;
  _WORD *v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  int64x2_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int64x2_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  uint64_t v75;
  int64x2_t v76;
  char *v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  char *v82;
  char *v83;
  int64x2_t v84;
  uint64_t v85;
  uint64_t v86;
  char *v87;
  __int128 v88;
  int64x2_t v89;
  char *v90;
  int v91;
  _QWORD *v92;
  int v93;
  int64x2_t v94;
  unint64_t v95;
  _QWORD *v96;
  uint64_t *v97;
  _QWORD *v98;
  unsigned int v99;
  unsigned int v100;
  uint64_t v101;
  uint64_t result;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  void *v109;
  std::string *v110;
  std::string *v111;
  __int128 v112;
  void *v113;
  std::string *v114;
  __int128 v115;
  void *v116;
  void *v117;
  void *exception;
  std::string *v119;
  __int128 v120;
  void *v121;
  std::string *v122;
  __int128 v123;
  void *v124;
  void *v125;
  void *v126;
  void *v127;
  void *v128;
  void *v129;
  void *v130;
  void *v131;
  void *v132;
  void *v133;
  void *v134;
  void *v135;
  void *v136;
  void *v137;
  void *v138;
  void *v139;
  void *v140;
  void *v141;
  void *v142;
  void *v143;
  void *v144;
  void *v145;
  void *v146;
  void *v147;
  void *v148;
  void *v149;
  int v150;
  void *v151;
  void *v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  void *v162;
  void *v163;
  void *v164;
  void *v165;
  void *v166;
  void *v167;
  void *v168;
  void *v169;
  void *v170;
  void *v171;
  void *v172;
  char *v173;
  _QWORD *v174;
  char *v176;
  char *v177;
  _QWORD *v178;
  void *v179;
  __int128 v180;
  uint64_t v181;
  char *v182;
  char *v183;
  _QWORD v184[2];
  char *v185[2];
  char v186[16];
  uint64_t v187;
  unint64_t v188[2];
  unint64_t v189;
  char v190[16];
  unint64_t v191[4];
  __int128 v192;
  void *__src;
  uint64_t v194;
  __int128 v195;
  __int128 v196;
  unint64_t v197[3];
  void *v198;
  int64x2_t v199;
  char *v200;
  unint64_t v201[2];
  unsigned int v202;
  _BYTE __str[32];
  unint64_t v204;
  int v205;
  int64x2_t v206;
  _QWORD v207[2];
  _BYTE v208[32];
  __int128 v209;
  unint64_t v210;
  unint64_t v211;
  int64x2_t v212;
  unint64_t v213[2];
  unint64_t v214;
  unint64_t v215;
  _BYTE v216[24];
  char *v217;
  char **v218;

  if (a1->data)
    v3 = a1->length == 0;
  else
    v3 = 1;
  if (v3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(__str, "Assertion: ");
    v119 = std::string::append((std::string *)__str, "input.data && input.length");
    v120 = *(_OWORD *)&v119->__r_.__value_.__l.__data_;
    __src = (void *)v119->__r_.__value_.__r.__words[2];
    v192 = v120;
    v119->__r_.__value_.__l.__size_ = 0;
    v119->__r_.__value_.__r.__words[2] = 0;
    v119->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v192);
  }
  v4 = DERParseSequenceContent((unint64_t *)a1, 5u, (uint64_t)&P73BaseFirmwareDERSpec::DeliveryObjectItemSpec, (unint64_t)&v192, 0x50uLL);
  if (v4)
  {
    v150 = v4;
    v151 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__str, "Failed to parse as per DeliveryObjectItemSpec");
    v152 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v151, (__int128 *)__str, v150, CFSTR("libDERErrorDomain"));
  }
  *(_DWORD *)__str = 0;
  if (DERParseInteger((char **)&v192, __str) || *(_DWORD *)__str || v194 != 32)
  {
    v153 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__str, "Failed to validate delivery object");
    v154 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v153, (__int128 *)__str, 15, CFSTR("SEUpdaterErrorDomain"));
  }
  v5 = (char *)operator new(0xC0uLL);
  *((_QWORD *)v5 + 1) = 0;
  *((_QWORD *)v5 + 2) = 0;
  *(_QWORD *)v5 = &off_24E0BFED0;
  *((_QWORD *)v5 + 3) = &off_24E0BFE28;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  *((_OWORD *)v5 + 11) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_QWORD *)v5 + 5) = 0;
  *((_QWORD *)v5 + 6) = 0;
  v178 = v5 + 40;
  *((_QWORD *)v5 + 4) = v5 + 40;
  *((_QWORD *)v5 + 7) = &unk_24E0BFCD0;
  v173 = v5 + 24;
  v174 = v5 + 56;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_QWORD *)v5 + 14) = &unk_24E0BFCD0;
  *((_QWORD *)v5 + 19) = 0;
  *((_QWORD *)v5 + 20) = 0;
  *((_QWORD *)v5 + 21) = 0;
  v182 = v5 + 24;
  v183 = v5;
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)v5 + 11, (char *)__src, (char *)__src + 32, 0x20uLL);
  *(_QWORD *)__str = &unk_24E0BFCD0;
  *(_OWORD *)&__str[8] = v195;
  *(_QWORD *)&__str[24] = 0;
  SERestoreInfo::BLOB::operator=((_QWORD *)v5 + 14, __str);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)__str);
  v179 = &unk_24E0BFCD0;
  v180 = *(_OWORD *)(v5 + 120);
  v181 = *((_QWORD *)v5 + 17);
  if (!(_QWORD)v180 || !*((_QWORD *)&v180 + 1))
  {
    v113 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(v208, "Assertion: ");
    v114 = std::string::append((std::string *)v208, "data.data && data.length");
    v115 = *(_OWORD *)&v114->__r_.__value_.__l.__data_;
    *(_QWORD *)&__str[16] = *((_QWORD *)&v114->__r_.__value_.__l + 2);
    *(_OWORD *)__str = v115;
    v114->__r_.__value_.__l.__size_ = 0;
    v114->__r_.__value_.__r.__words[2] = 0;
    v114->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v113, __str);
  }
  std::string::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(__str, (char *)v180, (char *)(v180 + *((_QWORD *)&v180 + 1)), *((unint64_t *)&v180 + 1));
  v6 = std::string::rfind((const std::string *)__str, 45, 0xFFFFFFFFFFFFFFFFLL);
  if (v6 == -1)
    goto LABEL_24;
  std::string::basic_string((std::string *)v208, (const std::string *)__str, v6 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)v216);
  if ((__str[23] & 0x80000000) != 0)
    operator delete(*(void **)__str);
  *(_QWORD *)&__str[16] = *(_QWORD *)&v208[16];
  *(_OWORD *)__str = *(_OWORD *)v208;
  if ((v208[23] & 0x80000000) != 0)
  {
    if (*(_QWORD *)&__str[8] != 2)
      goto LABEL_24;
    v7 = *(_BYTE **)__str;
  }
  else
  {
    if (v208[23] != 2)
      goto LABEL_24;
    v7 = __str;
  }
  v8 = 0;
  v9 = 0;
  while (1)
  {
    v10 = v8;
    if ((char)v7[v9] < 0 || (*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v7[v9] + 60) & 0x400) == 0)
      break;
    v8 = 1;
    v9 = 1;
    if ((v10 & 1) != 0)
    {
      v11 = std::stoul((const std::string *)__str, 0, 10);
      goto LABEL_25;
    }
  }
LABEL_24:
  v11 = -18;
LABEL_25:
  if ((__str[23] & 0x80000000) != 0)
    operator delete(*(void **)__str);
  v5[176] = v11;
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&v179);
  v12 = DERParseSequence((uint64_t)&v196, 3u, (uint64_t)&P73BaseFirmwareDERSpec::UpdatePayloadItemSpec, (unint64_t)v190, 0x30uLL);
  if (v12)
  {
    v155 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__str, "Failed to parse updatePayload as per UpdatePayloadItemSpec");
    v156 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v155, (__int128 *)__str, v12, CFSTR("libDERErrorDomain"));
  }
  v13 = DERParseSequenceContent(v191, 2u, (uint64_t)&P73BaseFirmwareDERSpec::SignedSectionItemSpec, (unint64_t)v188, 0x20uLL);
  if (v13)
  {
    v157 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__str, "Failed to parse signedSection as per SignedSectionItemSpec");
    v158 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v157, (__int128 *)__str, v13, CFSTR("libDERErrorDomain"));
  }
  v199 = 0uLL;
  v200 = 0;
  v14 = DERParseSequenceContent(v188, 3u, (uint64_t)&P73BaseFirmwareDERSpec::UpdateTableItemSpec, (unint64_t)__str, 0x30uLL);
  if (v14)
  {
    v159 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(v208, "Cannot parse UpdateTable.");
    v160 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v159, (__int128 *)v208, v14, CFSTR("libDERErrorDomain"));
  }
  v15 = DERParseInteger((char **)&__str[16], &v198);
  if (v15)
  {
    v161 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(v208, "Cannot parse UpdateTable.bsn.");
    v162 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v161, (__int128 *)v208, v15, CFSTR("libDERErrorDomain"));
  }
  v16 = DERDecodeSeqContentInit(&v204, v213);
  v177 = v5 + 152;
  v176 = v5;
  if (v16)
  {
    v163 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(v208, "Cannot parse UpdateTable entries");
    v164 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v163, (__int128 *)v208, v16, CFSTR("libDERErrorDomain"));
  }
  while (1)
  {
    v17 = DERDecodeSeqNext(v213, &v211);
    v18 = v17;
    if (v17)
      break;
    v19 = (char *)v212.i64[0];
    if (v212.i64[0])
      v20 = v212.i64[1] == 0;
    else
      v20 = 1;
    if (v20)
    {
      v109 = __cxa_allocate_exception(0x10uLL);
      v110 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v214, "Assertion: ");
      v111 = std::string::append(v110, "entry.data && entry.length");
      v112 = *(_OWORD *)&v111->__r_.__value_.__l.__data_;
      *(_QWORD *)&v216[16] = *((_QWORD *)&v111->__r_.__value_.__l + 2);
      *(_OWORD *)v216 = v112;
      v111->__r_.__value_.__l.__size_ = 0;
      v111->__r_.__value_.__r.__words[2] = 0;
      v111->__r_.__value_.__r.__words[0] = 0;
      MEMORY[0x22078A520](v109, v216);
    }
    v21 = 0;
    v209 = 0u;
    memset(v208, 0, sizeof(v208));
    do
    {
      if ((unint64_t)v19 >= v212.i64[0] + v212.i64[1])
        break;
      v22 = *v19;
      if (*v19)
        v23 = (v22 & 1) == 0;
      else
        v23 = 0;
      if (!v23)
      {
        v124 = __cxa_allocate_exception(0x48uLL);
        std::string::basic_string[abi:ne180100]<0>(v216, "Wrong length for updateTableEnry");
        v125 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v124, (__int128 *)v216, 2, CFSTR("SEUpdaterErrorDomain"));
      }
      v24 = 0;
      v25 = 0;
      v26 = 0;
      ++v19;
      memset(v216, 0, sizeof(v216));
      do
      {
        v27 = *(unsigned __int16 *)v19;
        v19 += 2;
        v28 = bswap32(v27) >> 16;
        if ((unint64_t)v26 >= v25)
        {
          v29 = v26 - v24;
          if (v26 - v24 <= -3)
            std::vector<unsigned short>::__throw_length_error[abi:ne180100]();
          v30 = v29 >> 1;
          if (v25 - (unint64_t)v24 <= (v29 >> 1) + 1)
            v31 = v30 + 1;
          else
            v31 = v25 - (_QWORD)v24;
          if (v25 - (unint64_t)v24 >= 0x7FFFFFFFFFFFFFFELL)
            v32 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v32 = v31;
          if (v32)
            v32 = (uint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(v32);
          else
            v33 = 0;
          v34 = (char *)(v32 + 2 * v30);
          *(_WORD *)v34 = v28;
          v35 = v34 + 2;
          while (v26 != v24)
          {
            v36 = *((_WORD *)v26 - 1);
            v26 -= 2;
            *((_WORD *)v34 - 1) = v36;
            v34 -= 2;
          }
          v25 = v32 + 2 * v33;
          *(_QWORD *)v216 = v34;
          *(_QWORD *)&v216[8] = v35;
          *(_QWORD *)&v216[16] = v25;
          if (v24)
            operator delete(v24);
          v24 = v34;
          v26 = v35;
        }
        else
        {
          *(_WORD *)v26 = v28;
          v26 += 2;
        }
        *(_QWORD *)&v216[8] = v26;
        v22 -= 2;
      }
      while ((_BYTE)v22);
      v37 = *(_QWORD **)&v208[8];
      if (*(_QWORD *)&v208[8] >= *(_QWORD *)&v208[16])
      {
        v38 = std::vector<std::vector<unsigned short>>::__emplace_back_slow_path<std::vector<unsigned short>&>((uint64_t *)v208, (uint64_t)v216);
      }
      else
      {
        **(_OWORD **)&v208[8] = 0uLL;
        v37[2] = 0;
        std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(v37, *(const void **)v216, (uint64_t)v26, (uint64_t)&v26[-*(_QWORD *)v216] >> 1);
        v38 = (uint64_t)(v37 + 3);
      }
      *(_QWORD *)&v208[8] = v38;
      if (*(_QWORD *)v216)
        operator delete(*(void **)v216);
      ++v21;
    }
    while (v21 != 4);
    v40 = v19 + 1;
    v39 = *v19;
    if (*v19)
    {
      v41 = 0;
      v42 = *v19;
      do
      {
        --v42;
        v43 = *v40++;
        v41 = v43 | (v41 << 8);
      }
      while ((_BYTE)v42);
      v44 = (unsigned __int8 *)&v19[(v39 - 1)];
      v19 += v39;
      v40 = v44 + 2;
    }
    else
    {
      v41 = 0;
    }
    v45 = operator new(2uLL);
    *v45 = v41;
    *(_QWORD *)&v216[8] = v45 + 1;
    *(_QWORD *)&v216[16] = v45 + 1;
    v46 = *(_QWORD **)&v208[8];
    *(_QWORD *)v216 = v45;
    if (*(_QWORD *)&v208[8] >= *(_QWORD *)&v208[16])
    {
      v47 = std::vector<std::vector<unsigned short>>::__emplace_back_slow_path<std::vector<unsigned short>&>((uint64_t *)v208, (uint64_t)v216);
    }
    else
    {
      **(_OWORD **)&v208[8] = 0uLL;
      v46[2] = 0;
      std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(v46, v45, (uint64_t)(v45 + 1), 1);
      v47 = (uint64_t)(v46 + 3);
    }
    *(_QWORD *)&v208[8] = v47;
    operator delete(v45);
    if (*v40 != 32)
    {
      v132 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(v216, "wrong updateTableEnry with wrong hash size");
      v133 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v132, (__int128 *)v216, 15, CFSTR("SEUpdaterErrorDomain"));
    }
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&v208[24], v19 + 2, v19 + 34, 0x20uLL);
    if (*(_QWORD *)&v208[8] - *(_QWORD *)v208 != 120)
    {
      v130 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(v216, "Missing element in updateTableEnry");
      v131 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v130, (__int128 *)v216, 15, CFSTR("SEUpdaterErrorDomain"));
    }
    v48 = v199.i64[1];
    if (v199.i64[1] >= (unint64_t)v200)
    {
      v50 = 0xAAAAAAAAAAAAAAABLL * ((v199.i64[1] - v199.i64[0]) >> 4);
      v51 = v50 + 1;
      if (v50 + 1 > 0x555555555555555)
        std::vector<unsigned short>::__throw_length_error[abi:ne180100]();
      if (0x5555555555555556 * ((uint64_t)&v200[-v199.i64[0]] >> 4) > v51)
        v51 = 0x5555555555555556 * ((uint64_t)&v200[-v199.i64[0]] >> 4);
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v200[-v199.i64[0]] >> 4) >= 0x2AAAAAAAAAAAAAALL)
        v52 = 0x555555555555555;
      else
        v52 = v51;
      v218 = &v200;
      if (v52)
      {
        if (v52 > 0x555555555555555)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v53 = (char *)operator new(48 * v52);
      }
      else
      {
        v53 = 0;
      }
      *(_QWORD *)v216 = v53;
      *(_QWORD *)&v216[8] = &v53[48 * v50];
      *(_QWORD *)&v216[16] = *(_QWORD *)&v216[8];
      v217 = &v53[48 * v52];
      std::allocator<SERestoreInfo::UpdateTableEntry>::construct[abi:ne180100]<SERestoreInfo::UpdateTableEntry,SERestoreInfo::UpdateTableEntry&>(*(_QWORD **)&v216[8], (uint64_t *)v208);
      v54 = *(_QWORD *)&v216[8];
      v49 = *(_QWORD *)&v216[16] + 48;
      *(_QWORD *)&v216[16] += 48;
      v55 = v199;
      if (v199.i64[1] == v199.i64[0])
      {
        v59 = vdupq_n_s64(v199.u64[1]);
      }
      else
      {
        v56 = 0;
        do
        {
          v57 = v54 + v56;
          v58 = v55.i64[1] + v56;
          *(_QWORD *)(v57 - 48) = 0;
          *(_QWORD *)(v57 - 40) = 0;
          *(_QWORD *)(v57 - 32) = 0;
          *(_OWORD *)(v57 - 48) = *(_OWORD *)(v55.i64[1] + v56 - 48);
          *(_QWORD *)(v57 - 32) = *(_QWORD *)(v55.i64[1] + v56 - 32);
          *(_QWORD *)(v58 - 48) = 0;
          *(_QWORD *)(v58 - 40) = 0;
          *(_QWORD *)(v58 - 32) = 0;
          *(_QWORD *)(v57 - 24) = 0;
          *(_QWORD *)(v57 - 16) = 0;
          *(_QWORD *)(v57 - 8) = 0;
          *(_OWORD *)(v57 - 24) = *(_OWORD *)(v55.i64[1] + v56 - 24);
          *(_QWORD *)(v57 - 8) = *(_QWORD *)(v55.i64[1] + v56 - 8);
          *(_QWORD *)(v58 - 24) = 0;
          *(_QWORD *)(v58 - 16) = 0;
          *(_QWORD *)(v58 - 8) = 0;
          v56 -= 48;
        }
        while (v55.i64[1] + v56 != v55.i64[0]);
        v59 = v199;
        v49 = *(_QWORD *)&v216[16];
        v54 += v56;
      }
      v199.i64[0] = v54;
      v199.i64[1] = v49;
      *(int64x2_t *)&v216[8] = v59;
      v60 = v200;
      v200 = v217;
      v217 = v60;
      *(_QWORD *)v216 = v59.i64[0];
      std::__split_buffer<SERestoreInfo::UpdateTableEntry>::~__split_buffer((uint64_t)v216);
    }
    else
    {
      std::allocator<SERestoreInfo::UpdateTableEntry>::construct[abi:ne180100]<SERestoreInfo::UpdateTableEntry,SERestoreInfo::UpdateTableEntry&>((_QWORD *)v199.i64[1], (uint64_t *)v208);
      v49 = v48 + 48;
    }
    v199.i64[1] = v49;
    if (*(_QWORD *)&v208[24])
    {
      *(_QWORD *)&v209 = *(_QWORD *)&v208[24];
      operator delete(*(void **)&v208[24]);
    }
    *(_QWORD *)v216 = v208;
    std::vector<std::vector<unsigned short>>::__destroy_vector::operator()[abi:ne180100]((void ***)v216);
  }
  if (v17 != 1)
  {
    v128 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(v208, "Wrong UpdateTable entries");
    v129 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v128, (__int128 *)v208, v18, CFSTR("libDERErrorDomain"));
  }
  v62 = v199.i64[1];
  v61 = v199.i64[0];
  if (v199.i64[0] == v199.i64[1])
  {
    v165 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(v208, "Size of UpdateTable.entries is zero");
    v166 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v165, (__int128 *)v208, 15, CFSTR("SEUpdaterErrorDomain"));
  }
  *((_DWORD *)v176 + 36) = (_DWORD)v198;
  v63 = *((_QWORD *)v176 + 19);
  if (v63)
  {
    v64 = *((_QWORD *)v176 + 20);
    v65 = (void *)*((_QWORD *)v176 + 19);
    if (v64 != v63)
    {
      do
      {
        v64 -= 48;
        std::allocator<SERestoreInfo::UpdateTableEntry>::destroy[abi:ne180100](v64);
      }
      while (v64 != v63);
      v65 = *(void **)v177;
    }
    *((_QWORD *)v176 + 20) = v63;
    operator delete(v65);
    *(_QWORD *)v177 = 0;
    *((_QWORD *)v177 + 1) = 0;
    *((_QWORD *)v177 + 2) = 0;
    v62 = v199.i64[1];
    v61 = v199.i64[0];
  }
  *((_QWORD *)v176 + 19) = v61;
  *((_QWORD *)v176 + 20) = v62;
  *((_QWORD *)v176 + 21) = v200;
  v200 = 0;
  v199 = 0uLL;
  *(_QWORD *)__str = &v199;
  std::vector<SERestoreInfo::UpdateTableEntry>::__destroy_vector::operator()[abi:ne180100]((void ***)__str);
  if (!v197[0] || !v197[1])
  {
    v121 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(v208, "Assertion: ");
    v122 = std::string::append((std::string *)v208, "binaryItem.data && binaryItem.length");
    v123 = *(_OWORD *)&v122->__r_.__value_.__l.__data_;
    *(_QWORD *)&__str[16] = *((_QWORD *)&v122->__r_.__value_.__l + 2);
    *(_OWORD *)__str = v123;
    v122->__r_.__value_.__l.__size_ = 0;
    v122->__r_.__value_.__r.__words[2] = 0;
    v122->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v121, __str);
  }
  v66 = DERDecodeSeqContentInit(v197, v213);
  if (v66)
  {
    v167 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__str, "Cannot init sequence for DeliveryObject.binaries");
    v168 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v167, (__int128 *)__str, v66, CFSTR("libDERErrorDomain"));
  }
  while (1)
  {
    v67 = DERDecodeSeqNext(v213, &v214);
    v68 = v67;
    if (v67)
      break;
    *(_DWORD *)__str = 0;
    *(_QWORD *)&__str[8] = &unk_24E0BFCD0;
    v204 = 0;
    v205 = 0;
    v207[0] = 0;
    v206 = 0uLL;
    v202 = 0;
    v69 = DERParseSequenceContent(&v215, 4u, (uint64_t)&P73BaseFirmwareDERSpec::ImageBinaryItemSpec, (unint64_t)v208, 0x40uLL);
    if (v69)
    {
      v134 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(v216, "Cannot parse ImageBinary.");
      v135 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v134, (__int128 *)v216, v69, CFSTR("libDERErrorDomain"));
    }
    v70 = DERParseInteger((char **)v208, &v202);
    if (v70 || v202 >= 5)
    {
      v126 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(v216, "ImageBinary.type is out of range.");
      v127 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v126, (__int128 *)v216, v70, CFSTR("libDERErrorDomain"));
    }
    *(_DWORD *)__str = v202;
    *(_QWORD *)v216 = &unk_24E0BFCD0;
    *(_OWORD *)&v216[8] = *(_OWORD *)&v208[16];
    v217 = 0;
    SERestoreInfo::BLOB::operator=(&__str[8], v216);
    SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)v216);
    v71 = DERParseInteger((char **)&v209, &v205);
    if (v71)
    {
      v136 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(v216, "Cannot parse ImageBinary.index.");
      v137 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v136, (__int128 *)v216, v71, CFSTR("libDERErrorDomain"));
    }
    v72 = DERDecodeSeqContentInit(&v210, v201);
    if (v72)
    {
      v138 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(v216, "Cannot init sequence for ImageBinary.apdus");
      v139 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v138, (__int128 *)v216, v72, CFSTR("libDERErrorDomain"));
    }
    while (1)
    {
      v73 = DERDecodeSeqNext(v201, &v211);
      v74 = v73;
      if (v73)
        break;
      v198 = &unk_24E0BFCD0;
      v199 = v212;
      v200 = 0;
      v75 = v206.i64[1];
      if (v206.i64[1] >= v207[0])
      {
        v78 = (v206.i64[1] - v206.i64[0]) >> 5;
        v79 = v78 + 1;
        if ((unint64_t)(v78 + 1) >> 59)
          std::vector<unsigned short>::__throw_length_error[abi:ne180100]();
        v80 = v207[0] - v206.i64[0];
        if ((v207[0] - v206.i64[0]) >> 4 > v79)
          v79 = v80 >> 4;
        if ((unint64_t)v80 >= 0x7FFFFFFFFFFFFFE0)
          v81 = 0x7FFFFFFFFFFFFFFLL;
        else
          v81 = v79;
        v218 = (char **)v207;
        if (v81)
          v82 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SERestoreInfo::BLOB>>((uint64_t)v207, v81);
        else
          v82 = 0;
        v83 = &v82[32 * v78];
        *(_QWORD *)v83 = &unk_24E0BFCD0;
        v84 = v199;
        *((_QWORD *)v83 + 3) = v200;
        *(int64x2_t *)(v83 + 8) = v84;
        v86 = v206.i64[1];
        v85 = v206.i64[0];
        if (v206.i64[1] == v206.i64[0])
        {
          v89 = vdupq_n_s64(v206.u64[1]);
          v87 = &v82[32 * v78];
        }
        else
        {
          v87 = &v82[32 * v78];
          do
          {
            *((_QWORD *)v87 - 4) = &unk_24E0BFCD0;
            v87 -= 32;
            v88 = *(_OWORD *)(v86 - 24);
            *((_QWORD *)v87 + 3) = *(_QWORD *)(v86 - 8);
            *(_OWORD *)(v87 + 8) = v88;
            v86 -= 32;
          }
          while (v86 != v85);
          v89 = v206;
        }
        v77 = v83 + 32;
        v206.i64[0] = (uint64_t)v87;
        v206.i64[1] = (uint64_t)(v83 + 32);
        *(int64x2_t *)&v216[8] = v89;
        v90 = (char *)v207[0];
        v207[0] = &v82[32 * v81];
        v217 = v90;
        *(_QWORD *)v216 = v89.i64[0];
        std::__split_buffer<SERestoreInfo::BLOB>::~__split_buffer((uint64_t)v216);
      }
      else
      {
        *(_QWORD *)v206.i64[1] = &unk_24E0BFCD0;
        v76 = v199;
        *(_QWORD *)(v75 + 24) = v200;
        *(int64x2_t *)(v75 + 8) = v76;
        v77 = (char *)(v75 + 32);
      }
      v206.i64[1] = (uint64_t)v77;
      SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&v198);
    }
    if (v73 != 1)
    {
      v116 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(v216, "Cannot parse ImageBinary.apdus");
      v117 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v116, (__int128 *)v216, v74, CFSTR("libDERErrorDomain"));
    }
    v91 = v205;
    v92 = operator new(0x70uLL);
    v92[11] = 0;
    *((_WORD *)v92 + 16) = v91;
    v93 = *(_DWORD *)__str;
    v92[6] = &unk_24E0BFCD0;
    *((_DWORD *)v92 + 10) = v93;
    *(_OWORD *)(v92 + 7) = *(_OWORD *)&__str[16];
    v92[9] = v204;
    *((_DWORD *)v92 + 20) = v91;
    v94 = v206;
    v95 = (v206.i64[1] - v206.i64[0]) >> 5;
    v92[12] = 0;
    v92[13] = 0;
    std::vector<SERestoreInfo::BLOB>::__init_with_size[abi:ne180100]<SERestoreInfo::BLOB*,SERestoreInfo::BLOB*>((char *)v92 + 88, v94.i64[0], v94.i64[1], v95);
    v96 = v178;
    v97 = (uint64_t *)*v178;
    v98 = v178;
    if (*v178)
    {
      v99 = *((unsigned __int16 *)v92 + 16);
      while (1)
      {
        while (1)
        {
          v96 = v97;
          v100 = *((unsigned __int16 *)v97 + 16);
          if (v99 >= v100)
            break;
          v97 = (uint64_t *)*v97;
          v98 = v96;
          if (!*v96)
            goto LABEL_145;
        }
        if (v100 >= v99)
          break;
        v97 = (uint64_t *)v97[1];
        if (!v97)
        {
          v98 = v96 + 1;
          goto LABEL_145;
        }
      }
      *(_QWORD *)v216 = v92 + 11;
      std::vector<SERestoreInfo::BLOB>::__destroy_vector::operator()[abi:ne180100]((void ***)v216);
      SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)(v92 + 6));
      operator delete(v92);
    }
    else
    {
LABEL_145:
      *v92 = 0;
      v92[1] = 0;
      v92[2] = v96;
      *v98 = v92;
      v101 = **((_QWORD **)v176 + 4);
      if (v101)
      {
        *((_QWORD *)v176 + 4) = v101;
        v92 = (_QWORD *)*v98;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v176 + 5), v92);
      ++*((_QWORD *)v176 + 6);
    }
    *(_QWORD *)v216 = &v206;
    std::vector<SERestoreInfo::BLOB>::__destroy_vector::operator()[abi:ne180100]((void ***)v216);
    SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&__str[8]);
  }
  if (v67 != 1)
  {
    v140 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__str, "Cannot parse DeliveryObject.binaries");
    v141 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v140, (__int128 *)__str, v68, CFSTR("libDERErrorDomain"));
  }
  *(_QWORD *)__str = &unk_24E0BFCD0;
  *(_OWORD *)&__str[8] = v196;
  *(_QWORD *)&__str[24] = 0;
  SERestoreInfo::BLOB::operator=(v174, __str);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)__str);
  *((_DWORD *)v176 + 45) = 0;
  *((_DWORD *)v176 + 46) = 0;
  result = (uint64_t)DERParseSequenceContent(&v189, 2u, (uint64_t)&P73BaseFirmwareDERSpec::UpdatePropertiesItemSpec, (unint64_t)v186, 0x20uLL);
  v103 = result;
  if ((_DWORD)result)
  {
    if ((_DWORD)result != 5)
    {
      v169 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(__str, "Failed to parse updateProperties as per UpdatePropertiesItemSpec.");
      v170 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v169, (__int128 *)__str, v103, CFSTR("libDERErrorDomain"));
    }
  }
  else
  {
    v198 = 0;
    v104 = DERDecodeSeqInit((uint64_t)&v187, &v198, v216);
    if (v104)
    {
      v171 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(__str, "Cannot parse properties entries");
      v172 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v171, (__int128 *)__str, v104, CFSTR("libDERErrorDomain"));
    }
    while (1)
    {
      result = DERDecodeSeqNext((unint64_t *)v216, (unint64_t *)__str);
      if ((_DWORD)result)
        break;
      v105 = DERDecodeItem((uint64_t)&__str[8], (unint64_t *)__str);
      if (v105)
      {
        v142 = __cxa_allocate_exception(0x48uLL);
        std::string::basic_string[abi:ne180100]<0>(v208, "Cannot parse property");
        v143 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v142, (__int128 *)v208, v105, CFSTR("libDERErrorDomain"));
      }
      v106 = DERParseSequenceContent((unint64_t *)&__str[8], 2u, (uint64_t)&P73BaseFirmwareDERSpec::PropertyItemSpec, (unint64_t)v184, 0x20uLL);
      if (v106)
      {
        v144 = __cxa_allocate_exception(0x48uLL);
        std::string::basic_string[abi:ne180100]<0>(v208, "Failed to parse as per PropertyItemSpec");
        v145 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v144, (__int128 *)v208, v106, CFSTR("libDERErrorDomain"));
      }
      if (v184[1] == 4)
      {
        if (*(_DWORD *)v184[0] == 1768121715)
        {
          LODWORD(v214) = 0;
          v108 = DERParseInteger(v185, &v214);
          if (v108)
          {
            v146 = __cxa_allocate_exception(0x48uLL);
            std::string::basic_string[abi:ne180100]<0>(v208, "Failed to parse 'seci' value");
            v147 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v146, (__int128 *)v208, v108, CFSTR("libDERErrorDomain"));
          }
          *((_DWORD *)v176 + 45) = v214;
        }
        else if (*(_DWORD *)v184[0] == 1986553203)
        {
          LODWORD(v214) = 0;
          v107 = DERParseInteger(v185, &v214);
          if (v107)
          {
            v148 = __cxa_allocate_exception(0x48uLL);
            std::string::basic_string[abi:ne180100]<0>(v208, "Failed to parse 'sehv' value");
            v149 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v148, (__int128 *)v208, v107, CFSTR("libDERErrorDomain"));
          }
          *((_DWORD *)v176 + 46) = v214;
        }
      }
    }
  }
  *a2 = v173;
  a2[1] = v176;
  return result;
}

void sub_21CC9ED00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *__p)
{
  char a68;

  if (a68 < 0)
    operator delete(__p);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&a21);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a25);
  _Unwind_Resume(a1);
}

void SERestoreInfo::P73BaseFirmware::~P73BaseFirmware(SERestoreInfo::P73BaseFirmware *this)
{
  SERestoreInfo::SEFirmwareBase::~SEFirmwareBase(this);
  JUMPOUT(0x22078A808);
}

void SERestoreInfo::P73BaseDeliveryObject::~P73BaseDeliveryObject(SERestoreInfo::P73BaseDeliveryObject *this)
{
  void *v2;
  void **v3;

  *(_QWORD *)this = &off_24E0BFE28;
  v3 = (void **)((char *)this + 128);
  std::vector<SERestoreInfo::UpdateTableEntry>::__destroy_vector::operator()[abi:ne180100](&v3);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::P73BaseDeliveryObject *)((char *)this + 88));
  v2 = (void *)*((_QWORD *)this + 8);
  if (v2)
  {
    *((_QWORD *)this + 9) = v2;
    operator delete(v2);
  }
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::P73BaseDeliveryObject *)((char *)this + 32));
  std::__tree<std::__value_type<unsigned short,SERestoreInfo::ImageBinary>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,SERestoreInfo::ImageBinary>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,SERestoreInfo::ImageBinary>>>::destroy(*((char **)this + 2));
}

{
  void *v2;
  void **v3;

  *(_QWORD *)this = &off_24E0BFE28;
  v3 = (void **)((char *)this + 128);
  std::vector<SERestoreInfo::UpdateTableEntry>::__destroy_vector::operator()[abi:ne180100](&v3);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::P73BaseDeliveryObject *)((char *)this + 88));
  v2 = (void *)*((_QWORD *)this + 8);
  if (v2)
  {
    *((_QWORD *)this + 9) = v2;
    operator delete(v2);
  }
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::P73BaseDeliveryObject *)((char *)this + 32));
  std::__tree<std::__value_type<unsigned short,SERestoreInfo::ImageBinary>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,SERestoreInfo::ImageBinary>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,SERestoreInfo::ImageBinary>>>::destroy(*((char **)this + 2));
  JUMPOUT(0x22078A808);
}

void std::vector<unsigned short>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(uint64_t a1)
{
  if (a1 < 0)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(2 * a1);
}

uint64_t std::vector<std::vector<unsigned short>>::__emplace_back_slow_path<std::vector<unsigned short>&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  __int128 v14;
  int64x2_t v15;
  unint64_t v16;
  unint64_t v18;
  int64x2_t v19;
  unint64_t v20;
  _QWORD *v21;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<unsigned short>::__throw_length_error[abi:ne180100]();
  v6 = a1 + 2;
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v3)
    v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555)
    v7 = 0xAAAAAAAAAAAAAAALL;
  else
    v7 = v3;
  v21 = v6;
  if (v7)
    v7 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<unsigned short>>>(v7);
  else
    v8 = 0;
  v9 = (_QWORD *)(v7 + 24 * v2);
  v18 = v7;
  v19.i64[0] = (uint64_t)v9;
  v19.i64[1] = (uint64_t)v9;
  v20 = v7 + 24 * v8;
  *v9 = 0;
  v9[1] = 0;
  v9[2] = 0;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(v9, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 1);
  v10 = v19.i64[0];
  v11 = v19.i64[1] + 24;
  v19.i64[1] += 24;
  v13 = (_QWORD *)*a1;
  v12 = (_QWORD *)a1[1];
  if (v12 == (_QWORD *)*a1)
  {
    v15 = vdupq_n_s64((unint64_t)v12);
  }
  else
  {
    do
    {
      *(_QWORD *)(v10 - 24) = 0;
      *(_QWORD *)(v10 - 16) = 0;
      v10 -= 24;
      *(_QWORD *)(v10 + 16) = 0;
      v14 = *(_OWORD *)(v12 - 3);
      v12 -= 3;
      *(_OWORD *)v10 = v14;
      *(_QWORD *)(v10 + 16) = v12[2];
      *v12 = 0;
      v12[1] = 0;
      v12[2] = 0;
    }
    while (v12 != v13);
    v15 = *(int64x2_t *)a1;
    v11 = v19.i64[1];
  }
  *a1 = v10;
  a1[1] = v11;
  v19 = v15;
  v16 = a1[2];
  a1[2] = v20;
  v20 = v16;
  v18 = v15.i64[0];
  std::__split_buffer<std::vector<unsigned short>>::~__split_buffer((uint64_t)&v18);
  return v11;
}

void sub_21CC9F3BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<unsigned short>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<unsigned short>>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a1);
}

uint64_t std::__split_buffer<std::vector<unsigned short>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    v4 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(_QWORD *)(v2 - 16) = v4;
      operator delete(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<std::vector<unsigned short>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void *v7;
  void *v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = (char *)v1[1];
      do
      {
        v8 = (void *)*((_QWORD *)v6 - 3);
        v6 -= 24;
        v7 = v8;
        if (v8)
        {
          *((_QWORD *)v4 - 2) = v7;
          operator delete(v7);
        }
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<SERestoreInfo::UpdateTableEntry>::destroy[abi:ne180100](uint64_t a1)
{
  void *v2;
  void **v3;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  v3 = (void **)a1;
  std::vector<std::vector<unsigned short>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void SERestoreInfo::ImageBinary::~ImageBinary(SERestoreInfo::ImageBinary *this)
{
  void **v2;

  v2 = (void **)((char *)this + 48);
  std::vector<SERestoreInfo::BLOB>::__destroy_vector::operator()[abi:ne180100](&v2);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::ImageBinary *)((char *)this + 8));
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<SERestoreInfo::BLOB>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a2);
}

uint64_t std::__split_buffer<SERestoreInfo::BLOB>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void (**v4)(void);

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(void (***)(void))(i - 32);
    *(_QWORD *)(a1 + 16) = i - 32;
    (*v4)();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

char *std::vector<SERestoreInfo::BLOB>::__init_with_size[abi:ne180100]<SERestoreInfo::BLOB*,SERestoreInfo::BLOB*>(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v6;
  uint64_t i;
  __int128 v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<SERestoreInfo::BLOB>::__vallocate[abi:ne180100](result, a4);
    for (i = *((_QWORD *)v6 + 1); a2 != a3; i += 32)
    {
      *(_QWORD *)i = &unk_24E0BFCD0;
      v8 = *(_OWORD *)(a2 + 8);
      *(_QWORD *)(i + 24) = *(_QWORD *)(a2 + 24);
      *(_OWORD *)(i + 8) = v8;
      a2 += 32;
    }
    *((_QWORD *)v6 + 1) = i;
  }
  return result;
}

void sub_21CC9F67C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<SERestoreInfo::BLOB>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<SERestoreInfo::BLOB>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 59)
    std::vector<unsigned short>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SERestoreInfo::BLOB>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void std::__tree<std::__value_type<unsigned short,SERestoreInfo::ImageBinary>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,SERestoreInfo::ImageBinary>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,SERestoreInfo::ImageBinary>>>::destroy(char *a1)
{
  void **v2;

  if (a1)
  {
    std::__tree<std::__value_type<unsigned short,SERestoreInfo::ImageBinary>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,SERestoreInfo::ImageBinary>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,SERestoreInfo::ImageBinary>>>::destroy(*(_QWORD *)a1);
    std::__tree<std::__value_type<unsigned short,SERestoreInfo::ImageBinary>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,SERestoreInfo::ImageBinary>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,SERestoreInfo::ImageBinary>>>::destroy(*((_QWORD *)a1 + 1));
    v2 = (void **)(a1 + 88);
    std::vector<SERestoreInfo::BLOB>::__destroy_vector::operator()[abi:ne180100](&v2);
    SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)(a1 + 48));
    operator delete(a1);
  }
}

void std::vector<SERestoreInfo::UpdateTableEntry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::allocator<SERestoreInfo::UpdateTableEntry>::destroy[abi:ne180100](v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::allocator<SERestoreInfo::UpdateTableEntry>::construct[abi:ne180100]<SERestoreInfo::UpdateTableEntry,SERestoreInfo::UpdateTableEntry&>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v11[3];
  char v12;
  _QWORD *v13;
  _QWORD *v14;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *a2;
  v5 = a2[1];
  if (v5 != *a2)
  {
    v6 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a2) >> 3);
    if (v6 >= 0xAAAAAAAAAAAAAABLL)
      std::vector<unsigned short>::__throw_length_error[abi:ne180100]();
    v7 = std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<unsigned short>>>(v6);
    *a1 = v7;
    a1[1] = v7;
    a1[2] = &v7[3 * v8];
    v13 = v7;
    v14 = v7;
    v11[0] = a1 + 2;
    v11[1] = &v13;
    v11[2] = &v14;
    v12 = 0;
    v9 = v7;
    do
    {
      *v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
      std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(v9, *(const void **)v4, *(_QWORD *)(v4 + 8), (uint64_t)(*(_QWORD *)(v4 + 8) - *(_QWORD *)v4) >> 1);
      v9 = v14 + 3;
      v14 += 3;
      v4 += 24;
    }
    while (v4 != v5);
    v12 = 1;
    std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned short>>,std::vector<unsigned short>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
    a1[1] = v9;
  }
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(a1 + 3, (const void *)a2[3], a2[4], a2[4] - a2[3]);
}

void sub_21CC9F8B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::vector<std::vector<unsigned short>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned short>>,std::vector<unsigned short>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = **(_QWORD **)(a1 + 8);
    v3 = **(_QWORD **)(a1 + 16);
    if (v3 != v2)
    {
      v4 = **(_QWORD **)(a1 + 16);
      do
      {
        v6 = *(void **)(v4 - 24);
        v4 -= 24;
        v5 = v6;
        if (v6)
        {
          *(_QWORD *)(v3 - 16) = v5;
          operator delete(v5);
        }
        v3 = v4;
      }
      while (v4 != v2);
    }
  }
  return a1;
}

uint64_t std::__split_buffer<SERestoreInfo::UpdateTableEntry>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 48;
    std::allocator<SERestoreInfo::UpdateTableEntry>::destroy[abi:ne180100](i - 48);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *std::string::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(_QWORD *result, char *a2, char *a3, unint64_t a4)
{
  _QWORD *v4;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v4 = result;
  if (a4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (a4 > 0x16)
  {
    v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17)
      v8 = a4 | 7;
    v9 = v8 + 1;
    result = operator new(v8 + 1);
    v4[1] = a4;
    v4[2] = v9 | 0x8000000000000000;
    *v4 = result;
    v4 = result;
  }
  else
  {
    *((_BYTE *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    v10 = *a2++;
    *(_BYTE *)v4 = v10;
    v4 = (_QWORD *)((char *)v4 + 1);
  }
  *(_BYTE *)v4 = 0;
  return result;
}

void std::vector<std::vector<unsigned short>>::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("vector");
}

_QWORD *std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(_QWORD *result, const void *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;

  if (a4)
  {
    v4 = result;
    if (a4 < 0)
      std::vector<unsigned short>::__throw_length_error[abi:ne180100]();
    result = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(a4);
    v7 = result;
    *v4 = result;
    v4[1] = result;
    v4[2] = (char *)result + 2 * v8;
    v9 = a3 - (_QWORD)a2;
    if (v9)
      result = memmove(result, a2, v9);
    v4[1] = (char *)v7 + v9;
  }
  return result;
}

void sub_21CC9FAC4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100IN13SERestoreInfo17P73BaseDeviceInfoENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0xD8uLL);
  result = _ZNSt3__120__shared_ptr_emplaceIN13SERestoreInfo17P73BaseDeviceInfoENS_9allocatorIS2_EEEC2B8ne180100IJES4_Li0EEES4_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_21CC9FB14(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceIN13SERestoreInfo17P73BaseDeviceInfoENS_9allocatorIS2_EEEC2B8ne180100IJES4_Li0EEES4_DpOT_(_QWORD *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_24E0BFE80;
  SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo((SERestoreInfo::P73BaseDeviceInfo *)(a1 + 3));
  return a1;
}

void sub_21CC9FB5C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<SERestoreInfo::P73BaseDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0BFE80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::P73BaseDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0BFE80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::P73BaseDeviceInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::vector<std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v4 - 16);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__tree<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::__map_value_compare<std::vector<unsigned char>,std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::less<std::vector<unsigned char>>,true>,std::allocator<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::__map_value_compare<std::vector<unsigned char>,std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::less<std::vector<unsigned char>>,true>,std::allocator<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::__map_value_compare<std::vector<unsigned char>,std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::less<std::vector<unsigned char>>,true>,std::allocator<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::vector<unsigned char> const,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::vector<unsigned char> const,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,0>(uint64_t a1)
{
  void *v2;

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](a1 + 24);
  v2 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
}

_QWORD *std::__tree<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::__map_value_compare<std::vector<unsigned char>,std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,std::less<std::vector<unsigned char>>,true>,std::allocator<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>>>::__find_equal<std::vector<unsigned char>>(uint64_t a1, _QWORD *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  _QWORD *result;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned __int8 *v15;
  unsigned int v16;
  unsigned int v17;

  v6 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v5 = v6;
  if (v6)
  {
    do
    {
      while (1)
      {
        v7 = v5;
        v8 = (unsigned __int8 *)v5[4];
        v9 = (unsigned __int8 *)v7[5];
        if (v8 != v9)
          break;
LABEL_11:
        if (a3 != a4)
        {
          v15 = a3 + 1;
          while (v8 != v9)
          {
            v16 = *v8;
            v17 = *(v15 - 1);
            if (v16 < v17)
              break;
            ++v8;
            if (v17 < v16 || v15++ == a4)
              goto LABEL_26;
          }
          result = v7 + 1;
          v5 = (_QWORD *)v7[1];
          if (v5)
            continue;
        }
        goto LABEL_26;
      }
      v10 = v8 + 1;
      v11 = a3;
      while (v11 != a4)
      {
        v12 = *v11;
        v13 = *(v10 - 1);
        if (v12 < v13)
          break;
        ++v11;
        if (v13 < v12 || v10++ == v9)
          goto LABEL_11;
      }
      v5 = (_QWORD *)*v7;
      result = v7;
    }
    while (*v7);
  }
  else
  {
    v7 = result;
  }
LABEL_26:
  *a2 = v7;
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::vector<unsigned char>,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::vector<unsigned char> const,std::shared_ptr<SERestoreInfo::P73BaseDeliveryObject const>>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::__shared_ptr_emplace<SERestoreInfo::P73BaseDeliveryObject>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0BFED0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::P73BaseDeliveryObject>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0BFED0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::P73BaseDeliveryObject>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t SEUpdaterUtil::SE310SImage4Signer::getSigningAlgorithm(SEUpdaterUtil::SE310SImage4Signer *this)
{
  return 1;
}

_QWORD *SEUpdaterUtil::SE310SImage4Signer::getSigningKey@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SE310SImage4Signer::getSigningKey(void)const::signingKey, (uint64_t)&SEUpdaterUtil::SE310SImage4Signer::getSigningCert(void)const::signingCert, 0xA7uLL);
}

_QWORD *SEUpdaterUtil::SE310SImage4Signer::getSigningCert@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SE310SImage4Signer::getSigningCert(void)const::signingCert, (uint64_t)"N13SEUpdaterUtil18SE310SImage4SignerE", 0x2E0uLL);
}

void SEUpdaterUtil::SE310SImage4Signer::~SE310SImage4Signer(const void **this)
{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
}

{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
  JUMPOUT(0x22078A808);
}

void SEUpdater::P73BaseSEController::~P73BaseSEController(const void **this)
{
  SEUpdaterUtil::SELogObj *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  __int128 v11;

  *this = &off_24E0BFF80;
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v11);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v11);
    v3 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
    if (*((_QWORD *)&v11 + 1))
    {
      v4 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v6 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v7 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v2, (SEUpdaterUtil::SELogObj *)2, 0, 1, "~P73BaseSEController", (SEUpdaterUtil::SELogObj *)"Destroy BaseSEController\n");
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  SEUpdater::SEControllerBase::shutdown(this);
  *this = &unk_24E0C14C8;
  SEUpdater::SEControllerBase::shutdown(this);
}

{
  SEUpdater::P73BaseSEController::~P73BaseSEController(this);
  JUMPOUT(0x22078A808);
}

void sub_21CCA0028(void *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  __clang_call_terminate(a1);
}

uint64_t SEUpdater::P73BaseSEController::initDevice(SEUpdater::P73BaseSEController *this)
{
  uint64_t v2;
  void *exception;
  std::string *v5;
  std::string *v6;
  __int128 v7;
  void *v8;
  void *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  if (*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    v5 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v19, "Assertion: ");
    v6 = std::string::append(v5, "fSeHandle == nullptr");
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    *(_QWORD *)&v11 = *((_QWORD *)&v6->__r_.__value_.__l + 2);
    v10 = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v10);
  }
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v10 = 0u;
  v2 = NfRestoreOpenWithSE();
  *((_QWORD *)this + 1) = v2;
  if (!v2)
  {
    v8 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v19, "Fail to enumerate");
    v9 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v8, &v19, 17, CFSTR("SEUpdaterErrorDomain"));
  }
  return 1;
}

void sub_21CCA01A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;
  int v15;
  uint64_t v16;

  if (a14 < 0)
    operator delete(__p);
  if (*(char *)(v16 - 33) < 0)
  {
    operator delete(*(void **)(v16 - 56));
    if ((v15 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v15)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v14);
  goto LABEL_8;
}

uint64_t SEUpdater::P73BaseSEController::reboot(SEUpdater::P73BaseSEController *this)
{
  SEUpdaterUtil::SELogObj *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *exception;
  std::string *v15;
  __int128 v16;
  void *v17[2];
  char v18;
  void *__p[2];
  char v20;
  std::string v21;
  __int128 v22;
  std::string::size_type v23;

  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v22);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v22);
    v3 = (std::__shared_weak_count *)*((_QWORD *)&v22 + 1);
    if (*((_QWORD *)&v22 + 1))
    {
      v4 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v6 = (std::__shared_weak_count *)off_2553234C8;
  v21.__r_.__value_.__r.__words[0] = (std::string::size_type)v2;
  v21.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v7 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v2, (SEUpdaterUtil::SELogObj *)2, 0, 1, "reboot", (SEUpdaterUtil::SELogObj *)"rebooting\n");
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (!*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v21, "Assertion: ");
    v15 = std::string::append(&v21, "fSeHandle");
    v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v23 = v15->__r_.__value_.__r.__words[2];
    v22 = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v22);
  }
  v11 = NfRestoreToggleSEPower();
  std::string::basic_string[abi:ne180100]<0>(__p, "Failed to toggle SE power off");
  SERestoreInfo::CallAndThrow<NfResult>(v11, (uint64_t)__p);
  if (v20 < 0)
    operator delete(__p[0]);
  v12 = NfRestoreToggleSEPower();
  std::string::basic_string[abi:ne180100]<0>(v17, "Failed to toggle SE power on");
  SERestoreInfo::CallAndThrow<NfResult>(v12, (uint64_t)v17);
  if (v18 < 0)
    operator delete(v17[0]);
  return 1;
}

void sub_21CCA0430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::CallAndThrow<NfResult>(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  void *exception;
  void *v5;

  if ((_DWORD)result)
  {
    v2 = result;
    exception = __cxa_allocate_exception(0x48uLL);
    v5 = (void *)SERestoreInfo::SEException::SEException(exception, a2, v2, CFSTR("libNfRestoreErrorDomain"));
  }
  return result;
}

uint64_t SEUpdater::P73BaseSEController::doRestrictedMode(SEUpdater::P73BaseSEController *this)
{
  uint64_t *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unsigned int v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  BOOL v19;
  int v20;
  SEUpdaterUtil::SELogObj *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unsigned int v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  void *v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  void *v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t *v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  __int128 v58;
  std::__shared_weak_count *v59;
  uint64_t *v60;
  _QWORD *v61;
  std::__shared_weak_count *v62;
  __int128 v63;
  _OWORD v64[2];
  _BYTE v65[22];
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v2 = (uint64_t *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v58);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v58);
    v3 = (std::__shared_weak_count *)*((_QWORD *)&v58 + 1);
    if (*((_QWORD *)&v58 + 1))
    {
      v4 = (unint64_t *)(*((_QWORD *)&v58 + 1) + 8);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v2 = (uint64_t *)off_2553234C0;
  }
  v6 = (std::__shared_weak_count *)off_2553234C8;
  v60 = v2;
  v61 = off_2553234C8;
  if (off_2553234C8)
  {
    v7 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v2, (SEUpdaterUtil::SELogObj *)1, 0, 1, "doRestrictedMode", (SEUpdaterUtil::SELogObj *)"This process may take a long time (~16 min)\n");
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v60, 0x2037uLL);
  v60 = (uint64_t *)&unk_24E0BF828;
  *(_DWORD *)v65 = 20608;
  v65[4] = 8;
  *(_QWORD *)&v65[5] = 0;
  v65[13] = 0;
  SERestoreInfo::CApdu::CApdu(&v58, v65, 0xEuLL, 0);
  *(_QWORD *)&v58 = &off_24E0BFFE8;
  SEUpdater::P73BaseSEController::transceive((uint64_t)this, (uint64_t)&v58, &v60, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  *(_QWORD *)&v58 = &unk_24E0BF880;
  v11 = v59;
  if (v59)
  {
    v12 = (unint64_t *)&v59->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = 0;
  do
  {
    v64[0] = xmmword_21CCD8847;
    *(_QWORD *)((char *)v64 + 14) = 0;
    SERestoreInfo::CApdu::CApdu(&v58, v64, 0x16uLL, 0);
    *(_QWORD *)&v58 = &off_24E0C0030;
    SEUpdater::P73BaseSEController::transceive((uint64_t)this, (uint64_t)&v58, &v60, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    *(_QWORD *)&v58 = &unk_24E0BF880;
    v15 = v59;
    if (v59)
    {
      v16 = (unint64_t *)&v59->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v18 = v61[1];
    if ((unint64_t)(v18 - *v61) >= 2
      && (*(unsigned __int8 *)(v18 - 1) | (*(unsigned __int8 *)(v18 - 2) << 8)) == 0x66A5)
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v47 = off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v58);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v58);
        v48 = (std::__shared_weak_count *)*((_QWORD *)&v58 + 1);
        if (*((_QWORD *)&v58 + 1))
        {
          v49 = (unint64_t *)(*((_QWORD *)&v58 + 1) + 8);
          do
            v50 = __ldaxr(v49);
          while (__stlxr(v50 - 1, v49));
          if (!v50)
          {
            ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
            std::__shared_weak_count::__release_weak(v48);
          }
        }
        v47 = off_2553234C0;
      }
      *(_QWORD *)v65 = v47;
      *(_QWORD *)&v65[8] = off_2553234C8;
      if (off_2553234C8)
      {
        v51 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v52 = __ldxr(v51);
        while (__stxr(v52 + 1, v51));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(*(SEUpdaterUtil::SELogObj **)v65, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doRestrictedMode", (SEUpdaterUtil::SELogObj *)"SE in restricted mode\n");
      v44 = *(std::__shared_weak_count **)&v65[8];
      if (*(_QWORD *)&v65[8])
      {
        v53 = (unint64_t *)(*(_QWORD *)&v65[8] + 8);
        do
          v46 = __ldaxr(v53);
        while (__stlxr(v46 - 1, v53));
LABEL_91:
        if (!v46)
        {
          ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
          std::__shared_weak_count::__release_weak(v44);
        }
      }
      goto LABEL_93;
    }
    v19 = v14++ > 0xC;
  }
  while (!v19);
  (*(void (**)(SEUpdater::P73BaseSEController *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
  v20 = 0;
LABEL_32:
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v58);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v58);
    v22 = (std::__shared_weak_count *)*((_QWORD *)&v58 + 1);
    if (*((_QWORD *)&v58 + 1))
    {
      v23 = (unint64_t *)(*((_QWORD *)&v58 + 1) + 8);
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v25 = (std::__shared_weak_count *)off_2553234C8;
  *(_QWORD *)&v63 = v21;
  *((_QWORD *)&v63 + 1) = off_2553234C8;
  if (off_2553234C8)
  {
    v26 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v21, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doRestrictedMode", (SEUpdaterUtil::SELogObj *)"Loop %u of 31\n", v20);
  if (v25)
  {
    v28 = (unint64_t *)&v25->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  LODWORD(v63) = 20608;
  BYTE4(v63) = 8;
  *(_QWORD *)((char *)&v63 + 5) = 0;
  BYTE13(v63) = 0;
  SERestoreInfo::CApdu::CApdu(&v58, &v63, 0xEuLL, 0);
  *(_QWORD *)&v58 = &off_24E0BFFE8;
  SEUpdater::P73BaseSEController::transceive((uint64_t)this, (uint64_t)&v58, &v60, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  *(_QWORD *)&v58 = &unk_24E0BF880;
  v30 = v59;
  if (v59)
  {
    v31 = (unint64_t *)&v59->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = 0;
  while (1)
  {
    *(_OWORD *)v65 = xmmword_21CCD8847;
    *(_QWORD *)&v65[14] = 0;
    SERestoreInfo::CApdu::CApdu(&v58, v65, 0x16uLL, 0);
    *(_QWORD *)&v58 = &off_24E0C0030;
    SEUpdater::P73BaseSEController::transceive((uint64_t)this, (uint64_t)&v58, &v60, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    *(_QWORD *)&v58 = &unk_24E0BF880;
    v34 = v59;
    if (v59)
    {
      v35 = (unint64_t *)&v59->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
    v37 = v61[1];
    if ((unint64_t)(v37 - *v61) >= 2
      && (*(unsigned __int8 *)(v37 - 1) | (*(unsigned __int8 *)(v37 - 2) << 8)) == 0x66A5)
    {
      break;
    }
    v19 = v33++ > 7;
    if (v19)
    {
      (*(void (**)(SEUpdater::P73BaseSEController *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
      if (++v20 != 31)
        goto LABEL_32;
      goto LABEL_93;
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v38 = off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v58);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v58);
    v39 = (std::__shared_weak_count *)*((_QWORD *)&v58 + 1);
    if (*((_QWORD *)&v58 + 1))
    {
      v40 = (unint64_t *)(*((_QWORD *)&v58 + 1) + 8);
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
    v38 = off_2553234C0;
  }
  *(_QWORD *)v65 = v38;
  *(_QWORD *)&v65[8] = off_2553234C8;
  if (off_2553234C8)
  {
    v42 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v43 = __ldxr(v42);
    while (__stxr(v43 + 1, v42));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(*(SEUpdaterUtil::SELogObj **)v65, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doRestrictedMode", (SEUpdaterUtil::SELogObj *)"SE in restricted mode\n");
  v44 = *(std::__shared_weak_count **)&v65[8];
  if (*(_QWORD *)&v65[8])
  {
    v45 = (unint64_t *)(*(_QWORD *)&v65[8] + 8);
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    goto LABEL_91;
  }
LABEL_93:
  v60 = (uint64_t *)&unk_24E0BF880;
  v54 = v62;
  if (v62)
  {
    v55 = (unint64_t *)&v62->__shared_owners_;
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }
  return 0;
}

void sub_21CCA0DDC(_Unwind_Exception *a1)
{
  uint64_t v2;

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v2);
  _Unwind_Resume(a1);
}

void sub_21CCA0F40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  JUMPOUT(0x21CCA0F5CLL);
}

void sub_21CCA1020(_Unwind_Exception *a1)
{
  uint64_t v2;

  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  __cxa_end_catch();
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v2);
  _Unwind_Resume(a1);
}

uint64_t SEUpdater::P73BaseSEController::transceive(uint64_t a1, uint64_t a2, uint64_t **a3, int a4, SEUpdaterUtil::SELogObj *a5, int a6)
{
  uint64_t *v12;
  unint64_t v13;
  SEUpdaterUtil::SELogObj *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  SEUpdaterUtil::SELogObj *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v35;
  __int128 v36;

  v12 = a3[1];
  v13 = v12[2] - *v12;
  LOBYTE(v36) = 0;
  std::vector<unsigned char>::assign((char **)v12, v13, (char *)&v36);
  v35 = a3[1][1] - *a3[1];
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v14 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v36);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v36);
    v15 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
    if (*((_QWORD *)&v36 + 1))
    {
      v16 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v14 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v18 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v19 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v14, a5, 0, 1, "transceive", (SEUpdaterUtil::SELogObj *)"Transmitting C-APDU %d: %zu\n", a4, *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8) - **(_QWORD **)(a2 + 8));
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  if (*(_QWORD *)(*(_QWORD *)(a2 + 8) + 8) - **(_QWORD **)(a2 + 8) >= 5uLL)
    v23 = 5;
  else
    v23 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8) - **(_QWORD **)(a2 + 8);
  SEUpdaterUtil::SELogPrintBinary(a5, *(_QWORD *)(a2 + 24), (const unsigned __int8 *)v23, 0);
  SERestoreInfo::CApdu::validate((_QWORD *)a2);
  if (*(_QWORD *)(a2 + 40))
  {
    SERestoreInfo::CApdu::validate((_QWORD *)a2);
    if (*(_QWORD *)(a2 + 32))
    {
      SERestoreInfo::CApdu::validate((_QWORD *)a2);
      v24 = *(_QWORD *)(a2 + 32);
      SERestoreInfo::CApdu::validate((_QWORD *)a2);
      SEUpdaterUtil::SELogPrintBinary(a5, v24, *(const unsigned __int8 **)(a2 + 40), 1);
    }
  }
  SEUpdater::P73BaseSEController::transceiveInternal(*(_QWORD *)(a1 + 8));
  ((void (*)(uint64_t **, uint64_t))(*a3)[2])(a3, v35);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v25 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v36);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v36);
    v26 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
    if (*((_QWORD *)&v36 + 1))
    {
      v27 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v25 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v29 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v30 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v25, a5, 0, 1, "transceive", (SEUpdaterUtil::SELogObj *)"Receiving R-APDU %d: %zu\n", a4, a3[1][1] - *a3[1]);
  if (v29)
  {
    v32 = (unint64_t *)&v29->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  SEUpdaterUtil::SELogPrintBinary(a5, *a3[1], (const unsigned __int8 *)(a3[1][1] - *a3[1]), a6);
  return 0;
}

void sub_21CCA139C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

_QWORD *SEUpdater::P73BaseSEController::doRestrictedMode(void)::FakeInitializeUpdate::~FakeInitializeUpdate(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

_QWORD *SEUpdater::P73BaseSEController::doRestrictedMode(void)::FakeExternalAuthenticate::~FakeExternalAuthenticate(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

uint64_t SEUpdater::P73BaseSEController::transceive(SEUpdater::P73BaseSEController *this, const unsigned __int8 *a2, const unsigned __int8 *a3, unsigned __int8 *a4, unint64_t *a5, SEUpdaterUtil::SELogObj *a6, int a7)
{
  int v13;
  SEUpdaterUtil::SELogObj *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  int v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  SEUpdaterUtil::SELogObj *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  int v34;
  __int128 v35;

  v34 = a7;
  v13 = *((unsigned __int8 *)this + 16);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v14 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v35);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v35);
    v15 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
    if (*((_QWORD *)&v35 + 1))
    {
      v16 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v14 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v18 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v19 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v21 = 2 * v13;
  SEUpdaterUtil::SELogObj::printLog(v14, a6, 0, 1, "transceive", (SEUpdaterUtil::SELogObj *)"Transmitting C-APDU %d: %zu\n", v21, (size_t)a3);
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  SEUpdaterUtil::SELogPrintBinary(a6, (uint64_t)a2, a3, v34);
  SEUpdater::P73BaseSEController::transceiveInternal(*((_QWORD *)this + 1));
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v24 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v35);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v35);
    v25 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
    if (*((_QWORD *)&v35 + 1))
    {
      v26 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    v24 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v28 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v29 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v24, a6, 0, 1, "transceive", (SEUpdaterUtil::SELogObj *)"Receiving R-APDU %d: %zu\n", v21, *a5);
  if (v28)
  {
    v31 = (unint64_t *)&v28->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  SEUpdaterUtil::SELogPrintBinary(a6, (uint64_t)a4, (const unsigned __int8 *)*a5, v34);
  return 0;
}

void sub_21CCA16D8(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

void SEUpdater::P73BaseSEController::transceiveInternal(uint64_t a1)
{
  uint64_t v1;
  void *exception;
  std::string *v3;
  __int128 v4;
  void *__p[2];
  char v6;
  std::string v7;
  __int128 v8;
  std::string::size_type v9;

  if (!a1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v7, "Assertion: ");
    v3 = std::string::append(&v7, "fSeHandle");
    v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
    v9 = v3->__r_.__value_.__r.__words[2];
    v8 = v4;
    v3->__r_.__value_.__l.__size_ = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
    v3->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v8);
  }
  v1 = NfRestoreSETransceiveToOS();
  std::string::basic_string[abi:ne180100]<0>(__p, "Fail to NfRestoreSETransceive");
  SERestoreInfo::CallAndThrow<NfResult>(v1, (uint64_t)__p);
  if (v6 < 0)
    operator delete(__p[0]);
}

void sub_21CCA185C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SEUpdater::P73BaseSEController::transceive(SEUpdater::P73BaseSEController *this, const SERestoreInfo::CApdu *a2, uint64_t **a3, SEUpdaterUtil::SELogObj *a4, int a5)
{
  SEUpdater::P73BaseSEController::transceive((uint64_t)this, (uint64_t)a2, a3, 2 * *((unsigned __int8 *)this + 16), a4, a5);
  return 0;
}

uint64_t SEUpdater::P73BaseSEController::transceiveInternal(SEUpdater::P73BaseSEController *this, const unsigned __int8 *a2, unint64_t a3, unsigned __int8 *a4, unint64_t *a5)
{
  SEUpdater::P73BaseSEController::transceiveInternal(*((_QWORD *)this + 1));
  return 0;
}

void SEUpdater::P73BaseSEController::doRestrictedMode(void)::FakeInitializeUpdate::~FakeInitializeUpdate(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x22078A808);
}

void SEUpdater::P73BaseSEController::doRestrictedMode(void)::FakeExternalAuthenticate::~FakeExternalAuthenticate(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x22078A808);
}

SEUpdater::P73BaseUpdateController *SEUpdater::P73BaseUpdateController::P73BaseUpdateController(SEUpdater::P73BaseUpdateController *this, char a2)
{
  SEUpdater::UpdateControllerBase *updated;
  _QWORD *v5;
  uint64_t (*v6)(uint64_t);
  void *exception;
  std::string *v9;
  __int128 v10;
  void *v11;
  std::string *v12;
  __int128 v13;
  std::string v14;
  __int128 v15;
  std::string::size_type v16;

  updated = SEUpdater::UpdateControllerBase::UpdateControllerBase(this);
  *((_OWORD *)updated + 8) = 0u;
  *((_OWORD *)updated + 10) = 0u;
  *(_QWORD *)updated = &off_24E0C0078;
  *((_OWORD *)updated + 9) = 0u;
  *((_OWORD *)updated + 11) = 0u;
  *((_OWORD *)updated + 12) = 0u;
  *((_OWORD *)updated + 13) = 0u;
  *((_BYTE *)updated + 224) = 0;
  v5 = operator new(0x30uLL);
  v5[2] = 0;
  *v5 = &unk_24E0C0DB0;
  v5[1] = 0;
  v5[4] = 0;
  v5[3] = &off_24E0BFF80;
  *((_BYTE *)v5 + 40) = a2;
  *((_QWORD *)this + 20) = v5 + 3;
  *((_QWORD *)this + 21) = v5;
  if (*((_BYTE *)this + 80))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v14, "Assertion: ");
    v9 = std::string::append(&v14, "!fIsDone");
    v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v16 = v9->__r_.__value_.__r.__words[2];
    v15 = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v15);
  }
  if (*((_QWORD *)this + 14))
    v6 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  else
    v6 = 0;
  if (!v6)
  {
    v11 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v14, "Assertion: ");
    v12 = std::string::append(&v14, "fOutput");
    v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v16 = v12->__r_.__value_.__r.__words[2];
    v15 = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v11, &v15);
  }
  return this;
}

void sub_21CCA1B5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  if (*(char *)(v21 + 223) < 0)
    operator delete(*(void **)(v21 + 200));
  if (*(char *)(v21 + 199) < 0)
    operator delete(*(void **)(v21 + 176));
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v23);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v21 + 144);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v22);
  SEUpdater::UpdateControllerBase::~UpdateControllerBase((const void **)v21);
  _Unwind_Resume(a1);
}

void SEUpdater::UpdateControllerBase::~UpdateControllerBase(const void **this)
{
  *this = &unk_24E0C1210;
  ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef(this + 15);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 14);
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)(this + 11), this[12]);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 9);
  std::__optional_destruct_base<AlohaPairingOptions,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)(this + 2));
}

void SEUpdater::P73BaseUpdateController::~P73BaseUpdateController(void **this)
{
  SEUpdaterUtil::SELogObj *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  __int128 v11;

  *this = &off_24E0C0078;
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v11);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v11);
    v3 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
    if (*((_QWORD *)&v11 + 1))
    {
      v4 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v6 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v7 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v2, 0, 0, 1, "~P73BaseUpdateController", (SEUpdaterUtil::SELogObj *)"Destroying Update Controller\n");
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (*((char *)this + 223) < 0)
    operator delete(this[25]);
  if (*((char *)this + 199) < 0)
    operator delete(this[22]);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(this + 20));
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(this + 18));
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(this + 16));
  SEUpdater::UpdateControllerBase::~UpdateControllerBase((const void **)this);
}

{
  SEUpdater::P73BaseUpdateController::~P73BaseUpdateController(this);
  JUMPOUT(0x22078A808);
}

void sub_21CCA1DCC(void *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  __clang_call_terminate(a1);
}

uint64_t SEUpdater::P73BaseUpdateController::doStart(SEUpdater::P73BaseUpdateController *this)
{
  void **v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t **v5;
  void **v6;
  uint64_t **v7;
  uint64_t **v8;
  BOOL v9;
  _BOOL4 v10;
  uint64_t **v11;
  uint64_t **v12;
  const void **v13;
  uint64_t *v14;
  std::string *v15;
  uint64_t i;
  uint64_t *v17;
  uint64_t **v18;
  uint64_t **v19;
  const void **v20;
  _BOOL4 v21;
  uint64_t *v22;
  const void **v23;
  SEUpdaterUtil::SELogObj *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  const char *v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  SEUpdaterUtil::SELogObj *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  const char *v41;
  unint64_t *v42;
  unint64_t v43;
  char *v44;
  char *v45;
  char *v46;
  _BOOL4 v47;
  char **v48;
  const char *v49;
  SEUpdaterUtil::SELogObj *v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  void *exception;
  void *v61;
  SEUpdater::P73BaseUpdateController *v62;
  SEUpdaterUtil::SELogObj *v63;
  uint64_t *v64;
  uint64_t v65;
  void *__p[2];
  uint64_t v67;
  uint64_t v68[3];
  uint64_t v69[3];
  _QWORD v70[5];

  v70[3] = *MEMORY[0x24BDAC8D0];
  SEUpdater::UpdateControllerBase::parseStartOptions(this);
  SEUpdater::UpdateControllerBase::getStringfromOption((CFDictionaryRef *)this, __p);
  v2 = (void **)((char *)this + 176);
  if (*((char *)this + 199) < 0)
    operator delete(*v2);
  *(_OWORD *)v2 = *(_OWORD *)__p;
  *((_QWORD *)this + 24) = v67;
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)&unk_21CCDB9F7);
  v62 = this;
  std::string::basic_string[abi:ne180100]<0>(v68, "Default");
  std::string::basic_string[abi:ne180100]<0>(v69, "Force");
  std::string::basic_string[abi:ne180100]<0>(v70, "Skip");
  v3 = 0;
  v4 = 0;
  v64 = 0;
  v65 = 0;
  v63 = (SEUpdaterUtil::SELogObj *)&v64;
  v5 = &v64;
  while (1)
  {
    v6 = &__p[3 * v4];
    if (v5 == &v64)
    {
      v8 = &v64;
    }
    else
    {
      v7 = &v64;
      if (v3)
      {
        do
        {
          v8 = (uint64_t **)v3;
          v3 = (uint64_t *)v3[1];
        }
        while (v3);
      }
      else
      {
        do
        {
          v8 = (uint64_t **)v7[2];
          v9 = *v8 == (uint64_t *)v7;
          v7 = v8;
        }
        while (v9);
      }
      v10 = std::less<std::string>::operator()[abi:ne180100]((uint64_t)&v65, (const void **)v8 + 4, (const void **)&__p[3 * v4]);
      v3 = v64;
      if (!v10)
      {
        v11 = &v64;
        v12 = &v64;
        if (v64)
        {
          v12 = &v64;
          while (1)
          {
            while (1)
            {
              v11 = (uint64_t **)v3;
              v13 = (const void **)(v3 + 4);
              if (!std::less<std::string>::operator()[abi:ne180100]((uint64_t)&v65, (const void **)&__p[3 * v4], (const void **)v3 + 4))break;
              v3 = *v11;
              v12 = v11;
              if (!*v11)
                goto LABEL_22;
            }
            if (!std::less<std::string>::operator()[abi:ne180100]((uint64_t)&v65, v13, (const void **)&__p[3 * v4]))
              break;
            v12 = v11 + 1;
            v3 = v11[1];
            if (!v3)
              goto LABEL_22;
          }
LABEL_21:
          if (*v12)
            goto LABEL_28;
          goto LABEL_22;
        }
        goto LABEL_22;
      }
    }
    v11 = &v64;
    v12 = &v64;
    if (v3)
    {
      v12 = v8 + 1;
      v11 = v8;
      goto LABEL_21;
    }
LABEL_22:
    v14 = (uint64_t *)operator new(0x38uLL);
    v15 = (std::string *)(v14 + 4);
    if (*((char *)v6 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v15, (const std::string::value_type *)*v6, (std::string::size_type)v6[1]);
    }
    else
    {
      *(_OWORD *)&v15->__r_.__value_.__l.__data_ = *(_OWORD *)v6;
      v14[6] = (uint64_t)v6[2];
    }
    *v14 = 0;
    v14[1] = 0;
    v14[2] = (uint64_t)v11;
    *v12 = v14;
    if (*(_QWORD *)v63)
    {
      v63 = *(SEUpdaterUtil::SELogObj **)v63;
      v14 = *v12;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v64, v14);
    ++v65;
LABEL_28:
    if (++v4 == 4)
      break;
    v5 = (uint64_t **)v63;
    v3 = v64;
  }
  for (i = 0; i != -12; i -= 3)
  {
    if (SHIBYTE(v70[i + 2]) < 0)
      operator delete((void *)v70[i]);
  }
  v17 = v64;
  if (!v64)
    goto LABEL_112;
  v18 = &v64;
  do
  {
    v19 = v18;
    v20 = (const void **)(v17 + 4);
    v21 = std::less<std::string>::operator()[abi:ne180100]((uint64_t)&v65, (const void **)v17 + 4, (const void **)v2);
    if (v21)
      v22 = v17 + 1;
    else
      v22 = v17;
    if (v21)
      v18 = v19;
    else
      v18 = (uint64_t **)v17;
    v17 = (uint64_t *)*v22;
  }
  while (*v22);
  if (v18 == &v64
    || (!v21 ? (v23 = v20) : (v23 = (const void **)(v19 + 4)),
        std::less<std::string>::operator()[abi:ne180100]((uint64_t)&v65, (const void **)v2, v23)))
  {
LABEL_112:
    exception = __cxa_allocate_exception(0x48uLL);
    std::operator+<char>();
    v61 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, (__int128 *)__p, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v24 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v25 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v26 = (unint64_t *)((char *)__p[1] + 8);
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    v24 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v28 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v29 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v31 = (const char *)v2;
  if (*((char *)v62 + 199) < 0)
    v31 = (const char *)*v2;
  SEUpdaterUtil::SELogObj::printLog(v24, (SEUpdaterUtil::SELogObj *)2, 0, 1, "parseStartOptions", (SEUpdaterUtil::SELogObj *)"SE Health Test Policy: %s\n", v31);
  if (v28)
  {
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    do
      v33 = __ldaxr(p_shared_owners);
    while (__stlxr(v33 - 1, p_shared_owners));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  *((_BYTE *)v62 + 224) = SEUpdater::UpdateControllerBase::getBooleanOption((CFDictionaryRef *)v62, CFSTR("performFactoryConfiguration"), 0);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v34 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v35 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v36 = (unint64_t *)((char *)__p[1] + 8);
      do
        v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
    v34 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v38 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v39 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v40 = __ldxr(v39);
    while (__stxr(v40 + 1, v39));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  if (*((_BYTE *)v62 + 224))
    v41 = "YES";
  else
    v41 = "NO";
  SEUpdaterUtil::SELogObj::printLog(v34, (SEUpdaterUtil::SELogObj *)2, 0, 1, "parseStartOptions", (SEUpdaterUtil::SELogObj *)"Perform Factory Postflight requested? %s\n", v41);
  if (v38)
  {
    v42 = (unint64_t *)&v38->__shared_owners_;
    do
      v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "dumpSE");
  v44 = (char *)v62 + 96;
  v45 = (char *)*((_QWORD *)v62 + 12);
  if (!v45)
    goto LABEL_90;
  v46 = (char *)v62 + 96;
  do
  {
    v47 = std::less<std::string>::operator()[abi:ne180100]((uint64_t)v62 + 104, (const void **)v45 + 4, (const void **)__p);
    v48 = (char **)(v45 + 8);
    if (!v47)
    {
      v48 = (char **)v45;
      v46 = v45;
    }
    v45 = *v48;
  }
  while (*v48);
  if (v46 == v44
    || std::less<std::string>::operator()[abi:ne180100]((uint64_t)v62 + 104, (const void **)__p, (const void **)v46 + 4))
  {
LABEL_90:
    v46 = (char *)v62 + 96;
  }
  if (SHIBYTE(v67) < 0)
    operator delete(__p[0]);
  if (v44 != v46)
  {
    v49 = (char *)v62 + 200;
    std::string::operator=((std::string *)((char *)v62 + 200), (const std::string *)(v46 + 56));
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v50 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v51 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v52 = (unint64_t *)((char *)__p[1] + 8);
        do
          v53 = __ldaxr(v52);
        while (__stlxr(v53 - 1, v52));
        if (!v53)
        {
          ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
          std::__shared_weak_count::__release_weak(v51);
        }
      }
      v50 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v54 = (std::__shared_weak_count *)off_2553234C8;
    if (off_2553234C8)
    {
      v55 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v56 = __ldxr(v55);
      while (__stxr(v56 + 1, v55));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    if (*((char *)v62 + 223) < 0)
      v49 = *(const char **)v49;
    SEUpdaterUtil::SELogObj::printLog(v50, (SEUpdaterUtil::SELogObj *)2, 0, 1, "parseStartOptions", (SEUpdaterUtil::SELogObj *)"Will dump SE to file --> %s\n", v49);
    if (v54)
    {
      v57 = (unint64_t *)&v54->__shared_owners_;
      do
        v58 = __ldaxr(v57);
      while (__stlxr(v58 - 1, v57));
      if (!v58)
      {
        ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
        std::__shared_weak_count::__release_weak(v54);
      }
    }
  }
  std::__tree<std::string>::destroy((char *)v64);
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)v62 + 20) + 40))(*((_QWORD *)v62 + 20), 0);
  SEUpdater::P73BaseUpdateController::doQuery(v62);
  SEUpdater::P73BaseUpdateController::printManifest(v62);
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)v62 + 16) + 32))(*((_QWORD *)v62 + 16));
}

void sub_21CCA2868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_21CCA2938(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  std::__tree<std::string>::destroy(a15);
  JUMPOUT(0x21CCA2A08);
}

void sub_21CCA2948(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void sub_21CCA2958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char *a15)
{
  std::__tree<std::string>::destroy(a15);
  _Unwind_Resume(a1);
}

void sub_21CCA2960(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21CCA296C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char *a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0)
    operator delete(__p);
  std::__tree<std::string>::destroy(a15);
  JUMPOUT(0x21CCA2A08);
}

void sub_21CCA2984()
{
  void *v0;

  __cxa_free_exception(v0);
  JUMPOUT(0x21CCA2990);
}

void sub_21CCA299C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  void **v17;

  while (1)
  {
    if (*((char *)v17 - 1) < 0)
      operator delete(*(v17 - 3));
    v17 -= 3;
    if (v17 == (void **)&a17)
      _Unwind_Resume(a1);
  }
}

void sub_21CCA29C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char *a15, uint64_t a16, char a17)
{
  void *v17;
  uint64_t v18;

  operator delete(v17);
  std::__tree<std::string>::destroy(a15);
  v18 = 0;
  while (1)
  {
    if (*(&a17 + v18 + 95) < 0)
      operator delete(*(void **)(&a17 + v18 + 72));
    v18 -= 24;
    if (v18 == -96)
      JUMPOUT(0x21CCA2A08);
  }
}

void SEUpdater::P73BaseUpdateController::doQuery(SEUpdater::P73BaseUpdateController *this)
{
  CFMutableDictionaryRef Dict;
  std::string::size_type v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  void *exception;
  std::string *v8;
  __int128 v9;
  std::string v10;
  __int128 v11;
  std::__shared_weak_count *v12;

  if (!*((_QWORD *)this + 20))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v10, "Assertion: ");
    v8 = std::string::append(&v10, "fSeController");
    v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v12 = (std::__shared_weak_count *)v8->__r_.__value_.__r.__words[2];
    v11 = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v11);
  }
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v11, 0x2037uLL);
  *(_QWORD *)&v11 = &unk_24E0BF828;
  SEUpdater::P73BaseUpdateController::sendManifestQuery(this);
  Dict = SERestoreInfo::SEDeviceInfo::createDict(*((SERestoreInfo::SEDeviceInfo **)this + 16), 0);
  v3 = *((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = Dict;
  v10.__r_.__value_.__r.__words[0] = v3;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)&v10.__r_.__value_.__l.__data_);
  *(_QWORD *)&v11 = &unk_24E0BF880;
  v4 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_21CCA2B44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void SEUpdaterUtil::SELogObj::dumpLogBuffer(SEUpdaterUtil::SELogObj *this)
{
  NSObject *v2;
  char *v3;
  char *v4;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  __n128 (*v9)(_QWORD *, uint64_t);
  void (*v10)(uint64_t);
  void *__p[3];
  _QWORD *v12;
  const char *block[7];

  block[6] = *(const char **)MEMORY[0x24BDAC8D0];
  v6 = 0;
  v7 = &v6;
  v8 = 0x4002000000;
  v9 = __Block_byref_object_copy__2;
  v10 = __Block_byref_object_dispose__2;
  std::vector<unsigned char>::vector(__p, 0xF001uLL);
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 0x40000000;
  v5[2] = ___ZN13SEUpdaterUtil8SELogObj13dumpLogBufferEv_block_invoke;
  v5[3] = &unk_24E0C00D8;
  v5[4] = &v6;
  v5[5] = this;
  v12 = v5;
  block[0] = (const char *)MEMORY[0x24BDAC760];
  block[1] = (const char *)0x40000000;
  block[2] = (const char *)___ZNK3ctu20SharedSynchronizableIN13SEUpdaterUtil8SELogObjEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke;
  block[3] = (const char *)&__block_descriptor_tmp_266;
  block[4] = (const char *)this;
  block[5] = (const char *)&v12;
  v2 = *((_QWORD *)this + 2);
  if (*((_QWORD *)this + 3))
    dispatch_async_and_wait(v2, block);
  else
    dispatch_sync(v2, block);
  SEUpdaterUtil::SELogObj::print(this, "********************************************************************************\n");
  SEUpdaterUtil::SELogObj::print(this, "Start of LogBuffer\n");
  SEUpdaterUtil::SELogObj::print(this, "********************************************************************************\n");
  v3 = strtok((char *)v7[5], "\n");
  if (v3)
  {
    v4 = v3;
    do
    {
      SEUpdaterUtil::SELogObj::FormatMsg((SEUpdaterUtil::SELogObj *)"%s\n", block, v4);
      SEUpdaterUtil::SELogObj::print(this, block[0]);
      v4 = strtok(0, "\n");
      std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100]((uint64_t *)block);
    }
    while (v4);
  }
  SEUpdaterUtil::SELogObj::print(this, "********************************************************************************\n");
  SEUpdaterUtil::SELogObj::print(this, "End of LogBuffer\n");
  SEUpdaterUtil::SELogObj::print(this, "********************************************************************************\n");
  _Block_object_dispose(&v6, 8);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_21CCA2DA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  _Unwind_Resume(exception_object);
}

void SEUpdater::P73BaseUpdateController::dumpDebugInfo(SEUpdater::P73BaseUpdateController *this)
{
  unint64_t *p_shared_owners;
  unint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  SEUpdaterUtil::SELogObj *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  int v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  SEUpdaterUtil::SELogObj *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  SEUpdaterUtil::SELogObj *v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  SEUpdaterUtil::SELogObj *v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t *v56;
  unint64_t v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  SEUpdaterUtil::SELogObj *v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  uint64_t v75;
  SEUpdaterUtil::SELogObj *v76;
  std::__shared_weak_count *v77;
  unint64_t *v78;
  unint64_t v79;
  std::__shared_weak_count *v80;
  unint64_t *v81;
  unint64_t v82;
  unint64_t *v83;
  unint64_t v84;
  uint64_t v85;
  void (**v86)(SEUpdater::CommandGetAllLogs *__hidden);
  uint64_t v87;
  uint64_t v88;
  std::__shared_weak_count *v89;
  unint64_t *v90;
  unint64_t v91;
  std::__shared_weak_count *v92;
  unint64_t *v93;
  unint64_t v94;
  uint64_t v95;
  std::__shared_weak_count *v96;
  unint64_t *v97;
  unint64_t v98;
  unint64_t *v99;
  SEUpdaterUtil::SELogObj *v100;
  std::__shared_weak_count *v101;
  unint64_t *v102;
  unint64_t v103;
  std::__shared_weak_count *v104;
  unint64_t *v105;
  unint64_t v106;
  unint64_t *v107;
  unint64_t v108;
  uint64_t v109;
  std::__shared_weak_count *v110;
  unint64_t *v111;
  unint64_t v112;
  uint64_t v113;
  std::__shared_weak_count *v114;
  unint64_t *v115;
  unint64_t v116;
  std::__shared_weak_count *v117;
  unint64_t *v118;
  unint64_t v119;
  __int128 v120;
  std::__shared_weak_count *v121;
  __int128 v122;
  __int128 v123;
  _QWORD v124[2];
  std::__shared_weak_count *v125;
  __int128 v126;
  __int128 v127;
  uint64_t v128;
  void *v129;
  __int128 v130;
  std::__shared_weak_count *v131;
  uint64_t v132;

  v132 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 20) + 48))(*((_QWORD *)this + 20), 0);
  v130 = xmmword_21CCD8B2B;
  LOWORD(v131) = 0;
  SERestoreInfo::CApdu::CApdu(&v120, &v130, 0x12uLL, 37);
  v124[1] = *((_QWORD *)&v120 + 1);
  v125 = v121;
  if (v121)
  {
    p_shared_owners = (unint64_t *)&v121->__shared_owners_;
    do
      v3 = __ldxr(p_shared_owners);
    while (__stxr(v3 + 1, p_shared_owners));
    v4 = v121;
    v124[0] = &unk_24E0BF960;
    v126 = v122;
    v127 = v123;
    *(_QWORD *)&v120 = &unk_24E0BF880;
    if (v121)
    {
      v5 = (unint64_t *)&v121->__shared_owners_;
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  else
  {
    v124[0] = &unk_24E0BF960;
    v126 = v122;
    v127 = v123;
  }
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v130, 0x2037uLL);
  *(_QWORD *)&v130 = &unk_24E0BF828;
  (*(void (**)(_QWORD, _QWORD *, __int128 *, uint64_t, _QWORD))(**((_QWORD **)this + 20) + 16))(*((_QWORD *)this + 20), v124, &v130, 2, 0);
  v7 = *((_QWORD *)this + 20);
  v8 = **((_QWORD **)&v130 + 1);
  v9 = *(_QWORD *)(*((_QWORD *)&v130 + 1) + 8);
  if (!*(_BYTE *)(v7 + 16))
  {
    if ((unint64_t)(v9 - v8) < 2
      || (*(unsigned __int8 *)(v9 - 1) | (*(unsigned __int8 *)(v9 - 2) << 8)) != 0x9000)
    {
      goto LABEL_33;
    }
    goto LABEL_29;
  }
  if ((unint64_t)(v9 - v8) < 2
    || v9 - **((_QWORD **)&v130 + 1) != 37
    || (*(unsigned __int8 *)(v9 - 1) | (*(unsigned __int8 *)(v8 + 35) << 8)) != 0x9000)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v10 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v120);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v120);
      v11 = (std::__shared_weak_count *)*((_QWORD *)&v120 + 1);
      if (*((_QWORD *)&v120 + 1))
      {
        v12 = (unint64_t *)(*((_QWORD *)&v120 + 1) + 8);
        do
          v13 = __ldaxr(v12);
        while (__stlxr(v13 - 1, v12));
        if (!v13)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
      v10 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v14 = (std::__shared_weak_count *)off_2553234C8;
    v128 = (uint64_t)v10;
    v129 = off_2553234C8;
    if (off_2553234C8)
    {
      v15 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v10, (SEUpdaterUtil::SELogObj *)1, 0, 1, "dumpDebugInfo", (SEUpdaterUtil::SELogObj *)"Failed to select OSU\n");
    if (v14)
    {
      v17 = (unint64_t *)&v14->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    goto LABEL_29;
  }
  if ((*(_BYTE *)(v8 + 12) & 1) == 0)
  {
LABEL_29:
    v19 = 0;
    goto LABEL_39;
  }
LABEL_33:
  SEUpdater::CommandSelectISD::CommandSelectISD((SEUpdater::CommandSelectISD *)&v120);
  SEUpdater::P73BaseSEController::transceive(v7, (uint64_t)&v120, (uint64_t **)&v130, 0, (SEUpdaterUtil::SELogObj *)2, 0);
  *(_QWORD *)&v120 = &unk_24E0BF880;
  v20 = v121;
  if (v121)
  {
    v21 = (unint64_t *)&v121->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v19 = 1;
LABEL_39:
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v23 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v120);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v120);
    v24 = (std::__shared_weak_count *)*((_QWORD *)&v120 + 1);
    if (*((_QWORD *)&v120 + 1))
    {
      v25 = (unint64_t *)(*((_QWORD *)&v120 + 1) + 8);
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    v23 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v27 = (std::__shared_weak_count *)off_2553234C8;
  v128 = (uint64_t)v23;
  v129 = off_2553234C8;
  if (off_2553234C8)
  {
    v28 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v23, (SEUpdaterUtil::SELogObj *)2, 0, 1, "dumpDebugInfo", (SEUpdaterUtil::SELogObj *)"Dumping manifest query\n");
  if (v27)
  {
    v30 = (unint64_t *)&v27->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  v32 = *((_QWORD *)this + 20);
  v128 = 0x3FFF02FE00CA80;
  SERestoreInfo::CApdu::CApdu(&v120, &v128, 8uLL, 0);
  *(_QWORD *)&v120 = &off_24E0C01E0;
  (*(void (**)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))(*(_QWORD *)v32 + 16))(v32, &v120, &v130, 2, 1);
  *(_QWORD *)&v120 = &unk_24E0BF880;
  v33 = v121;
  if (v121)
  {
    v34 = (unint64_t *)&v121->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  SEUpdater::P73BaseUpdateController::printManifest(this);
  if (!*(_BYTE *)(*((_QWORD *)this + 20) + 16))
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v100 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v120);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v120);
      v101 = (std::__shared_weak_count *)*((_QWORD *)&v120 + 1);
      if (*((_QWORD *)&v120 + 1))
      {
        v102 = (unint64_t *)(*((_QWORD *)&v120 + 1) + 8);
        do
          v103 = __ldaxr(v102);
        while (__stlxr(v103 - 1, v102));
        if (!v103)
        {
          ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
          std::__shared_weak_count::__release_weak(v101);
        }
      }
      v100 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v104 = (std::__shared_weak_count *)off_2553234C8;
    v128 = (uint64_t)v100;
    v129 = off_2553234C8;
    if (off_2553234C8)
    {
      v105 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v106 = __ldxr(v105);
      while (__stxr(v106 + 1, v105));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v100, (SEUpdaterUtil::SELogObj *)2, 0, 1, "dumpDebugInfo", (SEUpdaterUtil::SELogObj *)"Dumping OSU\n");
    if (v104)
    {
      v107 = (unint64_t *)&v104->__shared_owners_;
      do
        v108 = __ldaxr(v107);
      while (__stlxr(v108 - 1, v107));
      if (!v108)
      {
        ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
        std::__shared_weak_count::__release_weak(v104);
      }
    }
    v109 = *((_QWORD *)this + 20);
    v128 = 0x29DF02FE00CA80;
    SERestoreInfo::CApdu::CApdu(&v120, &v128, 8uLL, 0);
    *(_QWORD *)&v120 = &off_24E0C06F0;
    (*(void (**)(uint64_t, __int128 *, __int128 *, uint64_t, _QWORD))(*(_QWORD *)v109 + 16))(v109, &v120, &v130, 2, 0);
    *(_QWORD *)&v120 = &unk_24E0BF880;
    v110 = v121;
    if (v121)
    {
      v111 = (unint64_t *)&v121->__shared_owners_;
      do
        v112 = __ldaxr(v111);
      while (__stlxr(v112 - 1, v111));
      if (!v112)
      {
        ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
        std::__shared_weak_count::__release_weak(v110);
      }
    }
  }
  if (v19)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v36 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v120);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v120);
      v37 = (std::__shared_weak_count *)*((_QWORD *)&v120 + 1);
      if (*((_QWORD *)&v120 + 1))
      {
        v38 = (unint64_t *)(*((_QWORD *)&v120 + 1) + 8);
        do
          v39 = __ldaxr(v38);
        while (__stlxr(v39 - 1, v38));
        if (!v39)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }
      v36 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v40 = (std::__shared_weak_count *)off_2553234C8;
    v128 = (uint64_t)v36;
    v129 = off_2553234C8;
    if (off_2553234C8)
    {
      v41 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v42 = __ldxr(v41);
      while (__stxr(v42 + 1, v41));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v36, (SEUpdaterUtil::SELogObj *)2, 0, 1, "dumpDebugInfo", (SEUpdaterUtil::SELogObj *)"Dumping AM Info\n");
    if (v40)
    {
      v43 = (unint64_t *)&v40->__shared_owners_;
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }
    v45 = *((_QWORD *)this + 20);
    LODWORD(v128) = 174720;
    BYTE4(v128) = 0;
    SERestoreInfo::CApdu::CApdu(&v120, &v128, 5uLL, 0);
    *(_QWORD *)&v120 = &off_24E0C0198;
    SEUpdater::P73BaseSEController::transceive(v45, (uint64_t)&v120, (uint64_t **)&v130, 0, (SEUpdaterUtil::SELogObj *)2, 0);
    *(_QWORD *)&v120 = &unk_24E0BF880;
    v46 = v121;
    if (v121)
    {
      v47 = (unint64_t *)&v121->__shared_owners_;
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v49 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v120);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v120);
      v50 = (std::__shared_weak_count *)*((_QWORD *)&v120 + 1);
      if (*((_QWORD *)&v120 + 1))
      {
        v51 = (unint64_t *)(*((_QWORD *)&v120 + 1) + 8);
        do
          v52 = __ldaxr(v51);
        while (__stlxr(v52 - 1, v51));
        if (!v52)
        {
          ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
          std::__shared_weak_count::__release_weak(v50);
        }
      }
      v49 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v53 = (std::__shared_weak_count *)off_2553234C8;
    v128 = (uint64_t)v49;
    v129 = off_2553234C8;
    if (off_2553234C8)
    {
      v54 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v55 = __ldxr(v54);
      while (__stxr(v55 + 1, v54));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v49, (SEUpdaterUtil::SELogObj *)2, 0, 1, "dumpDebugInfo", (SEUpdaterUtil::SELogObj *)"Dumping platform identifier\n");
    if (v53)
    {
      v56 = (unint64_t *)&v53->__shared_owners_;
      do
        v57 = __ldaxr(v56);
      while (__stlxr(v57 - 1, v56));
      if (!v57)
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
      }
    }
    v58 = *((_QWORD *)this + 20);
    v128 = 0x20DF02FE00CA80;
    SERestoreInfo::CApdu::CApdu(&v120, &v128, 8uLL, 0);
    *(_QWORD *)&v120 = &off_24E0C0738;
    SEUpdater::P73BaseSEController::transceive(v58, (uint64_t)&v120, (uint64_t **)&v130, 0, (SEUpdaterUtil::SELogObj *)2, 0);
    *(_QWORD *)&v120 = &unk_24E0BF880;
    v59 = v121;
    if (v121)
    {
      v60 = (unint64_t *)&v121->__shared_owners_;
      do
        v61 = __ldaxr(v60);
      while (__stlxr(v61 - 1, v60));
      if (!v61)
      {
        ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
        std::__shared_weak_count::__release_weak(v59);
      }
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v62 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v120);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v120);
    v63 = (std::__shared_weak_count *)*((_QWORD *)&v120 + 1);
    if (*((_QWORD *)&v120 + 1))
    {
      v64 = (unint64_t *)(*((_QWORD *)&v120 + 1) + 8);
      do
        v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
        std::__shared_weak_count::__release_weak(v63);
      }
    }
    v62 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v66 = (std::__shared_weak_count *)off_2553234C8;
  v128 = (uint64_t)v62;
  v129 = off_2553234C8;
  if (off_2553234C8)
  {
    v67 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v68 = __ldxr(v67);
    while (__stxr(v68 + 1, v67));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v62, (SEUpdaterUtil::SELogObj *)2, 0, 1, "dumpDebugInfo", (SEUpdaterUtil::SELogObj *)"Dumping Update Table\n");
  if (v66)
  {
    v69 = (unint64_t *)&v66->__shared_owners_;
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }
  do
  {
    v71 = *((_QWORD *)this + 20);
    v128 = 0x40DF02FE00CA80;
    SERestoreInfo::CApdu::CApdu(&v120, &v128, 8uLL, 0);
    *(_QWORD *)&v120 = &off_24E0C0780;
    (*(void (**)(uint64_t, __int128 *, __int128 *, uint64_t, _QWORD))(*(_QWORD *)v71 + 16))(v71, &v120, &v130, 2, 0);
    *(_QWORD *)&v120 = &unk_24E0BF880;
    v72 = v121;
    if (v121)
    {
      v73 = (unint64_t *)&v121->__shared_owners_;
      do
        v74 = __ldaxr(v73);
      while (__stlxr(v74 - 1, v73));
      if (!v74)
      {
        ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
        std::__shared_weak_count::__release_weak(v72);
      }
    }
    v75 = *(_QWORD *)(*((_QWORD *)&v130 + 1) + 8);
  }
  while ((unint64_t)(v75 - **((_QWORD **)&v130 + 1)) >= 2
       && (*(unsigned __int8 *)(v75 - 1) | (*(unsigned __int8 *)(v75 - 2) << 8)) == 0x6310);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v76 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v120);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v120);
    v77 = (std::__shared_weak_count *)*((_QWORD *)&v120 + 1);
    if (*((_QWORD *)&v120 + 1))
    {
      v78 = (unint64_t *)(*((_QWORD *)&v120 + 1) + 8);
      do
        v79 = __ldaxr(v78);
      while (__stlxr(v79 - 1, v78));
      if (!v79)
      {
        ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
        std::__shared_weak_count::__release_weak(v77);
      }
    }
    v76 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v80 = (std::__shared_weak_count *)off_2553234C8;
  v128 = (uint64_t)v76;
  v129 = off_2553234C8;
  if (off_2553234C8)
  {
    v81 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v82 = __ldxr(v81);
    while (__stxr(v82 + 1, v81));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v76, (SEUpdaterUtil::SELogObj *)2, 0, 1, "dumpDebugInfo", (SEUpdaterUtil::SELogObj *)"Dumping AC Log\n");
  if (v80)
  {
    v83 = (unint64_t *)&v80->__shared_owners_;
    do
      v84 = __ldaxr(v83);
    while (__stlxr(v84 - 1, v83));
    if (!v84)
    {
      ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
      std::__shared_weak_count::__release_weak(v80);
    }
  }
  v85 = *((_QWORD *)this + 16);
  if (v85 && (*(_DWORD *)(v85 + 56) != 115 || *(_DWORD *)(v85 + 12) >= 0x327u))
  {
    v128 = 0x26DF06FE00CA80;
    LODWORD(v129) = 65534;
    SERestoreInfo::CApdu::CApdu(&v120, &v128, 0xCuLL, 0);
    v86 = &off_24E0C07C8;
    *(_QWORD *)&v120 = &off_24E0C07C8;
    v87 = operator new();
    v88 = v87;
    v89 = v121;
    *(_QWORD *)(v87 + 8) = *((_QWORD *)&v120 + 1);
    *(_QWORD *)(v87 + 16) = v89;
    if (v89)
    {
      v90 = (unint64_t *)&v89->__shared_owners_;
      do
        v91 = __ldxr(v90);
      while (__stxr(v91 + 1, v90));
      v92 = v121;
      *(_OWORD *)(v87 + 24) = v122;
      *(_OWORD *)(v87 + 40) = v123;
      *(_QWORD *)v87 = &off_24E0C07C8;
      *(_QWORD *)&v120 = &unk_24E0BF880;
      if (!v92)
        goto LABEL_177;
      v93 = (unint64_t *)&v92->__shared_owners_;
      do
        v94 = __ldaxr(v93);
      while (__stlxr(v94 - 1, v93));
      goto LABEL_154;
    }
LABEL_176:
    *(_OWORD *)(v88 + 24) = v122;
    *(_OWORD *)(v88 + 40) = v123;
    *(_QWORD *)v88 = v86;
    goto LABEL_177;
  }
  v128 = 0x26DF02FE00CA80;
  SERestoreInfo::CApdu::CApdu(&v120, &v128, 8uLL, 0);
  v86 = &off_24E0C0810;
  *(_QWORD *)&v120 = &off_24E0C0810;
  v95 = operator new();
  v88 = v95;
  v96 = v121;
  *(_QWORD *)(v95 + 8) = *((_QWORD *)&v120 + 1);
  *(_QWORD *)(v95 + 16) = v96;
  if (!v96)
    goto LABEL_176;
  v97 = (unint64_t *)&v96->__shared_owners_;
  do
    v98 = __ldxr(v97);
  while (__stxr(v98 + 1, v97));
  v92 = v121;
  *(_OWORD *)(v95 + 24) = v122;
  *(_OWORD *)(v95 + 40) = v123;
  *(_QWORD *)v95 = &off_24E0C0810;
  *(_QWORD *)&v120 = &unk_24E0BF880;
  if (!v92)
    goto LABEL_177;
  v99 = (unint64_t *)&v92->__shared_owners_;
  do
    v94 = __ldaxr(v99);
  while (__stlxr(v94 - 1, v99));
LABEL_154:
  if (!v94)
  {
    ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
    std::__shared_weak_count::__release_weak(v92);
  }
  do
  {
LABEL_177:
    (*(void (**)(_QWORD, uint64_t, __int128 *, uint64_t, _QWORD))(**((_QWORD **)this + 20) + 16))(*((_QWORD *)this + 20), v88, &v130, 2, 0);
    v113 = *(_QWORD *)(*((_QWORD *)&v130 + 1) + 8);
  }
  while ((unint64_t)(v113 - **((_QWORD **)&v130 + 1)) >= 2
       && (*(unsigned __int8 *)(v113 - 1) | (*(unsigned __int8 *)(v113 - 2) << 8)) == 0x6310);
  (*(void (**)(uint64_t))(*(_QWORD *)v88 + 8))(v88);
  *(_QWORD *)&v130 = &unk_24E0BF880;
  v114 = v131;
  if (v131)
  {
    v115 = (unint64_t *)&v131->__shared_owners_;
    do
      v116 = __ldaxr(v115);
    while (__stlxr(v116 - 1, v115));
    if (!v116)
    {
      ((void (*)(std::__shared_weak_count *))v114->__on_zero_shared)(v114);
      std::__shared_weak_count::__release_weak(v114);
    }
  }
  v124[0] = &unk_24E0BF880;
  v117 = v125;
  if (v125)
  {
    v118 = (unint64_t *)&v125->__shared_owners_;
    do
      v119 = __ldaxr(v118);
    while (__stlxr(v119 - 1, v118));
    if (!v119)
    {
      ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
      std::__shared_weak_count::__release_weak(v117);
    }
  }
}

#error "21CCA3F40: call analysis failed (funcsize=65)"

BOOL std::operator!=[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(uint64_t *a1)
{
  int v1;

  v1 = *((char *)a1 + 23);
  if (v1 < 0)
  {
    if (a1[1] != 5)
      return 1;
    a1 = (uint64_t *)*a1;
  }
  else if (v1 != 5)
  {
    return 1;
  }
  return *(_DWORD *)a1 != 1668443974 || *((_BYTE *)a1 + 4) != 101;
}

void SEUpdater::P73BaseUpdateController::printManifest(SEUpdater::P73BaseUpdateController *this)
{
  SEUpdaterUtil::SELogObj *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  SERestoreInfo::P73BaseDeviceInfo *v9;
  const char *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  void *__p[2];
  char v14;
  SEUpdaterUtil::SELogObj *v15;
  void *v16;

  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v3 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v4 = (unint64_t *)((char *)__p[1] + 8);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v6 = (std::__shared_weak_count *)off_2553234C8;
  v15 = v2;
  v16 = off_2553234C8;
  if (off_2553234C8)
  {
    v7 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v9 = (SERestoreInfo::P73BaseDeviceInfo *)*((_QWORD *)this + 16);
  if (v9)
  {
    SERestoreInfo::P73BaseDeviceInfo::print(v9);
    if (v14 >= 0)
      v10 = (const char *)__p;
    else
      v10 = (const char *)__p[0];
  }
  else
  {
    v10 = "NULL deviceInfo";
  }
  SEUpdaterUtil::SELogObj::printLog(v2, (SEUpdaterUtil::SELogObj *)2, 0, 1, "printManifest", (SEUpdaterUtil::SELogObj *)"MQ: %s\n", v10);
  if (v9 && v14 < 0)
    operator delete(__p[0]);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_21CCA4134(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t SEUpdater::P73BaseUpdateController::doCommand(SEUpdater::P73BaseUpdateController *this, CFStringRef theString1, const __CFDictionary **a3)
{
  SERestoreInfo::P73BaseDeviceInfo *v6;
  void *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t (*v18)(uint64_t);
  void *exception;
  std::string *v20;
  __int128 v21;
  SERestoreInfo::SEException *v22;
  SERestoreInfo::SEException *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  std::string v26;
  CFErrorRef err[2];
  std::string::size_type v28;

  if (!theString1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v26, "Assertion: ");
    v20 = std::string::append(&v26, "command");
    v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v28 = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)err = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, err);
  }
  if (CFStringCompare(theString1, CFSTR("queryInfo"), 0))
  {
    if (CFStringCompare(theString1, CFSTR("performNextStage"), 0))
    {
      if (CFStringCompare(theString1, CFSTR("verifyPairing"), 0))
        return 0;
      v6 = (SERestoreInfo::P73BaseDeviceInfo *)*((_QWORD *)this + 16);
      if (*((_DWORD *)v6 + 14) == 54)
      {
        if (SERestoreInfo::P73BaseDeviceInfo::isProdEval(v6))
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v7 = off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(err);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)err);
            std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)err);
            v7 = off_2553234C0;
          }
          v26.__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
          v26.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v8 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v9 = __ldxr(v8);
            while (__stxr(v9 + 1, v8));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v26.__r_.__value_.__l.__data_, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doCommand", (SEUpdaterUtil::SELogObj *)"SE is PROD_EVAL -> Skip SE-SEP pairing verification\n");
          if (v26.__r_.__value_.__l.__size_)
          {
            v10 = (unint64_t *)(v26.__r_.__value_.__l.__size_ + 8);
            do
              v11 = __ldaxr(v10);
            while (__stlxr(v11 - 1, v10));
            if (!v11)
            {
              (*(void (**)(std::string::size_type))(*(_QWORD *)v26.__r_.__value_.__l.__size_ + 16))(v26.__r_.__value_.__l.__size_);
              std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v26.__r_.__value_.__l.__size_);
            }
          }
          return 1;
        }
        v6 = (SERestoreInfo::P73BaseDeviceInfo *)*((_QWORD *)this + 16);
      }
      (*(void (**)(SERestoreInfo::P73BaseDeviceInfo *))(*(_QWORD *)v6 + 32))(v6);
      v12 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
      v24 = *((_QWORD *)this + 20);
      v25 = v12;
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v14 = __ldxr(p_shared_owners);
        while (__stxr(v14 + 1, p_shared_owners));
      }
      if (!*((_BYTE *)this + 66))
        std::__throw_bad_optional_access[abi:ne180100]();
      verifyAlohaPairing(&v24, (uint64_t)this + 64, err);
      v15 = v25;
      if (v25)
      {
        v16 = (unint64_t *)&v25->__shared_owners_;
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      if (err[0])
        v18 = ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::get;
      else
        v18 = 0;
      if (v18)
      {
        v22 = (SERestoreInfo::SEException *)__cxa_allocate_exception(0x48uLL);
        v23 = SERestoreInfo::SEException::SEException(v22, err[0]);
      }
      ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::~SharedRef((const void **)err);
      return 1;
    }
    SEUpdater::P73BaseUpdateController::doPerform(this);
  }
  else
  {
    SEUpdater::P73BaseUpdateController::doQuery(this);
  }
  return 1;
}

#error "21CCA4610: call analysis failed (funcsize=142)"

void sub_21CCA46FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_21CCA47A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;
  int v24;

  if (a23 < 0)
    operator delete(__p);
  if (a17 < 0)
  {
    operator delete(a12);
    if ((v24 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v24)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v23);
  goto LABEL_8;
}

void SEUpdater::P73BaseUpdateController::doPerform(SEUpdater::P73BaseUpdateController *this)
{
  SERestoreInfo::P73BaseDeviceInfo **v1;
  const void **v2;
  const char *v3;
  uint64_t (*v4)(uint64_t);
  CFTypeID v5;
  void *v6;
  const __CFData *v7;
  uint64_t (*v8)(uint64_t);
  std::__shared_weak_count *v9;
  SERestoreInfo::SEFirmwareBase *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *size;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  SEUpdaterUtil::SELogObj *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  __CFDictionary *Mutable;
  uint64_t (*v31)(uint64_t);
  int v32;
  __CFString **v33;
  __CFDictionary *v35;
  CFNumberRef v36;
  __CFDictionary *v37;
  CFDataRef v38;
  __CFDictionary *v39;
  CFDataRef v40;
  __CFDictionary *v41;
  CFDataRef v42;
  CFMutableDictionaryRef v43;
  uint64_t (*v44)(uint64_t);
  size_t v45;
  std::string::size_type v46;
  CFDataRef v47;
  uint64_t (*v48)(uint64_t);
  int v49;
  uint64_t v50;
  const char *v51;
  __CFString **v52;
  uint64_t (*v53)(uint64_t);
  uint64_t (*v54)(uint64_t);
  unsigned int v55;
  _QWORD *v56;
  const void *v57;
  CFTypeID v58;
  CFMutableDictionaryRef MutableCopy;
  uint64_t (*v60)(uint64_t);
  int v61;
  __CFString **v62;
  CFTypeRef v63;
  CFTypeID v64;
  void *v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  SERestoreInfo::P73BaseDeviceInfo *v69;
  int v70;
  BOOL v72;
  _BOOL4 v73;
  void *v74;
  std::__shared_weak_count *v75;
  unint64_t *v76;
  unint64_t v77;
  unint64_t *v78;
  unint64_t v79;
  const char *v80;
  std::__shared_weak_count *v81;
  unint64_t *v82;
  unint64_t v83;
  _DWORD *v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  int v88;
  unsigned int v89;
  _BOOL4 v90;
  unint64_t *v91;
  unint64_t v92;
  void *v93;
  char *v94;
  std::__shared_weak_count *v95;
  unint64_t *v96;
  unint64_t *v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  std::__shared_weak_count *v102;
  unint64_t *v103;
  unint64_t v104;
  std::__shared_weak_count *v105;
  unint64_t *v106;
  unint64_t v107;
  std::__shared_weak_count *v108;
  unint64_t *v109;
  unint64_t v110;
  std::__shared_weak_count *v111;
  unint64_t *v112;
  unint64_t v113;
  std::__shared_weak_count *v114;
  unint64_t *v115;
  unint64_t v116;
  std::__shared_weak_count *v117;
  unint64_t *v118;
  unint64_t v119;
  int v120;
  _DWORD *v121;
  char *v122;
  char *v123;
  std::string::size_type v124;
  unint64_t *v125;
  unint64_t v126;
  std::__shared_weak_count *v127;
  unint64_t *v128;
  unint64_t v129;
  std::string::size_type v130;
  uint64_t v131;
  uint64_t *v132;
  BOOL v133;
  uint64_t v134;
  uint64_t v135;
  BOOL v136;
  SEUpdaterUtil::SELogObj *v137;
  std::__shared_weak_count *v138;
  unint64_t *v139;
  unint64_t v140;
  std::__shared_weak_count *v141;
  unint64_t *v142;
  unint64_t v143;
  void **v144;
  unint64_t *v145;
  unint64_t v146;
  std::__shared_weak_count *v147;
  SEUpdaterUtil::SELogObj *v148;
  std::__shared_weak_count *v149;
  unint64_t *v150;
  unint64_t v151;
  std::__shared_weak_count *v152;
  unint64_t *v153;
  unint64_t v154;
  unint64_t *v155;
  unint64_t v156;
  SEUpdaterUtil::SELogObj *v157;
  std::__shared_weak_count *v158;
  unint64_t *v159;
  unint64_t v160;
  std::__shared_weak_count *v161;
  unint64_t *v162;
  unint64_t v163;
  void **v164;
  unint64_t *v165;
  unint64_t v166;
  const void *v167;
  unint64_t *v168;
  std::__shared_weak_count *v169;
  unint64_t *v170;
  unint64_t *v171;
  unint64_t v172;
  unint64_t v173;
  unint64_t v174;
  unint64_t v175;
  std::__shared_weak_count *v176;
  unint64_t *v177;
  unint64_t v178;
  std::__shared_weak_count *v179;
  unint64_t *v180;
  unint64_t v181;
  std::__shared_weak_count *v182;
  unint64_t *v183;
  unint64_t v184;
  std::__shared_weak_count *v185;
  unint64_t *v186;
  unint64_t v187;
  SEUpdaterUtil::SELogObj *v188;
  std::__shared_weak_count *v189;
  unint64_t *v190;
  unint64_t v191;
  std::__shared_weak_count *v192;
  unint64_t *v193;
  unint64_t v194;
  unint64_t *v195;
  unint64_t v196;
  std::__shared_weak_count *v197;
  unint64_t *v198;
  unint64_t v199;
  std::string::size_type v200;
  unint64_t *v201;
  unint64_t v202;
  int v203;
  _BOOL4 v206;
  uint64_t v207;
  uint64_t v208;
  SERestoreInfo::P73BaseDeviceInfo *v209;
  _BOOL4 v210;
  char v211;
  uint64_t v212;
  const char *v213;
  std::__shared_weak_count *v214;
  unint64_t *v215;
  unint64_t v216;
  uint64_t v217;
  const char *v218;
  std::__shared_weak_count *v219;
  unint64_t *v220;
  unint64_t v221;
  uint64_t v222;
  unint64_t v223;
  unsigned int v224;
  unsigned int v225;
  SEUpdaterUtil::SELogObj *v226;
  std::__shared_weak_count *v227;
  unint64_t *v228;
  unint64_t v229;
  std::__shared_weak_count *v230;
  unint64_t *v231;
  unint64_t v232;
  unint64_t *v233;
  unint64_t v234;
  std::__shared_weak_count *v235;
  unint64_t *v236;
  unint64_t v237;
  const void *v238;
  SEUpdaterUtil::SELogObj *v239;
  std::__shared_weak_count *v240;
  unint64_t *v241;
  unint64_t v242;
  std::__shared_weak_count *v243;
  unint64_t *v244;
  unint64_t v245;
  unint64_t *v246;
  unint64_t v247;
  _BOOL4 v248;
  BOOL v249;
  uint64_t v250;
  std::__shared_weak_count *v251;
  unint64_t *v252;
  unint64_t v253;
  uint64_t v254;
  uint64_t v255;
  std::__shared_weak_count *v256;
  unint64_t *v257;
  unint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  int v262;
  SEUpdaterUtil::SELogObj *v263;
  std::__shared_weak_count *v264;
  unint64_t *v265;
  unint64_t v266;
  std::__shared_weak_count *v267;
  unint64_t *v268;
  unint64_t v269;
  uint64_t v270;
  int v271;
  unint64_t *v272;
  unint64_t v273;
  SEUpdaterUtil::SELogObj *v274;
  std::__shared_weak_count *v275;
  unint64_t *v276;
  unint64_t v277;
  unint64_t *v278;
  unint64_t v279;
  uint64_t v280;
  int v281;
  unint64_t *v282;
  int v283;
  int v284;
  std::__shared_weak_count *v285;
  unint64_t *v286;
  unint64_t v287;
  const __CFDictionary *v288;
  SEUpdaterUtil::SELogObj *v289;
  std::__shared_weak_count *v290;
  unint64_t *v291;
  unint64_t v292;
  unint64_t *v293;
  unint64_t v294;
  unint64_t *v295;
  unsigned int v296;
  unsigned int v297;
  SERestoreInfo::P73BaseDeviceInfo *v298;
  uint64_t v299;
  int v300;
  std::__shared_weak_count *v301;
  unint64_t *v302;
  unint64_t v303;
  uint64_t v304;
  uint64_t v305;
  int v306;
  std::__shared_weak_count *v307;
  unint64_t *v308;
  unint64_t v309;
  uint64_t v310;
  SEUpdaterUtil::SELogObj *v311;
  unint64_t *v312;
  unint64_t v313;
  int v314;
  uint64_t v315;
  unsigned __int8 v316;
  SEUpdaterUtil::SELogObj *v317;
  std::__shared_weak_count *v318;
  unint64_t *v319;
  unint64_t v320;
  std::__shared_weak_count *v321;
  unint64_t *v322;
  unint64_t v323;
  unint64_t *v324;
  unint64_t v325;
  SERestoreInfo::P73BaseDeviceInfo *v326;
  const char **v328;
  int v329;
  uint64_t v332;
  const char *v333;
  std::__shared_weak_count *v334;
  unint64_t *v335;
  unint64_t v336;
  std::__shared_weak_count *v337;
  unint64_t *v338;
  unint64_t v339;
  uint64_t v340;
  _DWORD *v341;
  unint64_t *v342;
  unint64_t v343;
  unsigned int NextAction;
  unint64_t *v345;
  unint64_t v346;
  SEUpdaterUtil::SELogObj *v347;
  std::__shared_weak_count *v348;
  unint64_t *v349;
  unint64_t v350;
  std::__shared_weak_count *v351;
  unint64_t *v352;
  unint64_t v353;
  unint64_t *v354;
  unint64_t v355;
  _BYTE *v356;
  int v357;
  SEUpdaterUtil::SELogObj *v359;
  std::__shared_weak_count *v360;
  unint64_t *v361;
  unint64_t v362;
  std::__shared_weak_count *v363;
  unint64_t *v364;
  unint64_t v365;
  unint64_t *v366;
  unint64_t v367;
  std::ios_base *v368;
  SEUpdaterUtil::SELogObj *v369;
  std::__shared_weak_count *v370;
  unint64_t *v371;
  unint64_t v372;
  std::__shared_weak_count *v373;
  unint64_t *v374;
  unint64_t v375;
  const char *v376;
  unint64_t *v377;
  unint64_t v378;
  std::__shared_weak_count *v379;
  uint64_t v380;
  int v381;
  std::__shared_weak_count *v382;
  unint64_t *v383;
  unint64_t v384;
  ctu *v385;
  uint64_t v386;
  unint64_t v387;
  unsigned __int8 *v388;
  int v389;
  SEUpdaterUtil::SELogObj *v391;
  std::__shared_weak_count *v392;
  unint64_t *v393;
  unint64_t v394;
  unint64_t *v395;
  unint64_t v396;
  const char *v397;
  unint64_t *v398;
  SEUpdaterUtil::SELogObj *v399;
  std::__shared_weak_count *v400;
  unint64_t *v401;
  unint64_t v402;
  std::__shared_weak_count *v403;
  unint64_t *v404;
  unint64_t v405;
  unint64_t *v406;
  unint64_t v407;
  std::__shared_weak_count *v408;
  unint64_t *v409;
  unint64_t v410;
  SERestoreInfo::P73BaseDeliveryObject *v411;
  uint64_t v412;
  SERestoreInfo::P73BaseDeviceInfo *v413;
  _BOOL4 v414;
  int v415;
  unsigned int v416;
  int v417;
  int v418;
  unsigned int v419;
  int v420;
  _BOOL4 v423;
  _BOOL4 v424;
  SEUpdaterUtil::SELogObj *v425;
  std::__shared_weak_count *v426;
  unint64_t *v427;
  unint64_t v428;
  std::__shared_weak_count *v429;
  unint64_t *v430;
  unint64_t v431;
  unint64_t *v432;
  unint64_t v433;
  int v434;
  int v435;
  SEUpdaterUtil::SELogObj *v436;
  std::__shared_weak_count *v437;
  unint64_t *v438;
  unint64_t v439;
  std::__shared_weak_count *v440;
  unint64_t *v441;
  unint64_t v442;
  unint64_t *v443;
  unint64_t v444;
  SERestoreInfo::P73BaseDeviceInfo **v445;
  SEUpdaterUtil::SELogObj *v446;
  std::__shared_weak_count *v447;
  unint64_t *v448;
  unint64_t v449;
  std::__shared_weak_count *v450;
  unint64_t *v451;
  unint64_t v452;
  unint64_t *v453;
  unint64_t v454;
  unsigned int FactoryPostflightAction;
  uint64_t v456;
  int v457;
  std::__shared_weak_count *v458;
  unint64_t *v459;
  unint64_t v460;
  uint64_t v461;
  uint64_t v462;
  int v463;
  std::__shared_weak_count *v464;
  unint64_t *v465;
  unint64_t v466;
  uint64_t v467;
  int v468;
  uint64_t v470;
  int v471;
  std::__shared_weak_count *v472;
  unint64_t *v473;
  unint64_t v474;
  uint64_t v475;
  uint64_t v476;
  int v477;
  std::__shared_weak_count *v478;
  unint64_t *v479;
  unint64_t v480;
  uint64_t v481;
  SEUpdaterUtil::SELogObj *v482;
  std::__shared_weak_count *v483;
  unint64_t *v484;
  unint64_t v485;
  std::__shared_weak_count *v486;
  unint64_t *v487;
  unint64_t v488;
  unint64_t *v489;
  unint64_t v490;
  std::__shared_weak_count *v491;
  unint64_t *v492;
  unint64_t v493;
  _BOOL4 v494;
  SEUpdaterUtil::SELogObj *v495;
  std::__shared_weak_count *v496;
  unint64_t *v497;
  unint64_t v498;
  std::__shared_weak_count *v499;
  unint64_t *v500;
  unint64_t v501;
  const char *v502;
  unint64_t *v503;
  unint64_t v504;
  char *v505;
  int v506;
  _DWORD *v507;
  _BOOL4 v508;
  BOOL v509;
  int v510;
  _BOOL4 v512;
  uint64_t v513;
  uint64_t v514;
  SEUpdaterUtil::SELogObj *v515;
  std::__shared_weak_count *v516;
  unint64_t *v517;
  unint64_t v518;
  std::__shared_weak_count *v519;
  unint64_t *v520;
  unint64_t v521;
  unint64_t *v522;
  unint64_t v523;
  _DWORD *v524;
  std::__shared_weak_count *v525;
  unint64_t *v526;
  unint64_t v527;
  int v528;
  unsigned int v529;
  SEUpdaterUtil::SELogObj *v530;
  std::__shared_weak_count *v531;
  unint64_t *v532;
  unint64_t v533;
  std::__shared_weak_count *v534;
  unint64_t *v535;
  unint64_t v536;
  uint64_t v537;
  int v538;
  BOOL v539;
  unint64_t *v540;
  unint64_t v541;
  unint64_t *v542;
  unint64_t *v543;
  unint64_t v544;
  std::__shared_weak_count *v545;
  unint64_t *v546;
  unint64_t v547;
  uint64_t v548;
  unint64_t *v549;
  unint64_t v550;
  std::__shared_weak_count *v551;
  unint64_t *v552;
  unint64_t v553;
  std::__shared_weak_count *v554;
  _BOOL4 isDev;
  _OWORD *v556;
  _QWORD *v557;
  _WORD *v558;
  _OWORD *v559;
  _WORD *v560;
  uint64_t v561;
  std::string::size_type v562;
  uint64_t v563;
  uint64_t v564;
  void *v565;
  const char **v566;
  std::string::size_type v567;
  char v568;
  std::string::size_type v569;
  std::string::size_type v570;
  std::string::size_type v571;
  const char *v572;
  size_t v573;
  const void *v574;
  __int128 v575;
  unint64_t *v576;
  unint64_t v577;
  unint64_t v578;
  SEUpdaterUtil::SELogObj *v579;
  std::__shared_weak_count *v580;
  unint64_t *v581;
  unint64_t v582;
  std::__shared_weak_count *v583;
  unint64_t *v584;
  unint64_t v585;
  unint64_t *v586;
  unint64_t v587;
  SEUpdaterUtil::SELogObj *v588;
  std::__shared_weak_count *v589;
  unint64_t *v590;
  unint64_t v591;
  unint64_t *v592;
  unint64_t v593;
  unint64_t *v594;
  SEUpdaterUtil::SELogObj *v595;
  std::__shared_weak_count *v596;
  unint64_t *v597;
  unint64_t v598;
  unint64_t *v599;
  unint64_t v600;
  unint64_t *v601;
  SEUpdaterUtil::SELogObj *v602;
  std::__shared_weak_count *v603;
  unint64_t *v604;
  unint64_t v605;
  unint64_t *v606;
  unint64_t v607;
  unint64_t *v608;
  __int128 v609;
  unint64_t *v610;
  unint64_t v611;
  unint64_t v612;
  std::__shared_weak_count *v613;
  unint64_t *v614;
  unint64_t v615;
  std::__shared_weak_count *v616;
  unint64_t *v617;
  unint64_t v618;
  std::__shared_weak_count *v619;
  unint64_t *v620;
  unint64_t v621;
  std::__shared_weak_count *v622;
  unint64_t *v623;
  unint64_t v624;
  SEUpdaterUtil::SELogObj *v625;
  std::__shared_weak_count *v626;
  unint64_t *v627;
  unint64_t v628;
  std::__shared_weak_count *v629;
  unint64_t *v630;
  unint64_t v631;
  unint64_t *v632;
  unint64_t v633;
  unint64_t *v634;
  unint64_t v635;
  std::__shared_weak_count *v636;
  unint64_t *v637;
  unint64_t v638;
  int v639;
  int v640;
  uint64_t v641;
  SEUpdaterUtil::SELogObj *v642;
  std::__shared_weak_count *v643;
  unint64_t *v644;
  unint64_t v645;
  std::__shared_weak_count *v646;
  unint64_t *v647;
  unint64_t v648;
  unint64_t *v649;
  unint64_t v650;
  _BOOL4 v652;
  SERestoreInfo::P73BaseDeviceInfo **v653;
  std::string::size_type v654;
  unint64_t *v655;
  unint64_t v656;
  std::__shared_weak_count *v657;
  unint64_t *v658;
  unint64_t v659;
  _BOOL4 v660;
  int v661;
  char v662;
  unint64_t *v663;
  unint64_t v664;
  std::__shared_weak_count *v665;
  std::__shared_weak_count *v666;
  unint64_t *v667;
  unint64_t v668;
  void *v669;
  void *v670;
  char *v671;
  _DWORD *v672;
  uint64_t v673;
  std::string::size_type v674;
  uint64_t v675;
  void *v676;
  std::string::size_type v677;
  const char **v678;
  uint64_t v679;
  const char *v680;
  std::string::size_type v681;
  SEUpdaterUtil::SELogObj *v682;
  std::__shared_weak_count *v683;
  unint64_t *v684;
  unint64_t v685;
  std::__shared_weak_count *v686;
  unint64_t *v687;
  unint64_t v688;
  unint64_t *v689;
  unint64_t v690;
  SEUpdaterUtil::SELogObj *v691;
  std::__shared_weak_count *v692;
  unint64_t *v693;
  unint64_t v694;
  unint64_t *v695;
  unint64_t v696;
  unint64_t *v697;
  SEUpdaterUtil::SELogObj *v698;
  std::__shared_weak_count *v699;
  unint64_t *v700;
  unint64_t v701;
  unint64_t *v702;
  unint64_t v703;
  unint64_t *v704;
  SEUpdaterUtil::SELogObj *v705;
  std::__shared_weak_count *v706;
  unint64_t *v707;
  unint64_t v708;
  std::__shared_weak_count *v709;
  unint64_t *v710;
  unint64_t v711;
  unint64_t *v712;
  unint64_t v713;
  std::string::size_type v714;
  uint64_t v715;
  const char *v716;
  void *v717;
  char *v718;
  unint64_t *v719;
  unint64_t *v720;
  unint64_t *v721;
  unint64_t v722;
  unint64_t v723;
  unint64_t v724;
  unint64_t v725;
  std::__shared_weak_count *v726;
  unint64_t *v727;
  unint64_t v728;
  std::__shared_weak_count *v729;
  unint64_t *v730;
  unint64_t v731;
  std::__shared_weak_count *v732;
  unint64_t *v733;
  unint64_t v734;
  std::__shared_weak_count *v735;
  unint64_t *v736;
  unint64_t v737;
  SEUpdaterUtil::SELogObj *v738;
  std::__shared_weak_count *v739;
  unint64_t *v740;
  unint64_t v741;
  std::__shared_weak_count *v742;
  unint64_t *v743;
  unint64_t v744;
  unint64_t *v745;
  unint64_t v746;
  std::__shared_weak_count *v747;
  unint64_t *v748;
  unint64_t v749;
  unint64_t *v750;
  _QWORD *v751;
  _BOOL4 v752;
  char *v753;
  char *v754;
  SEUpdaterUtil::SELogObj *v755;
  std::__shared_weak_count *v756;
  unint64_t *v757;
  unint64_t v758;
  std::__shared_weak_count *v759;
  unint64_t *v760;
  unint64_t v761;
  unint64_t *v762;
  unint64_t v763;
  uint64_t v764;
  std::__shared_weak_count *v765;
  unint64_t *v766;
  unint64_t v767;
  uint64_t v768;
  uint64_t v769;
  std::__shared_weak_count *v770;
  unint64_t *v771;
  unint64_t v772;
  uint64_t v773;
  SEUpdaterUtil::SELogObj *v774;
  std::__shared_weak_count *v775;
  unint64_t *v776;
  unint64_t v777;
  std::__shared_weak_count *v778;
  unint64_t *v779;
  unint64_t v780;
  unint64_t *v781;
  unint64_t v782;
  char *v783;
  SEUpdaterUtil::SELogObj *v784;
  std::__shared_weak_count *v785;
  unint64_t *v786;
  unint64_t v787;
  std::__shared_weak_count *v788;
  unint64_t *v789;
  unint64_t v790;
  unint64_t *v791;
  unint64_t v792;
  SEUpdaterUtil::SELogObj *v793;
  std::__shared_weak_count *v794;
  unint64_t *v795;
  unint64_t v796;
  unint64_t *v797;
  unint64_t v798;
  unint64_t *v799;
  SEUpdaterUtil::SELogObj *v800;
  std::__shared_weak_count *v801;
  unint64_t *v802;
  unint64_t v803;
  unint64_t *v804;
  unint64_t v805;
  unint64_t *v806;
  SEUpdaterUtil::SELogObj *v807;
  std::__shared_weak_count *v808;
  unint64_t *v809;
  unint64_t v810;
  std::__shared_weak_count *v811;
  unint64_t *v812;
  unint64_t v813;
  unint64_t *v814;
  unint64_t v815;
  __int128 v816;
  unint64_t *v817;
  unint64_t v818;
  unint64_t v819;
  __int128 v820;
  unint64_t *v821;
  unint64_t v822;
  unint64_t v823;
  std::__shared_weak_count *v824;
  unint64_t *v825;
  unint64_t v826;
  std::__shared_weak_count *v827;
  unint64_t *v828;
  unint64_t v829;
  std::__shared_weak_count *v830;
  unint64_t *v831;
  unint64_t v832;
  std::__shared_weak_count *v833;
  unint64_t *v834;
  unint64_t v835;
  __int128 v836;
  unint64_t *v837;
  unint64_t v838;
  unint64_t v839;
  __int128 v840;
  unint64_t *v841;
  unint64_t v842;
  unint64_t v843;
  std::__shared_weak_count *v844;
  unint64_t *v845;
  unint64_t v846;
  std::__shared_weak_count *v847;
  unint64_t *v848;
  unint64_t v849;
  std::__shared_weak_count *v850;
  unint64_t *v851;
  unint64_t v852;
  std::__shared_weak_count *v853;
  unint64_t *v854;
  unint64_t v855;
  SEUpdaterUtil::SELogObj *v856;
  std::__shared_weak_count *v857;
  unint64_t *v858;
  unint64_t v859;
  std::__shared_weak_count *v860;
  unint64_t *v861;
  unint64_t v862;
  unint64_t *v863;
  unint64_t v864;
  SEUpdaterUtil::SELogObj *v865;
  std::__shared_weak_count *v866;
  unint64_t *v867;
  unint64_t v868;
  std::__shared_weak_count *v869;
  unint64_t *v870;
  unint64_t v871;
  unint64_t *v872;
  unint64_t v873;
  std::__shared_weak_count *v874;
  unint64_t *v875;
  unint64_t v876;
  std::__shared_weak_count *v877;
  unint64_t *v878;
  unint64_t v879;
  std::__shared_weak_count *v880;
  unint64_t *v881;
  unint64_t v882;
  char *v883;
  std::string::size_type v884;
  unint64_t *v885;
  unint64_t v886;
  std::__shared_weak_count *v887;
  unint64_t *v888;
  unint64_t v889;
  std::string::size_type v890;
  std::string::size_type v891;
  uint64_t *v892;
  uint64_t v893;
  uint64_t v894;
  SEUpdaterUtil::SELogObj *v896;
  std::__shared_weak_count *v897;
  unint64_t *v898;
  unint64_t v899;
  std::__shared_weak_count *v900;
  unint64_t *v901;
  unint64_t v902;
  void **v903;
  unint64_t *v904;
  unint64_t v905;
  const void *v906;
  unint64_t *v907;
  _QWORD *v908;
  unint64_t *v909;
  unint64_t *v910;
  unint64_t v911;
  unint64_t v912;
  unint64_t v913;
  unint64_t v914;
  std::__shared_weak_count *v915;
  unint64_t *v916;
  unint64_t v917;
  std::__shared_weak_count *v918;
  unint64_t *v919;
  unint64_t v920;
  std::__shared_weak_count *v921;
  unint64_t *v922;
  unint64_t v923;
  std::__shared_weak_count *v924;
  unint64_t *v925;
  unint64_t v926;
  SEUpdaterUtil::SELogObj *v927;
  std::__shared_weak_count *v928;
  unint64_t *v929;
  unint64_t v930;
  std::__shared_weak_count *v931;
  unint64_t *v932;
  unint64_t v933;
  unint64_t *v934;
  unint64_t v935;
  std::__shared_weak_count *v936;
  unint64_t *v937;
  unint64_t v938;
  std::__shared_weak_count *v939;
  unint64_t *v940;
  unint64_t v941;
  _QWORD *v942;
  _BOOL4 v943;
  unint64_t *v944;
  char v945;
  unint64_t *v946;
  unint64_t v947;
  std::__shared_weak_count *v948;
  unint64_t *v949;
  unint64_t v950;
  char *v951;
  char *v952;
  char *v953;
  uint64_t v954;
  _QWORD *v955;
  _QWORD *v956;
  std::string::size_type v957;
  std::string::size_type v958;
  void ***v959;
  uint64_t j;
  void *v961;
  const char **v962;
  std::string::size_type v963;
  uint64_t v964;
  const char *v965;
  const char *v966;
  __int128 v967;
  std::string::size_type v968;
  uint64_t v969;
  const void *v970;
  size_t v971;
  uint64_t v972;
  SEUpdaterUtil::SELogObj *v973;
  std::__shared_weak_count *v974;
  unint64_t *v975;
  unint64_t v976;
  std::__shared_weak_count *v977;
  unint64_t *v978;
  unint64_t v979;
  unint64_t *v980;
  unint64_t v981;
  SEUpdaterUtil::SELogObj *v982;
  std::__shared_weak_count *v983;
  unint64_t *v984;
  unint64_t v985;
  unint64_t *v986;
  unint64_t v987;
  unint64_t *v988;
  SEUpdaterUtil::SELogObj *v989;
  std::__shared_weak_count *v990;
  unint64_t *v991;
  unint64_t v992;
  unint64_t *v993;
  unint64_t v994;
  unint64_t *v995;
  SEUpdaterUtil::SELogObj *v996;
  std::__shared_weak_count *v997;
  unint64_t *v998;
  unint64_t v999;
  unint64_t *v1000;
  unint64_t v1001;
  const char *v1002;
  void **v1003;
  std::__shared_weak_count *v1004;
  unint64_t *v1005;
  unint64_t v1006;
  SEUpdaterUtil::SELogObj *v1007;
  std::__shared_weak_count *v1008;
  unint64_t *v1009;
  unint64_t v1010;
  std::__shared_weak_count *v1011;
  unint64_t *v1012;
  unint64_t v1013;
  unint64_t *v1014;
  unint64_t v1015;
  __int128 v1016;
  unint64_t *v1017;
  unint64_t v1018;
  unint64_t v1019;
  __int128 v1020;
  unint64_t *v1021;
  unint64_t v1022;
  unint64_t v1023;
  std::__shared_weak_count *v1024;
  unint64_t *v1025;
  unint64_t v1026;
  std::__shared_weak_count *v1027;
  unint64_t *v1028;
  unint64_t v1029;
  std::__shared_weak_count *v1030;
  unint64_t *v1031;
  unint64_t v1032;
  std::__shared_weak_count *v1033;
  unint64_t *v1034;
  unint64_t v1035;
  SEUpdaterUtil::SELogObj *v1036;
  std::__shared_weak_count *v1037;
  unint64_t *v1038;
  unint64_t v1039;
  std::__shared_weak_count *v1040;
  unint64_t *v1041;
  unint64_t v1042;
  unint64_t *v1043;
  unint64_t v1044;
  std::__shared_weak_count *v1045;
  unint64_t *v1046;
  unint64_t v1047;
  std::__shared_weak_count *v1048;
  unint64_t *v1049;
  unint64_t v1050;
  SERestoreInfo::P73BaseDeviceInfo *v1051;
  int v1052;
  void *v1053;
  char *v1054;
  unint64_t *v1055;
  unint64_t *v1056;
  unint64_t *v1057;
  unint64_t v1058;
  unint64_t v1059;
  unint64_t v1060;
  unint64_t v1061;
  std::__shared_weak_count *v1062;
  unint64_t *v1063;
  unint64_t v1064;
  std::__shared_weak_count *v1065;
  unint64_t *v1066;
  unint64_t v1067;
  std::__shared_weak_count *v1068;
  unint64_t *v1069;
  unint64_t v1070;
  std::__shared_weak_count *v1071;
  unint64_t *v1072;
  unint64_t v1073;
  SEUpdaterUtil::SELogObj *v1074;
  std::__shared_weak_count *v1075;
  unint64_t *v1076;
  unint64_t v1077;
  std::__shared_weak_count *v1078;
  unint64_t *v1079;
  unint64_t v1080;
  unint64_t *v1081;
  unint64_t v1082;
  std::__shared_weak_count *v1083;
  unint64_t *v1084;
  unint64_t v1085;
  std::__shared_weak_count *v1086;
  unint64_t *v1087;
  unint64_t v1088;
  std::__shared_weak_count *v1089;
  unint64_t *v1090;
  unint64_t v1091;
  int v1092;
  unsigned int v1093;
  unsigned int v1094;
  unint64_t *v1095;
  unint64_t v1096;
  unint64_t *v1097;
  unint64_t v1098;
  std::string::size_type v1099;
  unint64_t *v1100;
  unint64_t v1101;
  std::string::size_type v1102;
  unint64_t *v1103;
  unint64_t v1104;
  std::__shared_weak_count *v1105;
  unint64_t *v1106;
  unint64_t v1107;
  std::__shared_weak_count *v1108;
  unint64_t *v1109;
  unint64_t v1110;
  __int128 v1111;
  unint64_t *v1112;
  unint64_t *v1113;
  unint64_t *v1114;
  unint64_t v1115;
  unint64_t v1116;
  SEUpdaterUtil::SELogObj *v1117;
  std::__shared_weak_count *v1118;
  unint64_t *v1119;
  unint64_t v1120;
  std::__shared_weak_count *v1121;
  unint64_t *v1122;
  unint64_t v1123;
  unint64_t *v1124;
  unint64_t v1125;
  _OWORD *v1126;
  char *v1127;
  std::string::size_type v1128;
  unint64_t *v1129;
  unint64_t v1130;
  std::__shared_weak_count *v1131;
  unint64_t *v1132;
  unint64_t v1133;
  std::string::size_type v1134;
  uint64_t v1135;
  uint64_t *v1136;
  uint64_t v1137;
  uint64_t v1138;
  BOOL v1139;
  SEUpdaterUtil::SELogObj *v1140;
  std::__shared_weak_count *v1141;
  unint64_t *v1142;
  unint64_t v1143;
  std::__shared_weak_count *v1144;
  unint64_t *v1145;
  unint64_t v1146;
  void **v1147;
  unint64_t *v1148;
  unint64_t v1149;
  std::__shared_weak_count *v1150;
  SEUpdaterUtil::SELogObj *v1151;
  std::__shared_weak_count *v1152;
  unint64_t *v1153;
  unint64_t v1154;
  std::__shared_weak_count *v1155;
  unint64_t *v1156;
  unint64_t v1157;
  unint64_t *v1158;
  unint64_t v1159;
  const void *v1160;
  unint64_t *v1161;
  _QWORD *v1162;
  unint64_t *v1163;
  unint64_t *v1164;
  unint64_t v1165;
  unint64_t v1166;
  unint64_t v1167;
  unint64_t v1168;
  std::__shared_weak_count *v1169;
  unint64_t *v1170;
  unint64_t v1171;
  std::__shared_weak_count *v1172;
  unint64_t *v1173;
  unint64_t v1174;
  std::__shared_weak_count *v1175;
  unint64_t *v1176;
  unint64_t v1177;
  std::__shared_weak_count *v1178;
  unint64_t *v1179;
  unint64_t v1180;
  SEUpdaterUtil::SELogObj *v1181;
  std::__shared_weak_count *v1182;
  unint64_t *v1183;
  unint64_t v1184;
  std::__shared_weak_count *v1185;
  unint64_t *v1186;
  unint64_t v1187;
  std::string *v1188;
  unint64_t *v1189;
  unint64_t v1190;
  std::__shared_weak_count *v1191;
  unint64_t *v1192;
  unint64_t v1193;
  unint64_t *v1194;
  int v1195;
  uint64_t v1196;
  int v1197;
  std::__shared_weak_count *v1198;
  unint64_t *v1199;
  unint64_t v1200;
  uint64_t v1201;
  uint64_t v1202;
  SEUpdaterUtil::SELogObj *v1203;
  std::__shared_weak_count *v1204;
  unint64_t *v1205;
  unint64_t v1206;
  std::__shared_weak_count *v1207;
  unint64_t *v1208;
  unint64_t v1209;
  unint64_t *v1210;
  unint64_t v1211;
  std::__shared_weak_count *v1212;
  unint64_t *v1213;
  unint64_t v1214;
  std::__shared_weak_count *v1215;
  unint64_t *v1216;
  unint64_t v1217;
  SERestoreInfo::P73BaseDeviceInfo *v1218;
  int v1219;
  SEUpdaterUtil::SELogObj *v1220;
  std::__shared_weak_count *v1221;
  unint64_t *v1222;
  unint64_t v1223;
  std::__shared_weak_count *v1224;
  unint64_t *v1225;
  unint64_t v1226;
  unint64_t *v1227;
  unint64_t v1228;
  uint64_t v1229;
  std::__shared_weak_count *v1230;
  unint64_t *v1231;
  unint64_t v1232;
  uint64_t v1233;
  std::__shared_weak_count *v1234;
  unint64_t *v1235;
  unint64_t v1236;
  uint64_t v1237;
  std::__shared_weak_count *v1238;
  unint64_t *v1239;
  unint64_t v1240;
  uint64_t v1241;
  std::__shared_weak_count *v1242;
  unint64_t *v1243;
  unint64_t v1244;
  std::__shared_weak_count *v1245;
  unint64_t *v1246;
  unint64_t v1247;
  SEUpdaterUtil::SELogObj *v1248;
  std::__shared_weak_count *v1249;
  unint64_t *v1250;
  unint64_t v1251;
  std::__shared_weak_count *v1252;
  unint64_t *v1253;
  unint64_t v1254;
  unint64_t *v1255;
  unint64_t v1256;
  uint64_t v1257;
  int shouldEnableEUICCDetectPullDown;
  capabilities::euicc *v1259;
  int v1260;
  SEUpdaterUtil::SELogObj *v1261;
  std::__shared_weak_count *v1262;
  unint64_t *v1263;
  unint64_t v1264;
  std::__shared_weak_count *v1265;
  unint64_t *v1266;
  unint64_t v1267;
  const char *v1268;
  unint64_t *v1269;
  unint64_t v1270;
  std::__shared_weak_count *v1271;
  unint64_t *v1272;
  unint64_t v1273;
  SEUpdaterUtil::SELogObj *v1274;
  std::__shared_weak_count *v1275;
  unint64_t *v1276;
  unint64_t v1277;
  std::__shared_weak_count *v1278;
  unint64_t *v1279;
  unint64_t v1280;
  unint64_t *v1281;
  unint64_t v1282;
  std::__shared_weak_count *v1283;
  unint64_t *v1284;
  unint64_t *v1285;
  unint64_t *v1286;
  uint64_t v1287;
  SEUpdaterUtil::SELogObj *v1288;
  std::__shared_weak_count *v1289;
  unint64_t *v1290;
  unint64_t v1291;
  std::__shared_weak_count *v1292;
  unint64_t *v1293;
  unint64_t v1294;
  unint64_t *v1295;
  unint64_t v1296;
  std::__shared_weak_count *v1297;
  unint64_t *v1298;
  unint64_t v1299;
  unint64_t *v1300;
  _BOOL8 isProdEval;
  SEUpdaterUtil::SELogObj *v1302;
  std::__shared_weak_count *v1303;
  unint64_t *v1304;
  unint64_t v1305;
  std::__shared_weak_count *v1306;
  unint64_t *v1307;
  unint64_t v1308;
  unint64_t *v1309;
  unint64_t v1310;
  std::__shared_weak_count *v1311;
  unint64_t *v1312;
  unint64_t v1313;
  SEUpdaterUtil::SELogObj *v1314;
  std::__shared_weak_count *v1315;
  unint64_t *v1316;
  unint64_t v1317;
  unint64_t *v1318;
  unint64_t v1319;
  unint64_t *v1320;
  unint64_t *v1321;
  unint64_t *v1322;
  uint64_t v1323;
  unsigned __int8 *v1324;
  unint64_t v1325;
  unint64_t v1326;
  char *v1327;
  void *v1328;
  _BOOL4 v1329;
  std::__shared_weak_count *v1330;
  unint64_t *v1331;
  unint64_t v1332;
  std::__shared_weak_count *v1333;
  unint64_t *v1334;
  unint64_t v1335;
  SEUpdaterUtil::SELogObj *v1336;
  std::__shared_weak_count *v1337;
  unint64_t *v1338;
  unint64_t v1339;
  unint64_t *v1340;
  unint64_t v1341;
  unint64_t *v1342;
  std::__shared_weak_count *v1343;
  unint64_t *v1344;
  unint64_t v1345;
  unint64_t *v1346;
  unint64_t v1347;
  unint64_t v1348;
  std::__shared_weak_count *v1349;
  unint64_t *v1350;
  unint64_t v1351;
  std::__shared_weak_count *v1352;
  unint64_t *v1353;
  unint64_t v1354;
  std::__shared_weak_count *v1355;
  unint64_t *v1356;
  unint64_t v1357;
  std::__shared_weak_count *v1358;
  unint64_t *v1359;
  unint64_t v1360;
  SEUpdaterUtil::SELogObj *v1361;
  std::__shared_weak_count *v1362;
  unint64_t *v1363;
  unint64_t v1364;
  std::__shared_weak_count *v1365;
  unint64_t *v1366;
  unint64_t v1367;
  unint64_t *v1368;
  unint64_t v1369;
  std::__shared_weak_count *v1370;
  unint64_t *v1371;
  unint64_t v1372;
  unint64_t *v1373;
  unint64_t *v1374;
  uint64_t v1375;
  SEUpdaterUtil::SELogObj *v1376;
  std::__shared_weak_count *v1377;
  unint64_t *v1378;
  unint64_t v1379;
  std::__shared_weak_count *v1380;
  unint64_t *v1381;
  unint64_t v1382;
  unint64_t *v1383;
  unint64_t v1384;
  std::__shared_weak_count *v1385;
  unint64_t *v1386;
  unint64_t v1387;
  unint64_t *v1388;
  SEUpdaterUtil::SELogObj *v1389;
  std::__shared_weak_count *v1390;
  unint64_t *v1391;
  unint64_t v1392;
  std::__shared_weak_count *v1393;
  unint64_t *v1394;
  unint64_t v1395;
  unint64_t *v1396;
  unint64_t v1397;
  unsigned int v1398;
  BOOL v1399;
  uint64_t v1400;
  SEUpdaterUtil::SELogObj *v1402;
  std::__shared_weak_count *v1403;
  unint64_t *v1404;
  unint64_t v1405;
  std::__shared_weak_count *v1406;
  unint64_t *v1407;
  unint64_t v1408;
  unint64_t *v1409;
  unint64_t v1410;
  std::__shared_weak_count *v1411;
  unint64_t *v1412;
  unint64_t v1413;
  SEUpdaterUtil::SELogObj *v1414;
  std::__shared_weak_count *v1415;
  unint64_t *v1416;
  unint64_t v1417;
  std::__shared_weak_count *v1418;
  unint64_t *v1419;
  unint64_t v1420;
  unint64_t *v1421;
  unint64_t v1422;
  SEUpdaterUtil::SELogObj *v1423;
  std::__shared_weak_count *v1424;
  unint64_t *v1425;
  unint64_t v1426;
  std::__shared_weak_count *v1427;
  unint64_t *v1428;
  unint64_t v1429;
  unint64_t *v1430;
  unint64_t v1431;
  std::__shared_weak_count *v1432;
  std::__shared_weak_count *v1433;
  unint64_t *v1434;
  unint64_t v1435;
  SEUpdaterUtil::SELogObj *v1436;
  std::__shared_weak_count *v1437;
  unint64_t *v1438;
  unint64_t v1439;
  unint64_t *v1440;
  unint64_t v1441;
  unint64_t *v1442;
  std::__shared_weak_count *v1443;
  unint64_t *v1444;
  unint64_t v1445;
  _QWORD *v1446;
  uint64_t v1447;
  unint64_t v1448;
  BOOL v1449;
  unint64_t v1450;
  _QWORD *v1451;
  void *v1452;
  SEUpdaterUtil::SELogObj *v1453;
  std::__shared_weak_count *v1454;
  unint64_t *v1455;
  unint64_t v1456;
  std::__shared_weak_count *v1457;
  unint64_t *v1458;
  unint64_t v1459;
  unint64_t *v1460;
  unint64_t v1461;
  std::__shared_weak_count *v1462;
  unint64_t *v1463;
  unint64_t v1464;
  uint64_t v1465;
  SEUpdaterUtil::SELogObj *v1466;
  unint64_t *v1467;
  unint64_t v1468;
  unint64_t *v1469;
  unint64_t *v1470;
  unint64_t *v1471;
  SEUpdaterUtil::SELogObj *v1472;
  std::__shared_weak_count *v1473;
  unint64_t *v1474;
  unint64_t v1475;
  std::__shared_weak_count *v1476;
  unint64_t *v1477;
  unint64_t v1478;
  unint64_t *v1479;
  unint64_t v1480;
  SEUpdater::P73BaseUpdateController *v1481;
  SEUpdaterUtil::SELogObj *v1482;
  std::__shared_weak_count *v1483;
  unint64_t *v1484;
  unint64_t v1485;
  std::__shared_weak_count *v1486;
  unint64_t *v1487;
  unint64_t v1488;
  void **v1489;
  unint64_t *v1490;
  unint64_t v1491;
  unsigned __int8 *v1492;
  int v1493;
  SERestoreInfo::P73BaseDeviceInfo *v1494;
  void *v1495;
  void *v1496;
  SEUpdaterUtil::SELogObj *v1497;
  std::__shared_weak_count *v1498;
  unint64_t *v1499;
  unint64_t v1500;
  unint64_t *v1501;
  unint64_t v1502;
  std::__shared_weak_count *v1503;
  unint64_t *v1504;
  unint64_t v1505;
  unint64_t *v1506;
  std::__shared_weak_count *v1507;
  unint64_t *v1508;
  unint64_t v1509;
  unsigned __int8 *i;
  SEUpdaterUtil::SELogObj *v1511;
  std::__shared_weak_count *v1512;
  unint64_t *v1513;
  unint64_t v1514;
  std::__shared_weak_count *v1515;
  unint64_t *v1516;
  unint64_t v1517;
  unint64_t *v1518;
  unint64_t v1519;
  SEUpdaterUtil::SELogObj *v1520;
  std::__shared_weak_count *v1521;
  unint64_t *v1522;
  unint64_t v1523;
  std::__shared_weak_count *v1524;
  unint64_t *v1525;
  unint64_t v1526;
  unint64_t *v1527;
  unint64_t v1528;
  SEUpdaterUtil::SELogObj *v1529;
  std::__shared_weak_count *v1530;
  unint64_t *v1531;
  unint64_t v1532;
  unint64_t *v1533;
  unint64_t v1534;
  unint64_t *v1535;
  SEUpdaterUtil::SELogObj *v1536;
  std::__shared_weak_count *v1537;
  unint64_t *v1538;
  unint64_t v1539;
  std::__shared_weak_count *v1540;
  unint64_t *v1541;
  unint64_t v1542;
  unint64_t *v1543;
  unint64_t v1544;
  SEUpdaterUtil::SELogObj *v1545;
  std::__shared_weak_count *v1546;
  unint64_t *v1547;
  unint64_t v1548;
  std::__shared_weak_count *v1549;
  unint64_t *v1550;
  unint64_t v1551;
  unint64_t *v1552;
  unint64_t v1553;
  char *v1554;
  void *v1555;
  void *v1556;
  SEUpdaterUtil::SELogObj *v1557;
  unint64_t *v1558;
  unint64_t v1559;
  uint64_t v1560;
  int v1561;
  SEUpdaterUtil::SELogObj *v1562;
  unint64_t *v1563;
  unint64_t v1564;
  uint64_t v1565;
  int v1566;
  void *exception;
  std::string *v1568;
  std::string *v1569;
  __int128 v1570;
  void *v1571;
  std::string *v1572;
  std::string *v1573;
  __int128 v1574;
  void *v1575;
  void *v1576;
  void *v1577;
  void *v1578;
  SEUpdaterUtil::SELogObj *v1579;
  unint64_t *v1580;
  unint64_t v1581;
  uint64_t v1582;
  int v1583;
  SEUpdaterUtil::SELogObj *v1584;
  unint64_t *v1585;
  unint64_t v1586;
  SEUpdaterUtil::SELogObj *v1587;
  unint64_t *v1588;
  unint64_t v1589;
  uint64_t v1590;
  int v1591;
  SEUpdaterUtil::SELogObj *v1592;
  unint64_t *v1593;
  unint64_t v1594;
  uint64_t v1595;
  int v1596;
  void *v1597;
  void *v1598;
  void *v1599;
  void *v1600;
  void *v1601;
  void *v1602;
  void *v1603;
  void *v1604;
  void *v1605;
  void *v1606;
  void *v1607;
  void *v1608;
  void *v1609;
  std::string *v1610;
  std::string *v1611;
  __int128 v1612;
  int v1613;
  SEUpdaterUtil::SELogObj *v1614;
  unint64_t *v1615;
  unint64_t v1616;
  const char *v1617;
  int v1618;
  const char *v1619;
  SEUpdaterUtil::SELogObj *v1620;
  unint64_t *v1621;
  unint64_t v1622;
  SEUpdaterUtil::SELogObj *v1623;
  unint64_t *v1624;
  unint64_t v1625;
  SEUpdaterUtil::SELogObj *v1626;
  unint64_t *v1627;
  unint64_t v1628;
  void *v1629;
  std::vector<std::string> *v1630;
  void *v1631;
  void *v1632;
  void *v1633;
  void *v1634;
  void *v1635;
  uint64_t v1636;
  void *v1637;
  void *v1638;
  void *v1639;
  __int128 v1640;
  SEUpdaterUtil::SELogObj *v1641;
  unint64_t *v1642;
  unint64_t v1643;
  void *v1644;
  void *v1645;
  __int128 v1646;
  void *v1647;
  void *v1648;
  void *v1649;
  unint64_t *v1650;
  unint64_t v1651;
  unint64_t v1652;
  CFTypeRef v1653;
  unint64_t *v1654;
  unint64_t *v1655;
  unint64_t v1656;
  unint64_t v1657;
  void *v1658;
  std::vector<std::string> *v1659;
  void *v1660;
  void *v1661;
  void *v1662;
  void *v1663;
  void *v1664;
  unint64_t *v1665;
  unint64_t v1666;
  unint64_t v1667;
  __int128 v1668;
  unint64_t *v1669;
  unint64_t v1670;
  unint64_t v1671;
  void *v1672;
  std::vector<std::string> *v1673;
  void *v1674;
  void *v1675;
  void *v1676;
  void *v1677;
  void *v1678;
  void *v1679;
  void *v1680;
  void *v1681;
  void *v1682;
  void *v1683;
  std::string *v1684;
  void *v1685;
  void *v1686;
  void *v1687;
  void *v1688;
  std::vector<std::string> *v1689;
  void *v1690;
  void *v1691;
  unint64_t DataSize;
  std::string *v1693;
  void *v1694;
  void *v1695;
  void *v1696;
  void *v1697;
  void *v1698;
  void *v1699;
  unint64_t v1700;
  std::string *v1701;
  void *v1702;
  void *v1703;
  std::vector<std::string> *v1704;
  void *v1705;
  void *v1706;
  std::vector<std::string> *v1707;
  void *v1708;
  void *v1709;
  std::vector<std::string> *v1710;
  void *v1711;
  void *v1712;
  std::vector<std::string> *v1713;
  void *v1714;
  void *v1715;
  void *v1716;
  void *v1717;
  void *v1718;
  uint64_t v1719;
  void *v1720;
  void *v1721;
  uint64_t v1722;
  uint64_t **v1723;
  SERestoreInfo::P73BaseDeliveryObject **v1724;
  char v1725;
  SERestoreInfo::P73BaseDeviceInfo **v1726;
  uint64_t v1728;
  std::__shared_weak_count *v1729;
  _DWORD *v1730[2];
  CFDictionaryRef v1731;
  std::__shared_weak_count *v1732;
  char v1733;
  CFDictionaryRef theDict;
  _QWORD *v1735;
  std::__shared_weak_count *v1736;
  std::string v1737;
  __int128 v1738;
  uint64_t v1739;
  uint64_t v1740;
  __int128 v1741;
  std::string v1742;
  CFTypeRef v1743;
  unint64_t *v1744;
  __int128 v1745;
  __int128 v1746;
  __int128 v1747;
  std::string::size_type v1748;
  std::__shared_weak_count *v1749;
  std::string v1750;
  __int128 v1751;
  __int128 v1752;
  __int128 v1753;
  CFTypeRef cf;
  unint64_t *v1755;
  __int128 v1756;
  void *__p[2];
  __int128 v1758;
  __int128 v1759;
  __int128 v1760;
  _OWORD v1761[4];
  __int128 v1762;
  __int128 v1763;
  __int128 v1764;
  __int128 v1765;
  __int128 v1766;
  __int128 v1767;
  __int128 v1768;
  __int128 v1769;
  __int128 v1770;
  __int128 v1771;
  __int128 v1772;
  __int128 v1773;
  __int128 v1774;
  __int128 v1775;
  __int128 v1776;
  __int128 v1777;
  __int128 v1778;
  __int128 v1779;
  _OWORD v1780[2];
  uint64_t v1781;
  std::string v1782;
  std::string v1783;
  __int128 v1784;
  __int128 v1785;
  std::string value;
  _BYTE v1787[32];
  uint64_t v1788;

  v1788 = *MEMORY[0x24BDAC8D0];
  v1 = (SERestoreInfo::P73BaseDeviceInfo **)((char *)this + 128);
  if (!*((_QWORD *)this + 16))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    v1568 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&value, "Assertion: ");
    v1569 = std::string::append(v1568, "fDeviceInfo");
    v1570 = *(_OWORD *)&v1569->__r_.__value_.__l.__data_;
    *(_QWORD *)&v1758 = *((_QWORD *)&v1569->__r_.__value_.__l + 2);
    *(_OWORD *)__p = v1570;
    v1569->__r_.__value_.__l.__size_ = 0;
    v1569->__r_.__value_.__r.__words[2] = 0;
    v1569->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, __p);
  }
  v2 = (const void **)((char *)this + 72);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef((const void **)&theDict, (const void **)this + 9);
  if (!CFSTR("FirmwareData"))
  {
    v1571 = __cxa_allocate_exception(0x10uLL);
    v1572 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&value, "Assertion: ");
    v1573 = std::string::append(v1572, "key");
    v1574 = *(_OWORD *)&v1573->__r_.__value_.__l.__data_;
    *(_QWORD *)&v1758 = *((_QWORD *)&v1573->__r_.__value_.__l + 2);
    *(_OWORD *)__p = v1574;
    v1573->__r_.__value_.__l.__size_ = 0;
    v1573->__r_.__value_.__r.__words[2] = 0;
    v1573->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v1571, __p);
  }
  value.__r_.__value_.__r.__words[0] = 0;
  v1783.__r_.__value_.__r.__words[0] = 0;
  v4 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  if (!theDict)
    v4 = 0;
  if (v4)
  {
    if (!CFDictionaryGetValueIfPresent(theDict, CFSTR("FirmwareData"), (const void **)&value.__r_.__value_.__l.__data_)
      || (v5 = CFGetTypeID(value.__r_.__value_.__l.__data_), v5 != CFDataGetTypeID()))
    {
      v1554 = "data is either not found or in wrong CFType";
      goto LABEL_2762;
    }
    v1782.__r_.__value_.__r.__words[0] = value.__r_.__value_.__r.__words[0];
    ctu::cf::CFSharedRef<__CFData const>::CFSharedRef<void const,void>(__p, (CFTypeRef *)&v1782.__r_.__value_.__l.__data_);
    v6 = (void *)v1783.__r_.__value_.__r.__words[0];
    v1783.__r_.__value_.__l.__data_ = (std::string::pointer)__p[0];
    __p[0] = v6;
    ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)__p);
    v7 = (const __CFData *)v1783.__r_.__value_.__r.__words[0];
    if (v1783.__r_.__value_.__r.__words[0])
      v8 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
    else
      v8 = 0;
    if (v8)
    {
      v9 = (std::__shared_weak_count *)operator new(0x40uLL);
      v9->__shared_owners_ = 0;
      v9->__shared_weak_owners_ = 0;
      v9->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1080;
      v10 = (SERestoreInfo::SEFirmwareBase *)&v9[1];
      SERestoreInfo::SEFirmwareBase::SEFirmwareBase((SERestoreInfo::SEFirmwareBase *)&v9[1], v7);
      v9[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0BFDE0;
      v1735 = &v9[1].__vftable;
      v1736 = v9;
      goto LABEL_13;
    }
  }
  v1554 = "fail to get Data";
LABEL_2762:
  SEUpdaterUtil::_AddError((SEUpdaterUtil *)2, 1, (uint64_t)"getDataFromDict", (SEUpdaterUtil::SELogObj *)v1554, v3);
  v10 = 0;
  v1735 = 0;
  v1736 = 0;
LABEL_13:
  ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)&v1783.__r_.__value_.__l.__data_);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)&theDict);
  if (!v10)
  {
    v1575 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__p, "Not FW found in option");
    v1576 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1575, (__int128 *)__p, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  SERestoreInfo::P73BaseFirmware::getDeliveryObject(v10, (uint64_t)v1, &value);
  *(_OWORD *)__p = *(_OWORD *)&value.__r_.__value_.__l.__data_;
  if (value.__r_.__value_.__l.__size_)
  {
    v11 = (unint64_t *)(value.__r_.__value_.__l.__size_ + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v1724 = (SERestoreInfo::P73BaseDeliveryObject **)((char *)this + 144);
  std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)this + 144, (__int128 *)__p);
  v13 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v14 = (unint64_t *)((char *)__p[1] + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  size = (std::__shared_weak_count *)value.__r_.__value_.__l.__size_;
  if (value.__r_.__value_.__l.__size_)
  {
    v17 = (unint64_t *)(value.__r_.__value_.__l.__size_ + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }
  if (!*v1724)
  {
    v1577 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__p, "No matching FW found");
    v1578 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1577, (__int128 *)__p, 15, CFSTR("SEUpdaterErrorDomain"));
  }
  if (*((_DWORD *)*v1 + 14) == 54 && SERestoreInfo::P73BaseDeviceInfo::isDev(*v1))
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "skipReperso");
    v19 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)this + 88, (const void **)__p);
    v20 = v19;
    if (SBYTE7(v1758) < 0)
    {
      operator delete(__p[0]);
      if (v20)
        goto LABEL_127;
    }
    else if (v19)
    {
      goto LABEL_127;
    }
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v22 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v23 = (unint64_t *)((char *)__p[1] + 8);
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v25 = (std::__shared_weak_count *)off_2553234C8;
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
    value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v26 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v21, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doPerform", (SEUpdaterUtil::SELogObj *)"Forcing local signing\n");
    if (v25)
    {
      p_shared_owners = (unint64_t *)&v25->__shared_owners_;
      do
        v29 = __ldaxr(p_shared_owners);
      while (__stlxr(v29 - 1, p_shared_owners));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)Mutable;
    if (Mutable)
      v31 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get;
    else
      v31 = 0;
    if (!v31)
    {
      v1677 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(__p, "Fail to create dictionary for request");
      v1678 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1677, (__int128 *)__p, 3, CFSTR("SEUpdaterErrorDomain"));
    }
    v32 = (*(uint64_t (**)(SERestoreInfo::P73BaseDeviceInfo *))(*(_QWORD *)*v1 + 32))(*v1);
    v33 = kSETagRequestTicket;
    if (v32 <= 199)
    {
      if (v32 != 100 && v32 != 115)
LABEL_62:
        v33 = kSETagRequestTicketEC384;
    }
    else if (v32 != 200 && v32 != 210 && v32 != 131601)
    {
      goto LABEL_62;
    }
    CFDictionaryAddValue(Mutable, *v33, (const void *)*MEMORY[0x24BDBD270]);
    v35 = (__CFDictionary *)v1750.__r_.__value_.__r.__words[0];
    LODWORD(__p[0]) = *((_DWORD *)*v1 + 14);
    v36 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt32Type, __p);
    if (v36)
    {
      CFDictionarySetValue(v35, CFSTR("SE,ChipID"), v36);
      CFRelease(v36);
      v37 = (__CFDictionary *)v1750.__r_.__value_.__r.__words[0];
      v38 = CFDataCreate(0, *((const UInt8 **)*v1 + 4), *((_QWORD *)*v1 + 5) - *((_QWORD *)*v1 + 4));
      if (v38)
      {
        CFDictionarySetValue(v37, CFSTR("SE,ID"), v38);
        CFRelease(v38);
        v39 = (__CFDictionary *)v1750.__r_.__value_.__r.__words[0];
        v40 = CFDataCreate(0, *((const UInt8 **)*v1 + 8), *((_QWORD *)*v1 + 9) - *((_QWORD *)*v1 + 8));
        if (v40)
        {
          CFDictionarySetValue(v39, CFSTR("SE,Nonce"), v40);
          CFRelease(v40);
          v41 = (__CFDictionary *)v1750.__r_.__value_.__r.__words[0];
          v42 = CFDataCreate(0, *((const UInt8 **)*v1 + 11), *((_QWORD *)*v1 + 12) - *((_QWORD *)*v1 + 11));
          if (v42)
          {
            CFDictionarySetValue(v41, CFSTR("SE,RootKeyIdentifier"), v42);
            CFRelease(v42);
            v43 = CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
            v1742.__r_.__value_.__r.__words[0] = (std::string::size_type)v43;
            if (v43)
              v44 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get;
            else
              v44 = 0;
            if (!v44)
            {
              v1679 = __cxa_allocate_exception(0x48uLL);
              std::string::basic_string[abi:ne180100]<0>(__p, "Fail to create dictionary for request image properties");
              v1680 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1679, (__int128 *)__p, 3, CFSTR("SEUpdaterErrorDomain"));
            }
            CFDictionarySetValue((CFMutableDictionaryRef)v1750.__r_.__value_.__l.__data_, CFSTR("SE,UpdatePayload"), v43);
            v45 = *(_QWORD *)ccsha256_di();
            memset(&v1783, 0, sizeof(v1783));
            if (v45)
            {
              std::vector<unsigned char>::__vallocate[abi:ne180100](&v1783, v45);
              v46 = v1783.__r_.__value_.__l.__size_;
              bzero((void *)v1783.__r_.__value_.__l.__size_, v45);
              v1783.__r_.__value_.__l.__size_ = v46 + v45;
            }
            ccdigest();
            v47 = CFDataCreate(0, (const UInt8 *)v1783.__r_.__value_.__l.__data_, v1783.__r_.__value_.__l.__size_ - v1783.__r_.__value_.__r.__words[0]);
            v1737.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
            if (v47)
              v48 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
            else
              v48 = 0;
            if (!v48)
            {
              v1681 = __cxa_allocate_exception(0x48uLL);
              std::string::basic_string[abi:ne180100]<0>(__p, "Fail to create data for SEDH in request");
              v1682 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1681, (__int128 *)__p, 3, CFSTR("SEUpdaterErrorDomain"));
            }
            CFDictionarySetValue((CFMutableDictionaryRef)v1742.__r_.__value_.__l.__data_, CFSTR("DevelopmentUpdatePayloadHash"), v47);
            ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef((const void **)&v1731, v2);
            v49 = (*(uint64_t (**)(SERestoreInfo::P73BaseDeviceInfo *))(*(_QWORD *)*v1 + 32))(*v1);
            v52 = kSETagResponseTicket;
            if (v49 <= 199)
            {
              if (v49 != 100 && v49 != 115)
                goto LABEL_84;
            }
            else if (v49 != 200 && v49 != 210 && v49 != 131601)
            {
LABEL_84:
              v52 = kSETagResponseTicketEC384;
            }
            SEUpdaterUtil::getDataFromDict<SERestoreInfo::BLOB>(&v1782, v1731, *v52, v50, v51);
            ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)&v1731);
            if (v1782.__r_.__value_.__r.__words[0])
            {
              v1781 = 0;
              memset(v1780, 0, sizeof(v1780));
              v1778 = 0u;
              v1779 = 0u;
              v1776 = 0u;
              v1777 = 0u;
              v1774 = 0u;
              v1775 = 0u;
              v1772 = 0u;
              v1773 = 0u;
              v1770 = 0u;
              v1771 = 0u;
              v1768 = 0u;
              v1769 = 0u;
              v1766 = 0u;
              v1767 = 0u;
              v1764 = 0u;
              v1765 = 0u;
              v1762 = 0u;
              v1763 = 0u;
              memset(v1761, 0, sizeof(v1761));
              v1759 = 0u;
              v1760 = 0u;
              *(_OWORD *)__p = 0u;
              v1758 = 0u;
              if (!Img4DecodeInitManifest())
              {
                SEUpdater::getOBJPOctetString(&value);
                if (value.__r_.__value_.__r.__words[0])
                  v53 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
                else
                  v53 = 0;
                if (v53)
                {
                  *(_QWORD *)&v1756 = CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
                  CFDictionaryAddValue((CFMutableDictionaryRef)v1756, CFSTR("Digest"), value.__r_.__value_.__l.__data_);
                  CFDictionaryAddValue((CFMutableDictionaryRef)v1750.__r_.__value_.__l.__data_, CFSTR("SE,RapRTKitOS"), (const void *)v1756);
                  ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::~SharedRef((const void **)&v1756);
                }
                SEUpdater::getOBJPOctetString(&v1756);
                if ((_QWORD)v1756)
                  v54 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
                else
                  v54 = 0;
                if (v54)
                {
                  cf = CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
                  CFDictionaryAddValue((CFMutableDictionaryRef)cf, CFSTR("Digest"), (const void *)v1756);
                  CFDictionaryAddValue((CFMutableDictionaryRef)v1750.__r_.__value_.__l.__data_, CFSTR("SE,RapSwBinDsp"), cf);
                  ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::~SharedRef(&cf);
                }
                ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)&v1756);
                ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)&value.__r_.__value_.__l.__data_);
              }
            }
            v55 = *((_DWORD *)*v1 + 14);
            if (v55 != 54)
            {
              v1683 = __cxa_allocate_exception(0x48uLL);
              std::to_string(&value, v55);
              v1684 = std::string::insert(&value, 0, "Can't retrieve Image4 signer; unknown ChipID: ");
              *(_OWORD *)__p = *(_OWORD *)&v1684->__r_.__value_.__l.__data_;
              *(_QWORD *)&v1758 = *((_QWORD *)&v1684->__r_.__value_.__l + 2);
              v1684->__r_.__value_.__l.__size_ = 0;
              v1684->__r_.__value_.__r.__words[2] = 0;
              v1684->__r_.__value_.__r.__words[0] = 0;
              v1685 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1683, (__int128 *)__p, 30, CFSTR("SEUpdaterErrorDomain"));
            }
            v56 = (_QWORD *)operator new();
            *v56 = &unk_24E0C1330;
            v56[1] = 0;
            __p[0] = 0;
            std::unique_ptr<SEUpdaterUtil::SN300V2Image4Signer>::reset[abi:ne180100]((uint64_t *)__p, 0);
            v57 = (const void *)v1750.__r_.__value_.__r.__words[0];
            if (v1750.__r_.__value_.__r.__words[0]
              && (v58 = CFGetTypeID(v1750.__r_.__value_.__l.__data_), v58 == CFDictionaryGetTypeID()))
            {
              *(_QWORD *)&v1756 = v57;
              CFRetain(v57);
            }
            else
            {
              *(_QWORD *)&v1756 = 0;
            }
            SEUpdaterUtil::SEImage4Signer::sign((const __CFDictionary **)&v1756, (CFDataRef *)&value);
            ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)&v1756);
            MutableCopy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)*v2);
            cf = MutableCopy;
            if (MutableCopy)
              v60 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get;
            else
              v60 = 0;
            if (!v60)
            {
              v1686 = __cxa_allocate_exception(0x48uLL);
              std::string::basic_string[abi:ne180100]<0>(__p, "Fail to create dictionary for new manifest");
              v1687 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1686, (__int128 *)__p, 3, CFSTR("SEUpdaterErrorDomain"));
            }
            v61 = (*(uint64_t (**)(SERestoreInfo::P73BaseDeviceInfo *))(*(_QWORD *)*v1 + 32))(*v1);
            v62 = kSETagResponseTicket;
            if (v61 <= 199)
            {
              if (v61 == 100 || v61 == 115)
                goto LABEL_115;
            }
            else if (v61 == 200 || v61 == 210 || v61 == 131601)
            {
              goto LABEL_115;
            }
            v62 = kSETagResponseTicketEC384;
LABEL_115:
            CFDictionarySetValue(MutableCopy, *v62, value.__r_.__value_.__l.__data_);
            v63 = cf;
            if (cf)
            {
              v64 = CFGetTypeID(cf);
              if (v64 == CFDictionaryGetTypeID())
              {
                __p[0] = (void *)v63;
                CFRetain(v63);
              }
              else
              {
                v63 = 0;
              }
            }
            v65 = (void *)*v2;
            *v2 = v63;
            __p[0] = v65;
            ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)__p);
            ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::~SharedRef(&cf);
            ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)&value.__r_.__value_.__l.__data_);
            (*(void (**)(_QWORD *))(*v56 + 8))(v56);
            v66 = (std::__shared_weak_count *)v1782.__r_.__value_.__l.__size_;
            if (v1782.__r_.__value_.__l.__size_)
            {
              v67 = (unint64_t *)(v1782.__r_.__value_.__l.__size_ + 8);
              do
                v68 = __ldaxr(v67);
              while (__stlxr(v68 - 1, v67));
              if (!v68)
              {
                ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
                std::__shared_weak_count::__release_weak(v66);
              }
            }
            ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)&v1737.__r_.__value_.__l.__data_);
            if (v1783.__r_.__value_.__r.__words[0])
            {
              v1783.__r_.__value_.__l.__size_ = v1783.__r_.__value_.__r.__words[0];
              operator delete(v1783.__r_.__value_.__l.__data_);
            }
            ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::~SharedRef((const void **)&v1742.__r_.__value_.__l.__data_);
            ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::~SharedRef((const void **)&v1750.__r_.__value_.__l.__data_);
            goto LABEL_127;
          }
        }
      }
      v1617 = "tmpData";
      v1618 = 59;
      v1619 = "_CFDictionarySetData";
    }
    else
    {
      v1617 = "num != nullptr";
      v1618 = 42;
      v1619 = "_CFDictionarySetInteger32";
    }
    __assert_rtn(v1619, "SERestoreInfoHelpers.hpp", v1618, v1617);
  }
LABEL_127:
  v69 = *v1;
  v70 = *((_DWORD *)*v1 + 7);
  v72 = v70 == 23195 || v70 == 47545 || v70 == 47411;
  v1726 = v1;
  if (v72)
  {
    v73 = SEUpdater::P73BaseUpdateController::getSEHealthCheckResult(this);
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v74 = off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v75 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v76 = (unint64_t *)((char *)__p[1] + 8);
        do
          v77 = __ldaxr(v76);
        while (__stlxr(v77 - 1, v76));
        if (!v77)
        {
          ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
          std::__shared_weak_count::__release_weak(v75);
        }
      }
      v74 = off_2553234C0;
    }
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)v74;
    value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v78 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v79 = __ldxr(v78);
      while (__stxr(v79 + 1, v78));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    if (v73)
      v80 = "FAILED";
    else
      v80 = "PASS";
    SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)value.__r_.__value_.__l.__data_, (SEUpdaterUtil::SELogObj *)1, 0, 1, "doPerform", (SEUpdaterUtil::SELogObj *)"Pre-update SE Health check result: %s\n", v80);
    v81 = (std::__shared_weak_count *)value.__r_.__value_.__l.__size_;
    if (value.__r_.__value_.__l.__size_)
    {
      v82 = (unint64_t *)(value.__r_.__value_.__l.__size_ + 8);
      do
        v83 = __ldaxr(v82);
      while (__stlxr(v83 - 1, v82));
      if (!v83)
      {
        ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
        std::__shared_weak_count::__release_weak(v81);
      }
    }
    SEUpdater::P73BaseUpdateController::sendIm4M((const void **)this);
    v84 = (_DWORD *)*((_QWORD *)this + 16);
    v85 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v84;
    v1783.__r_.__value_.__l.__size_ = (std::string::size_type)v85;
    if (v85)
    {
      v86 = (unint64_t *)&v85->__shared_owners_;
      do
        v87 = __ldxr(v86);
      while (__stxr(v87 + 1, v86));
    }
    v88 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v84 + 32))(v84);
    if (v88 != 200)
    {
      if (v88 == 115)
      {
        v89 = 1294;
LABEL_161:
        v90 = v84[3] > v89;
        if (!v85)
          goto LABEL_167;
        goto LABEL_164;
      }
      if (v88 != 100)
      {
        v90 = 1;
        if (!v85)
          goto LABEL_167;
LABEL_164:
        v91 = (unint64_t *)&v85->__shared_owners_;
        do
          v92 = __ldaxr(v91);
        while (__stlxr(v92 - 1, v91));
        if (!v92)
        {
          ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
          std::__shared_weak_count::__release_weak(v85);
          if (v90)
            goto LABEL_168;
          goto LABEL_213;
        }
LABEL_167:
        if (v90)
        {
LABEL_168:
          std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(__p, *((_QWORD *)this + 20), *((std::__shared_weak_count **)this + 21));
          v93 = __p[0];
          v94 = (char *)__p[1];
          *(_OWORD *)&v1782.__r_.__value_.__l.__data_ = *(_OWORD *)__p;
          v95 = (std::__shared_weak_count *)operator new(0x20uLL);
          v95->__shared_owners_ = 0;
          v96 = (unint64_t *)&v95->__shared_owners_;
          v95->__shared_weak_owners_ = 0;
          v95->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1170;
          v95[1].__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C11C0;
          v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)&v95[1];
          v1750.__r_.__value_.__l.__size_ = (std::string::size_type)v95;
          v1737.__r_.__value_.__r.__words[0] = (std::string::size_type)v93;
          v1737.__r_.__value_.__l.__size_ = (std::string::size_type)v94;
          if (v94)
          {
            v97 = (unint64_t *)(v94 + 8);
            do
              v98 = __ldxr(v97);
            while (__stxr(v98 + 1, v97));
            v1742.__r_.__value_.__l.__size_ = (std::string::size_type)v94;
            do
              v99 = __ldxr(v97);
            while (__stxr(v99 + 1, v97));
          }
          else
          {
            v1742.__r_.__value_.__l.__size_ = 0;
          }
          v1742.__r_.__value_.__r.__words[0] = (std::string::size_type)v93;
          if (!v93)
            goto LABEL_2917;
          *(_QWORD *)&v1756 = v95 + 1;
          *((_QWORD *)&v1756 + 1) = v95;
          do
            v100 = __ldxr(v96);
          while (__stxr(v100 + 1, v96));
          v1731 = (CFDictionaryRef)&v95[1];
          v1732 = v95;
          do
            v101 = __ldxr(v96);
          while (__stxr(v101 + 1, v96));
          SLAM::SLAM::PerformRecovery((uint64_t *)&v1742, (uint64_t *)&v1731, (uint64_t)__p);
          v102 = v1732;
          if (v1732)
          {
            v103 = (unint64_t *)&v1732->__shared_owners_;
            do
              v104 = __ldaxr(v103);
            while (__stlxr(v104 - 1, v103));
            if (!v104)
            {
              ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
              std::__shared_weak_count::__release_weak(v102);
            }
          }
          v105 = (std::__shared_weak_count *)*((_QWORD *)&v1756 + 1);
          if (*((_QWORD *)&v1756 + 1))
          {
            v106 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
            do
              v107 = __ldaxr(v106);
            while (__stlxr(v107 - 1, v106));
            if (!v107)
            {
              ((void (*)(std::__shared_weak_count *))v105->__on_zero_shared)(v105);
              std::__shared_weak_count::__release_weak(v105);
            }
          }
          v108 = (std::__shared_weak_count *)v1742.__r_.__value_.__l.__size_;
          if (v1742.__r_.__value_.__l.__size_)
          {
            v109 = (unint64_t *)(v1742.__r_.__value_.__l.__size_ + 8);
            do
              v110 = __ldaxr(v109);
            while (__stlxr(v110 - 1, v109));
            if (!v110)
            {
              ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
              std::__shared_weak_count::__release_weak(v108);
            }
          }
          v111 = (std::__shared_weak_count *)v1737.__r_.__value_.__l.__size_;
          if (v1737.__r_.__value_.__l.__size_)
          {
            v112 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
            do
              v113 = __ldaxr(v112);
            while (__stlxr(v113 - 1, v112));
            if (!v113)
            {
              ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
              std::__shared_weak_count::__release_weak(v111);
            }
          }
          if (BYTE8(v1758))
          {
            v1639 = __cxa_allocate_exception(0x48uLL);
            if (!BYTE8(v1758))
              std::__throw_bad_optional_access[abi:ne180100]();
            ctu::join<std::__wrap_iter<std::string const*>>((std::string *)__p[0], (std::string *)__p[1], ", ", 2uLL, &value);
            v1649 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1639, (__int128 *)&value, 36, CFSTR("SEUpdaterErrorDomain"));
          }
          v114 = (std::__shared_weak_count *)v1750.__r_.__value_.__l.__size_;
          if (v1750.__r_.__value_.__l.__size_)
          {
            v115 = (unint64_t *)(v1750.__r_.__value_.__l.__size_ + 8);
            do
              v116 = __ldaxr(v115);
            while (__stlxr(v116 - 1, v115));
            if (!v116)
            {
              ((void (*)(std::__shared_weak_count *))v114->__on_zero_shared)(v114);
              std::__shared_weak_count::__release_weak(v114);
            }
          }
          v117 = (std::__shared_weak_count *)v1782.__r_.__value_.__l.__size_;
          if (v1782.__r_.__value_.__l.__size_)
          {
            v118 = (unint64_t *)(v1782.__r_.__value_.__l.__size_ + 8);
            do
              v119 = __ldaxr(v118);
            while (__stlxr(v119 - 1, v118));
            if (!v119)
            {
              ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
              std::__shared_weak_count::__release_weak(v117);
            }
          }
        }
LABEL_213:
        PTCUtil::workaroundForPTCExport((uint64_t *)this + 20, (uint64_t)v1);
        PTCUtil::deletePTCKeysWithNoStoredPK((uint64_t *)this + 20, (uint64_t *)v1);
        v69 = *v1;
        goto LABEL_214;
      }
    }
    v89 = 1608;
    goto LABEL_161;
  }
LABEL_214:
  if (*((_DWORD *)v69 + 3) != *((_DWORD *)v69 + 6) || *((_DWORD *)v69 + 7) != 23195)
    goto LABEL_368;
  v120 = (*(uint64_t (**)(SERestoreInfo::P73BaseDeviceInfo *))(*(_QWORD *)v69 + 32))(v69);
  if (v120 > 114)
  {
    if (v120 == 115)
      goto LABEL_367;
    if (v120 != 210 && v120 != 200)
    {
LABEL_229:
      v121 = operator new(0x10uLL);
      value.__r_.__value_.__l.__size_ = (std::string::size_type)(v121 + 4);
      value.__r_.__value_.__r.__words[2] = (std::string::size_type)(v121 + 4);
      *(_QWORD *)v121 = 0x5011D004070000A0;
      v121[2] = 0;
      v121[3] = 1;
      value.__r_.__value_.__r.__words[0] = (std::string::size_type)v121;
      v122 = (char *)operator new(0x10uLL);
      *(_QWORD *)v122 = 0x5011D004070000A0;
      *((_DWORD *)v122 + 2) = 0;
      v122[12] = 0;
      *(_WORD *)(v122 + 13) = 2;
      v122[15] = 6;
      v123 = (char *)operator new(0x10uLL);
      *(_QWORD *)v123 = 0x5011D004070000A0;
      *((_DWORD *)v123 + 2) = 0;
      v123[12] = 0;
      *(_WORD *)(v123 + 13) = 258;
      v123[15] = 17;
      v124 = *((_QWORD *)this + 21);
      v1742.__r_.__value_.__r.__words[0] = *((_QWORD *)this + 20);
      v1742.__r_.__value_.__l.__size_ = v124;
      if (v124)
      {
        v125 = (unint64_t *)(v124 + 8);
        do
          v126 = __ldxr(v125);
        while (__stxr(v126 + 1, v125));
      }
      SEUpdater::GetPackageInfo((uint64_t *)&v1742, (std::string::size_type *)&v1783);
      v127 = (std::__shared_weak_count *)v1742.__r_.__value_.__l.__size_;
      if (v1742.__r_.__value_.__l.__size_)
      {
        v128 = (unint64_t *)(v1742.__r_.__value_.__l.__size_ + 8);
        do
          v129 = __ldaxr(v128);
        while (__stlxr(v129 - 1, v128));
        if (!v129)
        {
          ((void (*)(std::__shared_weak_count *))v127->__on_zero_shared)(v127);
          std::__shared_weak_count::__release_weak(v127);
        }
      }
      v130 = v1783.__r_.__value_.__l.__size_;
      v131 = SEUpdater::find_if<std::vector<SEUpdater::PackageInfo>,SEUpdater::FindPackageForModule(std::vector<SEUpdater::PackageInfo> const&,std::vector<unsigned char> const&)::{lambda(std::vector<SEUpdater::PackageInfo> const&)#1}>((uint64_t)v1783.__r_.__value_.__l.__data_, v1783.__r_.__value_.__l.__size_, (uint64_t)&value);
      if (v130 == v131)
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v148 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(__p);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
          v149 = (std::__shared_weak_count *)__p[1];
          if (__p[1])
          {
            v150 = (unint64_t *)((char *)__p[1] + 8);
            do
              v151 = __ldaxr(v150);
            while (__stlxr(v151 - 1, v150));
            if (!v151)
            {
              ((void (*)(std::__shared_weak_count *))v149->__on_zero_shared)(v149);
              std::__shared_weak_count::__release_weak(v149);
            }
          }
          v148 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v152 = (std::__shared_weak_count *)off_2553234C8;
        v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v148;
        v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v153 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v154 = __ldxr(v153);
          while (__stxr(v154 + 1, v153));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v148, (SEUpdaterUtil::SELogObj *)2, 0, 1, "DeleteEnablementPTA", (SEUpdaterUtil::SELogObj *)"No PTA loaded on device, skipping delete operation\n");
        if (!v152)
          goto LABEL_365;
        v155 = (unint64_t *)&v152->__shared_owners_;
        do
          v156 = __ldaxr(v155);
        while (__stlxr(v156 - 1, v155));
        if (v156)
          goto LABEL_365;
        ((void (*)(std::__shared_weak_count *))v152->__on_zero_shared)(v152);
        v147 = v152;
      }
      else
      {
        v132 = *(uint64_t **)v131;
        if (*(_QWORD *)(v131 + 8) - *(_QWORD *)v131 == 16
          && (*v132 == *(_QWORD *)v122 ? (v133 = v132[1] == *((_QWORD *)v122 + 1)) : (v133 = 0),
              v133
           || ((v135 = *v132, v134 = v132[1], v135 == *(_QWORD *)v123)
             ? (v136 = v134 == *((_QWORD *)v123 + 1))
             : (v136 = 0),
               v136)))
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v157 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(__p);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
            v158 = (std::__shared_weak_count *)__p[1];
            if (__p[1])
            {
              v159 = (unint64_t *)((char *)__p[1] + 8);
              do
                v160 = __ldaxr(v159);
              while (__stlxr(v160 - 1, v159));
              if (!v160)
              {
                ((void (*)(std::__shared_weak_count *))v158->__on_zero_shared)(v158);
                std::__shared_weak_count::__release_weak(v158);
              }
            }
            v157 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v161 = (std::__shared_weak_count *)off_2553234C8;
          v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v157;
          v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v162 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v163 = __ldxr(v162);
            while (__stxr(v163 + 1, v162));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          ctu::hex();
          if ((SBYTE7(v1758) & 0x80u) == 0)
            v164 = __p;
          else
            v164 = (void **)__p[0];
          SEUpdaterUtil::SELogObj::printLog(v157, (SEUpdaterUtil::SELogObj *)2, 0, 1, "DeleteEnablementPTA", (SEUpdaterUtil::SELogObj *)"Deleting enablement PTA %s\n", (const char *)v164);
          if (SBYTE7(v1758) < 0)
            operator delete(__p[0]);
          if (v161)
          {
            v165 = (unint64_t *)&v161->__shared_owners_;
            do
              v166 = __ldaxr(v165);
            while (__stlxr(v166 - 1, v165));
            if (!v166)
            {
              ((void (*)(std::__shared_weak_count *))v161->__on_zero_shared)(v161);
              std::__shared_weak_count::__release_weak(v161);
            }
          }
          std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(__p, *((_QWORD *)this + 20), *((std::__shared_weak_count **)this + 21));
          v167 = __p[0];
          v168 = (unint64_t *)__p[1];
          *(_OWORD *)&v1737.__r_.__value_.__l.__data_ = *(_OWORD *)__p;
          v169 = (std::__shared_weak_count *)operator new(0x20uLL);
          v169->__shared_owners_ = 0;
          v170 = (unint64_t *)&v169->__shared_owners_;
          v169->__shared_weak_owners_ = 0;
          v169->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1170;
          v169[1].__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C11C0;
          v1731 = (CFDictionaryRef)&v169[1];
          v1732 = v169;
          std::string::basic_string[abi:ne180100]<0>(&v1782, "SLAMDeleteCopernicusAndSunsprite");
          cf = v167;
          v1755 = v168;
          if (v168)
          {
            v171 = v168 + 1;
            do
              v172 = __ldxr(v171);
            while (__stxr(v172 + 1, v171));
            *((_QWORD *)&v1756 + 1) = v168;
            do
              v173 = __ldxr(v171);
            while (__stxr(v173 + 1, v171));
          }
          else
          {
            *((_QWORD *)&v1756 + 1) = 0;
          }
          *(_QWORD *)&v1756 = v167;
          if (!v167)
            goto LABEL_2917;
          *(_QWORD *)&v1752 = v169 + 1;
          *((_QWORD *)&v1752 + 1) = v169;
          do
            v174 = __ldxr(v170);
          while (__stxr(v174 + 1, v170));
          *(_QWORD *)&v1753 = v169 + 1;
          *((_QWORD *)&v1753 + 1) = v169;
          do
            v175 = __ldxr(v170);
          while (__stxr(v175 + 1, v170));
          SLAM::SLAM::PerformScript((uint64_t)&v1782, (uint64_t *)&v1756, (uint64_t *)&v1753, (uint64_t)__p);
          v176 = (std::__shared_weak_count *)*((_QWORD *)&v1753 + 1);
          if (*((_QWORD *)&v1753 + 1))
          {
            v177 = (unint64_t *)(*((_QWORD *)&v1753 + 1) + 8);
            do
              v178 = __ldaxr(v177);
            while (__stlxr(v178 - 1, v177));
            if (!v178)
            {
              ((void (*)(std::__shared_weak_count *))v176->__on_zero_shared)(v176);
              std::__shared_weak_count::__release_weak(v176);
            }
          }
          v179 = (std::__shared_weak_count *)*((_QWORD *)&v1752 + 1);
          if (*((_QWORD *)&v1752 + 1))
          {
            v180 = (unint64_t *)(*((_QWORD *)&v1752 + 1) + 8);
            do
              v181 = __ldaxr(v180);
            while (__stlxr(v181 - 1, v180));
            if (!v181)
            {
              ((void (*)(std::__shared_weak_count *))v179->__on_zero_shared)(v179);
              std::__shared_weak_count::__release_weak(v179);
            }
          }
          v182 = (std::__shared_weak_count *)*((_QWORD *)&v1756 + 1);
          if (*((_QWORD *)&v1756 + 1))
          {
            v183 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
            do
              v184 = __ldaxr(v183);
            while (__stlxr(v184 - 1, v183));
            if (!v184)
            {
              ((void (*)(std::__shared_weak_count *))v182->__on_zero_shared)(v182);
              std::__shared_weak_count::__release_weak(v182);
            }
          }
          v185 = (std::__shared_weak_count *)v1755;
          if (v1755)
          {
            v186 = v1755 + 1;
            do
              v187 = __ldaxr(v186);
            while (__stlxr(v187 - 1, v186));
            if (!v187)
            {
              ((void (*)(std::__shared_weak_count *))v185->__on_zero_shared)(v185);
              std::__shared_weak_count::__release_weak(v185);
            }
          }
          if (SHIBYTE(v1782.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v1782.__r_.__value_.__l.__data_);
          if (BYTE8(v1758))
          {
            v1712 = __cxa_allocate_exception(0x48uLL);
            v1713 = SLAM::Error::Add((std::vector<std::string> *)__p, "At SLAMDeleteCopernicusAndSunsprite");
            ctu::join<std::__wrap_iter<std::string const*>>(v1713->__begin_, v1713->__end_, ", ", 2uLL, &v1750);
            v1714 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1712, (__int128 *)&v1750, 36, CFSTR("SEUpdaterErrorDomain"));
          }
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v188 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(&v1750);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1750);
            v189 = (std::__shared_weak_count *)v1750.__r_.__value_.__l.__size_;
            if (v1750.__r_.__value_.__l.__size_)
            {
              v190 = (unint64_t *)(v1750.__r_.__value_.__l.__size_ + 8);
              do
                v191 = __ldaxr(v190);
              while (__stlxr(v191 - 1, v190));
              if (!v191)
              {
                ((void (*)(std::__shared_weak_count *))v189->__on_zero_shared)(v189);
                std::__shared_weak_count::__release_weak(v189);
              }
            }
            v188 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v192 = (std::__shared_weak_count *)off_2553234C8;
          *(_QWORD *)&v1751 = v188;
          *((_QWORD *)&v1751 + 1) = off_2553234C8;
          if (off_2553234C8)
          {
            v193 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v194 = __ldxr(v193);
            while (__stxr(v194 + 1, v193));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v188, (SEUpdaterUtil::SELogObj *)2, 0, 1, "DeleteEnablementPTA", (SEUpdaterUtil::SELogObj *)"Successfully deleted enablement PTA\n");
          if (v192)
          {
            v195 = (unint64_t *)&v192->__shared_owners_;
            do
              v196 = __ldaxr(v195);
            while (__stlxr(v196 - 1, v195));
            if (!v196)
            {
              ((void (*)(std::__shared_weak_count *))v192->__on_zero_shared)(v192);
              std::__shared_weak_count::__release_weak(v192);
            }
          }
          if (BYTE8(v1758))
          {
            v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
            std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v1750);
          }
          v197 = v1732;
          if (v1732)
          {
            v198 = (unint64_t *)&v1732->__shared_owners_;
            do
              v199 = __ldaxr(v198);
            while (__stlxr(v199 - 1, v198));
            if (!v199)
            {
              ((void (*)(std::__shared_weak_count *))v197->__on_zero_shared)(v197);
              std::__shared_weak_count::__release_weak(v197);
            }
          }
          v200 = v1737.__r_.__value_.__l.__size_;
          if (!v1737.__r_.__value_.__l.__size_)
            goto LABEL_365;
          v201 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
          do
            v202 = __ldaxr(v201);
          while (__stlxr(v202 - 1, v201));
          if (v202)
            goto LABEL_365;
          (*(void (**)(std::string::size_type))(*(_QWORD *)v200 + 16))(v200);
          v147 = (std::__shared_weak_count *)v200;
        }
        else
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v137 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(__p);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
            v138 = (std::__shared_weak_count *)__p[1];
            if (__p[1])
            {
              v139 = (unint64_t *)((char *)__p[1] + 8);
              do
                v140 = __ldaxr(v139);
              while (__stlxr(v140 - 1, v139));
              if (!v140)
              {
                ((void (*)(std::__shared_weak_count *))v138->__on_zero_shared)(v138);
                std::__shared_weak_count::__release_weak(v138);
              }
            }
            v137 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v141 = (std::__shared_weak_count *)off_2553234C8;
          v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v137;
          v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v142 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v143 = __ldxr(v142);
            while (__stxr(v143 + 1, v142));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          ctu::hex();
          if ((SBYTE7(v1758) & 0x80u) == 0)
            v144 = __p;
          else
            v144 = (void **)__p[0];
          SEUpdaterUtil::SELogObj::printLog(v137, (SEUpdaterUtil::SELogObj *)2, 0, 1, "DeleteEnablementPTA", (SEUpdaterUtil::SELogObj *)"PTA Package AID on device is %s, skipping delete operation\n", (const char *)v144);
          if (SBYTE7(v1758) < 0)
            operator delete(__p[0]);
          if (!v141)
            goto LABEL_365;
          v145 = (unint64_t *)&v141->__shared_owners_;
          do
            v146 = __ldaxr(v145);
          while (__stlxr(v146 - 1, v145));
          if (v146)
            goto LABEL_365;
          ((void (*)(std::__shared_weak_count *))v141->__on_zero_shared)(v141);
          v147 = v141;
        }
      }
      std::__shared_weak_count::__release_weak(v147);
LABEL_365:
      __p[0] = &v1783;
      std::vector<SEUpdater::PackageInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
      operator delete(v123);
      operator delete(v122);
      if (value.__r_.__value_.__r.__words[0])
        operator delete(value.__r_.__value_.__l.__data_);
      goto LABEL_367;
    }
    goto LABEL_224;
  }
  switch(v120)
  {
    case ',':
      if (*((_DWORD *)*v1 + 3) >= 0x298u)
        goto LABEL_229;
      break;
    case '6':
      if (*((_DWORD *)*v1 + 3) >= 0xBFu)
        goto LABEL_229;
      break;
    case 'd':
LABEL_224:
      if (*((_DWORD *)*v1 + 3) >= 0xE18u)
        goto LABEL_229;
      break;
    default:
      goto LABEL_229;
  }
LABEL_367:
  v69 = *v1;
LABEL_368:
  v203 = *((_DWORD *)v69 + 7);
  v206 = v203 != 23195 && v203 != 47411 && v203 != 47545;
  std::string::basic_string[abi:ne180100]<0>(__p, "skipSeshatCheck");
  v1723 = (uint64_t **)((char *)this + 88);
  v207 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)this + 88, (const void **)__p);
  if (SBYTE7(v1758) < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "ignoreSecureChannelAM");
  v208 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v1723, (const void **)__p);
  if (SBYTE7(v1758) < 0)
    operator delete(__p[0]);
  v209 = *v1;
  v210 = *((_DWORD *)*v1 + 3) != *((_DWORD *)*v1 + 6) || *((_DWORD *)v209 + 7) != 23195;
  if (v208)
    v211 = 1;
  else
    v211 = v206;
  if ((v211 & 1) == 0)
  {
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v1783, 0x2037uLL);
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF828;
    v212 = *((_QWORD *)this + 20);
    SEUpdater::CommandSelectISD::CommandSelectISD((SEUpdater::CommandSelectISD *)__p);
    SEUpdater::P73BaseSEController::transceive(v212, (uint64_t)__p, (uint64_t **)&v1783, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    __p[0] = &unk_24E0BF880;
    v214 = (std::__shared_weak_count *)v1758;
    if ((_QWORD)v1758)
    {
      v215 = (unint64_t *)(v1758 + 8);
      do
        v216 = __ldaxr(v215);
      while (__stlxr(v216 - 1, v215));
      if (!v216)
      {
        ((void (*)(std::__shared_weak_count *))v214->__on_zero_shared)(v214);
        std::__shared_weak_count::__release_weak(v214);
      }
    }
    SEUpdaterUtil::assertSW((uint64_t)&v1783, (const SERestoreInfo::RApdu *)"Failed to send Select ISD", v213);
    v217 = *((_QWORD *)this + 20);
    LODWORD(value.__r_.__value_.__l.__data_) = 240256;
    value.__r_.__value_.__s.__data_[4] = 0;
    SERestoreInfo::CApdu::CApdu(__p, &value, 5uLL, 0);
    __p[0] = &off_24E0C0660;
    SEUpdater::P73BaseSEController::transceive(v217, (uint64_t)__p, (uint64_t **)&v1783, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    __p[0] = &unk_24E0BF880;
    v219 = (std::__shared_weak_count *)v1758;
    if ((_QWORD)v1758)
    {
      v220 = (unint64_t *)(v1758 + 8);
      do
        v221 = __ldaxr(v220);
      while (__stlxr(v221 - 1, v220));
      if (!v221)
      {
        ((void (*)(std::__shared_weak_count *))v219->__on_zero_shared)(v219);
        std::__shared_weak_count::__release_weak(v219);
      }
    }
    SEUpdaterUtil::assertSW((uint64_t)&v1783, (const SERestoreInfo::RApdu *)"Failed to send CommandGetAMState", v218);
    v222 = *(_QWORD *)(v1783.__r_.__value_.__l.__size_ + 8);
    v1782.__r_.__value_.__r.__words[0] = *(_QWORD *)v1783.__r_.__value_.__l.__size_;
    v223 = v222 - v1782.__r_.__value_.__r.__words[0];
    if (v223 <= 1)
      __assert_rtn("getDataSize", "Apdu.hpp", 382, "len >= 2");
    v1782.__r_.__value_.__l.__size_ = v223 - 2;
    *(_OWORD *)&v1750.__r_.__value_.__l.__data_ = 0uLL;
    if (DERParseDERSequenceSpecContent((unint64_t *)&v1782, (uint64_t)&DStatusContainerItemSeqSpec, (char *)&v1750, 0x10uLL))
    {
      v1597 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(__p, "Failed to parse DStatusContainerItem");
      v1598 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1597, (__int128 *)__p, 14, CFSTR("SEUpdaterErrorDomain"));
    }
    v1759 = 0u;
    v1760 = 0u;
    *(_OWORD *)__p = 0u;
    v1758 = 0u;
    if (DERParseDERSequenceSpecContent((unint64_t *)&v1750, (uint64_t)&DStatusContainerDataItemSeqSpec, (char *)__p, 0x40uLL))
    {
      v1599 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&value, "Failed to parse DStatusContainerDataItem");
      v1600 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1599, (__int128 *)&value, 14, CFSTR("SEUpdaterErrorDomain"));
    }
    if (*((_QWORD *)&v1760 + 1) != 2)
    {
      v1601 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&value, "Bad length for context");
      v1602 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1601, (__int128 *)&value, 14, CFSTR("SEUpdaterErrorDomain"));
    }
    v224 = *(unsigned __int16 *)v1760;
    if (*((_QWORD *)&v1758 + 1) != 2)
    {
      v1603 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&value, "Bad length for AM status");
      v1604 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1603, (__int128 *)&value, 14, CFSTR("SEUpdaterErrorDomain"));
    }
    v225 = *(unsigned __int16 *)v1758;
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v226 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&value);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&value);
      v227 = (std::__shared_weak_count *)value.__r_.__value_.__l.__size_;
      if (value.__r_.__value_.__l.__size_)
      {
        v228 = (unint64_t *)(value.__r_.__value_.__l.__size_ + 8);
        do
          v229 = __ldaxr(v228);
        while (__stlxr(v229 - 1, v228));
        if (!v229)
        {
          ((void (*)(std::__shared_weak_count *))v227->__on_zero_shared)(v227);
          std::__shared_weak_count::__release_weak(v227);
        }
      }
      v226 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v230 = (std::__shared_weak_count *)off_2553234C8;
    v1742.__r_.__value_.__r.__words[0] = (std::string::size_type)v226;
    v1742.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v231 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v232 = __ldxr(v231);
      while (__stxr(v232 + 1, v231));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v226, (SEUpdaterUtil::SELogObj *)3, 0, 1, "isSCAMInProgress", (SEUpdaterUtil::SELogObj *)"Context 0x%X status 0x%X\n", __rev16(v224), __rev16(v225));
    if (v230)
    {
      v233 = (unint64_t *)&v230->__shared_owners_;
      do
        v234 = __ldaxr(v233);
      while (__stlxr(v234 - 1, v233));
      if (!v234)
      {
        ((void (*)(std::__shared_weak_count *))v230->__on_zero_shared)(v230);
        std::__shared_weak_count::__release_weak(v230);
      }
    }
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
    v235 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
    if (v1783.__r_.__value_.__r.__words[2])
    {
      v236 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
      do
        v237 = __ldaxr(v236);
      while (__stlxr(v237 - 1, v236));
      if (!v237)
      {
        ((void (*)(std::__shared_weak_count *))v235->__on_zero_shared)(v235);
        std::__shared_weak_count::__release_weak(v235);
      }
    }
    if (v224 == 42405 && v225 != 23130)
    {
      v238 = (const void *)*((_QWORD *)this + 15);
      v1737.__r_.__value_.__r.__words[0] = (std::string::size_type)v238;
      if (v238)
        CFRetain(v238);
      WriteEvent(1, &v1737);
      ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef((const void **)&v1737.__r_.__value_.__l.__data_);
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v239 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        v240 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          v241 = (unint64_t *)((char *)__p[1] + 8);
          do
            v242 = __ldaxr(v241);
          while (__stlxr(v242 - 1, v241));
          if (!v242)
          {
            ((void (*)(std::__shared_weak_count *))v240->__on_zero_shared)(v240);
            std::__shared_weak_count::__release_weak(v240);
          }
        }
        v239 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v243 = (std::__shared_weak_count *)off_2553234C8;
      value.__r_.__value_.__r.__words[0] = (std::string::size_type)v239;
      value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v244 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v245 = __ldxr(v244);
        while (__stxr(v245 + 1, v244));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v239, (SEUpdaterUtil::SELogObj *)1, 0, 1, "skipUpdate", (SEUpdaterUtil::SELogObj *)"Skip update since secure channel context AM is in progress\n");
      if (!v243)
        goto LABEL_528;
      v246 = (unint64_t *)&v243->__shared_owners_;
      do
        v247 = __ldaxr(v246);
      while (__stlxr(v247 - 1, v246));
LABEL_526:
      if (!v247)
      {
        ((void (*)(std::__shared_weak_count *))v243->__on_zero_shared)(v243);
        std::__shared_weak_count::__release_weak(v243);
      }
LABEL_528:
      *((_BYTE *)this + 80) = 1;
      goto LABEL_2668;
    }
    v1 = v1726;
    v209 = *v1726;
  }
  v248 = *((_DWORD *)v209 + 14) == 115 && *((_DWORD *)v209 + 3) < 0x1DBu;
  if (*((_BYTE *)this + 9))
    v249 = 0;
  else
    v249 = v207 == 0;
  if (!v249)
    v248 = 1;
  if (!v206 && !v210 && !v248)
  {
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&value, 0x2037uLL);
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF828;
    v250 = *((_QWORD *)this + 20);
    SEUpdater::CommandSelectSeshat::CommandSelectSeshat((SEUpdater::CommandSelectSeshat *)__p);
    SEUpdater::P73BaseSEController::transceive(v250, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    __p[0] = &unk_24E0BF880;
    v251 = (std::__shared_weak_count *)v1758;
    if ((_QWORD)v1758)
    {
      v252 = (unint64_t *)(v1758 + 8);
      do
        v253 = __ldaxr(v252);
      while (__stlxr(v253 - 1, v252));
      if (!v253)
      {
        ((void (*)(std::__shared_weak_count *))v251->__on_zero_shared)(v251);
        std::__shared_weak_count::__release_weak(v251);
      }
    }
    v254 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8);
    if ((unint64_t)(v254 - *(_QWORD *)value.__r_.__value_.__l.__size_) >= 2
      && (*(unsigned __int8 *)(v254 - 1) | (*(unsigned __int8 *)(v254 - 2) << 8)) == 0x9000)
    {
      v255 = *((_QWORD *)this + 20);
      LODWORD(v1783.__r_.__value_.__l.__data_) = 1408;
      SERestoreInfo::CApdu::CApdu(__p, &v1783, 4uLL, 0);
      __p[0] = &off_24E0C06A8;
      SEUpdater::P73BaseSEController::transceive(v255, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)3, 1);
      __p[0] = &unk_24E0BF880;
      v256 = (std::__shared_weak_count *)v1758;
      if ((_QWORD)v1758)
      {
        v257 = (unint64_t *)(v1758 + 8);
        do
          v258 = __ldaxr(v257);
        while (__stlxr(v258 - 1, v257));
        if (!v258)
        {
          ((void (*)(std::__shared_weak_count *))v256->__on_zero_shared)(v256);
          std::__shared_weak_count::__release_weak(v256);
        }
      }
      v259 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8);
      if ((unint64_t)(v259 - *(_QWORD *)value.__r_.__value_.__l.__size_) >= 2
        && (*(unsigned __int8 *)(v259 - 1) | (*(unsigned __int8 *)(v259 - 2) << 8)) == 0x9000)
      {
        *(_QWORD *)&v1758 = 0;
        __p[1] = 0;
        __p[0] = 0;
        v260 = *(_QWORD *)value.__r_.__value_.__l.__size_;
        v261 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8) - *(_QWORD *)value.__r_.__value_.__l.__size_;
        if (v261 == 35)
        {
          v262 = *(unsigned __int8 *)(v260 + 8);
          std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)__p, 0, (char *)(v260 + 9), (char *)(v260 + 33), 24);
        }
        else
        {
          if (v261 != 23)
          {
            pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v1511 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            if (!off_2553234C0)
            {
              SEUpdaterUtil::SELogObj::create_default_global(&v1783);
              std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
              v1512 = (std::__shared_weak_count *)v1783.__r_.__value_.__l.__size_;
              if (v1783.__r_.__value_.__l.__size_)
              {
                v1513 = (unint64_t *)(v1783.__r_.__value_.__l.__size_ + 8);
                do
                  v1514 = __ldaxr(v1513);
                while (__stlxr(v1514 - 1, v1513));
                if (!v1514)
                {
                  ((void (*)(std::__shared_weak_count *))v1512->__on_zero_shared)(v1512);
                  std::__shared_weak_count::__release_weak(v1512);
                }
              }
              v1511 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            }
            v1515 = (std::__shared_weak_count *)off_2553234C8;
            v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v1511;
            v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
            if (off_2553234C8)
            {
              v1516 = (unint64_t *)((char *)off_2553234C8 + 8);
              do
                v1517 = __ldxr(v1516);
              while (__stxr(v1517 + 1, v1516));
            }
            pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            SEUpdaterUtil::SELogObj::printLog(v1511, (SEUpdaterUtil::SELogObj *)1, 0, 1, "isSeshatEnrolledAndNotKUD", (SEUpdaterUtil::SELogObj *)"Seshat get data response is 0x%zx bytes, expected 0x%lx or 0x%lx", *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8) - *(_QWORD *)value.__r_.__value_.__l.__size_, 23, 35);
            if (v1515)
            {
              v1518 = (unint64_t *)&v1515->__shared_owners_;
              do
                v1519 = __ldaxr(v1518);
              while (__stlxr(v1519 - 1, v1518));
              if (!v1519)
              {
                ((void (*)(std::__shared_weak_count *))v1515->__on_zero_shared)(v1515);
                std::__shared_weak_count::__release_weak(v1515);
              }
            }
            v283 = 0;
            v284 = 0;
LABEL_2727:
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
            goto LABEL_504;
          }
          v262 = *(unsigned __int8 *)(v260 + 8);
          std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)__p, 0, (char *)(v260 + 9), (char *)(v260 + 21), 12);
        }
        if (v262 == 238)
        {
          for (i = (unsigned __int8 *)__p[0]; i != __p[1]; ++i)
          {
            if (*i != 238)
            {
              pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              v1545 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              if (!off_2553234C0)
              {
                SEUpdaterUtil::SELogObj::create_default_global(&v1783);
                std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
                v1546 = (std::__shared_weak_count *)v1783.__r_.__value_.__l.__size_;
                if (v1783.__r_.__value_.__l.__size_)
                {
                  v1547 = (unint64_t *)(v1783.__r_.__value_.__l.__size_ + 8);
                  do
                    v1548 = __ldaxr(v1547);
                  while (__stlxr(v1548 - 1, v1547));
                  if (!v1548)
                  {
                    ((void (*)(std::__shared_weak_count *))v1546->__on_zero_shared)(v1546);
                    std::__shared_weak_count::__release_weak(v1546);
                  }
                }
                v1545 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              }
              v1549 = (std::__shared_weak_count *)off_2553234C8;
              v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v1545;
              v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
              if (off_2553234C8)
              {
                v1550 = (unint64_t *)((char *)off_2553234C8 + 8);
                do
                  v1551 = __ldxr(v1550);
                while (__stxr(v1551 + 1, v1550));
              }
              pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              SEUpdaterUtil::SELogObj::printLog(v1545, (SEUpdaterUtil::SELogObj *)2, 0, 1, "isSeshatEnrolledAndNotKUD", (SEUpdaterUtil::SELogObj *)"At least one slot enrolled & no KUD\n");
              if (v1549)
              {
                v1552 = (unint64_t *)&v1549->__shared_owners_;
                do
                  v1553 = __ldaxr(v1552);
                while (__stlxr(v1553 - 1, v1552));
                if (!v1553)
                {
                  ((void (*)(std::__shared_weak_count *))v1549->__on_zero_shared)(v1549);
                  std::__shared_weak_count::__release_weak(v1549);
                }
              }
              SEUpdaterUtil::SELogPrintBinary((SEUpdaterUtil *)2, (uint64_t)__p[0], (const unsigned __int8 *)((char *)__p[1] - (char *)__p[0]), 0);
              v283 = 1;
              goto LABEL_2726;
            }
          }
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v1529 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(&v1783);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
            v1530 = (std::__shared_weak_count *)v1783.__r_.__value_.__l.__size_;
            if (v1783.__r_.__value_.__l.__size_)
            {
              v1531 = (unint64_t *)(v1783.__r_.__value_.__l.__size_ + 8);
              do
                v1532 = __ldaxr(v1531);
              while (__stlxr(v1532 - 1, v1531));
              if (!v1532)
              {
                ((void (*)(std::__shared_weak_count *))v1530->__on_zero_shared)(v1530);
                std::__shared_weak_count::__release_weak(v1530);
              }
            }
            v1529 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v1524 = (std::__shared_weak_count *)off_2553234C8;
          v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v1529;
          v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v1533 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v1534 = __ldxr(v1533);
            while (__stxr(v1534 + 1, v1533));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v1529, (SEUpdaterUtil::SELogObj *)2, 0, 1, "isSeshatEnrolledAndNotKUD", (SEUpdaterUtil::SELogObj *)"No slots are enrolled, can proceed\n");
          if (v1524)
          {
            v1535 = (unint64_t *)&v1524->__shared_owners_;
            do
              v1528 = __ldaxr(v1535);
            while (__stlxr(v1528 - 1, v1535));
            goto LABEL_2723;
          }
        }
        else
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v1520 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(&v1783);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
            v1521 = (std::__shared_weak_count *)v1783.__r_.__value_.__l.__size_;
            if (v1783.__r_.__value_.__l.__size_)
            {
              v1522 = (unint64_t *)(v1783.__r_.__value_.__l.__size_ + 8);
              do
                v1523 = __ldaxr(v1522);
              while (__stlxr(v1523 - 1, v1522));
              if (!v1523)
              {
                ((void (*)(std::__shared_weak_count *))v1521->__on_zero_shared)(v1521);
                std::__shared_weak_count::__release_weak(v1521);
              }
            }
            v1520 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v1524 = (std::__shared_weak_count *)off_2553234C8;
          v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v1520;
          v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v1525 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v1526 = __ldxr(v1525);
            while (__stxr(v1526 + 1, v1525));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v1520, (SEUpdaterUtil::SELogObj *)2, 0, 1, "isSeshatEnrolledAndNotKUD", (SEUpdaterUtil::SELogObj *)"KUD is set (0x%x), can proceed\n", v262);
          if (v1524)
          {
            v1527 = (unint64_t *)&v1524->__shared_owners_;
            do
              v1528 = __ldaxr(v1527);
            while (__stlxr(v1528 - 1, v1527));
LABEL_2723:
            if (!v1528)
            {
              ((void (*)(std::__shared_weak_count *))v1524->__on_zero_shared)(v1524);
              std::__shared_weak_count::__release_weak(v1524);
            }
          }
        }
        v283 = 0;
LABEL_2726:
        v284 = 1;
        goto LABEL_2727;
      }
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v274 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        v275 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          v276 = (unint64_t *)((char *)__p[1] + 8);
          do
            v277 = __ldaxr(v276);
          while (__stlxr(v277 - 1, v276));
          if (!v277)
          {
            ((void (*)(std::__shared_weak_count *))v275->__on_zero_shared)(v275);
            std::__shared_weak_count::__release_weak(v275);
          }
        }
        v274 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v267 = (std::__shared_weak_count *)off_2553234C8;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v274;
      v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v278 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v279 = __ldxr(v278);
        while (__stxr(v279 + 1, v278));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v280 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8);
      if ((unint64_t)(v280 - *(_QWORD *)value.__r_.__value_.__l.__size_) < 2)
        v281 = 0xFFFF;
      else
        v281 = *(unsigned __int8 *)(v280 - 1) | (*(unsigned __int8 *)(v280 - 2) << 8);
      SEUpdaterUtil::SELogObj::printLog(v274, (SEUpdaterUtil::SELogObj *)1, 0, 1, "isSeshatEnrolledAndNotKUD", (SEUpdaterUtil::SELogObj *)"Failed to GET_DATA Seshat 0x%x\n", v281);
      if (!v267)
      {
LABEL_503:
        v283 = 0;
        v284 = 0;
LABEL_504:
        value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
        v285 = (std::__shared_weak_count *)value.__r_.__value_.__r.__words[2];
        if (value.__r_.__value_.__r.__words[2])
        {
          v286 = (unint64_t *)(value.__r_.__value_.__r.__words[2] + 8);
          do
            v287 = __ldaxr(v286);
          while (__stlxr(v287 - 1, v286));
          if (!v287)
          {
            ((void (*)(std::__shared_weak_count *))v285->__on_zero_shared)(v285);
            std::__shared_weak_count::__release_weak(v285);
          }
        }
        if (!v284)
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v1641 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(__p);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
            std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)__p);
            v1641 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1641;
          value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v1642 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v1643 = __ldxr(v1642);
            while (__stxr(v1643 + 1, v1642));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v1641, (SEUpdaterUtil::SELogObj *)2, 0, 1, "skipUpdate", (SEUpdaterUtil::SELogObj *)"Failed to query Seshat KUD status, pass forceUpdate if you really know what you are doing and want to skip it\n");
          std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&value);
          v1644 = __cxa_allocate_exception(0x48uLL);
          std::string::basic_string[abi:ne180100]<0>(__p, "Failed to query Seshat KUD");
          v1645 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1644, (__int128 *)__p, 35, CFSTR("SEUpdaterErrorDomain"));
        }
        if (v283)
        {
          v288 = (const __CFDictionary *)*((_QWORD *)this + 15);
          v1731 = v288;
          if (v288)
            CFRetain(v288);
          WriteEvent(2, &v1731);
          ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef((const void **)&v1731);
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v289 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(__p);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
            v290 = (std::__shared_weak_count *)__p[1];
            if (__p[1])
            {
              v291 = (unint64_t *)((char *)__p[1] + 8);
              do
                v292 = __ldaxr(v291);
              while (__stlxr(v292 - 1, v291));
              if (!v292)
              {
                ((void (*)(std::__shared_weak_count *))v290->__on_zero_shared)(v290);
                std::__shared_weak_count::__release_weak(v290);
              }
            }
            v289 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v243 = (std::__shared_weak_count *)off_2553234C8;
          value.__r_.__value_.__r.__words[0] = (std::string::size_type)v289;
          value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v293 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v294 = __ldxr(v293);
            while (__stxr(v294 + 1, v293));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v289, (SEUpdaterUtil::SELogObj *)1, 0, 1, "skipUpdate", (SEUpdaterUtil::SELogObj *)"Skipping SE Updater due to enrolled Seshat\n");
          if (!v243)
            goto LABEL_528;
          v295 = (unint64_t *)&v243->__shared_owners_;
          do
            v247 = __ldaxr(v295);
          while (__stlxr(v247 - 1, v295));
          goto LABEL_526;
        }
        v209 = *v1;
        goto LABEL_530;
      }
      v282 = (unint64_t *)&v267->__shared_owners_;
      do
        v273 = __ldaxr(v282);
      while (__stlxr(v273 - 1, v282));
    }
    else
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v263 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        v264 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          v265 = (unint64_t *)((char *)__p[1] + 8);
          do
            v266 = __ldaxr(v265);
          while (__stlxr(v266 - 1, v265));
          if (!v266)
          {
            ((void (*)(std::__shared_weak_count *))v264->__on_zero_shared)(v264);
            std::__shared_weak_count::__release_weak(v264);
          }
        }
        v263 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v267 = (std::__shared_weak_count *)off_2553234C8;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v263;
      v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v268 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v269 = __ldxr(v268);
        while (__stxr(v269 + 1, v268));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v270 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8);
      if ((unint64_t)(v270 - *(_QWORD *)value.__r_.__value_.__l.__size_) < 2)
        v271 = 0xFFFF;
      else
        v271 = *(unsigned __int8 *)(v270 - 1) | (*(unsigned __int8 *)(v270 - 2) << 8);
      SEUpdaterUtil::SELogObj::printLog(v263, (SEUpdaterUtil::SELogObj *)1, 0, 1, "isSeshatEnrolledAndNotKUD", (SEUpdaterUtil::SELogObj *)"Failed to SELECT Seshat 0x%x?\n", v271);
      if (!v267)
        goto LABEL_503;
      v272 = (unint64_t *)&v267->__shared_owners_;
      do
        v273 = __ldaxr(v272);
      while (__stlxr(v273 - 1, v272));
    }
    if (!v273)
    {
      ((void (*)(std::__shared_weak_count *))v267->__on_zero_shared)(v267);
      std::__shared_weak_count::__release_weak(v267);
    }
    goto LABEL_503;
  }
LABEL_530:
  v296 = *((_DWORD *)*v1724 + 30);
  v297 = *((_DWORD *)v209 + 4);
  if (v296 <= v297)
  {
    std::string::basic_string[abi:ne180100]<0>(&v1731, "forceUpdate");
    if (!std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v1723, (const void **)&v1731)|| (v298 = *v1, *((_DWORD *)*v1 + 3) != *((_DWORD *)*v1 + 6))|| *((_DWORD *)v298 + 7) != 23195|| *((_DWORD *)v298 + 14) != 44)
    {
      LOBYTE(v314) = 0;
      goto LABEL_563;
    }
  }
  else if (*((_DWORD *)v209 + 3) != *((_DWORD *)v209 + 6)
         || *((_DWORD *)v209 + 7) != 23195
         || *((_DWORD *)v209 + 14) != 44)
  {
    goto LABEL_566;
  }
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&value, 0x2037uLL);
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF828;
  v299 = *((_QWORD *)this + 20);
  SEUpdater::CommandSelectCRS::CommandSelectCRS((SEUpdater::CommandSelectCRS *)__p);
  v300 = SEUpdater::P73BaseSEController::transceive(v299, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  __p[0] = &unk_24E0BF880;
  v301 = (std::__shared_weak_count *)v1758;
  if ((_QWORD)v1758)
  {
    v302 = (unint64_t *)(v1758 + 8);
    do
      v303 = __ldaxr(v302);
    while (__stlxr(v303 - 1, v302));
    if (!v303)
    {
      ((void (*)(std::__shared_weak_count *))v301->__on_zero_shared)(v301);
      std::__shared_weak_count::__release_weak(v301);
    }
  }
  if (v300
    || (v304 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8),
        (unint64_t)(v304 - *(_QWORD *)value.__r_.__value_.__l.__size_) < 2)
    || (*(unsigned __int8 *)(v304 - 1) | (*(unsigned __int8 *)(v304 - 2) << 8)) != 0x9000)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v530 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v531 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v532 = (unint64_t *)((char *)__p[1] + 8);
        do
          v533 = __ldaxr(v532);
        while (__stlxr(v533 - 1, v532));
        if (!v533)
        {
          ((void (*)(std::__shared_weak_count *))v531->__on_zero_shared)(v531);
          std::__shared_weak_count::__release_weak(v531);
        }
      }
      v530 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v534 = (std::__shared_weak_count *)off_2553234C8;
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v530;
    v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v535 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v536 = __ldxr(v535);
      while (__stxr(v536 + 1, v535));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v537 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8);
    if ((unint64_t)(v537 - *(_QWORD *)value.__r_.__value_.__l.__size_) < 2)
      v538 = 43947;
    else
      v538 = *(unsigned __int8 *)(v537 - 1) | (*(unsigned __int8 *)(v537 - 2) << 8);
    SEUpdaterUtil::SELogObj::printLog(v530, 0, 0, 1, "shouldAbortToAvoidBrick", (SEUpdaterUtil::SELogObj *)"Failed to select CRS 0x%X\n", v538);
    if (!v534)
      goto LABEL_1196;
    v663 = (unint64_t *)&v534->__shared_owners_;
    do
      v664 = __ldaxr(v663);
    while (__stlxr(v664 - 1, v663));
    if (v664)
      goto LABEL_1196;
    ((void (*)(std::__shared_weak_count *))v534->__on_zero_shared)(v534);
    v665 = v534;
  }
  else
  {
    v305 = *((_QWORD *)this + 20);
    LODWORD(v1783.__r_.__value_.__l.__data_) = -754922880;
    v1783.__r_.__value_.__s.__data_[4] = 0;
    SERestoreInfo::CApdu::CApdu(__p, &v1783, 5uLL, 0);
    __p[0] = &off_24E0C0588;
    v306 = SEUpdater::P73BaseSEController::transceive(v305, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    __p[0] = &unk_24E0BF880;
    v307 = (std::__shared_weak_count *)v1758;
    if ((_QWORD)v1758)
    {
      v308 = (unint64_t *)(v1758 + 8);
      do
        v309 = __ldaxr(v308);
      while (__stlxr(v309 - 1, v308));
      if (!v309)
      {
        ((void (*)(std::__shared_weak_count *))v307->__on_zero_shared)(v307);
        std::__shared_weak_count::__release_weak(v307);
      }
    }
    if (!v306)
    {
      v310 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8);
      if ((unint64_t)(v310 - *(_QWORD *)value.__r_.__value_.__l.__size_) >= 2
        && (*(unsigned __int8 *)(v310 - 1) | (*(unsigned __int8 *)(v310 - 2) << 8)) == 0x9000)
      {
        *(_OWORD *)&v1782.__r_.__value_.__l.__data_ = 0uLL;
        v1782.__r_.__value_.__r.__words[0] = *(_QWORD *)value.__r_.__value_.__l.__size_;
        v1782.__r_.__value_.__l.__size_ = SERestoreInfo::RApdu::getDataSize((SERestoreInfo::RApdu *)&value);
        __p[1] = 0;
        __p[0] = 0;
        *(_QWORD *)&v1758 = 0;
        if (DERDecodeItem((uint64_t)&v1782, (unint64_t *)__p))
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v311 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(&v1783);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
            std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1783);
            v311 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)v311;
          v1750.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v312 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v313 = __ldxr(v312);
            while (__stxr(v313 + 1, v312));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v311, 0, 0, 1, "shouldAbortToAvoidBrick", (SEUpdaterUtil::SELogObj *)"Failed to parse CRS get perso state response\n");
          std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1750);
          goto LABEL_1196;
        }
        if (__p[0] == (void *)0xC000000000000013)
        {
          if ((_QWORD)v1758)
          {
            v1613 = *(unsigned __int8 *)__p[1];
            if (v1613 != 197 && v1613 != 195 || *((_DWORD *)*v1724 + 30) >= 0x1AEu && *((_DWORD *)*v1726 + 4) > 0x191u)
            {
              v314 = 0;
              goto LABEL_2862;
            }
            pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v1614 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            if (!off_2553234C0)
            {
              SEUpdaterUtil::SELogObj::create_default_global(&v1783);
              std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
              std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1783);
              v1614 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            }
            v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)v1614;
            v1750.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
            if (off_2553234C8)
            {
              v1615 = (unint64_t *)((char *)off_2553234C8 + 8);
              do
                v1616 = __ldxr(v1615);
              while (__stxr(v1616 + 1, v1615));
            }
            pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            SEUpdaterUtil::SELogObj::printLog(v1614, 0, 0, 1, "shouldAbortToAvoidBrick", (SEUpdaterUtil::SELogObj *)"Aborting due to DO BSN 0x%X <= 0x01AD or device RSN 0x%X < 0x0192\n", *((_DWORD *)*v1724 + 30), *((_DWORD *)*v1726 + 4));
          }
          else
          {
            pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v1626 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            if (!off_2553234C0)
            {
              SEUpdaterUtil::SELogObj::create_default_global(&v1783);
              std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
              std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1783);
              v1626 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            }
            v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)v1626;
            v1750.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
            if (off_2553234C8)
            {
              v1627 = (unint64_t *)((char *)off_2553234C8 + 8);
              do
                v1628 = __ldxr(v1627);
              while (__stxr(v1628 + 1, v1627));
            }
            pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            SEUpdaterUtil::SELogObj::printLog(v1626, 0, 0, 1, "shouldAbortToAvoidBrick", (SEUpdaterUtil::SELogObj *)"Unexpected length for perso state response\n");
          }
        }
        else
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v1620 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(&v1783);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
            std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1783);
            v1620 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)v1620;
          v1750.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v1621 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v1622 = __ldxr(v1621);
            while (__stxr(v1622 + 1, v1621));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v1620, 0, 0, 1, "shouldAbortToAvoidBrick", (SEUpdaterUtil::SELogObj *)"Unexpected tag for perso state\n");
        }
        std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1750);
        v314 = 1;
LABEL_2862:
        v1 = v1726;
        goto LABEL_1197;
      }
    }
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1536 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v1537 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v1538 = (unint64_t *)((char *)__p[1] + 8);
        do
          v1539 = __ldaxr(v1538);
        while (__stlxr(v1539 - 1, v1538));
        if (!v1539)
        {
          ((void (*)(std::__shared_weak_count *))v1537->__on_zero_shared)(v1537);
          std::__shared_weak_count::__release_weak(v1537);
        }
      }
      v1536 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v1540 = (std::__shared_weak_count *)off_2553234C8;
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1536;
    v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v1541 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v1542 = __ldxr(v1541);
      while (__stxr(v1542 + 1, v1541));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v1536, 0, 0, 1, "shouldAbortToAvoidBrick", (SEUpdaterUtil::SELogObj *)"Failed to retrieve CRS perso state\n");
    if (!v1540)
      goto LABEL_1196;
    v1543 = (unint64_t *)&v1540->__shared_owners_;
    do
      v1544 = __ldaxr(v1543);
    while (__stlxr(v1544 - 1, v1543));
    if (v1544)
      goto LABEL_1196;
    ((void (*)(std::__shared_weak_count *))v1540->__on_zero_shared)(v1540);
    v665 = v1540;
  }
  std::__shared_weak_count::__release_weak(v665);
LABEL_1196:
  v314 = 1;
LABEL_1197:
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
  v666 = (std::__shared_weak_count *)value.__r_.__value_.__r.__words[2];
  if (value.__r_.__value_.__r.__words[2])
  {
    v667 = (unint64_t *)(value.__r_.__value_.__r.__words[2] + 8);
    do
      v668 = __ldaxr(v667);
    while (__stlxr(v668 - 1, v667));
    if (!v668)
    {
      ((void (*)(std::__shared_weak_count *))v666->__on_zero_shared)(v666);
      std::__shared_weak_count::__release_weak(v666);
    }
  }
  if (v296 > v297)
  {
    if (!v314)
      goto LABEL_566;
LABEL_1204:
    v669 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__p, "This update would brick the SE due to rdar://problem/90407147");
    v670 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v669, (__int128 *)__p, 31, CFSTR("SEUpdaterErrorDomain"));
  }
LABEL_563:
  if (v1733 < 0)
    operator delete(v1731);
  if ((v314 & 1) != 0)
    goto LABEL_1204;
LABEL_566:
  std::string::basic_string[abi:ne180100]<0>(__p, "forceDeviceHwVersion");
  v315 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v1723, (const void **)__p);
  if (SBYTE7(v1758) < 0)
    operator delete(__p[0]);
  if (v315)
  {
    v1634 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__p, "Update was going to proceed but bailing out due to forceDeviceHwVersion debug arg; don't want to brick SEs");
    v1635 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1634, (__int128 *)__p, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  v316 = atomic_load((unsigned __int8 *)&qword_255323758);
  if ((v316 & 1) == 0 && __cxa_guard_acquire(&qword_255323758))
  {
    _MergedGlobals_2 = SEUpdater::getForceUpdateLoop(v1723);
    __cxa_guard_release(&qword_255323758);
    v1 = v1726;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v317 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v318 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v319 = (unint64_t *)((char *)__p[1] + 8);
      do
        v320 = __ldaxr(v319);
      while (__stlxr(v320 - 1, v319));
      if (!v320)
      {
        ((void (*)(std::__shared_weak_count *))v318->__on_zero_shared)(v318);
        std::__shared_weak_count::__release_weak(v318);
      }
    }
    v317 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v321 = (std::__shared_weak_count *)off_2553234C8;
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v317;
  value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v322 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v323 = __ldxr(v322);
    while (__stxr(v323 + 1, v322));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v317, (SEUpdaterUtil::SELogObj *)3, 0, 1, "doPerform", (SEUpdaterUtil::SELogObj *)"Found forceUpdateLoop: %lu\n", _MergedGlobals_2);
  if (v321)
  {
    v324 = (unint64_t *)&v321->__shared_owners_;
    do
      v325 = __ldaxr(v324);
    while (__stlxr(v325 - 1, v324));
    if (!v325)
    {
      ((void (*)(std::__shared_weak_count *))v321->__on_zero_shared)(v321);
      std::__shared_weak_count::__release_weak(v321);
    }
  }
  v326 = *v1;
  if (*((_DWORD *)*v1724 + 30) > *((_DWORD *)*v1 + 4) || _MergedGlobals_2 != 0)
  {
    v328 = (const char **)((char *)this + 200);
    v1718 = (void *)*MEMORY[0x24BEDB7E8];
    v1720 = *(void **)(MEMORY[0x24BEDB7E8] + 16);
    v1721 = *(void **)(MEMORY[0x24BEDB7E8] + 8);
    v1717 = *(void **)(MEMORY[0x24BEDB7E8] + 24);
    v1719 = MEMORY[0x24BEDB840] + 64;
    while (1)
    {
      v329 = *((_DWORD *)v326 + 7);
      if (v329 == 23195 || v329 == 47545 || v329 == 47411)
      {
        SEUpdater::P73BaseUpdateController::sendIm4M((const void **)this);
        SEUpdater::P73BaseUpdateController::sendIm4P(this);
        v326 = *v1726;
      }
      if (!*(_BYTE *)(*((_QWORD *)this + 20) + 16))
      {
        if (*((_DWORD *)v326 + 7) != 47545)
        {
          if (*((char *)this + 223) < 0)
          {
            if (!*((_QWORD *)this + 26))
              goto LABEL_617;
          }
          else if (!*((_BYTE *)this + 223))
          {
            goto LABEL_617;
          }
        }
        SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&value, 0x2037uLL);
        value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF828;
        (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 20) + 48))(*((_QWORD *)this + 20), 0);
        v332 = *((_QWORD *)this + 20);
        v1783.__r_.__value_.__r.__words[0] = 0xBEADDE041380704FLL;
        LOWORD(v1783.__r_.__value_.__r.__words[1]) = 239;
        SERestoreInfo::CApdu::CApdu(__p, &v1783, 0xAuLL, 0);
        __p[0] = &off_24E0C0348;
        (*(void (**)(uint64_t, void **, std::string *, uint64_t, uint64_t))(*(_QWORD *)v332 + 16))(v332, __p, &value, 3, 1);
        __p[0] = &unk_24E0BF880;
        v334 = (std::__shared_weak_count *)v1758;
        if ((_QWORD)v1758)
        {
          v335 = (unint64_t *)(v1758 + 8);
          do
            v336 = __ldaxr(v335);
          while (__stlxr(v336 - 1, v335));
          if (!v336)
          {
            ((void (*)(std::__shared_weak_count *))v334->__on_zero_shared)(v334);
            std::__shared_weak_count::__release_weak(v334);
          }
        }
        SEUpdaterUtil::assertSW((uint64_t)&value, (const SERestoreInfo::RApdu *)"Fail to switch to updaterOS", v333);
        SEUpdater::P73BaseUpdateController::sendManifestQuery(this);
        if (*((_DWORD *)*v1726 + 7) == 47545)
        {
          v1555 = __cxa_allocate_exception(0x48uLL);
          std::string::basic_string[abi:ne180100]<0>(__p, "Cannot switch to UOS");
          v1556 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1555, (__int128 *)__p, 30, CFSTR("SEUpdaterErrorDomain"));
        }
        value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
        v337 = (std::__shared_weak_count *)value.__r_.__value_.__r.__words[2];
        if (value.__r_.__value_.__r.__words[2])
        {
          v338 = (unint64_t *)(value.__r_.__value_.__r.__words[2] + 8);
          do
            v339 = __ldaxr(v338);
          while (__stlxr(v339 - 1, v338));
          if (!v339)
          {
            ((void (*)(std::__shared_weak_count *))v337->__on_zero_shared)(v337);
            std::__shared_weak_count::__release_weak(v337);
          }
        }
        v326 = *v1726;
      }
LABEL_617:
      v341 = (_DWORD *)*((_QWORD *)this + 17);
      v340 = *((_QWORD *)this + 18);
      v1730[0] = v326;
      v1730[1] = v341;
      if (v341)
      {
        v342 = (unint64_t *)(v341 + 2);
        do
          v343 = __ldxr(v342);
        while (__stxr(v343 + 1, v342));
      }
      NextAction = SERestoreInfo::P73BaseDeliveryObject::findNextAction(v340, v1730);
      if (v341)
      {
        v345 = (unint64_t *)(v341 + 2);
        do
          v346 = __ldaxr(v345);
        while (__stlxr(v346 - 1, v345));
        if (!v346)
        {
          (*(void (**)(_DWORD *))(*(_QWORD *)v341 + 16))(v341);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v341);
        }
      }
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v347 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        v348 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          v349 = (unint64_t *)((char *)__p[1] + 8);
          do
            v350 = __ldaxr(v349);
          while (__stlxr(v350 - 1, v349));
          if (!v350)
          {
            ((void (*)(std::__shared_weak_count *))v348->__on_zero_shared)(v348);
            std::__shared_weak_count::__release_weak(v348);
          }
        }
        v347 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v351 = (std::__shared_weak_count *)off_2553234C8;
      value.__r_.__value_.__r.__words[0] = (std::string::size_type)v347;
      value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v352 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v353 = __ldxr(v352);
        while (__stxr(v353 + 1, v352));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v347, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doPerform", (SEUpdaterUtil::SELogObj *)"Found action %d\n", NextAction);
      if (v351)
      {
        v354 = (unint64_t *)&v351->__shared_owners_;
        do
          v355 = __ldaxr(v354);
        while (__stlxr(v355 - 1, v354));
        if (!v355)
        {
          ((void (*)(std::__shared_weak_count *))v351->__on_zero_shared)(v351);
          std::__shared_weak_count::__release_weak(v351);
        }
      }
      SEUpdater::P73BaseUpdateController::doOneAction(this, NextAction);
      v356 = (_BYTE *)*((_QWORD *)this + 20);
      if (v356[16])
        (*(void (**)(_BYTE *, _QWORD))(*(_QWORD *)v356 + 48))(v356, 0);
      SEUpdater::P73BaseUpdateController::sendManifestQuery(this);
      if (*((char *)this + 223) < 0)
      {
        if (!*((_QWORD *)this + 26))
          goto LABEL_740;
      }
      else if (!*((_BYTE *)this + 223))
      {
        goto LABEL_740;
      }
      v357 = *((_DWORD *)*v1726 + 7);
      if (v357 == 47362 || v357 == 42242)
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v359 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(__p);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
          v360 = (std::__shared_weak_count *)__p[1];
          if (__p[1])
          {
            v361 = (unint64_t *)((char *)__p[1] + 8);
            do
              v362 = __ldaxr(v361);
            while (__stlxr(v362 - 1, v361));
            if (!v362)
            {
              ((void (*)(std::__shared_weak_count *))v360->__on_zero_shared)(v360);
              std::__shared_weak_count::__release_weak(v360);
            }
          }
          v359 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v363 = (std::__shared_weak_count *)off_2553234C8;
        value.__r_.__value_.__r.__words[0] = (std::string::size_type)v359;
        value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v364 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v365 = __ldxr(v364);
          while (__stxr(v365 + 1, v364));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v359, (SEUpdaterUtil::SELogObj *)2, 0, 1, "DumpSE", (SEUpdaterUtil::SELogObj *)"Starting SE Dump\n");
        if (v363)
        {
          v366 = (unint64_t *)&v363->__shared_owners_;
          do
            v367 = __ldaxr(v366);
          while (__stlxr(v367 - 1, v366));
          if (!v367)
          {
            ((void (*)(std::__shared_weak_count *))v363->__on_zero_shared)(v363);
            std::__shared_weak_count::__release_weak(v363);
          }
        }
        SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v1783, 0x2037uLL);
        v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF828;
        *(_QWORD *)&v1780[0] = v1719;
        __p[0] = v1721;
        *(void **)((char *)__p + *((_QWORD *)v1721 - 3)) = v1720;
        v368 = (std::ios_base *)((char *)__p + *((_QWORD *)__p[0] - 3));
        std::ios_base::init(v368, &__p[1]);
        v368[1].__vftable = 0;
        v368[1].__fmtflags_ = -1;
        __p[0] = (void *)(MEMORY[0x24BEDB840] + 24);
        *(_QWORD *)&v1780[0] = MEMORY[0x24BEDB840] + 64;
        MEMORY[0x22078A5BC](&__p[1]);
        if (!std::filebuf::open())
          std::ios_base::clear((std::ios_base *)((char *)__p + *((_QWORD *)__p[0] - 3)), *(_DWORD *)((char *)&v1759 + *((_QWORD *)__p[0] - 3)) | 4);
        if ((*((_BYTE *)&v1759 + *((_QWORD *)__p[0] - 3)) & 5) != 0)
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v369 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(&value);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&value);
            v370 = (std::__shared_weak_count *)value.__r_.__value_.__l.__size_;
            if (value.__r_.__value_.__l.__size_)
            {
              v371 = (unint64_t *)(value.__r_.__value_.__l.__size_ + 8);
              do
                v372 = __ldaxr(v371);
              while (__stlxr(v372 - 1, v371));
              if (!v372)
              {
                ((void (*)(std::__shared_weak_count *))v370->__on_zero_shared)(v370);
                std::__shared_weak_count::__release_weak(v370);
              }
            }
            v369 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v373 = (std::__shared_weak_count *)off_2553234C8;
          v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v369;
          v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v374 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v375 = __ldxr(v374);
            while (__stxr(v375 + 1, v374));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v376 = (char *)this + 200;
          if (*((char *)this + 223) < 0)
            v376 = *v328;
          SEUpdaterUtil::SELogObj::printLog(v369, 0, 0, 1, "DumpSE", (SEUpdaterUtil::SELogObj *)"Failed to open file %s\n", v376);
          if (v373)
          {
            v377 = (unint64_t *)&v373->__shared_owners_;
            do
              v378 = __ldaxr(v377);
            while (__stlxr(v378 - 1, v377));
LABEL_684:
            if (!v378)
            {
              ((void (*)(std::__shared_weak_count *))v373->__on_zero_shared)(v373);
              v379 = v373;
LABEL_733:
              std::__shared_weak_count::__release_weak(v379);
            }
          }
        }
        else
        {
          do
          {
            v380 = *((_QWORD *)this + 20);
            v1782.__r_.__value_.__r.__words[0] = 0x48DF02FE00CA80;
            SERestoreInfo::CApdu::CApdu(&value, &v1782, 8uLL, 0);
            value.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0858;
            v381 = (*(uint64_t (**)(uint64_t, std::string *, std::string *, uint64_t, uint64_t))(*(_QWORD *)v380 + 16))(v380, &value, &v1783, 3, 1);
            value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
            v382 = (std::__shared_weak_count *)value.__r_.__value_.__r.__words[2];
            if (value.__r_.__value_.__r.__words[2])
            {
              v383 = (unint64_t *)(value.__r_.__value_.__r.__words[2] + 8);
              do
                v384 = __ldaxr(v383);
              while (__stlxr(v384 - 1, v383));
              if (!v384)
              {
                ((void (*)(std::__shared_weak_count *))v382->__on_zero_shared)(v382);
                std::__shared_weak_count::__release_weak(v382);
              }
            }
            if (v381
              || (v385 = *(ctu **)v1783.__r_.__value_.__l.__size_,
                  v386 = *(_QWORD *)(v1783.__r_.__value_.__l.__size_ + 8),
                  v387 = v386 - *(_QWORD *)v1783.__r_.__value_.__l.__size_,
                  v388 = (unsigned __int8 *)(v387 - 2),
                  v387 < 2))
            {
              v389 = 61166;
LABEL_718:
              pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              v399 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              if (!off_2553234C0)
              {
                SEUpdaterUtil::SELogObj::create_default_global(&value);
                std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&value);
                v400 = (std::__shared_weak_count *)value.__r_.__value_.__l.__size_;
                if (value.__r_.__value_.__l.__size_)
                {
                  v401 = (unint64_t *)(value.__r_.__value_.__l.__size_ + 8);
                  do
                    v402 = __ldaxr(v401);
                  while (__stlxr(v402 - 1, v401));
                  if (!v402)
                  {
                    ((void (*)(std::__shared_weak_count *))v400->__on_zero_shared)(v400);
                    std::__shared_weak_count::__release_weak(v400);
                  }
                }
                v399 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              }
              v403 = (std::__shared_weak_count *)off_2553234C8;
              v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v399;
              v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
              if (off_2553234C8)
              {
                v404 = (unint64_t *)((char *)off_2553234C8 + 8);
                do
                  v405 = __ldxr(v404);
                while (__stxr(v405 + 1, v404));
              }
              pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              SEUpdaterUtil::SELogObj::printLog(v399, 0, 0, 1, "DumpSE", (SEUpdaterUtil::SELogObj *)"Failed to dump rc %d sw 0x%x\n", v381, v389);
              if (v403)
              {
                v406 = (unint64_t *)&v403->__shared_owners_;
                do
                  v407 = __ldaxr(v406);
                while (__stlxr(v407 - 1, v406));
                if (!v407)
                {
                  ((void (*)(std::__shared_weak_count *))v403->__on_zero_shared)(v403);
                  v379 = v403;
                  goto LABEL_733;
                }
              }
              goto LABEL_734;
            }
            v389 = *(unsigned __int8 *)(v386 - 1) | (v388[(_QWORD)v385] << 8);
            if (v389 != 36864 && v389 != 25360)
              goto LABEL_718;
            ctu::hex(v385, v388);
            std::ostream::write();
            if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0)
              operator delete(value.__r_.__value_.__l.__data_);
          }
          while (v389 == 25360);
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v391 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(&value);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&value);
            v392 = (std::__shared_weak_count *)value.__r_.__value_.__l.__size_;
            if (value.__r_.__value_.__l.__size_)
            {
              v393 = (unint64_t *)(value.__r_.__value_.__l.__size_ + 8);
              do
                v394 = __ldaxr(v393);
              while (__stlxr(v394 - 1, v393));
              if (!v394)
              {
                ((void (*)(std::__shared_weak_count *))v392->__on_zero_shared)(v392);
                std::__shared_weak_count::__release_weak(v392);
              }
            }
            v391 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v373 = (std::__shared_weak_count *)off_2553234C8;
          v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v391;
          v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v395 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v396 = __ldxr(v395);
            while (__stxr(v396 + 1, v395));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v397 = (char *)this + 200;
          if (*((char *)this + 223) < 0)
            v397 = *v328;
          SEUpdaterUtil::SELogObj::printLog(v391, (SEUpdaterUtil::SELogObj *)2, 0, 1, "DumpSE", (SEUpdaterUtil::SELogObj *)"Successfully dumped SE NVM to %s\n", v397);
          if (v373)
          {
            v398 = (unint64_t *)&v373->__shared_owners_;
            do
              v378 = __ldaxr(v398);
            while (__stlxr(v378 - 1, v398));
            goto LABEL_684;
          }
        }
LABEL_734:
        __p[0] = v1718;
        *(void **)((char *)__p + *((_QWORD *)v1718 - 3)) = v1717;
        MEMORY[0x22078A5C8](&__p[1]);
        std::ostream::~ostream();
        MEMORY[0x22078A778](v1780);
        v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
        v408 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
        if (v1783.__r_.__value_.__r.__words[2])
        {
          v409 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
          do
            v410 = __ldaxr(v409);
          while (__stlxr(v410 - 1, v409));
          if (!v410)
          {
            ((void (*)(std::__shared_weak_count *))v408->__on_zero_shared)(v408);
            std::__shared_weak_count::__release_weak(v408);
          }
        }
        MEMORY[0x22078A55C](v328, &unk_21CCDB9F7);
        SEUpdater::P73BaseUpdateController::sendManifestQuery(this);
      }
LABEL_740:
      if (!_MergedGlobals_2)
      {
        v411 = *v1724;
        v326 = *v1726;
        goto LABEL_746;
      }
      v326 = *v1726;
      v411 = *v1724;
      if (*((_DWORD *)*v1726 + 7) == 23195 && *((_DWORD *)v411 + 30) == *((_DWORD *)v326 + 4))
      {
        --_MergedGlobals_2;
        break;
      }
      if (!_MergedGlobals_2)
      {
LABEL_746:
        if (*((_DWORD *)v411 + 30) <= *((_DWORD *)v326 + 4))
          break;
      }
    }
  }
  if (*((_DWORD *)v326 + 3) != *((_DWORD *)v326 + 6) || *((_DWORD *)v326 + 7) != 23195)
  {
    v1632 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__p, "SE OS not in idle state");
    v1633 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1632, (__int128 *)__p, 1, CFSTR("SEUpdaterErrorDomain"));
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "forceFPF");
  v412 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v1723, (const void **)__p);
  if (SBYTE7(v1758) < 0)
    operator delete(__p[0]);
  v413 = *v1726;
  if (*((_DWORD *)*v1726 + 2) && *((_DWORD *)v413 + 7) == 23195 && *((_DWORD *)v413 + 36) == 0xFFFFFF)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "ignoreFPTear");
    v414 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v1723, (const void **)__p) == 0;
    if (SBYTE7(v1758) < 0)
      operator delete(__p[0]);
    v413 = *v1726;
  }
  else
  {
    v414 = 0;
  }
  v1722 = v412;
  v415 = *((_DWORD *)v413 + 7);
  v416 = *((_DWORD *)v413 + 36);
  v417 = *((_DWORD *)*v1724 + 30);
  v418 = *((unsigned __int8 *)*v1724 + 152);
  v419 = v416 >> 8;
  v420 = v416;
  v423 = (v416 >> 8 != v417 || v416 != v418) && v418 != 238;
  v424 = v415 == 23195 && v423;
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v425 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v426 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v427 = (unint64_t *)((char *)__p[1] + 8);
      do
        v428 = __ldaxr(v427);
      while (__stlxr(v428 - 1, v427));
      if (!v428)
      {
        ((void (*)(std::__shared_weak_count *))v426->__on_zero_shared)(v426);
        std::__shared_weak_count::__release_weak(v426);
      }
    }
    v425 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v429 = (std::__shared_weak_count *)off_2553234C8;
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v425;
  value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v430 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v431 = __ldxr(v430);
    while (__stxr(v431 + 1, v430));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v425, (SEUpdaterUtil::SELogObj *)1, 0, 1, "isFPRequired", (SEUpdaterUtil::SELogObj *)"deviceFPFBSN 0x%x deviceFPREV %d deliveryBSN 0x%x deliveryFPFRev %d amStateOK %d bsnChanged %d revChanged %d ret %d\n", v419, v420, v417, v418, v415 == 23195, v419 != v417, v420 != v418, v424);
  if (v429)
  {
    v432 = (unint64_t *)&v429->__shared_owners_;
    do
      v433 = __ldaxr(v432);
    while (__stlxr(v433 - 1, v432));
    if (!v433)
    {
      ((void (*)(std::__shared_weak_count *))v429->__on_zero_shared)(v429);
      std::__shared_weak_count::__release_weak(v429);
    }
  }
  v434 = *((_DWORD *)*v1724 + 30);
  v435 = *((_DWORD *)*v1726 + 6);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v436 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v437 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v438 = (unint64_t *)((char *)__p[1] + 8);
      do
        v439 = __ldaxr(v438);
      while (__stlxr(v439 - 1, v438));
      if (!v439)
      {
        ((void (*)(std::__shared_weak_count *))v437->__on_zero_shared)(v437);
        std::__shared_weak_count::__release_weak(v437);
      }
    }
    v436 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v440 = (std::__shared_weak_count *)off_2553234C8;
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v436;
  value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v441 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v442 = __ldxr(v441);
    while (__stxr(v442 + 1, v441));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v436, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doPerform", (SEUpdaterUtil::SELogObj *)"FPF: forced %d, torn %d, requested %d, required %d, allowed %d\n", v1722 != 0, v414, *((unsigned __int8 *)this + 224), v424, v434 == v435);
  if (v440)
  {
    v443 = (unint64_t *)&v440->__shared_owners_;
    do
      v444 = __ldaxr(v443);
    while (__stlxr(v444 - 1, v443));
    if (!v444)
    {
      ((void (*)(std::__shared_weak_count *))v440->__on_zero_shared)(v440);
      std::__shared_weak_count::__release_weak(v440);
    }
  }
  if (v1722)
  {
    v445 = v1726;
    if (v434 != v435)
    {
      v1605 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(__p, "Forced FPF with device BSN != firmware BSN");
      v1606 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1605, (__int128 *)__p, 2, CFSTR("SEUpdaterErrorDomain"));
    }
  }
  else
  {
    v445 = v1726;
    if (v434 != v435 || !v414 && (!v424 || !*((_BYTE *)this + 224)))
      goto LABEL_827;
  }
  if (!SERestoreInfo::P73BaseDeliveryObject::isFpAvailable(*v1724))
  {
    v1607 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__p, "No factory postflight in the update bundle");
    v1608 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1607, (__int128 *)__p, 15, CFSTR("SEUpdaterErrorDomain"));
  }
  SEUpdater::P73BaseUpdateController::sendIm4M((const void **)this);
  SEUpdater::P73BaseUpdateController::sendIm4P(this);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v446 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v447 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v448 = (unint64_t *)((char *)__p[1] + 8);
      do
        v449 = __ldaxr(v448);
      while (__stlxr(v449 - 1, v448));
      if (!v449)
      {
        ((void (*)(std::__shared_weak_count *))v447->__on_zero_shared)(v447);
        std::__shared_weak_count::__release_weak(v447);
      }
    }
    v446 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v450 = (std::__shared_weak_count *)off_2553234C8;
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v446;
  value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v451 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v452 = __ldxr(v451);
    while (__stxr(v452 + 1, v451));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v446, (SEUpdaterUtil::SELogObj *)2, 0, 1, "runFactoryPostflight", (SEUpdaterUtil::SELogObj *)"\n");
  if (v450)
  {
    v453 = (unint64_t *)&v450->__shared_owners_;
    do
      v454 = __ldaxr(v453);
    while (__stlxr(v454 - 1, v453));
    if (!v454)
    {
      ((void (*)(std::__shared_weak_count *))v450->__on_zero_shared)(v450);
      std::__shared_weak_count::__release_weak(v450);
    }
  }
  if (!*v1724)
  {
    v1609 = __cxa_allocate_exception(0x10uLL);
    v1610 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&value, "Assertion: ");
    v1611 = std::string::append(v1610, "fDeliveryObj");
    v1612 = *(_OWORD *)&v1611->__r_.__value_.__l.__data_;
    *(_QWORD *)&v1758 = *((_QWORD *)&v1611->__r_.__value_.__l + 2);
    *(_OWORD *)__p = v1612;
    v1611->__r_.__value_.__l.__size_ = 0;
    v1611->__r_.__value_.__r.__words[2] = 0;
    v1611->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v1609, __p);
  }
  SEUpdater::P73BaseUpdateController::deactivateAll(this, "FPF");
  FactoryPostflightAction = SERestoreInfo::P73BaseDeliveryObject::findFactoryPostflightAction(*v1724);
  SEUpdater::P73BaseUpdateController::doOneAction(this, FactoryPostflightAction);
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 20) + 48))(*((_QWORD *)this + 20), 0);
LABEL_827:
  if (!*((_BYTE *)this + 9))
    goto LABEL_884;
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&value, 0x2037uLL);
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF828;
  v456 = *((_QWORD *)this + 20);
  SEUpdater::CommandSelectCRS::CommandSelectCRS((SEUpdater::CommandSelectCRS *)__p);
  v457 = SEUpdater::P73BaseSEController::transceive(v456, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  __p[0] = &unk_24E0BF880;
  v458 = (std::__shared_weak_count *)v1758;
  if ((_QWORD)v1758)
  {
    v459 = (unint64_t *)(v1758 + 8);
    do
      v460 = __ldaxr(v459);
    while (__stlxr(v460 - 1, v459));
    if (!v460)
    {
      ((void (*)(std::__shared_weak_count *))v458->__on_zero_shared)(v458);
      std::__shared_weak_count::__release_weak(v458);
    }
  }
  if (v457
    || (v461 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8),
        (unint64_t)(v461 - *(_QWORD *)value.__r_.__value_.__l.__size_) < 2)
    || (*(unsigned __int8 *)(v461 - 1) | (*(unsigned __int8 *)(v461 - 2) << 8)) != 0x9000)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1579 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)__p);
      v1579 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1579;
    v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v1580 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v1581 = __ldxr(v1580);
      while (__stxr(v1581 + 1, v1580));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1582 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8);
    if ((unint64_t)(v1582 - *(_QWORD *)value.__r_.__value_.__l.__size_) < 2)
      v1583 = 43947;
    else
      v1583 = *(unsigned __int8 *)(v1582 - 1) | (*(unsigned __int8 *)(v1582 - 2) << 8);
    SEUpdaterUtil::SELogObj::printLog(v1579, 0, 0, 1, "markForDeleteAll", (SEUpdaterUtil::SELogObj *)"Failed to select CRS with ret %d SW: %x\n", v457, v1583);
  }
  else
  {
    v462 = *((_QWORD *)this + 20);
    LODWORD(v1783.__r_.__value_.__l.__data_) = 63104;
    WORD2(v1783.__r_.__value_.__r.__words[0]) = 20226;
    v1783.__r_.__value_.__s.__data_[6] = 0;
    SERestoreInfo::CApdu::CApdu(__p, &v1783, 7uLL, 0);
    __p[0] = &off_24E0C0468;
    v463 = SEUpdater::P73BaseSEController::transceive(v462, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    __p[0] = &unk_24E0BF880;
    v464 = (std::__shared_weak_count *)v1758;
    if ((_QWORD)v1758)
    {
      v465 = (unint64_t *)(v1758 + 8);
      do
        v466 = __ldaxr(v465);
      while (__stlxr(v466 - 1, v465));
      if (!v466)
      {
        ((void (*)(std::__shared_weak_count *))v464->__on_zero_shared)(v464);
        std::__shared_weak_count::__release_weak(v464);
      }
    }
    if (v463
      || (v467 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8),
          (unint64_t)(v467 - *(_QWORD *)value.__r_.__value_.__l.__size_) <= 1))
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v1584 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)__p);
        v1584 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1584;
      v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v1585 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v1586 = __ldxr(v1585);
        while (__stxr(v1586 + 1, v1585));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v1584, 0, 0, 1, "markForDeleteAll", (SEUpdaterUtil::SELogObj *)"Failed to set MFDAll ret: %d\n", v463);
    }
    else
    {
      v468 = *(unsigned __int8 *)(v467 - 1) | (*(unsigned __int8 *)(v467 - 2) << 8);
      if (v468 != 36864 && v468 != 27266)
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v1623 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(__p);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
          std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)__p);
          v1623 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1623;
        v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v1624 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v1625 = __ldxr(v1624);
          while (__stxr(v1625 + 1, v1624));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v1623, 0, 0, 1, "markForDeleteAll", (SEUpdaterUtil::SELogObj *)"Failed to set MFDAll SW: %x\n", v468);
        std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1783);
        v445 = v1726;
        goto LABEL_879;
      }
      v470 = *((_QWORD *)this + 20);
      SEUpdater::CommandSelectSeshat::CommandSelectSeshat((SEUpdater::CommandSelectSeshat *)__p);
      v471 = SEUpdater::P73BaseSEController::transceive(v470, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)3, 1);
      __p[0] = &unk_24E0BF880;
      v472 = (std::__shared_weak_count *)v1758;
      if ((_QWORD)v1758)
      {
        v473 = (unint64_t *)(v1758 + 8);
        do
          v474 = __ldaxr(v473);
        while (__stlxr(v474 - 1, v473));
        if (!v474)
        {
          ((void (*)(std::__shared_weak_count *))v472->__on_zero_shared)(v472);
          std::__shared_weak_count::__release_weak(v472);
        }
      }
      if (v471
        || (v475 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8),
            (unint64_t)(v475 - *(_QWORD *)value.__r_.__value_.__l.__size_) < 2)
        || (*(unsigned __int8 *)(v475 - 1) | (*(unsigned __int8 *)(v475 - 2) << 8)) != 0x9000)
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v1587 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(__p);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
          std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)__p);
          v1587 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1587;
        v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v1588 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v1589 = __ldxr(v1588);
          while (__stxr(v1589 + 1, v1588));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v1590 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8);
        if ((unint64_t)(v1590 - *(_QWORD *)value.__r_.__value_.__l.__size_) < 2)
          v1591 = 43947;
        else
          v1591 = *(unsigned __int8 *)(v1590 - 1) | (*(unsigned __int8 *)(v1590 - 2) << 8);
        SEUpdaterUtil::SELogObj::printLog(v1587, 0, 0, 1, "markForDeleteAll", (SEUpdaterUtil::SELogObj *)"Failed to select seshat with ret: %d and sw: %x\n", v471, v1591);
      }
      else
      {
        v476 = *((_QWORD *)this + 20);
        LODWORD(v1783.__r_.__value_.__l.__data_) = 15598720;
        SERestoreInfo::CApdu::CApdu(__p, &v1783, 4uLL, 0);
        __p[0] = &off_24E0C04F8;
        v477 = SEUpdater::P73BaseSEController::transceive(v476, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)3, 1);
        __p[0] = &unk_24E0BF880;
        v478 = (std::__shared_weak_count *)v1758;
        if ((_QWORD)v1758)
        {
          v479 = (unint64_t *)(v1758 + 8);
          do
            v480 = __ldaxr(v479);
          while (__stlxr(v480 - 1, v479));
          if (!v480)
          {
            ((void (*)(std::__shared_weak_count *))v478->__on_zero_shared)(v478);
            std::__shared_weak_count::__release_weak(v478);
          }
        }
        if (!v477)
        {
          v481 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8);
          if ((unint64_t)(v481 - *(_QWORD *)value.__r_.__value_.__l.__size_) >= 2
            && (*(unsigned __int8 *)(v481 - 1) | (*(unsigned __int8 *)(v481 - 2) << 8)) == 0x9000)
          {
            pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v482 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            if (!off_2553234C0)
            {
              SEUpdaterUtil::SELogObj::create_default_global(__p);
              std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
              v483 = (std::__shared_weak_count *)__p[1];
              if (__p[1])
              {
                v484 = (unint64_t *)((char *)__p[1] + 8);
                do
                  v485 = __ldaxr(v484);
                while (__stlxr(v485 - 1, v484));
                if (!v485)
                {
                  ((void (*)(std::__shared_weak_count *))v483->__on_zero_shared)(v483);
                  std::__shared_weak_count::__release_weak(v483);
                }
              }
              v482 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            }
            v486 = (std::__shared_weak_count *)off_2553234C8;
            v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v482;
            v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
            if (off_2553234C8)
            {
              v487 = (unint64_t *)((char *)off_2553234C8 + 8);
              do
                v488 = __ldxr(v487);
              while (__stxr(v488 + 1, v487));
            }
            pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            SEUpdaterUtil::SELogObj::printLog(v482, (SEUpdaterUtil::SELogObj *)1, 0, 1, "markForDeleteAll", (SEUpdaterUtil::SELogObj *)"Successfully MFD'ed all applets\n");
            if (v486)
            {
              v489 = (unint64_t *)&v486->__shared_owners_;
              do
                v490 = __ldaxr(v489);
              while (__stlxr(v490 - 1, v489));
              if (!v490)
              {
                ((void (*)(std::__shared_weak_count *))v486->__on_zero_shared)(v486);
                std::__shared_weak_count::__release_weak(v486);
              }
            }
            goto LABEL_879;
          }
        }
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v1592 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(__p);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
          std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)__p);
          v1592 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1592;
        v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v1593 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v1594 = __ldxr(v1593);
          while (__stxr(v1594 + 1, v1593));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v1595 = *(_QWORD *)(value.__r_.__value_.__l.__size_ + 8);
        if ((unint64_t)(v1595 - *(_QWORD *)value.__r_.__value_.__l.__size_) < 2)
          v1596 = 43947;
        else
          v1596 = *(unsigned __int8 *)(v1595 - 1) | (*(unsigned __int8 *)(v1595 - 2) << 8);
        SEUpdaterUtil::SELogObj::printLog(v1592, 0, 0, 1, "markForDeleteAll", (SEUpdaterUtil::SELogObj *)"Failed to kill all slots with ret: %d and sw: %x\n", v477, v1596);
      }
    }
  }
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1783);
LABEL_879:
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
  v491 = (std::__shared_weak_count *)value.__r_.__value_.__r.__words[2];
  if (value.__r_.__value_.__r.__words[2])
  {
    v492 = (unint64_t *)(value.__r_.__value_.__r.__words[2] + 8);
    do
      v493 = __ldaxr(v492);
    while (__stlxr(v493 - 1, v492));
    if (!v493)
    {
      ((void (*)(std::__shared_weak_count *))v491->__on_zero_shared)(v491);
      std::__shared_weak_count::__release_weak(v491);
    }
  }
LABEL_884:
  v494 = SEUpdater::P73BaseUpdateController::getSEHealthCheckResult(this);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v495 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v496 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v497 = (unint64_t *)((char *)__p[1] + 8);
      do
        v498 = __ldaxr(v497);
      while (__stlxr(v498 - 1, v497));
      if (!v498)
      {
        ((void (*)(std::__shared_weak_count *))v496->__on_zero_shared)(v496);
        std::__shared_weak_count::__release_weak(v496);
      }
    }
    v495 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v499 = (std::__shared_weak_count *)off_2553234C8;
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v495;
  value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v500 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v501 = __ldxr(v500);
    while (__stxr(v501 + 1, v500));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v502 = "FAILED";
  if (!v494)
    v502 = "PASS";
  SEUpdaterUtil::SELogObj::printLog(v495, (SEUpdaterUtil::SELogObj *)1, 0, 1, "performSEHealthCheck", (SEUpdaterUtil::SELogObj *)"SE Health check result: %s\n", v502);
  if (!v499)
    goto LABEL_900;
  v503 = (unint64_t *)&v499->__shared_owners_;
  do
    v504 = __ldaxr(v503);
  while (__stlxr(v504 - 1, v503));
  if (!v504)
  {
    ((void (*)(std::__shared_weak_count *))v499->__on_zero_shared)(v499);
    std::__shared_weak_count::__release_weak(v499);
    if (!v494)
      goto LABEL_931;
  }
  else
  {
LABEL_900:
    if (!v494)
      goto LABEL_931;
  }
  v505 = (char *)this + 176;
  v506 = *((char *)this + 199);
  if (v506 < 0)
  {
    if (*((_QWORD *)this + 23) != 4)
      goto LABEL_909;
    v507 = *(_DWORD **)v505;
  }
  else
  {
    v507 = (_DWORD *)((char *)this + 176);
    if (v506 != 4)
    {
LABEL_909:
      std::string::basic_string[abi:ne180100]<0>(__p, "forceProd");
      if (std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v1723, (const void **)__p))
      {
        v508 = 1;
      }
      else
      {
        v508 = !SERestoreInfo::P73BaseDeviceInfo::isDev(*v445);
      }
      if (SBYTE7(v1758) < 0)
        operator delete(__p[0]);
      v509 = *((_DWORD *)*v445 + 14) == 115 && *((_DWORD *)*v445 + 3) < 0x1AEu;
      v510 = *((char *)this + 199);
      if (v510 < 0)
      {
        if (*((_QWORD *)this + 23) != 5)
        {
LABEL_926:
          if (!v508)
            goto LABEL_931;
          if (!*((_BYTE *)this + 11))
            std::__throw_bad_optional_access[abi:ne180100]();
          if (!*((_BYTE *)this + 10))
            v509 = 1;
          if (v509)
            goto LABEL_931;
LABEL_2882:
          v1647 = __cxa_allocate_exception(0x48uLL);
          std::string::basic_string[abi:ne180100]<0>(__p, "SE Hardware Failure!");
          v1648 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1647, (__int128 *)__p, 30, CFSTR("SEUpdaterErrorDomain"));
        }
        v505 = *(char **)v505;
      }
      else if (v510 != 5)
      {
        goto LABEL_926;
      }
      if (*(_DWORD *)v505 == 1668443974 && v505[4] == 101)
        goto LABEL_2882;
      goto LABEL_926;
    }
  }
  if (*v507 != 1885956947)
    goto LABEL_909;
LABEL_931:
  if (*((_DWORD *)*v445 + 14) == 54 && SERestoreInfo::P73BaseDeviceInfo::isProdEval(*v445))
  {
    v512 = 1;
    goto LABEL_1147;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "skipAppletCleanup");
  v513 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v1723, (const void **)__p);
  v514 = v513;
  if (SBYTE7(v1758) < 0)
  {
    operator delete(__p[0]);
    if (v514)
      goto LABEL_1145;
  }
  else if (v513)
  {
    goto LABEL_1145;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v515 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v516 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v517 = (unint64_t *)((char *)__p[1] + 8);
      do
        v518 = __ldaxr(v517);
      while (__stlxr(v518 - 1, v517));
      if (!v518)
      {
        ((void (*)(std::__shared_weak_count *))v516->__on_zero_shared)(v516);
        std::__shared_weak_count::__release_weak(v516);
      }
    }
    v515 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v519 = (std::__shared_weak_count *)off_2553234C8;
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v515;
  value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v520 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v521 = __ldxr(v520);
    while (__stxr(v521 + 1, v520));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v515, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doPerform", (SEUpdaterUtil::SELogObj *)"Cleaning up unused applets\n");
  if (v519)
  {
    v522 = (unint64_t *)&v519->__shared_owners_;
    do
      v523 = __ldaxr(v522);
    while (__stlxr(v523 - 1, v522));
    if (!v523)
    {
      ((void (*)(std::__shared_weak_count *))v519->__on_zero_shared)(v519);
      std::__shared_weak_count::__release_weak(v519);
    }
  }
  v524 = (_DWORD *)*((_QWORD *)this + 16);
  v525 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
  *(_QWORD *)&v1756 = v524;
  *((_QWORD *)&v1756 + 1) = v525;
  if (v525)
  {
    v526 = (unint64_t *)&v525->__shared_owners_;
    do
      v527 = __ldxr(v526);
    while (__stxr(v527 + 1, v526));
  }
  v528 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v524 + 32))(v524);
  switch(v528)
  {
    case 200:
      goto LABEL_959;
    case 115:
      v529 = 1294;
LABEL_973:
      v539 = v524[3] > v529;
      if (!v525)
        goto LABEL_979;
      goto LABEL_976;
    case 100:
LABEL_959:
      v529 = 1608;
      goto LABEL_973;
  }
  v539 = 1;
  if (!v525)
    goto LABEL_979;
LABEL_976:
  v540 = (unint64_t *)&v525->__shared_owners_;
  do
    v541 = __ldaxr(v540);
  while (__stlxr(v541 - 1, v540));
  if (!v541)
  {
    ((void (*)(std::__shared_weak_count *))v525->__on_zero_shared)(v525);
    std::__shared_weak_count::__release_weak(v525);
    if (!v539)
      goto LABEL_1145;
    goto LABEL_980;
  }
LABEL_979:
  if (!v539)
    goto LABEL_1145;
LABEL_980:
  v542 = (unint64_t *)*((_QWORD *)this + 21);
  cf = (CFTypeRef)*((_QWORD *)this + 20);
  v1755 = v542;
  if (v542)
  {
    v543 = v542 + 1;
    do
      v544 = __ldxr(v543);
    while (__stxr(v544 + 1, v543));
  }
  SEUpdater::GetPackageInfo((uint64_t *)&cf, (std::string::size_type *)&v1783);
  v545 = (std::__shared_weak_count *)v1755;
  if (v1755)
  {
    v546 = v1755 + 1;
    do
      v547 = __ldaxr(v546);
    while (__stlxr(v547 - 1, v546));
    if (!v547)
    {
      ((void (*)(std::__shared_weak_count *))v545->__on_zero_shared)(v545);
      std::__shared_weak_count::__release_weak(v545);
    }
  }
  v548 = *((_QWORD *)this + 21);
  *(_QWORD *)&v1753 = *((_QWORD *)this + 20);
  *((_QWORD *)&v1753 + 1) = v548;
  if (v548)
  {
    v549 = (unint64_t *)(v548 + 8);
    do
      v550 = __ldxr(v549);
    while (__stxr(v550 + 1, v549));
  }
  SEUpdater::GetInstanceInfo((uint64_t *)&v1753, (std::string::size_type *)&v1782);
  v551 = (std::__shared_weak_count *)*((_QWORD *)&v1753 + 1);
  if (*((_QWORD *)&v1753 + 1))
  {
    v552 = (unint64_t *)(*((_QWORD *)&v1753 + 1) + 8);
    do
      v553 = __ldaxr(v552);
    while (__stlxr(v553 - 1, v552));
    if (!v553)
    {
      ((void (*)(std::__shared_weak_count *))v551->__on_zero_shared)(v551);
      std::__shared_weak_count::__release_weak(v551);
    }
  }
  std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(__p, *((_QWORD *)this + 20), *((std::__shared_weak_count **)this + 21));
  v1752 = *(_OWORD *)__p;
  v554 = (std::__shared_weak_count *)operator new(0x20uLL);
  v554->__shared_owners_ = 0;
  v554->__shared_weak_owners_ = 0;
  v554->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1170;
  v554[1].__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C11C0;
  *(_QWORD *)&v1751 = v554 + 1;
  *((_QWORD *)&v1751 + 1) = v554;
  isDev = SERestoreInfo::P73BaseDeviceInfo::isDev(*v445);
  __p[0] = "Neon Delete";
  v556 = operator new(0x10uLL);
  __p[1] = v556;
  *v556 = xmmword_21CCD8A60;
  *((_QWORD *)&v1758 + 1) = v556 + 1;
  *(_QWORD *)&v1758 = v556 + 1;
  *(_QWORD *)&v1759 = "SLAMDeleteNeon";
  WORD4(v1759) = 3;
  *(_QWORD *)&v1760 = "Pioneer Delete";
  *((_QWORD *)&v1760 + 1) = 0;
  v1761[0] = 0uLL;
  v557 = operator new(8uLL);
  *((_QWORD *)&v1760 + 1) = v557;
  *v557 = 0x100021400005691;
  *((_QWORD *)&v1761[0] + 1) = v557 + 1;
  *(_QWORD *)&v1761[0] = v557 + 1;
  *(_QWORD *)&v1761[1] = "SLAMDeletePioneer";
  WORD4(v1761[1]) = 3;
  *(_QWORD *)&v1761[2] = "Davenport Delete";
  memset((char *)&v1761[2] + 8, 0, 24);
  v558 = operator new(0xAuLL);
  *(_QWORD *)v558 = 0x1018040040000A0;
  v558[4] = 256;
  *((_QWORD *)&v1761[2] + 1) = v558;
  *(_QWORD *)&v1761[3] = v558 + 5;
  *((_QWORD *)&v1761[3] + 1) = v558 + 5;
  *(_QWORD *)&v1762 = "SLAMDeleteDavenport";
  WORD4(v1762) = 3;
  *(_QWORD *)&v1763 = "Xenon Delete";
  *((_QWORD *)&v1763 + 1) = 0;
  v1764 = 0uLL;
  v559 = operator new(0x10uLL);
  *((_QWORD *)&v1763 + 1) = v559;
  *v559 = xmmword_21CCD8A70;
  *((_QWORD *)&v1764 + 1) = v559 + 1;
  *(_QWORD *)&v1764 = v559 + 1;
  *(_QWORD *)&v1765 = "SLAMDeleteXenon";
  WORD4(v1765) = 3;
  *(_QWORD *)&v1766 = "Bee Delete";
  *((_QWORD *)&v1766 + 1) = 0;
  v1767 = 0uLL;
  v560 = operator new(0xAuLL);
  *(_QWORD *)v560 = 0x2008158080000A0;
  v560[4] = 1;
  *((_QWORD *)&v1766 + 1) = v560;
  *(_QWORD *)&v1767 = v560 + 5;
  *((_QWORD *)&v1767 + 1) = v560 + 5;
  *(_QWORD *)&v1768 = "SLAMDeleteBeeLegacy";
  WORD4(v1768) = 259;
  memset(&v1750, 0, sizeof(v1750));
  v1742.__r_.__value_.__r.__words[0] = (std::string::size_type)&v1750;
  v1742.__r_.__value_.__s.__data_[8] = 0;
  v561 = 0;
  v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0xF0uLL);
  v1750.__r_.__value_.__l.__size_ = v1750.__r_.__value_.__r.__words[0];
  v1750.__r_.__value_.__r.__words[2] = v1750.__r_.__value_.__r.__words[0] + 240;
  v1737.__r_.__value_.__r.__words[0] = v1750.__r_.__value_.__r.__words[0];
  v1748 = v1750.__r_.__value_.__r.__words[0];
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)&v1750.__r_.__value_.__r.__words[2];
  value.__r_.__value_.__l.__size_ = (std::string::size_type)&v1748;
  value.__r_.__value_.__r.__words[2] = (std::string::size_type)&v1737;
  v562 = v1750.__r_.__value_.__r.__words[0];
  v1787[0] = 0;
  do
  {
    *(_QWORD *)v562 = __p[v561];
    *(_QWORD *)(v562 + 16) = 0;
    *(_QWORD *)(v562 + 24) = 0;
    *(_QWORD *)(v562 + 8) = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v562 + 8), __p[v561 + 1], (uint64_t)__p[v561 + 2], (_BYTE *)__p[v561 + 2] - (_BYTE *)__p[v561 + 1]);
    v563 = *(_QWORD *)((char *)&v1759 + v561 * 8);
    *(_WORD *)(v562 + 40) = *(_WORD *)((char *)&v1759 + v561 * 8 + 8);
    *(_QWORD *)(v562 + 32) = v563;
    v562 = v1737.__r_.__value_.__r.__words[0] + 48;
    v1737.__r_.__value_.__r.__words[0] += 48;
    v561 += 6;
  }
  while (v561 != 30);
  v1787[0] = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<SLAM::Deletion::Trigger>,SLAM::Deletion::Trigger*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&value);
  v564 = 0;
  v1750.__r_.__value_.__l.__size_ = v562;
  do
  {
    v565 = *(void **)((char *)&v1766 + v564 + 8);
    if (v565)
    {
      *(_QWORD *)((char *)&v1767 + v564) = v565;
      operator delete(v565);
    }
    v564 -= 48;
  }
  while (v564 != -240);
  v567 = v1750.__r_.__value_.__l.__size_;
  v566 = (const char **)v1750.__r_.__value_.__r.__words[0];
  if (v1750.__r_.__value_.__r.__words[0] != v1750.__r_.__value_.__l.__size_)
  {
    if (isDev)
      v568 = 1;
    else
      v568 = 2;
    while (1)
    {
      if ((v568 & (_BYTE)v566[5]) != 0)
      {
        v569 = v1783.__r_.__value_.__l.__size_;
        if (v569 == SEUpdater::find_if<std::vector<SEUpdater::PackageInfo>,SEUpdater::FindPackageForModule(std::vector<SEUpdater::PackageInfo> const&,std::vector<unsigned char> const&)::{lambda(std::vector<SEUpdater::PackageInfo> const&)#1}>((uint64_t)v1783.__r_.__value_.__l.__data_, v1783.__r_.__value_.__l.__size_, (uint64_t)(v566 + 1)))
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v588 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(__p);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
            v589 = (std::__shared_weak_count *)__p[1];
            if (__p[1])
            {
              v590 = (unint64_t *)((char *)__p[1] + 8);
              do
                v591 = __ldaxr(v590);
              while (__stlxr(v591 - 1, v590));
              if (!v591)
              {
                ((void (*)(std::__shared_weak_count *))v589->__on_zero_shared)(v589);
                std::__shared_weak_count::__release_weak(v589);
              }
            }
            v588 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v583 = (std::__shared_weak_count *)off_2553234C8;
          value.__r_.__value_.__r.__words[0] = (std::string::size_type)v588;
          value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v592 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v593 = __ldxr(v592);
            while (__stxr(v593 + 1, v592));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v588, (SEUpdaterUtil::SELogObj *)2, 0, 1, "deleteUnusedApplets", (SEUpdaterUtil::SELogObj *)"Skipping cleanup script <%s, %s> because package is not found\n", *v566, v566[4]);
          if (!v583)
            goto LABEL_1129;
          v594 = (unint64_t *)&v583->__shared_owners_;
          do
            v587 = __ldaxr(v594);
          while (__stlxr(v587 - 1, v594));
        }
        else if (*((_BYTE *)v566 + 41) && !*((_BYTE *)this + 9))
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v602 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(__p);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
            v603 = (std::__shared_weak_count *)__p[1];
            if (__p[1])
            {
              v604 = (unint64_t *)((char *)__p[1] + 8);
              do
                v605 = __ldaxr(v604);
              while (__stlxr(v605 - 1, v604));
              if (!v605)
              {
                ((void (*)(std::__shared_weak_count *))v603->__on_zero_shared)(v603);
                std::__shared_weak_count::__release_weak(v603);
              }
            }
            v602 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v583 = (std::__shared_weak_count *)off_2553234C8;
          value.__r_.__value_.__r.__words[0] = (std::string::size_type)v602;
          value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v606 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v607 = __ldxr(v606);
            while (__stxr(v607 + 1, v606));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v602, (SEUpdaterUtil::SELogObj *)2, 0, 1, "deleteUnusedApplets", (SEUpdaterUtil::SELogObj *)"Skipping cleanup script <%s, %s> because of no erase install\n", *v566, v566[4]);
          if (!v583)
            goto LABEL_1129;
          v608 = (unint64_t *)&v583->__shared_owners_;
          do
            v587 = __ldaxr(v608);
          while (__stlxr(v587 - 1, v608));
        }
        else
        {
          v570 = v1782.__r_.__value_.__l.__size_;
          v571 = v1782.__r_.__value_.__r.__words[0];
          if (v1782.__r_.__value_.__l.__size_ != v1782.__r_.__value_.__r.__words[0])
          {
            v572 = v566[1];
            v573 = v566[2] - v572;
            while (1)
            {
              v574 = *(const void **)(v571 + 24);
              if (v573 == *(_QWORD *)(v571 + 32) - (_QWORD)v574
                && !memcmp(v572, v574, v573)
                && (**(unsigned __int8 **)(v571 + 48) | 4) != 7)
              {
                break;
              }
              v571 += 72;
              if (v571 == v570)
              {
                SEUpdater::P73BaseUpdateController::deactivateAll(this, "SLAM");
                std::string::basic_string[abi:ne180100]<0>(&v1742, (char *)v566[4]);
                v575 = v1752;
                v1747 = v1752;
                if (*((_QWORD *)&v1752 + 1))
                {
                  v576 = (unint64_t *)(*((_QWORD *)&v1752 + 1) + 8);
                  do
                    v577 = __ldxr(v576);
                  while (__stxr(v577 + 1, v576));
                  v1749 = (std::__shared_weak_count *)*((_QWORD *)&v575 + 1);
                  do
                    v578 = __ldxr(v576);
                  while (__stxr(v578 + 1, v576));
                }
                else
                {
                  v1749 = 0;
                }
                v1748 = v575;
                if (!(_QWORD)v575)
                  goto LABEL_2917;
                v609 = v1751;
                v1745 = v1751;
                if (*((_QWORD *)&v1751 + 1))
                {
                  v610 = (unint64_t *)(*((_QWORD *)&v1751 + 1) + 8);
                  do
                    v611 = __ldxr(v610);
                  while (__stxr(v611 + 1, v610));
                  *((_QWORD *)&v1746 + 1) = *((_QWORD *)&v609 + 1);
                  do
                    v612 = __ldxr(v610);
                  while (__stxr(v612 + 1, v610));
                }
                else
                {
                  *((_QWORD *)&v1746 + 1) = 0;
                }
                *(_QWORD *)&v1746 = v609;
                if (!(_QWORD)v609)
                  goto LABEL_2917;
                SLAM::SLAM::PerformScript((uint64_t)&v1742, (uint64_t *)&v1748, (uint64_t *)&v1746, (uint64_t)__p);
                v613 = (std::__shared_weak_count *)*((_QWORD *)&v1746 + 1);
                if (*((_QWORD *)&v1746 + 1))
                {
                  v614 = (unint64_t *)(*((_QWORD *)&v1746 + 1) + 8);
                  do
                    v615 = __ldaxr(v614);
                  while (__stlxr(v615 - 1, v614));
                  if (!v615)
                  {
                    ((void (*)(std::__shared_weak_count *))v613->__on_zero_shared)(v613);
                    std::__shared_weak_count::__release_weak(v613);
                  }
                }
                v616 = (std::__shared_weak_count *)*((_QWORD *)&v1745 + 1);
                if (*((_QWORD *)&v1745 + 1))
                {
                  v617 = (unint64_t *)(*((_QWORD *)&v1745 + 1) + 8);
                  do
                    v618 = __ldaxr(v617);
                  while (__stlxr(v618 - 1, v617));
                  if (!v618)
                  {
                    ((void (*)(std::__shared_weak_count *))v616->__on_zero_shared)(v616);
                    std::__shared_weak_count::__release_weak(v616);
                  }
                }
                v619 = v1749;
                if (v1749)
                {
                  v620 = (unint64_t *)&v1749->__shared_owners_;
                  do
                    v621 = __ldaxr(v620);
                  while (__stlxr(v621 - 1, v620));
                  if (!v621)
                  {
                    ((void (*)(std::__shared_weak_count *))v619->__on_zero_shared)(v619);
                    std::__shared_weak_count::__release_weak(v619);
                  }
                }
                v622 = (std::__shared_weak_count *)*((_QWORD *)&v1747 + 1);
                if (*((_QWORD *)&v1747 + 1))
                {
                  v623 = (unint64_t *)(*((_QWORD *)&v1747 + 1) + 8);
                  do
                    v624 = __ldaxr(v623);
                  while (__stlxr(v624 - 1, v623));
                  if (!v624)
                  {
                    ((void (*)(std::__shared_weak_count *))v622->__on_zero_shared)(v622);
                    std::__shared_weak_count::__release_weak(v622);
                  }
                }
                if (SHIBYTE(v1742.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v1742.__r_.__value_.__l.__data_);
                if (BYTE8(v1758))
                {
                  v1646 = v1752;
                  v1741 = v1752;
                  if (*((_QWORD *)&v1752 + 1))
                  {
                    v1665 = (unint64_t *)(*((_QWORD *)&v1752 + 1) + 8);
                    do
                      v1666 = __ldxr(v1665);
                    while (__stxr(v1666 + 1, v1665));
                    v1744 = (unint64_t *)*((_QWORD *)&v1646 + 1);
                    do
                      v1667 = __ldxr(v1665);
                    while (__stxr(v1667 + 1, v1665));
                  }
                  else
                  {
                    v1744 = 0;
                  }
                  v1743 = (CFTypeRef)v1646;
                  if ((_QWORD)v1646)
                  {
                    v1668 = v1751;
                    v1738 = v1751;
                    if (*((_QWORD *)&v1751 + 1))
                    {
                      v1669 = (unint64_t *)(*((_QWORD *)&v1751 + 1) + 8);
                      do
                        v1670 = __ldxr(v1669);
                      while (__stxr(v1670 + 1, v1669));
                      v1740 = *((_QWORD *)&v1668 + 1);
                      do
                        v1671 = __ldxr(v1669);
                      while (__stxr(v1671 + 1, v1669));
                    }
                    else
                    {
                      v1740 = 0;
                    }
                    v1739 = v1668;
                    if ((_QWORD)v1668)
                    {
                      SLAM::SLAM::PerformRecovery((uint64_t *)&v1743, &v1739, (uint64_t)&value);
                      if (v1787[0])
                      {
                        v1737.__r_.__value_.__r.__words[0] = (std::string::size_type)&value;
                        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v1737);
                      }
                      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1739);
                      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1738);
                      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1743);
                      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1741);
                      v1672 = __cxa_allocate_exception(0x48uLL);
                      v1673 = SLAM::Error::Add((std::vector<std::string> *)__p, "At cleanup script: %s, %s\n", *v566, v566[4]);
                      ctu::join<std::__wrap_iter<std::string const*>>(v1673->__begin_, v1673->__end_, ", ", 2uLL, &v1737);
                      v1674 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1672, (__int128 *)&v1737, 36, CFSTR("SEUpdaterErrorDomain"));
                    }
                  }
                  goto LABEL_2917;
                }
                pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                v625 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                if (!off_2553234C0)
                {
                  SEUpdaterUtil::SELogObj::create_default_global(&value);
                  std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&value);
                  v626 = (std::__shared_weak_count *)value.__r_.__value_.__l.__size_;
                  if (value.__r_.__value_.__l.__size_)
                  {
                    v627 = (unint64_t *)(value.__r_.__value_.__l.__size_ + 8);
                    do
                      v628 = __ldaxr(v627);
                    while (__stlxr(v628 - 1, v627));
                    if (!v628)
                    {
                      ((void (*)(std::__shared_weak_count *))v626->__on_zero_shared)(v626);
                      std::__shared_weak_count::__release_weak(v626);
                    }
                  }
                  v625 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                }
                v629 = (std::__shared_weak_count *)off_2553234C8;
                v1737.__r_.__value_.__r.__words[0] = (std::string::size_type)v625;
                v1737.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
                if (off_2553234C8)
                {
                  v630 = (unint64_t *)((char *)off_2553234C8 + 8);
                  do
                    v631 = __ldxr(v630);
                  while (__stxr(v631 + 1, v630));
                }
                pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                SEUpdaterUtil::SELogObj::printLog(v625, (SEUpdaterUtil::SELogObj *)2, 0, 1, "deleteUnusedApplets", (SEUpdaterUtil::SELogObj *)"Cleanup script <%s, %s> executed successfully!\n", *v566, v566[4]);
                if (v629)
                {
                  v632 = (unint64_t *)&v629->__shared_owners_;
                  do
                    v633 = __ldaxr(v632);
                  while (__stlxr(v633 - 1, v632));
                  if (!v633)
                  {
                    ((void (*)(std::__shared_weak_count *))v629->__on_zero_shared)(v629);
                    std::__shared_weak_count::__release_weak(v629);
                  }
                }
                if (BYTE8(v1758))
                {
                  value.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
                  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&value);
                }
                goto LABEL_1129;
              }
            }
          }
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v595 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(__p);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
            v596 = (std::__shared_weak_count *)__p[1];
            if (__p[1])
            {
              v597 = (unint64_t *)((char *)__p[1] + 8);
              do
                v598 = __ldaxr(v597);
              while (__stlxr(v598 - 1, v597));
              if (!v598)
              {
                ((void (*)(std::__shared_weak_count *))v596->__on_zero_shared)(v596);
                std::__shared_weak_count::__release_weak(v596);
              }
            }
            v595 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v583 = (std::__shared_weak_count *)off_2553234C8;
          value.__r_.__value_.__r.__words[0] = (std::string::size_type)v595;
          value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v599 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v600 = __ldxr(v599);
            while (__stxr(v600 + 1, v599));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v595, (SEUpdaterUtil::SELogObj *)2, 0, 1, "deleteUnusedApplets", (SEUpdaterUtil::SELogObj *)"Skipping cleanup script <%s, %s> because module is not in selectable or installed state\n", *v566, v566[4]);
          if (!v583)
            goto LABEL_1129;
          v601 = (unint64_t *)&v583->__shared_owners_;
          do
            v587 = __ldaxr(v601);
          while (__stlxr(v587 - 1, v601));
        }
      }
      else
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v579 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(__p);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
          v580 = (std::__shared_weak_count *)__p[1];
          if (__p[1])
          {
            v581 = (unint64_t *)((char *)__p[1] + 8);
            do
              v582 = __ldaxr(v581);
            while (__stlxr(v582 - 1, v581));
            if (!v582)
            {
              ((void (*)(std::__shared_weak_count *))v580->__on_zero_shared)(v580);
              std::__shared_weak_count::__release_weak(v580);
            }
          }
          v579 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v583 = (std::__shared_weak_count *)off_2553234C8;
        value.__r_.__value_.__r.__words[0] = (std::string::size_type)v579;
        value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v584 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v585 = __ldxr(v584);
          while (__stxr(v585 + 1, v584));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v579, (SEUpdaterUtil::SELogObj *)2, 0, 1, "deleteUnusedApplets", (SEUpdaterUtil::SELogObj *)"Skipping cleanup script <%s, %s> by key\n", *v566, v566[4]);
        if (!v583)
          goto LABEL_1129;
        v586 = (unint64_t *)&v583->__shared_owners_;
        do
          v587 = __ldaxr(v586);
        while (__stlxr(v587 - 1, v586));
      }
      if (!v587)
      {
        ((void (*)(std::__shared_weak_count *))v583->__on_zero_shared)(v583);
        std::__shared_weak_count::__release_weak(v583);
      }
LABEL_1129:
      v566 += 6;
      if (v566 == (const char **)v567)
      {
        v554 = (std::__shared_weak_count *)*((_QWORD *)&v1751 + 1);
        __p[0] = &v1750;
        std::vector<SLAM::Deletion::Trigger>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
        v445 = v1726;
        if (!v554)
          goto LABEL_1139;
        goto LABEL_1135;
      }
    }
  }
  __p[0] = &v1750;
  std::vector<SLAM::Deletion::Trigger>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  v445 = v1726;
LABEL_1135:
  v634 = (unint64_t *)&v554->__shared_owners_;
  do
    v635 = __ldaxr(v634);
  while (__stlxr(v635 - 1, v634));
  if (!v635)
  {
    ((void (*)(std::__shared_weak_count *))v554->__on_zero_shared)(v554);
    std::__shared_weak_count::__release_weak(v554);
  }
LABEL_1139:
  v636 = (std::__shared_weak_count *)*((_QWORD *)&v1752 + 1);
  if (*((_QWORD *)&v1752 + 1))
  {
    v637 = (unint64_t *)(*((_QWORD *)&v1752 + 1) + 8);
    do
      v638 = __ldaxr(v637);
    while (__stlxr(v638 - 1, v637));
    if (!v638)
    {
      ((void (*)(std::__shared_weak_count *))v636->__on_zero_shared)(v636);
      std::__shared_weak_count::__release_weak(v636);
    }
  }
  __p[0] = &v1782;
  std::vector<SEUpdater::InstanceInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  __p[0] = &v1783;
  std::vector<SEUpdater::PackageInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
LABEL_1145:
  std::string::basic_string[abi:ne180100]<0>(__p, "skipSLAM");
  v512 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v1723, (const void **)__p) != 0;
  if (SBYTE7(v1758) < 0)
    operator delete(__p[0]);
LABEL_1147:
  v639 = *((_DWORD *)*v445 + 4);
  v640 = *((_DWORD *)*v1724 + 30);
  std::string::basic_string[abi:ne180100]<0>(__p, "forceSLAM");
  v641 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v1723, (const void **)__p);
  if (SBYTE7(v1758) < 0)
    operator delete(__p[0]);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v642 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v643 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v644 = (unint64_t *)((char *)__p[1] + 8);
      do
        v645 = __ldaxr(v644);
      while (__stlxr(v645 - 1, v644));
      if (!v645)
      {
        ((void (*)(std::__shared_weak_count *))v643->__on_zero_shared)(v643);
        std::__shared_weak_count::__release_weak(v643);
      }
    }
    v642 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v646 = (std::__shared_weak_count *)off_2553234C8;
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v642;
  value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v647 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v648 = __ldxr(v647);
    while (__stxr(v648 + 1, v647));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v642, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doPerform", (SEUpdaterUtil::SELogObj *)"RSN 0x%X BSN 0x%X, skipSLAM %d forceSLAM %d\n", *((_DWORD *)*v1726 + 4), *((_DWORD *)*v1724 + 30), v512, v641 != 0);
  if (v646)
  {
    v649 = (unint64_t *)&v646->__shared_owners_;
    do
      v650 = __ldaxr(v649);
    while (__stlxr(v650 - 1, v649));
    if (!v650)
    {
      ((void (*)(std::__shared_weak_count *))v646->__on_zero_shared)(v646);
      std::__shared_weak_count::__release_weak(v646);
    }
  }
  v652 = v639 == v640 || v641 != 0;
  v653 = v1726;
  if (!v512 && v652)
  {
    SEUpdater::P73BaseUpdateController::PerformSLAMMigrations(this);
    if ((*((_DWORD *)*v1726 + 14) & 0xFFFFFFFE) != 0x36)
      goto LABEL_1341;
    v654 = *((_QWORD *)this + 21);
    v1737.__r_.__value_.__r.__words[0] = *((_QWORD *)this + 20);
    v1737.__r_.__value_.__l.__size_ = v654;
    if (v654)
    {
      v655 = (unint64_t *)(v654 + 8);
      do
        v656 = __ldxr(v655);
      while (__stxr(v656 + 1, v655));
    }
    SEUpdater::GetPackageInfo((uint64_t *)&v1737, (std::string::size_type *)&v1783);
    v657 = (std::__shared_weak_count *)v1737.__r_.__value_.__l.__size_;
    if (v1737.__r_.__value_.__l.__size_)
    {
      v658 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
      do
        v659 = __ldaxr(v658);
      while (__stlxr(v659 - 1, v658));
      if (!v659)
      {
        ((void (*)(std::__shared_weak_count *))v657->__on_zero_shared)(v657);
        std::__shared_weak_count::__release_weak(v657);
      }
    }
    v660 = SERestoreInfo::P73BaseDeviceInfo::isDev(*v1726);
    v661 = *((_DWORD *)*v1726 + 14);
    v662 = 1;
    if (v661 <= 114)
    {
      if (v661 == 44)
      {
        v662 = 2;
        goto LABEL_1206;
      }
      if (v661 != 100)
        goto LABEL_1188;
    }
    else if (v661 != 115 && v661 != 200 && v661 != 210)
    {
LABEL_1188:
      v662 = 4;
    }
LABEL_1206:
    __p[0] = "PTC Load and install SLAM";
    v671 = (char *)operator new(0xCuLL);
    *(_DWORD *)v671 = 117440672;
    *((_WORD *)v671 + 2) = -16380;
    *(_DWORD *)(v671 + 6) = 0;
    *((_WORD *)v671 + 5) = 256;
    __p[1] = v671;
    *(_QWORD *)&v1758 = v671 + 12;
    *((_QWORD *)&v1758 + 1) = v671 + 12;
    *(_QWORD *)&v1759 = "SLAMLoadAndInstallPTC";
    WORD4(v1759) = 1027;
    *(_QWORD *)&v1760 = "Krypton Load and install SLAM";
    v672 = operator new(0xFuLL);
    *(_QWORD *)v672 = 0x4F430033030000A0;
    v672[2] = 1229018190;
    *((_WORD *)v672 + 6) = 17742;
    *((_BYTE *)v672 + 14) = 82;
    *((_QWORD *)&v1760 + 1) = v672;
    *(_QWORD *)&v1761[0] = (char *)v672 + 15;
    *((_QWORD *)&v1761[0] + 1) = (char *)v672 + 15;
    *(_QWORD *)&v1761[1] = "SLAMLoadAndInstallKrypton_3_2_4_0H_eosv2";
    WORD4(v1761[1]) = 1027;
    memset(&v1782, 0, sizeof(v1782));
    v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)&v1782;
    v1750.__r_.__value_.__s.__data_[8] = 0;
    v673 = 0;
    v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x60uLL);
    v1782.__r_.__value_.__l.__size_ = v1782.__r_.__value_.__r.__words[0];
    v1782.__r_.__value_.__r.__words[2] = v1782.__r_.__value_.__r.__words[0] + 96;
    v1742.__r_.__value_.__r.__words[0] = v1782.__r_.__value_.__r.__words[0];
    *(_QWORD *)&v1756 = v1782.__r_.__value_.__r.__words[0];
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)&v1782.__r_.__value_.__r.__words[2];
    value.__r_.__value_.__l.__size_ = (std::string::size_type)&v1756;
    value.__r_.__value_.__r.__words[2] = (std::string::size_type)&v1742;
    v674 = v1782.__r_.__value_.__r.__words[0];
    v1787[0] = 0;
    do
    {
      *(_QWORD *)v674 = __p[v673];
      *(_QWORD *)(v674 + 16) = 0;
      *(_QWORD *)(v674 + 24) = 0;
      *(_QWORD *)(v674 + 8) = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v674 + 8), __p[v673 + 1], (uint64_t)__p[v673 + 2], (_BYTE *)__p[v673 + 2] - (_BYTE *)__p[v673 + 1]);
      *(_QWORD *)(v674 + 32) = *(_QWORD *)((char *)&v1759 + v673 * 8);
      *(_WORD *)(v674 + 40) = *(_WORD *)((char *)&v1759 + v673 * 8 + 8);
      v674 = v1742.__r_.__value_.__r.__words[0] + 48;
      v1742.__r_.__value_.__r.__words[0] += 48;
      v673 += 6;
    }
    while (v673 != 12);
    v1787[0] = 1;
    std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<SLAM::Deletion::Trigger>,SLAM::Deletion::Trigger*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&value);
    v675 = 0;
    v1782.__r_.__value_.__l.__size_ = v674;
    do
    {
      v676 = *(void **)((char *)&v1760 + v675 * 16 + 8);
      if (v676)
      {
        *(_QWORD *)&v1761[v675] = v676;
        operator delete(v676);
      }
      v675 -= 3;
    }
    while (v675 != -6);
    v677 = v1782.__r_.__value_.__l.__size_;
    v678 = (const char **)v1782.__r_.__value_.__r.__words[0];
    if (v1782.__r_.__value_.__r.__words[0] != v1782.__r_.__value_.__l.__size_)
    {
      if (v660)
        v679 = 1;
      else
        v679 = 2;
      v680 = "PreLoadEligibleApplets";
      do
      {
        if ((v679 & (_BYTE)v678[5]) != 0)
        {
          if ((*((_BYTE *)v678 + 41) & v662) != 0)
          {
            v681 = v1783.__r_.__value_.__l.__size_;
            if (v681 == SEUpdater::find_if<std::vector<SEUpdater::PackageInfo>,SEUpdater::FindPackageForModule(std::vector<SEUpdater::PackageInfo> const&,std::vector<unsigned char> const&)::{lambda(std::vector<SEUpdater::PackageInfo> const&)#1}>((uint64_t)v1783.__r_.__value_.__l.__data_, v1783.__r_.__value_.__l.__size_, (uint64_t)(v678 + 1)))
            {
              pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              v705 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              if (!off_2553234C0)
              {
                SEUpdaterUtil::SELogObj::create_default_global(__p);
                std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
                v706 = (std::__shared_weak_count *)__p[1];
                if (__p[1])
                {
                  v707 = (unint64_t *)((char *)__p[1] + 8);
                  do
                    v708 = __ldaxr(v707);
                  while (__stlxr(v708 - 1, v707));
                  if (!v708)
                  {
                    ((void (*)(std::__shared_weak_count *))v706->__on_zero_shared)(v706);
                    std::__shared_weak_count::__release_weak(v706);
                  }
                }
                v705 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              }
              v709 = (std::__shared_weak_count *)off_2553234C8;
              value.__r_.__value_.__r.__words[0] = (std::string::size_type)v705;
              value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
              if (off_2553234C8)
              {
                v710 = (unint64_t *)((char *)off_2553234C8 + 8);
                do
                  v711 = __ldxr(v710);
                while (__stxr(v711 + 1, v710));
              }
              pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              SEUpdaterUtil::SELogObj::printLog(v705, (SEUpdaterUtil::SELogObj *)2, 0, 1, v680, (SEUpdaterUtil::SELogObj *)"Executing script <%s, %s>\n", *v678, v678[4]);
              if (v709)
              {
                v712 = (unint64_t *)&v709->__shared_owners_;
                do
                  v713 = __ldaxr(v712);
                while (__stlxr(v713 - 1, v712));
                if (!v713)
                {
                  ((void (*)(std::__shared_weak_count *))v709->__on_zero_shared)(v709);
                  std::__shared_weak_count::__release_weak(v709);
                }
              }
              v714 = v677;
              v715 = v679;
              v716 = v680;
              std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(__p, *((_QWORD *)this + 20), *((std::__shared_weak_count **)this + 21));
              v717 = __p[0];
              v718 = (char *)__p[1];
              v1756 = *(_OWORD *)__p;
              v719 = (unint64_t *)operator new(0x20uLL);
              v719[1] = 0;
              v720 = v719 + 1;
              v719[2] = 0;
              *v719 = (unint64_t)&off_24E0C1170;
              v719[3] = (unint64_t)&off_24E0C11C0;
              cf = v719 + 3;
              v1755 = v719;
              std::string::basic_string[abi:ne180100]<0>(&v1750, (char *)v678[4]);
              *(_QWORD *)&v1752 = v717;
              *((_QWORD *)&v1752 + 1) = v718;
              if (v718)
              {
                v721 = (unint64_t *)(v718 + 8);
                do
                  v722 = __ldxr(v721);
                while (__stxr(v722 + 1, v721));
                *((_QWORD *)&v1753 + 1) = v718;
                do
                  v723 = __ldxr(v721);
                while (__stxr(v723 + 1, v721));
              }
              else
              {
                *((_QWORD *)&v1753 + 1) = 0;
              }
              *(_QWORD *)&v1753 = v717;
              if (!v717)
                goto LABEL_2917;
              v1748 = (std::string::size_type)(v719 + 3);
              v1749 = (std::__shared_weak_count *)v719;
              do
                v724 = __ldxr(v720);
              while (__stxr(v724 + 1, v720));
              *(_QWORD *)&v1751 = v719 + 3;
              *((_QWORD *)&v1751 + 1) = v719;
              v680 = v716;
              v679 = v715;
              do
                v725 = __ldxr(v720);
              while (__stxr(v725 + 1, v720));
              SLAM::SLAM::PerformScript((uint64_t)&v1750, (uint64_t *)&v1753, (uint64_t *)&v1751, (uint64_t)__p);
              v677 = v714;
              v726 = (std::__shared_weak_count *)*((_QWORD *)&v1751 + 1);
              if (*((_QWORD *)&v1751 + 1))
              {
                v727 = (unint64_t *)(*((_QWORD *)&v1751 + 1) + 8);
                do
                  v728 = __ldaxr(v727);
                while (__stlxr(v728 - 1, v727));
                if (!v728)
                {
                  ((void (*)(std::__shared_weak_count *))v726->__on_zero_shared)(v726);
                  std::__shared_weak_count::__release_weak(v726);
                }
              }
              v729 = v1749;
              if (v1749)
              {
                v730 = (unint64_t *)&v1749->__shared_owners_;
                do
                  v731 = __ldaxr(v730);
                while (__stlxr(v731 - 1, v730));
                if (!v731)
                {
                  ((void (*)(std::__shared_weak_count *))v729->__on_zero_shared)(v729);
                  std::__shared_weak_count::__release_weak(v729);
                }
              }
              v732 = (std::__shared_weak_count *)*((_QWORD *)&v1753 + 1);
              if (*((_QWORD *)&v1753 + 1))
              {
                v733 = (unint64_t *)(*((_QWORD *)&v1753 + 1) + 8);
                do
                  v734 = __ldaxr(v733);
                while (__stlxr(v734 - 1, v733));
                if (!v734)
                {
                  ((void (*)(std::__shared_weak_count *))v732->__on_zero_shared)(v732);
                  std::__shared_weak_count::__release_weak(v732);
                }
              }
              v735 = (std::__shared_weak_count *)*((_QWORD *)&v1752 + 1);
              if (*((_QWORD *)&v1752 + 1))
              {
                v736 = (unint64_t *)(*((_QWORD *)&v1752 + 1) + 8);
                do
                  v737 = __ldaxr(v736);
                while (__stlxr(v737 - 1, v736));
                if (!v737)
                {
                  ((void (*)(std::__shared_weak_count *))v735->__on_zero_shared)(v735);
                  std::__shared_weak_count::__release_weak(v735);
                }
              }
              if (SHIBYTE(v1750.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v1750.__r_.__value_.__l.__data_);
              if (BYTE8(v1758))
              {
                v1640 = v1756;
                v1746 = v1756;
                if (*((_QWORD *)&v1756 + 1))
                {
                  v1650 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
                  do
                    v1651 = __ldxr(v1650);
                  while (__stxr(v1651 + 1, v1650));
                  *((_QWORD *)&v1747 + 1) = *((_QWORD *)&v1640 + 1);
                  do
                    v1652 = __ldxr(v1650);
                  while (__stxr(v1652 + 1, v1650));
                }
                else
                {
                  *((_QWORD *)&v1747 + 1) = 0;
                }
                *(_QWORD *)&v1747 = v1640;
                if ((_QWORD)v1640)
                {
                  v1653 = cf;
                  v1654 = v1755;
                  v1743 = cf;
                  v1744 = v1755;
                  if (v1755)
                  {
                    v1655 = v1755 + 1;
                    do
                      v1656 = __ldxr(v1655);
                    while (__stxr(v1656 + 1, v1655));
                    *((_QWORD *)&v1745 + 1) = v1654;
                    do
                      v1657 = __ldxr(v1655);
                    while (__stxr(v1657 + 1, v1655));
                  }
                  else
                  {
                    *((_QWORD *)&v1745 + 1) = 0;
                  }
                  *(_QWORD *)&v1745 = v1653;
                  if (v1653)
                  {
                    SLAM::SLAM::PerformRecovery((uint64_t *)&v1747, (uint64_t *)&v1745, (uint64_t)&value);
                    if (v1787[0])
                    {
                      v1742.__r_.__value_.__r.__words[0] = (std::string::size_type)&value;
                      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v1742);
                    }
                    std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1745);
                    std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1743);
                    std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1747);
                    std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1746);
                    v1658 = __cxa_allocate_exception(0x48uLL);
                    v1659 = SLAM::Error::Add((std::vector<std::string> *)__p, "At Pre Load: %s %s", *v678, v678[4]);
                    ctu::join<std::__wrap_iter<std::string const*>>(v1659->__begin_, v1659->__end_, ", ", 2uLL, &v1742);
                    v1660 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1658, (__int128 *)&v1742, 36, CFSTR("SEUpdaterErrorDomain"));
                  }
                }
                goto LABEL_2917;
              }
              pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              v738 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              if (!off_2553234C0)
              {
                SEUpdaterUtil::SELogObj::create_default_global(&value);
                std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&value);
                v739 = (std::__shared_weak_count *)value.__r_.__value_.__l.__size_;
                if (value.__r_.__value_.__l.__size_)
                {
                  v740 = (unint64_t *)(value.__r_.__value_.__l.__size_ + 8);
                  do
                    v741 = __ldaxr(v740);
                  while (__stlxr(v741 - 1, v740));
                  if (!v741)
                  {
                    ((void (*)(std::__shared_weak_count *))v739->__on_zero_shared)(v739);
                    std::__shared_weak_count::__release_weak(v739);
                  }
                }
                v738 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              }
              v742 = (std::__shared_weak_count *)off_2553234C8;
              v1742.__r_.__value_.__r.__words[0] = (std::string::size_type)v738;
              v1742.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
              if (off_2553234C8)
              {
                v743 = (unint64_t *)((char *)off_2553234C8 + 8);
                do
                  v744 = __ldxr(v743);
                while (__stxr(v744 + 1, v743));
              }
              pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              SEUpdaterUtil::SELogObj::printLog(v738, (SEUpdaterUtil::SELogObj *)2, 0, 1, v716, (SEUpdaterUtil::SELogObj *)"Pre Load <%s, %s> executed successfully!\n", *v678, v678[4]);
              if (v742)
              {
                v745 = (unint64_t *)&v742->__shared_owners_;
                do
                  v746 = __ldaxr(v745);
                while (__stlxr(v746 - 1, v745));
                if (!v746)
                {
                  ((void (*)(std::__shared_weak_count *))v742->__on_zero_shared)(v742);
                  std::__shared_weak_count::__release_weak(v742);
                }
              }
              if (BYTE8(v1758))
              {
                value.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
                std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&value);
              }
              v747 = (std::__shared_weak_count *)v1755;
              if (v1755)
              {
                v748 = v1755 + 1;
                do
                  v749 = __ldaxr(v748);
                while (__stlxr(v749 - 1, v748));
                if (!v749)
                {
                  ((void (*)(std::__shared_weak_count *))v747->__on_zero_shared)(v747);
                  std::__shared_weak_count::__release_weak(v747);
                }
              }
              v686 = (std::__shared_weak_count *)*((_QWORD *)&v1756 + 1);
              if (!*((_QWORD *)&v1756 + 1))
                goto LABEL_1339;
              v750 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
              do
                v690 = __ldaxr(v750);
              while (__stlxr(v690 - 1, v750));
            }
            else
            {
              pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              v682 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              if (!off_2553234C0)
              {
                SEUpdaterUtil::SELogObj::create_default_global(__p);
                std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
                v683 = (std::__shared_weak_count *)__p[1];
                if (__p[1])
                {
                  v684 = (unint64_t *)((char *)__p[1] + 8);
                  do
                    v685 = __ldaxr(v684);
                  while (__stlxr(v685 - 1, v684));
                  if (!v685)
                  {
                    ((void (*)(std::__shared_weak_count *))v683->__on_zero_shared)(v683);
                    std::__shared_weak_count::__release_weak(v683);
                  }
                }
                v682 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              }
              v686 = (std::__shared_weak_count *)off_2553234C8;
              value.__r_.__value_.__r.__words[0] = (std::string::size_type)v682;
              value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
              if (off_2553234C8)
              {
                v687 = (unint64_t *)((char *)off_2553234C8 + 8);
                do
                  v688 = __ldxr(v687);
                while (__stxr(v688 + 1, v687));
              }
              pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              SEUpdaterUtil::SELogObj::printLog(v682, (SEUpdaterUtil::SELogObj *)2, 0, 1, v680, (SEUpdaterUtil::SELogObj *)"Package already present, skipping pre load <%s> \n", *v678);
              if (!v686)
                goto LABEL_1339;
              v689 = (unint64_t *)&v686->__shared_owners_;
              do
                v690 = __ldaxr(v689);
              while (__stlxr(v690 - 1, v689));
            }
          }
          else
          {
            pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v698 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            if (!off_2553234C0)
            {
              SEUpdaterUtil::SELogObj::create_default_global(__p);
              std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
              v699 = (std::__shared_weak_count *)__p[1];
              if (__p[1])
              {
                v700 = (unint64_t *)((char *)__p[1] + 8);
                do
                  v701 = __ldaxr(v700);
                while (__stlxr(v701 - 1, v700));
                if (!v701)
                {
                  ((void (*)(std::__shared_weak_count *))v699->__on_zero_shared)(v699);
                  std::__shared_weak_count::__release_weak(v699);
                }
              }
              v698 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            }
            v686 = (std::__shared_weak_count *)off_2553234C8;
            value.__r_.__value_.__r.__words[0] = (std::string::size_type)v698;
            value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
            if (off_2553234C8)
            {
              v702 = (unint64_t *)((char *)off_2553234C8 + 8);
              do
                v703 = __ldxr(v702);
              while (__stxr(v703 + 1, v702));
            }
            pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            SEUpdaterUtil::SELogObj::printLog(v698, (SEUpdaterUtil::SELogObj *)2, 0, 1, v680, (SEUpdaterUtil::SELogObj *)"SLAM unavailable for Pre Load <%s> on current platform\n", *v678);
            if (!v686)
              goto LABEL_1339;
            v704 = (unint64_t *)&v686->__shared_owners_;
            do
              v690 = __ldaxr(v704);
            while (__stlxr(v690 - 1, v704));
          }
        }
        else
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v691 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(__p);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
            v692 = (std::__shared_weak_count *)__p[1];
            if (__p[1])
            {
              v693 = (unint64_t *)((char *)__p[1] + 8);
              do
                v694 = __ldaxr(v693);
              while (__stlxr(v694 - 1, v693));
              if (!v694)
              {
                ((void (*)(std::__shared_weak_count *))v692->__on_zero_shared)(v692);
                std::__shared_weak_count::__release_weak(v692);
              }
            }
            v691 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v686 = (std::__shared_weak_count *)off_2553234C8;
          value.__r_.__value_.__r.__words[0] = (std::string::size_type)v691;
          value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v695 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v696 = __ldxr(v695);
            while (__stxr(v696 + 1, v695));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v691, (SEUpdaterUtil::SELogObj *)2, 0, 1, v680, (SEUpdaterUtil::SELogObj *)"Skipping Pre Load <%s> by key\n", *v678);
          if (!v686)
            goto LABEL_1339;
          v697 = (unint64_t *)&v686->__shared_owners_;
          do
            v690 = __ldaxr(v697);
          while (__stlxr(v690 - 1, v697));
        }
        if (!v690)
        {
          ((void (*)(std::__shared_weak_count *))v686->__on_zero_shared)(v686);
          std::__shared_weak_count::__release_weak(v686);
        }
LABEL_1339:
        v678 += 6;
      }
      while (v678 != (const char **)v677);
    }
    __p[0] = &v1782;
    std::vector<SLAM::Deletion::Trigger>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
    __p[0] = &v1783;
    std::vector<SEUpdater::PackageInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
    v653 = v1726;
LABEL_1341:
    std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(__p, *((_QWORD *)this + 20), *((std::__shared_weak_count **)this + 21));
    *(_OWORD *)&v1737.__r_.__value_.__l.__data_ = *(_OWORD *)__p;
    v751 = operator new(0x20uLL);
    v751[1] = 0;
    v751[2] = 0;
    *v751 = &off_24E0C1170;
    v751[3] = &off_24E0C11C0;
    *(_QWORD *)&v1756 = v751 + 3;
    *((_QWORD *)&v1756 + 1) = v751;
    v752 = SERestoreInfo::P73BaseDeviceInfo::isDev(*v653);
    v753 = (char *)operator new(0x10uLL);
    *(_DWORD *)v753 = 6175;
    v753[4] = 4;
    *(_QWORD *)(v753 + 5) = 0;
    *((_DWORD *)v753 + 3) = 0;
    v754 = (char *)operator new(0x10uLL);
    *(_DWORD *)v754 = 6160;
    v754[4] = 4;
    *(_QWORD *)(v754 + 5) = 0;
    *((_DWORD *)v754 + 3) = 0;
    memset(&v1783, 0, sizeof(v1783));
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v755 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v756 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v757 = (unint64_t *)((char *)__p[1] + 8);
        do
          v758 = __ldaxr(v757);
        while (__stlxr(v758 - 1, v757));
        if (!v758)
        {
          ((void (*)(std::__shared_weak_count *))v756->__on_zero_shared)(v756);
          std::__shared_weak_count::__release_weak(v756);
        }
      }
      v755 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v759 = (std::__shared_weak_count *)off_2553234C8;
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)v755;
    value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v760 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v761 = __ldxr(v760);
      while (__stxr(v761 + 1, v760));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v755, (SEUpdaterUtil::SELogObj *)2, 0, 1, "CheckAndInstallOasisApplet", (SEUpdaterUtil::SELogObj *)"Checking for Oasis instance\n");
    if (v759)
    {
      v762 = (unint64_t *)&v759->__shared_owners_;
      do
        v763 = __ldaxr(v762);
      while (__stlxr(v763 - 1, v762));
      if (!v763)
      {
        ((void (*)(std::__shared_weak_count *))v759->__on_zero_shared)(v759);
        std::__shared_weak_count::__release_weak(v759);
      }
    }
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v1782, 0x2037uLL);
    v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF828;
    v764 = *((_QWORD *)this + 20);
    value.__r_.__value_.__r.__words[0] = 0xA0090004A400;
    LODWORD(value.__r_.__value_.__r.__words[1]) = 8804360;
    WORD2(value.__r_.__value_.__r.__words[1]) = 258;
    value.__r_.__value_.__s.__data_[14] = 0;
    SERestoreInfo::CApdu::CApdu(__p, &value, 0xFuLL, 0);
    __p[0] = &off_24E0C08A0;
    SEUpdater::P73BaseSEController::transceive(v764, (uint64_t)__p, (uint64_t **)&v1782, 0, (SEUpdaterUtil::SELogObj *)2, 1);
    __p[0] = &unk_24E0BF880;
    v765 = (std::__shared_weak_count *)v1758;
    if ((_QWORD)v1758)
    {
      v766 = (unint64_t *)(v1758 + 8);
      do
        v767 = __ldaxr(v766);
      while (__stlxr(v767 - 1, v766));
      if (!v767)
      {
        ((void (*)(std::__shared_weak_count *))v765->__on_zero_shared)(v765);
        std::__shared_weak_count::__release_weak(v765);
      }
    }
    v768 = *(_QWORD *)(v1782.__r_.__value_.__l.__size_ + 8);
    if ((unint64_t)(v768 - *(_QWORD *)v1782.__r_.__value_.__l.__size_) >= 2
      && (*(unsigned __int8 *)(v768 - 1) | (*(unsigned __int8 *)(v768 - 2) << 8)) == 0x9000)
    {
      v769 = *((_QWORD *)this + 20);
      LODWORD(value.__r_.__value_.__l.__data_) = -922695040;
      value.__r_.__value_.__s.__data_[4] = 0;
      SERestoreInfo::CApdu::CApdu(__p, &value, 5uLL, 0);
      __p[0] = &off_24E0C08E8;
      SEUpdater::P73BaseSEController::transceive(v769, (uint64_t)__p, (uint64_t **)&v1782, 0, (SEUpdaterUtil::SELogObj *)2, 1);
      __p[0] = &unk_24E0BF880;
      v770 = (std::__shared_weak_count *)v1758;
      if ((_QWORD)v1758)
      {
        v771 = (unint64_t *)(v1758 + 8);
        do
          v772 = __ldaxr(v771);
        while (__stlxr(v772 - 1, v771));
        if (!v772)
        {
          ((void (*)(std::__shared_weak_count *))v770->__on_zero_shared)(v770);
          std::__shared_weak_count::__release_weak(v770);
        }
      }
      v773 = *(_QWORD *)(v1782.__r_.__value_.__l.__size_ + 8);
      if ((unint64_t)(v773 - *(_QWORD *)v1782.__r_.__value_.__l.__size_) >= 2
        && (*(unsigned __int8 *)(v773 - 1) | (*(unsigned __int8 *)(v773 - 2) << 8)) == 0x9000)
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v774 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(__p);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
          v775 = (std::__shared_weak_count *)__p[1];
          if (__p[1])
          {
            v776 = (unint64_t *)((char *)__p[1] + 8);
            do
              v777 = __ldaxr(v776);
            while (__stlxr(v777 - 1, v776));
            if (!v777)
            {
              ((void (*)(std::__shared_weak_count *))v775->__on_zero_shared)(v775);
              std::__shared_weak_count::__release_weak(v775);
            }
          }
          v774 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v778 = (std::__shared_weak_count *)off_2553234C8;
        value.__r_.__value_.__r.__words[0] = (std::string::size_type)v774;
        value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v779 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v780 = __ldxr(v779);
          while (__stxr(v780 + 1, v779));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v774, (SEUpdaterUtil::SELogObj *)2, 0, 1, "CheckAndInstallOasisApplet", (SEUpdaterUtil::SELogObj *)"Current Oasis Config ID: %s\n", *(const char **)v1782.__r_.__value_.__l.__size_);
        if (v778)
        {
          v781 = (unint64_t *)&v778->__shared_owners_;
          do
            v782 = __ldaxr(v781);
          while (__stlxr(v782 - 1, v781));
          if (!v782)
          {
            ((void (*)(std::__shared_weak_count *))v778->__on_zero_shared)(v778);
            std::__shared_weak_count::__release_weak(v778);
          }
        }
        if (v752)
          v783 = v753;
        else
          v783 = v754;
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&v1783, v783, v783 + 16, 0x10uLL);
        if (v1783.__r_.__value_.__l.__size_ - v1783.__r_.__value_.__r.__words[0] == *(_QWORD *)(v1782.__r_.__value_.__l.__size_
                                                                                               + 8)
                                                                                   - *(_QWORD *)v1782.__r_.__value_.__l.__size_
          && !memcmp(v1783.__r_.__value_.__l.__data_, *(const void **)v1782.__r_.__value_.__l.__size_, v1783.__r_.__value_.__l.__size_ - v1783.__r_.__value_.__r.__words[0]))
        {
          goto LABEL_1557;
        }
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v784 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(__p);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
          v785 = (std::__shared_weak_count *)__p[1];
          if (__p[1])
          {
            v786 = (unint64_t *)((char *)__p[1] + 8);
            do
              v787 = __ldaxr(v786);
            while (__stlxr(v787 - 1, v786));
            if (!v787)
            {
              ((void (*)(std::__shared_weak_count *))v785->__on_zero_shared)(v785);
              std::__shared_weak_count::__release_weak(v785);
            }
          }
          v784 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v788 = (std::__shared_weak_count *)off_2553234C8;
        value.__r_.__value_.__r.__words[0] = (std::string::size_type)v784;
        value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v789 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v790 = __ldxr(v789);
          while (__stxr(v790 + 1, v789));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v784, (SEUpdaterUtil::SELogObj *)1, 0, 1, "CheckAndInstallOasisApplet", (SEUpdaterUtil::SELogObj *)"Oasis configuration out of date\n");
        if (!v788)
        {
LABEL_1433:
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v807 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(__p);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
            v808 = (std::__shared_weak_count *)__p[1];
            if (__p[1])
            {
              v809 = (unint64_t *)((char *)__p[1] + 8);
              do
                v810 = __ldaxr(v809);
              while (__stlxr(v810 - 1, v809));
              if (!v810)
              {
                ((void (*)(std::__shared_weak_count *))v808->__on_zero_shared)(v808);
                std::__shared_weak_count::__release_weak(v808);
              }
            }
            v807 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v811 = (std::__shared_weak_count *)off_2553234C8;
          value.__r_.__value_.__r.__words[0] = (std::string::size_type)v807;
          value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
          if (off_2553234C8)
          {
            v812 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v813 = __ldxr(v812);
            while (__stxr(v813 + 1, v812));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v807, (SEUpdaterUtil::SELogObj *)2, 0, 1, "CheckAndInstallOasisApplet", (SEUpdaterUtil::SELogObj *)"SLAMing Oasis\n");
          if (v811)
          {
            v814 = (unint64_t *)&v811->__shared_owners_;
            do
              v815 = __ldaxr(v814);
            while (__stlxr(v815 - 1, v814));
            if (!v815)
            {
              ((void (*)(std::__shared_weak_count *))v811->__on_zero_shared)(v811);
              std::__shared_weak_count::__release_weak(v811);
            }
          }
          std::string::basic_string[abi:ne180100]<0>(&v1750, "SLAMLoadAndInstallSilverBullet");
          v816 = *(_OWORD *)&v1737.__r_.__value_.__l.__data_;
          v1753 = *(_OWORD *)&v1737.__r_.__value_.__l.__data_;
          if (v1737.__r_.__value_.__l.__size_)
          {
            v817 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
            do
              v818 = __ldxr(v817);
            while (__stxr(v818 + 1, v817));
            v1755 = (unint64_t *)*((_QWORD *)&v816 + 1);
            do
              v819 = __ldxr(v817);
            while (__stxr(v819 + 1, v817));
          }
          else
          {
            v1755 = 0;
          }
          cf = (CFTypeRef)v816;
          if (!(_QWORD)v816)
            goto LABEL_2917;
          v820 = v1756;
          v1751 = v1756;
          if (*((_QWORD *)&v1756 + 1))
          {
            v821 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
            do
              v822 = __ldxr(v821);
            while (__stxr(v822 + 1, v821));
            *((_QWORD *)&v1752 + 1) = *((_QWORD *)&v820 + 1);
            do
              v823 = __ldxr(v821);
            while (__stxr(v823 + 1, v821));
          }
          else
          {
            *((_QWORD *)&v1752 + 1) = 0;
          }
          *(_QWORD *)&v1752 = v820;
          if (!(_QWORD)v820)
            goto LABEL_2917;
          SLAM::SLAM::PerformScript((uint64_t)&v1750, (uint64_t *)&cf, (uint64_t *)&v1752, (uint64_t)__p);
          v824 = (std::__shared_weak_count *)*((_QWORD *)&v1752 + 1);
          if (*((_QWORD *)&v1752 + 1))
          {
            v825 = (unint64_t *)(*((_QWORD *)&v1752 + 1) + 8);
            do
              v826 = __ldaxr(v825);
            while (__stlxr(v826 - 1, v825));
            if (!v826)
            {
              ((void (*)(std::__shared_weak_count *))v824->__on_zero_shared)(v824);
              std::__shared_weak_count::__release_weak(v824);
            }
          }
          v827 = (std::__shared_weak_count *)*((_QWORD *)&v1751 + 1);
          if (*((_QWORD *)&v1751 + 1))
          {
            v828 = (unint64_t *)(*((_QWORD *)&v1751 + 1) + 8);
            do
              v829 = __ldaxr(v828);
            while (__stlxr(v829 - 1, v828));
            if (!v829)
            {
              ((void (*)(std::__shared_weak_count *))v827->__on_zero_shared)(v827);
              std::__shared_weak_count::__release_weak(v827);
            }
          }
          v830 = (std::__shared_weak_count *)v1755;
          if (v1755)
          {
            v831 = v1755 + 1;
            do
              v832 = __ldaxr(v831);
            while (__stlxr(v832 - 1, v831));
            if (!v832)
            {
              ((void (*)(std::__shared_weak_count *))v830->__on_zero_shared)(v830);
              std::__shared_weak_count::__release_weak(v830);
            }
          }
          v833 = (std::__shared_weak_count *)*((_QWORD *)&v1753 + 1);
          if (*((_QWORD *)&v1753 + 1))
          {
            v834 = (unint64_t *)(*((_QWORD *)&v1753 + 1) + 8);
            do
              v835 = __ldaxr(v834);
            while (__stlxr(v835 - 1, v834));
            if (!v835)
            {
              ((void (*)(std::__shared_weak_count *))v833->__on_zero_shared)(v833);
              std::__shared_weak_count::__release_weak(v833);
            }
          }
          if (SHIBYTE(v1750.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v1750.__r_.__value_.__l.__data_);
          if (BYTE8(v1758))
          {
            v836 = *(_OWORD *)&v1737.__r_.__value_.__l.__data_;
            v1747 = *(_OWORD *)&v1737.__r_.__value_.__l.__data_;
            if (v1737.__r_.__value_.__l.__size_)
            {
              v837 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
              do
                v838 = __ldxr(v837);
              while (__stxr(v838 + 1, v837));
              v1749 = (std::__shared_weak_count *)*((_QWORD *)&v836 + 1);
              do
                v839 = __ldxr(v837);
              while (__stxr(v839 + 1, v837));
            }
            else
            {
              v1749 = 0;
            }
            v1748 = v836;
            if (!(_QWORD)v836)
              goto LABEL_2917;
            v840 = v1756;
            v1745 = v1756;
            if (*((_QWORD *)&v1756 + 1))
            {
              v841 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
              do
                v842 = __ldxr(v841);
              while (__stxr(v842 + 1, v841));
              *((_QWORD *)&v1746 + 1) = *((_QWORD *)&v840 + 1);
              do
                v843 = __ldxr(v841);
              while (__stxr(v843 + 1, v841));
            }
            else
            {
              *((_QWORD *)&v1746 + 1) = 0;
            }
            *(_QWORD *)&v1746 = v840;
            if (!(_QWORD)v840)
              goto LABEL_2917;
            SLAM::SLAM::PerformRecovery((uint64_t *)&v1748, (uint64_t *)&v1746, (uint64_t)&value);
            if (v1787[0])
            {
              v1742.__r_.__value_.__r.__words[0] = (std::string::size_type)&value;
              std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v1742);
            }
            v844 = (std::__shared_weak_count *)*((_QWORD *)&v1746 + 1);
            if (*((_QWORD *)&v1746 + 1))
            {
              v845 = (unint64_t *)(*((_QWORD *)&v1746 + 1) + 8);
              do
                v846 = __ldaxr(v845);
              while (__stlxr(v846 - 1, v845));
              if (!v846)
              {
                ((void (*)(std::__shared_weak_count *))v844->__on_zero_shared)(v844);
                std::__shared_weak_count::__release_weak(v844);
              }
            }
            v847 = (std::__shared_weak_count *)*((_QWORD *)&v1745 + 1);
            if (*((_QWORD *)&v1745 + 1))
            {
              v848 = (unint64_t *)(*((_QWORD *)&v1745 + 1) + 8);
              do
                v849 = __ldaxr(v848);
              while (__stlxr(v849 - 1, v848));
              if (!v849)
              {
                ((void (*)(std::__shared_weak_count *))v847->__on_zero_shared)(v847);
                std::__shared_weak_count::__release_weak(v847);
              }
            }
            v850 = v1749;
            if (v1749)
            {
              v851 = (unint64_t *)&v1749->__shared_owners_;
              do
                v852 = __ldaxr(v851);
              while (__stlxr(v852 - 1, v851));
              if (!v852)
              {
                ((void (*)(std::__shared_weak_count *))v850->__on_zero_shared)(v850);
                std::__shared_weak_count::__release_weak(v850);
              }
            }
            v853 = (std::__shared_weak_count *)*((_QWORD *)&v1747 + 1);
            if (*((_QWORD *)&v1747 + 1))
            {
              v854 = (unint64_t *)(*((_QWORD *)&v1747 + 1) + 8);
              do
                v855 = __ldaxr(v854);
              while (__stlxr(v855 - 1, v854));
              if (!v855)
              {
                ((void (*)(std::__shared_weak_count *))v853->__on_zero_shared)(v853);
                std::__shared_weak_count::__release_weak(v853);
              }
            }
            pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v856 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            if (!off_2553234C0)
            {
              SEUpdaterUtil::SELogObj::create_default_global(&v1742);
              std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1742);
              v857 = (std::__shared_weak_count *)v1742.__r_.__value_.__l.__size_;
              if (v1742.__r_.__value_.__l.__size_)
              {
                v858 = (unint64_t *)(v1742.__r_.__value_.__l.__size_ + 8);
                do
                  v859 = __ldaxr(v858);
                while (__stlxr(v859 - 1, v858));
                if (!v859)
                {
                  ((void (*)(std::__shared_weak_count *))v857->__on_zero_shared)(v857);
                  std::__shared_weak_count::__release_weak(v857);
                }
              }
              v856 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            }
            v860 = (std::__shared_weak_count *)off_2553234C8;
            v1743 = v856;
            v1744 = (unint64_t *)off_2553234C8;
            if (off_2553234C8)
            {
              v861 = (unint64_t *)((char *)off_2553234C8 + 8);
              do
                v862 = __ldxr(v861);
              while (__stxr(v862 + 1, v861));
            }
            pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            SEUpdaterUtil::SELogObj::printLog(v856, 0, 0, 1, "CheckAndInstallOasisApplet", (SEUpdaterUtil::SELogObj *)"Failed to SLAM Oasis :( \n");
            if (v860)
            {
              v863 = (unint64_t *)&v860->__shared_owners_;
              do
                v864 = __ldaxr(v863);
              while (__stlxr(v864 - 1, v863));
              if (!v864)
              {
                ((void (*)(std::__shared_weak_count *))v860->__on_zero_shared)(v860);
                std::__shared_weak_count::__release_weak(v860);
              }
            }
          }
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v865 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(&v1742);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1742);
            v866 = (std::__shared_weak_count *)v1742.__r_.__value_.__l.__size_;
            if (v1742.__r_.__value_.__l.__size_)
            {
              v867 = (unint64_t *)(v1742.__r_.__value_.__l.__size_ + 8);
              do
                v868 = __ldaxr(v867);
              while (__stlxr(v868 - 1, v867));
              if (!v868)
              {
                ((void (*)(std::__shared_weak_count *))v866->__on_zero_shared)(v866);
                std::__shared_weak_count::__release_weak(v866);
              }
            }
            v865 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v869 = (std::__shared_weak_count *)off_2553234C8;
          v1743 = v865;
          v1744 = (unint64_t *)off_2553234C8;
          if (off_2553234C8)
          {
            v870 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v871 = __ldxr(v870);
            while (__stxr(v871 + 1, v870));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v865, (SEUpdaterUtil::SELogObj *)2, 0, 1, "CheckAndInstallOasisApplet", (SEUpdaterUtil::SELogObj *)"SLAM Oasis executed successfully!\n");
          if (v869)
          {
            v872 = (unint64_t *)&v869->__shared_owners_;
            do
              v873 = __ldaxr(v872);
            while (__stlxr(v873 - 1, v872));
            if (!v873)
            {
              ((void (*)(std::__shared_weak_count *))v869->__on_zero_shared)(v869);
              std::__shared_weak_count::__release_weak(v869);
            }
          }
          if (BYTE8(v1758))
          {
            v1742.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
            std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v1742);
          }
LABEL_1557:
          v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
          v874 = (std::__shared_weak_count *)v1782.__r_.__value_.__r.__words[2];
          if (v1782.__r_.__value_.__r.__words[2])
          {
            v875 = (unint64_t *)(v1782.__r_.__value_.__r.__words[2] + 8);
            do
              v876 = __ldaxr(v875);
            while (__stlxr(v876 - 1, v875));
            if (!v876)
            {
              ((void (*)(std::__shared_weak_count *))v874->__on_zero_shared)(v874);
              std::__shared_weak_count::__release_weak(v874);
            }
          }
          if (v1783.__r_.__value_.__r.__words[0])
          {
            v1783.__r_.__value_.__l.__size_ = v1783.__r_.__value_.__r.__words[0];
            operator delete(v1783.__r_.__value_.__l.__data_);
          }
          operator delete(v754);
          operator delete(v753);
          v877 = (std::__shared_weak_count *)*((_QWORD *)&v1756 + 1);
          if (*((_QWORD *)&v1756 + 1))
          {
            v878 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
            do
              v879 = __ldaxr(v878);
            while (__stlxr(v879 - 1, v878));
            if (!v879)
            {
              ((void (*)(std::__shared_weak_count *))v877->__on_zero_shared)(v877);
              std::__shared_weak_count::__release_weak(v877);
            }
          }
          v880 = (std::__shared_weak_count *)v1737.__r_.__value_.__l.__size_;
          if (v1737.__r_.__value_.__l.__size_)
          {
            v881 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
            do
              v882 = __ldaxr(v881);
            while (__stlxr(v882 - 1, v881));
            if (!v882)
            {
              ((void (*)(std::__shared_weak_count *))v880->__on_zero_shared)(v880);
              std::__shared_weak_count::__release_weak(v880);
            }
          }
          v883 = (char *)operator new(0xCuLL);
          *(_DWORD *)v883 = 117440672;
          *((_WORD *)v883 + 2) = -16380;
          *(_DWORD *)(v883 + 6) = 0;
          *((_WORD *)v883 + 5) = 256;
          v884 = *((_QWORD *)this + 21);
          v1750.__r_.__value_.__r.__words[0] = *((_QWORD *)this + 20);
          v1750.__r_.__value_.__l.__size_ = v884;
          if (v884)
          {
            v885 = (unint64_t *)(v884 + 8);
            do
              v886 = __ldxr(v885);
            while (__stxr(v886 + 1, v885));
          }
          SEUpdater::GetInstanceInfo((uint64_t *)&v1750, (std::string::size_type *)&value);
          v887 = (std::__shared_weak_count *)v1750.__r_.__value_.__l.__size_;
          if (v1750.__r_.__value_.__l.__size_)
          {
            v888 = (unint64_t *)(v1750.__r_.__value_.__l.__size_ + 8);
            do
              v889 = __ldaxr(v888);
            while (__stlxr(v889 - 1, v888));
            if (!v889)
            {
              ((void (*)(std::__shared_weak_count *))v887->__on_zero_shared)(v887);
              std::__shared_weak_count::__release_weak(v887);
            }
          }
          v891 = value.__r_.__value_.__l.__size_;
          v890 = value.__r_.__value_.__r.__words[0];
          if (value.__r_.__value_.__r.__words[0] == value.__r_.__value_.__l.__size_)
            goto LABEL_1673;
          while (1)
          {
            v892 = *(uint64_t **)(v890 + 24);
            if (*(_QWORD *)(v890 + 32) - (_QWORD)v892 == 12)
            {
              v893 = *v892;
              v894 = *((unsigned int *)v892 + 2);
              if (v893 == *(_QWORD *)v883 && v894 == *((_DWORD *)v883 + 2))
                break;
            }
LABEL_1588:
            v890 += 72;
            if (v890 == v891)
              goto LABEL_1673;
          }
          if (**(unsigned __int8 **)(v890 + 48) != 129)
          {
            pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v896 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            if (!off_2553234C0)
            {
              SEUpdaterUtil::SELogObj::create_default_global(__p);
              std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
              v897 = (std::__shared_weak_count *)__p[1];
              if (__p[1])
              {
                v898 = (unint64_t *)((char *)__p[1] + 8);
                do
                  v899 = __ldaxr(v898);
                while (__stlxr(v899 - 1, v898));
                if (!v899)
                {
                  ((void (*)(std::__shared_weak_count *))v897->__on_zero_shared)(v897);
                  std::__shared_weak_count::__release_weak(v897);
                }
              }
              v896 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            }
            v900 = (std::__shared_weak_count *)off_2553234C8;
            v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v896;
            v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
            if (off_2553234C8)
            {
              v901 = (unint64_t *)((char *)off_2553234C8 + 8);
              do
                v902 = __ldxr(v901);
              while (__stxr(v902 + 1, v901));
            }
            pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            ctu::hex();
            if ((SBYTE7(v1758) & 0x80u) == 0)
              v903 = __p;
            else
              v903 = (void **)__p[0];
            SEUpdaterUtil::SELogObj::printLog(v896, (SEUpdaterUtil::SELogObj *)2, 0, 1, "CleanUpTerminatedPTC", (SEUpdaterUtil::SELogObj *)"PTC Instance %s in LC state 0x%X\n", (const char *)v903, **(unsigned __int8 **)(v890 + 48));
            if (SBYTE7(v1758) < 0)
              operator delete(__p[0]);
            if (v900)
            {
              v904 = (unint64_t *)&v900->__shared_owners_;
              do
                v905 = __ldaxr(v904);
              while (__stlxr(v905 - 1, v904));
              if (!v905)
              {
                ((void (*)(std::__shared_weak_count *))v900->__on_zero_shared)(v900);
                std::__shared_weak_count::__release_weak(v900);
              }
            }
            goto LABEL_1588;
          }
          std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(__p, *((_QWORD *)this + 20), *((std::__shared_weak_count **)this + 21));
          v906 = __p[0];
          v907 = (unint64_t *)__p[1];
          *(_OWORD *)&v1742.__r_.__value_.__l.__data_ = *(_OWORD *)__p;
          v908 = operator new(0x20uLL);
          v908[1] = 0;
          v909 = v908 + 1;
          v908[2] = 0;
          *v908 = &off_24E0C1170;
          v908[3] = &off_24E0C11C0;
          v1737.__r_.__value_.__r.__words[0] = (std::string::size_type)(v908 + 3);
          v1737.__r_.__value_.__l.__size_ = (std::string::size_type)v908;
          std::string::basic_string[abi:ne180100]<0>(&v1783, "SLAMDeletePTCInstances");
          cf = v906;
          v1755 = v907;
          if (v907)
          {
            v910 = v907 + 1;
            do
              v911 = __ldxr(v910);
            while (__stxr(v911 + 1, v910));
            *((_QWORD *)&v1756 + 1) = v907;
            do
              v912 = __ldxr(v910);
            while (__stxr(v912 + 1, v910));
          }
          else
          {
            *((_QWORD *)&v1756 + 1) = 0;
          }
          *(_QWORD *)&v1756 = v906;
          if (!v906)
            goto LABEL_2917;
          *(_QWORD *)&v1752 = v908 + 3;
          *((_QWORD *)&v1752 + 1) = v908;
          do
            v913 = __ldxr(v909);
          while (__stxr(v913 + 1, v909));
          *(_QWORD *)&v1753 = v908 + 3;
          *((_QWORD *)&v1753 + 1) = v908;
          do
            v914 = __ldxr(v909);
          while (__stxr(v914 + 1, v909));
          SLAM::SLAM::PerformScript((uint64_t)&v1783, (uint64_t *)&v1756, (uint64_t *)&v1753, (uint64_t)__p);
          v915 = (std::__shared_weak_count *)*((_QWORD *)&v1753 + 1);
          if (*((_QWORD *)&v1753 + 1))
          {
            v916 = (unint64_t *)(*((_QWORD *)&v1753 + 1) + 8);
            do
              v917 = __ldaxr(v916);
            while (__stlxr(v917 - 1, v916));
            if (!v917)
            {
              ((void (*)(std::__shared_weak_count *))v915->__on_zero_shared)(v915);
              std::__shared_weak_count::__release_weak(v915);
            }
          }
          v918 = (std::__shared_weak_count *)*((_QWORD *)&v1752 + 1);
          if (*((_QWORD *)&v1752 + 1))
          {
            v919 = (unint64_t *)(*((_QWORD *)&v1752 + 1) + 8);
            do
              v920 = __ldaxr(v919);
            while (__stlxr(v920 - 1, v919));
            if (!v920)
            {
              ((void (*)(std::__shared_weak_count *))v918->__on_zero_shared)(v918);
              std::__shared_weak_count::__release_weak(v918);
            }
          }
          v921 = (std::__shared_weak_count *)*((_QWORD *)&v1756 + 1);
          if (*((_QWORD *)&v1756 + 1))
          {
            v922 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
            do
              v923 = __ldaxr(v922);
            while (__stlxr(v923 - 1, v922));
            if (!v923)
            {
              ((void (*)(std::__shared_weak_count *))v921->__on_zero_shared)(v921);
              std::__shared_weak_count::__release_weak(v921);
            }
          }
          v924 = (std::__shared_weak_count *)v1755;
          if (v1755)
          {
            v925 = v1755 + 1;
            do
              v926 = __ldaxr(v925);
            while (__stlxr(v926 - 1, v925));
            if (!v926)
            {
              ((void (*)(std::__shared_weak_count *))v924->__on_zero_shared)(v924);
              std::__shared_weak_count::__release_weak(v924);
            }
          }
          if (SHIBYTE(v1783.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v1783.__r_.__value_.__l.__data_);
          if (BYTE8(v1758))
          {
            v1706 = __cxa_allocate_exception(0x48uLL);
            v1707 = SLAM::Error::Add((std::vector<std::string> *)__p, "At SLAMDeletePTCInstances");
            ctu::join<std::__wrap_iter<std::string const*>>(v1707->__begin_, v1707->__end_, ", ", 2uLL, &v1782);
            v1708 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1706, (__int128 *)&v1782, 36, CFSTR("SEUpdaterErrorDomain"));
          }
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v927 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(&v1782);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1782);
            v928 = (std::__shared_weak_count *)v1782.__r_.__value_.__l.__size_;
            if (v1782.__r_.__value_.__l.__size_)
            {
              v929 = (unint64_t *)(v1782.__r_.__value_.__l.__size_ + 8);
              do
                v930 = __ldaxr(v929);
              while (__stlxr(v930 - 1, v929));
              if (!v930)
              {
                ((void (*)(std::__shared_weak_count *))v928->__on_zero_shared)(v928);
                std::__shared_weak_count::__release_weak(v928);
              }
            }
            v927 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v931 = (std::__shared_weak_count *)off_2553234C8;
          *(_QWORD *)&v1751 = v927;
          *((_QWORD *)&v1751 + 1) = off_2553234C8;
          if (off_2553234C8)
          {
            v932 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v933 = __ldxr(v932);
            while (__stxr(v933 + 1, v932));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v927, (SEUpdaterUtil::SELogObj *)2, 0, 1, "CleanUpTerminatedPTC", (SEUpdaterUtil::SELogObj *)"Successfully deleted terminated PTC\n");
          if (v931)
          {
            v934 = (unint64_t *)&v931->__shared_owners_;
            do
              v935 = __ldaxr(v934);
            while (__stlxr(v935 - 1, v934));
            if (!v935)
            {
              ((void (*)(std::__shared_weak_count *))v931->__on_zero_shared)(v931);
              std::__shared_weak_count::__release_weak(v931);
            }
          }
          if (BYTE8(v1758))
          {
            v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
            std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v1782);
          }
          v936 = (std::__shared_weak_count *)v1737.__r_.__value_.__l.__size_;
          if (v1737.__r_.__value_.__l.__size_)
          {
            v937 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
            do
              v938 = __ldaxr(v937);
            while (__stlxr(v938 - 1, v937));
            if (!v938)
            {
              ((void (*)(std::__shared_weak_count *))v936->__on_zero_shared)(v936);
              std::__shared_weak_count::__release_weak(v936);
            }
          }
          v939 = (std::__shared_weak_count *)v1742.__r_.__value_.__l.__size_;
          if (v1742.__r_.__value_.__l.__size_)
          {
            v940 = (unint64_t *)(v1742.__r_.__value_.__l.__size_ + 8);
            do
              v941 = __ldaxr(v940);
            while (__stlxr(v941 - 1, v940));
            if (!v941)
            {
              ((void (*)(std::__shared_weak_count *))v939->__on_zero_shared)(v939);
              std::__shared_weak_count::__release_weak(v939);
            }
          }
LABEL_1673:
          __p[0] = &value;
          std::vector<SEUpdater::InstanceInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
          operator delete(v883);
          std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(__p, *((_QWORD *)this + 20), *((std::__shared_weak_count **)this + 21));
          *(_OWORD *)&v1737.__r_.__value_.__l.__data_ = *(_OWORD *)__p;
          v942 = operator new(0x20uLL);
          v942[1] = 0;
          v942[2] = 0;
          *v942 = &off_24E0C1170;
          v942[3] = &off_24E0C11C0;
          *(_QWORD *)&v1756 = v942 + 3;
          *((_QWORD *)&v1756 + 1) = v942;
          v943 = SERestoreInfo::P73BaseDeviceInfo::isDev(*v1726);
          v944 = (unint64_t *)*((_QWORD *)this + 21);
          if (*(_BYTE *)(*((_QWORD *)this + 20) + 16))
            v945 = 2;
          else
            v945 = 1;
          cf = (CFTypeRef)*((_QWORD *)this + 20);
          v1755 = v944;
          if (v944)
          {
            v946 = v944 + 1;
            do
              v947 = __ldxr(v946);
            while (__stxr(v947 + 1, v946));
          }
          SEUpdater::GetInstanceInfo((uint64_t *)&cf, (std::string::size_type *)&v1782);
          v948 = (std::__shared_weak_count *)v1755;
          if (v1755)
          {
            v949 = v1755 + 1;
            do
              v950 = __ldaxr(v949);
            while (__stlxr(v950 - 1, v949));
            if (!v950)
            {
              ((void (*)(std::__shared_weak_count *))v948->__on_zero_shared)(v948);
              std::__shared_weak_count::__release_weak(v948);
            }
          }
          value.__r_.__value_.__r.__words[0] = (std::string::size_type)"Reinstall PTC";
          v951 = (char *)operator new(0xCuLL);
          *(_DWORD *)v951 = 117440672;
          *((_WORD *)v951 + 2) = -16380;
          *(_DWORD *)(v951 + 6) = 0;
          *((_WORD *)v951 + 5) = 0;
          __p[0] = v951;
          __p[1] = v951 + 12;
          v1758 = (unint64_t)(v951 + 12);
          v1759 = 0uLL;
          v952 = (char *)operator new(0xCuLL);
          v1725 = v945;
          *(_DWORD *)v952 = 117440672;
          *((_WORD *)v952 + 2) = -16380;
          *(_DWORD *)(v952 + 6) = 0;
          *((_WORD *)v952 + 5) = 256;
          *((_QWORD *)&v1758 + 1) = v952;
          *(_QWORD *)&v1759 = v952 + 12;
          *((_QWORD *)&v1759 + 1) = v952 + 12;
          v1760 = 0uLL;
          *(_QWORD *)&v1761[0] = 0;
          v953 = (char *)operator new(0xCuLL);
          *(_QWORD *)&v1761[0] = v953 + 12;
          *(_DWORD *)v953 = 117440672;
          *((_WORD *)v953 + 2) = -16380;
          *(_DWORD *)(v953 + 6) = 0;
          *((_WORD *)v953 + 5) = 512;
          *(_QWORD *)&v1760 = v953;
          *((_QWORD *)&v1760 + 1) = v953 + 12;
          *(_QWORD *)v1787 = 0;
          *(_OWORD *)&value.__r_.__value_.__r.__words[1] = 0uLL;
          v1742.__r_.__value_.__r.__words[0] = (std::string::size_type)&value.__r_.__value_.__l.__size_;
          v1742.__r_.__value_.__s.__data_[8] = 0;
          v954 = 0;
          value.__r_.__value_.__l.__size_ = (std::string::size_type)operator new(0x48uLL);
          value.__r_.__value_.__r.__words[2] = value.__r_.__value_.__l.__size_;
          *(_QWORD *)v1787 = value.__r_.__value_.__l.__size_ + 72;
          *(_QWORD *)&v1753 = value.__r_.__value_.__l.__size_;
          *(_QWORD *)&v1752 = value.__r_.__value_.__l.__size_;
          v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1787;
          v1783.__r_.__value_.__l.__size_ = (std::string::size_type)&v1752;
          v1783.__r_.__value_.__r.__words[2] = (std::string::size_type)&v1753;
          v955 = (_QWORD *)value.__r_.__value_.__l.__size_;
          LOBYTE(v1784) = 0;
          do
          {
            *v955 = 0;
            v955[1] = 0;
            v955[2] = 0;
            std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v955, __p[v954], (uint64_t)__p[v954 + 1], (_BYTE *)__p[v954 + 1] - (_BYTE *)__p[v954]);
            v955 = (_QWORD *)(v1753 + 24);
            *(_QWORD *)&v1753 = v1753 + 24;
            v954 += 3;
          }
          while (v954 != 9);
          LOBYTE(v1784) = 1;
          std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::vector<unsigned char>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&v1783);
          value.__r_.__value_.__r.__words[2] = (std::string::size_type)v955;
          *(_WORD *)&v1787[8] = 771;
          *(_QWORD *)&v1787[16] = "SLAMInstallPTCInstances";
          memset(&v1750, 0, sizeof(v1750));
          v1742.__r_.__value_.__r.__words[0] = (std::string::size_type)&v1750;
          v1742.__r_.__value_.__s.__data_[8] = 0;
          v956 = operator new(0x30uLL);
          v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)v956;
          v1750.__r_.__value_.__l.__size_ = (std::string::size_type)v956;
          v1750.__r_.__value_.__r.__words[2] = (std::string::size_type)(v956 + 6);
          *(_QWORD *)&v1753 = v956;
          *(_QWORD *)&v1752 = v956;
          v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&v1750.__r_.__value_.__r.__words[2];
          v1783.__r_.__value_.__l.__size_ = (std::string::size_type)&v1752;
          v1783.__r_.__value_.__r.__words[2] = (std::string::size_type)&v1753;
          LOBYTE(v1784) = 0;
          v957 = value.__r_.__value_.__l.__size_;
          *v956 = value.__r_.__value_.__r.__words[0];
          v956[2] = 0;
          v956[3] = 0;
          v956[1] = 0;
          std::vector<std::vector<unsigned char>>::__init_with_size[abi:ne180100]<std::vector<unsigned char>*,std::vector<unsigned char>*>(v956 + 1, v957, (uint64_t)v955, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v955 - v957) >> 3));
          *((_OWORD *)v956 + 2) = *(_OWORD *)&v1787[8];
          *(_QWORD *)&v1753 = v1753 + 48;
          v958 = v1753;
          LOBYTE(v1784) = 1;
          v959 = (void ***)std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<SEUpdater::SLAM::Installation::InstallationTrigger>,SEUpdater::SLAM::Installation::InstallationTrigger*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&v1783);
          v1750.__r_.__value_.__l.__size_ = v958;
          v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&value.__r_.__value_.__l.__size_;
          std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100](v959);
          for (j = 0; j != -72; j -= 24)
          {
            v961 = *(void **)((char *)&v1761[-1] + j);
            if (v961)
            {
              *(_QWORD *)((char *)&v1760 + j + 8) = v961;
              operator delete(v961);
            }
          }
          v963 = v1750.__r_.__value_.__l.__size_;
          v962 = (const char **)v1750.__r_.__value_.__r.__words[0];
          if (v1750.__r_.__value_.__r.__words[0] != v1750.__r_.__value_.__l.__size_)
          {
            if (v943)
              v964 = 1;
            else
              v964 = 2;
            do
            {
              if ((v964 & (_BYTE)v962[4]) != 0)
              {
                if ((v945 & *((_BYTE *)v962 + 33)) != 0)
                {
                  v965 = v962[1];
                  v966 = v962[2];
                  if (v965 != v966)
                  {
                    v967 = *(_OWORD *)&v1782.__r_.__value_.__l.__data_;
                    if (v1782.__r_.__value_.__r.__words[0] == v1782.__r_.__value_.__l.__size_)
                      goto LABEL_1747;
                    do
                    {
                      v968 = v963;
                      v969 = v964;
                      v970 = *(const void **)v965;
                      v971 = *((_QWORD *)v965 + 1) - *(_QWORD *)v965;
                      v972 = v967;
                      while (*(_QWORD *)(v972 + 8) - *(_QWORD *)v972 != v971
                           || memcmp(*(const void **)v972, v970, v971))
                      {
                        v972 += 72;
                        if (v972 == *((_QWORD *)&v967 + 1))
                        {
                          v945 = v1725;
                          v964 = v969;
                          v963 = v968;
LABEL_1747:
                          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                          v996 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                          if (!off_2553234C0)
                          {
                            SEUpdaterUtil::SELogObj::create_default_global(__p);
                            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
                            v997 = (std::__shared_weak_count *)__p[1];
                            if (__p[1])
                            {
                              v998 = (unint64_t *)((char *)__p[1] + 8);
                              do
                                v999 = __ldaxr(v998);
                              while (__stlxr(v999 - 1, v998));
                              if (!v999)
                              {
                                ((void (*)(std::__shared_weak_count *))v997->__on_zero_shared)(v997);
                                std::__shared_weak_count::__release_weak(v997);
                              }
                            }
                            v996 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                          }
                          v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v996;
                          v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
                          if (off_2553234C8)
                          {
                            v1000 = (unint64_t *)((char *)off_2553234C8 + 8);
                            do
                              v1001 = __ldxr(v1000);
                            while (__stxr(v1001 + 1, v1000));
                          }
                          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                          v1002 = *v962;
                          ctu::hex();
                          v1003 = __p;
                          if (SBYTE7(v1758) < 0)
                            v1003 = (void **)__p[0];
                          SEUpdaterUtil::SELogObj::printLog(v996, (SEUpdaterUtil::SELogObj *)2, 0, 1, "InstallMissingInstances", (SEUpdaterUtil::SELogObj *)"For Trigger %s missing instance AID %s\n", v1002, (const char *)v1003);
                          if (SBYTE7(v1758) < 0)
                            operator delete(__p[0]);
                          v1004 = (std::__shared_weak_count *)v1783.__r_.__value_.__l.__size_;
                          if (v1783.__r_.__value_.__l.__size_)
                          {
                            v1005 = (unint64_t *)(v1783.__r_.__value_.__l.__size_ + 8);
                            do
                              v1006 = __ldaxr(v1005);
                            while (__stlxr(v1006 - 1, v1005));
                            if (!v1006)
                            {
                              ((void (*)(std::__shared_weak_count *))v1004->__on_zero_shared)(v1004);
                              std::__shared_weak_count::__release_weak(v1004);
                            }
                          }
                          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                          v1007 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                          if (!off_2553234C0)
                          {
                            SEUpdaterUtil::SELogObj::create_default_global(__p);
                            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
                            v1008 = (std::__shared_weak_count *)__p[1];
                            if (__p[1])
                            {
                              v1009 = (unint64_t *)((char *)__p[1] + 8);
                              do
                                v1010 = __ldaxr(v1009);
                              while (__stlxr(v1010 - 1, v1009));
                              if (!v1010)
                              {
                                ((void (*)(std::__shared_weak_count *))v1008->__on_zero_shared)(v1008);
                                std::__shared_weak_count::__release_weak(v1008);
                              }
                            }
                            v1007 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                          }
                          v1011 = (std::__shared_weak_count *)off_2553234C8;
                          v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1007;
                          v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
                          if (off_2553234C8)
                          {
                            v1012 = (unint64_t *)((char *)off_2553234C8 + 8);
                            do
                              v1013 = __ldxr(v1012);
                            while (__stxr(v1013 + 1, v1012));
                          }
                          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                          SEUpdaterUtil::SELogObj::printLog(v1007, (SEUpdaterUtil::SELogObj *)2, 0, 1, "InstallMissingInstances", (SEUpdaterUtil::SELogObj *)"Running trigger %s script 0x%s\n", *v962, v962[5]);
                          if (v1011)
                          {
                            v1014 = (unint64_t *)&v1011->__shared_owners_;
                            do
                              v1015 = __ldaxr(v1014);
                            while (__stlxr(v1015 - 1, v1014));
                            if (!v1015)
                            {
                              ((void (*)(std::__shared_weak_count *))v1011->__on_zero_shared)(v1011);
                              std::__shared_weak_count::__release_weak(v1011);
                            }
                          }
                          std::string::basic_string[abi:ne180100]<0>(&value, (char *)v962[5]);
                          v1016 = *(_OWORD *)&v1737.__r_.__value_.__l.__data_;
                          v1753 = *(_OWORD *)&v1737.__r_.__value_.__l.__data_;
                          if (v1737.__r_.__value_.__l.__size_)
                          {
                            v1017 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
                            do
                              v1018 = __ldxr(v1017);
                            while (__stxr(v1018 + 1, v1017));
                            v1742.__r_.__value_.__l.__size_ = *((_QWORD *)&v1016 + 1);
                            do
                              v1019 = __ldxr(v1017);
                            while (__stxr(v1019 + 1, v1017));
                          }
                          else
                          {
                            v1742.__r_.__value_.__l.__size_ = 0;
                          }
                          v1742.__r_.__value_.__r.__words[0] = v1016;
                          if ((_QWORD)v1016)
                          {
                            v1020 = v1756;
                            v1751 = v1756;
                            if (*((_QWORD *)&v1756 + 1))
                            {
                              v1021 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
                              do
                                v1022 = __ldxr(v1021);
                              while (__stxr(v1022 + 1, v1021));
                              *((_QWORD *)&v1752 + 1) = *((_QWORD *)&v1020 + 1);
                              do
                                v1023 = __ldxr(v1021);
                              while (__stxr(v1023 + 1, v1021));
                            }
                            else
                            {
                              *((_QWORD *)&v1752 + 1) = 0;
                            }
                            *(_QWORD *)&v1752 = v1020;
                            if ((_QWORD)v1020)
                            {
                              SLAM::SLAM::PerformScript((uint64_t)&value, (uint64_t *)&v1742, (uint64_t *)&v1752, (uint64_t)__p);
                              v1024 = (std::__shared_weak_count *)*((_QWORD *)&v1752 + 1);
                              if (*((_QWORD *)&v1752 + 1))
                              {
                                v1025 = (unint64_t *)(*((_QWORD *)&v1752 + 1) + 8);
                                do
                                  v1026 = __ldaxr(v1025);
                                while (__stlxr(v1026 - 1, v1025));
                                if (!v1026)
                                {
                                  ((void (*)(std::__shared_weak_count *))v1024->__on_zero_shared)(v1024);
                                  std::__shared_weak_count::__release_weak(v1024);
                                }
                              }
                              v1027 = (std::__shared_weak_count *)*((_QWORD *)&v1751 + 1);
                              if (*((_QWORD *)&v1751 + 1))
                              {
                                v1028 = (unint64_t *)(*((_QWORD *)&v1751 + 1) + 8);
                                do
                                  v1029 = __ldaxr(v1028);
                                while (__stlxr(v1029 - 1, v1028));
                                if (!v1029)
                                {
                                  ((void (*)(std::__shared_weak_count *))v1027->__on_zero_shared)(v1027);
                                  std::__shared_weak_count::__release_weak(v1027);
                                }
                              }
                              v1030 = (std::__shared_weak_count *)v1742.__r_.__value_.__l.__size_;
                              if (v1742.__r_.__value_.__l.__size_)
                              {
                                v1031 = (unint64_t *)(v1742.__r_.__value_.__l.__size_ + 8);
                                do
                                  v1032 = __ldaxr(v1031);
                                while (__stlxr(v1032 - 1, v1031));
                                if (!v1032)
                                {
                                  ((void (*)(std::__shared_weak_count *))v1030->__on_zero_shared)(v1030);
                                  std::__shared_weak_count::__release_weak(v1030);
                                }
                              }
                              v1033 = (std::__shared_weak_count *)*((_QWORD *)&v1753 + 1);
                              if (*((_QWORD *)&v1753 + 1))
                              {
                                v1034 = (unint64_t *)(*((_QWORD *)&v1753 + 1) + 8);
                                do
                                  v1035 = __ldaxr(v1034);
                                while (__stlxr(v1035 - 1, v1034));
                                if (!v1035)
                                {
                                  ((void (*)(std::__shared_weak_count *))v1033->__on_zero_shared)(v1033);
                                  std::__shared_weak_count::__release_weak(v1033);
                                }
                              }
                              if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0)
                                operator delete(value.__r_.__value_.__l.__data_);
                              if (BYTE8(v1758))
                              {
                                v1629 = __cxa_allocate_exception(0x48uLL);
                                v1630 = SLAM::Error::Add((std::vector<std::string> *)__p, "At installation trigger %s script %s\n", *v962, v962[5]);
                                ctu::join<std::__wrap_iter<std::string const*>>(v1630->__begin_, v1630->__end_, ", ", 2uLL, &v1783);
                                v1631 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1629, (__int128 *)&v1783, 36, CFSTR("SEUpdaterErrorDomain"));
                              }
                              pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                              v1036 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                              if (!off_2553234C0)
                              {
                                SEUpdaterUtil::SELogObj::create_default_global(&v1783);
                                std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
                                v1037 = (std::__shared_weak_count *)v1783.__r_.__value_.__l.__size_;
                                if (v1783.__r_.__value_.__l.__size_)
                                {
                                  v1038 = (unint64_t *)(v1783.__r_.__value_.__l.__size_ + 8);
                                  do
                                    v1039 = __ldaxr(v1038);
                                  while (__stlxr(v1039 - 1, v1038));
                                  if (!v1039)
                                  {
                                    ((void (*)(std::__shared_weak_count *))v1037->__on_zero_shared)(v1037);
                                    std::__shared_weak_count::__release_weak(v1037);
                                  }
                                }
                                v1036 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                              }
                              v1040 = (std::__shared_weak_count *)off_2553234C8;
                              v1748 = (std::string::size_type)v1036;
                              v1749 = (std::__shared_weak_count *)off_2553234C8;
                              if (off_2553234C8)
                              {
                                v1041 = (unint64_t *)((char *)off_2553234C8 + 8);
                                do
                                  v1042 = __ldxr(v1041);
                                while (__stxr(v1042 + 1, v1041));
                              }
                              pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                              SEUpdaterUtil::SELogObj::printLog(v1036, (SEUpdaterUtil::SELogObj *)2, 0, 1, "InstallMissingInstances", (SEUpdaterUtil::SELogObj *)"Successfully ran trigger %s\n", *v962);
                              if (v1040)
                              {
                                v1043 = (unint64_t *)&v1040->__shared_owners_;
                                do
                                  v1044 = __ldaxr(v1043);
                                while (__stlxr(v1044 - 1, v1043));
                                if (!v1044)
                                {
                                  ((void (*)(std::__shared_weak_count *))v1040->__on_zero_shared)(v1040);
                                  std::__shared_weak_count::__release_weak(v1040);
                                }
                              }
                              if (BYTE8(v1758))
                              {
                                v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
                                std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v1783);
                              }
                              goto LABEL_1837;
                            }
                          }
LABEL_2917:
                          std::terminate();
                        }
                      }
                      v965 += 24;
                      v945 = v1725;
                      v964 = v969;
                      v963 = v968;
                    }
                    while (v965 != v966);
                  }
                  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                  v973 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                  if (!off_2553234C0)
                  {
                    SEUpdaterUtil::SELogObj::create_default_global(__p);
                    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
                    v974 = (std::__shared_weak_count *)__p[1];
                    if (__p[1])
                    {
                      v975 = (unint64_t *)((char *)__p[1] + 8);
                      do
                        v976 = __ldaxr(v975);
                      while (__stlxr(v976 - 1, v975));
                      if (!v976)
                      {
                        ((void (*)(std::__shared_weak_count *))v974->__on_zero_shared)(v974);
                        std::__shared_weak_count::__release_weak(v974);
                      }
                    }
                    v973 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                  }
                  v977 = (std::__shared_weak_count *)off_2553234C8;
                  v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v973;
                  v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
                  if (off_2553234C8)
                  {
                    v978 = (unint64_t *)((char *)off_2553234C8 + 8);
                    do
                      v979 = __ldxr(v978);
                    while (__stxr(v979 + 1, v978));
                  }
                  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                  SEUpdaterUtil::SELogObj::printLog(v973, (SEUpdaterUtil::SELogObj *)2, 0, 1, "InstallMissingInstances", (SEUpdaterUtil::SELogObj *)"All instances found for %s\n", *v962);
                  if (!v977)
                    goto LABEL_1837;
                  v980 = (unint64_t *)&v977->__shared_owners_;
                  do
                    v981 = __ldaxr(v980);
                  while (__stlxr(v981 - 1, v980));
                }
                else
                {
                  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                  v989 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                  if (!off_2553234C0)
                  {
                    SEUpdaterUtil::SELogObj::create_default_global(__p);
                    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
                    v990 = (std::__shared_weak_count *)__p[1];
                    if (__p[1])
                    {
                      v991 = (unint64_t *)((char *)__p[1] + 8);
                      do
                        v992 = __ldaxr(v991);
                      while (__stlxr(v992 - 1, v991));
                      if (!v992)
                      {
                        ((void (*)(std::__shared_weak_count *))v990->__on_zero_shared)(v990);
                        std::__shared_weak_count::__release_weak(v990);
                      }
                    }
                    v989 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                  }
                  v977 = (std::__shared_weak_count *)off_2553234C8;
                  v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v989;
                  v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
                  if (off_2553234C8)
                  {
                    v993 = (unint64_t *)((char *)off_2553234C8 + 8);
                    do
                      v994 = __ldxr(v993);
                    while (__stxr(v994 + 1, v993));
                  }
                  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                  SEUpdaterUtil::SELogObj::printLog(v989, (SEUpdaterUtil::SELogObj *)2, 0, 1, "InstallMissingInstances", (SEUpdaterUtil::SELogObj *)"Skipping Install Missing Instance <%s> by platform\n", *v962);
                  if (!v977)
                    goto LABEL_1837;
                  v995 = (unint64_t *)&v977->__shared_owners_;
                  do
                    v981 = __ldaxr(v995);
                  while (__stlxr(v981 - 1, v995));
                }
              }
              else
              {
                pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                v982 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                if (!off_2553234C0)
                {
                  SEUpdaterUtil::SELogObj::create_default_global(__p);
                  std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
                  v983 = (std::__shared_weak_count *)__p[1];
                  if (__p[1])
                  {
                    v984 = (unint64_t *)((char *)__p[1] + 8);
                    do
                      v985 = __ldaxr(v984);
                    while (__stlxr(v985 - 1, v984));
                    if (!v985)
                    {
                      ((void (*)(std::__shared_weak_count *))v983->__on_zero_shared)(v983);
                      std::__shared_weak_count::__release_weak(v983);
                    }
                  }
                  v982 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                }
                v977 = (std::__shared_weak_count *)off_2553234C8;
                v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v982;
                v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
                if (off_2553234C8)
                {
                  v986 = (unint64_t *)((char *)off_2553234C8 + 8);
                  do
                    v987 = __ldxr(v986);
                  while (__stxr(v987 + 1, v986));
                }
                pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                SEUpdaterUtil::SELogObj::printLog(v982, (SEUpdaterUtil::SELogObj *)2, 0, 1, "InstallMissingInstances", (SEUpdaterUtil::SELogObj *)"Skipping Install Missing Instance <%s> by key\n", *v962);
                if (!v977)
                  goto LABEL_1837;
                v988 = (unint64_t *)&v977->__shared_owners_;
                do
                  v981 = __ldaxr(v988);
                while (__stlxr(v981 - 1, v988));
              }
              if (!v981)
              {
                ((void (*)(std::__shared_weak_count *))v977->__on_zero_shared)(v977);
                std::__shared_weak_count::__release_weak(v977);
              }
LABEL_1837:
              v962 += 6;
            }
            while (v962 != (const char **)v963);
          }
          __p[0] = &v1750;
          std::vector<SEUpdater::SLAM::Installation::InstallationTrigger>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
          __p[0] = &v1782;
          std::vector<SEUpdater::InstanceInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
          v1045 = (std::__shared_weak_count *)*((_QWORD *)&v1756 + 1);
          v653 = v1726;
          if (*((_QWORD *)&v1756 + 1))
          {
            v1046 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
            do
              v1047 = __ldaxr(v1046);
            while (__stlxr(v1047 - 1, v1046));
            if (!v1047)
            {
              ((void (*)(std::__shared_weak_count *))v1045->__on_zero_shared)(v1045);
              std::__shared_weak_count::__release_weak(v1045);
            }
          }
          v1048 = (std::__shared_weak_count *)v1737.__r_.__value_.__l.__size_;
          if (v1737.__r_.__value_.__l.__size_)
          {
            v1049 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
            do
              v1050 = __ldaxr(v1049);
            while (__stlxr(v1050 - 1, v1049));
            if (!v1050)
            {
              ((void (*)(std::__shared_weak_count *))v1048->__on_zero_shared)(v1048);
              std::__shared_weak_count::__release_weak(v1048);
            }
          }
          v1051 = *v1726;
          v1052 = *((_DWORD *)*v1726 + 14);
          if (v1052 != 44 && v1052 != 115)
          {
            std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(__p, *((_QWORD *)this + 20), *((std::__shared_weak_count **)this + 21));
            v1053 = __p[0];
            v1054 = (char *)__p[1];
            *(_OWORD *)&v1782.__r_.__value_.__l.__data_ = *(_OWORD *)__p;
            v1055 = (unint64_t *)operator new(0x20uLL);
            v1055[1] = 0;
            v1056 = v1055 + 1;
            v1055[2] = 0;
            *v1055 = (unint64_t)&off_24E0C1170;
            v1055[3] = (unint64_t)&off_24E0C11C0;
            v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)(v1055 + 3);
            v1750.__r_.__value_.__l.__size_ = (std::string::size_type)v1055;
            std::string::basic_string[abi:ne180100]<0>(&value, "SLAMConfigureProhibitTimer");
            v1737.__r_.__value_.__r.__words[0] = (std::string::size_type)v1053;
            v1737.__r_.__value_.__l.__size_ = (std::string::size_type)v1054;
            if (v1054)
            {
              v1057 = (unint64_t *)(v1054 + 8);
              do
                v1058 = __ldxr(v1057);
              while (__stxr(v1058 + 1, v1057));
              v1742.__r_.__value_.__l.__size_ = (std::string::size_type)v1054;
              do
                v1059 = __ldxr(v1057);
              while (__stxr(v1059 + 1, v1057));
            }
            else
            {
              v1742.__r_.__value_.__l.__size_ = 0;
            }
            v1742.__r_.__value_.__r.__words[0] = (std::string::size_type)v1053;
            if (!v1053)
              goto LABEL_2917;
            cf = v1055 + 3;
            v1755 = v1055;
            do
              v1060 = __ldxr(v1056);
            while (__stxr(v1060 + 1, v1056));
            *(_QWORD *)&v1756 = v1055 + 3;
            *((_QWORD *)&v1756 + 1) = v1055;
            do
              v1061 = __ldxr(v1056);
            while (__stxr(v1061 + 1, v1056));
            SLAM::SLAM::PerformScript((uint64_t)&value, (uint64_t *)&v1742, (uint64_t *)&v1756, (uint64_t)__p);
            v1062 = (std::__shared_weak_count *)*((_QWORD *)&v1756 + 1);
            if (*((_QWORD *)&v1756 + 1))
            {
              v1063 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
              do
                v1064 = __ldaxr(v1063);
              while (__stlxr(v1064 - 1, v1063));
              if (!v1064)
              {
                ((void (*)(std::__shared_weak_count *))v1062->__on_zero_shared)(v1062);
                std::__shared_weak_count::__release_weak(v1062);
              }
            }
            v1065 = (std::__shared_weak_count *)v1755;
            if (v1755)
            {
              v1066 = v1755 + 1;
              do
                v1067 = __ldaxr(v1066);
              while (__stlxr(v1067 - 1, v1066));
              if (!v1067)
              {
                ((void (*)(std::__shared_weak_count *))v1065->__on_zero_shared)(v1065);
                std::__shared_weak_count::__release_weak(v1065);
              }
            }
            v1068 = (std::__shared_weak_count *)v1742.__r_.__value_.__l.__size_;
            if (v1742.__r_.__value_.__l.__size_)
            {
              v1069 = (unint64_t *)(v1742.__r_.__value_.__l.__size_ + 8);
              do
                v1070 = __ldaxr(v1069);
              while (__stlxr(v1070 - 1, v1069));
              if (!v1070)
              {
                ((void (*)(std::__shared_weak_count *))v1068->__on_zero_shared)(v1068);
                std::__shared_weak_count::__release_weak(v1068);
              }
            }
            v1071 = (std::__shared_weak_count *)v1737.__r_.__value_.__l.__size_;
            if (v1737.__r_.__value_.__l.__size_)
            {
              v1072 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
              do
                v1073 = __ldaxr(v1072);
              while (__stlxr(v1073 - 1, v1072));
              if (!v1073)
              {
                ((void (*)(std::__shared_weak_count *))v1071->__on_zero_shared)(v1071);
                std::__shared_weak_count::__release_weak(v1071);
              }
            }
            if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0)
              operator delete(value.__r_.__value_.__l.__data_);
            if (BYTE8(v1758))
            {
              v1688 = __cxa_allocate_exception(0x48uLL);
              v1689 = SLAM::Error::Add((std::vector<std::string> *)__p, "At Configure Prohibit Timer");
              ctu::join<std::__wrap_iter<std::string const*>>(v1689->__begin_, v1689->__end_, ", ", 2uLL, &v1783);
              v1690 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1688, (__int128 *)&v1783, 36, CFSTR("SEUpdaterErrorDomain"));
            }
            pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v1074 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            if (!off_2553234C0)
            {
              SEUpdaterUtil::SELogObj::create_default_global(&v1783);
              std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
              v1075 = (std::__shared_weak_count *)v1783.__r_.__value_.__l.__size_;
              if (v1783.__r_.__value_.__l.__size_)
              {
                v1076 = (unint64_t *)(v1783.__r_.__value_.__l.__size_ + 8);
                do
                  v1077 = __ldaxr(v1076);
                while (__stlxr(v1077 - 1, v1076));
                if (!v1077)
                {
                  ((void (*)(std::__shared_weak_count *))v1075->__on_zero_shared)(v1075);
                  std::__shared_weak_count::__release_weak(v1075);
                }
              }
              v1074 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            }
            v1078 = (std::__shared_weak_count *)off_2553234C8;
            *(_QWORD *)&v1753 = v1074;
            *((_QWORD *)&v1753 + 1) = off_2553234C8;
            if (off_2553234C8)
            {
              v1079 = (unint64_t *)((char *)off_2553234C8 + 8);
              do
                v1080 = __ldxr(v1079);
              while (__stxr(v1080 + 1, v1079));
            }
            pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            SEUpdaterUtil::SELogObj::printLog(v1074, (SEUpdaterUtil::SELogObj *)2, 0, 1, "ConfigureProhibitTimer", (SEUpdaterUtil::SELogObj *)"Successfully Configured Prohibit Timer \n");
            if (v1078)
            {
              v1081 = (unint64_t *)&v1078->__shared_owners_;
              do
                v1082 = __ldaxr(v1081);
              while (__stlxr(v1082 - 1, v1081));
              if (!v1082)
              {
                ((void (*)(std::__shared_weak_count *))v1078->__on_zero_shared)(v1078);
                std::__shared_weak_count::__release_weak(v1078);
              }
            }
            if (BYTE8(v1758))
            {
              v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
              std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v1783);
            }
            v1083 = (std::__shared_weak_count *)v1750.__r_.__value_.__l.__size_;
            if (v1750.__r_.__value_.__l.__size_)
            {
              v1084 = (unint64_t *)(v1750.__r_.__value_.__l.__size_ + 8);
              do
                v1085 = __ldaxr(v1084);
              while (__stlxr(v1085 - 1, v1084));
              if (!v1085)
              {
                ((void (*)(std::__shared_weak_count *))v1083->__on_zero_shared)(v1083);
                std::__shared_weak_count::__release_weak(v1083);
              }
            }
            v1086 = (std::__shared_weak_count *)v1782.__r_.__value_.__l.__size_;
            if (v1782.__r_.__value_.__l.__size_)
            {
              v1087 = (unint64_t *)(v1782.__r_.__value_.__l.__size_ + 8);
              do
                v1088 = __ldaxr(v1087);
              while (__stlxr(v1088 - 1, v1087));
              if (!v1088)
              {
                ((void (*)(std::__shared_weak_count *))v1086->__on_zero_shared)(v1086);
                std::__shared_weak_count::__release_weak(v1086);
              }
            }
            v1051 = *v1726;
          }
          v1089 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
          v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)v1051;
          v1750.__r_.__value_.__l.__size_ = (std::string::size_type)v1089;
          if (v1089)
          {
            v1090 = (unint64_t *)&v1089->__shared_owners_;
            do
              v1091 = __ldxr(v1090);
            while (__stxr(v1091 + 1, v1090));
          }
          v1092 = (*(uint64_t (**)(SERestoreInfo::P73BaseDeviceInfo *))(*(_QWORD *)v1051 + 32))(v1051);
          if (v1092 != 200)
          {
            if (v1092 == 115)
            {
              v1093 = 1294;
LABEL_1921:
              if (*((_DWORD *)v1051 + 3) <= v1093)
                goto LABEL_1923;
              goto LABEL_1922;
            }
            if (v1092 != 100)
            {
LABEL_1922:
              v1094 = *((_DWORD *)*v1726 + 46);
              if (v1094 >= 0x14)
              {
                if (v1089)
                {
                  v1097 = (unint64_t *)&v1089->__shared_owners_;
                  do
                    v1098 = __ldaxr(v1097);
                  while (__stlxr(v1098 - 1, v1097));
                  if (!v1098)
                  {
                    ((void (*)(std::__shared_weak_count *))v1089->__on_zero_shared)(v1089);
                    std::__shared_weak_count::__release_weak(v1089);
                  }
                }
                if (v1094 != -1)
                {
                  LODWORD(v1760) = 0;
                  v1758 = 0u;
                  v1759 = 0u;
                  *(_OWORD *)__p = 0u;
                  v1099 = *((_QWORD *)this + 21);
                  v1742.__r_.__value_.__r.__words[0] = *((_QWORD *)this + 20);
                  v1742.__r_.__value_.__l.__size_ = v1099;
                  if (v1099)
                  {
                    v1100 = (unint64_t *)(v1099 + 8);
                    do
                      v1101 = __ldxr(v1100);
                    while (__stxr(v1101 + 1, v1100));
                  }
                  v1102 = *((_QWORD *)this + 17);
                  v1737.__r_.__value_.__r.__words[0] = *((_QWORD *)this + 16);
                  v1737.__r_.__value_.__l.__size_ = v1102;
                  if (v1102)
                  {
                    v1103 = (unint64_t *)(v1102 + 8);
                    do
                      v1104 = __ldxr(v1103);
                    while (__stxr(v1104 + 1, v1103));
                  }
                  SEUpdater::GetAvailableMemory((uint64_t *)&v1742, (uint64_t)&v1737, (uint64_t)__p);
                  v1105 = (std::__shared_weak_count *)v1737.__r_.__value_.__l.__size_;
                  if (v1737.__r_.__value_.__l.__size_)
                  {
                    v1106 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
                    do
                      v1107 = __ldaxr(v1106);
                    while (__stlxr(v1107 - 1, v1106));
                    if (!v1107)
                    {
                      ((void (*)(std::__shared_weak_count *))v1105->__on_zero_shared)(v1105);
                      std::__shared_weak_count::__release_weak(v1105);
                    }
                  }
                  v1108 = (std::__shared_weak_count *)v1742.__r_.__value_.__l.__size_;
                  if (v1742.__r_.__value_.__l.__size_)
                  {
                    v1109 = (unint64_t *)(v1742.__r_.__value_.__l.__size_ + 8);
                    do
                      v1110 = __ldaxr(v1109);
                    while (__stlxr(v1110 - 1, v1109));
                    if (!v1110)
                    {
                      ((void (*)(std::__shared_weak_count *))v1108->__on_zero_shared)(v1108);
                      std::__shared_weak_count::__release_weak(v1108);
                    }
                  }
                  if (*(_QWORD *)((char *)&v1759 + 4) != 0x500000000200)
                  {
                    std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(&value, *((_QWORD *)this + 20), *((std::__shared_weak_count **)this + 21));
                    v1111 = *(_OWORD *)&value.__r_.__value_.__l.__data_;
                    v1756 = *(_OWORD *)&value.__r_.__value_.__l.__data_;
                    v1112 = (unint64_t *)operator new(0x20uLL);
                    v1112[1] = 0;
                    v1113 = v1112 + 1;
                    v1112[2] = 0;
                    *v1112 = (unint64_t)&off_24E0C1170;
                    v1112[3] = (unint64_t)&off_24E0C11C0;
                    cf = v1112 + 3;
                    v1755 = v1112;
                    std::string::basic_string[abi:ne180100]<0>(&v1783, "SLAMConfigureOSUReserves");
                    v1752 = v1111;
                    if (*((_QWORD *)&v1111 + 1))
                    {
                      v1114 = (unint64_t *)(*((_QWORD *)&v1111 + 1) + 8);
                      do
                        v1115 = __ldxr(v1114);
                      while (__stxr(v1115 + 1, v1114));
                      *((_QWORD *)&v1753 + 1) = *((_QWORD *)&v1111 + 1);
                      do
                        v1116 = __ldxr(v1114);
                      while (__stxr(v1116 + 1, v1114));
                    }
                    else
                    {
                      *((_QWORD *)&v1753 + 1) = 0;
                    }
                    *(_QWORD *)&v1753 = v1111;
                    if (!(_QWORD)v1111)
                      goto LABEL_2917;
                    v1748 = (std::string::size_type)(v1112 + 3);
                    v1749 = (std::__shared_weak_count *)v1112;
                    do
                      v1347 = __ldxr(v1113);
                    while (__stxr(v1347 + 1, v1113));
                    *(_QWORD *)&v1751 = v1112 + 3;
                    *((_QWORD *)&v1751 + 1) = v1112;
                    do
                      v1348 = __ldxr(v1113);
                    while (__stxr(v1348 + 1, v1113));
                    SLAM::SLAM::PerformScript((uint64_t)&v1783, (uint64_t *)&v1753, (uint64_t *)&v1751, (uint64_t)&value);
                    v1349 = (std::__shared_weak_count *)*((_QWORD *)&v1751 + 1);
                    if (*((_QWORD *)&v1751 + 1))
                    {
                      v1350 = (unint64_t *)(*((_QWORD *)&v1751 + 1) + 8);
                      do
                        v1351 = __ldaxr(v1350);
                      while (__stlxr(v1351 - 1, v1350));
                      if (!v1351)
                      {
                        ((void (*)(std::__shared_weak_count *))v1349->__on_zero_shared)(v1349);
                        std::__shared_weak_count::__release_weak(v1349);
                      }
                    }
                    v1352 = v1749;
                    if (v1749)
                    {
                      v1353 = (unint64_t *)&v1749->__shared_owners_;
                      do
                        v1354 = __ldaxr(v1353);
                      while (__stlxr(v1354 - 1, v1353));
                      if (!v1354)
                      {
                        ((void (*)(std::__shared_weak_count *))v1352->__on_zero_shared)(v1352);
                        std::__shared_weak_count::__release_weak(v1352);
                      }
                    }
                    v1355 = (std::__shared_weak_count *)*((_QWORD *)&v1753 + 1);
                    if (*((_QWORD *)&v1753 + 1))
                    {
                      v1356 = (unint64_t *)(*((_QWORD *)&v1753 + 1) + 8);
                      do
                        v1357 = __ldaxr(v1356);
                      while (__stlxr(v1357 - 1, v1356));
                      if (!v1357)
                      {
                        ((void (*)(std::__shared_weak_count *))v1355->__on_zero_shared)(v1355);
                        std::__shared_weak_count::__release_weak(v1355);
                      }
                    }
                    v1358 = (std::__shared_weak_count *)*((_QWORD *)&v1752 + 1);
                    if (*((_QWORD *)&v1752 + 1))
                    {
                      v1359 = (unint64_t *)(*((_QWORD *)&v1752 + 1) + 8);
                      do
                        v1360 = __ldaxr(v1359);
                      while (__stlxr(v1360 - 1, v1359));
                      if (!v1360)
                      {
                        ((void (*)(std::__shared_weak_count *))v1358->__on_zero_shared)(v1358);
                        std::__shared_weak_count::__release_weak(v1358);
                      }
                    }
                    if (SHIBYTE(v1783.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v1783.__r_.__value_.__l.__data_);
                    if (v1787[0])
                    {
                      v1709 = __cxa_allocate_exception(0x48uLL);
                      v1710 = SLAM::Error::Add((std::vector<std::string> *)&value, "At Configure OSU Reserve");
                      ctu::join<std::__wrap_iter<std::string const*>>(v1710->__begin_, v1710->__end_, ", ", 2uLL, &v1782);
                      v1711 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1709, (__int128 *)&v1782, 36, CFSTR("SEUpdaterErrorDomain"));
                    }
                    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                    v1361 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                    if (!off_2553234C0)
                    {
                      SEUpdaterUtil::SELogObj::create_default_global(&v1782);
                      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1782);
                      v1362 = (std::__shared_weak_count *)v1782.__r_.__value_.__l.__size_;
                      if (v1782.__r_.__value_.__l.__size_)
                      {
                        v1363 = (unint64_t *)(v1782.__r_.__value_.__l.__size_ + 8);
                        do
                          v1364 = __ldaxr(v1363);
                        while (__stlxr(v1364 - 1, v1363));
                        if (!v1364)
                        {
                          ((void (*)(std::__shared_weak_count *))v1362->__on_zero_shared)(v1362);
                          std::__shared_weak_count::__release_weak(v1362);
                        }
                      }
                      v1361 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                    }
                    v1365 = (std::__shared_weak_count *)off_2553234C8;
                    *(_QWORD *)&v1747 = v1361;
                    *((_QWORD *)&v1747 + 1) = off_2553234C8;
                    if (off_2553234C8)
                    {
                      v1366 = (unint64_t *)((char *)off_2553234C8 + 8);
                      do
                        v1367 = __ldxr(v1366);
                      while (__stxr(v1367 + 1, v1366));
                    }
                    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                    SEUpdaterUtil::SELogObj::printLog(v1361, (SEUpdaterUtil::SELogObj *)2, 0, 1, "ConfigureOSUReserves", (SEUpdaterUtil::SELogObj *)"Successfully Configured OSU Reserve \n");
                    if (v1365)
                    {
                      v1368 = (unint64_t *)&v1365->__shared_owners_;
                      do
                        v1369 = __ldaxr(v1368);
                      while (__stlxr(v1369 - 1, v1368));
                      if (!v1369)
                      {
                        ((void (*)(std::__shared_weak_count *))v1365->__on_zero_shared)(v1365);
                        std::__shared_weak_count::__release_weak(v1365);
                      }
                    }
                    if (v1787[0])
                    {
                      v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)&value;
                      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v1782);
                    }
                    v1370 = (std::__shared_weak_count *)v1755;
                    if (v1755)
                    {
                      v1371 = v1755 + 1;
                      do
                        v1372 = __ldaxr(v1371);
                      while (__stlxr(v1372 - 1, v1371));
                      if (!v1372)
                      {
                        ((void (*)(std::__shared_weak_count *))v1370->__on_zero_shared)(v1370);
                        std::__shared_weak_count::__release_weak(v1370);
                      }
                    }
                    v1121 = (std::__shared_weak_count *)*((_QWORD *)&v1756 + 1);
                    if (*((_QWORD *)&v1756 + 1))
                    {
                      v1373 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
                      do
                        v1125 = __ldaxr(v1373);
                      while (__stlxr(v1125 - 1, v1373));
LABEL_1970:
                      if (!v1125)
                      {
                        ((void (*)(std::__shared_weak_count *))v1121->__on_zero_shared)(v1121);
                        std::__shared_weak_count::__release_weak(v1121);
                      }
                    }
                  }
LABEL_1972:
                  v1126 = operator new(0x10uLL);
                  *v1126 = xmmword_21CCD8A60;
                  value.__r_.__value_.__l.__size_ = (std::string::size_type)(v1126 + 1);
                  value.__r_.__value_.__r.__words[2] = (std::string::size_type)(v1126 + 1);
                  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1126;
                  v1127 = (char *)operator new(0xFuLL);
                  *(_QWORD *)v1127 = 0x535477000000A0;
                  *((_DWORD *)v1127 + 2) = 0x10000;
                  *((_WORD *)v1127 + 6) = 7437;
                  v1127[14] = 0;
                  v1128 = *((_QWORD *)this + 21);
                  v1742.__r_.__value_.__r.__words[0] = *((_QWORD *)this + 20);
                  v1742.__r_.__value_.__l.__size_ = v1128;
                  if (v1128)
                  {
                    v1129 = (unint64_t *)(v1128 + 8);
                    do
                      v1130 = __ldxr(v1129);
                    while (__stxr(v1130 + 1, v1129));
                  }
                  SEUpdater::GetPackageInfo((uint64_t *)&v1742, (std::string::size_type *)&v1783);
                  v1131 = (std::__shared_weak_count *)v1742.__r_.__value_.__l.__size_;
                  if (v1742.__r_.__value_.__l.__size_)
                  {
                    v1132 = (unint64_t *)(v1742.__r_.__value_.__l.__size_ + 8);
                    do
                      v1133 = __ldaxr(v1132);
                    while (__stlxr(v1133 - 1, v1132));
                    if (!v1133)
                    {
                      ((void (*)(std::__shared_weak_count *))v1131->__on_zero_shared)(v1131);
                      std::__shared_weak_count::__release_weak(v1131);
                    }
                  }
                  v1134 = v1783.__r_.__value_.__l.__size_;
                  v1135 = SEUpdater::find_if<std::vector<SEUpdater::PackageInfo>,SEUpdater::FindPackageForModule(std::vector<SEUpdater::PackageInfo> const&,std::vector<unsigned char> const&)::{lambda(std::vector<SEUpdater::PackageInfo> const&)#1}>((uint64_t)v1783.__r_.__value_.__l.__data_, v1783.__r_.__value_.__l.__size_, (uint64_t)&value);
                  if (v1134 == v1135)
                  {
                    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                    v1151 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                    if (!off_2553234C0)
                    {
                      SEUpdaterUtil::SELogObj::create_default_global(__p);
                      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
                      v1152 = (std::__shared_weak_count *)__p[1];
                      if (__p[1])
                      {
                        v1153 = (unint64_t *)((char *)__p[1] + 8);
                        do
                          v1154 = __ldaxr(v1153);
                        while (__stlxr(v1154 - 1, v1153));
                        if (!v1154)
                        {
                          ((void (*)(std::__shared_weak_count *))v1152->__on_zero_shared)(v1152);
                          std::__shared_weak_count::__release_weak(v1152);
                        }
                      }
                      v1151 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                    }
                    v1155 = (std::__shared_weak_count *)off_2553234C8;
                    v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v1151;
                    v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
                    if (off_2553234C8)
                    {
                      v1156 = (unint64_t *)((char *)off_2553234C8 + 8);
                      do
                        v1157 = __ldxr(v1156);
                      while (__stxr(v1157 + 1, v1156));
                    }
                    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                    SEUpdaterUtil::SELogObj::printLog(v1151, (SEUpdaterUtil::SELogObj *)2, 0, 1, "DeleteNeonAppletYK300R106", (SEUpdaterUtil::SELogObj *)"No Neon Package loaded on device, skipping delete operation\n");
                    if (!v1155)
                      goto LABEL_2088;
                    v1158 = (unint64_t *)&v1155->__shared_owners_;
                    do
                      v1159 = __ldaxr(v1158);
                    while (__stlxr(v1159 - 1, v1158));
                  }
                  else
                  {
                    v1136 = *(uint64_t **)v1135;
                    if (*(_QWORD *)(v1135 + 8) - *(_QWORD *)v1135 != 15
                      || ((v1137 = *v1136, v1138 = *(uint64_t *)((char *)v1136 + 7), v1137 == *(_QWORD *)v1127)
                        ? (v1139 = v1138 == *(_QWORD *)(v1127 + 7))
                        : (v1139 = 0),
                          !v1139))
                    {
                      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                      v1140 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                      if (!off_2553234C0)
                      {
                        SEUpdaterUtil::SELogObj::create_default_global(__p);
                        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
                        v1141 = (std::__shared_weak_count *)__p[1];
                        if (__p[1])
                        {
                          v1142 = (unint64_t *)((char *)__p[1] + 8);
                          do
                            v1143 = __ldaxr(v1142);
                          while (__stlxr(v1143 - 1, v1142));
                          if (!v1143)
                          {
                            ((void (*)(std::__shared_weak_count *))v1141->__on_zero_shared)(v1141);
                            std::__shared_weak_count::__release_weak(v1141);
                          }
                        }
                        v1140 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                      }
                      v1144 = (std::__shared_weak_count *)off_2553234C8;
                      v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v1140;
                      v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
                      if (off_2553234C8)
                      {
                        v1145 = (unint64_t *)((char *)off_2553234C8 + 8);
                        do
                          v1146 = __ldxr(v1145);
                        while (__stxr(v1146 + 1, v1145));
                      }
                      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                      ctu::hex();
                      if ((SBYTE7(v1758) & 0x80u) == 0)
                        v1147 = __p;
                      else
                        v1147 = (void **)__p[0];
                      SEUpdaterUtil::SELogObj::printLog(v1140, (SEUpdaterUtil::SELogObj *)2, 0, 1, "DeleteNeonAppletYK300R106", (SEUpdaterUtil::SELogObj *)"Neon Package AID on device is %s, skipping delete operation\n", (const char *)v1147);
                      if (SBYTE7(v1758) < 0)
                        operator delete(__p[0]);
                      if (!v1144)
                        goto LABEL_2088;
                      v1148 = (unint64_t *)&v1144->__shared_owners_;
                      do
                        v1149 = __ldaxr(v1148);
                      while (__stlxr(v1149 - 1, v1148));
                      if (v1149)
                        goto LABEL_2088;
                      ((void (*)(std::__shared_weak_count *))v1144->__on_zero_shared)(v1144);
                      v1150 = v1144;
                      goto LABEL_2087;
                    }
                    std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(__p, *((_QWORD *)this + 20), *((std::__shared_weak_count **)this + 21));
                    v1160 = __p[0];
                    v1161 = (unint64_t *)__p[1];
                    *(_OWORD *)&v1737.__r_.__value_.__l.__data_ = *(_OWORD *)__p;
                    v1162 = operator new(0x20uLL);
                    v1162[1] = 0;
                    v1163 = v1162 + 1;
                    v1162[2] = 0;
                    *v1162 = &off_24E0C1170;
                    v1162[3] = &off_24E0C11C0;
                    *(_QWORD *)&v1756 = v1162 + 3;
                    *((_QWORD *)&v1756 + 1) = v1162;
                    std::string::basic_string[abi:ne180100]<0>(&v1782, "SLAMDeleteNeon");
                    *(_QWORD *)&v1753 = v1160;
                    *((_QWORD *)&v1753 + 1) = v1161;
                    if (v1161)
                    {
                      v1164 = v1161 + 1;
                      do
                        v1165 = __ldxr(v1164);
                      while (__stxr(v1165 + 1, v1164));
                      v1755 = v1161;
                      do
                        v1166 = __ldxr(v1164);
                      while (__stxr(v1166 + 1, v1164));
                    }
                    else
                    {
                      v1755 = 0;
                    }
                    cf = v1160;
                    if (!v1160)
                      goto LABEL_2917;
                    *(_QWORD *)&v1751 = v1162 + 3;
                    *((_QWORD *)&v1751 + 1) = v1162;
                    do
                      v1167 = __ldxr(v1163);
                    while (__stxr(v1167 + 1, v1163));
                    *(_QWORD *)&v1752 = v1162 + 3;
                    *((_QWORD *)&v1752 + 1) = v1162;
                    do
                      v1168 = __ldxr(v1163);
                    while (__stxr(v1168 + 1, v1163));
                    SLAM::SLAM::PerformScript((uint64_t)&v1782, (uint64_t *)&cf, (uint64_t *)&v1752, (uint64_t)__p);
                    v1169 = (std::__shared_weak_count *)*((_QWORD *)&v1752 + 1);
                    if (*((_QWORD *)&v1752 + 1))
                    {
                      v1170 = (unint64_t *)(*((_QWORD *)&v1752 + 1) + 8);
                      do
                        v1171 = __ldaxr(v1170);
                      while (__stlxr(v1171 - 1, v1170));
                      if (!v1171)
                      {
                        ((void (*)(std::__shared_weak_count *))v1169->__on_zero_shared)(v1169);
                        std::__shared_weak_count::__release_weak(v1169);
                      }
                    }
                    v1172 = (std::__shared_weak_count *)*((_QWORD *)&v1751 + 1);
                    if (*((_QWORD *)&v1751 + 1))
                    {
                      v1173 = (unint64_t *)(*((_QWORD *)&v1751 + 1) + 8);
                      do
                        v1174 = __ldaxr(v1173);
                      while (__stlxr(v1174 - 1, v1173));
                      if (!v1174)
                      {
                        ((void (*)(std::__shared_weak_count *))v1172->__on_zero_shared)(v1172);
                        std::__shared_weak_count::__release_weak(v1172);
                      }
                    }
                    v1175 = (std::__shared_weak_count *)v1755;
                    if (v1755)
                    {
                      v1176 = v1755 + 1;
                      do
                        v1177 = __ldaxr(v1176);
                      while (__stlxr(v1177 - 1, v1176));
                      if (!v1177)
                      {
                        ((void (*)(std::__shared_weak_count *))v1175->__on_zero_shared)(v1175);
                        std::__shared_weak_count::__release_weak(v1175);
                      }
                    }
                    v1178 = (std::__shared_weak_count *)*((_QWORD *)&v1753 + 1);
                    if (*((_QWORD *)&v1753 + 1))
                    {
                      v1179 = (unint64_t *)(*((_QWORD *)&v1753 + 1) + 8);
                      do
                        v1180 = __ldaxr(v1179);
                      while (__stlxr(v1180 - 1, v1179));
                      if (!v1180)
                      {
                        ((void (*)(std::__shared_weak_count *))v1178->__on_zero_shared)(v1178);
                        std::__shared_weak_count::__release_weak(v1178);
                      }
                    }
                    if (SHIBYTE(v1782.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v1782.__r_.__value_.__l.__data_);
                    if (BYTE8(v1758))
                    {
                      v1703 = __cxa_allocate_exception(0x48uLL);
                      v1704 = SLAM::Error::Add((std::vector<std::string> *)__p, "At SLAMDeleteNeon");
                      ctu::join<std::__wrap_iter<std::string const*>>(v1704->__begin_, v1704->__end_, ", ", 2uLL, &v1750);
                      v1705 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1703, (__int128 *)&v1750, 36, CFSTR("SEUpdaterErrorDomain"));
                    }
                    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                    v1181 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                    if (!off_2553234C0)
                    {
                      SEUpdaterUtil::SELogObj::create_default_global(&v1750);
                      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1750);
                      v1182 = (std::__shared_weak_count *)v1750.__r_.__value_.__l.__size_;
                      if (v1750.__r_.__value_.__l.__size_)
                      {
                        v1183 = (unint64_t *)(v1750.__r_.__value_.__l.__size_ + 8);
                        do
                          v1184 = __ldaxr(v1183);
                        while (__stlxr(v1184 - 1, v1183));
                        if (!v1184)
                        {
                          ((void (*)(std::__shared_weak_count *))v1182->__on_zero_shared)(v1182);
                          std::__shared_weak_count::__release_weak(v1182);
                        }
                      }
                      v1181 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                    }
                    v1185 = (std::__shared_weak_count *)off_2553234C8;
                    v1748 = (std::string::size_type)v1181;
                    v1749 = (std::__shared_weak_count *)off_2553234C8;
                    if (off_2553234C8)
                    {
                      v1186 = (unint64_t *)((char *)off_2553234C8 + 8);
                      do
                        v1187 = __ldxr(v1186);
                      while (__stxr(v1187 + 1, v1186));
                    }
                    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                    ctu::hex();
                    if ((v1750.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v1188 = &v1750;
                    else
                      v1188 = (std::string *)v1750.__r_.__value_.__r.__words[0];
                    SEUpdaterUtil::SELogObj::printLog(v1181, (SEUpdaterUtil::SELogObj *)2, 0, 1, "DeleteNeonAppletYK300R106", (SEUpdaterUtil::SELogObj *)"Successfully deleted Neon Applet YK300R106 with AID: %s\n", (const char *)v1188);
                    if (SHIBYTE(v1750.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v1750.__r_.__value_.__l.__data_);
                    if (v1185)
                    {
                      v1189 = (unint64_t *)&v1185->__shared_owners_;
                      do
                        v1190 = __ldaxr(v1189);
                      while (__stlxr(v1190 - 1, v1189));
                      if (!v1190)
                      {
                        ((void (*)(std::__shared_weak_count *))v1185->__on_zero_shared)(v1185);
                        std::__shared_weak_count::__release_weak(v1185);
                      }
                    }
                    if (BYTE8(v1758))
                    {
                      v1750.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
                      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v1750);
                    }
                    v1191 = (std::__shared_weak_count *)*((_QWORD *)&v1756 + 1);
                    if (*((_QWORD *)&v1756 + 1))
                    {
                      v1192 = (unint64_t *)(*((_QWORD *)&v1756 + 1) + 8);
                      do
                        v1193 = __ldaxr(v1192);
                      while (__stlxr(v1193 - 1, v1192));
                      if (!v1193)
                      {
                        ((void (*)(std::__shared_weak_count *))v1191->__on_zero_shared)(v1191);
                        std::__shared_weak_count::__release_weak(v1191);
                      }
                    }
                    v1155 = (std::__shared_weak_count *)v1737.__r_.__value_.__l.__size_;
                    if (!v1737.__r_.__value_.__l.__size_)
                      goto LABEL_2088;
                    v1194 = (unint64_t *)(v1737.__r_.__value_.__l.__size_ + 8);
                    do
                      v1159 = __ldaxr(v1194);
                    while (__stlxr(v1159 - 1, v1194));
                  }
                  if (v1159)
                    goto LABEL_2088;
                  ((void (*)(std::__shared_weak_count *))v1155->__on_zero_shared)(v1155);
                  v1150 = v1155;
LABEL_2087:
                  std::__shared_weak_count::__release_weak(v1150);
LABEL_2088:
                  __p[0] = &v1783;
                  std::vector<SEUpdater::PackageInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
                  operator delete(v1127);
                  if (value.__r_.__value_.__r.__words[0])
                    operator delete(value.__r_.__value_.__l.__data_);
                  goto LABEL_2090;
                }
LABEL_1957:
                pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                v1117 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                if (!off_2553234C0)
                {
                  SEUpdaterUtil::SELogObj::create_default_global(__p);
                  std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
                  v1118 = (std::__shared_weak_count *)__p[1];
                  if (__p[1])
                  {
                    v1119 = (unint64_t *)((char *)__p[1] + 8);
                    do
                      v1120 = __ldaxr(v1119);
                    while (__stlxr(v1120 - 1, v1119));
                    if (!v1120)
                    {
                      ((void (*)(std::__shared_weak_count *))v1118->__on_zero_shared)(v1118);
                      std::__shared_weak_count::__release_weak(v1118);
                    }
                  }
                  v1117 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                }
                v1121 = (std::__shared_weak_count *)off_2553234C8;
                value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1117;
                value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
                if (off_2553234C8)
                {
                  v1122 = (unint64_t *)((char *)off_2553234C8 + 8);
                  do
                    v1123 = __ldxr(v1122);
                  while (__stxr(v1123 + 1, v1122));
                }
                pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                SEUpdaterUtil::SELogObj::printLog(v1117, (SEUpdaterUtil::SELogObj *)2, 0, 1, "ConfigureOSUReserves", (SEUpdaterUtil::SELogObj *)"Skip: JCOP version low.\n");
                if (v1121)
                {
                  v1124 = (unint64_t *)&v1121->__shared_owners_;
                  do
                    v1125 = __ldaxr(v1124);
                  while (__stlxr(v1125 - 1, v1124));
                  goto LABEL_1970;
                }
                goto LABEL_1972;
              }
LABEL_1923:
              if (v1089)
              {
                v1095 = (unint64_t *)&v1089->__shared_owners_;
                do
                  v1096 = __ldaxr(v1095);
                while (__stlxr(v1096 - 1, v1095));
                if (!v1096)
                {
                  ((void (*)(std::__shared_weak_count *))v1089->__on_zero_shared)(v1089);
                  std::__shared_weak_count::__release_weak(v1089);
                }
              }
              goto LABEL_1957;
            }
          }
          v1093 = 1608;
          goto LABEL_1921;
        }
        v791 = (unint64_t *)&v788->__shared_owners_;
        do
          v792 = __ldaxr(v791);
        while (__stlxr(v792 - 1, v791));
      }
      else
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v800 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(__p);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
          v801 = (std::__shared_weak_count *)__p[1];
          if (__p[1])
          {
            v802 = (unint64_t *)((char *)__p[1] + 8);
            do
              v803 = __ldaxr(v802);
            while (__stlxr(v803 - 1, v802));
            if (!v803)
            {
              ((void (*)(std::__shared_weak_count *))v801->__on_zero_shared)(v801);
              std::__shared_weak_count::__release_weak(v801);
            }
          }
          v800 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v788 = (std::__shared_weak_count *)off_2553234C8;
        value.__r_.__value_.__r.__words[0] = (std::string::size_type)v800;
        value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v804 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v805 = __ldxr(v804);
          while (__stxr(v805 + 1, v804));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v800, (SEUpdaterUtil::SELogObj *)1, 0, 1, "CheckAndInstallOasisApplet", (SEUpdaterUtil::SELogObj *)"Failed to get the ConfigID\n");
        if (!v788)
          goto LABEL_1433;
        v806 = (unint64_t *)&v788->__shared_owners_;
        do
          v792 = __ldaxr(v806);
        while (__stlxr(v792 - 1, v806));
      }
    }
    else
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v793 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        v794 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          v795 = (unint64_t *)((char *)__p[1] + 8);
          do
            v796 = __ldaxr(v795);
          while (__stlxr(v796 - 1, v795));
          if (!v796)
          {
            ((void (*)(std::__shared_weak_count *))v794->__on_zero_shared)(v794);
            std::__shared_weak_count::__release_weak(v794);
          }
        }
        v793 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v788 = (std::__shared_weak_count *)off_2553234C8;
      value.__r_.__value_.__r.__words[0] = (std::string::size_type)v793;
      value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v797 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v798 = __ldxr(v797);
        while (__stxr(v798 + 1, v797));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v793, (SEUpdaterUtil::SELogObj *)1, 0, 1, "CheckAndInstallOasisApplet", (SEUpdaterUtil::SELogObj *)"Failed to select Oasis\n");
      if (!v788)
        goto LABEL_1433;
      v799 = (unint64_t *)&v788->__shared_owners_;
      do
        v792 = __ldaxr(v799);
      while (__stlxr(v792 - 1, v799));
    }
    if (!v792)
    {
      ((void (*)(std::__shared_weak_count *))v788->__on_zero_shared)(v788);
      std::__shared_weak_count::__release_weak(v788);
    }
    goto LABEL_1433;
  }
LABEL_2090:
  v1195 = *((unsigned __int8 *)this + 8);
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v1783, 0x2037uLL);
  v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF828;
  strcpy((char *)&value, "\x80\xF0\x01\x01\x10O\x0EFACTORYTESTAPP");
  SERestoreInfo::CApdu::CApdu(__p, &value, 0x16uLL, 0);
  __p[0] = &off_24E0C0390;
  v1196 = *((_QWORD *)this + 20);
  SEUpdater::CommandSelectCRS::CommandSelectCRS((SEUpdater::CommandSelectCRS *)&value);
  v1197 = SEUpdater::P73BaseSEController::transceive(v1196, (uint64_t)&value, (uint64_t **)&v1783, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
  v1198 = (std::__shared_weak_count *)value.__r_.__value_.__r.__words[2];
  if (value.__r_.__value_.__r.__words[2])
  {
    v1199 = (unint64_t *)(value.__r_.__value_.__r.__words[2] + 8);
    do
      v1200 = __ldaxr(v1199);
    while (__stlxr(v1200 - 1, v1199));
    if (!v1200)
    {
      ((void (*)(std::__shared_weak_count *))v1198->__on_zero_shared)(v1198);
      std::__shared_weak_count::__release_weak(v1198);
    }
  }
  if (v1197
    || (v1201 = *(_QWORD *)(v1783.__r_.__value_.__l.__size_ + 8),
        (unint64_t)(v1201 - *(_QWORD *)v1783.__r_.__value_.__l.__size_) < 2)
    || (*(unsigned __int8 *)(v1201 - 1) | (*(unsigned __int8 *)(v1201 - 2) << 8)) != 0x9000)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1557 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&value);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&value);
      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&value);
      v1557 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v1557;
    v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v1558 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v1559 = __ldxr(v1558);
      while (__stxr(v1559 + 1, v1558));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1560 = *(_QWORD *)(v1783.__r_.__value_.__l.__size_ + 8);
    if ((unint64_t)(v1560 - *(_QWORD *)v1783.__r_.__value_.__l.__size_) < 2)
      v1561 = 43947;
    else
      v1561 = *(unsigned __int8 *)(v1560 - 1) | (*(unsigned __int8 *)(v1560 - 2) << 8);
    SEUpdaterUtil::SELogObj::printLog(v1557, 0, 0, 1, "setFTAActivationStatus", (SEUpdaterUtil::SELogObj *)"Failed to select CRS with ret %d SW: %x\n", v1197, v1561);
    goto LABEL_2813;
  }
  SERestoreInfo::Apdu::SetP2((uint64_t)__p, v1195);
  if (SEUpdater::P73BaseSEController::transceive(*((_QWORD *)this + 20), (uint64_t)__p, (uint64_t **)&v1783, 0, (SEUpdaterUtil::SELogObj *)3, 1)|| (v1202 = *(_QWORD *)(v1783.__r_.__value_.__l.__size_ + 8), (unint64_t)(v1202 - *(_QWORD *)v1783.__r_.__value_.__l.__size_) < 2)|| (*(unsigned __int8 *)(v1202 - 1) | (*(unsigned __int8 *)(v1202 - 2) << 8)) != 0x9000)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1562 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&value);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&value);
      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&value);
      v1562 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v1562;
    v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v1563 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v1564 = __ldxr(v1563);
      while (__stxr(v1564 + 1, v1563));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1565 = *(_QWORD *)(v1783.__r_.__value_.__l.__size_ + 8);
    if ((unint64_t)(v1565 - *(_QWORD *)v1783.__r_.__value_.__l.__size_) < 2)
      v1566 = 43947;
    else
      v1566 = *(unsigned __int8 *)(v1565 - 1) | (*(unsigned __int8 *)(v1565 - 2) << 8);
    SEUpdaterUtil::SELogObj::printLog(v1562, 0, 0, 1, "setFTAActivationStatus", (SEUpdaterUtil::SELogObj *)"Failed to set FTA activation with SW: %x\n", v1566);
LABEL_2813:
    std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v1782);
    goto LABEL_2116;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v1203 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&value);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&value);
    v1204 = (std::__shared_weak_count *)value.__r_.__value_.__l.__size_;
    if (value.__r_.__value_.__l.__size_)
    {
      v1205 = (unint64_t *)(value.__r_.__value_.__l.__size_ + 8);
      do
        v1206 = __ldaxr(v1205);
      while (__stlxr(v1206 - 1, v1205));
      if (!v1206)
      {
        ((void (*)(std::__shared_weak_count *))v1204->__on_zero_shared)(v1204);
        std::__shared_weak_count::__release_weak(v1204);
      }
    }
    v1203 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v1207 = (std::__shared_weak_count *)off_2553234C8;
  v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v1203;
  v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v1208 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v1209 = __ldxr(v1208);
    while (__stxr(v1209 + 1, v1208));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v1203, (SEUpdaterUtil::SELogObj *)2, 0, 1, "setFTAActivationStatus", (SEUpdaterUtil::SELogObj *)"Successfully set FTA Activation Status to %d\n", v1195);
  if (v1207)
  {
    v1210 = (unint64_t *)&v1207->__shared_owners_;
    do
      v1211 = __ldaxr(v1210);
    while (__stlxr(v1211 - 1, v1210));
    if (!v1211)
    {
      ((void (*)(std::__shared_weak_count *))v1207->__on_zero_shared)(v1207);
      std::__shared_weak_count::__release_weak(v1207);
    }
  }
LABEL_2116:
  __p[0] = &unk_24E0BF880;
  v1212 = (std::__shared_weak_count *)v1758;
  if ((_QWORD)v1758)
  {
    v1213 = (unint64_t *)(v1758 + 8);
    do
      v1214 = __ldaxr(v1213);
    while (__stlxr(v1214 - 1, v1213));
    if (!v1214)
    {
      ((void (*)(std::__shared_weak_count *))v1212->__on_zero_shared)(v1212);
      std::__shared_weak_count::__release_weak(v1212);
    }
  }
  v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
  v1215 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
  if (v1783.__r_.__value_.__r.__words[2])
  {
    v1216 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
    do
      v1217 = __ldaxr(v1216);
    while (__stlxr(v1217 - 1, v1216));
    if (!v1217)
    {
      ((void (*)(std::__shared_weak_count *))v1215->__on_zero_shared)(v1215);
      std::__shared_weak_count::__release_weak(v1215);
    }
  }
  v1218 = *v653;
  v1219 = *((_DWORD *)*v653 + 14);
  if (v1219 == 44)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1220 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v1221 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v1222 = (unint64_t *)((char *)__p[1] + 8);
        do
          v1223 = __ldaxr(v1222);
        while (__stlxr(v1223 - 1, v1222));
        if (!v1223)
        {
          ((void (*)(std::__shared_weak_count *))v1221->__on_zero_shared)(v1221);
          std::__shared_weak_count::__release_weak(v1221);
        }
      }
      v1220 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v1224 = (std::__shared_weak_count *)off_2553234C8;
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1220;
    value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v1225 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v1226 = __ldxr(v1225);
      while (__stxr(v1226 + 1, v1225));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v1220, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doPerform", (SEUpdaterUtil::SELogObj *)"Sending GET DATA OBKG\n");
    if (v1224)
    {
      v1227 = (unint64_t *)&v1224->__shared_owners_;
      do
        v1228 = __ldaxr(v1227);
      while (__stlxr(v1228 - 1, v1227));
      if (!v1228)
      {
        ((void (*)(std::__shared_weak_count *))v1224->__on_zero_shared)(v1224);
        std::__shared_weak_count::__release_weak(v1224);
      }
    }
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&value, 0x2037uLL);
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF828;
    v1229 = *((_QWORD *)this + 20);
    SEUpdater::CommandSelectISD::CommandSelectISD((SEUpdater::CommandSelectISD *)__p);
    SEUpdater::P73BaseSEController::transceive(v1229, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)2, 1);
    __p[0] = &unk_24E0BF880;
    v1230 = (std::__shared_weak_count *)v1758;
    if ((_QWORD)v1758)
    {
      v1231 = (unint64_t *)(v1758 + 8);
      do
        v1232 = __ldaxr(v1231);
      while (__stlxr(v1232 - 1, v1231));
      if (!v1232)
      {
        ((void (*)(std::__shared_weak_count *))v1230->__on_zero_shared)(v1230);
        std::__shared_weak_count::__release_weak(v1230);
      }
    }
    v1233 = *((_QWORD *)this + 20);
    LODWORD(v1783.__r_.__value_.__l.__data_) = -33502592;
    WORD2(v1783.__r_.__value_.__r.__words[0]) = -8446;
    v1783.__r_.__value_.__s.__data_[6] = 48;
    SERestoreInfo::CApdu::CApdu(__p, &v1783, 7uLL, 0);
    __p[0] = &off_24E0C05D0;
    SEUpdater::P73BaseSEController::transceive(v1233, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)2, 1);
    __p[0] = &unk_24E0BF880;
    v1234 = (std::__shared_weak_count *)v1758;
    if ((_QWORD)v1758)
    {
      v1235 = (unint64_t *)(v1758 + 8);
      do
        v1236 = __ldaxr(v1235);
      while (__stlxr(v1236 - 1, v1235));
      if (!v1236)
      {
        ((void (*)(std::__shared_weak_count *))v1234->__on_zero_shared)(v1234);
        std::__shared_weak_count::__release_weak(v1234);
      }
    }
    v1237 = *((_QWORD *)this + 20);
    *(_OWORD *)&v1783.__r_.__value_.__l.__data_ = xmmword_21CCD8DA0;
    LOWORD(v1783.__r_.__value_.__r.__words[2]) = 76;
    SERestoreInfo::CApdu::CApdu(__p, &v1783, 0x12uLL, 0);
    __p[0] = &off_24E0C0618;
    SEUpdater::P73BaseSEController::transceive(v1237, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)2, 1);
    __p[0] = &unk_24E0BF880;
    v1238 = (std::__shared_weak_count *)v1758;
    if ((_QWORD)v1758)
    {
      v1239 = (unint64_t *)(v1758 + 8);
      do
        v1240 = __ldaxr(v1239);
      while (__stlxr(v1240 - 1, v1239));
      if (!v1240)
      {
        ((void (*)(std::__shared_weak_count *))v1238->__on_zero_shared)(v1238);
        std::__shared_weak_count::__release_weak(v1238);
      }
    }
    v1241 = *((_QWORD *)this + 20);
    LODWORD(v1783.__r_.__value_.__l.__data_) = -33502592;
    WORD2(v1783.__r_.__value_.__r.__words[0]) = -8446;
    v1783.__r_.__value_.__s.__data_[6] = 48;
    SERestoreInfo::CApdu::CApdu(__p, &v1783, 7uLL, 0);
    __p[0] = &off_24E0C05D0;
    SEUpdater::P73BaseSEController::transceive(v1241, (uint64_t)__p, (uint64_t **)&value, 0, (SEUpdaterUtil::SELogObj *)2, 1);
    __p[0] = &unk_24E0BF880;
    v1242 = (std::__shared_weak_count *)v1758;
    if ((_QWORD)v1758)
    {
      v1243 = (unint64_t *)(v1758 + 8);
      do
        v1244 = __ldaxr(v1243);
      while (__stlxr(v1244 - 1, v1243));
      if (!v1244)
      {
        ((void (*)(std::__shared_weak_count *))v1242->__on_zero_shared)(v1242);
        std::__shared_weak_count::__release_weak(v1242);
      }
    }
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
    v1245 = (std::__shared_weak_count *)value.__r_.__value_.__r.__words[2];
    if (value.__r_.__value_.__r.__words[2])
    {
      v1246 = (unint64_t *)(value.__r_.__value_.__r.__words[2] + 8);
      do
        v1247 = __ldaxr(v1246);
      while (__stlxr(v1247 - 1, v1246));
      if (!v1247)
      {
        ((void (*)(std::__shared_weak_count *))v1245->__on_zero_shared)(v1245);
        std::__shared_weak_count::__release_weak(v1245);
      }
    }
    v1218 = *v653;
    v1219 = *((_DWORD *)*v653 + 14);
  }
  if (v1219 != 54 && (v1219 != 44 || *((_DWORD *)v1218 + 3) < 0x1B6u))
    goto LABEL_2280;
  if (SERestoreInfo::P73BaseDeviceInfo::isProdEval(v1218))
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1248 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v1249 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v1250 = (unint64_t *)((char *)__p[1] + 8);
        do
          v1251 = __ldaxr(v1250);
        while (__stlxr(v1251 - 1, v1250));
        if (!v1251)
        {
          ((void (*)(std::__shared_weak_count *))v1249->__on_zero_shared)(v1249);
          std::__shared_weak_count::__release_weak(v1249);
        }
      }
      v1248 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v1252 = (std::__shared_weak_count *)off_2553234C8;
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1248;
    value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v1253 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v1254 = __ldxr(v1253);
      while (__stxr(v1254 + 1, v1253));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v1248, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureSIMDetectGPIO", (SEUpdaterUtil::SELogObj *)"Not configuring SIM_DETECT GPIO due to PROD_EVAL\n");
    if (v1252)
    {
      v1255 = (unint64_t *)&v1252->__shared_owners_;
      do
        v1256 = __ldaxr(v1255);
      while (__stlxr(v1256 - 1, v1255));
LABEL_2277:
      if (v1256)
        goto LABEL_2280;
      ((void (*)(std::__shared_weak_count *))v1252->__on_zero_shared)(v1252);
      v1283 = v1252;
      goto LABEL_2279;
    }
    goto LABEL_2280;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "simDetectWPD");
  v1257 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v1723, (const void **)__p);
  if (SBYTE7(v1758) < 0)
    operator delete(__p[0]);
  if (v1257)
  {
    shouldEnableEUICCDetectPullDown = 1;
    goto LABEL_2197;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "simDetectHIZ");
  v1259 = (capabilities::euicc *)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v1723, (const void **)__p);
  if (v1259)
  {
    if (SBYTE7(v1758) < 0)
      operator delete(__p[0]);
LABEL_2196:
    shouldEnableEUICCDetectPullDown = 0;
    goto LABEL_2197;
  }
  v1260 = *((_DWORD *)*v653 + 14);
  if (SBYTE7(v1758) < 0)
    operator delete(__p[0]);
  if (v1260 == 54)
    goto LABEL_2196;
  shouldEnableEUICCDetectPullDown = capabilities::euicc::shouldEnableEUICCDetectPullDown(v1259);
LABEL_2197:
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v1261 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v1262 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v1263 = (unint64_t *)((char *)__p[1] + 8);
      do
        v1264 = __ldaxr(v1263);
      while (__stlxr(v1264 - 1, v1263));
      if (!v1264)
      {
        ((void (*)(std::__shared_weak_count *))v1262->__on_zero_shared)(v1262);
        std::__shared_weak_count::__release_weak(v1262);
      }
    }
    v1261 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v1265 = (std::__shared_weak_count *)off_2553234C8;
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1261;
  value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v1266 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v1267 = __ldxr(v1266);
    while (__stxr(v1267 + 1, v1266));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  if (shouldEnableEUICCDetectPullDown)
    v1268 = "WPD";
  else
    v1268 = "HiZ";
  SEUpdaterUtil::SELogObj::printLog(v1261, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureSIMDetectGPIO", (SEUpdaterUtil::SELogObj *)"Configuring SIM_DETECT GPIO with %s\n", v1268);
  if (v1265)
  {
    v1269 = (unint64_t *)&v1265->__shared_owners_;
    do
      v1270 = __ldaxr(v1269);
    while (__stlxr(v1270 - 1, v1269));
    if (!v1270)
    {
      ((void (*)(std::__shared_weak_count *))v1265->__on_zero_shared)(v1265);
      std::__shared_weak_count::__release_weak(v1265);
    }
  }
  if (shouldEnableEUICCDetectPullDown == SEUpdater::P73BaseUpdateController::isSIMDetectGPIOConfiguredWithWPD((SERestoreInfo::P73BaseDeviceInfo **)this))
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1274 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v1275 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v1276 = (unint64_t *)((char *)__p[1] + 8);
        do
          v1277 = __ldaxr(v1276);
        while (__stlxr(v1277 - 1, v1276));
        if (!v1277)
        {
          ((void (*)(std::__shared_weak_count *))v1275->__on_zero_shared)(v1275);
          std::__shared_weak_count::__release_weak(v1275);
        }
      }
      v1274 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v1278 = (std::__shared_weak_count *)off_2553234C8;
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1274;
    value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v1279 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v1280 = __ldxr(v1279);
      while (__stxr(v1280 + 1, v1279));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v1274, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureSIMDetectGPIO", (SEUpdaterUtil::SELogObj *)"SIM_DETECT GPIO already configured with %s\n", v1268);
    if (v1278)
    {
      v1281 = (unint64_t *)&v1278->__shared_owners_;
      do
        v1282 = __ldaxr(v1281);
      while (__stlxr(v1282 - 1, v1281));
      if (!v1282)
      {
        ((void (*)(std::__shared_weak_count *))v1278->__on_zero_shared)(v1278);
        v1283 = v1278;
LABEL_2279:
        std::__shared_weak_count::__release_weak(v1283);
        goto LABEL_2280;
      }
    }
    goto LABEL_2280;
  }
  SERestoreInfo::CApdu::CApdu((SERestoreInfo::CApdu *)&value);
  if (SERestoreInfo::P73BaseDeviceInfo::isDev(*v653))
  {
    if (shouldEnableEUICCDetectPullDown)
    {
      v1761[0] = xmmword_21CCD92F1;
      v1761[1] = unk_21CCD9301;
      v1761[2] = xmmword_21CCD9311;
      *(_OWORD *)__p = xmmword_21CCD92B1;
      v1758 = unk_21CCD92C1;
      v1759 = xmmword_21CCD92D1;
      v1760 = unk_21CCD92E1;
      LOWORD(v1761[3]) = 20301;
      SERestoreInfo::CApdu::CApdu(&v1783, __p, 0x72uLL, 0);
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0A50;
      std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
      *(_OWORD *)v1787 = v1784;
      *(_OWORD *)&v1787[16] = v1785;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
      v1271 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
      if (!v1783.__r_.__value_.__r.__words[2])
        goto LABEL_2251;
      v1272 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
      do
        v1273 = __ldaxr(v1272);
      while (__stlxr(v1273 - 1, v1272));
    }
    else
    {
      v1761[0] = xmmword_21CCD9396;
      v1761[1] = unk_21CCD93A6;
      v1761[2] = xmmword_21CCD93B6;
      *(_OWORD *)__p = xmmword_21CCD9356;
      v1758 = unk_21CCD9366;
      v1759 = xmmword_21CCD9376;
      v1760 = unk_21CCD9386;
      LOWORD(v1761[3]) = -21026;
      SERestoreInfo::CApdu::CApdu(&v1783, __p, 0x72uLL, 0);
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0A98;
      std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
      *(_OWORD *)v1787 = v1784;
      *(_OWORD *)&v1787[16] = v1785;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
      v1271 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
      if (!v1783.__r_.__value_.__r.__words[2])
        goto LABEL_2251;
      v1285 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
      do
        v1273 = __ldaxr(v1285);
      while (__stlxr(v1273 - 1, v1285));
    }
  }
  else if (shouldEnableEUICCDetectPullDown)
  {
    v1761[0] = xmmword_21CCD91A5;
    v1761[1] = unk_21CCD91B5;
    v1761[2] = xmmword_21CCD91C5;
    *(_OWORD *)__p = xmmword_21CCD9165;
    v1758 = unk_21CCD9175;
    v1759 = xmmword_21CCD9185;
    v1760 = unk_21CCD9195;
    LOWORD(v1761[3]) = -23314;
    SERestoreInfo::CApdu::CApdu(&v1783, __p, 0x72uLL, 0);
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C09C0;
    std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
    *(_OWORD *)v1787 = v1784;
    *(_OWORD *)&v1787[16] = v1785;
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
    v1271 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
    if (!v1783.__r_.__value_.__r.__words[2])
      goto LABEL_2251;
    v1284 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
    do
      v1273 = __ldaxr(v1284);
    while (__stlxr(v1273 - 1, v1284));
  }
  else
  {
    v1761[0] = xmmword_21CCD924B;
    v1761[1] = unk_21CCD925B;
    v1761[2] = xmmword_21CCD926B;
    *(_OWORD *)__p = xmmword_21CCD920B;
    v1758 = unk_21CCD921B;
    v1759 = xmmword_21CCD922B;
    v1760 = unk_21CCD923B;
    LOWORD(v1761[3]) = 2748;
    SERestoreInfo::CApdu::CApdu(&v1783, __p, 0x72uLL, 0);
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0A08;
    std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
    *(_OWORD *)v1787 = v1784;
    *(_OWORD *)&v1787[16] = v1785;
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
    v1271 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
    if (!v1783.__r_.__value_.__r.__words[2])
      goto LABEL_2251;
    v1286 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
    do
      v1273 = __ldaxr(v1286);
    while (__stlxr(v1273 - 1, v1286));
  }
  if (!v1273)
  {
    ((void (*)(std::__shared_weak_count *))v1271->__on_zero_shared)(v1271);
    std::__shared_weak_count::__release_weak(v1271);
  }
LABEL_2251:
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)__p, 0x2037uLL);
  __p[0] = &unk_24E0BF828;
  (*(void (**)(_QWORD, std::string *, void **, uint64_t, uint64_t))(**((_QWORD **)this + 20) + 16))(*((_QWORD *)this + 20), &value, __p, 3, 1);
  v1287 = *((_QWORD *)__p[1] + 1);
  if ((unint64_t)(v1287 - *(_QWORD *)__p[1]) < 2
    || (*(unsigned __int8 *)(v1287 - 1) | (*(unsigned __int8 *)(v1287 - 2) << 8)) != 0x9000)
  {
    v1663 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v1783, "Failed to configure SIM_DETECT GPIO");
    v1664 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1663, (__int128 *)&v1783, 31, CFSTR("SEUpdaterErrorDomain"));
  }
  if (shouldEnableEUICCDetectPullDown != SEUpdater::P73BaseUpdateController::isSIMDetectGPIOConfiguredWithWPD((SERestoreInfo::P73BaseDeviceInfo **)this))
  {
    v1695 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v1783, "Failed to verify the configuration for SIM_DETECT GPIO");
    v1696 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1695, (__int128 *)&v1783, 31, CFSTR("SEUpdaterErrorDomain"));
  }
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 20) + 48))(*((_QWORD *)this + 20), 0);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v1288 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v1783);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
    v1289 = (std::__shared_weak_count *)v1783.__r_.__value_.__l.__size_;
    if (v1783.__r_.__value_.__l.__size_)
    {
      v1290 = (unint64_t *)(v1783.__r_.__value_.__l.__size_ + 8);
      do
        v1291 = __ldaxr(v1290);
      while (__stlxr(v1291 - 1, v1290));
      if (!v1291)
      {
        ((void (*)(std::__shared_weak_count *))v1289->__on_zero_shared)(v1289);
        std::__shared_weak_count::__release_weak(v1289);
      }
    }
    v1288 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v1292 = (std::__shared_weak_count *)off_2553234C8;
  v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v1288;
  v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v1293 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v1294 = __ldxr(v1293);
    while (__stxr(v1294 + 1, v1293));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v1288, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureSIMDetectGPIO", (SEUpdaterUtil::SELogObj *)"SIM_DETECT GPIO configured with %s\n", v1268);
  if (v1292)
  {
    v1295 = (unint64_t *)&v1292->__shared_owners_;
    do
      v1296 = __ldaxr(v1295);
    while (__stlxr(v1296 - 1, v1295));
    if (!v1296)
    {
      ((void (*)(std::__shared_weak_count *))v1292->__on_zero_shared)(v1292);
      std::__shared_weak_count::__release_weak(v1292);
    }
  }
  __p[0] = &unk_24E0BF880;
  v1297 = (std::__shared_weak_count *)v1758;
  if ((_QWORD)v1758)
  {
    v1298 = (unint64_t *)(v1758 + 8);
    do
      v1299 = __ldaxr(v1298);
    while (__stlxr(v1299 - 1, v1298));
    if (!v1299)
    {
      ((void (*)(std::__shared_weak_count *))v1297->__on_zero_shared)(v1297);
      std::__shared_weak_count::__release_weak(v1297);
    }
  }
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
  v1252 = (std::__shared_weak_count *)value.__r_.__value_.__r.__words[2];
  if (value.__r_.__value_.__r.__words[2])
  {
    v1300 = (unint64_t *)(value.__r_.__value_.__r.__words[2] + 8);
    do
      v1256 = __ldaxr(v1300);
    while (__stlxr(v1256 - 1, v1300));
    goto LABEL_2277;
  }
LABEL_2280:
  if (*((_DWORD *)*v653 + 14) != 54)
    goto LABEL_2455;
  isProdEval = SERestoreInfo::P73BaseDeviceInfo::isProdEval(*v653);
  if (!isProdEval)
  {
    if ((capabilities::euicc::shouldEnableEUICCDetectPullDown((capabilities::euicc *)isProdEval) & 1) == 0)
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v1314 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        v1315 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          v1316 = (unint64_t *)((char *)__p[1] + 8);
          do
            v1317 = __ldaxr(v1316);
          while (__stlxr(v1317 - 1, v1316));
          if (!v1317)
          {
            ((void (*)(std::__shared_weak_count *))v1315->__on_zero_shared)(v1315);
            std::__shared_weak_count::__release_weak(v1315);
          }
        }
        v1314 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v1306 = (std::__shared_weak_count *)off_2553234C8;
      value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1314;
      value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v1318 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v1319 = __ldxr(v1318);
        while (__stxr(v1319 + 1, v1318));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v1314, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureEOSMemoryReserve", (SEUpdaterUtil::SELogObj *)"SIM_DETECT GPIO configured with HiZ, skipping memory reconfiguration\n");
      if (!v1306)
        goto LABEL_2455;
      v1320 = (unint64_t *)&v1306->__shared_owners_;
      do
        v1310 = __ldaxr(v1320);
      while (__stlxr(v1310 - 1, v1320));
LABEL_2453:
      if (!v1310)
      {
        ((void (*)(std::__shared_weak_count *))v1306->__on_zero_shared)(v1306);
        std::__shared_weak_count::__release_weak(v1306);
      }
      goto LABEL_2455;
    }
    SERestoreInfo::CApdu::CApdu((SERestoreInfo::CApdu *)&value);
    if (SERestoreInfo::P73BaseDeviceInfo::isDev(*v653))
    {
      if (SERestoreInfo::P73BaseDeviceInfo::isProdEval(*v653))
      {
        v1761[0] = xmmword_21CCD94E6;
        v1761[1] = unk_21CCD94F6;
        *(_OWORD *)((char *)&v1761[1] + 15) = unk_21CCD9505;
        *(_OWORD *)__p = xmmword_21CCD94A6;
        v1758 = unk_21CCD94B6;
        v1759 = xmmword_21CCD94C6;
        v1760 = unk_21CCD94D6;
        SERestoreInfo::CApdu::CApdu(&v1783, __p, 0x6FuLL, 0);
        v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0B28;
        std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
        *(_OWORD *)v1787 = v1784;
        *(_OWORD *)&v1787[16] = v1785;
        v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
        v1311 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
        if (!v1783.__r_.__value_.__r.__words[2])
          goto LABEL_2326;
        v1312 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
        do
          v1313 = __ldaxr(v1312);
        while (__stlxr(v1313 - 1, v1312));
      }
      else
      {
        v1761[0] = xmmword_21CCD9595;
        v1761[1] = unk_21CCD95A5;
        *(_OWORD *)((char *)&v1761[1] + 15) = unk_21CCD95B4;
        *(_OWORD *)__p = xmmword_21CCD9555;
        v1758 = unk_21CCD9565;
        v1759 = xmmword_21CCD9575;
        v1760 = unk_21CCD9585;
        SERestoreInfo::CApdu::CApdu(&v1783, __p, 0x6FuLL, 0);
        v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0B70;
        std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
        *(_OWORD *)v1787 = v1784;
        *(_OWORD *)&v1787[16] = v1785;
        v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
        v1311 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
        if (!v1783.__r_.__value_.__r.__words[2])
          goto LABEL_2326;
        v1322 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
        do
          v1313 = __ldaxr(v1322);
        while (__stlxr(v1313 - 1, v1322));
      }
    }
    else
    {
      v1761[0] = xmmword_21CCD943B;
      v1761[1] = unk_21CCD944B;
      *(_OWORD *)((char *)&v1761[1] + 15) = unk_21CCD945A;
      *(_OWORD *)__p = xmmword_21CCD93FB;
      v1758 = unk_21CCD940B;
      v1759 = xmmword_21CCD941B;
      v1760 = unk_21CCD942B;
      SERestoreInfo::CApdu::CApdu(&v1783, __p, 0x6FuLL, 0);
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0AE0;
      std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
      *(_OWORD *)v1787 = v1784;
      *(_OWORD *)&v1787[16] = v1785;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
      v1311 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
      if (!v1783.__r_.__value_.__r.__words[2])
        goto LABEL_2326;
      v1321 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
      do
        v1313 = __ldaxr(v1321);
      while (__stlxr(v1313 - 1, v1321));
    }
    if (!v1313)
    {
      ((void (*)(std::__shared_weak_count *))v1311->__on_zero_shared)(v1311);
      std::__shared_weak_count::__release_weak(v1311);
    }
LABEL_2326:
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)__p, 0x2037uLL);
    __p[0] = &unk_24E0BF828;
    (*(void (**)(_QWORD, std::string *, void **, uint64_t, uint64_t))(**((_QWORD **)this + 20) + 16))(*((_QWORD *)this + 20), &value, __p, 3, 1);
    v1324 = *(unsigned __int8 **)__p[1];
    v1323 = *((_QWORD *)__p[1] + 1);
    v1325 = v1323 - *(_QWORD *)__p[1];
    v1326 = v1325 - 2;
    if (v1325 < 2 || (*(unsigned __int8 *)(v1323 - 1) | (v1324[v1326] << 8)) != 0x9000)
    {
      v1661 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v1783, "Failed to query Memory configuration");
      v1662 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1661, (__int128 *)&v1783, 31, CFSTR("SEUpdaterErrorDomain"));
    }
    if (v1326 <= 0x43)
    {
      v1691 = __cxa_allocate_exception(0x48uLL);
      DataSize = SERestoreInfo::RApdu::getDataSize((SERestoreInfo::RApdu *)__p);
      std::to_string(&v1782, DataSize);
      v1693 = std::string::insert(&v1782, 0, "Wrong size for Get Reserved Memory Config item  query ");
      v1783 = *v1693;
      v1693->__r_.__value_.__l.__size_ = 0;
      v1693->__r_.__value_.__r.__words[2] = 0;
      v1693->__r_.__value_.__r.__words[0] = 0;
      v1694 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1691, (__int128 *)&v1783, 31, CFSTR("SEUpdaterErrorDomain"));
    }
    v1327 = (char *)operator new(0x46uLL);
    v1328 = v1327;
    *((_OWORD *)v1327 + 2) = xmmword_21CCD8AC0;
    *((_OWORD *)v1327 + 3) = unk_21CCD8AD0;
    *(_QWORD *)(v1327 + 62) = 0x90000000000000;
    *(_OWORD *)v1327 = xmmword_21CCD8AA0;
    *((_OWORD *)v1327 + 1) = unk_21CCD8AB0;
    v1329 = v1325 == 70 && memcmp(v1327, v1324, 0x46uLL) == 0;
    operator delete(v1328);
    __p[0] = &unk_24E0BF880;
    v1330 = (std::__shared_weak_count *)v1758;
    if ((_QWORD)v1758)
    {
      v1331 = (unint64_t *)(v1758 + 8);
      do
        v1332 = __ldaxr(v1331);
      while (__stlxr(v1332 - 1, v1331));
      if (!v1332)
      {
        ((void (*)(std::__shared_weak_count *))v1330->__on_zero_shared)(v1330);
        std::__shared_weak_count::__release_weak(v1330);
      }
    }
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
    v1333 = (std::__shared_weak_count *)value.__r_.__value_.__r.__words[2];
    if (value.__r_.__value_.__r.__words[2])
    {
      v1334 = (unint64_t *)(value.__r_.__value_.__r.__words[2] + 8);
      do
        v1335 = __ldaxr(v1334);
      while (__stlxr(v1335 - 1, v1334));
      if (!v1335)
      {
        ((void (*)(std::__shared_weak_count *))v1333->__on_zero_shared)(v1333);
        std::__shared_weak_count::__release_weak(v1333);
      }
    }
    if (v1329)
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v1336 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        v1337 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          v1338 = (unint64_t *)((char *)__p[1] + 8);
          do
            v1339 = __ldaxr(v1338);
          while (__stlxr(v1339 - 1, v1338));
          if (!v1339)
          {
            ((void (*)(std::__shared_weak_count *))v1337->__on_zero_shared)(v1337);
            std::__shared_weak_count::__release_weak(v1337);
          }
        }
        v1336 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v1306 = (std::__shared_weak_count *)off_2553234C8;
      value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1336;
      value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v1340 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v1341 = __ldxr(v1340);
        while (__stxr(v1341 + 1, v1340));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v1336, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureEOSMemoryReserve", (SEUpdaterUtil::SELogObj *)"Memory already reconfigured, skipping memory reconfiguration\n");
      if (!v1306)
        goto LABEL_2455;
      v1342 = (unint64_t *)&v1306->__shared_owners_;
      do
        v1310 = __ldaxr(v1342);
      while (__stlxr(v1310 - 1, v1342));
      goto LABEL_2453;
    }
    SERestoreInfo::CApdu::CApdu((SERestoreInfo::CApdu *)&value);
    if (SERestoreInfo::P73BaseDeviceInfo::isDev(*v653))
    {
      if (SERestoreInfo::P73BaseDeviceInfo::isProdEval(*v653))
      {
        v1762 = xmmword_21CCD976C;
        v1763 = unk_21CCD977C;
        v1764 = xmmword_21CCD978C;
        v1761[0] = xmmword_21CCD972C;
        v1761[1] = unk_21CCD973C;
        v1761[2] = xmmword_21CCD974C;
        v1761[3] = unk_21CCD975C;
        *(_OWORD *)__p = xmmword_21CCD96EC;
        v1758 = unk_21CCD96FC;
        v1759 = xmmword_21CCD970C;
        v1760 = unk_21CCD971C;
        LOBYTE(v1765) = -73;
        SERestoreInfo::CApdu::CApdu(&v1783, __p, 0xB1uLL, 0);
        v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0C00;
        std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
        *(_OWORD *)v1787 = v1784;
        *(_OWORD *)&v1787[16] = v1785;
        v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
        v1343 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
        if (v1783.__r_.__value_.__r.__words[2])
        {
          v1344 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
          do
            v1345 = __ldaxr(v1344);
          while (__stlxr(v1345 - 1, v1344));
          goto LABEL_2426;
        }
LABEL_2428:
        SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)__p, 0x2037uLL);
        __p[0] = &unk_24E0BF828;
        (*(void (**)(_QWORD, std::string *, void **, uint64_t, uint64_t))(**((_QWORD **)this + 20) + 16))(*((_QWORD *)this + 20), &value, __p, 3, 1);
        v1375 = *((_QWORD *)__p[1] + 1);
        if ((unint64_t)(v1375 - *(_QWORD *)__p[1]) < 2
          || (*(unsigned __int8 *)(v1375 - 1) | (*(unsigned __int8 *)(v1375 - 2) << 8)) != 0x9000)
        {
          v1697 = __cxa_allocate_exception(0x48uLL);
          std::string::basic_string[abi:ne180100]<0>(&v1783, "Failed to reconfigure eSE/eUICC Memory Reserve");
          v1698 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1697, (__int128 *)&v1783, 31, CFSTR("SEUpdaterErrorDomain"));
        }
        (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 20) + 48))(*((_QWORD *)this + 20), 0);
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v1376 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v1783);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v1783);
          v1377 = (std::__shared_weak_count *)v1783.__r_.__value_.__l.__size_;
          if (v1783.__r_.__value_.__l.__size_)
          {
            v1378 = (unint64_t *)(v1783.__r_.__value_.__l.__size_ + 8);
            do
              v1379 = __ldaxr(v1378);
            while (__stlxr(v1379 - 1, v1378));
            if (!v1379)
            {
              ((void (*)(std::__shared_weak_count *))v1377->__on_zero_shared)(v1377);
              std::__shared_weak_count::__release_weak(v1377);
            }
          }
          v1376 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v1380 = (std::__shared_weak_count *)off_2553234C8;
        v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)v1376;
        v1782.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v1381 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v1382 = __ldxr(v1381);
          while (__stxr(v1382 + 1, v1381));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v1376, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureEOSMemoryReserve", (SEUpdaterUtil::SELogObj *)"eSE/eUICC Memory Reserve configured successfully\n");
        if (v1380)
        {
          v1383 = (unint64_t *)&v1380->__shared_owners_;
          do
            v1384 = __ldaxr(v1383);
          while (__stlxr(v1384 - 1, v1383));
          if (!v1384)
          {
            ((void (*)(std::__shared_weak_count *))v1380->__on_zero_shared)(v1380);
            std::__shared_weak_count::__release_weak(v1380);
          }
        }
        __p[0] = &unk_24E0BF880;
        v1385 = (std::__shared_weak_count *)v1758;
        if ((_QWORD)v1758)
        {
          v1386 = (unint64_t *)(v1758 + 8);
          do
            v1387 = __ldaxr(v1386);
          while (__stlxr(v1387 - 1, v1386));
          if (!v1387)
          {
            ((void (*)(std::__shared_weak_count *))v1385->__on_zero_shared)(v1385);
            std::__shared_weak_count::__release_weak(v1385);
          }
        }
        value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
        v1306 = (std::__shared_weak_count *)value.__r_.__value_.__r.__words[2];
        if (!value.__r_.__value_.__r.__words[2])
          goto LABEL_2455;
        v1388 = (unint64_t *)(value.__r_.__value_.__r.__words[2] + 8);
        do
          v1310 = __ldaxr(v1388);
        while (__stlxr(v1310 - 1, v1388));
        goto LABEL_2453;
      }
      v1762 = xmmword_21CCD985D;
      v1763 = unk_21CCD986D;
      v1764 = xmmword_21CCD987D;
      v1761[0] = xmmword_21CCD981D;
      v1761[1] = unk_21CCD982D;
      v1761[2] = xmmword_21CCD983D;
      v1761[3] = unk_21CCD984D;
      *(_OWORD *)__p = xmmword_21CCD97DD;
      v1758 = unk_21CCD97ED;
      v1759 = xmmword_21CCD97FD;
      v1760 = unk_21CCD980D;
      LOBYTE(v1765) = -107;
      SERestoreInfo::CApdu::CApdu(&v1783, __p, 0xB1uLL, 0);
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0C48;
      std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
      *(_OWORD *)v1787 = v1784;
      *(_OWORD *)&v1787[16] = v1785;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
      v1343 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
      if (!v1783.__r_.__value_.__r.__words[2])
        goto LABEL_2428;
      v1374 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
      do
        v1345 = __ldaxr(v1374);
      while (__stlxr(v1345 - 1, v1374));
    }
    else
    {
      v1762 = xmmword_21CCD967F;
      v1763 = unk_21CCD968F;
      v1764 = xmmword_21CCD969F;
      v1761[0] = xmmword_21CCD963F;
      v1761[1] = unk_21CCD964F;
      v1761[2] = xmmword_21CCD965F;
      v1761[3] = unk_21CCD966F;
      *(_OWORD *)__p = xmmword_21CCD95FF;
      v1758 = unk_21CCD960F;
      v1759 = xmmword_21CCD961F;
      v1760 = unk_21CCD962F;
      LOBYTE(v1765) = 22;
      SERestoreInfo::CApdu::CApdu(&v1783, __p, 0xB1uLL, 0);
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0BB8;
      std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
      *(_OWORD *)v1787 = v1784;
      *(_OWORD *)&v1787[16] = v1785;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
      v1343 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
      if (!v1783.__r_.__value_.__r.__words[2])
        goto LABEL_2428;
      v1346 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
      do
        v1345 = __ldaxr(v1346);
      while (__stlxr(v1345 - 1, v1346));
    }
LABEL_2426:
    if (!v1345)
    {
      ((void (*)(std::__shared_weak_count *))v1343->__on_zero_shared)(v1343);
      std::__shared_weak_count::__release_weak(v1343);
    }
    goto LABEL_2428;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v1302 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v1303 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v1304 = (unint64_t *)((char *)__p[1] + 8);
      do
        v1305 = __ldaxr(v1304);
      while (__stlxr(v1305 - 1, v1304));
      if (!v1305)
      {
        ((void (*)(std::__shared_weak_count *))v1303->__on_zero_shared)(v1303);
        std::__shared_weak_count::__release_weak(v1303);
      }
    }
    v1302 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v1306 = (std::__shared_weak_count *)off_2553234C8;
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1302;
  value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v1307 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v1308 = __ldxr(v1307);
    while (__stxr(v1308 + 1, v1307));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v1302, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureEOSMemoryReserve", (SEUpdaterUtil::SELogObj *)"Not reconfiguring eSE/eUICC Memory Reserve due to PROD_EVAL, default will be used\n");
  if (v1306)
  {
    v1309 = (unint64_t *)&v1306->__shared_owners_;
    do
      v1310 = __ldaxr(v1309);
    while (__stlxr(v1310 - 1, v1309));
    goto LABEL_2453;
  }
LABEL_2455:
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v1389 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v1390 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v1391 = (unint64_t *)((char *)__p[1] + 8);
      do
        v1392 = __ldaxr(v1391);
      while (__stlxr(v1392 - 1, v1391));
      if (!v1392)
      {
        ((void (*)(std::__shared_weak_count *))v1390->__on_zero_shared)(v1390);
        std::__shared_weak_count::__release_weak(v1390);
      }
    }
    v1389 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v1393 = (std::__shared_weak_count *)off_2553234C8;
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1389;
  value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v1394 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v1395 = __ldxr(v1394);
    while (__stxr(v1395 + 1, v1394));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v1389, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureIndexTableDefragmentation", (SEUpdaterUtil::SELogObj *)"Start.\n");
  if (v1393)
  {
    v1396 = (unint64_t *)&v1393->__shared_owners_;
    do
      v1397 = __ldaxr(v1396);
    while (__stlxr(v1397 - 1, v1396));
    if (!v1397)
    {
      ((void (*)(std::__shared_weak_count *))v1393->__on_zero_shared)(v1393);
      std::__shared_weak_count::__release_weak(v1393);
    }
  }
  v1398 = *((_DWORD *)*v653 + 14);
  v1399 = v1398 > 0x37;
  v1400 = (1 << v1398) & 0xC0100000000000;
  if (v1399 || v1400 == 0)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1423 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v1424 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v1425 = (unint64_t *)((char *)__p[1] + 8);
        do
          v1426 = __ldaxr(v1425);
        while (__stlxr(v1426 - 1, v1425));
        if (!v1426)
        {
          ((void (*)(std::__shared_weak_count *))v1424->__on_zero_shared)(v1424);
          std::__shared_weak_count::__release_weak(v1424);
        }
      }
      v1423 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v1427 = (std::__shared_weak_count *)off_2553234C8;
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1423;
    value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v1428 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v1429 = __ldxr(v1428);
      while (__stxr(v1429 + 1, v1428));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v1423, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureIndexTableDefragmentation", (SEUpdaterUtil::SELogObj *)"Skip: JCOP platform %u not supported.\n", *((_DWORD *)*v653 + 14));
    if (v1427)
    {
      v1430 = (unint64_t *)&v1427->__shared_owners_;
      do
        v1431 = __ldaxr(v1430);
      while (__stlxr(v1431 - 1, v1430));
      if (!v1431)
      {
        ((void (*)(std::__shared_weak_count *))v1427->__on_zero_shared)(v1427);
        v1432 = v1427;
LABEL_2596:
        std::__shared_weak_count::__release_weak(v1432);
        goto LABEL_2597;
      }
    }
    goto LABEL_2597;
  }
  if ((*((_DWORD *)*v653 + 46) + 1) > 0x14)
  {
    SERestoreInfo::CApdu::CApdu((SERestoreInfo::CApdu *)&value);
    if (!SERestoreInfo::P73BaseDeviceInfo::isDev(*v653))
    {
      v1761[0] = xmmword_21CCD9909;
      v1761[1] = unk_21CCD9919;
      v1761[2] = xmmword_21CCD9929;
      *(_OWORD *)__p = xmmword_21CCD98C9;
      v1758 = unk_21CCD98D9;
      v1759 = xmmword_21CCD98E9;
      v1760 = unk_21CCD98F9;
      SERestoreInfo::CApdu::CApdu(&v1783, __p, 0x70uLL, 0);
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0C90;
      std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
      *(_OWORD *)v1787 = v1784;
      *(_OWORD *)&v1787[16] = v1785;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
      v1433 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
      if (v1783.__r_.__value_.__r.__words[2])
      {
        v1434 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
        do
          v1435 = __ldaxr(v1434);
        while (__stlxr(v1435 - 1, v1434));
        if (!v1435)
        {
          ((void (*)(std::__shared_weak_count *))v1433->__on_zero_shared)(v1433);
          std::__shared_weak_count::__release_weak(v1433);
        }
      }
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v1436 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        v1437 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          v1438 = (unint64_t *)((char *)__p[1] + 8);
          do
            v1439 = __ldaxr(v1438);
          while (__stlxr(v1439 - 1, v1438));
          if (!v1439)
          {
            ((void (*)(std::__shared_weak_count *))v1437->__on_zero_shared)(v1437);
            std::__shared_weak_count::__release_weak(v1437);
          }
        }
        v1436 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v1418 = (std::__shared_weak_count *)off_2553234C8;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1436;
      v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v1440 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v1441 = __ldxr(v1440);
        while (__stxr(v1441 + 1, v1440));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v1436, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureIndexTableDefragmentation", (SEUpdaterUtil::SELogObj *)"Skip: Prod SE, maybe enabled later.\n");
      if (!v1418)
        goto LABEL_2591;
      v1442 = (unint64_t *)&v1418->__shared_owners_;
      do
        v1422 = __ldaxr(v1442);
      while (__stlxr(v1422 - 1, v1442));
      goto LABEL_2589;
    }
    if (SERestoreInfo::P73BaseDeviceInfo::isProdEval(*v653))
    {
      v1761[0] = xmmword_21CCD99C5;
      v1761[1] = unk_21CCD99D5;
      *(_OWORD *)((char *)&v1761[1] + 15) = unk_21CCD99E4;
      *(_OWORD *)__p = xmmword_21CCD9985;
      v1758 = unk_21CCD9995;
      v1759 = xmmword_21CCD99A5;
      v1760 = unk_21CCD99B5;
      SERestoreInfo::CApdu::CApdu(&v1783, __p, 0x6FuLL, 0);
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0CD8;
      std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
      *(_OWORD *)v1787 = v1784;
      *(_OWORD *)&v1787[16] = v1785;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
      v1411 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
      if (v1783.__r_.__value_.__r.__words[2])
      {
        v1412 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
        do
          v1413 = __ldaxr(v1412);
        while (__stlxr(v1413 - 1, v1412));
        if (!v1413)
        {
          ((void (*)(std::__shared_weak_count *))v1411->__on_zero_shared)(v1411);
          std::__shared_weak_count::__release_weak(v1411);
        }
      }
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v1414 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        v1415 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          v1416 = (unint64_t *)((char *)__p[1] + 8);
          do
            v1417 = __ldaxr(v1416);
          while (__stlxr(v1417 - 1, v1416));
          if (!v1417)
          {
            ((void (*)(std::__shared_weak_count *))v1415->__on_zero_shared)(v1415);
            std::__shared_weak_count::__release_weak(v1415);
          }
        }
        v1414 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v1418 = (std::__shared_weak_count *)off_2553234C8;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1414;
      v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v1419 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v1420 = __ldxr(v1419);
        while (__stxr(v1420 + 1, v1419));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v1414, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureIndexTableDefragmentation", (SEUpdaterUtil::SELogObj *)"Skip: Prod Eval SE, pending verification once hardware ready.\n");
      if (!v1418)
        goto LABEL_2591;
      v1421 = (unint64_t *)&v1418->__shared_owners_;
      do
        v1422 = __ldaxr(v1421);
      while (__stlxr(v1422 - 1, v1421));
      goto LABEL_2589;
    }
    v1761[0] = xmmword_21CCD9A84;
    v1761[1] = unk_21CCD9A94;
    *(_OWORD *)((char *)&v1761[1] + 15) = unk_21CCD9AA3;
    *(_OWORD *)__p = xmmword_21CCD9A44;
    v1758 = unk_21CCD9A54;
    v1759 = xmmword_21CCD9A64;
    v1760 = unk_21CCD9A74;
    SERestoreInfo::CApdu::CApdu(&v1783, __p, 0x6FuLL, 0);
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0D20;
    std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
    *(_OWORD *)v1787 = v1784;
    *(_OWORD *)&v1787[16] = v1785;
    v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
    v1443 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
    if (v1783.__r_.__value_.__r.__words[2])
    {
      v1444 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
      do
        v1445 = __ldaxr(v1444);
      while (__stlxr(v1445 - 1, v1444));
      if (!v1445)
      {
        ((void (*)(std::__shared_weak_count *))v1443->__on_zero_shared)(v1443);
        std::__shared_weak_count::__release_weak(v1443);
      }
    }
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v1782, 0x2037uLL);
    v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF828;
    (*(void (**)(_QWORD, std::string *, std::string *, uint64_t, uint64_t))(**((_QWORD **)this + 20) + 16))(*((_QWORD *)this + 20), &value, &v1782, 3, 1);
    v1446 = (_QWORD *)v1782.__r_.__value_.__l.__size_;
    v1447 = *(_QWORD *)(v1782.__r_.__value_.__l.__size_ + 8);
    v1448 = v1447 - *(_QWORD *)v1782.__r_.__value_.__l.__size_;
    v1449 = v1448 >= 2;
    v1450 = v1448 - 2;
    if (!v1449
      || (*(unsigned __int8 *)(v1447 - 1) | (*(unsigned __int8 *)(*(_QWORD *)v1782.__r_.__value_.__l.__size_ + v1450) << 8)) != 0x9000)
    {
      v1675 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(__p, "Failed to read Index Table Defragmentation configuration");
      v1676 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1675, (__int128 *)__p, 31, CFSTR("SEUpdaterErrorDomain"));
    }
    if (v1450 <= 5)
    {
      v1699 = __cxa_allocate_exception(0x48uLL);
      v1700 = SERestoreInfo::RApdu::getDataSize((SERestoreInfo::RApdu *)&v1782);
      std::to_string(&v1783, v1700);
      v1701 = std::string::insert(&v1783, 0, "Wrong size for Index Table Defragmentation Config item query ");
      *(_OWORD *)__p = *(_OWORD *)&v1701->__r_.__value_.__l.__data_;
      *(_QWORD *)&v1758 = *((_QWORD *)&v1701->__r_.__value_.__l + 2);
      v1701->__r_.__value_.__l.__size_ = 0;
      v1701->__r_.__value_.__r.__words[2] = 0;
      v1701->__r_.__value_.__r.__words[0] = 0;
      v1702 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1699, (__int128 *)__p, 31, CFSTR("SEUpdaterErrorDomain"));
    }
    v1451 = operator new(8uLL);
    v1452 = v1451;
    *v1451 = 0x900400025E4103;
    if (v1446[1] - *v1446 == 8 && *v1451 == *(_QWORD *)*v1446)
    {
      v1761[0] = xmmword_21CCD9B3E;
      v1761[1] = unk_21CCD9B4E;
      v1761[2] = xmmword_21CCD9B5E;
      *(_OWORD *)__p = xmmword_21CCD9AFE;
      v1758 = unk_21CCD9B0E;
      v1759 = xmmword_21CCD9B1E;
      v1760 = unk_21CCD9B2E;
      *(_DWORD *)((char *)&v1761[2] + 15) = -2054377758;
      SERestoreInfo::CApdu::CApdu(&v1783, __p, 0x73uLL, 0);
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0D68;
      std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&value.__r_.__value_.__l.__size_, (uint64_t *)&v1783.__r_.__value_.__l.__size_);
      *(_OWORD *)v1787 = v1784;
      *(_OWORD *)&v1787[16] = v1785;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
      v1462 = (std::__shared_weak_count *)v1783.__r_.__value_.__r.__words[2];
      if (v1783.__r_.__value_.__r.__words[2])
      {
        v1463 = (unint64_t *)(v1783.__r_.__value_.__r.__words[2] + 8);
        do
          v1464 = __ldaxr(v1463);
        while (__stlxr(v1464 - 1, v1463));
        if (!v1464)
        {
          ((void (*)(std::__shared_weak_count *))v1462->__on_zero_shared)(v1462);
          std::__shared_weak_count::__release_weak(v1462);
        }
      }
      (*(void (**)(_QWORD, std::string *, std::string *, uint64_t, uint64_t))(**((_QWORD **)this + 20) + 16))(*((_QWORD *)this + 20), &value, &v1782, 3, 1);
      v1465 = *(_QWORD *)(v1782.__r_.__value_.__l.__size_ + 8);
      if ((unint64_t)(v1465 - *(_QWORD *)v1782.__r_.__value_.__l.__size_) < 2
        || (*(unsigned __int8 *)(v1465 - 1) | (*(unsigned __int8 *)(v1465 - 2) << 8)) != 0x9000)
      {
        v1715 = __cxa_allocate_exception(0x48uLL);
        std::string::basic_string[abi:ne180100]<0>(__p, "Failed to configure Index Table Defragmentation");
        v1716 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1715, (__int128 *)__p, 31, CFSTR("SEUpdaterErrorDomain"));
      }
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v1466 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)__p);
        v1466 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v1457 = (std::__shared_weak_count *)off_2553234C8;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1466;
      v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v1467 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v1468 = __ldxr(v1467);
        while (__stxr(v1468 + 1, v1467));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v1466, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureIndexTableDefragmentation", (SEUpdaterUtil::SELogObj *)"Index Table Defragmentation already configured: It needs to be reverted for now.\n");
      if (!v1457)
        goto LABEL_2586;
      v1469 = (unint64_t *)&v1457->__shared_owners_;
      do
        v1461 = __ldaxr(v1469);
      while (__stlxr(v1461 - 1, v1469));
    }
    else
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v1453 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        v1454 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          v1455 = (unint64_t *)((char *)__p[1] + 8);
          do
            v1456 = __ldaxr(v1455);
          while (__stlxr(v1456 - 1, v1455));
          if (!v1456)
          {
            ((void (*)(std::__shared_weak_count *))v1454->__on_zero_shared)(v1454);
            std::__shared_weak_count::__release_weak(v1454);
          }
        }
        v1453 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v1457 = (std::__shared_weak_count *)off_2553234C8;
      v1783.__r_.__value_.__r.__words[0] = (std::string::size_type)v1453;
      v1783.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v1458 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v1459 = __ldxr(v1458);
        while (__stxr(v1459 + 1, v1458));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v1453, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureIndexTableDefragmentation", (SEUpdaterUtil::SELogObj *)"Skip: Dev SE, there are issues needs to be fixed in JCOP.\n");
      if (!v1457)
        goto LABEL_2586;
      v1460 = (unint64_t *)&v1457->__shared_owners_;
      do
        v1461 = __ldaxr(v1460);
      while (__stlxr(v1461 - 1, v1460));
    }
    if (!v1461)
    {
      ((void (*)(std::__shared_weak_count *))v1457->__on_zero_shared)(v1457);
      std::__shared_weak_count::__release_weak(v1457);
    }
LABEL_2586:
    operator delete(v1452);
    v1782.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
    v1418 = (std::__shared_weak_count *)v1782.__r_.__value_.__r.__words[2];
    if (!v1782.__r_.__value_.__r.__words[2])
    {
LABEL_2591:
      value.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
      v1406 = (std::__shared_weak_count *)value.__r_.__value_.__r.__words[2];
      if (!value.__r_.__value_.__r.__words[2])
        goto LABEL_2597;
      v1471 = (unint64_t *)(value.__r_.__value_.__r.__words[2] + 8);
      do
        v1410 = __ldaxr(v1471);
      while (__stlxr(v1410 - 1, v1471));
      goto LABEL_2594;
    }
    v1470 = (unint64_t *)(v1782.__r_.__value_.__r.__words[2] + 8);
    do
      v1422 = __ldaxr(v1470);
    while (__stlxr(v1422 - 1, v1470));
LABEL_2589:
    if (!v1422)
    {
      ((void (*)(std::__shared_weak_count *))v1418->__on_zero_shared)(v1418);
      std::__shared_weak_count::__release_weak(v1418);
    }
    goto LABEL_2591;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v1402 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v1403 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v1404 = (unint64_t *)((char *)__p[1] + 8);
      do
        v1405 = __ldaxr(v1404);
      while (__stlxr(v1405 - 1, v1404));
      if (!v1405)
      {
        ((void (*)(std::__shared_weak_count *))v1403->__on_zero_shared)(v1403);
        std::__shared_weak_count::__release_weak(v1403);
      }
    }
    v1402 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v1406 = (std::__shared_weak_count *)off_2553234C8;
  value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1402;
  value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v1407 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v1408 = __ldxr(v1407);
    while (__stxr(v1408 + 1, v1407));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v1402, (SEUpdaterUtil::SELogObj *)2, 0, 1, "configureIndexTableDefragmentation", (SEUpdaterUtil::SELogObj *)"Skip: JCOP version low.\n");
  if (v1406)
  {
    v1409 = (unint64_t *)&v1406->__shared_owners_;
    do
      v1410 = __ldaxr(v1409);
    while (__stlxr(v1410 - 1, v1409));
LABEL_2594:
    if (v1410)
      goto LABEL_2597;
    ((void (*)(std::__shared_weak_count *))v1406->__on_zero_shared)(v1406);
    v1432 = v1406;
    goto LABEL_2596;
  }
LABEL_2597:
  if (_MergedGlobals_2)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1472 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v1473 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v1474 = (unint64_t *)((char *)__p[1] + 8);
        do
          v1475 = __ldaxr(v1474);
        while (__stlxr(v1475 - 1, v1474));
        if (!v1475)
        {
          ((void (*)(std::__shared_weak_count *))v1473->__on_zero_shared)(v1473);
          std::__shared_weak_count::__release_weak(v1473);
        }
      }
      v1472 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v1476 = (std::__shared_weak_count *)off_2553234C8;
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1472;
    value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v1477 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v1478 = __ldxr(v1477);
      while (__stxr(v1478 + 1, v1477));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v1472, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doPerform", (SEUpdaterUtil::SELogObj *)"Continue update with forceUpdateLoop=%lu \n", _MergedGlobals_2);
    if (v1476)
    {
      v1479 = (unint64_t *)&v1476->__shared_owners_;
      do
        v1480 = __ldaxr(v1479);
      while (__stlxr(v1480 - 1, v1479));
      if (!v1480)
      {
        ((void (*)(std::__shared_weak_count *))v1476->__on_zero_shared)(v1476);
        std::__shared_weak_count::__release_weak(v1476);
      }
    }
    v1481 = this;
  }
  else
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1482 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      v1483 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v1484 = (unint64_t *)((char *)__p[1] + 8);
        do
          v1485 = __ldaxr(v1484);
        while (__stlxr(v1485 - 1, v1484));
        if (!v1485)
        {
          ((void (*)(std::__shared_weak_count *))v1483->__on_zero_shared)(v1483);
          std::__shared_weak_count::__release_weak(v1483);
        }
      }
      v1482 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v1486 = (std::__shared_weak_count *)off_2553234C8;
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1482;
    value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v1487 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v1488 = __ldxr(v1487);
      while (__stxr(v1488 + 1, v1487));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SERestoreInfo::P73BaseDeviceInfo::print(*v653);
    if ((SBYTE7(v1758) & 0x80u) == 0)
      v1489 = __p;
    else
      v1489 = (void **)__p[0];
    SEUpdaterUtil::SELogObj::printLog(v1482, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doPerform", (SEUpdaterUtil::SELogObj *)"Update is done successfully: %s\n", (const char *)v1489);
    if (SBYTE7(v1758) < 0)
      operator delete(__p[0]);
    if (v1486)
    {
      v1490 = (unint64_t *)&v1486->__shared_owners_;
      do
        v1491 = __ldaxr(v1490);
      while (__stlxr(v1491 - 1, v1490));
      if (!v1491)
      {
        ((void (*)(std::__shared_weak_count *))v1486->__on_zero_shared)(v1486);
        std::__shared_weak_count::__release_weak(v1486);
      }
    }
    v1481 = this;
    *((_BYTE *)this + 80) = 1;
  }
  if (!*((_BYTE *)v1481 + 56))
    goto LABEL_2668;
  v1492 = (unsigned __int8 *)v1481 + 16;
  if (!*((_BYTE *)v1481 + 16))
    goto LABEL_2668;
  v1493 = (*(uint64_t (**)(SERestoreInfo::P73BaseDeviceInfo *))(*(_QWORD *)*v653 + 32))(*v653);
  if (v1493 > 99)
  {
    if (v1493 > 199)
    {
      if (v1493 != 200 && v1493 != 210)
        goto LABEL_2647;
    }
    else if (v1493 != 100 && v1493 != 115)
    {
      goto LABEL_2647;
    }
    v1636 = (*(uint64_t (**)(SERestoreInfo::P73BaseDeviceInfo *))(*(_QWORD *)*v653 + 32))(*v653);
    SLAM::StringUtil::Format((SLAM::StringUtil *)"Refusing to V2 pair with ChipID 0x%X", __p, v1636);
    v1637 = __cxa_allocate_exception(0x48uLL);
    v1638 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1637, (__int128 *)__p, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  if (v1493 != 44)
  {
LABEL_2647:
    v1494 = *v653;
    goto LABEL_2648;
  }
  v1494 = *v653;
  if (*((_DWORD *)*v653 + 3) <= 0x1B5u)
  {
    SLAM::StringUtil::Format((SLAM::StringUtil *)"Refusing to V2 pair EOS with CSN 0x%X", __p, *((unsigned int *)*v653 + 3));
    v1495 = __cxa_allocate_exception(0x48uLL);
    v1496 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v1495, (__int128 *)__p, 2, CFSTR("SEUpdaterErrorDomain"));
  }
LABEL_2648:
  if (*((_DWORD *)v1494 + 14) == 54 && SERestoreInfo::P73BaseDeviceInfo::isProdEval(v1494))
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v1497 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)__p);
      v1497 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v1498 = (std::__shared_weak_count *)off_2553234C8;
    value.__r_.__value_.__r.__words[0] = (std::string::size_type)v1497;
    value.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v1499 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v1500 = __ldxr(v1499);
      while (__stxr(v1500 + 1, v1499));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v1497, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doPerform", (SEUpdaterUtil::SELogObj *)"SE is PROD_EVAL -> Skip SE-SEP pairing\n");
    if (v1498)
    {
      v1501 = (unint64_t *)&v1498->__shared_owners_;
      do
        v1502 = __ldaxr(v1501);
      while (__stlxr(v1502 - 1, v1501));
      goto LABEL_2666;
    }
  }
  else
  {
    if (!*((_BYTE *)this + 56))
      std::__throw_bad_optional_access[abi:ne180100]();
    v1503 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
    v1728 = *((_QWORD *)this + 20);
    v1729 = v1503;
    if (v1503)
    {
      v1504 = (unint64_t *)&v1503->__shared_owners_;
      do
        v1505 = __ldxr(v1504);
      while (__stxr(v1505 + 1, v1504));
    }
    doAlohaPairing(v1492, &v1728);
    v1498 = v1729;
    if (v1729)
    {
      v1506 = (unint64_t *)&v1729->__shared_owners_;
      do
        v1502 = __ldaxr(v1506);
      while (__stlxr(v1502 - 1, v1506));
LABEL_2666:
      if (!v1502)
      {
        ((void (*)(std::__shared_weak_count *))v1498->__on_zero_shared)(v1498);
        std::__shared_weak_count::__release_weak(v1498);
      }
    }
  }
LABEL_2668:
  v1507 = v1736;
  if (v1736)
  {
    v1508 = (unint64_t *)&v1736->__shared_owners_;
    do
      v1509 = __ldaxr(v1508);
    while (__stlxr(v1509 - 1, v1508));
    if (!v1509)
    {
      ((void (*)(std::__shared_weak_count *))v1507->__on_zero_shared)(v1507);
      std::__shared_weak_count::__release_weak(v1507);
    }
  }
}

void sub_21CCB1328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,uint64_t a41,uint64_t a42,__int16 a43)
{
  __cxa_guard_abort(&qword_255323758);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a43);
  _Unwind_Resume(a1);
}

uint64_t std::map<std::string,std::string>::at(uint64_t a1, const void **a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(a1, &v4, a2);
  if (!v2)
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  return v2 + 56;
}

void SEUpdater::CommandGetOsInfo::~CommandGetOsInfo(SEUpdater::CommandGetOsInfo *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSelectOSU::~CommandSelectOSU(SEUpdater::CommandSelectOSU *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetAMExportInfo::~CommandGetAMExportInfo(SEUpdater::CommandGetAMExportInfo *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::P73BaseUpdateController::sendManifestQuery(SEUpdater::P73BaseUpdateController *this)
{
  uint64_t *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  const char *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  BOOL v20;
  uint64_t v21;
  const char *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  SERestoreInfo::P73BaseDeviceInfo *v28;
  uint64_t v29;
  int v30;
  unsigned __int8 *v31;
  int v32;
  SEUpdaterUtil::SELogObj *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  _QWORD *v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  SEUpdaterUtil::SELogObj *v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  _QWORD *v55;
  unint64_t *v56;
  SEUpdaterUtil::SELogObj *v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  unint64_t *v64;
  unint64_t v65;
  _QWORD *v66;
  unint64_t *v67;
  SEUpdaterUtil::SELogObj *v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  _QWORD *v77;
  unint64_t *v78;
  SEUpdaterUtil::SELogObj *v79;
  std::__shared_weak_count *v80;
  unint64_t *v81;
  unint64_t v82;
  std::__shared_weak_count *v83;
  unint64_t *v84;
  unint64_t v85;
  unint64_t *p_shared_owners;
  unint64_t v87;
  _QWORD *v88;
  unint64_t *v89;
  SEUpdaterUtil::SELogObj *v90;
  std::__shared_weak_count *v91;
  unint64_t *v92;
  unint64_t v93;
  std::__shared_weak_count *v94;
  unint64_t *v95;
  unint64_t v96;
  unint64_t *v97;
  unint64_t v98;
  _QWORD *v99;
  unint64_t *v100;
  SEUpdaterUtil::SELogObj *v101;
  std::__shared_weak_count *v102;
  unint64_t *v103;
  unint64_t v104;
  std::__shared_weak_count *v105;
  unint64_t *v106;
  unint64_t v107;
  unint64_t *v108;
  unint64_t v109;
  _QWORD *v110;
  unint64_t *v111;
  uint64_t v112;
  int v113;
  std::__shared_weak_count *v115;
  unint64_t *v116;
  unint64_t v117;
  uint64_t v118;
  int v119;
  unsigned __int8 *v120;
  int v121;
  BOOL v122;
  char v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  const std::string *v129;
  int v130;
  SEUpdaterUtil::SELogObj *v131;
  std::__shared_weak_count *v132;
  unint64_t *v133;
  unint64_t v134;
  std::__shared_weak_count *v135;
  unint64_t *v136;
  unint64_t v137;
  unint64_t *v138;
  unint64_t v139;
  char v140;
  std::__shared_weak_count *v141;
  unint64_t *v142;
  unint64_t v143;
  unint64_t *v144;
  uint64_t v145;
  uint64_t v146;
  SEUpdaterUtil::SELogObj *v147;
  std::__shared_weak_count *v148;
  unint64_t *v149;
  unint64_t v150;
  std::__shared_weak_count *v151;
  unint64_t *v152;
  unint64_t v153;
  unint64_t *v154;
  unint64_t v155;
  std::__shared_weak_count *v156;
  unint64_t *v157;
  unint64_t v158;
  unint64_t *v159;
  SEUpdaterUtil::SELogObj *v160;
  std::__shared_weak_count *v161;
  unint64_t *v162;
  unint64_t v163;
  std::__shared_weak_count *v164;
  unint64_t *v165;
  unint64_t v166;
  unint64_t *v167;
  unint64_t v168;
  SEUpdaterUtil::SELogObj *v169;
  std::__shared_weak_count *v170;
  unint64_t *v171;
  unint64_t v172;
  unint64_t *v173;
  unint64_t v174;
  unint64_t *v175;
  void *exception;
  std::string *v177;
  std::string *v178;
  __int128 v179;
  void *v180;
  std::string *v181;
  std::string *v182;
  __int128 v183;
  void *v184;
  void *v185;
  void *v186;
  void *v187;
  void *v188;
  void *v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  uint64_t *v205;
  uint64_t *v206;
  std::__shared_weak_count *v207;
  SEUpdaterUtil::SELogObj *v208;
  void *v209;
  void (**v210)(SEUpdater::CommandGetOsInfo *__hidden);
  _QWORD *v211;
  std::__shared_weak_count *v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  std::__shared_weak_count *v216;
  __int128 v217;
  __int128 v218;
  __int128 v219;
  __int16 v220;
  uint64_t v221;

  v221 = *MEMORY[0x24BDAC8D0];
  v2 = (uint64_t *)((char *)this + 160);
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 20) + 48))(*((_QWORD *)this + 20), 0);
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v205, 0x2037uLL);
  v205 = (uint64_t *)&unk_24E0BF828;
  v3 = *v2;
  v215 = xmmword_21CCD8B2B;
  LOWORD(v216) = 0;
  SERestoreInfo::CApdu::CApdu(&v190, &v215, 0x12uLL, 37);
  *(_QWORD *)&v190 = &off_24E0C0150;
  (*(void (**)(uint64_t, __int128 *, uint64_t **, uint64_t, uint64_t))(*(_QWORD *)v3 + 16))(v3, &v190, &v205, 3, 1);
  *(_QWORD *)&v190 = &unk_24E0BF880;
  v4 = (std::__shared_weak_count *)v191;
  if ((_QWORD)v191)
  {
    v5 = (unint64_t *)(v191 + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  v7 = (_BYTE *)*((_QWORD *)this + 20);
  v8 = *v206;
  v9 = v206[1];
  v10 = v9 - *v206;
  if (!v7[16])
  {
    if (v10 < 2 || (*(unsigned __int8 *)(v9 - 1) | (*(unsigned __int8 *)(v10 + v8 - 2) << 8)) != 0x9000)
    {
      SEUpdater::CommandSelectISD::CommandSelectISD((SEUpdater::CommandSelectISD *)&v190);
      (*(void (**)(_BYTE *, __int128 *, uint64_t **, uint64_t, uint64_t))(*(_QWORD *)v7 + 16))(v7, &v190, &v205, 3, 1);
      *(_QWORD *)&v190 = &unk_24E0BF880;
      v17 = (std::__shared_weak_count *)v191;
      if ((_QWORD)v191)
      {
        v18 = (unint64_t *)(v191 + 8);
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      SEUpdaterUtil::assertSW((uint64_t)&v205, (const SERestoreInfo::RApdu *)"Failed to send select ISD", v16);
    }
    goto LABEL_25;
  }
  if (v10 != 37 || (*(unsigned __int8 *)(v9 - 1) | (*(unsigned __int8 *)(v8 + 35) << 8)) != 0x9000)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    v177 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v215, "Assertion: ");
    v178 = std::string::append(v177, "!rApdu.isBad() && sizeof(SelectOSUResponse) == rApdu.size()");
    v179 = *(_OWORD *)&v178->__r_.__value_.__l.__data_;
    *(_QWORD *)&v191 = *((_QWORD *)&v178->__r_.__value_.__l + 2);
    v190 = v179;
    v178->__r_.__value_.__l.__size_ = 0;
    v178->__r_.__value_.__r.__words[2] = 0;
    v178->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v190);
  }
  if ((*(_BYTE *)(v8 + 12) & 1) == 0)
  {
LABEL_25:
    v20 = 0;
    goto LABEL_28;
  }
  LODWORD(v215) = 304128;
  SERestoreInfo::CApdu::CApdu(&v190, &v215, 4uLL, 0);
  SEUpdater::P73BaseSEController::transceive((uint64_t)v7, (uint64_t)&v190, &v205, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  *(_QWORD *)&v190 = &unk_24E0BF880;
  v11 = (std::__shared_weak_count *)v191;
  if ((_QWORD)v191)
  {
    v12 = (unint64_t *)(v191 + 8);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v206[1];
  if ((unint64_t)(v14 - *v206) < 2)
    v15 = 43947;
  else
    v15 = *(unsigned __int8 *)(v14 - 1) | (*(unsigned __int8 *)(v14 - 2) << 8);
  v20 = v15 == 26277;
LABEL_28:
  v21 = *((_QWORD *)this + 20);
  *(_QWORD *)&v215 = 0x3FFF02FE00CA80;
  SERestoreInfo::CApdu::CApdu(&v190, &v215, 8uLL, 0);
  *(_QWORD *)&v190 = &off_24E0C01E0;
  (*(void (**)(uint64_t, __int128 *, uint64_t **, uint64_t, uint64_t))(*(_QWORD *)v21 + 16))(v21, &v190, &v205, 3, 1);
  *(_QWORD *)&v190 = &unk_24E0BF880;
  v23 = (std::__shared_weak_count *)v191;
  if ((_QWORD)v191)
  {
    v24 = (unint64_t *)(v191 + 8);
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  SEUpdaterUtil::assertSW((uint64_t)&v205, (const SERestoreInfo::RApdu *)"Failed to send manifest query", v22);
  v203 = 0u;
  v204 = 0u;
  v201 = 0u;
  v202 = 0u;
  v199 = 0u;
  v200 = 0u;
  v197 = 0u;
  v198 = 0u;
  v195 = 0u;
  v196 = 0u;
  v193 = 0u;
  v194 = 0u;
  v191 = 0u;
  v192 = 0u;
  v190 = 0u;
  v26 = *v206;
  v27 = (std::__shared_weak_count *)(v206[1] - *v206);
  *(_QWORD *)&v215 = &unk_24E0BFCD0;
  *((_QWORD *)&v215 + 1) = v26;
  v216 = v27;
  *(_QWORD *)&v217 = 0;
  SERestoreInfo::P73BaseDeviceInfo::parseManifest((SERestoreInfo::P73BaseDeviceInfo *)&v215, (unsigned __int8 **)&v190);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&v215);
  v28 = (SERestoreInfo::P73BaseDeviceInfo *)*((_QWORD *)this + 16);
  if (v28)
    goto LABEL_181;
  v29 = *((_QWORD *)&v197 + 1);
  if (!*((_QWORD *)&v197 + 1))
    goto LABEL_314;
  v30 = 0;
  v31 = (unsigned __int8 *)v197;
  do
  {
    v32 = *v31++;
    v30 = v32 | (v30 << 8);
    --v29;
  }
  while (v29);
  if (v30 <= 99)
  {
    switch(v30)
    {
      case ',':
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v79 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v215);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v215);
          v80 = (std::__shared_weak_count *)*((_QWORD *)&v215 + 1);
          if (*((_QWORD *)&v215 + 1))
          {
            v81 = (unint64_t *)(*((_QWORD *)&v215 + 1) + 8);
            do
              v82 = __ldaxr(v81);
            while (__stlxr(v82 - 1, v81));
            if (!v82)
            {
              ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
              std::__shared_weak_count::__release_weak(v80);
            }
          }
          v79 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v83 = (std::__shared_weak_count *)off_2553234C8;
        v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))v79;
        v211 = off_2553234C8;
        if (off_2553234C8)
        {
          v84 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v85 = __ldxr(v84);
          while (__stxr(v85 + 1, v84));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v79, (SEUpdaterUtil::SELogObj *)2, 0, 1, "sendManifestQuery", (SEUpdaterUtil::SELogObj *)"SN300V detected based on manifest query response\n");
        if (v83)
        {
          p_shared_owners = (unint64_t *)&v83->__shared_owners_;
          do
            v87 = __ldaxr(p_shared_owners);
          while (__stlxr(v87 - 1, p_shared_owners));
          if (!v87)
          {
            ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
            std::__shared_weak_count::__release_weak(v83);
          }
        }
        v88 = operator new(0xD8uLL);
        v88[2] = 0;
        *v88 = &unk_24E0C0F40;
        v88[1] = 0;
        v28 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo((SERestoreInfo::P73BaseDeviceInfo *)(v88 + 3));
        v88[3] = &off_24E0C19F8;
        *((_DWORD *)v88 + 20) = 44;
        v43 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
        *((_QWORD *)this + 16) = v28;
        *((_QWORD *)this + 17) = v88;
        if (v43)
        {
          v89 = (unint64_t *)&v43->__shared_owners_;
          do
            v45 = __ldaxr(v89);
          while (__stlxr(v45 - 1, v89));
          goto LABEL_178;
        }
        goto LABEL_181;
      case '6':
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v68 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v215);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v215);
          v69 = (std::__shared_weak_count *)*((_QWORD *)&v215 + 1);
          if (*((_QWORD *)&v215 + 1))
          {
            v70 = (unint64_t *)(*((_QWORD *)&v215 + 1) + 8);
            do
              v71 = __ldaxr(v70);
            while (__stlxr(v71 - 1, v70));
            if (!v71)
            {
              ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
              std::__shared_weak_count::__release_weak(v69);
            }
          }
          v68 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v72 = (std::__shared_weak_count *)off_2553234C8;
        v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))v68;
        v211 = off_2553234C8;
        if (off_2553234C8)
        {
          v73 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v74 = __ldxr(v73);
          while (__stxr(v74 + 1, v73));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v68, (SEUpdaterUtil::SELogObj *)2, 0, 1, "sendManifestQuery", (SEUpdaterUtil::SELogObj *)"SN300V2 detected based on manifest query response\n");
        if (v72)
        {
          v75 = (unint64_t *)&v72->__shared_owners_;
          do
            v76 = __ldaxr(v75);
          while (__stlxr(v76 - 1, v75));
          if (!v76)
          {
            ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
            std::__shared_weak_count::__release_weak(v72);
          }
        }
        v77 = operator new(0xD8uLL);
        v77[2] = 0;
        *v77 = &unk_24E0C0FE0;
        v77[1] = 0;
        v28 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo((SERestoreInfo::P73BaseDeviceInfo *)(v77 + 3));
        v77[3] = &off_24E0BF620;
        *((_DWORD *)v77 + 20) = 54;
        v43 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
        *((_QWORD *)this + 16) = v28;
        *((_QWORD *)this + 17) = v77;
        if (v43)
        {
          v78 = (unint64_t *)&v43->__shared_owners_;
          do
            v45 = __ldaxr(v78);
          while (__stlxr(v45 - 1, v78));
          goto LABEL_178;
        }
        goto LABEL_181;
      case '7':
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v46 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v215);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v215);
          v47 = (std::__shared_weak_count *)*((_QWORD *)&v215 + 1);
          if (*((_QWORD *)&v215 + 1))
          {
            v48 = (unint64_t *)(*((_QWORD *)&v215 + 1) + 8);
            do
              v49 = __ldaxr(v48);
            while (__stlxr(v49 - 1, v48));
            if (!v49)
            {
              ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
              std::__shared_weak_count::__release_weak(v47);
            }
          }
          v46 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v50 = (std::__shared_weak_count *)off_2553234C8;
        v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))v46;
        v211 = off_2553234C8;
        if (off_2553234C8)
        {
          v51 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v52 = __ldxr(v51);
          while (__stxr(v52 + 1, v51));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v46, (SEUpdaterUtil::SELogObj *)2, 0, 1, "sendManifestQuery", (SEUpdaterUtil::SELogObj *)"SE310S detected based on manifest query response\n");
        if (v50)
        {
          v53 = (unint64_t *)&v50->__shared_owners_;
          do
            v54 = __ldaxr(v53);
          while (__stlxr(v54 - 1, v53));
          if (!v54)
          {
            ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
            std::__shared_weak_count::__release_weak(v50);
          }
        }
        v55 = operator new(0xD8uLL);
        v55[2] = 0;
        *v55 = &unk_24E0C0F90;
        v55[1] = 0;
        v28 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo((SERestoreInfo::P73BaseDeviceInfo *)(v55 + 3));
        v55[3] = &off_24E0C1B60;
        *((_DWORD *)v55 + 20) = 55;
        v43 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
        *((_QWORD *)this + 16) = v28;
        *((_QWORD *)this + 17) = v55;
        if (v43)
        {
          v56 = (unint64_t *)&v43->__shared_owners_;
          do
            v45 = __ldaxr(v56);
          while (__stlxr(v45 - 1, v56));
          goto LABEL_178;
        }
        goto LABEL_181;
    }
    goto LABEL_314;
  }
  if (v30 > 199)
  {
    if (v30 == 200)
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v101 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v215);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v215);
        v102 = (std::__shared_weak_count *)*((_QWORD *)&v215 + 1);
        if (*((_QWORD *)&v215 + 1))
        {
          v103 = (unint64_t *)(*((_QWORD *)&v215 + 1) + 8);
          do
            v104 = __ldaxr(v103);
          while (__stlxr(v104 - 1, v103));
          if (!v104)
          {
            ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
            std::__shared_weak_count::__release_weak(v102);
          }
        }
        v101 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v105 = (std::__shared_weak_count *)off_2553234C8;
      v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))v101;
      v211 = off_2553234C8;
      if (off_2553234C8)
      {
        v106 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v107 = __ldxr(v106);
        while (__stxr(v107 + 1, v106));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v101, (SEUpdaterUtil::SELogObj *)2, 0, 1, "sendManifestQuery", (SEUpdaterUtil::SELogObj *)"SN200V detected based on manifest query response\n");
      if (v105)
      {
        v108 = (unint64_t *)&v105->__shared_owners_;
        do
          v109 = __ldaxr(v108);
        while (__stlxr(v109 - 1, v108));
        if (!v109)
        {
          ((void (*)(std::__shared_weak_count *))v105->__on_zero_shared)(v105);
          std::__shared_weak_count::__release_weak(v105);
        }
      }
      v110 = operator new(0xD8uLL);
      v110[2] = 0;
      *v110 = &unk_24E0C0EA0;
      v110[1] = 0;
      v28 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo((SERestoreInfo::P73BaseDeviceInfo *)(v110 + 3));
      v110[3] = &off_24E0C1EF0;
      *((_DWORD *)v110 + 20) = 200;
      v43 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
      *((_QWORD *)this + 16) = v28;
      *((_QWORD *)this + 17) = v110;
      if (v43)
      {
        v111 = (unint64_t *)&v43->__shared_owners_;
        do
          v45 = __ldaxr(v111);
        while (__stlxr(v45 - 1, v111));
        goto LABEL_178;
      }
      goto LABEL_181;
    }
    if (v30 == 210)
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v57 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v215);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v215);
        v58 = (std::__shared_weak_count *)*((_QWORD *)&v215 + 1);
        if (*((_QWORD *)&v215 + 1))
        {
          v59 = (unint64_t *)(*((_QWORD *)&v215 + 1) + 8);
          do
            v60 = __ldaxr(v59);
          while (__stlxr(v60 - 1, v59));
          if (!v60)
          {
            ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
            std::__shared_weak_count::__release_weak(v58);
          }
        }
        v57 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v61 = (std::__shared_weak_count *)off_2553234C8;
      v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))v57;
      v211 = off_2553234C8;
      if (off_2553234C8)
      {
        v62 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v63 = __ldxr(v62);
        while (__stxr(v63 + 1, v62));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v57, (SEUpdaterUtil::SELogObj *)2, 0, 1, "sendManifestQuery", (SEUpdaterUtil::SELogObj *)"SN210V detected based on manifest query response\n");
      if (v61)
      {
        v64 = (unint64_t *)&v61->__shared_owners_;
        do
          v65 = __ldaxr(v64);
        while (__stlxr(v65 - 1, v64));
        if (!v65)
        {
          ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
          std::__shared_weak_count::__release_weak(v61);
        }
      }
      v66 = operator new(0xD8uLL);
      v66[2] = 0;
      *v66 = &unk_24E0C0EF0;
      v66[1] = 0;
      v28 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo((SERestoreInfo::P73BaseDeviceInfo *)(v66 + 3));
      v66[3] = &off_24E0C12C8;
      *((_DWORD *)v66 + 20) = 210;
      v43 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
      *((_QWORD *)this + 16) = v28;
      *((_QWORD *)this + 17) = v66;
      if (v43)
      {
        v67 = (unint64_t *)&v43->__shared_owners_;
        do
          v45 = __ldaxr(v67);
        while (__stlxr(v45 - 1, v67));
        goto LABEL_178;
      }
      goto LABEL_181;
    }
    goto LABEL_314;
  }
  if (v30 != 100)
  {
    if (v30 == 115)
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v33 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v215);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v215);
        v34 = (std::__shared_weak_count *)*((_QWORD *)&v215 + 1);
        if (*((_QWORD *)&v215 + 1))
        {
          v35 = (unint64_t *)(*((_QWORD *)&v215 + 1) + 8);
          do
            v36 = __ldaxr(v35);
          while (__stlxr(v36 - 1, v35));
          if (!v36)
          {
            ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
            std::__shared_weak_count::__release_weak(v34);
          }
        }
        v33 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v37 = (std::__shared_weak_count *)off_2553234C8;
      v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))v33;
      v211 = off_2553234C8;
      if (off_2553234C8)
      {
        v38 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v39 = __ldxr(v38);
        while (__stxr(v39 + 1, v38));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v33, (SEUpdaterUtil::SELogObj *)2, 0, 1, "sendManifestQuery", (SEUpdaterUtil::SELogObj *)"P73 detected based on manifest query response\n");
      if (v37)
      {
        v40 = (unint64_t *)&v37->__shared_owners_;
        do
          v41 = __ldaxr(v40);
        while (__stlxr(v41 - 1, v40));
        if (!v41)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }
      v42 = operator new(0xD8uLL);
      v42[2] = 0;
      *v42 = &unk_24E0C0E00;
      v42[1] = 0;
      v28 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo((SERestoreInfo::P73BaseDeviceInfo *)(v42 + 3));
      v42[3] = &off_24E0C1378;
      *((_DWORD *)v42 + 20) = 115;
      v43 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
      *((_QWORD *)this + 16) = v28;
      *((_QWORD *)this + 17) = v42;
      if (v43)
      {
        v44 = (unint64_t *)&v43->__shared_owners_;
        do
          v45 = __ldaxr(v44);
        while (__stlxr(v45 - 1, v44));
LABEL_178:
        if (!v45)
        {
          ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
          std::__shared_weak_count::__release_weak(v43);
        }
        v28 = (SERestoreInfo::P73BaseDeviceInfo *)*((_QWORD *)this + 16);
        if (!v28)
        {
          v180 = __cxa_allocate_exception(0x10uLL);
          v181 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v210, "Assertion: ");
          v182 = std::string::append(v181, "fDeviceInfo");
          v183 = *(_OWORD *)&v182->__r_.__value_.__l.__data_;
          v216 = (std::__shared_weak_count *)v182->__r_.__value_.__r.__words[2];
          v215 = v183;
          v182->__r_.__value_.__l.__size_ = 0;
          v182->__r_.__value_.__r.__words[2] = 0;
          v182->__r_.__value_.__r.__words[0] = 0;
          MEMORY[0x22078A520](v180, &v215);
        }
        goto LABEL_181;
      }
      goto LABEL_181;
    }
LABEL_314:
    v186 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v215, "Unknown ChipID");
    v187 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v186, &v215, 30, CFSTR("SEUpdaterErrorDomain"));
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v90 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v215);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v215);
    v91 = (std::__shared_weak_count *)*((_QWORD *)&v215 + 1);
    if (*((_QWORD *)&v215 + 1))
    {
      v92 = (unint64_t *)(*((_QWORD *)&v215 + 1) + 8);
      do
        v93 = __ldaxr(v92);
      while (__stlxr(v93 - 1, v92));
      if (!v93)
      {
        ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
        std::__shared_weak_count::__release_weak(v91);
      }
    }
    v90 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v94 = (std::__shared_weak_count *)off_2553234C8;
  v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))v90;
  v211 = off_2553234C8;
  if (off_2553234C8)
  {
    v95 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v96 = __ldxr(v95);
    while (__stxr(v96 + 1, v95));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v90, (SEUpdaterUtil::SELogObj *)2, 0, 1, "sendManifestQuery", (SEUpdaterUtil::SELogObj *)"SN100V detected based on manifest query response\n");
  if (v94)
  {
    v97 = (unint64_t *)&v94->__shared_owners_;
    do
      v98 = __ldaxr(v97);
    while (__stlxr(v98 - 1, v97));
    if (!v98)
    {
      ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
      std::__shared_weak_count::__release_weak(v94);
    }
  }
  v99 = operator new(0xD8uLL);
  v99[2] = 0;
  *v99 = &unk_24E0C0E50;
  v99[1] = 0;
  v28 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo((SERestoreInfo::P73BaseDeviceInfo *)(v99 + 3));
  v99[3] = &off_24E0C1EA0;
  *((_DWORD *)v99 + 20) = 100;
  v43 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
  *((_QWORD *)this + 16) = v28;
  *((_QWORD *)this + 17) = v99;
  if (v43)
  {
    v100 = (unint64_t *)&v43->__shared_owners_;
    do
      v45 = __ldaxr(v100);
    while (__stlxr(v45 - 1, v100));
    goto LABEL_178;
  }
LABEL_181:
  SERestoreInfo::P73BaseDeviceInfo::updateDeviceInfo((uint64_t)v28, (unsigned __int8 **)&v190);
  if (*(_DWORD *)(*((_QWORD *)this + 16) + 176))
    goto LABEL_182;
  v118 = *((_QWORD *)&v195 + 1);
  if (!*((_QWORD *)&v195 + 1))
    goto LABEL_211;
  v119 = 0;
  v120 = (unsigned __int8 *)v195;
  do
  {
    v121 = *v120++;
    v119 = v121 | (v119 << 8);
    --v118;
  }
  while (v118);
  v122 = v119 == 23195 || v119 == 47411;
  if (v122 || v119 == 47545)
    v124 = 1;
  else
LABEL_211:
    v124 = 0;
  std::string::basic_string[abi:ne180100]<0>(&v215, "forceDeviceHwVersion");
  v125 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)this + 88, (const void **)&v215);
  v126 = v125;
  if (SHIBYTE(v216) < 0)
  {
    operator delete((void *)v215);
    if (v126)
      goto LABEL_214;
LABEL_237:
    SERestoreInfo::CApdu::CApdu((SERestoreInfo::CApdu *)&v215);
    v140 = v124 ^ 1;
    if (*(_BYTE *)(*((_QWORD *)this + 20) + 16))
      v140 = 1;
    if ((v140 & 1) != 0)
    {
      v219 = xmmword_21CCD8B2B;
      v220 = 0;
      SERestoreInfo::CApdu::CApdu(&v210, &v219, 0x12uLL, 37);
      v210 = &off_24E0C0150;
      std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100]((_QWORD *)&v215 + 1, (uint64_t *)&v211);
      v217 = v213;
      v218 = v214;
      v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))&unk_24E0BF880;
      v141 = v212;
      if (!v212)
        goto LABEL_249;
      v144 = (unint64_t *)&v212->__shared_owners_;
      do
        v143 = __ldaxr(v144);
      while (__stlxr(v143 - 1, v144));
    }
    else
    {
      *(_QWORD *)&v219 = 0x31DF02FE00CA80;
      SERestoreInfo::CApdu::CApdu(&v210, &v219, 8uLL, 23);
      v210 = &off_24E0C0108;
      std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100]((_QWORD *)&v215 + 1, (uint64_t *)&v211);
      v217 = v213;
      v218 = v214;
      v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))&unk_24E0BF880;
      v141 = v212;
      if (!v212)
        goto LABEL_249;
      v142 = (unint64_t *)&v212->__shared_owners_;
      do
        v143 = __ldaxr(v142);
      while (__stlxr(v143 - 1, v142));
    }
    if (!v143)
    {
      ((void (*)(std::__shared_weak_count *))v141->__on_zero_shared)(v141);
      std::__shared_weak_count::__release_weak(v141);
    }
LABEL_249:
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v210, 0x2037uLL);
    v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))&unk_24E0BF828;
    (*(void (**)(_QWORD, __int128 *, void (***)(SEUpdater::CommandGetOsInfo *__hidden), uint64_t, uint64_t))(**((_QWORD **)this + 20) + 16))(*((_QWORD *)this + 20), &v215, &v210, 3, 1);
    v145 = v211[1];
    if ((unint64_t)(v145 - *v211) >= 2
      && (*(unsigned __int8 *)(v145 - 1) | (*(unsigned __int8 *)(v145 - 2) << 8)) == 0x9000)
    {
      if (v145 - *v211 == *((_QWORD *)&v218 + 1))
      {
        v146 = 17;
        if ((v124 & (*(_BYTE *)(*((_QWORD *)this + 20) + 16) == 0)) != 0)
          v146 = 11;
        v130 = *(unsigned __int8 *)(*v211 + v146);
        goto LABEL_271;
      }
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v169 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v219);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v219);
        v170 = (std::__shared_weak_count *)*((_QWORD *)&v219 + 1);
        if (*((_QWORD *)&v219 + 1))
        {
          v171 = (unint64_t *)(*((_QWORD *)&v219 + 1) + 8);
          do
            v172 = __ldaxr(v171);
          while (__stlxr(v172 - 1, v171));
          if (!v172)
          {
            ((void (*)(std::__shared_weak_count *))v170->__on_zero_shared)(v170);
            std::__shared_weak_count::__release_weak(v170);
          }
        }
        v169 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v151 = (std::__shared_weak_count *)off_2553234C8;
      v208 = v169;
      v209 = off_2553234C8;
      if (off_2553234C8)
      {
        v173 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v174 = __ldxr(v173);
        while (__stxr(v174 + 1, v173));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v169, (SEUpdaterUtil::SELogObj *)1, 0, 1, "getDeviceHardwareVersion", (SEUpdaterUtil::SELogObj *)"Unexpected returned length for hardware version query %zu != %zu\n", v211[1] - *v211, *((size_t *)&v218 + 1));
      if (!v151)
      {
LABEL_270:
        v130 = 0;
LABEL_271:
        v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))&unk_24E0BF880;
        v156 = v212;
        if (v212)
        {
          v157 = (unint64_t *)&v212->__shared_owners_;
          do
            v158 = __ldaxr(v157);
          while (__stlxr(v158 - 1, v157));
          if (!v158)
          {
            ((void (*)(std::__shared_weak_count *))v156->__on_zero_shared)(v156);
            std::__shared_weak_count::__release_weak(v156);
          }
        }
        *(_QWORD *)&v215 = &unk_24E0BF880;
        v135 = v216;
        if (!v216)
          goto LABEL_281;
        v159 = (unint64_t *)&v216->__shared_owners_;
        do
          v139 = __ldaxr(v159);
        while (__stlxr(v139 - 1, v159));
        goto LABEL_279;
      }
      v175 = (unint64_t *)&v151->__shared_owners_;
      do
        v155 = __ldaxr(v175);
      while (__stlxr(v155 - 1, v175));
    }
    else
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v147 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v219);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v219);
        v148 = (std::__shared_weak_count *)*((_QWORD *)&v219 + 1);
        if (*((_QWORD *)&v219 + 1))
        {
          v149 = (unint64_t *)(*((_QWORD *)&v219 + 1) + 8);
          do
            v150 = __ldaxr(v149);
          while (__stlxr(v150 - 1, v149));
          if (!v150)
          {
            ((void (*)(std::__shared_weak_count *))v148->__on_zero_shared)(v148);
            std::__shared_weak_count::__release_weak(v148);
          }
        }
        v147 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v151 = (std::__shared_weak_count *)off_2553234C8;
      v208 = v147;
      v209 = off_2553234C8;
      if (off_2553234C8)
      {
        v152 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v153 = __ldxr(v152);
        while (__stxr(v153 + 1, v152));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v147, (SEUpdaterUtil::SELogObj *)1, 0, 1, "getDeviceHardwareVersion", (SEUpdaterUtil::SELogObj *)"Failed to query hardware version\n");
      if (!v151)
        goto LABEL_270;
      v154 = (unint64_t *)&v151->__shared_owners_;
      do
        v155 = __ldaxr(v154);
      while (__stlxr(v155 - 1, v154));
    }
    if (!v155)
    {
      ((void (*)(std::__shared_weak_count *))v151->__on_zero_shared)(v151);
      std::__shared_weak_count::__release_weak(v151);
    }
    goto LABEL_270;
  }
  if (!v125)
    goto LABEL_237;
LABEL_214:
  std::string::basic_string[abi:ne180100]<0>(&v215, "forceDeviceHwVersion");
  v127 = std::map<std::string,std::string>::at((uint64_t)this + 88, (const void **)&v215);
  if (*(char *)(v127 + 23) >= 0)
    v128 = *(unsigned __int8 *)(v127 + 23);
  else
    v128 = *(_QWORD *)(v127 + 8);
  if (SHIBYTE(v216) < 0)
    operator delete((void *)v215);
  if (!v128)
  {
    v188 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v215, "Debug argument forceDeviceHwVersion empty");
    v189 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v188, &v215, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  std::string::basic_string[abi:ne180100]<0>(&v215, "forceDeviceHwVersion");
  v129 = (const std::string *)std::map<std::string,std::string>::at((uint64_t)this + 88, (const void **)&v215);
  v130 = std::stoi(v129, 0, 10);
  if (SHIBYTE(v216) < 0)
    operator delete((void *)v215);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v131 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v215);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v215);
    v132 = (std::__shared_weak_count *)*((_QWORD *)&v215 + 1);
    if (*((_QWORD *)&v215 + 1))
    {
      v133 = (unint64_t *)(*((_QWORD *)&v215 + 1) + 8);
      do
        v134 = __ldaxr(v133);
      while (__stlxr(v134 - 1, v133));
      if (!v134)
      {
        ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
        std::__shared_weak_count::__release_weak(v132);
      }
    }
    v131 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v135 = (std::__shared_weak_count *)off_2553234C8;
  v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))v131;
  v211 = off_2553234C8;
  if (off_2553234C8)
  {
    v136 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v137 = __ldxr(v136);
    while (__stxr(v137 + 1, v136));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v131, (SEUpdaterUtil::SELogObj *)1, 0, 1, "getDeviceHardwareVersion", (SEUpdaterUtil::SELogObj *)"Forcing device hardware version %u\n", v130);
  if (!v135)
    goto LABEL_281;
  v138 = (unint64_t *)&v135->__shared_owners_;
  do
    v139 = __ldaxr(v138);
  while (__stlxr(v139 - 1, v138));
LABEL_279:
  if (!v139)
  {
    ((void (*)(std::__shared_weak_count *))v135->__on_zero_shared)(v135);
    std::__shared_weak_count::__release_weak(v135);
  }
LABEL_281:
  *(_DWORD *)(*((_QWORD *)this + 16) + 176) = v130;
  if (v130)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v160 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v215);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v215);
      v161 = (std::__shared_weak_count *)*((_QWORD *)&v215 + 1);
      if (*((_QWORD *)&v215 + 1))
      {
        v162 = (unint64_t *)(*((_QWORD *)&v215 + 1) + 8);
        do
          v163 = __ldaxr(v162);
        while (__stlxr(v163 - 1, v162));
        if (!v163)
        {
          ((void (*)(std::__shared_weak_count *))v161->__on_zero_shared)(v161);
          std::__shared_weak_count::__release_weak(v161);
        }
      }
      v160 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v164 = (std::__shared_weak_count *)off_2553234C8;
    v210 = (void (**)(SEUpdater::CommandGetOsInfo *__hidden))v160;
    v211 = off_2553234C8;
    if (off_2553234C8)
    {
      v165 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v166 = __ldxr(v165);
      while (__stxr(v166 + 1, v165));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v160, (SEUpdaterUtil::SELogObj *)2, 0, 1, "sendManifestQuery", (SEUpdaterUtil::SELogObj *)"Hardware version %u\n", *(_DWORD *)(*((_QWORD *)this + 16) + 176));
    if (v164)
    {
      v167 = (unint64_t *)&v164->__shared_owners_;
      do
        v168 = __ldaxr(v167);
      while (__stlxr(v168 - 1, v167));
      if (!v168)
      {
        ((void (*)(std::__shared_weak_count *))v164->__on_zero_shared)(v164);
        std::__shared_weak_count::__release_weak(v164);
      }
    }
  }
LABEL_182:
  SEUpdater::P73BaseUpdateController::printManifest(this);
  if (v20 || *(_DWORD *)(*((_QWORD *)this + 16) + 136) != 165)
  {
    v184 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v215, "SE in restricted mode");
    v185 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v184, &v215, 34, CFSTR("SEUpdaterErrorDomain"));
  }
  std::string::basic_string[abi:ne180100]<0>(&v215, "singleStep");
  v112 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)this + 88, (const void **)&v215);
  if (SHIBYTE(v216) < 0)
    operator delete((void *)v215);
  if (v112)
  {
    puts("type return to continue");
    do
      v113 = getchar() << 24;
    while (v113 != 167772160 && v113 != 218103808);
  }
  v205 = (uint64_t *)&unk_24E0BF880;
  v115 = v207;
  if (v207)
  {
    v116 = (unint64_t *)&v207->__shared_owners_;
    do
      v117 = __ldaxr(v116);
    while (__stlxr(v117 - 1, v116));
    if (!v117)
    {
      ((void (*)(std::__shared_weak_count *))v115->__on_zero_shared)(v115);
      std::__shared_weak_count::__release_weak(v115);
    }
  }
}

void sub_21CCB51AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
  uint64_t v44;
  uint64_t v45;

  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  *(_QWORD *)(v45 - 232) = v44 + 16;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v45 - 224);
  *(_QWORD *)(v45 - 176) = v44 + 16;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v45 - 168);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void sub_21CCB53C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
  uint64_t v44;

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v44 - 232);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void sub_21CCB53DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
  uint64_t v44;
  void *exception;
  void *v47;

  if (a2 == 2)
  {
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v44 - 176), "Failed to parse forceDeviceHwVersion debug argument");
    v47 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, (__int128 *)(v44 - 176), 2, CFSTR("SEUpdaterErrorDomain"));
  }
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void sub_21CCB5478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
  uint64_t v44;

  if (*(char *)(v44 - 153) < 0)
    operator delete(*(void **)(v44 - 176));
  __cxa_end_catch();
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void sub_21CCB54A4(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x21CCB55E0);
}

void sub_21CCB54BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
  uint64_t v44;

  if (*(char *)(v44 - 153) < 0)
    operator delete(*(void **)(v44 - 176));
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void sub_21CCB54D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
  uint64_t v44;

  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)(v44 - 176));
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void sub_21CCB54F8()
{
  JUMPOUT(0x21CCB5508);
}

void sub_21CCB551C()
{
  JUMPOUT(0x21CCB55E0);
}

void sub_21CCB5528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44)
{
  a43 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](&a44);
  _Unwind_Resume(a1);
}

void sub_21CCB5530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47)
{
  int v47;
  uint64_t v48;

  if (*(char *)(v48 - 153) < 0)
    operator delete(*(void **)(v48 - 176));
  if (*(char *)(v48 - 209) < 0)
  {
    operator delete(*(void **)(v48 - 232));
    if ((v47 & 1) == 0)
    {
LABEL_7:
      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a47);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_7;
  }
  JUMPOUT(0x21CCB55BCLL);
}

void sub_21CCB55A0()
{
  uint64_t v0;

  if (*(char *)(v0 - 153) < 0)
    JUMPOUT(0x21CCB55B0);
  JUMPOUT(0x21CCB55BCLL);
}

void sub_21CCB55B8()
{
  void *v0;

  __cxa_free_exception(v0);
  JUMPOUT(0x21CCB55C4);
}

void SEUpdater::CommandMQ::~CommandMQ(SEUpdater::CommandMQ *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::P73BaseUpdateController::sendIm4M(const void **this)
{
  int v2;
  uint64_t v3;
  const char *v4;
  __CFString **v5;
  unint64_t *v7;
  unint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *exception;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFDictionaryRef theDict;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  void *__p[2];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef((const void **)&theDict, this + 9);
  v2 = (*(uint64_t (**)(const void *))(*(_QWORD *)this[16] + 32))(this[16]);
  v5 = kSETagResponseTicket;
  if (v2 <= 199)
  {
    if (v2 != 100 && v2 != 115)
LABEL_10:
      v5 = kSETagResponseTicketEC384;
  }
  else if (v2 != 200 && v2 != 210 && v2 != 131601)
  {
    goto LABEL_10;
  }
  SEUpdaterUtil::getDataFromDict<SERestoreInfo::BLOB>(&v19, theDict, *v5, v3, v4);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)&theDict);
  if (v19 && *(_QWORD *)(v19 + 8) && *(_QWORD *)(v19 + 16))
  {
    v16 = v19;
    v17 = v20;
    if (v20)
    {
      v7 = (unint64_t *)(v20 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    v15 = 0;
    v22 = 0;
    v51 = 0;
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    *(_OWORD *)__p = 0u;
    v24 = 0u;
    if (!Img4DecodeInitManifest())
    {
      Img4DecodeGetObjectPropertyData();
      exception = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v21, "Failed to get nonce from manifest");
      v14 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, &v21, 18, CFSTR("SEUpdaterErrorDomain"));
    }
    v11 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v21, "Failed to decode manifest");
    v12 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v11, &v21, 18, CFSTR("SEUpdaterErrorDomain"));
  }
  v9 = __cxa_allocate_exception(0x48uLL);
  std::string::basic_string[abi:ne180100]<0>(__p, "Cannot find SE ticket in restore option");
  v10 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v9, (__int128 *)__p, 9, CFSTR("SEUpdaterErrorDomain"));
}

void sub_21CCB5DEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, char a20,uint64_t a21,char a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  a28 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a29);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void SEUpdater::P73BaseUpdateController::sendIm4P(SEUpdater::P73BaseUpdateController *this)
{
  int v2;
  uint64_t v4;
  const char *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  SEUpdaterUtil::SELogObj *v24;
  std::__shared_weak_count *size;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  int v34;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  SEUpdaterUtil::SELogObj *v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  std::string *p_p;
  unint64_t *v48;
  unint64_t v49;
  _QWORD v50[2];
  void (**v51)(SEUpdater::CommandImage4 *__hidden);
  __int128 v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  std::string __p;
  __int128 v58;
  __int128 v59;
  _QWORD v60[2];
  std::__shared_weak_count *v61;

  v2 = *(_DWORD *)(*((_QWORD *)this + 16) + 140);
  if (v2 == 47545 || v2 == 59367)
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 20) + 48))(*((_QWORD *)this + 20), 0);
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)v60, 0x2037uLL);
    v60[0] = &unk_24E0BF828;
    v4 = *((_QWORD *)this + 20);
    SEUpdater::CommandTriggerImg4::CommandTriggerImg4((SEUpdater::CommandTriggerImg4 *)&__p);
    (*(void (**)(uint64_t, std::string *, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v4 + 16))(v4, &__p, v60, 3, 1);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
    v6 = (std::__shared_weak_count *)__p.__r_.__value_.__r.__words[2];
    if (__p.__r_.__value_.__r.__words[2])
    {
      v7 = (unint64_t *)(__p.__r_.__value_.__r.__words[2] + 8);
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    SEUpdaterUtil::assertSW((uint64_t)v60, (const SERestoreInfo::RApdu *)"Failed to send Image4 trigger", v5);
    v9 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
    v55 = *((_QWORD *)this + 20);
    v56 = v9;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    v12 = *((_QWORD *)this + 18);
    LOBYTE(v50[0]) = 20;
    *(_DWORD *)((char *)v50 + 1) = 0;
    SERestoreInfo::CApdu::CApdu(&__p, v50, 5uLL, 0);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0300;
    *(_BYTE *)(v58 + 1) = -69;
    v52 = *(_OWORD *)&__p.__r_.__value_.__r.__words[1];
    if (__p.__r_.__value_.__r.__words[2])
    {
      v13 = (unint64_t *)(__p.__r_.__value_.__r.__words[2] + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v53 = v58;
    v54 = v59;
    v51 = &off_24E0C02D0;
    SEUpdater::sendImage4Apdu(&v55, v12 + 32, &v51);
    v51 = (void (**)(SEUpdater::CommandImage4 *__hidden))&unk_24E0BF880;
    v15 = (std::__shared_weak_count *)*((_QWORD *)&v52 + 1);
    if (*((_QWORD *)&v52 + 1))
    {
      v16 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
    v18 = (std::__shared_weak_count *)__p.__r_.__value_.__r.__words[2];
    if (__p.__r_.__value_.__r.__words[2])
    {
      v19 = (unint64_t *)(__p.__r_.__value_.__r.__words[2] + 8);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    v21 = v56;
    if (v56)
    {
      v22 = (unint64_t *)&v56->__shared_owners_;
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v24 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&__p);
      size = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
      if (__p.__r_.__value_.__l.__size_)
      {
        v26 = (unint64_t *)(__p.__r_.__value_.__l.__size_ + 8);
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
          std::__shared_weak_count::__release_weak(size);
        }
      }
      v24 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v28 = (std::__shared_weak_count *)off_2553234C8;
    v50[0] = v24;
    v50[1] = off_2553234C8;
    if (off_2553234C8)
    {
      v29 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v24, (SEUpdaterUtil::SELogObj *)2, 0, 1, "sendIm4P", (SEUpdaterUtil::SELogObj *)"Pushed Update Payload successfully\n");
    if (v28)
    {
      v31 = (unint64_t *)&v28->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, "singleStep");
    v33 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)this + 88, (const void **)&__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (v33)
    {
      puts("type return to continue");
      do
        v34 = getchar() << 24;
      while (v34 != 167772160 && v34 != 218103808);
    }
    SEUpdater::P73BaseUpdateController::sendManifestQuery(this);
    v60[0] = &unk_24E0BF880;
    v36 = v61;
    if (v61)
    {
      v37 = (unint64_t *)&v61->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        v39 = v36;
LABEL_81:
        std::__shared_weak_count::__release_weak(v39);
      }
    }
  }
  else
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v40 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&__p);
      v41 = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
      if (__p.__r_.__value_.__l.__size_)
      {
        v42 = (unint64_t *)(__p.__r_.__value_.__l.__size_ + 8);
        do
          v43 = __ldaxr(v42);
        while (__stlxr(v43 - 1, v42));
        if (!v43)
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
      }
      v40 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v44 = (std::__shared_weak_count *)off_2553234C8;
    v60[0] = v40;
    v60[1] = off_2553234C8;
    if (off_2553234C8)
    {
      v45 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v46 = __ldxr(v45);
      while (__stxr(v46 + 1, v45));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SERestoreInfo::P73BaseDeviceInfo::getIm4State((SERestoreInfo::P73BaseDeviceInfo *)*(unsigned int *)(*((_QWORD *)this + 16) + 140), &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    SEUpdaterUtil::SELogObj::printLog(v40, (SEUpdaterUtil::SELogObj *)2, 0, 1, "sendIm4P", (SEUpdaterUtil::SELogObj *)"Skip sending the Update Payload because of IM4 state %s\n", (const char *)p_p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (v44)
    {
      v48 = (unint64_t *)&v44->__shared_owners_;
      do
        v49 = __ldaxr(v48);
      while (__stlxr(v49 - 1, v48));
      if (!v49)
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        v39 = v44;
        goto LABEL_81;
      }
    }
  }
}

void sub_21CCB64A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

const void **SEUpdaterUtil::getDataFromDict<SERestoreInfo::BLOB>(_QWORD *a1, CFDictionaryRef theDict, void *key, uint64_t a4, const char *a5)
{
  uint64_t (*v6)(uint64_t);
  CFTypeID v7;
  const void *v8;
  uint64_t (*v9)(uint64_t);
  char *v11;
  void *exception;
  std::string *v13;
  __int128 v14;
  std::string::size_type v15;
  const void *v16;
  std::string value;
  __int128 v18;
  std::string::size_type v19;

  if (!key)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&value, "Assertion: ");
    v13 = std::string::append(&value, "key");
    v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v19 = v13->__r_.__value_.__r.__words[2];
    v18 = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v18);
  }
  v16 = 0;
  value.__r_.__value_.__r.__words[0] = 0;
  v6 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  if (!theDict)
    v6 = 0;
  if (!v6)
    goto LABEL_12;
  if (!CFDictionaryGetValueIfPresent(theDict, key, (const void **)&value.__r_.__value_.__l.__data_)
    || (v7 = CFGetTypeID(value.__r_.__value_.__l.__data_), v7 != CFDataGetTypeID()))
  {
    v11 = "data is either not found or in wrong CFType";
    goto LABEL_14;
  }
  v15 = value.__r_.__value_.__r.__words[0];
  ctu::cf::CFSharedRef<__CFData const>::CFSharedRef<void const,void>(&v18, (CFTypeRef *)&v15);
  v8 = v16;
  v16 = (const void *)v18;
  *(_QWORD *)&v18 = v8;
  ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)&v18);
  v9 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  if (!v16)
    v9 = 0;
  if (!v9)
  {
LABEL_12:
    v11 = "fail to get Data";
LABEL_14:
    SEUpdaterUtil::_AddError((SEUpdaterUtil *)2, 1, (uint64_t)"getDataFromDict", (SEUpdaterUtil::SELogObj *)v11, a5);
    *a1 = 0;
    a1[1] = 0;
    return ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef(&v16);
  }
  *(_QWORD *)&v18 = v16;
  std::allocate_shared[abi:ne180100]<SERestoreInfo::BLOB,std::allocator<SERestoreInfo::BLOB>,__CFData const*,void>((CFTypeRef *)&v18, a1);
  return ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef(&v16);
}

void sub_21CCB6728(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef(&a11);
  _Unwind_Resume(a1);
}

void SEUpdater::CommandTriggerImg4::~CommandTriggerImg4(SEUpdater::CommandTriggerImg4 *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::sendImage4Apdu(_QWORD *a1, uint64_t a2, _QWORD *a3)
{
  BOOL v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  BOOL v18;
  unint64_t v19;
  uint64_t v20;
  const char *v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  int v25;
  const char *v26;
  void *exception;
  std::string *v28;
  __int128 v29;
  std::string v30;
  __int128 v31;
  std::__shared_weak_count *v32;

  if (*(_QWORD *)(a2 + 8))
    v3 = *(_QWORD *)(a2 + 16) == 0;
  else
    v3 = 1;
  if (v3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v30, "Assertion: ");
    v28 = std::string::append(&v30, "b.data && b.length");
    v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v32 = (std::__shared_weak_count *)v28->__r_.__value_.__r.__words[2];
    v31 = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v31);
  }
  v7 = 0;
  do
  {
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v31, 0x2037uLL);
    *(_QWORD *)&v31 = &unk_24E0BF828;
    v8 = a3[3];
    *(_BYTE *)(v8 + 3) = 1;
    v9 = *(_QWORD *)(a2 + 16);
    v10 = v7 + 240;
    if (v9 <= v7 + 240)
    {
      *(_BYTE *)(v8 + 3) = 0;
      v11 = v9 - v7;
    }
    else
    {
      v11 = 240;
    }
    v12 = *(_QWORD *)(a2 + 8);
    if (!v12)
    {
      v25 = 250;
      v26 = "data";
      goto LABEL_30;
    }
    if ((unint64_t)(v11 - 8243) < 0xFFFFFFFFFFFFDFC8)
    {
      v25 = 251;
      v26 = "(sizeof(CApduHeader_t)+len)<=MAX_APDU_LEN";
LABEL_30:
      __assert_rtn("copyPayload", "Apdu.hpp", v25, v26);
    }
    SERestoreInfo::CApdu::validate(a3);
    v13 = (unint64_t *)a3[1];
    v14 = *v13;
    v15 = v13[1] - *v13;
    if (v15 > 4)
    {
      if (v15 != 5)
        v13[1] = v14 + 5;
    }
    else
    {
      std::vector<unsigned char>::__append(v13, 5 - v15);
      v13 = (unint64_t *)a3[1];
      v14 = *v13;
    }
    std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)v13, (char *)(v14 + 5), (char *)(v12 + v7), (char *)(v12 + v7 + v11), v11);
    v16 = *(_QWORD *)a3[1];
    v17 = *(_QWORD *)(a3[1] + 8) - v16;
    v18 = v17 >= 6;
    if (v17 >= 6)
      v19 = v17 - 5;
    else
      v19 = 0;
    if (v18)
      v20 = v16 + 5;
    else
      v20 = 0;
    a3[4] = v20;
    a3[5] = v19;
    a3[3] = v16;
    SERestoreInfo::CApdu::validate(a3);
    *(_BYTE *)(a3[3] + 4) = a3[5];
    (*(void (**)(_QWORD, _QWORD *, __int128 *, uint64_t, uint64_t))(*(_QWORD *)*a1 + 16))(*a1, a3, &v31, 3, 1);
    SEUpdaterUtil::assertSW((uint64_t)&v31, (const SERestoreInfo::RApdu *)"Failed to send IM4 APDU", v21);
    ++*(_BYTE *)(a3[3] + 2);
    *(_QWORD *)&v31 = &unk_24E0BF880;
    v22 = v32;
    if (v32)
    {
      p_shared_owners = (unint64_t *)&v32->__shared_owners_;
      do
        v24 = __ldaxr(p_shared_owners);
      while (__stlxr(v24 - 1, p_shared_owners));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    v7 += 240;
  }
  while (*(_QWORD *)(a2 + 16) > v10);
}

void sub_21CCB6A70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

void SEUpdater::CommandImage4::~CommandImage4(SEUpdater::CommandImage4 *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandIm4m::~CommandIm4m(SEUpdater::CommandIm4m *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandUpdatePayload::~CommandUpdatePayload(SEUpdater::CommandUpdatePayload *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::P73BaseUpdateController::doOneAction(SEUpdater::P73BaseUpdateController *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t **v5;
  unsigned int v6;
  void *exception;
  std::string *v8;
  void *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  std::__shared_weak_count *size;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::string *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  unint64_t v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  const char *v29;
  char *v30;
  int v31;
  int v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  char *v40;
  char *v41;
  const unsigned __int8 *v42;
  SEUpdaterUtil::SELogObj *v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  char *v50;
  int v51;
  unint64_t *v52;
  unint64_t v53;
  uint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  SEUpdaterUtil::SELogObj *v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  unint64_t *v65;
  unint64_t v66;
  char v67;
  uint64_t *v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  std::string *v75;
  unint64_t *v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  char *v81;
  void *v82[2];
  char v83;
  unsigned int v84;
  void *v85;
  __int128 v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  void *__p[2];
  char v93;
  __int128 v94;
  __int128 v95;
  uint64_t v96;
  int v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  std::string v101;
  SEUpdaterUtil::SELogObj *v102;
  void *v103;
  unint64_t v104;
  uint64_t *v105;
  char **v106;
  std::__shared_weak_count *v107;

  v3 = *(uint64_t **)(*((_QWORD *)this + 18) + 16);
  if (!v3)
  {
LABEL_7:
    exception = __cxa_allocate_exception(0x48uLL);
    std::to_string(&v101, a2);
    v8 = std::string::insert(&v101, 0, "No update item with index: ");
    v94 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    *(_QWORD *)&v95 = *((_QWORD *)&v8->__r_.__value_.__l + 2);
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    v9 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, &v94, 31, CFSTR("SEUpdaterErrorDomain"));
  }
  v5 = *(uint64_t ***)(*((_QWORD *)this + 18) + 16);
  while (1)
  {
    v6 = *((unsigned __int16 *)v5 + 16);
    if (v6 <= a2)
      break;
LABEL_6:
    v5 = (uint64_t **)*v5;
    if (!v5)
      goto LABEL_7;
  }
  if (v6 < a2)
  {
    ++v5;
    goto LABEL_6;
  }
  while (1)
  {
    while (1)
    {
      v10 = *((unsigned __int16 *)v3 + 16);
      if (v10 <= a2)
        break;
      v3 = (uint64_t *)*v3;
      if (!v3)
LABEL_141:
        std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
    }
    if (v10 >= a2)
      break;
    v3 = (uint64_t *)v3[1];
    if (!v3)
      goto LABEL_141;
  }
  LODWORD(v94) = *((_DWORD *)v3 + 10);
  *((_QWORD *)&v94 + 1) = &unk_24E0BFCD0;
  v95 = *(_OWORD *)(v3 + 7);
  v96 = v3[9];
  v97 = *((_DWORD *)v3 + 20);
  v99 = 0;
  v100 = 0;
  v11 = v3[11];
  v12 = v3[12];
  v98 = 0;
  std::vector<SERestoreInfo::BLOB>::__init_with_size[abi:ne180100]<SERestoreInfo::BLOB*,SERestoreInfo::BLOB*>((char *)&v98, v11, v12, (v12 - v11) >> 5);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v13 = (uint64_t *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v101);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v101);
    size = (std::__shared_weak_count *)v101.__r_.__value_.__l.__size_;
    if (v101.__r_.__value_.__l.__size_)
    {
      v15 = (unint64_t *)(v101.__r_.__value_.__l.__size_ + 8);
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
    }
    v13 = (uint64_t *)off_2553234C0;
  }
  v17 = (std::__shared_weak_count *)off_2553234C8;
  v105 = v13;
  v106 = (char **)off_2553234C8;
  if (off_2553234C8)
  {
    v18 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)&unk_21CCDB9F7);
  SERestoreInfo::ImageBinary::print((int *)&v94, (uint64_t)__p);
  if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v20 = &v101;
  else
    v20 = (std::string *)v101.__r_.__value_.__r.__words[0];
  SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v13, (SEUpdaterUtil::SELogObj *)3, 0, 1, "doOneAction", (SEUpdaterUtil::SELogObj *)"%s: \n", (const char *)v20);
  if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v101.__r_.__value_.__l.__data_);
  if (v93 < 0)
    operator delete(__p[0]);
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v84 = v94;
  v85 = &unk_24E0BFCD0;
  v86 = v95;
  v87 = v96;
  v88 = v97;
  v90 = 0;
  v91 = 0;
  v89 = 0;
  std::vector<SERestoreInfo::BLOB>::__init_with_size[abi:ne180100]<SERestoreInfo::BLOB*,SERestoreInfo::BLOB*>((char *)&v89, v98, v99, (v99 - v98) >> 5);
  v23 = 0;
  if (v84 != 1 && v84 <= 4)
  {
    if ((unint64_t)(((v90 - v89) >> 4) + ((v90 - v89) >> 5)) <= 0x14)
      v23 = 20;
    else
      v23 = ((v90 - v89) >> 4) + ((v90 - v89) >> 5);
  }
  v24 = 0;
  v25 = 0;
  v81 = (char *)this + 88;
  while (2)
  {
    v26 = v89;
    v27 = v25;
    if (v89 == v90)
      goto LABEL_108;
    while (2)
    {
      SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v105, 0x2037uLL);
      v105 = (uint64_t *)&unk_24E0BF828;
      v28 = v106[2] - *v106;
      v101.__r_.__value_.__s.__data_[0] = 0;
      std::vector<unsigned char>::assign(v106, v28, (char *)&v101);
      v104 = 0;
      v104 = v106[1] - *v106;
      (*(void (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 20) + 24))(*((_QWORD *)this + 20), *(_QWORD *)(v26 + 8), *(_QWORD *)(v26 + 16));
      SERestoreInfo::Apdu::updateSize((uint64_t)&v105, v104);
      v30 = v106[1];
      if ((unint64_t)(v30 - *v106) < 2
        || ((v31 = *(v30 - 2), v32 = *(v30 - 1), (v32 | (v31 << 8)) != 0x6F24)
          ? (v33 = (v32 & 0xF0 | (v31 << 8)) == 25536)
          : (v33 = 1),
            !v33))
      {
        v27 = v25;
        goto LABEL_55;
      }
      v27 = (v25 + 1);
      if (v23 <= (int)v25 || v84 == 1 || v84 > 4)
      {
LABEL_55:
        SEUpdaterUtil::assertSW((uint64_t)&v105, (const SERestoreInfo::RApdu *)"Fail to sendApdus", v29);
        v36 = 0;
        goto LABEL_56;
      }
      std::string::basic_string[abi:ne180100]<0>(&v101, "disableAMRetry");
      v34 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v81, (const void **)&v101.__r_.__value_.__l.__data_);
      v35 = v34;
      if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v101.__r_.__value_.__l.__data_);
        if (!v35)
          goto LABEL_65;
        goto LABEL_55;
      }
      if (v34)
        goto LABEL_55;
LABEL_65:
      v40 = *v106;
      v41 = v106[1];
      v42 = (const unsigned __int8 *)(v41 - *v106);
      if ((unint64_t)v42 >= 2
        && (*(v41 - 1) | (v40[(_QWORD)v42 - 2] << 8)) == 0x6F24)
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v43 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v101);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v101);
          v44 = (std::__shared_weak_count *)v101.__r_.__value_.__l.__size_;
          if (v101.__r_.__value_.__l.__size_)
          {
            v45 = (unint64_t *)(v101.__r_.__value_.__l.__size_ + 8);
            do
              v46 = __ldaxr(v45);
            while (__stlxr(v46 - 1, v45));
            if (!v46)
            {
              ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
              std::__shared_weak_count::__release_weak(v44);
            }
          }
          v43 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v47 = (std::__shared_weak_count *)off_2553234C8;
        v102 = v43;
        v103 = off_2553234C8;
        if (off_2553234C8)
        {
          v48 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v49 = __ldxr(v48);
          while (__stxr(v49 + 1, v48));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v50 = v106[1];
        if ((unint64_t)(v50 - *v106) < 2)
          v51 = 43947;
        else
          v51 = *(v50 - 1) | (*(v50 - 2) << 8);
        SEUpdaterUtil::SELogObj::printLog(v43, (SEUpdaterUtil::SELogObj *)1, 0, 1, "sendApdus", (SEUpdaterUtil::SELogObj *)"Resetting due to 0x%hx", v51);
        if (v47)
        {
          v52 = (unint64_t *)&v47->__shared_owners_;
          do
            v53 = __ldaxr(v52);
          while (__stlxr(v53 - 1, v52));
          if (!v53)
          {
            ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
            std::__shared_weak_count::__release_weak(v47);
          }
        }
        (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 20) + 48))(*((_QWORD *)this + 20), 0);
        v40 = *v106;
        v42 = (const unsigned __int8 *)(v106[1] - *v106);
      }
      SEUpdaterUtil::SELogPrintBinary((SEUpdaterUtil *)1, (uint64_t)v40, v42, 1);
      v54 = *((_QWORD *)this + 20);
      LODWORD(v102) = 174720;
      BYTE4(v102) = 0;
      SERestoreInfo::CApdu::CApdu(&v101, &v102, 5uLL, 0);
      v101.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0198;
      SEUpdater::P73BaseSEController::transceive(v54, (uint64_t)&v101, &v105, 0, (SEUpdaterUtil::SELogObj *)2, 1);
      v101.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
      v55 = (std::__shared_weak_count *)v101.__r_.__value_.__r.__words[2];
      if (v101.__r_.__value_.__r.__words[2])
      {
        v56 = (unint64_t *)(v101.__r_.__value_.__r.__words[2] + 8);
        do
          v57 = __ldaxr(v56);
        while (__stlxr(v57 - 1, v56));
        if (!v57)
        {
          ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
          std::__shared_weak_count::__release_weak(v55);
        }
      }
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v58 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v101);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v101);
        v59 = (std::__shared_weak_count *)v101.__r_.__value_.__l.__size_;
        if (v101.__r_.__value_.__l.__size_)
        {
          v60 = (unint64_t *)(v101.__r_.__value_.__l.__size_ + 8);
          do
            v61 = __ldaxr(v60);
          while (__stlxr(v61 - 1, v60));
          if (!v61)
          {
            ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
            std::__shared_weak_count::__release_weak(v59);
          }
        }
        v58 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v62 = (std::__shared_weak_count *)off_2553234C8;
      v102 = v58;
      v103 = off_2553234C8;
      if (off_2553234C8)
      {
        v63 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v64 = __ldxr(v63);
        while (__stxr(v64 + 1, v63));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v58, (SEUpdaterUtil::SELogObj *)1, 0, 1, "sendApdus", (SEUpdaterUtil::SELogObj *)"Failed APDU # %ld during attempt # %d; replaying from scratch\n",
        (v26 - v89) >> 5,
        v27);
      if (v62)
      {
        v65 = (unint64_t *)&v62->__shared_owners_;
        do
          v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
          std::__shared_weak_count::__release_weak(v62);
        }
      }
      v36 = 1;
LABEL_56:
      v105 = (uint64_t *)&unk_24E0BF880;
      v37 = v107;
      if (v107)
      {
        v38 = (unint64_t *)&v107->__shared_owners_;
        do
          v39 = __ldaxr(v38);
        while (__stlxr(v39 - 1, v38));
        if (!v39)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }
      if ((v36 & 1) == 0)
      {
        v26 += 32;
        v25 = v27;
        if (v26 == v90)
          goto LABEL_109;
        continue;
      }
      break;
    }
    v24 = 1;
LABEL_108:
    v67 = v24;
    v24 = 1;
    v25 = v27;
    if ((v67 & 1) != 0)
      continue;
    break;
  }
LABEL_109:
  v101.__r_.__value_.__r.__words[0] = (std::string::size_type)&v89;
  std::vector<SERestoreInfo::BLOB>::__destroy_vector::operator()[abi:ne180100]((void ***)&v101);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&v85);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v68 = (uint64_t *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v101);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v101);
    v69 = (std::__shared_weak_count *)v101.__r_.__value_.__l.__size_;
    if (v101.__r_.__value_.__l.__size_)
    {
      v70 = (unint64_t *)(v101.__r_.__value_.__l.__size_ + 8);
      do
        v71 = __ldaxr(v70);
      while (__stlxr(v71 - 1, v70));
      if (!v71)
      {
        ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
        std::__shared_weak_count::__release_weak(v69);
      }
    }
    v68 = (uint64_t *)off_2553234C0;
  }
  v72 = (std::__shared_weak_count *)off_2553234C8;
  v105 = v68;
  v106 = (char **)off_2553234C8;
  if (off_2553234C8)
  {
    v73 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v74 = __ldxr(v73);
    while (__stxr(v74 + 1, v73));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  std::string::basic_string[abi:ne180100]<0>(v82, (char *)&unk_21CCDB9F7);
  SERestoreInfo::ImageBinary::print((int *)&v94, (uint64_t)v82);
  if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v75 = &v101;
  else
    v75 = (std::string *)v101.__r_.__value_.__r.__words[0];
  SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v68, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doOneAction", (SEUpdaterUtil::SELogObj *)"Successfully pushed binary: %s\n", (const char *)v75);
  if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v101.__r_.__value_.__l.__data_);
  if (v83 < 0)
    operator delete(v82[0]);
  if (v72)
  {
    v76 = (unint64_t *)&v72->__shared_owners_;
    do
      v77 = __ldaxr(v76);
    while (__stlxr(v77 - 1, v76));
    if (!v77)
    {
      ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
      std::__shared_weak_count::__release_weak(v72);
    }
  }
  std::string::basic_string[abi:ne180100]<0>(&v101, "singleStep");
  v78 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v81, (const void **)&v101.__r_.__value_.__l.__data_);
  if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v101.__r_.__value_.__l.__data_);
  if (v78)
  {
    puts("type return to continue");
    do
      v79 = getchar() << 24;
    while (v79 != 167772160 && v79 != 218103808);
  }
  v101.__r_.__value_.__r.__words[0] = (std::string::size_type)&v98;
  std::vector<SERestoreInfo::BLOB>::__destroy_vector::operator()[abi:ne180100]((void ***)&v101);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)((char *)&v94 + 8));
}

void sub_21CCB75BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, SERestoreInfo::BLOB *a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  uint64_t v46;
  uint64_t v47;

  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  *(_QWORD *)(v47 - 112) = v46 + 16;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](a11);
  SERestoreInfo::ImageBinary::~ImageBinary((SERestoreInfo::ImageBinary *)&a26);
  SERestoreInfo::ImageBinary::~ImageBinary((SERestoreInfo::ImageBinary *)&a41);
  _Unwind_Resume(a1);
}

void SEUpdater::CommandTriggerOSU::~CommandTriggerOSU(SEUpdater::CommandTriggerOSU *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSelectCRS::~CommandSelectCRS(SEUpdater::CommandSelectCRS *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSetFTAActivation::~CommandSetFTAActivation(SEUpdater::CommandSetFTAActivation *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

BOOL SEUpdater::P73BaseUpdateController::getSEHealthCheckResult(SEUpdater::P73BaseUpdateController *this)
{
  _BYTE *v2;
  int v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  int v24;
  SEUpdaterUtil::SELogObj *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  _BOOL8 v32;
  unint64_t *v33;
  unint64_t v34;
  int v35;
  int v36;
  SEUpdaterUtil::SELogObj *v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t *p_shared_owners;
  unint64_t v45;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  SEUpdaterUtil::SELogObj *v52;
  unint64_t *v53;
  unint64_t v54;
  unint64_t v55;
  int v56;
  SEUpdaterUtil::SELogObj *v57;
  unint64_t *v58;
  unint64_t v59;
  unint64_t v60;
  int v61;
  unint64_t *v62;
  unint64_t v63;
  unint64_t v64;
  SEUpdaterUtil::SELogObj *v65;
  unint64_t *v66;
  unint64_t v67;
  uint64_t v68;
  const unsigned __int8 *DataSize;
  SEUpdaterUtil::SELogObj *v70;
  unint64_t *v71;
  unint64_t v72;
  SEUpdaterUtil::SELogObj *v73;
  unint64_t *v74;
  unint64_t v75;
  SEUpdaterUtil::SELogObj *v76;
  unint64_t *v77;
  unint64_t v78;
  __int128 *v79;
  unint64_t *v80;
  unint64_t v81;
  SEUpdaterUtil::SELogObj *v82;
  unint64_t *v83;
  unint64_t v84;
  SEUpdaterUtil::SELogObj *v85;
  unint64_t *v86;
  unint64_t v87;
  SEUpdaterUtil::SELogObj *v88;
  void *v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  unint64_t v99;
  unint64_t v100;
  void *v101;
  unint64_t *v102;
  std::__shared_weak_count *v103;
  __int128 v104;
  uint64_t v105;

  v105 = *MEMORY[0x24BDAC8D0];
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v101, 0x2037uLL);
  v101 = &unk_24E0BF828;
  v2 = (_BYTE *)*((_QWORD *)this + 20);
  if (v2[16])
  {
    *(_QWORD *)&v104 = 0x4ADF02FE00CA00;
    SERestoreInfo::CApdu::CApdu(&v90, &v104, 8uLL, 0);
    *(_QWORD *)&v90 = &off_24E0C0420;
    v3 = (*(uint64_t (**)(_BYTE *, __int128 *, void **, uint64_t, uint64_t))(*(_QWORD *)v2 + 16))(v2, &v90, &v101, 3, 1);
    *(_QWORD *)&v90 = &unk_24E0BF880;
    v4 = (std::__shared_weak_count *)v91;
    if ((_QWORD)v91)
    {
      v5 = (unint64_t *)(v91 + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    if (!v3)
    {
      v7 = v102[1];
      if (v7 - *v102 >= 2 && (*(unsigned __int8 *)(v7 - 1) | (*(unsigned __int8 *)(v7 - 2) << 8)) == 0x9000)
      {
        v99 = 0;
        v100 = 0;
        v8 = v102[1];
        v99 = *v102;
        v9 = v8 - v99;
        if (v9 <= 1)
          __assert_rtn("getDataSize", "Apdu.hpp", 382, "len >= 2");
        v100 = v9 - 2;
        v97 = 0u;
        v98 = 0u;
        v95 = 0u;
        v96 = 0u;
        v93 = 0u;
        v94 = 0u;
        v91 = 0u;
        v92 = 0u;
        v90 = 0u;
        if (!DERParseDERSequenceSpecContent(&v99, (uint64_t)&LogStatusDataItemSeqSpec, (char *)&v90, 0x90uLL))
        {
          if (*((_QWORD *)&v90 + 1) == 1)
          {
            if (*((_QWORD *)&v96 + 1) == 1)
            {
              if (*((_QWORD *)&v92 + 1) == 1)
              {
                if (*((_QWORD *)&v94 + 1))
                  v10 = *(unsigned __int8 *)v94;
                else
                  v10 = 0;
                v24 = *(unsigned __int8 *)v96;
                v35 = *(unsigned __int8 *)v90;
                v36 = *(unsigned __int8 *)v92;
                pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                v37 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                if (!off_2553234C0)
                {
                  SEUpdaterUtil::SELogObj::create_default_global(&v104);
                  std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v104);
                  v38 = (std::__shared_weak_count *)*((_QWORD *)&v104 + 1);
                  if (*((_QWORD *)&v104 + 1))
                  {
                    v39 = (unint64_t *)(*((_QWORD *)&v104 + 1) + 8);
                    do
                      v40 = __ldaxr(v39);
                    while (__stlxr(v40 - 1, v39));
                    if (!v40)
                    {
                      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
                      std::__shared_weak_count::__release_weak(v38);
                    }
                  }
                  v37 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
                }
                v41 = (std::__shared_weak_count *)off_2553234C8;
                v88 = v37;
                v89 = off_2553234C8;
                if (off_2553234C8)
                {
                  v42 = (unint64_t *)((char *)off_2553234C8 + 8);
                  do
                    v43 = __ldxr(v42);
                  while (__stxr(v43 + 1, v42));
                }
                pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
                SEUpdaterUtil::SELogObj::printLog(v37, (SEUpdaterUtil::SELogObj *)2, 0, 1, "getSEHealthCheckResult", (SEUpdaterUtil::SELogObj *)"AC Platform Primary %d Platform Secondary %d JCOP1 %d JCOP2 %d\n", v35 == 90, v24 == 90, v36 == 90, v10 == 90);
                if (v41)
                {
                  p_shared_owners = (unint64_t *)&v41->__shared_owners_;
                  do
                    v45 = __ldaxr(p_shared_owners);
                  while (__stlxr(v45 - 1, p_shared_owners));
                  if (!v45)
                  {
                    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
                    std::__shared_weak_count::__release_weak(v41);
                  }
                }
                v32 = v35 == 90 || v36 == 90 || v10 == 90;
LABEL_77:
                if (v32 || v24 == 90)
                  SEUpdater::P73BaseUpdateController::dumpDebugInfo(this);
                else
                  v32 = 0;
                goto LABEL_81;
              }
              pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              v76 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              if (!off_2553234C0)
              {
                SEUpdaterUtil::SELogObj::create_default_global(&v104);
                std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v104);
                std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v104);
                v76 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              }
              v88 = v76;
              v89 = off_2553234C8;
              if (off_2553234C8)
              {
                v77 = (unint64_t *)((char *)off_2553234C8 + 8);
                do
                  v78 = __ldxr(v77);
                while (__stxr(v78 + 1, v77));
              }
              pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              SEUpdaterUtil::SELogObj::printLog(v76, 0, 0, 1, "getSEHealthCheckResult", (SEUpdaterUtil::SELogObj *)"Bad length for JCOP1 primary attack log indicator\n");
            }
            else
            {
              pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              v73 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              if (!off_2553234C0)
              {
                SEUpdaterUtil::SELogObj::create_default_global(&v104);
                std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v104);
                std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v104);
                v73 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
              }
              v88 = v73;
              v89 = off_2553234C8;
              if (off_2553234C8)
              {
                v74 = (unint64_t *)((char *)off_2553234C8 + 8);
                do
                  v75 = __ldxr(v74);
                while (__stxr(v75 + 1, v74));
              }
              pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
              SEUpdaterUtil::SELogObj::printLog(v73, 0, 0, 1, "getSEHealthCheckResult", (SEUpdaterUtil::SELogObj *)"Bad length for platform secondary attack log indicator\n");
            }
          }
          else
          {
            pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v70 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            if (!off_2553234C0)
            {
              SEUpdaterUtil::SELogObj::create_default_global(&v104);
              std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v104);
              std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v104);
              v70 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
            }
            v88 = v70;
            v89 = off_2553234C8;
            if (off_2553234C8)
            {
              v71 = (unint64_t *)((char *)off_2553234C8 + 8);
              do
                v72 = __ldxr(v71);
              while (__stxr(v72 + 1, v71));
            }
            pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            SEUpdaterUtil::SELogObj::printLog(v70, 0, 0, 1, "getSEHealthCheckResult", (SEUpdaterUtil::SELogObj *)"Bad length for platform primary attack log indicator\n");
          }
LABEL_158:
          v79 = (__int128 *)&v88;
          goto LABEL_159;
        }
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v65 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v104);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v104);
          std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v104);
          v65 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v88 = v65;
        v89 = off_2553234C8;
        if (off_2553234C8)
        {
          v66 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v67 = __ldxr(v66);
          while (__stxr(v67 + 1, v66));
        }
        goto LABEL_115;
      }
    }
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v52 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v90);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v90);
      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v90);
      v52 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    *(_QWORD *)&v104 = v52;
    *((_QWORD *)&v104 + 1) = off_2553234C8;
    if (off_2553234C8)
    {
      v53 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v54 = __ldxr(v53);
      while (__stxr(v54 + 1, v53));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v55 = v102[1];
    if (v55 - *v102 < 2)
      v56 = 43947;
    else
      v56 = *(unsigned __int8 *)(v55 - 1) | (*(unsigned __int8 *)(v55 - 2) << 8);
    goto LABEL_137;
  }
  SEUpdater::CommandSelectISD::CommandSelectISD((SEUpdater::CommandSelectISD *)&v90);
  v11 = (*(uint64_t (**)(_BYTE *, __int128 *, void **, uint64_t, uint64_t))(*(_QWORD *)v2 + 16))(v2, &v90, &v101, 3, 1);
  *(_QWORD *)&v90 = &unk_24E0BF880;
  v12 = (std::__shared_weak_count *)v91;
  if ((_QWORD)v91)
  {
    v13 = (unint64_t *)(v91 + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  if (v11
    || (v15 = v102[1], v15 - *v102 < 2)
    || (*(unsigned __int8 *)(v15 - 1) | (*(unsigned __int8 *)(v15 - 2) << 8)) != 0x9000)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v57 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v90);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v90);
      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v90);
      v57 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    *(_QWORD *)&v104 = v57;
    *((_QWORD *)&v104 + 1) = off_2553234C8;
    if (off_2553234C8)
    {
      v58 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v59 = __ldxr(v58);
      while (__stxr(v59 + 1, v58));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v60 = v102[1];
    if (v60 - *v102 < 2)
      v61 = 43947;
    else
      v61 = *(unsigned __int8 *)(v60 - 1) | (*(unsigned __int8 *)(v60 - 2) << 8);
    SEUpdaterUtil::SELogObj::printLog(v57, 0, 0, 1, "getSEHealthCheckResult", (SEUpdaterUtil::SELogObj *)"Failed to select ISD %d SW: %x\n", v11, v61);
    goto LABEL_138;
  }
  v16 = *((_QWORD *)this + 20);
  *(_QWORD *)&v104 = 0x4ADF02FE00CA00;
  SERestoreInfo::CApdu::CApdu(&v90, &v104, 8uLL, 0);
  *(_QWORD *)&v90 = &off_24E0C0420;
  v3 = (*(uint64_t (**)(uint64_t, __int128 *, void **, uint64_t, uint64_t))(*(_QWORD *)v16 + 16))(v16, &v90, &v101, 3, 1);
  *(_QWORD *)&v90 = &unk_24E0BF880;
  v17 = (std::__shared_weak_count *)v91;
  if ((_QWORD)v91)
  {
    v18 = (unint64_t *)(v91 + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  if (v3
    || (v20 = v102[1], v20 - *v102 < 2)
    || (*(unsigned __int8 *)(v20 - 1) | (*(unsigned __int8 *)(v20 - 2) << 8)) != 0x9000)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v52 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v90);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v90);
      std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v90);
      v52 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    *(_QWORD *)&v104 = v52;
    *((_QWORD *)&v104 + 1) = off_2553234C8;
    if (off_2553234C8)
    {
      v62 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v63 = __ldxr(v62);
      while (__stxr(v63 + 1, v62));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v64 = v102[1];
    if (v64 - *v102 < 2)
      v56 = 43947;
    else
      v56 = *(unsigned __int8 *)(v64 - 1) | (*(unsigned __int8 *)(v64 - 2) << 8);
LABEL_137:
    SEUpdaterUtil::SELogObj::printLog(v52, 0, 0, 1, "getSEHealthCheckResult", (SEUpdaterUtil::SELogObj *)"Failed to query attack log status %d SW: %x\n", v3, v56);
LABEL_138:
    v79 = &v104;
LABEL_159:
    std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)v79);
    goto LABEL_160;
  }
  v99 = 0;
  v100 = 0;
  v21 = v102[1];
  v99 = *v102;
  v22 = v21 - v99;
  if (v22 <= 1)
    __assert_rtn("getDataSize", "Apdu.hpp", 382, "len >= 2");
  v100 = v22 - 2;
  v93 = 0u;
  v94 = 0u;
  v91 = 0u;
  v92 = 0u;
  v90 = 0u;
  if (!DERParseDERSequenceSpecContent(&v99, (uint64_t)&LogStatusDataItemSeqSpec_p73, (char *)&v90, 0x50uLL))
  {
    if (*((_QWORD *)&v90 + 1) == 1)
    {
      if (*((_QWORD *)&v91 + 1) == 1)
      {
        v23 = *(unsigned __int8 *)v90;
        v24 = *(unsigned __int8 *)v91;
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v25 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v104);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v104);
          v26 = (std::__shared_weak_count *)*((_QWORD *)&v104 + 1);
          if (*((_QWORD *)&v104 + 1))
          {
            v27 = (unint64_t *)(*((_QWORD *)&v104 + 1) + 8);
            do
              v28 = __ldaxr(v27);
            while (__stlxr(v28 - 1, v27));
            if (!v28)
            {
              ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
              std::__shared_weak_count::__release_weak(v26);
            }
          }
          v25 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v29 = (std::__shared_weak_count *)off_2553234C8;
        v88 = v25;
        v89 = off_2553234C8;
        if (off_2553234C8)
        {
          v30 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v31 = __ldxr(v30);
          while (__stxr(v31 + 1, v30));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v32 = v23 == 90;
        SEUpdaterUtil::SELogObj::printLog(v25, (SEUpdaterUtil::SELogObj *)2, 0, 1, "getSEHealthCheckResult", (SEUpdaterUtil::SELogObj *)"AC Platform Primary %d Platform Secondary %d\n", v23 == 90, v24 == 90);
        if (v29)
        {
          v33 = (unint64_t *)&v29->__shared_owners_;
          do
            v34 = __ldaxr(v33);
          while (__stlxr(v34 - 1, v33));
          if (!v34)
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v29);
          }
        }
        goto LABEL_77;
      }
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v85 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v104);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v104);
        std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v104);
        v85 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v88 = v85;
      v89 = off_2553234C8;
      if (off_2553234C8)
      {
        v86 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v87 = __ldxr(v86);
        while (__stxr(v87 + 1, v86));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v85, 0, 0, 1, "getSEHealthCheckResult", (SEUpdaterUtil::SELogObj *)"Bad length for secondary attack log indicator\n");
    }
    else
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v82 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v104);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v104);
        std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v104);
        v82 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v88 = v82;
      v89 = off_2553234C8;
      if (off_2553234C8)
      {
        v83 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v84 = __ldxr(v83);
        while (__stxr(v84 + 1, v83));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v82, 0, 0, 1, "getSEHealthCheckResult", (SEUpdaterUtil::SELogObj *)"Bad length for primary attack log indicator\n");
    }
    goto LABEL_158;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v65 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v104);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v104);
    std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v104);
    v65 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v88 = v65;
  v89 = off_2553234C8;
  if (off_2553234C8)
  {
    v80 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v81 = __ldxr(v80);
    while (__stxr(v81 + 1, v80));
  }
LABEL_115:
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v65, 0, 0, 1, "getSEHealthCheckResult", (SEUpdaterUtil::SELogObj *)"Failed to parse attack log output\n");
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v88);
  v68 = *v102;
  DataSize = (const unsigned __int8 *)SERestoreInfo::RApdu::getDataSize((SERestoreInfo::RApdu *)&v101);
  SEUpdaterUtil::SELogPrintBinary(0, v68, DataSize, 0);
LABEL_160:
  v32 = 1;
LABEL_81:
  v101 = &unk_24E0BF880;
  v48 = v103;
  if (v103)
  {
    v49 = (unint64_t *)&v103->__shared_owners_;
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
  return v32;
}

void sub_21CCB8594(_Unwind_Exception *a1)
{
  uint64_t v1;

  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  *(_QWORD *)(v1 - 112) = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v1 - 104);
  _Unwind_Resume(a1);
}

void SEUpdater::CommandGetLogStatus::~CommandGetLogStatus(SEUpdater::CommandGetLogStatus *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

unint64_t SERestoreInfo::RApdu::getDataSize(SERestoreInfo::RApdu *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)(*((_QWORD *)this + 1) + 8) - **((_QWORD **)this + 1);
  if (v1 <= 1)
    __assert_rtn("getDataSize", "Apdu.hpp", 382, "len >= 2");
  return v1 - 2;
}

void SEUpdater::CommandMarkForDeleteAll::~CommandMarkForDeleteAll(SEUpdater::CommandMarkForDeleteAll *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSelectSeshat::~CommandSelectSeshat(SEUpdater::CommandSelectSeshat *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSeshatKillAllSlots::~CommandSeshatKillAllSlots(SEUpdater::CommandSeshatKillAllSlots *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::P73BaseUpdateController::deactivateAll(SEUpdater::P73BaseUpdateController *this, const char *a2)
{
  uint64_t v4;
  int v5;
  int v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  SEUpdaterUtil::SELogObj *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  SEUpdaterUtil::SELogObj *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *v38;
  SEUpdaterUtil::SELogObj *v39;
  void *v40;
  __int128 v41;
  std::__shared_weak_count *v42;
  uint64_t *v43;
  _QWORD *v44;
  std::__shared_weak_count *v45;

  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v43, 0x2037uLL);
  v43 = (uint64_t *)&unk_24E0BF828;
  v4 = *((_QWORD *)this + 20);
  SEUpdater::CommandSelectCRS::CommandSelectCRS((SEUpdater::CommandSelectCRS *)&v41);
  v5 = SEUpdater::P73BaseSEController::transceive(v4, (uint64_t)&v41, &v43, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  v6 = v5;
  *(_QWORD *)&v41 = &unk_24E0BF880;
  v7 = v42;
  if (!v42)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v42->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (v6)
      goto LABEL_26;
  }
  else
  {
LABEL_5:
    if (v5)
      goto LABEL_26;
  }
  v10 = v44[1];
  if ((unint64_t)(v10 - *v44) >= 2
    && (*(unsigned __int8 *)(v10 - 1) | (*(unsigned __int8 *)(v10 - 2) << 8)) == 0x9000)
  {
    v11 = *((_QWORD *)this + 20);
    LODWORD(v39) = 127104;
    WORD2(v39) = 20226;
    BYTE6(v39) = 0;
    SERestoreInfo::CApdu::CApdu(&v41, &v39, 7uLL, 0);
    *(_QWORD *)&v41 = &off_24E0C0540;
    v12 = SEUpdater::P73BaseSEController::transceive(v11, (uint64_t)&v41, &v43, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    *(_QWORD *)&v41 = &unk_24E0BF880;
    v13 = v42;
    if (v42)
    {
      v14 = (unint64_t *)&v42->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v16 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v41);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v41);
      v17 = (std::__shared_weak_count *)*((_QWORD *)&v41 + 1);
      if (*((_QWORD *)&v41 + 1))
      {
        v18 = (unint64_t *)(*((_QWORD *)&v41 + 1) + 8);
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      v16 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v20 = (std::__shared_weak_count *)off_2553234C8;
    v39 = v16;
    v40 = off_2553234C8;
    if (off_2553234C8)
    {
      v21 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v22 = __ldxr(v21);
      while (__stxr(v22 + 1, v21));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v23 = v44[1];
    if ((unint64_t)(v23 - *v44) < 2)
      v24 = 43947;
    else
      v24 = *(unsigned __int8 *)(v23 - 1) | (*(unsigned __int8 *)(v23 - 2) << 8);
    SEUpdaterUtil::SELogObj::printLog(v16, (SEUpdaterUtil::SELogObj *)2, 0, 1, "deactivateAll", (SEUpdaterUtil::SELogObj *)"DeactivateAll for %s ret %d SW 0x%hx\n", a2, v12, v24);
    if (v20)
    {
      v38 = (unint64_t *)&v20->__shared_owners_;
      do
        v34 = __ldaxr(v38);
      while (__stlxr(v34 - 1, v38));
      goto LABEL_42;
    }
    goto LABEL_44;
  }
LABEL_26:
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v25 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v41);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v41);
    v26 = (std::__shared_weak_count *)*((_QWORD *)&v41 + 1);
    if (*((_QWORD *)&v41 + 1))
    {
      v27 = (unint64_t *)(*((_QWORD *)&v41 + 1) + 8);
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v25 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v20 = (std::__shared_weak_count *)off_2553234C8;
  v39 = v25;
  v40 = off_2553234C8;
  if (off_2553234C8)
  {
    v29 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v31 = v44[1];
  if ((unint64_t)(v31 - *v44) < 2)
    v32 = 43947;
  else
    v32 = *(unsigned __int8 *)(v31 - 1) | (*(unsigned __int8 *)(v31 - 2) << 8);
  SEUpdaterUtil::SELogObj::printLog(v25, (SEUpdaterUtil::SELogObj *)1, 0, 1, "deactivateAll", (SEUpdaterUtil::SELogObj *)"DeactivateAll for %s failed to SELECT CRS %d SW 0x%hx\n", a2, v6, v32);
  if (v20)
  {
    v33 = (unint64_t *)&v20->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
LABEL_42:
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
LABEL_44:
  v43 = (uint64_t *)&unk_24E0BF880;
  v35 = v45;
  if (v45)
  {
    v36 = (unint64_t *)&v45->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
}

void sub_21CCB8CFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  *(_QWORD *)(v1 - 72) = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v1 - 64);
  _Unwind_Resume(a1);
}

void SEUpdater::CommandCRSDeactivateAll::~CommandCRSDeactivateAll(SEUpdater::CommandCRSDeactivateAll *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandCRSGetDataPersoState::~CommandCRSGetDataPersoState(SEUpdater::CommandCRSGetDataPersoState *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

uint64_t SEUpdater::getForceUpdateLoop(uint64_t **a1)
{
  uint64_t v2;
  unint64_t v3;
  _OWORD *v4;
  uint64_t v5;
  _OWORD *v6;
  char *v7;
  void *v9[2];
  char v10;
  std::string __p;
  void **v12;

  std::string::basic_string[abi:ne180100]<0>(&__p, "forceUpdate");
  v2 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)a1, (const void **)&__p.__r_.__value_.__l.__data_);
  v3 = v2;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (!v3)
      return v3;
  }
  else if (!v2)
  {
    return v3;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "forceUpdate");
  v9[0] = &__p;
  v4 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, (_OWORD **)v9);
  if (*((char *)v4 + 79) < 0)
    v5 = *((_QWORD *)v4 + 8);
  else
    v5 = *((unsigned __int8 *)v4 + 79);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v5)
      goto LABEL_10;
    return 1;
  }
  if (!v5)
    return 1;
LABEL_10:
  std::string::basic_string[abi:ne180100]<0>(v9, "forceUpdate");
  v12 = v9;
  v6 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, (const void **)v9, (uint64_t)&std::piecewise_construct, (_OWORD **)&v12);
  v7 = (char *)v6 + 56;
  if (*((char *)v6 + 79) < 0)
    v7 = *(char **)v7;
  std::string::basic_string[abi:ne180100]<0>(&__p, v7);
  v3 = std::stoul(&__p, 0, 10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v10 < 0)
    operator delete(v9[0]);
  return v3;
}

#error "21CCB908C: call analysis failed (funcsize=72)"

void SEUpdater::P73BaseUpdateController::PerformSLAMMigrations(SEUpdater::P73BaseUpdateController *this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  _BOOL4 isDev;
  int v9;
  char v10;
  _WORD *v11;
  char *v12;
  _WORD *v13;
  char *v14;
  _WORD *v15;
  _DWORD *v16;
  _OWORD *v17;
  _DWORD *v18;
  _DWORD *v19;
  _WORD *v20;
  char *v21;
  _WORD *v22;
  _DWORD *v23;
  char *v24;
  _DWORD *v25;
  char *v26;
  _DWORD *v27;
  _WORD *v28;
  _DWORD *v29;
  _WORD *v30;
  _OWORD *v31;
  _DWORD *v32;
  char *v33;
  _WORD *v34;
  _OWORD *v35;
  _DWORD *v36;
  uint64_t v37;
  const char **v38;
  std::vector<std::string> *v39;
  std::string *value;
  std::vector<std::string>::pointer end;
  const char **v42;
  int64_t v43;
  unint64_t v44;
  const char *v45;
  uint64_t v46;
  std::string *v47;
  char *v48;
  char *v49;
  char *v50;
  __int128 v51;
  std::vector<std::string> *v52;
  std::vector<std::string>::pointer v53;
  uint64_t i;
  uint64_t j;
  char *v56;
  char *v57;
  char *v58;
  const char **v59;
  const char **v60;
  char v61;
  uint64_t v62;
  unsigned __int8 v63;
  void *v64;
  uint64_t v65;
  const void *v66;
  uint64_t v67;
  const void *v68;
  size_t v69;
  unint64_t v70;
  BOOL v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v76;
  unint64_t v77;
  SEUpdaterUtil::SELogObj *v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  std::__shared_weak_count *v82;
  unint64_t *v83;
  unint64_t v84;
  std::vector<std::string>::pointer begin;
  unint64_t *v86;
  unint64_t v87;
  SEUpdaterUtil::SELogObj *v88;
  std::__shared_weak_count *v89;
  unint64_t *v90;
  unint64_t v91;
  std::__shared_weak_count *v92;
  unint64_t *v93;
  unint64_t v94;
  std::vector<std::string>::pointer v95;
  unint64_t *v96;
  unint64_t v97;
  SEUpdaterUtil::SELogObj *v98;
  std::__shared_weak_count *v99;
  unint64_t *v100;
  unint64_t v101;
  std::__shared_weak_count *v102;
  unint64_t *v103;
  unint64_t v104;
  unint64_t *v105;
  unint64_t v106;
  SEUpdaterUtil::SELogObj *v107;
  std::__shared_weak_count *v108;
  unint64_t *v109;
  unint64_t v110;
  std::__shared_weak_count *v111;
  unint64_t *v112;
  unint64_t v113;
  unint64_t *v114;
  unint64_t v115;
  std::vector<std::string>::pointer v116;
  std::vector<std::string>::pointer v117;
  unint64_t *v118;
  unint64_t *v119;
  unint64_t *v120;
  unint64_t v121;
  unint64_t v122;
  SEUpdaterUtil::SELogObj *v123;
  std::__shared_weak_count *v124;
  unint64_t *p_size;
  unint64_t v126;
  std::__shared_weak_count *v127;
  unint64_t *v128;
  unint64_t v129;
  unint64_t *v130;
  unint64_t v131;
  SEUpdaterUtil::SELogObj *v132;
  std::__shared_weak_count *v133;
  unint64_t *v134;
  unint64_t v135;
  unint64_t *v136;
  unint64_t v137;
  unint64_t *v138;
  int v139;
  SEUpdaterUtil::SELogObj *v140;
  std::__shared_weak_count *v141;
  unint64_t *v142;
  unint64_t v143;
  unint64_t *v144;
  unint64_t v145;
  unint64_t *v146;
  SEUpdaterUtil::SELogObj *v147;
  std::__shared_weak_count *v148;
  unint64_t *v149;
  unint64_t v150;
  unint64_t *v151;
  unint64_t v152;
  unint64_t *v153;
  unint64_t v154;
  unint64_t v155;
  std::__shared_weak_count *v156;
  unint64_t *v157;
  unint64_t v158;
  std::__shared_weak_count *v159;
  unint64_t *v160;
  unint64_t v161;
  std::__shared_weak_count *v162;
  unint64_t *v163;
  unint64_t v164;
  std::__shared_weak_count *v165;
  unint64_t *v166;
  unint64_t v167;
  void *v168;
  std::__shared_weak_count *size;
  unint64_t *v170;
  unint64_t v171;
  std::__shared_weak_count *v172;
  unint64_t *v173;
  unint64_t v174;
  unint64_t *v175;
  unint64_t v176;
  std::__shared_weak_count *v177;
  unint64_t *v178;
  unint64_t v179;
  char *v180;
  char *v181;
  void *v182;
  std::__shared_weak_count *v183;
  unint64_t *v184;
  unint64_t v185;
  std::__shared_weak_count *v186;
  unint64_t *v187;
  unint64_t v188;
  unint64_t *v189;
  void *exception;
  std::string *v191;
  __int128 v192;
  void *v193;
  std::__shared_weak_count *v194;
  unint64_t *v195;
  unint64_t v196;
  unint64_t v197;
  void *v198;
  std::__shared_weak_count *v199;
  unint64_t *v200;
  unint64_t v201;
  unint64_t v202;
  void *v203;
  std::vector<std::string> *v204;
  void *v205;
  SEUpdater::P73BaseUpdateController *v206;
  char v207;
  const char **v208;
  char v209;
  const char **v210;
  _BOOL4 v211;
  const char *v212;
  uint64_t v213;
  std::__shared_weak_count *v214;
  _QWORD v215[2];
  void *v216;
  std::__shared_weak_count *v217;
  _QWORD v218[2];
  void *v219;
  std::__shared_weak_count *v220;
  _BYTE v221[32];
  _QWORD *v222;
  std::__shared_weak_count *v223;
  _QWORD *v224;
  std::__shared_weak_count *v225;
  std::vector<std::string>::pointer v226;
  std::__shared_weak_count *v227;
  std::vector<std::string>::pointer v228;
  std::__shared_weak_count *v229;
  void *v230[2];
  char v231;
  const char **v232;
  const char **v233;
  char *v234;
  uint64_t v235;
  std::__shared_weak_count *v236;
  void *v237[2];
  _QWORD v238[3];
  char v239;
  char **v240;
  const char ***v241;
  _QWORD *v242;
  char v243;
  const char **v244;
  _QWORD v245[2];
  char v246;
  void *v247;
  void *v248;
  _OWORD *v249;
  void *__p;
  void *v251;
  char *v252;
  __int128 v253;
  char v254;
  void *v255;
  void *v256;
  char *v257;
  void *v258;
  void *v259;
  char *v260;
  __int128 v261;
  char v262;
  void *v263;
  void *v264;
  _OWORD *v265;
  void *v266;
  void *v267;
  char *v268;
  char v269;
  char v270;
  void *v271;
  void *v272;
  char *v273;
  void *v274;
  void *v275;
  char *v276;
  __int128 v277;
  char v278;
  void *v279;
  void *v280;
  char *v281;
  void *v282;
  void *v283;
  char *v284;
  char v285;
  char v286;
  void *v287;
  void *v288;
  char *v289;
  void *v290;
  void *v291;
  char *v292;
  __int128 v293;
  char v294;
  std::string v295;
  _WORD *v296;
  char *v297;
  char *v298;
  __int128 v299;
  char v300;
  _DWORD *v301;
  char *v302;
  char *v303;
  char *v304;
  char *v305;
  char *v306;
  __int128 v307;
  char v308;
  uint64_t v309;
  void *v310;
  void *v311;
  char *v312;
  void *v313;
  void *v314;
  char *v315;
  __int128 v316;
  char v317;
  void *v318;
  void *v319;
  _OWORD *v320;
  void *v321;
  void *v322;
  char *v323;
  __int128 v324;
  char v325;
  void *v326;
  void *v327;
  char *v328;
  void *v329;
  void *v330;
  char *v331;
  char v332;
  char v333;
  void *v334;
  std::__shared_weak_count *v335;
  char *v336;
  void *v337;
  void *v338;
  char *v339;
  char v340;
  char v341;
  void *v342;
  std::__shared_weak_count *v343;
  char *v344;
  void *v345;
  void *v346;
  char *v347;
  char v348;
  char v349;
  std::vector<std::string> v350;
  std::vector<std::string>::pointer v351;
  const char *v352;
  __int16 v353;
  const char *v354;
  char *v355;
  uint64_t v356;
  char *v357;
  const char *v358;
  __int16 v359;
  const char *v360;
  char *v361;
  uint64_t v362;
  char *v363;
  const char *v364;
  __int16 v365;
  const char *v366;
  char *v367;
  uint64_t v368;
  char *v369;
  const char *v370;
  __int16 v371;
  const char *v372;
  char *v373;
  uint64_t v374;
  char *v375;
  const char *v376;
  __int16 v377;
  const char *v378;
  char *v379;
  uint64_t v380;
  char *v381;
  const char *v382;
  __int16 v383;
  const char *v384;
  char *v385;
  uint64_t v386;
  char *v387;
  const char *v388;
  __int16 v389;
  const char *v390;
  char *v391;
  uint64_t v392;
  char *v393;
  const char *v394;
  __int16 v395;
  const char *v396;
  char *v397;
  uint64_t v398;
  char *v399;
  const char *v400;
  __int16 v401;
  const char *v402;
  char *v403;
  uint64_t v404;
  char *v405;
  const char *v406;
  __int16 v407;
  const char *v408;
  char *v409;
  uint64_t v410;
  char *v411;
  const char *v412;
  __int16 v413;
  const char *v414;
  char *v415;
  uint64_t v416;
  char *v417;
  const char *v418;
  __int16 v419;
  uint64_t v420;

  v420 = *MEMORY[0x24BDAC8D0];
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
  v235 = *((_QWORD *)this + 20);
  v236 = v2;
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  SEUpdater::GetPackageInfo(&v235, (std::string::size_type *)v237);
  v5 = v236;
  if (v236)
  {
    v6 = (unint64_t *)&v236->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  isDev = SERestoreInfo::P73BaseDeviceInfo::isDev(*((SERestoreInfo::P73BaseDeviceInfo **)this + 16));
  v9 = *(_DWORD *)(*((_QWORD *)this + 16) + 56);
  v209 = 1;
  if (v9 <= 114)
  {
    if (v9 == 44)
    {
      v10 = 2;
      goto LABEL_18;
    }
    if (v9 == 100)
      goto LABEL_19;
LABEL_16:
    v10 = 4;
LABEL_18:
    v209 = v10;
    goto LABEL_19;
  }
  if (v9 != 115 && v9 != 200 && v9 != 210)
    goto LABEL_16;
LABEL_19:
  v350.__begin_ = (std::vector<std::string>::pointer)"Slalom Dev SLAM";
  v11 = operator new(0xAuLL);
  v344 = (char *)(v11 + 5);
  *(_QWORD *)v11 = 0x1FF0180060000A0;
  v11[4] = 257;
  v342 = v11;
  v343 = (std::__shared_weak_count *)(v11 + 5);
  v12 = (char *)operator new(9uLL);
  v347 = v12 + 9;
  *(_QWORD *)v12 = 0x6FF0180060000A0;
  v12[8] = 45;
  v345 = v12;
  v346 = v12 + 9;
  v348 = 0;
  v349 = 0;
  v350.__end_cap_.__value_ = 0;
  v351 = 0;
  v350.__end_ = 0;
  v295.__r_.__value_.__r.__words[0] = (std::string::size_type)&v350.__end_;
  v295.__r_.__value_.__s.__data_[8] = 0;
  v206 = this;
  v350.__end_ = (std::vector<std::string>::pointer)operator new(0x48uLL);
  v350.__end_cap_.__value_ = v350.__end_;
  v351 = v350.__end_ + 3;
  v350.__end_cap_.__value_ = (std::string *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v342, (uint64_t)&v350, (uint64_t)v350.__end_);
  v352 = "SLAMSlalomMigration_14_3_0";
  v353 = 257;
  v354 = "Slalom Prod SLAM";
  v13 = operator new(0xAuLL);
  *(_QWORD *)v13 = 0x1000180060000A0;
  v13[4] = 257;
  v334 = v13;
  v335 = (std::__shared_weak_count *)(v13 + 5);
  v336 = (char *)(v13 + 5);
  v337 = 0;
  v339 = 0;
  v338 = 0;
  v14 = (char *)operator new(9uLL);
  v339 = v14 + 9;
  *(_QWORD *)v14 = 0x6000180060000A0;
  v14[8] = 45;
  v337 = v14;
  v338 = v14 + 9;
  v340 = 0;
  v341 = 0;
  v356 = 0;
  v357 = 0;
  v355 = 0;
  v295.__r_.__value_.__r.__words[0] = (std::string::size_type)&v355;
  v295.__r_.__value_.__s.__data_[8] = 0;
  v355 = (char *)operator new(0x48uLL);
  v356 = (uint64_t)v355;
  v357 = v355 + 72;
  v356 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v334, (uint64_t)&v342, (uint64_t)v355);
  v358 = "SLAMSlalomMigration_14_3_0";
  v359 = 258;
  v360 = "Seos SLAM";
  v15 = operator new(0xAuLL);
  *(_QWORD *)v15 = 0x1010040040000A0;
  v15[4] = 256;
  v326 = v15;
  v327 = v15 + 5;
  v328 = (char *)(v15 + 5);
  v329 = 0;
  v331 = 0;
  v330 = 0;
  v16 = operator new(0xCuLL);
  v331 = (char *)(v16 + 3);
  *(_QWORD *)v16 = 0x10040040000A0;
  v16[2] = 100729088;
  v329 = v16;
  v330 = v16 + 3;
  v332 = 0;
  v333 = 0;
  v362 = 0;
  v363 = 0;
  v361 = 0;
  v295.__r_.__value_.__r.__words[0] = (std::string::size_type)&v361;
  v295.__r_.__value_.__s.__data_[8] = 0;
  v361 = (char *)operator new(0x48uLL);
  v362 = (uint64_t)v361;
  v363 = v361 + 72;
  v362 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v326, (uint64_t)&v334, (uint64_t)v361);
  v364 = "SLAMSeosMigration_1_2_4";
  v365 = 259;
  v366 = "MIFARE DESFire SLAM";
  v17 = operator new(0x10uLL);
  *v17 = xmmword_21CCD8A80;
  v318 = v17;
  v319 = v17 + 1;
  v320 = v17 + 1;
  v321 = 0;
  v323 = 0;
  v322 = 0;
  v18 = operator new(0xFuLL);
  v323 = (char *)v18 + 15;
  *(_QWORD *)v18 = 0x535496030000A0;
  v18[2] = 16842752;
  *((_WORD *)v18 + 6) = 4688;
  *((_BYTE *)v18 + 14) = 0;
  v321 = v18;
  v322 = (char *)v18 + 15;
  v324 = SLAM::Migration::versionLocationMIFARE;
  v325 = 1;
  v368 = 0;
  v369 = 0;
  v367 = 0;
  v295.__r_.__value_.__r.__words[0] = (std::string::size_type)&v367;
  v295.__r_.__value_.__s.__data_[8] = 0;
  v367 = (char *)operator new(0x48uLL);
  v368 = (uint64_t)v367;
  v369 = v367 + 72;
  v368 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v318, (uint64_t)&v326, (uint64_t)v367);
  v370 = "SLAMDESFireMigration_1_0_23";
  v371 = 771;
  v372 = "Luau SLAM";
  v19 = operator new(0xCuLL);
  *(_QWORD *)v19 = 0x10104070000A0;
  v19[2] = 256;
  v310 = v19;
  v311 = v19 + 3;
  v312 = (char *)(v19 + 3);
  v313 = 0;
  v315 = 0;
  v314 = 0;
  v20 = operator new(0xBuLL);
  v315 = (char *)v20 + 11;
  *(_QWORD *)v20 = 0x30010104070000A0;
  v20[4] = 1298;
  *((_BYTE *)v20 + 10) = 0;
  v313 = v20;
  v314 = (char *)v20 + 11;
  v316 = SLAM::Migration::versionLocationIron;
  v317 = 1;
  v374 = 0;
  v375 = 0;
  v373 = 0;
  v295.__r_.__value_.__r.__words[0] = (std::string::size_type)&v373;
  v295.__r_.__value_.__s.__data_[8] = 0;
  v373 = (char *)operator new(0x48uLL);
  v374 = (uint64_t)v373;
  v375 = v373 + 72;
  v374 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v310, (uint64_t)&v318, (uint64_t)v373);
  v376 = "SLAMLuauMigration_1_2_0_5";
  v377 = 259;
  v378 = "Copernicus + Sunsprite SLAM";
  v21 = (char *)operator new(0xAuLL);
  *(_DWORD *)v21 = 117440672;
  *((_WORD *)v21 + 2) = -8188;
  *(_DWORD *)(v21 + 6) = 0;
  v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
  v295.__r_.__value_.__l.__size_ = (std::string::size_type)(v21 + 10);
  v295.__r_.__value_.__r.__words[2] = (std::string::size_type)(v21 + 10);
  v296 = 0;
  v298 = 0;
  v297 = 0;
  v22 = operator new(0xAuLL);
  v298 = (char *)(v22 + 5);
  *(_QWORD *)v22 = 0x200E004070000A0;
  v22[4] = 1793;
  v296 = v22;
  v297 = (char *)(v22 + 5);
  v299 = SLAM::Migration::versionLocationSunsprite;
  v300 = 1;
  v303 = 0;
  v301 = 0;
  v302 = 0;
  v23 = operator new(0x10uLL);
  *(_QWORD *)v23 = 0x5011D004070000A0;
  v23[2] = 0;
  v23[3] = 1;
  v301 = v23;
  v302 = (char *)(v23 + 4);
  v303 = (char *)(v23 + 4);
  v304 = 0;
  v306 = 0;
  v305 = 0;
  v24 = (char *)operator new(0x10uLL);
  v306 = v24 + 16;
  *(_QWORD *)v24 = 0x5011D004070000A0;
  *((_DWORD *)v24 + 2) = 0;
  v24[12] = 0;
  *(_WORD *)(v24 + 13) = 514;
  v24[15] = 8;
  v304 = v24;
  v305 = v24 + 16;
  v307 = SLAM::Migration::versionLocationCopernicus;
  v308 = 1;
  v380 = 0;
  v381 = 0;
  v379 = 0;
  v287 = &v379;
  LOBYTE(v288) = 0;
  v379 = (char *)operator new(0x90uLL);
  v380 = (uint64_t)v379;
  v381 = v379 + 144;
  v380 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v295, (uint64_t)&v309, (uint64_t)v379);
  v382 = "SLAMMigrateCopernicus_2_2_8_LoadAndInstallSunsprite_2_1_7";
  v383 = 1795;
  v384 = "Copernicus SLAM";
  v25 = operator new(0x10uLL);
  *(_QWORD *)v25 = 0x5011D004070000A0;
  v25[2] = 0;
  v25[3] = 1;
  v287 = v25;
  v288 = v25 + 4;
  v289 = (char *)(v25 + 4);
  v290 = 0;
  v292 = 0;
  v291 = 0;
  v26 = (char *)operator new(0x10uLL);
  v292 = v26 + 16;
  *(_QWORD *)v26 = 0x5011D004070000A0;
  *((_DWORD *)v26 + 2) = 0;
  v26[12] = 0;
  *(_WORD *)(v26 + 13) = 514;
  v26[15] = 8;
  v290 = v26;
  v291 = v26 + 16;
  v293 = SLAM::Migration::versionLocationCopernicus;
  v294 = 1;
  v386 = 0;
  v387 = 0;
  v385 = 0;
  v279 = &v385;
  LOBYTE(v280) = 0;
  v385 = (char *)operator new(0x48uLL);
  v386 = (uint64_t)v385;
  v387 = v385 + 72;
  v386 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v287, (uint64_t)&v295, (uint64_t)v385);
  v388 = "SLAMMigrateCopernicus_2_2_8";
  v389 = 1795;
  v390 = "Haishan SLAM";
  v27 = operator new(0xCuLL);
  *(_QWORD *)v27 = 0x1A004070000A0;
  v27[2] = 16777488;
  v279 = v27;
  v280 = v27 + 3;
  v281 = (char *)(v27 + 3);
  v282 = 0;
  v284 = 0;
  v283 = 0;
  v28 = operator new(0xBuLL);
  v284 = (char *)v28 + 11;
  *(_QWORD *)v28 = 0x2001A004070000A0;
  v28[4] = 1810;
  *((_BYTE *)v28 + 10) = 0;
  v282 = v28;
  v283 = (char *)v28 + 11;
  v285 = 0;
  v286 = 0;
  v392 = 0;
  v393 = 0;
  v391 = 0;
  v271 = &v391;
  LOBYTE(v272) = 0;
  v391 = (char *)operator new(0x48uLL);
  v392 = (uint64_t)v391;
  v393 = v391 + 72;
  v392 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v279, (uint64_t)&v287, (uint64_t)v391);
  v394 = "SLAMMigrateHaishan_1_2_07";
  v395 = 259;
  v396 = "Iron SLAM";
  v29 = operator new(0xCuLL);
  *(_QWORD *)v29 = 0x20204070000A0;
  v29[2] = 256;
  v271 = v29;
  v272 = v29 + 3;
  v273 = (char *)(v29 + 3);
  v274 = 0;
  v276 = 0;
  v275 = 0;
  v30 = operator new(0xBuLL);
  v276 = (char *)v30 + 11;
  *(_QWORD *)v30 = 0x1140204070000A0;
  v30[4] = 4896;
  *((_BYTE *)v30 + 10) = 0;
  v274 = v30;
  v275 = (char *)v30 + 11;
  v277 = SLAM::Migration::versionLocationIron;
  v278 = 1;
  v398 = 0;
  v399 = 0;
  v397 = 0;
  v263 = &v397;
  LOBYTE(v264) = 0;
  v397 = (char *)operator new(0x48uLL);
  v398 = (uint64_t)v397;
  v399 = v397 + 72;
  v398 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v271, (uint64_t)&v279, (uint64_t)v397);
  v400 = "SLAMMigrateIron_2_0_13";
  v401 = 259;
  v402 = "Neon SLAM";
  v31 = operator new(0x10uLL);
  *v31 = xmmword_21CCD8A60;
  v263 = v31;
  v264 = v31 + 1;
  v265 = v31 + 1;
  v266 = 0;
  v268 = 0;
  v267 = 0;
  v32 = operator new(0xFuLL);
  v268 = (char *)v32 + 15;
  *(_QWORD *)v32 = 0x535477000000A0;
  v32[2] = 0x10000;
  *((_WORD *)v32 + 6) = 7693;
  *((_BYTE *)v32 + 14) = 0;
  v266 = v32;
  v267 = (char *)v32 + 15;
  v269 = 0;
  v270 = 0;
  v404 = 0;
  v405 = 0;
  v403 = 0;
  v255 = &v403;
  LOBYTE(v256) = 0;
  v403 = (char *)operator new(0x48uLL);
  v404 = (uint64_t)v403;
  v405 = v403 + 72;
  v404 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v263, (uint64_t)&v271, (uint64_t)v403);
  v406 = "SLAMMigrateNeon_YK300R107";
  v407 = 771;
  v408 = "PTC SLAM";
  v33 = (char *)operator new(0xCuLL);
  *(_DWORD *)v33 = 117440672;
  *((_WORD *)v33 + 2) = -16380;
  *(_DWORD *)(v33 + 6) = 0;
  *((_WORD *)v33 + 5) = 256;
  v255 = v33;
  v256 = v33 + 12;
  v257 = v33 + 12;
  v258 = 0;
  v260 = 0;
  v259 = 0;
  v34 = operator new(0xBuLL);
  v260 = (char *)v34 + 11;
  *(_QWORD *)v34 = 0x502C004070000A0;
  v34[4] = 771;
  *((_BYTE *)v34 + 10) = 3;
  v258 = v34;
  v259 = (char *)v34 + 11;
  v261 = SLAM::Migration::versionLocationPTC;
  v262 = 1;
  v410 = 0;
  v411 = 0;
  v409 = 0;
  v247 = &v409;
  LOBYTE(v248) = 0;
  v409 = (char *)operator new(0x48uLL);
  v410 = (uint64_t)v409;
  v411 = v409 + 72;
  v410 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v255, (uint64_t)&v263, (uint64_t)v409);
  v412 = "SLAMMigratePTC";
  v413 = 1027;
  v414 = "Sodium SLAM";
  v35 = operator new(0x10uLL);
  *v35 = xmmword_21CCD8A90;
  v247 = v35;
  v248 = v35 + 1;
  v249 = v35 + 1;
  __p = 0;
  v251 = 0;
  v252 = 0;
  v36 = operator new(0xFuLL);
  v251 = (char *)v36 + 15;
  v252 = (char *)v36 + 15;
  *(_QWORD *)v36 = 0x535496030000A0;
  v36[2] = 0x10000;
  *((_WORD *)v36 + 6) = 4362;
  *((_BYTE *)v36 + 14) = 0;
  __p = v36;
  v253 = SLAM::Migration::versionLocationSodium;
  v254 = 1;
  v416 = 0;
  v417 = 0;
  v415 = 0;
  v240 = &v415;
  LOBYTE(v241) = 0;
  v415 = (char *)operator new(0x48uLL);
  v416 = (uint64_t)v415;
  v417 = v415 + 72;
  v211 = isDev;
  v416 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>((uint64_t)&v247, (uint64_t)&v255, (uint64_t)v415);
  v418 = "SLAMMigrateSodium_1_0_12";
  v419 = 1795;
  v233 = 0;
  v234 = 0;
  v232 = 0;
  v238[2] = &v232;
  v239 = 0;
  v37 = 0;
  v232 = (const char **)operator new(0x240uLL);
  v233 = v232;
  v234 = (char *)(v232 + 72);
  v244 = v232;
  v245[0] = v232;
  v240 = &v234;
  v241 = &v244;
  v242 = v245;
  v38 = v232;
  v243 = 0;
  do
  {
    v39 = &v350 + 2 * v37;
    *v38 = (const char *)v39->__begin_;
    v38[2] = 0;
    v38[3] = 0;
    v38[1] = 0;
    end = v39->__end_;
    value = v39->__end_cap_.__value_;
    v245[1] = v38 + 1;
    v246 = 0;
    v42 = v38;
    v43 = (char *)value - (char *)end;
    if (value != end)
    {
      v44 = 0x8E38E38E38E38E39 * (v43 >> 3);
      if (v44 >= 0x38E38E38E38E38FLL)
        std::vector<std::string>::__throw_length_error[abi:ne180100]();
      v45 = (const char *)operator new(v43);
      v46 = 0;
      v38[1] = v45;
      v38[2] = v45;
      v38[3] = &v45[72 * v44];
      do
      {
        v47 = &end[v46];
        v48 = (char *)&v45[v46 * 24];
        *(_QWORD *)v48 = 0;
        *((_QWORD *)v48 + 1) = 0;
        *((_QWORD *)v48 + 2) = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v45[v46 * 24], end[v46].__r_.__value_.__l.__data_, end[v46].__r_.__value_.__l.__size_, end[v46].__r_.__value_.__l.__size_ - end[v46].__r_.__value_.__r.__words[0]);
        *((_QWORD *)v48 + 3) = 0;
        *((_QWORD *)v48 + 4) = 0;
        v49 = (char *)&v45[v46 * 24 + 24];
        *((_QWORD *)v49 + 2) = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v49, v47[1].__r_.__value_.__l.__data_, v47[1].__r_.__value_.__l.__size_, v47[1].__r_.__value_.__l.__size_ - v47[1].__r_.__value_.__r.__words[0]);
        v50 = (char *)&v45[v46 * 24];
        v51 = *(_OWORD *)&end[v46 + 2].__r_.__value_.__l.__data_;
        *((_QWORD *)v50 + 8) = *((_QWORD *)&end[v46 + 2].__r_.__value_.__l + 2);
        *((_OWORD *)v50 + 3) = v51;
        v46 += 3;
      }
      while (&v47[3] != value);
      v42 = (const char **)v245[0];
      v38[2] = &v45[v46 * 24];
    }
    v52 = &v350 + 2 * v37;
    v53 = v52[1].__end_;
    *((_WORD *)v38 + 20) = v52[1].__end_cap_.__value_;
    v38[4] = (const char *)v53;
    ++v37;
    v38 = v42 + 6;
    v245[0] = v42 + 6;
  }
  while (v37 != 12);
  v243 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<SLAM::Migration::Trigger>,SLAM::Migration::Trigger*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&v240);
  v233 = v38;
  for (i = 536; i != -40; i -= 48)
  {
    v240 = (char **)((char *)&v350 + i);
    std::vector<SLAM::Migration::AppletInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v240);
  }
  if (__p)
  {
    v251 = __p;
    operator delete(__p);
  }
  if (v247)
  {
    v248 = v247;
    operator delete(v247);
  }
  if (v258)
  {
    v259 = v258;
    operator delete(v258);
  }
  if (v255)
  {
    v256 = v255;
    operator delete(v255);
  }
  if (v266)
  {
    v267 = v266;
    operator delete(v266);
  }
  if (v263)
  {
    v264 = v263;
    operator delete(v263);
  }
  if (v274)
  {
    v275 = v274;
    operator delete(v274);
  }
  if (v271)
  {
    v272 = v271;
    operator delete(v271);
  }
  if (v282)
  {
    v283 = v282;
    operator delete(v282);
  }
  if (v279)
  {
    v280 = v279;
    operator delete(v279);
  }
  if (v290)
  {
    v291 = v290;
    operator delete(v290);
  }
  if (v287)
  {
    v288 = v287;
    operator delete(v287);
  }
  for (j = 0; j != -18; j -= 9)
  {
    v56 = (char *)&v295 + j * 8;
    v57 = (&v304)[j];
    if (v57)
    {
      *((_QWORD *)v56 + 13) = v57;
      operator delete(v57);
    }
    v58 = (char *)*((_QWORD *)v56 + 9);
    if (v58)
    {
      (&v302)[j] = v58;
      operator delete(v58);
    }
  }
  if (v313)
  {
    v314 = v313;
    operator delete(v313);
  }
  if (v310)
  {
    v311 = v310;
    operator delete(v310);
  }
  if (v321)
  {
    v322 = v321;
    operator delete(v321);
  }
  if (v318)
  {
    v319 = v318;
    operator delete(v318);
  }
  if (v329)
  {
    v330 = v329;
    operator delete(v329);
  }
  if (v326)
  {
    v327 = v326;
    operator delete(v326);
  }
  if (v337)
  {
    v338 = v337;
    operator delete(v337);
  }
  if (v334)
  {
    v335 = (std::__shared_weak_count *)v334;
    operator delete(v334);
  }
  if (v345)
  {
    v346 = v345;
    operator delete(v345);
  }
  if (v342)
  {
    v343 = (std::__shared_weak_count *)v342;
    operator delete(v342);
  }
  v59 = v232;
  v60 = v233;
  if (v232 == v233)
    goto LABEL_308;
  if (v211)
    v61 = 1;
  else
    v61 = 2;
  v208 = v233;
  v207 = v61;
  do
  {
    if ((v61 & (_BYTE)v59[5]) == 0)
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v123 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v350);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v350);
        v124 = (std::__shared_weak_count *)v350.__end_;
        if (v350.__end_)
        {
          p_size = &v350.__end_->__r_.__value_.__l.__size_;
          do
            v126 = __ldaxr(p_size);
          while (__stlxr(v126 - 1, p_size));
          if (!v126)
          {
            ((void (*)(std::__shared_weak_count *))v124->__on_zero_shared)(v124);
            std::__shared_weak_count::__release_weak(v124);
          }
        }
        v123 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v127 = (std::__shared_weak_count *)off_2553234C8;
      v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v123;
      v295.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v128 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v129 = __ldxr(v128);
        while (__stxr(v129 + 1, v128));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v123, (SEUpdaterUtil::SELogObj *)2, 0, 1, "PerformSLAMMigrations", (SEUpdaterUtil::SELogObj *)"Skipping MP <%s> by key\n", *v59);
      if (v127)
      {
        v130 = (unint64_t *)&v127->__shared_owners_;
        do
          v131 = __ldaxr(v130);
        while (__stlxr(v131 - 1, v130));
        goto LABEL_235;
      }
      goto LABEL_237;
    }
    if ((*((_BYTE *)v59 + 41) & v209) == 0)
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v132 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v350);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v350);
        v133 = (std::__shared_weak_count *)v350.__end_;
        if (v350.__end_)
        {
          v134 = &v350.__end_->__r_.__value_.__l.__size_;
          do
            v135 = __ldaxr(v134);
          while (__stlxr(v135 - 1, v134));
          if (!v135)
          {
            ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
            std::__shared_weak_count::__release_weak(v133);
          }
        }
        v132 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v127 = (std::__shared_weak_count *)off_2553234C8;
      v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v132;
      v295.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v136 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v137 = __ldxr(v136);
        while (__stxr(v137 + 1, v136));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v132, (SEUpdaterUtil::SELogObj *)2, 0, 1, "PerformSLAMMigrations", (SEUpdaterUtil::SELogObj *)"SLAM unavailable for MP <%s> on current platform\n", *v59);
      if (v127)
      {
        v138 = (unint64_t *)&v127->__shared_owners_;
        do
          v131 = __ldaxr(v138);
        while (__stlxr(v131 - 1, v138));
        goto LABEL_235;
      }
      goto LABEL_237;
    }
    v62 = (uint64_t)v59[1];
    v210 = v59;
    v212 = v59[2];
    if ((const char *)v62 == v212)
    {
      v139 = 0;
      v63 = 0;
      goto LABEL_222;
    }
    v63 = 0;
    do
    {
      v64 = v237[1];
      v65 = SEUpdater::find_if<std::vector<SEUpdater::PackageInfo>,SEUpdater::FindPackageForModule(std::vector<SEUpdater::PackageInfo> const&,std::vector<unsigned char> const&)::{lambda(std::vector<SEUpdater::PackageInfo> const&)#1}>((uint64_t)v237[0], (uint64_t)v237[1], v62);
      if (v64 == (void *)v65)
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v140 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        v59 = v210;
        v60 = v208;
        v61 = v207;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v350);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v350);
          v141 = (std::__shared_weak_count *)v350.__end_;
          if (v350.__end_)
          {
            v142 = &v350.__end_->__r_.__value_.__l.__size_;
            do
              v143 = __ldaxr(v142);
            while (__stlxr(v143 - 1, v142));
            if (!v143)
            {
              ((void (*)(std::__shared_weak_count *))v141->__on_zero_shared)(v141);
              std::__shared_weak_count::__release_weak(v141);
            }
          }
          v140 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v127 = (std::__shared_weak_count *)off_2553234C8;
        v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v140;
        v295.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v144 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v145 = __ldxr(v144);
          while (__stxr(v145 + 1, v144));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v140, (SEUpdaterUtil::SELogObj *)2, 0, 1, "PerformSLAMMigrations", (SEUpdaterUtil::SELogObj *)"Skipping MP <%s> because module not on SE\n", *v210);
        if (v127)
        {
          v146 = (unint64_t *)&v127->__shared_owners_;
          do
            v131 = __ldaxr(v146);
          while (__stlxr(v131 - 1, v146));
          goto LABEL_235;
        }
        goto LABEL_237;
      }
      v66 = *(const void **)(v62 + 24);
      v68 = *(const void **)v65;
      v67 = *(_QWORD *)(v65 + 8);
      v69 = v67 - *(_QWORD *)v65;
      v70 = *(_QWORD *)(v62 + 32) - (_QWORD)v66;
      v71 = v69 != v70 || memcmp(*(const void **)v65, v66, v69) != 0;
      v63 |= v71;
      if (*(_BYTE *)(v62 + 64))
      {
        v73 = *(_QWORD *)(v62 + 48);
        v72 = *(_QWORD *)(v62 + 56);
        if (v69 < v72 || v70 < v72 || v73 >= v72)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          std::string::basic_string[abi:ne180100]<0>(&v295, "Assertion: ");
          v191 = std::string::append(&v295, "packageOnSE.size() >= versionLocationInPID.second && targetPackageAID.size() >= versionLocationInPID.second && versionLocationInPID.first < versionLocationInPID.second");
          v192 = *(_OWORD *)&v191->__r_.__value_.__l.__data_;
          v350.__end_cap_.__value_ = (std::string *)v191->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v350.__begin_ = v192;
          v191->__r_.__value_.__l.__size_ = 0;
          v191->__r_.__value_.__r.__words[2] = 0;
          v191->__r_.__value_.__r.__words[0] = 0;
          MEMORY[0x22078A520](exception, &v350);
        }
        v76 = SEUpdater::bigEndianFromRange((uint64_t)v68, v67, *(_QWORD *)(v62 + 48), *(_QWORD *)(v62 + 56));
        v77 = SEUpdater::bigEndianFromRange(*(_QWORD *)(v62 + 24), *(_QWORD *)(v62 + 32), v73, v72);
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v78 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v350);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v350);
          v79 = (std::__shared_weak_count *)v350.__end_;
          if (v350.__end_)
          {
            v80 = &v350.__end_->__r_.__value_.__l.__size_;
            do
              v81 = __ldaxr(v80);
            while (__stlxr(v81 - 1, v80));
            if (!v81)
            {
              ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
              std::__shared_weak_count::__release_weak(v79);
            }
          }
          v78 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v82 = (std::__shared_weak_count *)off_2553234C8;
        v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v78;
        v295.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v83 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v84 = __ldxr(v83);
          while (__stxr(v84 + 1, v83));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        ctu::hex();
        begin = (std::vector<std::string>::pointer)&v350;
        if (SHIBYTE(v350.__end_cap_.__value_) < 0)
          begin = v350.__begin_;
        SEUpdaterUtil::SELogObj::printLog(v78, (SEUpdaterUtil::SELogObj *)3, 0, 1, "wouldDowngrade", (SEUpdaterUtil::SELogObj *)"PID on SE %s, version on SE 0x%04llX\n", (const char *)begin, v76);
        if (SHIBYTE(v350.__end_cap_.__value_) < 0)
        {
          operator delete(v350.__begin_);
          if (!v82)
            goto LABEL_119;
        }
        else if (!v82)
        {
          goto LABEL_119;
        }
        v86 = (unint64_t *)&v82->__shared_owners_;
        do
          v87 = __ldaxr(v86);
        while (__stlxr(v87 - 1, v86));
        if (!v87)
        {
          ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
          std::__shared_weak_count::__release_weak(v82);
        }
LABEL_119:
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v88 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v350);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v350);
          v89 = (std::__shared_weak_count *)v350.__end_;
          if (v350.__end_)
          {
            v90 = &v350.__end_->__r_.__value_.__l.__size_;
            do
              v91 = __ldaxr(v90);
            while (__stlxr(v91 - 1, v90));
            if (!v91)
            {
              ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
              std::__shared_weak_count::__release_weak(v89);
            }
          }
          v88 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v92 = (std::__shared_weak_count *)off_2553234C8;
        v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v88;
        v295.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v93 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v94 = __ldxr(v93);
          while (__stxr(v94 + 1, v93));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        ctu::hex();
        v95 = (std::vector<std::string>::pointer)&v350;
        if (SHIBYTE(v350.__end_cap_.__value_) < 0)
          v95 = v350.__begin_;
        SEUpdaterUtil::SELogObj::printLog(v88, (SEUpdaterUtil::SELogObj *)3, 0, 1, "wouldDowngrade", (SEUpdaterUtil::SELogObj *)"PID  INFO %s, version  INFO 0x%04llX\n", (const char *)v95, v77);
        if (SHIBYTE(v350.__end_cap_.__value_) < 0)
        {
          operator delete(v350.__begin_);
          if (!v92)
            goto LABEL_139;
        }
        else if (!v92)
        {
          goto LABEL_139;
        }
        v96 = (unint64_t *)&v92->__shared_owners_;
        do
          v97 = __ldaxr(v96);
        while (__stlxr(v97 - 1, v96));
        if (!v97)
        {
          ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
          std::__shared_weak_count::__release_weak(v92);
        }
LABEL_139:
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v98 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v350);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v350);
          v99 = (std::__shared_weak_count *)v350.__end_;
          if (v350.__end_)
          {
            v100 = &v350.__end_->__r_.__value_.__l.__size_;
            do
              v101 = __ldaxr(v100);
            while (__stlxr(v101 - 1, v100));
            if (!v101)
            {
              ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
              std::__shared_weak_count::__release_weak(v99);
            }
          }
          v98 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v102 = (std::__shared_weak_count *)off_2553234C8;
        v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v98;
        v295.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v103 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v104 = __ldxr(v103);
          while (__stxr(v104 + 1, v103));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v98, (SEUpdaterUtil::SELogObj *)3, 0, 1, "wouldDowngrade", (SEUpdaterUtil::SELogObj *)"  --> wouldDowngrade %d\n", v76 > v77);
        if (v102)
        {
          v105 = (unint64_t *)&v102->__shared_owners_;
          do
            v106 = __ldaxr(v105);
          while (__stlxr(v106 - 1, v105));
          if (!v106)
          {
            ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
            std::__shared_weak_count::__release_weak(v102);
          }
        }
        if (v76 > v77)
        {
          v139 = 1;
          goto LABEL_222;
        }
      }
      v62 += 72;
    }
    while ((const char *)v62 != v212);
    if ((v63 & 1) != 0)
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v107 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      v59 = v210;
      v60 = v208;
      v61 = v207;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v350);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v350);
        v108 = (std::__shared_weak_count *)v350.__end_;
        if (v350.__end_)
        {
          v109 = &v350.__end_->__r_.__value_.__l.__size_;
          do
            v110 = __ldaxr(v109);
          while (__stlxr(v110 - 1, v109));
          if (!v110)
          {
            ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
            std::__shared_weak_count::__release_weak(v108);
          }
        }
        v107 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v111 = (std::__shared_weak_count *)off_2553234C8;
      v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v107;
      v295.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v112 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v113 = __ldxr(v112);
        while (__stxr(v113 + 1, v112));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v107, (SEUpdaterUtil::SELogObj *)2, 0, 1, "PerformSLAMMigrations", (SEUpdaterUtil::SELogObj *)"Executing script <%s, %s>\n", *v210, v210[4]);
      if (v111)
      {
        v114 = (unint64_t *)&v111->__shared_owners_;
        do
          v115 = __ldaxr(v114);
        while (__stlxr(v115 - 1, v114));
        if (!v115)
        {
          ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
          std::__shared_weak_count::__release_weak(v111);
        }
      }
      SEUpdater::P73BaseUpdateController::deactivateAll(v206, "SLAM");
      std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(&v350, *((_QWORD *)v206 + 20), *((std::__shared_weak_count **)v206 + 21));
      v116 = v350.__begin_;
      v117 = v350.__end_;
      v342 = v350.__begin_;
      v343 = (std::__shared_weak_count *)v350.__end_;
      v118 = (unint64_t *)operator new(0x20uLL);
      v118[1] = 0;
      v119 = v118 + 1;
      v118[2] = 0;
      *v118 = (unint64_t)&off_24E0C1170;
      v118[3] = (unint64_t)&off_24E0C11C0;
      v334 = v118 + 3;
      v335 = (std::__shared_weak_count *)v118;
      std::string::basic_string[abi:ne180100]<0>(v230, (char *)v210[4]);
      v226 = v116;
      v227 = (std::__shared_weak_count *)v117;
      if (v117)
      {
        v120 = &v117->__r_.__value_.__l.__size_;
        do
          v121 = __ldxr(v120);
        while (__stxr(v121 + 1, v120));
        v229 = (std::__shared_weak_count *)v117;
        do
          v122 = __ldxr(v120);
        while (__stxr(v122 + 1, v120));
      }
      else
      {
        v229 = 0;
      }
      v228 = v116;
      if (v116)
      {
        v222 = v118 + 3;
        v223 = (std::__shared_weak_count *)v118;
        do
          v154 = __ldxr(v119);
        while (__stxr(v154 + 1, v119));
        v224 = v118 + 3;
        v225 = (std::__shared_weak_count *)v118;
        do
          v155 = __ldxr(v119);
        while (__stxr(v155 + 1, v119));
        SLAM::SLAM::PerformScript((uint64_t)v230, (uint64_t *)&v228, (uint64_t *)&v224, (uint64_t)&v350);
        v156 = v225;
        if (v225)
        {
          v157 = (unint64_t *)&v225->__shared_owners_;
          do
            v158 = __ldaxr(v157);
          while (__stlxr(v158 - 1, v157));
          if (!v158)
          {
            ((void (*)(std::__shared_weak_count *))v156->__on_zero_shared)(v156);
            std::__shared_weak_count::__release_weak(v156);
          }
        }
        v159 = v223;
        if (v223)
        {
          v160 = (unint64_t *)&v223->__shared_owners_;
          do
            v161 = __ldaxr(v160);
          while (__stlxr(v161 - 1, v160));
          if (!v161)
          {
            ((void (*)(std::__shared_weak_count *))v159->__on_zero_shared)(v159);
            std::__shared_weak_count::__release_weak(v159);
          }
        }
        v162 = v229;
        if (v229)
        {
          v163 = (unint64_t *)&v229->__shared_owners_;
          do
            v164 = __ldaxr(v163);
          while (__stlxr(v164 - 1, v163));
          if (!v164)
          {
            ((void (*)(std::__shared_weak_count *))v162->__on_zero_shared)(v162);
            std::__shared_weak_count::__release_weak(v162);
          }
        }
        v165 = v227;
        if (v227)
        {
          v166 = (unint64_t *)&v227->__shared_owners_;
          do
            v167 = __ldaxr(v166);
          while (__stlxr(v167 - 1, v166));
          if (!v167)
          {
            ((void (*)(std::__shared_weak_count *))v165->__on_zero_shared)(v165);
            std::__shared_weak_count::__release_weak(v165);
          }
        }
        if (v231 < 0)
          operator delete(v230[0]);
        if (!(_BYTE)v351)
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v168 = off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(&v295);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v295);
            size = (std::__shared_weak_count *)v295.__r_.__value_.__l.__size_;
            if (v295.__r_.__value_.__l.__size_)
            {
              v170 = (unint64_t *)(v295.__r_.__value_.__l.__size_ + 8);
              do
                v171 = __ldaxr(v170);
              while (__stlxr(v171 - 1, v170));
              if (!v171)
              {
                ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
                std::__shared_weak_count::__release_weak(size);
              }
            }
            v168 = off_2553234C0;
          }
          v172 = (std::__shared_weak_count *)off_2553234C8;
          v326 = v168;
          v327 = off_2553234C8;
          if (off_2553234C8)
          {
            v173 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v174 = __ldxr(v173);
            while (__stxr(v174 + 1, v173));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v168, (SEUpdaterUtil::SELogObj *)2, 0, 1, "PerformSLAMMigrations", (SEUpdaterUtil::SELogObj *)"MP <%s, %s> executed successfully!\n", *v210, v210[4]);
          if (v172)
          {
            v175 = (unint64_t *)&v172->__shared_owners_;
            do
              v176 = __ldaxr(v175);
            while (__stlxr(v176 - 1, v175));
            if (!v176)
            {
              ((void (*)(std::__shared_weak_count *))v172->__on_zero_shared)(v172);
              std::__shared_weak_count::__release_weak(v172);
            }
          }
          v177 = (std::__shared_weak_count *)*((_QWORD *)v206 + 21);
          v213 = *((_QWORD *)v206 + 20);
          v214 = v177;
          if (v177)
          {
            v178 = (unint64_t *)&v177->__shared_owners_;
            do
              v179 = __ldxr(v178);
            while (__stxr(v179 + 1, v178));
          }
          SEUpdater::GetPackageInfo(&v213, (std::string::size_type *)&v295);
          v180 = (char *)v237[0];
          if (v237[0])
          {
            v181 = (char *)v237[1];
            v182 = v237[0];
            if (v237[1] != v237[0])
            {
              do
              {
                v181 -= 48;
                std::allocator<SEUpdater::PackageInfo>::destroy[abi:ne180100]((uint64_t)v238, (uint64_t)v181);
              }
              while (v181 != v180);
              v182 = v237[0];
            }
            v237[1] = v180;
            operator delete(v182);
          }
          *(_OWORD *)v237 = *(_OWORD *)&v295.__r_.__value_.__l.__data_;
          v238[0] = *((_QWORD *)&v295.__r_.__value_.__l + 2);
          memset(&v295, 0, sizeof(v295));
          v326 = &v295;
          std::vector<SEUpdater::PackageInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v326);
          v183 = v214;
          if (v214)
          {
            v184 = (unint64_t *)&v214->__shared_owners_;
            do
              v185 = __ldaxr(v184);
            while (__stlxr(v185 - 1, v184));
            if (!v185)
            {
              ((void (*)(std::__shared_weak_count *))v183->__on_zero_shared)(v183);
              std::__shared_weak_count::__release_weak(v183);
            }
          }
          if ((_BYTE)v351)
          {
            v295.__r_.__value_.__r.__words[0] = (std::string::size_type)&v350;
            std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v295);
          }
          v186 = v335;
          if (v335)
          {
            v187 = (unint64_t *)&v335->__shared_owners_;
            do
              v188 = __ldaxr(v187);
            while (__stlxr(v188 - 1, v187));
            if (!v188)
            {
              ((void (*)(std::__shared_weak_count *))v186->__on_zero_shared)(v186);
              std::__shared_weak_count::__release_weak(v186);
            }
          }
          v127 = v343;
          if (v343)
          {
            v189 = (unint64_t *)&v343->__shared_owners_;
            do
              v131 = __ldaxr(v189);
            while (__stlxr(v131 - 1, v189));
LABEL_235:
            if (!v131)
            {
              ((void (*)(std::__shared_weak_count *))v127->__on_zero_shared)(v127);
              std::__shared_weak_count::__release_weak(v127);
            }
          }
          goto LABEL_237;
        }
        v193 = v342;
        v194 = v343;
        v218[0] = v342;
        v218[1] = v343;
        if (v343)
        {
          v195 = (unint64_t *)&v343->__shared_owners_;
          do
            v196 = __ldxr(v195);
          while (__stxr(v196 + 1, v195));
          v220 = v194;
          do
            v197 = __ldxr(v195);
          while (__stxr(v197 + 1, v195));
        }
        else
        {
          v220 = 0;
        }
        v219 = v193;
        if (v193)
        {
          v198 = v334;
          v199 = v335;
          v215[0] = v334;
          v215[1] = v335;
          if (v335)
          {
            v200 = (unint64_t *)&v335->__shared_owners_;
            do
              v201 = __ldxr(v200);
            while (__stxr(v201 + 1, v200));
            v217 = v199;
            do
              v202 = __ldxr(v200);
            while (__stxr(v202 + 1, v200));
          }
          else
          {
            v217 = 0;
          }
          v216 = v198;
          if (v198)
          {
            SLAM::SLAM::PerformRecovery((uint64_t *)&v219, (uint64_t *)&v216, (uint64_t)v221);
            if (v221[24])
            {
              v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v221;
              std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v295);
            }
            std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v216);
            std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)v215);
            std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&v219);
            std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)v218);
            v203 = __cxa_allocate_exception(0x48uLL);
            v204 = SLAM::Error::Add(&v350, "At MP: %s %s", *v210, v210[4]);
            ctu::join<std::__wrap_iter<std::string const*>>(v204->__begin_, v204->__end_, ", ", 2uLL, &v295);
            v205 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v203, (__int128 *)&v295, 36, CFSTR("SEUpdaterErrorDomain"));
          }
        }
      }
      std::terminate();
    }
    v139 = 0;
    v63 = 0;
LABEL_222:
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v147 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v350);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v350);
      v148 = (std::__shared_weak_count *)v350.__end_;
      if (v350.__end_)
      {
        v149 = &v350.__end_->__r_.__value_.__l.__size_;
        do
          v150 = __ldaxr(v149);
        while (__stlxr(v150 - 1, v149));
        if (!v150)
        {
          ((void (*)(std::__shared_weak_count *))v148->__on_zero_shared)(v148);
          std::__shared_weak_count::__release_weak(v148);
        }
      }
      v147 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v127 = (std::__shared_weak_count *)off_2553234C8;
    v295.__r_.__value_.__r.__words[0] = (std::string::size_type)v147;
    v295.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v151 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v152 = __ldxr(v151);
      while (__stxr(v152 + 1, v151));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v59 = v210;
    SEUpdaterUtil::SELogObj::printLog(v147, (SEUpdaterUtil::SELogObj *)2, 0, 1, "PerformSLAMMigrations", (SEUpdaterUtil::SELogObj *)"Skipping MP <%s> because we are up to date %d or would downgrade %d \n", *v210, (v63 ^ 1) & 1, v139);
    v60 = v208;
    v61 = v207;
    if (v127)
    {
      v153 = (unint64_t *)&v127->__shared_owners_;
      do
        v131 = __ldaxr(v153);
      while (__stlxr(v131 - 1, v153));
      goto LABEL_235;
    }
LABEL_237:
    v59 += 6;
  }
  while (v59 != v60);
LABEL_308:
  v350.__begin_ = (std::vector<std::string>::pointer)&v232;
  std::vector<SLAM::Migration::Trigger>::__destroy_vector::operator()[abi:ne180100]((void ***)&v350);
  v350.__begin_ = (std::vector<std::string>::pointer)v237;
  std::vector<SEUpdater::PackageInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v350);
}

void sub_21CCBB0F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (SLOBYTE(STACK[0x397]) < 0)
    operator delete((void *)STACK[0x380]);
  if (LOBYTE(STACK[0x598]))
  {
    STACK[0x380] = (unint64_t)&STACK[0x580];
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x380]);
  }
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x4F0]);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x538]);
  STACK[0x580] = (unint64_t)&a48;
  std::vector<SLAM::Migration::Trigger>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x580]);
  STACK[0x580] = (unint64_t)&a53;
  std::vector<SEUpdater::PackageInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x580]);
  _Unwind_Resume(a1);
}

_QWORD *SEUpdater::P73BaseUpdateController::doPerform(void)::CommandGetDataOBKG::~CommandGetDataOBKG(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

_QWORD *SEUpdater::P73BaseUpdateController::doPerform(void)::CommandSelectASD::~CommandSelectASD(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

void SEUpdater::CommandGetAMState::~CommandGetAMState(SEUpdater::CommandGetAMState *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSeshatGetData::~CommandSeshatGetData(SEUpdater::CommandSeshatGetData *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetOSUpdateLog::~CommandGetOSUpdateLog(SEUpdater::CommandGetOSUpdateLog *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetPlatformIdentifier::~CommandGetPlatformIdentifier(SEUpdater::CommandGetPlatformIdentifier *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandUpdateTableQuery::~CommandUpdateTableQuery(SEUpdater::CommandUpdateTableQuery *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetAllLogs::~CommandGetAllLogs(SEUpdater::CommandGetAllLogs *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetAttackLog::~CommandGetAttackLog(SEUpdater::CommandGetAttackLog *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandDumpSENVM::~CommandDumpSENVM(SEUpdater::CommandDumpSENVM *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

_QWORD *std::ofstream::~ofstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x24BEDB7E8];
  v3 = *MEMORY[0x24BEDB7E8];
  *a1 = *MEMORY[0x24BEDB7E8];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x22078A5C8](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x22078A778](a1 + 52);
  return a1;
}

_QWORD *SEUpdater::P73BaseUpdateController::CheckAndInstallOasisApplet(void)::CommandSelectOasis::~CommandSelectOasis(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

_QWORD *SEUpdater::P73BaseUpdateController::CheckAndInstallOasisApplet(void)::CommandGetConfigID::~CommandGetConfigID(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

BOOL SEUpdater::P73BaseUpdateController::isSIMDetectGPIOConfiguredWithWPD(SERestoreInfo::P73BaseDeviceInfo **this)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  BOOL v9;
  unint64_t v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  void *exception;
  void *v20;
  void *v21;
  unint64_t DataSize;
  std::string *v23;
  void *v24;
  void *v25;
  std::string *v26;
  void *v27;
  std::string v28;
  std::string v29;
  __int128 v30;
  __int128 v31;
  void *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _OWORD v42[2];
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  SERestoreInfo::CApdu::CApdu((SERestoreInfo::CApdu *)&v32);
  if (SERestoreInfo::P73BaseDeviceInfo::isDev(this[16]))
  {
    v41 = xmmword_21CCD9107;
    v42[0] = unk_21CCD9117;
    *(_OWORD *)((char *)v42 + 15) = unk_21CCD9126;
    v37 = xmmword_21CCD90C7;
    v38 = unk_21CCD90D7;
    v39 = xmmword_21CCD90E7;
    v40 = unk_21CCD90F7;
    SERestoreInfo::CApdu::CApdu(&v29, &v37, 0x6FuLL, 0);
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0978;
    std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&v33, (uint64_t *)&v29.__r_.__value_.__l.__size_);
    v35 = v30;
    v36 = v31;
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
    v2 = (std::__shared_weak_count *)v29.__r_.__value_.__r.__words[2];
    if (!v29.__r_.__value_.__r.__words[2])
      goto LABEL_11;
    v3 = (unint64_t *)(v29.__r_.__value_.__r.__words[2] + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
  }
  else
  {
    v41 = xmmword_21CCD9068;
    v42[0] = unk_21CCD9078;
    *(_OWORD *)((char *)v42 + 15) = unk_21CCD9087;
    v37 = xmmword_21CCD9028;
    v38 = unk_21CCD9038;
    v39 = xmmword_21CCD9048;
    v40 = unk_21CCD9058;
    SERestoreInfo::CApdu::CApdu(&v29, &v37, 0x6FuLL, 0);
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24E0C0930;
    std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](&v33, (uint64_t *)&v29.__r_.__value_.__l.__size_);
    v35 = v30;
    v36 = v31;
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BF880;
    v2 = (std::__shared_weak_count *)v29.__r_.__value_.__r.__words[2];
    if (!v29.__r_.__value_.__r.__words[2])
      goto LABEL_11;
    v5 = (unint64_t *)(v29.__r_.__value_.__r.__words[2] + 8);
    do
      v4 = __ldaxr(v5);
    while (__stlxr(v4 - 1, v5));
  }
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
LABEL_11:
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v37, 0x2037uLL);
  *(_QWORD *)&v37 = &unk_24E0BF828;
  (*(void (**)(SERestoreInfo::P73BaseDeviceInfo *, void **, __int128 *, uint64_t, uint64_t))(*(_QWORD *)this[20] + 16))(this[20], &v32, &v37, 3, 1);
  v6 = **((_QWORD **)&v37 + 1);
  v7 = *(_QWORD *)(*((_QWORD *)&v37 + 1) + 8);
  v8 = v7 - **((_QWORD **)&v37 + 1);
  v9 = v8 >= 2;
  v10 = v8 - 2;
  if (!v9 || (*(unsigned __int8 *)(v7 - 1) | (*(unsigned __int8 *)(v6 + v10) << 8)) != 0x9000)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v29, "Failed to query SIM_DETECT GPIO configuration");
    v20 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, (__int128 *)&v29, 31, CFSTR("SEUpdaterErrorDomain"));
  }
  if (v10 <= 4)
  {
    v21 = __cxa_allocate_exception(0x48uLL);
    DataSize = SERestoreInfo::RApdu::getDataSize((SERestoreInfo::RApdu *)&v37);
    std::to_string(&v28, DataSize);
    v23 = std::string::insert(&v28, 0, "Wrong size for SIM_DETECT GPIO query ");
    v29 = *v23;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    v24 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v21, (__int128 *)&v29, 31, CFSTR("SEUpdaterErrorDomain"));
  }
  v11 = *(unsigned __int8 *)(v6 + 4);
  if ((v11 - 3) <= 0xFFFFFFFD)
  {
    v25 = __cxa_allocate_exception(0x48uLL);
    std::to_string(&v28, v11);
    v26 = std::string::insert(&v28, 0, "Invalid configuration value ");
    v29 = *v26;
    v26->__r_.__value_.__l.__size_ = 0;
    v26->__r_.__value_.__r.__words[2] = 0;
    v26->__r_.__value_.__r.__words[0] = 0;
    v27 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v25, (__int128 *)&v29, 31, CFSTR("SEUpdaterErrorDomain"));
  }
  *(_QWORD *)&v37 = &unk_24E0BF880;
  v12 = (std::__shared_weak_count *)v38;
  if ((_QWORD)v38)
  {
    v13 = (unint64_t *)(v38 + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v32 = &unk_24E0BF880;
  v15 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  return v11 != 1;
}

void sub_21CCBBF34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  a33 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a34);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void sub_21CCBC000()
{
  JUMPOUT(0x21CCBBFF8);
}

void SEUpdater::CommandGetConfigItem4143_Eos_Prod::~CommandGetConfigItem4143_Eos_Prod(SEUpdater::CommandGetConfigItem4143_Eos_Prod *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetConfigItem4143_Eos_Dev::~CommandGetConfigItem4143_Eos_Dev(SEUpdater::CommandGetConfigItem4143_Eos_Dev *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSetConfigItem4143_WPD_Eos_Prod::~CommandSetConfigItem4143_WPD_Eos_Prod(SEUpdater::CommandSetConfigItem4143_WPD_Eos_Prod *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSetConfigItem4143_HiZ_Eos_Prod::~CommandSetConfigItem4143_HiZ_Eos_Prod(SEUpdater::CommandSetConfigItem4143_HiZ_Eos_Prod *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSetConfigItem4143_WPD_Eos_Dev::~CommandSetConfigItem4143_WPD_Eos_Dev(SEUpdater::CommandSetConfigItem4143_WPD_Eos_Dev *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSetConfigItem4143_HiZ_Eos_Dev::~CommandSetConfigItem4143_HiZ_Eos_Dev(SEUpdater::CommandSetConfigItem4143_HiZ_Eos_Dev *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetConfigItem412A_Mem_Reserve_Eos_Prod::~CommandGetConfigItem412A_Mem_Reserve_Eos_Prod(SEUpdater::CommandGetConfigItem412A_Mem_Reserve_Eos_Prod *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetConfigItem412A_Mem_Reserve_Eos_ProdEval::~CommandGetConfigItem412A_Mem_Reserve_Eos_ProdEval(SEUpdater::CommandGetConfigItem412A_Mem_Reserve_Eos_ProdEval *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetConfigItem412A_Mem_Reserve_Eos_Dev::~CommandGetConfigItem412A_Mem_Reserve_Eos_Dev(SEUpdater::CommandGetConfigItem412A_Mem_Reserve_Eos_Dev *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSetConfigItem412A_Mem_Reserve_Eos_Prod::~CommandSetConfigItem412A_Mem_Reserve_Eos_Prod(SEUpdater::CommandSetConfigItem412A_Mem_Reserve_Eos_Prod *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSetConfigItem412A_Mem_Reserve_Eos_ProdEval::~CommandSetConfigItem412A_Mem_Reserve_Eos_ProdEval(SEUpdater::CommandSetConfigItem412A_Mem_Reserve_Eos_ProdEval *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSetConfigItem412A_Mem_Reserve_Eos_Dev::~CommandSetConfigItem412A_Mem_Reserve_Eos_Dev(SEUpdater::CommandSetConfigItem412A_Mem_Reserve_Eos_Dev *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetConfigItem415E_Index_Table_Defragmentation_Eos_Prod::~CommandGetConfigItem415E_Index_Table_Defragmentation_Eos_Prod(SEUpdater::CommandGetConfigItem415E_Index_Table_Defragmentation_Eos_Prod *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetConfigItem415E_Index_Table_Defragmentation_Eos_ProdEval::~CommandGetConfigItem415E_Index_Table_Defragmentation_Eos_ProdEval(SEUpdater::CommandGetConfigItem415E_Index_Table_Defragmentation_Eos_ProdEval *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandGetConfigItem415E_Index_Table_Defragmentation_Eos_Dev::~CommandGetConfigItem415E_Index_Table_Defragmentation_Eos_Dev(SEUpdater::CommandGetConfigItem415E_Index_Table_Defragmentation_Eos_Dev *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSetConfigItem415E_Index_Table_Defragmentation_Disable_Eos_Dev::~CommandSetConfigItem415E_Index_Table_Defragmentation_Disable_Eos_Dev(SEUpdater::CommandSetConfigItem415E_Index_Table_Defragmentation_Disable_Eos_Dev *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

uint64_t ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t SEUpdater::getOBJPOctetString(_QWORD *a1)
{
  uint64_t result;

  Img4DecodeGetObjectPropertyData();
  result = 0;
  *a1 = 0;
  return result;
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t std::__optional_destruct_base<AlohaPairingOptions,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40))
  {
    ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef((const void **)(a1 + 24));
    ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef((const void **)(a1 + 16));
    ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::~SharedRef((const void **)(a1 + 8));
  }
  return a1;
}

const void **ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

__n128 __Block_byref_object_copy__2(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void ___ZN13SEUpdaterUtil8SELogObj13dumpLogBufferEv_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  char **v4;
  char *v5;
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  size_t v10;
  _BYTE *v11;
  char v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char v17;
  char v18;
  _BYTE *v19;
  _BYTE *v20;
  char v21;
  _QWORD *v22;
  unint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  unint64_t v26;
  _BYTE *v27;
  uint64_t v28;
  unint64_t v29;
  size_t v30;
  _BYTE *v31;
  char *v32;
  _BYTE *v33;
  char v34;
  char *v35;
  _QWORD v36[2];
  _QWORD v37[2];

  v2 = *(_QWORD **)(a1 + 40);
  v3 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
  v4 = (char **)(v2 + 7);
  if (v2[11])
    v5 = (char *)v2[9];
  else
    v5 = 0;
  v37[0] = v2 + 7;
  v37[1] = v5;
  v36[0] = v2 + 7;
  v36[1] = 0;
  v6 = boost::cb_details::iterator<boost::circular_buffer<unsigned char,std::allocator<unsigned char>>,boost::cb_details::nonconst_traits<std::allocator<unsigned char>>>::operator-<boost::cb_details::nonconst_traits<std::allocator<unsigned char>>>((uint64_t)v36, (uint64_t)v37);
  v7 = v3[7];
  v8 = (_BYTE *)v3[5];
  if (v7 - (unint64_t)v8 < v6)
  {
    if (v8)
    {
      v3[6] = v8;
      operator delete(v8);
      v7 = 0;
      v3[5] = 0;
      v3[6] = 0;
      v3[7] = 0;
    }
    if ((v6 & 0x8000000000000000) != 0)
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    v9 = 2 * v7;
    if (2 * v7 <= v6)
      v9 = v6;
    if (v7 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v9;
    std::vector<unsigned char>::__vallocate[abi:ne180100](v3 + 5, v10);
    v11 = (_BYTE *)v3[6];
    if (v5)
    {
      do
      {
        v12 = *v5++;
        *v11 = v12;
        if (v5 == (char *)v2[8])
          v5 = *v4;
        ++v11;
      }
      while (v5 && v5 != (char *)v2[10]);
    }
    goto LABEL_48;
  }
  v13 = (_BYTE *)v3[6];
  v14 = v13 - v8;
  if (v13 - v8 < v6)
  {
    if (v14 < 1)
    {
      if ((v14 & 0x8000000000000000) == 0)
      {
LABEL_40:
        v19 = v13;
        if (v5)
        {
          v19 = v13;
          v20 = v13;
          do
          {
            v21 = *v5++;
            *v20 = v21;
            if (v5 == (char *)v2[8])
              v5 = *v4;
            ++v19;
            if (!v5)
              break;
            ++v20;
          }
          while (v5 != (char *)v2[10]);
        }
        v11 = v19;
        goto LABEL_48;
      }
      v35 = v5;
      if (!v5)
        v35 = (char *)v2[10];
      if (v35 - *v4 < v8 - v13)
        v14 = v14 - (_QWORD)*v4 + v2[8];
      v16 = &v35[v14];
    }
    else
    {
      v15 = v2[8];
      if (v15 - (uint64_t)v5 <= v14)
        v14 = (uint64_t)&(*v4)[v14 - v15];
      v16 = &v5[v14];
      if (v16 == (char *)v2[10])
        v16 = 0;
    }
    if (v16 != v5)
    {
      do
      {
        v17 = *v5++;
        *v8 = v17;
        if (v5 == (char *)v2[8])
          v5 = *v4;
        if (v5 == (char *)v2[10])
          v5 = 0;
        ++v8;
      }
      while (v5 != v16);
      v13 = (_BYTE *)v3[6];
      v5 = v16;
    }
    goto LABEL_40;
  }
  if (v5)
  {
    v11 = (_BYTE *)v3[5];
    do
    {
      v18 = *v5++;
      *v8 = v18;
      if (v5 == (char *)v2[8])
        v5 = *v4;
      ++v11;
      if (!v5)
        break;
      ++v8;
    }
    while (v5 != (char *)v2[10]);
  }
  else
  {
    v11 = (_BYTE *)v3[5];
  }
LABEL_48:
  v3[6] = v11;
  v22 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
  v24 = (_BYTE *)v22[6];
  v23 = v22[7];
  if ((unint64_t)v24 >= v23)
  {
    v26 = v22[5];
    v27 = &v24[-v26];
    v28 = (uint64_t)&v24[-v26 + 1];
    if (v28 < 0)
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    v29 = v23 - v26;
    if (2 * v29 > v28)
      v28 = 2 * v29;
    if (v29 >= 0x3FFFFFFFFFFFFFFFLL)
      v30 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v30 = v28;
    if (v30)
      v31 = operator new(v30);
    else
      v31 = 0;
    v32 = &v31[v30];
    v27[(_QWORD)v31] = 0;
    v25 = (uint64_t)&v27[(_QWORD)v31 + 1];
    if (v24 == (_BYTE *)v26)
    {
      v31 = &v27[(_QWORD)v31];
    }
    else
    {
      v33 = &v24[~v26];
      do
      {
        v34 = *--v24;
        (v33--)[(_QWORD)v31] = v34;
      }
      while (v24 != (_BYTE *)v26);
      v24 = (_BYTE *)v22[5];
    }
    v22[5] = v31;
    v22[6] = v25;
    v22[7] = v32;
    if (v24)
      operator delete(v24);
  }
  else
  {
    *v24 = 0;
    v25 = (uint64_t)(v24 + 1);
  }
  v22[6] = v25;
}

void std::__throw_bad_optional_access[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x24BEDB8E0] + 16;
  __cxa_throw(exception, MEMORY[0x24BEDB740], MEMORY[0x24BEDABA8]);
}

SERestoreInfo::CApdu *SERestoreInfo::CApdu::CApdu(SERestoreInfo::CApdu *this)
{
  SERestoreInfo::Apdu *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  BOOL v8;
  uint64_t v9;

  v2 = SERestoreInfo::Apdu::Apdu(this, 0x2037uLL);
  v3 = (_QWORD *)*((_QWORD *)v2 + 1);
  *(_QWORD *)v2 = &unk_24E0BF960;
  v5 = v3;
  v4 = *v3;
  v6 = v5[1] - v4;
  v7 = v6 - 5;
  v8 = v6 >= 6;
  v9 = v4 + 5;
  if (!v8)
  {
    v7 = 0;
    v9 = 0;
  }
  *((_QWORD *)v2 + 4) = v9;
  *((_QWORD *)v2 + 5) = v7;
  *((_QWORD *)v2 + 3) = v4;
  SERestoreInfo::CApdu::validate(v2);
  *((_QWORD *)this + 6) = 0;
  return this;
}

void sub_21CCBC8D4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  *v1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<std::vector<unsigned char>>::operator=[abi:ne180100](_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void std::vector<unsigned char>::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("vector");
}

const void **ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(const void **a1, const void **a2)
{
  const void *v3;

  v3 = *a2;
  *a1 = *a2;
  if (v3)
    CFRetain(v3);
  return a1;
}

_QWORD *SEUpdater::CommandTriggerImg4::CommandTriggerImg4(SEUpdater::CommandTriggerImg4 *this)
{
  _QWORD *result;
  uint64_t v2;
  __int16 v3;
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  v2 = 0x474D49041380704FLL;
  v3 = 52;
  result = SERestoreInfo::CApdu::CApdu(this, &v2, 0xAuLL, 0);
  *result = &off_24E0C0228;
  return result;
}

_QWORD *SEUpdater::CommandSelectCRS::CommandSelectCRS(SEUpdater::CommandSelectCRS *this)
{
  _QWORD *result;
  uint64_t v2;
  int v3;
  __int16 v4;
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v2 = 0xA0080004A400;
  v3 = 1380143361;
  v4 = 83;
  result = SERestoreInfo::CApdu::CApdu(this, &v2, 0xEuLL, 0);
  *result = &unk_24E0C03D8;
  return result;
}

_QWORD *SEUpdater::CommandSelectSeshat::CommandSelectSeshat(SEUpdater::CommandSelectSeshat *this)
{
  _QWORD *result;
  uint64_t v2;
  char v3[8];
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  v2 = 0x444548080004A400;
  strcpy(v3, "S_APP");
  result = SERestoreInfo::CApdu::CApdu(this, &v2, 0xEuLL, 0);
  *result = &off_24E0C04B0;
  return result;
}

const void **ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

_OWORD *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD v12[2];
  char v13;
  uint64_t v14;

  v6 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v14, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x50uLL);
    v12[1] = a1 + 1;
    v9 = *a4;
    v10 = *((_QWORD *)*a4 + 2);
    v7[2] = **a4;
    *((_QWORD *)v7 + 6) = v10;
    v9[1] = 0;
    v9[2] = 0;
    *v9 = 0;
    *((_QWORD *)v7 + 8) = 0;
    *((_QWORD *)v7 + 9) = 0;
    *((_QWORD *)v7 + 7) = 0;
    v13 = 1;
    std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::__insert_node_at(a1, v14, v8, (uint64_t *)v7);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)v12, 0);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!std::less<std::string>::operator()[abi:ne180100](v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::less<std::string>::operator()[abi:ne180100](v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

BOOL std::less<std::string>::operator()[abi:ne180100](uint64_t a1, const void **a2, const void **a3)
{
  int v3;
  int v4;
  size_t v5;
  const void *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  int v10;

  v3 = *((char *)a3 + 23);
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (v4 >= 0)
    v6 = a2;
  else
    v6 = *a2;
  if (v3 >= 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (v3 >= 0)
    v8 = a3;
  else
    v8 = *a3;
  if (v7 >= v5)
    v9 = v5;
  else
    v9 = v7;
  v10 = memcmp(v6, v8, v9);
  if (v10)
    return v10 < 0;
  else
    return v5 < v7;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

void SEUpdater::P73BaseUpdateController::doPerform(void)::CommandGetDataOBKG::~CommandGetDataOBKG(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x22078A808);
}

void SEUpdater::P73BaseUpdateController::doPerform(void)::CommandSelectASD::~CommandSelectASD(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x22078A808);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<SLAM::Deletion::Trigger>,SLAM::Deletion::Trigger*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t v3;
  uint64_t i;
  void *v5;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = **(_QWORD **)(a1 + 8);
    for (i = **(_QWORD **)(a1 + 16); i != v3; i -= 48)
    {
      v5 = *(void **)(i - 40);
      if (v5)
      {
        *(_QWORD *)(i - 32) = v5;
        operator delete(v5);
      }
    }
  }
  return a1;
}

void std::vector<SLAM::Deletion::Trigger>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 5);
        if (v6)
        {
          *((_QWORD *)v4 - 4) = v6;
          operator delete(v6);
        }
        v4 -= 48;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t SEUpdater::find_if<std::vector<SEUpdater::PackageInfo>,SEUpdater::FindPackageForModule(std::vector<SEUpdater::PackageInfo> const&,std::vector<unsigned char> const&)::{lambda(std::vector<SEUpdater::PackageInfo> const&)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v3 = a1;
  if (a1 != a2)
  {
    v6 = *(const void **)a3;
    while (1)
    {
      v8 = *(_QWORD *)(v3 + 24);
      v7 = *(_QWORD *)(v3 + 32);
      if (v8 == v7)
      {
LABEL_8:
        v8 = v7;
      }
      else
      {
        v9 = *(_QWORD *)(a3 + 8) - (_QWORD)v6;
        while (*(_QWORD *)(v8 + 8) - *(_QWORD *)v8 != v9 || memcmp(*(const void **)v8, v6, v9))
        {
          v8 += 24;
          if (v8 == v7)
            goto LABEL_8;
        }
      }
      if (v7 != v8)
        break;
      v3 += 48;
      if (v3 == a2)
        return a2;
    }
  }
  return v3;
}

void SEUpdater::P73BaseUpdateController::CheckAndInstallOasisApplet(void)::CommandSelectOasis::~CommandSelectOasis(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x22078A808);
}

void SEUpdater::P73BaseUpdateController::CheckAndInstallOasisApplet(void)::CommandGetConfigID::~CommandGetConfigID(_QWORD *a1)
{
  *a1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x22078A808);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<SEUpdater::SLAM::Installation::InstallationTrigger>,SEUpdater::SLAM::Installation::InstallationTrigger*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void **v6;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = **(_QWORD **)(a1 + 8);
    v3 = **(_QWORD **)(a1 + 16);
    if (v3 != v2)
    {
      do
      {
        v4 = v3 - 48;
        v6 = (void **)(v3 - 40);
        std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100](&v6);
        v3 = v4;
      }
      while (v4 != v2);
    }
  }
  return a1;
}

void std::vector<SEUpdater::SLAM::Installation::InstallationTrigger>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void **v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 48;
        v7 = (void **)(v4 - 40);
        std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:ne180100](&v7);
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void SLAM::Migration::AppletInfo::~AppletInfo(SLAM::Migration::AppletInfo *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  v3 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v3;
    operator delete(v3);
  }
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<SLAM::Migration::AppletInfo>,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo const*,SLAM::Migration::AppletInfo*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  __int128 v11;

  if (a1 != a2)
  {
    v6 = 0;
    do
    {
      v7 = a1 + v6;
      v8 = (_QWORD *)(a3 + v6);
      *v8 = 0;
      v8[1] = 0;
      v8[2] = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(a3 + v6), *(const void **)(a1 + v6), *(_QWORD *)(a1 + v6 + 8), *(_QWORD *)(a1 + v6 + 8) - *(_QWORD *)(a1 + v6));
      v8[3] = 0;
      v8[4] = 0;
      v9 = (_QWORD *)(a3 + v6 + 24);
      v9[2] = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v9, *(const void **)(v7 + 24), *(_QWORD *)(v7 + 32), *(_QWORD *)(v7 + 32) - *(_QWORD *)(v7 + 24));
      v10 = a3 + v6;
      v11 = *(_OWORD *)(a1 + v6 + 48);
      *(_QWORD *)(v10 + 64) = *(_QWORD *)(a1 + v6 + 64);
      *(_OWORD *)(v10 + 48) = v11;
      v6 += 72;
    }
    while (v7 + 72 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_21CCBD864(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void *v4;
  uint64_t v5;

  v4 = *(void **)(v1 + v2);
  if (v4)
  {
    *(_QWORD *)(v1 + v2 + 8) = v4;
    operator delete(v4);
  }
  if (v2)
  {
    v5 = v1 - 72;
    do
    {
      std::allocator<SLAM::Migration::AppletInfo>::destroy[abi:ne180100](v5 + v2);
      v2 -= 72;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void std::allocator<SLAM::Migration::AppletInfo>::destroy[abi:ne180100](uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  v3 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v3;
    operator delete(v3);
  }
}

void std::vector<SLAM::Migration::AppletInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 72;
        std::allocator<SLAM::Migration::AppletInfo>::destroy[abi:ne180100](v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<SLAM::Migration::Trigger>,SLAM::Migration::Trigger*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void **v6;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = **(_QWORD **)(a1 + 8);
    v3 = **(_QWORD **)(a1 + 16);
    if (v3 != v2)
    {
      do
      {
        v4 = v3 - 48;
        v6 = (void **)(v3 - 40);
        std::vector<SLAM::Migration::AppletInfo>::__destroy_vector::operator()[abi:ne180100](&v6);
        v3 = v4;
      }
      while (v4 != v2);
    }
  }
  return a1;
}

void std::vector<SLAM::Migration::Trigger>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void **v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 48;
        v7 = (void **)(v4 - 40);
        std::vector<SLAM::Migration::AppletInfo>::__destroy_vector::operator()[abi:ne180100](&v7);
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unint64_t SEUpdater::bigEndianFromRange(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v6;
  unint64_t result;
  unsigned __int8 *v8;
  unsigned int v9;

  v4 = a4 - a3;
  if (a4 <= a3)
    return 0;
  v6 = a2 - a1 - a3;
  if (a2 - a1 < a3)
    v6 = 0;
  if (v6 <= a4 + ~a3)
    std::vector<unsigned char>::__throw_out_of_range[abi:ne180100]();
  result = 0;
  v8 = (unsigned __int8 *)(a1 + a3);
  do
  {
    v9 = *v8++;
    result = v9 | (result << 8);
    --v4;
  }
  while (v4);
  return result;
}

_QWORD *ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::SharedRef(_QWORD *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf)
    CFRetain(cf);
  return a1;
}

const void **ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(uint64_t a1, char *__dst, char *__src, char *a4, int64_t a5)
{
  uint64_t v9;
  _BYTE *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  size_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  int64_t v19;
  _BYTE *v20;
  char *v21;
  char *v22;
  _BYTE *v23;
  char *v24;
  char v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;

  if (a5 < 1)
    return;
  v10 = *(_BYTE **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    v11 = *(char **)a1;
    v12 = (uint64_t)&v10[a5 - *(_QWORD *)a1];
    if (v12 < 0)
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    v13 = (char *)(__dst - v11);
    v14 = v9 - (_QWORD)v11;
    if (2 * v14 > v12)
      v12 = 2 * v14;
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL)
      v15 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v15 = v12;
    if (v15)
      v16 = (char *)operator new(v15);
    else
      v16 = 0;
    v26 = &v13[(_QWORD)v16];
    memcpy(&v13[(_QWORD)v16], __src, a5);
    if (v11 == __dst)
    {
      v27 = &v13[(_QWORD)v16];
    }
    else
    {
      do
      {
        v13[(_QWORD)v16 - 1] = v13[(_QWORD)(v11 - 1)];
        --v13;
      }
      while (v13);
      v10 = *(_BYTE **)(a1 + 8);
      v27 = v16;
    }
    v28 = &v26[a5];
    v29 = &v16[v15];
    if (v10 != __dst)
      memmove(v28, __dst, v10 - __dst);
    v30 = *(char **)a1;
    *(_QWORD *)a1 = v27;
    *(_QWORD *)(a1 + 8) = &v28[v10 - __dst];
    *(_QWORD *)(a1 + 16) = v29;
    if (v30)
      operator delete(v30);
    return;
  }
  v17 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    v18 = &__src[a5];
    v20 = *(_BYTE **)(a1 + 8);
LABEL_17:
    v21 = &__dst[a5];
    v22 = &v20[-a5];
    v23 = v20;
    if (&v20[-a5] < v10)
    {
      v24 = (char *)(&v10[a5] - v20);
      v23 = v20;
      do
      {
        v25 = *v22++;
        *v23++ = v25;
        --v24;
      }
      while (v24);
    }
    *(_QWORD *)(a1 + 8) = v23;
    if (v20 != v21)
      memmove(&__dst[a5], __dst, v20 - v21);
    if (v18 != __src)
      memmove(__dst, __src, v18 - __src);
    return;
  }
  v18 = &__src[v17];
  v19 = a4 - &__src[v17];
  if (a4 != &__src[v17])
    memmove(*(void **)(a1 + 8), &__src[v17], a4 - &__src[v17]);
  v20 = &v10[v19];
  *(_QWORD *)(a1 + 8) = &v10[v19];
  if (v17 >= 1)
    goto LABEL_17;
}

uint64_t std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>(uint64_t a1, const void **a2)
{
  const void **v2;
  uint64_t v4;
  uint64_t v5;

  v2 = *(const void ***)(a1 + 8);
  if (v2)
  {
    v4 = a1 + 16;
    v5 = 1;
    do
    {
      if (!std::less<std::string>::operator()[abi:ne180100](v4, a2, v2 + 4))
      {
        if (!std::less<std::string>::operator()[abi:ne180100](v4, v2 + 4, a2))
          return v5;
        ++v2;
      }
      v2 = (const void **)*v2;
    }
    while (v2);
  }
  return 0;
}

void std::__shared_ptr_emplace<SEUpdater::P73BaseSEController>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0DB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SEUpdater::P73BaseSEController>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0DB0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SEUpdater::P73BaseSEController>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__tree<std::string>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::string>::destroy(*(_QWORD *)a1);
    std::__tree<std::string>::destroy(*((_QWORD *)a1 + 1));
    if (a1[55] < 0)
      operator delete(*((void **)a1 + 4));
    operator delete(a1);
  }
}

void std::__shared_ptr_emplace<SERestoreInfo::P73DeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0E00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::P73DeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0E00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::P73DeviceInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<SERestoreInfo::SN100VDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0E50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::SN100VDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0E50;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::SN100VDeviceInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<SERestoreInfo::SN200VDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0EA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::SN200VDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0EA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::SN200VDeviceInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<SERestoreInfo::SN210VDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0EF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::SN210VDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0EF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::SN210VDeviceInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<SERestoreInfo::SN300VDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0F40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::SN300VDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0F40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::SN300VDeviceInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<SERestoreInfo::SE310SDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0F90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::SE310SDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0F90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::SE310SDeviceInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<SERestoreInfo::SN300V2DeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0FE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::SN300V2DeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C0FE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::SN300V2DeviceInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void SEUpdaterUtil::_AddError(SEUpdaterUtil *this, int a2, uint64_t a3, SEUpdaterUtil::SELogObj *a4, const char *a5, ...)
{
  int v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t v16;
  SEUpdaterUtil::SELogObj *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  void **v24;
  unint64_t *v25;
  unint64_t v26;
  void *__p[2];
  unsigned __int8 v28;
  va_list v29;
  __int128 v30;
  va_list va;

  va_start(va, a5);
  if (!a4)
    __assert_rtn("_AddError", "Error.hpp", 66, "fmt");
  v6 = (int)this;
  va_copy(v29, va);
  SEUpdaterUtil::SELogToStrv(0, a4, va, 0, a3, __p);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::Error,SEUpdaterUtil::Error,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::Error>>::sInstance);
  v7 = qword_255323590;
  if (!qword_255323590)
  {
    SEUpdaterUtil::Error::create_default_global(&v30);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&qword_255323590, &v30);
    v8 = (std::__shared_weak_count *)*((_QWORD *)&v30 + 1);
    if (*((_QWORD *)&v30 + 1))
    {
      v9 = (unint64_t *)(*((_QWORD *)&v30 + 1) + 8);
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v7 = qword_255323590;
  }
  v11 = (std::__shared_weak_count *)off_255323598;
  if (off_255323598)
  {
    v12 = (unint64_t *)((char *)off_255323598 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::Error,SEUpdaterUtil::Error,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::Error>>::sInstance);
  SEUpdaterUtil::Error::addError(v7, (uint64_t)__p, v6);
  if (!v11)
    goto LABEL_16;
  p_shared_owners = (unint64_t *)&v11->__shared_owners_;
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    if (!a2)
      goto LABEL_38;
  }
  else
  {
LABEL_16:
    if (!a2)
      goto LABEL_38;
  }
  v16 = v28;
  if ((v28 & 0x80u) != 0)
    v16 = (unint64_t)__p[1];
  if (v16)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v17 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v30);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v30);
      v18 = (std::__shared_weak_count *)*((_QWORD *)&v30 + 1);
      if (*((_QWORD *)&v30 + 1))
      {
        v19 = (unint64_t *)(*((_QWORD *)&v30 + 1) + 8);
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      v17 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v21 = (std::__shared_weak_count *)off_2553234C8;
    if (off_2553234C8)
    {
      v22 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v24 = __p;
    if ((v28 & 0x80u) != 0)
      v24 = (void **)__p[0];
    SEUpdaterUtil::SELogObj::printLog(v17, 0, 0, 0, 0, (SEUpdaterUtil::SELogObj *)"%s\n", (const char *)v24);
    if (v21)
    {
      v25 = (unint64_t *)&v21->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
  }
LABEL_38:
  if ((char)v28 < 0)
    operator delete(__p[0]);
}

void sub_21CCBE75C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t *SEUpdaterUtil::SELogToStrv@<X0>(SEUpdaterUtil *this@<X0>, SEUpdaterUtil::SELogObj *a2@<X2>, va_list a3@<X3>, char *a4@<X4>, uint64_t a5@<X1>, _QWORD *a6@<X8>)
{
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  __int128 v19;
  char *__s[5];
  char *v21[6];

  v21[5] = *(char **)MEMORY[0x24BDAC8D0];
  SEUpdaterUtil::SELogObj::FormatMsgv(a2, a3, v21);
  if (!v21[0])
    goto LABEL_19;
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v19);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v19);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
    if (*((_QWORD *)&v19 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  v13 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v14 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::createVerboseLogString(this, v21[0], a4, a5, __s);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (!__s[0])
  {
    std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100]((uint64_t *)__s);
LABEL_19:
    *a6 = 0;
    a6[1] = 0;
    a6[2] = 0;
    return std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100]((uint64_t *)v21);
  }
  std::string::basic_string[abi:ne180100]<0>(a6, __s[0]);
  std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100]((uint64_t *)__s);
  return std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100]((uint64_t *)v21);
}

void sub_21CCBE95C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  std::unique_ptr<char const,std::function<void ()(char const*)>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

_QWORD *SEUpdaterUtil::Error::create_default_global@<X0>(_QWORD *a1@<X8>)
{
  SEUpdaterUtil::Error *v3;

  v3 = (SEUpdaterUtil::Error *)operator new();
  SEUpdaterUtil::Error::Error(v3);
  return std::shared_ptr<SEUpdaterUtil::Error>::shared_ptr[abi:ne180100]<SEUpdaterUtil::Error,std::shared_ptr<SEUpdaterUtil::Error> ctu::SharedSynchronizable<SEUpdaterUtil::Error>::make_shared_ptr<SEUpdaterUtil::Error>(SEUpdaterUtil::Error*)::{lambda(SEUpdaterUtil::Error*)#1},void>(a1, v3);
}

_QWORD *std::shared_ptr<SEUpdaterUtil::Error>::shared_ptr[abi:ne180100]<SEUpdaterUtil::Error,std::shared_ptr<SEUpdaterUtil::Error> ctu::SharedSynchronizable<SEUpdaterUtil::Error>::make_shared_ptr<SEUpdaterUtil::Error>(SEUpdaterUtil::Error*)::{lambda(SEUpdaterUtil::Error*)#1},void>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24E0C1268;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  std::shared_ptr<SEUpdaterUtil::SELogObj>::__enable_weak_this[abi:ne180100]<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,void>((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_21CCBEA68(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)std::shared_ptr<SEUpdaterUtil::Error> ctu::SharedSynchronizable<SEUpdaterUtil::Error>::make_shared_ptr<SEUpdaterUtil::Error>(SEUpdaterUtil::Error*)::{lambda(SEUpdaterUtil::Error*)#1}::operator() const(SEUpdaterUtil::Error*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_21CCBEA88(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<SEUpdaterUtil::Error *,std::shared_ptr<SEUpdaterUtil::Error> ctu::SharedSynchronizable<SEUpdaterUtil::Error>::make_shared_ptr<SEUpdaterUtil::Error>(SEUpdaterUtil::Error*)::{lambda(SEUpdaterUtil::Error *)#1},std::allocator<SEUpdaterUtil::Error>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

void std::__shared_ptr_pointer<SEUpdaterUtil::Error *,std::shared_ptr<SEUpdaterUtil::Error> ctu::SharedSynchronizable<SEUpdaterUtil::Error>::make_shared_ptr<SEUpdaterUtil::Error>(SEUpdaterUtil::Error*)::{lambda(SEUpdaterUtil::Error *)#1},std::allocator<SEUpdaterUtil::Error>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 16), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<SEUpdaterUtil::Error> ctu::SharedSynchronizable<SEUpdaterUtil::Error>::make_shared_ptr<SEUpdaterUtil::Error>(SEUpdaterUtil::Error*)::{lambda(SEUpdaterUtil::Error*)#1}::operator() const(SEUpdaterUtil::Error*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<SEUpdaterUtil::Error *,std::shared_ptr<SEUpdaterUtil::Error> ctu::SharedSynchronizable<SEUpdaterUtil::Error>::make_shared_ptr<SEUpdaterUtil::Error>(SEUpdaterUtil::Error*)::{lambda(SEUpdaterUtil::Error *)#1},std::allocator<SEUpdaterUtil::Error>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<SEUpdaterUtil::Error> ctu::SharedSynchronizable<SEUpdaterUtil::Error>::make_shared_ptr<SEUpdaterUtil::Error>(SEUpdaterUtil::Error*)::{lambda(SEUpdaterUtil::Error*)#1}::operator() const(SEUpdaterUtil::Error*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  _QWORD *v1;
  _QWORD *v2;
  void **v3;

  if (result)
  {
    v1 = (_QWORD *)result;
    v3 = (void **)(result + 32);
    std::vector<std::pair<std::string,int>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v2 = ctu::SharedSynchronizable<SEUpdaterUtil::Error>::~SharedSynchronizable(v1);
    return MEMORY[0x22078A808](v2, 0x20C400FA29667);
  }
  return result;
}

_QWORD *ctu::SharedSynchronizable<SEUpdaterUtil::Error>::~SharedSynchronizable(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  v2 = a1[3];
  if (v2)
    dispatch_release(v2);
  v3 = a1[2];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[1];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void std::vector<std::pair<std::string,int>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::pair<std::string,int>>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

_QWORD *ctu::cf::CFSharedRef<__CFData const>::CFSharedRef<void const,void>(_QWORD *a1, CFTypeRef *a2)
{
  CFTypeRef v3;
  CFTypeID v4;
  const void *v5;

  v3 = *a2;
  if (*a2)
  {
    v4 = CFGetTypeID(*a2);
    if (v4 == CFDataGetTypeID())
      v5 = v3;
    else
      v5 = 0;
  }
  else
  {
    v5 = 0;
  }
  return ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::SharedRef(a1, v5);
}

_QWORD *std::allocate_shared[abi:ne180100]<SERestoreInfo::BLOB,std::allocator<SERestoreInfo::BLOB>,__CFData const*,void>@<X0>(CFTypeRef *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x38uLL);
  result = std::__shared_ptr_emplace<SERestoreInfo::BLOB>::__shared_ptr_emplace[abi:ne180100]<__CFData const*,std::allocator<SERestoreInfo::BLOB>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_21CCBEC84(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<SERestoreInfo::BLOB>::__shared_ptr_emplace[abi:ne180100]<__CFData const*,std::allocator<SERestoreInfo::BLOB>,0>(_QWORD *a1, CFTypeRef *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_24E0C1030;
  SERestoreInfo::BLOB::BLOB((SERestoreInfo::BLOB *)(a1 + 3), *a2);
  return a1;
}

void sub_21CCBECD4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<SERestoreInfo::BLOB>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C1030;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::BLOB>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C1030;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::BLOB>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

SERestoreInfo::BLOB *SERestoreInfo::BLOB::BLOB(SERestoreInfo::BLOB *this, CFTypeRef cf)
{
  const __CFData *v3;

  *(_QWORD *)this = &unk_24E0BFCD0;
  v3 = (const __CFData *)CFRetain(cf);
  *((_QWORD *)this + 3) = v3;
  *((_QWORD *)this + 1) = CFDataGetBytePtr(v3);
  *((_QWORD *)this + 2) = CFDataGetLength(*((CFDataRef *)this + 3));
  return this;
}

void std::__shared_ptr_emplace<SERestoreInfo::P73BaseFirmware>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1080;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::P73BaseFirmware>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1080;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::P73BaseFirmware>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::allocate_shared[abi:ne180100]<SEUpdater::SEHandleShim,std::allocator<SEUpdater::SEHandleShim>,std::shared_ptr<SEUpdater::P73BaseSEController> &,void>(_QWORD *a1, uint64_t a2, std::__shared_weak_count *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;

  v6 = operator new(0x30uLL);
  v7 = v6;
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_24E0C10D0;
  v8 = v6 + 3;
  if (a3)
  {
    p_shared_owners = (unint64_t *)&a3->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    v6[3] = &off_24E0C1120;
    v6[4] = a2;
    v6[5] = a3;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
  else
  {
    v6[3] = &off_24E0C1120;
    v6[4] = a2;
    v6[5] = 0;
  }
  *a1 = v8;
  a1[1] = v7;
}

void std::__shared_ptr_emplace<SEUpdater::SEHandleShim>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C10D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SEUpdater::SEHandleShim>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C10D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SEUpdater::SEHandleShim>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 24) + 8))(a1 + 24);
}

void SEUpdater::SEHandleShim::Transceive(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  const void *v5;
  uint64_t v6;
  size_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  _QWORD v19[2];
  std::__shared_weak_count *v20;

  SERestoreInfo::CApdu::CApdu((SERestoreInfo::CApdu *)v19, *(const unsigned __int8 **)a2, *(_QWORD *)(a2 + 8) - *(_QWORD *)a2, 0);
  SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v16, 0x2037uLL);
  v16 = (uint64_t *)&unk_24E0BF828;
  SEUpdater::P73BaseSEController::transceive(*(_QWORD *)(a1 + 8), (uint64_t)v19, &v16, 0, (SEUpdaterUtil::SELogObj *)3, 1);
  v5 = *(const void **)v17;
  v6 = *(_QWORD *)(v17 + 8);
  v7 = v6 - *(_QWORD *)v17;
  v15 = 0;
  v14 = 0uLL;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v14, v5, v6, v7);
  *(_OWORD *)a3 = v14;
  *(_QWORD *)(a3 + 16) = v15;
  *(_BYTE *)(a3 + 24) = 1;
  v16 = (uint64_t *)&unk_24E0BF880;
  v8 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v19[0] = &unk_24E0BF880;
  v11 = v20;
  if (v20)
  {
    v12 = (unint64_t *)&v20->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_21CCBF030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  void *v10;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, void *);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  v10 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void SEUpdater::SEHandleShim::~SEHandleShim(SEUpdater::SEHandleShim *this)
{
  *(_QWORD *)this = &off_24E0C1120;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &off_24E0C1120;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

SERestoreInfo::CApdu *SERestoreInfo::CApdu::CApdu(SERestoreInfo::CApdu *this, const unsigned __int8 *a2, size_t a3, uint64_t a4)
{
  SERestoreInfo::Apdu *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;

  v6 = SERestoreInfo::Apdu::Apdu(this, a2, a3);
  v7 = (_QWORD *)*((_QWORD *)v6 + 1);
  *(_QWORD *)v6 = &unk_24E0BF960;
  v9 = v7;
  v8 = *v7;
  v10 = v9[1] - v8;
  v11 = v10 - 5;
  v12 = v10 >= 6;
  v13 = v8 + 5;
  if (!v12)
  {
    v11 = 0;
    v13 = 0;
  }
  *((_QWORD *)v6 + 4) = v13;
  *((_QWORD *)v6 + 5) = v11;
  *((_QWORD *)v6 + 3) = v8;
  SERestoreInfo::CApdu::validate(v6);
  *((_QWORD *)this + 6) = a4;
  return this;
}

void sub_21CCBF164(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  *v1 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

SERestoreInfo::Apdu *SERestoreInfo::Apdu::Apdu(SERestoreInfo::Apdu *this, const unsigned __int8 *a2, size_t a3)
{
  unint64_t **v3;
  _QWORD *v7;
  const char *v9;
  int v10;

  *(_QWORD *)this = &unk_24E0BF880;
  *((_QWORD *)this + 1) = 0;
  v3 = (unint64_t **)((char *)this + 8);
  *((_QWORD *)this + 2) = 0;
  if (!a2)
  {
    v9 = "data";
    v10 = 112;
    goto LABEL_6;
  }
  if (a3 >> 3 >= 0x407)
  {
    v9 = "len <= MAX_APDU_LEN";
    v10 = 113;
LABEL_6:
    __assert_rtn("Apdu", "Apdu.hpp", v10, v9);
  }
  v7 = (_QWORD *)operator new();
  *v7 = 0;
  v7[1] = 0;
  v7[2] = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v7, a2, (uint64_t)&a2[a3], a3);
  std::shared_ptr<std::vector<unsigned char>>::reset[abi:ne180100]<std::vector<unsigned char>,void>(v3, (uint64_t)v7);
  std::vector<unsigned char>::reserve(*v3, 0x2037uLL);
  return this;
}

void sub_21CCBF26C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x22078A808](v2, 0x10C402FEFCB83);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<SEUpdater::LogSinkShim>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1170;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SEUpdater::LogSinkShim>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1170;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SEUpdater::LogSinkShim>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 24) + 8))(a1 + 24);
}

void SEUpdater::LogSinkShim::Log(uint64_t a1, uint64_t a2)
{
  SEUpdaterUtil::SELogObj *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  const char *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  __int128 v13;

  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v3 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v13);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v13);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
    if (*((_QWORD *)&v13 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    v3 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v7 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v8 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  if (*(char *)(a2 + 23) >= 0)
    v10 = (const char *)a2;
  else
    v10 = *(const char **)a2;
  SEUpdaterUtil::SELogObj::printLog(v3, (SEUpdaterUtil::SELogObj *)2, 0, 0, 0, (SEUpdaterUtil::SELogObj *)"%s\n", v10);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_21CCBF418(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

void SEUpdater::LogSinkShim::~LogSinkShim(SEUpdater::LogSinkShim *this)
{
  JUMPOUT(0x22078A808);
}

uint64_t *std::unique_ptr<SEUpdaterUtil::SN300V2Image4Signer>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    *(_QWORD *)v2 = off_24E0C18A8;
    ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)(v2 + 8));
    JUMPOUT(0x22078A808);
  }
  return result;
}

id DERDecodeData(NSData *a1, uint64_t a2)
{
  NSData *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  _QWORD v8[2];
  unint64_t v9;
  _QWORD v10[2];

  v3 = a1;
  v9 = 0;
  v10[0] = 0;
  v10[1] = 0;
  v8[0] = -[NSData DERItem](v3, "DERItem");
  v8[1] = v4;
  v5 = DERDecodeItem((uint64_t)v8, &v9);
  if ((_DWORD)v5)
  {
    _ObjCLog(0, "DERDecodeData", CFSTR("Failed to decode with dr %d\n"), v5);
  }
  else
  {
    if (a2 == -1 || v9 == a2)
    {
      objc_msgSend(MEMORY[0x24BDBCE50], "dataWithDERItem:", v10);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      goto LABEL_7;
    }
    _ObjCLog(0, "DERDecodeData", CFSTR("Unexpected tag encountered 0x%llx, expected tag 0x%llx\n"), v9, a2);
  }
  v6 = 0;
LABEL_7:

  return v6;
}

void sub_21CCBF584(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t DERParseSequence(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t a5)
{
  uint64_t v10;
  uint64_t v11;
  unint64_t v13;
  unint64_t v14[2];

  bzero(a4, a5);
  v13 = 0;
  v14[0] = 0;
  v14[1] = 0;
  v10 = DERDecodeItem(a1, &v13);
  if ((_DWORD)v10)
  {
    v11 = v10;
    _ObjCLog(0, "DERParseSequence", CFSTR("Failed to decode with dr %d\n"), v10);
  }
  else if (a3 == -1 || v13 == a3)
  {
    return (uint64_t)DERParseSequenceContent(v14, *(unsigned __int16 *)(a2 + 8), *(_QWORD *)a2, (unint64_t)a4, a5);
  }
  else
  {
    _ObjCLog(0, "DERParseSequence", CFSTR("Expected tag 0x%llx, got tag 0x%llx\n"), a3, v13);
    return 2;
  }
  return v11;
}

uint64_t DERParseSequenceSpec(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t a5)
{
  uint64_t result;
  unint64_t v11;
  unint64_t v12[2];

  bzero(a4, a5);
  v11 = 0;
  v12[0] = 0;
  v12[1] = 0;
  result = DERDecodeItem(a2, &v11);
  if (!(_DWORD)result)
  {
    if (v11 == a1)
      return (uint64_t)DERParseSequenceContent(v12, *(unsigned __int16 *)(a3 + 8), *(_QWORD *)a3, (unint64_t)a4, a5);
    else
      return 2;
  }
  return result;
}

unint64_t *DERParseSequenceSpecContent(void *a1, uint64_t a2, unint64_t a3, size_t a4)
{
  id v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v11[2];

  v7 = a1;
  v11[0] = objc_msgSend(v7, "DERItem");
  v11[1] = v8;
  v9 = DERParseSequenceContent(v11, *(unsigned __int16 *)(a2 + 8), *(_QWORD *)a2, a3, a4);

  return v9;
}

void sub_21CCBF780(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id encodeSequence(uint64_t a1, unint64_t a2, unsigned int a3, uint64_t a4)
{
  id v8;
  uint64_t v9;
  id v10;
  uint64_t v12;

  v12 = DERLengthOfEncodedSequence(a1, a2, a3, a4);
  objc_msgSend(MEMORY[0x24BDBCEC8], "dataWithLength:", v12);
  v8 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v9 = DEREncodeSequence(a1, a2, a3, a4, objc_msgSend(v8, "mutableBytes"), (unint64_t *)&v12);
  if ((_DWORD)v9)
  {
    _ObjCLog(0, "encodeSequence", CFSTR("while encoding extensions : %d\n"), v9);
    v10 = 0;
  }
  else
  {
    v10 = v8;
  }

  return v10;
}

void sub_21CCBF84C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id splitDERSeq(NSData *a1, uint64_t a2)
{
  NSData *v3;
  unint64_t v4;
  unint64_t *v5;
  id v6;
  void *v7;
  unint64_t v8;
  void *v9;
  unint64_t v11[3];
  unint64_t v12[2];
  unint64_t v13[2];

  v3 = a1;
  v13[0] = -[NSData DERItem](v3, "DERItem");
  v13[1] = v4;
  v12[0] = 0;
  v12[1] = 0;
  v5 = DERDecodeSeqContentInit(v13, v12);
  if ((_DWORD)v5)
  {
    _ObjCLog(0, "splitDERSeq", CFSTR("Attempting to split a non DER sequence %d\n"), v5);
    v6 = 0;
  }
  else
  {
    v7 = (void *)objc_opt_new();
    while (1)
    {
      v8 = v12[0];
      memset(v11, 0, sizeof(v11));
      if (DERDecodeSeqNext(v12, v11) == 1)
      {
        v6 = v7;
        goto LABEL_9;
      }
      if (v11[0] != a2)
        break;
      objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytes:length:", v8, v12[0] - v8);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "addObject:", v9);

    }
    _ObjCLog(0, "splitDERSeq", CFSTR("Unexpected tag encountered 0x%llx, expected tag 0x%llx\n"), v11[0], a2);
    v6 = 0;
LABEL_9:

  }
  return v6;
}

void sub_21CCBF980(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

SERestoreInfo::SN210VDeviceInfo *SERestoreInfo::SN210VDeviceInfo::SN210VDeviceInfo(SERestoreInfo::SN210VDeviceInfo *this, const SERestoreInfo::BLOB *a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  SERestoreInfo::SEWrongDeviceInfo *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_24E0C12C8;
  if (*((_DWORD *)v3 + 14) != 210)
  {
    exception = (SERestoreInfo::SEWrongDeviceInfo *)__cxa_allocate_exception(0x48uLL);
    SERestoreInfo::SEWrongDeviceInfo::SEWrongDeviceInfo(exception);
  }
  return this;
}

void sub_21CCBFA28(_Unwind_Exception *a1)
{
  SERestoreInfo::P73BaseDeviceInfo *v1;

  SERestoreInfo::P73BaseDeviceInfo::~P73BaseDeviceInfo(v1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::SN210VDeviceInfo::~SN210VDeviceInfo(SERestoreInfo::SN210VDeviceInfo *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
  JUMPOUT(0x22078A808);
}

uint64_t SEUpdaterUtil::SN300V2Image4Signer::getSigningAlgorithm(SEUpdaterUtil::SN300V2Image4Signer *this)
{
  return 1;
}

_QWORD *SEUpdaterUtil::SN300V2Image4Signer::getSigningKey@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SN300V2Image4Signer::getSigningKey(void)const::signingKey, (uint64_t)&SEUpdaterUtil::SN300V2Image4Signer::getSigningCert(void)const::signingCert, 0xA7uLL);
}

_QWORD *SEUpdaterUtil::SN300V2Image4Signer::getSigningCert@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SN300V2Image4Signer::getSigningCert(void)const::signingCert, (uint64_t)"N13SEUpdaterUtil19SN300V2Image4SignerE", 0x2E3uLL);
}

void SEUpdaterUtil::SN300V2Image4Signer::~SN300V2Image4Signer(const void **this)
{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
}

{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
  JUMPOUT(0x22078A808);
}

void **SERestoreInfo::P73DeviceInfo::P73DeviceInfo(void **this, const SERestoreInfo::BLOB *a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  SERestoreInfo::SEWrongDeviceInfo *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo((SERestoreInfo::P73BaseDeviceInfo *)this, a2);
  *(_QWORD *)v3 = &off_24E0C1378;
  if (*((_DWORD *)v3 + 14) != 115)
  {
    exception = (SERestoreInfo::SEWrongDeviceInfo *)__cxa_allocate_exception(0x48uLL);
    SERestoreInfo::SEWrongDeviceInfo::SEWrongDeviceInfo(exception);
  }
  if (SERestoreInfo::isDummyRootCaKeyId((uint64_t)(this + 11)))
    SERestoreInfo::fixRootCaKeyId(this + 11, (uint64_t)(this + 14));
  return this;
}

void sub_21CCBFCD0(_Unwind_Exception *a1)
{
  SERestoreInfo::P73BaseDeviceInfo *v1;
  void *v2;

  __cxa_free_exception(v2);
  SERestoreInfo::P73BaseDeviceInfo::~P73BaseDeviceInfo(v1);
  _Unwind_Resume(a1);
}

BOOL SERestoreInfo::isDummyRootCaKeyId(uint64_t a1)
{
  const void *v2;
  size_t v3;
  _BYTE *v4;
  _BOOL8 v5;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;

  v7 = 0;
  v8 = 0;
  v9 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&v7, &SERestoreInfo::isDummyRootCaKeyId(std::vector<unsigned char> const&)::dummyRootCaKeyIdArray, (uint64_t)&SERestoreInfo::isProdCometIm4KeyId(std::vector<unsigned char> const&)::prodCometIm4KeyIdArray, 0x20uLL);
  v2 = *(const void **)a1;
  v3 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  v4 = v7;
  if (v3 == v8 - v7)
  {
    v5 = memcmp(v2, v7, v3) == 0;
    if (!v4)
      return v5;
    goto LABEL_5;
  }
  v5 = 0;
  if (v7)
  {
LABEL_5:
    v8 = v4;
    operator delete(v4);
  }
  return v5;
}

void SERestoreInfo::fixRootCaKeyId(void **a1, uint64_t a2)
{
  const void *v4;
  size_t v5;
  _BYTE *v6;
  _BOOL4 v7;
  void *__p;
  char *v9;
  _BYTE *v10;
  _BYTE *v11;
  uint64_t v12;

  v10 = 0;
  v11 = 0;
  v12 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&v10, &SERestoreInfo::isProdCometIm4KeyId(std::vector<unsigned char> const&)::prodCometIm4KeyIdArray, (uint64_t)&unk_21CCDA5D2, 0x20uLL);
  v4 = *(const void **)a2;
  v5 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  v6 = v10;
  if (v5 != v11 - v10)
  {
    v7 = 0;
    if (!v10)
      goto LABEL_6;
    goto LABEL_5;
  }
  v7 = memcmp(v4, v10, v5) == 0;
  if (v6)
  {
LABEL_5:
    v11 = v6;
    operator delete(v6);
  }
LABEL_6:
  RootCA::getRootKeyId(v7, 115, &__p);
  if (&__p != a1)
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, (char *)__p, v9, v9 - (_BYTE *)__p);
  if (__p)
  {
    v9 = (char *)__p;
    operator delete(__p);
  }
}

void sub_21CCBFE50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SERestoreInfo::P73DeviceInfo::~P73DeviceInfo(SERestoreInfo::P73DeviceInfo *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
  JUMPOUT(0x22078A808);
}

void PTCUtil::deletePTCKeysWithNoStoredPK(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3;
  int v4;
  unsigned int v5;
  SETransceiveHelper *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  id v13;
  void *v14;
  id v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t j;
  void *v19;
  unint64_t *v20;
  void *v21;
  NSString *v22;
  uint64_t v23;
  void *exception;
  void *v25;
  id obj;
  uint64_t v27;
  uint64_t v28;
  uint64_t i;
  SETransceiveHelper *v30;
  SETransceiveHelper *v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  id v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  _BYTE v49[128];
  _BYTE v50[128];
  _QWORD v51[4];

  v51[2] = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  v4 = *(_DWORD *)(*a2 + 56);
  if (v4 == 100)
  {
    v5 = *(_DWORD *)(v3 + 12) - 2719;
  }
  else
  {
    if (v4 != 115)
      return;
    v5 = *(_DWORD *)(v3 + 12) - 2451;
  }
  if (v5 >= 0xFFFFFF79)
  {
    _ObjCLog((SEUpdaterUtil::SELogObj *)2, "deletePTCKeysWithNoStoredPK", CFSTR("Performing cleanup of old PTC keys\n"));
    v6 = [SETransceiveHelper alloc];
    v7 = (std::__shared_weak_count *)a1[1];
    v47 = *a1;
    v48 = v7;
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
    v30 = -[SETransceiveHelper initWithSEController:](v6, "initWithSEController:", &v47);
    v10 = v48;
    if (v48)
    {
      v11 = (unint64_t *)&v48->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v51[0] = CFSTR("A000000704C0000000000001");
    v51[1] = CFSTR("A000000704C0000000000002");
    objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v51, 2);
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    obj = (id)objc_claimAutoreleasedReturnValue();
    v28 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v43, v50, 16);
    if (v28)
    {
      v27 = *(_QWORD *)v44;
      do
      {
        for (i = 0; i != v28; ++i)
        {
          if (*(_QWORD *)v44 != v27)
            objc_enumerationMutation(obj);
          v31 = *(SETransceiveHelper **)(*((_QWORD *)&v43 + 1) + 8 * i);
          -[SETransceiveHelper selectWithAID:](v30, "selectWithAID:");
          v13 = (id)objc_claimAutoreleasedReturnValue();
          if (v13)
          {
            _ObjCLog(0, "deletePTCKeysWithNoStoredPK", CFSTR("Failed to select %@\n"), v31);
          }
          else
          {
            v42 = 0;
            PTCCommand::ptc_listKeys(v30, v31, (uint64_t *)&v42);
            v14 = (void *)objc_claimAutoreleasedReturnValue();
            v13 = v42;
            if (!v14)
            {
              exception = __cxa_allocate_exception(0x48uLL);
              std::string::basic_string[abi:ne180100]<0>(&v32, "While listing keys");
              v25 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, &v32, 1, CFSTR("SEUpdaterErrorDomain"));
            }
            v40 = 0u;
            v41 = 0u;
            v38 = 0u;
            v39 = 0u;
            v15 = v14;
            v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v38, v49, 16);
            if (v16)
            {
              v17 = *(_QWORD *)v39;
              do
              {
                for (j = 0; j != v16; ++j)
                {
                  if (*(_QWORD *)v39 != v17)
                    objc_enumerationMutation(v15);
                  v19 = *(void **)(*((_QWORD *)&v38 + 1) + 8 * j);
                  v36 = 0u;
                  v37 = 0u;
                  v34 = 0u;
                  v35 = 0u;
                  v32 = 0u;
                  v33 = 0u;
                  v20 = DERParseSequenceSpecContent(v19, (uint64_t)&PTKeyInSlotSpec, (unint64_t)&v32, 0x60uLL);
                  if ((_DWORD)v20)
                  {
                    objc_msgSend(v19, "asHexString");
                    v21 = (void *)objc_claimAutoreleasedReturnValue();
                    _ObjCLog(0, "deletePTCKeysWithNoStoredPK", CFSTR("Failed to parse key data %d %@\n"), v20, v21);

                  }
                  else
                  {
                    v22 = (NSString *)(bswap32(*(unsigned __int16 *)v33) >> 16);
                    _ObjCLog((SEUpdaterUtil::SELogObj *)2, "deletePTCKeysWithNoStoredPK", CFSTR("PTC key in slot %d to be deleted %d\n"), v22, *((_QWORD *)&v36 + 1) == 0);
                    if (!*((_QWORD *)&v36 + 1))
                    {
                      PTCCommand::ptc_DeleteKey((PTCCommand *)v30, v31, v22);
                      v23 = objc_claimAutoreleasedReturnValue();

                      v13 = (id)v23;
                      _ObjCLog((SEUpdaterUtil::SELogObj *)2, "deletePTCKeysWithNoStoredPK", CFSTR("PTC key deleted with error %@\n"), v23);
                    }
                  }
                }
                v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v38, v49, 16);
              }
              while (v16);
            }

          }
        }
        v28 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v43, v50, 16);
      }
      while (v28);
    }

    _ObjCLog((SEUpdaterUtil::SELogObj *)2, "deletePTCKeysWithNoStoredPK", CFSTR("Cleanup complete\n"));
  }
}

void sub_21CCC03B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{

  _Unwind_Resume(a1);
}

void PTCUtil::workaroundForPTCExport(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  SEUpdaterUtil::SELogObj *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  __int128 v39;
  std::__shared_weak_count *v40;
  uint64_t *v41;
  _QWORD *v42;
  std::__shared_weak_count *v43;
  uint64_t *v44;
  _QWORD *v45;
  std::__shared_weak_count *v46;
  uint64_t *v47;
  _QWORD *v48;
  std::__shared_weak_count *v49;
  __int128 v50;
  __int16 v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(*(_QWORD *)a2 + 12) == *(_DWORD *)(*(_QWORD *)a2 + 24)
    && *(_DWORD *)(*(_QWORD *)a2 + 28) == 23195)
  {
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v47, 0x2037uLL);
    v47 = (uint64_t *)&unk_24E0BF828;
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v44, 0x2037uLL);
    v44 = (uint64_t *)&unk_24E0BF828;
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v41, 0x2037uLL);
    v41 = (uint64_t *)&unk_24E0BF828;
    v3 = *a1;
    v50 = xmmword_21CCDA668;
    v51 = 1;
    SERestoreInfo::CApdu::CApdu(&v39, &v50, 0x12uLL, 0);
    *(_QWORD *)&v39 = &off_24E0C13D8;
    SEUpdater::P73BaseSEController::transceive(v3, (uint64_t)&v39, &v47, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    *(_QWORD *)&v39 = &unk_24E0BF880;
    v4 = v40;
    if (v40)
    {
      p_shared_owners = (unint64_t *)&v40->__shared_owners_;
      do
        v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    v7 = *a1;
    v50 = xmmword_21CCDA6A1;
    v51 = 2;
    SERestoreInfo::CApdu::CApdu(&v39, &v50, 0x12uLL, 0);
    *(_QWORD *)&v39 = &off_24E0C1420;
    SEUpdater::P73BaseSEController::transceive(v7, (uint64_t)&v39, &v44, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    *(_QWORD *)&v39 = &unk_24E0BF880;
    v8 = v40;
    if (v40)
    {
      v9 = (unint64_t *)&v40->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v11 = *a1;
    SEUpdater::CommandSelectISD::CommandSelectISD((SEUpdater::CommandSelectISD *)&v39);
    SEUpdater::P73BaseSEController::transceive(v11, (uint64_t)&v39, &v41, 0, (SEUpdaterUtil::SELogObj *)3, 1);
    *(_QWORD *)&v39 = &unk_24E0BF880;
    v12 = v40;
    if (v40)
    {
      v13 = (unint64_t *)&v40->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v15 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v39);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v39);
      v16 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
      if (*((_QWORD *)&v39 + 1))
      {
        v17 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v15 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v19 = (std::__shared_weak_count *)off_2553234C8;
    *(_QWORD *)&v50 = v15;
    *((_QWORD *)&v50 + 1) = off_2553234C8;
    if (off_2553234C8)
    {
      v20 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v22 = v48[1];
    if ((unint64_t)(v22 - *v48) < 2)
      v23 = 43947;
    else
      v23 = *(unsigned __int8 *)(v22 - 1) | (*(unsigned __int8 *)(v22 - 2) << 8);
    v24 = v45[1];
    if ((unint64_t)(v24 - *v45) < 2)
      v25 = 43947;
    else
      v25 = *(unsigned __int8 *)(v24 - 1) | (*(unsigned __int8 *)(v24 - 2) << 8);
    v26 = v42[1];
    if ((unint64_t)(v26 - *v42) < 2)
      v27 = 43947;
    else
      v27 = *(unsigned __int8 *)(v26 - 1) | (*(unsigned __int8 *)(v26 - 2) << 8);
    SEUpdaterUtil::SELogObj::printLog(v15, (SEUpdaterUtil::SELogObj *)2, 0, 1, "workaroundForPTCExport", (SEUpdaterUtil::SELogObj *)"Select PT: SW1 0x%x SW2 0x%x SW3 0x%x\n", v23, v25, v27);
    if (v19)
    {
      v28 = (unint64_t *)&v19->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v41 = (uint64_t *)&unk_24E0BF880;
    v30 = v43;
    if (v43)
    {
      v31 = (unint64_t *)&v43->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    v44 = (uint64_t *)&unk_24E0BF880;
    v33 = v46;
    if (v46)
    {
      v34 = (unint64_t *)&v46->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    v47 = (uint64_t *)&unk_24E0BF880;
    v36 = v49;
    if (v49)
    {
      v37 = (unint64_t *)&v49->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
  }
}

void sub_21CCC0914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  uint64_t v15;
  va_list va;
  uint64_t v17;
  void *v18;
  va_list va1;

  va_start(va1, a13);
  va_start(va, a13);
  v15 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, void *);
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  v18 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  *(_QWORD *)(v13 - 88) = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v13 - 80);
  _Unwind_Resume(a1);
}

void sub_21CCC0A00()
{
  JUMPOUT(0x21CCC09C0);
}

void sub_21CCC0A08()
{
  JUMPOUT(0x21CCC09DCLL);
}

void sub_21CCC0A10()
{
  JUMPOUT(0x21CCC09F8);
}

void SEUpdater::CommandSelectPTInstance1::~CommandSelectPTInstance1(SEUpdater::CommandSelectPTInstance1 *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void SEUpdater::CommandSelectPTInstance2::~CommandSelectPTInstance2(SEUpdater::CommandSelectPTInstance2 *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

uint64_t SEUpdaterUtil::SN100VImage4Signer::getSigningAlgorithm(SEUpdaterUtil::SN100VImage4Signer *this)
{
  return 0;
}

_QWORD *SEUpdaterUtil::SN100VImage4Signer::getSigningKey@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SN100VImage4Signer::getSigningKey(void)const::signingKey, (uint64_t)&SEUpdaterUtil::SN100VImage4Signer::getSigningCert(void)const::signingCert, 0x79uLL);
}

_QWORD *SEUpdaterUtil::SN100VImage4Signer::getSigningCert@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SN100VImage4Signer::getSigningCert(void)const::signingCert, (uint64_t)"N13SEUpdaterUtil18SN100VImage4SignerE", 0x274uLL);
}

void SEUpdaterUtil::SN100VImage4Signer::~SN100VImage4Signer(const void **this)
{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
}

{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
  JUMPOUT(0x22078A808);
}

void WriteEvent(uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;
  void *v5;
  id v6;
  void *v7;
  void *v8;
  SEUpdaterUtil::SELogObj *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  SEUpdaterUtil::SELogObj *v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  char v32;
  SEUpdaterUtil::SELogObj *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  const char *v40;
  id v41;
  unint64_t *v42;
  unint64_t v43;
  SEUpdaterUtil::SELogObj *v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  id v50;
  unint64_t *v51;
  SEUpdaterUtil::SELogObj *v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t *v56;
  unint64_t v57;
  id v58;
  unint64_t *v59;
  void *v60;
  id v61;
  id v62;
  id v63;
  SEUpdaterUtil::SELogObj *v64;
  void *v65;
  __int128 v66;
  _QWORD v67[2];
  _QWORD v68[3];

  v68[2] = *MEMORY[0x24BDAC8D0];
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@%@"), *a2, CFSTR("SEUpdaterEventsLog.plist"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3)
  {
    objc_msgSend(MEMORY[0x24BDBCE50], "dataWithContentsOfFile:", v3);
    v60 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = (void *)objc_opt_new();
    if (v60)
    {
      v63 = 0;
      objc_msgSend(MEMORY[0x24BDD1770], "propertyListWithData:options:format:error:", v60, 2, 0, &v63);
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      v6 = v63;
      v7 = v6;
      if (!v5 || v6)
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v18 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v66);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v66);
          v19 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
          if (*((_QWORD *)&v66 + 1))
          {
            v20 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
            do
              v21 = __ldaxr(v20);
            while (__stlxr(v21 - 1, v20));
            if (!v21)
            {
              ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
              std::__shared_weak_count::__release_weak(v19);
            }
          }
          v18 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v22 = (std::__shared_weak_count *)off_2553234C8;
        v64 = v18;
        v65 = off_2553234C8;
        if (off_2553234C8)
        {
          v23 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v24 = __ldxr(v23);
          while (__stxr(v24 + 1, v23));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v18, (SEUpdaterUtil::SELogObj *)2, 0, 1, "WriteEvent", (SEUpdaterUtil::SELogObj *)"EVENT LOGGING: Could not recreate log events properties from file - Defaulting to empty file\n");
        if (v22)
        {
          p_shared_owners = (unint64_t *)&v22->__shared_owners_;
          do
            v26 = __ldaxr(p_shared_owners);
          while (__stlxr(v26 - 1, p_shared_owners));
          if (!v26)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
      }
      else
      {
        objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("events"));
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        if (v8)
          objc_msgSend(v4, "addObjectsFromArray:", v8);

      }
    }
    else
    {
      v7 = 0;
    }
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", a1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    if ((objc_msgSend(v4, "containsObject:", v27) & 1) == 0)
      objc_msgSend(v4, "addObject:", v27);
    v67[0] = CFSTR("version");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInteger:", 1);
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    v67[1] = CFSTR("events");
    v68[0] = v28;
    v68[1] = v4;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v68, v67, 2);
    v29 = (void *)objc_claimAutoreleasedReturnValue();

    v62 = 0;
    objc_msgSend(MEMORY[0x24BDD1770], "dataWithPropertyList:format:options:error:", v29, 200, 0, &v62);
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    v31 = v62;

    if (!v30 || v31)
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v44 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v66);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v66);
        v45 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
        if (*((_QWORD *)&v66 + 1))
        {
          v46 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
          do
            v47 = __ldaxr(v46);
          while (__stlxr(v47 - 1, v46));
          if (!v47)
          {
            ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
            std::__shared_weak_count::__release_weak(v45);
          }
        }
        v44 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v37 = (std::__shared_weak_count *)off_2553234C8;
      v64 = v44;
      v65 = off_2553234C8;
      if (off_2553234C8)
      {
        v48 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v49 = __ldxr(v48);
        while (__stxr(v49 + 1, v48));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      objc_msgSend(v31, "description");
      v50 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      SEUpdaterUtil::SELogObj::printLog(v44, (SEUpdaterUtil::SELogObj *)2, 0, 1, "WriteEvent", (SEUpdaterUtil::SELogObj *)"EVENT LOGGING: Unable to serialize data - %s\n", (const char *)objc_msgSend(v50, "UTF8String"));

      if (!v37)
        goto LABEL_88;
      v51 = (unint64_t *)&v37->__shared_owners_;
      do
        v43 = __ldaxr(v51);
      while (__stlxr(v43 - 1, v51));
    }
    else
    {
      v61 = 0;
      v32 = objc_msgSend(v30, "writeToFile:options:error:", v3, 0, &v61);
      v31 = v61;
      if ((v32 & 1) != 0)
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v33 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v66);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v66);
          v34 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
          if (*((_QWORD *)&v66 + 1))
          {
            v35 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
            do
              v36 = __ldaxr(v35);
            while (__stlxr(v36 - 1, v35));
            if (!v36)
            {
              ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
              std::__shared_weak_count::__release_weak(v34);
            }
          }
          v33 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v37 = (std::__shared_weak_count *)off_2553234C8;
        v64 = v33;
        v65 = off_2553234C8;
        if (off_2553234C8)
        {
          v38 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v39 = __ldxr(v38);
          while (__stxr(v39 + 1, v38));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v40 = (const char *)objc_msgSend(objc_retainAutorelease(v3), "UTF8String");
        objc_msgSend(v4, "description");
        v41 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        SEUpdaterUtil::SELogObj::printLog(v33, (SEUpdaterUtil::SELogObj *)2, 0, 1, "WriteEvent", (SEUpdaterUtil::SELogObj *)"EVENT LOGGING: Successfully wrote to file %s with events %s:\n", v40, (const char *)objc_msgSend(v41, "UTF8String"));

        if (!v37)
          goto LABEL_88;
        v42 = (unint64_t *)&v37->__shared_owners_;
        do
          v43 = __ldaxr(v42);
        while (__stlxr(v43 - 1, v42));
      }
      else
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v52 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v66);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v66);
          v53 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
          if (*((_QWORD *)&v66 + 1))
          {
            v54 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
            do
              v55 = __ldaxr(v54);
            while (__stlxr(v55 - 1, v54));
            if (!v55)
            {
              ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
              std::__shared_weak_count::__release_weak(v53);
            }
          }
          v52 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v37 = (std::__shared_weak_count *)off_2553234C8;
        v64 = v52;
        v65 = off_2553234C8;
        if (off_2553234C8)
        {
          v56 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v57 = __ldxr(v56);
          while (__stxr(v57 + 1, v56));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        objc_msgSend(v31, "description");
        v58 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        SEUpdaterUtil::SELogObj::printLog(v52, (SEUpdaterUtil::SELogObj *)2, 0, 1, "WriteEvent", (SEUpdaterUtil::SELogObj *)"EVENT LOGGING: Error writing to file - %s\n", (const char *)objc_msgSend(v58, "UTF8String"));

        if (!v37)
          goto LABEL_88;
        v59 = (unint64_t *)&v37->__shared_owners_;
        do
          v43 = __ldaxr(v59);
        while (__stlxr(v43 - 1, v59));
      }
    }
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
LABEL_88:

    goto LABEL_89;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v9 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v66);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v66);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
    if (*((_QWORD *)&v66 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v9 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v13 = (std::__shared_weak_count *)off_2553234C8;
  v64 = v9;
  v65 = off_2553234C8;
  if (off_2553234C8)
  {
    v14 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v9, (SEUpdaterUtil::SELogObj *)2, 0, 1, "WriteEvent", (SEUpdaterUtil::SELogObj *)"EVENT LOGGING: Unable to recreate full file name with path\n");
  if (v13)
  {
    v16 = (unint64_t *)&v13->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
LABEL_89:

}

void sub_21CCC15A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);

  _Unwind_Resume(a1);
}

const void *SEUpdater::SEControllerBase::shutdown(const void **this)
{
  SEUpdaterUtil::SELogObj *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  const void *result;
  __int128 v12;

  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v12);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v12);
    v3 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
    if (*((_QWORD *)&v12 + 1))
    {
      v4 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v6 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v7 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v2, (SEUpdaterUtil::SELogObj *)2, 0, 1, "shutdown", (SEUpdaterUtil::SELogObj *)"Shutdown fSeHandle %p\n", this[1]);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  result = this[1];
  if (result)
  {
    result = (const void *)NfRestoreSEClose();
    this[1] = 0;
  }
  return result;
}

void sub_21CCC187C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t SEUpdater::SEControllerBase::transceiveInternal(SEUpdater::SEControllerBase *this, const unsigned __int8 *a2, unint64_t a3, unsigned __int8 *a4, unint64_t *a5)
{
  uint64_t v5;
  const char *v6;
  uint64_t v7;

  v5 = NfRestoreSETransceive();
  if (!(_DWORD)v5)
    return 0;
  v7 = 25;
  SEUpdaterUtil::_AddError((SEUpdaterUtil *)0x19, 1, (uint64_t)"transceiveInternal", (SEUpdaterUtil::SELogObj *)"NfRestoreSETransceive returns %d", v6, v5);
  return v7;
}

uint64_t SEUpdater::SEControllerBase::transceive(SEUpdater::SEControllerBase *this, const unsigned __int8 *a2, const unsigned __int8 *a3, unsigned __int8 *a4, unint64_t *a5, SEUpdaterUtil::SELogObj *a6, int a7)
{
  SEUpdaterUtil::SELogObj *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  uint64_t v23;
  SEUpdaterUtil::SELogObj *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  void *exception;
  std::string *v35;
  __int128 v36;
  std::string v37;
  __int128 v38;
  std::string::size_type v39;

  if (!*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v37, "Assertion: ");
    v35 = std::string::append(&v37, "fSeHandle");
    v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    v39 = v35->__r_.__value_.__r.__words[2];
    v38 = v36;
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v38);
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v14 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v38);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v38);
    v15 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
    if (*((_QWORD *)&v38 + 1))
    {
      v16 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v14 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v18 = (std::__shared_weak_count *)off_2553234C8;
  v37.__r_.__value_.__r.__words[0] = (std::string::size_type)v14;
  v37.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v19 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v14, a6, 0, 1, "transceive", (SEUpdaterUtil::SELogObj *)"transmitting C-APDU: %zu \n", (size_t)a3);
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  SEUpdaterUtil::SELogPrintBinary(a6, (uint64_t)a2, a3, a7);
  v23 = (*(uint64_t (**)(SEUpdater::SEControllerBase *, const unsigned __int8 *, const unsigned __int8 *, unsigned __int8 *, unint64_t *))(*(_QWORD *)this + 56))(this, a2, a3, a4, a5);
  if (!(_DWORD)v23)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v24 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v38);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v38);
      v25 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
      if (*((_QWORD *)&v38 + 1))
      {
        v26 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      v24 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v28 = (std::__shared_weak_count *)off_2553234C8;
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
    v37.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v29 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v24, a6, 0, 1, "transceive", (SEUpdaterUtil::SELogObj *)"receiving R-APDU: %zu \n", *a5);
    if (v28)
    {
      v31 = (unint64_t *)&v28->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    SEUpdaterUtil::SELogPrintBinary(a6, (uint64_t)a4, (const unsigned __int8 *)*a5, a7);
  }
  return v23;
}

void sub_21CCC1C1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t SEUpdater::SEControllerBase::transceive(SEUpdater::SEControllerBase *this, const SERestoreInfo::CApdu *a2, SERestoreInfo::RApdu *a3, SEUpdaterUtil::SELogObj *a4, int a5)
{
  uint64_t v10;
  unint64_t v11;
  SEUpdaterUtil::SELogObj *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  SEUpdaterUtil::SELogObj *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  void *exception;
  std::string *v35;
  __int128 v36;
  uint64_t v37;
  std::string v38;
  __int128 v39;
  std::string::size_type v40;

  if (!*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v38, "Assertion: ");
    v35 = std::string::append(&v38, "fSeHandle");
    v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    v40 = v35->__r_.__value_.__r.__words[2];
    v39 = v36;
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v39);
  }
  v10 = *((_QWORD *)a3 + 1);
  v11 = *(_QWORD *)(v10 + 16) - *(_QWORD *)v10;
  LOBYTE(v39) = 0;
  std::vector<unsigned char>::assign((char **)v10, v11, (char *)&v39);
  v37 = *(_QWORD *)(*((_QWORD *)a3 + 1) + 8) - **((_QWORD **)a3 + 1);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v12 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v39);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v39);
    v13 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
    if (*((_QWORD *)&v39 + 1))
    {
      v14 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    v12 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v16 = (std::__shared_weak_count *)off_2553234C8;
  v38.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
  v38.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v17 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v12, a4, 0, 1, "transceive", (SEUpdaterUtil::SELogObj *)"transmitting C-APDU: %zu \n", *(_QWORD *)(*((_QWORD *)a2 + 1) + 8) - **((_QWORD **)a2 + 1));
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  if (*(_QWORD *)(*((_QWORD *)a2 + 1) + 8) - **((_QWORD **)a2 + 1) >= 5uLL)
    v21 = 5;
  else
    v21 = *(_QWORD *)(*((_QWORD *)a2 + 1) + 8) - **((_QWORD **)a2 + 1);
  SEUpdaterUtil::SELogPrintBinary(a4, *((_QWORD *)a2 + 3), (const unsigned __int8 *)v21, 0);
  SERestoreInfo::CApdu::validate(a2);
  if (*((_QWORD *)a2 + 5))
  {
    SERestoreInfo::CApdu::validate(a2);
    if (*((_QWORD *)a2 + 4))
    {
      SERestoreInfo::CApdu::validate(a2);
      v22 = *((_QWORD *)a2 + 4);
      SERestoreInfo::CApdu::validate(a2);
      SEUpdaterUtil::SELogPrintBinary(a4, v22, *((const unsigned __int8 **)a2 + 5), 1);
    }
  }
  v23 = (*(uint64_t (**)(SEUpdater::SEControllerBase *, _QWORD, _QWORD, _QWORD, uint64_t *))(*(_QWORD *)this + 56))(this, **((_QWORD **)a2 + 1), *(_QWORD *)(*((_QWORD *)a2 + 1) + 8) - **((_QWORD **)a2 + 1), **((_QWORD **)a3 + 1), &v37);
  if (!(_DWORD)v23)
  {
    (*(void (**)(SERestoreInfo::RApdu *, uint64_t))(*(_QWORD *)a3 + 16))(a3, v37);
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v24 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v39);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v39);
      v25 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
      if (*((_QWORD *)&v39 + 1))
      {
        v26 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      v24 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v28 = (std::__shared_weak_count *)off_2553234C8;
    v38.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
    v38.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v29 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v24, a4, 0, 1, "transceive", (SEUpdaterUtil::SELogObj *)"receiving R-APDU: %zu \n", *(_QWORD *)(*((_QWORD *)a3 + 1) + 8) - **((_QWORD **)a3 + 1));
    if (v28)
    {
      v31 = (unint64_t *)&v28->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    SEUpdaterUtil::SELogPrintBinary(a4, **((_QWORD **)a3 + 1), (const unsigned __int8 *)(*(_QWORD *)(*((_QWORD *)a3 + 1) + 8) - **((_QWORD **)a3 + 1)), a5);
  }
  return v23;
}

void sub_21CCC2080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

id PTCCommand::ptc_DeleteKey(PTCCommand *this, SETransceiveHelper *a2, NSString *a3)
{
  unsigned int v3;
  PTCCommand *v5;
  SETransceiveHelper *v6;
  void *v7;
  id v8;
  NSError *v9;
  NSError *v10;
  void *v11;
  id v13;
  _QWORD v14[4];
  char v15;
  unsigned __int16 v16;

  v3 = a3;
  v5 = this;
  v6 = a2;
  v15 = 1;
  v16 = __rev16(v3);
  v14[0] = &v15;
  v14[1] = 1;
  v14[2] = &v16;
  v14[3] = 2;
  PTCCommand::CreateCommand(0xA001u, (unint64_t)v14, (uint64_t)&PTDeleteKeyInputSpec);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v7)
  {
    v13 = 0;
    v8 = PTCCommand::ExecuteCommand(v5, v6, v7, &v13);
    v9 = (NSError *)v13;
    v10 = v9;
    if (v9)
    {
      _ObjCLogNSError(v9, 0, "ptc_DeleteKey", CFSTR("While deleting key slot 0x%x\n"), v16);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v11 = 0;
    }

  }
  else
  {
    _ObjCLogNSError(0, 0, "ptc_DeleteKey", CFSTR("Could not create deleteKeyCommandData\n"));
    v11 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v11;
}

void sub_21CCC225C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id PTCCommand::CreateCommand(unsigned int a1, unint64_t a2, uint64_t a3)
{
  void *v3;
  uint64_t v4;
  void *v5;
  _QWORD v7[6];
  char v8;
  __int16 v9;

  v3 = 0;
  v8 = 1;
  v9 = __rev16(a1);
  if (a2
    && a3
    && (encodeSequence(0x2000000000000010, a2, *(unsigned __int16 *)(a3 + 8), *(_QWORD *)a3),
        (v3 = (void *)objc_claimAutoreleasedReturnValue()) == 0))
  {
    v5 = 0;
  }
  else
  {
    v7[0] = &v8;
    v7[1] = 1;
    v7[2] = &v9;
    v7[3] = 2;
    v7[4] = objc_msgSend(v3, "DERItem");
    v7[5] = v4;
    encodeSequence(0x2000000000000010, (unint64_t)v7, 3u, (uint64_t)&PTCommandSpecItems);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v5;
}

void sub_21CCC2340(_Unwind_Exception *a1)
{

  _Unwind_Resume(a1);
}

id PTCCommand::ExecuteCommand(void *a1, void *a2, void *a3, _QWORD *a4)
{
  id v7;
  id v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  id v14;
  unint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  id v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  int v26;
  char v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  id v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  unint64_t *v39;
  unint64_t v40;
  id v41;
  void *v42;
  void *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  unint64_t v51;
  int v52;
  void *v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  id v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  uint64_t v71;
  _QWORD *v72;
  id v73;
  id v74;
  id v75;
  void *v76;
  _QWORD *v77;
  std::__shared_weak_count *v78;
  id v79;
  void *v80;
  _QWORD *v81;
  std::__shared_weak_count *v82;
  _QWORD v83[2];
  std::__shared_weak_count *v84;

  v7 = a1;
  v8 = a2;
  v9 = a3;
  objc_msgSend(v7, "selectWithAID:", v8);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = v10;
  if (v10)
  {
    if (a4)
    {
      v11 = objc_retainAutorelease(v10);
      v12 = 0;
      *a4 = v11;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v72 = a4;
    v74 = v8;
    v79 = 0;
    v13 = v7;
    v14 = v9;
    v73 = v9;
    SERestoreInfo::Apdu::Apdu((SERestoreInfo::Apdu *)&v80, 0x2037uLL);
    v80 = &unk_24E0BF828;
    v15 = objc_msgSend(v14, "length");
    v16 = 0;
    v17 = 0;
    while (v15)
    {
      if (v15 >= 0x2BC)
        v18 = 700;
      else
        v18 = v15;
      if (v16 || v18 != objc_msgSend(v14, "length"))
      {
        objc_msgSend(v14, "subdataWithRange:", v16, v18);
        v19 = (id)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        v19 = v14;
      }
      v20 = v19;
      +[APDUUtil getCXXApduWithCla:ins:p1:p2:payload:](APDUUtil, "getCXXApduWithCla:ins:p1:p2:payload:", 128, 160, (v15 < 0x2BD) << 7, 0, v19);
      objc_msgSend(v13, "transceiveAndRecordCapdu:rapdu:", v83, &v80);
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v24
        && (v25 = v81[1], (unint64_t)(v25 - *v81) >= 2)
        && ((v26 = *(unsigned __int8 *)(v25 - 2), (v26 & 0xFFFFFFFD) == 0x61)
         || (*(unsigned __int8 *)(v25 - 1) | (v26 << 8)) == 0x9000))
      {
        v16 += v18;
        v15 -= v18;
        v27 = 1;
      }
      else
      {
        _ObjCLogWrapOutError(&v79, v24, 0, "WriteCommand", CFSTR("Failed to write at offset 0x%x\n"), v21, v22, v23, v16);
        v27 = 0;
        v17 = 1;
      }

      v83[0] = &unk_24E0BF880;
      v28 = v84;
      if (v84)
      {
        p_shared_owners = (unint64_t *)&v84->__shared_owners_;
        do
          v30 = __ldaxr(p_shared_owners);
        while (__stlxr(v30 - 1, p_shared_owners));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }

      if ((v27 & 1) == 0)
      {
        if ((v17 & 1) == 0)
        {
          v80 = &unk_24E0BF880;
          v31 = v82;
          if (v82)
          {
            v32 = (unint64_t *)&v82->__shared_owners_;
            do
              v33 = __ldaxr(v32);
            while (__stlxr(v33 - 1, v32));
            if (!v33)
            {
              ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
              std::__shared_weak_count::__release_weak(v31);
            }
          }
        }
        break;
      }
    }

    v34 = v79;
    if (v34)
    {
      v11 = v34;
      v12 = 0;
      _ObjCLogWrapOutError(v72, v34, 0, "ExecuteCommand", CFSTR("While writing command\n"), v35, v36, v37, v71);
      v8 = v74;
    }
    else
    {
      v38 = v81;
      v77 = v81;
      v78 = v82;
      if (v82)
      {
        v39 = (unint64_t *)&v82->__shared_owners_;
        do
          v40 = __ldxr(v39);
        while (__stxr(v40 + 1, v39));
        v38 = v77;
      }
      v75 = 0;
      v76 = &unk_24E0BF828;
      v41 = v13;
      if (v38[1] - *v38 <= 1uLL)
        __assert_rtn("getDataSize", "Apdu.hpp", 382, "len >= 2");
      objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytes:length:");
      v42 = (void *)objc_claimAutoreleasedReturnValue();
      v43 = (void *)objc_msgSend(v42, "mutableCopy");

      v44 = *v77;
      v45 = v77[1] - *v77;
      if (v45 >= 2)
      {
        while ((*(_BYTE *)(v45 + v44 - 2) & 0xFD) == 0x61)
        {
          +[APDUUtil getCXXApduWithCla:ins:p1:p2:payload:](APDUUtil, "getCXXApduWithCla:ins:p1:p2:payload:", 128, 176, 0, 0, 0);
          objc_msgSend(v41, "transceiveAndRecordCapdu:rapdu:", v83, &v76);
          v49 = (void *)objc_claimAutoreleasedReturnValue();
          if (v49
            || (v50 = v77[1], v51 = v50 - *v77, v51 < 2)
            || (v52 = *(unsigned __int8 *)(*v77 + v51 - 2), (v52 & 0xFFFFFFFD) != 0x61)
            && (*(unsigned __int8 *)(v50 - 1) | (v52 << 8)) != 0x9000)
          {
            _ObjCLogWrapOutError(&v75, v49, 0, "ReadResponse", CFSTR("Failed to read response\n"), v46, v47, v48, v71);

            v83[0] = &unk_24E0BF880;
            v58 = v84;
            if (v84)
            {
              v59 = (unint64_t *)&v84->__shared_owners_;
              do
                v60 = __ldaxr(v59);
              while (__stlxr(v60 - 1, v59));
              if (!v60)
              {
                ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
                std::__shared_weak_count::__release_weak(v58);
              }
            }
            v57 = 0;
            goto LABEL_59;
          }
          objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytes:length:");
          v53 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v43, "appendData:", v53);

          v83[0] = &unk_24E0BF880;
          v54 = v84;
          if (v84)
          {
            v55 = (unint64_t *)&v84->__shared_owners_;
            do
              v56 = __ldaxr(v55);
            while (__stlxr(v56 - 1, v55));
            if (!v56)
            {
              ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
              std::__shared_weak_count::__release_weak(v54);
            }
          }
          v44 = *v77;
          v45 = v77[1] - *v77;
          if (v45 <= 1)
            break;
        }
      }
      v57 = v43;
LABEL_59:

      v11 = v75;
      v76 = &unk_24E0BF880;
      v64 = v78;
      v8 = v74;
      if (v78)
      {
        v65 = (unint64_t *)&v78->__shared_owners_;
        do
          v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
      }
      if (v11 || !v57)
      {
        _ObjCLogWrapOutError(v72, v11, 0, "ExecuteCommand", CFSTR("While reading response for command\n"), v61, v62, v63, v71);
        v12 = 0;
      }
      else
      {
        v12 = v57;
      }

    }
    v80 = &unk_24E0BF880;
    v67 = v82;
    if (v82)
    {
      v68 = (unint64_t *)&v82->__shared_owners_;
      do
        v69 = __ldaxr(v68);
      while (__stlxr(v69 - 1, v68));
      if (!v69)
      {
        ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
        std::__shared_weak_count::__release_weak(v67);
      }
    }
    v9 = v73;
  }

  return v12;
}

void sub_21CCC2954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  void *v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, void *);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  v20 = va_arg(va1, void *);

  v20 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va1);

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  v17 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](a3);

  _Unwind_Resume(a1);
}

id PTCCommand::ptc_listKeys(void *a1, void *a2, uint64_t *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD v31[5];
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t (*v35)(uint64_t, uint64_t);
  void (*v36)(uint64_t);
  id v37;
  __int128 v38;
  __int128 v39;
  _QWORD v40[2];
  id v41;

  v5 = a1;
  v6 = a2;
  PTCCommand::CreateCommand(0x1002u, 0, 0);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  if (v11)
  {
    v41 = 0;
    PTCCommand::ExecuteCommand(v5, v6, v11, &v41);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v13 = v41;
    if (v13)
    {
      objc_msgSend(v11, "asHexString");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      _ObjCLogWrapOutError(a3, v13, 0, "ptc_listKeys", CFSTR("While listing keys: %@\n"), v15, v16, v17, (uint64_t)v14);
    }
    else
    {
      v40[0] = objc_msgSend(v12, "DERItem");
      v40[1] = v19;
      v38 = 0u;
      v39 = 0u;
      if (!DERParseSequenceSpec(0x2000000000000010, (uint64_t)v40, (uint64_t)&PTListKeysOutputSpec, &v38, 0x20uLL))
      {
        v32 = 0;
        v33 = &v32;
        v34 = 0x3032000000;
        v35 = __Block_byref_object_copy__3;
        v36 = __Block_byref_object_dispose__3;
        v37 = (id)objc_opt_new();
        v31[0] = MEMORY[0x24BDAC760];
        v31[1] = 3221225472;
        v31[2] = ___ZN10PTCCommand12ptc_listKeysEP18SETransceiveHelperP8NSStringPU15__autoreleasingP7NSError_block_invoke;
        v31[3] = &unk_24E0BF518;
        v31[4] = &v32;
        if (DERDecodeSequenceWithBlock((uint64_t)&v39, (uint64_t)v31))
        {
          objc_msgSend(v12, "asHexString");
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          _ObjCLogOutError(a3, 0, "ptc_listKeys", CFSTR("Invalid listKeys output %@\n"), v26, v27, v28, v29, (uint64_t)v25);

          v18 = 0;
        }
        else
        {
          v18 = (id)v33[5];
        }
        _Block_object_dispose(&v32, 8);

        goto LABEL_8;
      }
      objc_msgSend(v12, "asHexString");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      _ObjCLogOutError(a3, 0, "ptc_listKeys", CFSTR("Invalid listKeys output %@\n"), v20, v21, v22, v23, (uint64_t)v14);
    }

    v18 = 0;
LABEL_8:

    goto LABEL_9;
  }
  _ObjCLogOutError(a3, 7, "ptc_listKeys", CFSTR("Could not create listKeysCommandData\n"), v7, v8, v9, v10, v30);
  v18 = 0;
LABEL_9:

  return v18;
}

void sub_21CCC2D0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__3(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{

}

uint64_t ___ZN10PTCCommand12ptc_listKeysEP18SETransceiveHelperP8NSStringPU15__autoreleasingP7NSError_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v2;
  void *v3;

  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  objc_msgSend(MEMORY[0x24BDBCE50], "dataWithDERItem:", a2 + 8);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "addObject:", v3);

  return 0;
}

void sub_21CCC2DEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t SEUpdater::PreflightUpdateController::doCommand(SEUpdater::PreflightUpdateController *this, ctu::cf *theString1, const __CFDictionary **a3)
{
  void *v5;
  void *v6;
  void *v7;
  unsigned int v8;
  unsigned int v9;
  SEUpdaterUtil::SELogObj *v10;
  std::__shared_weak_count *size;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  SEUpdaterUtil::SELogObj *v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  int v28;
  SEUpdaterUtil::SELogObj *v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  SEUpdaterUtil::SELogObj *v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  void *v47;
  const void *v48;
  uint64_t (*v49)(uint64_t);
  std::__shared_weak_count *v50;
  const __CFData *v51;
  CFMutableDictionaryRef Dict;
  const void *v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  void *v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t *v63;
  void *v65;
  std::string *v66;
  void *v67;
  void *exception;
  const void *v69;
  std::string *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  _QWORD v77[5];
  std::string v78;
  uint64_t (*v79)(uint64_t, uint64_t);
  const void **(*v80)(uint64_t);
  uint64_t v81;
  const void *v82;
  const void *v83[3];
  std::string v84;
  const __CFData *v85;

  if (CFStringCompare((CFStringRef)theString1, CFSTR("queryInfo"), 0))
  {
    exception = __cxa_allocate_exception(0x48uLL);
    ctu::cf::show(theString1, v69);
    v70 = std::string::insert(&v84, 0, "Unknown command: ");
    v78 = *v70;
    v70->__r_.__value_.__l.__size_ = 0;
    v70->__r_.__value_.__r.__words[2] = 0;
    v70->__r_.__value_.__r.__words[0] = 0;
    v71 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, (__int128 *)&v78, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  v5 = (void *)MEMORY[0x22078AB2C]();
  if (getNFHardwareManagerClass())
  {
    objc_msgSend(getNFHardwareManagerClass(), "sharedHardwareManager");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = v6;
    if (!v6)
    {
      v72 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v78, "Couldn't get sharedHardwareManager");
      v73 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v72, (__int128 *)&v78, 31, CFSTR("SEUpdaterErrorDomain"));
    }
    v76 = v5;
    v8 = objc_msgSend(v6, "getHwSupport");
    v9 = v8;
    if (v8 != 2)
    {
      if (v8 == 4)
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v10 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v78);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v78);
          size = (std::__shared_weak_count *)v78.__r_.__value_.__l.__size_;
          if (v78.__r_.__value_.__l.__size_)
          {
            v12 = (unint64_t *)(v78.__r_.__value_.__l.__size_ + 8);
            do
              v13 = __ldaxr(v12);
            while (__stlxr(v13 - 1, v12));
            if (!v13)
            {
              ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
              std::__shared_weak_count::__release_weak(size);
            }
          }
          v10 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v14 = (std::__shared_weak_count *)off_2553234C8;
        v84.__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
        v84.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v15 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v16 = __ldxr(v15);
          while (__stxr(v16 + 1, v15));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v10, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doCommand", (SEUpdaterUtil::SELogObj *)"HWState returns UnSupported, bailing out\n");
        if (v14)
        {
          p_shared_owners = (unint64_t *)&v14->__shared_owners_;
          do
            v18 = __ldaxr(p_shared_owners);
          while (__stlxr(v18 - 1, p_shared_owners));
          if (!v18)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
        }
        goto LABEL_93;
      }
      v28 = 0;
      do
      {
        if (v28 == 10)
        {
          v65 = __cxa_allocate_exception(0x48uLL);
          std::to_string(&v84, v9);
          v66 = std::string::insert(&v84, 0, "Hardware still not in a valid state: ");
          v78 = *v66;
          v66->__r_.__value_.__l.__size_ = 0;
          v66->__r_.__value_.__r.__words[2] = 0;
          v66->__r_.__value_.__r.__words[0] = 0;
          v67 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v65, (__int128 *)&v78, 31, CFSTR("SEUpdaterErrorDomain"));
        }
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v29 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v78);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v78);
          v30 = (std::__shared_weak_count *)v78.__r_.__value_.__l.__size_;
          if (v78.__r_.__value_.__l.__size_)
          {
            v31 = (unint64_t *)(v78.__r_.__value_.__l.__size_ + 8);
            do
              v32 = __ldaxr(v31);
            while (__stlxr(v32 - 1, v31));
            if (!v32)
            {
              ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
              std::__shared_weak_count::__release_weak(v30);
            }
          }
          v29 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v33 = (std::__shared_weak_count *)off_2553234C8;
        v84.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
        v84.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v34 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v35 = __ldxr(v34);
          while (__stxr(v35 + 1, v34));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v29, (SEUpdaterUtil::SELogObj *)1, 0, 1, "doCommand", (SEUpdaterUtil::SELogObj *)"Attempt %d state %d is not yet ready, sleeping a bit\n", ++v28, v9);
        if (v33)
        {
          v36 = (unint64_t *)&v33->__shared_owners_;
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 - 1, v36));
          if (!v37)
          {
            ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
            std::__shared_weak_count::__release_weak(v33);
          }
        }
        usleep(0xF4240u);
        v9 = objc_msgSend(v7, "queryHardwareSupport:", 0);
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v38 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(&v78);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v78);
          v39 = (std::__shared_weak_count *)v78.__r_.__value_.__l.__size_;
          if (v78.__r_.__value_.__l.__size_)
          {
            v40 = (unint64_t *)(v78.__r_.__value_.__l.__size_ + 8);
            do
              v41 = __ldaxr(v40);
            while (__stlxr(v41 - 1, v40));
            if (!v41)
            {
              ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
              std::__shared_weak_count::__release_weak(v39);
            }
          }
          v38 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v42 = (std::__shared_weak_count *)off_2553234C8;
        v84.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
        v84.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
        if (off_2553234C8)
        {
          v43 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v44 = __ldxr(v43);
          while (__stxr(v44 + 1, v43));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v38, (SEUpdaterUtil::SELogObj *)1, 0, 1, "doCommand", (SEUpdaterUtil::SELogObj *)"new state --> %d\n", v9);
        if (v42)
        {
          v45 = (unint64_t *)&v42->__shared_owners_;
          do
            v46 = __ldaxr(v45);
          while (__stlxr(v46 - 1, v45));
          if (!v46)
          {
            ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
            std::__shared_weak_count::__release_weak(v42);
          }
        }
      }
      while (v9 != 2);
    }
    objc_msgSend(v7, "secureElements");
    v47 = (void *)objc_claimAutoreleasedReturnValue();
    if (!objc_msgSend(v47, "count"))
    {
      v74 = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v78, "Error getting secure element array");
      v75 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v74, (__int128 *)&v78, 31, CFSTR("SEUpdaterErrorDomain"));
    }
    v78.__r_.__value_.__r.__words[0] = 0;
    v78.__r_.__value_.__l.__size_ = (std::string::size_type)&v78;
    v78.__r_.__value_.__r.__words[2] = 0x3812000000;
    v79 = __Block_byref_object_copy__4;
    v80 = __Block_byref_object_dispose__4;
    v81 = 0;
    v82 = 0;
    v77[0] = MEMORY[0x24BDAC760];
    v77[1] = 3221225472;
    v77[2] = ___ZN9SEUpdater25PreflightUpdateController9doCommandEPK10__CFStringPPK14__CFDictionary_block_invoke;
    v77[3] = &unk_24E0C1540;
    v77[4] = &v78;
    objc_msgSend(v47, "enumerateObjectsUsingBlock:", v77);
    v5 = v76;
    v48 = *(const void **)(v78.__r_.__value_.__l.__size_ + 48);
    v49 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
    if (!v48)
      v49 = 0;
    if (v49)
    {
      v50 = (std::__shared_weak_count *)operator new(0xB8uLL);
      v50->__shared_weak_owners_ = 0;
      v50->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C15F8;
      v50->__shared_owners_ = 0;
      v84.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BFCD0;
      v51 = (const __CFData *)CFRetain(v48);
      v85 = v51;
      v84.__r_.__value_.__l.__size_ = (std::string::size_type)CFDataGetBytePtr(v51);
      v84.__r_.__value_.__r.__words[2] = CFDataGetLength(v51);
      SERestoreInfo::IcefallDeviceInfo::IcefallDeviceInfo((SERestoreInfo::IcefallDeviceInfo *)&v50[1], (const SERestoreInfo::BLOB *)&v84);
      SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&v84);
      ((void (*)(std::__shared_weak_count_vtbl **))v50[1].__on_zero_shared_weak)(&v50[1].__vftable);
      Dict = SERestoreInfo::SEDeviceInfo::createDict((SERestoreInfo::SEDeviceInfo *)&v50[1], 0);
      v53 = (const void *)*((_QWORD *)this + 14);
      *((_QWORD *)this + 14) = Dict;
      v83[0] = v53;
      ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(v83);
      v54 = v50;
      if (!v50)
      {
LABEL_92:
        _Block_object_dispose(&v78, 8);
        ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef(&v82);

LABEL_93:
        goto LABEL_94;
      }
      v55 = (unint64_t *)&v50->__shared_owners_;
      do
        v56 = __ldaxr(v55);
      while (__stlxr(v56 - 1, v55));
    }
    else
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v57 = off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v84);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v84);
        v58 = (std::__shared_weak_count *)v84.__r_.__value_.__l.__size_;
        if (v84.__r_.__value_.__l.__size_)
        {
          v59 = (unint64_t *)(v84.__r_.__value_.__l.__size_ + 8);
          do
            v60 = __ldaxr(v59);
          while (__stlxr(v60 - 1, v59));
          if (!v60)
          {
            ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
            std::__shared_weak_count::__release_weak(v58);
          }
        }
        v57 = off_2553234C0;
      }
      v54 = (std::__shared_weak_count *)off_2553234C8;
      v83[0] = v57;
      v83[1] = off_2553234C8;
      if (off_2553234C8)
      {
        v61 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v62 = __ldxr(v61);
        while (__stxr(v62 + 1, v61));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v57, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doCommand", (SEUpdaterUtil::SELogObj *)"No personalisable SEs found\n");
      if (!v54)
        goto LABEL_92;
      v63 = (unint64_t *)&v54->__shared_owners_;
      do
        v56 = __ldaxr(v63);
      while (__stlxr(v56 - 1, v63));
    }
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
    goto LABEL_92;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v19 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v78);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)&v78);
    v20 = (std::__shared_weak_count *)v78.__r_.__value_.__l.__size_;
    if (v78.__r_.__value_.__l.__size_)
    {
      v21 = (unint64_t *)(v78.__r_.__value_.__l.__size_ + 8);
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v19 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v23 = (std::__shared_weak_count *)off_2553234C8;
  v84.__r_.__value_.__r.__words[0] = (std::string::size_type)v19;
  v84.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
  if (off_2553234C8)
  {
    v24 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v19, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doCommand", (SEUpdaterUtil::SELogObj *)"Can't get softlinked NFHM class, nothing to personalize\n");
  if (v23)
  {
    v26 = (unint64_t *)&v23->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
LABEL_94:
  objc_autoreleasePoolPop(v5);
  return 1;
}

void sub_21CCC369C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, __int128 a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;
  const void **v29;

  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Block_object_dispose(&__p, 8);
  ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef(v29);

  JUMPOUT(0x21CCC3CB4);
}

void sub_21CCC3810()
{
  JUMPOUT(0x21CCC3818);
}

void sub_21CCC3988()
{
  uint64_t v0;

  if (*(char *)(v0 - 121) < 0)
    operator delete(*(void **)(v0 - 144));
  JUMPOUT(0x21CCC378CLL);
}

void sub_21CCC39A0()
{
  void *v0;

  __cxa_free_exception(v0);
  JUMPOUT(0x21CCC378CLL);
}

void sub_21CCC39B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  va_list va;

  va_start(va, a6);
  if (*(char *)(v6 - 121) < 0)
    operator delete(*(void **)(v6 - 144));
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  JUMPOUT(0x21CCC378CLL);
}

void sub_21CCC39D8()
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  JUMPOUT(0x21CCC378CLL);
}

void sub_21CCC3BE0()
{
  uint64_t v0;

  if (*(char *)(v0 - 121) < 0)
    operator delete(*(void **)(v0 - 144));
  JUMPOUT(0x21CCC37D4);
}

void sub_21CCC3BF8()
{
  void *v0;

  __cxa_free_exception(v0);
  JUMPOUT(0x21CCC37D4);
}

void sub_21CCC3C0C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;

  if (a30 < 0)
    operator delete(__p);
  if (*(char *)(v30 - 97) < 0)
    JUMPOUT(0x21CCC3C2CLL);
  JUMPOUT(0x21CCC3CB4);
}

void sub_21CCC3C34()
{
  uint64_t v0;

  if (*(char *)(v0 - 97) < 0)
    operator delete(*(void **)(v0 - 120));
  JUMPOUT(0x21CCC3C80);
}

void sub_21CCC3C4C()
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  JUMPOUT(0x21CCC3CB4);
}

void sub_21CCC3C64()
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  JUMPOUT(0x21CCC3CB4);
}

void sub_21CCC3CA0()
{
  uint64_t v0;

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v0 - 120);
  JUMPOUT(0x21CCC3CB4);
}

void sub_21CCC3CB0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id getNFHardwareManagerClass(void)
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)_MergedGlobals_3;
  v7 = _MergedGlobals_3;
  if (!_MergedGlobals_3)
  {
    v3[0] = MEMORY[0x24BDAC760];
    v3[1] = 3221225472;
    v3[2] = ___ZL25getNFHardwareManagerClassv_block_invoke;
    v3[3] = &unk_24E0C15B0;
    v3[4] = &v4;
    ___ZL25getNFHardwareManagerClassv_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_21CCC3D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = 0;
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

const void **__Block_byref_object_dispose__4(uint64_t a1)
{
  return ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)(a1 + 48));
}

void ___ZN9SEUpdater25PreflightUpdateController9doCommandEPK10__CFStringPPK14__CFDictionary_block_invoke(uint64_t a1, void *a2, int a3, _BYTE *a4)
{
  id v7;
  SEUpdaterUtil::SELogObj *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  void *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  void *v18;
  int v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(uint64_t);
  void *exception;
  void *v27;
  __int128 v28;
  SEUpdaterUtil::SELogObj *v29;
  void *v30;

  v7 = a2;
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v8 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v28);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v28);
    v9 = (std::__shared_weak_count *)*((_QWORD *)&v28 + 1);
    if (*((_QWORD *)&v28 + 1))
    {
      v10 = (unint64_t *)(*((_QWORD *)&v28 + 1) + 8);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    v8 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v12 = (std::__shared_weak_count *)off_2553234C8;
  v29 = v8;
  v30 = off_2553234C8;
  if (off_2553234C8)
  {
    v13 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  objc_msgSend(v7, "info");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  SEUpdaterUtil::SELogObj::printLog(v8, (SEUpdaterUtil::SELogObj *)2, 0, 1, "doCommand_block_invoke", (SEUpdaterUtil::SELogObj *)"SE %u personalisable %d\n", a3, objc_msgSend(v15, "personalisable"));

  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  objc_msgSend(v7, "info");
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  v19 = objc_msgSend(v18, "personalisable");

  if (v19)
  {
    objc_msgSend(v7, "info");
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v20, "manifestQuery");
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = v21;
    v23 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (v21)
      CFRetain(v21);
    v24 = *(_QWORD *)(v23 + 48);
    *(_QWORD *)(v23 + 48) = v22;
    *(_QWORD *)&v28 = v24;
    ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)&v28);

    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48))
      v25 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
    else
      v25 = 0;
    if (!v25)
    {
      exception = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v28, "Got personalisable SE with nil manifestQuery?!");
      v27 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, &v28, 31, CFSTR("SEUpdaterErrorDomain"));
    }
    *a4 = 1;
  }

}

void sub_21CCC3FD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  void *v18;

  if (a17 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void SEUpdater::PreflightUpdateController::~PreflightUpdateController(const void **this)
{
  SEUpdater::UpdateControllerBase::~UpdateControllerBase(this);
  JUMPOUT(0x22078A808);
}

Class ___ZL25getNFHardwareManagerClassv_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!qword_255323768)
  {
    qword_255323768 = _sl_dlopen();
    if (!qword_255323768)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("NFHardwareManager");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  _MergedGlobals_3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void std::__shared_ptr_emplace<SERestoreInfo::IcefallDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C15F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SERestoreInfo::IcefallDeviceInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24E0C15F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SERestoreInfo::IcefallDeviceInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::allocate_shared[abi:ne180100]<SERestoreInfo::P73DeviceInfo,std::allocator<SERestoreInfo::P73DeviceInfo>,__CFData const* const&,void>(_QWORD *a1, const void *a2)
{
  char *v4;
  _QWORD v5[3];
  CFDataRef v6;

  v4 = (char *)operator new(0xD8uLL);
  *((_QWORD *)v4 + 2) = 0;
  *(_QWORD *)v4 = &unk_24E0C0E00;
  *((_QWORD *)v4 + 1) = 0;
  v5[0] = &unk_24E0BFCD0;
  v6 = (CFDataRef)CFRetain(a2);
  v5[1] = CFDataGetBytePtr(v6);
  v5[2] = CFDataGetLength(v6);
  SERestoreInfo::P73DeviceInfo::P73DeviceInfo((void **)v4 + 3, (const SERestoreInfo::BLOB *)v5);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)v5);
  *a1 = v4 + 24;
  a1[1] = v4;
}

void sub_21CCC4288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  void *v11;

  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&a9);
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v11);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<SERestoreInfo::SN100VDeviceInfo,std::allocator<SERestoreInfo::SN100VDeviceInfo>,__CFData const* const&,void>(_QWORD *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD v5[3];
  CFDataRef v6;

  v4 = operator new(0xD8uLL);
  v4[2] = 0;
  *v4 = &unk_24E0C0E50;
  v4[1] = 0;
  v5[0] = &unk_24E0BFCD0;
  v6 = (CFDataRef)CFRetain(a2);
  v5[1] = CFDataGetBytePtr(v6);
  v5[2] = CFDataGetLength(v6);
  SERestoreInfo::SN100VDeviceInfo::SN100VDeviceInfo((SERestoreInfo::SN100VDeviceInfo *)(v4 + 3), (const SERestoreInfo::BLOB *)v5);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)v5);
  *a1 = v4 + 3;
  a1[1] = v4;
}

void sub_21CCC4350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  void *v11;

  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&a9);
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v11);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<SERestoreInfo::SN200VDeviceInfo,std::allocator<SERestoreInfo::SN200VDeviceInfo>,__CFData const* const&,void>(_QWORD *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD v5[3];
  CFDataRef v6;

  v4 = operator new(0xD8uLL);
  v4[2] = 0;
  *v4 = &unk_24E0C0EA0;
  v4[1] = 0;
  v5[0] = &unk_24E0BFCD0;
  v6 = (CFDataRef)CFRetain(a2);
  v5[1] = CFDataGetBytePtr(v6);
  v5[2] = CFDataGetLength(v6);
  SERestoreInfo::SN200VDeviceInfo::SN200VDeviceInfo((SERestoreInfo::SN200VDeviceInfo *)(v4 + 3), (const SERestoreInfo::BLOB *)v5);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)v5);
  *a1 = v4 + 3;
  a1[1] = v4;
}

void sub_21CCC4418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  void *v11;

  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&a9);
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v11);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<SERestoreInfo::SN210VDeviceInfo,std::allocator<SERestoreInfo::SN210VDeviceInfo>,__CFData const* const&,void>(_QWORD *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD v5[3];
  CFDataRef v6;

  v4 = operator new(0xD8uLL);
  v4[2] = 0;
  *v4 = &unk_24E0C0EF0;
  v4[1] = 0;
  v5[0] = &unk_24E0BFCD0;
  v6 = (CFDataRef)CFRetain(a2);
  v5[1] = CFDataGetBytePtr(v6);
  v5[2] = CFDataGetLength(v6);
  SERestoreInfo::SN210VDeviceInfo::SN210VDeviceInfo((SERestoreInfo::SN210VDeviceInfo *)(v4 + 3), (const SERestoreInfo::BLOB *)v5);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)v5);
  *a1 = v4 + 3;
  a1[1] = v4;
}

void sub_21CCC44E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  void *v11;

  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&a9);
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v11);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<SERestoreInfo::SN300VDeviceInfo,std::allocator<SERestoreInfo::SN300VDeviceInfo>,__CFData const* const&,void>(_QWORD *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD v5[3];
  CFDataRef v6;

  v4 = operator new(0xD8uLL);
  v4[2] = 0;
  *v4 = &unk_24E0C0F40;
  v4[1] = 0;
  v5[0] = &unk_24E0BFCD0;
  v6 = (CFDataRef)CFRetain(a2);
  v5[1] = CFDataGetBytePtr(v6);
  v5[2] = CFDataGetLength(v6);
  SERestoreInfo::SN300VDeviceInfo::SN300VDeviceInfo((SERestoreInfo::SN300VDeviceInfo *)(v4 + 3), (const SERestoreInfo::BLOB *)v5);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)v5);
  *a1 = v4 + 3;
  a1[1] = v4;
}

void sub_21CCC45A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  void *v11;

  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&a9);
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v11);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<SERestoreInfo::SE310SDeviceInfo,std::allocator<SERestoreInfo::SE310SDeviceInfo>,__CFData const* const&,void>(_QWORD *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD v5[3];
  CFDataRef v6;

  v4 = operator new(0xD8uLL);
  v4[2] = 0;
  *v4 = &unk_24E0C0F90;
  v4[1] = 0;
  v5[0] = &unk_24E0BFCD0;
  v6 = (CFDataRef)CFRetain(a2);
  v5[1] = CFDataGetBytePtr(v6);
  v5[2] = CFDataGetLength(v6);
  SERestoreInfo::SE310SDeviceInfo::SE310SDeviceInfo((SERestoreInfo::SE310SDeviceInfo *)(v4 + 3), (const SERestoreInfo::BLOB *)v5);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)v5);
  *a1 = v4 + 3;
  a1[1] = v4;
}

void sub_21CCC4670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  void *v11;

  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&a9);
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v11);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<SERestoreInfo::SN300V2DeviceInfo,std::allocator<SERestoreInfo::SN300V2DeviceInfo>,__CFData const* const&,void>(_QWORD *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD v5[3];
  CFDataRef v6;

  v4 = operator new(0xD8uLL);
  v4[2] = 0;
  *v4 = &unk_24E0C0FE0;
  v4[1] = 0;
  v5[0] = &unk_24E0BFCD0;
  v6 = (CFDataRef)CFRetain(a2);
  v5[1] = CFDataGetBytePtr(v6);
  v5[2] = CFDataGetLength(v6);
  SERestoreInfo::SN300V2DeviceInfo::SN300V2DeviceInfo((SERestoreInfo::SN300V2DeviceInfo *)(v4 + 3), (const SERestoreInfo::BLOB *)v5);
  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)v5);
  *a1 = v4 + 3;
  a1[1] = v4;
}

void sub_21CCC4738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  void *v11;

  SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&a9);
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v11);
  _Unwind_Resume(a1);
}

CFMutableDictionaryRef SERestoreInfo::SEDeviceInfo::createDict(SERestoreInfo::SEDeviceInfo *this, uint64_t a2)
{
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v5;
  void *exception;
  void *v8;
  __int128 v9;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v9, "Cannot allocate for dict");
    v8 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, &v9, 3, CFSTR("SEUpdaterErrorDomain"));
  }
  v5 = Mutable;
  (*(void (**)(SERestoreInfo::SEDeviceInfo *, CFMutableDictionaryRef, uint64_t))(*(_QWORD *)this + 24))(this, Mutable, a2);
  return v5;
}

void sub_21CCC4820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SERestoreInfo::SEException::SEException(uint64_t a1, __int128 *a2, int a3, CFTypeRef cf)
{
  void **v7;
  std::string::value_type *v8;
  __int128 v9;
  CFTypeRef v10;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  __int128 v14;
  int v15;
  const std::string::value_type *v16;
  std::string::size_type v17;
  std::string *v18;
  std::string::size_type v19;
  char v20;
  uint64_t v21;
  std::string v23;
  std::string v24;
  std::string v25;
  _QWORD v26[3];

  v26[2] = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = &off_24E0C1648;
  *(_QWORD *)(a1 + 8) = 0;
  v7 = (void **)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v8 = (std::string::value_type *)(a1 + 32);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 32), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v9 = *a2;
    *(_QWORD *)(a1 + 48) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v8 = v9;
  }
  *(_DWORD *)(a1 + 64) = a3;
  if (cf)
  {
    v10 = CFRetain(cf);
    a3 = *(_DWORD *)(a1 + 64);
  }
  else
  {
    v10 = 0;
  }
  *(_QWORD *)(a1 + 56) = v10;
  std::to_string(&v23, a3);
  v11 = std::string::insert(&v23, 0, "(");
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  v13 = std::string::append(&v24, ") ");
  v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  v15 = *(char *)(a1 + 55);
  if (v15 >= 0)
    v16 = v8;
  else
    v16 = *(const std::string::value_type **)(a1 + 32);
  if (v15 >= 0)
    v17 = *(unsigned __int8 *)(a1 + 55);
  else
    v17 = *(_QWORD *)(a1 + 40);
  v18 = std::string::append(&v25, v16, v17);
  v19 = v18->__r_.__value_.__r.__words[0];
  v26[0] = v18->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v26 + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
  v20 = HIBYTE(v18->__r_.__value_.__r.__words[2]);
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*v7);
  v21 = v26[0];
  *(_QWORD *)(a1 + 8) = v19;
  *(_QWORD *)(a1 + 16) = v21;
  *(_QWORD *)(a1 + 23) = *(_QWORD *)((char *)v26 + 7);
  *(_BYTE *)(a1 + 31) = v20;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v25.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  return a1;
}

void sub_21CCC4A10(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

SERestoreInfo::SEException *SERestoreInfo::SEException::SEException(SERestoreInfo::SEException *this, CFErrorRef err)
{
  void **v4;
  const __CFString *v5;
  const __CFString *v6;
  CFIndex Length;
  CFIndex Bytes;
  char *v9;
  std::string::size_type size;
  std::string::size_type v11;
  std::string::size_type v12;
  std::string::size_type v13;
  uint64_t v14;
  _BYTE *v15;
  std::string::size_type v16;
  char v17;
  const void *Domain;
  std::string *v19;
  __int128 v20;
  std::string *v21;
  __int128 v22;
  int v23;
  const std::string::value_type *v24;
  std::string::size_type v25;
  std::string *v26;
  std::string::size_type v27;
  char v28;
  uint64_t v29;
  std::string v31;
  std::string usedBufLen;
  std::string __p;
  _QWORD v34[3];
  CFRange v35;
  CFRange v36;

  v34[2] = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = &off_24E0C1648;
  *(_OWORD *)((char *)this + 8) = 0u;
  v4 = (void **)((char *)this + 8);
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  v5 = CFErrorCopyDescription(err);
  v6 = v5;
  if (v5)
  {
    Length = CFStringGetLength(v5);
    usedBufLen.__r_.__value_.__r.__words[0] = 0;
    v35.location = 0;
    v35.length = Length;
    Bytes = CFStringGetBytes(v6, v35, 0x8000100u, 0, 0, 0, 0, (CFIndex *)&usedBufLen);
    if (!usedBufLen.__r_.__value_.__r.__words[0] || !Bytes)
    {
LABEL_22:
      CFRelease(v6);
      goto LABEL_23;
    }
    std::vector<unsigned char>::vector(&__p, usedBufLen.__r_.__value_.__r.__words[0]);
    v36.location = 0;
    v36.length = Length;
    if (!CFStringGetBytes(v6, v36, 0x8000100u, 0, 0, (UInt8 *)__p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0], 0))
    {
LABEL_20:
      if (__p.__r_.__value_.__r.__words[0])
      {
        __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      goto LABEL_22;
    }
    size = __p.__r_.__value_.__l.__size_;
    v9 = (char *)__p.__r_.__value_.__r.__words[0];
    v11 = __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0];
    if (*((char *)this + 55) < 0)
    {
      v14 = *((_QWORD *)this + 6);
      v13 = (v14 & 0x7FFFFFFFFFFFFFFFLL) - 1;
      if (v13 >= v11)
      {
        if ((v14 & 0x8000000000000000) == 0)
          goto LABEL_11;
        goto LABEL_13;
      }
      v12 = *((_QWORD *)this + 5);
    }
    else
    {
      if (v11 <= 0x16)
      {
LABEL_11:
        v15 = (char *)this + 32;
LABEL_14:
        if ((char *)size != v9)
        {
          v16 = v11;
          do
          {
            v17 = *v9++;
            *v15++ = v17;
            --v16;
          }
          while (v16);
        }
        *v15 = 0;
        if (*((char *)this + 55) < 0)
          *((_QWORD *)this + 5) = v11;
        else
          *((_BYTE *)this + 55) = v11 & 0x7F;
        goto LABEL_20;
      }
      v12 = *((unsigned __int8 *)this + 55);
      v13 = 22;
    }
    std::string::__grow_by((std::string *)((char *)this + 32), v13, v11 - v13, v12, 0, v12, 0);
    *((_QWORD *)this + 5) = 0;
    if ((*((_BYTE *)this + 55) & 0x80) == 0)
      goto LABEL_11;
LABEL_13:
    v15 = (_BYTE *)*((_QWORD *)this + 4);
    goto LABEL_14;
  }
LABEL_23:
  *((_DWORD *)this + 16) = CFErrorGetCode(err);
  Domain = CFErrorGetDomain(err);
  if (Domain)
    Domain = CFRetain(Domain);
  *((_QWORD *)this + 7) = Domain;
  std::to_string(&v31, *((int *)this + 16));
  v19 = std::string::insert(&v31, 0, "CF=(");
  v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  usedBufLen.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&usedBufLen.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  v21 = std::string::append(&usedBufLen, ") ");
  v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  v23 = *((char *)this + 55);
  if (v23 >= 0)
    v24 = (char *)this + 32;
  else
    v24 = (const std::string::value_type *)*((_QWORD *)this + 4);
  if (v23 >= 0)
    v25 = *((unsigned __int8 *)this + 55);
  else
    v25 = *((_QWORD *)this + 5);
  v26 = std::string::append(&__p, v24, v25);
  v27 = v26->__r_.__value_.__r.__words[0];
  v34[0] = v26->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v34 + 7) = *(std::string::size_type *)((char *)&v26->__r_.__value_.__r.__words[1] + 7);
  v28 = HIBYTE(v26->__r_.__value_.__r.__words[2]);
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  if (*((char *)this + 31) < 0)
    operator delete(*v4);
  v29 = v34[0];
  *((_QWORD *)this + 1) = v27;
  *((_QWORD *)this + 2) = v29;
  *(_QWORD *)((char *)this + 23) = *(_QWORD *)((char *)v34 + 7);
  *((_BYTE *)this + 31) = v28;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(usedBufLen.__r_.__value_.__r.__words[2]) < 0)
    operator delete(usedBufLen.__r_.__value_.__l.__data_);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v31.__r_.__value_.__l.__data_);
  return this;
}

void sub_21CCC4D1C(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::SEException::~SEException(std::exception *this)
{
  std::exception_vtbl *v2;

  this->__vftable = (std::exception_vtbl *)&off_24E0C1648;
  v2 = this[7].__vftable;
  if (v2)
  {
    CFRelease(v2);
    this[7].__vftable = 0;
  }
  if (SHIBYTE(this[6].__vftable) < 0)
    operator delete(this[4].__vftable);
  if (SHIBYTE(this[3].__vftable) < 0)
    operator delete(this[1].__vftable);
  std::exception::~exception(this);
}

{
  SERestoreInfo::SEException::~SEException(this);
  JUMPOUT(0x22078A808);
}

uint64_t SERestoreInfo::SEFirmwareBase::get(SERestoreInfo::SEFirmwareBase *this, unsigned int a2)
{
  uint64_t v2;
  void *exception;
  std::string *v5;
  __int128 v6;
  std::string v7;
  __int128 v8;
  std::string::size_type v9;

  if ((a2 & 0x80000000) != 0
    || (v2 = *((_QWORD *)this + 2), a2 >= (unint64_t)((*((_QWORD *)this + 3) - v2) >> 5)))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v7, "Assertion: ");
    v5 = std::string::append(&v7, "index>=0 && index<fObjs.size()");
    v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v9 = v5->__r_.__value_.__r.__words[2];
    v8 = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v8);
  }
  v8 = *(_OWORD *)(v2 + 32 * a2 + 8);
  return (*(uint64_t (**)(SERestoreInfo::SEFirmwareBase *, __int128 *))(*(_QWORD *)this + 24))(this, &v8);
}

void sub_21CCC4E8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

SERestoreInfo::SEFirmwareBase *SERestoreInfo::SEFirmwareBase::SEFirmwareBase(SERestoreInfo::SEFirmwareBase *this, CFDataRef theData)
{
  int64x2_t *v3;
  int v4;
  int v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  __int128 v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  __int128 v21;
  int64x2_t v22;
  uint64_t v23;
  void *v25;
  void *v26;
  void *exception;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  std::string *v32;
  void *v33;
  void *v34;
  void *v35;
  std::string v37;
  uint64_t v38;
  unint64_t v39;
  __int128 v40;
  unsigned int __val;
  _QWORD v42[2];
  unint64_t v43[2];
  uint64_t v44;
  char *v45[2];
  uint64_t v46;
  std::string v47;
  uint64_t v48;
  char *v49;

  *(_QWORD *)this = off_24E0C1688;
  *((_QWORD *)this + 2) = 0;
  v3 = (int64x2_t *)((char *)this + 16);
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  v44 = 0;
  v42[0] = CFDataGetBytePtr(theData);
  v42[1] = CFDataGetLength(theData);
  v4 = DERParseSequence((uint64_t)v42, 2u, (uint64_t)&SEFirmwareDERSpec::SEFirmwareItemSpec, (unint64_t)v45, 0x20uLL);
  if (v4)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v47, "Fail to parse SEFW.");
    v28 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, (__int128 *)&v47, v4, CFSTR("libDERErrorDomain"));
  }
  __val = 0;
  v5 = DERParseInteger(v45, &__val);
  if (v5)
  {
    v29 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v47, "Failed to parse SEFirmware.version.");
    v30 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v29, (__int128 *)&v47, v5, CFSTR("libDERErrorDomain"));
  }
  if (__val >= 2)
  {
    v31 = __cxa_allocate_exception(0x48uLL);
    std::to_string(&v37, __val);
    v32 = std::string::insert(&v37, 0, "Unsupported firmware version: ");
    v47 = *v32;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    v33 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v31, (__int128 *)&v47, 7, CFSTR("SEUpdaterErrorDomain"));
  }
  v6 = DERDecodeSeqInit((uint64_t)&v46, &v44, v43);
  if (v6)
  {
    v34 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v47, "Fail to DERDecodeSeqInit firmwareArray.");
    v35 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v34, (__int128 *)&v47, v6, CFSTR("libDERErrorDomain"));
  }
  while (!v6)
  {
    v6 = DERDecodeSeqNext(v43, &v39);
    if (!v6)
    {
      v37.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24E0BFCD0;
      *(_OWORD *)&v37.__r_.__value_.__r.__words[1] = v40;
      v38 = 0;
      v7 = *((_QWORD *)this + 3);
      v8 = *((_QWORD *)this + 4);
      if (v7 >= v8)
      {
        v11 = (uint64_t)(v7 - v3->i64[0]) >> 5;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 59)
          std::vector<unsigned short>::__throw_length_error[abi:ne180100]();
        v13 = v8 - v3->i64[0];
        if (v13 >> 4 > v12)
          v12 = v13 >> 4;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFE0)
          v14 = 0x7FFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        v49 = (char *)this + 32;
        if (v14)
          v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SERestoreInfo::BLOB>>((uint64_t)this + 32, v14);
        else
          v15 = 0;
        v16 = &v15[32 * v11];
        *(_QWORD *)v16 = &unk_24E0BFCD0;
        v17 = *(_OWORD *)&v37.__r_.__value_.__r.__words[1];
        *((_QWORD *)v16 + 3) = v38;
        *(_OWORD *)(v16 + 8) = v17;
        v18 = *((_QWORD *)this + 2);
        v19 = *((_QWORD *)this + 3);
        if (v19 == v18)
        {
          v22 = vdupq_n_s64(v19);
          v20 = &v15[32 * v11];
        }
        else
        {
          v20 = &v15[32 * v11];
          do
          {
            *((_QWORD *)v20 - 4) = &unk_24E0BFCD0;
            v20 -= 32;
            v21 = *(_OWORD *)(v19 - 24);
            *((_QWORD *)v20 + 3) = *(_QWORD *)(v19 - 8);
            *(_OWORD *)(v20 + 8) = v21;
            v19 -= 32;
          }
          while (v19 != v18);
          v22 = *v3;
        }
        v10 = v16 + 32;
        *((_QWORD *)this + 2) = v20;
        *((_QWORD *)this + 3) = v16 + 32;
        *(int64x2_t *)&v47.__r_.__value_.__r.__words[1] = v22;
        v23 = *((_QWORD *)this + 4);
        *((_QWORD *)this + 4) = &v15[32 * v14];
        v48 = v23;
        v47.__r_.__value_.__r.__words[0] = v22.i64[0];
        std::__split_buffer<SERestoreInfo::BLOB>::~__split_buffer((uint64_t)&v47);
      }
      else
      {
        *(_QWORD *)v7 = &unk_24E0BFCD0;
        v9 = *(_OWORD *)&v37.__r_.__value_.__r.__words[1];
        *(_QWORD *)(v7 + 24) = v38;
        *(_OWORD *)(v7 + 8) = v9;
        v10 = (char *)(v7 + 32);
      }
      *((_QWORD *)this + 3) = v10;
      SERestoreInfo::BLOB::~BLOB((SERestoreInfo::BLOB *)&v37);
    }
  }
  if (v6 != 1)
  {
    v25 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v47, "Fail to DERDecodeSeqNext firmwareArray.");
    v26 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v25, (__int128 *)&v47, v6, CFSTR("libDERErrorDomain"));
  }
  *((_QWORD *)this + 1) = CFRetain(theData);
  return this;
}

void sub_21CCC5308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  std::vector<SERestoreInfo::BLOB>::__destroy_vector::operator()[abi:ne180100]((void ***)&a26);
  _Unwind_Resume(a1);
}

void SERestoreInfo::SEFirmwareBase::updateMeasurementDict(SERestoreInfo::SEFirmwareBase *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  char v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  SERestoreInfo::SEException *exception;
  SERestoreInfo::SEException *v15;
  void *v16;
  void *v17;
  void *__p[3];
  uint64_t v19;
  std::__shared_weak_count *v20;

  v3 = (*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 5;
  if (!(_DWORD)v3)
    goto LABEL_18;
  v7 = 0;
  v8 = 0;
  do
  {
    SERestoreInfo::SEFirmwareBase::get(this, v8);
    if (!*(_QWORD *)a3)
      goto LABEL_7;
    v9 = v19;
    (*(void (**)(void **__return_ptr))(**(_QWORD **)a3 + 16))(__p);
    v10 = (*(uint64_t (**)(uint64_t, void **))(*(_QWORD *)v9 + 32))(v9, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v10)
    {
LABEL_7:
      __p[0] = 0;
      (*(void (**)(uint64_t, uint64_t, void **))(*(_QWORD *)v19 + 16))(v19, a2, __p);
      if (__p[0])
      {
        exception = (SERestoreInfo::SEException *)__cxa_allocate_exception(0x48uLL);
        v15 = SERestoreInfo::SEException::SEException(exception, (CFErrorRef)__p[0]);
      }
      v7 = 1;
    }
    v11 = v20;
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    ++v8;
  }
  while (v8 != (_DWORD)v3);
  if ((v7 & 1) == 0)
  {
LABEL_18:
    v16 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(__p, "Cannot found any matched delivery object");
    v17 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v16, (__int128 *)__p, 24, CFSTR("SEUpdaterErrorDomain"));
  }
}

void sub_21CCC5558(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

SEUpdaterUtil::SELogObj *SEUpdaterUtil::SELogObj::SELogObj(SEUpdaterUtil::SELogObj *this)
{
  NSObject *v2;
  NSObject *v3;
  char *v4;

  v2 = dispatch_queue_create("SELogObj", 0);
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = v2;
  if (v2)
  {
    v3 = v2;
    dispatch_retain(v2);
    *((_QWORD *)this + 3) = 0;
    dispatch_release(v3);
  }
  else
  {
    *((_QWORD *)this + 3) = 0;
  }
  *((_QWORD *)this + 11) = 0;
  v4 = (char *)operator new(0xF000uLL);
  *((_QWORD *)this + 7) = v4;
  *((_QWORD *)this + 8) = v4 + 61440;
  *((_QWORD *)this + 9) = v4;
  *((_QWORD *)this + 10) = v4;
  *((_QWORD *)this + 4) = SEUpdaterUtil::SELogObj::_defaultLogFunc;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 3;
  return this;
}

void sub_21CCC5624(_Unwind_Exception *a1)
{
  _QWORD *v1;

  ctu::SharedSynchronizable<SEUpdaterUtil::Error>::~SharedSynchronizable(v1);
  _Unwind_Resume(a1);
}

_QWORD *SEUpdaterUtil::SELogObj::_defaultLogFunc(SEUpdaterUtil::SELogObj *this, char *__s, const char *a3)
{
  size_t v4;

  v4 = strlen(__s);
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)__s, v4);
}

void SEUpdaterUtil::SELogPrintBinary(SEUpdaterUtil *this, uint64_t a2, const unsigned __int8 *a3, int a4)
{
  char *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t v10;
  const char *v11;
  SEUpdaterUtil::SELogObj *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  SEUpdaterUtil::SELogObj *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unsigned int v32;
  char *v33;
  std::__shared_weak_count *v34;
  __int128 v35;

  v32 = this;
  v7 = (char *)malloc_type_calloc(0x1000uLL, 1uLL, 0xD27E16E7uLL);
  v33 = v7;
  v8 = (std::__shared_weak_count *)operator new();
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C16C8;
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)v7;
  v34 = v8;
  if (!a3)
    goto LABEL_47;
  v9 = 0;
  v10 = 0;
  v11 = a4 ? "%2.2x" : "0x%2.2x ";
  while (1)
  {
    if ((v9 & 0xF) == 0 && (a4 & 1) == 0)
    {
      v10 += snprintf(&v7[v10], 4096 - v10, "%04x: ", v9);
      if (v10 > 0xFFF)
        break;
      v7 = v33;
    }
    v10 += snprintf(&v7[v10], 4096 - v10, v11, *(unsigned __int8 *)(a2 + v9));
    if (v10 > 0xFFF)
      break;
    if ((v9 & 0xF) != 0xF || (a4 & 1) != 0)
    {
      if ((const unsigned __int8 *)++v9 == a3)
      {
        if (v10)
        {
          pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          if (!off_2553234C0)
          {
            SEUpdaterUtil::SELogObj::create_default_global(&v35);
            std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v35);
            v22 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
            if (*((_QWORD *)&v35 + 1))
            {
              v23 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
              do
                v24 = __ldaxr(v23);
              while (__stlxr(v24 - 1, v23));
              if (!v24)
              {
                ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
                std::__shared_weak_count::__release_weak(v22);
              }
            }
            v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
          }
          v25 = (std::__shared_weak_count *)off_2553234C8;
          if (off_2553234C8)
          {
            v26 = (unint64_t *)((char *)off_2553234C8 + 8);
            do
              v27 = __ldxr(v26);
            while (__stxr(v27 + 1, v26));
          }
          pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
          SEUpdaterUtil::SELogObj::printLog(v21, (SEUpdaterUtil::SELogObj *)v32, 0, 0, 0, (SEUpdaterUtil::SELogObj *)"%s\n", v33);
          if (v25)
          {
            p_shared_owners = (unint64_t *)&v25->__shared_owners_;
            do
              v29 = __ldaxr(p_shared_owners);
            while (__stlxr(v29 - 1, p_shared_owners));
            if (!v29)
            {
              ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
              std::__shared_weak_count::__release_weak(v25);
            }
          }
        }
        break;
      }
    }
    else
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v12 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v35);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v35);
        v13 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
        if (*((_QWORD *)&v35 + 1))
        {
          v14 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
          do
            v15 = __ldaxr(v14);
          while (__stlxr(v15 - 1, v14));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
        v12 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v16 = (std::__shared_weak_count *)off_2553234C8;
      if (off_2553234C8)
      {
        v17 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v12, (SEUpdaterUtil::SELogObj *)v32, 0, 0, 0, (SEUpdaterUtil::SELogObj *)"%s\n", v33);
      if (v16)
      {
        v19 = (unint64_t *)&v16->__shared_owners_;
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v7 = v33;
      bzero(v33, 0x1000uLL);
      v10 = 0;
      if ((const unsigned __int8 *)++v9 == a3)
        break;
    }
  }
  v8 = v34;
  if (v34)
  {
LABEL_47:
    v30 = (unint64_t *)&v8->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_21CCC59DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void boost::circular_buffer<unsigned char,std::allocator<unsigned char>>::destroy(char **a1)
{
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;

  v3 = a1[1];
  v2 = a1[2];
  v4 = a1[4];
  v5 = *a1;
  v6 = v3 - v2;
  v7 = &v5[v4 - v3];
  if (v6 <= (uint64_t)v4)
    v4 = v7;
  a1[2] = &v4[(_QWORD)v2];
  if (v5)
    operator delete(v5);
}

void std::__shared_ptr_pointer<char *,std::shared_ptr<char>::__shared_ptr_default_delete<char,char>,std::allocator<char>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_pointer<char *,std::shared_ptr<char>::__shared_ptr_default_delete<char,char>,std::allocator<char>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x22078A808);
  return result;
}

uint64_t std::__shared_ptr_pointer<char *,std::shared_ptr<char>::__shared_ptr_default_delete<char,char>,std::allocator<char>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t SEUpdaterUtil::Img4EncodeCallAndThrow(uint64_t this, char *a2, const char *a3)
{
  int v3;
  void *exception;
  void *v6;
  __int128 v7;

  if ((_DWORD)this != 100)
  {
    v3 = this;
    exception = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v7, a2);
    v6 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, &v7, v3, CFSTR("libImage4Encode"));
  }
  return this;
}

void sub_21CCC5BA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SEUpdaterUtil::SN300VImage4Signer::getSigningAlgorithm(SEUpdaterUtil::SN300VImage4Signer *this)
{
  return 1;
}

_QWORD *SEUpdaterUtil::SN300VImage4Signer::getSigningKey@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SN300VImage4Signer::getSigningKey(void)const::signingKey, (uint64_t)&SEUpdaterUtil::SN300VImage4Signer::getSigningCert(void)const::signingCert, 0xA7uLL);
}

_QWORD *SEUpdaterUtil::SN300VImage4Signer::getSigningCert@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SN300VImage4Signer::getSigningCert(void)const::signingCert, (uint64_t)"N13SEUpdaterUtil18SN300VImage4SignerE", 0x31EuLL);
}

void SEUpdaterUtil::SN300VImage4Signer::~SN300VImage4Signer(const void **this)
{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
}

{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
  JUMPOUT(0x22078A808);
}

uint64_t SEUpdaterUtil::SEImage4Signer::sign@<X0>(const __CFDictionary **a1@<X0>, CFDataRef *a2@<X8>)
{
  int Int;
  __CFString *v5;
  __CFString *v6;
  __CFString *v7;
  __CFString *v8;
  __CFString *v9;
  __CFString *v10;
  __CFString *v11;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  _BYTE v20[16];
  const __CFString *v21;

  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v20, *a1);
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v21, "SE,ChipID");
  Int = ctu::cf::map_adapter::getInt((ctu::cf::map_adapter *)v20, v21);
  MEMORY[0x22078A43C](&v21);
  if (Int <= 99)
  {
    switch(Int)
    {
      case ',':
        v9 = (__CFString *)operator new();
        v9->isa = &unk_24E0C1850;
        v9->info = 0;
        v21 = v9;
        ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v15, (const void **)a1);
        SEUpdaterUtil::SEImage4Signer::signInternal(a2, &v9->isa, &v15);
        ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v15);
        std::unique_ptr<SEUpdaterUtil::P73Image4Signer>::reset[abi:ne180100]((uint64_t *)&v21);
        return MEMORY[0x22078A454](v20);
      case '6':
        v10 = (__CFString *)operator new();
        v10->isa = &unk_24E0C1330;
        v10->info = 0;
        v21 = v10;
        ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v13, (const void **)a1);
        SEUpdaterUtil::SEImage4Signer::signInternal(a2, &v10->isa, &v13);
        ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v13);
        std::unique_ptr<SEUpdaterUtil::SN300V2Image4Signer>::reset[abi:ne180100]((uint64_t *)&v21, 0);
        return MEMORY[0x22078A454](v20);
      case '7':
        v6 = (__CFString *)operator new();
        v6->isa = &unk_24E0BFF38;
        v6->info = 0;
        v21 = v6;
        ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v14, (const void **)a1);
        SEUpdaterUtil::SEImage4Signer::signInternal(a2, &v6->isa, &v14);
        ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v14);
        std::unique_ptr<SEUpdaterUtil::P73Image4Signer>::reset[abi:ne180100]((uint64_t *)&v21);
        return MEMORY[0x22078A454](v20);
    }
LABEL_17:
    *a2 = 0;
    return MEMORY[0x22078A454](v20);
  }
  if (Int > 199)
  {
    if (Int == 200)
    {
      v11 = (__CFString *)operator new();
      v11->isa = &unk_24E0BFC78;
      v11->info = 0;
      v21 = v11;
      ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v17, (const void **)a1);
      SEUpdaterUtil::SEImage4Signer::signInternal(a2, &v11->isa, &v17);
      ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v17);
      std::unique_ptr<SEUpdaterUtil::P73Image4Signer>::reset[abi:ne180100]((uint64_t *)&v21);
      return MEMORY[0x22078A454](v20);
    }
    if (Int == 210)
    {
      v7 = (__CFString *)operator new();
      v7->isa = &unk_24E0C1B18;
      v7->info = 0;
      v21 = v7;
      ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v16, (const void **)a1);
      SEUpdaterUtil::SEImage4Signer::signInternal(a2, &v7->isa, &v16);
      ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v16);
      std::unique_ptr<SEUpdaterUtil::P73Image4Signer>::reset[abi:ne180100]((uint64_t *)&v21);
      return MEMORY[0x22078A454](v20);
    }
    goto LABEL_17;
  }
  if (Int == 100)
  {
    v8 = (__CFString *)operator new();
    v8->isa = &unk_24E0C1480;
    v8->info = 0;
    v21 = v8;
    ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v18, (const void **)a1);
    SEUpdaterUtil::SEImage4Signer::signInternal(a2, &v8->isa, &v18);
    ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v18);
    std::unique_ptr<SEUpdaterUtil::P73Image4Signer>::reset[abi:ne180100]((uint64_t *)&v21);
    return MEMORY[0x22078A454](v20);
  }
  if (Int != 115)
    goto LABEL_17;
  v5 = (__CFString *)operator new();
  v5->isa = &unk_24E0C1960;
  v5->info = 0;
  v21 = v5;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v19, (const void **)a1);
  SEUpdaterUtil::SEImage4Signer::signInternal(a2, &v5->isa, &v19);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v19);
  std::unique_ptr<SEUpdaterUtil::P73Image4Signer>::reset[abi:ne180100]((uint64_t *)&v21);
  return MEMORY[0x22078A454](v20);
}

void sub_21CCC6020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  const void *v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v7 = va_arg(va1, const void *);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)va);
  std::unique_ptr<SEUpdaterUtil::P73Image4Signer>::reset[abi:ne180100]((uint64_t *)(v5 - 40));
  MEMORY[0x22078A454](va1);
  _Unwind_Resume(a1);
}

void SEUpdaterUtil::SEImage4Signer::signInternal(CFDataRef *a1, void **a2, const void **a3)
{
  uint64_t (*v3)(uint64_t);
  void **v7;
  void *v8;
  int v9;
  const __CFNumber *Value;
  const char *v11;
  _BYTE *v12;
  _BYTE *v13;
  const __CFData *v14;
  const char *v15;
  uint64_t (*v16)(uint64_t);
  const UInt8 *BytePtr;
  const UInt8 *v18;
  CFIndex Length;
  const void *v20;
  char *v21;
  CFDataRef v22;
  uint64_t (*v23)(uint64_t);
  void *exception;
  std::string *v25;
  std::string *v26;
  __int128 v27;
  void *v28;
  std::string *v29;
  __int128 v30;
  const char *v31;
  void **v32;
  void **v33;
  void **v34;
  std::string v35;
  void *v36[2];
  int64_t v37;
  void *__p[2];
  void *v39;
  uint64_t v40;
  void *v41;
  _BYTE *v42;
  const __CFData *v43;
  uint64_t valuePtr;
  UInt8 *v45;
  void *v46[3];

  if (*a3)
    v3 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  else
    v3 = 0;
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    v25 = (std::string *)std::string::basic_string[abi:ne180100]<0>(v46, "Assertion: ");
    v26 = std::string::append(v25, "requestDict");
    v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
    v39 = (void *)v26->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v27;
    v26->__r_.__value_.__l.__size_ = 0;
    v26->__r_.__value_.__r.__words[2] = 0;
    v26->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, __p);
  }
  *a1 = 0;
  valuePtr = 0;
  v45 = 0;
  v7 = a2 + 1;
  v43 = 0;
  if (a2 + 1 != (void **)a3)
  {
    ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef((const void **)__p, a3);
    v8 = *v7;
    *v7 = __p[0];
    __p[0] = v8;
    ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)__p);
  }
  v9 = (*((uint64_t (**)(void **))*a2 + 4))(a2);
  (*((void (**)(void **__return_ptr, void **))*a2 + 5))(v46, a2);
  (*((void (**)(void **__return_ptr, void **))*a2 + 6))(&v41, a2);
  LODWORD(__p[0]) = v9;
  v39 = 0;
  v40 = 0;
  __p[1] = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p[1], v41, (uint64_t)v42, v42 - (_BYTE *)v41);
  Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)*a3, CFSTR("SE,ChipID"));
  if (!Value)
  {
    v12 = 0;
    SEUpdaterUtil::_AddError((SEUpdaterUtil *)0x1D, 1, (uint64_t)"signInternal", (SEUpdaterUtil::SELogObj *)"Missing SE,ChipID in request dictionary", v11);
    goto LABEL_22;
  }
  if (!CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr))
  {
    v28 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v35, "Assertion: ");
    v29 = std::string::append(&v35, "CFNumberGetValue(tmp, kCFNumberSInt32Type, (void *)&chipID)");
    v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
    v37 = v29->__r_.__value_.__r.__words[2];
    *(_OWORD *)v36 = v30;
    v29->__r_.__value_.__l.__size_ = 0;
    v29->__r_.__value_.__r.__words[2] = 0;
    v29->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v28, v36);
  }
  RootCA::getRootKeyId(0, valuePtr, v36);
  v12 = v36[0];
  v13 = v36[1];
  v35.__r_.__value_.__r.__words[0] = (std::string::size_type)CFDictionaryGetValue((CFDictionaryRef)*a3, CFSTR("SE,RootKeyIdentifier"));
  ctu::cf::CFSharedRef<__CFData const>::CFSharedRef<void const,void>(v36, (CFTypeRef *)&v35.__r_.__value_.__l.__data_);
  v14 = v43;
  v43 = (const __CFData *)v36[0];
  v36[0] = v14;
  ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)v36);
  if (v43)
    v16 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  else
    v16 = 0;
  if (!v16)
  {
    v21 = "Missing SE,RootKeyIdentifier in request dictionary";
    goto LABEL_44;
  }
  BytePtr = CFDataGetBytePtr(v43);
  v18 = CFDataGetBytePtr(v43);
  Length = CFDataGetLength(v43);
  v20 = (const void *)(v13 - v12);
  if (v13 - v12 == &v18[Length] - BytePtr && !memcmp(v12, BytePtr, (size_t)v20))
  {
    v33 = a2;
    v34 = __p;
    if (Img4EncodeCreateManifest() == 100)
    {
      v21 = "manifest is null or zero manifesetLen";
      if (v45 && HIDWORD(valuePtr))
      {
        v22 = CFDataCreate(0, v45, HIDWORD(valuePtr));
        *a1 = v22;
        v36[0] = 0;
        ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)v36);
        if (v22)
          v23 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
        else
          v23 = 0;
        if (v23)
          goto LABEL_22;
        v21 = "failed to CFDataCreate for manifest data";
      }
    }
    else
    {
      v21 = "failed to Img4EncodeCreateManifest";
    }
LABEL_44:
    SEUpdaterUtil::_AddError((SEUpdaterUtil *)0x1D, 1, (uint64_t)"signInternal", (SEUpdaterUtil::SELogObj *)v21, v15, v33, v34);
    goto LABEL_22;
  }
  ctu::cf::show((ctu::cf *)1, (uint64_t)v43, v20);
  if (v37 >= 0)
    v32 = v36;
  else
    v32 = (void **)v36[0];
  SEUpdaterUtil::_AddError((SEUpdaterUtil *)0x1D, 1, (uint64_t)"signInternal", (SEUpdaterUtil::SELogObj *)"KeyID %s is not localCA!", v31, v32);
  if (SHIBYTE(v37) < 0)
    operator delete(v36[0]);
LABEL_22:
  if (v45)
  {
    free(v45);
    v45 = 0;
  }
  if (__p[1])
  {
    v39 = __p[1];
    operator delete(__p[1]);
  }
  if (v41)
  {
    v42 = v41;
    operator delete(v41);
  }
  if (v46[0])
  {
    v46[1] = v46[0];
    operator delete(v46[0]);
  }
  ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)&v43);
  if (v12)
    operator delete(v12);
}

void sub_21CCC6544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31)
{
  const void **v31;
  void *v32;
  uint64_t v33;
  void *v35;

  if (a23 < 0)
    operator delete(__p);
  if (a26)
    operator delete(a26);
  if (a30)
    operator delete(a30);
  v35 = *(void **)(v33 - 88);
  if (v35)
  {
    *(_QWORD *)(v33 - 80) = v35;
    operator delete(v35);
  }
  ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef((const void **)(v33 - 112));
  if (v32)
    operator delete(v32);
  ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef(v31);
  _Unwind_Resume(a1);
}

uint64_t SEUpdaterUtil::manifestPropertiesCallback(SEUpdaterUtil *this, unsigned __int8 **a2, unsigned int *a3, void *a4)
{
  void *exception;
  std::string *v6;
  __int128 v7;
  std::string v8;
  __int128 v9;
  std::string::size_type v10;

  if (!a2 || !this || !a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v8, "Assertion: ");
    v6 = std::string::append(&v8, "context && outdata && outlength");
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v10 = v6->__r_.__value_.__r.__words[2];
    v9 = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v9);
  }
  (*(void (**)(unsigned int *, SEUpdaterUtil *, unsigned __int8 **, void *))(*(_QWORD *)a3 + 16))(a3, this, a2, a4);
  return 100;
}

void sub_21CCC6778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t SEUpdaterUtil::objectPropertiesCallback(SEUpdaterUtil *this, unsigned __int8 **a2, unsigned int *a3, void *a4)
{
  void *exception;
  std::string *v6;
  __int128 v7;
  std::string v8;
  __int128 v9;
  std::string::size_type v10;

  if (!a2 || !this || !a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v8, "Assertion: ");
    v6 = std::string::append(&v8, "context && outdata && outlength");
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v10 = v6->__r_.__value_.__r.__words[2];
    v9 = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v9);
  }
  (*(void (**)(unsigned int *, SEUpdaterUtil *, unsigned __int8 **, void *))(*(_QWORD *)a3 + 24))(a3, this, a2, a4);
  return 100;
}

void sub_21CCC68A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t SEUpdaterUtil::_createDataSignature(SEUpdaterUtil *this, uint64_t a2, const unsigned __int8 *a3, _QWORD *a4, unsigned __int8 **a5, unint64_t *a6, void *a7)
{
  int v9;
  uint64_t SignatureSha512;
  const char *v11;
  uint64_t v12;
  void *exception;
  std::string *v15;
  __int128 v16;
  void *v17;
  std::string *v18;
  __int128 v19;
  void *v20;
  std::string *v21;
  __int128 v22;
  char *v23;
  void *v25;
  std::string *v26;
  void *v27;
  std::string v28;
  std::string v29;

  if (!a6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v28, "Assertion: ");
    v15 = std::string::append(&v28, "context");
    v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v29);
  }
  if (!a4 || !a5)
  {
    v17 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v28, "Assertion: ");
    v18 = std::string::append(&v28, "outDataSignature && outDataSignatureLength");
    v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v17, &v29);
  }
  if (!a2 || !a3)
  {
    v20 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v28, "Assertion: ");
    v21 = std::string::append(&v28, "dataToSign && dataToSignLength");
    v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v20, &v29);
  }
  v9 = *(_DWORD *)a6;
  if (*(_DWORD *)a6 == 2)
  {
    SignatureSha512 = AMSupportEcDsaCreateSignatureSha512();
  }
  else if (v9 == 1)
  {
    SignatureSha512 = AMSupportEcDsaCreateSignatureSha384();
  }
  else
  {
    if (v9)
    {
      v25 = __cxa_allocate_exception(0x48uLL);
      std::to_string(&v28, *(_DWORD *)a6);
      v26 = std::string::insert(&v28, 0, "Unknown algorithm ");
      v29 = *v26;
      v26->__r_.__value_.__l.__size_ = 0;
      v26->__r_.__value_.__r.__words[2] = 0;
      v26->__r_.__value_.__r.__words[0] = 0;
      v27 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v25, (__int128 *)&v29, 29, CFSTR("SEUpdaterErrorDomain"));
    }
    SignatureSha512 = AMSupportEcDsaCreateSignatureSha256();
  }
  v12 = SignatureSha512;
  if ((_DWORD)SignatureSha512)
  {
    SEUpdaterUtil::_AddError((SEUpdaterUtil *)0x1D, 1, (uint64_t)"_createDataSignature", (SEUpdaterUtil::SELogObj *)"Failed to sign: %d", v11, SignatureSha512);
    return v12;
  }
  if (!*a4)
  {
    v23 = "*outDataSignature is nullptr";
LABEL_23:
    SEUpdaterUtil::_AddError((SEUpdaterUtil *)0x1D, 1, (uint64_t)"_createDataSignature", (SEUpdaterUtil::SELogObj *)v23, v11);
    return 0;
  }
  if (!*a5)
  {
    v23 = "*outDataSignatureLength is 0";
    goto LABEL_23;
  }
  return 100;
}

void sub_21CCC6C18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void SEUpdaterUtil::SEImage4Signer::doManifestPropertiesCB(CFDictionaryRef *this, unsigned __int8 **a2, unsigned int *a3)
{
  const __CFNumber *Value;
  int v5;
  const __CFData *v6;
  const __CFData *v7;
  CFTypeID v8;
  int v9;
  const __CFData *v10;
  const __CFData *v11;
  CFTypeID v12;
  int v13;
  int v14;
  int v15;
  void *exception;
  std::string *v17;
  __int128 v18;
  void *v19;
  std::string *v20;
  __int128 v21;
  void *v22;
  std::string *v23;
  __int128 v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  int valuePtr;
  uint64_t v42;
  std::string v43;
  __int128 v44;
  std::string::size_type v45;

  if (!a2 || !a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v43, "Assertion: ");
    v17 = std::string::append(&v43, "outdata && outlength");
    v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v45 = v17->__r_.__value_.__r.__words[2];
    v44 = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v44);
  }
  v42 = 0;
  valuePtr = 0;
  if (Img4EncodeItemBegin() != 100)
  {
    v29 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v44, "Fail to Img4EncodeItemBegin");
    v30 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v29, &v44, 29, CFSTR("SEUpdaterErrorDomain"));
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(this[1], CFSTR("SE,ChipID"));
  if (!Value)
  {
    v19 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v43, "Assertion: ");
    v20 = std::string::append(&v43, "tmpNum");
    v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v45 = v20->__r_.__value_.__r.__words[2];
    v44 = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v19, &v44);
  }
  if (!CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr))
  {
    v22 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v43, "Assertion: ");
    v23 = std::string::append(&v43, "CFNumberGetValue(tmpNum, kCFNumberSInt32Type, (void*)&tmpValue)");
    v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v45 = v23->__r_.__value_.__r.__words[2];
    v44 = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v22, &v44);
  }
  v5 = Img4EncodeItemPropertyInt32();
  if (v5 != 100)
  {
    v31 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v44, "Fail to add chip ID");
    v32 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v31, &v44, v5, CFSTR("libImage4Encode"));
  }
  v6 = (const __CFData *)CFDictionaryGetValue(this[1], CFSTR("SE,ID"));
  v7 = v6;
  if (!v6 || (v8 = CFGetTypeID(v6), v8 != CFDataGetTypeID()))
  {
    v25 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v44, "Fail to get SEID from the request");
    v26 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v25, &v44, 29, CFSTR("SEUpdaterErrorDomain"));
  }
  CFDataGetBytePtr(v7);
  CFDataGetLength(v7);
  v9 = Img4EncodeItemPropertyData();
  if (v9 != 100)
  {
    v33 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v44, "Fail to add SEID");
    v34 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v33, &v44, v9, CFSTR("libImage4Encode"));
  }
  v10 = (const __CFData *)CFDictionaryGetValue(this[1], CFSTR("SE,Nonce"));
  v11 = v10;
  if (!v10 || (v12 = CFGetTypeID(v10), v12 != CFDataGetTypeID()))
  {
    v27 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v44, "Fail to get Nonce from the request");
    v28 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v27, &v44, 100, CFSTR("libImage4Encode"));
  }
  CFDataGetBytePtr(v11);
  CFDataGetLength(v11);
  v13 = Img4EncodeItemPropertyData();
  if (v13 != 100)
  {
    v35 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v44, "Fail to add Nonce");
    v36 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v35, &v44, v13, CFSTR("libImage4Encode"));
  }
  v14 = Img4EncodeItemEnd();
  if (v14 != 100)
  {
    v37 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v44, "Fail to Img4EncodeItemEnd");
    v38 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v37, &v44, v14, CFSTR("libImage4Encode"));
  }
  v15 = Img4EncodeItemCopyBuffer();
  if (v15 != 100)
  {
    v39 = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v44, "Fail to Img4EncodeItemCopyBuffer");
    v40 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v39, &v44, v15, CFSTR("libImage4Encode"));
  }
  SEUpdaterUtil::SEImg4EncodeContext::~SEImg4EncodeContext((SEUpdaterUtil::SEImg4EncodeContext *)&v42);
}

void sub_21CCC7280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  SEUpdaterUtil::SEImg4EncodeContext::~SEImg4EncodeContext((SEUpdaterUtil::SEImg4EncodeContext *)&a11);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<SEUpdaterUtil::P73Image4Signer>::reset[abi:ne180100](uint64_t *result)
{
  uint64_t v1;

  v1 = *result;
  *result = 0;
  if (v1)
  {
    *(_QWORD *)v1 = off_24E0C18A8;
    ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)(v1 + 8));
    JUMPOUT(0x22078A808);
  }
  return result;
}

void sub_21CCC74AC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<SEUpdater::P73BaseSEController>::operator=[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  if (a3)
  {
    v4 = (unint64_t *)(a3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (std::__shared_weak_count *)a1[1];
  *a1 = a2;
  a1[1] = a3;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return a1;
}

void sub_21CCC7588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)SETransceiveHelper;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_21CCC77FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  void *v5;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  void *v10;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, void *);

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  v10 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va1);

  _Unwind_Resume(a1);
}

void sub_21CCC7ACC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  void *v5;
  void *v6;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  void *v11;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, void *);

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  v11 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_21CCC821C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  void *v29;
  void *v30;
  uint64_t v31;

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](a11);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](a12);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a29);
  *(_QWORD *)(v31 - 144) = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v31 - 136);

  _Unwind_Resume(a1);
}

void sub_21CCC8624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v10;
  va_list va;
  uint64_t v12;
  void *v13;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, void *);

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  v13 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_21CCC8BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  void *v5;
  void *v6;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  va_list va1;
  uint64_t v18;
  void *v19;
  va_list va2;

  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, void *);
  va_copy(va2, va1);
  v16 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  v19 = va_arg(va2, void *);

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  v15 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  v19 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va2);

  _Unwind_Resume(a1);
}

void sub_21CCC9014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a6);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_21CCC9364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, void *);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  v12 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_21CCC959C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  void *v5;
  void *v6;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  void *v11;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, void *);

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  v11 = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va1);

  _Unwind_Resume(a1);
}

void sub_21CCC9608()
{
  JUMPOUT(0x21CCC95FCLL);
}

void sub_21CCC984C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_21CCC9924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_21CCC9CBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v12;
  va_list va;

  va_start(va, a12);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100](v12 + 8);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void SEUpdater::CommandCRSRetrieveSEPK::~CommandCRSRetrieveSEPK(SEUpdater::CommandCRSRetrieveSEPK *this)
{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &unk_24E0BF880;
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x22078A808);
}

void sub_21CCCA030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  void *v12;
  void *v13;
  va_list va;

  va_start(va, a11);

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t SEUpdaterUtil::P73Image4Signer::getSigningAlgorithm(SEUpdaterUtil::P73Image4Signer *this)
{
  return 0;
}

double SEUpdaterUtil::P73Image4Signer::getSigningKey@<D0>(_QWORD *a1@<X8>)
{
  _OWORD *v3;
  double result;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v3 = operator new(0x79uLL);
  a1[1] = (char *)v3 + 121;
  a1[2] = (char *)v3 + 121;
  v3[4] = xmmword_21CCDB0F1;
  v3[5] = unk_21CCDB101;
  v3[6] = xmmword_21CCDB111;
  *(_OWORD *)((char *)v3 + 105) = *(__int128 *)((char *)&xmmword_21CCDB111 + 9);
  *v3 = xmmword_21CCDB0B1;
  v3[1] = unk_21CCDB0C1;
  result = -1.178079e-152;
  v3[2] = xmmword_21CCDB0D1;
  v3[3] = unk_21CCDB0E1;
  *a1 = v3;
  return result;
}

void *SEUpdaterUtil::P73Image4Signer::getSigningCert@<X0>(char **a1@<X8>)
{
  char *v3;
  char *v4;
  void *result;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v3 = (char *)operator new(0x26EuLL);
  *a1 = v3;
  v4 = v3 + 622;
  a1[2] = v3 + 622;
  result = memcpy(v3, &unk_21CCDB12A, 0x26EuLL);
  a1[1] = v4;
  return result;
}

void SEUpdaterUtil::P73Image4Signer::~P73Image4Signer(const void **this)
{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
}

{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
  JUMPOUT(0x22078A808);
}

SERestoreInfo::IcefallDeviceInfo *SERestoreInfo::IcefallDeviceInfo::IcefallDeviceInfo(SERestoreInfo::IcefallDeviceInfo *this, const SERestoreInfo::BLOB *a2)
{
  SERestoreInfo::SEWrongDeviceInfo *exception;

  *((_OWORD *)this + 1) = 0u;
  *(_QWORD *)this = &off_24E0C19A8;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_QWORD *)this + 16) = 0;
  *((_DWORD *)this + 37) = 6;
  *((_WORD *)this + 76) = 7;
  SERestoreInfo::IcefallDeviceInfo::updateFromMQ(this, a2);
  if (*((_DWORD *)this + 36) != 131601)
  {
    exception = (SERestoreInfo::SEWrongDeviceInfo *)__cxa_allocate_exception(0x48uLL);
    SERestoreInfo::SEWrongDeviceInfo::SEWrongDeviceInfo(exception);
  }
  return this;
}

void sub_21CCCA374(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;
  void **v3;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  __cxa_free_exception(v2);
  v5 = (void *)v1[14];
  if (v5)
  {
    v1[15] = v5;
    operator delete(v5);
  }
  v6 = (void *)v1[11];
  if (v6)
  {
    v1[12] = v6;
    operator delete(v6);
  }
  v7 = (void *)v1[8];
  if (v7)
  {
    v1[9] = v7;
    operator delete(v7);
  }
  v8 = (void *)v1[5];
  if (v8)
  {
    v1[6] = v8;
    operator delete(v8);
  }
  v9 = *v3;
  if (*v3)
  {
    v1[3] = v9;
    operator delete(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::IcefallDeviceInfo::updateFromMQ(SERestoreInfo::IcefallDeviceInfo *this, const SERestoreInfo::BLOB *a2)
{
  uint64_t v2;
  int v4;
  SERestoreInfo::SEWrongDeviceInfo *exception;

  v2 = *((_QWORD *)a2 + 1);
  if (!v2 || (*((_QWORD *)a2 + 2) & 0xFFFFFFFFFFFFFFFDLL) != 0x9D || *(_WORD *)v2 != 257)
  {
    exception = (SERestoreInfo::SEWrongDeviceInfo *)__cxa_allocate_exception(0x48uLL);
    SERestoreInfo::SEWrongDeviceInfo::SEWrongDeviceInfo(exception);
  }
  *((_BYTE *)this + 10) = *(_BYTE *)(v2 + 3) == 0;
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)this + 2, (char *)(v2 + 4), (char *)(v2 + 28), 0x18uLL);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)this + 5, (char *)(v2 + 28), (char *)(v2 + 48), 0x14uLL);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)this + 8, (char *)(v2 + 48), (char *)(v2 + 80), 0x20uLL);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)this + 11, (char *)(v2 + 112), (char *)(v2 + 144), 0x20uLL);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)this + 14, (char *)(v2 + 80), (char *)(v2 + 112), 0x20uLL);
  *((_QWORD *)this + 17) = *(_QWORD *)(v2 + 144);
  v4 = *(unsigned __int8 *)(v2 + 2);
  *((_DWORD *)this + 36) = *(_DWORD *)(v2 + 153);
  *((_DWORD *)this + 37) = v4;
  return 1;
}

void sub_21CCCA4EC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::IcefallDeviceInfo::updateDict(SERestoreInfo::IcefallDeviceInfo *this, __CFDictionary *a2, char a3)
{
  CFNumberRef v6;
  CFNumberRef v7;
  CFDataRef v8;
  CFDataRef v9;
  CFDataRef v10;
  CFDataRef v11;
  uint64_t v12;
  CFDataRef v13;
  CFDataRef v14;
  const void **v15;
  CFDataRef v16;
  CFDataRef v17;
  CFDataRef v18;
  CFDataRef v19;
  int valuePtr;

  valuePtr = *((_DWORD *)this + 36);
  v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt32Type, &valuePtr);
  if (!v6)
    __assert_rtn("_CFDictionarySetInteger32", "SERestoreInfoHelpers.hpp", 42, "num != nullptr");
  v7 = v6;
  CFDictionarySetValue(a2, CFSTR("SE,ChipID"), v6);
  CFRelease(v7);
  v8 = CFDataCreate(0, *((const UInt8 **)this + 2), *((_QWORD *)this + 3) - *((_QWORD *)this + 2));
  if (!v8)
    goto LABEL_15;
  v9 = v8;
  CFDictionarySetValue(a2, CFSTR("SE,ID"), v8);
  CFRelease(v9);
  v10 = CFDataCreate(0, *((const UInt8 **)this + 5), *((_QWORD *)this + 6) - *((_QWORD *)this + 5));
  if (!v10)
    goto LABEL_15;
  v11 = v10;
  CFDictionarySetValue(a2, CFSTR("SE,Nonce"), v10);
  CFRelease(v11);
  v12 = MEMORY[0x24BDBD270];
  if (*((_BYTE *)this + 153))
    CFDictionarySetValue(a2, CFSTR("SE,FactoryMode"), (const void *)*MEMORY[0x24BDBD270]);
  v13 = CFDataCreate(0, *((const UInt8 **)this + 8), *((_QWORD *)this + 9) - *((_QWORD *)this + 8));
  if (!v13)
    goto LABEL_15;
  v14 = v13;
  CFDictionarySetValue(a2, CFSTR("SE,RootKeyIdentifier"), v13);
  CFRelease(v14);
  if ((a3 & 1) != 0)
    return;
  v15 = (const void **)(*((_BYTE *)this + 10) ? v12 : MEMORY[0x24BDBD268]);
  CFDictionarySetValue(a2, CFSTR("SE,IsDev"), *v15);
  v16 = CFDataCreate(0, *((const UInt8 **)this + 14), *((_QWORD *)this + 15) - *((_QWORD *)this + 14));
  if (!v16
    || (v17 = v16,
        CFDictionarySetValue(a2, CFSTR("SE,BLFWKeysIdentifier"), v16),
        CFRelease(v17),
        (v18 = CFDataCreate(0, *((const UInt8 **)this + 11), *((_QWORD *)this + 12) - *((_QWORD *)this + 11))) == 0))
  {
LABEL_15:
    __assert_rtn("_CFDictionarySetData", "SERestoreInfoHelpers.hpp", 59, "tmpData");
  }
  v19 = v18;
  CFDictionarySetValue(a2, CFSTR("SE,OsKeysIdentifier"), v18);
  CFRelease(v19);
}

void SERestoreInfo::IcefallDeviceInfo::~IcefallDeviceInfo(SERestoreInfo::IcefallDeviceInfo *this)
{
  SERestoreInfo::IcefallDeviceInfo::~IcefallDeviceInfo(this);
  JUMPOUT(0x22078A808);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0C19A8;
  v2 = (void *)*((_QWORD *)this + 14);
  if (v2)
  {
    *((_QWORD *)this + 15) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 11);
  if (v3)
  {
    *((_QWORD *)this + 12) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 8);
  if (v4)
  {
    *((_QWORD *)this + 9) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 5);
  if (v5)
  {
    *((_QWORD *)this + 6) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 2);
  if (v6)
  {
    *((_QWORD *)this + 3) = v6;
    operator delete(v6);
  }
}

_QWORD *SERestoreInfo::IcefallDeviceInfo::getOsKeyId@<X0>(SERestoreInfo::IcefallDeviceInfo *this@<X0>, _QWORD *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(a2, *((const void **)this + 11), *((_QWORD *)this + 12), *((_QWORD *)this + 12) - *((_QWORD *)this + 11));
}

uint64_t SERestoreInfo::IcefallDeviceInfo::getChipID(SERestoreInfo::IcefallDeviceInfo *this)
{
  return *((unsigned int *)this + 36);
}

SERestoreInfo::SN300VDeviceInfo *SERestoreInfo::SN300VDeviceInfo::SN300VDeviceInfo(SERestoreInfo::SN300VDeviceInfo *this, const SERestoreInfo::BLOB *a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  SERestoreInfo::SEWrongDeviceInfo *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_24E0C19F8;
  if (*((_DWORD *)v3 + 14) != 44)
  {
    exception = (SERestoreInfo::SEWrongDeviceInfo *)__cxa_allocate_exception(0x48uLL);
    SERestoreInfo::SEWrongDeviceInfo::SEWrongDeviceInfo(exception);
  }
  return this;
}

void sub_21CCCA87C(_Unwind_Exception *a1)
{
  SERestoreInfo::P73BaseDeviceInfo *v1;

  SERestoreInfo::P73BaseDeviceInfo::~P73BaseDeviceInfo(v1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::SN300VDeviceInfo::~SN300VDeviceInfo(SERestoreInfo::SN300VDeviceInfo *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
  JUMPOUT(0x22078A808);
}

void getAlohaPairingOptions(id *a1@<X0>, uint64_t a2@<X8>)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  BOOL v7;
  void *v8;
  void *v9;
  void *v10;
  char v11;
  void *v12;
  void *v13;
  void *v14;
  void *exception;
  void *v16;
  __int128 v17;
  const void *v18;
  const void *v19;
  __int16 v20;
  char v21;
  const void *v22;
  const void *v23;
  const void *v24;

  v3 = *a1;
  objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("Options"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v4)
    _ObjCLog((SEUpdaterUtil::SELogObj *)2, "getAlohaPairingOptions", CFSTR("Options not present\n"));
  objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("DebugLogPath"));
  v5 = objc_claimAutoreleasedReturnValue();
  v6 = (void *)v5;
  if (v4)
    v7 = v5 == 0;
  else
    v7 = 0;
  if (v7)
    _ObjCLog((SEUpdaterUtil::SELogObj *)2, "getAlohaPairingOptions", CFSTR("DebugLogPath not present\n"));
  objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("RestoreOptions"));
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = v8;
  if (!v8)
  {
    _ObjCLog((SEUpdaterUtil::SELogObj *)2, "getAlohaPairingOptions", CFSTR("Skip pairing due to RestoreOptions not present\n"));
LABEL_15:
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 40) = 0;
    goto LABEL_27;
  }
  objc_msgSend(v8, "objectForKeyedSubscript:", CFSTR("PairStockholm"));
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = objc_msgSend(v10, "BOOLValue");

  if ((v11 & 1) == 0)
  {
    _ObjCLog((SEUpdaterUtil::SELogObj *)2, "getAlohaPairingOptions", CFSTR("Pairing not enabled\n"));
    goto LABEL_15;
  }
  objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("StockholmPairingProtocolVersion"));
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInteger:", objc_msgSend(v12, "integerValue"));
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v13, "integerValue") > 1)
  {
    objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("StockholmPairingServerURL"));
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v14)
    {
      _ObjCLog(0, "getAlohaPairingOptions", CFSTR("Pairing is requested but no server URL is provided\n"));
      exception = __cxa_allocate_exception(0x48uLL);
      std::string::basic_string[abi:ne180100]<0>(&v17, "Pairing is requested but no server URL is provided\n");
      v16 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, &v17, 2, CFSTR("SEUpdaterErrorDomain"));
    }
    v24 = v13;
    if (v13)
      CFRetain(v13);
    v23 = v14;
    CFRetain(v14);
    v22 = v6;
    if (v6)
      CFRetain(v6);
    LOBYTE(v17) = v11;
    if (v13)
      CFRetain(v13);
    CFRetain(v14);
    if (v6)
      CFRetain(v6);
    v20 = 1;
    v21 = 1;
    *(_BYTE *)a2 = v11;
    *(_QWORD *)(a2 + 8) = v13;
    *(_QWORD *)(a2 + 16) = v14;
    *((_QWORD *)&v17 + 1) = 0;
    v18 = 0;
    *(_QWORD *)(a2 + 24) = v6;
    v19 = 0;
    *(_WORD *)(a2 + 32) = 1;
    *(_BYTE *)(a2 + 34) = 1;
    *(_BYTE *)(a2 + 40) = 1;
    ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef(&v19);
    ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef(&v18);
    ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::~SharedRef((const void **)&v17 + 1);
    ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef(&v22);
    ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef(&v23);
    ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::~SharedRef(&v24);

  }
  else
  {
    _ObjCLog((SEUpdaterUtil::SELogObj *)2, "getAlohaPairingOptions", CFSTR("Skip pairing due to version %@\n"), v12);
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 40) = 0;
  }

LABEL_27:
}

void sub_21CCCACC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  if (a16 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_21CCCAD60()
{
  JUMPOUT(0x21CCCAD54);
}

void doAlohaPairing(unsigned __int8 *a1, uint64_t *a2)
{
  void *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  void *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  void *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  const void *v29;
  uint64_t v30;
  uint64_t (*v31)(uint64_t);
  const char *v32;
  unint64_t *v33;
  unint64_t v34;
  void *v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  const void *v42;
  uint64_t v43;
  uint64_t (*v44)(uint64_t);
  uint64_t (*v45)(uint64_t);
  void **v46;
  unint64_t *v47;
  unint64_t v48;
  SEUpdaterUtil::SELogObj *v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  const void *v56;
  uint64_t v57;
  void **v58;
  unint64_t *v59;
  unint64_t v60;
  SEUpdaterUtil::SELogObj *v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  unint64_t *v68;
  unint64_t v69;
  SEUpdaterUtil::SELogObj *v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  unint64_t *v77;
  unint64_t v78;
  AlohaPairingController *v79;
  std::__shared_weak_count *v80;
  unint64_t *v81;
  unint64_t v82;
  AlohaPairingController *v83;
  std::__shared_weak_count *v84;
  unint64_t *v85;
  unint64_t v86;
  uint64_t v87;
  int v88;
  BOOL v89;
  __CFError *v90;
  BOOL v91;
  void *v92;
  void *exception;
  void *v94;
  __CFError *v95;
  id v96;
  SERestoreInfo::SEException *v97;
  SERestoreInfo::SEException *v98;
  void *v99;
  void *v100;
  void *v101;
  void *v102;
  void *v103;
  id v104;
  __int128 v105;
  uint64_t v106;
  std::__shared_weak_count *v107;
  SEUpdaterUtil::SELogObj *v108;
  void *v109;
  void *v110[2];
  char v111;
  void *__p[2];
  char v113;
  __int128 v114;
  char v115;

  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v4 = off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v114);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v114);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v114 + 1);
    if (*((_QWORD *)&v114 + 1))
    {
      v6 = (unint64_t *)(*((_QWORD *)&v114 + 1) + 8);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    v4 = off_2553234C0;
  }
  v8 = (std::__shared_weak_count *)off_2553234C8;
  __p[0] = v4;
  __p[1] = off_2553234C8;
  if (off_2553234C8)
  {
    v9 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v4, (SEUpdaterUtil::SELogObj *)2, 0, 1, "print", (SEUpdaterUtil::SELogObj *)"Pairing options:\n");
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v13 = off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v114);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v114);
    v14 = (std::__shared_weak_count *)*((_QWORD *)&v114 + 1);
    if (*((_QWORD *)&v114 + 1))
    {
      v15 = (unint64_t *)(*((_QWORD *)&v114 + 1) + 8);
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    v13 = off_2553234C0;
  }
  v17 = (std::__shared_weak_count *)off_2553234C8;
  __p[0] = v13;
  __p[1] = off_2553234C8;
  if (off_2553234C8)
  {
    v18 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v13, (SEUpdaterUtil::SELogObj *)2, 0, 1, "print", (SEUpdaterUtil::SELogObj *)"Pairing selected: %d\n", *a1);
  if (v17)
  {
    v20 = (unint64_t *)&v17->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v22 = off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v114);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v114);
    v23 = (std::__shared_weak_count *)*((_QWORD *)&v114 + 1);
    if (*((_QWORD *)&v114 + 1))
    {
      v24 = (unint64_t *)(*((_QWORD *)&v114 + 1) + 8);
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    v22 = off_2553234C0;
  }
  v26 = (std::__shared_weak_count *)off_2553234C8;
  __p[0] = v22;
  __p[1] = off_2553234C8;
  if (off_2553234C8)
  {
    v27 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v30 = *((_QWORD *)a1 + 1);
  if (v30)
    v31 = ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::get;
  else
    v31 = 0;
  if (v31)
  {
    ctu::cf::show((ctu::cf *)1, v30, v29);
    if (v115 >= 0)
      v32 = (const char *)&v114;
    else
      v32 = (const char *)v114;
  }
  else
  {
    v32 = 0;
  }
  SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v22, (SEUpdaterUtil::SELogObj *)2, 0, 1, "print", (SEUpdaterUtil::SELogObj *)"Pairing protocol version: %s\n", v32);
  if (v31 && v115 < 0)
    operator delete((void *)v114);
  if (v26)
  {
    v33 = (unint64_t *)&v26->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v35 = off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v36 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v37 = (unint64_t *)((char *)__p[1] + 8);
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    v35 = off_2553234C0;
  }
  v39 = (std::__shared_weak_count *)off_2553234C8;
  v110[0] = v35;
  v110[1] = off_2553234C8;
  if (off_2553234C8)
  {
    v40 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v43 = *((_QWORD *)a1 + 2);
  v44 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
  if (v43)
    v45 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
  else
    v45 = 0;
  if (v45)
  {
    ctu::cf::show((ctu::cf *)1, v43, v42);
    if (v113 >= 0)
      v46 = __p;
    else
      v46 = (void **)__p[0];
  }
  else
  {
    v46 = 0;
  }
  SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v35, (SEUpdaterUtil::SELogObj *)2, 0, 1, "print", (SEUpdaterUtil::SELogObj *)"Pairing hostname URL: %s\n", (const char *)v46);
  if (v45 && v113 < 0)
    operator delete(__p[0]);
  if (v39)
  {
    v47 = (unint64_t *)&v39->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v49 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(v110);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)v110);
    v50 = (std::__shared_weak_count *)v110[1];
    if (v110[1])
    {
      v51 = (unint64_t *)((char *)v110[1] + 8);
      do
        v52 = __ldaxr(v51);
      while (__stlxr(v52 - 1, v51));
      if (!v52)
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
    }
    v49 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v53 = (std::__shared_weak_count *)off_2553234C8;
  *(_QWORD *)&v105 = v49;
  *((_QWORD *)&v105 + 1) = off_2553234C8;
  if (off_2553234C8)
  {
    v54 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v57 = *((_QWORD *)a1 + 3);
  if (!v57)
    v44 = 0;
  if (v44)
  {
    ctu::cf::show((ctu::cf *)1, v57, v56);
    if (v111 >= 0)
      v58 = v110;
    else
      v58 = (void **)v110[0];
  }
  else
  {
    v58 = 0;
  }
  SEUpdaterUtil::SELogObj::printLog(v49, (SEUpdaterUtil::SELogObj *)2, 0, 1, "print", (SEUpdaterUtil::SELogObj *)"Pairing error debug log path: %s\n", (const char *)v58);
  if (v44 && v111 < 0)
    operator delete(v110[0]);
  if (v53)
  {
    v59 = (unint64_t *)&v53->__shared_owners_;
    do
      v60 = __ldaxr(v59);
    while (__stlxr(v60 - 1, v59));
    if (!v60)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v61 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v105);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v105);
    v62 = (std::__shared_weak_count *)*((_QWORD *)&v105 + 1);
    if (*((_QWORD *)&v105 + 1))
    {
      v63 = (unint64_t *)(*((_QWORD *)&v105 + 1) + 8);
      do
        v64 = __ldaxr(v63);
      while (__stlxr(v64 - 1, v63));
      if (!v64)
      {
        ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
        std::__shared_weak_count::__release_weak(v62);
      }
    }
    v61 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v65 = (std::__shared_weak_count *)off_2553234C8;
  v108 = v61;
  v109 = off_2553234C8;
  if (off_2553234C8)
  {
    v66 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v67 = __ldxr(v66);
    while (__stxr(v67 + 1, v66));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v61, (SEUpdaterUtil::SELogObj *)2, 0, 1, "print", (SEUpdaterUtil::SELogObj *)"Pairing with reverse proxy: %d\n", a1[32]);
  if (v65)
  {
    v68 = (unint64_t *)&v65->__shared_owners_;
    do
      v69 = __ldaxr(v68);
    while (__stlxr(v69 - 1, v68));
    if (!v69)
    {
      ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
      std::__shared_weak_count::__release_weak(v65);
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v70 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v105);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v105);
    v71 = (std::__shared_weak_count *)*((_QWORD *)&v105 + 1);
    if (*((_QWORD *)&v105 + 1))
    {
      v72 = (unint64_t *)(*((_QWORD *)&v105 + 1) + 8);
      do
        v73 = __ldaxr(v72);
      while (__stlxr(v73 - 1, v72));
      if (!v73)
      {
        ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
        std::__shared_weak_count::__release_weak(v71);
      }
    }
    v70 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v74 = (std::__shared_weak_count *)off_2553234C8;
  v108 = v70;
  v109 = off_2553234C8;
  if (off_2553234C8)
  {
    v75 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v76 = __ldxr(v75);
    while (__stxr(v76 + 1, v75));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v70, (SEUpdaterUtil::SELogObj *)2, 0, 1, "print", (SEUpdaterUtil::SELogObj *)"Submitting sePK to FDR: %d\n", a1[34]);
  if (v74)
  {
    v77 = (unint64_t *)&v74->__shared_owners_;
    do
      v78 = __ldaxr(v77);
    while (__stlxr(v78 - 1, v77));
    if (!v78)
    {
      ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
      std::__shared_weak_count::__release_weak(v74);
    }
  }
  v79 = [AlohaPairingController alloc];
  v80 = (std::__shared_weak_count *)a2[1];
  v106 = *a2;
  v107 = v80;
  if (v80)
  {
    v81 = (unint64_t *)&v80->__shared_owners_;
    do
      v82 = __ldxr(v81);
    while (__stxr(v82 + 1, v81));
  }
  v83 = -[AlohaPairingController initWithOptions:seController:](v79, "initWithOptions:seController:", a1, &v106);
  v84 = v107;
  if (v107)
  {
    v85 = (unint64_t *)&v107->__shared_owners_;
    do
      v86 = __ldaxr(v85);
    while (__stlxr(v86 - 1, v85));
    if (!v86)
    {
      ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
      std::__shared_weak_count::__release_weak(v84);
    }
  }
  v87 = -[AlohaPairingController performAlohaPairing](v83, "performAlohaPairing");
  v88 = v87;
  _ObjCLog((SEUpdaterUtil::SELogObj *)2, "doAlohaPairing", CFSTR("APC finished with return code %d\n"), v87);
  if (v88)
  {
    -[AlohaPairingController debugRecordPath](v83, "debugRecordPath");
    v92 = (void *)objc_claimAutoreleasedReturnValue();

    if (v92)
    {
      -[AlohaPairingController transceiver](v83, "transceiver");
      v99 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v99, "capduRecord");
      v100 = (void *)objc_claimAutoreleasedReturnValue();
      -[AlohaPairingController writeRecord:fileExtension:](v83, "writeRecord:fileExtension:", v100, CFSTR("capdu"));

      -[AlohaPairingController transceiver](v83, "transceiver");
      v101 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v101, "rapduRecord");
      v102 = (void *)objc_claimAutoreleasedReturnValue();
      -[AlohaPairingController writeRecord:fileExtension:](v83, "writeRecord:fileExtension:", v102, CFSTR("rapdu"));

      -[AlohaPairingController alohaPlistRecord](v83, "alohaPlistRecord");
      v103 = (void *)objc_claimAutoreleasedReturnValue();
      -[AlohaPairingController writeRecord:fileExtension:](v83, "writeRecord:fileExtension:", v103, CFSTR("plist"));

    }
    else
    {
      _ObjCLog((SEUpdaterUtil::SELogObj *)2, "doAlohaPairing", CFSTR("debugLogPath is unavailable, unable to log APDU and plists\n"));
    }
    -[AlohaPairingController invalidate](v83, "invalidate");
    exception = __cxa_allocate_exception(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v105, "Aloha Pairing failed with return code\n");
    v94 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, &v105, v88, CFSTR("SEUpdaterErrorDomain"));
  }
  if (a1[34])
  {
    v104 = 0;
    v89 = -[AlohaPairingController submitPairingRecord:](v83, "submitPairingRecord:", &v104);
    v90 = (__CFError *)v104;
    if (v90)
      v91 = 0;
    else
      v91 = v89;
    if (!v91)
    {
      v95 = v90;
      -[__CFError description](v90, "description");
      v96 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      _ObjCLog(0, "doAlohaPairing", CFSTR("Failed to query submit pairing record: %s\n"), objc_msgSend(v96, "UTF8String"));

      -[AlohaPairingController invalidate](v83, "invalidate");
      v97 = (SERestoreInfo::SEException *)__cxa_allocate_exception(0x48uLL);
      v98 = SERestoreInfo::SEException::SEException(v97, v95);
    }
  }
  -[AlohaPairingController invalidate](v83, "invalidate");

}

void sub_21CCCB788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  void *v32;
  void *v33;

  _Unwind_Resume(a1);
}

void sub_21CCCBAB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

uint64_t ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

void sub_21CCCBB38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)AlohaPairingController;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_21CCCC108(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_21CCCC6E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_21CCCCD20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _Unwind_Exception *exception_object, void *a12, void *a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void sub_21CCCD130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  void *v11;

  _Unwind_Resume(a1);
}

void sub_21CCCD290(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_21CCCD648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,id a27)
{
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;

  _Block_object_dispose(&a22, 8);
  _Block_object_dispose((const void *)(v34 - 136), 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{

}

void sub_21CCCD828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_21CCCDCF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t *v11;
  uint64_t v12;
  unint64_t v14;
  uint64_t v15;
  va_list va;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  id v21;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v15 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  v20 = va_arg(va1, _QWORD);
  v21 = va_arg(va1, id);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(v12 - 112));
  if (*(_BYTE *)(v12 - 96))
    std::mutex::unlock(*(std::mutex **)(v12 - 104));
  do
    v14 = __ldaxr(v11);
  while (__stlxr(v14 - 1, v11));
  if (!v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10);
  _Block_object_dispose(va, 8);

  _Block_object_dispose(va1, 8);
  std::promise<BOOL>::~promise(v9);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__131(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

uint64_t *__Block_byref_object_dispose__132(uint64_t a1)
{
  return std::promise<BOOL>::~promise((uint64_t *)(a1 + 48));
}

void sub_21CCCDF10(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_21CCCE084(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_21CCCE1E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_21CCCE5E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void std::__assoc_state<BOOL>::~__assoc_state(uint64_t a1)
{
  std::exception_ptr *v2;

  *(_QWORD *)a1 = MEMORY[0x24BEDB850] + 16;
  v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

{
  std::exception_ptr *v2;

  *(_QWORD *)a1 = MEMORY[0x24BEDB850] + 16;
  v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__assoc_state<BOOL>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
}

uint64_t *std::promise<BOOL>::~promise(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  const std::error_category *v7;
  std::logic_error *exception;
  std::logic_error *v9;
  std::logic_error v10;
  std::logic_error v11;
  std::exception_ptr v12;

  v2 = *a1;
  if (v2)
  {
    if ((*(_BYTE *)(v2 + 136) & 1) == 0)
    {
      v12.__ptr_ = 0;
      v3 = *(_QWORD *)(v2 + 16);
      std::exception_ptr::~exception_ptr(&v12);
      v2 = *a1;
      if (!v3 && *(uint64_t *)(v2 + 8) >= 1)
      {
        v7 = std::future_category();
        MEMORY[0x22078A598](&v10, 4, v7);
        exception = (std::logic_error *)__cxa_allocate_exception(0x20uLL);
        v9 = std::logic_error::logic_error(exception, &v10);
        v9->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB810] + 16);
        v9[1] = v11;
        __cxa_throw(v9, MEMORY[0x24BEDB6E0], (void (*)(void *))MEMORY[0x24BEDAD80]);
      }
    }
    v4 = (unint64_t *)(v2 + 8);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  }
  return a1;
}

void sub_21CCCE7B4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__assoc_sub_state *a10, char a11)
{
  uint64_t v11;
  std::exception_ptr v12;

  __cxa_begin_catch(a1);
  std::current_exception();
  __cxa_end_catch();
  v12.__ptr_ = (void *)(v11 - 32);
  std::__assoc_sub_state::set_exception(a10, v12);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(v11 - 32));
  MEMORY[0x22078A5A4](&a11);
  JUMPOUT(0x21CCCE724);
}

void std::__throw_future_error[abi:ne180100](unsigned int a1)
{
  void *exception;
  const std::error_category *v3;

  exception = __cxa_allocate_exception(0x20uLL);
  v3 = std::future_category();
  MEMORY[0x22078A598](exception, a1, v3);
  __cxa_throw(exception, MEMORY[0x24BEDB6E0], (void (*)(void *))MEMORY[0x24BEDAD80]);
}

void sub_21CCCE838(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void _GLOBAL__sub_I_AlohaPairingController_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x22078AB2C]();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 1);
  _MergedGlobals_4 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 1);
  qword_255323778 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 0);
  qword_255323780 = objc_claimAutoreleasedReturnValue();
  objc_autoreleasePoolPop(v0);
}

CFErrorRef SERestoreInfo::CreateCFError(const UInt8 *a1, int a2, const void *a3, const __CFString *a4)
{
  const __CFAllocator *v8;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v10;
  CFIndex v11;
  const UInt8 *v12;
  CFStringRef v13;
  CFStringRef v14;
  CFErrorRef v15;
  void *exception;
  std::string *v18;
  __int128 v19;
  void *v20;
  std::string *v21;
  __int128 v22;
  std::string v23;
  __int128 v24;
  std::string::size_type v25;

  v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v23, "Assertion: ");
    v18 = std::string::append(&v23, "userInfo");
    v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v25 = v18->__r_.__value_.__r.__words[2];
    v24 = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v24);
  }
  v10 = Mutable;
  if ((char)a1[23] < 0)
  {
    v12 = a1;
    a1 = *(const UInt8 **)a1;
    v11 = *((_QWORD *)v12 + 1);
  }
  else
  {
    v11 = a1[23];
  }
  v13 = CFStringCreateWithBytes(v8, a1, v11, 0x8000100u, 0);
  if (!v13)
  {
    v20 = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v23, "Assertion: ");
    v21 = std::string::append(&v23, "description");
    v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v25 = v21->__r_.__value_.__r.__words[2];
    v24 = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](v20, &v24);
  }
  v14 = v13;
  CFDictionaryAddValue(v10, (const void *)*MEMORY[0x24BDBD3A0], v13);
  CFRelease(v14);
  if (a3)
    CFDictionaryAddValue(v10, (const void *)*MEMORY[0x24BDBD3B0], a3);
  v15 = CFErrorCreate(v8, a4, a2, v10);
  CFRelease(v10);
  return v15;
}

void sub_21CCCEAAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  char v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  if ((v22 & 1) != 0)
    __cxa_free_exception(v21);
  _Unwind_Resume(exception_object);
}

uint64_t SEUpdaterUtil::SN210VImage4Signer::getSigningAlgorithm(SEUpdaterUtil::SN210VImage4Signer *this)
{
  return 0;
}

_QWORD *SEUpdaterUtil::SN210VImage4Signer::getSigningKey@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SN210VImage4Signer::getSigningKey(void)const::signingKey, (uint64_t)&SEUpdaterUtil::SN210VImage4Signer::getSigningCert(void)const::signingCert, 0x79uLL);
}

_QWORD *SEUpdaterUtil::SN210VImage4Signer::getSigningCert@<X0>(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a1, &SEUpdaterUtil::SN210VImage4Signer::getSigningCert(void)const::signingCert, (uint64_t)"N13SEUpdaterUtil18SN210VImage4SignerE", 0x276uLL);
}

void SEUpdaterUtil::SN210VImage4Signer::~SN210VImage4Signer(const void **this)
{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
}

{
  *this = off_24E0C18A8;
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(this + 1);
  JUMPOUT(0x22078A808);
}

SERestoreInfo::SE310SDeviceInfo *SERestoreInfo::SE310SDeviceInfo::SE310SDeviceInfo(SERestoreInfo::SE310SDeviceInfo *this, const SERestoreInfo::BLOB *a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  SERestoreInfo::SEWrongDeviceInfo *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_24E0C1B60;
  if (*((_DWORD *)v3 + 14) != 55)
  {
    exception = (SERestoreInfo::SEWrongDeviceInfo *)__cxa_allocate_exception(0x48uLL);
    SERestoreInfo::SEWrongDeviceInfo::SEWrongDeviceInfo(exception);
  }
  return this;
}

void sub_21CCCEC68(_Unwind_Exception *a1)
{
  SERestoreInfo::P73BaseDeviceInfo *v1;

  SERestoreInfo::P73BaseDeviceInfo::~P73BaseDeviceInfo(v1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::SE310SDeviceInfo::~SE310SDeviceInfo(SERestoreInfo::SE310SDeviceInfo *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
  JUMPOUT(0x22078A808);
}

double ___ZN13SERestoreInfo16SERestoreInfoLog3getEv_block_invoke()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  *(_QWORD *)v0 = SERestoreInfo::SERestoreInfoLog::printToOsLog;
  *(_QWORD *)(v0 + 8) = 0;
  *(_DWORD *)(v0 + 16) = 2;
  *(_QWORD *)(v0 + 24) = 850045863;
  result = 0.0;
  *(_OWORD *)(v0 + 32) = 0u;
  *(_OWORD *)(v0 + 48) = 0u;
  *(_OWORD *)(v0 + 64) = 0u;
  *(_QWORD *)(v0 + 80) = 0;
  SERestoreInfo::SERestoreInfoLog::instance = v0;
  return result;
}

void SERestoreInfo::SERestoreInfoLog::printToOsLog(SERestoreInfo::SERestoreInfoLog *this, char *a2, const char *a3)
{
  unint64_t v3;
  NSObject *v4;
  std::string *v5;
  std::string v6;
  std::string __str;
  char v8;
  uint8_t buf[4];
  std::string *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  std::string::basic_string[abi:ne180100]<0>(&__str, a2);
  v3 = 0;
  v4 = MEMORY[0x24BDACB70];
  while ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v3 >= HIBYTE(__str.__r_.__value_.__r.__words[2]))
      return;
LABEL_6:
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      std::string::basic_string(&v6, &__str, v3, 0x3E8uLL, (std::allocator<char> *)&v8);
      if ((v6.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v5 = &v6;
      else
        v5 = (std::string *)v6.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315138;
      v10 = v5;
      _os_log_impl(&dword_21CC7F000, v4, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
      if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v6.__r_.__value_.__l.__data_);
    }
    v3 += 1000;
  }
  if (v3 < __str.__r_.__value_.__l.__size_)
    goto LABEL_6;
  operator delete(__str.__r_.__value_.__l.__data_);
}

void sub_21CCCEF30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  _Unwind_Resume(exception_object);
}

char *SERestoreInfo::SERestoreInfoLog::FormatMsg(SERestoreInfo::SERestoreInfoLog *this, const char *a2, ...)
{
  int v2;
  BOOL v3;
  char *v5;
  va_list va;

  va_start(va, a2);
  v5 = 0;
  v2 = vasprintf(&v5, "[%3.3ld.%1.1d] [%s] %s: %s", va);
  if (v5)
    v3 = v2 <= 0;
  else
    v3 = 1;
  if (v3)
    return 0;
  else
    return v5;
}

char *SERestoreInfo::SERestoreInfoLog::createVerboseLogString(SERestoreInfo::SERestoreInfoLog *this, unsigned int a2, const char *a3, const char *a4)
{
  SERestoreInfo::SERestoreInfoLog *v7;
  const char *v8;
  void *exception;
  std::string *v11;
  timeval v12;
  std::string v13;
  timeval v14;
  std::string::size_type v15;

  if (a2 >= 5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v13, "Assertion: ");
    v11 = std::string::append(&v13, "level >= 0 && level < _LOG_LEVEL_MAX && \"level is not good\"");
    v12 = *(timeval *)&v11->__r_.__value_.__l.__data_;
    v15 = v11->__r_.__value_.__r.__words[2];
    v14 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v14);
  }
  v14.tv_sec = 0;
  *(_QWORD *)&v14.tv_usec = 0;
  v7 = (SERestoreInfo::SERestoreInfoLog *)gettimeofday(&v14, 0);
  return SERestoreInfo::SERestoreInfoLog::FormatMsg(v7, v8, v14.tv_sec, (v14.tv_usec / 1000), SERestoreInfo::logLevelNames[a2], a3, a4);
}

void sub_21CCCF094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;
  int v26;

  if (a25 < 0)
    operator delete(__p);
  if (a19 < 0)
  {
    operator delete(a14);
    if ((v26 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v26)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v25);
  goto LABEL_8;
}

void SERestoreInfo::SERestoreInfoLog::printLogv(SERestoreInfo::SERestoreInfoLog *this, unsigned int a2, const char *a3, const char *a4, va_list a5)
{
  SERestoreInfo::SERestoreInfoLog *v8;
  char *v9;
  char *VerboseLogString;
  char *v12;

  v12 = 0;
  v8 = (SERestoreInfo::SERestoreInfoLog *)vasprintf(&v12, a4, a5);
  v9 = v12;
  if ((int)v8 >= 1 && v12 != 0)
  {
    VerboseLogString = SERestoreInfo::SERestoreInfoLog::createVerboseLogString(v8, a2, a3, v12);
    free(v9);
    if (VerboseLogString)
    {
      std::mutex::lock((std::mutex *)((char *)this + 24));
      (*(void (**)(_QWORD, char *))this)(*((_QWORD *)this + 1), VerboseLogString);
      std::mutex::unlock((std::mutex *)((char *)this + 24));
      free(VerboseLogString);
    }
  }
}

void SERestoreInfo::SERestoreInfoLog::printLog(SERestoreInfo::SERestoreInfoLog *this, signed int a2, const char *a3, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  if (*((_DWORD *)this + 4) >= a2)
    SERestoreInfo::SERestoreInfoLog::printLogv(this, a2, a3, a4, va);
}

const void *SEUpdaterCreate(const __CFDictionary *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  NSObject **v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  NSObject *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  SEUpdaterUtil::SELogObj *v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  const char *v25;
  unint64_t *v26;
  unint64_t v27;
  const __CFDictionary *Value;
  const __CFDictionary *v29;
  CFTypeID v30;
  ctu::cf *v31;
  ctu::cf *v32;
  CFTypeID v33;
  SEUpdaterUtil::SELogObj *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  const void *v41;
  const char *v42;
  unint64_t *v43;
  unint64_t v44;
  _BOOL8 v45;
  SEUpdaterUtil::SELogObj *v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  SEUpdaterUtil::SELogObj *v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  unint64_t *v61;
  const char *v62;
  uint64_t Instance;
  uint64_t v64;
  const void *v65;
  const void *v66;
  const void **v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  SEUpdaterUtil *ErrorCode;
  SEUpdaterUtil::SELogObj *v72;
  std::__shared_weak_count *v73;
  unint64_t *v74;
  unint64_t v75;
  unint64_t *v76;
  unint64_t v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  char *v82;
  __int128 *p_p;
  std::__shared_weak_count *v84;
  __int128 __p;
  _QWORD *(*v86)(_QWORD *);
  void *v87;
  NSObject **v88;
  uint64_t v89;
  uint64_t v90;
  SEUpdaterUtil::SELogObj *block;
  uint64_t v92;
  _QWORD *(*v93)(uint64_t);
  void *v94;
  NSObject **v95;
  __int128 **p_p_p;

  if (a2)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v8 = (NSObject **)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &__p);
      v9 = (std::__shared_weak_count *)*((_QWORD *)&__p + 1);
      if (*((_QWORD *)&__p + 1))
      {
        v10 = (unint64_t *)(*((_QWORD *)&__p + 1) + 8);
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      v8 = (NSObject **)off_2553234C0;
    }
    v12 = (std::__shared_weak_count *)off_2553234C8;
    if (off_2553234C8)
    {
      v13 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    *(_QWORD *)&__p = MEMORY[0x24BDAC760];
    *((_QWORD *)&__p + 1) = 0x40000000;
    v86 = ___ZN13SEUpdaterUtil8SELogObj15registerLogSinkEPvPFvS1_PKcE_block_invoke;
    v87 = &__block_descriptor_tmp_22;
    v88 = v8;
    v89 = a2;
    v90 = a3;
    block = (SEUpdaterUtil::SELogObj *)MEMORY[0x24BDAC760];
    p_p = &__p;
    v92 = 0x40000000;
    v93 = ___ZNK3ctu20SharedSynchronizableIN13SEUpdaterUtil8SELogObjEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke_0;
    v94 = &__block_descriptor_tmp_23;
    v95 = v8;
    p_p_p = &p_p;
    v15 = v8[2];
    if (v8[3])
    {
      dispatch_async_and_wait(v15, &block);
      if (!v12)
        goto LABEL_20;
    }
    else
    {
      dispatch_sync(v15, &block);
      if (!v12)
        goto LABEL_20;
    }
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
LABEL_20:
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v18 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &__p);
    v19 = (std::__shared_weak_count *)*((_QWORD *)&__p + 1);
    if (*((_QWORD *)&__p + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&__p + 1) + 8);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v18 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v22 = (std::__shared_weak_count *)off_2553234C8;
  block = v18;
  v92 = (uint64_t)off_2553234C8;
  if (off_2553234C8)
  {
    v23 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  std::string::basic_string[abi:ne180100]<0>(&__p, "root");
  if (SHIBYTE(v86) >= 0)
    v25 = (const char *)&__p;
  else
    v25 = (const char *)__p;
  SEUpdaterUtil::SELogObj::printLog(v18, (SEUpdaterUtil::SELogObj *)2, 0, 1, "SEUpdaterCreate", (SEUpdaterUtil::SELogObj *)"Project version%s: %s\n", " beta", v25);
  if (SHIBYTE(v86) < 0)
    operator delete((void *)__p);
  if (v22)
  {
    v26 = (unint64_t *)&v22->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("Options"));
  v29 = Value;
  if (!Value || (v30 = CFGetTypeID(Value), v30 != CFDictionaryGetTypeID()))
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v46 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &__p);
      v47 = (std::__shared_weak_count *)*((_QWORD *)&__p + 1);
      if (*((_QWORD *)&__p + 1))
      {
        v48 = (unint64_t *)(*((_QWORD *)&__p + 1) + 8);
        do
          v49 = __ldaxr(v48);
        while (__stlxr(v49 - 1, v48));
        if (!v49)
        {
          ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
          std::__shared_weak_count::__release_weak(v47);
        }
      }
      v46 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v50 = (std::__shared_weak_count *)off_2553234C8;
    block = v46;
    v92 = (uint64_t)off_2553234C8;
    if (off_2553234C8)
    {
      v51 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v52 = __ldxr(v51);
      while (__stxr(v52 + 1, v51));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v46, (SEUpdaterUtil::SELogObj *)1, 0, 1, "IsBootedOS", (SEUpdaterUtil::SELogObj *)"No RestoreOptions dictionary? Defaulting to limited environment\n");
    if (!v50)
      goto LABEL_94;
    v53 = (unint64_t *)&v50->__shared_owners_;
    do
      v54 = __ldaxr(v53);
    while (__stlxr(v54 - 1, v53));
    goto LABEL_92;
  }
  v31 = (ctu::cf *)CFDictionaryGetValue(v29, CFSTR("PreflightContext"));
  v32 = v31;
  if (!v31 || (v33 = CFGetTypeID(v31), v33 != CFStringGetTypeID()))
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v55 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &__p);
      v56 = (std::__shared_weak_count *)*((_QWORD *)&__p + 1);
      if (*((_QWORD *)&__p + 1))
      {
        v57 = (unint64_t *)(*((_QWORD *)&__p + 1) + 8);
        do
          v58 = __ldaxr(v57);
        while (__stlxr(v58 - 1, v57));
        if (!v58)
        {
          ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
          std::__shared_weak_count::__release_weak(v56);
        }
      }
      v55 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v50 = (std::__shared_weak_count *)off_2553234C8;
    block = v55;
    v92 = (uint64_t)off_2553234C8;
    if (off_2553234C8)
    {
      v59 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v60 = __ldxr(v59);
      while (__stxr(v60 + 1, v59));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v55, (SEUpdaterUtil::SELogObj *)1, 0, 1, "IsBootedOS", (SEUpdaterUtil::SELogObj *)"No updater context hint, defaulting to limited environment\n");
    if (!v50)
      goto LABEL_94;
    v61 = (unint64_t *)&v50->__shared_owners_;
    do
      v54 = __ldaxr(v61);
    while (__stlxr(v54 - 1, v61));
LABEL_92:
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
LABEL_94:
    v45 = 0;
    goto LABEL_95;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v34 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &__p);
    v35 = (std::__shared_weak_count *)*((_QWORD *)&__p + 1);
    if (*((_QWORD *)&__p + 1))
    {
      v36 = (unint64_t *)(*((_QWORD *)&__p + 1) + 8);
      do
        v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
    v34 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v38 = (std::__shared_weak_count *)off_2553234C8;
  block = v34;
  v92 = (uint64_t)off_2553234C8;
  if (off_2553234C8)
  {
    v39 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v40 = __ldxr(v39);
    while (__stxr(v40 + 1, v39));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  ctu::cf::show(v32, v41);
  if (SHIBYTE(v86) >= 0)
    v42 = (const char *)&__p;
  else
    v42 = (const char *)__p;
  SEUpdaterUtil::SELogObj::printLog(v34, (SEUpdaterUtil::SELogObj *)1, 0, 1, "IsBootedOS", (SEUpdaterUtil::SELogObj *)"Got Updater Context %s\n", v42);
  if (SHIBYTE(v86) < 0)
    operator delete((void *)__p);
  if (v38)
  {
    v43 = (unint64_t *)&v38->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  v45 = CFStringCompare((CFStringRef)v32, CFSTR("BootedOS"), 0) == kCFCompareEqualTo;
LABEL_95:
  SEUpdater::makeUpdateController((SEUpdater *)v45, &__p);
  if (!(_QWORD)__p)
  {
    v82 = "no controller instance";
LABEL_130:
    SEUpdaterUtil::_AddError((SEUpdaterUtil *)3, 1, (uint64_t)"SEUpdaterCreate", (SEUpdaterUtil::SELogObj *)v82, v62);
    v66 = 0;
    goto LABEL_101;
  }
  if (_MergedGlobals_5 != -1)
    dispatch_once(&_MergedGlobals_5, &__block_literal_global_1);
  if (!qword_255323790)
  {
    v82 = "fail to register kLibSEUpdaterClass";
    goto LABEL_130;
  }
  Instance = _CFRuntimeCreateInstance();
  v66 = (const void *)Instance;
  if (!Instance)
  {
    v82 = "fail to create SEUpdaterObj";
    goto LABEL_130;
  }
  *(_QWORD *)(Instance + 16) = 0;
  v67 = SEUpdater::UpdateControllerBase::start((const void **)__p, a1, v64, v65);
LABEL_101:
  v68 = (std::__shared_weak_count *)*((_QWORD *)&__p + 1);
  if (*((_QWORD *)&__p + 1))
  {
    v69 = (unint64_t *)(*((_QWORD *)&__p + 1) + 8);
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
      std::__shared_weak_count::__release_weak(v68);
    }
  }
  ErrorCode = (SEUpdaterUtil *)SEUpdaterUtil::GetErrorCode((SEUpdaterUtil *)v67);
  if ((_DWORD)ErrorCode)
  {
    if (a4)
      *a4 = SEUpdaterUtil::CreateCFError(ErrorCode);
    if (v66)
    {
      CFRelease(v66);
      v66 = 0;
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v72 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &__p);
    v73 = (std::__shared_weak_count *)*((_QWORD *)&__p + 1);
    if (*((_QWORD *)&__p + 1))
    {
      v74 = (unint64_t *)(*((_QWORD *)&__p + 1) + 8);
      do
        v75 = __ldaxr(v74);
      while (__stlxr(v75 - 1, v74));
      if (!v75)
      {
        ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
        std::__shared_weak_count::__release_weak(v73);
      }
    }
    v72 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  p_p = (__int128 *)v72;
  v84 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v76 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v77 = __ldxr(v76);
    while (__stxr(v77 + 1, v76));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v72, (SEUpdaterUtil::SELogObj *)2, 0, 1, "SEUpdaterCreate", (SEUpdaterUtil::SELogObj *)"Created updater %p\n", v66);
  v78 = v84;
  if (v84)
  {
    v79 = (unint64_t *)&v84->__shared_owners_;
    do
      v80 = __ldaxr(v79);
    while (__stlxr(v80 - 1, v79));
    if (!v80)
    {
      ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
      std::__shared_weak_count::__release_weak(v78);
    }
  }
  return v66;
}

void sub_21CCCF9E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  unsigned int *v26;
  SEUpdaterUtil *v27;
  const char *v28;
  void *v29;
  const char *v30;

  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  if (a2 == 3)
  {
    v26 = (unsigned int *)__cxa_begin_catch(a1);
    v27 = (SEUpdaterUtil *)v26[16];
    (*(void (**)(unsigned int *))(*(_QWORD *)v26 + 16))(v26);
    SEUpdaterUtil::_AddError(v27, 1, (uint64_t)"SEUpdaterCreate", (SEUpdaterUtil::SELogObj *)"%s", v28);
  }
  else
  {
    if (a2 != 2)
      _Unwind_Resume(a1);
    v29 = __cxa_begin_catch(a1);
    (*(void (**)(void *))(*(_QWORD *)v29 + 16))(v29);
    SEUpdaterUtil::_AddError((SEUpdaterUtil *)0x1F, 1, (uint64_t)"SEUpdaterCreate", (SEUpdaterUtil::SELogObj *)"%s", v30);
  }
  __cxa_end_catch();
  JUMPOUT(0x21CCCF85CLL);
}

void sub_21CCCFBC4()
{
  __cxa_end_catch();
  JUMPOUT(0x21CCCFB0CLL);
}

void sub_21CCCFBD0()
{
  __cxa_end_catch();
  JUMPOUT(0x21CCCFB0CLL);
}

void SEUpdaterDestroy(const void *a1)
{
  SEUpdaterUtil::SELogObj *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  __int128 v17;

  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v17);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v17);
    v3 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
    if (*((_QWORD *)&v17 + 1))
    {
      v4 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v6 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v7 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v2, (SEUpdaterUtil::SELogObj *)2, 0, 1, "SEUpdaterDestroy", (SEUpdaterUtil::SELogObj *)"Called SEUpdaterDestroy updater %p\n", a1);
  if (!v6)
    goto LABEL_15;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (!a1)
      return;
  }
  else
  {
LABEL_15:
    if (!a1)
      return;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
  std::shared_ptr<SEUpdater::UpdateControllerBase>::reset[abi:ne180100](&xmmword_255323688);
  pthread_mutex_unlock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::Error,SEUpdaterUtil::Error,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::Error>>::sInstance);
  v11 = (std::__shared_weak_count *)off_255323598;
  qword_255323590 = 0;
  off_255323598 = 0;
  if (v11)
  {
    v12 = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::Error,SEUpdaterUtil::Error,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::Error>>::sInstance);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v14 = (std::__shared_weak_count *)off_2553234C8;
  off_2553234C0 = 0;
  off_2553234C8 = 0;
  if (v14)
  {
    v15 = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
}

void sub_21CCCFDF8(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

CFStringRef SEUpdaterCreateDescribe(CFStringRef result)
{
  CFStringRef v1;
  const __CFAllocator *v2;
  CFAllocatorRef v3;

  if (result)
  {
    v1 = result;
    v2 = CFGetAllocator(result);
    v3 = CFGetAllocator(v1);
    return CFStringCreateWithFormat(v2, 0, CFSTR("<libSEUpdater %p [%p]>{}"), v1, v3);
  }
  return result;
}

uint64_t SEUpdaterUtil::GetErrorCode(SEUpdaterUtil *this)
{
  SEUpdaterUtil::Error *v1;
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t ErrorCode;
  unint64_t *p_shared_owners;
  unint64_t v10;
  __int128 v12;

  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::Error,SEUpdaterUtil::Error,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::Error>>::sInstance);
  v1 = (SEUpdaterUtil::Error *)qword_255323590;
  if (!qword_255323590)
  {
    SEUpdaterUtil::Error::create_default_global(&v12);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&qword_255323590, &v12);
    v2 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
    if (*((_QWORD *)&v12 + 1))
    {
      v3 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
      do
        v4 = __ldaxr(v3);
      while (__stlxr(v4 - 1, v3));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
    v1 = (SEUpdaterUtil::Error *)qword_255323590;
  }
  v5 = (std::__shared_weak_count *)off_255323598;
  if (off_255323598)
  {
    v6 = (unint64_t *)((char *)off_255323598 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::Error,SEUpdaterUtil::Error,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::Error>>::sInstance);
  ErrorCode = SEUpdaterUtil::Error::getErrorCode(v1);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return ErrorCode;
}

void sub_21CCCFF78(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::Error,SEUpdaterUtil::Error,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::Error>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t SEUpdaterUtil::CreateCFError(SEUpdaterUtil *this)
{
  SEUpdaterUtil::Error *v1;
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t CFError;
  unint64_t *p_shared_owners;
  unint64_t v10;
  __int128 v12;

  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::Error,SEUpdaterUtil::Error,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::Error>>::sInstance);
  v1 = (SEUpdaterUtil::Error *)qword_255323590;
  if (!qword_255323590)
  {
    SEUpdaterUtil::Error::create_default_global(&v12);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&qword_255323590, &v12);
    v2 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
    if (*((_QWORD *)&v12 + 1))
    {
      v3 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
      do
        v4 = __ldaxr(v3);
      while (__stlxr(v4 - 1, v3));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
    v1 = (SEUpdaterUtil::Error *)qword_255323590;
  }
  v5 = (std::__shared_weak_count *)off_255323598;
  if (off_255323598)
  {
    v6 = (unint64_t *)((char *)off_255323598 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::Error,SEUpdaterUtil::Error,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::Error>>::sInstance);
  CFError = SEUpdaterUtil::Error::CreateCFError(v1);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return CFError;
}

void sub_21CCD008C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::Error,SEUpdaterUtil::Error,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::Error>>::sInstance);
  _Unwind_Resume(a1);
}

BOOL SEUpdaterExecCommand(uint64_t a1, const __CFString *a2, const __CFDictionary *a3, const __CFDictionary **a4, char *a5)
{
  const void **v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  const char *v16;
  SEUpdaterUtil *v17;
  int v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  SEUpdaterUtil::SELogObj *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  const void *v28;
  unint64_t *v29;
  unint64_t v30;
  __int128 v32;

  if (a1 && a2)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
    v9 = (const void **)xmmword_255323688;
    if (!(_QWORD)xmmword_255323688)
    {
      v32 = 0uLL;
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&xmmword_255323688, &v32);
      v10 = (std::__shared_weak_count *)*((_QWORD *)&v32 + 1);
      if (*((_QWORD *)&v32 + 1))
      {
        v11 = (unint64_t *)(*((_QWORD *)&v32 + 1) + 8);
        do
          v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
      v9 = (const void **)xmmword_255323688;
    }
    v13 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_255323688 + 1);
    if (*((_QWORD *)&xmmword_255323688 + 1))
    {
      v14 = (unint64_t *)(*((_QWORD *)&xmmword_255323688 + 1) + 8);
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
    if (v9)
    {
      v17 = (SEUpdaterUtil *)SEUpdater::UpdateControllerBase::execCommand(v9, a2, a3, a4);
      v18 = (int)v17;
    }
    else
    {
      v18 = 2;
      SEUpdaterUtil::_AddError((SEUpdaterUtil *)2, 0, (uint64_t)"SEUpdaterExecCommand", (SEUpdaterUtil::SELogObj *)"no controller instance", v16);
    }
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v20 = __ldaxr(p_shared_owners);
      while (__stlxr(v20 - 1, p_shared_owners));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
  else
  {
    v18 = 2;
    SEUpdaterUtil::_AddError((SEUpdaterUtil *)2, 0, (uint64_t)"SEUpdaterExecCommand", (SEUpdaterUtil::SELogObj *)"Invalid input", a5);
  }
  if (a5 && v18)
  {
    *(_QWORD *)a5 = SEUpdaterUtil::CreateCFError(v17);
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v32);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v32);
      v22 = (std::__shared_weak_count *)*((_QWORD *)&v32 + 1);
      if (*((_QWORD *)&v32 + 1))
      {
        v23 = (unint64_t *)(*((_QWORD *)&v32 + 1) + 8);
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v25 = (std::__shared_weak_count *)off_2553234C8;
    if (off_2553234C8)
    {
      v26 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v21, (SEUpdaterUtil::SELogObj *)2, 0, 1, "SEUpdaterExecCommand", (SEUpdaterUtil::SELogObj *)"Returning outError:\n");
    if (v25)
    {
      v29 = (unint64_t *)&v25->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    SEUpdaterUtil::SELogPrintCFType((SEUpdaterUtil *)2, (ctu::cf *)1, *(const void **)a5, v28);
  }
  return v18 == 0;
}

void sub_21CCD0330(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

void sub_21CCD0360(void *a1, int a2, uint64_t a3, uint64_t a4, ...)
{
  unsigned int *v6;
  SEUpdaterUtil *v7;
  const char *v8;
  void *v9;
  const char *v10;
  va_list va;

  va_start(va, a4);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)va);
  if (a2 == 2)
  {
    v6 = (unsigned int *)__cxa_begin_catch(a1);
    v7 = (SEUpdaterUtil *)v6[16];
    (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 16))(v6);
    SEUpdaterUtil::_AddError(v7, 1, (uint64_t)"SEUpdaterExecCommand", (SEUpdaterUtil::SELogObj *)"%s", v8);
    __cxa_end_catch();
  }
  else
  {
    if (a2 != 1)
      JUMPOUT(0x21CCD0354);
    v9 = __cxa_begin_catch(a1);
    (*(void (**)(void *))(*(_QWORD *)v9 + 16))(v9);
    SEUpdaterUtil::_AddError((SEUpdaterUtil *)0x1F, 1, (uint64_t)"SEUpdaterExecCommand", (SEUpdaterUtil::SELogObj *)"%s", v10);
    __cxa_end_catch();
  }
  JUMPOUT(0x21CCD01BCLL);
}

void sub_21CCD0410()
{
  __cxa_end_catch();
  JUMPOUT(0x21CCD0354);
}

void sub_21CCD041C()
{
  __cxa_end_catch();
  JUMPOUT(0x21CCD0354);
}

void SEUpdaterUtil::SELogPrintCFType(SEUpdaterUtil *this, ctu::cf *a2, const void *a3, const void *a4)
{
  SEUpdaterUtil::SELogObj *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  const char *p_p;
  unint64_t *p_shared_owners;
  unint64_t v14;
  void *__p;
  char v16;
  __int128 v17;

  ctu::cf::show(a2, (uint64_t)a3, a3);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v5 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v17);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v17);
    v6 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
    if (*((_QWORD *)&v17 + 1))
    {
      v7 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    v5 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v9 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v10 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  p_p = (const char *)&__p;
  if (v16 < 0)
    p_p = (const char *)__p;
  SEUpdaterUtil::SELogObj::printLog(v5, this, 0, 1, 0, (SEUpdaterUtil::SELogObj *)"%s\n", p_p);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (v16 < 0)
    operator delete(__p);
}

void sub_21CCD0578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

BOOL SEUpdaterIsDone(uint64_t a1, CFErrorRef *a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  _BOOL8 v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  void *__p[2];
  char v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;

  if (!a1)
    return 0;
  pthread_mutex_lock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
  v3 = xmmword_255323688;
  if (!(_QWORD)xmmword_255323688)
  {
    v18 = 0uLL;
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&xmmword_255323688, &v18);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
    if (*((_QWORD *)&v18 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    v3 = xmmword_255323688;
  }
  v7 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_255323688 + 1);
  v16 = v3;
  v17 = *((_QWORD *)&xmmword_255323688 + 1);
  if (*((_QWORD *)&xmmword_255323688 + 1))
  {
    v8 = (unint64_t *)(*((_QWORD *)&xmmword_255323688 + 1) + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
  if (v3)
  {
    v10 = *(_BYTE *)(v3 + 80) != 0;
    if (!v7)
      return v10;
    goto LABEL_19;
  }
  if (a2)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "no controller instance");
    *a2 = SERestoreInfo::CreateCFError((const UInt8 *)__p, 3, 0, CFSTR("SEUpdaterErrorDomain"));
    if (v15 < 0)
      operator delete(__p[0]);
  }
  v10 = 1;
  if (v7)
  {
LABEL_19:
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return v10;
}

void sub_21CCD0720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
    operator delete(__p);
  std::shared_ptr<SLAM::SEHandle>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_21CCD0804(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

void std::shared_ptr<SEUpdater::UpdateControllerBase>::reset[abi:ne180100](_QWORD *a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void SEUpdater::cbNfRestoreSEEnumerate(uint64_t a1, unsigned int a2, _OWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  SEUpdaterUtil::SELogObj *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _DWORD *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  SEUpdaterUtil::SELogObj *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  void *exception;
  std::string *v32;
  __int128 v33;
  std::string v35;
  __int128 v36;
  std::string::size_type v37;

  if (!a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v35, "Assertion: ");
    v32 = std::string::append(&v35, "ctx");
    v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v37 = v32->__r_.__value_.__r.__words[2];
    v36 = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v36);
  }
  if (a2)
  {
    v4 = 0;
    v5 = a2;
    while (1)
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v6 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v36);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v36);
        v7 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
        if (*((_QWORD *)&v36 + 1))
        {
          v8 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
          do
            v9 = __ldaxr(v8);
          while (__stlxr(v9 - 1, v8));
          if (!v9)
          {
            ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
            std::__shared_weak_count::__release_weak(v7);
          }
        }
        v6 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v10 = (std::__shared_weak_count *)off_2553234C8;
      v35.__r_.__value_.__r.__words[0] = (std::string::size_type)v6;
      v35.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
      if (off_2553234C8)
      {
        v11 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v12 = __ldxr(v11);
        while (__stxr(v12 + 1, v11));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v13 = (_DWORD *)(a1 + 144 * v4);
      SEUpdaterUtil::SELogObj::printLog(v6, (SEUpdaterUtil::SELogObj *)3, 0, 1, "cbNfRestoreSEEnumerate", (SEUpdaterUtil::SELogObj *)"found SE with ID: %d \n", *v13);
      if (v10)
      {
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v15 = __ldaxr(p_shared_owners);
        while (__stlxr(v15 - 1, p_shared_owners));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
      if (*(_BYTE *)(a1 + 144 * v4 + 4))
        break;
      if (++v4 == v5)
        return;
    }
    *a3 = *(_OWORD *)v13;
    v16 = *((_OWORD *)v13 + 1);
    v17 = *((_OWORD *)v13 + 2);
    v18 = *((_OWORD *)v13 + 4);
    a3[3] = *((_OWORD *)v13 + 3);
    a3[4] = v18;
    a3[1] = v16;
    a3[2] = v17;
    v19 = *((_OWORD *)v13 + 5);
    v20 = *((_OWORD *)v13 + 6);
    v21 = *((_OWORD *)v13 + 8);
    a3[7] = *((_OWORD *)v13 + 7);
    a3[8] = v21;
    a3[5] = v19;
    a3[6] = v20;
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v22 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v36);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v36);
      v23 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
      if (*((_QWORD *)&v36 + 1))
      {
        v24 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      v22 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v26 = (std::__shared_weak_count *)off_2553234C8;
    v35.__r_.__value_.__r.__words[0] = (std::string::size_type)v22;
    v35.__r_.__value_.__l.__size_ = (std::string::size_type)off_2553234C8;
    if (off_2553234C8)
    {
      v27 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v28 = __ldxr(v27);
      while (__stxr(v28 + 1, v27));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v22, (SEUpdaterUtil::SELogObj *)3, 0, 1, "cbNfRestoreSEEnumerate", (SEUpdaterUtil::SELogObj *)"Selecting SE with ID: %d \n", *v13);
    if (v26)
    {
      v29 = (unint64_t *)&v26->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
  }
}

void sub_21CCD0BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

void SEUpdater::makeUpdateController(SEUpdater *this@<X0>, _QWORD *a2@<X8>)
{
  int v2;
  SEUpdaterUtil::SELogObj *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  char *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  SEUpdaterUtil::SELogObj *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  SEUpdaterUtil::SELogObj *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  SEUpdaterUtil::SELogObj *v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  __int128 v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  _QWORD *v66;
  _QWORD *v67;
  SEUpdaterUtil::SELogObj *v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  __int128 v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  std::__shared_weak_count *v81;
  unint64_t *v82;
  unint64_t v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t *v89;
  unint64_t v90;
  int v91;
  unint64_t *v92;
  unint64_t v93;
  std::__shared_weak_count *v94;
  unint64_t *v95;
  unint64_t v96;
  uint64_t v97;
  std::__shared_weak_count *v98;
  unint64_t *v99;
  unint64_t v100;
  uint64_t v101;
  unint64_t *v102;
  unint64_t v103;
  std::__shared_weak_count *v104;
  unint64_t *v105;
  unint64_t v106;
  __int128 v107[9];
  char *v108;
  std::__shared_weak_count *v109;
  __int128 v110;
  char v111;
  __int128 v112;

  v2 = (int)this;
  pthread_mutex_lock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
  std::shared_ptr<SEUpdater::UpdateControllerBase>::reset[abi:ne180100](&xmmword_255323688);
  pthread_mutex_unlock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v4 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(v107);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, v107);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v107[0] + 1);
    if (*((_QWORD *)&v107[0] + 1))
    {
      v6 = (unint64_t *)(*((_QWORD *)&v107[0] + 1) + 8);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    v4 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v8 = (std::__shared_weak_count *)off_2553234C8;
  *(_QWORD *)&v110 = v4;
  *((_QWORD *)&v110 + 1) = off_2553234C8;
  if (off_2553234C8)
  {
    v9 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v4, (SEUpdaterUtil::SELogObj *)2, 0, 1, "makeUpdateController", (SEUpdaterUtil::SELogObj *)"Are we in booted OS? %d\n", v2);
  if (!v8)
    goto LABEL_15;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if (v2)
    {
LABEL_16:
      v13 = (char *)operator new(0x98uLL);
      *((_QWORD *)v13 + 1) = 0;
      *((_QWORD *)v13 + 2) = 0;
      *(_QWORD *)v13 = &off_24E0C1D28;
      *(_OWORD *)(v13 + 24) = 0u;
      *(_OWORD *)(v13 + 40) = 0u;
      *(_OWORD *)(v13 + 56) = 0u;
      *(_OWORD *)(v13 + 72) = 0u;
      *(_OWORD *)(v13 + 88) = 0u;
      *(_OWORD *)(v13 + 104) = 0u;
      *(_OWORD *)(v13 + 120) = 0u;
      *(_OWORD *)(v13 + 136) = 0u;
      SEUpdater::UpdateControllerBase::UpdateControllerBase((SEUpdater::UpdateControllerBase *)(v13 + 24));
      *((_QWORD *)v13 + 3) = &unk_24E0C1570;
      v108 = v13 + 24;
      v109 = (std::__shared_weak_count *)v13;
      v107[0] = 0uLL;
      pthread_mutex_lock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
      v14 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_255323688 + 1);
      *(_QWORD *)&xmmword_255323688 = v13 + 24;
      *((_QWORD *)&xmmword_255323688 + 1) = v13;
      v108 = 0;
      v109 = 0;
      pthread_mutex_unlock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
      if (v14)
      {
        v15 = (unint64_t *)&v14->__shared_owners_;
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      v17 = v109;
      if (v109)
      {
        v18 = (unint64_t *)&v109->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      v20 = (std::__shared_weak_count *)*((_QWORD *)&v107[0] + 1);
      if (*((_QWORD *)&v107[0] + 1))
      {
        v21 = (unint64_t *)(*((_QWORD *)&v107[0] + 1) + 8);
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      pthread_mutex_lock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
      v23 = xmmword_255323688;
      if (!(_QWORD)xmmword_255323688)
      {
        v107[0] = 0uLL;
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&xmmword_255323688, v107);
        v24 = (std::__shared_weak_count *)*((_QWORD *)&v107[0] + 1);
        if (*((_QWORD *)&v107[0] + 1))
        {
          v25 = (unint64_t *)(*((_QWORD *)&v107[0] + 1) + 8);
          do
            v26 = __ldaxr(v25);
          while (__stlxr(v26 - 1, v25));
          if (!v26)
          {
            ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
            std::__shared_weak_count::__release_weak(v24);
          }
        }
        v23 = xmmword_255323688;
      }
      v27 = *((_QWORD *)&xmmword_255323688 + 1);
      *a2 = v23;
      a2[1] = v27;
      if (v27)
      {
        v28 = (unint64_t *)(v27 + 8);
        do
          v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
      }
LABEL_41:
      pthread_mutex_unlock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
      return;
    }
  }
  else
  {
LABEL_15:
    if (v2)
      goto LABEL_16;
  }
  memset(v107, 0, sizeof(v107));
  v30 = NfRestoreSEEnumerate();
  if ((_DWORD)v30 == 1)
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v31 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v110);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v110);
      v32 = (std::__shared_weak_count *)*((_QWORD *)&v110 + 1);
      if (*((_QWORD *)&v110 + 1))
      {
        v33 = (unint64_t *)(*((_QWORD *)&v110 + 1) + 8);
        do
          v34 = __ldaxr(v33);
        while (__stlxr(v34 - 1, v33));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
      }
      v31 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v35 = (std::__shared_weak_count *)off_2553234C8;
    *(_QWORD *)&v112 = v31;
    *((_QWORD *)&v112 + 1) = off_2553234C8;
    if (off_2553234C8)
    {
      v36 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v37 = __ldxr(v36);
      while (__stxr(v37 + 1, v36));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v31, 0, 0, 1, "getSEInfo", (SEUpdaterUtil::SELogObj *)"Ignoring NFC load stack error\n");
    if (v35)
    {
      v38 = (unint64_t *)&v35->__shared_owners_;
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
    LODWORD(v107[0]) = 2;
  }
  else
  {
    v40 = v30;
    std::string::basic_string[abi:ne180100]<0>(&v110, "Failed to load NFC stack");
    SERestoreInfo::CallAndThrow<NfResult>(v40, (uint64_t)&v110);
    if (v111 < 0)
      operator delete((void *)v110);
  }
  if (!BYTE4(v107[0]))
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v68 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v110);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v110);
      v69 = (std::__shared_weak_count *)*((_QWORD *)&v110 + 1);
      if (*((_QWORD *)&v110 + 1))
      {
        v70 = (unint64_t *)(*((_QWORD *)&v110 + 1) + 8);
        do
          v71 = __ldaxr(v70);
        while (__stlxr(v71 - 1, v70));
        if (!v71)
        {
          ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
          std::__shared_weak_count::__release_weak(v69);
        }
      }
      v68 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v72 = (std::__shared_weak_count *)off_2553234C8;
    *(_QWORD *)&v112 = v68;
    *((_QWORD *)&v112 + 1) = off_2553234C8;
    if (off_2553234C8)
    {
      v73 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v74 = __ldxr(v73);
      while (__stxr(v74 + 1, v73));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v68, (SEUpdaterUtil::SELogObj *)2, 0, 1, "makeUpdateController", (SEUpdaterUtil::SELogObj *)"No personalizable SE found\n");
    if (v72)
    {
      v75 = (unint64_t *)&v72->__shared_owners_;
      do
        v76 = __ldaxr(v75);
      while (__stlxr(v76 - 1, v75));
      if (!v76)
      {
        ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
        std::__shared_weak_count::__release_weak(v72);
      }
    }
    _ZNSt3__115allocate_sharedB8ne180100IN9SEUpdater19NOPUpdateControllerENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((SEUpdater::UpdateControllerBase **)&v110);
    v77 = v110;
    v110 = 0uLL;
    pthread_mutex_lock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
    v78 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_255323688 + 1);
    xmmword_255323688 = v77;
    pthread_mutex_unlock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
    if (v78)
    {
      v79 = (unint64_t *)&v78->__shared_owners_;
      do
        v80 = __ldaxr(v79);
      while (__stlxr(v80 - 1, v79));
      if (!v80)
      {
        ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
        std::__shared_weak_count::__release_weak(v78);
      }
    }
    v81 = (std::__shared_weak_count *)*((_QWORD *)&v110 + 1);
    if (*((_QWORD *)&v110 + 1))
    {
      v82 = (unint64_t *)(*((_QWORD *)&v110 + 1) + 8);
      do
        v83 = __ldaxr(v82);
      while (__stlxr(v83 - 1, v82));
      if (!v83)
      {
        ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
        std::__shared_weak_count::__release_weak(v81);
      }
    }
    pthread_mutex_lock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
    v84 = xmmword_255323688;
    if (!(_QWORD)xmmword_255323688)
    {
      v110 = 0uLL;
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&xmmword_255323688, &v110);
      v85 = (std::__shared_weak_count *)*((_QWORD *)&v110 + 1);
      if (*((_QWORD *)&v110 + 1))
      {
        v86 = (unint64_t *)(*((_QWORD *)&v110 + 1) + 8);
        do
          v87 = __ldaxr(v86);
        while (__stlxr(v87 - 1, v86));
        if (!v87)
        {
          ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
          std::__shared_weak_count::__release_weak(v85);
        }
      }
      v84 = xmmword_255323688;
    }
    v88 = *((_QWORD *)&xmmword_255323688 + 1);
    *a2 = v84;
    a2[1] = v88;
    if (v88)
    {
      v89 = (unint64_t *)(v88 + 8);
      do
        v90 = __ldxr(v89);
      while (__stxr(v90 + 1, v89));
    }
    goto LABEL_41;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v41 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v110);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v110);
    v42 = (std::__shared_weak_count *)*((_QWORD *)&v110 + 1);
    if (*((_QWORD *)&v110 + 1))
    {
      v43 = (unint64_t *)(*((_QWORD *)&v110 + 1) + 8);
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
      }
    }
    v41 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v45 = (std::__shared_weak_count *)off_2553234C8;
  *(_QWORD *)&v112 = v41;
  *((_QWORD *)&v112 + 1) = off_2553234C8;
  if (off_2553234C8)
  {
    v46 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v47 = __ldxr(v46);
    while (__stxr(v47 + 1, v46));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v41, (SEUpdaterUtil::SELogObj *)2, 0, 1, "makeUpdateController", (SEUpdaterUtil::SELogObj *)"SE HW type %d multi-OS %d\n", LODWORD(v107[0]), BYTE5(v107[0]));
  if (v45)
  {
    v48 = (unint64_t *)&v45->__shared_owners_;
    do
      v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  v112 = 0uLL;
  if (LODWORD(v107[0]))
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v50 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v110);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v110);
      v51 = (std::__shared_weak_count *)*((_QWORD *)&v110 + 1);
      if (*((_QWORD *)&v110 + 1))
      {
        v52 = (unint64_t *)(*((_QWORD *)&v110 + 1) + 8);
        do
          v53 = __ldaxr(v52);
        while (__stlxr(v53 - 1, v52));
        if (!v53)
        {
          ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
          std::__shared_weak_count::__release_weak(v51);
        }
      }
      v50 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v54 = (std::__shared_weak_count *)off_2553234C8;
    if (off_2553234C8)
    {
      v55 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v56 = __ldxr(v55);
      while (__stxr(v56 + 1, v55));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog(v50, 0, 0, 1, "makeUpdateController", (SEUpdaterUtil::SELogObj *)"Unknown personalizable SE %d\n", LODWORD(v107[0]));
    if (v54)
    {
      v57 = (unint64_t *)&v54->__shared_owners_;
      do
        v58 = __ldaxr(v57);
      while (__stlxr(v58 - 1, v57));
      if (!v58)
      {
        ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
        std::__shared_weak_count::__release_weak(v54);
      }
    }
    _ZNSt3__115allocate_sharedB8ne180100IN9SEUpdater19NOPUpdateControllerENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((SEUpdater::UpdateControllerBase **)&v110);
    v59 = v110;
    v110 = 0uLL;
    v60 = (std::__shared_weak_count *)*((_QWORD *)&v112 + 1);
    v112 = v59;
    if (v60)
    {
      v61 = (unint64_t *)&v60->__shared_owners_;
      do
        v62 = __ldaxr(v61);
      while (__stlxr(v62 - 1, v61));
      if (!v62)
      {
        ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
        std::__shared_weak_count::__release_weak(v60);
      }
    }
    v63 = (std::__shared_weak_count *)*((_QWORD *)&v110 + 1);
    if (*((_QWORD *)&v110 + 1))
    {
      v64 = (unint64_t *)(*((_QWORD *)&v110 + 1) + 8);
      do
        v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
        std::__shared_weak_count::__release_weak(v63);
      }
    }
    v66 = (_QWORD *)*((_QWORD *)&v112 + 1);
    v67 = (_QWORD *)v112;
    if (!*((_QWORD *)&v112 + 1))
      goto LABEL_145;
  }
  else
  {
    v91 = BYTE5(v107[0]);
    v66 = operator new(0x100uLL);
    v66[1] = 0;
    v66[2] = 0;
    *v66 = &off_24E0C1E10;
    v67 = v66 + 3;
    SEUpdater::P73BaseUpdateController::P73BaseUpdateController((SEUpdater::P73BaseUpdateController *)(v66 + 3), v91 != 0);
    *(_QWORD *)&v112 = v66 + 3;
    *((_QWORD *)&v112 + 1) = v66;
  }
  v92 = v66 + 1;
  do
    v93 = __ldxr(v92);
  while (__stxr(v93 + 1, v92));
LABEL_145:
  pthread_mutex_lock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
  v94 = (std::__shared_weak_count *)*((_QWORD *)&xmmword_255323688 + 1);
  *(_QWORD *)&xmmword_255323688 = v67;
  *((_QWORD *)&xmmword_255323688 + 1) = v66;
  pthread_mutex_unlock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
  if (v94)
  {
    v95 = (unint64_t *)&v94->__shared_owners_;
    do
      v96 = __ldaxr(v95);
    while (__stlxr(v96 - 1, v95));
    if (!v96)
    {
      ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
      std::__shared_weak_count::__release_weak(v94);
    }
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
  v97 = xmmword_255323688;
  if (!(_QWORD)xmmword_255323688)
  {
    v110 = 0uLL;
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&xmmword_255323688, &v110);
    v98 = (std::__shared_weak_count *)*((_QWORD *)&v110 + 1);
    if (*((_QWORD *)&v110 + 1))
    {
      v99 = (unint64_t *)(*((_QWORD *)&v110 + 1) + 8);
      do
        v100 = __ldaxr(v99);
      while (__stlxr(v100 - 1, v99));
      if (!v100)
      {
        ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
        std::__shared_weak_count::__release_weak(v98);
      }
    }
    v97 = xmmword_255323688;
  }
  v101 = *((_QWORD *)&xmmword_255323688 + 1);
  *a2 = v97;
  a2[1] = v101;
  if (v101)
  {
    v102 = (unint64_t *)(v101 + 8);
    do
      v103 = __ldxr(v102);
    while (__stxr(v103 + 1, v102));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdater::UpdateControllerBase,SEUpdater::UpdateControllerBase,ctu::PthreadMutexGuardPolicy<SEUpdater::UpdateControllerBase>>::sInstance);
  v104 = (std::__shared_weak_count *)*((_QWORD *)&v112 + 1);
  if (*((_QWORD *)&v112 + 1))
  {
    v105 = (unint64_t *)(*((_QWORD *)&v112 + 1) + 8);
    do
      v106 = __ldaxr(v105);
    while (__stlxr(v106 - 1, v105));
    if (!v106)
    {
      ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
      std::__shared_weak_count::__release_weak(v104);
    }
  }
}

void sub_21CCD1764(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<SEUpdater::PreflightUpdateController>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1D28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SEUpdater::PreflightUpdateController>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1D28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SEUpdater::PreflightUpdateController>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

SEUpdater::UpdateControllerBase *_ZNSt3__115allocate_sharedB8ne180100IN9SEUpdater19NOPUpdateControllerENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(SEUpdater::UpdateControllerBase **a1)
{
  _QWORD *v2;
  SEUpdater::UpdateControllerBase *result;

  v2 = operator new(0x98uLL);
  v2[1] = 0;
  v2[2] = 0;
  *v2 = &off_24E0C1D78;
  result = SEUpdater::UpdateControllerBase::UpdateControllerBase((SEUpdater::UpdateControllerBase *)(v2 + 3));
  v2[3] = &off_24E0C1DC8;
  *((_BYTE *)v2 + 104) = 1;
  *a1 = result;
  a1[1] = (SEUpdater::UpdateControllerBase *)v2;
  return result;
}

void sub_21CCD1980(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<SEUpdater::NOPUpdateController>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1D78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SEUpdater::NOPUpdateController>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1D78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SEUpdater::NOPUpdateController>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void SEUpdater::NOPUpdateController::~NOPUpdateController(const void **this)
{
  SEUpdater::UpdateControllerBase::~UpdateControllerBase(this);
  JUMPOUT(0x22078A808);
}

uint64_t SEUpdater::NOPUpdateController::doCommand(SEUpdater::NOPUpdateController *this, const __CFString *a2, const __CFDictionary **a3)
{
  return 1;
}

void std::__shared_ptr_emplace<SEUpdater::P73BaseUpdateController>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1E10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SEUpdater::P73BaseUpdateController>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24E0C1E10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x22078A808);
}

uint64_t std::__shared_ptr_emplace<SEUpdater::P73BaseUpdateController>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t SEUpdaterUtil::RegisterDebugSignals(SEUpdaterUtil *this)
{
  uint64_t v1;
  uint64_t result;
  sigaction v3;

  v1 = 0;
  v3.__sigaction_u.__sa_handler = (void (__cdecl *)(int))SEUpdaterUtil::_handleSignals;
  *(_QWORD *)&v3.sa_mask = 0;
  do
    result = sigaction(__const__ZN13SEUpdaterUtil20RegisterDebugSignalsEv_signals[v1++], &v3, 0);
  while (v1 != 6);
  return result;
}

void SEUpdaterUtil::_handleSignals(SEUpdaterUtil *this, int a2, __siginfo *a3, void *a4)
{
  FILE **v4;
  void *v5;
  int v6;

  v4 = (FILE **)MEMORY[0x24BDAC8D8];
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "caught signal %d\n", (_DWORD)this);
  v5 = operator new(0x400uLL);
  bzero(v5, 0x400uLL);
  v6 = backtrace((void **)v5, 128);
  backtrace_symbols_fd((void *const *)v5, v6, 2);
  operator delete(v5);
  fwrite("->pls attach debugger\n", 0x16uLL, 1uLL, *v4);
  __break(1u);
}

void sub_21CCD1B44(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void SEUpdaterUtil::parseArgs(uint64_t a1, uint64_t **a2)
{
  std::string *v2;
  std::string::size_type size;
  std::string *v4;
  std::locale::id *v5;
  std::string::size_type v6;
  uint64_t v7;
  const std::locale::facet *v8;
  int v9;
  std::string::size_type v10;
  std::string *v11;
  std::string *v12;
  std::string::size_type v13;
  std::string *v14;
  std::locale::id *v15;
  std::string *v16;
  uint64_t v17;
  const std::locale::facet *v18;
  std::string *v19;
  std::string::size_type v20;
  char v21;
  std::string *v22;
  std::string::size_type v23;
  BOOL v24;
  char *v25;
  char *v26;
  unint64_t v27;
  __int128 *v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  std::vector<std::string>::pointer end;
  __int128 v33;
  std::string *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  std::string *v38;
  std::string *v39;
  __int128 v40;
  __int128 v41;
  std::string *v42;
  uint64_t v43;
  size_t v44;
  void *v45;
  const void *p_src;
  size_t v47;
  __int128 *v48;
  const void *v49;
  size_t v50;
  uint64_t v51;
  int v52;
  std::string *v53;
  uint64_t v54;
  __int128 *v55;
  void **p_dst;
  size_t v57;
  std::string *p_v;
  __int128 *v59;
  std::__split_buffer<std::string>::pointer v60;
  void *v61;
  const void *first;
  size_t v63;
  std::locale::__imp *v64;
  const void *v65;
  size_t v66;
  void *v67;
  const void *locale;
  size_t v69;
  void *v70;
  const void *v71;
  size_t v72;
  __int128 *v73;
  const void *v74;
  _QWORD *v75;
  _QWORD *v76;
  size_t v77;
  void *v78;
  uint64_t v79;
  BOOL v80;
  std::string::value_type *v81;
  std::string::value_type *v82;
  unint64_t v83;
  std::string *v84;
  uint64_t v85;
  uint64_t v86;
  std::string::value_type v87;
  std::vector<std::string>::pointer v88;
  __int128 v89;
  std::string *v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  std::string *v94;
  std::string *v95;
  __int128 v96;
  __int128 v97;
  std::string *v98;
  void *v99;
  std::__shared_weak_count *v100;
  unint64_t *v101;
  unint64_t v102;
  std::__shared_weak_count *v103;
  unint64_t *v104;
  unint64_t v105;
  const char *v106;
  const char *v107;
  unint64_t *p_shared_owners;
  unint64_t v109;
  const std::string *v110;
  uint64_t *v111;
  void *v112;
  std::__shared_weak_count *v113;
  unint64_t *v114;
  unint64_t v115;
  unint64_t *v116;
  unint64_t v117;
  const char *v118;
  std::__shared_weak_count *v119;
  unint64_t *v120;
  unint64_t v121;
  uint64_t *v122;
  uint64_t v123;
  uint64_t v125;
  std::locale *v126;
  std::locale *v127;
  std::locale *v128;
  __int128 v129;
  std::string *v130;
  int v131;
  std::locale v132;
  __int128 v133;
  std::string *value;
  std::string v135;
  std::vector<std::string> v136;
  uint64_t v137;
  std::locale v138;
  int v139;
  __int128 v140;
  __int128 v141;
  char v142;
  uint64_t (**v143)();
  _QWORD *v144;
  std::locale v145;
  int v146;
  std::string *v147;
  std::string *v148;
  std::string *v149;
  char *v150;
  char v151;
  uint64_t v152;
  std::locale v153[9];
  std::vector<std::string> v154;
  std::locale v155;
  char v156;
  void *__src;
  size_t __n;
  void *v159;
  char v160;
  size_t v161;
  void *__dst;
  std::locale v163;
  size_t v164;
  int v165;
  void *v166;
  std::locale v167;
  size_t v168;
  int v169;
  std::locale v170;
  std::locale v171;
  size_t v172;
  int v173;
  void *v174;
  std::locale v175;
  size_t v176;
  int v177;
  __int128 v178;
  std::string *v179;
  int v180;
  void *v181;
  std::locale v182;
  size_t v183;
  int v184;
  void *__s2;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  unsigned __int8 v189;
  __int128 v190;
  size_t v191;
  int v192;
  char *v193;
  char *v194;
  uint64_t v195;
  uint64_t v196;
  unsigned __int8 v197;
  std::__split_buffer<std::string> __v;
  uint64_t v199;

  v199 = *MEMORY[0x24BDAC8D0];
  if (*(char *)(a1 + 23) < 0)
    std::string::__init_copy_ctor_external(&v135, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  else
    v135 = *(std::string *)a1;
  MEMORY[0x22078A730](&v170);
  LODWORD(v174) = 0x4000;
  std::locale::locale(&v175, &v170);
  LODWORD(v152) = (_DWORD)v174;
  std::locale::locale(v153, &v175);
  if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v2 = &v135;
  else
    v2 = (std::string *)v135.__r_.__value_.__r.__words[0];
  if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v135.__r_.__value_.__r.__words[2]);
  else
    size = v135.__r_.__value_.__l.__size_;
  v4 = (std::string *)((char *)v2 + size);
  LODWORD(v181) = v152;
  std::locale::locale(&v182, v153);
  LODWORD(v190) = (_DWORD)v181;
  std::locale::locale((std::locale *)&v190 + 1, &v182);
  v5 = (std::locale::id *)MEMORY[0x24BEDB350];
  while (size)
  {
    v6 = size;
    v7 = v2->__r_.__value_.__s.__data_[size - 1];
    v8 = std::locale::use_facet((const std::locale *)&v190 + 1, v5);
    if ((v7 & 0x80) != 0)
    {
      v2 = v4;
      break;
    }
    v4 = (std::string *)((char *)v4 - 1);
    v9 = *((_DWORD *)&v8[1].~facet + v7);
    size = v6 - 1;
    if ((v9 & v190) == 0)
    {
      v2 = (std::string *)((char *)v2 + v6);
      break;
    }
  }
  std::locale::~locale((std::locale *)&v190 + 1);
  v10 = HIBYTE(v135.__r_.__value_.__r.__words[2]);
  if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = &v135;
  else
    v11 = (std::string *)v135.__r_.__value_.__r.__words[0];
  if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v10 = v135.__r_.__value_.__l.__size_;
  std::string::erase(&v135, (char *)v2 - (char *)v11, (char *)v11 + v10 - (char *)v2);
  std::locale::~locale(&v182);
  std::locale::~locale(v153);
  LODWORD(v181) = (_DWORD)v174;
  std::locale::locale(&v182, &v175);
  if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &v135;
  else
    v12 = (std::string *)v135.__r_.__value_.__r.__words[0];
  if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v13 = HIBYTE(v135.__r_.__value_.__r.__words[2]);
  else
    v13 = v135.__r_.__value_.__l.__size_;
  LODWORD(v190) = (_DWORD)v181;
  std::locale::locale((std::locale *)&v190 + 1, &v182);
  if (v13)
  {
    v14 = (std::string *)((char *)v12 + v13);
    v15 = (std::locale::id *)MEMORY[0x24BEDB350];
    v16 = v12;
    while (1)
    {
      v17 = v16->__r_.__value_.__s.__data_[0];
      v18 = std::locale::use_facet((const std::locale *)&v190 + 1, v15);
      if ((v17 & 0x80) != 0 || (*((_DWORD *)&v18[1].~facet + v17) & v190) == 0)
        break;
      v16 = (std::string *)((char *)v16 + 1);
      if (!--v13)
      {
        v16 = v14;
        break;
      }
    }
  }
  else
  {
    v16 = v12;
  }
  v19 = &v135;
  if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v19 = (std::string *)v135.__r_.__value_.__r.__words[0];
  std::string::erase(&v135, (char *)v12 - (char *)v19, (char *)v16 - (char *)v12);
  std::locale::~locale((std::locale *)&v190 + 1);
  std::locale::~locale(&v182);
  std::locale::~locale(&v175);
  std::locale::~locale(&v170);
  v20 = HIBYTE(v135.__r_.__value_.__r.__words[2]);
  v21 = HIBYTE(v135.__r_.__value_.__r.__words[2]);
  if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v20 = v135.__r_.__value_.__l.__size_;
  if (v20)
  {
    v133 = 0uLL;
    value = 0;
    MEMORY[0x22078A730](&v155);
    v131 = 0x4000;
    std::locale::locale(&v132, &v155);
    LODWORD(v129) = 0x4000;
    std::locale::locale((std::locale *)&v129 + 1, &v132);
    LODWORD(v190) = 0x4000;
    std::locale::locale((std::locale *)&v190 + 1, (const std::locale *)&v129 + 1);
    LODWORD(v136.__begin_) = v190;
    std::locale::locale((std::locale *)&v136.__end_, (const std::locale *)&v190 + 1);
    LODWORD(v136.__end_cap_.__value_) = 0;
    std::locale::~locale((std::locale *)&v190 + 1);
    if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v22 = &v135;
    else
      v22 = (std::string *)v135.__r_.__value_.__r.__words[0];
    if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v23 = HIBYTE(v135.__r_.__value_.__r.__words[2]);
    else
      v23 = v135.__r_.__value_.__l.__size_;
    LODWORD(__dst) = v136.__begin_;
    std::locale::locale(&v163, (const std::locale *)&v136.__end_);
    LODWORD(v164) = v136.__end_cap_.__value_;
    LODWORD(v137) = (_DWORD)__dst;
    std::locale::locale(&v138, &v163);
    v139 = v164;
    LODWORD(v166) = v137;
    std::locale::locale(&v167, &v138);
    LODWORD(v168) = v139;
    v143 = 0;
    LODWORD(v170.__locale_) = (_DWORD)v166;
    std::locale::locale(&v171, &v167);
    LODWORD(v172) = v168;
    LODWORD(v174) = v170.__locale_;
    std::locale::locale(&v175, &v171);
    LODWORD(v176) = v172;
    LODWORD(v181) = (_DWORD)v174;
    std::locale::locale(&v182, &v175);
    LODWORD(v183) = v176;
    LODWORD(v190) = (_DWORD)v181;
    std::locale::locale((std::locale *)&v190 + 1, &v182);
    LODWORD(v191) = v183;
    LODWORD(v144) = v190;
    std::locale::locale(&v145, (const std::locale *)&v190 + 1);
    v146 = v191;
    std::locale::~locale((std::locale *)&v190 + 1);
    std::locale::~locale(&v182);
    std::locale::~locale(&v175);
    v143 = &boost::function2<boost::iterator_range<std::__wrap_iter<char *>>,std::__wrap_iter<char *>,std::__wrap_iter<char *>>::assign_to<boost::algorithm::detail::token_finderF<boost::algorithm::detail::is_classifiedF>>(boost::algorithm::detail::token_finderF<boost::algorithm::detail::is_classifiedF>)::stored_vtable;
    std::locale::~locale(&v171);
    std::locale::~locale(&v167);
    std::locale::~locale(&v138);
    v147 = v22;
    v148 = v22;
    v149 = v22;
    v150 = (char *)v22 + v23;
    v151 = 0;
    if (v23)
      boost::algorithm::split_iterator<std::__wrap_iter<char *>>::increment((uint64_t)&v143);
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v152, (uint64_t *)&v143);
    boost::function2<boost::iterator_range<std::__wrap_iter<char *>>,std::__wrap_iter<char *>,std::__wrap_iter<char *>>::~function2((uint64_t *)&v143);
    std::locale::~locale(&v163);
    v137 = 0;
    v140 = 0u;
    v141 = 0u;
    v142 = 1;
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v174, &v137);
    boost::function2<boost::iterator_range<std::__wrap_iter<char *>>,std::__wrap_iter<char *>,std::__wrap_iter<char *>>::~function2(&v137);
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v170, &v152);
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v166, (uint64_t *)&v174);
    memset(&v154, 0, sizeof(v154));
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v190, (uint64_t *)&v170);
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v181, (uint64_t *)&v166);
    v159 = &v154;
    v160 = 0;
    while ((_QWORD)v190)
    {
      if (!v181)
      {
        if (v197)
          goto LABEL_85;
        goto LABEL_59;
      }
      if (v189 | v197)
      {
        if ((v197 != 0) == (v189 != 0))
          goto LABEL_85;
        goto LABEL_59;
      }
      v25 = v193;
      v26 = v194;
      v27 = v194 - v193;
      if (v194 - v193 == v186 - (_QWORD)__s2 && !memcmp(v193, __s2, v194 - v193) && v195 == v187 && v196 == v188)
        goto LABEL_85;
LABEL_60:
      if (v27 > 0x7FFFFFFFFFFFFFF7)
        std::string::__throw_length_error[abi:ne180100]();
      if (v27 > 0x16)
      {
        v29 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v27 | 7) != 0x17)
          v29 = v27 | 7;
        v30 = v29 + 1;
        v28 = (__int128 *)operator new(v29 + 1);
        v179 = (std::string *)(v30 | 0x8000000000000000);
        *(_QWORD *)&v178 = v28;
        *((_QWORD *)&v178 + 1) = v27;
      }
      else
      {
        HIBYTE(v179) = v27;
        v28 = &v178;
      }
      while (v25 != v26)
      {
        v31 = *v25++;
        *(_BYTE *)v28 = v31;
        v28 = (__int128 *)((char *)v28 + 1);
      }
      *(_BYTE *)v28 = 0;
      end = v154.__end_;
      if (v154.__end_ >= v154.__end_cap_.__value_)
      {
        v35 = 0xAAAAAAAAAAAAAAABLL * (((char *)v154.__end_ - (char *)v154.__begin_) >> 3);
        v36 = v35 + 1;
        if (v35 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<std::string>::__throw_length_error[abi:ne180100]();
        if (0x5555555555555556 * (((char *)v154.__end_cap_.__value_ - (char *)v154.__begin_) >> 3) > v36)
          v36 = 0x5555555555555556 * (((char *)v154.__end_cap_.__value_ - (char *)v154.__begin_) >> 3);
        if (0xAAAAAAAAAAAAAAABLL * (((char *)v154.__end_cap_.__value_ - (char *)v154.__begin_) >> 3) >= 0x555555555555555)
          v37 = 0xAAAAAAAAAAAAAAALL;
        else
          v37 = v36;
        __v.__end_cap_.__value_ = (std::allocator<std::string> *)&v154.__end_cap_;
        if (v37)
          v38 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&v154.__end_cap_, v37);
        else
          v38 = 0;
        v39 = v38 + v35;
        __v.__first_ = v38;
        __v.__begin_ = v39;
        __v.__end_cap_.__value_ = &v38[v37];
        v40 = v178;
        v39->__r_.__value_.__r.__words[2] = (std::string::size_type)v179;
        *(_OWORD *)&v39->__r_.__value_.__l.__data_ = v40;
        v179 = 0;
        v178 = 0uLL;
        __v.__end_ = v39 + 1;
        std::vector<std::string>::__swap_out_circular_buffer(&v154, &__v);
        v34 = v154.__end_;
        std::__split_buffer<std::string>::~__split_buffer(&__v);
      }
      else
      {
        v33 = v178;
        v154.__end_->__r_.__value_.__r.__words[2] = (std::string::size_type)v179;
        *(_OWORD *)&end->__r_.__value_.__l.__data_ = v33;
        v34 = end + 1;
      }
      v154.__end_ = v34;
      boost::algorithm::split_iterator<std::__wrap_iter<char *>>::increment((uint64_t)&v190);
    }
    if (v181)
      v24 = v189 == 0;
    else
      v24 = 0;
    if (v24)
    {
LABEL_59:
      v25 = v193;
      v26 = v194;
      v27 = v194 - v193;
      goto LABEL_60;
    }
LABEL_85:
    boost::function2<boost::iterator_range<std::__wrap_iter<char *>>,std::__wrap_iter<char *>,std::__wrap_iter<char *>>::~function2((uint64_t *)&v181);
    boost::function2<boost::iterator_range<std::__wrap_iter<char *>>,std::__wrap_iter<char *>,std::__wrap_iter<char *>>::~function2((uint64_t *)&v190);
    boost::function2<boost::iterator_range<std::__wrap_iter<char *>>,std::__wrap_iter<char *>,std::__wrap_iter<char *>>::~function2((uint64_t *)&v166);
    boost::function2<boost::iterator_range<std::__wrap_iter<char *>>,std::__wrap_iter<char *>,std::__wrap_iter<char *>>::~function2((uint64_t *)&v170);
    v41 = v133;
    v133 = *(_OWORD *)&v154.__begin_;
    *(_OWORD *)&v154.__begin_ = v41;
    v42 = value;
    value = v154.__end_cap_.__value_;
    v154.__end_cap_.__value_ = v42;
    *(_QWORD *)&v190 = &v154;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v190);
    boost::function2<boost::iterator_range<std::__wrap_iter<char *>>,std::__wrap_iter<char *>,std::__wrap_iter<char *>>::~function2((uint64_t *)&v174);
    boost::function2<boost::iterator_range<std::__wrap_iter<char *>>,std::__wrap_iter<char *>,std::__wrap_iter<char *>>::~function2(&v152);
    std::locale::~locale((std::locale *)&v136.__end_);
    std::locale::~locale((std::locale *)&v129 + 1);
    std::locale::~locale(&v132);
    std::locale::~locale(&v155);
    v123 = *((_QWORD *)&v133 + 1);
    v43 = v133;
    if ((_QWORD)v133 == *((_QWORD *)&v133 + 1))
      goto LABEL_234;
LABEL_86:
    v129 = 0uLL;
    v130 = 0;
    __n = 1;
    __src = (void *)61;
    std::__sort<std::__less<char,char> &,char *>();
    v44 = __n;
    v161 = __n;
    v159 = 0;
    if (__n >= 0x11)
    {
      v45 = (void *)operator new[]();
      v159 = v45;
      p_src = __src;
    }
    else
    {
      v45 = &v159;
      p_src = &__src;
    }
    memcpy(v45, p_src, v44);
    v47 = v161;
    v191 = v161;
    *(_QWORD *)&v190 = 0;
    v128 = (std::locale *)v161;
    if (v161 >= 0x11)
    {
      v48 = (__int128 *)operator new[]();
      *(_QWORD *)&v190 = v48;
      v49 = v159;
      v47 = (size_t)v128;
    }
    else
    {
      v48 = &v190;
      v49 = &v159;
    }
    memcpy(v48, v49, v47);
    v50 = v191;
    v164 = v191;
    __dst = 0;
    if (v191 > 0x10)
    {
      __dst = (void *)operator new[]();
      v51 = v190;
      memcpy(__dst, (const void *)v190, v50);
      v165 = 1;
      if (v51)
        MEMORY[0x22078A7F0](v51, 0x1000C8077774924);
    }
    else
    {
      memcpy(&__dst, &v190, v191);
      v165 = 1;
      v50 = v164;
    }
    v52 = *(char *)(v43 + 23);
    if (v52 >= 0)
      v53 = (std::string *)v43;
    else
      v53 = *(std::string **)v43;
    if (v52 >= 0)
      v54 = *(unsigned __int8 *)(v43 + 23);
    else
      v54 = *(_QWORD *)(v43 + 8);
    v179 = (std::string *)v50;
    *(_QWORD *)&v178 = 0;
    if (v50 >= 0x11)
    {
      v55 = (__int128 *)operator new[]();
      *(_QWORD *)&v178 = v55;
      p_dst = (void **)__dst;
    }
    else
    {
      v55 = &v178;
      p_dst = &__dst;
    }
    memcpy(v55, p_dst, v50);
    v180 = 1;
    v57 = (size_t)v179;
    __v.__end_ = v179;
    __v.__first_ = 0;
    if ((unint64_t)v179 >= 0x11)
    {
      p_v = (std::string *)operator new[]();
      __v.__first_ = p_v;
      v59 = (__int128 *)v178;
    }
    else
    {
      p_v = (std::string *)&__v;
      v59 = &v178;
    }
    memcpy(p_v, v59, v57);
    LODWORD(__v.__end_cap_.__value_) = 1;
    v60 = __v.__end_;
    v168 = (size_t)__v.__end_;
    v166 = 0;
    v127 = (std::locale *)v57;
    if (__v.__end_ >= (std::__split_buffer<std::string>::pointer)0x11)
    {
      v61 = (void *)operator new[]();
      v166 = v61;
      first = __v.__first_;
    }
    else
    {
      v61 = &v166;
      first = &__v;
    }
    v126 = (std::locale *)v60;
    memcpy(v61, first, (size_t)v60);
    v169 = 1;
    v143 = 0;
    v63 = v168;
    v172 = v168;
    v170.__locale_ = 0;
    if (v168 >= 0x11)
    {
      v64 = (std::locale::__imp *)operator new[]();
      v170.__locale_ = v64;
      v65 = v166;
    }
    else
    {
      v64 = (std::locale::__imp *)&v170;
      v65 = &v166;
    }
    memcpy(v64, v65, v63);
    v173 = 1;
    v66 = v172;
    v176 = v172;
    v174 = 0;
    if (v172 >= 0x11)
    {
      v67 = (void *)operator new[]();
      v174 = v67;
      locale = v170.__locale_;
    }
    else
    {
      v67 = &v174;
      locale = &v170;
    }
    memcpy(v67, locale, v66);
    v177 = 1;
    v69 = v176;
    v183 = v176;
    v181 = 0;
    if (v176 >= 0x11)
    {
      v70 = (void *)operator new[]();
      v181 = v70;
      v71 = v174;
    }
    else
    {
      v70 = &v181;
      v71 = &v174;
    }
    memcpy(v70, v71, v69);
    v184 = 1;
    v72 = v183;
    v191 = v183;
    *(_QWORD *)&v190 = 0;
    if (v183 >= 0x11)
    {
      v73 = (__int128 *)operator new[]();
      *(_QWORD *)&v190 = v73;
      v74 = v181;
    }
    else
    {
      v73 = &v190;
      v74 = &v181;
    }
    memcpy(v73, v74, v72);
    v192 = 1;
    v75 = (_QWORD *)operator new();
    v76 = v75;
    v77 = v191;
    v75[2] = v191;
    *v75 = 0;
    v125 = v43;
    if (v77 > 0x10)
    {
      v78 = (void *)operator new[]();
      *v76 = v78;
      v79 = v190;
      memcpy(v78, (const void *)v190, v76[2]);
      *((_DWORD *)v76 + 6) = 1;
      v144 = v76;
      if (v79)
        MEMORY[0x22078A7F0](v79, 0x1000C8077774924);
    }
    else
    {
      memcpy(v75, &v190, v77);
      *((_DWORD *)v76 + 6) = 1;
      v144 = v76;
    }
    if (v72 >= 0x11 && v181)
      MEMORY[0x22078A7F0](v181, 0x1000C8077774924);
    if (v69 >= 0x11 && v174)
      MEMORY[0x22078A7F0](v174, 0x1000C8077774924);
    v143 = boost::function2<boost::iterator_range<std::__wrap_iter<char const*>>,std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>::assign_to<boost::algorithm::detail::token_finderF<boost::algorithm::detail::is_any_ofF<char>>>(boost::algorithm::detail::token_finderF<boost::algorithm::detail::is_any_ofF<char>>)::stored_vtable;
    if (v66 >= 0x11 && v170.__locale_)
      MEMORY[0x22078A7F0](v170.__locale_, 0x1000C8077774924);
    if (v63 >= 0x11 && v166)
      MEMORY[0x22078A7F0](v166, 0x1000C8077774924);
    if ((unint64_t)v126 >= 0x11 && __v.__first_)
      MEMORY[0x22078A7F0](__v.__first_, 0x1000C8077774924);
    v147 = v53;
    v148 = v53;
    v149 = v53;
    v150 = (char *)v53 + v54;
    v151 = 0;
    if (v54)
      boost::algorithm::split_iterator<std::__wrap_iter<char *>>::increment((uint64_t)&v143);
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v152, (uint64_t *)&v143);
    boost::function2<boost::iterator_range<std::__wrap_iter<char const*>>,std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>::~function2((uint64_t *)&v143);
    if ((unint64_t)v127 >= 0x11 && (_QWORD)v178)
      MEMORY[0x22078A7F0](v178, 0x1000C8077774924);
    v137 = 0;
    v140 = 0u;
    v141 = 0u;
    v142 = 1;
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v174, &v137);
    boost::function2<boost::iterator_range<std::__wrap_iter<char const*>>,std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>::~function2(&v137);
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v170, &v152);
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v166, (uint64_t *)&v174);
    memset(&v136, 0, sizeof(v136));
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v190, (uint64_t *)&v170);
    boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator((uint64_t)&v181, (uint64_t *)&v166);
    v155.__locale_ = (std::locale::__imp *)&v136;
    v156 = 0;
    while (1)
    {
      if (!(_QWORD)v190)
      {
        if (v181)
          v80 = v189 == 0;
        else
          v80 = 0;
        if (!v80)
        {
LABEL_185:
          boost::function2<boost::iterator_range<std::__wrap_iter<char const*>>,std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>::~function2((uint64_t *)&v181);
          boost::function2<boost::iterator_range<std::__wrap_iter<char const*>>,std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>::~function2((uint64_t *)&v190);
          boost::function2<boost::iterator_range<std::__wrap_iter<char const*>>,std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>::~function2((uint64_t *)&v166);
          boost::function2<boost::iterator_range<std::__wrap_iter<char const*>>,std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>::~function2((uint64_t *)&v170);
          v97 = v129;
          v129 = *(_OWORD *)&v136.__begin_;
          *(_OWORD *)&v136.__begin_ = v97;
          v98 = v130;
          v130 = v136.__end_cap_.__value_;
          v136.__end_cap_.__value_ = v98;
          *(_QWORD *)&v190 = &v136;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v190);
          boost::function2<boost::iterator_range<std::__wrap_iter<char const*>>,std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>::~function2((uint64_t *)&v174);
          boost::function2<boost::iterator_range<std::__wrap_iter<char const*>>,std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>::~function2(&v152);
          if (v164 >= 0x11 && __dst)
            MEMORY[0x22078A7F0](__dst, 0x1000C8077774924);
          if ((unint64_t)v128 >= 0x11 && v159)
            MEMORY[0x22078A7F0](v159, 0x1000C8077774924);
          if (__n >= 0x11 && __src)
            MEMORY[0x22078A7F0](__src, 0x1000C8077774924);
          if (*((_QWORD *)&v129 + 1) - (_QWORD)v129 == 48)
          {
            pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v99 = off_2553234C0;
            if (!off_2553234C0)
            {
              SEUpdaterUtil::SELogObj::create_default_global(&v190);
              std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v190);
              v100 = (std::__shared_weak_count *)*((_QWORD *)&v190 + 1);
              if (*((_QWORD *)&v190 + 1))
              {
                v101 = (unint64_t *)(*((_QWORD *)&v190 + 1) + 8);
                do
                  v102 = __ldaxr(v101);
                while (__stlxr(v102 - 1, v101));
                if (!v102)
                {
                  ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
                  std::__shared_weak_count::__release_weak(v100);
                }
              }
              v99 = off_2553234C0;
            }
            v103 = (std::__shared_weak_count *)off_2553234C8;
            v181 = v99;
            v182.__locale_ = (std::locale::__imp *)off_2553234C8;
            if (off_2553234C8)
            {
              v104 = (unint64_t *)((char *)off_2553234C8 + 8);
              do
                v105 = __ldxr(v104);
              while (__stxr(v105 + 1, v104));
            }
            pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v106 = (const char *)v129;
            if (*(char *)(v129 + 23) < 0)
              v106 = *(const char **)v129;
            v107 = (const char *)(v129 + 24);
            if (*(char *)(v129 + 47) < 0)
              v107 = *(const char **)v107;
            SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v99, (SEUpdaterUtil::SELogObj *)2, 0, 1, "parseArgs", (SEUpdaterUtil::SELogObj *)"Setting debugArgs (kv): %s=%s\n", v106, v107);
            if (v103)
            {
              p_shared_owners = (unint64_t *)&v103->__shared_owners_;
              do
                v109 = __ldaxr(p_shared_owners);
              while (__stlxr(v109 - 1, p_shared_owners));
              if (!v109)
              {
                ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
                std::__shared_weak_count::__release_weak(v103);
              }
            }
            v110 = (const std::string *)v129;
            *(_QWORD *)&v190 = v129;
            v111 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a2, (const void **)v129, (__int128 **)&v190);
            std::string::operator=((std::string *)(v111 + 7), v110 + 1);
          }
          else
          {
            pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v112 = off_2553234C0;
            if (!off_2553234C0)
            {
              SEUpdaterUtil::SELogObj::create_default_global(&v190);
              std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v190);
              v113 = (std::__shared_weak_count *)*((_QWORD *)&v190 + 1);
              if (*((_QWORD *)&v190 + 1))
              {
                v114 = (unint64_t *)(*((_QWORD *)&v190 + 1) + 8);
                do
                  v115 = __ldaxr(v114);
                while (__stlxr(v115 - 1, v114));
                if (!v115)
                {
                  ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
                  std::__shared_weak_count::__release_weak(v113);
                }
              }
              v112 = off_2553234C0;
            }
            v181 = v112;
            v182.__locale_ = (std::locale::__imp *)off_2553234C8;
            if (off_2553234C8)
            {
              v116 = (unint64_t *)((char *)off_2553234C8 + 8);
              do
                v117 = __ldxr(v116);
              while (__stxr(v117 + 1, v116));
            }
            pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
            v118 = (const char *)v125;
            if (*(char *)(v125 + 23) < 0)
              v118 = *(const char **)v125;
            SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v112, (SEUpdaterUtil::SELogObj *)2, 0, 1, "parseArgs", (SEUpdaterUtil::SELogObj *)"Setting debugArgs (empty): %s\n", v118);
            v119 = (std::__shared_weak_count *)v182.__locale_;
            if (v182.__locale_)
            {
              v120 = (unint64_t *)((char *)v182.__locale_ + 8);
              do
                v121 = __ldaxr(v120);
              while (__stlxr(v121 - 1, v120));
              if (!v121)
              {
                ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
                std::__shared_weak_count::__release_weak(v119);
              }
            }
            *(_QWORD *)&v190 = v125;
            v122 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a2, (const void **)v125, (__int128 **)&v190);
            MEMORY[0x22078A55C](v122 + 7, &unk_21CCDB9F7);
          }
          *(_QWORD *)&v190 = &v129;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v190);
          v43 = v125 + 24;
          if (v125 + 24 == v123)
          {
LABEL_234:
            *(_QWORD *)&v190 = &v133;
            std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v190);
            v21 = HIBYTE(v135.__r_.__value_.__r.__words[2]);
            goto LABEL_235;
          }
          goto LABEL_86;
        }
        goto LABEL_159;
      }
      if (!v181)
        break;
      if (v189 | v197)
      {
        if ((v197 != 0) == (v189 != 0))
          goto LABEL_185;
LABEL_159:
        v81 = v193;
        v82 = v194;
        v83 = v194 - v193;
        goto LABEL_160;
      }
      v81 = v193;
      v82 = v194;
      v83 = v194 - v193;
      if (v194 - v193 == v186 - (_QWORD)__s2 && !memcmp(v193, __s2, v194 - v193) && v195 == v187 && v196 == v188)
        goto LABEL_185;
LABEL_160:
      if (v83 > 0x7FFFFFFFFFFFFFF7)
        std::string::__throw_length_error[abi:ne180100]();
      if (v83 > 0x16)
      {
        v85 = (v83 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v83 | 7) != 0x17)
          v85 = v83 | 7;
        v86 = v85 + 1;
        v84 = (std::string *)operator new(v85 + 1);
        v154.__end_ = (std::vector<std::string>::pointer)v83;
        v154.__end_cap_.__value_ = (std::string *)(v86 | 0x8000000000000000);
        v154.__begin_ = v84;
      }
      else
      {
        HIBYTE(v154.__end_cap_.__value_) = v83;
        v84 = (std::string *)&v154;
      }
      while (v81 != v82)
      {
        v87 = *v81++;
        v84->__r_.__value_.__s.__data_[0] = v87;
        v84 = (std::string *)((char *)v84 + 1);
      }
      v84->__r_.__value_.__s.__data_[0] = 0;
      v88 = v136.__end_;
      if (v136.__end_ >= v136.__end_cap_.__value_)
      {
        v91 = 0xAAAAAAAAAAAAAAABLL * (((char *)v136.__end_ - (char *)v136.__begin_) >> 3);
        v92 = v91 + 1;
        if (v91 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<std::string>::__throw_length_error[abi:ne180100]();
        if (0x5555555555555556 * (((char *)v136.__end_cap_.__value_ - (char *)v136.__begin_) >> 3) > v92)
          v92 = 0x5555555555555556 * (((char *)v136.__end_cap_.__value_ - (char *)v136.__begin_) >> 3);
        if (0xAAAAAAAAAAAAAAABLL * (((char *)v136.__end_cap_.__value_ - (char *)v136.__begin_) >> 3) >= 0x555555555555555)
          v93 = 0xAAAAAAAAAAAAAAALL;
        else
          v93 = v92;
        __v.__end_cap_.__value_ = (std::allocator<std::string> *)&v136.__end_cap_;
        if (v93)
          v94 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&v136.__end_cap_, v93);
        else
          v94 = 0;
        v95 = v94 + v91;
        __v.__first_ = v94;
        __v.__begin_ = v95;
        __v.__end_cap_.__value_ = &v94[v93];
        v96 = *(_OWORD *)&v154.__begin_;
        v95->__r_.__value_.__r.__words[2] = (std::string::size_type)v154.__end_cap_.__value_;
        *(_OWORD *)&v95->__r_.__value_.__l.__data_ = v96;
        memset(&v154, 0, sizeof(v154));
        __v.__end_ = v95 + 1;
        std::vector<std::string>::__swap_out_circular_buffer(&v136, &__v);
        v90 = v136.__end_;
        std::__split_buffer<std::string>::~__split_buffer(&__v);
      }
      else
      {
        v89 = *(_OWORD *)&v154.__begin_;
        v136.__end_->__r_.__value_.__r.__words[2] = (std::string::size_type)v154.__end_cap_.__value_;
        *(_OWORD *)&v88->__r_.__value_.__l.__data_ = v89;
        v90 = v88 + 1;
      }
      v136.__end_ = v90;
      boost::algorithm::split_iterator<std::__wrap_iter<char *>>::increment((uint64_t)&v190);
    }
    if (v197)
      goto LABEL_185;
    goto LABEL_159;
  }
LABEL_235:
  if (v21 < 0)
    operator delete(v135.__r_.__value_.__l.__data_);
}

void sub_21CCD2F0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void SEUpdaterUtil::cbPrintLog(SEUpdaterUtil *this, void *a2, SEUpdaterUtil::SELogObj *a3, const char *a4, ...)
{
  unsigned int v5;
  SEUpdaterUtil::SELogObj *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  __int128 v16;
  va_list va;

  va_start(va, a4);
  v5 = a2;
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v6 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v16);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v16);
    v7 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
    if (*((_QWORD *)&v16 + 1))
    {
      v8 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    v6 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v10 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v11 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  if (v5 > 6)
    v13 = 3;
  else
    v13 = dword_21CCDB92C[v5];
  SEUpdaterUtil::SELogObj::printLogv(v6, (SEUpdaterUtil::SELogObj *)v13, 0, 1, 0, a3, va);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_21CCD3514(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t SEUpdaterUtil::assertSW(uint64_t this, const SERestoreInfo::RApdu *a2, const char *a3)
{
  uint64_t v3;
  uint64_t v4;
  void *exception;
  void *v6;
  __int128 v7;

  v3 = *(_QWORD *)(*(_QWORD *)(this + 8) + 8);
  if ((unint64_t)(v3 - **(_QWORD **)(this + 8)) < 2)
  {
    v4 = 43947;
LABEL_5:
    SEUpdaterUtil::SELogToStr(0, (SEUpdaterUtil::SELogObj *)"%s : 0x%x", (uint64_t)"assertSW", &v7, a2, v4);
    exception = __cxa_allocate_exception(0x48uLL);
    v6 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, &v7, 8, CFSTR("SEUpdaterErrorDomain"));
  }
  v4 = *(unsigned __int8 *)(v3 - 1) | (*(unsigned __int8 *)(v3 - 2) << 8);
  if ((_DWORD)v4 != 36864)
    goto LABEL_5;
  return this;
}

void sub_21CCD35EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *SEUpdaterUtil::SELogToStr@<X0>(SEUpdaterUtil *this@<X0>, SEUpdaterUtil::SELogObj *a2@<X2>, uint64_t a3@<X1>, _QWORD *a4@<X8>, ...)
{
  va_list va;

  va_start(va, a4);
  return SEUpdaterUtil::SELogToStrv(this, a2, va, (char *)1, a3, a4);
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, __int128 **a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  __int128 *v8;
  _QWORD *v9;
  std::string *v10;
  __int128 v11;
  uint64_t *v12;
  _QWORD v14[2];
  char v15;
  uint64_t v16;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v16, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    v8 = *a3;
    v9 = operator new(0x50uLL);
    v14[0] = v9;
    v14[1] = a1 + 1;
    v15 = 0;
    v10 = (std::string *)(v9 + 4);
    if (*((char *)v8 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
      v12 = (uint64_t *)v14[0];
    }
    else
    {
      v11 = *v8;
      v9[6] = *((_QWORD *)v8 + 2);
      *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
      v12 = v9;
    }
    v9[7] = 0;
    v9[8] = 0;
    v9[9] = 0;
    v15 = 1;
    std::__tree<std::__value_type<unsigned long long,DERItem>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,DERItem>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,DERItem>>>::__insert_node_at(a1, v16, v7, v12);
    v6 = (uint64_t *)v14[0];
    v14[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)v14, 0);
  }
  return v6;
}

void sub_21CCD3708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)&a9, 0);
  _Unwind_Resume(a1);
}

uint64_t boost::algorithm::split_iterator<std::__wrap_iter<char *>>::split_iterator(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  __int128 v5;

  *(_QWORD *)a1 = 0;
  v4 = *a2;
  if (*a2)
  {
    *(_QWORD *)a1 = v4;
    if ((v4 & 1) != 0)
    {
      v5 = *(_OWORD *)(a2 + 1);
      *(_QWORD *)(a1 + 24) = a2[3];
      *(_OWORD *)(a1 + 8) = v5;
    }
    else
    {
      (*(void (**)(uint64_t *, uint64_t, _QWORD))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, a1 + 8, 0);
    }
  }
  *(_OWORD *)(a1 + 32) = *((_OWORD *)a2 + 2);
  *(_QWORD *)(a1 + 48) = a2[6];
  *(_QWORD *)(a1 + 56) = a2[7];
  *(_BYTE *)(a1 + 64) = *((_BYTE *)a2 + 64);
  return a1;
}

uint64_t boost::algorithm::split_iterator<std::__wrap_iter<char *>>::increment(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  BOOL v5;

  v2 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)a1)
  {
    result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))((*(_QWORD *)a1 & 0xFFFFFFFFFFFFFFFELL) + 8))(a1 + 8, *(_QWORD *)(a1 + 48), v2);
    v2 = *(_QWORD *)(a1 + 56);
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 56);
    result = v4;
  }
  v5 = result == v2 && v4 == v2;
  if (v5 && *(_QWORD *)(a1 + 40) == v2)
    *(_BYTE *)(a1 + 64) = 1;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 40) = result;
  *(_QWORD *)(a1 + 48) = v4;
  return result;
}

void boost::detail::function::functor_manager<boost::algorithm::detail::token_finderF<boost::algorithm::detail::is_classifiedF>>::manage(uint64_t a1, uint64_t a2, unsigned int a3)
{
  std::locale *v6;
  const char *v7;

  if (a3 == 4)
    goto LABEL_2;
  if (a3 > 1)
  {
    if (a3 != 3)
    {
      if (a3 != 2)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return;
      }
      v6 = (std::locale *)(a2 + 8);
LABEL_10:
      std::locale::~locale(v6);
      return;
    }
    v7 = (const char *)(*(_QWORD *)(*(_QWORD *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)(0x800000021CCDB8ACLL & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)(0x800000021CCDB8ACLL & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(_QWORD *)a2 = a1;
    }
    else
    {
      *(_QWORD *)a2 = 0;
    }
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)a1;
    std::locale::locale((std::locale *)(a2 + 8), (const std::locale *)(a1 + 8));
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
    if (a3 == 1)
    {
      v6 = (std::locale *)(a1 + 8);
      goto LABEL_10;
    }
  }
}

unsigned __int8 *boost::detail::function::function_obj_invoker2<boost::algorithm::detail::token_finderF<boost::algorithm::detail::is_classifiedF>,boost::iterator_range<std::__wrap_iter<char *>>,std::__wrap_iter<char *>,std::__wrap_iter<char *>>::invoke(std::locale *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  const std::locale *v6;
  std::locale::id *v7;
  uint64_t v8;
  const std::locale::facet *v9;
  std::locale::id *v11;
  char *v12;
  int v13;
  const std::locale::facet *v14;
  int locale;
  std::locale v16;

  v6 = a1 + 1;
  locale = (int)a1->__locale_;
  std::locale::locale(&v16, a1 + 1);
  if (a2 == a3)
  {
    std::locale::~locale(&v16);
    return a3;
  }
  v7 = (std::locale::id *)MEMORY[0x24BEDB350];
  while (1)
  {
    v8 = *a2;
    v9 = std::locale::use_facet(&v16, v7);
    if ((v8 & 0x80) == 0 && (*((_DWORD *)&v9[1].~facet + v8) & locale) != 0)
      break;
    if (++a2 == a3)
    {
      a2 = a3;
      break;
    }
  }
  std::locale::~locale(&v16);
  if (a2 == a3)
    return a3;
  if (!LODWORD(a1[2].__locale_))
  {
    v11 = (std::locale::id *)MEMORY[0x24BEDB350];
    v12 = (char *)a2;
    do
    {
      v13 = *v12;
      v14 = std::locale::use_facet(v6, v11);
      if (v13 < 0)
        break;
      if ((*((_DWORD *)&v14[1].~facet + v13) & (uint64_t)a1->__locale_) == 0)
        break;
      ++v12;
    }
    while (v12 != (char *)a3);
  }
  return a2;
}

void sub_21CCD3A28(_Unwind_Exception *a1)
{
  std::locale *v1;

  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

uint64_t *boost::function2<boost::iterator_range<std::__wrap_iter<char *>>,std::__wrap_iter<char *>,std::__wrap_iter<char *>>::~function2(uint64_t *a1)
{
  uint64_t v2;
  void (*v3)(uint64_t *, uint64_t *, uint64_t);

  v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3)
        v3(a1 + 1, a1 + 1, 2);
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t boost::detail::function::functor_manager<boost::algorithm::detail::token_finderF<boost::algorithm::detail::is_any_ofF<char>>>::manage(uint64_t result, _WORD *a2, int a3)
{
  _QWORD *v4;
  _DWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  size_t v8;
  const void *v9;
  _QWORD *v10;

  v4 = (_QWORD *)result;
  switch(a3)
  {
    case 0:
      v5 = *(_DWORD **)result;
      v6 = (_QWORD *)operator new();
      v7 = v6;
      v8 = *((_QWORD *)v5 + 2);
      v6[2] = v8;
      *v6 = 0;
      if (v8 >= 0x11)
      {
        v6 = (_QWORD *)operator new[]();
        *v7 = v6;
        v9 = *(const void **)v5;
        v8 = v7[2];
      }
      else
      {
        v9 = v5;
      }
      result = (uint64_t)memcpy(v6, v9, v8);
      *((_DWORD *)v7 + 6) = v5[6];
      *(_QWORD *)a2 = v7;
      break;
    case 1:
      *(_QWORD *)a2 = *(_QWORD *)result;
      *(_QWORD *)result = 0;
      break;
    case 2:
      v10 = *(_QWORD **)a2;
      if (*(_QWORD *)a2)
      {
        if (v10[2] >= 0x11uLL && *v10)
          MEMORY[0x22078A7F0](*v10, 0x1000C8077774924);
        result = MEMORY[0x22078A808](v10, 0x1012C405C87E9CELL);
      }
      goto LABEL_13;
    case 3:
      result = *(_QWORD *)(*(_QWORD *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x800000021CCDB8ECLL & 0x7FFFFFFFFFFFFFFFLL)
        || (result = strcmp((const char *)result, (const char *)(0x800000021CCDB8ECLL & 0x7FFFFFFFFFFFFFFFLL)),
            !(_DWORD)result))
      {
        *(_QWORD *)a2 = *v4;
      }
      else
      {
LABEL_13:
        *(_QWORD *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_21CCD3C00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x22078A808](v1, 0x1012C405C87E9CELL);
  _Unwind_Resume(a1);
}

char *boost::detail::function::function_obj_invoker2<boost::algorithm::detail::token_finderF<boost::algorithm::detail::is_any_ofF<char>>,boost::iterator_range<std::__wrap_iter<char const*>>,std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>::invoke(const void ***a1, char *a2, char *a3)
{
  const void **v5;
  size_t v6;
  _QWORD *v7;
  const void *v8;
  char *v9;
  _QWORD v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v5 = *a1;
  v6 = (size_t)(*a1)[2];
  v12 = v6;
  v11[0] = 0;
  if (v6 >= 0x11)
  {
    v7 = (_QWORD *)operator new[]();
    v11[0] = v7;
    v8 = *v5;
  }
  else
  {
    v7 = v11;
    v8 = v5;
  }
  memcpy(v7, v8, v6);
  while (a2 != a3)
  {
    if (boost::algorithm::detail::is_any_ofF<char>::operator()<char>(v11, *a2))
      goto LABEL_9;
    ++a2;
  }
  a2 = a3;
LABEL_9:
  if (v12 >= 0x11 && v11[0])
    MEMORY[0x22078A7F0](v11[0], 0x1000C8077774924);
  if (a2 == a3)
    return a3;
  if (!*((_DWORD *)v5 + 6))
  {
    v9 = a2;
    do
    {
      if (!boost::algorithm::detail::is_any_ofF<char>::operator()<char>(v5, *v9))
        break;
      ++v9;
    }
    while (v9 != a3);
  }
  return a2;
}

BOOL boost::algorithm::detail::is_any_ofF<char>::operator()<char>(_QWORD *a1, int a2)
{
  unint64_t v2;
  _QWORD *v3;
  char *v4;
  char *v5;
  int v6;
  unint64_t v7;

  v2 = a1[2];
  if (v2 >= 0x11)
  {
    a1 = (_QWORD *)*a1;
    v3 = (_QWORD *)((char *)a1 + v2);
  }
  else
  {
    v3 = (_QWORD *)((char *)a1 + v2);
    if (!v2)
      return a1 != v3 && *(char *)a1 <= a2;
  }
  do
  {
    v4 = (char *)a1 + (v2 >> 1);
    v6 = *v4;
    v5 = v4 + 1;
    v7 = v2 >> 1;
    v2 += ~(v2 >> 1);
    if (v6 < a2)
      a1 = v5;
    else
      v2 = v7;
  }
  while (v2);
  return a1 != v3 && *(char *)a1 <= a2;
}

uint64_t *boost::function2<boost::iterator_range<std::__wrap_iter<char const*>>,std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>::~function2(uint64_t *a1)
{
  uint64_t v2;
  void (*v3)(uint64_t *, uint64_t *, uint64_t);

  v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3)
        v3(a1 + 1, a1 + 1, 2);
    }
    *a1 = 0;
  }
  return a1;
}

SERestoreInfo::SN100VDeviceInfo *SERestoreInfo::SN100VDeviceInfo::SN100VDeviceInfo(SERestoreInfo::SN100VDeviceInfo *this, const SERestoreInfo::BLOB *a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  SERestoreInfo::SEWrongDeviceInfo *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_24E0C1EA0;
  if (*((_DWORD *)v3 + 14) != 100)
  {
    exception = (SERestoreInfo::SEWrongDeviceInfo *)__cxa_allocate_exception(0x48uLL);
    SERestoreInfo::SEWrongDeviceInfo::SEWrongDeviceInfo(exception);
  }
  return this;
}

void sub_21CCD3E8C(_Unwind_Exception *a1)
{
  SERestoreInfo::P73BaseDeviceInfo *v1;

  SERestoreInfo::P73BaseDeviceInfo::~P73BaseDeviceInfo(v1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::SN100VDeviceInfo::~SN100VDeviceInfo(SERestoreInfo::SN100VDeviceInfo *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
  JUMPOUT(0x22078A808);
}

SERestoreInfo::SN200VDeviceInfo *SERestoreInfo::SN200VDeviceInfo::SN200VDeviceInfo(SERestoreInfo::SN200VDeviceInfo *this, const SERestoreInfo::BLOB *a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  SERestoreInfo::SEWrongDeviceInfo *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_24E0C1EF0;
  if (*((_DWORD *)v3 + 14) != 200)
  {
    exception = (SERestoreInfo::SEWrongDeviceInfo *)__cxa_allocate_exception(0x48uLL);
    SERestoreInfo::SEWrongDeviceInfo::SEWrongDeviceInfo(exception);
  }
  return this;
}

void sub_21CCD4030(_Unwind_Exception *a1)
{
  SERestoreInfo::P73BaseDeviceInfo *v1;

  SERestoreInfo::P73BaseDeviceInfo::~P73BaseDeviceInfo(v1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::SN200VDeviceInfo::~SN200VDeviceInfo(SERestoreInfo::SN200VDeviceInfo *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24E0BFD58;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
  {
    *((_QWORD *)this + 15) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 8);
  if (v5)
  {
    *((_QWORD *)this + 9) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 4);
  if (v6)
  {
    *((_QWORD *)this + 5) = v6;
    operator delete(v6);
  }
  JUMPOUT(0x22078A808);
}

void sub_21CCD421C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_21CCD4294(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

SEUpdater::UpdateControllerBase *SEUpdater::UpdateControllerBase::UpdateControllerBase(SEUpdater::UpdateControllerBase *this)
{
  CFMutableDictionaryRef Mutable;

  *(_QWORD *)this = &unk_24E0C1210;
  *((_BYTE *)this + 16) = 0;
  *((_BYTE *)this + 56) = 0;
  *((_BYTE *)this + 64) = 0;
  *((_BYTE *)this + 66) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 11) = (char *)this + 96;
  *((_BYTE *)this + 80) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 2) = 0;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  ctu::cf::CFSharedRef<__CFDictionary const>::CFSharedRef<__CFDictionary,void>((_QWORD *)this + 14, (CFTypeRef *)&Mutable);
  *((_QWORD *)this + 15) = 0;
  return this;
}

void sub_21CCD4364(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void **v2;
  uint64_t v3;
  _QWORD **v4;

  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(v3, *v4);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(v2);
  std::__optional_destruct_base<AlohaPairingOptions,false>::~__optional_destruct_base[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

const void **SEUpdater::UpdateControllerBase::start(const void **this, const __CFDictionary *a2, uint64_t a3, const void *a4)
{
  AlohaVerificationOptions v6;
  const void *v8;
  const void *v9;
  AlohaVerificationOptions v10[4];

  if (a2)
    SEUpdaterUtil::SELogPrintCFType((SEUpdaterUtil *)3, (ctu::cf *)1, a2, a4);
  *(_QWORD *)&v10[0].var0 = a2;
  ctu::cf::CFSharedRef<__CFDictionary const>::reset(this + 9, (CFTypeRef *)v10);
  SEUpdater::UpdateControllerBase::setDebugOptions((SEUpdater::UpdateControllerBase *)this);
  (*((void (**)(const void **))*this + 2))(this);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v9, this + 9);
  getAlohaPairingOptions((id *)&v9, (uint64_t)v10);
  std::__optional_storage_base<AlohaPairingOptions,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<AlohaPairingOptions,false>>(this + 2, (uint64_t)v10);
  std::__optional_destruct_base<AlohaPairingOptions,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v10);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v9);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v8, this + 9);
  v10[0] = (AlohaVerificationOptions)256;
  AlohaVerificationOptions::print(v10);
  v6 = v10[0];
  *((_BYTE *)this + 66) = 1;
  *((AlohaVerificationOptions *)this + 32) = v6;
  return ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v8);
}

void sub_21CCD4464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&a9);
  _Unwind_Resume(a1);
}

const void **ctu::cf::CFSharedRef<__CFDictionary const>::reset(const void **a1, CFTypeRef *a2)
{
  CFTypeRef v3;
  const void *v4;
  const void *v6;

  v3 = *a2;
  if (*a2)
    CFRetain(*a2);
  v4 = *a1;
  *a1 = v3;
  v6 = v4;
  return ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v6);
}

void SEUpdater::UpdateControllerBase::setDebugOptions(SEUpdater::UpdateControllerBase *this)
{
  SEUpdaterUtil::SELogObj *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  const char *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  void *v12;
  uint64_t (*v13)(uint64_t);
  id v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  uint64_t (*v20)(uint64_t);
  SEUpdaterUtil::SELogObj *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  SEUpdaterUtil::SELogObj *v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  SEUpdaterUtil::SELogObj *v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  SEUpdaterUtil::SELogObj *v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *v52;
  void *__p[2];
  char v54;
  SEUpdaterUtil::SELogObj *v55;
  void *v56;

  *((_WORD *)this + 5) = SEUpdater::UpdateControllerBase::getBooleanOption((CFDictionaryRef *)this, CFSTR("RestoreInternal"), 0) | 0x100;
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v3 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v4 = (unint64_t *)((char *)__p[1] + 8);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v2 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v6 = (std::__shared_weak_count *)off_2553234C8;
  v55 = v2;
  v56 = off_2553234C8;
  if (off_2553234C8)
  {
    v7 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  if (!*((_BYTE *)this + 11))
    std::__throw_bad_optional_access[abi:ne180100]();
  if (*((_BYTE *)this + 10))
    v9 = "YES";
  else
    v9 = "NO";
  SEUpdaterUtil::SELogObj::printLog(v2, (SEUpdaterUtil::SELogObj *)1, 0, 1, "setDebugOptions", (SEUpdaterUtil::SELogObj *)"Internal Restore? %s\n", v9);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  SEUpdater::UpdateControllerBase::getStringfromOption((CFDictionaryRef *)this, __p);
  SEUpdaterUtil::parseArgs((uint64_t)__p, (uint64_t **)this + 11);
  if (v54 < 0)
    operator delete(__p[0]);
  v12 = (void *)*((_QWORD *)this + 9);
  v13 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  if (!v12)
    v13 = 0;
  if (v13)
  {
    v14 = v12;
    objc_msgSend(v14, "objectForKeyedSubscript:", CFSTR("Options"));
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    v16 = v15;
    if (v15)
    {
      objc_msgSend(v15, "objectForKeyedSubscript:", CFSTR("DebugLogPath"));
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      v18 = v17;
      if (v17)
        CFRetain(v17);
      v19 = (void *)*((_QWORD *)this + 15);
      *((_QWORD *)this + 15) = v18;
      __p[0] = v19;
      ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef((const void **)__p);

      if (*((_QWORD *)this + 15))
        v20 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
      else
        v20 = 0;
      if (v20)
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(__p);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
          v22 = (std::__shared_weak_count *)__p[1];
          if (__p[1])
          {
            v23 = (unint64_t *)((char *)__p[1] + 8);
            do
              v24 = __ldaxr(v23);
            while (__stlxr(v24 - 1, v23));
            if (!v24)
            {
              ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
              std::__shared_weak_count::__release_weak(v22);
            }
          }
          v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v25 = (std::__shared_weak_count *)off_2553234C8;
        v55 = v21;
        v56 = off_2553234C8;
        if (off_2553234C8)
        {
          v26 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v27 = __ldxr(v26);
          while (__stxr(v27 + 1, v26));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v21, (SEUpdaterUtil::SELogObj *)2, 0, 1, "setDebugOptions", (SEUpdaterUtil::SELogObj *)"EVENT LOGGING: debugLogPath obtained\n");
        if (!v25)
          goto LABEL_90;
        v28 = (unint64_t *)&v25->__shared_owners_;
        do
          v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
      }
      else
      {
        pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        v46 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        if (!off_2553234C0)
        {
          SEUpdaterUtil::SELogObj::create_default_global(__p);
          std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
          v47 = (std::__shared_weak_count *)__p[1];
          if (__p[1])
          {
            v48 = (unint64_t *)((char *)__p[1] + 8);
            do
              v49 = __ldaxr(v48);
            while (__stlxr(v49 - 1, v48));
            if (!v49)
            {
              ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
              std::__shared_weak_count::__release_weak(v47);
            }
          }
          v46 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
        }
        v25 = (std::__shared_weak_count *)off_2553234C8;
        v55 = v46;
        v56 = off_2553234C8;
        if (off_2553234C8)
        {
          v50 = (unint64_t *)((char *)off_2553234C8 + 8);
          do
            v51 = __ldxr(v50);
          while (__stxr(v51 + 1, v50));
        }
        pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
        SEUpdaterUtil::SELogObj::printLog(v46, (SEUpdaterUtil::SELogObj *)2, 0, 1, "setDebugOptions", (SEUpdaterUtil::SELogObj *)"EVENT LOGGING: debugLogPath not present\n");
        if (!v25)
          goto LABEL_90;
        v52 = (unint64_t *)&v25->__shared_owners_;
        do
          v29 = __ldaxr(v52);
        while (__stlxr(v29 - 1, v52));
      }
    }
    else
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v39 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(__p);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
        v40 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          v41 = (unint64_t *)((char *)__p[1] + 8);
          do
            v42 = __ldaxr(v41);
          while (__stlxr(v42 - 1, v41));
          if (!v42)
          {
            ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
            std::__shared_weak_count::__release_weak(v40);
          }
        }
        v39 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v25 = (std::__shared_weak_count *)off_2553234C8;
      v55 = v39;
      v56 = off_2553234C8;
      if (off_2553234C8)
      {
        v43 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v44 = __ldxr(v43);
        while (__stxr(v44 + 1, v43));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v39, (SEUpdaterUtil::SELogObj *)2, 0, 1, "setDebugOptions", (SEUpdaterUtil::SELogObj *)"EVENT LOGGING: Options not present\n");
      if (!v25)
        goto LABEL_90;
      v45 = (unint64_t *)&v25->__shared_owners_;
      do
        v29 = __ldaxr(v45);
      while (__stlxr(v29 - 1, v45));
    }
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
LABEL_90:

    return;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v30 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(__p);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)__p);
    v31 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      v32 = (unint64_t *)((char *)__p[1] + 8);
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    v30 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v34 = (std::__shared_weak_count *)off_2553234C8;
  v55 = v30;
  v56 = off_2553234C8;
  if (off_2553234C8)
  {
    v35 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  SEUpdaterUtil::SELogObj::printLog(v30, (SEUpdaterUtil::SELogObj *)2, 0, 1, "setDebugOptions", (SEUpdaterUtil::SELogObj *)"EVENT LOGGING: Invalid options parameter\n");
  if (v34)
  {
    v37 = (unint64_t *)&v34->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
}

void sub_21CCD4A80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  void *v16;
  void *v17;

  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);

  _Unwind_Resume(a1);
}

uint64_t SEUpdater::UpdateControllerBase::execCommand(const void **this, const __CFString *a2, const __CFDictionary *a3, const __CFDictionary **a4)
{
  SEUpdaterUtil::SELogObj *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::string *p_p;
  const void *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  const char *v19;
  std::string *v20;
  SEUpdaterUtil::SELogObj *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  const void *v28;
  unint64_t *v29;
  unint64_t v30;
  const __CFDictionary *v31;
  SEUpdaterUtil::SELogObj *v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  SEUpdaterUtil::SELogObj *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  uint64_t ErrorCode;
  SEUpdaterUtil::SELogObj *v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  std::string *v58;
  unint64_t *v59;
  unint64_t v60;
  void *exception;
  std::string *v63;
  __int128 v64;
  std::string __p;
  __int128 v66;
  std::string::size_type v67;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&__p, "Assertion: ");
    v63 = std::string::append(&__p, "command");
    v64 = *(_OWORD *)&v63->__r_.__value_.__l.__data_;
    v67 = v63->__r_.__value_.__r.__words[2];
    v66 = v64;
    v63->__r_.__value_.__l.__size_ = 0;
    v63->__r_.__value_.__r.__words[2] = 0;
    v63->__r_.__value_.__r.__words[0] = 0;
    MEMORY[0x22078A520](exception, &v66);
  }
  v66 = 0uLL;
  v67 = 0;
  ctu::cf::assign();
  memset(&__p, 0, sizeof(__p));
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v8 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v66);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v66);
    v9 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
    if (*((_QWORD *)&v66 + 1))
    {
      v10 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    v8 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v12 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v13 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  p_p = &__p;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  SEUpdaterUtil::SELogObj::printLog(v8, (SEUpdaterUtil::SELogObj *)2, 0, 1, "execCommand", (SEUpdaterUtil::SELogObj *)"Start processing command: %s\n", (const char *)p_p);
  if (!v12)
    goto LABEL_18;
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (v18)
  {
LABEL_18:
    if (!a3)
      goto LABEL_20;
    goto LABEL_19;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (a3)
  {
LABEL_19:
    SEUpdaterUtil::SELogPrintCFType((SEUpdaterUtil *)2, (ctu::cf *)1, a3, v16);
    *(_QWORD *)&v66 = a3;
    ctu::cf::CFSharedRef<__CFDictionary const>::reset(this + 9, (CFTypeRef *)&v66);
  }
LABEL_20:
  if (((*((uint64_t (**)(const void **, const __CFString *, const __CFDictionary **))*this + 3))(this, a2, a4) & 1) == 0)
  {
    v20 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
    SEUpdaterUtil::_AddError((SEUpdaterUtil *)2, 1, (uint64_t)"execCommand", (SEUpdaterUtil::SELogObj *)"Unrecognized command %s", v19, v20);
  }
  if (a4)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)this[14]))
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v66);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v66);
        v22 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
        if (*((_QWORD *)&v66 + 1))
        {
          v23 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
          do
            v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
        v21 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v25 = (std::__shared_weak_count *)off_2553234C8;
      if (off_2553234C8)
      {
        v26 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v27 = __ldxr(v26);
        while (__stxr(v27 + 1, v26));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      SEUpdaterUtil::SELogObj::printLog(v21, (SEUpdaterUtil::SELogObj *)2, 0, 1, "execCommand", (SEUpdaterUtil::SELogObj *)"Command output:\n");
      if (v25)
      {
        v29 = (unint64_t *)&v25->__shared_owners_;
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      SEUpdaterUtil::SELogPrintCFType((SEUpdaterUtil *)2, (ctu::cf *)1, this[14], v28);
      v31 = (const __CFDictionary *)CFRetain(this[14]);
      *a4 = v31;
    }
    else
    {
      pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v41 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      if (!off_2553234C0)
      {
        SEUpdaterUtil::SELogObj::create_default_global(&v66);
        std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v66);
        v42 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
        if (*((_QWORD *)&v66 + 1))
        {
          v43 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
          do
            v44 = __ldaxr(v43);
          while (__stlxr(v44 - 1, v43));
          if (!v44)
          {
            ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
            std::__shared_weak_count::__release_weak(v42);
          }
        }
        v41 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
      }
      v45 = (std::__shared_weak_count *)off_2553234C8;
      if (off_2553234C8)
      {
        v46 = (unint64_t *)((char *)off_2553234C8 + 8);
        do
          v47 = __ldxr(v46);
        while (__stxr(v47 + 1, v46));
      }
      pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
      v31 = (const __CFDictionary *)SEUpdaterUtil::SELogObj::printLog(v41, (SEUpdaterUtil::SELogObj *)2, 0, 1, "execCommand", (SEUpdaterUtil::SELogObj *)"No command output, returning NULL\n");
      if (v45)
      {
        v48 = (unint64_t *)&v45->__shared_owners_;
        do
          v49 = __ldaxr(v48);
        while (__stlxr(v49 - 1, v48));
        if (!v49)
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
      }
      *a4 = 0;
    }
  }
  else
  {
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v32 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&v66);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v66);
      v33 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
      if (*((_QWORD *)&v66 + 1))
      {
        v34 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
        do
          v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }
      v32 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v36 = (std::__shared_weak_count *)off_2553234C8;
    if (off_2553234C8)
    {
      v37 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v38 = __ldxr(v37);
      while (__stxr(v38 + 1, v37));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v31 = (const __CFDictionary *)SEUpdaterUtil::SELogObj::printLog(v32, (SEUpdaterUtil::SELogObj *)1, 0, 1, "execCommand", (SEUpdaterUtil::SELogObj *)"Caller did not provide an output dictionary\n");
    if (v36)
    {
      v39 = (unint64_t *)&v36->__shared_owners_;
      do
        v40 = __ldaxr(v39);
      while (__stlxr(v40 - 1, v39));
      if (!v40)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
  }
  ErrorCode = SEUpdaterUtil::GetErrorCode(v31);
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v51 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(&v66);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &v66);
    v52 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
    if (*((_QWORD *)&v66 + 1))
    {
      v53 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
      do
        v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
      if (!v54)
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
    }
    v51 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v55 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v56 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v57 = __ldxr(v56);
    while (__stxr(v57 + 1, v56));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v58 = &__p;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v58 = (std::string *)__p.__r_.__value_.__r.__words[0];
  SEUpdaterUtil::SELogObj::printLog(v51, (SEUpdaterUtil::SELogObj *)2, 0, 1, "execCommand", (SEUpdaterUtil::SELogObj *)"Finish processing command: %s and returning %d \n", (const char *)v58, ErrorCode);
  if (v55)
  {
    v59 = (unint64_t *)&v55->__shared_owners_;
    do
      v60 = __ldaxr(v59);
    while (__stlxr(v60 - 1, v59));
    if (!v60)
    {
      ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
      std::__shared_weak_count::__release_weak(v55);
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return ErrorCode;
}

void sub_21CCD51F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void SEUpdater::UpdateControllerBase::parseStartOptions(SEUpdater::UpdateControllerBase *this)
{
  uint64_t **v2;
  uint64_t v3;
  _OWORD *v4;
  int v5;
  void *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  void *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  SEUpdaterUtil::SELogObj *v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  const __CFDictionary *v37;
  uint64_t (*v38)(uint64_t);
  const __CFDictionary *Value;
  const __CFDictionary *v40;
  CFTypeID v41;
  const __CFBoolean *v42;
  const __CFBoolean *v43;
  CFTypeID v44;
  uint64_t v45;
  SEUpdaterUtil::SELogObj *v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  const char *v53;
  const char *v54;
  unint64_t *v55;
  unint64_t v56;
  void *v57;
  void *v58;
  void *exception;
  void *v60;
  void *v61[2];
  char v62;
  __int128 __p;
  uint64_t (*v64)(uint64_t);
  void *v65;
  void *v66;
  int v67;

  v2 = (uint64_t **)((char *)this + 88);
  std::string::basic_string[abi:ne180100]<0>(&__p, "logLevel");
  v3 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v2, (const void **)&__p);
  if (SHIBYTE(v64) < 0)
    operator delete((void *)__p);
  if (v3)
  {
    std::string::basic_string[abi:ne180100]<0>(&__p, "logLevel");
    v61[0] = &__p;
    v4 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2, (const void **)&__p, (uint64_t)&std::piecewise_construct, (_OWORD **)v61);
    v5 = std::stoi((const std::string *)((char *)v4 + 56), 0, 10);
    if (SHIBYTE(v64) < 0)
      operator delete((void *)__p);
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v6 = off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &__p);
      v7 = (std::__shared_weak_count *)*((_QWORD *)&__p + 1);
      if (*((_QWORD *)&__p + 1))
      {
        v8 = (unint64_t *)(*((_QWORD *)&__p + 1) + 8);
        do
          v9 = __ldaxr(v8);
        while (__stlxr(v9 - 1, v8));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      v6 = off_2553234C0;
    }
    v10 = (std::__shared_weak_count *)off_2553234C8;
    v61[0] = v6;
    v61[1] = off_2553234C8;
    if (off_2553234C8)
    {
      v11 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    SEUpdaterUtil::SELogObj::printLog((SEUpdaterUtil::SELogObj *)v6, 0, 0, 1, "parseStartOptions", (SEUpdaterUtil::SELogObj *)"Setting loglevel to %d\n", v5);
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v15 = off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(&__p);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, &__p);
      v16 = (std::__shared_weak_count *)*((_QWORD *)&__p + 1);
      if (*((_QWORD *)&__p + 1))
      {
        v17 = (unint64_t *)(*((_QWORD *)&__p + 1) + 8);
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v15 = off_2553234C0;
    }
    v19 = (std::__shared_weak_count *)off_2553234C8;
    if (off_2553234C8)
    {
      v20 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    *(_QWORD *)&__p = MEMORY[0x24BDAC760];
    *((_QWORD *)&__p + 1) = 3221225472;
    v64 = ___ZN13SEUpdaterUtil8SELogObj11setLogLevelEi_block_invoke;
    v65 = &__block_descriptor_44_e5_v8__0l;
    v66 = v15;
    v67 = v5;
    v61[0] = &__p;
    ctu::SharedSynchronizable<SEUpdaterUtil::SELogObj>::execute_wrapped_sync<void({block_pointer} {__strong}&)(void)>((uint64_t)v15, (uint64_t)v61);

    if (v19)
    {
      v22 = (unint64_t *)&v19->__shared_owners_;
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
  if (!*((_BYTE *)this + 11))
    std::__throw_bad_optional_access[abi:ne180100]();
  if (*((_BYTE *)this + 10))
  {
    std::string::basic_string[abi:ne180100]<0>(v61, "haltOnCrash");
    v24 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v2, (const void **)v61);
    v25 = v24;
    if (v62 < 0)
    {
      operator delete(v61[0]);
      if (!v25)
        goto LABEL_58;
    }
    else if (!v24)
    {
      goto LABEL_58;
    }
    pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v26 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    if (!off_2553234C0)
    {
      SEUpdaterUtil::SELogObj::create_default_global(v61);
      std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)v61);
      v27 = (std::__shared_weak_count *)v61[1];
      if (v61[1])
      {
        v28 = (unint64_t *)((char *)v61[1] + 8);
        do
          v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
      v26 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
    }
    v30 = (std::__shared_weak_count *)off_2553234C8;
    if (off_2553234C8)
    {
      v31 = (unint64_t *)((char *)off_2553234C8 + 8);
      do
        v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
    }
    pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
    v33 = SEUpdaterUtil::SELogObj::printLog(v26, 0, 0, 1, "parseStartOptions", (SEUpdaterUtil::SELogObj *)"Install signal handlers\n");
    if (v30)
    {
      v34 = (unint64_t *)&v30->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    SEUpdaterUtil::RegisterDebugSignals((SEUpdaterUtil *)v33);
  }
LABEL_58:
  *((_BYTE *)this + 8) = SEUpdater::UpdateControllerBase::getBooleanOption((CFDictionaryRef *)this, CFSTR("FactoryRFTest"), 0);
  std::string::basic_string[abi:ne180100]<0>(v61, "setActivateFTA");
  v36 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v2, (const void **)v61);
  if (v62 < 0)
    operator delete(v61[0]);
  if (v36)
    *((_BYTE *)this + 8) = 1;
  v37 = (const __CFDictionary *)*((_QWORD *)this + 9);
  v38 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  if (!v37)
    v38 = 0;
  if (v38)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v37, CFSTR("RestoreOptions"));
    if (Value)
    {
      v40 = Value;
      v41 = CFGetTypeID(Value);
      if (v41 != CFDictionaryGetTypeID())
      {
        exception = __cxa_allocate_exception(0x48uLL);
        std::string::basic_string[abi:ne180100]<0>(v61, "RestoreOptions not a dict?");
        v60 = (void *)SERestoreInfo::SEException::SEException((uint64_t)exception, (__int128 *)v61, 2, CFSTR("SEUpdaterErrorDomain"));
      }
      v42 = (const __CFBoolean *)CFDictionaryGetValue(v40, CFSTR("CreateFilesystemPartitions"));
      if (!v42 || (v43 = v42, v44 = CFGetTypeID(v42), v44 != CFBooleanGetTypeID()))
      {
        v57 = __cxa_allocate_exception(0x48uLL);
        std::string::basic_string[abi:ne180100]<0>(v61, "CreateFilesystemPartitions missing or wrong type");
        v58 = (void *)SERestoreInfo::SEException::SEException((uint64_t)v57, (__int128 *)v61, 2, CFSTR("SEUpdaterErrorDomain"));
      }
      *((_BYTE *)this + 9) = CFBooleanGetValue(v43) != 0;
    }
    else
    {
      *((_BYTE *)this + 9) = 0;
    }
    std::string::basic_string[abi:ne180100]<0>(v61, "setEraseInstall");
    v45 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>((uint64_t)v2, (const void **)v61);
    if (v62 < 0)
      operator delete(v61[0]);
    if (v45)
      *((_BYTE *)this + 9) = 1;
  }
  pthread_mutex_lock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v46 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  if (!off_2553234C0)
  {
    SEUpdaterUtil::SELogObj::create_default_global(v61);
    std::shared_ptr<SEUpdaterUtil::SELogObj>::operator=[abi:ne180100]((uint64_t)&off_2553234C0, (__int128 *)v61);
    v47 = (std::__shared_weak_count *)v61[1];
    if (v61[1])
    {
      v48 = (unint64_t *)((char *)v61[1] + 8);
      do
        v49 = __ldaxr(v48);
      while (__stlxr(v49 - 1, v48));
      if (!v49)
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
    }
    v46 = (SEUpdaterUtil::SELogObj *)off_2553234C0;
  }
  v50 = (std::__shared_weak_count *)off_2553234C8;
  if (off_2553234C8)
  {
    v51 = (unint64_t *)((char *)off_2553234C8 + 8);
    do
      v52 = __ldxr(v51);
    while (__stxr(v52 + 1, v51));
  }
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  v53 = "activated";
  if (!*((_BYTE *)this + 8))
    v53 = "deactivated";
  if (*((_BYTE *)this + 9))
    v54 = (const char *)&unk_21CCDB9F7;
  else
    v54 = "not ";
  SEUpdaterUtil::SELogObj::printLog(v46, (SEUpdaterUtil::SELogObj *)1, 0, 1, "parseStartOptions", (SEUpdaterUtil::SELogObj *)"Additional actions: FTA will be %s, MFD will %sbe performed\n", v53, v54);
  if (v50)
  {
    v55 = (unint64_t *)&v50->__shared_owners_;
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
}

void sub_21CCD5A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  pthread_mutex_unlock(&ctu::Singleton<SEUpdaterUtil::SELogObj,SEUpdaterUtil::SELogObj,ctu::PthreadMutexGuardPolicy<SEUpdaterUtil::SELogObj>>::sInstance);
  _Unwind_Resume(a1);
}

BOOL SEUpdater::UpdateControllerBase::getBooleanOption(CFDictionaryRef *this, const __CFString *a2, uint64_t a3)
{
  const __CFDictionary *Value;
  const __CFDictionary *v6;
  CFTypeID v7;
  const __CFBoolean *v8;
  const __CFBoolean *v9;
  CFTypeID v10;

  Value = (const __CFDictionary *)CFDictionaryGetValue(this[9], CFSTR("Options"));
  if (Value)
  {
    v6 = Value;
    v7 = CFGetTypeID(Value);
    if (v7 == CFDictionaryGetTypeID())
    {
      v8 = (const __CFBoolean *)CFDictionaryGetValue(v6, a2);
      if (v8)
      {
        v9 = v8;
        v10 = CFGetTypeID(v8);
        if (v10 == CFBooleanGetTypeID())
          return CFBooleanGetValue(v9) != 0;
      }
    }
  }
  return a3;
}

const void *SEUpdater::UpdateControllerBase::getStringfromOption@<X0>(CFDictionaryRef *this@<X0>, _QWORD *a2@<X8>)
{
  const void *result;
  const void *v5;
  CFTypeID TypeID;
  __int128 v7;
  uint64_t v8;
  _BYTE v9[16];

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  result = CFDictionaryGetValue(this[9], CFSTR("Options"));
  if (result)
  {
    v5 = result;
    TypeID = CFDictionaryGetTypeID();
    result = (const void *)CFGetTypeID(v5);
    if ((const void *)TypeID == result)
    {
      ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v9, (const __CFDictionary *)v5);
      ctu::cf::map_adapter::getString();
      *(_OWORD *)a2 = v7;
      a2[2] = v8;
      return (const void *)MEMORY[0x22078A454](v9);
    }
  }
  return result;
}

void sub_21CCD5C68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a14 < 0)
    operator delete(__p);
  MEMORY[0x22078A454](&a18);
  _Unwind_Resume(a1);
}

const void **std::__optional_storage_base<AlohaPairingOptions,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<AlohaPairingOptions,false>>(const void **result, uint64_t a2)
{
  const void **v3;
  const void *v4;
  const void *v5;
  const void *v6;
  __int16 v7;
  __int16 v8;
  const void *v9;

  v3 = result;
  if (*((unsigned __int8 *)result + 40) == *(unsigned __int8 *)(a2 + 40))
  {
    if (*((_BYTE *)result + 40))
    {
      *(_BYTE *)result = *(_BYTE *)a2;
      if (result != (const void **)a2)
      {
        v4 = result[1];
        result[1] = 0;
        v9 = v4;
        result[1] = *(const void **)(a2 + 8);
        *(_QWORD *)(a2 + 8) = 0;
        ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::~SharedRef(&v9);
        v5 = v3[2];
        v3[2] = 0;
        v9 = v5;
        v3[2] = *(const void **)(a2 + 16);
        *(_QWORD *)(a2 + 16) = 0;
        ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef(&v9);
        v6 = v3[3];
        v3[3] = 0;
        v9 = v6;
        v3[3] = *(const void **)(a2 + 24);
        *(_QWORD *)(a2 + 24) = 0;
        result = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef(&v9);
      }
      v7 = *(_WORD *)(a2 + 32);
      *((_BYTE *)v3 + 34) = *(_BYTE *)(a2 + 34);
      *((_WORD *)v3 + 16) = v7;
    }
  }
  else if (*((_BYTE *)result + 40))
  {
    ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef(result + 3);
    ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef(v3 + 2);
    result = ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::~SharedRef(v3 + 1);
    *((_BYTE *)v3 + 40) = 0;
  }
  else
  {
    *(_BYTE *)result = *(_BYTE *)a2;
    result[1] = 0;
    result[1] = *(const void **)(a2 + 8);
    *(_QWORD *)(a2 + 8) = 0;
    result[2] = 0;
    result[2] = *(const void **)(a2 + 16);
    *(_QWORD *)(a2 + 16) = 0;
    result[3] = 0;
    result[3] = *(const void **)(a2 + 24);
    *(_QWORD *)(a2 + 24) = 0;
    v8 = *(_WORD *)(a2 + 32);
    *((_BYTE *)result + 34) = *(_BYTE *)(a2 + 34);
    *((_WORD *)result + 16) = v8;
    *((_BYTE *)result + 40) = 1;
  }
  return result;
}

uint64_t ___ZN13SEUpdaterUtil8SELogObj11setLogLevelEi_block_invoke(uint64_t result)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(result + 32);
  v2 = *(_DWORD *)(result + 40);
  if (v2 >= 6)
  {
    v2 = 5;
LABEL_4:
    *(_DWORD *)(v1 + 48) = v2;
    return result;
  }
  if ((v2 & 0x80000000) == 0)
    goto LABEL_4;
  *(_DWORD *)(v1 + 48) = 0;
  return result;
}

_QWORD *ctu::cf::CFSharedRef<__CFDictionary const>::CFSharedRef<__CFDictionary,void>(_QWORD *a1, CFTypeRef *a2)
{
  CFTypeRef v4;
  CFTypeID v5;

  v4 = *a2;
  if (*a2 && (v5 = CFGetTypeID(*a2), v5 == CFDictionaryGetTypeID()))
  {
    *a1 = v4;
  }
  else
  {
    *a1 = 0;
    if (*a2)
      CFRelease(*a2);
  }
  return a1;
}

void _GLOBAL__sub_I_UpdateControllerBase_cpp()
{
  void *v0;

  v0 = (void *)MEMORY[0x22078AB2C]();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 1);
  qword_2553237A0 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 1);
  qword_2553237A8 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 0);
  qword_2553237B0 = objc_claimAutoreleasedReturnValue();
  objc_autoreleasePoolPop(v0);
}

uint64_t AMFDRDataPutForRestore()
{
  return MEMORY[0x24BED4208]();
}

uint64_t AMFDRSealingMapCopyLocalData()
{
  return MEMORY[0x24BED4320]();
}

uint64_t AMFDRSealingMapCopyLocalDataForClass()
{
  return MEMORY[0x24BED4328]();
}

uint64_t AMSupportDigestSha256()
{
  return MEMORY[0x24BED9FF0]();
}

uint64_t AMSupportEcDsaCreateSignatureSha256()
{
  return MEMORY[0x24BEDA000]();
}

uint64_t AMSupportEcDsaCreateSignatureSha384()
{
  return MEMORY[0x24BEDA008]();
}

uint64_t AMSupportEcDsaCreateSignatureSha512()
{
  return MEMORY[0x24BEDA010]();
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x24BDBBA18]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x24BDBBA20](BOOLean);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x24BDBBC98](allocator, bytes, length);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x24BDBBCE0](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  MEMORY[0x24BDBBCE8](theData, range.location, range.length, buffer);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x24BDBBCF8](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x24BDBBD08]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBDB0](theDict, key, value);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x24BDBBE00](theDict);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x24BDBBE18]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x24BDBBE38](theDict, key, value);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x24BDBBE70](err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x24BDBBE88](allocator, domain, code, userInfo);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x24BDBBE98](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x24BDBBEA0](err);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x24BDBBEE0](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x24BDBC0A0](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x24BDBC118]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x24BDBC130](number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBC2A8](cf);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x24BDBC4D0](theString1, theString2, compareOptions);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x24BDBC558](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x24BDBC598](alloc, formatOptions, format);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x24BDBC5F8](theString, range.location, range.length, *(_QWORD *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x24BDBC658](theString);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x24BDBC698]();
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return MEMORY[0x24BDD7F08](*(_QWORD *)&connection, *(_QWORD *)&selector, inputStruct, inputStructCnt, outputStruct, outputStructCnt);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x24BDD8690](*(_QWORD *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
  MEMORY[0x24BDD8698](notify);
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
  MEMORY[0x24BDD86B0](notify, queue);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x24BDD86F8](*(_QWORD *)&object);
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return MEMORY[0x24BDD8958](notifyPort, *(_QWORD *)&service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x24BDD8970](*(_QWORD *)&connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x24BDD8988](*(_QWORD *)&mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDD89A8](name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return MEMORY[0x24BDD89B8](*(_QWORD *)&service, *(_QWORD *)&owningTask, *(_QWORD *)&type, connect);
}

uint64_t Img4DecodeGetObjectPropertyData()
{
  return MEMORY[0x24BEDA1C8]();
}

uint64_t Img4DecodeInitManifest()
{
  return MEMORY[0x24BEDA208]();
}

uint64_t Img4EncodeCreateManifest()
{
  return MEMORY[0x24BEDA230]();
}

uint64_t Img4EncodeItemBegin()
{
  return MEMORY[0x24BEDA240]();
}

uint64_t Img4EncodeItemCopyBuffer()
{
  return MEMORY[0x24BEDA248]();
}

uint64_t Img4EncodeItemDestroy()
{
  return MEMORY[0x24BEDA250]();
}

uint64_t Img4EncodeItemEnd()
{
  return MEMORY[0x24BEDA258]();
}

uint64_t Img4EncodeItemPropertyBool()
{
  return MEMORY[0x24BEDA260]();
}

uint64_t Img4EncodeItemPropertyData()
{
  return MEMORY[0x24BEDA268]();
}

uint64_t Img4EncodeItemPropertyInt32()
{
  return MEMORY[0x24BEDA270]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x24BED8470]();
}

uint64_t MGGetSInt64Answer()
{
  return MEMORY[0x24BED84A0]();
}

uint64_t NfRestoreOpenWithSE()
{
  return MEMORY[0x24BEDCC08]();
}

uint64_t NfRestoreSEClose()
{
  return MEMORY[0x24BEDCC18]();
}

uint64_t NfRestoreSEEnumerate()
{
  return MEMORY[0x24BEDCC28]();
}

uint64_t NfRestoreSETransceive()
{
  return MEMORY[0x24BEDCC48]();
}

uint64_t NfRestoreSETransceiveToOS()
{
  return MEMORY[0x24BEDCC50]();
}

uint64_t NfRestoreToggleSEPower()
{
  return MEMORY[0x24BEDCC58]();
}

uint64_t RPCopyProxyDictionary()
{
  return MEMORY[0x24BED8C70]();
}

uint64_t RPRegisterForAvailability()
{
  return MEMORY[0x24BED8C80]();
}

uint64_t RPRegistrationInvalidate()
{
  return MEMORY[0x24BED8C90]();
}

uint64_t RPRegistrationResume()
{
  return MEMORY[0x24BED8CA0]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x24BDBD0A8]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x24BDBD0B0]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

uint64_t capabilities::euicc::shouldEnableEUICCDetectPullDown(capabilities::euicc *this)
{
  return MEMORY[0x24BED9248](this);
}

uint64_t ctu::cf::MakeCFString::MakeCFString(ctu::cf::MakeCFString *this, const char *a2)
{
  return MEMORY[0x24BED9A78](this, a2);
}

void ctu::cf::MakeCFString::~MakeCFString(ctu::cf::MakeCFString *this)
{
  MEMORY[0x24BED9A80](this);
}

uint64_t ctu::cf::dict_adapter::dict_adapter(ctu::cf::dict_adapter *this, const __CFDictionary *a2)
{
  return MEMORY[0x24BED9AA0](this, a2);
}

void ctu::cf::dict_adapter::~dict_adapter(ctu::cf::dict_adapter *this)
{
  MEMORY[0x24BED9AB0](this);
}

uint64_t ctu::cf::show(ctu::cf *this, const void *a2)
{
  return MEMORY[0x24BED9AC8](this, a2);
}

uint64_t ctu::cf::show(ctu::cf *this, uint64_t a2, const void *a3)
{
  return MEMORY[0x24BED9AD0](this, a2, a3);
}

uint64_t ctu::cf::assign()
{
  return MEMORY[0x24BED9AD8]();
}

uint64_t ctu::hex(ctu *this, const void *a2)
{
  return MEMORY[0x24BED9BB0](this, a2);
}

uint64_t ctu::hex()
{
  return MEMORY[0x24BED9BB8]();
}

uint64_t ctu::cf::map_adapter::getInt(ctu::cf::map_adapter *this, const __CFString *a2)
{
  return MEMORY[0x24BED9E90](this, a2);
}

uint64_t ctu::cf::map_adapter::getString()
{
  return MEMORY[0x24BED9EA8]();
}

std::string::size_type std::string::rfind(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return MEMORY[0x24BEDA9B8](this, __c, __pos);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x24BEDA9E0]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x24BEDAA60](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x24BEDAA70](this);
}

const char *__cdecl std::exception::what(const std::exception *this)
{
  return (const char *)MEMORY[0x24BEDAA88](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::logic_error *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAB8](this, a2);
}

std::exception_ptr *__cdecl std::exception_ptr::exception_ptr(std::exception_ptr *this, const std::exception_ptr *a2)
{
  return (std::exception_ptr *)MEMORY[0x24BEDAB18](this, a2);
}

void std::exception_ptr::~exception_ptr(std::exception_ptr *this)
{
  MEMORY[0x24BEDAB20](this);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::string *a2)
{
  return (std::runtime_error *)MEMORY[0x24BEDAB38](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x24BEDABB0](this);
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC20](this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x24BEDAC38](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC40](this, __s, __n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x24BEDAC58](this, __s);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x24BEDAC80](this, __pos, __s);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
  MEMORY[0x24BEDACC0](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add);
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x24BEDACE8](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x24BEDAD00](this, __str);
}

std::future_error *__cdecl std::future_error::future_error(std::future_error *this, std::error_code __ec)
{
  return (std::future_error *)MEMORY[0x24BEDAD78](this, *(_QWORD *)&__ec.__val_, __ec.__cat_);
}

void std::future_error::~future_error(std::future_error *this)
{
  MEMORY[0x24BEDAD80](this);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x24BEDADD8]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x24BEDADF0]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x24BEDADF8]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x24BEDAEE0]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x24BEDAEE8]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x24BEDAEF0]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x24BEDAEF8]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x24BEDAF00]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x24BEDAF10]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x24BEDAF50]();
}

{
  return MEMORY[0x24BEDAF70]();
}

void std::__shared_count::~__shared_count(std::__shared_count *this)
{
  MEMORY[0x24BEDAFF8](this);
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x24BEDB048]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x24BEDB050]();
}

const std::error_category *std::future_category(void)
{
  return (const std::error_category *)MEMORY[0x24BEDB080]();
}

const std::error_category *std::generic_category(void)
{
  return (const std::error_category *)MEMORY[0x24BEDB0B8]();
}

void std::__assoc_sub_state::__sub_wait(std::__assoc_sub_state *this, std::unique_lock<std::mutex> *__lk)
{
  MEMORY[0x24BEDB0C0](this, __lk);
}

void std::__assoc_sub_state::set_exception(std::__assoc_sub_state *this, std::exception_ptr __p)
{
  MEMORY[0x24BEDB0C8](this, __p.__ptr_);
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
  MEMORY[0x24BEDB0F8](this);
}

void std::condition_variable::__do_timed_wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk, std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> a3)
{
  MEMORY[0x24BEDB108](this, __lk, a3.__d_.__rep_);
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
  MEMORY[0x24BEDB118](this);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB180](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB190](this);
}

int std::stoi(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x24BEDB330](__str, __idx, *(_QWORD *)&__base);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x24BEDB368](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x24BEDB370](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x24BEDB380](this);
}

unint64_t std::stoul(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x24BEDB390](__str, __idx, *(_QWORD *)&__base);
}

uint64_t std::__sort<std::__less<char,char> &,char *>()
{
  return MEMORY[0x24BEDB398]();
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x24BEDB3E0]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x24BEDB3F0]();
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x24BEDB438](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x24BEDB440](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x24BEDB448](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x24BEDB500](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x24BEDB518](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x24BEDB530](this, *(_QWORD *)&__state);
}

std::ios_base::failure *__cdecl std::ios_base::failure::failure(std::ios_base::failure *this, const std::string *__msg, const std::error_code *__ec)
{
  return (std::ios_base::failure *)MEMORY[0x24BEDB558](this, __msg, __ec);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x24BEDB5E8]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x24BEDB608](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x24BEDB610](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return (std::string *)MEMORY[0x24BEDB620](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, uint64_t __val)
{
  return (std::string *)MEMORY[0x24BEDB628](retstr, __val);
}

uint64_t std::operator+<char>()
{
  return MEMORY[0x24BEDB638]();
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x24BEDB688](this);
}

std::exception_ptr std::current_exception(void)
{
  return (std::exception_ptr)MEMORY[0x24BEDB6A0]();
}

void std::rethrow_exception(std::exception_ptr a1)
{
  MEMORY[0x24BEDB6A8](a1.__ptr_);
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

uint64_t operator delete[]()
{
  return off_24E0BEC18();
}

void operator delete(void *__p)
{
  off_24E0BEC20(__p);
}

uint64_t operator delete()
{
  return off_24E0BEC28();
}

uint64_t operator new[]()
{
  return off_24E0BEC30();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24E0BEC38(__sz);
}

uint64_t operator new()
{
  return off_24E0BEC40();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x24BDAC7A0](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x24BEDB928]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x24BEDB940](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x24BEDB948](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x24BEDB950](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x24BEDB958]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x24BDAC7D0]();
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x24BDAC848]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB80](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x24BEAE670]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x24BDAD010]();
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x24BDAD288](a1, *(_QWORD *)&a2);
}

void backtrace_symbols_fd(void *const *a1, int a2, int a3)
{
  MEMORY[0x24BDAD2A8](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

uint64_t ccdigest()
{
  return MEMORY[0x24BDAD538]();
}

uint64_t ccsha256_di()
{
  return MEMORY[0x24BDAD828]();
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x24BDAD990](a1, a2);
}

int close(int a1)
{
  return MEMORY[0x24BDAD9D8](*(_QWORD *)&a1);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC0](queue, block);
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC8](queue, block);
}

void dispatch_barrier_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x24BDADCF0](queue, context, work);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x24BDADF10](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x24BDADF20](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x24BDADF28](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x24BDADF30](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADF38](dsema, timeout);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

int dlclose(void *__handle)
{
  return MEMORY[0x24BDAE060](__handle);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x24BDAE070](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x24BDAE088](__handle, __symbol);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x24BDAE2E8](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

int fflush(FILE *a1)
{
  return MEMORY[0x24BDAE350](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x24BDAE410](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAE428](a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x24BDAE440](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x24BDAE508](*(_QWORD *)&a1, a2);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x24BDAE530](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE590](__ptr, __size, __nitems, __stream);
}

int getchar(void)
{
  return MEMORY[0x24BDAE5D0]();
}

const char *getprogname(void)
{
  return (const char *)MEMORY[0x24BDAE6E8]();
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x24BDAE780](a1, a2);
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x24BDAEA98](a1);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x24BDAEFA8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x24BDAEFF0](a1, a2);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x24BEDCF68](a1);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x24BEDCFA8](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x24BEDCFB0](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x24BEDCFC0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDCFD0](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x24BEDD068](obj);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x24BEDD088](name);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD120](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x24BEDD130]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x24BEDD138]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x24BEDD148]();
}

void objc_release(id a1)
{
  MEMORY[0x24BEDD188](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x24BEDD2A8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B8](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x24BEDD2C0](a1);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x24BEDD410](location, obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD458](a1);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x24BDAF228](a1, *(_QWORD *)&a2);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8D0](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8E0](a1);
}

int puts(const char *a1)
{
  return MEMORY[0x24BDAF9F8](a1);
}

int sigaction(int a1, const sigaction *a2, sigaction *a3)
{
  return MEMORY[0x24BDAFDE8](*(_QWORD *)&a1, a2, a3);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x24BDAFF10](__s1);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return MEMORY[0x24BDAFF28](a1, a2, a3, a4);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

char *__cdecl strtok(char *__str, const char *__sep)
{
  return (char *)MEMORY[0x24BDAFFF0](__str, __sep);
}

char *__cdecl strtok_r(char *__str, const char *__sep, char **__lasts)
{
  return (char *)MEMORY[0x24BDAFFF8](__str, __sep, __lasts);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0030](__str, __endptr, *(_QWORD *)&__base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x24BDB00F8](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x24BDB0100](a1, a2, a3, a4, a5);
}

time_t time(time_t *a1)
{
  return MEMORY[0x24BDB0240](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x24BDB02E8](*(_QWORD *)&a1);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x24BDB0358](a1, a2, a3);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return MEMORY[0x24BDB0370](a1, a2, a3);
}

