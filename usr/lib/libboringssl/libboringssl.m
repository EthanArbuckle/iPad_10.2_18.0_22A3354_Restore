uint64_t ssl_cipher_id_cmp_void(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  v2 = a1[4];
  v3 = a2[4];
  v4 = v2 > v3;
  if (v2 >= v3)
    v5 = 0;
  else
    v5 = -1;
  if (v4)
    return 1;
  else
    return v5;
}

uint64_t bssl::`anonymous namespace'::X25519KeyShare::Finish(uint64_t a1, uint64_t a2, _BYTE *a3, int64x2_t *a4, uint64_t a5)
{
  char *v10;
  char *v11;
  uint64_t v12;

  *a3 = 80;
  OPENSSL_free(0);
  v10 = (char *)OPENSSL_malloc(0x20uLL);
  v11 = v10;
  if (v10)
  {
    if (a5 == 32 && X25519(v10, (__int128 *)(a1 + 8), a4))
    {
      OPENSSL_free(*(_QWORD **)a2);
      *(_QWORD *)a2 = v11;
      *(_QWORD *)(a2 + 8) = 32;
      v12 = 1;
      v11 = 0;
    }
    else
    {
      *a3 = 50;
      ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_key_share.cc", 154);
      v12 = 0;
    }
  }
  else
  {
    v12 = 0;
  }
  OPENSSL_free(v11);
  return v12;
}

void sub_1B4F6E084(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL X25519(char *a1, __int128 *a2, int64x2_t *a3)
{
  int64x2_t v3;
  __int128 v4;
  int64x2_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t j;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  __int128 v42;
  int8x16_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t k;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int8x16_t v58;
  int64x2_t v59;
  int64x2_t v60;
  unint64_t v61;
  int64x2_t v62[2];
  unint64_t v63;
  int64x2_t v64[2];
  unint64_t v65;
  int64x2_t v66[2];
  unint64_t v67;
  int64x2_t v68[2];
  unint64_t v69;
  int64x2_t v70[2];
  unint64_t v71;
  int64x2_t v72[2];
  unint64_t v73;
  uint64_t v74;
  __int128 v75;
  int8x16_t v76;
  int64x2_t v77[2];
  unint64_t v78;
  int64x2_t v79;
  int64x2_t v80;
  uint64_t v81;
  unint64_t v82;
  __int128 v83;
  __int128 v84;
  int64x2_t v85;
  int64x2_t v86;
  unint64_t v87;
  __int128 v88;
  __int128 v89;
  int64x2_t v90;
  int64x2_t v91;
  uint64_t v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  v87 = 0xAAAAAAAAAAAAAAAALL;
  v3.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v3.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v85 = v3;
  v86 = v3;
  v73 = 0xAAAAAAAAAAAAAAAALL;
  v72[0] = v3;
  v72[1] = v3;
  v71 = 0xAAAAAAAAAAAAAAAALL;
  v70[0] = v3;
  v70[1] = v3;
  v69 = 0xAAAAAAAAAAAAAAAALL;
  v68[0] = v3;
  v68[1] = v3;
  v67 = 0xAAAAAAAAAAAAAAAALL;
  v66[0] = v3;
  v66[1] = v3;
  v65 = 0xAAAAAAAAAAAAAAAALL;
  v64[0] = v3;
  v64[1] = v3;
  v63 = 0xAAAAAAAAAAAAAAAALL;
  v62[0] = v3;
  v62[1] = v3;
  v61 = 0xAAAAAAAAAAAAAAAALL;
  v59 = v3;
  v60 = v3;
  v4 = a2[1];
  v88 = *a2;
  v89 = v4;
  LOBYTE(v88) = v88 & 0xF8;
  HIBYTE(v89) = HIBYTE(v4) & 0x3F | 0x40;
  v5 = a3[1];
  v90 = *a3;
  v91 = v5;
  v91.i8[15] = v5.i8[15] & 0x7F;
  fe_frombytes_strict((unint64_t *)&v85, (unsigned int *)&v90);
  v6 = 0;
  v83 = 0u;
  v84 = 0u;
  v81 = 0;
  v82 = 1;
  v79 = 0u;
  v80 = 0u;
  v77[0] = v85;
  v77[1] = v86;
  v7 = 254;
  v78 = v87;
  v75 = 0u;
  v74 = 1;
  v58 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFuLL);
  v76 = 0u;
  do
  {
    v8 = 0;
    v9 = v7;
    v10 = v6;
    v6 = (*((unsigned __int8 *)&v88 + ((unint64_t)v7 >> 3)) >> (v7 & 7)) & 1;
    v11 = -(uint64_t)(v6 ^ v10);
    do
    {
      v12 = *(unint64_t *)((char *)&v82 + v8 * 8);
      v13 = v77[0].i64[v8];
      v14 = (v13 ^ v12) & v11;
      *(unint64_t *)((char *)&v82 + v8 * 8) = v14 ^ v12;
      v77[0].i64[v8++] = v14 ^ v13;
    }
    while (v8 != 5);
    for (i = 0; i != 5; ++i)
    {
      v16 = v79.i64[i];
      v17 = *(uint64_t *)((char *)&v74 + i * 8);
      v18 = (v17 ^ v16) & v11;
      v79.i64[i] = v18 ^ v16;
      *(uint64_t *)((char *)&v74 + i * 8) = v18 ^ v17;
    }
    fe_sub(v62, v77, (int64x2_t *)&v74);
    fe_sub(&v59, (int64x2_t *)&v82, &v79);
    fe_add(v68, (int64x2_t *)&v82, &v79);
    fe_add(v66, v77, (int64x2_t *)&v74);
    fe_mul_impl((uint64_t)&v74, (unint64_t *)v62, (unint64_t *)v68);
    fe_mul_impl((uint64_t)&v79, (unint64_t *)v66, (unint64_t *)&v59);
    fe_sq_tl((uint64_t)v72, (unint64_t *)&v59);
    fe_sq_tl((uint64_t)v70, (unint64_t *)v68);
    fe_add(v64, (int64x2_t *)&v74, &v79);
    fe_sub(v66, (int64x2_t *)&v74, &v79);
    fe_mul_impl((uint64_t)&v82, (unint64_t *)v70, (unint64_t *)v72);
    fe_sub(&v59, v70, v72);
    fe_sq_tl((uint64_t)&v79, (unint64_t *)v66);
    for (j = 0; j != 5; ++j)
    {
      if (v59.i64[j] >= 0x1A666666666665uLL)
        X25519_cold_1();
    }
    v20 = 0;
    v21 = (v61 * (unsigned __int128)0x1DB42uLL) >> 64;
    v22 = 121666 * v61;
    v23 = (v60.u64[1] * (unsigned __int128)0x1DB42uLL) >> 64;
    v24 = 121666 * v60.i64[1];
    v25 = (__int128)(v59.u64[0] * (unsigned __int128)0x1DB42uLL) >> 51;
    v26 = __CFADD__(v25, 121666 * v59.i64[1]);
    v27 = v25 + 121666 * v59.i64[1];
    v28 = 121666 * v60.i64[0];
    v29 = (v59.u64[1] * (unsigned __int128)0x1DB42uLL) >> 64;
    if (v26)
      ++v29;
    *((_QWORD *)&v31 + 1) = v29;
    *(_QWORD *)&v31 = v27;
    v30 = v31 >> 51;
    v32 = v27 & 0x7FFFFFFFFFFFFLL;
    v26 = __CFADD__(v30, v28);
    v33 = v30 + v28;
    if (v26)
      v34 = ((v60.u64[0] * (unsigned __int128)0x1DB42uLL) >> 64) + 1;
    else
      v34 = (v60.u64[0] * (unsigned __int128)0x1DB42uLL) >> 64;
    *((_QWORD *)&v36 + 1) = v34;
    *(_QWORD *)&v36 = v33;
    v35 = v36 >> 51;
    v26 = __CFADD__(v35, v24);
    v37 = v35 + v24;
    if (v26)
      ++v23;
    *((_QWORD *)&v39 + 1) = v23;
    *(_QWORD *)&v39 = v37;
    v38 = v39 >> 51;
    v40 = v33 & 0x7FFFFFFFFFFFFLL;
    v26 = __CFADD__(v38, v22);
    v41 = v38 + v22;
    if (v26)
      ++v21;
    *((_QWORD *)&v42 + 1) = v21;
    *(_QWORD *)&v42 = v41;
    v43.i64[0] = v37;
    v43.i64[1] = v41;
    v44 = ((121666 * v59.i64[0]) & 0x7FFFFFFFFFFFELL) + 19 * (v42 >> 51);
    v45 = v44 & 0x7FFFFFFFFFFFFLL;
    v46 = v32 + (v44 >> 51);
    v74 = v45;
    *(_QWORD *)&v75 = v46 & 0x7FFFFFFFFFFFFLL;
    *((_QWORD *)&v75 + 1) = v40 + (v46 >> 51);
    v76 = vandq_s8(v43, v58);
    do
    {
      if (*(unint64_t *)((char *)&v74 + v20) >= 0x8CCCCCCCCCCCDLL)
        X25519_cold_2();
      v20 += 8;
    }
    while (v20 != 40);
    fe_sq_tl((uint64_t)v77, (unint64_t *)v64);
    fe_add(v62, v72, (int64x2_t *)&v74);
    fe_mul_impl((uint64_t)&v74, (unint64_t *)&v85, (unint64_t *)&v79);
    fe_mul_impl((uint64_t)&v79, (unint64_t *)&v59, (unint64_t *)v62);
    v7 = v9 - 1;
  }
  while (v9);
  v47 = 0;
  v48 = -(uint64_t)v6;
  do
  {
    v49 = *(unint64_t *)((char *)&v82 + v47 * 8);
    v50 = v77[0].i64[v47];
    v51 = (v50 ^ v49) & v48;
    *(unint64_t *)((char *)&v82 + v47 * 8) = v51 ^ v49;
    v77[0].i64[v47++] = v51 ^ v50;
  }
  while (v47 != 5);
  for (k = 0; k != 5; ++k)
  {
    v53 = v79.i64[k];
    v54 = *(uint64_t *)((char *)&v74 + k * 8);
    v55 = (v54 ^ v53) & v48;
    v79.i64[k] = v55 ^ v53;
    *(uint64_t *)((char *)&v74 + k * 8) = v55 ^ v54;
  }
  v90 = v79;
  v91 = v80;
  v92 = v81;
  fe_loose_invert((uint64_t)&v79, (unint64_t *)&v90);
  fe_mul_impl((uint64_t)&v82, &v82, (unint64_t *)&v79);
  fe_tobytes(a1, &v82);
  return CRYPTO_memcmp(X25519_kZeros, a1, 32) != 0;
}

uint64_t fe_mul_impl(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  uint64_t i;
  uint64_t j;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  signed __int128 v17;
  unsigned __int128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int128 v29;
  unsigned __int128 v30;
  uint64_t v31;
  unsigned __int128 v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  unint64_t v37;
  int8x16_t v38;
  uint64_t v39;
  unint64_t v40;

  for (i = 0; i != 5; ++i)
  {
    if (a2[i] > 0x1A666666666664)
      fe_mul_impl_cold_1();
  }
  for (j = 0; j != 5; ++j)
  {
    if (a3[j] > 0x1A666666666664)
      fe_mul_impl_cold_2();
  }
  v5 = 0;
  v6 = a2[4];
  v8 = a3[3];
  v7 = a3[4];
  v10 = a3[1];
  v9 = a3[2];
  v11 = *a3;
  v12 = a2[2];
  v13 = a2[3];
  v14 = *a2;
  v15 = a2[1];
  v17 = v13 * (unsigned __int128)(19 * v9)
      + 19 * v10 * (unsigned __int128)v6
      + v12 * (unsigned __int128)(19 * v8)
      + v15 * (unsigned __int128)(19 * v7)
      + v14 * (unsigned __int128)v11;
  v18 = v13 * (unsigned __int128)(19 * v7) + 19 * v8 * (unsigned __int128)v6;
  v19 = (v13 * (unsigned __int128)(19 * v8)
       + 19 * v9 * (unsigned __int128)v6
       + v12 * (unsigned __int128)(19 * v7)
       + v11 * (unsigned __int128)v15
       + v14 * (unsigned __int128)v10) >> 64;
  v20 = v13 * 19 * v8 + 19 * v9 * v6 + v12 * 19 * v7 + v11 * v15 + v14 * v10;
  v21 = v17 >> 51;
  v22 = __CFADD__(v20, v21);
  v23 = v20 + v21;
  if (v22)
    ++v19;
  *((_QWORD *)&v25 + 1) = v19;
  *(_QWORD *)&v25 = v23;
  v24 = v25 >> 51;
  v26 = (v18 + v15 * (unsigned __int128)v10 + v11 * (unsigned __int128)v12 + v14 * (unsigned __int128)v9) >> 64;
  v27 = v18 + v15 * v10 + v11 * v12 + v14 * v9;
  v22 = __CFADD__(v27, v24);
  v28 = v27 + v24;
  if (v22)
    ++v26;
  v29 = v12 * (unsigned __int128)v10
      + 19 * v7 * (unsigned __int128)v6
      + v15 * (unsigned __int128)v9
      + v11 * (unsigned __int128)v13
      + v14 * (unsigned __int128)v8;
  v30 = v12 * (unsigned __int128)v9
      + v13 * (unsigned __int128)v10
      + v15 * (unsigned __int128)v8
      + v11 * (unsigned __int128)v6;
  v32 = v30 + v14 * (unsigned __int128)v7;
  v31 = *((_QWORD *)&v32 + 1);
  *((_QWORD *)&v33 + 1) = v26;
  *(_QWORD *)&v33 = v28;
  v34 = v29 + (v33 >> 51);
  *((_QWORD *)&v33 + 1) = v30;
  *(_QWORD *)&v33 = v34;
  v35 = v33 >> 51;
  if (__CFADD__((_QWORD)v32, v35))
    v31 = *((_QWORD *)&v32 + 1) + 1;
  *((_QWORD *)&v36 + 1) = v31;
  *(_QWORD *)&v36 = v32 + v35;
  v37 = (v17 & 0x7FFFFFFFFFFFFLL) + 19 * (v36 >> 51);
  v38.i64[0] = v34;
  v38.i64[1] = v32 + v35;
  v39 = v37 & 0x7FFFFFFFFFFFFLL;
  v40 = (v23 & 0x7FFFFFFFFFFFFLL) + (v37 >> 51);
  *(_QWORD *)result = v39;
  *(_QWORD *)(result + 8) = v40 & 0x7FFFFFFFFFFFFLL;
  *(_QWORD *)(result + 16) = (v28 & 0x7FFFFFFFFFFFFLL) + (v40 >> 51);
  *(int8x16_t *)(result + 24) = vandq_s8(v38, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFuLL));
  do
  {
    if (*(_QWORD *)(result + v5) >= 0x8CCCCCCCCCCCDuLL)
      fe_mul_impl_cold_3();
    v5 += 8;
  }
  while (v5 != 40);
  return result;
}

int64x2_t *fe_add(int64x2_t *result, int64x2_t *a2, int64x2_t *a3)
{
  uint64_t i;
  uint64_t j;
  uint64_t v5;
  uint64_t v6;
  int64x2_t v7;

  for (i = 0; i != 5; ++i)
  {
    if (a2->i64[i] > 0x8CCCCCCCCCCCCuLL)
      fe_add_cold_1();
  }
  for (j = 0; j != 5; ++j)
  {
    if (a3->i64[j] > 0x8CCCCCCCCCCCCuLL)
      fe_add_cold_2();
  }
  v5 = 0;
  v6 = a3[2].i64[0] + a2[2].i64[0];
  v7 = vaddq_s64(a3[1], a2[1]);
  *result = vaddq_s64(*a3, *a2);
  result[1] = v7;
  result[2].i64[0] = v6;
  do
  {
    if (result->i64[v5] >= 0x1A666666666665uLL)
      fe_add_cold_3();
    ++v5;
  }
  while (v5 != 5);
  return result;
}

int64x2_t *fe_sub(int64x2_t *result, int64x2_t *a2, int64x2_t *a3)
{
  uint64_t i;
  uint64_t j;
  uint64_t v5;
  uint64_t v6;
  int64x2_t v7;

  for (i = 0; i != 5; ++i)
  {
    if (a2->i64[i] > 0x8CCCCCCCCCCCCuLL)
      fe_sub_cold_1();
  }
  for (j = 0; j != 5; ++j)
  {
    if (a3->i64[j] > 0x8CCCCCCCCCCCCuLL)
      fe_sub_cold_2();
  }
  v5 = 0;
  v6 = a2[2].i64[0] - a3[2].i64[0] + 0xFFFFFFFFFFFFELL;
  v7 = vaddq_s64(vsubq_s64(a2[1], a3[1]), vdupq_n_s64(0xFFFFFFFFFFFFEuLL));
  *result = vaddq_s64(vsubq_s64(*a2, *a3), (int64x2_t)xmmword_1B501A4D0);
  result[1] = v7;
  result[2].i64[0] = v6;
  do
  {
    if (result->i64[v5] >= 0x1A666666666665uLL)
      fe_sub_cold_3();
    ++v5;
  }
  while (v5 != 5);
  return result;
}

uint64_t fe_sq_tl(uint64_t result, unint64_t *a2)
{
  uint64_t i;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  signed __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int128 v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  unint64_t v37;
  int8x16_t v38;
  unint64_t v39;

  for (i = 0; i != 5; ++i)
  {
    if (a2[i] >= 0x1A666666666665)
      fe_sq_tl_cold_1();
  }
  v3 = 0;
  v5 = a2[3];
  v4 = a2[4];
  v6 = a2[1];
  v7 = a2[2];
  v8 = 2 * v7;
  v9 = *a2;
  v10 = (v5 * (unsigned __int128)(38 * v4)) >> 64;
  v11 = v5 * 38 * v4;
  v12 = (v7 * (unsigned __int128)(38 * v4)) >> 64;
  v13 = v7 * 38 * v4;
  v14 = v6 * (unsigned __int128)(38 * v4) + v7 * (unsigned __int128)(38 * v5) + v9 * (unsigned __int128)v9;
  v15 = (v6 * (unsigned __int128)(2 * v5) + v7 * (unsigned __int128)v7 + v9 * (unsigned __int128)(2 * v4)) >> 64;
  v16 = v6 * 2 * v5 + v7 * v7 + v9 * 2 * v4;
  v19 = v6 * (unsigned __int128)(2 * v7) + 19 * v4 * (unsigned __int128)v4 + v9 * (unsigned __int128)(2 * v5);
  v18 = v19 >> 64;
  v17 = v19;
  v21 = v6 * v6 + v11 + v9 * v8;
  v20 = (v6 * (unsigned __int128)v6 + __PAIR128__(v10, v11) + v9 * (unsigned __int128)(unint64_t)v8) >> 64;
  v23 = __PAIR128__(v12, v13) + 19 * v5 * (unsigned __int128)v5 + v9 * (unsigned __int128)(2 * v6);
  v22 = *((_QWORD *)&v23 + 1);
  v24 = v14 >> 51;
  if (__CFADD__((_QWORD)v23, v24))
    v22 = *((_QWORD *)&v23 + 1) + 1;
  *((_QWORD *)&v26 + 1) = v22;
  *(_QWORD *)&v26 = v23 + v24;
  v25 = v26 >> 51;
  v27 = __CFADD__(v21, v25);
  v28 = v21 + v25;
  if (v27)
    ++v20;
  *((_QWORD *)&v30 + 1) = v20;
  *(_QWORD *)&v30 = v28;
  v29 = v30 >> 51;
  v27 = __CFADD__(v17, v29);
  v31 = v17 + v29;
  if (v27)
    v32 = v18 + 1;
  else
    v32 = v18;
  *((_QWORD *)&v34 + 1) = v32;
  *(_QWORD *)&v34 = v31;
  v33 = v34 >> 51;
  v27 = __CFADD__(v16, v33);
  v35 = v16 + v33;
  if (v27)
    ++v15;
  *((_QWORD *)&v36 + 1) = v15;
  *(_QWORD *)&v36 = v35;
  v37 = (v14 & 0x7FFFFFFFFFFFFLL) + 19 * (v36 >> 51);
  v38.i64[0] = v31;
  v38.i64[1] = v35;
  v39 = ((v23 + v24) & 0x7FFFFFFFFFFFFLL) + (v37 >> 51);
  *(_QWORD *)result = v37 & 0x7FFFFFFFFFFFFLL;
  *(_QWORD *)(result + 8) = v39 & 0x7FFFFFFFFFFFFLL;
  *(_QWORD *)(result + 16) = (v28 & 0x7FFFFFFFFFFFFLL) + (v39 >> 51);
  *(int8x16_t *)(result + 24) = vandq_s8(v38, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFuLL));
  do
  {
    if (*(_QWORD *)(result + v3) >= 0x8CCCCCCCCCCCDuLL)
      fe_sq_tl_cold_2();
    v3 += 8;
  }
  while (v3 != 40);
  return result;
}

_BYTE *X25519_public_from_private(_BYTE *a1, uint64_t a2)
{
  __int128 v3;
  __int128 v4;
  int64x2_t v5;
  _OWORD v7[2];
  unint64_t v8;
  int64x2_t v9[2];
  unint64_t v10;
  int64x2_t v11[2];
  unint64_t v12;
  __int128 v13[2];
  _OWORD v14[3];
  int64x2_t v15[5];
  int8x16_t v16;
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v3 = *(_OWORD *)(a2 + 16);
  v16 = *(int8x16_t *)a2;
  v17 = v3;
  v16.i8[0] &= 0xF8u;
  HIBYTE(v17) = HIBYTE(v3) & 0x3F | 0x40;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v15[3] = (int64x2_t)v4;
  v15[4] = (int64x2_t)v4;
  v15[1] = (int64x2_t)v4;
  v15[2] = (int64x2_t)v4;
  v14[2] = v4;
  v15[0] = (int64x2_t)v4;
  v14[0] = v4;
  v14[1] = v4;
  v13[0] = v4;
  v13[1] = v4;
  x25519_ge_scalarmult_base(v13, &v16);
  v12 = 0xAAAAAAAAAAAAAAAALL;
  v5.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v5.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = v5;
  v11[1] = v5;
  v10 = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = v5;
  v9[1] = v5;
  v8 = 0xAAAAAAAAAAAAAAAALL;
  v7[0] = v5;
  v7[1] = v5;
  fe_add(v11, v15, (int64x2_t *)((char *)v14 + 8));
  fe_sub(v9, v15, (int64x2_t *)((char *)v14 + 8));
  fe_loose_invert((uint64_t)v7, (unint64_t *)v9);
  fe_mul_impl((uint64_t)v7, (unint64_t *)v11, (unint64_t *)v7);
  return fe_tobytes(a1, v7);
}

_BYTE *fe_tobytes(_BYTE *result, _QWORD *a2)
{
  uint64_t i;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  for (i = 0; i != 5; ++i)
  {
    if (a2[i] >= 0x8CCCCCCCCCCCDuLL)
      fe_tobytes_cold_1();
  }
  v3 = *a2 - 0x7FFFFFFFFFFEDLL;
  v4 = a2[1] - -(uint64_t)(v3 >> 51) - 0x7FFFFFFFFFFFFLL;
  v5 = a2[2] - -(uint64_t)(v4 >> 51) - 0x7FFFFFFFFFFFFLL;
  v6 = a2[3] - -(uint64_t)(v5 >> 51) - 0x7FFFFFFFFFFFFLL;
  v7 = v3 & 0x7FFFFFFFFFFFFLL;
  v8 = v4 & 0x7FFFFFFFFFFFFLL;
  v9 = v5 & 0x7FFFFFFFFFFFFLL;
  v10 = v6 & 0x7FFFFFFFFFFFFLL;
  v11 = a2[4] - -(uint64_t)(v6 >> 51) - 0x7FFFFFFFFFFFFLL;
  if ((v11 & 0x7F8000000000000) != 0)
    v12 = -1;
  else
    v12 = 0;
  v13 = (v12 & 0x7FFFFFFFFFFEDLL) + v7;
  result[1] = BYTE1(v13);
  result[2] = BYTE2(v13);
  result[3] = (unint64_t)((v12 & 0xFFFFFFED) + v7) >> 24;
  result[4] = BYTE4(v13);
  result[5] = BYTE5(v13);
  v14 = (v12 & 0x7FFFFFFFFFFFFLL) + v8 + (v13 >> 51);
  *result = v13;
  result[6] = BYTE6(v13) & 7 | (8 * (v12 + v8 + (v13 >> 51)));
  result[7] = v14 >> 5;
  result[8] = v14 >> 13;
  result[9] = v14 >> 21;
  result[10] = v14 >> 29;
  result[11] = v14 >> 37;
  v15 = v9 + (v12 & 0x7FFFFFFFFFFFFLL) + (v14 >> 51);
  result[12] = (v14 >> 45) & 0x3F | (((_BYTE)v9 + (_BYTE)v12 + (v14 >> 51)) << 6);
  result[13] = v15 >> 2;
  result[14] = v15 >> 10;
  result[15] = v15 >> 18;
  result[16] = v15 >> 26;
  result[17] = v15 >> 34;
  result[18] = v15 >> 42;
  v16 = v10 + (v12 & 0x7FFFFFFFFFFFFLL) + (v15 >> 51);
  result[19] = ((v15 & 0x4000000000000) != 0) | (2 * (v10 + v12 + (v15 >> 51)));
  result[20] = v16 >> 7;
  result[21] = v16 >> 15;
  result[22] = v16 >> 23;
  result[23] = v16 >> 31;
  result[24] = v16 >> 39;
  v17 = v11 + v12 + (v16 >> 51);
  result[25] = (v16 >> 47) & 0xF | (16 * v17);
  result[26] = v17 >> 4;
  result[27] = v17 >> 12;
  result[28] = v17 >> 20;
  result[29] = v17 >> 28;
  result[30] = v17 >> 36;
  result[31] = (v17 >> 44) & 0x7F;
  return result;
}

uint64_t x25519_ge_scalarmult_base(__int128 *a1, int8x16_t *a2)
{
  uint64_t v3;
  __int128 v4;
  int8x16_t v5;
  int8x16_t v6;
  char *v7;
  uint64_t v8;
  int v9;
  int v10;
  __int128 v11;
  int v12;
  unint64_t v13;
  BOOL v14;
  __int128 v15;
  int v16;
  unint64_t v17;
  uint64_t result;
  _OWORD v19[7];
  unint64_t v20;
  _OWORD v21[7];
  unint64_t v22;
  _OWORD v23[10];
  _OWORD v24[7];
  unint64_t v25;
  _OWORD v26[3];
  __int128 v27;
  uint64_t v28;
  int8x16x2_t v29;

  v3 = 0;
  v28 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v26[2] = v4;
  v27 = v4;
  v26[0] = v4;
  v26[1] = v4;
  v5.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v5.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  do
  {
    v6 = *a2++;
    v29.val[0] = vandq_s8(v6, v5);
    v29.val[1] = (int8x16_t)vshrq_n_u8((uint8x16_t)v6, 4uLL);
    v7 = (char *)&v26[v3];
    vst2q_s8(v7, v29);
    v3 += 2;
  }
  while (v3 != 4);
  v8 = 0;
  v9 = 0;
  do
  {
    v10 = *((unsigned __int8 *)v26 + v8) + v9;
    v9 = (v10 + 8) << 24 >> 28;
    *((_BYTE *)v26 + v8++) = v10 - ((v10 + 8) & 0xF0);
  }
  while (v8 != 63);
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[8] = v11;
  v23[9] = v11;
  v23[6] = v11;
  v23[7] = v11;
  v23[4] = v11;
  v23[5] = v11;
  v23[2] = v11;
  v23[3] = v11;
  v23[0] = v11;
  v23[1] = v11;
  v19[0] = v11;
  v19[1] = v11;
  v19[2] = v11;
  v19[3] = v11;
  v19[4] = v11;
  v19[5] = v11;
  v19[6] = v11;
  v20 = 0xAAAAAAAAAAAAAAAALL;
  HIBYTE(v27) += v9;
  ge_p3_0((uint64_t)a1);
  v12 = 0;
  v13 = 1;
  do
  {
    table_select((uint64_t)v19, v12, *((char *)v26 + v13));
    ge_madd((uint64_t)v23, (uint64_t)a1, (unint64_t *)v19);
    x25519_ge_p1p1_to_p3((uint64_t)a1, (unint64_t *)v23);
    ++v12;
    v14 = v13 >= 0x3E;
    v13 += 2;
  }
  while (!v14);
  v22 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v21[5] = v15;
  v21[6] = v15;
  v21[3] = v15;
  v21[4] = v15;
  v21[1] = v15;
  v21[2] = v15;
  v21[0] = v15;
  v25 = 0xAAAAAAAAAAAAAAAALL;
  v24[5] = v15;
  v24[6] = v15;
  v24[3] = v15;
  v24[4] = v15;
  v24[1] = v15;
  v24[2] = v15;
  v24[0] = v15;
  ge_p3_to_p2((uint64_t)v24, a1);
  ge_p2_dbl((uint64_t)v23, (uint64_t)v24);
  x25519_ge_p1p1_to_p2((uint64_t)v21, (unint64_t *)v23);
  ge_p2_dbl((uint64_t)v23, (uint64_t)v21);
  x25519_ge_p1p1_to_p2((uint64_t)v21, (unint64_t *)v23);
  ge_p2_dbl((uint64_t)v23, (uint64_t)v21);
  x25519_ge_p1p1_to_p2((uint64_t)v21, (unint64_t *)v23);
  ge_p2_dbl((uint64_t)v23, (uint64_t)v21);
  x25519_ge_p1p1_to_p3((uint64_t)a1, (unint64_t *)v23);
  v16 = 0;
  v17 = 0;
  do
  {
    table_select((uint64_t)v19, v16, *((char *)v26 + v17));
    ge_madd((uint64_t)v23, (uint64_t)a1, (unint64_t *)v19);
    result = x25519_ge_p1p1_to_p3((uint64_t)a1, (unint64_t *)v23);
    ++v16;
    v14 = v17 >= 0x3E;
    v17 += 2;
  }
  while (!v14);
  return result;
}

uint64_t x25519_ge_p1p1_to_p3(uint64_t a1, unint64_t *a2)
{
  unint64_t *v4;

  v4 = a2 + 15;
  fe_mul_impl(a1, a2, a2 + 15);
  fe_mul_impl(a1 + 40, a2 + 5, a2 + 10);
  fe_mul_impl(a1 + 80, a2 + 10, v4);
  return fe_mul_impl(a1 + 120, a2, a2 + 5);
}

uint64_t table_select(uint64_t a1, int a2, int a3)
{
  unsigned int v5;
  int v6;
  char *v7;
  __int128 v8;
  __int128 v9;
  int64x2_t v10;
  int64x2_t v12[2];
  unint64_t v13;
  _OWORD v14[2];
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  int64x2_t v19[2];
  unint64_t v20;

  v5 = (a3 >> 7) & 1;
  v6 = a3 - 2 * (a3 & (a3 >> 31));
  ge_precomp_0(a1);
  v7 = (char *)&k25519Precomp + 960 * a2;
  cmov(a1, (uint64_t)v7, ((v6 ^ 1u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 120), ((v6 ^ 2u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 240), ((v6 ^ 3u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 360), ((v6 ^ 4u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 480), ((v6 ^ 5u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 600), ((v6 ^ 6u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 720), ((v6 ^ 7u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 840), ((v6 ^ 8u) - 1) >> 31);
  v8 = *(_OWORD *)(a1 + 56);
  v14[0] = *(_OWORD *)(a1 + 40);
  v14[1] = v8;
  v15 = *(_QWORD *)(a1 + 72);
  v9 = *(_OWORD *)(a1 + 16);
  v16 = *(_OWORD *)a1;
  v10.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v10.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v19[0] = v10;
  v19[1] = v10;
  v20 = 0xAAAAAAAAAAAAAAAALL;
  v17 = v9;
  v18 = *(_QWORD *)(a1 + 32);
  v13 = 0xAAAAAAAAAAAAAAAALL;
  v12[0] = v10;
  v12[1] = v10;
  fe_carry((unint64_t *)v12, (_QWORD *)(a1 + 80));
  fe_neg(v19, v12);
  return cmov(a1, (uint64_t)v14, v5);
}

uint64_t cmov(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t i;
  uint64_t j;
  uint64_t k;

  for (i = 0; i != 40; i += 8)
    *(_QWORD *)(result + i) = *(_QWORD *)(a2 + i) & -(uint64_t)a3 | *(_QWORD *)(result + i) & (a3 - 1);
  for (j = 0; j != 40; j += 8)
    *(_QWORD *)(result + 40 + j) = *(_QWORD *)(a2 + 40 + j) & -(uint64_t)a3 | *(_QWORD *)(result + 40 + j) & (a3 - 1);
  for (k = 0; k != 40; k += 8)
    *(_QWORD *)(result + 80 + k) = *(_QWORD *)(a2 + 80 + k) & -(uint64_t)a3 | *(_QWORD *)(result + 80 + k) & (a3 - 1);
  return result;
}

double ge_precomp_0(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)a1 = 1;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_QWORD *)(a1 + 112) = 0;
  return result;
}

int64x2_t *ge_madd(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  int64x2_t v6;
  int64x2_t *v7;
  int64x2_t v9[2];
  unint64_t v10;
  int64x2_t v11[2];
  unint64_t v12;
  int64x2_t v13[2];
  unint64_t v14;

  v14 = 0xAAAAAAAAAAAAAAAALL;
  v6.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v13[0] = v6;
  v13[1] = v6;
  v12 = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = v6;
  v11[1] = v6;
  v7 = (int64x2_t *)(a2 + 40);
  v10 = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = v6;
  v9[1] = v6;
  fe_add((int64x2_t *)a1, (int64x2_t *)(a2 + 40), (int64x2_t *)a2);
  fe_sub((int64x2_t *)(a1 + 40), v7, (int64x2_t *)a2);
  fe_mul_impl((uint64_t)v11, (unint64_t *)a1, a3);
  fe_mul_impl((uint64_t)v13, (unint64_t *)(a1 + 40), a3 + 5);
  fe_mul_impl((uint64_t)v9, a3 + 10, (unint64_t *)(a2 + 120));
  fe_add((int64x2_t *)(a1 + 120), (int64x2_t *)(a2 + 80), (int64x2_t *)(a2 + 80));
  fe_sub((int64x2_t *)a1, v11, v13);
  fe_add((int64x2_t *)(a1 + 40), v11, v13);
  fe_carry((unint64_t *)v11, (_QWORD *)(a1 + 120));
  fe_add((int64x2_t *)(a1 + 80), v11, v9);
  return fe_sub((int64x2_t *)(a1 + 120), v11, v9);
}

unint64_t *fe_carry(unint64_t *result, _QWORD *a2)
{
  uint64_t i;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  for (i = 0; i != 5; ++i)
  {
    if (a2[i] >= 0x1A666666666665uLL)
      fe_carry_cold_1();
  }
  v3 = 0;
  v4 = a2[1] + (*a2 >> 51);
  v5 = a2[2] + (v4 >> 51);
  v6 = a2[3] + (v5 >> 51);
  v7 = a2[4] + (v6 >> 51);
  v8 = (*a2 & 0x7FFFFFFFFFFFFLL) + 19 * (v7 >> 51);
  v9 = (v4 & 0x7FFFFFFFFFFFFLL) + (v8 >> 51);
  *result = v8 & 0x7FFFFFFFFFFFFLL;
  result[1] = v9 & 0x7FFFFFFFFFFFFLL;
  result[2] = (v5 & 0x7FFFFFFFFFFFFLL) + (v9 >> 51);
  result[3] = v6 & 0x7FFFFFFFFFFFFLL;
  result[4] = v7 & 0x7FFFFFFFFFFFFLL;
  do
  {
    if (result[v3] >= 0x8CCCCCCCCCCCDLL)
      fe_carry_cold_2();
    ++v3;
  }
  while (v3 != 5);
  return result;
}

int64x2_t *fe_neg(int64x2_t *result, int64x2_t *a2)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  int64x2_t v5;

  for (i = 0; i != 5; ++i)
  {
    if (a2->i64[i] >= 0x8CCCCCCCCCCCDuLL)
      fe_neg_cold_1();
  }
  v3 = 0;
  v4 = 0xFFFFFFFFFFFFELL - a2[2].i64[0];
  v5 = vsubq_s64(vdupq_n_s64(0xFFFFFFFFFFFFEuLL), a2[1]);
  *result = vsubq_s64((int64x2_t)xmmword_1B501A4D0, *a2);
  result[1] = v5;
  result[2].i64[0] = v4;
  do
  {
    if (result->i64[v3] >= 0x1A666666666665uLL)
      fe_neg_cold_2();
    ++v3;
  }
  while (v3 != 5);
  return result;
}

int64x2_t *ge_p2_dbl(uint64_t a1, uint64_t a2)
{
  int64x2_t v4;
  int64x2_t v5;
  int64x2_t v7[2];
  unint64_t v8;
  int64x2_t v9[2];
  unint64_t v10;
  int64x2_t v11[2];
  unint64_t v12;
  int64x2_t v13[2];
  unint64_t v14;
  int64x2_t v15[2];
  unint64_t v16;

  v14 = 0xAAAAAAAAAAAAAAAALL;
  v4.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v4.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v13[0] = v4;
  v13[1] = v4;
  v12 = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = v4;
  v11[1] = v4;
  v10 = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = v4;
  v9[1] = v4;
  v8 = 0xAAAAAAAAAAAAAAAALL;
  v7[0] = v4;
  v7[1] = v4;
  fe_sq_tt((uint64_t)v13, (unint64_t *)a2);
  fe_sq_tt((uint64_t)v11, (unint64_t *)(a2 + 40));
  fe_sq_tt((uint64_t)v9, (unint64_t *)(a2 + 80));
  v16 = 0xAAAAAAAAAAAAAAAALL;
  v5.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v5.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v15[0] = v5;
  v15[1] = v5;
  fe_add(v15, v9, v9);
  fe_carry((unint64_t *)v9, v15);
  fe_add((int64x2_t *)(a1 + 40), (int64x2_t *)a2, (int64x2_t *)(a2 + 40));
  fe_sq_tl((uint64_t)v7, (unint64_t *)(a1 + 40));
  fe_add((int64x2_t *)(a1 + 40), v11, v13);
  fe_sub((int64x2_t *)(a1 + 80), v11, v13);
  fe_carry((unint64_t *)v11, (_QWORD *)(a1 + 40));
  fe_sub((int64x2_t *)a1, v7, v11);
  fe_carry((unint64_t *)v11, (_QWORD *)(a1 + 80));
  return fe_sub((int64x2_t *)(a1 + 120), v9, v11);
}

uint64_t x25519_ge_p1p1_to_p2(uint64_t a1, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t *v4;
  unint64_t *v5;

  v2 = a2;
  v4 = a2 + 15;
  fe_mul_impl(a1, a2, a2 + 15);
  v5 = v2 + 5;
  v2 += 10;
  fe_mul_impl(a1 + 40, v5, v2);
  return fe_mul_impl(a1 + 80, v2, v4);
}

uint64_t fe_loose_invert(uint64_t a1, unint64_t *a2)
{
  __int128 v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  _OWORD v14[2];
  unint64_t v15;
  _OWORD v16[2];
  unint64_t v17;
  _OWORD v18[2];
  unint64_t v19;
  _OWORD v20[2];
  unint64_t v21;

  v21 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[0] = v4;
  v20[1] = v4;
  v19 = 0xAAAAAAAAAAAAAAAALL;
  v18[0] = v4;
  v18[1] = v4;
  v17 = 0xAAAAAAAAAAAAAAAALL;
  v16[0] = v4;
  v16[1] = v4;
  v15 = 0xAAAAAAAAAAAAAAAALL;
  v14[0] = v4;
  v14[1] = v4;
  fe_sq_tl((uint64_t)v20, a2);
  fe_sq_tt((uint64_t)v18, (unint64_t *)v20);
  fe_sq_tt((uint64_t)v18, (unint64_t *)v18);
  fe_mul_impl((uint64_t)v18, a2, (unint64_t *)v18);
  fe_mul_impl((uint64_t)v20, (unint64_t *)v20, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v20);
  fe_mul_impl((uint64_t)v18, (unint64_t *)v18, (unint64_t *)v16);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v18);
  v5 = 4;
  do
  {
    fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
    --v5;
  }
  while (v5);
  fe_mul_impl((uint64_t)v18, (unint64_t *)v16, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v18);
  v6 = 9;
  do
  {
    fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
    --v6;
  }
  while (v6);
  fe_mul_impl((uint64_t)v16, (unint64_t *)v16, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v14, (unint64_t *)v16);
  v7 = 19;
  do
  {
    fe_sq_tt((uint64_t)v14, (unint64_t *)v14);
    --v7;
  }
  while (v7);
  fe_mul_impl((uint64_t)v16, (unint64_t *)v14, (unint64_t *)v16);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
  v8 = 9;
  do
  {
    fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
    --v8;
  }
  while (v8);
  fe_mul_impl((uint64_t)v18, (unint64_t *)v16, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v18);
  v9 = 49;
  do
  {
    fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
    --v9;
  }
  while (v9);
  fe_mul_impl((uint64_t)v16, (unint64_t *)v16, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v14, (unint64_t *)v16);
  v10 = 99;
  do
  {
    fe_sq_tt((uint64_t)v14, (unint64_t *)v14);
    --v10;
  }
  while (v10);
  fe_mul_impl((uint64_t)v16, (unint64_t *)v14, (unint64_t *)v16);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
  v11 = 49;
  do
  {
    fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
    --v11;
  }
  while (v11);
  fe_mul_impl((uint64_t)v18, (unint64_t *)v16, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v18, (unint64_t *)v18);
  v12 = 4;
  do
  {
    fe_sq_tt((uint64_t)v18, (unint64_t *)v18);
    --v12;
  }
  while (v12);
  return fe_mul_impl(a1, (unint64_t *)v18, (unint64_t *)v20);
}

uint64_t fe_sq_tt(uint64_t result, unint64_t *a2)
{
  uint64_t i;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  signed __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int128 v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  unint64_t v37;
  int8x16_t v38;
  unint64_t v39;

  for (i = 0; i != 5; ++i)
  {
    if (a2[i] >= 0x1A666666666665)
      fe_sq_tt_cold_1();
  }
  v3 = 0;
  v5 = a2[3];
  v4 = a2[4];
  v6 = a2[1];
  v7 = a2[2];
  v8 = 2 * v7;
  v9 = *a2;
  v10 = (v5 * (unsigned __int128)(38 * v4)) >> 64;
  v11 = v5 * 38 * v4;
  v12 = (v7 * (unsigned __int128)(38 * v4)) >> 64;
  v13 = v7 * 38 * v4;
  v14 = v6 * (unsigned __int128)(38 * v4) + v7 * (unsigned __int128)(38 * v5) + v9 * (unsigned __int128)v9;
  v15 = (v6 * (unsigned __int128)(2 * v5) + v7 * (unsigned __int128)v7 + v9 * (unsigned __int128)(2 * v4)) >> 64;
  v16 = v6 * 2 * v5 + v7 * v7 + v9 * 2 * v4;
  v19 = v6 * (unsigned __int128)(2 * v7) + 19 * v4 * (unsigned __int128)v4 + v9 * (unsigned __int128)(2 * v5);
  v18 = v19 >> 64;
  v17 = v19;
  v21 = v6 * v6 + v11 + v9 * v8;
  v20 = (v6 * (unsigned __int128)v6 + __PAIR128__(v10, v11) + v9 * (unsigned __int128)(unint64_t)v8) >> 64;
  v23 = __PAIR128__(v12, v13) + 19 * v5 * (unsigned __int128)v5 + v9 * (unsigned __int128)(2 * v6);
  v22 = *((_QWORD *)&v23 + 1);
  v24 = v14 >> 51;
  if (__CFADD__((_QWORD)v23, v24))
    v22 = *((_QWORD *)&v23 + 1) + 1;
  *((_QWORD *)&v26 + 1) = v22;
  *(_QWORD *)&v26 = v23 + v24;
  v25 = v26 >> 51;
  v27 = __CFADD__(v21, v25);
  v28 = v21 + v25;
  if (v27)
    ++v20;
  *((_QWORD *)&v30 + 1) = v20;
  *(_QWORD *)&v30 = v28;
  v29 = v30 >> 51;
  v27 = __CFADD__(v17, v29);
  v31 = v17 + v29;
  if (v27)
    v32 = v18 + 1;
  else
    v32 = v18;
  *((_QWORD *)&v34 + 1) = v32;
  *(_QWORD *)&v34 = v31;
  v33 = v34 >> 51;
  v27 = __CFADD__(v16, v33);
  v35 = v16 + v33;
  if (v27)
    ++v15;
  *((_QWORD *)&v36 + 1) = v15;
  *(_QWORD *)&v36 = v35;
  v37 = (v14 & 0x7FFFFFFFFFFFFLL) + 19 * (v36 >> 51);
  v38.i64[0] = v31;
  v38.i64[1] = v35;
  v39 = ((v23 + v24) & 0x7FFFFFFFFFFFFLL) + (v37 >> 51);
  *(_QWORD *)result = v37 & 0x7FFFFFFFFFFFFLL;
  *(_QWORD *)(result + 8) = v39 & 0x7FFFFFFFFFFFFLL;
  *(_QWORD *)(result + 16) = (v28 & 0x7FFFFFFFFFFFFLL) + (v39 >> 51);
  *(int8x16_t *)(result + 24) = vandq_s8(v38, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFuLL));
  do
  {
    if (*(_QWORD *)(result + v3) >= 0x8CCCCCCCCCCCDuLL)
      fe_sq_tt_cold_2();
    v3 += 8;
  }
  while (v3 != 40);
  return result;
}

double ge_p3_0(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 1;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_QWORD *)(a1 + 152) = 0;
  return result;
}

__n128 ge_p3_to_p2(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __n128 result;
  __int128 v7;

  v2 = *a2;
  v3 = a2[1];
  *(_QWORD *)(a1 + 32) = *((_QWORD *)a2 + 4);
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  v4 = *(__int128 *)((char *)a2 + 40);
  v5 = *(__int128 *)((char *)a2 + 56);
  *(_QWORD *)(a1 + 72) = *((_QWORD *)a2 + 9);
  *(_OWORD *)(a1 + 56) = v5;
  *(_OWORD *)(a1 + 40) = v4;
  result = (__n128)a2[5];
  v7 = a2[6];
  *(_QWORD *)(a1 + 112) = *((_QWORD *)a2 + 14);
  *(__n128 *)(a1 + 80) = result;
  *(_OWORD *)(a1 + 96) = v7;
  return result;
}

unint64_t *fe_frombytes_strict(unint64_t *result, unsigned int *a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v2 = *((char *)a2 + 31);
  if (v2 < 0)
    fe_frombytes_strict_cold_1();
  v3 = 0;
  v4 = *((unsigned __int8 *)a2 + 30);
  v5 = *((unsigned __int8 *)a2 + 6);
  v6 = ((unint64_t)*((unsigned __int8 *)a2 + 5) << 40) & 0xFFF8FFFFFFFFFFFFLL | ((v5 & 7) << 48) | *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32);
  v7 = *((unsigned __int8 *)a2 + 12);
  v8 = *((unsigned __int8 *)a2 + 29);
  v9 = *((unsigned __int8 *)a2 + 28);
  v10 = *((unsigned __int8 *)a2 + 27);
  v11 = *((unsigned __int8 *)a2 + 26);
  v12 = *(unsigned int *)((char *)a2 + 22);
  v13 = ((v7 & 0x3F) << 45) | ((unint64_t)*((unsigned __int8 *)a2 + 11) << 37) | ((unint64_t)*((unsigned __int8 *)a2 + 10) << 29) | ((unint64_t)*((unsigned __int8 *)a2 + 9) << 21) | ((unint64_t)*((unsigned __int8 *)a2 + 8) << 13) | (32 * *((unsigned __int8 *)a2 + 7)) | (v5 >> 3);
  v14 = a2[4];
  v15 = ((v14 & 0x1FFFFFF) << 26) | ((unint64_t)*((unsigned __int8 *)a2 + 15) << 18) | ((unint64_t)*((unsigned __int8 *)a2 + 14) << 10) | (4 * *((unsigned __int8 *)a2 + 13)) | (v7 >> 6);
  v16 = ((v12 & 0xFFFFFFF) << 23) | ((unint64_t)*((unsigned __int8 *)a2 + 21) << 15) | ((unint64_t)*((unsigned __int8 *)a2 + 20) << 7) | (v14 >> 25);
  *result = v6;
  result[1] = v13;
  result[2] = v15;
  result[3] = v16;
  result[4] = ((unint64_t)v2 << 44) | (v4 << 36) | (v8 << 28) | (v9 << 20) | (v10 << 12) | (16 * v11) | (v12 >> 28);
  do
  {
    if (result[v3] >= 0x8CCCCCCCCCCCDLL)
      fe_frombytes_strict_cold_2();
    ++v3;
  }
  while (v3 != 5);
  return result;
}

void *nw_protocol_boringssl_copy_options(uint64_t a1, uint64_t a2)
{
  void *v3;

  v3 = malloc_type_calloc(1uLL, 0x170uLL, 0x95F2CF9BuLL);
  nw_protocol_boringssl_copy_options_contents((uint64_t)v3, a2);
  return v3;
}

void nw_protocol_boringssl_copy_options_contents(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  const char *v38;
  const char *v39;
  void *v40;
  void *v41;
  xpc_object_t v42;
  void *v43;
  void *v44;
  xpc_object_t v45;
  void *v46;
  void *v47;
  xpc_object_t v48;
  void *v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  void *v53;
  uint64_t v54;
  void *v55;
  void *v56;
  uint64_t v57;
  void *v58;
  void *v59;
  xpc_object_t v60;
  void *v61;
  void *v62;
  void *v63;
  uint64_t v64;
  void *v65;
  uint64_t v66;
  void *v67;
  void *v68;
  uint64_t v69;
  void *v70;
  void *v71;
  uint64_t v72;
  void *v73;
  void *v74;
  uint64_t v75;
  void *v76;
  void *v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  void *v81;
  void *v82;
  void *v83;
  const __CFArray *v84;
  CFAllocatorRef *v85;
  const __CFArray *v86;

  if (a1 && a2)
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    v4 = *(_DWORD *)(a1 + 361) & 0xFFFFFFFE | ((unint64_t)*(unsigned __int8 *)(a1 + 365) << 32) | *(_DWORD *)(a2 + 361) & 1;
    *(_DWORD *)(a1 + 361) = *(_DWORD *)(a1 + 361) & 0xFFFFFFFE | *(_DWORD *)(a2 + 361) & 1;
    v5 = v4 & 0xFFFFFFFFFFFFFFF7 | (8 * (((unint64_t)*(unsigned int *)(a2 + 361) >> 3) & 1));
    *(_DWORD *)(a1 + 361) = v5;
    v6 = v5 & 0xFFFFFFFFFFFFFFEFLL | (16 * (((unint64_t)*(unsigned int *)(a2 + 361) >> 4) & 1));
    *(_DWORD *)(a1 + 361) = v6;
    v7 = v6 & 0xFFFFFFFFFFFFFFDFLL | (32 * (((unint64_t)*(unsigned int *)(a2 + 361) >> 5) & 1));
    *(_DWORD *)(a1 + 361) = v7;
    v8 = v7 & 0xFFFFFFFFFFFFFFBFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 6) & 1) << 6);
    *(_DWORD *)(a1 + 361) = v8;
    v9 = v8 & 0xFFFFFFFFFFFFFDFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 9) & 1) << 9);
    *(_DWORD *)(a1 + 361) = v9;
    v10 = v9 & 0xFFFFFFFFFFFFFBFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 10) & 1) << 10);
    *(_DWORD *)(a1 + 361) = v10;
    v11 = v10 & 0xFFFFFFFFFFFFF7FFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 11) & 1) << 11);
    *(_DWORD *)(a1 + 361) = v11;
    v12 = v11 & 0xFFFFFFFFFFFFEFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 12) & 1) << 12);
    *(_DWORD *)(a1 + 361) = v12;
    v13 = v12 & 0xFFFFFFFFFFFFDFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 13) & 1) << 13);
    *(_DWORD *)(a1 + 361) = v13;
    v14 = v13 & 0xFFFFFFFFFFFFBFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 14) & 1) << 14);
    *(_DWORD *)(a1 + 361) = v14;
    v15 = v14 & 0xFFFFFFFFFFFF7FFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 15) & 1) << 15);
    *(_DWORD *)(a1 + 361) = v15;
    v16 = v15 & 0xFFFFFFFFFFFEFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 16) & 1) << 16);
    *(_DWORD *)(a1 + 361) = v16;
    v17 = v16 & 0xFFFFFFFFFFFDFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 17) & 1) << 17);
    *(_DWORD *)(a1 + 361) = v17;
    v18 = v17 & 0xFFFFFFFFFFFBFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 18) & 1) << 18);
    *(_DWORD *)(a1 + 361) = v18;
    v19 = v18 & 0xFFFFFFFFFDFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 25) & 1) << 25);
    *(_DWORD *)(a1 + 361) = v19;
    v20 = v19 & 0xFFFFFFFFFFF7FFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 19) & 1) << 19);
    *(_DWORD *)(a1 + 361) = v20;
    v21 = v20 & 0xFFFFFFFFFFEFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 20) & 1) << 20);
    *(_DWORD *)(a1 + 361) = v21;
    v22 = v21 & 0xFFFFFFFFFFDFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 21) & 1) << 21);
    *(_DWORD *)(a1 + 361) = v22;
    v23 = v22 & 0xFFFFFFFFFFBFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 22) & 1) << 22);
    *(_DWORD *)(a1 + 361) = v23;
    v24 = v23 & 0xFFFFFFFFFF7FFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 23) & 1) << 23);
    *(_DWORD *)(a1 + 361) = v24;
    v25 = v24 & 0xFFFFFFEFFFFFFFFFLL | ((((unint64_t)*(unsigned __int8 *)(a2 + 365) >> 4) & 1) << 36);
    *(_DWORD *)(a1 + 361) = v24;
    *(_BYTE *)(a1 + 365) = BYTE4(v25);
    v26 = v25 & 0xFFFFFFDFFFFFFFFFLL | ((((unint64_t)*(unsigned __int8 *)(a2 + 365) >> 5) & 1) << 37);
    *(_DWORD *)(a1 + 361) = v24;
    v27 = HIDWORD(v26);
    *(_BYTE *)(a1 + 365) = BYTE4(v26);
    v28 = v26 & 0xFFFFFFFFFEFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 24) & 1) << 24);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v28;
    v29 = v28 & 0xFFFFFFFFFBFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 26) & 1) << 26);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v29;
    v30 = v29 & 0xFFFFFFFFF7FFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 27) & 1) << 27);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v30;
    v31 = v30 & 0xFFFFFFFFEFFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 28) & 1) << 28);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v31;
    v32 = v31 & 0xFFFFFFFFDFFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 29) & 1) << 29);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v32;
    v33 = v32 & 0xFFFFFFFFBFFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 30) & 1) << 30);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v33;
    v34 = v33 & 0xFFFFFFFFFFFFFF7FLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 7) & 1) << 7);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v34;
    v35 = v34 & 0xFFFFFFFFFFFFFEFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 8) & 1) << 8);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v35;
    v36 = v35 & 0xFFFFFFFFFFFFFFFELL | *(_DWORD *)(a2 + 361) & 1;
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v36;
    v37 = v36 & 0xFDFFFFFFFFLL | ((((unint64_t)*(unsigned __int8 *)(a2 + 365) >> 1) & 1) << 33);
    *(_DWORD *)(a1 + 361) = v36;
    *(_BYTE *)(a1 + 365) = BYTE4(v37);
    *(_OWORD *)(a1 + 304) = *(_OWORD *)(a2 + 304);
    *(_DWORD *)(a1 + 320) = *(_DWORD *)(a2 + 320);
    *(_QWORD *)(a1 + 344) = *(_QWORD *)(a2 + 344);
    v38 = *(const char **)(a2 + 8);
    if (v38)
      *(_QWORD *)(a1 + 8) = strdup(v38);
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    v39 = *(const char **)(a2 + 16);
    if (v39)
      *(_QWORD *)(a1 + 16) = strdup(v39);
    v40 = *(void **)(a2 + 56);
    if (v40)
      objc_storeStrong((id *)(a1 + 56), v40);
    v41 = *(void **)(a2 + 48);
    if (v41)
    {
      v42 = xpc_copy(v41);
      v43 = *(void **)(a1 + 48);
      *(_QWORD *)(a1 + 48) = v42;

    }
    v44 = *(void **)(a2 + 40);
    if (v44)
    {
      v45 = xpc_copy(v44);
      v46 = *(void **)(a1 + 40);
      *(_QWORD *)(a1 + 40) = v45;

    }
    v47 = *(void **)(a2 + 232);
    if (v47)
    {
      v48 = xpc_copy(v47);
      v49 = *(void **)(a1 + 232);
      *(_QWORD *)(a1 + 232) = v48;

    }
    if (*(_QWORD *)(a2 + 88))
    {
      v50 = MEMORY[0x1B5E45624]();
      v51 = *(void **)(a1 + 88);
      *(_QWORD *)(a1 + 88) = v50;

      objc_storeStrong((id *)(a1 + 96), *(id *)(a2 + 96));
    }
    if (*(_QWORD *)(a2 + 104))
    {
      v52 = MEMORY[0x1B5E45624]();
      v53 = *(void **)(a1 + 104);
      *(_QWORD *)(a1 + 104) = v52;

      objc_storeStrong((id *)(a1 + 112), *(id *)(a2 + 112));
    }
    if (*(_QWORD *)(a2 + 120))
    {
      v54 = MEMORY[0x1B5E45624]();
      v55 = *(void **)(a1 + 120);
      *(_QWORD *)(a1 + 120) = v54;

      objc_storeStrong((id *)(a1 + 128), *(id *)(a2 + 128));
    }
    v56 = *(void **)(a2 + 192);
    if (v56)
      objc_storeStrong((id *)(a1 + 192), v56);
    if (*(_QWORD *)(a2 + 176))
    {
      v57 = MEMORY[0x1B5E45624]();
      v58 = *(void **)(a1 + 176);
      *(_QWORD *)(a1 + 176) = v57;

      objc_storeStrong((id *)(a1 + 184), *(id *)(a2 + 184));
    }
    v59 = *(void **)(a2 + 72);
    if (v59)
    {
      v60 = xpc_copy(v59);
      v61 = *(void **)(a1 + 72);
      *(_QWORD *)(a1 + 72) = v60;

    }
    v62 = *(void **)(a2 + 136);
    if (v62)
      objc_storeStrong((id *)(a1 + 136), v62);
    v63 = *(void **)(a2 + 216);
    if (v63)
      objc_storeStrong((id *)(a1 + 216), v63);
    if (*(_QWORD *)(a2 + 200))
    {
      v64 = MEMORY[0x1B5E45624]();
      v65 = *(void **)(a1 + 200);
      *(_QWORD *)(a1 + 200) = v64;

    }
    if (*(_QWORD *)(a2 + 208))
    {
      v66 = MEMORY[0x1B5E45624]();
      v67 = *(void **)(a1 + 208);
      *(_QWORD *)(a1 + 208) = v66;

    }
    v68 = *(void **)(a2 + 64);
    if (v68)
      objc_storeStrong((id *)(a1 + 64), v68);
    if (*(_QWORD *)(a2 + 144))
    {
      v69 = MEMORY[0x1B5E45624]();
      v70 = *(void **)(a1 + 144);
      *(_QWORD *)(a1 + 144) = v69;

    }
    v71 = *(void **)(a2 + 152);
    if (v71)
      objc_storeStrong((id *)(a1 + 152), v71);
    if (*(_QWORD *)(a2 + 160))
    {
      v72 = MEMORY[0x1B5E45624]();
      v73 = *(void **)(a1 + 160);
      *(_QWORD *)(a1 + 160) = v72;

    }
    v74 = *(void **)(a2 + 168);
    if (v74)
      objc_storeStrong((id *)(a1 + 168), v74);
    if (*(_QWORD *)(a2 + 328))
    {
      v75 = MEMORY[0x1B5E45624]();
      v76 = *(void **)(a1 + 328);
      *(_QWORD *)(a1 + 328) = v75;

    }
    v77 = *(void **)(a2 + 248);
    if (v77)
      objc_storeStrong((id *)(a1 + 248), v77);
    if (*(_QWORD *)(a2 + 240))
    {
      v78 = MEMORY[0x1B5E45624]();
      v79 = *(void **)(a1 + 240);
      *(_QWORD *)(a1 + 240) = v78;

    }
    if (*(_QWORD *)(a2 + 256))
    {
      v80 = MEMORY[0x1B5E45624]();
      v81 = *(void **)(a1 + 256);
      *(_QWORD *)(a1 + 256) = v80;

    }
    v82 = *(void **)(a2 + 264);
    if (v82)
      objc_storeStrong((id *)(a1 + 264), v82);
    v83 = *(void **)(a2 + 80);
    if (v83)
      objc_storeStrong((id *)(a1 + 80), v83);
    v84 = *(const __CFArray **)(a2 + 280);
    v85 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    if (v84)
      *(_QWORD *)(a1 + 280) = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v84);
    v86 = *(const __CFArray **)(a2 + 288);
    if (v86)
      *(_QWORD *)(a1 + 288) = CFArrayCreateCopy(*v85, v86);
    if (*(_BYTE *)(a2 + 296))
      *(_BYTE *)(a1 + 296) = *(_BYTE *)(a2 + 296);
    if (*(_BYTE *)(a2 + 297))
      *(_BYTE *)(a1 + 297) = *(_BYTE *)(a2 + 297);
    if (*(_BYTE *)(a2 + 360))
      *(_BYTE *)(a1 + 360) = *(_BYTE *)(a2 + 360);
  }
}

uint64_t bssl::ssl_cert_check_key_usage(__int128 *a1, unsigned int a2)
{
  uint64_t v3;
  int v6;
  int v7;
  unsigned __int8 *v8[2];
  __int128 v9;
  __int128 v10[2];
  __int128 v11;
  int v12;
  __int128 v13[2];
  __int128 v14;

  v14 = *a1;
  memset(v13, 170, sizeof(v13));
  v12 = -1431655766;
  if (bssl::ssl_cert_skip_to_spki(&v14, &v13[1])
    && CBS_get_asn1(&v13[1], 0, 536870928)
    && CBS_get_optional_asn1(&v13[1], 0, 0, -2147483647)
    && CBS_get_optional_asn1(&v13[1], 0, 0, -2147483646)
    && CBS_get_optional_asn1(&v13[1], v13, &v12, -1610612733))
  {
    if (!v12)
      return 1;
    *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_asn1(v13, &v11, 536870928))
    {
      if (CBS_len((uint64_t)&v11))
      {
        while (1)
        {
          memset(v10, 170, sizeof(v10));
          *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_asn1(&v11, &v10[1], 536870928)
            || !CBS_get_asn1(&v10[1], v10, 6)
            || CBS_peek_asn1_tag(&v10[1], 1) && !CBS_get_asn1(&v10[1], 0, 1)
            || !CBS_get_asn1(&v10[1], &v9, 4)
            || CBS_len((uint64_t)&v10[1]))
          {
            v6 = 272;
            v7 = 593;
            goto LABEL_23;
          }
          if (CBS_len((uint64_t)v10) == 3)
          {
            v3 = CBS_data((uint64_t)v10);
            if (*(_WORD *)v3 == 7509 && *(_BYTE *)(v3 + 2) == 15)
              break;
          }
          if (!CBS_len((uint64_t)&v11))
            return 1;
        }
        v8[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
        v8[1] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_asn1(&v9, v8, 3) || CBS_len((uint64_t)&v9))
        {
          v6 = 272;
          v7 = 607;
          goto LABEL_23;
        }
        if (!CBS_is_valid_asn1_bitstring(v8))
        {
          v6 = 272;
          v7 = 614;
          goto LABEL_23;
        }
        if (!CBS_asn1_bitstring_has_bit((uint64_t)v8, a2))
        {
          v6 = 302;
          v7 = 619;
          goto LABEL_23;
        }
      }
      return 1;
    }
    v6 = 272;
    v7 = 581;
  }
  else
  {
    v6 = 272;
    v7 = 571;
  }
LABEL_23:
  ERR_put_error(16, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", v7);
  return 0;
}

uint64_t cbs_get_asn1(__int128 *a1, _QWORD *a2, int a3, int a4)
{
  _QWORD *v7;
  int any_asn1_element;
  uint64_t result;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  _QWORD v14[2];
  int v15;
  unint64_t v16;

  v16 = 0xAAAAAAAAAAAAAAAALL;
  v15 = -1431655766;
  if (a2)
    v7 = a2;
  else
    v7 = v14;
  v14[0] = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = 0xAAAAAAAAAAAAAAAALL;
  any_asn1_element = cbs_get_any_asn1_element(a1, v7, &v15, &v16, 0, 0, 0);
  result = 0;
  if (any_asn1_element && v15 == a3)
  {
    if (a4)
    {
      v10 = v14;
      if (a2)
        v10 = a2;
      v11 = v10[1];
      v12 = v11 >= v16;
      v13 = v11 - v16;
      if (!v12)
        cbs_get_asn1_cold_1();
      *v7 += v16;
      v10[1] = v13;
    }
    return 1;
  }
  return result;
}

uint64_t cbs_get_any_asn1_element(__int128 *a1, _QWORD *a2, _DWORD *a3, unint64_t *a4, _DWORD *a5, _DWORD *a6, int a7)
{
  uint64_t result;
  unsigned __int8 *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  BOOL v25;
  unint64_t v26;
  unint64_t v27;
  unsigned int v28;
  unint64_t v29;
  unsigned int v30;
  __int128 v31;

  v31 = *a1;
  if (a7)
  {
    *a5 = 0;
    *a6 = 0;
  }
  else
  {
    if (a5)
      cbs_get_any_asn1_element_cold_2();
    if (a6)
      cbs_get_any_asn1_element_cold_1();
  }
  v30 = -1431655766;
  result = parse_asn1_tag(&v31, &v30);
  if ((_DWORD)result)
  {
    if (a3)
      *a3 = v30;
    if (!*((_QWORD *)&v31 + 1))
      return 0;
    v15 = (unsigned __int8 *)(v31 + 1);
    v16 = *(unsigned __int8 *)v31;
    v17 = *((_QWORD *)a1 + 1);
    v18 = v17 - (*((_QWORD *)&v31 + 1) - 1);
    if ((*(char *)v31 & 0x80000000) == 0)
    {
      v19 = v18 + v16;
      if (!a4)
        goto LABEL_12;
      goto LABEL_11;
    }
    v23 = v16 & 0x7F;
    if (a7)
    {
      if (!(_DWORD)v23 && (v30 & 0x20000000) != 0)
      {
        if (a4)
        {
          *a4 = v18;
          v17 = *((_QWORD *)a1 + 1);
        }
        *a5 = 1;
        *a6 = 1;
        v29 = v17 - v18;
        if (v17 < v18)
          return 0;
        v22 = *(_QWORD *)a1;
        *(_QWORD *)a1 += v18;
        *((_QWORD *)a1 + 1) = v29;
        if (a2)
        {
LABEL_15:
          *a2 = v22;
          a2[1] = v18;
        }
        return 1;
      }
    }
    v25 = (v23 - 5) >= 0xFFFFFFFC && *((_QWORD *)&v31 + 1) - 1 >= v23;
    if (!v25)
      return 0;
    v26 = 0;
    v27 = v23;
    do
    {
      v28 = *v15++;
      v26 = v28 | (v26 << 8);
      --v27;
    }
    while (v27);
    if (v26 > 0x7F)
    {
      if (v26 >> (8 * v23 - 8))
        goto LABEL_42;
      if (!a7)
        return 0;
    }
    else
    {
      if (!a7)
        return 0;
      *a5 = 1;
      if (v26 >> (8 * v23 - 8))
      {
LABEL_42:
        v18 += v23;
        if (!__CFADD__(v26, v18))
        {
          v19 = v26 + v18;
          if (!a4)
          {
LABEL_12:
            v20 = *((_QWORD *)a1 + 1);
            v25 = v20 >= v19;
            v21 = v20 - v19;
            if (!v25)
              return 0;
            v22 = *(_QWORD *)a1;
            *(_QWORD *)a1 += v19;
            *((_QWORD *)a1 + 1) = v21;
            v18 = v19;
            if (a2)
              goto LABEL_15;
            return 1;
          }
LABEL_11:
          *a4 = v18;
          goto LABEL_12;
        }
        return 0;
      }
    }
    *a5 = 1;
    goto LABEL_42;
  }
  return result;
}

uint64_t parse_asn1_tag(_QWORD *a1, unsigned int *a2)
{
  uint64_t v2;
  unsigned __int8 *v4;
  int v5;
  int v6;
  int v7;
  uint64_t result;
  unsigned int v9;
  unint64_t v10;

  v2 = a1[1];
  if (!v2)
    return 0;
  v4 = (unsigned __int8 *)(*a1)++;
  a1[1] = v2 - 1;
  v5 = *v4;
  v6 = v5 & 0x1F;
  if (v6 != 31
    || (v10 = 0xAAAAAAAAAAAAAAAALL, v7 = parse_base128_integer(a1, &v10), result = 0, v7)
    && (v6 = v10, !(v10 >> 29))
    && v10 >= 0x1F)
  {
    v9 = v6 | (v5 << 24) & 0xE0000000;
    if ((v9 & 0xDFFFFFFF) != 0)
    {
      *a2 = v9;
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t CBS_get_asn1(__int128 *a1, _QWORD *a2, int a3)
{
  return cbs_get_asn1(a1, a2, a3, 1);
}

BOOL CBS_peek_asn1_tag(__int128 *a1, int a2)
{
  unsigned int v5;
  __int128 v6;

  v6 = *a1;
  v5 = -1431655766;
  return parse_asn1_tag(&v6, &v5) && v5 == a2;
}

uint64_t CBS_get_optional_asn1(__int128 *a1, _QWORD *a2, int *a3, int a4)
{
  int v8;
  uint64_t result;
  unsigned int v10;
  __int128 v11;

  v11 = *a1;
  v10 = -1431655766;
  v8 = 0;
  if (!parse_asn1_tag(&v11, &v10)
    || v10 != a4
    || (v8 = 1, result = cbs_get_asn1(a1, a2, a4, 1), (_DWORD)result))
  {
    if (a3)
      *a3 = v8;
    return 1;
  }
  return result;
}

void bssl::tls_next_message(bssl *this, ssl_st *a2)
{
  __int128 v3;
  unint64_t *v4;
  unint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BUF_MEM **v13;
  _QWORD *v14;
  __int128 v15;
  __int128 v16;
  unint64_t v17;

  v17 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v15 = v3;
  v16 = v3;
  if (!bssl::tls_get_message((uint64_t)this, (uint64_t)&v15)
    || (v4 = *(unint64_t **)(*((_QWORD *)this + 6) + 224)) == 0
    || (v5 = *v4, v5 < CBS_len((uint64_t)&v16 + 8)))
  {
    bssl::tls_next_message();
  }
  v6 = *(char **)(*(_QWORD *)(*((_QWORD *)this + 6) + 224) + 8);
  v7 = CBS_len((uint64_t)&v16 + 8);
  v8 = **(_QWORD **)(*((_QWORD *)this + 6) + 224);
  v9 = CBS_len((uint64_t)&v16 + 8);
  if (v8 != v9)
    memmove(v6, &v6[v7], v8 - v9);
  v10 = CBS_len((uint64_t)&v16 + 8);
  v11 = *((_QWORD *)this + 6);
  **(_QWORD **)(v11 + 224) -= v10;
  *(_WORD *)(v11 + 220) &= ~8u;
  *(_WORD *)(*((_QWORD *)this + 6) + 220) &= ~0x10u;
  if (!SSL_in_init((uint64_t)this))
  {
    v12 = *((_QWORD *)this + 6);
    v14 = *(_QWORD **)(v12 + 224);
    v13 = (BUF_MEM **)(v12 + 224);
    if (!*v14)
      std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v13, 0);
  }
}

int SSL_peek(SSL *ssl, void *buf, int num)
{
  size_t v3;
  int impl;
  int (__cdecl *handshake_func)(SSL *);

  if (*(_QWORD *)&ssl->hit)
  {
    ERR_put_error(16, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 1288);
    LODWORD(v3) = -1;
  }
  else
  {
    LODWORD(v3) = num;
    impl = ssl_read_impl(ssl);
    if (impl < 1)
    {
      LODWORD(v3) = impl;
    }
    else if ((int)v3 >= 1)
    {
      handshake_func = ssl->handshake_func;
      if (*((_QWORD *)handshake_func + 17) >= (unint64_t)v3)
        v3 = v3;
      else
        v3 = *((_QWORD *)handshake_func + 17);
      if (buf && v3)
        memcpy(buf, *((const void **)handshake_func + 16), v3);
    }
  }
  return v3;
}

uint64_t ssl_read_impl(ssl_st *a1)
{
  uint64_t v1;
  int (__cdecl *handshake_func)(SSL *);
  int v4;
  int v5;
  int (__cdecl *v6)(SSL *);
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  ssl_st *v15;
  int (__cdecl *v16)(SSL *);
  char v18;
  ssl_st *v19;
  unsigned __int8 v20;
  _OWORD v21[2];
  unint64_t v22;

  *((_DWORD *)a1->handshake_func + 49) = 0;
  ERR_clear_error();
  ERR_clear_system_error();
  if (!*(_QWORD *)&a1->rwstate)
  {
    v4 = 226;
    v5 = 1205;
LABEL_28:
    ERR_put_error(16, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", v5);
    return 0xFFFFFFFFLL;
  }
  handshake_func = a1->handshake_func;
  if (*((_DWORD *)handshake_func + 43) == 2)
  {
    ERR_restore_state(*((_QWORD **)handshake_func + 23));
    return 0xFFFFFFFFLL;
  }
  while (2)
  {
    v6 = a1->handshake_func;
    if (*((_QWORD *)v6 + 17))
      return 1;
    if ((*((_WORD *)v6 + 110) & 0x2000) != 0)
    {
      *((_DWORD *)v6 + 49) = 19;
      return 0xFFFFFFFFLL;
    }
    while (1)
    {
      v7 = *((_QWORD *)a1->handshake_func + 35);
      if (!v7 || (*(_WORD *)(v7 + 1600) & 0x2008) != 0)
        break;
      v8 = SSL_do_handshake(a1);
      if ((v8 & 0x80000000) != 0)
        return v8;
      if (!(_DWORD)v8)
      {
        v4 = 215;
        v5 = 1229;
        goto LABEL_28;
      }
    }
    v22 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v21[0] = v9;
    v21[1] = v9;
    if ((*(unsigned int (**)(ssl_st *, _OWORD *))(*(_QWORD *)&a1->version + 24))(a1, v21))
    {
      v10 = *((_QWORD *)a1->handshake_func + 35);
      if (!v10 || (v11 = *(_DWORD *)(v10 + 1600), (v11 & 8) != 0))
      {
        if (!ssl_do_post_handshake((uint64_t)a1, (uint64_t)v21))
        {
          bssl::ssl_set_read_error((bssl *)a1, v15);
          return 0xFFFFFFFFLL;
        }
        (*(void (**)(ssl_st *))(*(_QWORD *)&a1->version + 32))(a1);
      }
      else
      {
        *(_DWORD *)(v10 + 1600) = v11 & 0xFFFFDFFF;
      }
      v14 = 2;
    }
    else
    {
      v20 = 50;
      v19 = 0;
      v12 = bssl::ssl_open_app_data(a1, (uint64_t)a1->handshake_func + 128, &v19, &v20);
      v18 = -86;
      v13 = bssl::ssl_handle_open_record((bssl *)a1, &v18, v12, v19, v20);
      if ((int)v13 < 1)
      {
        v14 = 1;
        v1 = v13;
      }
      else if (v18)
      {
        v14 = 0;
      }
      else
      {
        v16 = a1->handshake_func;
        if (!*((_QWORD *)v16 + 17))
          ssl_read_impl();
        v14 = 0;
        *((_BYTE *)v16 + 212) = 0;
      }
    }
    if (v14 != 1)
      continue;
    return v1;
  }
}

uint64_t bssl::ssl_handle_open_record(bssl *a1, _BYTE *a2, int a3, ssl_st *a4, int a5)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t buffer_extend_to;

  *a2 = 0;
  v6 = *((_QWORD *)a1 + 6);
  v7 = *(unsigned __int16 *)(v6 + 92);
  if (a3 == 2)
    goto LABEL_4;
  if (v7 < (unint64_t)a4)
    abort();
  *(_WORD *)(v6 + 88) += (_WORD)a4;
  LOWORD(v7) = v7 - (_WORD)a4;
  *(_WORD *)(v6 + 92) = v7;
  *(_WORD *)(v6 + 94) -= (_WORD)a4;
  if (!a3)
    return 1;
LABEL_4:
  if (!(_WORD)v7)
  {
    *(_WORD *)(v6 + 88) = *(_WORD *)(v6 + 90);
    *(_WORD *)(v6 + 92) = 0;
    *(_WORD *)(v6 + 94) = *(_WORD *)(v6 + 96);
  }
  v8 = 1;
  switch(a3)
  {
    case 0:
      return v8;
    case 1:
      goto LABEL_9;
    case 2:
      buffer_extend_to = bssl::ssl_read_buffer_extend_to(a1, (unint64_t)a4);
      if ((int)buffer_extend_to < 1)
      {
        v8 = buffer_extend_to;
      }
      else
      {
        v8 = 1;
LABEL_9:
        *a2 = 1;
      }
      break;
    case 3:
      v8 = 0;
      *(_DWORD *)(v6 + 196) = 6;
      return v8;
    case 4:
      if (a5)
        bssl::ssl_send_alert(a1, (ssl_st *)2, a5);
      return 0xFFFFFFFFLL;
    default:
      bssl::ssl_handle_open_record();
  }
  return v8;
}

uint64_t bssl::tls_open_record(bssl *a1, char *a2, uint64_t a3, unsigned __int8 **a4, ssl_st *a5, unsigned __int16 *a6, unsigned __int16 *a7)
{
  uint64_t result;
  bssl::SSLAEADContext *v15;
  int v16;
  int v17;
  int v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  const ssl_st *v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  bssl::SSLAEADContext *v29;
  char *v30;
  unint64_t v31;
  int v32;
  BOOL v33;
  const ssl_st *v34;
  uint64_t v35;
  __int16 v36;
  _QWORD *v37;
  bssl::SSLAEADContext *v38;
  unsigned int v39;
  unint64_t v40;
  unint64_t v41;
  int v42;
  uint64_t v43;
  unsigned int v44;
  char v45;
  __int16 v46;
  char v47;
  _QWORD v48[2];
  unsigned __int16 v49;
  unsigned __int16 v50;
  char v51;
  unsigned __int16 *v52[2];

  *a4 = 0;
  if (*(_DWORD *)(*((_QWORD *)a1 + 6) + 172) == 1)
    return 3;
  if (!bssl::tls_can_accept_handshake_data(a1, a5, (unsigned __int8 *)a3))
    return 4;
  v52[0] = a6;
  v52[1] = a7;
  v51 = -86;
  v50 = -21846;
  v49 = -21846;
  if (!CBS_get_u8(v52, &v51)
    || !CBS_get_u16(v52, &v50)
    || !CBS_get_u16(v52, &v49))
  {
    v20 = 5;
    goto LABEL_13;
  }
  v15 = *(bssl::SSLAEADContext **)(*((_QWORD *)a1 + 6) + 264);
  v16 = v50;
  if (*(_QWORD *)v15)
  {
    if (v16 == bssl::SSLAEADContext::RecordVersion(v15))
      goto LABEL_9;
LABEL_15:
    ERR_put_error(16, 0, 247, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 231);
    v19 = 70;
    goto LABEL_16;
  }
  if ((v50 & 0xFF00) != 0x300)
    goto LABEL_15;
LABEL_9:
  if (v49 < 0x4141uLL)
  {
    v48[0] = 0xAAAAAAAAAAAAAAAALL;
    v48[1] = 0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_bytes((uint64_t *)v52, v48, v49))
    {
      if ((unint64_t)a7 >= 5)
        v21 = 5;
      else
        v21 = (uint64_t)a7;
      bssl::ssl_do_msg_callback((uint64_t)a1, 0, 256, (uint64_t)a6, v21);
      *a4 = (unsigned __int8 *)a7 - CBS_len((uint64_t)v52);
      if ((*(_WORD *)(*((_QWORD *)a1 + 6) + 220) & 2) != 0
        && bssl::ssl_protocol_version(a1, v22) >= 0x304
        && SSL_in_init((uint64_t)a1)
        && v51 == 20
        && v49 == 1
        && *(_BYTE *)CBS_data((uint64_t)v48) == 1)
      {
        v23 = *((_QWORD *)a1 + 6);
        v24 = ++*(_BYTE *)(v23 + 210);
        if (v24 < 0x21)
          return 1;
        v25 = 219;
        v26 = 263;
        goto LABEL_67;
      }
      v27 = *((_QWORD *)a1 + 6);
      if ((*(_WORD *)(v27 + 220) & 1) == 0 || **(_QWORD **)(v27 + 264) || v51 != 23)
      {
        v28 = *(_QWORD *)v27;
        if (*(_QWORD *)v27 == -1)
        {
          ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 280);
          v19 = 80;
          goto LABEL_16;
        }
        v29 = *(bssl::SSLAEADContext **)(v27 + 264);
        v46 = v50;
        v47 = v51;
        v30 = (char *)CBS_data((uint64_t)v48);
        v31 = CBS_len((uint64_t)v48);
        v33 = bssl::SSLAEADContext::Open(v29, (char **)a3, v47, v46, v28, (int)a6, v21, v32, v30, v31);
        v35 = *((_QWORD *)a1 + 6);
        v36 = *(_WORD *)(v35 + 220);
        if (v33)
        {
          *(_WORD *)(v35 + 220) = v36 & 0xFFFE;
          v37 = (_QWORD *)*((_QWORD *)a1 + 6);
          ++*v37;
          v38 = (bssl::SSLAEADContext *)v37[33];
          if (*(_QWORD *)v38)
          {
            v39 = bssl::SSLAEADContext::ProtocolVersion(v38);
            v40 = 0x4000;
            if (v39 > 0x303)
              v40 = 16385;
            v41 = *(_QWORD *)(a3 + 8);
            if (v41 <= v40)
            {
              if (v39 >= 0x304)
              {
                if (v51 == 23)
                {
                  while (v41)
                  {
                    v42 = *(unsigned __int8 *)(*(_QWORD *)a3 + v41 - 1);
                    v51 = *(_BYTE *)(*(_QWORD *)a3 + v41 - 1);
                    if (v41 >= v41 - 1)
                      --v41;
                    *(_QWORD *)(a3 + 8) = v41;
                    if (v42)
                      goto LABEL_57;
                  }
                  ERR_put_error(16, 0, 139, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 327);
                  v19 = 51;
                }
                else
                {
                  ERR_put_error(16, 0, 251, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 320);
                  v19 = 50;
                }
                goto LABEL_16;
              }
LABEL_57:
              v43 = *((_QWORD *)a1 + 6);
              if (v41)
              {
                *(_BYTE *)(v43 + 210) = 0;
              }
              else
              {
                v44 = ++*(_BYTE *)(v43 + 210);
                if (v44 >= 0x21)
                {
                  v25 = 219;
                  v26 = 340;
LABEL_67:
                  ERR_put_error(16, 0, v25, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", v26);
                  v19 = 10;
                  goto LABEL_16;
                }
              }
              v45 = v51;
              if (v51 != 22)
              {
                if (v51 == 21)
                  return bssl::ssl_process_alert(a1, a5, *(unsigned __int8 **)a3, v41);
                if (bssl::tls_has_unprocessed_handshake_data(a1, v34))
                {
                  v25 = 225;
                  v26 = 357;
                  goto LABEL_67;
                }
                v43 = *((_QWORD *)a1 + 6);
                v45 = v51;
              }
              result = 0;
              *(_BYTE *)(v43 + 211) = 0;
              *a2 = v45;
              return result;
            }
          }
          else
          {
            v41 = *(_QWORD *)(a3 + 8);
            if (v41 <= 0x4000)
              goto LABEL_57;
          }
          v17 = 136;
          v18 = 312;
          goto LABEL_11;
        }
        if ((v36 & 1) == 0 || !**(_QWORD **)(v35 + 264))
        {
          ERR_put_error(16, 0, 139, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 294);
          v19 = 20;
          goto LABEL_16;
        }
        ERR_clear_error();
      }
      return bssl::skip_early_data(a1, a5, *a4);
    }
    v20 = v49 + 5;
LABEL_13:
    *a4 = (unsigned __int8 *)v20;
    return 2;
  }
  v17 = 146;
  v18 = 238;
LABEL_11:
  ERR_put_error(16, 0, v17, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", v18);
  v19 = 22;
LABEL_16:
  LOBYTE(a5->version) = v19;
  return 4;
}

uint64_t CBS_len(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t CBS_get_u16(unsigned __int16 **a1, _WORD *a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  unsigned __int16 *v6;

  v2 = (unint64_t)a1[1];
  v3 = v2 >= 2;
  v4 = v2 - 2;
  if (!v3)
    return 0;
  v6 = (*a1)++;
  a1[1] = (unsigned __int16 *)v4;
  *a2 = bswap32(*v6) >> 16;
  return 1;
}

uint64_t CBS_get_u8(_QWORD *a1, _BYTE *a2)
{
  uint64_t v2;
  _BYTE *v3;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = (_BYTE *)(*a1)++;
  a1[1] = v2 - 1;
  *a2 = *v3;
  return 1;
}

uint64_t bssl::tls_can_accept_handshake_data(bssl *this, const ssl_st *a2, unsigned __int8 *a3)
{
  __int128 v5;
  const ssl_st *v6;
  char v7;
  unint64_t v8;
  uint64_t result;
  unint64_t v10;
  _OWORD v11[2];
  unint64_t v12;

  v12 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = v5;
  v11[1] = v5;
  v10 = 0xAAAAAAAAAAAAAAAALL;
  if (bssl::parse_message((uint64_t)this, (uint64_t)v11, (uint64_t *)&v10))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 523);
    v7 = 80;
LABEL_5:
    result = 0;
    LOBYTE(a2->version) = v7;
    return result;
  }
  v8 = v10;
  if (v8 > bssl::ssl_max_handshake_message_len(this, v6) + 4)
  {
    ERR_put_error(16, 0, 150, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 530);
    v7 = 47;
    goto LABEL_5;
  }
  return 1;
}

uint64_t bssl::tls_get_message(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  __int16 v6;
  uint64_t v8;

  v4 = bssl::parse_message(a1, a2, &v8);
  if ((_DWORD)v4)
  {
    v5 = *(_QWORD *)(a1 + 48);
    v6 = *(_WORD *)(v5 + 220);
    if ((v6 & 0x10) == 0)
    {
      if (!*(_BYTE *)a2)
      {
        bssl::ssl_do_msg_callback(a1, 0, 22, *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32));
        v5 = *(_QWORD *)(a1 + 48);
        v6 = *(_WORD *)(v5 + 220);
      }
      *(_WORD *)(v5 + 220) = v6 | 0x10;
    }
  }
  return v4;
}

uint64_t bssl::parse_message(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *v4;
  uint64_t result;
  uint64_t v8;
  int v9[5];

  v4 = *(uint64_t **)(*(_QWORD *)(a1 + 48) + 224);
  if (v4
    && (memset(v9, 170, sizeof(v9)), CBS_init(&v9[1], v4[1], *v4), CBS_get_u8(&v9[1], (_BYTE *)(a2 + 1)))
    && CBS_get_u24((uint64_t *)&v9[1], v9))
  {
    result = CBS_get_bytes((uint64_t *)&v9[1], (_QWORD *)(a2 + 8), v9[0]);
    if ((_DWORD)result)
    {
      CBS_init((_QWORD *)(a2 + 24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 224) + 8), (v9[0] + 4));
      *(_BYTE *)a2 = (*(_BYTE *)(*(_QWORD *)(a1 + 48) + 220) & 8) != 0;
      return 1;
    }
    v8 = (v9[0] + 4);
  }
  else
  {
    result = 0;
    v8 = 4;
  }
  *a3 = v8;
  return result;
}

uint64_t bssl::ssl_max_handshake_message_len(bssl *this, const ssl_st *a2)
{
  const ssl_st *v3;
  unsigned int v5;

  if (SSL_in_init((uint64_t)this))
  {
    if ((*((_BYTE *)this + 180) & 1) == 0 || (*(_BYTE *)(*((_QWORD *)this + 1) + 312) & 1) != 0)
    {
      v5 = *((_DWORD *)this + 38);
      if (v5 <= 0x4000)
        return 0x4000;
      else
        return v5;
    }
    else
    {
      return 0x4000;
    }
  }
  else if (bssl::ssl_protocol_version(this, v3) >= 0x304)
  {
    if ((*((_BYTE *)this + 180) & 1) != 0)
      return 1;
    else
      return 0x4000;
  }
  else
  {
    return 0;
  }
}

BOOL SSL_in_init(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 280);
  return v1 && ((*(_DWORD *)(v1 + 1600) >> 3) & 1) == 0;
}

uint64_t bssl::ssl_protocol_version(bssl *this, const ssl_st *a2)
{
  uint64_t result;

  if ((*(_WORD *)(*((_QWORD *)this + 6) + 220) & 2) == 0)
    bssl::ssl_protocol_version();
  result = *((unsigned __int16 *)this + 8);
  if ((result - 769) >= 4)
  {
    if ((_DWORD)result == 65277)
    {
      return 771;
    }
    else
    {
      if ((_DWORD)result != 65279)
        bssl::ssl_protocol_version();
      return 770;
    }
  }
  return result;
}

uint64_t CBS_get_bytes(uint64_t *a1, _QWORD *a2, unint64_t a3)
{
  unint64_t v3;
  BOOL v4;
  unint64_t v5;
  uint64_t v7;

  v3 = a1[1];
  v4 = v3 >= a3;
  v5 = v3 - a3;
  if (!v4)
    return 0;
  v7 = *a1;
  *a1 += a3;
  a1[1] = v5;
  *a2 = v7;
  a2[1] = a3;
  return 1;
}

_QWORD *CBS_init(_QWORD *result, uint64_t a2, uint64_t a3)
{
  *result = a2;
  result[1] = a3;
  return result;
}

uint64_t bssl::ssl_open_app_data(_QWORD *a1, uint64_t a2, _QWORD *a3, _BYTE *a4)
{
  uint64_t v5;
  uint64_t result;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;

  *a3 = 0;
  v5 = a1[6];
  if (*(_DWORD *)(v5 + 172) == 2)
  {
    ERR_restore_state(*(_QWORD **)(v5 + 184));
    *a4 = 0;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD *))(*a1 + 64))(a1);
    if ((_DWORD)result != 4)
      return result;
    v8 = a1[6];
    *(_DWORD *)(v8 + 172) = 2;
    v9 = (uint64_t *)(v8 + 184);
    v10 = ERR_save_state();
    std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100](v9, (uint64_t)v10);
  }
  return 4;
}

uint64_t bssl::tls_open_app_data(uint64_t a1, ssl_st *a2, unsigned __int8 **a3, ssl_st *a4, unsigned __int16 *a5, unsigned __int16 *a6)
{
  uint64_t result;
  const ssl_st *v13;
  _BOOL4 v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  __int128 v21;
  char v22;

  if ((bssl::ssl_can_read((bssl *)a1, a2) & 1) == 0)
    bssl::tls_open_app_data();
  if (!**(_QWORD **)(*(_QWORD *)(a1 + 48) + 264))
    bssl::tls_open_app_data();
  v22 = -86;
  v21 = 0uLL;
  result = bssl::tls_open_record((bssl *)a1, &v22, (uint64_t)&v21, a3, a4, a5, a6);
  if (!(_DWORD)result)
  {
    v14 = (*(_BYTE *)(a1 + 180) & 1) != 0 && SSL_in_early_data(a1) != 0;
    if (v22 != 23)
    {
      if (v22 == 22)
      {
        if ((*(_BYTE *)(a1 + 180) & 1) != 0 && bssl::ssl_protocol_version((bssl *)a1, v13) <= 0x303)
        {
          ERR_put_error(16, 0, 182, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", 330);
          v15 = 100;
LABEL_19:
          LOBYTE(a4->version) = v15;
          return 4;
        }
        if ((bssl::tls_append_handshake_data(a1, (const void *)v21, *((size_t *)&v21 + 1)) & 1) == 0)
        {
          v15 = 80;
          goto LABEL_19;
        }
        return 1;
      }
      v19 = 225;
      v20 = 343;
LABEL_16:
      ERR_put_error(16, 0, v19, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", v20);
      v15 = 10;
      goto LABEL_19;
    }
    v16 = *((_QWORD *)&v21 + 1);
    if (v14)
    {
      v17 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 280);
      v18 = *(unsigned __int16 *)(v17 + 1606);
      if (*((_QWORD *)&v21 + 1) > (unint64_t)(14336 - v18))
      {
        v19 = 300;
        v20 = 350;
        goto LABEL_16;
      }
      *(_WORD *)(v17 + 1606) = v18 + WORD4(v21);
    }
    if (v16)
    {
      result = 0;
      *(_OWORD *)&a2->version = v21;
      return result;
    }
    return 1;
  }
  return result;
}

uint64_t bssl::ssl_can_read(bssl *this, const ssl_st *a2)
{
  uint64_t v2;
  unsigned int v3;

  v2 = *(_QWORD *)(*((_QWORD *)this + 6) + 280);
  if (!v2)
    return 1;
  v3 = *(_DWORD *)(v2 + 1600);
  if ((v3 & 8) != 0)
    return 1;
  else
    return (v3 >> 13) & 1;
}

uint64_t bssl::ssl_read_buffer_extend_to(bssl *this, unint64_t a2)
{
  _WORD *v4;
  const ssl_st *v5;
  bssl::SSLBuffer *v6;
  int v7;
  int is_dtls;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t result;
  _WORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unsigned __int16 v17;

  v4 = (_WORD *)*((_QWORD *)this + 6);
  if (!v4[46])
  {
    v4[44] = v4[45];
    v4[46] = 0;
    v4[47] = v4[48];
  }
  if (SSL_is_dtls((unsigned __int8 **)this))
    a2 = 16717;
  v6 = (bssl::SSLBuffer *)(*((_QWORD *)this + 6) + 80);
  v7 = bssl::ssl_record_prefix_len((unsigned __int8 **)this, v5);
  if (!bssl::SSLBuffer::EnsureCap(v6, v7, a2))
    return 0xFFFFFFFFLL;
  if (!*((_QWORD *)this + 3))
  {
    ERR_put_error(16, 0, 119, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_buffer.cc", 213);
    return 0xFFFFFFFFLL;
  }
  is_dtls = SSL_is_dtls((unsigned __int8 **)this);
  v9 = *((_QWORD *)this + 6);
  if (is_dtls)
  {
    if (*(_WORD *)(v9 + 92))
    {
      v10 = 68;
      v11 = 156;
LABEL_15:
      ERR_put_error(16, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_buffer.cc", v11);
      result = 0xFFFFFFFFLL;
      goto LABEL_16;
    }
    result = BIO_read(*((BIO **)this + 3), (void *)(*(_QWORD *)(v9 + 80) + *(unsigned __int16 *)(v9 + 88)), *(unsigned __int16 *)(v9 + 94));
    if ((int)result > 0)
    {
      v14 = *(unsigned __int16 *)(v9 + 92);
      if ((unint64_t)*(unsigned __int16 *)(v9 + 94) - v14 < result)
LABEL_28:
        abort();
      *(_WORD *)(v9 + 92) = v14 + result;
      return 1;
    }
  }
  else
  {
    if (a2 > *(unsigned __int16 *)(v9 + 94))
    {
      v10 = 121;
      v11 = 175;
      goto LABEL_15;
    }
    v15 = *(unsigned __int16 *)(v9 + 92);
    if (a2 <= v15)
      return 1;
    while (1)
    {
      result = BIO_read(*((BIO **)this + 3), (void *)(*(_QWORD *)(v9 + 80) + *(unsigned __int16 *)(v9 + 88) + v15), a2 - v15);
      if ((int)result <= 0)
        break;
      v16 = *(unsigned __int16 *)(v9 + 92);
      if ((unint64_t)*(unsigned __int16 *)(v9 + 94) - v16 < result)
        goto LABEL_28;
      v17 = v16 + result;
      *(_WORD *)(v9 + 92) = v16 + result;
      v15 = (unsigned __int16)(v16 + result);
      result = 1;
      if (a2 <= v17)
        return result;
    }
  }
  *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 2;
LABEL_16:
  v13 = (_WORD *)*((_QWORD *)this + 6);
  if (!v13[46])
  {
    v13[44] = v13[45];
    v13[46] = 0;
    v13[47] = v13[48];
  }
  return result;
}

uint64_t SSL_is_dtls(unsigned __int8 **a1)
{
  return **a1;
}

int BIO_read(BIO *b, void *data, int len)
{
  int (__cdecl *bread)(BIO *, char *, int);
  int result;
  int v6;
  int v7;

  if (!b || !b->method || (bread = b->method->bread) == 0)
  {
    v6 = 115;
    v7 = 125;
LABEL_9:
    ERR_put_error(17, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio.c", v7);
    return -2;
  }
  if (!LODWORD(b->callback))
  {
    v6 = 114;
    v7 = 129;
    goto LABEL_9;
  }
  if (len < 1)
    return 0;
  result = ((uint64_t (*)(BIO *, void *))bread)(b, data);
  if (result >= 1)
    b->ptr = (char *)b->ptr + result;
  return result;
}

uint64_t boringssl_bio_read(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;

  if (!a2)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    result = (*(uint64_t (**)(_QWORD))(v3 + 8))(*(_QWORD *)v3);
    if ((int)result > 0)
      return result;
    BIO_set_retry_read(a1);
  }
  return 0xFFFFFFFFLL;
}

uint64_t bssl::SSLBuffer::EnsureCap(bssl::SSLBuffer *this, int a2, unint64_t a3)
{
  int v3;
  int v4;
  uint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;

  if (a3 >= 0x10000)
  {
    v3 = 68;
    v4 = 68;
LABEL_3:
    ERR_put_error(16, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_buffer.cc", v4);
    return 0;
  }
  if (*((unsigned __int16 *)this + 7) < a3)
  {
    if (a3 <= 5)
    {
      v12 = 0;
      v11 = (char *)this + 18;
      LOWORD(v9) = a3;
    }
    else
    {
      if (a3 <= 0x4145)
        v9 = 16709;
      else
        v9 = a3;
      v10 = (char *)malloc_type_malloc(v9 + 7, 0x8BDA0CE4uLL);
      if (!v10)
      {
        v3 = 65;
        v4 = 99;
        goto LABEL_3;
      }
      v11 = v10;
      v12 = (-a2 - (int)v10) & 7;
    }
    if (*((_WORD *)this + 6))
      memmove(&v11[v12], (const void *)(*(_QWORD *)this + *((unsigned __int16 *)this + 4)), *((unsigned __int16 *)this + 6));
    if (*((_BYTE *)this + 23))
      free(*(void **)this);
    *(_QWORD *)this = v11;
    *((_BYTE *)this + 23) = a3 > 5;
    *((_WORD *)this + 4) = v12;
    *((_WORD *)this + 7) = v9;
    *((_WORD *)this + 8) = v9;
    *((_WORD *)this + 5) = v12;
  }
  return 1;
}

uint64_t bssl::ssl_record_prefix_len(unsigned __int8 **this, const ssl_st *a2)
{
  uint64_t v3;

  if (SSL_is_dtls(this))
    v3 = 13;
  else
    v3 = 5;
  return bssl::SSLAEADContext::ExplicitNonceLen(*((bssl::SSLAEADContext **)this[6] + 33)) + v3;
}

uint64_t bssl::SSLAEADContext::ExplicitNonceLen(bssl::SSLAEADContext *this)
{
  if ((*((_BYTE *)this + 625) & 1) != 0)
    return *((unsigned __int8 *)this + 621);
  else
    return 0;
}

int *ERR_clear_system_error()
{
  int *result;

  result = __error();
  *result = 0;
  return result;
}

void ERR_clear_error(void)
{
  _QWORD *state;
  _QWORD *v1;
  uint64_t i;
  _QWORD *v3;

  state = err_get_state();
  if (state)
  {
    v1 = state;
    for (i = 0; i != 48; i += 3)
    {
      v3 = &v1[i];
      free((void *)v1[i + 1]);
      *v3 = 0;
      v3[1] = 0;
      v3[2] = 0;
    }
    free((void *)v1[49]);
    v1[48] = 0;
    v1[49] = 0;
  }
}

_QWORD *err_get_state()
{
  _QWORD *thread_local;
  _OWORD *v2;

  thread_local = CRYPTO_get_thread_local(0);
  if (!thread_local)
  {
    v2 = malloc_type_malloc(0x190uLL, 0x10D00400F8CE868uLL);
    thread_local = v2;
    if (v2)
    {
      v2[23] = 0u;
      v2[24] = 0u;
      v2[21] = 0u;
      v2[22] = 0u;
      v2[19] = 0u;
      v2[20] = 0u;
      v2[17] = 0u;
      v2[18] = 0u;
      v2[15] = 0u;
      v2[16] = 0u;
      v2[13] = 0u;
      v2[14] = 0u;
      v2[11] = 0u;
      v2[12] = 0u;
      v2[9] = 0u;
      v2[10] = 0u;
      v2[7] = 0u;
      v2[8] = 0u;
      v2[5] = 0u;
      v2[6] = 0u;
      v2[3] = 0u;
      v2[4] = 0u;
      v2[1] = 0u;
      v2[2] = 0u;
      *v2 = 0u;
      if (!CRYPTO_set_thread_local(0, (uint64_t)v2, (void (*)(uint64_t))err_state_free))
        return 0;
    }
  }
  return thread_local;
}

_QWORD *CRYPTO_get_thread_local(int a1)
{
  _QWORD *result;

  if (pthread_once(&g_thread_local_init_once, (void (*)(void))thread_local_init))
    abort();
  if (!g_thread_local_key_created)
    return 0;
  result = pthread_getspecific(g_thread_local_key);
  if (result)
    return (_QWORD *)result[a1];
  return result;
}

uint64_t bssl::SSLAEADContext::RecordVersion(bssl::SSLAEADContext *this)
{
  if (*((_WORD *)this + 311))
  {
    if (bssl::SSLAEADContext::ProtocolVersion(this) > 0x303)
      return 771;
    else
      return (unsigned __int16)*((_WORD *)this + 311);
  }
  else
  {
    if (*(_QWORD *)this)
      bssl::SSLAEADContext::RecordVersion();
    if (*((_BYTE *)this + 624))
      return (unsigned __int16)-257;
    else
      return 769;
  }
}

uint64_t bssl::SSLAEADContext::ProtocolVersion(bssl::SSLAEADContext *this)
{
  unsigned __int16 v2;

  v2 = -21846;
  if ((bssl::ssl_protocol_version_from_wire((bssl *)&v2, (unsigned __int16 *)*((unsigned __int16 *)this + 311)) & 1) == 0)
    bssl::SSLAEADContext::ProtocolVersion();
  return v2;
}

uint64_t bssl::ssl_protocol_version_from_wire(bssl *this, unsigned __int16 *a2)
{
  if (((_DWORD)a2 - 769) < 4)
    goto LABEL_6;
  if ((_DWORD)a2 == 65277)
  {
    LOWORD(a2) = 771;
    goto LABEL_6;
  }
  if ((_DWORD)a2 == 65279)
  {
    LOWORD(a2) = 770;
LABEL_6:
    *(_WORD *)this = (_WORD)a2;
    return 1;
  }
  return 0;
}

uint64_t CBS_data(uint64_t a1)
{
  return *(_QWORD *)a1;
}

void boringssl_context_message_handler(int a1, int a2, uint64_t a3, char *a4, size_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v15;
  char *v16;
  id *v17;
  id WeakRetained;
  void *v19;
  _BYTE *v20;
  char v21;
  id v22;
  _BYTE *v23;
  _BOOL4 v24;
  id *v25;
  id v26;
  void *v27;
  _BYTE *v28;
  char v29;
  id v30;
  _BYTE *v31;
  _BOOL4 v32;
  NSObject *v33;
  id v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  dispatch_data_t v42;
  NSObject *v43;
  NSObject *v44;
  id v45;
  void *v46;
  const char *v47;
  char *v48;
  uint64_t block;
  uint64_t v50;
  uint64_t (*v51)(uint64_t);
  void *v52;
  dispatch_data_t v53;
  uint64_t v54;
  uint64_t v55;
  _BYTE buf[40];
  const char *v57;
  _BYTE v58[20];
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a3 == 256 && a2 == 0 || a7 == 0)
    return;
  if (*(_DWORD *)a7 != -1252936367)
    return;
  v10 = *(_QWORD *)(a7 + 8);
  if (!v10 || (_DWORD)a3 == 23 && boringssl_session_get_state(a7) > 1)
    return;
  boringssl_session_update_flight_time(a7, a1, a5);
  if (*(_DWORD *)a7 != -1252936367)
    goto LABEL_35;
  v15 = *(_QWORD *)(a7 + 8);
  if (!v15)
    goto LABEL_35;
  if ((a3 - 20) < 4)
  {
    v16 = off_1E6879288[(int)a3 - 20];
    v17 = (id *)(v15 + 16);
    WeakRetained = objc_loadWeakRetained((id *)(v15 + 16));
    if (WeakRetained)
    {
      v19 = WeakRetained;
      v20 = objc_loadWeakRetained(v17);
      v21 = v20[475];

      if ((v21 & 1) != 0)
        goto LABEL_35;
    }
    v22 = objc_loadWeakRetained(v17);
    if (v22)
    {
      v23 = objc_loadWeakRetained(v17);
      v24 = (v23[475] & 1) == 0;

    }
    else
    {
      v24 = 1;
    }

    if (!v24 || !g_boringssl_log)
      goto LABEL_35;
    v33 = (id)g_boringssl_log;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      v34 = objc_loadWeakRetained(v17);
      if (v34)
      {
        v48 = (char *)objc_loadWeakRetained(v17);
        v35 = v48 + 391;
      }
      else
      {
        v35 = &unk_1B50022E3;
      }
      v45 = objc_loadWeakRetained(v17);
      v46 = v45;
      *(_DWORD *)buf = 136447746;
      *(_QWORD *)&buf[4] = "boringssl_context_log_message";
      v47 = "Writing";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2299;
      *(_WORD *)&buf[18] = 2082;
      if (!a1)
        v47 = "Reading";
      *(_QWORD *)&buf[20] = v35;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = v45;
      *(_WORD *)&buf[38] = 2082;
      v57 = v47;
      *(_WORD *)v58 = 2082;
      *(_QWORD *)&v58[2] = v16;
      *(_WORD *)&v58[10] = 2048;
      *(_QWORD *)&v58[12] = a5;
      _os_log_debug_impl(&dword_1B4F6D000, v33, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] %{public}s %{public}s %zu bytes", buf, 0x44u);

      if (v34)
    }
LABEL_34:

LABEL_35:
    if ((_DWORD)a3 == 22)
    {
      if (a4)
      {
        if (a5)
        {
          v41 = *a4;
          *(_BYTE *)(v10 + 308) = *a4;
          if (*(_QWORD *)(v10 + 208))
          {
            if (*(_QWORD *)(v10 + 216))
            {
              v42 = dispatch_data_create(a4, a5, 0, 0);
              v43 = *(NSObject **)(v10 + 208);
              block = MEMORY[0x1E0C809B0];
              v50 = 3221225472;
              v51 = __boringssl_context_message_handler_block_invoke;
              v52 = &unk_1E6879168;
              LOBYTE(v55) = v41;
              v53 = v42;
              v54 = v10;
              v44 = v42;
              dispatch_async(v43, &block);

            }
          }
        }
      }
    }
    return;
  }
  v25 = (id *)(v15 + 16);
  v26 = objc_loadWeakRetained((id *)(v15 + 16));
  if (!v26
    || (v27 = v26, v28 = objc_loadWeakRetained(v25),
                   v29 = v28[475],
                   v28,
                   v27,
                   (v29 & 1) == 0))
  {
    v30 = objc_loadWeakRetained(v25);
    if (v30)
    {
      v31 = objc_loadWeakRetained(v25);
      v32 = (v31[475] & 1) == 0;

    }
    else
    {
      v32 = 1;
    }

    if (v32)
    {
      if (g_boringssl_log)
      {
        v33 = (id)g_boringssl_log;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
          boringssl_context_message_handler_cold_1((uint64_t)v25, a3, (uint64_t)v33, v36, v37, v38, v39, v40, (int)v48, block, v50, (uint64_t)v51, (uint64_t)v52, (uint64_t)v53, v54, v55, *(uint64_t *)buf, *(uint64_t *)&buf[8], *(uint64_t *)&buf[16],
            *(uint64_t *)&buf[24],
            *(uint64_t *)&buf[32],
            (uint64_t)v57,
            *(uint64_t *)v58,
            *(uint64_t *)&v58[8]);
        goto LABEL_34;
      }
    }
  }
}

uint64_t bssl::ssl_do_msg_callback(uint64_t ssl, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t (*v5)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t v10;
  uint64_t v11;

  v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(ssl + 64);
  if (v5)
  {
    v10 = ssl;
    if ((_DWORD)a3)
    {
      if ((_DWORD)a3 == 256)
      {
        v11 = 0;
      }
      else
      {
        v11 = SSL_version((const SSL *)ssl);
        v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(v10 + 64);
      }
    }
    else
    {
      v11 = 2;
    }
    return v5(a2, v11, a3, a4, a5, v10, *(_QWORD *)(v10 + 72));
  }
  return ssl;
}

BOOL bssl::SSLAEADContext::Open(bssl::SSLAEADContext *this, char **a2, char a3, __int16 a4, unint64_t a5, int a6, int a7, int a8, char *a9, unint64_t a10)
{
  char *v11;
  size_t v12;
  char v17;
  unint64_t v18;
  unsigned int v19;
  int v20;
  _BOOL8 result;
  size_t v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  _BYTE *v27;
  size_t v28;
  char v29;
  int v30;
  size_t v31;
  size_t v32;
  _QWORD __dst[6];

  v11 = a9;
  v12 = a10;
  __dst[5] = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)this)
  {
    *a2 = a9;
    a2[1] = (char *)a10;
    return 1;
  }
  v17 = *((_BYTE *)this + 625);
  if ((v17 & 8) != 0)
  {
    v19 = 0;
  }
  else
  {
    v18 = bssl::SSLAEADContext::MaxOverhead(this);
    v19 = a10 - v18;
    if (a10 < v18)
    {
      v20 = 256;
LABEL_22:
      ERR_put_error(16, 0, 112, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_aead_ctx.cc", v20);
      return 0;
    }
    v17 = *((_BYTE *)this + 625);
  }
  memset(&__dst[3], 170, 13);
  if ((v17 & 0x10) == 0)
  {
    __dst[3] = bswap64(a5);
    LOBYTE(__dst[4]) = a3;
    BYTE1(__dst[4]) = HIBYTE(a4);
    BYTE2(__dst[4]) = a4;
    if ((v17 & 8) == 0)
      *(_WORD *)((char *)&__dst[4] + 3) = bswap32(v19) >> 16;
  }
  memset(__dst, 170, 24);
  v22 = *((unsigned __int8 *)this + 620);
  v23 = *((unsigned __int8 *)this + 620);
  if ((v17 & 4) != 0)
  {
    v22 -= *((unsigned __int8 *)this + 621);
    if (v22)
      bzero(__dst, v22);
  }
  else if (*((_BYTE *)this + 620))
  {
    memcpy(__dst, (char *)this + 608, *((unsigned __int8 *)this + 620));
  }
  else
  {
    v22 = 0;
  }
  v24 = *((unsigned __int8 *)this + 621);
  if ((v17 & 1) != 0)
  {
    v12 = a10 - v24;
    if (a10 < v24)
    {
      v20 = 283;
      goto LABEL_22;
    }
    if (*((_BYTE *)this + 621))
      memcpy((char *)__dst + v22, a9, *((unsigned __int8 *)this + 621));
    v11 = &a9[v24];
  }
  else
  {
    if ((_DWORD)v24 != 8)
      bssl::SSLAEADContext::Open();
    *(_QWORD *)((char *)__dst + v22) = bswap64(a5);
    v24 = 8;
  }
  v25 = v22 + v24;
  if ((v17 & 4) != 0)
  {
    if (v25 != v23)
      bssl::SSLAEADContext::Open();
    if (v23)
    {
      v26 = (char *)this + 608;
      v27 = __dst;
      v28 = v22 + v24;
      do
      {
        v29 = *v26++;
        *v27++ ^= v29;
        --v28;
      }
      while (v28);
    }
  }
  v32 = 0xAAAAAAAAAAAAAAAALL;
  v30 = EVP_AEAD_CTX_open((unsigned __int8 *)this + 8, v11, &v32, v12, (uint64_t)__dst, v25, v11, v12);
  result = v30 != 0;
  if (v30)
  {
    v31 = v32;
    if (v12 < v32)
      v31 = v12;
    *a2 = v11;
    a2[1] = (char *)v31;
  }
  return result;
}

uint64_t bssl::SSLAEADContext::MaxOverhead(bssl::SSLAEADContext *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if ((*((_BYTE *)this + 625) & 1) != 0)
    v1 = *((unsigned __int8 *)this + 621);
  else
    v1 = 0;
  if (*(_QWORD *)this)
  {
    v2 = EVP_AEAD_CTX_aead((uint64_t)this + 8);
    v3 = EVP_AEAD_max_overhead(v2);
  }
  else
  {
    v3 = 0;
  }
  return v3 + v1;
}

uint64_t EVP_AEAD_max_overhead(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 2);
}

uint64_t EVP_AEAD_CTX_aead(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t EVP_AEAD_CTX_open(unsigned __int8 *a1, char *a2, size_t *a3, size_t a4, uint64_t a5, uint64_t a6, char *a7, unint64_t a8)
{
  int v11;
  int v12;
  size_t v13;
  uint64_t result;
  unsigned int (*v15)(unsigned __int8 *, char *);
  unint64_t v16;

  if (a7 != a2 && &a2[a4] > a7 && &a7[a8] > a2)
  {
    v11 = 115;
    v12 = 191;
    goto LABEL_5;
  }
  v15 = *(unsigned int (**)(unsigned __int8 *, char *))(*(_QWORD *)a1 + 32);
  if (!v15)
  {
    v16 = a1[592];
    if (!a1[592])
      EVP_AEAD_CTX_open_cold_1();
    v13 = a8 - v16;
    if (a8 >= v16)
    {
      if (v13 <= a4)
      {
        if (EVP_AEAD_CTX_open_gather((uint64_t)a1, a2, a5, a6, a7, a8 - v16))
        {
          result = 1;
LABEL_9:
          *a3 = v13;
          return result;
        }
LABEL_6:
        if (a4)
          bzero(a2, a4);
        v13 = 0;
        result = 0;
        goto LABEL_9;
      }
      v11 = 103;
      v12 = 214;
    }
    else
    {
      v11 = 101;
      v12 = 208;
    }
LABEL_5:
    ERR_put_error(30, 0, v11, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", v12);
    goto LABEL_6;
  }
  if (!v15(a1, a2))
    goto LABEL_6;
  return 1;
}

uint64_t EVP_AEAD_CTX_open_gather(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, char *a5, size_t a6)
{
  int v8;
  int v9;
  unsigned int (*v10)(uint64_t, char *);

  if (a5 != a2 && &a5[a6] > a2 && &a2[a6] > a5)
  {
    v8 = 115;
    v9 = 238;
LABEL_9:
    ERR_put_error(30, 0, v8, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", v9);
    goto LABEL_10;
  }
  v10 = *(unsigned int (**)(uint64_t, char *))(*(_QWORD *)a1 + 48);
  if (!v10)
  {
    v8 = 104;
    v9 = 243;
    goto LABEL_9;
  }
  if (v10(a1, a2))
    return 1;
LABEL_10:
  if (a6)
    bzero(a2, a6);
  return 0;
}

uint64_t aead_aes_gcm_open_gather(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  int v10;
  int v11;
  int v12;

  if (!a4)
  {
    v11 = 111;
    v12 = 373;
    goto LABEL_10;
  }
  if (*(unsigned __int8 *)(a1 + 592) != a8)
  {
    v11 = 101;
    v12 = 377;
    goto LABEL_10;
  }
  if (!*(_QWORD *)(a1 + 8) || !*(_QWORD *)(a1 + 16))
  {
    v11 = 112;
    v12 = 381;
    goto LABEL_10;
  }
  v10 = ccgcm_reset();
  if (ccgcm_set_iv() | v10)
  {
    v11 = 107;
    v12 = 388;
LABEL_10:
    ERR_put_error(30, 0, v11, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_aes.m", v12);
    return 0;
  }
  if (a10 && ccgcm_aad())
  {
    if (g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        aead_aes_gcm_open_gather_cold_3();
    }
    v11 = 101;
    v12 = 396;
    goto LABEL_10;
  }
  if (ccgcm_update())
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      aead_aes_gcm_open_gather_cold_2();
    v11 = 101;
    v12 = 404;
    goto LABEL_10;
  }
  if (ccgcm_finalize())
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      aead_aes_gcm_open_gather_cold_1();
    v11 = 101;
    v12 = 411;
    goto LABEL_10;
  }
  return 1;
}

uint64_t BIO_set_retry_read(uint64_t result)
{
  *(_DWORD *)(result + 16) |= 9u;
  return result;
}

uint64_t CBS_get_u24(uint64_t *a1, int *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v5;
  int v6;
  uint64_t v7;

  v2 = a1[1];
  v3 = v2 - 3;
  if (v2 < 3)
    return 0;
  v5 = 0;
  v6 = 0;
  v7 = *a1;
  *a1 += 3;
  a1[1] = v3;
  do
    v6 = *(unsigned __int8 *)(v7 + v5++) | (v6 << 8);
  while (v5 != 3);
  *a2 = v6;
  return 1;
}

BOOL bssl::tls_has_unprocessed_handshake_data(bssl *this, const ssl_st *a2)
{
  uint64_t v2;
  unint64_t v3;
  __int128 v5;
  unint64_t *v6;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  unint64_t v11;

  v2 = *((_QWORD *)this + 6);
  if ((*(_WORD *)(v2 + 220) & 0x10) != 0)
  {
    v11 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9 = v5;
    v10 = v5;
    if (bssl::parse_message((uint64_t)this, (uint64_t)&v9, &v8))
      v3 = CBS_len((uint64_t)&v10 + 8);
    else
      v3 = 0;
    v2 = *((_QWORD *)this + 6);
  }
  else
  {
    v3 = 0;
  }
  v6 = *(unint64_t **)(v2 + 224);
  return v6 && *v6 > v3;
}

int SSL_version(const SSL *ssl)
{
  const ssl_st *v1;

  return bssl::ssl_version((bssl *)ssl, v1);
}

uint64_t bssl::ssl_version(bssl *this, const ssl_st *a2)
{
  unsigned __int16 *v3;

  if (!SSL_in_early_data((uint64_t)this) || (*((_BYTE *)this + 180) & 1) != 0)
    v3 = (unsigned __int16 *)((char *)this + 16);
  else
    v3 = (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 6) + 280) + 1544) + 4);
  return *v3;
}

uint64_t boringssl_session_in_early_data(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
    {
      result = *(_QWORD *)(v1 + 400);
      if (result)
        return SSL_in_early_data(result) != 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SSL_in_early_data(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 280);
  if (v1)
    return (*(_DWORD *)(v1 + 1600) >> 11) & 1;
  else
    return 0;
}

uint64_t boringssl_session_update_flight_time(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3;
  int *v6;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      v3 = *(_QWORD *)(result + 8);
      if (v3)
      {
        if (*(_DWORD *)(v3 + 300) <= 1u)
        {
          result = boringssl_session_in_early_data(result);
          if ((result & 1) == 0)
          {
            if ((*(_BYTE *)(v3 + 556) & 1) != 0 && ((*(unsigned __int8 *)(v3 + 558) >> 1) & 1) != a2)
            {
              if (*(_QWORD *)(v3 + 440))
              {
                result = boringssl_helper_get_current_time_ms();
                *(_QWORD *)(v3 + 448) += result - *(_QWORD *)(v3 + 440);
                *(_QWORD *)(v3 + 440) = 0;
                if (!*(_QWORD *)(v3 + 464))
                  *(_QWORD *)(v3 + 464) = result;
              }
            }
            else
            {
              result = boringssl_helper_get_current_time_ms();
              *(_QWORD *)(v3 + 440) = result;
              if (!*(_QWORD *)(v3 + 456))
                *(_QWORD *)(v3 + 456) = *(_QWORD *)(v3 + 440);
              *(_BYTE *)(v3 + 558) = *(_BYTE *)(v3 + 558) & 0xFD | (2 * (a2 & 1));
              *(_BYTE *)(v3 + 556) |= 1u;
            }
            v6 = &OBJC_IVAR___boringssl_concrete_boringssl_ctx_inbound_byte_count;
            if (a2 == 1)
              v6 = &OBJC_IVAR___boringssl_concrete_boringssl_ctx_outbound_byte_count;
            *(_QWORD *)(v3 + *v6) += a3;
          }
        }
      }
    }
  }
  return result;
}

__darwin_time_t boringssl_helper_get_current_time_ms()
{
  timeval v1;

  v1.tv_sec = 0;
  *(_QWORD *)&v1.tv_usec = 0;
  gettimeofday(&v1, 0);
  return 1000 * v1.tv_sec + v1.tv_usec / 1000;
}

uint64_t bssl::ssl_cipher_process_rulestr(char *a1, uint64_t **a2, _QWORD *a3, int a4)
{
  char v4;
  char v5;
  const char *v6;
  char v7;
  unsigned int v8;
  int v9;
  char v10;
  const char *i;
  size_t j;
  unsigned __int8 v13;
  int v14;
  uint64_t v16;
  const char *v17;
  const char *v18;
  uint64_t k;
  const char *v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;
  _QWORD *v24;
  uint64_t *m;
  unsigned int bits;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  char v35;
  unsigned __int16 v37;
  int v38;
  int v39;
  int v40;
  int v41;
  char v43;
  int v44;
  char v45;
  unsigned int v47;
  char v48;
  void *v49[2];

  v4 = *a1;
  if (!*a1)
    return 1;
  v5 = a4;
  v6 = a1;
  v7 = 0;
LABEL_3:
  v43 = v7;
  v35 = v7;
  while (1)
  {
    while (1)
    {
      v8 = v4;
      if ((v43 & 1) == 0)
      {
        v48 = 0;
        v44 = 1;
        if (v4 <= 0x2Cu)
        {
          if (v4 == 33)
          {
            v48 = 0;
            v9 = 2;
          }
          else
          {
            if (v4 != 43)
              goto LABEL_21;
            v48 = 0;
            v9 = 4;
          }
        }
        else
        {
          if (v4 != 45)
          {
            if (v4 != 64)
            {
              if (v4 == 91)
              {
                v31 = *(unsigned __int8 *)++v6;
                v4 = v31;
                v7 = 1;
                if (v31)
                  goto LABEL_3;
                goto LABEL_106;
              }
              goto LABEL_21;
            }
            v44 = 5;
            v48 = 1;
            goto LABEL_19;
          }
          v9 = 3;
        }
        v44 = v9;
LABEL_19:
        if ((v7 & 1) != 0)
        {
          v32 = 168;
          v33 = 1214;
          goto LABEL_112;
        }
        ++v6;
        goto LABEL_21;
      }
      if (v4 != 124)
        break;
      v43 = 1;
LABEL_100:
      v30 = *(unsigned __int8 *)++v6;
      v4 = v30;
      if (!v30)
        goto LABEL_105;
    }
    if (v4 == 93)
    {
      v43 = 0;
      if (*a3)
        *(_BYTE *)(*a3 + 9) = 0;
      goto LABEL_100;
    }
    if (!OPENSSL_isalnum(v4))
    {
      v32 = 224;
      v33 = 1184;
      goto LABEL_112;
    }
    v48 = 0;
    v44 = 1;
LABEL_21:
    if (v8 == 58 || (v5 & 1) != 0)
    {
      if (v8 != 58)
        break;
      goto LABEL_25;
    }
    if (v8 > 0x3B || ((1 << v8) & 0x800100100000000) == 0)
      break;
LABEL_25:
    ++v6;
LABEL_26:
    v4 = *v6;
    if (!*v6)
      goto LABEL_105;
  }
  v45 = 0;
  v47 = 0;
  v10 = 1;
  v40 = -1;
  v41 = -1;
  v39 = -1;
  v37 = 0;
  v38 = -1;
  for (i = v6; ; i += j + 1)
  {
    for (j = 0; ; ++j)
    {
      v13 = i[j];
      if (!OPENSSL_isalnum((char)v13))
      {
        v14 = v13;
        if (v13 - 45 > 0x32 || ((1 << (v13 - 45)) & 0x4000000000003) == 0)
          break;
      }
    }
    if (!j)
    {
      v32 = 158;
      v33 = 1244;
      goto LABEL_112;
    }
    if ((v48 & 1) != 0)
      break;
    if (v13 != 43 && (v10 & 1) != 0)
    {
      v16 = 0;
      while (1)
      {
        v17 = bssl::kCiphers[v16];
        if (!strncmp(v17, i, j) && !v17[j])
          break;
        v18 = bssl::kCiphers[v16 + 1];
        if (!strncmp(v18, i, j) && !v18[j])
          break;
        v16 += 5;
        if (v16 == 185)
          goto LABEL_48;
      }
      v47 = bssl::kCiphers[v16 + 2];
    }
LABEL_48:
    if (!v47)
    {
      for (k = 0; k != 116; k += 4)
      {
        v20 = (&bssl::kCipherAliases)[k];
        if (!strncmp(v20, i, j) && !v20[j])
        {
          v40 &= *((_DWORD *)&bssl::kCipherAliases + 2 * k + 3);
          v41 &= LODWORD((&bssl::kCipherAliases)[k + 1]);
          v38 &= *((_DWORD *)&bssl::kCipherAliases + 2 * k + 5);
          v39 &= LODWORD((&bssl::kCipherAliases)[k + 2]);
          if (v37)
          {
            if (LOWORD((&bssl::kCipherAliases)[k + 3]) != v37)
              goto LABEL_54;
          }
          else
          {
            v37 = (unsigned __int16)(&bssl::kCipherAliases)[k + 3];
          }
          goto LABEL_55;
        }
      }
      if (!a4)
      {
LABEL_54:
        v45 = 1;
        goto LABEL_55;
      }
      v32 = 158;
      v33 = 1285;
      goto LABEL_112;
    }
LABEL_55:
    if (v14 != 43)
    {
      v6 = &i[j];
      if ((v45 & 1) == 0)
        bssl::ssl_cipher_apply_rule(v47, v41, v40, v39, v38, v37, v44, -1, v43 & 1, a2, a3);
      v5 = a4;
      v7 = v35;
      goto LABEL_26;
    }
    v10 = 0;
  }
  if (j != 8 || strncmp(v6, "STRENGTH", 8uLL))
  {
    v32 = 158;
    v33 = 1302;
    goto LABEL_112;
  }
  v21 = *a2;
  if (*a2)
  {
    LODWORD(v22) = 0;
    do
    {
      if (*((_BYTE *)v21 + 8) && SSL_CIPHER_get_bits((const SSL_CIPHER *)*v21, 0) > (int)v22)
        LODWORD(v22) = SSL_CIPHER_get_bits((const SSL_CIPHER *)*v21, 0);
      v21 = (uint64_t *)v21[2];
    }
    while (v21);
  }
  else
  {
    LODWORD(v22) = 0;
  }
  v49[0] = 0;
  v49[1] = 0;
  v23 = bssl::Array<int>::Init((uint64_t)v49, (v22 + 1));
  v24 = v49[0];
  if ((v23 & 1) != 0)
  {
    bzero(v49[0], 4 * (v22 + 1));
    for (m = *a2; m; m = (uint64_t *)m[2])
    {
      if (*((_BYTE *)m + 8))
      {
        bits = SSL_CIPHER_get_bits((const SSL_CIPHER *)*m, 0);
        ++*((_DWORD *)v49[0] + bits);
      }
    }
    v22 = v22;
    do
    {
      if (*((int *)v49[0] + v22) >= 1)
        bssl::ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 4, v22, 0, a2, a3);
    }
    while (v22-- > 0);
    v24 = v49[0];
  }
  OPENSSL_free(v24);
  if (v23)
  {
    v6 = i + 8;
    v28 = *((unsigned __int8 *)i + 8);
    v5 = a4;
    v7 = v35;
    if (v28)
    {
      do
      {
        if (v28 == 58 || (a4 & 1) != 0)
        {
          if (v28 == 58)
            goto LABEL_26;
        }
        else if (v28 <= 0x3B && ((1 << v28) & 0x800100100000000) != 0)
        {
          goto LABEL_26;
        }
        v29 = *(unsigned __int8 *)++v6;
        v28 = v29;
      }
      while (v29);
    }
LABEL_105:
    if ((v43 & 1) == 0)
      return 1;
LABEL_106:
    v32 = 158;
    v33 = 1321;
LABEL_112:
    ERR_put_error(16, 0, v32, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cipher.cc", v33);
  }
  return 0;
}

void sub_1B4F73518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL OPENSSL_isalnum(int a1)
{
  return (a1 - 48) < 0xA || (a1 & 0xFFFFFFDF) - 65 < 0x1A;
}

uint64_t bssl::ssl_cipher_apply_rule(uint64_t result, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t **a10, _QWORD *a11)
{
  int v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  BOOL v19;
  uint64_t *v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t *v39;

  v13 = result;
  if (a6 || (_DWORD)result || a8 != -1 || a2 && a3 && a4 && a5)
  {
    v14 = a11;
    v15 = *a10;
    v16 = (uint64_t *)*a11;
    if (a7 == 3)
      v17 = (uint64_t *)*a11;
    else
      v17 = *a10;
    if (a7 == 3)
      v18 = *a10;
    else
      v18 = (uint64_t *)*a11;
    if (v18)
      v19 = v17 == 0;
    else
      v19 = 1;
    if (v19)
      goto LABEL_100;
    while (1)
    {
      v39 = v15;
      v20 = v17;
      while (1)
      {
        if (a7 == 3)
          v21 = 3;
        else
          v21 = 2;
        v17 = (uint64_t *)v20[v21];
        result = *v20;
        if (v13)
        {
          if (*(_DWORD *)(result + 16) == v13)
            goto LABEL_48;
          goto LABEL_27;
        }
        if ((a8 & 0x80000000) == 0)
        {
          result = SSL_CIPHER_get_bits((const SSL_CIPHER *)result, 0);
          if ((_DWORD)result == a8)
            goto LABEL_48;
          goto LABEL_27;
        }
        v22 = *(_DWORD *)(result + 20);
        if ((v22 & a2) == 0)
          goto LABEL_27;
        v23 = *(_DWORD *)(result + 24);
        if ((v23 & a3) == 0)
          goto LABEL_27;
        v24 = *(_DWORD *)(result + 28);
        if ((v24 & a4) == 0 || (*(_DWORD *)(result + 32) & a5) == 0)
          goto LABEL_27;
        if (a6)
          break;
        if (v24 != 32)
          goto LABEL_48;
LABEL_27:
        if (v20 != v18)
        {
          v20 = v17;
          if (v17)
            continue;
        }
        v14 = a11;
        v15 = v39;
        goto LABEL_100;
      }
      if (v22 == 16 || v23 == 8)
      {
        v26 = 772;
      }
      else if (*(_DWORD *)(result + 36) == 1)
      {
        v26 = 768;
      }
      else
      {
        v26 = 771;
      }
      if (v24 == 32 || v26 != a6)
        goto LABEL_27;
LABEL_48:
      v27 = v20 + 2;
      if (a7 != 4)
      {
        if (a7 != 1)
        {
          if (a7 == 3)
          {
            if (!*((_BYTE *)v20 + 8))
              goto LABEL_82;
            v15 = v39;
            if (v39 != v20)
            {
              v33 = v20[2];
              v32 = v20[3];
              if (v16 == v20)
                v16 = (uint64_t *)v20[3];
              if (v33)
              {
                *(_QWORD *)(v33 + 24) = v32;
                v32 = v20[3];
              }
              if (v32)
                *(_QWORD *)(v32 + 16) = v33;
              v39[3] = (uint64_t)v20;
              v20[2] = (uint64_t)v39;
              v20[3] = 0;
              v15 = v20;
            }
            *((_WORD *)v20 + 4) = 0;
          }
          else
          {
            if (a7 != 2)
              goto LABEL_82;
            v34 = (uint64_t *)v20[3];
            v15 = v39;
            if (v39 == v20)
              v15 = (uint64_t *)v20[2];
            else
              v34[2] = v20[2];
            if (v16 == v20)
              v16 = v34;
            *((_BYTE *)v20 + 8) = 0;
            v35 = v20[2];
            if (v35)
            {
              *(_QWORD *)(v35 + 24) = v34;
              v34 = (uint64_t *)v20[3];
            }
            if (v34)
              v34[2] = v35;
            *v27 = 0;
            v20[3] = 0;
          }
          v14 = a11;
          goto LABEL_96;
        }
        if (!*((_BYTE *)v20 + 8))
        {
          v15 = v39;
          if (v16 == v20)
          {
            v14 = a11;
          }
          else
          {
            v28 = v20[2];
            v29 = v20[3];
            if (v39 == v20)
              v15 = (uint64_t *)v20[2];
            if (v29)
            {
              *(_QWORD *)(v29 + 16) = v28;
              v28 = *v27;
            }
            v14 = a11;
            if (v28)
              *(_QWORD *)(v28 + 24) = v29;
            v16[2] = (uint64_t)v20;
            v20[2] = 0;
            v20[3] = (uint64_t)v16;
            v16 = v20;
          }
          *((_BYTE *)v20 + 8) = 1;
          *((_BYTE *)v20 + 9) = a9;
          goto LABEL_96;
        }
LABEL_82:
        v14 = a11;
        v15 = v39;
        goto LABEL_96;
      }
      if (!*((_BYTE *)v20 + 8))
        goto LABEL_82;
      if (v16 == v20)
      {
        v14 = a11;
        v15 = v39;
      }
      else
      {
        v15 = v39;
        v30 = v20[2];
        v31 = v20[3];
        if (v39 == v20)
          v15 = (uint64_t *)v20[2];
        if (v31)
        {
          *(_QWORD *)(v31 + 16) = v30;
          v30 = *v27;
        }
        v14 = a11;
        if (v30)
          *(_QWORD *)(v30 + 24) = v31;
        v16[2] = (uint64_t)v20;
        v20[2] = 0;
        v20[3] = (uint64_t)v16;
        v16 = v20;
      }
      *((_BYTE *)v20 + 9) = 0;
LABEL_96:
      if (v20 == v18 || !v17)
      {
LABEL_100:
        *a10 = v15;
        *v14 = v16;
        return result;
      }
    }
  }
  return result;
}

void ERR_put_error(int lib, int func, int reason, const char *file, int line)
{
  __int16 v5;
  _QWORD *state;
  _QWORD *v10;
  int v11;
  int v12;
  const char **v13;

  v5 = line;
  state = err_get_state();
  if (state)
  {
    v10 = state;
    if (lib == 2 && !reason)
      reason = *__error();
    v11 = *((_DWORD *)v10 + 96);
    v12 = ((_BYTE)v11 + 1) & 0xF;
    *((_DWORD *)v10 + 96) = v12;
    if (v12 == *((_DWORD *)v10 + 97))
      *((_DWORD *)v10 + 97) = ((_BYTE)v11 + 2) & 0xF;
    v13 = (const char **)&v10[3 * ((v11 + 1) & 0xF)];
    free((void *)v13[1]);
    v13[1] = 0;
    v13[2] = 0;
    *v13 = file;
    *((_WORD *)v13 + 10) = v5;
    *((_DWORD *)v13 + 4) = reason & 0xFFF | (lib << 24);
  }
}

uint64_t CRYPTO_set_thread_local(unsigned int a1, uint64_t a2, void (*a3)(uint64_t))
{
  void *v6;
  _OWORD *v8;

  if (pthread_once(&g_thread_local_init_once, (void (*)(void))thread_local_init))
    abort();
  if (!g_thread_local_key_created)
    goto LABEL_9;
  v6 = pthread_getspecific(g_thread_local_key);
  if (!v6)
  {
    v8 = malloc_type_malloc(0x28uLL, 0x80040B8603338uLL);
    if (!v8)
      goto LABEL_9;
    v6 = v8;
    *((_QWORD *)v8 + 4) = 0;
    *v8 = 0u;
    v8[1] = 0u;
    if (pthread_setspecific(g_thread_local_key, v8))
    {
      free(v6);
      goto LABEL_9;
    }
  }
  if (!pthread_mutex_lock(&g_destructors_lock))
  {
    *((_QWORD *)&g_destructors + a1) = a3;
    pthread_mutex_unlock(&g_destructors_lock);
    *((_QWORD *)v6 + a1) = a2;
    return 1;
  }
LABEL_9:
  a3(a2);
  return 0;
}

BOOL CBS_asn1_bitstring_has_bit(uint64_t a1, unsigned int a2)
{
  _BOOL8 result;
  unint64_t v5;

  result = CBS_is_valid_asn1_bitstring((unsigned __int8 **)a1);
  if (result)
  {
    v5 = (a2 >> 3) + 1;
    if (*(_QWORD *)(a1 + 8) <= v5)
      return 0;
    else
      return (*(unsigned __int8 *)(*(_QWORD *)a1 + v5) >> (~(_BYTE)a2 & 7)) & 1;
  }
  return result;
}

BOOL CBS_is_valid_asn1_bitstring(unsigned __int8 **a1)
{
  unsigned __int8 *v1;
  unsigned int v2;

  v1 = a1[1];
  if (!v1)
    return 0;
  v2 = **a1;
  if (v2 > 7)
    return 0;
  if (!**a1)
    return 1;
  if (v1 == (unsigned __int8 *)1)
    return 0;
  return ((*a1)[(_QWORD)v1 - 1] & ~(-1 << v2)) == 0;
}

void bssl::tls_open_app_data()
{
  __assert_rtn("tls_open_app_data", "s3_pkt.cc", 314, "!ssl->s3->aead_read_ctx->is_null_cipher()");
}

{
  __assert_rtn("tls_open_app_data", "s3_pkt.cc", 313, "ssl_can_read(ssl)");
}

uint64_t bssl::ssl_process_alert(bssl *a1, _BYTE *a2, unsigned __int8 *a3, uint64_t a4)
{
  int v7;
  int v8;
  const ssl_st *v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v22;

  if (a4 != 2)
  {
    *a2 = 50;
    v12 = 102;
    v13 = 551;
    goto LABEL_12;
  }
  bssl::ssl_do_msg_callback((uint64_t)a1, 0, 21, (uint64_t)a3, 2);
  v7 = *a3;
  v8 = a3[1];
  bssl::ssl_do_info_callback((uint64_t)a1, (const ssl_st *)0x4004);
  if (v7 == 2)
  {
    ERR_put_error(16, 0, v8 + 1000, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 592);
    ERR_add_error_dataf("SSL alert number %d", v14, v15, v16, v17, v18, v19, v20, v8);
    *a2 = 0;
    return 4;
  }
  if (v7 != 1)
  {
    *a2 = 47;
    v12 = 227;
    v13 = 599;
    goto LABEL_12;
  }
  v10 = *((_QWORD *)a1 + 6);
  if (v8)
  {
    if ((*(_WORD *)(v10 + 220) & 2) != 0)
    {
      v11 = bssl::ssl_protocol_version(a1, v9);
      if (v8 != 90 && v11 > 0x303)
      {
        *a2 = 50;
        v12 = 102;
        v13 = 578;
LABEL_12:
        ERR_put_error(16, 0, v12, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", v13);
        return 4;
      }
      v10 = *((_QWORD *)a1 + 6);
    }
    v22 = ++*(_BYTE *)(v10 + 211);
    if (v22 >= 5)
    {
      *a2 = 10;
      v12 = 220;
      v13 = 585;
      goto LABEL_12;
    }
    return 1;
  }
  else
  {
    *(_DWORD *)(v10 + 172) = 1;
    return 3;
  }
}

uint64_t __boringssl_helper_xpc_array_union_block_invoke(uint64_t a1, int a2, xpc_object_t value)
{
  xpc_array_append_value(*(xpc_object_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), value);
  return 1;
}

uint64_t __boringssl_context_set_ciphersuites_from_list_block_invoke(uint64_t a1, size_t a2)
{
  *(_WORD *)(*(_QWORD *)(a1 + 40) + 2 * a2) = xpc_array_get_uint64(*(xpc_object_t *)(a1 + 32), a2);
  return 1;
}

uint64_t EC_KEY_oct2key(EC_KEY *a1, const unsigned __int8 *a2, size_t a3, BN_CTX *a4)
{
  const EC_GROUP *v5;
  EC_POINT *v9;
  uint64_t v10;

  v5 = *(const EC_GROUP **)a1;
  if (v5)
  {
    v9 = EC_POINT_new(v5);
    if (v9 && EC_POINT_oct2point(*(const EC_GROUP **)a1, v9, a2, a3, a4))
      v10 = EC_KEY_set_public_key(a1, v9);
    else
      v10 = 0;
    EC_POINT_free(v9);
  }
  else
  {
    ERR_put_error(15, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", 397);
    return 0;
  }
  return v10;
}

void EC_POINT_free(EC_POINT *a1)
{
  if (a1)
  {
    EC_GROUP_free(*(EC_GROUP **)a1);
    OPENSSL_free(a1);
  }
}

EC_POINT *__cdecl EC_POINT_new(const EC_GROUP *a1)
{
  EC_POINT *v2;

  if (a1)
  {
    v2 = (EC_POINT *)OPENSSL_malloc(0xE0uLL);
    if (v2)
    {
      if (!*((_DWORD *)a1 + 10))
        CRYPTO_refcount_inc((unsigned int *)a1 + 76);
      *(_QWORD *)v2 = a1;
      ec_GFp_simple_point_init((uint64_t)v2 + 8);
    }
  }
  else
  {
    ERR_put_error(15, 0, 67, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", 681);
    return 0;
  }
  return v2;
}

double ec_GFp_simple_point_init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 64) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_QWORD *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_QWORD *)(a1 + 208) = 0;
  return result;
}

uint64_t tls1_P_hash(_BYTE *a1, unint64_t a2, EVP_MD *md, const void *a4, int a5, const unsigned __int8 *a6, size_t a7, const unsigned __int8 *a8, size_t len, const unsigned __int8 *a10, size_t a11)
{
  __int128 v19;
  unint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  __int128 v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unint64_t v32;
  char *v33;
  _BYTE *v34;
  unint64_t v35;
  char v36;
  int v37;
  uint64_t v38;
  unsigned int v40;
  unsigned int v41[61];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  unint64_t v47;
  _OWORD v48[4];
  _OWORD v49[4];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v47 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v19 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v45 = v19;
  v46 = v19;
  v43 = v19;
  v44 = v19;
  *(_OWORD *)&v41[57] = v19;
  v42 = v19;
  *(_QWORD *)&v41[53] = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v41[45] = v19;
  *(_OWORD *)&v41[49] = v19;
  *(_OWORD *)&v41[37] = v19;
  *(_OWORD *)&v41[41] = v19;
  *(_OWORD *)&v41[33] = v19;
  *(_OWORD *)&v41[29] = v19;
  *(_QWORD *)&v41[25] = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v41[17] = v19;
  *(_OWORD *)&v41[21] = v19;
  *(_OWORD *)&v41[9] = v19;
  *(_OWORD *)&v41[13] = v19;
  *(_OWORD *)&v41[1] = v19;
  *(_OWORD *)&v41[5] = v19;
  v49[2] = v19;
  v49[3] = v19;
  v49[0] = v19;
  v49[1] = v19;
  v41[0] = -1431655766;
  v20 = EVP_MD_size(md);
  HMAC_CTX_init((HMAC_CTX *)&v41[57]);
  HMAC_CTX_init((HMAC_CTX *)&v41[29]);
  HMAC_CTX_init((HMAC_CTX *)&v41[1]);
  HMAC_Init_ex((HMAC_CTX *)&v41[1], a4, a5, md, 0);
  if (v21)
  {
    if (HMAC_CTX_copy_ex((uint64_t)&v41[57], (uint64_t)&v41[1]))
    {
      HMAC_Update((HMAC_CTX *)&v41[57], a6, a7);
      if (v22)
      {
        HMAC_Update((HMAC_CTX *)&v41[57], a8, len);
        if (v23)
        {
          HMAC_Update((HMAC_CTX *)&v41[57], a10, a11);
          if (v24)
          {
            HMAC_Final((HMAC_CTX *)&v41[57], (unsigned __int8 *)v49, v41);
            if (v25)
            {
              while (1)
              {
                v40 = -1431655766;
                *(_QWORD *)&v26 = 0xAAAAAAAAAAAAAAAALL;
                *((_QWORD *)&v26 + 1) = 0xAAAAAAAAAAAAAAAALL;
                v48[2] = v26;
                v48[3] = v26;
                v48[0] = v26;
                v48[1] = v26;
                if (!HMAC_CTX_copy_ex((uint64_t)&v41[57], (uint64_t)&v41[1]))
                  break;
                HMAC_Update((HMAC_CTX *)&v41[57], (const unsigned __int8 *)v49, v41[0]);
                if (!v27 || a2 > v20 && !HMAC_CTX_copy_ex((uint64_t)&v41[29], (uint64_t)&v41[57]))
                  break;
                HMAC_Update((HMAC_CTX *)&v41[57], a6, a7);
                if (!v28)
                  break;
                HMAC_Update((HMAC_CTX *)&v41[57], a8, len);
                if (!v29)
                  break;
                HMAC_Update((HMAC_CTX *)&v41[57], a10, a11);
                if (!v30)
                  break;
                HMAC_Final((HMAC_CTX *)&v41[57], (unsigned __int8 *)v48, &v40);
                if (!v31)
                  break;
                if (v20 != v40)
                  tls1_P_hash_cold_1();
                if (a2 >= v20)
                  v32 = v20;
                else
                  v32 = a2;
                if (v32)
                {
                  v33 = (char *)v48;
                  v34 = a1;
                  v35 = v32;
                  do
                  {
                    v36 = *v33++;
                    *v34++ ^= v36;
                    --v35;
                  }
                  while (v35);
                }
                a2 -= v32;
                if (!a2)
                {
                  v38 = 1;
                  goto LABEL_26;
                }
                HMAC_Final((HMAC_CTX *)&v41[29], (unsigned __int8 *)v49, v41);
                if (!v37)
                  break;
                a1 += v32;
              }
            }
          }
        }
      }
    }
  }
  v38 = 0;
LABEL_26:
  OPENSSL_cleanse(v49, 0x40uLL);
  HMAC_CTX_cleanup((HMAC_CTX *)&v41[57]);
  HMAC_CTX_cleanup((HMAC_CTX *)&v41[29]);
  HMAC_CTX_cleanup((HMAC_CTX *)&v41[1]);
  return v38;
}

void HMAC_Update(HMAC_CTX *ctx, const unsigned __int8 *data, size_t len)
{
  EVP_DigestUpdate(&ctx->md_ctx, data, len);
}

void HMAC_CTX_init(HMAC_CTX *ctx)
{
  EVP_MD_CTX *p_md_ctx;

  ctx->md = 0;
  p_md_ctx = &ctx->md_ctx;
  EVP_MD_CTX_init(&ctx->i_ctx);
  EVP_MD_CTX_init(&ctx->o_ctx);
  EVP_MD_CTX_init(p_md_ctx);
}

void HMAC_CTX_cleanup(HMAC_CTX *ctx)
{
  EVP_MD_CTX_cleanup(&ctx->i_ctx);
  EVP_MD_CTX_cleanup(&ctx->o_ctx);
  EVP_MD_CTX_cleanup(&ctx->md_ctx);
  OPENSSL_cleanse(ctx, 0x68uLL);
}

void HMAC_Final(HMAC_CTX *ctx, unsigned __int8 *md, unsigned int *len)
{
  __int128 v6;
  EVP_MD_CTX *p_md_ctx;
  unsigned int s;
  unsigned __int8 mda[16];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  s = -1431655766;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11 = v6;
  v12 = v6;
  *(_OWORD *)mda = v6;
  v10 = v6;
  p_md_ctx = &ctx->md_ctx;
  if (!EVP_DigestFinal_ex(&ctx->md_ctx, mda, &s)
    || !EVP_MD_CTX_copy_ex(p_md_ctx, &ctx->o_ctx)
    || !EVP_DigestUpdate(p_md_ctx, mda, s)
    || !EVP_DigestFinal_ex(p_md_ctx, md, len))
  {
    *len = 0;
  }
}

uint64_t HMAC_CTX_copy_ex(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = EVP_MD_CTX_copy_ex((EVP_MD_CTX *)(a1 + 40), (const EVP_MD_CTX *)(a2 + 40));
  if ((_DWORD)result)
  {
    result = EVP_MD_CTX_copy_ex((EVP_MD_CTX *)(a1 + 72), (const EVP_MD_CTX *)(a2 + 72));
    if ((_DWORD)result)
    {
      result = EVP_MD_CTX_copy_ex((EVP_MD_CTX *)(a1 + 8), (const EVP_MD_CTX *)(a2 + 8));
      if ((_DWORD)result)
      {
        *(_QWORD *)a1 = *(_QWORD *)a2;
        return 1;
      }
    }
  }
  return result;
}

int PKCS1_MGF1(unsigned __int8 *mask, uint64_t len, const unsigned __int8 *seed, uint64_t seedlen, const EVP_MD *dgst)
{
  __int128 v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;
  __int128 v14;
  int v15;
  unsigned int d;
  EVP_MD_CTX ctx;
  unsigned __int8 md[16];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.digest = v10;
  *(_OWORD *)&ctx.flags = v10;
  EVP_MD_CTX_init(&ctx);
  v11 = EVP_MD_size(dgst);
  if (len)
  {
    v12 = v11;
    v13 = 0;
    while (1)
    {
      d = bswap32(v13);
      if (!EVP_DigestInit_ex(&ctx, dgst, 0)
        || !EVP_DigestUpdate(&ctx, seed, seedlen)
        || !EVP_DigestUpdate(&ctx, &d, 4uLL))
      {
        break;
      }
      if (len < v12)
      {
        *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v21 = v14;
        v22 = v14;
        *(_OWORD *)md = v14;
        v20 = v14;
        if (EVP_DigestFinal_ex(&ctx, md, 0))
        {
          memcpy(mask, md, len);
          goto LABEL_12;
        }
        break;
      }
      if (!EVP_DigestFinal_ex(&ctx, mask, 0))
        break;
      mask += v12;
      ++v13;
      len -= v12;
      if (!len)
        goto LABEL_12;
    }
    v15 = 0;
  }
  else
  {
LABEL_12:
    v15 = 1;
  }
  EVP_MD_CTX_cleanup(&ctx);
  return v15;
}

int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt)
{
  ((void (*)(EVP_MD_CTX *, const void *, size_t))ctx->digest->init)(ctx, d, cnt);
  return 1;
}

uint64_t digest_update_wrapper(uint64_t a1)
{
  return digest_update(*(_QWORD *)(a1 + 8));
}

uint64_t digest_update(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    digest_update_cold_1();
  result = CCDigestUpdate();
  if ((_DWORD)result)
    digest_update_cold_2();
  return result;
}

int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
{
  unint64_t final_high;
  ENGINE *v6;
  ENGINE *v7;

  if (ctx->digest == type)
    goto LABEL_5;
  final_high = HIDWORD(type->final);
  if (!(_DWORD)final_high)
    EVP_DigestInit_ex_cold_2();
  v6 = (ENGINE *)OPENSSL_malloc(final_high);
  if (v6)
  {
    v7 = v6;
    OPENSSL_free((_QWORD *)ctx->engine);
    ctx->digest = type;
    ctx->engine = v7;
LABEL_5:
    if (ctx->flags && !ctx->md_data)
      EVP_DigestInit_ex_cold_1();
    ((void (*)(EVP_MD_CTX *))type->flags)(ctx);
    LODWORD(v6) = 1;
  }
  return (int)v6;
}

uint64_t digest_init(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    digest_init_cold_1();
  result = CCDigestInit();
  if ((_DWORD)result)
    digest_init_cold_2();
  return result;
}

uint64_t sha256_init(uint64_t a1)
{
  return digest_init(*(_QWORD *)(a1 + 8));
}

uint64_t sha384_init(uint64_t a1)
{
  return digest_init(*(_QWORD *)(a1 + 8));
}

RSA *RSA_parse_public_key(__int128 *a1)
{
  RSA *v2;
  int v3;
  int v4;
  __int128 v6;

  v2 = RSA_new();
  if (v2)
  {
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_asn1(a1, &v6, 536870928)
      && parse_integer_0(&v6, (BIGNUM **)&v2->version)
      && parse_integer_0(&v6, (BIGNUM **)&v2->meth)
      && !CBS_len((uint64_t)&v6))
    {
      if (RSA_check_key(v2))
        return v2;
      v3 = 104;
      v4 = 106;
    }
    else
    {
      v3 = 100;
      v4 = 100;
    }
    ERR_put_error(4, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", v4);
    RSA_free(v2);
    return 0;
  }
  return v2;
}

BIGNUM *parse_integer(__int128 *a1, BIGNUM **a2)
{
  BIGNUM *result;

  if (*a2)
    parse_integer_cold_1();
  result = BN_new();
  *a2 = result;
  if (result)
    return (BIGNUM *)BN_parse_asn1_unsigned(a1, result);
  return result;
}

BIGNUM *parse_integer_0(__int128 *a1, BIGNUM **a2)
{
  BIGNUM *result;

  if (*a2)
    parse_integer_cold_1_0();
  result = BN_new();
  *a2 = result;
  if (result)
    return (BIGNUM *)BN_parse_asn1_unsigned(a1, result);
  return result;
}

BIGNUM *BN_new(void)
{
  BIGNUM *result;

  result = (BIGNUM *)OPENSSL_malloc(0x18uLL);
  if (result)
  {
    *(_QWORD *)&result->top = 0;
    *(_QWORD *)&result->neg = 0;
    result->d = 0;
    result->flags = 1;
  }
  return result;
}

BOOL BN_parse_asn1_unsigned(__int128 *a1, BIGNUM *a2)
{
  int v3;
  int v4;
  const unsigned __int8 *v6;
  int v7;
  unsigned int v8[5];

  memset(v8, 170, sizeof(v8));
  if (CBS_get_asn1(a1, &v8[1], 2) && CBS_is_valid_asn1_integer((unsigned __int8 **)&v8[1], v8))
  {
    if (!v8[0])
    {
      v6 = (const unsigned __int8 *)CBS_data((uint64_t)&v8[1]);
      v7 = CBS_len((uint64_t)&v8[1]);
      return BN_bin2bn(v6, v7, a2) != 0;
    }
    v3 = 109;
    v4 = 31;
  }
  else
  {
    v3 = 117;
    v4 = 26;
  }
  ERR_put_error(3, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bn_extra/bn_asn1.c", v4);
  return 0;
}

uint64_t ec_GFp_mont_felem_from_bytes(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  result = ec_GFp_simple_felem_from_bytes(a1, a2, a3, a4);
  if ((_DWORD)result)
  {
    bn_to_montgomery_small(a2, a2, *(int *)(a1 + 64), *(unint64_t ***)(a1 + 312));
    return 1;
  }
  return result;
}

uint64_t ec_GFp_simple_felem_from_bytes(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  int v9;

  if (BN_num_bytes((const BIGNUM *)(a1 + 56)) == a4)
  {
    bn_big_endian_to_words(a2, *(int *)(a1 + 64), a3, a4);
    if (bn_less_than_words((uint64_t *)a2, *(uint64_t **)(a1 + 56), *(int *)(a1 + 64)))
      return 1;
    v9 = 347;
  }
  else
  {
    v9 = 340;
  }
  ERR_put_error(15, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/simple.c", v9);
  return 0;
}

BIGNUM *__cdecl BN_bin2bn(const unsigned __int8 *s, int len, BIGNUM *ret)
{
  unint64_t v3;
  BIGNUM *v5;
  BIGNUM *v6;
  unint64_t v7;

  v3 = *(_QWORD *)&len;
  if (ret)
  {
    v5 = ret;
    v6 = 0;
  }
  else
  {
    v5 = BN_new();
    v6 = v5;
    if (!v5)
      return v5;
  }
  if (v3)
  {
    v7 = ((v3 - 1) >> 3) + 1;
    if (bn_wexpand(&v5->d, v7))
    {
      if (v3 >= 0x3FFFFFFF9)
        BN_bin2bn_cold_1();
      v5->top = v7;
      v5->neg = 0;
      bn_big_endian_to_words(v5->d, (int)v7, (uint64_t)s, v3);
    }
    else
    {
      BN_free(v6);
      return 0;
    }
  }
  else
  {
    v5->top = 0;
  }
  return v5;
}

uint64_t bn_wexpand(_QWORD **a1, unint64_t a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t result;
  _QWORD *v7;
  uint64_t v8;

  if (*((int *)a1 + 3) >= a2)
    return 1;
  v2 = a2;
  if (a2 < 0x800000)
  {
    if ((*((_BYTE *)a1 + 20) & 2) != 0)
    {
      v3 = 106;
      v4 = 360;
      goto LABEL_11;
    }
    result = (uint64_t)OPENSSL_malloc(8 * a2);
    if (!result)
      return result;
    v7 = (_QWORD *)result;
    v8 = *((int *)a1 + 2);
    if ((_DWORD)v8)
      memcpy((void *)result, *a1, 8 * v8);
    OPENSSL_free(*a1);
    *a1 = v7;
    *((_DWORD *)a1 + 3) = v2;
    return 1;
  }
  v3 = 102;
  v4 = 355;
LABEL_11:
  ERR_put_error(3, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/bn.c", v4);
  return 0;
}

void bn_big_endian_to_words(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;

  if (a2)
  {
    v4 = 0;
    v5 = a2;
    while ((unint64_t)(a4 + v4) > 7)
    {
      *a1++ = bswap64(*(_QWORD *)(a4 + a3 - 8 + v4));
      v4 -= 8;
      if (!--v5)
      {
        a4 += v4;
        goto LABEL_6;
      }
    }
    if (a4 + v4)
    {
      v6 = 0;
      v7 = 0;
      do
        v7 = *(unsigned __int8 *)(a3 + v6++) | (v7 << 8);
      while (v6 < a4 + v4);
    }
    else
    {
      v7 = 0;
    }
    *a1 = v7;
    v8 = v4 + 8 * a2;
    if (v8 != 8)
      bzero(a1 + 1, v8 - 8);
  }
  else
  {
LABEL_6:
    if (a4)
      bn_big_endian_to_words_cold_1();
  }
}

uint64_t bn_less_than_words(uint64_t *a1, uint64_t *a2, unint64_t a3)
{
  return bn_cmp_words_consttime(a1, a3, a2, a3) >> 31;
}

unint64_t bn_cmp_words_consttime(uint64_t *a1, unint64_t a2, uint64_t *a3, unint64_t a4)
{
  unint64_t v5;
  unint64_t result;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;

  if (a2 >= a4)
    v5 = a4;
  else
    v5 = a2;
  if (v5)
  {
    LODWORD(result) = 0;
    v7 = a1;
    v8 = a3;
    do
    {
      v10 = *v7++;
      v9 = v10;
      v11 = *v8++;
      v12 = (((v11 ^ v9) - 1) & ~(v11 ^ v9)) >> 63;
      v13 = ((v9 - v11) ^ v9 | v11 ^ v9) ^ v9;
      result = ~v12 & ((((v13 >> 63) & 1) == 0) | (unint64_t)(v13 >> 63)) | result & v12;
      --v5;
    }
    while (v5);
  }
  else
  {
    result = 0;
  }
  v14 = a2 - a4;
  if (a2 >= a4)
  {
    if (a4 < a2)
    {
      v19 = 0;
      v20 = &a1[a4];
      do
      {
        v21 = *v20++;
        v19 |= v21;
        --v14;
      }
      while (v14);
      return (((((v19 - 1) & ~v19) >> 63) & 1) == 0) | (((v19 - 1) & ~v19) >> 63) & result;
    }
  }
  else
  {
    v15 = 0;
    v16 = a4 - a2;
    v17 = &a3[a2];
    do
    {
      v18 = *v17++;
      v15 |= v18;
      --v16;
    }
    while (v16);
    return ~(((v15 - 1) & ~v15) >> 63) | (((v15 - 1) & ~v15) >> 63) & result;
  }
  return result;
}

void bn_to_montgomery_small(unint64_t *a1, unint64_t *a2, unint64_t a3, unint64_t **a4)
{
  bn_mod_mul_montgomery_small(a1, a2, *a4, a3, (uint64_t)a4);
}

BOOL CBS_is_valid_asn1_integer(unsigned __int8 **a1, unsigned int *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  unsigned int v4;
  int v6;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = (uint64_t)*a1;
  v4 = **a1;
  if (a2)
    *a2 = v4 >> 7;
  if (v2 == (unsigned __int8 *)1)
    return 1;
  v6 = *(char *)(v3 + 1);
  if (!v4 && (v6 & 0x80000000) == 0)
    return 0;
  return v4 != 255 || v6 >= 0;
}

uint64_t BN_marshal_asn1(uint64_t *a1, const BIGNUM *a2)
{
  int v4;
  int v5;
  __int128 v6;
  unsigned int v7;
  _OWORD v9[3];

  if (BN_is_negative((uint64_t)a2))
  {
    v4 = 109;
    v5 = 41;
  }
  else
  {
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[1] = v6;
    v9[2] = v6;
    v9[0] = v6;
    if (CBB_add_asn1(a1, (uint64_t)v9, 2u)
      && ((BN_num_bits(a2) & 7) != 0 || CBB_add_u8((uint64_t)v9, 0)))
    {
      v7 = BN_num_bytes(a2);
      if (BN_bn2cbb_padded((uint64_t)v9, v7, (uint64_t)a2))
      {
        if (CBB_flush(a1))
          return 1;
      }
    }
    v4 = 118;
    v5 = 52;
  }
  ERR_put_error(3, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bn_extra/bn_asn1.c", v5);
  return 0;
}

uint64_t BN_num_bytes(const BIGNUM *a1)
{
  return (BN_num_bits(a1) + 7) >> 3;
}

int BN_num_bits(const BIGNUM *a)
{
  uint64_t top;
  int v2;
  uint64_t v3;
  int v4;
  BOOL v5;
  unint64_t *d;
  uint64_t v7;

  top = a->top;
  v2 = top & ((int)top >> 31);
  v3 = 8 * top - 8;
  v4 = a->top;
  while (1)
  {
    v5 = __OFSUB__(v4--, 1);
    if (v4 < 0 != v5)
      break;
    d = a->d;
    v7 = *(unint64_t *)((char *)a->d + v3);
    v3 -= 8;
    if (v7)
    {
      v2 = v4 + 1;
      return BN_num_bits_word(d[v2 - 1]) + ((v2 - 1) << 6);
    }
  }
  if ((top & 0x80000000) == 0)
    return 0;
  d = a->d;
  return BN_num_bits_word(d[v2 - 1]) + ((v2 - 1) << 6);
}

int BN_num_bits_word(unint64_t a1)
{
  unint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;

  v1 = HIDWORD(a1);
  if (!HIDWORD(a1))
    v1 = a1;
  v2 = (a1 != 0) | (32 * (HIDWORD(a1) != 0)) | (16 * (v1 >> 16 != 0));
  if (v1 >> 16)
    v1 >>= 16;
  v3 = v2 | (8 * (v1 > 0xFF));
  if (v1 > 0xFF)
    v1 >>= 8;
  v4 = v3 | (4 * (v1 > 0xF));
  if (v1 > 0xF)
    v1 >>= 4;
  v5 = v4 | (2 * (v1 > 3));
  if (v1 > 3)
    v1 >>= 2;
  if (v1 <= 1)
    return v5;
  else
    return v5 + 1;
}

BOOL BN_is_negative(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) != 0;
}

uint64_t BN_bn2cbb_padded(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result;
  char *v6;

  v6 = (char *)0xAAAAAAAAAAAAAAAALL;
  result = CBB_add_space(a1, &v6, a2);
  if ((_DWORD)result)
    return BN_bn2bin_padded(v6, a2, a3) != 0;
  return result;
}

uint64_t BN_bn2bin_padded(char *a1, unint64_t a2, uint64_t a3)
{
  char *v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  char *v8;
  int v9;

  v4 = *(char **)a3;
  v5 = *(int *)(a3 + 8);
  if (a2 < 8 * v5)
  {
    v6 = 0;
    v7 = a2 - 8 * v5;
    v8 = &v4[a2];
    do
    {
      v9 = *v8++;
      v6 |= v9;
    }
    while (!__CFADD__(v7++, 1));
    if (v6)
      return 0;
  }
  bn_words_to_big_endian(a1, a2, v4, v5);
  return 1;
}

void bn_words_to_big_endian(char *a1, unint64_t a2, char *a3, uint64_t a4)
{
  unint64_t v4;
  int v5;
  unint64_t v6;
  char *v7;
  int v8;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;

  v4 = 8 * a4;
  if (a2 < 8 * a4)
  {
    v5 = 0;
    v6 = a2 - v4;
    v7 = &a3[a2];
    do
    {
      v8 = *v7++;
      v5 |= v8;
    }
    while (!__CFADD__(v6++, 1));
    if (v5)
      bn_words_to_big_endian_cold_1();
  }
  if (v4 >= a2)
    v10 = a2;
  else
    v10 = 8 * a4;
  if (v10)
  {
    v11 = &a1[a2 - 1];
    v12 = v10;
    do
    {
      v13 = *a3++;
      *v11-- = v13;
      --v12;
    }
    while (v12);
  }
  if (a2 > v4)
    bzero(a1, a2 - v10);
}

BOOL bssl::tls13_get_cert_verify_signature_input(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4, size_t a5)
{
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  int v13;
  _BOOL8 v14;
  unint64_t v16;
  _OWORD v17[3];
  _OWORD __dst[4];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[1] = v10;
  v17[2] = v10;
  v17[0] = v10;
  CBB_zero(v17);
  if (!CBB_init((uint64_t)v17, 0xE2uLL))
    goto LABEL_15;
  v11 = 64;
  do
  {
    if (!CBB_add_u8((uint64_t)v17, 0x20u))
      goto LABEL_15;
    --v11;
  }
  while (v11);
  if (a3 < 4 && CBB_add_bytes((uint64_t)v17, off_1E686EB88[a3], *(_QWORD *)&asc_1B5017D88[8 * a3]))
  {
    *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __dst[2] = v12;
    __dst[3] = v12;
    __dst[0] = v12;
    __dst[1] = v12;
    v16 = 0xAAAAAAAAAAAAAAAALL;
    if (a4)
    {
      if (a5 - 65 < 0xFFFFFFFFFFFFFFC0)
      {
        v13 = 105;
LABEL_18:
        ERR_put_error(16, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", v13);
        v14 = 0;
        goto LABEL_16;
      }
      memcpy(__dst, a4, a5);
      v16 = a5;
    }
    else
    {
      if (!bssl::SSLTranscript::GetHash((bssl::SSLTranscript *)(a1 + 424), (unsigned __int8 *)__dst, &v16))
      {
        v13 = 112;
        goto LABEL_18;
      }
      a5 = v16;
    }
    if (!CBB_add_bytes((uint64_t)v17, __dst, a5))
      goto LABEL_15;
    v14 = bssl::CBBFinishArray((uint64_t)v17, a2);
  }
  else
  {
LABEL_15:
    v14 = 0;
  }
LABEL_16:
  CBB_cleanup((uint64_t)v17);
  return v14;
}

void sub_1B4F750BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  CBB_cleanup((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t CBB_add_u8(uint64_t a1, unsigned int a2)
{
  return cbb_add_u(a1, a2, 1uLL);
}

uint64_t bssl::SSL_SESSION_to_bytes_full(uint64_t result, uint64_t *a2, int a3)
{
  uint64_t v3;
  __int128 v6;
  unsigned int v7;
  char *v8;
  const void *v9;
  size_t v10;
  size_t v11;
  const void *v12;
  size_t v13;
  const void *v14;
  size_t v15;
  const STACK *v16;
  uint64_t v17;
  char *v18;
  const void *v19;
  size_t v20;
  _OWORD v21[3];
  _OWORD v22[3];
  _OWORD v23[3];

  if (result)
  {
    v3 = result;
    if (!*(_QWORD *)(result + 208))
      return 0;
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v23[1] = v6;
    v23[2] = v6;
    v22[2] = v6;
    v23[0] = v6;
    v22[0] = v6;
    v22[1] = v6;
    v21[1] = v6;
    v21[2] = v6;
    v21[0] = v6;
    result = CBB_add_asn1(a2, (uint64_t)v23, 0x20000010u);
    if ((_DWORD)result)
    {
      result = CBB_add_asn1_uint64((uint64_t *)v23, 1uLL);
      if ((_DWORD)result)
      {
        result = CBB_add_asn1_uint64((uint64_t *)v23, *(unsigned __int16 *)(v3 + 4));
        if ((_DWORD)result)
        {
          result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 4u);
          if ((_DWORD)result)
          {
            result = CBB_add_u16((uint64_t)v22, *(unsigned __int16 *)(*(_QWORD *)(v3 + 208) + 16));
            if ((_DWORD)result)
            {
              v7 = a3 ? 0 : *(_DWORD *)(v3 + 64);
              result = CBB_add_asn1_octet_string((uint64_t *)v23, (const void *)(v3 + 68), v7);
              if ((_DWORD)result)
              {
                result = CBB_add_asn1_octet_string((uint64_t *)v23, (const void *)(v3 + 16), *(int *)(v3 + 12));
                if ((_DWORD)result)
                {
                  result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000001);
                  if ((_DWORD)result)
                  {
                    result = CBB_add_asn1_uint64((uint64_t *)v22, *(_QWORD *)(v3 + 200));
                    if ((_DWORD)result)
                    {
                      result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000002);
                      if ((_DWORD)result)
                      {
                        result = CBB_add_asn1_uint64((uint64_t *)v22, *(unsigned int *)(v3 + 192));
                        if ((_DWORD)result)
                        {
                          if (!sk_num(*(const STACK **)(v3 + 144))
                            || (*(_BYTE *)(v3 + 448) & 2) != 0
                            || (v8 = sk_value(*(const STACK **)(v3 + 144), 0),
                                result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000003),
                                (_DWORD)result)
                            && (v9 = (const void *)CRYPTO_BUFFER_data((uint64_t)v8),
                                v10 = CRYPTO_BUFFER_len((uint64_t)v8),
                                result = CBB_add_bytes((uint64_t)v22, v9, v10),
                                (_DWORD)result))
                          {
                            result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000004);
                            if ((_DWORD)result)
                            {
                              result = CBB_add_asn1_octet_string((uint64_t *)v22, (const void *)(v3 + 101), *(unsigned __int8 *)(v3 + 100));
                              if ((_DWORD)result)
                              {
                                if (!*(_QWORD *)(v3 + 184)
                                  || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000005), (_DWORD)result)
                                  && (result = CBB_add_asn1_uint64((uint64_t *)v22, *(_QWORD *)(v3 + 184)), (_DWORD)result))
                                {
                                  if (!*(_QWORD *)(v3 + 136)
                                    || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000008), (_DWORD)result)
                                    && (v11 = strlen(*(const char **)(v3 + 136)),
                                        result = CBB_add_asn1_octet_string((uint64_t *)v22, *(const void **)(v3 + 136), v11), (_DWORD)result))
                                  {
                                    if (!*(_DWORD *)(v3 + 380)
                                      || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000009), (_DWORD)result)
                                      && (result = CBB_add_asn1_uint64((uint64_t *)v22, *(unsigned int *)(v3 + 380)),
                                          (_DWORD)result))
                                    {
                                      if (a3
                                        || !*(_QWORD *)(v3 + 248)
                                        || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000000A),
                                            (_DWORD)result)
                                        && (result = CBB_add_asn1_octet_string((uint64_t *)v22, *(const void **)(v3 + 240), *(_QWORD *)(v3 + 248)), (_DWORD)result))
                                      {
                                        if ((*(_BYTE *)(v3 + 448) & 2) == 0
                                          || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000000D),
                                              (_DWORD)result)
                                          && (result = CBB_add_asn1_octet_string((uint64_t *)v22, (const void *)(v3 + 280), 0x20uLL), (_DWORD)result))
                                        {
                                          if (!*(_BYTE *)(v3 + 376)
                                            || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000000E),
                                                (_DWORD)result)
                                            && (result = CBB_add_asn1_octet_string((uint64_t *)v22, (const void *)(v3 + 312), *(unsigned __int8 *)(v3 + 376)), (_DWORD)result))
                                          {
                                            if (!*(_QWORD *)(v3 + 256)
                                              || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000000F),
                                                  (_DWORD)result)
                                              && (v12 = (const void *)CRYPTO_BUFFER_data(*(_QWORD *)(v3 + 256)),
                                                  v13 = CRYPTO_BUFFER_len(*(_QWORD *)(v3 + 256)),
                                                  result = CBB_add_asn1_octet_string((uint64_t *)v22, v12, v13),
                                                  (_DWORD)result))
                                            {
                                              if (!*(_QWORD *)(v3 + 264)
                                                || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000010),
                                                    (_DWORD)result)
                                                && (v14 = (const void *)CRYPTO_BUFFER_data(*(_QWORD *)(v3 + 264)),
                                                    v15 = CRYPTO_BUFFER_len(*(_QWORD *)(v3 + 264)),
                                                    result = CBB_add_asn1_octet_string((uint64_t *)v22, v14, v15),
                                                    (_DWORD)result))
                                              {
                                                if ((*(_BYTE *)(v3 + 448) & 1) == 0
                                                  || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000011),
                                                      (_DWORD)result)
                                                  && (result = CBB_add_asn1_BOOL((uint64_t *)v22, 1), (_DWORD)result))
                                                {
                                                  if (!*(_WORD *)(v3 + 6)
                                                    || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000012),
                                                        (_DWORD)result)
                                                    && (result = CBB_add_asn1_uint64((uint64_t *)v22, *(unsigned __int16 *)(v3 + 6)), (_DWORD)result))
                                                  {
                                                    v16 = *(const STACK **)(v3 + 144);
                                                    if (v16
                                                      && (*(_BYTE *)(v3 + 448) & 2) == 0
                                                      && (unint64_t)sk_num(v16) >= 2)
                                                    {
                                                      result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000013);
                                                      if (!(_DWORD)result)
                                                        return result;
                                                      if ((unint64_t)sk_num(*(const STACK **)(v3 + 144)) >= 2)
                                                      {
                                                        v17 = 1;
                                                        do
                                                        {
                                                          v18 = sk_value(*(const STACK **)(v3 + 144), v17);
                                                          v19 = (const void *)CRYPTO_BUFFER_data((uint64_t)v18);
                                                          v20 = CRYPTO_BUFFER_len((uint64_t)v18);
                                                          result = CBB_add_bytes((uint64_t)v22, v19, v20);
                                                          if (!(_DWORD)result)
                                                            return result;
                                                        }
                                                        while (++v17 < (unint64_t)sk_num(*(const STACK **)(v3 + 144)));
                                                      }
                                                    }
                                                    if ((*(_BYTE *)(v3 + 448) & 8) != 0)
                                                    {
                                                      result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000015);
                                                      if (!(_DWORD)result)
                                                        return result;
                                                      result = CBB_add_asn1((uint64_t *)v22, (uint64_t)v21, 4u);
                                                      if (!(_DWORD)result)
                                                        return result;
                                                      result = CBB_add_u32((uint64_t)v21, *(_DWORD *)(v3 + 384));
                                                      if (!(_DWORD)result)
                                                        return result;
                                                      if ((*(_BYTE *)(v3 + 448) & 0x10) != 0)
                                                        goto LABEL_73;
                                                    }
                                                    else if ((*(_BYTE *)(v3 + 448) & 0x10) != 0)
                                                    {
LABEL_73:
                                                      if (!*(_WORD *)(v3 + 8)
                                                        || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000017), (_DWORD)result)&& (result = CBB_add_asn1_uint64((uint64_t *)v22, *(unsigned __int16 *)(v3 + 8)), (_DWORD)result))
                                                      {
                                                        if (!*(_DWORD *)(v3 + 388)
                                                          || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000018), (_DWORD)result)&& (result = CBB_add_asn1_uint64((uint64_t *)v22, *(unsigned int *)(v3 + 388)), (_DWORD)result))
                                                        {
                                                          if (*(_DWORD *)(v3 + 192) == *(_DWORD *)(v3 + 196)
                                                            || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000019), (_DWORD)result)&& (result = CBB_add_asn1_uint64((uint64_t *)v22, *(unsigned int *)(v3 + 196)), (_DWORD)result))
                                                          {
                                                            if (!*(_QWORD *)(v3 + 408)
                                                              || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000001A), (_DWORD)result)&& (result = CBB_add_asn1_octet_string((uint64_t *)v22, *(const void **)(v3 + 400), *(_QWORD *)(v3 + 408)), (_DWORD)result))
                                                            {
                                                              if ((*(_BYTE *)(v3 + 448) & 0x20) == 0
                                                                || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000001B), (_DWORD)result)&& (result = CBB_add_asn1_BOOL((uint64_t *)v22, 1), (_DWORD)result))
                                                              {
                                                                if (!*(_QWORD *)(v3 + 464)
                                                                  || (result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000001C), (_DWORD)result)&& (result = CBB_add_asn1_octet_string((uint64_t *)v22, *(const void **)(v3 + 456), *(_QWORD *)(v3 + 464)), (_DWORD)result))
                                                                {
                                                                  if ((*(_BYTE *)(v3 + 448) & 0x40) == 0)
                                                                    return CBB_flush(a2);
                                                                  result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000001D);
                                                                  if ((_DWORD)result)
                                                                  {
                                                                    result = CBB_add_asn1_octet_string((uint64_t *)v22, *(const void **)(v3 + 416), *(_QWORD *)(v3 + 424));
                                                                    if ((_DWORD)result)
                                                                    {
                                                                      result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000001E);
                                                                      if ((_DWORD)result)
                                                                      {
                                                                        result = CBB_add_asn1_octet_string((uint64_t *)v22, *(const void **)(v3 + 432), *(_QWORD *)(v3 + 440));
                                                                        if ((_DWORD)result)
                                                                          return CBB_flush(a2);
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                      return result;
                                                    }
                                                    result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000016);
                                                    if (!(_DWORD)result)
                                                      return result;
                                                    result = CBB_add_asn1_BOOL((uint64_t *)v22, 0);
                                                    if (!(_DWORD)result)
                                                      return result;
                                                    goto LABEL_73;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t CBB_add_asn1_uint64_with_tag(uint64_t *a1, unint64_t a2, unsigned int a3)
{
  __int128 v5;
  uint64_t result;
  uint64_t v7;
  char v8;
  _OWORD v9[3];

  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v5;
  v9[2] = v5;
  v9[0] = v5;
  result = CBB_add_asn1(a1, (uint64_t)v9, a3);
  if (!(_DWORD)result)
    return result;
  v7 = 0;
  v8 = 1;
  do
  {
    while ((v8 & 1) == 0)
    {
LABEL_7:
      result = cbb_add_u((uint64_t)v9, (a2 >> (56 - 8 * v7)), 1uLL);
      if (!(_DWORD)result)
        return result;
      v8 = 0;
      if (++v7 == 8)
        return CBB_flush(a1);
    }
    if ((a2 >> (56 - 8 * v7)))
    {
      if (((a2 >> (56 - 8 * v7)) & 0x80) != 0)
      {
        result = cbb_add_u((uint64_t)v9, 0, 1uLL);
        if (!(_DWORD)result)
          return result;
      }
      goto LABEL_7;
    }
    ++v7;
    v8 = 1;
  }
  while (v7 != 8);
  result = cbb_add_u((uint64_t)v9, 0, 1uLL);
  if (!(_DWORD)result)
    return result;
  return CBB_flush(a1);
}

BOOL bssl::hkdf_expand_label(int a1, int a2, EVP_MD *a3, uint64_t a4, uint64_t a5, const void *a6, size_t a7, uint64_t a8, const void *a9, size_t a10)
{
  __int128 v15;
  __int128 v16;
  _BOOL8 v17;
  void *v19[2];
  _OWORD v20[3];
  _OWORD v21[3];

  *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v21[1] = v15;
  v21[2] = v15;
  v21[0] = v15;
  CBB_zero(v21);
  *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[1] = v16;
  v20[2] = v16;
  v20[0] = v16;
  v19[0] = 0;
  v19[1] = 0;
  v17 = CBB_init((uint64_t)v21, a7 + a10 + 10)
     && CBB_add_u16((uint64_t)v21, (unsigned __int16)a2)
     && CBB_add_u8_length_prefixed((uint64_t *)v21, (uint64_t)v20)
     && CBB_add_bytes((uint64_t)v20, "tls13 ", 6uLL)
     && CBB_add_bytes((uint64_t)v20, a6, a7)
     && CBB_add_u8_length_prefixed((uint64_t *)v21, (uint64_t)v20)
     && CBB_add_bytes((uint64_t)v20, a9, a10)
     && bssl::CBBFinishArray((uint64_t)v21, (uint64_t)v19)
     && HKDF_expand(a1, a2, a3);
  OPENSSL_free((_QWORD *)v19[0]);
  CBB_cleanup((uint64_t)v21);
  return v17;
}

void sub_1B4F75984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  CBB_cleanup((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t CBB_add_bytes(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t result;
  void *__dst;

  __dst = (void *)0xAAAAAAAAAAAAAAAALL;
  result = CBB_add_space(a1, &__dst, a3);
  if ((_DWORD)result)
  {
    if (a3)
      memcpy(__dst, a2, a3);
    return 1;
  }
  return result;
}

uint64_t cbb_add_length_prefixed(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;

  result = CBB_flush(a1);
  if ((_DWORD)result)
    return cbb_add_child((uint64_t)a1, a2, a3, 0);
  return result;
}

uint64_t CBB_add_asn1(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  if (!CBB_flush(a1))
    return 0;
  if ((a3 & 0x1FFFFFFF) < 0x1F)
  {
    if (!cbb_add_u((uint64_t)a1, HIBYTE(a3) & 0xE0 | a3, 1uLL))
      return 0;
  }
  else if (!cbb_add_u((uint64_t)a1, HIBYTE(a3) | 0x1F, 1uLL)
         || !add_base128_integer((uint64_t)a1, a3 & 0x1FFFFFFF))
  {
    return 0;
  }
  return cbb_add_child((uint64_t)a1, a2, 1u, 1);
}

uint64_t cbb_add_child(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  char v4;
  _QWORD *v8;
  uint64_t v9;
  uint64_t result;
  void *v11;

  if (*(_QWORD *)a1)
    cbb_add_child_cold_2();
  v4 = a4;
  if (a3 != 1 && a4)
    cbb_add_child_cold_1();
  v8 = (_QWORD *)(a1 + 16);
  if (*(_BYTE *)(a1 + 8))
    v8 = (_QWORD *)*v8;
  v9 = v8[1];
  v11 = (void *)0xAAAAAAAAAAAAAAAALL;
  result = cbb_buffer_reserve((uint64_t)v8, &v11, a3);
  if ((_DWORD)result)
  {
    v8[1] += a3;
    if (a3)
      bzero(v11, a3);
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    result = 1;
    *(_BYTE *)(a2 + 8) = 1;
    *(_QWORD *)(a2 + 16) = v8;
    *(_QWORD *)(a2 + 24) = v9;
    *(_BYTE *)(a2 + 32) = a3;
    *(_BYTE *)(a2 + 33) = *(_BYTE *)(a2 + 33) & 0xFE | v4 & 1;
    *(_QWORD *)a1 = a2;
  }
  return result;
}

uint64_t cbb_add_u(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t result;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v9 = 0xAAAAAAAAAAAAAAAALL;
  result = CBB_add_space(a1, &v9, a3);
  if ((_DWORD)result)
  {
    if (a3)
    {
      v7 = a3 - 1;
      do
      {
        *(_BYTE *)(v9 + v7) = a2;
        a2 >>= 8;
        --v7;
      }
      while (v7 < a3);
    }
    if (a2)
    {
      v8 = a1 + 16;
      if (*(_BYTE *)(a1 + 8))
        v8 = *(_QWORD *)v8;
      result = 0;
      *(_BYTE *)(v8 + 24) |= 2u;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t CBB_add_space(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  _QWORD *v8;

  result = CBB_flush((uint64_t *)a1);
  if ((_DWORD)result)
  {
    v7 = *(unsigned __int8 *)(a1 + 8);
    v8 = (_QWORD *)(a1 + 16);
    if (v7)
      v8 = (_QWORD *)*v8;
    result = cbb_buffer_reserve((uint64_t)v8, a2, a3);
    if ((_DWORD)result)
    {
      v8[1] += a3;
      return 1;
    }
  }
  return result;
}

uint64_t CBB_flush(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  size_t v9;
  uint64_t v10;
  int v11;
  uint64_t result;
  char v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;

  v2 = (uint64_t)(a1 + 2);
  if (*((_BYTE *)a1 + 8))
  {
    v2 = *(_QWORD *)v2;
    if (!v2)
      return 0;
  }
  if ((*(_BYTE *)(v2 + 24) & 2) != 0)
    return 0;
  v3 = *a1;
  if (!*a1)
    return 1;
  if (!*(_BYTE *)(v3 + 8))
    CBB_flush_cold_1();
  if (*(_QWORD *)(v3 + 16) != v2)
    CBB_flush_cold_3();
  v4 = *(_QWORD *)(v3 + 24);
  v5 = *(unsigned __int8 *)(v3 + 32);
  if (!CBB_flush(*a1))
    goto LABEL_32;
  v6 = v4 + v5;
  v7 = *(_QWORD *)(v3 + 24);
  if (v4 + v5 < v7)
    goto LABEL_32;
  v8 = *(_QWORD *)(v2 + 8);
  v9 = v8 - v6;
  if (v8 < v6)
    goto LABEL_32;
  LODWORD(v10) = *(unsigned __int8 *)(v3 + 32);
  if ((*(_BYTE *)(v3 + 33) & 1) != 0)
  {
    if ((_DWORD)v10 != 1)
      CBB_flush_cold_2();
    if (v9 > 0xFFFFFFFE)
    {
      v11 = 198;
LABEL_31:
      ERR_put_error(14, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bytestring/cbb.c", v11);
      goto LABEL_32;
    }
    if (v9 >> 24)
    {
      v13 = -124;
      v14 = 5;
    }
    else if (v9 >> 16)
    {
      v13 = -125;
      v14 = 4;
    }
    else if (v9 <= 0xFF)
    {
      if (v9 <= 0x7F)
      {
        LOBYTE(v14) = 1;
        v13 = v9;
        v9 = 0;
LABEL_25:
        v10 = *(_QWORD *)v2;
        *(_QWORD *)(v3 + 24) = v7 + 1;
        *(_BYTE *)(v10 + v7) = v13;
        LOBYTE(v10) = v14 - 1;
        *(_BYTE *)(v3 + 32) = v14 - 1;
        goto LABEL_26;
      }
      v13 = -127;
      v14 = 2;
    }
    else
    {
      v13 = -126;
      v14 = 3;
    }
    v15 = (v14 - 1);
    if (!cbb_buffer_reserve(v2, 0, v15))
    {
LABEL_32:
      result = 0;
      *(_BYTE *)(v2 + 24) |= 2u;
      return result;
    }
    v16 = *(_QWORD *)v2;
    *(_QWORD *)(v2 + 8) += v15;
    memmove((void *)(v16 + v6 + v15), (const void *)(v16 + v6), v9);
    v7 = *(_QWORD *)(v3 + 24);
    goto LABEL_25;
  }
LABEL_26:
  if ((_BYTE)v10)
  {
    v17 = v10 - 1;
    do
    {
      *(_BYTE *)(*(_QWORD *)v2 + *(_QWORD *)(v3 + 24) + v17) = v9;
      v9 >>= 8;
      --v17;
    }
    while (v17 < *(unsigned __int8 *)(v3 + 32));
  }
  if (v9)
  {
    v11 = 237;
    goto LABEL_31;
  }
  *(_QWORD *)(v3 + 16) = 0;
  *a1 = 0;
  return 1;
}

uint64_t cbb_buffer_reserve(uint64_t result, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  unint64_t v6;
  int v7;
  uint64_t v9;
  unint64_t v11;
  _QWORD *v12;

  if (result)
  {
    v3 = result;
    v4 = *(_QWORD *)(result + 8);
    v5 = __CFADD__(v4, a3);
    v6 = v4 + a3;
    if (v5)
    {
      v7 = 81;
LABEL_5:
      ERR_put_error(14, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bytestring/cbb.c", v7);
LABEL_6:
      result = 0;
      *(_BYTE *)(v3 + 24) |= 2u;
      return result;
    }
    v9 = *(_QWORD *)(result + 16);
    if (v6 > v9)
    {
      if ((*(_BYTE *)(result + 24) & 1) == 0)
      {
        v7 = 87;
        goto LABEL_5;
      }
      if (2 * v9 < v6 || v9 < 0)
        v11 = v6;
      else
        v11 = 2 * v9;
      v12 = OPENSSL_realloc(*(_QWORD **)result, v11);
      if (!v12)
        goto LABEL_6;
      *(_QWORD *)v3 = v12;
      *(_QWORD *)(v3 + 16) = v11;
    }
    if (a2)
      *a2 = *(_QWORD *)v3 + *(_QWORD *)(v3 + 8);
    return 1;
  }
  return result;
}

uint64_t CBB_add_u8_length_prefixed(uint64_t *a1, uint64_t a2)
{
  return cbb_add_length_prefixed(a1, a2, 1u);
}

int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx)
{
  void (**md_data)(void);

  OPENSSL_free((_QWORD *)ctx->engine);
  md_data = (void (**)(void))ctx->md_data;
  if (ctx->flags)
  {
    if (!md_data)
      EVP_MD_CTX_cleanup_cold_1();
    goto LABEL_5;
  }
  if (md_data)
LABEL_5:
    (*md_data)();
  *(_OWORD *)&ctx->digest = 0u;
  *(_OWORD *)&ctx->flags = 0u;
  return 1;
}

void OPENSSL_free(_QWORD *a1)
{
  uint64_t v1;
  char *v2;

  if (a1)
  {
    v2 = (char *)(a1 - 1);
    v1 = *(a1 - 1);
    if (v1 != -8)
      bzero(a1 - 1, v1 + 8);
    free(v2);
  }
}

uint64_t CBB_init(uint64_t a1, unint64_t a2)
{
  uint64_t result;

  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  result = (uint64_t)OPENSSL_malloc(a2);
  if (!a2 || result)
  {
    *(_BYTE *)(a1 + 8) = 0;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 16) = result;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = a2;
    *(_BYTE *)(a1 + 40) = *(_BYTE *)(a1 + 40) & 0xFC | 1;
    return 1;
  }
  return result;
}

_QWORD *OPENSSL_realloc(_QWORD *a1, unint64_t a2)
{
  size_t v4;
  _QWORD *v5;
  _QWORD *v6;
  size_t v7;

  if (!a1)
    return OPENSSL_malloc(a2);
  v4 = *(a1 - 1);
  v5 = OPENSSL_malloc(a2);
  v6 = v5;
  if (v5)
  {
    if (v4 >= a2)
      v7 = a2;
    else
      v7 = v4;
    memcpy(v5, a1, v7);
    OPENSSL_free(a1);
  }
  return v6;
}

_QWORD *OPENSSL_malloc(unint64_t a1)
{
  _QWORD *v2;

  if (a1 < 0xFFFFFFFFFFFFFFF8 && (v2 = malloc_type_malloc(a1 + 8, 0x6162BCD9uLL)) != 0)
  {
    *v2 = a1;
    return v2 + 1;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/mem.c", 267);
    return 0;
  }
}

double CBB_zero(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

BOOL bssl::CBBFinishArray(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;

  v7 = 0xAAAAAAAAAAAAAAAALL;
  v8 = 0xAAAAAAAAAAAAAAAALL;
  v3 = CBB_finish(a1, &v8, &v7);
  if (v3)
  {
    v5 = v7;
    v4 = v8;
    OPENSSL_free(*(_QWORD **)a2);
    *(_QWORD *)a2 = v4;
    *(_QWORD *)(a2 + 8) = v5;
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 204);
  }
  return v3 != 0;
}

uint64_t CBB_finish(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;

  if (*(_BYTE *)(a1 + 8))
  {
    ERR_put_error(14, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bytestring/cbb.c", 127);
    return 0;
  }
  result = CBB_flush((uint64_t *)a1);
  if ((_DWORD)result)
  {
    if ((*(_BYTE *)(a1 + 40) & 1) != 0)
    {
      result = 0;
      if (!a2 || !a3)
        return result;
    }
    else if (!a2)
    {
      goto LABEL_10;
    }
    *a2 = *(_QWORD *)(a1 + 16);
LABEL_10:
    if (a3)
      *a3 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 16) = 0;
    CBB_cleanup(a1);
    return 1;
  }
  return result;
}

void CBB_cleanup(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    CBB_cleanup_cold_1();
  if ((*(_BYTE *)(a1 + 40) & 1) != 0)
    OPENSSL_free(*(_QWORD **)(a1 + 16));
}

BOOL HKDF_expand(int a1, int a2, EVP_MD *md)
{
  int v3;

  v3 = EVP_MD_type(md);
  boringssl_crypto_hash_nid_to_cc_digest(v3);
  return cchkdf_expand() == 0;
}

int EVP_MD_type(const EVP_MD *md)
{
  return md->type;
}

uint64_t boringssl_crypto_hash_nid_to_cc_digest(int a1)
{
  uint64_t result;

  switch(a1)
  {
    case 672:
      result = ccsha256_di();
      break;
    case 673:
      result = ccsha384_di();
      break;
    case 674:
      result = ccsha512_di();
      break;
    case 675:
      result = ccsha224_di();
      break;
    default:
      if (a1 == 64)
      {
        result = ccsha1_di();
      }
      else if (a1 == 4)
      {
        result = ccmd5_di();
      }
      else
      {
        if (g_boringssl_log)
        {
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
            boringssl_crypto_hash_nid_to_cc_digest_cold_1();
        }
        result = 0;
      }
      break;
  }
  return result;
}

uint64_t CBB_add_asn1_uint64(uint64_t *a1, unint64_t a2)
{
  return CBB_add_asn1_uint64_with_tag(a1, a2, 2u);
}

uint64_t CBB_add_asn1_octet_string(uint64_t *a1, const void *a2, size_t a3)
{
  __int128 v6;
  uint64_t result;
  _OWORD v8[3];

  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v6;
  v8[2] = v6;
  v8[0] = v6;
  result = CBB_add_asn1(a1, (uint64_t)v8, 4u);
  if ((_DWORD)result)
  {
    result = CBB_add_bytes((uint64_t)v8, a2, a3);
    if ((_DWORD)result)
      return CBB_flush(a1) != 0;
  }
  return result;
}

__CFArray *boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs(void *a1, const STACK *a2)
{
  id *v3;
  __CFArray *v4;
  CFMutableArrayRef Mutable;
  unint64_t v6;
  char *v7;
  const void *v8;
  const void *v9;
  id WeakRetained;
  void *v11;
  _BYTE *v12;
  char v13;
  id v14;
  _BYTE *v15;
  _BOOL4 v16;
  NSObject *v17;
  void *v18;
  id v19;
  id v20;
  void *v21;
  _BYTE *v22;
  char v23;
  id v24;
  _BYTE *v25;
  _BOOL4 v26;
  NSObject *v27;
  char *v29;
  id v30;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;
  __int16 v37;
  id v38;
  __int16 v39;
  unint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = 0;
  if (v3 && a2)
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      v4 = Mutable;
      if (sk_num(a2))
      {
        v6 = 0;
        do
        {
          v7 = sk_value(a2, v6);
          CRYPTO_BUFFER_data((uint64_t)v7);
          CRYPTO_BUFFER_len((uint64_t)v7);
          v8 = (const void *)SecCertificateCreateWithBytes();
          if (v8)
          {
            v9 = v8;
            CFArrayAppendValue(v4, v8);
            CFRelease(v9);
          }
          else
          {
            WeakRetained = objc_loadWeakRetained(v3 + 2);
            if (!WeakRetained
              || (v11 = WeakRetained,
                  v12 = objc_loadWeakRetained(v3 + 2),
                  v13 = v12[475],
                  v12,
                  v11,
                  (v13 & 1) == 0))
            {
              v14 = objc_loadWeakRetained(v3 + 2);
              if (v14)
              {
                v15 = objc_loadWeakRetained(v3 + 2);
                v16 = (v15[475] & 1) == 0;

              }
              else
              {
                v16 = 1;
              }

              if (v16)
              {
                if (g_boringssl_log)
                {
                  v17 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
                  {
                    v18 = &unk_1B50022E3;
                    v30 = objc_loadWeakRetained(v3 + 2);
                    if (v30)
                    {
                      v29 = (char *)objc_loadWeakRetained(v3 + 2);
                      v18 = v29 + 391;
                    }
                    v19 = objc_loadWeakRetained(v3 + 2);
                    *(_DWORD *)buf = 136447234;
                    v32 = "boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs";
                    v33 = 1024;
                    v34 = 153;
                    v35 = 2082;
                    v36 = v18;
                    v37 = 2048;
                    v38 = v19;
                    v39 = 2048;
                    v40 = v6;
                    _os_log_error_impl(&dword_1B4F6D000, v17, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] Failed to extract certificate #%zu", buf, 0x30u);

                    if (v30)
                  }

                }
              }
            }
          }
          ++v6;
        }
        while (v6 < sk_num(a2));
      }
      if (CFArrayGetCount(v4) < 1)
      {
        CFRelease(v4);
LABEL_36:
        v4 = 0;
      }
    }
    else
    {
      v20 = objc_loadWeakRetained(v3 + 2);
      if (v20)
      {
        v21 = v20;
        v22 = objc_loadWeakRetained(v3 + 2);
        v23 = v22[475];

        if ((v23 & 1) != 0)
          goto LABEL_36;
      }
      v24 = objc_loadWeakRetained(v3 + 2);
      if (v24)
      {
        v25 = objc_loadWeakRetained(v3 + 2);
        v26 = (v25[475] & 1) == 0;

      }
      else
      {
        v26 = 1;
      }

      v4 = 0;
      if (v26 && g_boringssl_log)
      {
        v27 = (id)g_boringssl_log;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs_cold_1(v3, v27);

        goto LABEL_36;
      }
    }
  }

  return v4;
}

uint64_t CRYPTO_BUFFER_len(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t CRYPTO_BUFFER_data(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t CBB_add_asn1_BOOL(uint64_t *a1, int a2)
{
  __int128 v4;
  uint64_t result;
  unint64_t v6;
  _OWORD v7[3];

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v4;
  v7[2] = v4;
  v7[0] = v4;
  result = CBB_add_asn1(a1, (uint64_t)v7, 1u);
  if ((_DWORD)result)
  {
    if (a2)
      v6 = 255;
    else
      v6 = 0;
    result = cbb_add_u((uint64_t)v7, v6, 1uLL);
    if ((_DWORD)result)
      return CBB_flush(a1) != 0;
  }
  return result;
}

void EVP_PKEY_CTX_free(EVP_PKEY **a1)
{
  void (*v2)(EVP_PKEY **);

  if (a1)
  {
    if (*a1)
    {
      v2 = *(void (**)(EVP_PKEY **))&(*a1)->save_parameters;
      if (v2)
        v2(a1);
    }
    EVP_PKEY_free(a1[2]);
    EVP_PKEY_free(a1[3]);
    OPENSSL_free(a1);
  }
}

void EVP_PKEY_free(EVP_PKEY *pkey)
{
  char *ptr;
  void (*v3)(EVP_PKEY *);

  if (pkey && CRYPTO_refcount_dec_and_test_zero((unsigned int *)pkey))
  {
    ptr = pkey->pkey.ptr;
    if (ptr)
    {
      v3 = (void (*)(EVP_PKEY *))*((_QWORD *)ptr + 20);
      if (v3)
      {
        v3(pkey);
        *(_QWORD *)&pkey->references = 0;
        pkey->save_type = 0;
      }
    }
    OPENSSL_free(pkey);
  }
}

uint64_t CBB_add_u32(uint64_t a1, unsigned int a2)
{
  return cbb_add_u(a1, a2, 4uLL);
}

void pkey_rsa_cleanup(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
  {
    BN_free(*(BIGNUM **)(v1 + 8));
    OPENSSL_free(*(_QWORD **)(v1 + 48));
    OPENSSL_free(*(_QWORD **)(v1 + 56));
    OPENSSL_free((_QWORD *)v1);
  }
}

void BN_free(BIGNUM *a)
{
  int flags;

  if (a)
  {
    flags = a->flags;
    if ((flags & 2) == 0)
    {
      OPENSSL_free(a->d);
      flags = a->flags;
    }
    if ((flags & 1) != 0)
      OPENSSL_free(a);
    else
      a->d = 0;
  }
}

uint64_t boringssl_ciphers_create_set_bitmask(const STACK *a1)
{
  unint64_t v2;
  uint64_t v3;
  char *v4;
  __int16 id;
  uint64_t v6;

  if (!sk_num(a1))
    return 0;
  v2 = 0;
  v3 = 0;
  do
  {
    v4 = sk_value(a1, v2);
    if (v4)
    {
      id = SSL_CIPHER_get_id((uint64_t)v4);
      v6 = 0;
      while (supported_bitmasks[v6] != id)
      {
        v6 += 8;
        if (v6 == 296)
          goto LABEL_9;
      }
      v3 |= *(_QWORD *)&supported_bitmasks[v6 + 4];
    }
LABEL_9:
    ++v2;
  }
  while (v2 < sk_num(a1));
  return v3;
}

const SSL *boringssl_context_info_handler(const SSL *result, int a2, char *a3)
{
  char *v3;
  const SSL *v6;
  SSL *v7;
  SSL_METHOD *method;
  id v9;
  void *v10;
  _BYTE *v11;
  char v12;
  id v13;
  _BYTE *v14;
  _BOOL4 v15;
  id v16;
  void *v17;
  _BYTE *v18;
  char v19;
  id v20;
  _BYTE *v21;
  _BOOL4 v22;
  uint64_t v23;
  ssl_method_st *(__cdecl *get_ssl_method)(int);
  id WeakRetained;
  void *v26;
  unsigned __int8 *v27;
  id v28;
  _BYTE *v29;
  _BOOL4 v30;
  NSObject *v31;
  id v32;
  void *v33;
  NSObject *v34;
  id v35;
  void *v36;
  NSObject *v37;
  id v38;
  void *v39;
  id v40;
  void *v41;
  char v42;
  const char *v43;
  id v44;
  void *v45;
  char v46;
  const char *v47;
  id v48;
  const char *v49;
  bssl::SSL_HANDSHAKE *v50;
  int v51;
  const char *v52;
  __int16 v53;
  int v54;
  __int16 v55;
  void *v56;
  __int16 v57;
  id v58;
  __int16 v59;
  const char *v60;
  __int16 v61;
  const char *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v6 = result;
    result = (const SSL *)SSL_get_ex_data(result, 0);
    if (result)
    {
      v7 = (SSL *)result;
      if (result->version == -1252936367)
      {
        method = result->method;
        if (method)
        {
          if (a2 > 0x2000)
          {
            if (a2 > 16387)
            {
              if (a2 == 16388)
              {
                boringssl_context_alert_callback_handler(v6, 16388, (int)a3, 1);
              }
              else if (a2 == 16392)
              {
                boringssl_context_alert_callback_handler(v6, 16392, (int)a3, 0);
              }
            }
          }
          else if (a2 > 4096)
          {
            if (a2 == 4097)
            {
              v23 = SSL_state(v6);
              LODWORD(method[1].ssl_shutdown) = v23;
              get_ssl_method = method[1].get_ssl_method;
              if (get_ssl_method)
                (*((void (**)(ssl_method_st *(__cdecl *)(int), uint64_t))get_ssl_method + 2))(get_ssl_method, v23);
              WeakRetained = objc_loadWeakRetained((id *)&method->ssl_clear);
              if (!WeakRetained
                || (v26 = WeakRetained,
                    v27 = (unsigned __int8 *)objc_loadWeakRetained((id *)&method->ssl_clear),
                    a3 = (char *)v27[475],
                    v27,
                    v26,
                    (a3 & 1) == 0))
              {
                v28 = objc_loadWeakRetained((id *)&method->ssl_clear);
                if (v28)
                {
                  v29 = objc_loadWeakRetained((id *)&method->ssl_clear);
                  v30 = (v29[475] & 1) == 0;

                }
                else
                {
                  v30 = 1;
                }

                if (v30)
                {
                  if (g_boringssl_log)
                  {
                    v37 = (id)g_boringssl_log;
                    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
                    {
                      v38 = objc_loadWeakRetained((id *)&method->ssl_clear);
                      if (v38)
                      {
                        a3 = (char *)objc_loadWeakRetained((id *)&method->ssl_clear);
                        v39 = a3 + 391;
                      }
                      else
                      {
                        v39 = &unk_1B50022E3;
                      }
                      v48 = objc_loadWeakRetained((id *)&method->ssl_clear);
                      if ((BYTE4(method[2].ssl_renegotiate_check) & 0x10) != 0)
                        v49 = "Server";
                      else
                        v49 = "Client";
                      v51 = 136447490;
                      v52 = "boringssl_context_info_handler";
                      v53 = 1024;
                      v54 = 2243;
                      v55 = 2082;
                      v56 = v39;
                      v57 = 2048;
                      v58 = v48;
                      v59 = 2082;
                      v60 = v49;
                      v61 = 2082;
                      v62 = SSL_state_string_long(v6);
                      _os_log_impl(&dword_1B4F6D000, v37, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] %{public}s handshake state: %{public}s", (uint8_t *)&v51, 0x3Au);

                      if (v38)
                    }

                  }
                }
              }
              if (nw_settings_get_signposts_enabled() && kdebug_is_enabled())
              {
                SSL_state_int((uint64_t)v6, v50);
                kdebug_trace();
              }
            }
          }
          else if (a2 == 16)
          {
            v16 = objc_loadWeakRetained((id *)&method->ssl_clear);
            if (!v16
              || (v17 = v16,
                  v18 = objc_loadWeakRetained((id *)&method->ssl_clear),
                  v19 = v18[475],
                  v18,
                  v17,
                  (v19 & 1) == 0))
            {
              v20 = objc_loadWeakRetained((id *)&method->ssl_clear);
              if (v20)
              {
                v21 = objc_loadWeakRetained((id *)&method->ssl_clear);
                v22 = (v21[475] & 1) == 0;

              }
              else
              {
                v22 = 1;
              }

              if (v22)
              {
                if (g_boringssl_log)
                {
                  v34 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                  {
                    v35 = objc_loadWeakRetained((id *)&method->ssl_clear);
                    if (v35)
                    {
                      v3 = (char *)objc_loadWeakRetained((id *)&method->ssl_clear);
                      v36 = v3 + 391;
                    }
                    else
                    {
                      v36 = &unk_1B50022E3;
                    }
                    v44 = objc_loadWeakRetained((id *)&method->ssl_clear);
                    v45 = v44;
                    v46 = BYTE4(method[2].ssl_renegotiate_check);
                    v52 = "boringssl_context_info_handler";
                    v53 = 1024;
                    v51 = 136447234;
                    v54 = 2226;
                    if ((v46 & 0x10) != 0)
                      v47 = "Server";
                    else
                      v47 = "Client";
                    v55 = 2082;
                    v56 = v36;
                    v57 = 2048;
                    v58 = v44;
                    v59 = 2082;
                    v60 = v47;
                    _os_log_impl(&dword_1B4F6D000, v34, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] %{public}s handshake started", (uint8_t *)&v51, 0x30u);

                    if (v35)
                  }

                }
              }
            }
            boringssl_session_set_state((uint64_t)v7, 1);
          }
          else if (a2 == 32)
          {
            v9 = objc_loadWeakRetained((id *)&method->ssl_clear);
            if (!v9
              || (v10 = v9,
                  v11 = objc_loadWeakRetained((id *)&method->ssl_clear),
                  v12 = v11[475],
                  v11,
                  v10,
                  (v12 & 1) == 0))
            {
              v13 = objc_loadWeakRetained((id *)&method->ssl_clear);
              if (v13)
              {
                v14 = objc_loadWeakRetained((id *)&method->ssl_clear);
                v15 = (v14[475] & 1) == 0;

              }
              else
              {
                v15 = 1;
              }

              if (v15)
              {
                if (g_boringssl_log)
                {
                  v31 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                  {
                    v32 = objc_loadWeakRetained((id *)&method->ssl_clear);
                    if (v32)
                    {
                      v3 = (char *)objc_loadWeakRetained((id *)&method->ssl_clear);
                      v33 = v3 + 391;
                    }
                    else
                    {
                      v33 = &unk_1B50022E3;
                    }
                    v40 = objc_loadWeakRetained((id *)&method->ssl_clear);
                    v41 = v40;
                    v42 = BYTE4(method[2].ssl_renegotiate_check);
                    v52 = "boringssl_context_info_handler";
                    v53 = 1024;
                    v51 = 136447234;
                    v54 = 2232;
                    if ((v42 & 0x10) != 0)
                      v43 = "Server";
                    else
                      v43 = "Client";
                    v55 = 2082;
                    v56 = v33;
                    v57 = 2048;
                    v58 = v40;
                    v59 = 2082;
                    v60 = v43;
                    _os_log_impl(&dword_1B4F6D000, v31, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] %{public}s handshake done", (uint8_t *)&v51, 0x30u);

                    if (v32)
                  }

                }
              }
            }
            boringssl_session_finish_handshake(v7);
          }
          result = (const SSL *)nw_settings_get_signposts_enabled();
          if ((_DWORD)result)
          {
            result = (const SSL *)kdebug_is_enabled();
            if ((_DWORD)result)
              return (const SSL *)kdebug_trace();
          }
        }
      }
    }
  }
  return result;
}

char *__cdecl sk_value(char *result, int a2)
{
  if (result)
  {
    if (*(_QWORD *)result <= *(_QWORD *)&a2)
      return 0;
    else
      return *(char **)(*((_QWORD *)result + 1) + 8 * *(_QWORD *)&a2);
  }
  return result;
}

void *__cdecl CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)
{
  STACK *sk;

  if (idx < 0)
    return 0;
  sk = ad->sk;
  if (!sk || sk_num(sk) <= (unint64_t)idx)
    return 0;
  else
    return sk_value(ad->sk, idx);
}

int sk_num(const STACK *a1)
{
  if (a1)
    return *(_QWORD *)&a1->num;
  return (int)a1;
}

void *__cdecl SSL_get_ex_data(const SSL *ssl, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)&ssl->d1, idx);
}

uint64_t SSL_CIPHER_get_id(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

const char *bssl::ssl_client_handshake_state(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  int v2;
  const char *result;

  v2 = *((_DWORD *)this + 5);
  result = "TLS client start_connect";
  switch(v2)
  {
    case 0:
      return result;
    case 1:
      result = "TLS client enter_early_data";
      break;
    case 2:
      result = "TLS client early_reverify_server_certificate";
      break;
    case 3:
      result = "TLS client read_hello_verify_request";
      break;
    case 4:
      result = "TLS client read_server_hello";
      break;
    case 5:
      result = bssl::tls13_client_handshake_state((uint64_t)this);
      break;
    case 6:
      result = "TLS client read_server_certificate";
      break;
    case 7:
      result = "TLS client read_certificate_status";
      break;
    case 8:
      result = "TLS client verify_server_certificate";
      break;
    case 9:
      result = "TLS client reverify_server_certificate";
      break;
    case 10:
      result = "TLS client read_server_key_exchange";
      break;
    case 11:
      result = "TLS client read_certificate_request";
      break;
    case 12:
      result = "TLS client read_server_hello_done";
      break;
    case 13:
      result = "TLS client send_client_certificate";
      break;
    case 14:
      result = "TLS client send_client_key_exchange";
      break;
    case 15:
      result = "TLS client send_client_certificate_verify";
      break;
    case 16:
      result = "TLS client send_client_finished";
      break;
    case 17:
      result = "TLS client finish_flight";
      break;
    case 18:
      result = "TLS client read_session_ticket";
      break;
    case 19:
      result = "TLS client process_change_cipher_spec";
      break;
    case 20:
      result = "TLS client read_server_finished";
      break;
    case 21:
      result = "TLS client finish_client_handshake";
      break;
    case 22:
      result = "TLS client done";
      break;
    default:
      result = "TLS client unknown";
      break;
  }
  return result;
}

const char *__cdecl SSL_state_string_long(const SSL *s)
{
  bssl::SSL_HANDSHAKE *v1;
  bssl *v3;

  v3 = (bssl *)*((_QWORD *)s->handshake_func + 35);
  if (!v3)
    return "SSL negotiation finished successfully";
  if ((BYTE4(s->param) & 1) != 0)
    return bssl::ssl_server_handshake_state(v3, v1);
  return bssl::ssl_client_handshake_state(v3, v1);
}

int SSL_state(const SSL *ssl)
{
  uint64_t v1;

  v1 = *((_QWORD *)ssl->handshake_func + 35);
  if (!v1 || (*(_DWORD *)(v1 + 1600) & 8) != 0)
    return 3;
  else
    return 12288;
}

const char *bssl::tls13_client_handshake_state(uint64_t a1)
{
  uint64_t v1;

  v1 = *(int *)(a1 + 24);
  if (v1 > 0xE)
    return "TLS 1.3 client unknown";
  else
    return off_1E686EB10[v1];
}

uint64_t boringssl_session_set_state(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0xFFFFFFFFLL;
  result = 0;
  *(_DWORD *)(v2 + 300) = a2;
  return result;
}

SSL *boringssl_session_finish_handshake(SSL *result)
{
  SSL *v1;
  SSL_METHOD *method;
  SSL_SESSION *session;
  id WeakRetained;
  void *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  id v10;
  _QWORD *v11;
  SSL_METHOD *v12;
  SSL_METHOD *v13;

  if (result)
  {
    v1 = result;
    if (result->version == -1252936367)
    {
      method = result->method;
      if (method)
      {
        session = SSL_get_session((const SSL *)method[1].num_ciphers);
        boringssl_session_set_peer_verification_state_from_session((uint64_t)v1, (uint64_t)session);
        if ((BYTE4(method[2].ssl_renegotiate_check) & 0x10) != 0)
        {
          WeakRetained = objc_loadWeakRetained((id *)&method->ssl_clear);
          if (WeakRetained)
          {
            v5 = WeakRetained;
            v6 = objc_loadWeakRetained((id *)&method->ssl_clear);
            v7 = v6[40];

            if (v7)
            {
              v8 = objc_loadWeakRetained((id *)&method->ssl_clear);
              v9 = v8[40];

              if (v9)
              {
                v10 = objc_loadWeakRetained((id *)&method->ssl_clear);
                nw_queue_cancel_source();

                v11 = objc_loadWeakRetained((id *)&method->ssl_clear);
                v11[40] = 0;

              }
            }
          }
        }
        if (v1->version == -1252936367)
        {
          v12 = v1->method;
          if (v12)
          {
            HIDWORD(v12[1].ssl_write) = 2;
            if (v1->version == -1252936367)
            {
              v13 = v1->method;
              if (v13)
                v13[1].ssl3_enc = (ssl3_enc_method *)boringssl_helper_get_current_time_ms();
            }
          }
        }
        boringssl_session_update_metadata((uint64_t)v1);
        boringssl_context_update_encryption_level((uint64_t)v1);
        boringssl_metrics_log_connection(v1);
        return (SSL *)boringssl_metrics_log_ech((uint64_t)v1);
      }
    }
  }
  return result;
}

void boringssl_session_update_metadata(uint64_t a1)
{
  void *v1;
  id v2;
  id v3;

  if (a1 && *(_DWORD *)a1 == -1252936367)
  {
    v1 = *(void **)(a1 + 8);
    if (v1)
    {
      v3 = v1;
      v2 = v3;
      nw_protocol_metadata_access_handle();

    }
  }
}

BOOL boringssl_metrics_log_connection(SSL *a1)
{
  xpc_object_t connection_event;
  void *v2;
  _BOOL8 v3;
  SSL *v5;

  if (!a1 || a1->version != -1252936367 || !a1->method)
    return 0;
  if (metricsQueueToken != -1)
  {
    v5 = a1;
    dispatch_once(&metricsQueueToken, &__block_literal_global_3);
    a1 = v5;
  }
  if (!boringssl_context_metrics_queue)
    return 0;
  connection_event = boringssl_metrics_create_connection_event(a1);
  if (!connection_event)
    return 0;
  v2 = connection_event;
  v3 = boringssl_metrics_log_event((uint64_t)"TLSConnectionEvent", connection_event, (void *)boringssl_context_metrics_queue);

  return v3;
}

BOOL boringssl_metrics_log_event(uint64_t a1, void *a2, void *a3)
{
  NSObject *v5;
  xpc_object_t v6;
  _BOOL8 v7;
  const char *v8;
  const char *whitelisted_bundle_identifier;
  id v10;
  _QWORD v12[4];
  id v13;
  uint64_t v14;

  v5 = a3;
  if (a1)
  {
    v6 = xpc_copy(a2);
    v7 = v6 != 0;
    if (v6)
    {
      v8 = (const char *)TLS_METRIC_PROCESS_IDENTIFIER;
      whitelisted_bundle_identifier = (const char *)boringssl_config_get_whitelisted_bundle_identifier();
      xpc_dictionary_set_string(v6, v8, whitelisted_bundle_identifier);
      v10 = v6;
      v12[0] = MEMORY[0x1E0C809B0];
      v12[1] = 3221225472;
      v12[2] = __boringssl_metrics_log_metric_block_invoke;
      v12[3] = &unk_1E686E720;
      v13 = v10;
      v14 = a1;
      dispatch_async(v5, v12);

    }
    else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      boringssl_metrics_log_event_cold_1();
    }

  }
  else
  {
    v7 = 0;
  }

  return v7;
}

uint64_t boringssl_config_get_whitelisted_bundle_identifier()
{
  if (boringssl_config_get_whitelisted_bundle_identifier_onceToken != -1)
    dispatch_once(&boringssl_config_get_whitelisted_bundle_identifier_onceToken, &__block_literal_global_2);
  return global_bundle_identifier;
}

BOOL boringssl_metrics_log_ech(uint64_t a1)
{
  xpc_object_t ech_event;
  void *v2;
  _BOOL8 v3;
  uint64_t v5;

  if (!a1 || *(_DWORD *)a1 != -1252936367 || !*(_QWORD *)(a1 + 8))
    return 0;
  if (metricsQueueToken != -1)
  {
    v5 = a1;
    dispatch_once(&metricsQueueToken, &__block_literal_global_78);
    a1 = v5;
  }
  if (!boringssl_context_metrics_queue)
    return 0;
  ech_event = boringssl_metrics_create_ech_event(a1);
  if (!ech_event)
    return 0;
  v2 = ech_event;
  v3 = boringssl_metrics_log_event((uint64_t)"TLSExperimentECHConnectionEvent", ech_event, (void *)boringssl_context_metrics_queue);

  return v3;
}

xpc_object_t boringssl_metrics_create_ech_event(uint64_t a1)
{
  xpc_object_t v2;
  const char *v3;
  char ech_was_used;
  id v5;

  if (!a1
    || *(_DWORD *)a1 != -1252936367
    || !*(_QWORD *)(a1 + 8)
    || !boringssl_context_get_ech_enabled(a1))
  {
    return 0;
  }
  v2 = xpc_dictionary_create(0, 0, 0);
  if (v2)
  {
    v3 = (const char *)TLS_METRIC_ECH_USED;
    ech_was_used = boringssl_session_get_ech_was_used(a1);
    xpc_dictionary_set_BOOL(v2, v3, ech_was_used);
    v5 = v2;
  }
  else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
  {
    boringssl_metrics_create_ech_event_cold_1();
  }

  return v2;
}

void pkey_ec_cleanup(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
  {
    EC_GROUP_free(*(EC_GROUP **)(v1 + 8));
    OPENSSL_free((_QWORD *)v1);
  }
}

void EC_GROUP_free(EC_GROUP *a1)
{
  void (*v2)(EC_GROUP *);
  _QWORD *v3;

  if (a1 && !*((_DWORD *)a1 + 10) && CRYPTO_refcount_dec_and_test_zero((unsigned int *)a1 + 76))
  {
    v2 = *(void (**)(EC_GROUP *))(*(_QWORD *)a1 + 8);
    if (v2)
      v2(a1);
    v3 = (_QWORD *)*((_QWORD *)a1 + 1);
    if (v3)
      OPENSSL_free(v3);
    BN_free((BIGNUM *)((char *)a1 + 16));
    BN_MONT_CTX_free(*((BN_MONT_CTX **)a1 + 6));
    OPENSSL_free(a1);
  }
}

int RSA_check_key(const RSA *a1)
{
  return 1;
}

void CBB_cleanup_cold_1()
{
  __assert_rtn("CBB_cleanup", "cbb.c", 62, "!cbb->is_child");
}

void boringssl_context_alert_callback_handler(const SSL *a1, uint64_t a2, int a3, int a4)
{
  char *v4;
  _DWORD *v8;
  void *v9;
  uint64_t v10;
  char *v11;
  id v12;
  void *v13;
  _BYTE *v14;
  char v15;
  id v16;
  _BYTE *v17;
  _BOOL4 v18;
  id WeakRetained;
  void *v20;
  _BYTE *v21;
  char v22;
  id v23;
  _BYTE *v24;
  _BOOL4 v25;
  id v26;
  void *v27;
  unsigned __int8 *v28;
  id v29;
  _BYTE *v30;
  _BOOL4 v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  id v35;
  NSObject *v36;
  id v37;
  void *v38;
  NSObject *v39;
  id v40;
  const char *v41;
  id v42;
  id v43;
  void *v44;
  id v45;
  const char *v46;
  id v47;
  void *v48;
  const char *v49;
  char *v50;
  void *v51;
  uint8_t buf[4];
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  void *v57;
  __int16 v58;
  id v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  const char *v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v8 = SSL_get_ex_data(a1, 0);
  if (v8)
  {
    v9 = v8;
    if (*v8 == -1252936367)
    {
      v10 = *((_QWORD *)v8 + 1);
      if (v10)
      {
        v11 = (char *)BYTE1(a3);
        if (BYTE1(a3) == 1)
        {
          WeakRetained = objc_loadWeakRetained((id *)(v10 + 16));
          if (!WeakRetained
            || (v20 = WeakRetained,
                v21 = objc_loadWeakRetained((id *)(v10 + 16)),
                v22 = v21[475],
                v21,
                v20,
                (v22 & 1) == 0))
          {
            v23 = objc_loadWeakRetained((id *)(v10 + 16));
            if (v23)
            {
              v24 = objc_loadWeakRetained((id *)(v10 + 16));
              v25 = (v24[475] & 1) == 0;

            }
            else
            {
              v25 = 1;
            }

            if (v25)
            {
              if (g_boringssl_log)
              {
                v36 = (id)g_boringssl_log;
                if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
                {
                  v37 = objc_loadWeakRetained((id *)(v10 + 16));
                  if (v37)
                  {
                    v11 = (char *)objc_loadWeakRetained((id *)(v10 + 16));
                    v38 = v11 + 391;
                  }
                  else
                  {
                    v38 = &unk_1B50022E3;
                  }
                  v40 = objc_loadWeakRetained((id *)(v10 + 16));
                  if (a4)
                    v41 = "read";
                  else
                    v41 = "write";
                  *(_DWORD *)buf = 136447746;
                  v53 = "boringssl_context_handle_warning_alert";
                  v54 = 1024;
                  v55 = 2184;
                  v56 = 2082;
                  v57 = v38;
                  v58 = 2048;
                  v59 = v40;
                  v60 = 2082;
                  v61 = v41;
                  v62 = 2082;
                  v63 = SSL_alert_type_string_long(a3);
                  v64 = 2082;
                  v65 = SSL_alert_desc_string_long(a3);
                  _os_log_impl(&dword_1B4F6D000, v36, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] %{public}s alert, level: %{public}s, description: %{public}s", buf, 0x44u);

                  if (v37)
                }

              }
            }
          }
          ++*(_BYTE *)(v10 + 318);
        }
        else if (BYTE1(a3) == 2)
        {
          v12 = objc_loadWeakRetained((id *)(v10 + 16));
          if (!v12
            || (v13 = v12,
                v14 = objc_loadWeakRetained((id *)(v10 + 16)),
                v15 = v14[475],
                v14,
                v13,
                (v15 & 1) == 0))
          {
            v16 = objc_loadWeakRetained((id *)(v10 + 16));
            if (v16)
            {
              v17 = objc_loadWeakRetained((id *)(v10 + 16));
              v18 = (v17[475] & 1) == 0;

            }
            else
            {
              v18 = 1;
            }

            if (v18)
            {
              if (g_boringssl_log)
              {
                v32 = (id)g_boringssl_log;
                if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                {
                  v42 = objc_loadWeakRetained((id *)(v10 + 16));
                  if (v42)
                  {
                    v50 = (char *)objc_loadWeakRetained((id *)(v10 + 16));
                    v51 = v50 + 391;
                  }
                  else
                  {
                    v51 = &unk_1B50022E3;
                  }
                  v45 = objc_loadWeakRetained((id *)(v10 + 16));
                  if (a4)
                    v46 = "read";
                  else
                    v46 = "write";
                  *(_DWORD *)buf = 136447746;
                  v53 = "boringssl_context_handle_fatal_alert";
                  v54 = 1024;
                  v55 = 2165;
                  v56 = 2082;
                  v57 = v51;
                  v58 = 2048;
                  v59 = v45;
                  v60 = 2082;
                  v61 = v46;
                  v62 = 2082;
                  v63 = SSL_alert_type_string_long(a3);
                  v64 = 2082;
                  v65 = SSL_alert_desc_string_long(a3);
                  _os_log_error_impl(&dword_1B4F6D000, v32, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] %{public}s alert, level: %{public}s, description: %{public}s", buf, 0x44u);

                  if (v42)
                }

              }
            }
          }
          ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))boringssl_context_error_print, v9);
          *(_DWORD *)(v10 + 312) = a2;
          *(_BYTE *)(v10 + 316) = 2;
          *(_BYTE *)(v10 + 317) = a3;
          v33 = boringssl_helper_convert_alert_code(a3, a2);
          v34 = *(_QWORD *)(v10 + 280);
          v35 = objc_loadWeakRetained((id *)(v10 + 16));
          (*(void (**)(uint64_t, id, uint64_t, uint64_t))(v34 + 16))(v34, v35, a2, v33);

        }
        else
        {
          v26 = objc_loadWeakRetained((id *)(v10 + 16));
          if (!v26
            || (v27 = v26,
                v28 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v10 + 16)),
                v4 = (char *)v28[475],
                v28,
                v27,
                (v4 & 1) == 0))
          {
            v29 = objc_loadWeakRetained((id *)(v10 + 16));
            if (v29)
            {
              v30 = objc_loadWeakRetained((id *)(v10 + 16));
              v31 = (v30[475] & 1) == 0;

            }
            else
            {
              v31 = 1;
            }

            if (v31)
            {
              if (g_boringssl_log)
              {
                v39 = (id)g_boringssl_log;
                if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                {
                  v43 = objc_loadWeakRetained((id *)(v10 + 16));
                  if (v43)
                  {
                    v4 = (char *)objc_loadWeakRetained((id *)(v10 + 16));
                    v44 = v4 + 391;
                  }
                  else
                  {
                    v44 = &unk_1B50022E3;
                  }
                  v47 = objc_loadWeakRetained((id *)(v10 + 16));
                  v48 = v47;
                  *(_DWORD *)buf = 136447490;
                  v53 = "boringssl_context_alert_callback_handler";
                  v49 = "write";
                  v55 = 2207;
                  v54 = 1024;
                  if (a4)
                    v49 = "read";
                  v56 = 2082;
                  v57 = v44;
                  v58 = 2048;
                  v59 = v47;
                  v60 = 2082;
                  v61 = v49;
                  v62 = 1024;
                  LODWORD(v63) = (_DWORD)v11;
                  _os_log_error_impl(&dword_1B4F6D000, v39, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] Unhandled %{public}s alert level: %d", buf, 0x36u);

                  if (v43)
                }

              }
            }
          }
        }
      }
    }
  }
}

const char *__cdecl SSL_alert_type_string_long(int value)
{
  const char *v1;

  v1 = "unknown";
  if (value >> 8 == 2)
    v1 = "fatal";
  if (value >> 8 == 1)
    return "warning";
  else
    return v1;
}

const char *__cdecl SSL_alert_desc_string_long(int value)
{
  const char *result;

  if (value > 0x45u)
  {
    if (value <= 0x55u)
    {
      switch(value)
      {
        case 'F':
          return "protocol version";
        case 'G':
          return "insufficient security";
        case 'P':
          return "internal error";
        default:
          return "unknown";
      }
    }
    else
    {
      switch((char)value)
      {
        case 'd':
          return "no renegotiation";
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'u':
        case 'v':
        case 'w':
          return "unknown";
        case 'm':
          return "missing extension";
        case 'n':
          return "unsupported extension";
        case 'o':
          return "certificate unobtainable";
        case 'p':
          return "unrecognized name";
        case 'q':
          return "bad certificate status response";
        case 'r':
          return "bad certificate hash value";
        case 's':
          return "unknown PSK identity";
        case 't':
          return "certificate required";
        case 'x':
          return "no application protocol";
        case 'y':
          return "ECH required";
        default:
          if (value == 86)
          {
            result = "inappropriate fallback";
          }
          else
          {
            if (value != 90)
              return "unknown";
            result = "user canceled";
          }
          break;
      }
    }
  }
  else
  {
    switch((char)value)
    {
      case 20:
        return "bad record mac";
      case 21:
        return "decryption failed";
      case 22:
        return "record overflow";
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
        return "unknown";
      case 30:
        return "decompression failure";
      case 40:
        return "handshake failure";
      case 41:
        return "no certificate";
      case 42:
        return "bad certificate";
      case 43:
        return "unsupported certificate";
      case 44:
        return "certificate revoked";
      case 45:
        return "certificate expired";
      case 46:
        return "certificate unknown";
      case 47:
        return "illegal parameter";
      case 48:
        return "unknown CA";
      case 49:
        return "access denied";
      case 50:
        return "decode error";
      case 51:
        return "decrypt error";
      case 60:
        return "export restriction";
      default:
        if ((_BYTE)value)
        {
          if (value != 10)
            return "unknown";
          result = "unexpected_message";
        }
        else
        {
          result = "close notify";
        }
        break;
    }
  }
  return result;
}

void cbb_add_child_cold_2()
{
  __assert_rtn("cbb_add_child", "cbb.c", 273, "cbb->child == NULL");
}

void int_rsa_free(uint64_t a1)
{
  RSA_free(*(RSA **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
}

void int_ec_free(uint64_t a1)
{
  EC_KEY_free(*(EC_KEY **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
}

void EC_KEY_free(EC_KEY *a1)
{
  uint64_t v2;
  void (*v3)(EC_KEY *);

  if (a1 && CRYPTO_refcount_dec_and_test_zero((unsigned int *)a1 + 8))
  {
    v2 = *((_QWORD *)a1 + 5);
    if (v2)
    {
      v3 = *(void (**)(EC_KEY *))(v2 + 24);
      if (v3)
      {
        v3(a1);
        v2 = *((_QWORD *)a1 + 5);
      }
      METHOD_unref(v2);
    }
    EC_GROUP_free(*(EC_GROUP **)a1);
    EC_POINT_free(*((EC_POINT **)a1 + 1));
    OPENSSL_free(*((_QWORD **)a1 + 2));
    CRYPTO_free_ex_data((int)&g_ec_ex_data_class, a1, (CRYPTO_EX_DATA *)a1 + 3);
    OPENSSL_free(a1);
  }
}

uint64_t bssl::compare_uint16_t(bssl *this, unsigned __int16 *a2, const void *a3)
{
  unsigned int v3;
  unsigned int v4;
  BOOL v5;
  _BOOL4 v6;

  v3 = *(unsigned __int16 *)this;
  v4 = *a2;
  v5 = v3 >= v4;
  v6 = v3 > v4;
  if (v5)
    return v6;
  else
    return 0xFFFFFFFFLL;
}

BOOL __boringssl_session_is_eap_configured_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2 && *(_BYTE *)(a2 + 360) != 1)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return a2 != 0;
}

void nw_protocol_boringssl_frame_input_finalizer(void *a1, uint64_t a2, void *a3)
{
  id v4;
  id v5;
  void *v6;
  uint64_t buffer;
  void *v8;

  v4 = a1;
  v5 = a3;
  v6 = v5;
  if ((!v5 || (*((_BYTE *)v5 + 475) & 1) == 0)
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_frame_input_finalizer_cold_1();
  }
  if (v4 && v6)
  {
    nw_frame_array_remove();
    buffer = nw_frame_get_buffer();
    if (buffer)
    {
      v8 = (void *)buffer;
      if (nw_frame_buffer_get_manager())
        nw_mem_buffer_free();
      else
        free(v8);
    }

  }
}

void *nw_protocol_boringssl_allocate_options()
{
  return malloc_type_calloc(1uLL, 0x170uLL, 0x10F00400E22A4EFuLL);
}

void nw_protocol_boringssl_cache_entry_deallocator(uint64_t a1, void *a2)
{
  if (a2)

}

int EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *a1, const EC_POINT *a2, BIGNUM *x, BIGNUM *y, BN_CTX *a5)
{
  int v9;
  int v10;
  int result;
  __int128 v12;
  _OWORD *v13;
  _OWORD *v14;
  _OWORD v15[4];
  unint64_t v16;
  _OWORD v17[4];
  unint64_t v18;

  if (!*(_QWORD *)(*(_QWORD *)a1 + 24))
  {
    v9 = 66;
    v10 = 780;
    goto LABEL_5;
  }
  if (EC_GROUP_cmp(a1, *(const EC_GROUP **)a2, (BN_CTX *)x))
  {
    v9 = 106;
    v10 = 784;
LABEL_5:
    ERR_put_error(15, 0, v9, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", v10);
    return 0;
  }
  v18 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[2] = v12;
  v17[3] = v12;
  v17[0] = v12;
  v17[1] = v12;
  v16 = 0xAAAAAAAAAAAAAAAALL;
  v15[2] = v12;
  v15[3] = v12;
  v15[0] = v12;
  v15[1] = v12;
  if (x)
    v13 = v17;
  else
    v13 = 0;
  if (y)
    v14 = v15;
  else
    v14 = 0;
  result = (*(uint64_t (**)(const EC_GROUP *, char *, _OWORD *, _OWORD *))(*(_QWORD *)a1 + 24))(a1, (char *)a2 + 8, v13, v14);
  if (result)
  {
    if (!x || (result = ec_felem_to_bignum((uint64_t)a1, x, (uint64_t)v17)) != 0)
    {
      if (!y)
        return 1;
      result = ec_felem_to_bignum((uint64_t)a1, y, (uint64_t)v15);
      if (result)
        return 1;
    }
  }
  return result;
}

BOOL ec_felem_to_bignum(uint64_t a1, BIGNUM *a2, uint64_t a3)
{
  __int128 v4;
  int len[2];
  unsigned __int8 s[16];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int16 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11 = -21846;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9 = v4;
  v10 = v4;
  *(_OWORD *)s = v4;
  v8 = v4;
  *(_QWORD *)len = 0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(uint64_t, unsigned __int8 *, int *, uint64_t))(*(_QWORD *)a1 + 128))(a1, s, len, a3);
  return BN_bin2bn(s, len[0], a2) != 0;
}

double ec_GFp_nistp256_point_mul(uint64_t a1, _OWORD *a2, _OWORD *a3, uint64_t a4)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  int v15;
  unint64_t i;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  uint64_t v43;
  char v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  BOOL v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  BOOL v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _BOOL8 v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  __int128 v62;
  __int128 v63;
  double result;
  __int128 v65;
  unint64_t v67;
  uint64_t v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  _OWORD v81[3];
  _BYTE v82[48];
  _OWORD v83[2];
  _OWORD v84[2];
  _OWORD v85[92];
  _QWORD v86[9];

  v86[0] = *MEMORY[0x1E0C80C00];
  bzero(v81, 0x660uLL);
  v6 = a3[1];
  v83[0] = *a3;
  v83[1] = v6;
  v7 = *(_OWORD *)((char *)a3 + 88);
  v84[0] = *(_OWORD *)((char *)a3 + 72);
  v84[1] = v7;
  v8 = a3[9];
  v9 = a3[10];
  v10 = -1440;
  v11 = 2;
  v85[0] = v8;
  v85[1] = v9;
  do
  {
    v12 = &v86[v10 / 8];
    v13 = &v86[v10 / 8 + 4];
    v14 = &v86[v10 / 8 + 8];
    if ((v11 & 1) != 0)
      fiat_p256_point_add(v12, v13, v14, (uint64_t)v83, (uint64_t)v84, (unint64_t *)v85, 0, (unint64_t *)&v85[v10 / 0x10 + 86], (unint64_t *)&v85[v10 / 0x10 + 88], (unint64_t *)&v85[v10 / 0x10 + 90]);
    else
      fiat_p256_point_double(v12, v13, v14, (unint64_t *)&v81[6 * (v11 >> 1)], (unint64_t *)&v81[6 * (v11 >> 1) + 2], (unint64_t *)&v82[96 * (v11 >> 1) + 16]);
    ++v11;
    v10 += 96;
  }
  while (v10);
  v79 = 0u;
  v80 = 0u;
  v77 = 0u;
  v78 = 0u;
  v15 = 1;
  v75 = 0u;
  v76 = 0u;
  for (i = 255; i < 0x100; --i)
  {
    if (!v15)
      fiat_p256_point_double((uint64_t *)&v75, (uint64_t *)&v77, (uint64_t *)&v79, (unint64_t *)&v75, (unint64_t *)&v77, (unint64_t *)&v79);
    if (-858993459 * i <= 0x33333333)
    {
      if (i <= 0xFB)
      {
        v17 = 32 * ((*(_QWORD *)(a4 + 8 * ((i + 4) >> 6)) >> (i + 4)) & 1);
        v18 = i + 3;
      }
      else
      {
        if ((_DWORD)i != 252)
        {
          if (i > 0xFD)
          {
            v21 = 0;
            if ((_DWORD)i != 254)
            {
              v23 = 0;
LABEL_17:
              if ((i - 1) <= 0xFF)
                v24 = (*(_QWORD *)(a4 + 8 * ((i - 1) >> 6)) >> (i - 1)) & 1;
              else
                v24 = 0;
              v25 = v21 | (4 * v23) | (2 * ((*(_QWORD *)(a4 + 8 * (i >> 6)) >> i) & 1)) | v24;
              v67 = 0xAAAAAAAAAAAAAAAALL;
              v68 = 0xAAAAAAAAAAAAAAAALL;
              ec_GFp_nistp_recode_scalar_bits(&v68, &v67, v25);
              v26 = 0;
              v27 = 0;
              v28 = 0;
              v29 = 0;
              v30 = 0;
              v31 = 0;
              v32 = 0;
              v33 = 0;
              v34 = 0;
              v35 = 0;
              v36 = 0;
              v37 = 0;
              v38 = 0;
              v39 = v82;
              do
              {
                if (v67 == v38)
                  v40 = -1;
                else
                  v40 = 0;
                if (v67 == v38)
                  v41 = 0;
                else
                  v41 = -1;
                v37 = v40 & *(v39 - 6) | v41 & v37;
                v34 = v34 & v41 | *(v39 - 5) & v40;
                v33 = v33 & v41 | *(v39 - 4) & v40;
                v32 = v32 & v41 | *(v39 - 3) & v40;
                v36 = v36 & v41 | *(v39 - 2) & v40;
                v31 = v31 & v41 | *(v39 - 1) & v40;
                v30 = v30 & v41 | *v39 & v40;
                v29 = v29 & v41 | v39[1] & v40;
                v35 = v35 & v41 | v39[2] & v40;
                v28 = v28 & v41 | v39[3] & v40;
                v27 = v27 & v41 | v39[4] & v40;
                v26 = v26 & v41 | v39[5] & v40;
                ++v38;
                v39 += 12;
              }
              while (v38 != 17);
              *(_QWORD *)&v70 = v33;
              *((_QWORD *)&v70 + 1) = v32;
              *(_QWORD *)&v74 = v27;
              *((_QWORD *)&v74 + 1) = v26;
              *(_QWORD *)&v69 = v37;
              *((_QWORD *)&v69 + 1) = v34;
              *(_QWORD *)&v73 = v35;
              *((_QWORD *)&v73 + 1) = v28;
              v42 = __CFADD__(v31, -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v26, v36) >> 64));
              v43 = v31 + -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v26, v36) >> 64);
              v44 = v42;
              v42 = v43 == 0;
              v45 = -v43;
              v47 = (v44 + !v42);
              v46 = v30 + v47;
              v48 = __CFADD__(v30, v47);
              v42 = v46 == 0;
              v49 = -v46;
              v51 = (v48 + !v42);
              v50 = v29 + v51;
              v52 = __CFADD__(v29, v51);
              v42 = v50 == 0;
              v53 = -v50;
              if (v52 + !v42)
                v54 = -1;
              else
                v54 = 0;
              v55 = v54 - v36;
              v42 = __CFADD__(__CFADD__(-v36, v54), v45);
              v56 = __CFADD__(-v36, v54) + v45;
              v42 |= __CFADD__(v54, v56);
              v56 += v54;
              v58 = v42;
              v42 = __CFADD__(v42, v49);
              v57 = v58 + v49;
              v59 = v53 + v42 + (v54 & 0xFFFFFFFF00000001);
              if (v68)
                v60 = 0;
              else
                v60 = -1;
              if (v68)
                v61 = -1;
              else
                v61 = 0;
              *(_QWORD *)&v71 = v60 & v36 | v61 & v55;
              *((_QWORD *)&v71 + 1) = v61 & v56 | v60 & v31;
              *(_QWORD *)&v72 = v61 & v57 | v60 & v30;
              *((_QWORD *)&v72 + 1) = v59 & v61 | v60 & v29;
              if (v15)
              {
                v75 = v69;
                v76 = v70;
                v77 = v71;
                v78 = v72;
                v79 = v73;
                v80 = v74;
              }
              else
              {
                fiat_p256_point_add((uint64_t *)&v75, (uint64_t *)&v77, (uint64_t *)&v79, (uint64_t)&v75, (uint64_t)&v77, (unint64_t *)&v79, 0, (unint64_t *)&v69, (unint64_t *)&v71, (unint64_t *)&v73);
              }
              v15 = 0;
              continue;
            }
            v22 = 255;
LABEL_16:
            v23 = (*(_QWORD *)(a4 + 8 * (v22 >> 6)) >> v22) & 1;
            goto LABEL_17;
          }
          v19 = 0;
          v20 = 255;
LABEL_15:
          v21 = (8 * ((*(_QWORD *)(a4 + 8 * (v20 >> 6)) >> v20) & 1)) | v19;
          v22 = i + 1;
          goto LABEL_16;
        }
        v17 = 0;
        v18 = 255;
      }
      v19 = (16 * ((*(_QWORD *)(a4 + 8 * (v18 >> 6)) >> v18) & 1)) | v17;
      v20 = i + 2;
      goto LABEL_15;
    }
  }
  v62 = v76;
  *a2 = v75;
  a2[1] = v62;
  v63 = v78;
  *(_OWORD *)((char *)a2 + 72) = v77;
  *(_OWORD *)((char *)a2 + 88) = v63;
  result = *(double *)&v79;
  v65 = v80;
  a2[9] = v79;
  a2[10] = v65;
  return result;
}

uint64_t *fiat_p256_point_double(uint64_t *a1, uint64_t *a2, uint64_t *a3, unint64_t *a4, unint64_t *a5, unint64_t *a6)
{
  __int128 v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  __int128 v15;
  unint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned __int128 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  _BOOL8 v35;
  uint64_t v36;
  unint64_t v37;
  _BOOL8 v38;
  unint64_t v39;
  _BOOL8 v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unsigned __int128 v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  __int128 v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unsigned __int8 v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _BOOL8 v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _BOOL8 v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _BOOL8 v79;
  unint64_t v80;
  uint64_t v81;
  unsigned __int128 v82;
  unsigned __int128 v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unsigned __int8 v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  __int128 v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unsigned __int128 v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  __int128 v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unsigned __int8 v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  uint64_t v135;
  uint64_t v136;
  unsigned __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  unint64_t v141;
  unint64_t v142;
  unint64_t v143;
  unsigned __int128 v144;
  uint64_t v145;
  unint64_t v146;
  unint64_t v147;
  uint64_t v148;
  BOOL v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  _BOOL8 v158;
  unint64_t v159;
  unint64_t v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  uint64_t v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  unint64_t v168;
  uint64_t v169;
  unint64_t v170;
  unsigned __int128 v171;
  unsigned __int128 v172;
  uint64_t v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  unsigned __int128 v184;
  unint64_t v185;
  uint64_t v186;
  unint64_t v187;
  unint64_t v188;
  unint64_t v189;
  uint64_t v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  uint64_t v195;
  char v196;
  unint64_t v197;
  unint64_t v198;
  uint64_t v199;
  unsigned __int128 v200;
  unint64_t v201;
  uint64_t v202;
  uint64_t v203;
  unint64_t v204;
  __int128 v205;
  unint64_t v206;
  unint64_t v207;
  unsigned __int8 v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t *result;
  uint64_t v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  unsigned __int8 v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  int v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  int v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  int v234;
  uint64_t v235;
  uint64_t v236;
  unsigned __int128 v237;
  uint64_t v238;
  _BYTE v239[24];
  _OWORD v243[2];
  unint64_t v244[4];
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  _BYTE v249[32];
  _BYTE v250[32];
  __int128 v251;
  __int128 v252;
  uint64_t v253;

  v253 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v251 = v10;
  v252 = v10;
  *(_OWORD *)v250 = v10;
  *(_OWORD *)&v250[16] = v10;
  *(_OWORD *)v249 = v10;
  *(_OWORD *)&v249[16] = v10;
  v243[0] = v10;
  v243[1] = v10;
  fiat_p256_square((uint64_t *)&v251, a6);
  fiat_p256_square((uint64_t *)v250, a5);
  fiat_p256_mul((uint64_t *)v249, a4, (unint64_t *)v250);
  v13 = *a4;
  v14 = a4[1];
  v15 = v251;
  v17 = *a4 - v251;
  v18 = __CFADD__(*((_QWORD *)&v251 + 1), -(uint64_t)((*a4 - __PAIR128__(v16, v251)) >> 64));
  v19 = *((_QWORD *)&v251 + 1) + -(uint64_t)((*a4 - __PAIR128__(v16, v251)) >> 64);
  v20 = v18;
  v21 = v14 - v19;
  v22 = v252;
  v18 = __CFADD__((_QWORD)v252, -(uint64_t)((v14 - __PAIR128__(v20, v19)) >> 64));
  v23 = v252 + -(uint64_t)((v14 - __PAIR128__(v20, v19)) >> 64);
  v24 = v18;
  v25 = a4[2];
  v26 = a4[3];
  v27 = v25 - v23;
  v18 = __CFADD__(*((_QWORD *)&v252 + 1), -(uint64_t)((v25 - __PAIR128__(v24, v23)) >> 64));
  v28 = *((_QWORD *)&v252 + 1) + -(uint64_t)((v25 - __PAIR128__(v24, v23)) >> 64);
  v29 = v18;
  v30 = v26 - __PAIR128__(v29, v28);
  v31 = __CFADD__(v17, *((_QWORD *)&v30 + 1)) + v21;
  v32 = __CFADD__(__CFADD__(v17, *((_QWORD *)&v30 + 1)), v21) | __CFADD__(DWORD2(v30), v31);
  v245 = v17 + *((_QWORD *)&v30 + 1);
  v246 = DWORD2(v30) + v31;
  v247 = v32 + v27;
  v248 = v30 + __CFADD__(v32, v27) + (*((_QWORD *)&v30 + 1) & 0xFFFFFFFF00000001);
  v18 = __CFADD__((_QWORD)v251, v13);
  v33 = v251 + v13;
  v35 = v18;
  v18 = __CFADD__(v18, v14);
  v34 = v35 + v14;
  v36 = v18;
  v37 = v252 + v25;
  v38 = __CFADD__((_QWORD)v252, v25);
  v39 = *((_QWORD *)&v252 + 1) + v26;
  v40 = __CFADD__(*((_QWORD *)&v252 + 1), v26);
  v42 = v34 + *((_QWORD *)&v251 + 1);
  v18 = __CFADD__(__CFADD__(v34, *((_QWORD *)&v251 + 1)), v37) | __CFADD__(v36, (__PAIR128__(v37, v34)+ *((unint64_t *)&v251 + 1)) >> 64);
  v41 = v36 + ((__PAIR128__(v37, v34) + *((unint64_t *)&v251 + 1)) >> 64);
  v44 = v18 + v39;
  v18 = __CFADD__(v18, v39) | __CFADD__(v38, v44);
  v43 = v38 + v44;
  if (v18)
    v45 = v40 + 1;
  else
    v45 = v40;
  v46 = v42 - __PAIR128__(v26, (1 - __CFADD__(v33, 1)));
  v47 = v43
      - -(uint64_t)((v41
                                   - __PAIR128__(0xFFFFFFFF00000001, (1 - (__CFADD__((_QWORD)v46, 0xFFFFFFFF00000001) + BYTE8(v46))))) >> 64);
  v48 = -(uint64_t)(v45
                 + (v45 < (1
                                          - (__CFADD__(v47, 0xFFFFFFFFLL)
                                           + ((v43
                                             - __PAIR128__(DWORD2(v30), -(uint64_t)((v41- __PAIR128__(0xFFFFFFFF00000001, (1- (__CFADD__((_QWORD)v46, 0xFFFFFFFF00000001)+ BYTE8(v46))))) >> 64))) >> 64)))));
  if ((_BYTE)v48)
    v49 = 0;
  else
    v49 = -1;
  if ((_BYTE)v48)
    v50 = -1;
  else
    v50 = 0;
  v51 = v49 & (v33 + 1) | v50 & v33;
  v52 = v49 & (v46 - 0xFFFFFFFF) | v50 & v42;
  v53 = v49 & (v41 - (1 - (__CFADD__((_QWORD)v46, 0xFFFFFFFF00000001) + BYTE8(v46)))) | v50 & v41;
  v54 = v49 & (v47 + 0xFFFFFFFF) | v50 & v43;
  *((_QWORD *)&v56 + 1) = v52;
  *(_QWORD *)&v56 = v51;
  v55 = v56 >> 63;
  *((_QWORD *)&v56 + 1) = v53;
  *(_QWORD *)&v56 = v52;
  v57 = v56 >> 63;
  *((_QWORD *)&v56 + 1) = v54;
  *(_QWORD *)&v56 = v53;
  v58 = v56 >> 63;
  v59 = v57 - (1 - __CFADD__(v55, 0xFFFFFFFF00000000));
  v60 = v58
      - -(uint64_t)((v57 - __PAIR128__(v11, (1 - __CFADD__(v55, 0xFFFFFFFF00000000)))) >> 64);
  v61 = 1
      - (__CFADD__(v60, 0xFFFFFFFFLL)
       + ((v58
         - __PAIR128__(v12, -(uint64_t)((v57- __PAIR128__(v11, (1 - __CFADD__(v55, 0xFFFFFFFF00000000)))) >> 64))) >> 64));
  if ((v54 < 0) + ((unint64_t)v54 >> 63 < v61))
    v62 = 0;
  else
    v62 = -1;
  if ((v54 < 0) + ((unint64_t)v54 >> 63 < v61))
    v63 = -1;
  else
    v63 = 0;
  v64 = v62 & ((2 * v51) | 1) | v63 & (2 * v51);
  v65 = v62 & (v55 - 0x100000000) | v63 & v55;
  v66 = v62 & v59;
  v67 = v62 & v59 | v63 & v57;
  v68 = v62 & (v60 + 0xFFFFFFFF) | v63 & v58;
  v18 = __CFADD__(v64, v51);
  v69 = v64 + v51;
  v71 = v18;
  v18 = __CFADD__(v18, v52);
  v70 = v71 + v52;
  v72 = v18;
  v18 = __CFADD__(v70, v65);
  v73 = v70 + v65;
  v75 = v18;
  v18 = __CFADD__(v18, v53);
  v74 = v75 + v53;
  v18 |= __CFADD__(v72, v74);
  v74 += v72;
  v76 = v18;
  v18 = __CFADD__(v74, v67);
  v77 = v74 + v67;
  v79 = v18;
  v18 = __CFADD__(v18, v54);
  v78 = v79 + v54;
  v18 |= __CFADD__(v76, v78);
  v78 += v76;
  v80 = v18;
  v18 = __CFADD__(v78, v68);
  v81 = v78 + v68;
  if (v18)
    ++v80;
  v82 = (unint64_t)v73 - __PAIR128__(v72, (1 - __CFADD__(v69, 1)));
  v83 = (unint64_t)v81
      - __PAIR128__(v66, -(uint64_t)(((unint64_t)v77- __PAIR128__(v64, (1- (__CFADD__((_QWORD)v82, 0xFFFFFFFF00000001)+ BYTE8(v82))))) >> 64));
  if ((_BYTE)v80 + (v80 < (1 - (__CFADD__((_QWORD)v83, 0xFFFFFFFFLL) + BYTE8(v83)))))
    v84 = 0;
  else
    v84 = -1;
  v244[0] = v84 & (v69 + 1) | v69 & *((_QWORD *)&v83 + 1);
  v244[1] = v84 & (v82 - 0xFFFFFFFF) | *((_QWORD *)&v83 + 1) & v73;
  v244[2] = v84 & (v77 - (1 - (__CFADD__((_QWORD)v82, 0xFFFFFFFF00000001) + BYTE8(v82)))) | *((_QWORD *)&v83 + 1) & v77;
  v244[3] = v84 & (v83 + 0xFFFFFFFF) | *((_QWORD *)&v83 + 1) & v81;
  fiat_p256_mul((uint64_t *)v243, (unint64_t *)&v245, v244);
  fiat_p256_square(a1, (unint64_t *)v243);
  v85 = *(__int128 *)v249 >> 63;
  v86 = *(__int128 *)&v249[8] >> 63;
  v87 = *(__int128 *)&v249[16] >> 63;
  v89 = v86 - (1 - __CFADD__(v85, 0xFFFFFFFF00000000));
  v92 = v87
      - -(uint64_t)((v86 - __PAIR128__(v88, (1 - __CFADD__(v85, 0xFFFFFFFF00000000)))) >> 64);
  v91 = (v87
       - __PAIR128__(v90, -(uint64_t)((v86- __PAIR128__(v88, (1 - __CFADD__(v85, 0xFFFFFFFF00000000)))) >> 64))) >> 64;
  v93 = v92 + 0xFFFFFFFF;
  v94 = 1 - (__CFADD__(v92, 0xFFFFFFFFLL) + v91);
  if ((*(uint64_t *)&v249[24] < 0) + (*(_QWORD *)&v249[24] >> 63 < (unint64_t)v94))
    v95 = 0;
  else
    v95 = -1;
  if ((*(uint64_t *)&v249[24] < 0) + (*(_QWORD *)&v249[24] >> 63 < (unint64_t)v94))
    v96 = -1;
  else
    v96 = 0;
  v97 = v95 & ((2 * *(_QWORD *)v249) | 1) | v96 & (2 * *(_QWORD *)v249);
  v98 = v95 & (v85 - 0x100000000) | v96 & v85;
  v99 = v95 & v89 | v96 & v86;
  v100 = v95 & v93 | v96 & v87;
  *((_QWORD *)&v102 + 1) = v98;
  *(_QWORD *)&v102 = v97;
  v101 = v102 >> 63;
  *((_QWORD *)&v102 + 1) = v99;
  *(_QWORD *)&v102 = v98;
  v103 = v102 >> 63;
  *((_QWORD *)&v102 + 1) = v100;
  *(_QWORD *)&v102 = v99;
  v104 = v102 >> 63;
  v105 = v103 - (1 - __CFADD__(v101, 0xFFFFFFFF00000000));
  v106 = v104
       - __PAIR128__(v96, -(uint64_t)((v103- __PAIR128__(v93, (1 - __CFADD__(v101, 0xFFFFFFFF00000000)))) >> 64));
  v107 = v106 + 0xFFFFFFFF;
  if ((v100 < 0)
     + ((unint64_t)v100 >> 63 < (1 - (__CFADD__((_QWORD)v106, 0xFFFFFFFFLL) + BYTE8(v106)))))
  {
    v108 = 0;
  }
  else
  {
    v108 = -1;
  }
  v109 = ((2 * v97) | 1) & v108 | *((_QWORD *)&v106 + 1) & (2 * v97);
  *(_QWORD *)&v239[8] = v108 & v105 | *((_QWORD *)&v106 + 1) & v103;
  *(_QWORD *)&v239[16] = v108 & v107 | *((_QWORD *)&v106 + 1) & v104;
  *(_QWORD *)v239 = v108 & (v101 - 0x100000000) | *((_QWORD *)&v106 + 1) & v101;
  *((_QWORD *)&v111 + 1) = *(_QWORD *)v239;
  *(_QWORD *)&v111 = v109;
  v110 = v111 >> 63;
  v112 = *(__int128 *)v239 >> 63;
  v113 = *(__int128 *)&v239[8] >> 63;
  v114 = v112 - (1 - __CFADD__(v110, 0xFFFFFFFF00000000));
  v116 = v113
       - -(uint64_t)((v112
                                    - __PAIR128__(v105, (1 - __CFADD__(v110, 0xFFFFFFFF00000000)))) >> 64);
  v115 = (v113
        - __PAIR128__(v107, -(uint64_t)((v112- __PAIR128__(v105, (1 - __CFADD__(v110, 0xFFFFFFFF00000000)))) >> 64))) >> 64;
  v117 = v116 + 0xFFFFFFFF;
  v118 = 1 - (__CFADD__(v116, 0xFFFFFFFFLL) + v115);
  if ((*(uint64_t *)&v239[16] < 0) + (*(_QWORD *)&v239[16] >> 63 < (unint64_t)v118))
    v119 = 0;
  else
    v119 = -1;
  if ((*(uint64_t *)&v239[16] < 0) + (*(_QWORD *)&v239[16] >> 63 < (unint64_t)v118))
    v120 = -1;
  else
    v120 = 0;
  v121 = v120 & (2 * v109);
  v122 = v119 & (v110 - 0x100000000) | v120 & v110;
  v123 = v119 & v114 | v120 & v112;
  v124 = v119 & v117 | v120 & v113;
  v126 = ((unint64_t)*a1
        - __PAIR128__(((2 * v109) | 1) & v119 | (unint64_t)v121, ((2 * v109) | 1) & v119 | (unint64_t)v121)) >> 64;
  v125 = *a1 - (((2 * v109) | 1) & v119 | v121);
  LODWORD(v126) = -(int)v126;
  v18 = __CFADD__(v122, v126);
  v127 = v122 + v126;
  v128 = v18;
  v129 = a1[1] - v127;
  v130 = -(int)(((unint64_t)a1[1] - __PAIR128__(v128, v127)) >> 64);
  v18 = __CFADD__(v123, v130);
  v131 = v123 + v130;
  v132 = v18;
  v133 = a1[2] - v131;
  v134 = -(int)(((unint64_t)a1[2] - __PAIR128__(v132, v131)) >> 64);
  v18 = __CFADD__(v124, v134);
  v135 = v124 + v134;
  v136 = v18;
  v137 = (unint64_t)a1[3] - __PAIR128__(v136, v135);
  *a1 = v125 + *((_QWORD *)&v137 + 1);
  a1[1] = DWORD2(v137) + __CFADD__(v125, *((_QWORD *)&v137 + 1)) + v129;
  a1[2] = (__CFADD__(__CFADD__(v125, *((_QWORD *)&v137 + 1)), v129) | __CFADD__(DWORD2(v137), __CFADD__(v125, *((_QWORD *)&v137 + 1))+ v129))+ v133;
  a1[3] = v137
        + __CFADD__(__CFADD__(__CFADD__(v125, *((_QWORD *)&v137 + 1)), v129) | __CFADD__(DWORD2(v137), __CFADD__(v125, *((_QWORD *)&v137 + 1))+ v129), v133)+ (*((_QWORD *)&v137 + 1) & 0xFFFFFFFF00000001);
  v138 = *(_OWORD *)v250;
  v139 = *(_OWORD *)v250 + v15;
  v140 = *(_OWORD *)&v250[16];
  v141 = v22
       + (__CFADD__(__CFADD__(*(_QWORD *)v250, (_QWORD)v15), *(_QWORD *)&v250[8]) | __CFADD__(*((_QWORD *)&v15 + 1), __CFADD__(*(_QWORD *)v250, (_QWORD)v15) + *(_QWORD *)&v250[8]))
       + *(_QWORD *)&v250[16];
  v142 = *((_QWORD *)&v22 + 1)
       + (__CFADD__(__CFADD__(__CFADD__(*(_QWORD *)v250, (_QWORD)v15), *(_QWORD *)&v250[8]) | __CFADD__(*((_QWORD *)&v15 + 1), __CFADD__(*(_QWORD *)v250, (_QWORD)v15) + *(_QWORD *)&v250[8]), (_QWORD)v140) | __CFADD__((_QWORD)v22, (__CFADD__(__CFADD__(*(_QWORD *)v250, (_QWORD)v15), *(_QWORD *)&v250[8]) | __CFADD__(*((_QWORD *)&v15 + 1), __CFADD__(*(_QWORD *)v250, (_QWORD)v15) + *(_QWORD *)&v250[8]))+ (_QWORD)v140))+ *(_QWORD *)&v250[24];
  if (__CFADD__(__CFADD__(__CFADD__(__CFADD__(*(_QWORD *)v250, (_QWORD)v15), *(_QWORD *)&v250[8]) | __CFADD__(*((_QWORD *)&v15 + 1), __CFADD__(*(_QWORD *)v250, (_QWORD)v15) + *(_QWORD *)&v250[8]), *(_QWORD *)&v250[16]) | __CFADD__((_QWORD)v22, (__CFADD__(__CFADD__(*(_QWORD *)v250, (_QWORD)v15), *(_QWORD *)&v250[8]) | __CFADD__(*((_QWORD *)&v15 + 1), __CFADD__(*(_QWORD *)v250, (_QWORD)v15)+ *(_QWORD *)&v250[8]))+ *(_QWORD *)&v250[16]), *(_QWORD *)&v250[24]) | __CFADD__(*((_QWORD *)&v22 + 1), (__CFADD__(__CFADD__(__CFADD__(*(_QWORD *)v250, (_QWORD)v15), *(_QWORD *)&v250[8]) | __CFADD__(*((_QWORD *)&v15 + 1), __CFADD__(*(_QWORD *)v250, (_QWORD)v15) + *(_QWORD *)&v250[8]), *(_QWORD *)&v250[16]) | __CFADD__((_QWORD)v22,
                                                                                 (__CFADD__(__CFADD__(*(_QWORD *)v250, (_QWORD)v15), *(_QWORD *)&v250[8]) | __CFADD__(*((_QWORD *)&v15 + 1), __CFADD__(*(_QWORD *)v250, (_QWORD)v15) + *(_QWORD *)&v250[8]))+ *(_QWORD *)&v250[16]))+ *(_QWORD *)&v250[24]))v143 = 1;
  else
    v143 = 0;
  v144 = *((unint64_t *)&v139 + 1) - __PAIR128__(v117, (1 - __CFADD__((_QWORD)v139, 1)));
  v146 = v142
       - -(uint64_t)((v141
                                    - __PAIR128__(v120, (1- (__CFADD__((_QWORD)v144, 0xFFFFFFFF00000001)+ BYTE8(v144))))) >> 64);
  v145 = (v142
        - __PAIR128__(v121, -(uint64_t)((v141- __PAIR128__(v120, (1- (__CFADD__((_QWORD)v144, 0xFFFFFFFF00000001)+ BYTE8(v144))))) >> 64))) >> 64;
  v147 = v146 + 0xFFFFFFFF;
  v148 = -(uint64_t)(v143 + (v143 < (1 - (__CFADD__(v146, 0xFFFFFFFFLL) + v145))));
  v149 = v148 == 0;
  if ((_BYTE)v148)
    v150 = 0;
  else
    v150 = -1;
  if (v149)
    v151 = 0;
  else
    v151 = -1;
  v152 = v150 & (v139 + 1) | v151 & v139;
  v153 = v150 & (v144 - 0xFFFFFFFF) | v151 & *((_QWORD *)&v139 + 1);
  v154 = v150 & (v141 - (1 - (__CFADD__((_QWORD)v144, 0xFFFFFFFF00000001) + BYTE8(v144)))) | v151 & v141;
  v238 = v150 & v147 | v151 & v142;
  v155 = a6[1];
  v157 = (*a6 + *(_OWORD *)a5) >> 64;
  v156 = *a6 + *a5;
  v158 = __CFADD__(__CFADD__(*a6, *a5), a5[1]);
  v159 = a5[2];
  v160 = a5[3];
  v161 = a6[2];
  v162 = a6[3];
  v18 = __CFADD__(v161, v159);
  v163 = v161 + v159;
  v164 = v18;
  v18 = __CFADD__(v162, v160);
  v165 = v162 + v160;
  v166 = v18;
  v168 = v157 + v155;
  v18 = __CFADD__(__CFADD__(v157, v155), v163) | __CFADD__(v158, (__PAIR128__(v163, v157) + v155) >> 64);
  v167 = v158 + ((__PAIR128__(v163, v157) + v155) >> 64);
  v169 = v164 + v18 + v165;
  if (__CFADD__(v18, v165) | __CFADD__(v164, v18 + v165))
    v170 = v166 + 1;
  else
    v170 = v166;
  v171 = v168 - __PAIR128__(v166, (1 - __CFADD__(v156, 1)));
  v172 = (unint64_t)v169
       - __PAIR128__(v151, -(uint64_t)((v167- __PAIR128__(v147, (1- (__CFADD__((_QWORD)v171, 0xFFFFFFFF00000001)+ BYTE8(v171))))) >> 64));
  if ((_BYTE)v170 + (v170 < (1 - (__CFADD__((_QWORD)v172, 0xFFFFFFFFLL) + BYTE8(v172)))))
    v173 = 0;
  else
    v173 = -1;
  v245 = v173 & (v156 + 1) | *((_QWORD *)&v172 + 1) & v156;
  v246 = v173 & (v171 - 0xFFFFFFFF) | *((_QWORD *)&v172 + 1) & v168;
  v247 = v173 & (v167 - (1 - (__CFADD__((_QWORD)v171, 0xFFFFFFFF00000001) + BYTE8(v171)))) | *((_QWORD *)&v172 + 1) & v167;
  v248 = v173 & (v172 + 0xFFFFFFFF) | *((_QWORD *)&v172 + 1) & v169;
  fiat_p256_square(a3, (unint64_t *)&v245);
  v177 = *a3 - v152;
  v178 = a3[1] - (v153 + -(uint64_t)(((unint64_t)*a3 - __PAIR128__(v176, v152)) >> 64));
  v18 = __CFADD__(v154, -(uint64_t)(((unint64_t)a3[1]- __PAIR128__(v153+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v176, v152)) >> 64), v153+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v176, v152)) >> 64))) >> 64));
  v179 = v154
       + -(uint64_t)(((unint64_t)a3[1]
                                    - __PAIR128__(v153+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v176, v152)) >> 64), v153+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v176, v152)) >> 64))) >> 64);
  v180 = v18;
  v181 = a3[2] - v179;
  v18 = __CFADD__(v238, -(uint64_t)(((unint64_t)a3[2] - __PAIR128__(v180, v179)) >> 64));
  v182 = v238 + -(uint64_t)(((unint64_t)a3[2] - __PAIR128__(v180, v179)) >> 64);
  v183 = v18;
  v184 = (unint64_t)a3[3] - __PAIR128__(v183, v182);
  v185 = __CFADD__(v177, *((_QWORD *)&v184 + 1)) + v178;
  v186 = __CFADD__(__CFADD__(v177, *((_QWORD *)&v184 + 1)), v178) | __CFADD__(DWORD2(v184), v185);
  *a3 = v177 + *((_QWORD *)&v184 + 1);
  a3[1] = DWORD2(v184) + v185;
  a3[2] = v186 + v181;
  a3[3] = v184 + __CFADD__(v186, v181) + (*((_QWORD *)&v184 + 1) & 0xFFFFFFFF00000001);
  v187 = a1[1];
  v188 = v109 - *a1;
  v18 = __CFADD__(v187, -(uint64_t)(((unint64_t)v109 - __PAIR128__(v186 + v181, *a1)) >> 64));
  v189 = v187 + -(uint64_t)(((unint64_t)v109 - __PAIR128__(v186 + v181, *a1)) >> 64);
  v190 = v18;
  v191 = *(_QWORD *)v239 - v189;
  v192 = a1[2];
  v193 = a1[3];
  v18 = __CFADD__(v192, -(uint64_t)((*(unint64_t *)v239 - __PAIR128__(v190, v189)) >> 64));
  v194 = v192 + -(uint64_t)((*(unint64_t *)v239 - __PAIR128__(v190, v189)) >> 64);
  v195 = v18;
  v197 = *(_QWORD *)&v239[8] - v194;
  v196 = (*(unint64_t *)&v239[8] - __PAIR128__(v195, v194)) >> 64;
  v18 = __CFADD__(v193, -v196);
  v198 = v193 + -v196;
  v199 = v18;
  v200 = *(unint64_t *)&v239[16] - __PAIR128__(v199, v198);
  v201 = __CFADD__(v188, *((_QWORD *)&v200 + 1)) + v191;
  v202 = __CFADD__(__CFADD__(v188, *((_QWORD *)&v200 + 1)), v191) | __CFADD__(DWORD2(v200), v201);
  *a2 = v188 + *((_QWORD *)&v200 + 1);
  a2[1] = DWORD2(v200) + v201;
  a2[2] = v202 + v197;
  a2[3] = v200 + __CFADD__(v202, v197) + (*((_QWORD *)&v200 + 1) & 0xFFFFFFFF00000001);
  v203 = v138 >> 63;
  *((_QWORD *)&v205 + 1) = v140;
  *(_QWORD *)&v205 = *((_QWORD *)&v138 + 1);
  v204 = v205 >> 63;
  v206 = v140 >> 63;
  v207 = v206
       - -(uint64_t)((v204
                                    - __PAIR128__(v174, (1 - __CFADD__(v203, 0xFFFFFFFF00000000)))) >> 64);
  v208 = 1
       - (__CFADD__(v207, 0xFFFFFFFFLL)
        + ((v206
          - __PAIR128__(v175, -(uint64_t)((v204- __PAIR128__(v174, (1 - __CFADD__(v203, 0xFFFFFFFF00000000)))) >> 64))) >> 64));
  if ((v140 < 0) + (*((_QWORD *)&v140 + 1) >> 63 < (unint64_t)v208))
    v209 = 0;
  else
    v209 = -1;
  if ((v140 < 0) + (*((_QWORD *)&v140 + 1) >> 63 < (unint64_t)v208))
    v210 = -1;
  else
    v210 = 0;
  *(_QWORD *)v250 = v209 & ((2 * v138) | 1) | v210 & (2 * v138);
  *(_QWORD *)&v250[8] = v209 & (v203 - 0x100000000) | v210 & v203;
  *(_QWORD *)&v250[16] = v209 & (v204 - (1 - __CFADD__(v203, 0xFFFFFFFF00000000))) | v210 & v204;
  *(_QWORD *)&v250[24] = v209 & (v207 + 0xFFFFFFFF) | v210 & v206;
  fiat_p256_square((uint64_t *)v250, (unint64_t *)v250);
  result = fiat_p256_mul(a2, (unint64_t *)v243, (unint64_t *)a2);
  v212 = *(__int128 *)v250 >> 63;
  v213 = *(__int128 *)&v250[8] >> 63;
  v214 = *(__int128 *)&v250[16] >> 63;
  v216 = v213 - (1 - __CFADD__(v212, 0xFFFFFFFF00000000));
  v218 = v214
       - -(uint64_t)((v213
                                    - __PAIR128__(v215, (1 - __CFADD__(v212, 0xFFFFFFFF00000000)))) >> 64);
  v219 = 1
       - (__CFADD__(v218, 0xFFFFFFFFLL)
        + ((v214
          - __PAIR128__(v217, -(uint64_t)((v213- __PAIR128__(v215, (1 - __CFADD__(v212, 0xFFFFFFFF00000000)))) >> 64))) >> 64));
  if ((*(uint64_t *)&v250[24] < 0) + (*(_QWORD *)&v250[24] >> 63 < (unint64_t)v219))
    v220 = 0;
  else
    v220 = -1;
  if ((*(uint64_t *)&v250[24] < 0) + (*(_QWORD *)&v250[24] >> 63 < (unint64_t)v219))
    v221 = -1;
  else
    v221 = 0;
  v222 = v220 & (v212 - 0x100000000) | v221 & v212;
  v223 = v220 & v216 | v221 & v213;
  v224 = v220 & (v218 + 0xFFFFFFFF) | v221 & v214;
  v225 = *a2 - (v220 & ((2 * *(_QWORD *)v250) | 1) | v221 & (2 * *(_QWORD *)v250));
  v226 = -(int)(((unint64_t)*a2
               - __PAIR128__(*a2, v220 & ((2 * *(_QWORD *)v250) | 1) | v221 & (unint64_t)(2 * *(_QWORD *)v250))) >> 64);
  v18 = __CFADD__(v222, v226);
  v227 = v222 + v226;
  v228 = v18;
  v229 = a2[1] - v227;
  v230 = -(int)(((unint64_t)a2[1] - __PAIR128__(v228, v227)) >> 64);
  v18 = __CFADD__(v223, v230);
  v231 = v223 + v230;
  v232 = v18;
  v233 = a2[2] - v231;
  v234 = -(int)(((unint64_t)a2[2] - __PAIR128__(v232, v231)) >> 64);
  v18 = __CFADD__(v224, v234);
  v235 = v224 + v234;
  v236 = v18;
  v237 = (unint64_t)a2[3] - __PAIR128__(v236, v235);
  *a2 = v225 + *((_QWORD *)&v237 + 1);
  a2[1] = DWORD2(v237) + __CFADD__(v225, *((_QWORD *)&v237 + 1)) + v229;
  a2[2] = (__CFADD__(__CFADD__(v225, *((_QWORD *)&v237 + 1)), v229) | __CFADD__(DWORD2(v237), __CFADD__(v225, *((_QWORD *)&v237 + 1))+ v229))+ v233;
  a2[3] = v237
        + __CFADD__(__CFADD__(__CFADD__(v225, *((_QWORD *)&v237 + 1)), v229) | __CFADD__(DWORD2(v237), __CFADD__(v225, *((_QWORD *)&v237 + 1))+ v229), v233)+ (*((_QWORD *)&v237 + 1) & 0xFFFFFFFF00000001);
  return result;
}

double fiat_p256_point_add(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, unint64_t *a6, int a7, unint64_t *a8, unint64_t *a9, unint64_t *a10)
{
  int8x16_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unsigned __int128 v23;
  unsigned __int128 v24;
  uint64_t v25;
  __int128 v26;
  unint64_t v27;
  unint64_t v28;
  unsigned __int128 v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  int8x16_t *v33;
  unsigned __int128 v34;
  uint64_t *v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unsigned __int128 v42;
  unsigned __int128 v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned __int128 v56;
  BOOL v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  char v61;
  unsigned __int128 v62;
  char v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int128 v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  char v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  signed __int128 v81;
  __int128 v82;
  __int128 v83;
  uint64_t *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  char v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  signed __int128 v98;
  uint64_t v99;
  __int128 v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unsigned __int8 v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unint64_t v111;
  double result;
  uint64_t v113;
  __int128 v114;
  unint64_t v115;
  unint64_t v116;
  unsigned __int128 v117;
  uint64_t v118;
  uint64_t v119;
  __int128 v120;
  __int128 v121;
  uint64_t v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  uint64_t v126;
  char v127;
  unint64_t v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  unsigned __int128 v134;
  uint64_t v135;
  uint64_t v136;
  unsigned __int128 v137;
  unint64_t v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  unint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  unsigned __int128 v147;
  char v148;
  uint64_t v149;
  unsigned __int128 v150;
  char v151;
  uint64_t v152;
  uint64_t v153;
  __int128 v154;
  unint64_t v155;
  uint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  uint64_t v160;
  unint64_t v161;
  uint64_t v162;
  unsigned __int128 v163;
  uint64_t v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  unint64_t v170;
  _BOOL8 v171;
  char v172;
  unint64_t v173;
  unint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unsigned __int128 v181;
  int8x16_t *v182;
  unint64_t v183;
  unint64_t v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t v190;
  int8x16_t v191;
  int8x16_t v192;
  int8x16_t v193;
  int8x16_t v194;
  uint64_t v198;
  unint64_t v200;
  unint64_t v201;
  uint64_t v203;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  uint64_t v211[4];
  unint64_t v212[4];
  __int128 v213;
  __int128 v214;
  _OWORD v215[2];
  unint64_t v216[2];
  unsigned __int128 v217;
  unsigned __int128 v218;
  unsigned __int128 v219;
  unsigned __int128 v220;
  unsigned __int128 v221;
  unsigned __int128 v222;
  unsigned __int128 v223;
  unsigned __int128 v224;
  unsigned __int128 v225;
  int8x16_t v226;
  int8x16_t v227;
  int8x16_t v228;
  int8x16_t v229;
  int8x16_t v230;
  unsigned __int128 v231;
  int8x16_t v232;
  int8x16_t v233;
  uint64_t v234;

  v234 = *MEMORY[0x1E0C80C00];
  v12.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v12.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v232 = v12;
  v233 = v12;
  v230 = v12;
  v231 = (unsigned __int128)v12;
  v228 = v12;
  v229 = v12;
  v13 = *a6;
  v14 = a6[1];
  v15 = a6[2];
  v16 = a6[3];
  v201 = v14 | *a6 | v15 | v16;
  v17 = *a10;
  v18 = a10[1];
  v20 = a10[2];
  v19 = a10[3];
  v203 = v18 | *a10 | v20 | v19;
  v226 = v12;
  v227 = v12;
  fiat_p256_square(v226.i64, a6);
  *(_QWORD *)&v23 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v224 = v23;
  v225 = v23;
  v222 = v23;
  v223 = v23;
  v220 = v23;
  v221 = v23;
  if (a7)
  {
    v24 = *(_OWORD *)(a4 + 16);
    *((_QWORD *)&v26 + 1) = v14;
    *(_QWORD *)&v26 = v13;
    v25 = v26 >> 63;
    v224 = *(_OWORD *)a4;
    v225 = v24;
    *((_QWORD *)&v26 + 1) = v15;
    *(_QWORD *)&v26 = v14;
    v27 = v26 >> 63;
    *((_QWORD *)&v26 + 1) = v16;
    *(_QWORD *)&v26 = v15;
    v28 = v26 >> 63;
    v29 = v28
        - __PAIR128__(v22, -(uint64_t)((v27- __PAIR128__(v21, (1 - __CFADD__(v25, 0xFFFFFFFF00000000)))) >> 64));
    if ((v16 < 0)
       + ((unint64_t)v16 >> 63 < (1 - (__CFADD__((_QWORD)v29, 0xFFFFFFFFLL) + BYTE8(v29)))))
    {
      v30 = 0;
    }
    else
    {
      v30 = -1;
    }
    if ((v16 < 0)
       + ((unint64_t)v16 >> 63 < (1 - (__CFADD__((_QWORD)v29, 0xFFFFFFFFLL) + BYTE8(v29)))))
    {
      v31 = -1;
    }
    else
    {
      v31 = 0;
    }
    *(_QWORD *)&v220 = v30 & ((2 * v13) | 1) | v31 & (2 * v13);
    *((_QWORD *)&v220 + 1) = v30 & (v25 - 0x100000000) | v31 & v25;
    *(_QWORD *)&v221 = v30 & (v27 - (1 - __CFADD__(v25, 0xFFFFFFFF00000000))) | v31 & v27;
    *((_QWORD *)&v221 + 1) = v30 & (v29 + 0xFFFFFFFF) | v31 & v28;
    v33 = (int8x16_t *)a10;
    v32 = (unint64_t *)a5;
    v34 = *(_OWORD *)(a5 + 16);
    v222 = *(_OWORD *)a5;
    v223 = v34;
  }
  else
  {
    v218 = v23;
    v219 = v23;
    fiat_p256_square((uint64_t *)&v218, a10);
    v35 = fiat_p256_mul((uint64_t *)&v224, (unint64_t *)a4, (unint64_t *)&v218);
    v37 = v17 + v13;
    v38 = v14 + __CFADD__(v17, v13) + v18;
    v39 = v15 + (__CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13) + v18)) + v20;
    v40 = v16
        + (__CFADD__(__CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13) + v18), v20) | __CFADD__(v15, (__CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13)+ v18))+ v20))+ v19;
    if (__CFADD__(__CFADD__(__CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13) + v18), v20) | __CFADD__(v15, (__CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13)+ v18))+ v20), v19) | __CFADD__(v16, (__CFADD__(__CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13) + v18), v20) | __CFADD__(v15, (__CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13) + v18))+ v20))+ v19))v41 = 1;
    else
      v41 = 0;
    v42 = v38 - __PAIR128__(v36, (1 - __CFADD__(v37, 1)));
    v43 = (unint64_t)v40
        - __PAIR128__((unint64_t)v35, -(uint64_t)((v39- __PAIR128__(0xFFFFFFFF00000001, (1- (__CFADD__((_QWORD)v42, 0xFFFFFFFF00000001)+ BYTE8(v42))))) >> 64));
    v44 = -(uint64_t)(v41 + (v41 < (1 - (__CFADD__((_QWORD)v43, 0xFFFFFFFFLL) + BYTE8(v43)))));
    v45 = v44 == 0;
    if ((_BYTE)v44)
      v46 = 0;
    else
      v46 = -1;
    if (v45)
      v47 = 0;
    else
      v47 = -1;
    *(_QWORD *)&v220 = v46 & (v37 + 1) | v47 & v37;
    *((_QWORD *)&v220 + 1) = v46 & (v42 - 0xFFFFFFFF) | v47 & v38;
    *(_QWORD *)&v221 = v46 & (v39 - (1 - (__CFADD__((_QWORD)v42, 0xFFFFFFFF00000001) + BYTE8(v42)))) | v47 & v39;
    *((_QWORD *)&v221 + 1) = v46 & (v43 + 0xFFFFFFFF) | v47 & v40;
    fiat_p256_square((uint64_t *)&v220, (unint64_t *)&v220);
    v48 = v220 - v226.i64[0];
    v49 = v226.i64[1]
        + -(uint64_t)(((unint64_t)v220 - __PAIR128__(v226.u64[0], v226.u64[0])) >> 64);
    v50 = *((_QWORD *)&v220 + 1) - v49;
    v57 = __CFADD__(v227.i64[0], -(uint64_t)((*((unint64_t *)&v220 + 1) - __PAIR128__(v49, v49)) >> 64));
    v51 = v227.i64[0] + -(uint64_t)((*((unint64_t *)&v220 + 1) - __PAIR128__(v49, v49)) >> 64);
    v52 = v57;
    v53 = v221 - v51;
    v57 = __CFADD__(v227.i64[1], -(uint64_t)(((unint64_t)v221 - __PAIR128__(v52, v51)) >> 64));
    v54 = v227.i64[1] + -(uint64_t)(((unint64_t)v221 - __PAIR128__(v52, v51)) >> 64);
    v55 = v57;
    v56 = *((unint64_t *)&v221 + 1) - __PAIR128__(v55, v54);
    v57 = __CFADD__(__CFADD__(v48, *((_QWORD *)&v56 + 1)), v50) | __CFADD__(DWORD2(v56), __CFADD__(v48, *((_QWORD *)&v56 + 1)) + v50);
    v58 = DWORD2(v56) + __CFADD__(v48, *((_QWORD *)&v56 + 1)) + v50;
    v59 = v56 + __CFADD__(v57, v53) + (*((_QWORD *)&v56 + 1) & 0xFFFFFFFF00000001);
    v61 = ((unint64_t)(v48 + *((_QWORD *)&v56 + 1)) - __PAIR128__(v218, v218)) >> 64;
    v60 = v48 + *((_QWORD *)&v56 + 1) - v218;
    v62 = (unint64_t)v58
        - __PAIR128__(*((_QWORD *)&v218 + 1) + (unint64_t)-v61, *((_QWORD *)&v218 + 1) + (unint64_t)-v61);
    v63 = ((unint64_t)v57
         + v53
         - __PAIR128__((unint64_t)v219 + -BYTE8(v62), (unint64_t)v219 + -BYTE8(v62))) >> 64;
    if (((v59
                          - __PAIR128__(*((_QWORD *)&v219 + 1) + (unint64_t)-v63, *((_QWORD *)&v219 + 1) + (unint64_t)-v63)) >> 64))v64 = -1;
    else
      v64 = 0;
    v65 = __CFADD__(v60, v64) + (_QWORD)v62;
    *(_QWORD *)&v220 = v60 + v64;
    *((_QWORD *)&v220 + 1) = v64 + v65;
    v221 = __PAIR128__(v64 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v60, v64), (_QWORD)v62) | __CFADD__(v64, v65))+ __PAIR128__(v59- (*((_QWORD *)&v219 + 1)+ -(uint64_t)(((unint64_t)v57+ v53- __PAIR128__((unint64_t)v219 + -BYTE8(v62), (unint64_t)v219 + -BYTE8(v62))) >> 64)), v57 + v53 - ((unint64_t)v219 + -BYTE8(v62)));
    fiat_p256_mul((uint64_t *)&v222, a10, (unint64_t *)&v218);
    v32 = (unint64_t *)a5;
    fiat_p256_mul((uint64_t *)&v222, (unint64_t *)&v222, (unint64_t *)a5);
    v33 = (int8x16_t *)a10;
  }
  v66 = a4;
  *(_QWORD *)&v67 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v67 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v218 = v67;
  v219 = v67;
  fiat_p256_mul((uint64_t *)&v218, a8, (unint64_t *)&v226);
  v68 = v218 - v224;
  v69 = *((_QWORD *)&v224 + 1) + -(uint64_t)(((unint64_t)v218 - __PAIR128__(v224, v224)) >> 64);
  v70 = *((_QWORD *)&v218 + 1) - v69;
  v57 = __CFADD__((_QWORD)v225, -(uint64_t)((*((unint64_t *)&v218 + 1) - __PAIR128__(v69, v69)) >> 64));
  v71 = v225 + -(uint64_t)((*((unint64_t *)&v218 + 1) - __PAIR128__(v69, v69)) >> 64);
  v72 = v57;
  v74 = v219 - v71;
  v73 = ((unint64_t)v219 - __PAIR128__(v72, v71)) >> 64;
  v57 = __CFADD__(*((_QWORD *)&v225 + 1), -v73);
  v75 = *((_QWORD *)&v225 + 1) + -v73;
  v76 = v57;
  v77 = *((_QWORD *)&v219 + 1) - v75;
  if (((*((unint64_t *)&v219 + 1) - __PAIR128__(v76, v75)) >> 64))
    v78 = -1;
  else
    v78 = 0;
  v79 = v68 + v78;
  v80 = v78 + __CFADD__(v68, v78) + v70;
  v216[0] = v68 + v78;
  v216[1] = v80;
  v81 = __PAIR128__(v78 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v68, v78), v70) | __CFADD__(v78, __CFADD__(v68, v78) + v70))+ __PAIR128__(v77, v74);
  v217 = __PAIR128__(v78 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v68, v78), v70) | __CFADD__(v78, __CFADD__(v68, v78) + v70))+ __PAIR128__(v77, v74);
  fiat_p256_mul(v228.i64, v216, (unint64_t *)&v220);
  *(_QWORD *)&v82 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v82 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v215[0] = v82;
  v215[1] = v82;
  fiat_p256_mul((uint64_t *)v215, a6, (unint64_t *)&v226);
  *(_QWORD *)&v83 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v83 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v213 = v83;
  v214 = v83;
  v84 = fiat_p256_mul((uint64_t *)&v213, a9, (unint64_t *)v215);
  v86 = v213 - v222;
  v87 = *((_QWORD *)&v222 + 1) + -(uint64_t)(((unint64_t)v213 - __PAIR128__(v222, v222)) >> 64);
  v88 = *((_QWORD *)&v213 + 1) - v87;
  v57 = __CFADD__((_QWORD)v223, -(uint64_t)((*((unint64_t *)&v213 + 1) - __PAIR128__(v87, v87)) >> 64));
  v89 = v223 + -(uint64_t)((*((unint64_t *)&v213 + 1) - __PAIR128__(v87, v87)) >> 64);
  v90 = v57;
  v92 = v214 - v89;
  v91 = ((unint64_t)v214 - __PAIR128__(v90, v89)) >> 64;
  v57 = __CFADD__(*((_QWORD *)&v223 + 1), -v91);
  v93 = *((_QWORD *)&v223 + 1) + -v91;
  v94 = v57;
  if (((*((unint64_t *)&v214 + 1) - __PAIR128__(v94, v93)) >> 64))
    v95 = -1;
  else
    v95 = 0;
  v96 = v86 + v95;
  v97 = __CFADD__(v86, v95) + v88;
  v98 = __PAIR128__(v95 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v86, v95), v88) | __CFADD__(v95, v97))+ __PAIR128__(*((_QWORD *)&v214 + 1) - v93, v92);
  *((_QWORD *)&v100 + 1) = v95 + v97;
  *(_QWORD *)&v100 = v86 + v95;
  v99 = v100 >> 63;
  *((_QWORD *)&v100 + 1) = (__CFADD__(__CFADD__(v86, v95), v88) | __CFADD__(v95, v97))
                         + v92;
  *(_QWORD *)&v100 = v95 + v97;
  v101 = v100 >> 63;
  v102 = v98 >> 63;
  v103 = v101 - (1 - __CFADD__(v99, 0xFFFFFFFF00000000));
  v105 = v102
       - -(uint64_t)((v101
                                    - __PAIR128__((unint64_t)v84, (1 - __CFADD__(v99, 0xFFFFFFFF00000000)))) >> 64);
  v104 = (v102
        - __PAIR128__(v85, -(uint64_t)((v101- __PAIR128__((unint64_t)v84, (1 - __CFADD__(v99, 0xFFFFFFFF00000000)))) >> 64))) >> 64;
  v106 = v105 + 0xFFFFFFFF;
  v107 = 1 - (__CFADD__(v105, 0xFFFFFFFFLL) + v104);
  if ((v98 < 0) + (*((_QWORD *)&v98 + 1) >> 63 < (unint64_t)v107))
    v108 = 0;
  else
    v108 = -1;
  if ((v98 < 0) + (*((_QWORD *)&v98 + 1) >> 63 < (unint64_t)v107))
    v109 = -1;
  else
    v109 = 0;
  v110 = v108 & (v99 - 0x100000000) | v109 & v99;
  v111 = v108 & v103 | v109 & v101;
  v212[0] = v108 & ((2 * v96) | 1) | v109 & (2 * v96);
  v212[1] = v110;
  v212[2] = v111;
  v212[3] = v108 & v106 | v109 & v102;
  if ((((v203 - 1) & ~v203 | (v201 - 1) & ~v201) & 0x8000000000000000) != 0
    || v80 | v79 | (unint64_t)v81 | *((_QWORD *)&v81 + 1) | v110 | v108 & ((2 * v96) | 1) | v109 & (2 * v96) | v111 | v108 & v106 | v109 & v102)
  {
    *((_QWORD *)&v114 + 1) = v80;
    *(_QWORD *)&v114 = v79;
    v113 = v114 >> 63;
    *((_QWORD *)&v114 + 1) = v81;
    *(_QWORD *)&v114 = v80;
    v115 = v114 >> 63;
    v116 = v81 >> 63;
    v117 = v116
         - __PAIR128__(v103, -(uint64_t)((v115- __PAIR128__(v203, (1 - __CFADD__(v113, 0xFFFFFFFF00000000)))) >> 64));
    if (1
       - (__CFADD__((_QWORD)v117, 0xFFFFFFFFLL)
        + BYTE8(v117))
       + (*((_QWORD *)&v81 + 1) >> 63 < (unint64_t)(1
                                                                          - (__CFADD__((_QWORD)v117, 0xFFFFFFFFLL)
                                                                           + BYTE8(v117)))))
    {
      v118 = 0;
    }
    else
    {
      v118 = -1;
    }
    if (1
       - (__CFADD__((_QWORD)v117, 0xFFFFFFFFLL)
        + BYTE8(v117))
       + (*((_QWORD *)&v81 + 1) >> 63 < (unint64_t)(1
                                                                          - (__CFADD__((_QWORD)v117, 0xFFFFFFFFLL)
                                                                           + BYTE8(v117)))))
    {
      v119 = -1;
    }
    else
    {
      v119 = 0;
    }
    v211[0] = v118 & ((2 * v79) | 1) | v119 & (2 * v79);
    v211[1] = v118 & (v113 - 0x100000000) | v119 & v113;
    v211[2] = v118 & (v115 - (1 - __CFADD__(v113, 0xFFFFFFFF00000000))) | v119 & v115;
    v211[3] = v118 & (v117 + 0xFFFFFFFF) | v119 & v116;
    fiat_p256_square(v211, (unint64_t *)v211);
    *(_QWORD *)&v120 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v120 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v209 = v120;
    v210 = v120;
    fiat_p256_mul((uint64_t *)&v209, v216, (unint64_t *)v211);
    *(_QWORD *)&v121 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v121 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v207 = v121;
    v208 = v121;
    fiat_p256_mul((uint64_t *)&v207, (unint64_t *)&v224, (unint64_t *)v211);
    fiat_p256_square(v232.i64, v212);
    v122 = v232.i64[0] - v209;
    v123 = *((_QWORD *)&v209 + 1) + -(uint64_t)((v232.u64[0] - __PAIR128__(v209, v209)) >> 64);
    v124 = v232.i64[1] - v123;
    v57 = __CFADD__((_QWORD)v210, -(uint64_t)((v232.u64[1] - __PAIR128__(v123, v123)) >> 64));
    v125 = v210 + -(uint64_t)((v232.u64[1] - __PAIR128__(v123, v123)) >> 64);
    v126 = v57;
    v128 = v233.i64[0] - v125;
    v127 = (v233.u64[0] - __PAIR128__(v126, v125)) >> 64;
    v57 = __CFADD__(*((_QWORD *)&v210 + 1), -v127);
    v129 = *((_QWORD *)&v210 + 1) + -v127;
    v130 = v57;
    if (((v233.u64[1] - __PAIR128__(v130, v129)) >> 64))
      v131 = -1;
    else
      v131 = 0;
    v132 = v131 + __CFADD__(v122, v131) + v124;
    v133 = v122 + v131 - v207;
    v134 = v132
         - __PAIR128__(v132, *((_QWORD *)&v207 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v122 + v131) - __PAIR128__(v128, v207)) >> 64));
    v136 = ((__CFADD__(__CFADD__(v122, v131), v124) | __CFADD__(v131, __CFADD__(v122, v131) + v124))+ v128- __PAIR128__((unint64_t)v208 + -BYTE8(v134), (unint64_t)v208 + -BYTE8(v134))) >> 64;
    v135 = (__CFADD__(__CFADD__(v122, v131), v124) | __CFADD__(v131, __CFADD__(v122, v131) + v124))+ v128- (v208+ -BYTE8(v134));
    v137 = ((__PAIR128__(v131 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v122, v131), v124) | __CFADD__(v131, __CFADD__(v122, v131) + v124))+ __PAIR128__(v233.i64[1] - v129, v128)) >> 64)- __PAIR128__(*((_QWORD *)&v208 + 1) + (unint64_t)-(char)v136, *((_QWORD *)&v208 + 1) + (unint64_t)-(char)v136);
    v138 = DWORD2(v137) + __CFADD__(v133, *((_QWORD *)&v137 + 1)) + (_QWORD)v134;
    v139 = v137
         + __CFADD__(__CFADD__(__CFADD__(v133, *((_QWORD *)&v137 + 1)), (_QWORD)v134) | __CFADD__(DWORD2(v137), __CFADD__(v133, *((_QWORD *)&v137 + 1))+ (_QWORD)v134), v135)+ (*((_QWORD *)&v137 + 1) & 0xFFFFFFFF00000001);
    v140 = v133 + *((_QWORD *)&v137 + 1) - v207;
    v141 = v138
         - (*((_QWORD *)&v207 + 1)
          + -(uint64_t)(((unint64_t)(v133 + *((_QWORD *)&v137 + 1))
                                       - __PAIR128__(*((_QWORD *)&v137 + 1) & 0xFFFFFFFF00000001, v207)) >> 64));
    LOBYTE(v138) = (v138
                  - __PAIR128__(v138, *((_QWORD *)&v207 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v133 + *((_QWORD *)&v137 + 1))- __PAIR128__(*((_QWORD *)&v137 + 1) & 0xFFFFFFFF00000001, v207)) >> 64))) >> 64;
    v142 = (__CFADD__(__CFADD__(v133, *((_QWORD *)&v137 + 1)), (_QWORD)v134) | __CFADD__(DWORD2(v137), __CFADD__(v133, *((_QWORD *)&v137 + 1))+ (_QWORD)v134))+ v135- (v208+ -(char)v138);
    LOBYTE(v138) = ((unint64_t)(__CFADD__(__CFADD__(v133, *((_QWORD *)&v137 + 1)), (_QWORD)v134) | __CFADD__(DWORD2(v137), __CFADD__(v133, *((_QWORD *)&v137 + 1)) + (_QWORD)v134))
                  + v135
                  - __PAIR128__((unint64_t)v208 + -(char)v138, (unint64_t)v208 + -(char)v138)) >> 64;
    v143 = v139 - (*((_QWORD *)&v208 + 1) + -(char)v138);
    if (((v139
                          - __PAIR128__(*((_QWORD *)&v208 + 1) + (unint64_t)-(char)v138, *((_QWORD *)&v208 + 1) + (unint64_t)-(char)v138)) >> 64))v144 = -1;
    else
      v144 = 0;
    v145 = v140 + v144;
    v146 = v144 + __CFADD__(v140, v144) + v141;
    v147 = __PAIR128__(v144 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v140, v144), v141) | __CFADD__(v144, __CFADD__(v140, v144) + v141))+ __PAIR128__(v143, v142);
    v198 = (__PAIR128__(v144 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v140, v144), v141) | __CFADD__(v144, __CFADD__(v140, v144) + v141))+ __PAIR128__(v143, v142)) >> 64;
    v200 = (__CFADD__(__CFADD__(v140, v144), v141) | __CFADD__(v144, __CFADD__(v140, v144) + v141))+ v142;
    v149 = v207 - (v140 + v144);
    v148 = ((unint64_t)v207 - __PAIR128__(v143, v140 + v144)) >> 64;
    v150 = *((unint64_t *)&v207 + 1)
         - __PAIR128__(v146 + (unint64_t)-v148, v146 + (unint64_t)-v148);
    v151 = ((unint64_t)v208
          - __PAIR128__((unint64_t)v147 + -BYTE8(v150), (unint64_t)v147 + -BYTE8(v150))) >> 64;
    if (((*((unint64_t *)&v208 + 1)
                          - __PAIR128__(*((_QWORD *)&v147 + 1) + (unint64_t)-v151, *((_QWORD *)&v147 + 1) + (unint64_t)-v151)) >> 64))v152 = -1;
    else
      v152 = 0;
    v153 = __CFADD__(v149, v152) + (_QWORD)v150;
    v230.i64[0] = v149 + v152;
    v230.i64[1] = v152 + v153;
    v231 = __PAIR128__(v152 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v149, v152), (_QWORD)v150) | __CFADD__(v152, v153))+ __PAIR128__(*((_QWORD *)&v208 + 1)- (*((_QWORD *)&v147 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)v208- __PAIR128__((unint64_t)v147 + -BYTE8(v150), (unint64_t)v147 + -BYTE8(v150))) >> 64)), v208 - (v147 + -BYTE8(v150)));
    fiat_p256_mul(v230.i64, (unint64_t *)&v230, v212);
    *(_QWORD *)&v154 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v154 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v205 = v154;
    v206 = v154;
    fiat_p256_mul((uint64_t *)&v205, (unint64_t *)&v222, (unint64_t *)&v209);
    v156 = v230.i64[0] - v205;
    v157 = v230.i64[1]
         - (*((_QWORD *)&v205 + 1)
          + -(uint64_t)((v230.u64[0] - __PAIR128__(v155, v205)) >> 64));
    v57 = __CFADD__((_QWORD)v206, -(uint64_t)((v230.u64[1]- __PAIR128__(*((_QWORD *)&v205 + 1)+ (unint64_t)-(uint64_t)((v230.u64[0]- __PAIR128__(v155, v205)) >> 64), *((_QWORD *)&v205 + 1)+ (unint64_t)-(uint64_t)((v230.u64[0]- __PAIR128__(v155, v205)) >> 64))) >> 64));
    v158 = v206
         + -(uint64_t)((v230.u64[1]
                                      - __PAIR128__(*((_QWORD *)&v205 + 1)+ (unint64_t)-(uint64_t)((v230.u64[0]- __PAIR128__(v155, v205)) >> 64), *((_QWORD *)&v205 + 1)+ (unint64_t)-(uint64_t)((v230.u64[0]- __PAIR128__(v155, v205)) >> 64))) >> 64);
    v159 = v57;
    v160 = v231 - v158;
    v57 = __CFADD__(*((_QWORD *)&v206 + 1), -(uint64_t)(((unint64_t)v231 - __PAIR128__(v159, v158)) >> 64));
    v161 = *((_QWORD *)&v206 + 1)
         + -(uint64_t)(((unint64_t)v231 - __PAIR128__(v159, v158)) >> 64);
    v162 = v57;
    v163 = *((unint64_t *)&v231 + 1) - __PAIR128__(v162, v161);
    v164 = __CFADD__(v156, *((_QWORD *)&v163 + 1)) + v157;
    v166 = __CFADD__(__CFADD__(v156, *((_QWORD *)&v163 + 1)), v157) | __CFADD__(DWORD2(v163), v164);
    v165 = v166 + v160;
    v167 = v163 + __CFADD__(v166, v160) + (*((_QWORD *)&v163 + 1) & 0xFFFFFFFF00000001);
    v168 = v156 + *((_QWORD *)&v163 + 1) - v205;
    v169 = DWORD2(v163)
         + v164
         - (*((_QWORD *)&v205 + 1)
          + -(uint64_t)(((unint64_t)(v156 + *((_QWORD *)&v163 + 1)) - __PAIR128__(v205, v205)) >> 64));
    v170 = v206
         + -(uint64_t)(((unint64_t)DWORD2(v163)
                                      + v164
                                      - __PAIR128__(*((_QWORD *)&v205 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v156 + *((_QWORD *)&v163 + 1))- __PAIR128__(v205, v205)) >> 64), *((_QWORD *)&v205 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v156 + *((_QWORD *)&v163 + 1))- __PAIR128__(v205, v205)) >> 64))) >> 64);
    v171 = __CFADD__((_QWORD)v206, -(uint64_t)(((unint64_t)DWORD2(v163)+ v164- __PAIR128__(*((_QWORD *)&v205 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v156 + *((_QWORD *)&v163 + 1))- __PAIR128__(v205, v205)) >> 64), *((_QWORD *)&v205 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v156 + *((_QWORD *)&v163 + 1))- __PAIR128__(v205, v205)) >> 64))) >> 64));
    v173 = v165 - v170;
    v172 = (v165 - __PAIR128__(v171, v170)) >> 64;
    v57 = __CFADD__(*((_QWORD *)&v206 + 1), -v172);
    v174 = *((_QWORD *)&v206 + 1) + -v172;
    v175 = v57;
    if (((v167 - __PAIR128__(v175, v174)) >> 64))
      v176 = -1;
    else
      v176 = 0;
    v177 = (uint64_t)v32;
    v178 = v168 + v176;
    v179 = v66;
    v180 = v176 + __CFADD__(v168, v176) + v169;
    v181 = __PAIR128__(v176 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v168, v176), v169) | __CFADD__(v176, __CFADD__(v168, v176) + v169))+ __PAIR128__(v167 - v174, v173);
    v182 = v33;
    if (v201)
      v183 = 0;
    else
      v183 = -1;
    if (v201)
      v184 = -1;
    else
      v184 = 0;
    v185 = a8[1] & v183 | v184 & v146;
    v186 = a8[2] & v183 | v184 & v200;
    v187 = a8[3] & v183;
    v232.i64[0] = v183 & *a8 | v184 & v145;
    v232.i64[1] = v185;
    v233.i64[0] = v186;
    v233.i64[1] = v187 | v184 & v198;
    fiat_p256_cmovznz((uint64_t)a1, v203, v179, (uint64_t)&v232);
    v188 = a9[1] & v183 | v184 & v180;
    v189 = a9[2] & v183 | v184 & v181;
    v190 = a9[3] & v183;
    v230.i64[0] = *a9 & v183 | v184 & v178;
    v230.i64[1] = v188;
    *(_QWORD *)&v231 = v189;
    *((_QWORD *)&v231 + 1) = v190 | *((_QWORD *)&v181 + 1) & v184;
    fiat_p256_cmovznz((uint64_t)a2, v203, v177, (uint64_t)&v230);
    v191 = (int8x16_t)vdupq_n_s64(v184);
    v192 = (int8x16_t)vdupq_n_s64(v183);
    v193 = vorrq_s8(vandq_s8(v228, v191), vandq_s8(*v182, v192));
    v194 = vorrq_s8(vandq_s8(v229, v191), vandq_s8(v182[1], v192));
    v228 = v193;
    v229 = v194;
    *(_QWORD *)&result = fiat_p256_cmovznz((uint64_t)a3, v203, (uint64_t)a6, (uint64_t)&v228).u64[0];
  }
  else
  {
    fiat_p256_point_double(a1, a2, a3, (unint64_t *)a4, v32, a6);
  }
  return result;
}

uint64_t *fiat_p256_mul(uint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t StatusReg;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unsigned __int128 v29;
  BOOL v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  char v37;
  unint64_t v38;
  _BOOL8 v39;
  uint64_t v40;
  char v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  BOOL v49;
  uint64_t v50;
  uint64_t v51;
  _BOOL8 v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  BOOL v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unsigned __int128 v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  _BOOL8 v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  BOOL v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  unint64_t v120;
  unint64_t v121;
  uint64_t v122;
  uint64_t v123;
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  _BOOL8 v133;
  uint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v146;
  _BOOL8 v147;
  unint64_t v148;
  unint64_t v149;
  uint64_t v150;
  unint64_t v151;
  uint64_t v152;
  uint64_t v153;
  BOOL v154;
  unint64_t v155;
  uint64_t v156;
  unint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unsigned __int128 v160;
  uint64_t v161;
  uint64_t v162;

  v4 = *a2;
  v3 = a2[1];
  v6 = a3[2];
  v5 = a3[3];
  v7 = v5 * *a2;
  v8 = v6 * *a2;
  v9 = (v6 * (unsigned __int128)*a2) >> 64;
  v11 = *a3;
  v10 = a3[1];
  v12 = (v10 * (unsigned __int128)*a2) >> 64;
  v13 = v10 * *a2;
  v14 = (v11 * (unsigned __int128)*a2) >> 64;
  v15 = v11 * *a2;
  v16 = (v15 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v17 = (__PAIR128__(0xFFFFFFFFLL, -1) * v15) >> 64;
  if (__CFADD__((v15 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v15))
    ++v16;
  v18 = v14 + v13;
  v30 = __CFADD__(__CFADD__(v14, v13), v12) | __CFADD__(v8, __CFADD__(v14, v13) + v12);
  v19 = v8 + __CFADD__(v14, v13) + v12;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v21 = v9 + v7 + v30 - 0xFFFFFFFF * v15;
  v22 = v13 + __CFADD__(-(uint64_t)(v11 * v4), v15) + v14 + v17;
  v23 = v16
      + (__CFADD__(__CFADD__(-(uint64_t)(v11 * v4), v15), v18) | __CFADD__(v17, __CFADD__(-(uint64_t)(v11 * v4), v15)+ v18))+ v19;
  v24 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v25 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v26 = (v11 * (unsigned __int128)v3) >> 64;
  v27 = v6 * v3 + __CFADD__(v26, v10 * v3) + ((v10 * (unsigned __int128)v3) >> 64);
  v28 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v29 = __PAIR128__(v10 * v3, v22) + v11 * (unsigned __int128)v3;
  v30 = __CFADD__(__CFADD__(v22, v11 * v3), (__PAIR128__(v10, v11) * v3) >> 64) | __CFADD__(v23, __CFADD__(v22, v11 * v3)+ ((__PAIR128__(v10, v11) * v3) >> 64));
  v31 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  if (v30)
    v32 = v27 + 1;
  else
    v32 = v6 * v3 + __CFADD__(v26, v10 * v3) + ((v10 * (unsigned __int128)v3) >> 64);
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v25);
  v33 = v21
      + (__CFADD__(__CFADD__(v22, v11 * v3), (__PAIR128__(v10, v11) * v3) >> 64) | __CFADD__(v23, __CFADD__(v22, v11 * v3) + ((__PAIR128__(v10, v11) * v3) >> 64)))
      + v32;
  v34 = (v5 * (unsigned __int128)v3) >> 64;
  v35 = v5 * v3;
  v36 = (v6 * (unsigned __int128)v3) >> 64;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v28);
  v39 = v30;
  v37 = __CFADD__(v30, v36) | __CFADD__(v35, v30 + v36);
  v38 = v35 + v39 + v36;
  if (v37)
    ++v34;
  v40 = (v5 * (unsigned __int128)v4) >> 64;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  v43 = v37;
  v41 = __CFADD__(v37, v9) | __CFADD__(v7, v37 + v9);
  v42 = v7 + v43 + v9;
  if (v41)
    v44 = v40 + 1;
  else
    v44 = v40;
  v45 = (v15 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v24);
  if (v41)
    v46 = v21 + 1;
  else
    v46 = v21;
  v48 = __CFADD__(v41, v42) | __CFADD__(0xFFFFFFFF00000001 * v15, v41 + v42);
  v47 = v44 + v48 + v45;
  v51 = __CFADD__(v48, v45) | __CFADD__(v44, v48 + v45);
  v49 = __CFADD__(v51, v34);
  v50 = v51 + v34;
  v52 = __CFADD__(v51, v34);
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v31);
  v54 = __CFADD__(v49, v27) | __CFADD__(v46, v49 + v27);
  v53 = v47 + v54 + v38;
  v55 = (__CFADD__(v54, v38) | __CFADD__(v47, v54 + v38)) + v50;
  v56 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v57 = ((unint64_t)v29 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v58 = (__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v29) >> 64;
  v59 = v23 + __CFADD__(-(uint64_t)v29, (_QWORD)v29) + *((_QWORD *)&v29 + 1);
  v30 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v29, (_QWORD)v29), *((_QWORD *)&v29 + 1) + v23) | __CFADD__(v58, __CFADD__(-(uint64_t)v29, (_QWORD)v29) + *((_QWORD *)&v29 + 1) + v23), v33);
  v60 = (__CFADD__(__CFADD__(-(uint64_t)v29, (_QWORD)v29), *((_QWORD *)&v29 + 1) + v23) | __CFADD__(v58, __CFADD__(-(uint64_t)v29, (_QWORD)v29) + *((_QWORD *)&v29 + 1) + v23))
      + v33;
  v61 = v30;
  v62 = ((unint64_t)v29 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v63 = ((unint64_t)v29 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v30 = __CFADD__(__CFADD__(v57, 0xFFFFFFFF * v29), v60) | __CFADD__(v63, (__PAIR128__(v60, v57)+ (unint64_t)(0xFFFFFFFF * v29)) >> 64);
  v64 = v63 + ((__PAIR128__(v60, v57) + (unint64_t)(0xFFFFFFFF * v29)) >> 64);
  v65 = v61 + v30 - 0xFFFFFFFF * v29;
  if (__CFADD__(v30, 0xFFFFFFFF00000001 * v29) | __CFADD__(v61, v30 - 0xFFFFFFFF * v29))
    v66 = 1;
  else
    v66 = 0;
  v30 = __CFADD__(v65, v53);
  v69 = (__PAIR128__(v62, v65) + v53) >> 64;
  v67 = v65 + v53;
  v30 = __CFADD__(v30, v62) | __CFADD__(v66, v69);
  v68 = v66 + v69;
  v70 = v30;
  v71 = __CFADD__(v68, v55);
  v72 = v68 + v55;
  if (v71)
    ++v70;
  v73 = v59 + ((__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v29) >> 64);
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v56);
  v74 = v52 + v71 + v70;
  v76 = a2[2];
  v75 = a2[3];
  v77 = (v5 * (unsigned __int128)v76) >> 64;
  v78 = v5 * v76;
  v79 = (v6 * (unsigned __int128)v76) >> 64;
  v80 = v6 * v76;
  v81 = (v10 * (unsigned __int128)v76) >> 64;
  v82 = v10 * v76;
  v83 = v11 * v76;
  v84 = (v11 * (unsigned __int128)v76) >> 64;
  v85 = v84 + v82;
  v30 = __CFADD__(__CFADD__(v84, v82), v81) | __CFADD__(v80, __CFADD__(v84, v82) + v81);
  v86 = v80 + __CFADD__(v84, v82) + v81;
  v88 = v30 + v79;
  v30 = __CFADD__(v30, v79) | __CFADD__(v78, v88);
  v87 = v78 + v88;
  if (v30)
    ++v77;
  v89 = __PAIR128__(v84, v73) + __PAIR128__(v82, v83);
  v90 = ((__PAIR128__(v84, v73) + __PAIR128__(v82, v83)) >> 64) + v64;
  v92 = (__CFADD__(__CFADD__(v73, v83), v85) | __CFADD__(v64, __CFADD__(v73, v83) + v85)) + v86;
  v30 = __CFADD__(__CFADD__(__CFADD__(v73, v83), v85) | __CFADD__(v64, __CFADD__(v73, v83) + v85), v86) | __CFADD__(v67, v92);
  v91 = v67 + v92;
  v94 = v30 + v87;
  v30 = __CFADD__(v30, v87) | __CFADD__(v72, v94);
  v93 = v72 + v94;
  v95 = v77 + v30 + v74;
  v96 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v97 = 0xFFFFFFFF00000001 * (v73 + v83);
  v98 = v64 + __CFADD__(-(uint64_t)v89, (_QWORD)v89) + *((_QWORD *)&v89 + 1);
  v99 = (__CFADD__(__CFADD__(-(uint64_t)v89, (_QWORD)v89), v90) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (v73 + v83)) >> 64, __CFADD__(-(uint64_t)v89, (_QWORD)v89)+ v90))+ v91;
  v30 = __CFADD__(((v73 + v83) * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * (v73 + v83));
  v100 = (__PAIR128__(0xFFFFFFFFLL, -1) * (v73 + v83)) >> 64;
  v101 = ((v73 + v83) * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v102 = ((v73 + v83) * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v104 = v30;
  v30 = __CFADD__(v30, v99);
  v103 = v104 + v99;
  v30 |= __CFADD__(v102, v103);
  v103 += v102;
  v106 = v30 + v97;
  v105 = *((_QWORD *)&v89 + 1) + v106;
  if (__CFADD__(v30, v97) | __CFADD__(*((_QWORD *)&v89 + 1), v106))
    v107 = 1;
  else
    v107 = 0;
  v30 = __CFADD__(v105, v93);
  v108 = v105 + v93;
  v109 = v107 + v30 + v101;
  if (__CFADD__(v30, v101) | __CFADD__(v107, v30 + v101))
    v110 = 1;
  else
    v110 = 0;
  v111 = __CFADD__(v109, v95);
  v112 = v109 + v95;
  if (v111)
    v113 = v110 + 1;
  else
    v113 = v110;
  v114 = v98 + v100;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v96);
  if (v111)
    ++v113;
  v115 = (v5 * (unsigned __int128)v75) >> 64;
  v116 = v5 * v75;
  v117 = (v6 * (unsigned __int128)v75) >> 64;
  v118 = v6 * v75;
  v119 = (v10 * (unsigned __int128)v75) >> 64;
  v120 = v10 * v75;
  v121 = v11 * v75;
  v122 = (v11 * (unsigned __int128)v75) >> 64;
  v123 = v122 + v120;
  v30 = __CFADD__(__CFADD__(v122, v120), v119) | __CFADD__(v118, __CFADD__(v122, v120) + v119);
  v124 = v118 + __CFADD__(v122, v120) + v119;
  v126 = v30 + v117;
  v30 = __CFADD__(v30, v117) | __CFADD__(v116, v126);
  v125 = v116 + v126;
  if (v30)
    ++v115;
  v30 = __CFADD__(v114, v121);
  v127 = v114 + v121;
  v128 = v120 + v30 + v122;
  v129 = v128 + v103;
  v131 = __CFADD__(v30, v123) | __CFADD__(v103, v30 + v123);
  v30 = __CFADD__(v131, v124);
  v130 = v131 + v124;
  v30 |= __CFADD__(v108, v130);
  v130 += v108;
  v133 = v30;
  v30 = __CFADD__(v30, v125);
  v132 = v133 + v125;
  v30 |= __CFADD__(v112, v132);
  v132 += v112;
  v134 = (v127 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v135 = v115 + v30 + v113;
  v136 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v137 = 0xFFFFFFFF00000001 * v127;
  v138 = 0xFFFFFFFF * v127;
  v139 = (__PAIR128__(0xFFFFFFFFLL, -1) * v127) >> 64;
  v140 = v103 + __CFADD__(-(uint64_t)v127, v127) + v128;
  v30 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v127, v127), v129) | __CFADD__(v139, __CFADD__(-(uint64_t)v127, v127) + v129), v130);
  v141 = (__CFADD__(__CFADD__(-(uint64_t)v127, v127), v129) | __CFADD__(v139, __CFADD__(-(uint64_t)v127, v127) + v129))+ v130;
  v142 = v30;
  v30 = __CFADD__(v134, v138);
  v143 = v134 + v138;
  v144 = (v127 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v145 = (v127 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v147 = v30;
  v30 = __CFADD__(v30, v141);
  v146 = v147 + v141;
  v30 |= __CFADD__(v145, v146);
  v146 += v145;
  v149 = v30 + v137;
  v30 = __CFADD__(v30, v137) | __CFADD__(v142, v149);
  v148 = v142 + v149;
  v150 = v30;
  v30 = __CFADD__(v148, v132);
  v151 = v148 + v132;
  v152 = v150 + v30 + v144;
  if (__CFADD__(v30, v144) | __CFADD__(v150, v30 + v144))
    v153 = 1;
  else
    v153 = 0;
  v154 = __CFADD__(v152, v135);
  v155 = v152 + v135;
  if (v154)
    ++v153;
  v156 = v140 + v143;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v136);
  if (v154)
    v157 = v153 + 1;
  else
    v157 = v153;
  v159 = v146 - (1 - __CFADD__(v156, 1));
  v158 = (v146 - __PAIR128__(v138, (1 - __CFADD__(v156, 1)))) >> 64;
  v160 = v155
       - __PAIR128__(v135, -(uint64_t)((v151- __PAIR128__(v158, (1 - (__CFADD__(v159, 0xFFFFFFFF00000001) + v158)))) >> 64));
  if (1
     - (__CFADD__((_QWORD)v160, 0xFFFFFFFFLL)
      + BYTE8(v160))
     + (v157 < (1 - (__CFADD__((_QWORD)v160, 0xFFFFFFFFLL) + BYTE8(v160)))))
  {
    v161 = 0;
  }
  else
  {
    v161 = -1;
  }
  if (1
     - (__CFADD__((_QWORD)v160, 0xFFFFFFFFLL)
      + BYTE8(v160))
     + (v157 < (1 - (__CFADD__((_QWORD)v160, 0xFFFFFFFFLL) + BYTE8(v160)))))
  {
    v162 = -1;
  }
  else
  {
    v162 = 0;
  }
  *result = v161 & (v156 + 1) | v162 & v156;
  result[1] = v161 & (v159 - 0xFFFFFFFF) | v162 & v146;
  result[2] = v161 & (v151 - (1 - (__CFADD__(v159, 0xFFFFFFFF00000001) + v158))) | v162 & v151;
  result[3] = v161 & (v160 + 0xFFFFFFFF) | v162 & v155;
  return result;
}

double fiat_p256_select_point_affine(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double result;

  v6 = 0;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  v7 = (uint64_t)(a3 + 2);
  v8 = a1 - 1;
  do
  {
    fiat_p256_cmovznz((uint64_t)a3, v6 ^ v8, a2, (uint64_t)a3);
    fiat_p256_cmovznz(v7, v6++ ^ v8, a2 + 32, v7);
    a2 += 64;
  }
  while (v6 != 15);
  *(_QWORD *)&result = fiat_p256_cmovznz((uint64_t)(a3 + 4), a1, (uint64_t)(a3 + 4), (uint64_t)&fiat_p256_one).u64[0];
  return result;
}

int8x16_t fiat_p256_cmovznz(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t result;

  if (a2)
    v4 = 0;
  else
    v4 = -1;
  if (a2)
    v5 = -1;
  else
    v5 = 0;
  v6 = *(_QWORD *)(a4 + 24) & v5 | *(_QWORD *)(a3 + 24) & v4;
  v7 = vandq_s8(*(int8x16_t *)(a4 + 8), (int8x16_t)vdupq_n_s64(v5));
  v8 = vandq_s8(*(int8x16_t *)(a3 + 8), (int8x16_t)vdupq_n_s64(v4));
  *(_QWORD *)a1 = v4 & *(_QWORD *)a3 | v5 & *(_QWORD *)a4;
  result = vorrq_s8(v7, v8);
  *(int8x16_t *)(a1 + 8) = result;
  *(_QWORD *)(a1 + 24) = v6;
  return result;
}

uint64_t *ec_GFp_nistp_recode_scalar_bits(uint64_t *result, _QWORD *a2, unint64_t a3)
{
  unint64_t v3;

  v3 = ((a3 >> 5) - 1) & a3 | (63 - a3) & -(uint64_t)(a3 >> 5);
  *result = -(uint64_t)(a3 >> 5) & 1;
  *a2 = (v3 & 1) + (v3 >> 1);
  return result;
}

uint64_t ec_GFp_nistp256_point_get_affine_coordinates(uint64_t a1, __int128 *a2, _OWORD *a3, _OWORD *a4)
{
  __int128 v8;
  __int128 v9;
  int v10;
  int v11;
  int v12;
  int v13;
  __int128 v14;
  int v15;
  int v16;
  int v17;
  int v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _OWORD v23[2];
  _OWORD v24[2];
  _OWORD v25[2];
  _OWORD v26[2];
  _OWORD v27[2];
  _OWORD v28[2];
  _OWORD v29[2];
  _OWORD v30[2];
  _OWORD v31[2];
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (ec_GFp_simple_is_at_infinity(a1, (uint64_t)a2))
  {
    ERR_put_error(15, 0, 119, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/p256.c", 419);
    return 0;
  }
  else
  {
    *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v23[0] = v8;
    v23[1] = v8;
    v9 = a2[10];
    v24[0] = a2[9];
    v24[1] = v9;
    v32 = v8;
    v33 = v8;
    v31[0] = v8;
    v31[1] = v8;
    v30[0] = v8;
    v30[1] = v8;
    v29[0] = v8;
    v29[1] = v8;
    v28[0] = v8;
    v28[1] = v8;
    v27[0] = v8;
    v27[1] = v8;
    v26[0] = v8;
    v26[1] = v8;
    fiat_p256_square((uint64_t *)&v32, (unint64_t *)v24);
    fiat_p256_mul((uint64_t *)&v32, (unint64_t *)&v32, (unint64_t *)v24);
    fiat_p256_square((uint64_t *)v31, (unint64_t *)&v32);
    fiat_p256_mul((uint64_t *)v31, (unint64_t *)v31, (unint64_t *)v24);
    fiat_p256_square((uint64_t *)v30, (unint64_t *)v31);
    v10 = 2;
    do
    {
      fiat_p256_square((uint64_t *)v30, (unint64_t *)v30);
      --v10;
    }
    while (v10);
    fiat_p256_mul((uint64_t *)v30, (unint64_t *)v30, (unint64_t *)v31);
    fiat_p256_square((uint64_t *)v29, (unint64_t *)v30);
    v11 = 5;
    do
    {
      fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
      --v11;
    }
    while (v11);
    fiat_p256_mul((uint64_t *)v29, (unint64_t *)v29, (unint64_t *)v30);
    fiat_p256_square((uint64_t *)v28, (unint64_t *)v29);
    v12 = 2;
    do
    {
      fiat_p256_square((uint64_t *)v28, (unint64_t *)v28);
      --v12;
    }
    while (v12);
    fiat_p256_mul((uint64_t *)v28, (unint64_t *)v28, (unint64_t *)v31);
    fiat_p256_square((uint64_t *)v27, (unint64_t *)v28);
    v13 = 14;
    do
    {
      fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
      --v13;
    }
    while (v13);
    fiat_p256_mul((uint64_t *)v27, (unint64_t *)v27, (unint64_t *)v28);
    fiat_p256_square((uint64_t *)v26, (unint64_t *)v27);
    fiat_p256_square((uint64_t *)v26, (unint64_t *)v26);
    fiat_p256_mul((uint64_t *)v26, (unint64_t *)v26, (unint64_t *)&v32);
    *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v25[0] = v14;
    v25[1] = v14;
    fiat_p256_square((uint64_t *)v25, (unint64_t *)v26);
    v15 = 31;
    do
    {
      fiat_p256_square((uint64_t *)v25, (unint64_t *)v25);
      --v15;
    }
    while (v15);
    fiat_p256_mul((uint64_t *)v25, (unint64_t *)v25, (unint64_t *)v24);
    v16 = 128;
    do
    {
      fiat_p256_square((uint64_t *)v25, (unint64_t *)v25);
      --v16;
    }
    while (v16);
    fiat_p256_mul((uint64_t *)v25, (unint64_t *)v25, (unint64_t *)v26);
    v17 = 32;
    do
    {
      fiat_p256_square((uint64_t *)v25, (unint64_t *)v25);
      --v17;
    }
    while (v17);
    fiat_p256_mul((uint64_t *)v25, (unint64_t *)v25, (unint64_t *)v26);
    v18 = 30;
    do
    {
      fiat_p256_square((uint64_t *)v25, (unint64_t *)v25);
      --v18;
    }
    while (v18);
    fiat_p256_mul((uint64_t *)v25, (unint64_t *)v25, (unint64_t *)v27);
    fiat_p256_square((uint64_t *)v25, (unint64_t *)v25);
    fiat_p256_square((uint64_t *)v23, (unint64_t *)v25);
    if (a3)
    {
      v19 = a2[1];
      v32 = *a2;
      v33 = v19;
      fiat_p256_mul((uint64_t *)&v32, (unint64_t *)&v32, (unint64_t *)v23);
      v20 = v33;
      *a3 = v32;
      a3[1] = v20;
    }
    if (a4)
    {
      v21 = *(__int128 *)((char *)a2 + 88);
      v32 = *(__int128 *)((char *)a2 + 72);
      v33 = v21;
      fiat_p256_square((uint64_t *)v23, (unint64_t *)v23);
      fiat_p256_mul((uint64_t *)&v32, (unint64_t *)&v32, (unint64_t *)v24);
      fiat_p256_mul((uint64_t *)&v32, (unint64_t *)&v32, (unint64_t *)v23);
      v22 = v33;
      *a4 = v32;
      a4[1] = v22;
    }
    return 1;
  }
}

uint64_t *fiat_p256_square(uint64_t *result, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unsigned __int128 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  _BOOL8 v44;
  uint64_t v45;
  _BOOL8 v46;
  uint64_t v47;
  _BOOL8 v48;
  uint64_t v49;
  unsigned __int128 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _BOOL8 v55;
  uint64_t v56;
  unint64_t StatusReg;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  _BOOL8 v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  BOOL v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned __int128 v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  _BOOL8 v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  BOOL v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v116;
  _BOOL8 v117;
  unsigned __int128 v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  _BOOL8 v123;
  unint64_t v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  unint64_t v130;
  unint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  unint64_t v135;
  unint64_t v136;
  BOOL v137;
  unint64_t v138;
  uint64_t v139;
  unsigned __int128 v140;
  unint64_t v141;
  uint64_t v142;
  BOOL v143;
  uint64_t v144;
  uint64_t v145;

  v3 = a2[2];
  v2 = a2[3];
  v5 = *a2;
  v4 = a2[1];
  v6 = (*a2 * (unsigned __int128)v2) >> 64;
  v7 = *a2 * v2;
  v8 = (*a2 * (unsigned __int128)v3) >> 64;
  v9 = *a2 * v3;
  v10 = (v5 * (unsigned __int128)v4) >> 64;
  v11 = v5 * v4;
  v12 = v5 * v5;
  v13 = (v5 * (unsigned __int128)v5) >> 64;
  v14 = (__PAIR128__(v4, v5) * v5) >> 64;
  v15 = v10 + __CFADD__(v13, v5 * v4) + v9;
  v16 = v8
      + (__CFADD__(__CFADD__(v13, v5 * v4), v9) | __CFADD__(v10, __CFADD__(v13, v5 * v4) + v9))
      + v7;
  if (__CFADD__(__CFADD__(__CFADD__(v13, v5 * v4), v9) | __CFADD__(v10, __CFADD__(v13, v5 * v4) + v9), v7) | __CFADD__(v8, (__CFADD__(__CFADD__(v13, v5 * v4), v9) | __CFADD__(v10, __CFADD__(v13, v5 * v4) + v9))+ v7))v17 = v6 + 1;
  else
    v17 = v6;
  v18 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v19 = 0xFFFFFFFFLL * v12;
  v20 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v21 = -(uint64_t)(v5 * v5);
  v22 = v11 + __CFADD__(v21, v12) + v13;
  v23 = (__CFADD__(__CFADD__(v21, v12), v14) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (unint64_t)v12) >> 64, __CFADD__(v21, v12) + v14))+ v15;
  v24 = __CFADD__(__CFADD__(__CFADD__(v21, v12), v14) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (unint64_t)v12) >> 64, __CFADD__(v21, v12) + v14), v15);
  v72 = __CFADD__(v16, 0xFFFFFFFF00000001 * v12);
  v25 = v16 - 0xFFFFFFFFLL * v12;
  v26 = v72;
  v72 = __CFADD__(v18, v17);
  v27 = v18 + v17;
  v28 = v72;
  v29 = (v2 * (unsigned __int128)v4) >> 64;
  v30 = v2 * v4;
  v31 = (v3 * (unsigned __int128)v4) >> 64;
  v32 = v3 * v4;
  v33 = v4 * v4;
  v34 = __PAIR128__(v3 * v4, v10) + v4 * (unsigned __int128)v4;
  v36 = __CFADD__(__CFADD__(v10, v4 * v4), v3 * v4) | __CFADD__((v4 * (unsigned __int128)v4) >> 64, __CFADD__(v10, v4 * v4) + v3 * v4);
  v35 = v31 + v36 + v2 * v4;
  if (__CFADD__(v36, v2 * v4) | __CFADD__(v31, v36 + v2 * v4))
    v37 = v29 + 1;
  else
    v37 = (v2 * (unsigned __int128)v4) >> 64;
  v72 = __CFADD__(v20, v19);
  v38 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v39 = 0xFFFFFFFFLL * v12;
  v40 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v41 = v22 + v20 + v19;
  v72 = __CFADD__(v72, v23) | __CFADD__(v40, (__PAIR128__(v23, v38) + (unint64_t)v39) >> 64);
  v42 = v40 + ((__PAIR128__(v23, v38) + (unint64_t)v39) >> 64);
  v44 = v72;
  v72 = __CFADD__(v72, v25);
  v43 = v44 + v25;
  v72 |= __CFADD__(v24, v43);
  v43 += v24;
  v46 = v72;
  v72 = __CFADD__(v72, v27);
  v45 = v46 + v27;
  v72 |= __CFADD__(v26, v45);
  v45 += v26;
  v48 = v72;
  v72 = __CFADD__(v72, v37);
  v47 = v48 + v37;
  v72 |= __CFADD__(v28, v47);
  v47 += v28;
  v49 = v72;
  v50 = __PAIR128__(v10, v41) + __PAIR128__(v33, v11);
  v51 = ((__PAIR128__(v10, v41) + __PAIR128__(v33, v11)) >> 64) + v42;
  v53 = (__CFADD__(__CFADD__(v41, v11), (_QWORD)v34) | __CFADD__(v42, __CFADD__(v41, v11) + (_QWORD)v34))+ *((_QWORD *)&v34 + 1);
  v72 = __CFADD__(__CFADD__(__CFADD__(v41, v11), (_QWORD)v34) | __CFADD__(v42, __CFADD__(v41, v11) + (_QWORD)v34), *((_QWORD *)&v34 + 1)) | __CFADD__(v43, v53);
  v52 = v43 + v53;
  v55 = v72;
  v72 = __CFADD__(v72, v35);
  v54 = v55 + v35;
  v72 |= __CFADD__(v45, v54);
  v54 += v45;
  v56 = v72 + v47;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v58 = 0xFFFFFFFF00000001 * (v41 + v11);
  v59 = (__PAIR128__(0xFFFFFFFFLL, -1) * (v41 + v11)) >> 64;
  v60 = v42 + __CFADD__(-(uint64_t)v50, (_QWORD)v50) + *((_QWORD *)&v50 + 1);
  v61 = (__CFADD__(__CFADD__(-(uint64_t)v50, (_QWORD)v50), v51) | __CFADD__(v59, __CFADD__(-(uint64_t)v50, (_QWORD)v50)+ v51))+ v52;
  v62 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v50, (_QWORD)v50), v51) | __CFADD__(v59, __CFADD__(-(uint64_t)v50, (_QWORD)v50)+ v51), v52);
  v63 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v64 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v65 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v72 = __CFADD__(__CFADD__(v63, 0xFFFFFFFF * v50), v61) | __CFADD__(v65, (__PAIR128__(v61, v63)+ (unint64_t)(0xFFFFFFFF * v50)) >> 64);
  v66 = v65 + ((__PAIR128__(v61, v63) + (unint64_t)(0xFFFFFFFF * v50)) >> 64);
  v67 = v62 + v72 + v58;
  if (__CFADD__(v72, v58) | __CFADD__(v62, v72 + v58))
    v68 = 1;
  else
    v68 = 0;
  v72 = __CFADD__(v67, v54);
  v69 = v67 + v54;
  v70 = v68 + v72 + v64;
  if (__CFADD__(v72, v64) | __CFADD__(v68, v72 + v64))
    v71 = 1;
  else
    v71 = 0;
  v72 = __CFADD__(v70, v56);
  v73 = v70 + v56;
  if (v72)
    v74 = v71 + 1;
  else
    v74 = v71;
  v75 = v60 + v63 + 0xFFFFFFFF * v50;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  v76 = v49 + v72 + v74;
  v77 = (v2 * (unsigned __int128)v3) >> 64;
  v78 = v2 * v3;
  v79 = (v3 * (unsigned __int128)v3) >> 64;
  v80 = v3 * v3;
  v81 = v8 + v32;
  v72 = __CFADD__(__CFADD__(v8, v32), v80);
  v82 = __CFADD__(v8, v32) + v80;
  v72 |= __CFADD__(v31, v82);
  v82 += v31;
  v83 = v79 + v72 + v78;
  if (__CFADD__(v72, v78) | __CFADD__(v79, v72 + v78))
    v84 = v77 + 1;
  else
    v84 = v77;
  v85 = __PAIR128__(v8, v75) + __PAIR128__(v32, v9);
  v86 = ((__PAIR128__(v8, v75) + __PAIR128__(v32, v9)) >> 64) + v66;
  v88 = (__CFADD__(__CFADD__(v75, v9), v81) | __CFADD__(v66, __CFADD__(v75, v9) + v81)) + v82;
  v72 = __CFADD__(__CFADD__(__CFADD__(v75, v9), v81) | __CFADD__(v66, __CFADD__(v75, v9) + v81), v82) | __CFADD__(v69, v88);
  v87 = v69 + v88;
  v90 = v72 + v83;
  v72 = __CFADD__(v72, v83) | __CFADD__(v73, v90);
  v89 = v73 + v90;
  v91 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v92 = v84 + v72 + v76;
  v93 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v94 = 0xFFFFFFFF * v85;
  v95 = (__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v85) >> 64;
  v72 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v85, (_QWORD)v85), v86) | __CFADD__(v95, __CFADD__(-(uint64_t)v85, (_QWORD)v85)+ v86), v87);
  v96 = (__CFADD__(__CFADD__(-(uint64_t)v85, (_QWORD)v85), v86) | __CFADD__(v95, __CFADD__(-(uint64_t)v85, (_QWORD)v85)+ v86))+ v87;
  v97 = v72;
  v72 = __CFADD__(v91, v94);
  v98 = v91 + v94;
  v99 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v100 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v102 = v72;
  v72 = __CFADD__(v72, v96);
  v101 = v102 + v96;
  v72 |= __CFADD__(v100, v101);
  v101 += v100;
  v103 = v97 + v72 - 0xFFFFFFFF * v85;
  if (__CFADD__(v72, 0xFFFFFFFF00000001 * v85) | __CFADD__(v97, v72 - 0xFFFFFFFF * v85))
    v104 = 1;
  else
    v104 = 0;
  v72 = __CFADD__(v103, v89);
  v105 = v103 + v89;
  v106 = v104 + v72 + v99;
  if (__CFADD__(v72, v99) | __CFADD__(v104, v72 + v99))
    v107 = 1;
  else
    v107 = 0;
  v108 = __CFADD__(v106, v92);
  v109 = v106 + v92;
  if (v108)
    ++v107;
  v110 = v66 + __CFADD__(-(uint64_t)v85, (_QWORD)v85) + *((_QWORD *)&v85 + 1) + v98;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v93);
  if (v108)
    v111 = v107 + 1;
  else
    v111 = v107;
  v112 = (v2 * (unsigned __int128)v2) >> 64;
  v113 = v2 * v2;
  v114 = v6 + v30;
  v72 = __CFADD__(__CFADD__(v6, v30), v78) | __CFADD__(v29, __CFADD__(v6, v30) + v78);
  v115 = v29 + __CFADD__(v6, v30) + v78;
  v117 = v72;
  v72 = __CFADD__(v72, v113);
  v116 = v117 + v113;
  v72 |= __CFADD__(v77, v116);
  v116 += v77;
  if (v72)
    ++v112;
  v118 = __PAIR128__(v6, v110) + __PAIR128__(v30, v7);
  v119 = ((__PAIR128__(v6, v110) + __PAIR128__(v30, v7)) >> 64) + v101;
  v121 = (__CFADD__(__CFADD__(v110, v7), v114) | __CFADD__(v101, __CFADD__(v110, v7) + v114)) + v115;
  v72 = __CFADD__(__CFADD__(__CFADD__(v110, v7), v114) | __CFADD__(v101, __CFADD__(v110, v7) + v114), v115) | __CFADD__(v105, v121);
  v120 = v105 + v121;
  v123 = v72;
  v72 = __CFADD__(v72, v116);
  v122 = v123 + v116;
  v72 |= __CFADD__(v109, v122);
  v122 += v109;
  v124 = v112 + v72 + v111;
  v125 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v126 = v101 + __CFADD__(-(uint64_t)v118, (_QWORD)v118) + *((_QWORD *)&v118 + 1);
  v127 = (__CFADD__(__CFADD__(-(uint64_t)v118, (_QWORD)v118), v119) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (unint64_t)v118) >> 64, __CFADD__(-(uint64_t)v118, (_QWORD)v118)+ v119))+ v120;
  v128 = ((unint64_t)v118 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v129 = ((unint64_t)v118 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v72 = __CFADD__(__CFADD__(((unint64_t)v118 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v118), v127);
  v130 = __CFADD__(((unint64_t)v118 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v118) + v127;
  v72 |= __CFADD__(v129, v130);
  v130 += v129;
  v132 = v72 - 0xFFFFFFFF * v118;
  v131 = *((_QWORD *)&v118 + 1) + v132;
  if (__CFADD__(v72, 0xFFFFFFFF00000001 * v118) | __CFADD__(*((_QWORD *)&v118 + 1), v132))
    v133 = 1;
  else
    v133 = 0;
  v135 = v131 + v122;
  v72 = __CFADD__(__CFADD__(v131, v122), v128) | __CFADD__(v133, (__PAIR128__(v128, v131) + v122) >> 64);
  v134 = v133 + ((__PAIR128__(v128, v131) + v122) >> 64);
  v136 = v72;
  v137 = __CFADD__(v134, v124);
  v138 = v134 + v124;
  if (v137)
    ++v136;
  v139 = v126 + ((__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v118) >> 64);
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v125);
  if (v137)
    ++v136;
  v140 = v130 - __PAIR128__(0xFFFFFFFFLL * (uint64_t)v118, (1 - __CFADD__(v139, 1)));
  v141 = v138
       - -(uint64_t)((v135
                                    - __PAIR128__(v124, (1- (__CFADD__((_QWORD)v140, 0xFFFFFFFF00000001)+ BYTE8(v140))))) >> 64);
  v142 = -(uint64_t)(v136
                  + (v136 < (1
                                            - (__CFADD__(v141, 0xFFFFFFFFLL)
                                             + ((v138
                                               - __PAIR128__(v125, -(uint64_t)((v135- __PAIR128__(v124, (1- (__CFADD__((_QWORD)v140, 0xFFFFFFFF00000001)+ BYTE8(v140))))) >> 64))) >> 64)))));
  v143 = v142 == 0;
  if ((_BYTE)v142)
    v144 = 0;
  else
    v144 = -1;
  if (v143)
    v145 = 0;
  else
    v145 = -1;
  *result = v144 & (v139 + 1) | v145 & v139;
  result[1] = v144 & (v140 - 0xFFFFFFFF) | v145 & v130;
  result[2] = v144 & (v135 - (1 - (__CFADD__((_QWORD)v140, 0xFFFFFFFF00000001) + BYTE8(v140)))) | v145 & v135;
  result[3] = v144 & (v141 + 0xFFFFFFFF) | v145 & v138;
  return result;
}

BOOL ec_GFp_simple_is_at_infinity(uint64_t a1, uint64_t a2)
{
  return ec_felem_non_zero_mask(a1, (uint64_t *)(a2 + 144)) == 0;
}

uint64_t ec_felem_non_zero_mask(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(unsigned int *)(a1 + 64);
  if ((int)v2 < 1)
    return 0;
  v3 = 0;
  do
  {
    v4 = *a2++;
    v3 |= v4;
    --v2;
  }
  while (v2);
  if (v3)
    return -1;
  else
    return 0;
}

uint64_t boringssl_context_send_alert(const SSL *a1, int a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  id WeakRetained;
  uint64_t v10;

  v5 = SSL_get_ex_data(a1, 0);
  if (!v5)
    return 0;
  v6 = (uint64_t)v5;
  if (*(_DWORD *)v5 != -1252936367)
    return 0;
  v7 = v5[1];
  if (!v7
    || boringssl_session_get_state((uint64_t)v5) > 3
    || (boringssl_session_is_cancelled(v6) & 1) != 0)
  {
    return 0;
  }
  if ((a2 - 1) >= 3)
    a2 = 0;
  WeakRetained = objc_loadWeakRetained((id *)(v7 + 16));
  v10 = nw_protocol_boringssl_send_alert(WeakRetained, a2, a3);

  return v10;
}

uint64_t nw_protocol_boringssl_send_alert(void *a1, int a2, uint64_t a3)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  void (**v9)(uint64_t, uint64_t, uint64_t);
  uint64_t v10;

  v5 = a1;
  v6 = v5;
  switch(a2)
  {
    case 0:
      v7 = v5[35];
      v8 = *(_QWORD *)(v7 + 24);
      goto LABEL_4;
    case 1:
      v7 = v5[35];
      v8 = *(_QWORD *)(v6[36] + 24);
LABEL_4:
      v9 = (void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
      goto LABEL_8;
    case 2:
      v10 = v5[37];
      goto LABEL_7;
    case 3:
      v10 = v5[38];
LABEL_7:
      v9 = (void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v10 + 24) + 56);
      v7 = v5[35];
LABEL_8:
      (*v9)(v7, (uint64_t)(v6 + 1), a3);
      break;
    default:
      break;
  }

  return 1;
}

void nw_protocol_boringssl_output_available(_QWORD *a1)
{
  uint64_t v2;
  int state;

  if (a1)
  {
    v2 = a1[5];
    if (v2)
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_output_available_cold_5();
      }
      if (a1[4])
      {
        if ((*(_BYTE *)(v2 + 390) & 2) != 0)
        {
          if ((*(_BYTE *)(v2 + 475) & 1) == 0
            && datapath_logging_enabled
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
          {
            nw_protocol_boringssl_output_available_cold_4();
          }
        }
        else if ((*(_BYTE *)(v2 + 475) & 1) == 0
               && g_boringssl_log
               && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          nw_protocol_boringssl_output_available_cold_3();
        }
        if ((*(_BYTE *)(v2 + 388) & 0x20) != 0
          && (nw_protocol_boringssl_write_frames((void *)v2), (*(_BYTE *)(v2 + 388) & 0x20) != 0))
        {
          if ((*(_BYTE *)(v2 + 475) & 1) == 0
            && datapath_logging_enabled
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
          {
            nw_protocol_boringssl_output_available_cold_2();
          }
        }
        else
        {
          state = boringssl_session_get_state(*(_QWORD *)(v2 + 336));
          if (state == 1)
          {
            nw_protocol_boringssl_handshake_negotiate((void *)v2);
          }
          else if (state == 2)
          {
            if ((*(_BYTE *)(v2 + 475) & 1) == 0
              && datapath_logging_enabled
              && g_boringssl_log
              && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
            {
              nw_protocol_boringssl_output_available_cold_1();
            }
            (*(void (**)(void))(*(_QWORD *)(a1[6] + 24) + 72))();
          }
        }
      }
    }
  }
}

void nw_protocol_boringssl_output_available_cold_3()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2();
  OUTLINED_FUNCTION_4_0(&dword_1B4F6D000, v0, v1, "%{public}s(%d) %{public}s[%p] received input available", v2, v3, v4, v5, 2u);
  OUTLINED_FUNCTION_8_0();
}

uint64_t nw_protocol_boringssl_get_input_frames(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v11;
  int v12;
  uint64_t v13;
  id v14;
  unsigned int v15;
  unsigned int v17;
  BOOL v18;
  unsigned int v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(uint64_t);
  void *v33;
  id v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  int v38;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  unsigned int v48;
  __int16 v49;
  unsigned int v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v35 = 0;
  v36 = &v35;
  v37 = 0x2020000000;
  v38 = 0;
  if (!a1)
    goto LABEL_17;
  v6 = *(_QWORD *)(a1 + 40);
  if (!v6)
    goto LABEL_17;
  if ((*(_BYTE *)(v6 + 475) & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_get_input_frames_cold_2();
  }
  v11 = 0;
  if (a4 && a5 && a6)
  {
    if ((boringssl_session_get_state(*(_QWORD *)(v6 + 336)) & 0xFFFFFFFE) == 2)
    {
      nw_frame_array_init();
      if ((*(_BYTE *)(v6 + 475) & 1) == 0)
      {
        if (datapath_logging_enabled)
        {
          v20 = g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136447490;
              v40 = "nw_protocol_boringssl_get_input_frames";
              v41 = 1024;
              v42 = 1823;
              v43 = 2082;
              v44 = v6 + 391;
              v45 = 2048;
              v46 = v6;
              v47 = 1024;
              v48 = a3;
              v49 = 1024;
              v50 = a4;
              _os_log_debug_impl(&dword_1B4F6D000, v20, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] get input frames expected min bytes %u expected max bytes %u", buf, 0x32u);
            }
          }
        }
      }
      v12 = *(char *)(v6 + 388);
      *(_BYTE *)(v6 + 388) &= ~0x40u;
      v13 = MEMORY[0x1E0C809B0];
      if (v12 < 0)
      {
        *(_BYTE *)(v6 + 388) = v12 & 0x3F;
        v14 = *(id *)(*(_QWORD *)(v6 + 336) + 8);
        v30 = v13;
        v31 = 3221225472;
        v32 = __nw_protocol_boringssl_get_input_frames_block_invoke;
        v33 = &unk_1E686E748;
        v34 = (id)v6;
        nw_queue_context_async();

      }
      v26 = 0;
      v27 = &v26;
      v28 = 0x2020000000;
      v29 = 0;
      nw_frame_array_foreach();
      v15 = *((_DWORD *)v27 + 6);
      if (v15 >= a3)
      {
        if ((*(_BYTE *)(v6 + 475) & 1) == 0)
        {
          if (datapath_logging_enabled)
          {
            v21 = g_boringssl_log;
            if (g_boringssl_log)
            {
              if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
              {
                v24 = *((_DWORD *)v36 + 6);
                v25 = *((_DWORD *)v27 + 6);
                *(_DWORD *)buf = 136447490;
                v40 = "nw_protocol_boringssl_get_input_frames";
                v41 = 1024;
                v42 = 1908;
                v43 = 2082;
                v44 = v6 + 391;
                v45 = 2048;
                v46 = v6;
                v47 = 1024;
                v48 = v24;
                v49 = 1024;
                v50 = v25;
                _os_log_debug_impl(&dword_1B4F6D000, v21, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Returning %u frames (%u bytes) to input handler", buf, 0x32u);
              }
              v15 = *((_DWORD *)v27 + 6);
            }
          }
        }
        v17 = *(_DWORD *)(v6 + 380);
        v18 = v17 >= v15;
        v19 = v17 - v15;
        if (!v18)
          v19 = 0;
        *(_DWORD *)(v6 + 380) = v19;
        v11 = *((unsigned int *)v36 + 6);
      }
      else
      {
        if (*((_DWORD *)v36 + 6))
          nw_protocol_boringssl_prepend_frame_array();
        nw_frame_array_init();
        if ((*(_BYTE *)(v6 + 475) & 1) == 0)
        {
          if (datapath_logging_enabled)
          {
            v22 = g_boringssl_log;
            if (g_boringssl_log)
            {
              if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
              {
                v23 = *((_DWORD *)v27 + 6);
                *(_DWORD *)buf = 136447490;
                v40 = "nw_protocol_boringssl_get_input_frames";
                v41 = 1024;
                v42 = 1904;
                v43 = 2082;
                v44 = v6 + 391;
                v45 = 2048;
                v46 = v6;
                v47 = 1024;
                v48 = v23;
                v49 = 1024;
                v50 = a3;
                _os_log_debug_impl(&dword_1B4F6D000, v22, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Not enough bytes in record to satisfy request (%u < %u)", buf, 0x32u);
              }
            }
          }
        }
        v11 = 0;
      }
      _Block_object_dispose(&v26, 8);
      goto LABEL_18;
    }
    if ((*(_BYTE *)(v6 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_get_input_frames_cold_1();
    }
LABEL_17:
    v11 = 0;
  }
LABEL_18:
  _Block_object_dispose(&v35, 8);
  return v11;
}

void sub_1B4F7B45C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void nw_protocol_boringssl_input_available(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL4 v3;
  _BOOL4 v4;
  _BOOL4 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 40);
    if (v2)
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0)
      {
        if (datapath_logging_enabled)
        {
          if (g_boringssl_log)
          {
            v7 = a2;
            v9 = a1;
            v4 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
            a2 = v7;
            a1 = v9;
            if (v4)
            {
              nw_protocol_boringssl_input_available_cold_3();
              a2 = v7;
              a1 = v9;
            }
          }
        }
      }
      if (*(_QWORD *)(a1 + 48))
      {
        if ((*(_BYTE *)(v2 + 390) & 2) != 0)
        {
          if ((*(_BYTE *)(v2 + 475) & 1) == 0)
          {
            if (datapath_logging_enabled)
            {
              if (g_boringssl_log)
              {
                v6 = a2;
                v8 = a1;
                v5 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
                a2 = v6;
                a1 = v8;
                if (v5)
                {
                  nw_protocol_boringssl_input_available_cold_2();
                  goto LABEL_10;
                }
              }
            }
          }
        }
        else if ((*(_BYTE *)(v2 + 475) & 1) == 0)
        {
          if (g_boringssl_log)
          {
            v6 = a2;
            v8 = a1;
            v3 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
            a2 = v6;
            a1 = v8;
            if (v3)
            {
              nw_protocol_boringssl_input_available_cold_1();
LABEL_10:
              a2 = v6;
              a1 = v8;
            }
          }
        }
        if (*(_QWORD *)(v2 + 280) == a2)
        {
          if (!a2)
            goto LABEL_24;
        }
        else if (*(_QWORD *)(v2 + 288) == a2)
        {
          if (!a2)
            goto LABEL_24;
        }
        else
        {
          if (*(_QWORD *)(v2 + 296) != a2)
          {
            if (*(_QWORD *)(v2 + 304) != a2 || !a2)
              goto LABEL_24;
            goto LABEL_21;
          }
          if (!a2)
          {
LABEL_24:
            nw_boringssl_read(a1);
            return;
          }
        }
LABEL_21:
        v10 = 0;
        if (nw_protocol_boringssl_read_frames((void *)v2, a2, &v10))
        {
          nw_frame_array_foreach();
          nw_protocol_boringssl_handshake_negotiate((void *)v2);
        }
      }
    }
  }
}

uint64_t nw_protocol_boringssl_handshake_negotiate(void *a1)
{
  _BYTE *v1;
  id v2;
  uint64_t (*v3)(void);
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  int current_handshake_state;
  int v8;
  const char *handshake_state_description;
  NSObject *v10;
  const char *v11;
  NSObject *v13;
  const char *v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  _BYTE *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  const char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1 || (v1[475] & 1) == 0)
  {
    if (datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_handshake_negotiate_cold_2();
    }
    if (!v2)
      goto LABEL_16;
  }
  if (!*((_QWORD *)v2 + 42) || (v3 = (uint64_t (*)(void))*((_QWORD *)v2 + 12)) == 0)
  {
LABEL_16:
    v4 = 0xFFFFFFFFLL;
    goto LABEL_30;
  }
  if ((*((_BYTE *)v2 + 389) & 4) != 0)
  {
    v4 = 0;
    goto LABEL_30;
  }
  *((_BYTE *)v2 + 389) |= 4u;
  v4 = v3();
  *((_BYTE *)v2 + 389) &= ~4u;
  v5 = v2;
  if ((v5[475] & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_handshake_negotiate_cold_1();
  }
  v6 = *((_QWORD *)v2 + 42);
  if (v6)
  {
    if ((_DWORD)v4)
    {
      current_handshake_state = boringssl_session_get_current_handshake_state(v6);
      if (current_handshake_state)
      {
        v8 = current_handshake_state;
        handshake_state_description = boringssl_helper_get_handshake_state_description(current_handshake_state);
        if ((v5[475] & 1) == 0)
        {
          v13 = g_boringssl_log;
          if (g_boringssl_log)
          {
            v14 = handshake_state_description;
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
            {
              v15 = 136447490;
              v16 = "nw_protocol_boringssl_handshake_negotiate_proceed";
              v17 = 1024;
              v18 = 780;
              v19 = 2082;
              v20 = v5 + 391;
              v21 = 2048;
              v22 = v5;
              v23 = 1024;
              v24 = v8;
              v25 = 2080;
              v26 = v14;
              _os_log_error_impl(&dword_1B4F6D000, v13, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] handshake failed at state %d: %s", (uint8_t *)&v15, 0x36u);
            }
          }
        }
      }
      ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))nw_protocol_error_print, *((void **)v2 + 42));
      if (*((_QWORD *)v5 + 40))
      {
        nw_queue_cancel_source();
        *((_QWORD *)v5 + 40) = 0;
      }
      nw_protocol_boringssl_internal_error(v5, -9858);
      nw_protocol_boringssl_disconnect((uint64_t)(v5 + 8));
      goto LABEL_27;
    }
    if (boringssl_session_get_state(v6) == 2)
      goto LABEL_26;
    if (boringssl_session_in_false_start(*((_QWORD *)v2 + 42)))
    {
      if ((v5[475] & 1) != 0)
        goto LABEL_26;
      v10 = g_boringssl_log;
      if (!g_boringssl_log || !os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO))
        goto LABEL_26;
      v15 = 136446978;
      v16 = "nw_protocol_boringssl_handshake_negotiate_proceed";
      v17 = 1024;
      v18 = 768;
      v19 = 2082;
      v20 = v5 + 391;
      v21 = 2048;
      v22 = v5;
      v11 = "%{public}s(%d) %{public}s[%p] Signaling premature connect due to False Start";
LABEL_44:
      _os_log_impl(&dword_1B4F6D000, v10, OS_LOG_TYPE_INFO, v11, (uint8_t *)&v15, 0x26u);
LABEL_26:
      nw_protocol_boringssl_signal_connected(v5);
      nw_boringssl_read((uint64_t)(v5 + 8));
      goto LABEL_27;
    }
    if (boringssl_session_in_early_data(*((_QWORD *)v2 + 42)))
    {
      if ((v5[475] & 1) != 0)
        goto LABEL_26;
      v10 = g_boringssl_log;
      if (!g_boringssl_log || !os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO))
        goto LABEL_26;
      v15 = 136446978;
      v16 = "nw_protocol_boringssl_handshake_negotiate_proceed";
      v17 = 1024;
      v18 = 772;
      v19 = 2082;
      v20 = v5 + 391;
      v21 = 2048;
      v22 = v5;
      v11 = "%{public}s(%d) %{public}s[%p] Signaling premature connect in early data mode";
      goto LABEL_44;
    }
  }
LABEL_27:

  if (boringssl_session_get_state(*((_QWORD *)v2 + 42)) == 2)
    *((_BYTE *)v2 + 389) &= ~2u;
  nw_boringssl_read((uint64_t)(v5 + 8));
LABEL_30:

  return v4;
}

void nw_boringssl_read(uint64_t a1)
{
  uint64_t v2;
  char v3;
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t buffer_manager_with_context;
  uint64_t v11;
  void *v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  const SSL *v20;
  int error;
  uint64_t v22;
  const char *v23;
  int v24;
  char v25;
  uint64_t v27;
  void *v28;
  id v29;
  id v30;
  NSObject *v31;
  int v32;
  uint64_t v33;
  uint32_t v34;
  uint64_t v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  int v46;
  const char *v47;
  int v48;
  NSObject *oslog;
  NSObject *osloga;
  NSObject *oslogb;
  uint8_t buf[4];
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  uint64_t v57;
  __int16 v58;
  uint64_t v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return;
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2)
    return;
  if ((*(_BYTE *)(v2 + 475) & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_boringssl_read_cold_1();
  }
  if ((*(_BYTE *)(v2 + 388) & 1) != 0 || *(_QWORD *)(v2 + 272) || (*(_BYTE *)(v2 + 389) & 2) != 0)
    return;
  *(_BYTE *)(v2 + 389) |= 2u;
  if (boringssl_session_get_state(*(_QWORD *)(v2 + 336)) < 2)
  {
    if (*(_QWORD *)(v2 + 320))
    {
      nw_queue_cancel_source();
      *(_QWORD *)(v2 + 320) = 0;
    }
    nw_protocol_boringssl_handshake_negotiate(v2);
    goto LABEL_134;
  }
  if (*(char *)(v2 + 388) < 0)
    goto LABEL_129;
  v3 = 0;
  v4 = v2 + 391;
  v5 = "nw_boringssl_read";
  while (1)
  {
    if (*(_DWORD *)(v2 + 380) > 0x800000u)
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0)
      {
        if (datapath_logging_enabled)
        {
          v45 = g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
            {
              v48 = *(_DWORD *)(v2 + 380);
              *(_DWORD *)buf = 136447234;
              v53 = v5;
              v54 = 1024;
              v55 = 636;
              v56 = 2082;
              v57 = v4;
              v58 = 2048;
              v59 = v2;
              v60 = 1024;
              v61 = v48;
              v47 = "%{public}s(%d) %{public}s[%p] Above maximum input threshold, skipping read and resuspending (%u bytes)";
LABEL_149:
              _os_log_debug_impl(&dword_1B4F6D000, v45, OS_LOG_TYPE_DEBUG, v47, buf, 0x2Cu);
            }
          }
        }
      }
LABEL_127:
      v19 = *(_BYTE *)(v2 + 388);
      goto LABEL_128;
    }
    v6 = *(_QWORD *)(a1 + 40);
    if (!v6)
      goto LABEL_28;
    if ((*(_BYTE *)(v6 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        v36 = g_boringssl_log;
        if (g_boringssl_log)
        {
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            v53 = "nw_protocol_boringssl_read_one_record";
            v54 = 1024;
            v55 = 1306;
            v56 = 2082;
            v57 = v6 + 391;
            v58 = 2048;
            v59 = v6;
            _os_log_debug_impl(&dword_1B4F6D000, v36, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] ", buf, 0x26u);
          }
        }
      }
    }
    if ((boringssl_session_get_state(*(_QWORD *)(v6 + 336)) & 0xFFFFFFFE) != 2)
    {
      if ((*(_BYTE *)(v6 + 475) & 1) == 0)
      {
        if (datapath_logging_enabled)
        {
          v38 = g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              v53 = "nw_protocol_boringssl_read_one_record";
              v54 = 1024;
              v55 = 1310;
              v56 = 2082;
              v57 = v6 + 391;
              v58 = 2048;
              v59 = v6;
              _os_log_debug_impl(&dword_1B4F6D000, v38, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Cannot get any bytes in current state", buf, 0x26u);
            }
          }
        }
      }
      goto LABEL_28;
    }
    v7 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t))(v6 + 80))(*(_QWORD *)(v6 + 336), 0, 0x7FFFFFFFLL, 1);
    if ((*(_BYTE *)(v6 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        v37 = g_boringssl_log;
        if (g_boringssl_log)
        {
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136447234;
            v53 = "nw_protocol_boringssl_read_one_record";
            v54 = 1024;
            v55 = 1319;
            v56 = 2082;
            v57 = v6 + 391;
            v58 = 2048;
            v59 = v6;
            v60 = 1024;
            v61 = v7;
            _os_log_debug_impl(&dword_1B4F6D000, v37, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] peeked %d bytes", buf, 0x2Cu);
          }
        }
      }
    }
    v8 = *(_QWORD **)(v6 + 336);
    if (v8)
    {
      if (*(_DWORD *)v8 == -1252936367)
      {
        v9 = v8[1];
        if (v9)
        {
          if ((int)v7 < 1)
          {
            if (boringssl_session_get_state(*(_QWORD *)(v6 + 336)) == 4)
              goto LABEL_28;
            v20 = *(const SSL **)(v9 + 400);
            if (v20)
            {
              error = SSL_get_error(v20, v7);
              if ((*(_BYTE *)(v6 + 475) & 1) == 0)
              {
                if (datapath_logging_enabled)
                {
                  v41 = g_boringssl_log;
                  if (g_boringssl_log)
                  {
                    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136447234;
                      v53 = "nw_protocol_boringssl_read_one_record";
                      v54 = 1024;
                      v55 = 1375;
                      v56 = 2082;
                      v57 = v6 + 391;
                      v58 = 2048;
                      v59 = v6;
                      v60 = 1024;
                      v61 = error;
                      _os_log_debug_impl(&dword_1B4F6D000, v41, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] read error code %d", buf, 0x2Cu);
                    }
                  }
                }
              }
              if (error == 1)
              {
                ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))nw_protocol_error_print, v8);
                nw_protocol_boringssl_internal_error((void *)v6, -9810);
                nw_protocol_boringssl_disconnect(a1);
              }
              else if (error == 6)
              {
                nw_protocol_boringssl_input_finished(a1);
              }
            }
            else if ((*(_BYTE *)(v6 + 475) & 1) == 0)
            {
              v35 = g_boringssl_log;
              if (g_boringssl_log)
              {
                if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446978;
                  v53 = "nw_protocol_boringssl_read_one_record";
                  v54 = 1024;
                  v55 = 1371;
                  v56 = 2082;
                  v57 = v6 + 391;
                  v58 = 2048;
                  v59 = v6;
                  v15 = v35;
                  v16 = "%{public}s(%d) %{public}s[%p] cannot peek into the session";
                  v34 = 38;
                  goto LABEL_79;
                }
              }
            }
            goto LABEL_28;
          }
          buffer_manager_with_context = nw_frame_get_buffer_manager_with_context();
          if (buffer_manager_with_context)
          {
            v11 = buffer_manager_with_context;
            v12 = (void *)nw_mem_buffer_allocate();
            if (v12)
            {
LABEL_47:
              v22 = v4;
              v23 = v5;
              v24 = (*(uint64_t (**)(_QWORD, void *, uint64_t, _QWORD))(v6 + 80))(*(_QWORD *)(v6 + 336), v12, v7, 0);
              v25 = *(_BYTE *)(v6 + 475);
              if ((v25 & 1) == 0)
              {
                if (datapath_logging_enabled)
                {
                  oslog = g_boringssl_log;
                  if (g_boringssl_log)
                  {
                    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136447234;
                      v53 = "nw_protocol_boringssl_read_one_record";
                      v54 = 1024;
                      v55 = 1350;
                      v56 = 2082;
                      v57 = v6 + 391;
                      v58 = 2048;
                      v59 = v6;
                      v60 = 1024;
                      v61 = v24;
                      _os_log_debug_impl(&dword_1B4F6D000, oslog, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Actually read %d bytes", buf, 0x2Cu);
                    }
                    v25 = *(_BYTE *)(v6 + 475);
                  }
                }
              }
              if (v24 != (_DWORD)v7 && (v25 & 1) == 0)
              {
                osloga = g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136447490;
                    v53 = "nw_protocol_boringssl_read_one_record";
                    v54 = 1024;
                    v55 = 1352;
                    v56 = 2082;
                    v57 = v6 + 391;
                    v58 = 2048;
                    v59 = v6;
                    v60 = 1024;
                    v61 = v24;
                    v62 = 1024;
                    v63 = v7;
                    _os_log_error_impl(&dword_1B4F6D000, osloga, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] Unexpected read result %d != %d", buf, 0x32u);
                  }
                  v25 = *(_BYTE *)(v6 + 475);
                }
              }
              if ((v25 & 1) == 0)
              {
                if (datapath_logging_enabled)
                {
                  v39 = g_boringssl_log;
                  if (g_boringssl_log)
                  {
                    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136447234;
                      v53 = "nw_protocol_boringssl_read_one_record";
                      v54 = 1024;
                      v55 = 1403;
                      v56 = 2082;
                      v57 = v6 + 391;
                      v58 = 2048;
                      v59 = v6;
                      v60 = 1024;
                      v61 = v7;
                      _os_log_debug_impl(&dword_1B4F6D000, v39, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] bytes read: %u", buf, 0x2Cu);
                    }
                  }
                }
              }
              v27 = nw_frame_create();
              v28 = (void *)v27;
              if (v11)
              {
                if (v27)
                {
                  nw_frame_set_buffer_used_manager();
LABEL_58:
                  v29 = boringssl_context_copy_metadata(*(_QWORD *)(v6 + 336));
                  if (v29)
                  {
                    boringssl_context_is_dtls(*(_QWORD *)(v6 + 336));
                    nw_frame_set_metadata();
                  }
                  v30 = v28;
                  nw_frame_array_append();
                  nw_frame_array_append();

                  *(_DWORD *)(v6 + 380) += v7;
                  v5 = v23;
                  v4 = v22;
                  goto LABEL_61;
                }
                if ((*(_BYTE *)(v6 + 475) & 1) == 0)
                {
                  oslogb = g_boringssl_log;
                  if (g_boringssl_log)
                  {
                    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136447234;
                      v53 = "nw_protocol_boringssl_read_one_record";
                      v54 = 1024;
                      v55 = 1410;
                      v56 = 2082;
                      v57 = v6 + 391;
                      v58 = 2048;
                      v59 = v6;
                      v60 = 1024;
                      v61 = v7;
                      _os_log_error_impl(&dword_1B4F6D000, oslogb, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] nw_frame_create failed for %d bytes", buf, 0x2Cu);
                    }
                  }
                }
                nw_mem_buffer_free();
              }
              else
              {
                if (v27)
                {
                  nw_frame_set_buffer_used_malloc();
                  goto LABEL_58;
                }
                if ((*(_BYTE *)(v6 + 475) & 1) == 0)
                {
                  v42 = g_boringssl_log;
                  if (g_boringssl_log)
                  {
                    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136447234;
                      v53 = "nw_protocol_boringssl_read_one_record";
                      v54 = 1024;
                      v55 = 1418;
                      v56 = 2082;
                      v57 = v6 + 391;
                      v58 = 2048;
                      v59 = v6;
                      v60 = 1024;
                      v61 = v7;
                      _os_log_error_impl(&dword_1B4F6D000, v42, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] nw_frame_create failed for %d bytes", buf, 0x2Cu);
                    }
                  }
                }
                free(v12);
              }

              v5 = v23;
              v4 = v22;
              goto LABEL_28;
            }
            if ((*(_BYTE *)(v6 + 475) & 1) == 0)
            {
              if (datapath_logging_enabled)
              {
                v40 = g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136447234;
                    v53 = "nw_protocol_boringssl_read_one_record";
                    v54 = 1024;
                    v55 = 1329;
                    v56 = 2082;
                    v57 = v6 + 391;
                    v58 = 2048;
                    v59 = v6;
                    v60 = 1024;
                    v61 = v7;
                    _os_log_debug_impl(&dword_1B4F6D000, v40, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Failed to allocate %d bytes for input_buffer from buffer manager", buf, 0x2Cu);
                  }
                }
              }
            }
            v13 = malloc_type_malloc(v7, 0xFBEE1C37uLL);
            if (!v13)
            {
              if ((*(_BYTE *)(v6 + 475) & 1) == 0)
              {
                v14 = g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136447234;
                    v53 = "nw_protocol_boringssl_read_one_record";
                    v54 = 1024;
                    v55 = 1335;
                    v56 = 2082;
                    v57 = v6 + 391;
                    v58 = 2048;
                    v59 = v6;
                    v60 = 1024;
                    v61 = v7;
                    v15 = v14;
                    v16 = "%{public}s(%d) %{public}s[%p] Failed to allocate %d bytes for input_buffer";
LABEL_74:
                    v34 = 44;
LABEL_79:
                    _os_log_error_impl(&dword_1B4F6D000, v15, OS_LOG_TYPE_ERROR, v16, buf, v34);
                    goto LABEL_28;
                  }
                }
              }
              goto LABEL_28;
            }
          }
          else
          {
            v13 = malloc_type_malloc(v7, 0x7226F300uLL);
            if (!v13)
            {
              if ((*(_BYTE *)(v6 + 475) & 1) == 0)
              {
                v33 = g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136447234;
                    v53 = "nw_protocol_boringssl_read_one_record";
                    v54 = 1024;
                    v55 = 1342;
                    v56 = 2082;
                    v57 = v6 + 391;
                    v58 = 2048;
                    v59 = v6;
                    v60 = 1024;
                    v61 = v7;
                    v15 = v33;
                    v16 = "%{public}s(%d) %{public}s[%p] Failed to allocate %d bytes for input_buffer";
                    goto LABEL_74;
                  }
                }
              }
LABEL_28:
              if ((v3 & 1) == 0)
                goto LABEL_129;
              goto LABEL_29;
            }
          }
          v12 = v13;
          v11 = 0;
          goto LABEL_47;
        }
      }
    }
LABEL_61:
    if (*(_DWORD *)(v2 + 380) <= 0x800000u)
    {
      v3 = 1;
      goto LABEL_36;
    }
    if ((*(_BYTE *)(v2 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        v31 = g_boringssl_log;
        if (g_boringssl_log)
        {
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
          {
            v32 = *(_DWORD *)(v2 + 380);
            *(_DWORD *)buf = 136447234;
            v53 = v5;
            v54 = 1024;
            v55 = 655;
            v56 = 2082;
            v57 = v4;
            v58 = 2048;
            v59 = v2;
            v60 = 1024;
            v61 = v32;
            _os_log_debug_impl(&dword_1B4F6D000, v31, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Passed max input threshold, stopping reading to deliver data (%u bytes)", buf, 0x2Cu);
          }
        }
      }
    }
LABEL_29:
    v17 = *(_QWORD *)(a1 + 48);
    if (!v17)
      goto LABEL_35;
    v18 = *(_QWORD *)(v17 + 24);
    if (!v18 || !*(_QWORD *)(v18 + 64))
      goto LABEL_35;
    *(_BYTE *)(v2 + 388) |= 0x40u;
    (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24) + 64))();
    v19 = *(_BYTE *)(v2 + 388);
    if ((v19 & 0x40) != 0)
      break;
    v3 = 0;
LABEL_37:
    if (v19 < 0)
      goto LABEL_129;
  }
  if (*(_DWORD *)(v2 + 380) <= 0x8000u)
  {
LABEL_35:
    v3 = 0;
LABEL_36:
    v19 = *(_BYTE *)(v2 + 388);
    goto LABEL_37;
  }
  if ((*(_BYTE *)(v2 + 475) & 1) == 0)
  {
    if (datapath_logging_enabled)
    {
      v45 = g_boringssl_log;
      if (g_boringssl_log)
      {
        if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          v46 = *(_DWORD *)(v2 + 380);
          *(_DWORD *)buf = 136447234;
          v53 = v5;
          v54 = 1024;
          v55 = 683;
          v56 = 2082;
          v57 = v4;
          v58 = 2048;
          v59 = v2;
          v60 = 1024;
          v61 = v46;
          v47 = "%{public}s(%d) %{public}s[%p] input_available unacknowledged, data (%u bytes) over readahead threshold, "
                "suspending reads";
          goto LABEL_149;
        }
        goto LABEL_127;
      }
    }
  }
LABEL_128:
  *(_BYTE *)(v2 + 388) = v19 | 0x80;
LABEL_129:
  if ((*(_BYTE *)(v2 + 389) & 1) != 0)
  {
    v43 = *(_QWORD *)(a1 + 48);
    if (v43)
    {
      v44 = *(_QWORD *)(v43 + 24);
      if (v44)
      {
        if (*(_QWORD *)(v44 + 184))
        {
          *(_BYTE *)(v2 + 389) &= ~1u;
          (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24) + 184))();
        }
      }
    }
  }
LABEL_134:
  *(_BYTE *)(v2 + 389) &= ~2u;
}

uint64_t nw_protocol_boringssl_read_bytes(void *a1, uint64_t a2, int a3)
{
  _BYTE *v5;
  char *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  char v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  NSObject *oslog;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  char *v25;
  __int16 v26;
  _BYTE v27[18];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if ((!v5 || (v5[475] & 1) == 0)
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_read_bytes_cold_7();
  }
  v7 = 0xFFFFFFFFLL;
  if (v6
    && a2
    && a3
    && boringssl_session_get_state(*((_QWORD *)v6 + 42)) <= 3
    && (boringssl_session_is_cancelled(*((_QWORD *)v6 + 42)) & 1) == 0)
  {
    if ((v6[390] & 2) != 0)
    {
      if ((v6[475] & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_read_bytes_cold_6();
      }
    }
    else if ((v6[475] & 1) == 0 && g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_read_bytes_cold_5();
    }
    if (nw_frame_array_is_empty()
      && (*(_DWORD *)buf = 0, !nw_protocol_boringssl_read_frames(v6, *((_QWORD *)v6 + 5), buf)))
    {
      if ((v6[390] & 2) != 0)
      {
        if ((v6[475] & 1) == 0
          && datapath_logging_enabled
          && g_boringssl_log
          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          nw_protocol_boringssl_read_bytes_cold_2();
        }
      }
      else if ((v6[475] & 1) == 0
             && g_boringssl_log
             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_read_bytes_cold_1();
      }
      v7 = 0;
    }
    else
    {
      nw_frame_array_first();
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      if (!*((_QWORD *)v6 + 46))
        objc_storeStrong((id *)v6 + 46, v8);
      if (v8)
      {
        do
        {
          if (*((void **)v6 + 46) != v8 && (v6[475] & 1) == 0)
          {
            v12 = g_boringssl_log;
            if (g_boringssl_log)
            {
              if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_FAULT))
              {
                v13 = *((_QWORD *)v6 + 46);
                *(_DWORD *)buf = 136447490;
                v19 = "nw_protocol_boringssl_read_bytes";
                v20 = 1024;
                v21 = 268;
                v22 = 2082;
                v23 = v6 + 391;
                v24 = 2048;
                v25 = v6;
                v26 = 2048;
                *(_QWORD *)v27 = v13;
                *(_WORD *)&v27[8] = 2048;
                *(_QWORD *)&v27[10] = v8;
                _os_log_fault_impl(&dword_1B4F6D000, v12, OS_LOG_TYPE_FAULT, "%{public}s(%d) %{public}s[%p] current input frame (%p) does not match frame being processed (%p)", buf, 0x3Au);
              }
            }
          }
          nw_frame_array_next();
          v9 = (void *)objc_claimAutoreleasedReturnValue();
          v10 = nw_frame_unclaimed_bytes();
          boringssl_context_is_dtls(*((_QWORD *)v6 + 42));
          v6[389] |= 0x40u;
          v11 = nw_frame_claim();
          *((_DWORD *)v6 + 94) = *((_DWORD *)v6 + 94);
          if ((nw_frame_unclaim() & 1) == 0 && (v6[475] & 1) == 0)
          {
            if (datapath_logging_enabled)
            {
              oslog = g_boringssl_log;
              if (g_boringssl_log)
              {
                if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                {
                  v15 = *((_DWORD *)v6 + 94);
                  *(_DWORD *)buf = 136447490;
                  v19 = "nw_protocol_boringssl_read_bytes";
                  v20 = 1024;
                  v21 = 290;
                  v22 = 2082;
                  v23 = v6 + 391;
                  v24 = 2048;
                  v25 = v6;
                  v26 = 1024;
                  *(_DWORD *)v27 = v15;
                  *(_WORD *)&v27[4] = 2048;
                  *(_QWORD *)&v27[6] = v8;
                  _os_log_debug_impl(&dword_1B4F6D000, oslog, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] failed to unclaim %d bytes from %p", buf, 0x36u);
                }
              }
            }
          }
          *((_DWORD *)v6 + 94) = 0;
          objc_storeStrong((id *)v6 + 46, v9);
          nw_frame_array_remove();
          nw_frame_finalize();
          if ((v11 & 1) == 0 && (v6[475] & 1) == 0)
          {
            if (datapath_logging_enabled)
            {
              v14 = g_boringssl_log;
              if (g_boringssl_log)
              {
                if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136447490;
                  v19 = "nw_protocol_boringssl_read_bytes";
                  v20 = 1024;
                  v21 = 299;
                  v22 = 2082;
                  v23 = v6 + 391;
                  v24 = 2048;
                  v25 = v6;
                  v26 = 1024;
                  *(_DWORD *)v27 = 0;
                  *(_WORD *)&v27[4] = 2048;
                  *(_QWORD *)&v27[6] = v10;
                  _os_log_debug_impl(&dword_1B4F6D000, v14, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] failed to claim %d bytes from %p", buf, 0x36u);
                }
              }
            }
          }
          v7 = 0;
          *((_DWORD *)v6 + 94) = 0;
          objc_storeStrong((id *)v6 + 46, v9);

          v8 = v9;
        }
        while (v9);
      }
      else
      {
        v7 = 0;
      }
      if ((v6[390] & 2) != 0)
      {
        if ((v6[475] & 1) == 0
          && datapath_logging_enabled
          && g_boringssl_log
          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          nw_protocol_boringssl_read_bytes_cold_4();
        }
      }
      else if ((v6[475] & 1) == 0
             && g_boringssl_log
             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_read_bytes_cold_3();
      }

    }
  }

  return v7;
}

uint64_t boringssl_session_get_state(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(unsigned int *)(v1 + 300);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_is_cancelled(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return (*(unsigned __int8 *)(v1 + 556) >> 1) & 1;
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_context_is_dtls(uint64_t a1)
{
  uint64_t v1;

  if (a1 && *(_DWORD *)a1 == -1252936367 && (v1 = *(_QWORD *)(a1 + 8)) != 0)
    return (*(unsigned __int8 *)(v1 + 556) >> 5) & 1;
  else
    return 1;
}

uint64_t boringssl_session_read(_QWORD *a1, void *a2, int a3, int a4)
{
  uint64_t v5;
  uint64_t v6;
  SSL *v7;
  id v8;
  void *v9;
  _BYTE *v10;
  char v11;
  id v12;
  _BYTE *v13;
  _BOOL4 v14;
  uint64_t v16;
  uint64_t error;
  uint64_t v18;
  id v19;
  void *v20;
  _BYTE *v21;
  char v22;
  id v23;
  _BYTE *v24;
  char v25;
  NSObject *v26;
  id WeakRetained;
  void *v28;
  _BYTE *v29;
  char v30;
  id v31;
  _BYTE *v32;
  char v33;
  NSObject *v34;
  NSObject *v35;

  if (!a1)
    return 0;
  if (*(_DWORD *)a1 != -1252936367)
    return 0;
  v5 = a1[1];
  if (!v5)
    return 0;
  v6 = 0;
  if (a3)
  {
    v7 = *(SSL **)(v5 + 400);
    if (v7)
    {
      if (a2 || (a4 & 1) != 0)
      {
        if (a4)
          v16 = SSL_peek(v7, a2, a3);
        else
          v16 = SSL_read(v7, a2, a3);
        v6 = v16;
        if ((int)v16 <= 0)
        {
          error = SSL_get_error(*(const SSL **)(v5 + 400), v16);
          v18 = error;
          if ((error - 5) >= 2)
          {
            if ((_DWORD)error == 2)
            {
              ++*(_QWORD *)(v5 + 496);
              WeakRetained = objc_loadWeakRetained((id *)(v5 + 16));
              if (!WeakRetained
                || (v28 = WeakRetained,
                    v29 = objc_loadWeakRetained((id *)(v5 + 16)),
                    v30 = v29[475],
                    v29,
                    v28,
                    (v30 & 1) == 0))
              {
                v31 = objc_loadWeakRetained((id *)(v5 + 16));
                if (v31)
                {
                  v32 = objc_loadWeakRetained((id *)(v5 + 16));
                  v33 = v32[475] & 1;

                }
                else
                {
                  v33 = 0;
                }

                if ((v33 & 1) == 0 && datapath_logging_enabled && g_boringssl_log)
                {
                  v35 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
                    boringssl_session_read_cold_2();

                }
              }
            }
            else
            {
              ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))boringssl_session_handshake_error_print, a1);
            }
          }
          else
          {
            v19 = objc_loadWeakRetained((id *)(v5 + 16));
            if (!v19
              || (v20 = v19,
                  v21 = objc_loadWeakRetained((id *)(v5 + 16)),
                  v22 = v21[475],
                  v21,
                  v20,
                  (v22 & 1) == 0))
            {
              v23 = objc_loadWeakRetained((id *)(v5 + 16));
              if (v23)
              {
                v24 = objc_loadWeakRetained((id *)(v5 + 16));
                v25 = v24[475] & 1;

              }
              else
              {
                v25 = 0;
              }

              if ((v25 & 1) == 0 && datapath_logging_enabled && g_boringssl_log)
              {
                v34 = (id)g_boringssl_log;
                if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
                  boringssl_session_read_cold_1(v5, v18, v34);

              }
            }
          }
        }
      }
      else
      {
        v8 = objc_loadWeakRetained((id *)(v5 + 16));
        if (v8)
        {
          v9 = v8;
          v10 = objc_loadWeakRetained((id *)(v5 + 16));
          v11 = v10[475];

          if ((v11 & 1) != 0)
            return 0xFFFFFFFFLL;
        }
        v12 = objc_loadWeakRetained((id *)(v5 + 16));
        if (v12)
        {
          v13 = objc_loadWeakRetained((id *)(v5 + 16));
          v14 = (v13[475] & 1) == 0;

        }
        else
        {
          v14 = 1;
        }

        v6 = 0xFFFFFFFFLL;
        if (v14 && g_boringssl_log)
        {
          v26 = (id)g_boringssl_log;
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            boringssl_session_read_cold_3(v5, v26);

          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return v6;
}

int SSL_get_error(const SSL *s, int ret_code)
{
  int result;
  unsigned int v5;
  BIO *bbio;
  int retry_reason;
  int v9;

  if (ret_code > 0)
    return 0;
  v5 = ERR_peek_error();
  if (v5)
  {
    if (HIBYTE(v5) == 2)
      return 5;
    else
      return 1;
  }
  result = *((_DWORD *)s->handshake_func + 49);
  if (!ret_code)
  {
    if (result == 6)
      return 6;
    else
      return 5;
  }
  if ((result - 11) >= 0xA && result != 4)
  {
    if (result == 3)
    {
      bbio = s->bbio;
      if (BIO_should_write((uint64_t)bbio))
        return 3;
      if (!BIO_should_read((uint64_t)bbio))
        goto LABEL_26;
    }
    else
    {
      if (result != 2)
        return 5;
      if (!*(_QWORD *)&s->hit)
      {
        bbio = s->wbio;
        if (!BIO_should_read((uint64_t)bbio))
        {
          if (!BIO_should_write((uint64_t)bbio))
          {
LABEL_26:
            if (BIO_should_io_special((uint64_t)bbio))
            {
              retry_reason = BIO_get_retry_reason(bbio);
              if (retry_reason == 3)
                v9 = 8;
              else
                v9 = 5;
              if (retry_reason == 2)
                return 7;
              else
                return v9;
            }
            return 5;
          }
          return 3;
        }
      }
    }
    return 2;
  }
  return result;
}

unint64_t ERR_peek_error(void)
{
  unint64_t result;
  int v1;

  result = (unint64_t)err_get_state();
  if (result)
  {
    v1 = *(_DWORD *)(result + 388);
    if (v1 == *(_DWORD *)(result + 384))
      return 0;
    else
      return *(unsigned int *)(result + 24 * (((_BYTE)v1 + 1) & 0xF) + 16);
  }
  return result;
}

uint64_t BIO_should_read(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) & 1;
}

uint64_t nw_protocol_boringssl_read_frames(void *a1, uint64_t a2, _DWORD *a3)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *log;
  _QWORD v14[2];
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  _QWORD *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!a3)
  {
LABEL_18:
    v7 = 0;
    goto LABEL_19;
  }
  if (boringssl_session_get_state(v5[42]) > 3 || (boringssl_session_is_cancelled(v6[42]) & 1) != 0)
  {
    v7 = 0xFFFFFFFFLL;
    goto LABEL_19;
  }
  if (!a2 || (v8 = *(_QWORD *)(a2 + 24)) == 0 || !*(_QWORD *)(v8 + 80))
  {
    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_read_frames_cold_1();
    }
    goto LABEL_18;
  }
  v14[0] = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = 0xAAAAAAAAAAAAAAAALL;
  nw_frame_array_init();
  v7 = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)(a2 + 24) + 80))(a2, v6 + 1, 1, 0xFFFFFFFFLL, 0xFFFFFFFFLL, v14);
  *a3 = 0;
  nw_frame_array_first();
  v9 = objc_claimAutoreleasedReturnValue();
  if (v9)
  {
    v10 = (void *)v9;
    do
    {
      nw_frame_array_next();
      v11 = objc_claimAutoreleasedReturnValue();
      nw_frame_unclaimed_bytes();
      *a3 = *a3;
      nw_frame_array_remove();
      nw_frame_array_append();
      if (nw_frame_is_wake_packet())
      {
        *((_BYTE *)v6 + 390) |= 0x10u;
        if ((*((_BYTE *)v6 + 475) & 1) == 0)
        {
          if (g_boringssl_log)
          {
            log = g_boringssl_log;
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446978;
              v16 = "nw_protocol_boringssl_read_frames";
              v17 = 1024;
              v18 = 216;
              v19 = 2082;
              v20 = (char *)v6 + 391;
              v21 = 2048;
              v22 = v6;
              _os_log_impl(&dword_1B4F6D000, log, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Frame with wake flag detected", buf, 0x26u);
            }
          }
        }
      }

      v10 = (void *)v11;
    }
    while (v11);
  }
LABEL_19:

  return v7;
}

id boringssl_context_copy_metadata(uint64_t a1)
{
  uint64_t v1;

  if (a1 && *(_DWORD *)a1 == -1252936367 && (v1 = *(_QWORD *)(a1 + 8)) != 0)
    return *(id *)(v1 + 520);
  else
    return 0;
}

int SSL_read(SSL *ssl, void *buf, int num)
{
  unsigned int v4;
  int v5;
  int (__cdecl *handshake_func)(SSL *);
  unint64_t v7;
  int (__cdecl *v8)(SSL *);

  v4 = SSL_peek(ssl, buf, num);
  v5 = v4;
  if ((int)v4 >= 1)
  {
    handshake_func = ssl->handshake_func;
    v7 = *((_QWORD *)handshake_func + 17);
    if (v7 < v4)
      abort();
    *((_QWORD *)handshake_func + 16) += v4;
    *((_QWORD *)handshake_func + 17) = v7 - v4;
    v8 = ssl->handshake_func;
    if (!*((_QWORD *)v8 + 17))
      bssl::SSLBuffer::DiscardConsumed((_WORD *)v8 + 40);
  }
  return v5;
}

_WORD *bssl::SSLBuffer::DiscardConsumed(_WORD *this)
{
  if (!this[6])
  {
    this[4] = this[5];
    this[6] = 0;
    this[7] = this[8];
  }
  return this;
}

#error "1B4F7D8F0: call analysis failed (funcsize=96)"

void boringssl_context_start_handshake_timer(uint64_t a1)
{
  _BYTE *v1;
  id *v2;
  _QWORD *WeakRetained;
  uint64_t v4;
  id v5;
  _QWORD *v6;
  id *v7;
  uint64_t source;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  char v12;
  id v13;
  int64_t v14;
  NSObject *v15;
  id v16;
  void *v17;
  _BYTE *v18;
  char v19;
  id v20;
  _BYTE *v21;
  _BOOL4 v22;
  id *v23;

  if (*(_DWORD *)a1 == -1252936367)
  {
    v1 = *(_BYTE **)(a1 + 8);
    if (v1)
    {
      if ((v1[556] & 0x20) != 0)
      {
        v2 = v1;
        WeakRetained = objc_loadWeakRetained(v2 + 2);
        v4 = WeakRetained[40];

        if (v4)
        {
          v5 = objc_loadWeakRetained(v2 + 2);
          nw_queue_cancel_source();

          v6 = objc_loadWeakRetained(v2 + 2);
          v6[40] = 0;

        }
        v23 = v2;
        v7 = v23;
        source = nw_queue_context_create_source();
        v9 = objc_loadWeakRetained(v7 + 2);
        v9[40] = source;

        v10 = objc_loadWeakRetained(v7 + 2);
        v11 = v10[40];

        if (v11)
        {
          v12 = *((_BYTE *)v7 + 556);
          v13 = objc_loadWeakRetained(v7 + 2);
          if ((v12 & 0x10) != 0)
            v14 = 10000000000;
          else
            v14 = 2000000000;
          dispatch_time(0, v14);
          nw_queue_set_timer_values();

          v15 = objc_loadWeakRetained(v7 + 2);
          nw_queue_activate_source();
        }
        else
        {
          v16 = objc_loadWeakRetained(v7 + 2);
          if (v16)
          {
            v17 = v16;
            v18 = objc_loadWeakRetained(v7 + 2);
            v19 = v18[475];

            if ((v19 & 1) != 0)
              goto LABEL_12;
          }
          v20 = objc_loadWeakRetained(v7 + 2);
          if (v20)
          {
            v21 = objc_loadWeakRetained(v7 + 2);
            v22 = (v21[475] & 1) == 0;

          }
          else
          {
            v22 = 1;
          }

          if (!v22 || !g_boringssl_log)
            goto LABEL_12;
          v15 = (id)g_boringssl_log;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
            boringssl_context_start_handshake_timer_cold_1(v7, v15);
        }

LABEL_12:
      }
    }
  }
}

uint64_t boringssl_session_in_false_start(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
    {
      result = *(_QWORD *)(v1 + 400);
      if (result)
        return SSL_in_false_start(result) != 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SSL_in_false_start(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 280);
  if (v1)
    return (*(_DWORD *)(v1 + 1600) >> 10) & 1;
  else
    return 0;
}

uint64_t boringssl_session_handshake_incomplete(_QWORD *a1, int a2, char a3)
{
  uint64_t v4;
  unsigned int error;
  unsigned int v7;
  int *v8;
  const char *ssl_error_code_description;
  id WeakRetained;
  void *v11;
  _BYTE *v12;
  char v13;
  id v14;
  _BYTE *v15;
  _BOOL4 v16;
  NSObject *v17;
  NSObject *v18;
  _BYTE *v19;
  char v20;
  _BYTE *v21;
  _BOOL4 v22;
  NSObject *v23;
  id v25;
  void *v26;
  id v27;
  id v28;
  void *v29;
  _BYTE *v30;
  char v31;
  id v32;
  _BYTE *v33;
  _BOOL4 v34;
  NSObject *v35;
  id v36;
  void *v37;
  id v38;
  char *v39;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  void *v45;
  __int16 v46;
  id v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  unsigned int v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v4 = a1[1];
  if (!v4)
    return 0xFFFFFFFFLL;
  error = SSL_get_error(*(const SSL **)(v4 + 400), a2);
  v7 = error;
  if (error == 2)
  {
    v8 = &OBJC_IVAR___boringssl_concrete_boringssl_ctx_read_stalls;
  }
  else
  {
    if (error != 3)
      goto LABEL_8;
    v8 = &OBJC_IVAR___boringssl_concrete_boringssl_ctx_write_stalls;
  }
  ++*(_QWORD *)(v4 + *v8);
LABEL_8:
  ssl_error_code_description = boringssl_helper_get_ssl_error_code_description(error);
  if (boringssl_helper_error_is_fatal(v7))
  {
    WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
    if (!WeakRetained
      || (v11 = WeakRetained,
          v12 = objc_loadWeakRetained((id *)(v4 + 16)),
          v13 = v12[475],
          v12,
          v11,
          (v13 & 1) == 0))
    {
      v14 = objc_loadWeakRetained((id *)(v4 + 16));
      if (v14)
      {
        v15 = objc_loadWeakRetained((id *)(v4 + 16));
        v16 = (v15[475] & 1) == 0;

      }
      else
      {
        v16 = 1;
      }

      if (v16)
      {
        if (g_boringssl_log)
        {
          v23 = (id)g_boringssl_log;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            boringssl_session_handshake_incomplete_cold_1(v4, ssl_error_code_description, v23);

        }
      }
    }
    ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))boringssl_session_handshake_error_print, a1);
    return 0xFFFFFFFFLL;
  }
  if (v7 == 15)
  {
    if ((a3 & 1) != 0)
      return 0;
    SSL_reset_early_data_reject(*(_QWORD *)(v4 + 400));
  }
  v17 = objc_loadWeakRetained((id *)(v4 + 16));
  if (!v17
    || (v18 = v17,
        v19 = objc_loadWeakRetained((id *)(v4 + 16)),
        v20 = v19[475],
        v19,
        v18,
        (v20 & 1) == 0))
  {
    v18 = objc_loadWeakRetained((id *)(v4 + 16));
    if (v18)
    {
      v21 = objc_loadWeakRetained((id *)(v4 + 16));
      v22 = (v21[475] & 1) == 0;

    }
    else
    {
      v22 = 1;
    }

    if (v22)
    {
      if (g_boringssl_log)
      {
        v18 = (id)g_boringssl_log;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          v25 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v25)
          {
            v39 = (char *)objc_loadWeakRetained((id *)(v4 + 16));
            v26 = v39 + 391;
          }
          else
          {
            v26 = &unk_1B50022E3;
          }
          v27 = objc_loadWeakRetained((id *)(v4 + 16));
          *(_DWORD *)buf = 136447490;
          v41 = "boringssl_session_handshake_incomplete";
          v42 = 1024;
          v43 = 254;
          v44 = 2082;
          v45 = v26;
          v46 = 2048;
          v47 = v27;
          v48 = 2082;
          v49 = ssl_error_code_description;
          v50 = 1024;
          v51 = v7;
          _os_log_impl(&dword_1B4F6D000, v18, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Handshake incomplete: %{public}s [%d]", buf, 0x36u);

          if (v25)
        }

      }
    }
  }
  boringssl_context_update_encryption_level((uint64_t)a1);
  if (v7 != 15)
    return 0;
  v28 = objc_loadWeakRetained((id *)(v4 + 16));
  if (!v28
    || (v29 = v28,
        v30 = objc_loadWeakRetained((id *)(v4 + 16)),
        v31 = v30[475],
        v30,
        v29,
        (v31 & 1) == 0))
  {
    v32 = objc_loadWeakRetained((id *)(v4 + 16));
    if (v32)
    {
      v33 = objc_loadWeakRetained((id *)(v4 + 16));
      v34 = (v33[475] & 1) == 0;

    }
    else
    {
      v34 = 1;
    }

    if (v34)
    {
      if (g_boringssl_log)
      {
        v35 = (id)g_boringssl_log;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
        {
          v36 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v36)
          {
            v18 = objc_loadWeakRetained((id *)(v4 + 16));
            v37 = (char *)&v18[48].isa + 7;
          }
          else
          {
            v37 = &unk_1B50022E3;
          }
          v38 = objc_loadWeakRetained((id *)(v4 + 16));
          *(_DWORD *)buf = 136446978;
          v41 = "boringssl_session_handshake_incomplete";
          v42 = 1024;
          v43 = 258;
          v44 = 2082;
          v45 = v37;
          v46 = 2048;
          v47 = v38;
          _os_log_impl(&dword_1B4F6D000, v35, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Restarting handshake", buf, 0x26u);

          if (v36)
        }

      }
    }
  }
  return boringssl_session_handshake_continue_inner(a1, 1);
}

uint64_t boringssl_context_update_encryption_level(uint64_t a1)
{
  void *v1;
  id v2;
  uint64_t v3;
  id v5;

  if (!a1)
    return 0;
  if (*(_DWORD *)a1 != -1252936367)
    return 0;
  v1 = *(void **)(a1 + 8);
  if (!v1)
    return 0;
  v5 = v1;
  v2 = v5;
  v3 = nw_protocol_options_access_handle();

  return v3;
}

const char *boringssl_helper_get_ssl_error_code_description(unsigned int a1)
{
  if (a1 > 0x12)
    return "unknown error";
  else
    return off_1E686F530[a1];
}

uint64_t boringssl_helper_error_is_fatal(unsigned int a1)
{
  return (a1 > 0x10) | (0x5FC3u >> a1) & 1;
}

void nw_protocol_boringssl_read_bytes_cold_3()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136447234;
  OUTLINED_FUNCTION_9_0();
  OUTLINED_FUNCTION_6_0();
  OUTLINED_FUNCTION_10_0(&dword_1B4F6D000, v0, v1, "%{public}s(%d) %{public}s[%p] total bytes read: %u", v2);
  OUTLINED_FUNCTION_12_0();
}

void nw_protocol_boringssl_read_bytes_cold_5()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136447234;
  OUTLINED_FUNCTION_9_0();
  OUTLINED_FUNCTION_6_0();
  OUTLINED_FUNCTION_10_0(&dword_1B4F6D000, v0, v1, "%{public}s(%d) %{public}s[%p] read request: %u byte(s)", v2);
  OUTLINED_FUNCTION_12_0();
}

void OUTLINED_FUNCTION_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

id OUTLINED_FUNCTION_9_1(id *location)
{
  return objc_loadWeakRetained(location);
}

id OUTLINED_FUNCTION_5(uint64_t a1)
{
  int *v1;

  return objc_loadWeakRetained((id *)(a1 + *v1));
}

void OUTLINED_FUNCTION_10_0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x2Cu);
}

void OUTLINED_FUNCTION_6(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x26u);
}

void OUTLINED_FUNCTION_4_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0x26u);
}

void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x18u);
}

void nw_protocol_boringssl_read_bytes_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2();
  OUTLINED_FUNCTION_4_0(&dword_1B4F6D000, v0, v1, "%{public}s(%d) %{public}s[%p] no input frames available", v2, v3, v4, v5, 2u);
  OUTLINED_FUNCTION_8_0();
}

void nw_protocol_boringssl_input_available_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_0_2();
  OUTLINED_FUNCTION_4_0(&dword_1B4F6D000, v0, v1, "%{public}s(%d) %{public}s[%p] triggering input available", v2, v3, v4, v5, 2u);
  OUTLINED_FUNCTION_8_0();
}

void OUTLINED_FUNCTION_2_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Cu);
}

id OUTLINED_FUNCTION_1_1()
{
  uint64_t v0;
  int *v1;

  return objc_loadWeakRetained((id *)(v0 + *v1));
}

void OUTLINED_FUNCTION_5_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 0x26u);
}

id OUTLINED_FUNCTION_5_3()
{
  id *v0;

  return objc_loadWeakRetained(v0);
}

void OUTLINED_FUNCTION_0_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x18u);
}

void OUTLINED_FUNCTION_0_5(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 282, a4);
}

void OUTLINED_FUNCTION_0_7(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void nw_protocol_boringssl_input_finished(uint64_t a1)
{
  uint64_t v2;
  unsigned int state;
  const char *session_state_description;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(void);
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  unsigned int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return;
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2)
    return;
  if ((*(_BYTE *)(v2 + 475) & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_input_finished_cold_2();
  }
  if (!*(_QWORD *)(a1 + 48))
  {
    if ((*(_BYTE *)(v2 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_input_finished_cold_1();
    }
    return;
  }
  state = boringssl_session_get_state(*(_QWORD *)(v2 + 336));
  session_state_description = boringssl_helper_get_session_state_description(state);
  if ((*(_BYTE *)(v2 + 475) & 1) == 0)
  {
    if (g_boringssl_log)
    {
      v10 = g_boringssl_log;
      v11 = session_state_description;
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447490;
        v13 = "nw_protocol_boringssl_input_finished";
        v14 = 1024;
        v15 = 1996;
        v16 = 2082;
        v17 = v2 + 391;
        v18 = 2048;
        v19 = v2;
        v20 = 2080;
        v21 = v11;
        v22 = 1024;
        v23 = state;
        _os_log_debug_impl(&dword_1B4F6D000, v10, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] session state: %s [%d]", buf, 0x36u);
      }
    }
  }
  if (state < 2)
  {
    nw_protocol_boringssl_internal_error((void *)v2, -9816);
    v8 = *(_QWORD *)(a1 + 48);
    if (!v8)
      return;
    v9 = *(_QWORD *)(v8 + 24);
    if (!v9)
      return;
    v7 = *(void (**)(void))(v9 + 48);
    if (!v7)
      return;
LABEL_20:
    v7();
    return;
  }
  if ((*(_BYTE *)(v2 + 389) & 2) != 0)
  {
    *(_BYTE *)(v2 + 389) |= 1u;
    return;
  }
  *(_BYTE *)(v2 + 388) &= ~0x80u;
  nw_boringssl_read(a1);
  v5 = *(_QWORD *)(a1 + 48);
  if (v5)
  {
    v6 = *(_QWORD *)(v5 + 24);
    if (v6)
    {
      v7 = *(void (**)(void))(v6 + 184);
      if (v7)
        goto LABEL_20;
    }
  }
}

const char *boringssl_helper_get_session_state_description(int a1)
{
  if ((a1 - 1) > 4)
    return "idle";
  else
    return off_1E686F5C8[a1 - 1];
}

void boringssl_session_handshake_negotiate_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, int a10, int a11, int a12, __int128 a13, int a14, __int16 a15, __int16 a16, int a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  char *v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  NSObject *v33;
  int v34;
  int v35;
  uint64_t v36;
  id v37;
  void *v38;
  id v39;
  uint64_t v40;
  __int16 v41;

  OUTLINED_FUNCTION_17();
  a28 = v30;
  a29 = v31;
  v33 = v32;
  v35 = v34;
  a19 = *MEMORY[0x1E0C80C00];
  v37 = OUTLINED_FUNCTION_8(v36, 16);
  if (v37)
  {
    v29 = (char *)OUTLINED_FUNCTION_12();
    v38 = v29 + 391;
  }
  else
  {
    v38 = &unk_1B50022E3;
  }
  v39 = OUTLINED_FUNCTION_12();
  a9 = 136447234;
  OUTLINED_FUNCTION_1_0();
  *(int *)((char *)&a12 + 2) = 410;
  WORD1(a13) = 2082;
  *(_QWORD *)((char *)&a13 + 4) = v38;
  WORD6(a13) = 2048;
  *(_QWORD *)((char *)&a13 + 14) = v40;
  a16 = v41;
  a17 = v35;
  _os_log_debug_impl(&dword_1B4F6D000, v33, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] state: %d, ignore handshake negotiate", (uint8_t *)&a9, 0x2Cu);

  if (v37)
  OUTLINED_FUNCTION_10();
}

#error "1B4F7EA88: call analysis failed (funcsize=47)"

void boringssl_helper_create_sec_trust_with_certificates_cold_6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9, __int128 a10, int a11, __int16 a12, __int16 a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  NSObject *v26;
  int v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  id v33;
  void *v34;
  id v35;
  uint64_t v36;

  OUTLINED_FUNCTION_17();
  a25 = v30;
  a26 = v31;
  OUTLINED_FUNCTION_13_1();
  a16 = *MEMORY[0x1E0C80C00];
  v33 = OUTLINED_FUNCTION_8(v32, 16);
  if (v33)
  {
    v28 = (char *)OUTLINED_FUNCTION_12();
    v34 = v28 + 391;
  }
  else
  {
    v34 = &unk_1B50022E3;
  }
  v35 = OUTLINED_FUNCTION_12();
  v36 = *(_QWORD *)(v29 + 272);
  LODWORD(a9) = 136447490;
  *(_QWORD *)((char *)&a9 + 4) = "boringssl_helper_create_sec_trust_with_certificates";
  WORD6(a9) = 1024;
  *(_DWORD *)((char *)&a9 + 14) = 595;
  WORD1(a10) = 2082;
  *(_QWORD *)((char *)&a10 + 4) = v34;
  WORD6(a10) = 2048;
  *(_QWORD *)((char *)&a10 + 14) = v35;
  a13 = 2048;
  a14 = v36;
  LOWORD(a15) = 1024;
  *(_DWORD *)((char *)&a15 + 2) = v27;
  _os_log_debug_impl(&dword_1B4F6D000, v26, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] SecTrustSetURLRequestAttribution(%lu) result: %d", (uint8_t *)&a9, 0x36u);

  if (v33)
  OUTLINED_FUNCTION_10();
}

void OUTLINED_FUNCTION_7(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x26u);
}

void OUTLINED_FUNCTION_17_0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x30u);
}

id OUTLINED_FUNCTION_12()
{
  uint64_t v0;
  int *v1;

  return objc_loadWeakRetained((id *)(v0 + *v1));
}

void OUTLINED_FUNCTION_12_1(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x2Cu);
}

id OUTLINED_FUNCTION_12_2()
{
  id *v0;

  return objc_loadWeakRetained(v0);
}

#error "1B4F7ED18: call analysis failed (funcsize=47)"

id OUTLINED_FUNCTION_8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return objc_loadWeakRetained((id *)(a1 + a2));
}

id OUTLINED_FUNCTION_15_1(id *location)
{
  return objc_loadWeakRetained(location);
}

uint64_t nw_protocol_boringssl_copy_info(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(void);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(void);
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(void);
  void *v13;
  void *v14;
  int v16;
  _BOOL4 v17;
  _BOOL4 v18;
  uint64_t v19;

  if (!a1)
    return 0;
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2)
    return 0;
  if ((*(_BYTE *)(v2 + 475) & 1) == 0)
  {
    if (datapath_logging_enabled)
    {
      if (g_boringssl_log)
      {
        v19 = a1;
        v16 = a2;
        v17 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
        a2 = v16;
        v18 = v17;
        a1 = v19;
        if (v18)
        {
          nw_protocol_boringssl_copy_info_cold_1();
          a1 = v19;
          a2 = v16;
        }
      }
    }
  }
  if (a2 == 254)
  {
    v7 = *(_QWORD *)(a1 + 32);
    if (v7 && (v8 = *(_QWORD *)(v7 + 24)) != 0 && (v9 = *(uint64_t (**)(void))(v8 + 224)) != 0)
      v6 = v9();
    else
      v6 = 0;
    boringssl_session_get_handshake_time_ms(*(_QWORD *)(v2 + 336));
    boringssl_session_get_handshake_rtt_ms(*(_QWORD *)(v2 + 336));
    v14 = (void *)MEMORY[0x1B5E453D8]();
    v13 = (void *)nw_protocol_establishment_report_create();

    if (!v13)
      goto LABEL_27;
LABEL_24:
    if (!v6)
      v6 = nw_array_create();
    nw_array_append();
LABEL_27:

    return v6;
  }
  if (a2 == 255)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3 && (v4 = *(_QWORD *)(v3 + 24)) != 0 && (v5 = *(uint64_t (**)(void))(v4 + 224)) != 0)
      v6 = v5();
    else
      v6 = 0;
    v13 = boringssl_context_copy_metadata(*(_QWORD *)(v2 + 336));
    if (!v13)
      goto LABEL_27;
    goto LABEL_24;
  }
  v10 = *(_QWORD *)(a1 + 32);
  if (v10 && (v11 = *(_QWORD *)(v10 + 24)) != 0 && (v12 = *(uint64_t (**)(void))(v11 + 224)) != 0)
    return v12();
  else
    return 0;
}

xpc_object_t boringssl_metrics_create_connection_event(SSL *a1)
{
  SSL_METHOD *method;
  xpc_object_t v3;
  char *v4;
  unint64_t v5;
  char *negotiated_group;
  uint64_t negotiated_protocol;
  signed int v9;
  uint64_t v10;
  int v11;
  const char *v12;
  unsigned int negotiated_ciphersuite;
  unsigned int negotiated_protocol_version;
  const char *v15;
  uint64_t handshake_time_ms;
  const char *v17;
  unsigned int peer_signature_algorithm;
  void *v19;
  const char *v20;
  int has_internal_content;
  const SSL *server_name;
  const char *v23;
  void *v24;
  const char *v25;
  const char *v26;
  BOOL is_unknown;
  const char *v28;
  unsigned __int8 v29;
  const char *v30;
  unsigned __int8 v31;
  const char *v32;
  BOOL v33;
  const char *v34;
  char ocsp_response_received;
  const char *v36;
  char sct_received;
  const char *v38;
  const ssl_st *v39;
  unsigned int ems_used;
  id v41;
  uint64_t v42;
  char string[16];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  if (a1->version != -1252936367)
    return 0;
  method = a1->method;
  if (!method)
    return 0;
  v3 = xpc_dictionary_create(0, 0, 0);
  if (v3)
  {
    v4 = (char *)TLS_METRIC_DEFAULT_EMPTY_STRING;
    if (boringssl_session_get_peer_public_key((uint64_t)a1))
    {
      v5 = SecKeyGetAlgorithmId() - 1;
      if (v5 <= 2)
        v4 = off_1E686F6C8[v5];
    }
    negotiated_group = boringssl_session_get_negotiated_group((uint64_t)a1);
    v42 = 0;
    negotiated_protocol = boringssl_session_get_negotiated_protocol((uint64_t)a1, &v42);
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    *(_OWORD *)string = 0u;
    v44 = 0u;
    if (!negotiated_protocol)
      strlen((const char *)TLS_METRIC_DEFAULT_EMPTY_STRING);
    __memcpy_chk();
    v9 = boringssl_session_ticket_lifetime_hint(a1);
    v10 = 0;
    while (1)
    {
      v11 = *(_DWORD *)&lifetime_buckets[v10];
      if (v11 <= v9 && *(_DWORD *)&lifetime_buckets[v10 + 4] > v9)
        break;
      v10 += 4;
      if (v10 == 20)
      {
        v11 = 108000;
        break;
      }
    }
    boringssl_metrics_log_configuration_data((uint64_t)a1, v3);
    boringssl_metrics_log_connection_data((uint64_t)a1, v3);
    v12 = (const char *)TLS_METRIC_CIPHERSUITE;
    negotiated_ciphersuite = boringssl_session_get_negotiated_ciphersuite((uint64_t)a1);
    xpc_dictionary_set_uint64(v3, v12, negotiated_ciphersuite);
    negotiated_protocol_version = boringssl_session_get_negotiated_protocol_version(a1);
    xpc_dictionary_set_uint64(v3, (const char *)TLS_METRIC_PROTOCOL_VERSION, negotiated_protocol_version);
    xpc_dictionary_set_uint64(v3, (const char *)TLS_METRIC_TICKET_LIFETIME, v11);
    v15 = (const char *)TLS_METRIC_HANDSHAKE_TIME;
    handshake_time_ms = boringssl_session_get_handshake_time_ms((uint64_t)a1);
    xpc_dictionary_set_uint64(v3, v15, handshake_time_ms);
    v17 = (const char *)TLS_METRIC_SIGNATURE_ALGORITHM;
    peer_signature_algorithm = boringssl_session_get_peer_signature_algorithm((uint64_t)a1);
    xpc_dictionary_set_uint64(v3, v17, peer_signature_algorithm);
    if (negotiated_group)
    {
      v19 = v3;
      v20 = negotiated_group;
    }
    else
    {
      v20 = (const char *)TLS_METRIC_DEFAULT_EMPTY_STRING;
      v19 = v3;
    }
    xpc_dictionary_set_string(v19, (const char *)TLS_METRIC_GROUP_NAME, v20);
    has_internal_content = os_variant_has_internal_content();
    if (negotiated_protocol_version - 769 <= 1 && has_internal_content)
    {
      server_name = boringssl_session_get_server_name(a1);
      if (server_name)
        v23 = (const char *)server_name;
      else
        v23 = (const char *)TLS_METRIC_DEFAULT_EMPTY_STRING;
      xpc_dictionary_set_string(v3, (const char *)TLS_METRIC_SERVER_NAME, v23);
    }
    if (v4)
    {
      v24 = v3;
      v25 = v4;
    }
    else
    {
      v25 = (const char *)TLS_METRIC_DEFAULT_EMPTY_STRING;
      v24 = v3;
    }
    xpc_dictionary_set_string(v24, (const char *)TLS_METRIC_PEER_PUBLIC_KEY_TYPE, v25);
    xpc_dictionary_set_string(v3, (const char *)TLS_METRIC_NEGOTIATED_PROTOCOL, string);
    v26 = (const char *)TLS_METRIC_UNKNOWN_NEGOTIATED_PROTOCOL;
    is_unknown = boringssl_context_negotiated_protocol_is_unknown((uint64_t)a1, string);
    xpc_dictionary_set_BOOL(v3, v26, is_unknown);
    xpc_dictionary_set_BOOL(v3, (const char *)TLS_METRIC_FALSE_START_USED, BYTE5(method[2].ssl_renegotiate_check) & 1);
    v28 = (const char *)TLS_METRIC_TICKET_RECEIVED;
    v29 = boringssl_session_has_session_ticket(a1, 0);
    xpc_dictionary_set_BOOL(v3, v28, v29);
    v30 = (const char *)TLS_METRIC_SESSION_RENEWED;
    v31 = boringssl_session_was_renewed(a1, 0);
    xpc_dictionary_set_BOOL(v3, v30, v31);
    v32 = (const char *)TLS_METRIC_ALPN_USED;
    v33 = boringssl_session_get_negotiated_protocol((uint64_t)a1, 0) != 0;
    xpc_dictionary_set_BOOL(v3, v32, v33);
    v34 = (const char *)TLS_METRIC_OCSP_RECEIVED;
    ocsp_response_received = boringssl_session_get_ocsp_response_received((uint64_t)a1);
    xpc_dictionary_set_BOOL(v3, v34, ocsp_response_received);
    v36 = (const char *)TLS_METRIC_SCT_RECEIVED;
    sct_received = boringssl_session_get_sct_received((uint64_t)a1);
    xpc_dictionary_set_BOOL(v3, v36, sct_received);
    xpc_dictionary_set_BOOL(v3, (const char *)TLS_METRIC_FALLBACK_ATTEMPTED, (BYTE4(method[2].ssl_renegotiate_check) & 0x40) != 0);
    xpc_dictionary_set_BOOL(v3, (const char *)TLS_METRIC_HANDSHAKE_CANCELLED, (BYTE4(method[2].ssl_renegotiate_check) & 2) != 0);
    xpc_dictionary_set_BOOL(v3, (const char *)TLS_METRIC_CERTIFICATE_REQUESTED, (BYTE6(method[2].ssl_renegotiate_check) & 0x10) != 0);
    xpc_dictionary_set_BOOL(v3, (const char *)TLS_METRIC_CERTIFICATE_COMPRESSION_ENABLED, (HIBYTE(method[2].ssl_renegotiate_check) & 0x20) != 0);
    xpc_dictionary_set_BOOL(v3, (const char *)TLS_METRIC_CERTIFICATE_COMPRESSION_USED, (HIBYTE(method[2].ssl_renegotiate_check) & 0x40) != 0);
    xpc_dictionary_set_uint64(v3, (const char *)TLS_METRIC_CERTIFICATE_COMPRESSION_ALGORITHM, LOWORD(method[1].ssl_read_bytes));
    v38 = (const char *)TLS_METRIC_EXTENDED_MASTER_SECRET_NEGOTIATED;
    ems_used = boringssl_session_get_ems_used((bssl *)a1, v39);
    xpc_dictionary_set_uint64(v3, v38, ems_used);
    xpc_dictionary_set_uuid(v3, (const char *)TLS_METRIC_CONNECTION_ID, (const unsigned __int8 *)&method[1].ssl_clear + 4);
    v41 = v3;
  }
  else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
  {
    boringssl_metrics_create_connection_event_cold_1();
  }

  return v3;
}

BOOL __boringssl_session_update_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  dispatch_data_t v17;
  uint64_t v18;
  const __CFArray *v19;
  const __CFArray *v20;
  uint64_t v21;
  void *v22;
  CFIndex v23;
  __SecCertificate *ValueAtIndex;
  sec_certificate_t v25;
  uint64_t v26;
  uint64_t v27;
  const __CFData *v28;
  const __CFData *v29;
  const UInt8 *BytePtr;
  size_t Length;
  dispatch_data_t v32;
  void *v33;
  uint64_t peer_signature_algorithms;
  unint64_t v35;
  xpc_object_t v36;
  void *v37;
  uint64_t v38;
  unsigned int v39;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  dispatch_data_t v45;
  uint64_t v46;
  __SecTrust *v47;
  sec_trust_t v48;
  void *v49;
  id *v50;
  id *v51;
  void *v52;
  id *v53;
  id *v54;
  void *v55;
  char *negotiated_group;
  const char *server_name;
  uint64_t v58;
  __int16 v59;
  uint64_t v60;
  __int16 v61;
  __int16 v62;
  __int16 v63;
  __int16 v64;
  __int16 v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  BOOL v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  const char *v76;
  uint64_t v77;
  uint64_t v79;
  uint64_t v80;
  size_t size;
  void *buffer;
  char __s1[16];
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return a2 != 0;
  v4 = *(void **)(a2 + 88);
  *(_QWORD *)(a2 + 88) = 0;

  v5 = *(void **)(a2 + 104);
  *(_QWORD *)(a2 + 104) = 0;

  v6 = *(void **)(a2 + 136);
  *(_QWORD *)(a2 + 136) = 0;

  v7 = *(void **)(a2 + 144);
  *(_QWORD *)(a2 + 144) = 0;

  v8 = *(void **)(a2 + 152);
  *(_QWORD *)(a2 + 152) = 0;

  v9 = *(void **)(a2 + 168);
  *(_QWORD *)(a2 + 168) = 0;

  v10 = *(void **)(a2 + 160);
  *(_QWORD *)(a2 + 160) = 0;

  v11 = *(void **)(a2 + 80);
  *(_QWORD *)(a2 + 80) = 0;

  v12 = *(void **)(a2 + 40);
  if (v12)
  {
    free(v12);
    *(_QWORD *)(a2 + 40) = 0;
  }
  v13 = *(void **)(a2 + 176);
  if (v13)
  {
    free(v13);
    *(_QWORD *)(a2 + 176) = 0;
  }
  v14 = *(void **)(a2 + 48);
  if (v14)
  {
    free(v14);
    *(_QWORD *)(a2 + 48) = 0;
  }
  *(_WORD *)(a2 + 32) = (unsigned __int16)boringssl_session_get_negotiated_protocol_version(*(const SSL **)(a1 + 40));
  *(_WORD *)(a2 + 34) = boringssl_session_get_negotiated_ciphersuite(*(_QWORD *)(a1 + 40));
  v89 = 0u;
  v90 = 0u;
  v87 = 0u;
  v88 = 0u;
  v85 = 0u;
  v86 = 0u;
  *(_OWORD *)__s1 = 0u;
  v84 = 0u;
  v80 = 0;
  if (boringssl_session_get_negotiated_protocol(*(_QWORD *)(a1 + 40), &v80))
  {
    __memcpy_chk();
    *(_QWORD *)(a2 + 40) = strdup(__s1);
  }
  v15 = sec_array_create();
  v16 = *(void **)(a2 + 136);
  *(_QWORD *)(a2 + 136) = v15;

  v17 = boringssl_context_copy_ocsp_response(*(_QWORD *)(a1 + 32));
  sec_array_append();
  v18 = *(_QWORD *)(a1 + 32);
  if (!*(_QWORD *)(v18 + 368))
  {
    v19 = *(_QWORD *)(v18 + 352)
        ? (const __CFArray *)CFRetain(*(CFTypeRef *)(v18 + 352))
        : boringssl_helper_copy_certificates_from_session((void *)v18, *(const SSL **)(v18 + 400));
    v20 = v19;
    if (v19)
    {
      v21 = sec_array_create();
      v22 = *(void **)(a2 + 88);
      *(_QWORD *)(a2 + 88) = v21;

      if (CFArrayGetCount(v20) >= 1)
      {
        v23 = 0;
        do
        {
          ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v20, v23);
          if (ValueAtIndex)
          {
            v25 = sec_certificate_create(ValueAtIndex);
            if (v25)
              sec_array_append();

          }
          ++v23;
        }
        while (v23 < CFArrayGetCount(v20));
      }
      CFRelease(v20);
    }
  }
  v26 = *(_QWORD *)(a1 + 40);
  if (v26)
  {
    if (*(_DWORD *)v26 == -1252936367)
    {
      v27 = *(_QWORD *)(v26 + 8);
      if (v27)
      {
        if (*(_QWORD *)(v27 + 344))
        {
          v28 = (const __CFData *)SecKeyCopySubjectPublicKeyInfo();
          if (v28)
          {
            v29 = v28;
            BytePtr = CFDataGetBytePtr(v28);
            Length = CFDataGetLength(v29);
            v32 = dispatch_data_create(BytePtr, Length, 0, 0);
            v33 = *(void **)(a2 + 104);
            *(_QWORD *)(a2 + 104) = v32;

            CFRelease(v29);
          }
        }
      }
    }
  }
  v79 = 0;
  peer_signature_algorithms = boringssl_session_get_peer_signature_algorithms(*(_QWORD *)(a1 + 40), &v79);
  if (peer_signature_algorithms && v79)
  {
    v35 = peer_signature_algorithms;
    v36 = xpc_array_create(0, 0);
    v37 = *(void **)(a2 + 112);
    *(_QWORD *)(a2 + 112) = v36;

    v38 = 0;
    v39 = 1;
    do
    {
      xpc_array_set_uint64(*(xpc_object_t *)(a2 + 112), 0xFFFFFFFFFFFFFFFFLL, *(unsigned __int16 *)(v79 + 2 * v38));
      v38 = v39;
    }
    while (v35 > v39++);
  }
  boringssl_context_copy_server_requested_CAs(*(_QWORD *)(a1 + 40));
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  if (v41)
    objc_storeStrong((id *)(a2 + 144), v41);
  v42 = *(_QWORD *)(a1 + 40);
  if (v42
    && *(_DWORD *)v42 == -1252936367
    && (v43 = *(_QWORD *)(v42 + 8)) != 0
    && (v44 = *(_QWORD *)(v43 + 400)) != 0
    && (size = 0, buffer = 0, SSL_get_peer_quic_transport_params(v44, &buffer, &size), buffer)
    && size)
  {
    v45 = dispatch_data_create(buffer, size, 0, 0);
    if (v45)
      objc_storeStrong((id *)(a2 + 152), v45);
  }
  else
  {
    v45 = 0;
  }
  v46 = *(_QWORD *)(a1 + 32);
  v47 = *(__SecTrust **)(v46 + 360);
  if (v47)
  {
    v48 = sec_trust_create(v47);
    v49 = *(void **)(a2 + 168);
    *(_QWORD *)(a2 + 168) = v48;

    v46 = *(_QWORD *)(a1 + 32);
  }
  v50 = *(id **)(v46 + 104);
  if (v50)
  {
    v51 = boringssl_identity_copy_sec_identity(v50);
    v52 = *(void **)(a2 + 160);
    *(_QWORD *)(a2 + 160) = v51;

    v53 = *(id **)(*(_QWORD *)(a1 + 32) + 104);
    if (v53)
    {
      v54 = boringssl_identity_copy_certificate_chain(v53);
      v55 = *(void **)(a2 + 80);
      *(_QWORD *)(a2 + 80) = v54;

    }
  }
  negotiated_group = boringssl_session_get_negotiated_group(*(_QWORD *)(a1 + 40));
  if (negotiated_group)
    *(_QWORD *)(a2 + 176) = strdup(negotiated_group);
  server_name = (const char *)boringssl_session_get_server_name(*(const SSL **)(a1 + 40));
  if (server_name)
    *(_QWORD *)(a2 + 48) = strdup(server_name);
  v58 = *(_QWORD *)(a1 + 40);
  if (v58)
  {
    if (*(_DWORD *)v58 == -1252936367)
    {
      v58 = *(_QWORD *)(v58 + 8);
      if (v58)
        LOWORD(v58) = 16 * (*(_BYTE *)(v58 + 557) & 1);
    }
    else
    {
      LOWORD(v58) = 0;
    }
  }
  v59 = *(_WORD *)(a2 + 328) & 0xFFEF | v58;
  *(_WORD *)(a2 + 328) = v59;
  v60 = *(_QWORD *)(a1 + 40);
  if (v60)
  {
    if (*(_DWORD *)v60 == -1252936367)
    {
      v60 = *(_QWORD *)(v60 + 8);
      if (v60)
        LODWORD(v60) = (*(unsigned __int8 *)(v60 + 558) >> 2) & 0x20;
    }
    else
    {
      LOWORD(v60) = 0;
    }
  }
  *(_WORD *)(a2 + 328) = v60 | v59 & 0xFFDF;
  if (boringssl_session_has_session_ticket(*(const SSL **)(a1 + 40), *(_QWORD *)(a1 + 48)))
    v61 = 64;
  else
    v61 = 0;
  *(_WORD *)(a2 + 328) = *(_WORD *)(a2 + 328) & 0xFFBF | v61;
  if (boringssl_session_early_data_accepted(*(_QWORD *)(a1 + 40)))
    v62 = 8;
  else
    v62 = 0;
  *(_WORD *)(a2 + 328) = *(_WORD *)(a2 + 328) & 0xFFF7 | v62;
  if (boringssl_session_was_resumed(*(_QWORD *)(a1 + 40)))
    v63 = 128;
  else
    v63 = 0;
  *(_WORD *)(a2 + 328) = *(_WORD *)(a2 + 328) & 0xFF7F | v63;
  if (boringssl_session_was_renewed(*(const SSL **)(a1 + 40), *(_QWORD *)(a1 + 48)))
    v64 = 256;
  else
    v64 = 0;
  v65 = *(_WORD *)(a2 + 328) & 0xFEFF | v64;
  *(_WORD *)(a2 + 328) = v65;
  v66 = *(_QWORD *)(a1 + 40);
  if (v66)
  {
    if (*(_DWORD *)v66 == -1252936367)
    {
      v66 = *(_QWORD *)(v66 + 8);
      if (v66)
        LOWORD(v66) = (*(_BYTE *)(v66 + 559) & 0x40) << 7;
    }
    else
    {
      LOWORD(v66) = 0;
    }
  }
  *(_WORD *)(a2 + 328) = v66 | v65 & 0xDFFF;
  v67 = *(_QWORD *)(a1 + 40);
  if (v67)
  {
    if (*(_DWORD *)v67 == -1252936367)
    {
      v68 = *(_QWORD *)(v67 + 8);
      if (v68)
      {
        *(_WORD *)(a2 + 256) = *(_WORD *)(v68 + 336);
        v69 = *(_QWORD *)(v68 + 464);
        v70 = *(_QWORD *)(v68 + 456);
        v71 = v69 >= v70;
        v72 = v69 - v70;
        if (!v71)
          v72 = -1;
        *(_QWORD *)(a2 + 248) = v72;
        v68 = *(_QWORD *)(v68 + 432) - *(_QWORD *)(v68 + 424);
      }
      else
      {
        *(_WORD *)(a2 + 256) = 0;
        *(_QWORD *)(a2 + 248) = 0;
      }
      *(_QWORD *)(a2 + 264) = v68;
      v73 = *(_QWORD *)(v67 + 8);
      if (v73)
      {
        *(_QWORD *)(a2 + 272) = *(_QWORD *)(v73 + 472) + *(_QWORD *)(v73 + 480);
        v73 = *(_QWORD *)(v73 + 472);
      }
      else
      {
        *(_QWORD *)(a2 + 272) = 0;
      }
      *(_QWORD *)(a2 + 280) = v73;
      v74 = *(_QWORD *)(v67 + 8);
      if (v74)
      {
        *(_QWORD *)(a2 + 288) = *(_QWORD *)(v74 + 480);
        v75 = *(_QWORD *)(v74 + 496);
      }
      else
      {
        v75 = 0;
        *(_QWORD *)(a2 + 288) = 0;
      }
      *(_QWORD *)(a2 + 296) = v75;
      v67 = *(_QWORD *)(v67 + 8);
      if (v67)
      {
        *(_QWORD *)(a2 + 304) = *(_QWORD *)(v67 + 488);
        v67 = *(_QWORD *)(v67 + 504);
      }
      else
      {
        *(_QWORD *)(a2 + 304) = 0;
      }
      goto LABEL_98;
    }
    v67 = 0;
  }
  *(_WORD *)(a2 + 256) = 0;
  *(_QWORD *)(a2 + 248) = 0;
  *(_OWORD *)(a2 + 264) = 0u;
  *(_OWORD *)(a2 + 280) = 0u;
  *(_OWORD *)(a2 + 296) = 0u;
LABEL_98:
  *(_QWORD *)(a2 + 312) = v67;
  uuid_copy((unsigned __int8 *)(a2 + 64), (const unsigned __int8 *)(*(_QWORD *)(a1 + 32) + 252));
  v76 = *(const char **)(*(_QWORD *)(a1 + 32) + 96);
  if (v76)
  {
    if (*(_QWORD *)(a2 + 56))
    {
      free(*(void **)(a2 + 56));
      *(_QWORD *)(a2 + 56) = 0;
      v76 = *(const char **)(*(_QWORD *)(a1 + 32) + 96);
    }
    *(_QWORD *)(a2 + 56) = strdup(v76);
  }
  *(_QWORD *)a2 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 8) = boringssl_session_export_secret_data;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 24) = boringssl_session_copy_serialized_session;
  v77 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 336) = boringssl_session_copy_authenticator;
  *(_QWORD *)(a2 + 344) = boringssl_session_copy_authenticator_trust;
  *(_QWORD *)(a2 + 352) = v77;
  if (boringssl_session_is_eap_configured(*(_QWORD *)(a1 + 40)))
    boringssl_session_update_eap_metadata(*(_QWORD *)(a1 + 40));

  return a2 != 0;
}

const SSL *boringssl_session_get_negotiated_protocol_version(const SSL *result)
{
  SSL_METHOD *method;

  if (result)
  {
    if (result->version == -1252936367 && (method = result->method) != 0)
    {
      result = (const SSL *)method[1].num_ciphers;
      if (result)
        LOWORD(result) = SSL_version(result);
    }
    else
    {
      LOWORD(result) = 0;
    }
  }
  return (const SSL *)(unsigned __int16)result;
}

uint64_t boringssl_session_get_negotiated_ciphersuite(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0 && (v2 = *(_QWORD *)(v1 + 400)) != 0)
    {
      result = (uint64_t)SSL_get_current_cipher(*(const SSL **)(v1 + 400));
      if (result || (result = SSL_get_pending_cipher(v2)) != 0)
        LOWORD(result) = SSL_CIPHER_get_id(result);
    }
    else
    {
      LOWORD(result) = 0;
    }
  }
  return (unsigned __int16)result;
}

uint64_t SSL_get0_ocsp_response(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v7;

  result = (uint64_t)SSL_get_session((const SSL *)a1);
  if ((*(_BYTE *)(a1 + 180) & 1) == 0 && (v7 = result) != 0 && (result = *(_QWORD *)(result + 264)) != 0)
  {
    *a2 = CRYPTO_BUFFER_data(result);
    result = CRYPTO_BUFFER_len(*(_QWORD *)(v7 + 264));
    *a3 = result;
  }
  else
  {
    *a3 = 0;
    *a2 = 0;
  }
  return result;
}

SSL_CIPHER *__cdecl SSL_get_current_cipher(const SSL *s)
{
  SSL_CIPHER *result;

  result = (SSL_CIPHER *)SSL_get_session(s);
  if (result)
    return (SSL_CIPHER *)result[2].mask_strength;
  return result;
}

SSL_SESSION *__cdecl SSL_get_session(const SSL *ssl)
{
  int (__cdecl *handshake_func)(SSL *);
  SSL_SESSION *v2;
  _QWORD *v3;

  handshake_func = ssl->handshake_func;
  v2 = (SSL_SESSION *)*((_QWORD *)handshake_func + 59);
  if (v2)
    return v2;
  v3 = (_QWORD *)*((_QWORD *)handshake_func + 35);
  if (!v3)
    SSL_get_session_cold_1();
  if ((*((_WORD *)handshake_func + 110) & 0x20) != 0)
    SSL_get_session_cold_2();
  v2 = (SSL_SESSION *)v3[193];
  if (v2)
    return v2;
  else
    return (SSL_SESSION *)bssl::ssl_handshake_session(v3);
}

uint64_t bssl::ssl_handshake_session(_QWORD *a1)
{
  uint64_t result;

  result = a1[192];
  if (!result)
    return *(_QWORD *)(*a1 + 104);
  return result;
}

uint64_t boringssl_session_get_negotiated_protocol(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  unsigned int v4;
  uint64_t v5;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v2 = *(_QWORD *)(result + 8)) != 0)
    {
      v5 = 0;
      v4 = 0;
      SSL_get0_alpn_selected(*(_QWORD *)(v2 + 400), &v5, &v4);
      if (a2)
        *a2 = v4;
      return v5;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SSL_get0_alpn_selected(uint64_t result, _QWORD *a2, _DWORD *a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t *v7;
  unint64_t v8;

  v3 = *(_QWORD **)(result + 48);
  v4 = v3[35];
  if (v4 && (*(_BYTE *)(v4 + 1601) & 8) != 0 && (*(_BYTE *)(result + 180) & 1) == 0)
  {
    v5 = *(_QWORD *)(v4 + 1544);
    v6 = (_QWORD *)(v5 + 400);
    v7 = (unint64_t *)(v5 + 408);
  }
  else
  {
    v6 = v3 + 62;
    v7 = v3 + 63;
  }
  v8 = *v7;
  if (v8 >= 0xFFFFFFFF)
    SSL_get0_alpn_selected_cold_1();
  *a2 = *v6;
  *a3 = v8;
  return result;
}

uint64_t boringssl_session_was_resumed(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
    {
      result = *(_QWORD *)(v1 + 400);
      if (result)
        return SSL_session_reused(result) != 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SSL_session_reused(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 48);
  if ((*(_WORD *)(v1 + 220) & 0x40) != 0)
    return 1;
  v2 = *(_QWORD *)(v1 + 280);
  if (v2)
    return (*(_DWORD *)(v2 + 1600) >> 11) & 1;
  else
    return 0;
}

const SSL *boringssl_session_was_renewed(const SSL *result, uint64_t a2)
{
  SSL_METHOD *method;

  if (result)
  {
    if (result->version == -1252936367 && (method = result->method) != 0)
    {
      result = (const SSL *)method[1].num_ciphers;
      if (result)
      {
        if (a2)
          return (const SSL *)(SSL_SESSION_was_renewed(a2) != 0);
        result = (const SSL *)SSL_get_session(result);
        a2 = (uint64_t)result;
        if (result)
          return (const SSL *)(SSL_SESSION_was_renewed(a2) != 0);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SSL_SESSION_was_renewed(uint64_t a1)
{
  return *(_BYTE *)(a1 + 392) & 1;
}

const SSL *boringssl_session_has_session_ticket(const SSL *result, uint64_t a2)
{
  SSL_METHOD *method;

  if (result)
  {
    if (result->version == -1252936367 && (method = result->method) != 0)
    {
      if (a2)
        return (const SSL *)SSL_SESSION_has_ticket(a2);
      result = (const SSL *)method[1].num_ciphers;
      if (result)
      {
        result = (const SSL *)SSL_get_session(result);
        a2 = (uint64_t)result;
        if (result)
          return (const SSL *)SSL_SESSION_has_ticket(a2);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL SSL_SESSION_has_ticket(uint64_t a1)
{
  return *(_QWORD *)(a1 + 248) != 0;
}

char *boringssl_session_get_negotiated_group(uint64_t a1)
{
  uint64_t v1;
  const SSL *v2;
  int curve_id;

  if (!a1)
    return 0;
  if (*(_DWORD *)a1 != -1252936367)
    return 0;
  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
    return 0;
  v2 = *(const SSL **)(v1 + 400);
  if (!v2)
    return 0;
  curve_id = SSL_get_curve_id(v2);
  return SSL_get_curve_name(curve_id);
}

SSL_SESSION *SSL_get_curve_id(const SSL *a1)
{
  SSL_SESSION *result;

  result = SSL_get_session(a1);
  if (result)
    return (SSL_SESSION *)HIWORD(result->key_arg_length);
  return result;
}

char *SSL_get_curve_name(int a1)
{
  uint64_t v1;

  v1 = 0;
  {
    v1 += 8;
    if (v1 == 64)
      return 0;
  }
}

__CFArray *boringssl_helper_copy_certificates_from_session(void *a1, const SSL *a2)
{
  char *v2;
  id *v4;
  __CFArray *v5;
  SSL_SESSION *v6;
  id WeakRetained;
  void *v8;
  unsigned __int8 *v9;
  id v10;
  _BYTE *v11;
  _BOOL4 v12;
  NSObject *v13;
  id v14;
  void *v15;
  id v16;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  void *v23;
  __int16 v24;
  id v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  v5 = 0;
  if (v4 && a2)
  {
    v6 = SSL_get0_peer_certificates(a2);
    if (v6)
    {
      v5 = boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs(v4, (const STACK *)v6);
      goto LABEL_21;
    }
    WeakRetained = objc_loadWeakRetained(v4 + 2);
    if (WeakRetained)
    {
      v8 = WeakRetained;
      v9 = (unsigned __int8 *)objc_loadWeakRetained(v4 + 2);
      v2 = (char *)v9[475];

      if ((v2 & 1) != 0)
      {
LABEL_20:
        v5 = 0;
        goto LABEL_21;
      }
    }
    v10 = objc_loadWeakRetained(v4 + 2);
    if (v10)
    {
      v11 = objc_loadWeakRetained(v4 + 2);
      v12 = (v11[475] & 1) == 0;

    }
    else
    {
      v12 = 1;
    }

    v5 = 0;
    if (v12 && g_boringssl_log)
    {
      v13 = (id)g_boringssl_log;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        v14 = objc_loadWeakRetained(v4 + 2);
        if (v14)
        {
          v2 = (char *)objc_loadWeakRetained(v4 + 2);
          v15 = v2 + 391;
        }
        else
        {
          v15 = &unk_1B50022E3;
        }
        v16 = objc_loadWeakRetained(v4 + 2);
        v18 = 136446978;
        v19 = "boringssl_helper_copy_certificates_from_session";
        v20 = 1024;
        v21 = 188;
        v22 = 2082;
        v23 = v15;
        v24 = 2048;
        v25 = v16;
        _os_log_impl(&dword_1B4F6D000, v13, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] SSL_get0_peer_certificates returned no certificates", (uint8_t *)&v18, 0x26u);

        if (v14)
      }

      goto LABEL_20;
    }
  }
LABEL_21:

  return v5;
}

dispatch_data_t boringssl_context_copy_ocsp_response(uint64_t a1)
{
  dispatch_data_t result;
  BOOL v2;
  size_t v3;
  const void *v4;

  result = *(dispatch_data_t *)(a1 + 400);
  if (result)
  {
    v3 = 0;
    v4 = 0;
    SSL_get0_ocsp_response((uint64_t)result, (uint64_t *)&v4, (uint64_t *)&v3);
    result = 0;
    if (v3)
      v2 = v4 == 0;
    else
      v2 = 1;
    if (!v2)
      return dispatch_data_create(v4, v3, 0, 0);
  }
  return result;
}

SSL_SESSION *SSL_get0_peer_certificates(const SSL *a1)
{
  SSL_SESSION *result;

  result = SSL_get_session(a1);
  if (result)
    return (SSL_SESSION *)result->sess_cert;
  return result;
}

uint64_t boringssl_session_early_data_accepted(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
    {
      result = *(_QWORD *)(v1 + 400);
      if (result)
        return SSL_early_data_accepted(result) != 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL boringssl_session_is_eap_configured(uint64_t a1)
{
  _BOOL8 v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  char v6;

  if (!a1 || *(_DWORD *)a1 != -1252936367 || !*(_QWORD *)(a1 + 8))
    return 0;
  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = 1;
  nw_protocol_options_access_handle();
  v1 = *((_BYTE *)v4 + 24) != 0;
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_1B4F80500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const SSL *boringssl_session_get_server_name(const SSL *result)
{
  SSL_METHOD *method;

  if (result)
  {
    if (result->version == -1252936367 && (method = result->method) != 0)
    {
      result = (const SSL *)method[1].num_ciphers;
      if (result)
      {
        if ((BYTE4(method[2].ssl_renegotiate_check) & 0x10) != 0)
          return (const SSL *)SSL_get_servername(result, 0);
        else
          return (const SSL *)method->ssl_renegotiate;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t boringssl_session_get_peer_signature_algorithms(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  if (a1 && *(_DWORD *)a1 == -1252936367 && a2 && (v2 = *(_QWORD *)(a1 + 8)) != 0 && (v3 = *(_QWORD *)(v2 + 400)) != 0)
    return SSL_get0_peer_verify_algorithms(v3, a2);
  else
    return 0;
}

id boringssl_context_copy_server_requested_CAs(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;
  const STACK *v4;
  const STACK *v5;
  unint64_t v6;
  char *v7;
  const void *v8;
  size_t v9;
  dispatch_data_t v10;

  if (a1 && *(_DWORD *)a1 == -1252936367 && (v1 = *(_QWORD *)(a1 + 8)) != 0 && (v2 = *(_QWORD *)(v1 + 400)) != 0)
  {
    v3 = (void *)sec_array_create();
    v4 = (const STACK *)SSL_get0_server_requested_CAs(v2);
    if (v4)
    {
      v5 = v4;
      if (sk_num(v4))
      {
        if (sk_num(v5))
        {
          v6 = 0;
          do
          {
            v7 = sk_value(v5, v6);
            v8 = (const void *)CRYPTO_BUFFER_data((uint64_t)v7);
            v9 = CRYPTO_BUFFER_len((uint64_t)v7);
            v10 = dispatch_data_create(v8, v9, 0, 0);
            sec_array_append();

            ++v6;
          }
          while (v6 < sk_num(v5));
        }
      }
    }
  }
  else
  {
    v3 = 0;
  }
  return v3;
}

uint64_t SSL_get_peer_quic_transport_params(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  *a2 = *(_QWORD *)(*(_QWORD *)(result + 48) + 584);
  *a3 = *(_QWORD *)(*(_QWORD *)(result + 48) + 592);
  return result;
}

uint64_t SSL_get0_server_requested_CAs(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 280);
  if (v1)
    return *(_QWORD *)(v1 + 1488);
  else
    return 0;
}

uint64_t SSL_get0_peer_verify_algorithms(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 280);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 648);
    result = *(_QWORD *)(v2 + 656);
  }
  else
  {
    result = 0;
    v3 = 0;
  }
  *a2 = v3;
  return result;
}

uint64_t SSL_early_data_accepted(uint64_t a1)
{
  return (*(unsigned __int16 *)(*(_QWORD *)(a1 + 48) + 220) >> 11) & 1;
}

void nw_protocol_boringssl_signal_connected(void *a1)
{
  char *v1;
  uint64_t v2;
  uint64_t negotiated_protocol;
  const char *negotiated_ciphersuite_name;
  void *v5;
  const char *v6;
  const SSL *v7;
  const char *v8;
  const char *v9;
  _BOOL4 ticket_offered;
  int false_start_used;
  int ocsp_response_received;
  int sct_received;
  uint64_t handshake_time_ms;
  uint64_t handshake_flight_time_ms;
  uint64_t handshake_rtt_ms;
  uint64_t v17;
  uint64_t stall_count;
  int v19;
  const char *v20;
  unsigned int peer_signature_algorithm;
  unsigned int negotiated_group_id;
  const char *v23;
  unsigned int negotiated_protocol_version;
  NSObject *log;
  uint64_t v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  char *v32;
  __int16 v33;
  char *v34;
  __int16 v35;
  unsigned int v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  unsigned int v40;
  __int16 v41;
  unsigned int v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  _BOOL4 v48;
  __int16 v49;
  int v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  __int16 v55;
  uint64_t v56;
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  uint64_t v60;
  __int16 v61;
  uint64_t v62;
  __int16 v63;
  uint64_t v64;
  _BYTE v65[136];
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if ((v1[475] & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_signal_connected_cold_1();
  }
  v2 = *((_QWORD *)v1 + 42);
  if (v2)
  {
    if (*((_QWORD *)v1 + 40))
    {
      nw_queue_cancel_source();
      *((_QWORD *)v1 + 40) = 0;
      v2 = *((_QWORD *)v1 + 42);
    }
    v26 = 0;
    negotiated_protocol = boringssl_session_get_negotiated_protocol(v2, &v26);
    memset(v65, 0, 128);
    if (negotiated_protocol)
      __memcpy_chk();
    negotiated_ciphersuite_name = (const char *)boringssl_session_get_negotiated_ciphersuite_name(*((_QWORD *)v1 + 42));
    if ((v1[475] & 1) == 0)
    {
      v5 = (void *)g_boringssl_log;
      if (g_boringssl_log)
      {
        v6 = negotiated_ciphersuite_name;
        if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEFAULT))
        {
          v7 = (const SSL *)*((_QWORD *)v1 + 42);
          log = v5;
          negotiated_protocol_version = boringssl_session_get_negotiated_protocol_version(v7);
          if (v6)
            v8 = v6;
          else
            v8 = "nil";
          v23 = v8;
          negotiated_group_id = boringssl_session_get_negotiated_group_id(*((_QWORD *)v1 + 42));
          peer_signature_algorithm = boringssl_session_get_peer_signature_algorithm(*((_QWORD *)v1 + 42));
          v9 = v65;
          if (!negotiated_protocol)
            v9 = "nil";
          v20 = v9;
          v19 = boringssl_session_was_resumed(*((_QWORD *)v1 + 42));
          ticket_offered = boringssl_session_get_ticket_offered(*((_QWORD *)v1 + 42));
          false_start_used = boringssl_session_get_false_start_used(*((_QWORD *)v1 + 42));
          ocsp_response_received = boringssl_session_get_ocsp_response_received(*((_QWORD *)v1 + 42));
          sct_received = boringssl_session_get_sct_received(*((_QWORD *)v1 + 42));
          handshake_time_ms = boringssl_session_get_handshake_time_ms(*((_QWORD *)v1 + 42));
          handshake_flight_time_ms = boringssl_session_get_handshake_flight_time_ms(*((_QWORD *)v1 + 42));
          handshake_rtt_ms = boringssl_session_get_handshake_rtt_ms(*((_QWORD *)v1 + 42));
          v17 = boringssl_session_get_handshake_write_stall_count(*((_QWORD *)v1 + 42));
          stall_count = boringssl_session_get_handshake_read_stall_count(*((_QWORD *)v1 + 42));
          *(_DWORD *)buf = 136450818;
          v28 = "nw_protocol_boringssl_signal_connected";
          v29 = 1024;
          v30 = 747;
          v31 = 2082;
          v32 = v1 + 391;
          v33 = 2048;
          v34 = v1;
          v35 = 1024;
          v36 = negotiated_protocol_version;
          v37 = 2080;
          v38 = v23;
          v39 = 1024;
          v40 = negotiated_group_id;
          v41 = 1024;
          v42 = peer_signature_algorithm;
          v43 = 2082;
          v44 = v20;
          v45 = 1024;
          v46 = v19;
          v47 = 1024;
          v48 = ticket_offered;
          v49 = 1024;
          v50 = false_start_used;
          v51 = 1024;
          v52 = ocsp_response_received;
          v53 = 1024;
          v54 = sct_received;
          v55 = 2048;
          v56 = handshake_time_ms;
          v57 = 2048;
          v58 = handshake_flight_time_ms;
          v59 = 2048;
          v60 = handshake_rtt_ms;
          v61 = 2048;
          v62 = v17;
          v63 = 2048;
          v64 = stall_count;
          _os_log_impl(&dword_1B4F6D000, log, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] TLS connected [version(0x%04x) ciphersuite(%s) group(0x%04x) signature_alg(0x%04x) alpn(%{public}s) resumed(%d) offered_ticket(%d) false_started(%d) ocsp_received(%d) sct_received(%d) connect_time(%llums) flight_time(%llums) rtt(%llums) write_stalls(%zu) read_stalls(%zu)]", buf, 0x9Cu);

        }
      }
    }
    (*(void (**)(void))(*(_QWORD *)(*((_QWORD *)v1 + 7) + 24) + 40))();
    v1[390] |= 2u;
  }

}

uint64_t boringssl_session_get_handshake_time_ms(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 432) - *(_QWORD *)(v1 + 424);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_get_handshake_rtt_ms(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  unint64_t v5;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
    {
      v2 = *(_QWORD *)(v1 + 464);
      v3 = *(_QWORD *)(v1 + 456);
      v4 = v2 >= v3;
      v5 = v2 - v3;
      if (v4)
        return v5;
      else
        return -1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL boringssl_session_get_ticket_offered(_BOOL8 result)
{
  uint64_t v1;

  if (result)
    return *(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0 && *(char *)(v1 + 558) < 0;
  return result;
}

SSL_SESSION *boringssl_session_get_peer_signature_algorithm(uint64_t a1)
{
  uint64_t v1;
  const SSL *v2;

  if (a1 && *(_DWORD *)a1 == -1252936367 && (v1 = *(_QWORD *)(a1 + 8)) != 0 && (v2 = *(const SSL **)(v1 + 400)) != 0)
    return SSL_get_peer_signature_algorithm(v2);
  else
    return 0;
}

uint64_t boringssl_session_get_ocsp_response_received(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
    {
      result = *(_QWORD *)(v1 + 400);
      if (result)
      {
        v2 = 0;
        v3 = 0;
        SSL_get0_ocsp_response(result, &v3, &v2);
        return v2 != 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t boringssl_session_get_handshake_write_stall_count(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 488);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_get_handshake_read_stall_count(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 496);
    else
      return 0;
  }
  return result;
}

SSL_SESSION *SSL_get_peer_signature_algorithm(const SSL *a1)
{
  SSL_SESSION *result;

  result = SSL_get_session(a1);
  if (result)
    return (SSL_SESSION *)*(unsigned __int16 *)result->key_arg;
  return result;
}

uint64_t boringssl_session_set_peer_verification_state_from_session(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  const STACK *v6;
  __CFArray *v7;
  __CFArray *v8;
  SecKeyRef v9;
  SecKeyRef v10;
  const char *string;
  __CFArray *v12;
  const __CFArray *v13;
  const void *sec_trust_with_certificates;
  id v15;
  void *v16;
  _BYTE *v17;
  char v18;
  id v19;
  _BYTE *v20;
  _BOOL4 v21;
  id v22;
  void *v23;
  _BYTE *v24;
  char v25;
  id v26;
  _BYTE *v27;
  _BOOL4 v28;
  const char *v29;
  const void *v30;
  __CFArray *v31;
  id v32;
  void *v33;
  _BYTE *v34;
  char v35;
  id v36;
  _BYTE *v37;
  _BOOL4 v38;
  id WeakRetained;
  void *v40;
  _BYTE *v41;
  char v42;
  id v43;
  _BYTE *v44;
  _BOOL4 v45;
  NSObject *v46;
  NSObject *v47;
  NSObject *v48;
  const __CFArray *cf;

  if (!a1 || *(_DWORD *)a1 != -1252936367)
    return 0;
  v3 = 0;
  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 8);
    if (v4)
    {
      if (*(_QWORD *)(v4 + 368))
        return 0;
      v6 = (const STACK *)SSL_SESSION_get0_peer_certificates(a2);
      v7 = boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs((void *)v4, v6);
      if (v7)
      {
        v8 = v7;
        v9 = boringssl_helper_copy_public_key_from_certificates((void *)v4, v7);
        if (!v9)
        {
          WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
          if (!WeakRetained
            || (v40 = WeakRetained,
                v41 = objc_loadWeakRetained((id *)(v4 + 16)),
                v42 = v41[475],
                v41,
                v40,
                (v42 & 1) == 0))
          {
            v43 = objc_loadWeakRetained((id *)(v4 + 16));
            if (v43)
            {
              v44 = objc_loadWeakRetained((id *)(v4 + 16));
              v45 = (v44[475] & 1) == 0;

            }
            else
            {
              v45 = 1;
            }

            if (v45)
            {
              if (g_boringssl_log)
              {
                v48 = (id)g_boringssl_log;
                if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
                  boringssl_session_set_peer_verification_state_from_session_cold_2(v4, v48);

              }
            }
          }
          CFRelease(v8);
          return 0;
        }
        v10 = v9;
        string = boringssl_helper_create_string(*(const char **)(v4 + 80));
        v12 = boringssl_context_copy_ocsp_responses((void *)v4);
        v13 = boringssl_context_copy_peer_sct_list((void *)v4);
        sec_trust_with_certificates = (const void *)boringssl_helper_create_sec_trust_with_certificates(a1, string, v8, v12, v13);
        if (boringssl_session_set_trust_reference(a1, (uint64_t)sec_trust_with_certificates)
          && boringssl_session_set_peer_certificate_chain(a1, (uint64_t)v8)
          && boringssl_session_set_peer_public_key(a1, (uint64_t)v10))
        {
          v15 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v15)
          {
            v16 = v15;
            v17 = objc_loadWeakRetained((id *)(v4 + 16));
            v18 = v17[475];

            if ((v18 & 1) != 0)
            {
              v3 = 1;
              goto LABEL_44;
            }
          }
          v19 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v19)
          {
            v20 = objc_loadWeakRetained((id *)(v4 + 16));
            v21 = (v20[475] & 1) == 0;

          }
          else
          {
            v21 = 1;
          }

          v3 = 1;
          if (!v21 || !g_boringssl_log)
            goto LABEL_44;
          v47 = (id)g_boringssl_log;
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
            boringssl_session_set_peer_verification_state_from_session_cold_3(v4, v47);
          goto LABEL_42;
        }
        cf = v13;
        v29 = string;
        v30 = sec_trust_with_certificates;
        v31 = v12;
        v32 = objc_loadWeakRetained((id *)(v4 + 16));
        if (v32
          && (v33 = v32,
              v34 = objc_loadWeakRetained((id *)(v4 + 16)),
              v35 = v34[475],
              v34,
              v33,
              (v35 & 1) != 0))
        {
          v3 = 0;
        }
        else
        {
          v36 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v36)
          {
            v37 = objc_loadWeakRetained((id *)(v4 + 16));
            v38 = (v37[475] & 1) == 0;

          }
          else
          {
            v38 = 1;
          }

          v3 = 0;
          if (v38)
          {
            v12 = v31;
            sec_trust_with_certificates = v30;
            string = v29;
            v13 = cf;
            if (!g_boringssl_log)
            {
LABEL_44:
              if (string)
                CFRelease(string);
              if (v13)
                CFRelease(v13);
              if (v12)
                CFRelease(v12);
              if (sec_trust_with_certificates)
                CFRelease(sec_trust_with_certificates);
              CFRelease(v8);
              CFRelease(v10);
              return v3;
            }
            v47 = (id)g_boringssl_log;
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
              boringssl_session_set_peer_verification_state_from_session_cold_4(v4, v47);
            v3 = 0;
LABEL_42:

            goto LABEL_44;
          }
        }
        v12 = v31;
        sec_trust_with_certificates = v30;
        string = v29;
        v13 = cf;
        goto LABEL_44;
      }
      v22 = objc_loadWeakRetained((id *)(v4 + 16));
      if (v22)
      {
        v23 = v22;
        v24 = objc_loadWeakRetained((id *)(v4 + 16));
        v25 = v24[475];

        if ((v25 & 1) != 0)
          return 0;
      }
      v26 = objc_loadWeakRetained((id *)(v4 + 16));
      if (v26)
      {
        v27 = objc_loadWeakRetained((id *)(v4 + 16));
        v28 = (v27[475] & 1) == 0;

      }
      else
      {
        v28 = 1;
      }

      v3 = 0;
      if (v28 && g_boringssl_log)
      {
        v46 = (id)g_boringssl_log;
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          boringssl_session_set_peer_verification_state_from_session_cold_1(v4, v46);

        return 0;
      }
    }
  }
  return v3;
}

uint64_t boringssl_session_set_trust_reference(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  const void *v5;

  if (result)
  {
    v2 = result;
    if (*(_DWORD *)result == -1252936367)
    {
      result = 0;
      if (a2)
      {
        v4 = *(_QWORD *)(v2 + 8);
        if (v4)
        {
          v5 = *(const void **)(v4 + 360);
          if (v5)
            CFRelease(v5);
          *(_QWORD *)(v4 + 360) = 0;
          *(_QWORD *)(v4 + 360) = a2;
          CFRetain(*(CFTypeRef *)(v4 + 360));
          return 1;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t boringssl_session_set_peer_public_key(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  const void *v5;

  if (result)
  {
    v2 = result;
    if (*(_DWORD *)result == -1252936367)
    {
      result = 0;
      if (a2)
      {
        v4 = *(_QWORD *)(v2 + 8);
        if (v4)
        {
          v5 = *(const void **)(v4 + 344);
          if (v5)
            CFRelease(v5);
          *(_QWORD *)(v4 + 344) = 0;
          *(_QWORD *)(v4 + 344) = a2;
          CFRetain(*(CFTypeRef *)(v4 + 344));
          return 1;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t boringssl_session_set_peer_certificate_chain(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  const void *v5;

  if (result)
  {
    v2 = result;
    if (*(_DWORD *)result == -1252936367)
    {
      result = 0;
      if (a2)
      {
        v4 = *(_QWORD *)(v2 + 8);
        if (v4)
        {
          v5 = *(const void **)(v4 + 352);
          if (v5)
            CFRelease(v5);
          *(_QWORD *)(v4 + 352) = 0;
          *(_QWORD *)(v4 + 352) = a2;
          CFRetain(*(CFTypeRef *)(v4 + 352));
          return 1;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SSL_SESSION_get0_peer_certificates(uint64_t a1)
{
  return *(_QWORD *)(a1 + 144);
}

SecKeyRef boringssl_helper_copy_public_key_from_certificates(void *a1, const __CFArray *a2)
{
  id *v3;
  SecKeyRef v4;
  __SecCertificate *ValueAtIndex;
  id WeakRetained;
  void *v7;
  _BYTE *v8;
  char v9;
  id v10;
  _BYTE *v11;
  _BOOL4 v12;
  NSObject *v13;

  v3 = a1;
  v4 = 0;
  if (v3 && a2)
  {
    ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(a2, 0);
    if (ValueAtIndex)
    {
      v4 = SecCertificateCopyKey(ValueAtIndex);
      goto LABEL_16;
    }
    WeakRetained = objc_loadWeakRetained(v3 + 2);
    if (WeakRetained)
    {
      v7 = WeakRetained;
      v8 = objc_loadWeakRetained(v3 + 2);
      v9 = v8[475];

      if ((v9 & 1) != 0)
      {
LABEL_15:
        v4 = 0;
        goto LABEL_16;
      }
    }
    v10 = objc_loadWeakRetained(v3 + 2);
    if (v10)
    {
      v11 = objc_loadWeakRetained(v3 + 2);
      v12 = (v11[475] & 1) == 0;

    }
    else
    {
      v12 = 1;
    }

    v4 = 0;
    if (v12 && g_boringssl_log)
    {
      v13 = (id)g_boringssl_log;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        boringssl_helper_copy_public_key_from_certificates_cold_1(v3, v13);

      goto LABEL_15;
    }
  }
LABEL_16:

  return v4;
}

const char *boringssl_helper_create_string(const char *cStr)
{
  if (cStr)
    return (const char *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x8000100u);
  return cStr;
}

#error "1B4F81B70: call analysis failed (funcsize=431)"

uint64_t boringssl_helper_ciphersuite_to_key_usage(int a1, int a2)
{
  uint64_t result;
  int kx_nid;

  if (a1 == 772)
    return 1;
  result = (uint64_t)SSL_get_cipher_by_value(a2);
  if (result)
  {
    kx_nid = SSL_CIPHER_get_kx_nid(result);
    if (kx_nid == 951)
      return 4;
    else
      return kx_nid == 952;
  }
  return result;
}

const __CFArray *boringssl_context_copy_peer_sct_list(void *a1)
{
  char *v1;
  uint64_t v2;
  const __CFArray *v3;
  id WeakRetained;
  void *v5;
  _BYTE *v6;
  char v7;
  id v8;
  _BYTE *v9;
  char v10;
  NSObject *v11;
  uint64_t v13;
  unsigned __int16 *v14;

  v1 = a1;
  v2 = *((_QWORD *)v1 + 50);
  if (!v2)
    goto LABEL_15;
  v13 = 0;
  v14 = 0;
  SSL_get0_signed_cert_timestamp_list(v2, (uint64_t *)&v14, &v13);
  if (v13)
  {
    v3 = boringssl_context_copy_peer_sct_list_from_extension(v1, v14, v13);
    goto LABEL_16;
  }
  WeakRetained = objc_loadWeakRetained((id *)v1 + 2);
  if (WeakRetained)
  {
    v5 = WeakRetained;
    v6 = objc_loadWeakRetained((id *)v1 + 2);
    v7 = v6[475];

    if ((v7 & 1) != 0)
    {
LABEL_15:
      v3 = 0;
      goto LABEL_16;
    }
  }
  v8 = objc_loadWeakRetained((id *)v1 + 2);
  if (v8)
  {
    v9 = objc_loadWeakRetained((id *)v1 + 2);
    v10 = v9[475] & 1;

  }
  else
  {
    v10 = 0;
  }

  v3 = 0;
  if ((v10 & 1) == 0 && datapath_logging_enabled)
  {
    if (g_boringssl_log)
    {
      v11 = (id)g_boringssl_log;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        boringssl_context_copy_peer_sct_list_cold_1(v1 + 16, v11);

    }
    goto LABEL_15;
  }
LABEL_16:

  return v3;
}

uint64_t boringssl_session_get_sct_received(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
    {
      result = *(_QWORD *)(v1 + 400);
      if (result)
      {
        v2 = 0;
        v3 = 0;
        SSL_get0_signed_cert_timestamp_list(result, &v3, &v2);
        return v2 != 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SSL_get0_signed_cert_timestamp_list(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v7;

  result = (uint64_t)SSL_get_session((const SSL *)a1);
  if ((*(_BYTE *)(a1 + 180) & 1) == 0 && (v7 = result) != 0 && (result = *(_QWORD *)(result + 256)) != 0)
  {
    *a2 = CRYPTO_BUFFER_data(result);
    result = CRYPTO_BUFFER_len(*(_QWORD *)(v7 + 256));
    *a3 = result;
  }
  else
  {
    *a3 = 0;
    *a2 = 0;
  }
  return result;
}

__CFArray *boringssl_context_copy_ocsp_responses(void *a1)
{
  __CFArray **v1;
  __CFArray **v2;
  __CFArray *Mutable;
  const STACK *v4;
  const STACK *v5;
  CFIndex v6;
  CFIndex v7;
  const __CFAllocator *v8;
  uint64_t i;
  char *v10;
  const UInt8 *v11;
  CFIndex v12;
  CFDataRef v13;
  const __CFAllocator *v14;
  CFDataRef v15;
  CFIndex v17;
  const UInt8 *v18;

  v1 = a1;
  v2 = v1;
  Mutable = v1[50];
  if (Mutable)
  {
    v4 = (const STACK *)SSL_get0_ocsp_responses((uint64_t)v1[50]);
    if (v4)
    {
      v5 = v4;
      v6 = sk_num(v4);
      if (v6)
      {
        v7 = v6;
        v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, MEMORY[0x1E0C9B378]);
        for (i = 0; i != v7; ++i)
        {
          v10 = sk_value(v5, i);
          v11 = (const UInt8 *)CRYPTO_BUFFER_data((uint64_t)v10);
          v12 = CRYPTO_BUFFER_len((uint64_t)v10);
          v13 = CFDataCreate(v8, v11, v12);
          CFArrayAppendValue(Mutable, v13);
          CFRelease(v13);
        }
        goto LABEL_11;
      }
    }
    else
    {
      v17 = 0;
      v18 = 0;
      SSL_get0_ocsp_response((uint64_t)Mutable, (uint64_t *)&v18, &v17);
      if (v17 && v18)
      {
        v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B378]);
        v15 = CFDataCreate(v14, v18, v17);
        CFArrayAppendValue(Mutable, v15);
        CFRelease(v15);
        goto LABEL_11;
      }
    }
    Mutable = 0;
  }
LABEL_11:

  return Mutable;
}

size_t SSL_get0_ocsp_responses(uint64_t a1)
{
  SSL_SESSION *session;
  size_t result;

  session = SSL_get_session((const SSL *)a1);
  result = 0;
  if ((*(_BYTE *)(a1 + 180) & 1) == 0)
  {
    if (session)
      return session->tlsext_ticklen;
  }
  return result;
}

SSL_SESSION *boringssl_session_get_negotiated_group_id(uint64_t a1)
{
  uint64_t v1;
  const SSL *v2;

  if (a1 && *(_DWORD *)a1 == -1252936367 && (v1 = *(_QWORD *)(a1 + 8)) != 0 && (v2 = *(const SSL **)(v1 + 400)) != 0)
    return SSL_get_curve_id(v2);
  else
    return 0;
}

void *boringssl_session_get_negotiated_ciphersuite_name(uint64_t a1)
{
  int negotiated_ciphersuite;
  void *result;

  negotiated_ciphersuite = boringssl_session_get_negotiated_ciphersuite(a1);
  result = SSL_get_cipher_by_value(negotiated_ciphersuite);
  if (result)
    return (void *)RSA_get0_n((uint64_t)result);
  return result;
}

uint64_t boringssl_context_set_cipher_suites(uint64_t a1, unsigned __int16 *a2, unsigned int a3)
{
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *cipher_by_value;
  uint64_t v11;
  const char *v12;
  void *v13;
  char *configuration_string;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  id *v19;
  id WeakRetained;
  void *v21;
  _BYTE *v22;
  char v23;
  id v24;
  _BYTE *v25;
  _BOOL4 v26;
  NSObject *v27;
  uint64_t v28;
  char v29;
  int v30;
  int v31;
  _BYTE v32[1024];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!a1 || *(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v4 = 0xFFFFFFFFLL;
  if (a3)
  {
    v5 = a2;
    if (a2)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        if (*(_QWORD *)(v6 + 408))
        {
          v7 = 0;
          v8 = 2 * a3;
          v9 = a3;
          while (1)
          {
            cipher_by_value = SSL_get_cipher_by_value(v5[v7 / 2]);
            if (cipher_by_value)
            {
              if (SSL_CIPHER_get_auth_nid((uint64_t)cipher_by_value) == 956
                && *(_DWORD *)a1 == -1252936367)
              {
                v11 = *(_QWORD *)(a1 + 8);
                if (v11)
                {
                  if (*(_WORD *)(v11 + 56) == 772)
                    break;
                }
              }
            }
            v7 += 2;
            if (v8 == v7)
              goto LABEL_14;
          }
          boringssl_context_set_max_version(a1, 0x303u);
LABEL_14:
          bzero(v32, 0x400uLL);
          v12 = (const char *)boringssl_ciphers_fillout_configuration_string((uint64_t)v5, v9, (uint64_t)v32, 0x400uLL);
          v13 = *(void **)(v6 + 88);
          if (v13)
          {
            free(v13);
            *(_QWORD *)(v6 + 88) = 0;
          }
          if (v12)
            configuration_string = strndup(v12, 0x400uLL);
          else
            configuration_string = boringssl_ciphers_create_configuration_string((uint64_t)v5, v9);
          v16 = configuration_string;
          *(_QWORD *)(v6 + 88) = configuration_string;
          if (configuration_string)
          {
            if (*(_DWORD *)a1 != -1252936367)
              goto LABEL_39;
            v17 = *(_QWORD *)(a1 + 8);
            if (v17)
            {
              v18 = *(_QWORD *)(v17 + 400);
              if (v18)
              {
                if (SSL_set_strict_cipher_list(v18, (uint64_t)v16))
                {
                  v4 = 0;
LABEL_41:
                  if (*(_DWORD *)a1 == -1252936367 && (v28 = *(_QWORD *)(a1 + 8)) != 0 && *(_WORD *)(v28 + 56) == 772)
                  {
                    boringssl_context_set_tls13_ciphersuite_aesgcm_enabled(a1, 0);
                    boringssl_context_set_tls13_ciphersuite_chacha20poly1305_enabled(a1, 0);
                    v29 = 0;
                    do
                    {
                      v31 = *v5++;
                      v30 = v31;
                      if ((v31 - 4865) >= 2)
                      {
                        if (v30 == 4867)
                        {
                          v29 = 1;
                          boringssl_context_set_tls13_ciphersuite_chacha20poly1305_enabled(a1, 1);
                        }
                      }
                      else
                      {
                        v29 = 1;
                        boringssl_context_set_tls13_ciphersuite_aesgcm_enabled(a1, 1);
                      }
                      --v9;
                    }
                    while (v9);
                    if ((v29 & 1) == 0)
                    {
                      boringssl_context_set_tls13_ciphersuite_aesgcm_enabled(a1, 1);
                      boringssl_context_set_tls13_ciphersuite_chacha20poly1305_enabled(a1, 1);
                    }
                  }
                  else
                  {
                    boringssl_context_set_tls13_ciphersuite_chacha20poly1305_enabled(a1, 0);
                    boringssl_context_set_tls13_ciphersuite_aesgcm_enabled(a1, 0);
                  }
                  return v4;
                }
                v19 = (id *)(v17 + 16);
                WeakRetained = objc_loadWeakRetained(v19);
                if (!WeakRetained
                  || (v21 = WeakRetained,
                      v22 = objc_loadWeakRetained(v19),
                      v23 = v22[475],
                      v22,
                      v21,
                      (v23 & 1) == 0))
                {
                  v24 = objc_loadWeakRetained(v19);
                  if (v24)
                  {
                    v25 = objc_loadWeakRetained(v19);
                    v26 = (v25[475] & 1) == 0;

                  }
                  else
                  {
                    v26 = 1;
                  }

                  if (v26)
                  {
                    if (g_boringssl_log)
                    {
                      v27 = (id)g_boringssl_log;
                      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
                        boringssl_context_set_cipher_suites_cold_1(v19, v27);

                    }
                  }
                }
              }
            }
            v16 = *(char **)(v6 + 88);
            if (v16)
            {
LABEL_39:
              free(v16);
              *(_QWORD *)(v6 + 88) = 0;
            }
          }
          v4 = 0xFFFFFFFFLL;
          goto LABEL_41;
        }
      }
    }
  }
  return v4;
}

uint64_t SSL_CIPHER_get_auth_nid(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 24) - 1;
  if (v1 >= 8 || ((0x8Bu >> v1) & 1) == 0)
    SSL_CIPHER_get_auth_nid_cold_1();
  return dword_1B5022290[v1];
}

uint64_t boringssl_context_set_tls13_ciphersuite_aesgcm_enabled(uint64_t result, int a2)
{
  uint64_t v2;
  char v3;

  if (*(_DWORD *)result == -1252936367)
  {
    v2 = *(_QWORD *)(result + 8);
    if (v2)
    {
      result = *(_QWORD *)(v2 + 400);
      if (result)
      {
        if (a2)
          v3 = 2;
        else
          v3 = 0;
        *(_BYTE *)(v2 + 560) = *(_BYTE *)(v2 + 560) & 0xFD | v3;
        return SSL_set_tls13_ciphersuite_aesgcm_enabled(result, a2);
      }
    }
  }
  return result;
}

uint64_t SSL_set_tls13_ciphersuite_aesgcm_enabled(uint64_t result, int a2)
{
  char v2;

  if (a2)
    v2 = 2;
  else
    v2 = 0;
  *(_BYTE *)(*(_QWORD *)(result + 120) + 240) = *(_BYTE *)(*(_QWORD *)(result + 120) + 240) & 0xFD | v2;
  return result;
}

uint64_t boringssl_context_set_tls13_ciphersuite_chacha20poly1305_enabled(uint64_t result, int a2)
{
  uint64_t v2;
  char v3;

  if (*(_DWORD *)result == -1252936367)
  {
    v2 = *(_QWORD *)(result + 8);
    if (v2)
    {
      result = *(_QWORD *)(v2 + 400);
      if (result)
      {
        if (a2)
          v3 = 4;
        else
          v3 = 0;
        *(_BYTE *)(v2 + 560) = *(_BYTE *)(v2 + 560) & 0xFB | v3;
        return SSL_set_tls13_ciphersuite_chacha20poly1305_enabled(result, a2);
      }
    }
  }
  return result;
}

uint64_t SSL_set_tls13_ciphersuite_chacha20poly1305_enabled(uint64_t result, int a2)
{
  char v2;

  if (a2)
    v2 = 4;
  else
    v2 = 0;
  *(_BYTE *)(*(_QWORD *)(result + 120) + 240) = *(_BYTE *)(*(_QWORD *)(result + 120) + 240) & 0xFB | v2;
  return result;
}

uint64_t boringssl_ciphers_fillout_configuration_string(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  char v10;
  size_t v11;
  uint64_t v12;
  const char *v13;
  const char *v14;
  size_t v15;
  size_t v16;

  result = 0;
  if (a1 && a2 && a3 && a4)
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = a2 - 1;
    do
    {
      while (1)
      {
        v13 = boringssl_ciphers_value_to_string(*(unsigned __int16 *)(a1 + 2 * v9));
        if (!v13)
          break;
        v14 = v13;
        if ((v10 & 1) != 0)
        {
          if (v11 + 1 >= a4)
            return 0;
          *(_BYTE *)(a3 + v11++) = 58;
        }
        v15 = strlen(v13);
        v16 = v15 + v11;
        if (v15 + v11 >= a4)
          return 0;
        strncpy((char *)(a3 + v11), v14, v15);
        v10 = 1;
        v11 = v16;
        if (v12 == v9++)
          return a3;
      }
      ++v9;
    }
    while (a2 != v9);
    result = a3;
    if ((v10 & 1) != 0)
      return result;
    if (g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        boringssl_ciphers_fillout_configuration_string_cold_1();
    }
    return 0;
  }
  return result;
}

const char *boringssl_ciphers_value_to_string(int a1)
{
  const SSL_CIPHER *cipher_by_value;
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    cipher_by_value = (const SSL_CIPHER *)SSL_get_cipher_by_value(a1);
    if (cipher_by_value)
      return SSL_CIPHER_get_name(cipher_by_value);
    v4 = g_boringssl_log;
    if (g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO))
      {
        v5 = 136446722;
        v6 = "boringssl_ciphers_value_to_string";
        v7 = 1024;
        v8 = 31;
        v9 = 1024;
        v10 = a1;
        _os_log_impl(&dword_1B4F6D000, v4, OS_LOG_TYPE_INFO, "%{public}s(%d) Failed to get boringssl cipher for ciphersuite 0x%04x", (uint8_t *)&v5, 0x18u);
      }
    }
  }
  return 0;
}

void *SSL_get_cipher_by_value(int a1)
{
  __int128 v1;
  __int128 v3;
  __int128 v4;
  unint64_t v5;

  *(_QWORD *)&v1 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v5 = 0xAAAAAAAAAAAAAAAALL;
  v3 = v1;
  v4 = v1;
  LODWORD(v4) = a1 | 0x3000000;
  return bsearch(&v3, bssl::kCiphers, 0x25uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
}

const char *__cdecl SSL_CIPHER_get_name(const SSL_CIPHER *c)
{
  if (c)
    return *(const char **)&c->valid;
  else
    return "(NONE)";
}

uint64_t SSL_set_strict_cipher_list(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
    return bssl::ssl_create_cipher_list((bssl::SSLCipherPreferenceList **)(v2 + 24), a2, 1);
  else
    return 0;
}

uint64_t boringssl_session_get_handshake_flight_time_ms(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 448);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_get_false_start_used(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_BYTE *)(v1 + 557) & 1;
    else
      return 0;
  }
  return result;
}

uint64_t RSA_get0_n(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

const SSL *boringssl_session_ticket_lifetime_hint(const SSL *result)
{
  SSL_METHOD *method;

  if (result)
  {
    if (result->version == -1252936367 && (method = result->method) != 0)
    {
      result = (const SSL *)method[1].num_ciphers;
      if (result)
      {
        result = (const SSL *)SSL_get_session(result);
        if (result)
          return (const SSL *)SSL_SESSION_get_ticket_lifetime_hint((uint64_t)result);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t boringssl_session_get_peer_public_key(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 344);
    else
      return 0;
  }
  return result;
}

bssl *boringssl_session_get_ems_used(bssl *result, const ssl_st *a2)
{
  uint64_t v2;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v2 = *((_QWORD *)result + 1)) != 0)
    {
      result = *(bssl **)(v2 + 400);
      if (result)
        return (bssl *)(SSL_get_extms_support(result, a2) != 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void boringssl_metrics_log_connection_data(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  const char *v5;
  uint64_t handshake_rtt_ms;
  const char *v7;
  uint64_t handshake_inbound_byte_count;
  const char *v9;
  uint64_t handshake_outbound_byte_count;
  const char *v11;
  uint64_t handshake_byte_count;
  const char *v13;
  uint64_t stall_count;
  const char *v15;
  uint64_t v16;
  const char *v17;
  uint64_t handshake_async_count;
  const char *v19;
  unsigned int address_family;
  xpc_object_t xdict;

  v3 = a2;
  if (*(_DWORD *)a1 == -1252936367)
  {
    v4 = *(_QWORD *)(a1 + 8);
    if (v4)
    {
      xdict = v3;
      xpc_dictionary_set_uint64(v3, (const char *)TLS_METRIC_HANDSHAKE_TIMER_FIRES, *(_QWORD *)(v4 + 328));
      v5 = (const char *)TLS_METRIC_HANDSHAKE_RTT;
      handshake_rtt_ms = boringssl_session_get_handshake_rtt_ms(a1);
      xpc_dictionary_set_uint64(xdict, v5, handshake_rtt_ms);
      v7 = (const char *)TLS_METRIC_HANDSHAKE_INBOUND_BYTE_COUNT;
      handshake_inbound_byte_count = boringssl_session_get_handshake_inbound_byte_count(a1);
      xpc_dictionary_set_uint64(xdict, v7, handshake_inbound_byte_count);
      v9 = (const char *)TLS_METRIC_HANDSHAKE_OUTBOUND_BYTE_COUNT;
      handshake_outbound_byte_count = boringssl_session_get_handshake_outbound_byte_count(a1);
      xpc_dictionary_set_uint64(xdict, v9, handshake_outbound_byte_count);
      v11 = (const char *)TLS_METRIC_HANDSHAKE_BYTE_COUNT;
      handshake_byte_count = boringssl_session_get_handshake_byte_count(a1);
      xpc_dictionary_set_uint64(xdict, v11, handshake_byte_count);
      v13 = (const char *)TLS_METRIC_HANDSHAKE_READ_STALLS;
      stall_count = boringssl_session_get_handshake_read_stall_count(a1);
      xpc_dictionary_set_uint64(xdict, v13, stall_count);
      v15 = (const char *)TLS_METRIC_HANDSHAKE_WRITE_STALLS;
      v16 = boringssl_session_get_handshake_write_stall_count(a1);
      xpc_dictionary_set_uint64(xdict, v15, v16);
      v17 = (const char *)TLS_METRIC_HANDSHAKE_ASYNC_CALLS;
      handshake_async_count = boringssl_session_get_handshake_async_count(a1);
      xpc_dictionary_set_uint64(xdict, v17, handshake_async_count);
      v19 = (const char *)TLS_METRIC_ADDRESS_FAMILY;
      address_family = boringssl_session_get_address_family(a1);
      xpc_dictionary_set_uint64(xdict, v19, address_family);
      v3 = xdict;
    }
  }

}

uint64_t boringssl_session_get_handshake_outbound_byte_count(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 472);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_get_handshake_inbound_byte_count(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 480);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_get_handshake_byte_count(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 472) + *(_QWORD *)(v1 + 480);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_get_handshake_async_count(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 504);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_get_address_family(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(unsigned __int8 *)(v1 + 225);
    else
      return 0;
  }
  return result;
}

BOOL boringssl_context_negotiated_protocol_is_unknown(uint64_t a1, char *__s)
{
  uint64_t v2;
  BOOL v3;
  size_t v6;
  id v7;
  size_t count;
  size_t v9;
  size_t i;
  const char *string;

  if (a1 && *(_DWORD *)a1 == -1252936367 && (v2 = *(_QWORD *)(a1 + 8)) != 0 && (*(_BYTE *)(v2 + 557) & 0x40) != 0)
  {
    if (__s)
    {
      v6 = strlen(__s);
      v7 = *(id *)(v2 + 64);
      count = xpc_array_get_count(v7);
      if (count)
      {
        v9 = count;
        v3 = 0;
        for (i = 0; i != v9; v3 = i >= v9)
        {
          string = xpc_array_get_string(v7, i);
          if (v6 == strlen(string) && !strncmp(__s, string, v6))
            break;
          ++i;
        }
      }
      else
      {
        v3 = 1;
      }

    }
    else
    {
      return 1;
    }
  }
  else
  {
    return 0;
  }
  return v3;
}

uint64_t SSL_get_extms_support(bssl *a1, const ssl_st *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if ((*(_WORD *)(*((_QWORD *)a1 + 6) + 220) & 2) == 0)
    return 0;
  if (bssl::ssl_protocol_version(a1, a2) > 0x303)
    return 1;
  v4 = *((_QWORD *)a1 + 6);
  v5 = *(_QWORD *)(v4 + 472);
  if (v5)
    return *(_BYTE *)(v5 + 448) & 1;
  v6 = *(_QWORD *)(v4 + 280);
  if (!v6)
    SSL_get_extms_support_cold_1();
  return (*(_DWORD *)(v6 + 1600) >> 17) & 1;
}

uint64_t SSL_SESSION_get_ticket_lifetime_hint(uint64_t a1)
{
  return *(unsigned int *)(a1 + 380);
}

uint64_t SSL_CIPHER_get_kx_nid(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 20);
  if (v1 > 7)
  {
    if (v1 == 8)
    {
      return 953;
    }
    else
    {
      if (v1 != 16)
        goto LABEL_11;
      return 957;
    }
  }
  else
  {
    if (v1 != 1)
    {
      if (v1 == 2)
        return 952;
LABEL_11:
      SSL_CIPHER_get_kx_nid_cold_1();
    }
    return 951;
  }
}

#error "1B4F82D60: call analysis failed (funcsize=47)"

void *nw_protocol_boringssl_allocate_metadata()
{
  return malloc_type_calloc(1uLL, 0x168uLL, 0x10D00404C253F0CuLL);
}

BOOL boringssl_context_set_quic_transport_parameters(uint64_t a1, void *a2)
{
  NSObject *v3;
  NSObject *v4;
  _BOOL8 v5;
  uint64_t v6;
  size_t size;
  void *buffer_from_dispatch_data;
  void *v9;
  int v10;
  id *v11;
  id v12;
  void *v13;
  _BYTE *v14;
  char v15;
  id v16;
  _BYTE *v17;
  _BOOL4 v18;
  id *v19;
  id WeakRetained;
  void *v21;
  _BYTE *v22;
  char v23;
  id v24;
  _BYTE *v25;
  _BOOL4 v26;
  NSObject *v27;
  NSObject *v29;

  v3 = a2;
  v4 = v3;
  if (!a1 || *(_DWORD *)a1 != -1252936367)
    goto LABEL_22;
  v5 = 0;
  if (!v3)
    goto LABEL_23;
  v6 = *(_QWORD *)(a1 + 8);
  if (!v6)
    goto LABEL_23;
  if (!*(_QWORD *)(v6 + 400))
    goto LABEL_22;
  size = dispatch_data_get_size(v3);
  buffer_from_dispatch_data = boringssl_helper_create_buffer_from_dispatch_data(v4);
  if (!buffer_from_dispatch_data)
  {
    v19 = (id *)(v6 + 16);
    WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
    if (!WeakRetained
      || (v21 = WeakRetained,
          v22 = objc_loadWeakRetained((id *)(v6 + 16)),
          v23 = v22[475],
          v22,
          v21,
          (v23 & 1) == 0))
    {
      v24 = objc_loadWeakRetained(v19);
      if (v24)
      {
        v25 = objc_loadWeakRetained(v19);
        v26 = (v25[475] & 1) == 0;

      }
      else
      {
        v26 = 1;
      }

      v5 = 0;
      if (!v26 || !g_boringssl_log)
        goto LABEL_23;
      v27 = (id)g_boringssl_log;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        boringssl_context_set_quic_transport_parameters_cold_1(v19, v27);

    }
LABEL_22:
    v5 = 0;
    goto LABEL_23;
  }
  v9 = buffer_from_dispatch_data;
  v10 = SSL_set_quic_transport_params(*(_QWORD *)(v6 + 400), buffer_from_dispatch_data, size);
  v5 = v10 == 1;
  if (v10 != 1)
  {
    v11 = (id *)(v6 + 16);
    v12 = objc_loadWeakRetained(v11);
    if (!v12
      || (v13 = v12,
          v14 = objc_loadWeakRetained(v11),
          v15 = v14[475],
          v14,
          v13,
          (v15 & 1) == 0))
    {
      v16 = objc_loadWeakRetained(v11);
      if (v16)
      {
        v17 = objc_loadWeakRetained(v11);
        v18 = (v17[475] & 1) == 0;

      }
      else
      {
        v18 = 1;
      }

      if (v18)
      {
        if (g_boringssl_log)
        {
          v29 = (id)g_boringssl_log;
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            boringssl_context_set_quic_transport_parameters_cold_2(v11, v29);

        }
      }
    }
  }
  free(v9);
LABEL_23:

  return v5;
}

void *boringssl_helper_create_buffer_from_dispatch_data(void *a1)
{
  NSObject *v1;
  NSObject *v2;
  size_t size;
  void *v4;

  v1 = a1;
  v2 = v1;
  if (!v1)
    goto LABEL_5;
  size = dispatch_data_get_size(v1);
  v4 = malloc_type_malloc(size, 0x4AACE611uLL);
  if (v4 && boringssl_helper_dispatch_data_copyout(v2, (uint64_t)v4, size) != size)
  {
    free(v4);
LABEL_5:
    v4 = 0;
  }

  return v4;
}

uint64_t boringssl_helper_dispatch_data_copyout(NSObject *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD applier[7];
  _QWORD v6[4];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x2020000000;
  v6[3] = a2;
  if (a1)
  {
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = __boringssl_helper_dispatch_data_copyout_block_invoke;
    applier[3] = &unk_1E686F3D0;
    applier[5] = v6;
    applier[6] = a3;
    applier[4] = &v7;
    dispatch_data_apply(a1, applier);
    v3 = v8[3];
  }
  else
  {
    v3 = 0;
  }
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v7, 8);
  return v3;
}

BOOL __boringssl_helper_dispatch_data_copyout_block_invoke(_QWORD *a1, int a2, int a3, void *__src, size_t a5)
{
  unint64_t v5;
  unint64_t v6;
  size_t v7;

  v5 = a1[6];
  v6 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  if (v5 - v6 >= a5)
    v7 = a5;
  else
    v7 = v5 - v6;
  if (v7)
  {
    memcpy((void *)(*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) + v6), __src, v7);
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) += v7;
    v6 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
    v5 = a1[6];
  }
  return v6 < v5;
}

uint64_t SSL_set_quic_transport_params(uint64_t a1, const void *a2, unint64_t a3)
{
  uint64_t v3;
  void **v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return 0;
  v6 = (void **)(v3 + 240);
  v7 = bssl::Array<unsigned char>::Init(v3 + 240, a3);
  v8 = v7;
  if (a3 && (_DWORD)v7)
    memcpy(*v6, a2, a3);
  return v8;
}

uint64_t bssl::ssl_parse_cert_chain(char *a1, unint64_t **a2, EVP_PKEY **a3, unsigned __int8 *a4, unsigned __int8 **a5, _QWORD **a6)
{
  EVP_PKEY *v12;
  uint64_t v13;
  _BOOL8 v14;
  EVP_PKEY *v15;
  const unsigned __int8 *v16;
  size_t v17;
  unsigned int *v18;
  char v19;
  unint64_t *v20;
  EVP_PKEY *v22;
  __int128 v23;
  EVP_PKEY *v24;
  STACK *st;
  unsigned __int8 *v26[2];

  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](a2, 0);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](a3, 0);
  v26[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  v26[1] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_u24_length_prefixed(a5, (unint64_t *)v26))
  {
    if (CBS_len((uint64_t)v26))
    {
      st = sk_new_null();
      if (st)
      {
        v12 = 0;
        v24 = 0;
        while (1)
        {
          v13 = CBS_len((uint64_t)v26);
          v14 = v13 == 0;
          if (!v13)
            break;
          *(_QWORD *)&v23 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_u24_length_prefixed(v26, (unint64_t *)&v23) || !CBS_len((uint64_t)&v23))
          {
            *a1 = 50;
            ERR_put_error(16, 0, 127, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 391);
            goto LABEL_25;
          }
          if (!sk_num(st))
          {
            bssl::ssl_cert_parse_pubkey(&v23, &v22);
            v15 = v22;
            v22 = 0;
            v24 = v15;
            if (v12)
            {
              EVP_PKEY_free(v12);
              v12 = v24;
              if (!v24)
                goto LABEL_29;
            }
            else
            {
              v12 = v15;
              if (!v15)
              {
LABEL_29:
                v19 = 50;
                goto LABEL_19;
              }
            }
            if (a4)
            {
              v16 = (const unsigned __int8 *)CBS_data((uint64_t)&v23);
              v17 = CBS_len((uint64_t)&v23);
              SHA256(v16, v17, a4);
            }
          }
          v18 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v23, a6);
          if (!v18)
            goto LABEL_18;
          v22 = 0;
          if (!sk_push(st, (char *)v18))
          {
            CRYPTO_BUFFER_free(v18);
LABEL_18:
            v19 = 80;
LABEL_19:
            *a1 = v19;
            goto LABEL_25;
          }
        }
        v20 = (unint64_t *)st;
        st = 0;
        std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](a2, v20);
        v24 = 0;
        std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](a3, v12);
        v12 = v24;
LABEL_25:
        v24 = 0;
        if (v12)
          EVP_PKEY_free(v12);
      }
      else
      {
        v14 = 0;
        *a1 = 80;
      }
      std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&st, 0);
    }
    else
    {
      return 1;
    }
  }
  else
  {
    *a1 = 50;
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 371);
    return 0;
  }
  return v14;
}

void sub_1B4F83434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  EVP_PKEY *v6;
  va_list va;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, EVP_PKEY *);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)va, 0);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)va1, 0);
  _Unwind_Resume(a1);
}

void bssl::SSL_HANDSHAKE::~SSL_HANDSHAKE(bssl::SSL_HANDSHAKE *this)
{
  uint64_t i;

  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 120) + 8) + 80))();
  std::unique_ptr<bssl::SSL_HANDSHAKE_HINTS,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)this + 199, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 1576);
  std::unique_ptr<bssl::ECHConfig,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)this + 195, 0);
  std::unique_ptr<ssl_ech_keys_st,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)this + 194, 0);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)this + 193, 0);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)this + 192, 0);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)this + 191, 0);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)this + 190, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 1504);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)this + 186, 0);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)this + 185, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 1464);
  EVP_HPKE_CTX_cleanup((uint64_t)this + 736);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 712);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 696);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 680);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 664);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 648);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 632);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 616);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 600);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 584);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 568);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 552);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 536);
  bssl::SSLTranscript::~SSLTranscript((bssl::SSL_HANDSHAKE *)((char *)this + 464));
  bssl::SSLTranscript::~SSLTranscript((bssl::SSL_HANDSHAKE *)((char *)this + 424));
  for (i = 400; i != 384; i -= 8)
    std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)((char *)this + i), 0);
  std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)this + 48, 0);
}

uint64_t bssl::Array<unsigned char>::~Array(uint64_t a1)
{
  OPENSSL_free(*(_QWORD **)a1);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  return a1;
}

uint64_t bssl::tls13_process_certificate(uint64_t *a1, uint64_t a2, char a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int16 *v20;
  uint64_t v21;
  unsigned int (*v22)(uint64_t, unsigned int **, uint64_t, uint64_t, uint64_t);
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  EVP_PKEY *v36;
  EVP_PKEY *v37;
  EVP_PKEY *v38;
  const unsigned __int8 *v39;
  size_t v40;
  unsigned int *v41;
  int v42;
  int v43;
  int u8;
  int v45;
  uint64_t v46;
  unsigned int *v47;
  unsigned int *v48;
  uint64_t v49;
  unsigned int *v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  EVP_PKEY *v67;
  unint64_t **v68;
  unint64_t *v69;
  unint64_t **v70;
  unint64_t *v71;
  char v72;
  int v73;
  int v74;
  int v75;
  unsigned int *v76;
  unsigned int *v77;
  char v78;
  unsigned __int8 v79;
  unsigned int *v80[3];
  EVP_PKEY *v81[3];
  unsigned int *v82;
  unsigned int *v83;
  __int128 v84[2];
  EVP_PKEY *v85;
  STACK *v86;
  STACK *st;
  unsigned __int8 *v88[4];
  unsigned int *v89;
  __int128 v90;
  EVP_PKEY **v91;
  unsigned int **v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  v5 = *a1;
  v90 = *(_OWORD *)(a2 + 8);
  v89 = 0;
  v6 = *(unsigned __int8 *)(a2 + 1);
  if (v6 == 25)
  {
    v81[0] = (EVP_PKEY *)0xAAAAAAAAAAAAAAAALL;
    v81[1] = (EVP_PKEY *)0xAAAAAAAAAAAAAAAALL;
    LOWORD(v88[0]) = -21846;
    LODWORD(v88[2]) = -1431655766;
    if (!CBS_get_u16((unsigned __int16 **)&v90, v88)
      || !CBS_get_u24((uint64_t *)&v90, (int *)&v88[2])
      || !CBS_get_u24_length_prefixed((unsigned __int8 **)&v90, (unint64_t *)v81)
      || CBS_len((uint64_t)&v90))
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 144);
LABEL_7:
      v7 = 0;
      goto LABEL_12;
    }
    v10 = LODWORD(v88[2]);
    if (LODWORD(v88[2]) > *(_DWORD *)(v5 + 152))
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
      ERR_put_error(16, 0, 293, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 150);
      ERR_add_error_dataf("requested=%u", v11, v12, v13, v14, v15, v16, v17, (char)v88[2]);
      goto LABEL_7;
    }
    v18 = *(_QWORD *)(v5 + 120);
    v19 = *(_QWORD *)(v18 + 720);
    if (!v19)
      goto LABEL_33;
    v20 = (unsigned __int16 *)(*(_QWORD *)(v18 + 728) + 16);
    v21 = 24 * v19;
    while (*v20 != LOWORD(v88[0]))
    {
      v20 += 12;
      v21 -= 24;
      if (!v21)
        goto LABEL_33;
    }
    v22 = (unsigned int (*)(uint64_t, unsigned int **, uint64_t, uint64_t, uint64_t))*((_QWORD *)v20 - 1);
    if (!v22)
    {
LABEL_33:
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
      ERR_put_error(16, 0, 294, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 166);
      ERR_add_error_dataf("alg=%d", v28, v29, v30, v31, v32, v33, v34, (char)v88[0]);
      goto LABEL_7;
    }
    v80[0] = 0;
    v23 = CBS_data((uint64_t)v81);
    v24 = CBS_len((uint64_t)v81);
    if (!v22(v5, v80, v10, v23, v24))
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
      ERR_put_error(16, 0, 292, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 175);
      ERR_add_error_dataf("alg=%d", v52, v53, v54, v55, v56, v57, v58, (char)v88[0]);
      goto LABEL_7;
    }
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v89, v80[0]);
    v25 = CRYPTO_BUFFER_len((uint64_t)v80[0]);
    if (v25 != LODWORD(v88[2]))
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
      ERR_put_error(16, 0, 292, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 183);
      v59 = (char)v88[0];
      CRYPTO_BUFFER_len((uint64_t)v80[0]);
      ERR_add_error_dataf("alg=%d got=%u expected=%u", v60, v61, v62, v63, v64, v65, v66, v59);
      goto LABEL_7;
    }
    v26 = CRYPTO_BUFFER_data((uint64_t)v80[0]);
    v27 = CRYPTO_BUFFER_len((uint64_t)v80[0]);
    CBS_init(&v90, v26, v27);
  }
  else if (v6 != 11)
  {
    __assert_rtn("tls13_process_certificate", "tls13_both.cc", 194, "msg.type == SSL3_MT_CERTIFICATE");
  }
  memset(v88, 170, sizeof(v88));
  if (!CBS_get_u8_length_prefixed((unsigned __int8 **)&v90, (unint64_t *)&v88[2])
    || CBS_len((uint64_t)&v88[2])
    || !CBS_get_u24_length_prefixed((unsigned __int8 **)&v90, (unint64_t *)v88)
    || CBS_len((uint64_t)&v90))
  {
    bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 203);
    v7 = 0;
  }
  else
  {
    st = (STACK *)0xAAAAAAAAAAAAAAAALL;
    st = sk_new_null();
    if (st)
    {
      v86 = (STACK *)0xAAAAAAAAAAAAAAAALL;
      v86 = sk_new_null();
      if (v86)
      {
        if ((*(_BYTE *)(v5 + 180) & 1) != 0)
          v75 = (*(unsigned __int16 *)(a1[1] + 313) >> 5) & 1;
        else
          v75 = 0;
        v85 = 0;
        while (CBS_len((uint64_t)v88))
        {
          memset(v84, 170, sizeof(v84));
          if (!CBS_get_u24_length_prefixed(v88, (unint64_t *)&v84[1])
            || !CBS_get_u16_length_prefixed(v88, (unint64_t *)v84)
            || !CBS_len((uint64_t)&v84[1]))
          {
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
            v73 = 231;
            v51 = 127;
LABEL_80:
            ERR_put_error(16, 0, v51, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", v73);
            goto LABEL_101;
          }
          v35 = *((_DWORD *)a1 + 400);
          if ((v35 & 0x400000) != 0 && *((_BYTE *)a1 + 730) == 2)
          {
            v36 = EVP_parse_public_key(&v84[1]);
            v81[0] = 0;
            std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](&v85, v36);
            std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](v81, 0);
            if (!v85)
            {
              bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
              v73 = 240;
LABEL_112:
              v51 = 137;
              goto LABEL_80;
            }
          }
          else if ((v35 & 0x800000) != 0 && *((_BYTE *)a1 + 731) == 2)
          {
            v37 = EVP_parse_public_key(&v84[1]);
            v81[0] = 0;
            std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](&v85, v37);
            std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](v81, 0);
            if (!v85)
            {
              bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
              v73 = 250;
              goto LABEL_112;
            }
          }
          else if (!sk_num(st))
          {
            bssl::ssl_cert_parse_pubkey(&v84[1], v81);
            v38 = v81[0];
            v81[0] = 0;
            std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](&v85, v38);
            std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](v81, 0);
            if (!v85)
            {
              bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
              v73 = 259;
              goto LABEL_112;
            }
            if ((bssl::ssl_cert_check_key_usage(&v84[1], 0) & 1) == 0)
            {
              bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
              goto LABEL_101;
            }
            if (v75)
            {
              v39 = (const unsigned __int8 *)CBS_data((uint64_t)&v84[1]);
              v40 = CBS_len((uint64_t)&v84[1]);
              SHA256(v39, v40, (unsigned __int8 *)(a1[192] + 280));
            }
          }
          v41 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v84[1], *(_QWORD ***)(*(_QWORD *)(v5 + 120) + 792));
          v83 = v41;
          if (!v41)
            goto LABEL_94;
          v82 = v41;
          v83 = 0;
          if (!sk_push(st, (char *)v41))
          {
            std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v82, 0);
LABEL_94:
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 80);
            goto LABEL_101;
          }
          v82 = 0;
          std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v82, 0);
          memset(v81, 170, sizeof(v81));
          if ((*(_BYTE *)(v5 + 180) & 1) != 0)
            LOBYTE(v42) = 0;
          else
            v42 = (*(unsigned __int16 *)(a1[1] + 313) >> 2) & 1;
          LOWORD(v81[0]) = 5;
          WORD1(v81[0]) = v42;
          CBS_init(&v81[1], 0, 0);
          memset(v80, 170, sizeof(v80));
          if ((*(_BYTE *)(v5 + 180) & 1) != 0)
            LOBYTE(v43) = 0;
          else
            v43 = (*(unsigned __int16 *)(a1[1] + 313) >> 1) & 1;
          LOWORD(v80[0]) = 18;
          WORD1(v80[0]) = v43;
          CBS_init(&v80[1], 0, 0);
          v79 = 50;
          v91 = v81;
          v92 = v80;
          if ((bssl::ssl_parse_extensions(v84, (char *)&v79, (uint64_t *)&v91, 2, 0) & 1) == 0)
          {
            v45 = v79;
            goto LABEL_98;
          }
          if (BYTE3(v81[0]))
          {
            v78 = -86;
            v91 = (EVP_PKEY **)0xAAAAAAAAAAAAAAAALL;
            v92 = (unsigned int **)0xAAAAAAAAAAAAAAAALL;
            u8 = CBS_get_u8(&v81[1], &v78);
            v45 = 50;
            if (!u8 || v78 != 1)
              goto LABEL_98;
            if (!CBS_get_u24_length_prefixed((unsigned __int8 **)&v81[1], (unint64_t *)&v91)
              || !CBS_len((uint64_t)&v91)
              || CBS_len((uint64_t)&v81[1]))
            {
              v45 = 50;
              goto LABEL_98;
            }
            if (sk_num(st) == 1)
            {
              v46 = a1[192];
              v47 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v91, *(_QWORD ***)(*(_QWORD *)(v5 + 120) + 792));
              std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)(v46 + 264), v47);
              if (!*(_QWORD *)(a1[192] + 264))
              {
                v45 = 80;
                goto LABEL_98;
              }
            }
            v77 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
            v48 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v91, *(_QWORD ***)(*(_QWORD *)(v5 + 120) + 792));
            v77 = v48;
            if (!v48)
              goto LABEL_100;
            v76 = v48;
            v77 = 0;
            if (!sk_push(v86, (char *)v48))
            {
              std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v76, 0);
LABEL_100:
              bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 80);
              ERR_put_error(16, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 328);
              std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v77, 0);
LABEL_101:
              v7 = 0;
              goto LABEL_102;
            }
            v76 = 0;
            std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v76, 0);
            std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v77, 0);
          }
          if (BYTE3(v80[0]))
          {
            if ((bssl::ssl_is_sct_list_valid((__int128 *)&v80[1]) & 1) == 0)
            {
              ERR_put_error(16, 0, 149, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 336);
              v45 = 50;
              goto LABEL_98;
            }
            if (sk_num(st) == 1)
            {
              v49 = a1[192];
              v50 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v80[1], *(_QWORD ***)(*(_QWORD *)(v5 + 120) + 792));
              std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)(v49 + 256), v50);
              if (!*(_QWORD *)(a1[192] + 256))
              {
                v45 = 80;
                goto LABEL_98;
              }
            }
          }
        }
        if (!sk_num(st))
          std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&st, 0);
        v67 = v85;
        v85 = 0;
        std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)a1 + 191, v67);
        v68 = (unint64_t **)(a1[192] + 144);
        v69 = (unint64_t *)st;
        st = 0;
        std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](v68, v69);
        v70 = (unint64_t **)(a1[192] + 272);
        v71 = (unint64_t *)v86;
        v86 = 0;
        std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](v70, v71);
        if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(v5 + 120) + 8) + 48))(a1[192]) & 1) == 0)
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 365);
          v45 = 50;
          goto LABEL_98;
        }
        if (sk_num(*(const STACK **)(a1[192] + 144)))
        {
          if (v75)
            v72 = 2;
          else
            v72 = 0;
          *(_BYTE *)(a1[192] + 448) = *(_BYTE *)(a1[192] + 448) & 0xFD | v72;
        }
        else
        {
          if ((a3 & 1) == 0)
          {
            v74 = *((_DWORD *)a1 + 400);
            if (((v74 & 0x400000) == 0 || *((_BYTE *)a1 + 730) != 2)
              && ((v74 & 0x800000) == 0 || *((_BYTE *)a1 + 731) != 2))
            {
              ERR_put_error(16, 0, 192, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 380);
              v45 = 116;
LABEL_98:
              bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, v45);
              goto LABEL_101;
            }
          }
          *(_QWORD *)(a1[192] + 184) = 0;
        }
        v7 = 1;
LABEL_102:
        std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](&v85, 0);
      }
      else
      {
        bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 80);
        ERR_put_error(16, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 217);
        v7 = 0;
      }
      std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&v86, 0);
    }
    else
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 80);
      v7 = 0;
    }
    std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&st, 0);
  }
LABEL_12:
  v8 = v89;
  v89 = 0;
  if (v8)
    CRYPTO_BUFFER_free(v8);
  return v7;
}

void sub_1B4F8409C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, unsigned int *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,unsigned int *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,EVP_PKEY *a29,unint64_t *a30,unint64_t *a31)
{
  uint64_t v31;

  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&a15, 0);
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&a24, 0);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](&a29, 0);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](&a30, 0);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](&a31, 0);
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)(v31 - 136), 0);
  _Unwind_Resume(a1);
}

uint64_t cbs_get_length_prefixed(unsigned __int8 **a1, unint64_t *a2, unint64_t a3)
{
  unint64_t v3;
  BOOL v4;
  unint64_t v5;
  unsigned __int8 *v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;

  v3 = (unint64_t)a1[1];
  v4 = v3 >= a3;
  v5 = v3 - a3;
  if (!v4)
    return 0;
  v6 = *a1;
  v7 = (unint64_t)&(*a1)[a3];
  *a1 = (unsigned __int8 *)v7;
  a1[1] = (unsigned __int8 *)v5;
  v8 = 0;
  if (a3)
  {
    do
    {
      v9 = *v6++;
      v8 = v9 | (v8 << 8);
      --a3;
    }
    while (a3);
    if (v5 < v8)
      return 0;
  }
  *a1 = (unsigned __int8 *)(v7 + v8);
  a1[1] = (unsigned __int8 *)(v5 - v8);
  *a2 = v7;
  a2[1] = v8;
  return 1;
}

uint64_t bssl::ssl_parse_extensions(__int128 *a1, char *a2, uint64_t *a3, uint64_t a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  _WORD *v18;
  char v19;
  __int128 v21;
  __int16 v22;
  __int128 v23;

  v10 = 8 * a4;
  if (a4)
  {
    v11 = 8 * a4;
    v12 = a3;
    do
    {
      v13 = *v12;
      *(_BYTE *)(v13 + 3) = 0;
      CBS_init((_QWORD *)(v13 + 8), 0, 0);
      if (*(_BYTE *)(v13 + 2))
        v14 = 1;
      else
        v14 = a5 == 0;
      if (!v14)
        bssl::ssl_parse_extensions();
      ++v12;
      v11 -= 8;
    }
    while (v11);
  }
  v23 = *a1;
  v15 = 1;
  if (!CBS_len((uint64_t)&v23))
    return v15;
  while (1)
  {
    v22 = -21846;
    *(_QWORD *)&v21 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (!CBS_get_u16((unsigned __int16 **)&v23, &v22)
      || !CBS_get_u16_length_prefixed((unsigned __int8 **)&v23, (unint64_t *)&v21))
    {
      ERR_put_error(16, 0, 190, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 294);
      v19 = 50;
      goto LABEL_25;
    }
    if (a4)
      break;
LABEL_17:
    if ((a5 & 1) == 0)
    {
      ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 311);
      v19 = 110;
      goto LABEL_25;
    }
LABEL_21:
    if (!CBS_len((uint64_t)&v23))
      return 1;
  }
  v16 = v10;
  v17 = a3;
  while (1)
  {
    v18 = (_WORD *)*v17;
    if (v22 == *(_WORD *)*v17)
    {
      if (*((_BYTE *)v18 + 2))
        break;
    }
    ++v17;
    v16 -= 8;
    if (!v16)
      goto LABEL_17;
  }
  if (!*((_BYTE *)v18 + 3))
  {
    *((_BYTE *)v18 + 3) = 1;
    *(_OWORD *)(v18 + 4) = v21;
    goto LABEL_21;
  }
  ERR_put_error(16, 0, 257, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 318);
  v19 = 47;
LABEL_25:
  v15 = 0;
  *a2 = v19;
  return v15;
}

uint64_t CBS_get_u24_length_prefixed(unsigned __int8 **a1, unint64_t *a2)
{
  return cbs_get_length_prefixed(a1, a2, 3uLL);
}

uint64_t crypto_buffer_new(const void *a1, unint64_t a2, int a3, _QWORD **a4)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  pthread_rwlock_t *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  int v16;
  _QWORD v18[4];

  if (a4)
  {
    v18[2] = a2;
    v18[3] = 0xAAAAAAAAAAAAAAAALL;
    v18[0] = a4;
    v18[1] = a1;
    CRYPTO_MUTEX_lock_read((pthread_rwlock_t *)(a4 + 1));
    v8 = OPENSSL_lh_retrieve(*a4, (uint64_t)v18, (uint64_t (*)(_QWORD, uint64_t))lh_CRYPTO_BUFFER_call_hash_func, (unsigned int (*)(_QWORD, _QWORD, uint64_t))lh_CRYPTO_BUFFER_call_cmp_func);
    v9 = v8;
    if (a3 && v8)
    {
      if (*(_DWORD *)(v8 + 28))
      {
LABEL_5:
        CRYPTO_refcount_inc((unsigned int *)(v8 + 24));
        CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)(a4 + 1));
        return v9;
      }
    }
    else if (v8)
    {
      goto LABEL_5;
    }
    CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)(a4 + 1));
  }
  v10 = OPENSSL_malloc(0x20uLL);
  v9 = (uint64_t)v10;
  if (v10)
  {
    *(_OWORD *)v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    if (a3)
    {
      v10[1] = a1;
      *((_DWORD *)v10 + 7) = 1;
    }
    else
    {
      v14 = OPENSSL_memdup(a1, a2);
      *(_QWORD *)(v9 + 8) = v14;
      if (a2 && !v14)
      {
        OPENSSL_free((_QWORD *)v9);
        return 0;
      }
    }
    *(_QWORD *)(v9 + 16) = a2;
    *(_DWORD *)(v9 + 24) = 1;
    if (a4)
    {
      *(_QWORD *)v9 = a4;
      v11 = (pthread_rwlock_t *)(a4 + 1);
      CRYPTO_MUTEX_lock_write((pthread_rwlock_t *)(a4 + 1));
      v12 = OPENSSL_lh_retrieve(*a4, v9, (uint64_t (*)(_QWORD, uint64_t))lh_CRYPTO_BUFFER_call_hash_func, (unsigned int (*)(_QWORD, _QWORD, uint64_t))lh_CRYPTO_BUFFER_call_cmp_func);
      v13 = v12;
      if (a3 && v12)
      {
        if (*(_DWORD *)(v12 + 28))
        {
LABEL_15:
          CRYPTO_refcount_inc((unsigned int *)(v12 + 24));
          CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)(a4 + 1));
LABEL_16:
          crypto_buffer_free_object((_QWORD **)v9);
          return v13;
        }
      }
      else if (v12)
      {
        goto LABEL_15;
      }
      v15 = *a4;
      v18[0] = 0;
      v16 = OPENSSL_lh_insert(v15, v18, v9, (uint64_t (*)(_QWORD, uint64_t))lh_CRYPTO_BUFFER_call_hash_func, (unsigned int (*)(_QWORD, _QWORD, uint64_t))lh_CRYPTO_BUFFER_call_cmp_func);
      CRYPTO_MUTEX_unlock_read(v11);
      if (v16)
        return v9;
      v13 = 0;
      goto LABEL_16;
    }
  }
  return v9;
}

_QWORD *OPENSSL_memdup(const void *a1, unint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  if (!a2)
    return 0;
  v4 = OPENSSL_malloc(a2);
  v5 = v4;
  if (v4)
    memcpy(v4, a1, a2);
  return v5;
}

uint64_t CRYPTO_BUFFER_new_from_CBS(uint64_t a1, _QWORD **a2)
{
  const void *v4;
  unint64_t v5;

  v4 = (const void *)CBS_data(a1);
  v5 = CBS_len(a1);
  return crypto_buffer_new(v4, v5, 0, a2);
}

uint64_t bssl::ssl_create_cipher_list(bssl::SSLCipherPreferenceList **a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  char *v12;
  unint64_t v13;
  _QWORD *v14;
  char *v15;
  uint64_t *v16;
  uint64_t is_opaque;
  int v18;
  int v19;
  STACK *v20;
  _QWORD *v21;
  uint64_t *v22;
  unint64_t v23;
  bssl::SSLCipherPreferenceList *v24;
  unint64_t v25;
  char v26;
  bssl::SSLCipherPreferenceList *v27;
  STACK *v29;
  bssl::SSLCipherPreferenceList *v30;
  STACK *v31;
  _QWORD *v32;
  uint64_t *v33;
  _QWORD *v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;

  v3 = 0;
  if (a1)
  {
    v4 = a2;
    if (a2)
    {
      v34 = 0;
      v35 = 0;
      v32 = 0;
      v33 = 0;
      OPENSSL_free(0);
      v37 = 0;
      v7 = OPENSSL_malloc(0x4A0uLL);
      v8 = v7;
      v36 = v7;
      if (v7)
      {
        v9 = 0;
        v10 = 0;
        v37 = 37;
        do
        {
          if (HIDWORD(bssl::kCiphers[v9 + 2]) != 16)
          {
            v11 = &v7[4 * (_QWORD)v10];
            *v11 = &bssl::kCiphers[v9];
            *((_WORD *)v11 + 4) = 0;
            v10 = (_QWORD *)((char *)v10 + 1);
            v11[2] = 0;
            v11[3] = 0;
          }
          v9 += 5;
        }
        while (v9 != 185);
        if (v10)
        {
          v12 = 0;
          v7[3] = 0;
          v13 = (unint64_t)v10 - 1;
          if (v10 != (_QWORD *)1)
          {
            v7[2] = v7 + 4;
            if (v13 >= 2)
            {
              v14 = v7 + 8;
              v15 = (char *)v10 - 2;
              do
              {
                *(v14 - 2) = v14;
                *(v14 - 1) = v14 - 8;
                v14 += 4;
                --v15;
              }
              while (v15);
            }
            v7[4 * v13 + 3] = &v7[4 * (_QWORD)v10 - 8];
            v12 = (char *)v10 - 1;
          }
          v10 = &v7[4 * (_QWORD)v12];
          v10[2] = 0;
          v16 = v7;
        }
        else
        {
          v16 = 0;
        }
        v32 = v10;
        v33 = v16;
        OPENSSL_free(0);
        v34 = v8;
        v35 = 37;
      }
      OPENSSL_free(0);
      if (!v8)
        goto LABEL_36;
      bssl::ssl_cipher_apply_rule(0, 2, 2, -1, -1, 0, 1, -1, 0, &v33, &v32);
      bssl::ssl_cipher_apply_rule(0, 2, -1, -1, -1, 0, 1, -1, 0, &v33, &v32);
      bssl::ssl_cipher_apply_rule(0, -1, -1, -1, -1, 0, 3, -1, 0, &v33, &v32);
      is_opaque = RSA_is_opaque();
      if ((_DWORD)is_opaque)
      {
        bssl::ssl_cipher_apply_rule(0, -1, -1, 8, -1, 0, 1, -1, 0, &v33, &v32);
        bssl::ssl_cipher_apply_rule(0, -1, -1, 16, -1, 0, 1, -1, 0, &v33, &v32);
        v18 = 64;
      }
      else
      {
        bssl::ssl_cipher_apply_rule(is_opaque, -1, -1, 64, -1, 0, 1, -1, 0, &v33, &v32);
        bssl::ssl_cipher_apply_rule(0, -1, -1, 8, -1, 0, 1, -1, 0, &v33, &v32);
        v18 = 16;
      }
      bssl::ssl_cipher_apply_rule(0, -1, -1, v18, -1, 0, 1, -1, 0, &v33, &v32);
      bssl::ssl_cipher_apply_rule(0, -1, -1, 2, -1, 0, 1, -1, 0, &v33, &v32);
      bssl::ssl_cipher_apply_rule(0, -1, -1, 4, -1, 0, 1, -1, 0, &v33, &v32);
      bssl::ssl_cipher_apply_rule(0, -1, -1, 1, -1, 0, 1, -1, 0, &v33, &v32);
      bssl::ssl_cipher_apply_rule(0, -1, -1, -1, -1, 0, 1, -1, 0, &v33, &v32);
      bssl::ssl_cipher_apply_rule(0, 9, -1, -1, -1, 0, 4, -1, 0, &v33, &v32);
      bssl::ssl_cipher_apply_rule(0, -1, -1, -1, -1, 0, 3, -1, 0, &v33, &v32);
      if (!strncmp((const char *)v4, "DEFAULT", 7uLL))
      {
        if ((bssl::ssl_cipher_process_rulestr("ALL", &v33, &v32, a3) & 1) == 0)
          goto LABEL_36;
        v19 = *(unsigned __int8 *)(v4 + 7);
        v4 += 7;
        if (v19 == 58)
          ++v4;
      }
      if (!*(_BYTE *)v4 || bssl::ssl_cipher_process_rulestr((char *)v4, &v33, &v32, a3))
      {
        v20 = sk_new_null();
        v31 = v20;
        v36 = 0;
        v37 = 0;
        if (v20)
        {
          OPENSSL_free(0);
          v36 = 0;
          v37 = 0;
          v21 = OPENSSL_malloc(0x25uLL);
          v36 = v21;
          if (v21)
          {
            v37 = 37;
            v22 = v33;
            if (v33)
            {
              v23 = 0;
              do
              {
                if (*((_BYTE *)v22 + 8))
                {
                  if (!sk_push(v20, (char *)*v22))
                    goto LABEL_38;
                  *((_BYTE *)v21 + v23++) = *((_BYTE *)v22 + 9);
                }
                v22 = (uint64_t *)v22[2];
              }
              while (v22);
            }
            else
            {
              v23 = 0;
            }
            v24 = (bssl::SSLCipherPreferenceList *)OPENSSL_malloc(0x10uLL);
            if (v24)
            {
              *(_QWORD *)v24 = 0;
              *((_QWORD *)v24 + 1) = 0;
              v30 = v24;
              v31 = 0;
              if (v23 >= 0x25)
                v25 = 37;
              else
                v25 = v23;
              v29 = v20;
              v26 = bssl::SSLCipherPreferenceList::Init((uint64_t)v24, (const STACK **)&v29, v21, v25);
              std::unique_ptr<stack_st_SSL_CIPHER,bssl::internal::Deleter>::reset[abi:ne180100](&v29, 0);
              if ((v26 & 1) != 0)
              {
                v27 = v30;
                v30 = 0;
                std::unique_ptr<bssl::SSLCipherPreferenceList,bssl::internal::Deleter>::reset[abi:ne180100](a1, v27);
                if (sk_num(*(const STACK **)*a1))
                {
                  v20 = 0;
                  v3 = 1;
LABEL_50:
                  std::unique_ptr<bssl::SSLCipherPreferenceList,bssl::internal::Deleter>::reset[abi:ne180100](&v30, 0);
LABEL_51:
                  OPENSSL_free(v21);
                  v31 = 0;
                  if (v20)
                  {
                    sk_free(v20);
                    v8 = v34;
                  }
                  goto LABEL_53;
                }
                ERR_put_error(16, 0, 177, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cipher.cc", 1451);
              }
              v20 = 0;
              v3 = 0;
              goto LABEL_50;
            }
            v3 = 0;
            v30 = 0;
            goto LABEL_50;
          }
        }
        else
        {
          v21 = 0;
        }
LABEL_38:
        v3 = 0;
        goto LABEL_51;
      }
LABEL_36:
      v3 = 0;
LABEL_53:
      OPENSSL_free(v8);
    }
  }
  return v3;
}

void sub_1B4F84BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  bssl::SSLCipherPreferenceList *v7;
  va_list va;
  STACK *v9;
  va_list va1;
  uint64_t v11;
  uint64_t v12;
  va_list va2;

  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  v7 = va_arg(va1, bssl::SSLCipherPreferenceList *);
  va_copy(va2, va1);
  v9 = va_arg(va2, STACK *);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  std::unique_ptr<bssl::SSLCipherPreferenceList,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLCipherPreferenceList **)va, 0);
  bssl::Array<unsigned char>::~Array(v5 - 64);
  std::unique_ptr<stack_st_SSL_CIPHER,bssl::internal::Deleter>::reset[abi:ne180100]((STACK **)va1, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)va2);
  _Unwind_Resume(a1);
}

int sk_push(STACK *st, char *data)
{
  return sk_insert(st, data, *(_QWORD *)&st->num);
}

int sk_insert(STACK *sk, char *data, int where)
{
  unint64_t v3;
  STACK *v5;
  int (__cdecl *comp)(const char *const *, const char *const *);
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  size_t v12;
  char **v13;
  char **v14;

  if (sk)
  {
    v3 = *(_QWORD *)&where;
    v5 = sk;
    comp = sk->comp;
    v7 = *(_QWORD *)&sk->num;
    if ((unint64_t)comp <= *(_QWORD *)&sk->num + 1)
    {
      if (((unint64_t)comp & 0x8000000000000000) != 0
        || (v8 = 2 * ((unint64_t)comp & 0xFFFFFFFFFFFFFFFLL), v8 != 2 * (_QWORD)comp))
      {
        v9 = (unint64_t)comp + 1;
        v10 = 8 * ((_QWORD)comp + 1);
        v8 = ((unint64_t)comp + 1) & 0x1FFFFFFFFFFFFFFFLL;
      }
      else
      {
        v9 = 2 * (_QWORD)comp;
        v10 = 16 * (_QWORD)comp;
      }
      if (v9 < (unint64_t)comp || v8 != v9)
      {
        LODWORD(sk) = 0;
        return (int)sk;
      }
      sk = (STACK *)OPENSSL_realloc(sk->data, v10);
      if (!sk)
        return (int)sk;
      v5->data = (char **)sk;
      v5->comp = (int (__cdecl *)(const char *const *, const char *const *))v9;
      v7 = *(_QWORD *)&v5->num;
    }
    if (v7 <= v3)
    {
      v14 = &v5->data[v7];
    }
    else
    {
      v12 = 8 * (v7 - v3);
      v13 = v5->data;
      if (v12)
      {
        memmove(&v13[v3 + 1], &v13[v3], v12);
        v7 = *(_QWORD *)&v5->num;
        v13 = v5->data;
      }
      v14 = &v13[v3];
    }
    *v14 = data;
    LODWORD(sk) = v7 + 1;
    *(_QWORD *)&v5->num = v7 + 1;
    v5->sorted = 0;
  }
  return (int)sk;
}

STACK *sk_new_null(void)
{
  return sk_new(0);
}

STACK *__cdecl sk_new(int (__cdecl *cmp)(const char *const *, const char *const *))
{
  STACK *v2;
  STACK *v3;
  char **v4;

  v2 = (STACK *)OPENSSL_malloc(0x28uLL);
  v3 = v2;
  if (v2)
  {
    *(_QWORD *)&v2[1].num = 0;
    *(_OWORD *)&v2->num = 0u;
    *(_OWORD *)&v2->sorted = 0u;
    v4 = (char **)OPENSSL_malloc(0x20uLL);
    v3->data = v4;
    if (v4)
    {
      *(_OWORD *)v4 = 0u;
      *((_OWORD *)v4 + 1) = 0u;
      v3->comp = (int (__cdecl *)(const char *const *, const char *const *))4;
      *(_QWORD *)&v3[1].num = cmp;
    }
    else
    {
      OPENSSL_free(v3);
      return 0;
    }
  }
  return v3;
}

uint64_t RSA_is_opaque()
{
  return 1;
}

uint64_t bssl::SSLCipherPreferenceList::Init(uint64_t a1, const STACK **a2, const void *a3, unint64_t a4)
{
  uint64_t v8;
  char v9;
  STACK *v10;
  _QWORD *v11;
  void *__dst;
  uint64_t v14;

  if (sk_num(*a2) == a4)
  {
    __dst = 0;
    v14 = 0;
    v8 = bssl::Array<unsigned char>::Init((uint64_t)&__dst, a4);
    v9 = v8 ^ 1;
    if (!a4)
      v9 = 1;
    if ((v9 & 1) == 0)
      memcpy(__dst, a3, a4);
    if ((v8 & 1) != 0)
    {
      v10 = (STACK *)*a2;
      *a2 = 0;
      std::unique_ptr<stack_st_SSL_CIPHER,bssl::internal::Deleter>::reset[abi:ne180100]((STACK **)a1, v10);
      v11 = 0;
      *(_QWORD *)(a1 + 8) = __dst;
      __dst = 0;
      v14 = 0;
    }
    else
    {
      v11 = __dst;
    }
    OPENSSL_free(v11);
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cipher.cc", 939);
    return 0;
  }
  return v8;
}

void sub_1B4F84E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void bssl::SSL_SESSION_dup(bssl *this@<X0>, ssl_session_st *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _QWORD *v6;
  _QWORD *v7;
  int v8;
  size_t v9;
  const char *v10;
  _QWORD *v11;
  STACK *v12;
  unint64_t *v13;
  unsigned int *v14;
  unsigned int *v15;
  __int128 v16;
  const void *v17;
  unint64_t v18;
  int v19;
  char v20;
  char v21;
  size_t v22;
  char v23;
  char v24;
  const void *v25;
  unint64_t v26;
  int v27;
  char v28;
  const void *v29;
  unint64_t v30;
  int v31;
  char v32;
  const void *v33;
  unint64_t v34;
  int v35;
  char v36;
  const void *v37;
  unint64_t v38;
  char v39;
  char v40;
  void *v41;

  v3 = (char)a2;
  v41 = (void *)*((_QWORD *)this + 19);
  v6 = bssl::New<ssl_session_st,bssl::SSL_X509_METHOD const*&>(&v41);
  v7 = v6;
  if (!v6)
    goto LABEL_23;
  v8 = v6[56] & 0xEF | (16 * ((*((unsigned __int8 *)this + 448) >> 4) & 1));
  *((_BYTE *)v6 + 448) = v8;
  *((_WORD *)v6 + 2) = *((_WORD *)this + 2);
  *((_BYTE *)v6 + 448) = *((_BYTE *)this + 448) & 0x20 | v8 & 0xDF;
  *((_BYTE *)v6 + 100) = *((_BYTE *)this + 100);
  if (*((_BYTE *)this + 100))
    memcpy((char *)v6 + 101, (char *)this + 101, *((unsigned __int8 *)this + 100));
  *((_DWORD *)v7 + 3) = *((_DWORD *)this + 3);
  v9 = *((int *)this + 3);
  if ((_DWORD)v9)
    memcpy(v7 + 2, (char *)this + 16, v9);
  v7[26] = *((_QWORD *)this + 26);
  v10 = (const char *)*((_QWORD *)this + 17);
  if (!v10
    || (v11 = OPENSSL_strdup(v10),
        std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)v7 + 17, v11),
        v7[17]))
  {
    v12 = (STACK *)*((_QWORD *)this + 18);
    if (!v12
      || (v13 = (unint64_t *)sk_deep_copy(v12, (uint64_t (*)(uint64_t))sk_CRYPTO_BUFFER_call_copy_func, (uint64_t)bssl::SSL_SESSION_dup(ssl_session_st *,int)::$_0::__invoke, (void (*)(uint64_t))sk_CRYPTO_BUFFER_call_free_func, (uint64_t)CRYPTO_BUFFER_free), std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)v7 + 18, v13), v7[18]))
    {
      if ((*(unsigned int (**)(_QWORD *, bssl *))(*((_QWORD *)this + 19) + 56))(v7, this))
      {
        v7[23] = *((_QWORD *)this + 23);
        v14 = (unsigned int *)*((_QWORD *)this + 33);
        if (v14)
          CRYPTO_BUFFER_up_ref(*((_QWORD *)this + 33));
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)v7 + 33, v14);
        v15 = (unsigned int *)*((_QWORD *)this + 32);
        if (v15)
          CRYPTO_BUFFER_up_ref(*((_QWORD *)this + 32));
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)v7 + 32, v15);
        v16 = *(_OWORD *)((char *)this + 296);
        *(_OWORD *)(v7 + 35) = *(_OWORD *)((char *)this + 280);
        *(_OWORD *)(v7 + 37) = v16;
        *((_BYTE *)v7 + 448) = v7[56] & 0xFD | *((_BYTE *)this + 448) & 2;
        *((_WORD *)v7 + 4) = *((_WORD *)this + 4);
        v7[24] = *((_QWORD *)this + 24);
        v7[25] = *((_QWORD *)this + 25);
        if ((v3 & 2) == 0)
          goto LABEL_21;
        *((_DWORD *)v7 + 16) = *((_DWORD *)this + 16);
        v22 = *((unsigned int *)this + 16);
        if ((_DWORD)v22)
          memcpy((char *)v7 + 68, (char *)this + 68, v22);
        *((_WORD *)v7 + 3) = *((_WORD *)this + 3);
        if (*((_BYTE *)this + 376))
        {
          memcpy(v7 + 39, (char *)this + 312, *((unsigned __int8 *)this + 376));
          v23 = *((_BYTE *)this + 376);
        }
        else
        {
          v23 = 0;
        }
        *((_BYTE *)v7 + 376) = v23;
        *((_DWORD *)v7 + 95) = *((_DWORD *)this + 95);
        v7[48] = *((_QWORD *)this + 48);
        v24 = v7[56] & 0xFE | *((_BYTE *)this + 448) & 1;
        *((_BYTE *)v7 + 448) = v24;
        *((_BYTE *)v7 + 448) = v24 & 0xBF | *((_BYTE *)this + 448) & 0x40;
        v25 = (const void *)*((_QWORD *)this + 50);
        v26 = *((_QWORD *)this + 51);
        v27 = bssl::Array<unsigned char>::Init((uint64_t)(v7 + 50), v26);
        v28 = v27 ^ 1;
        if (!v26)
          v28 = 1;
        if ((v28 & 1) == 0)
          memcpy((void *)v7[50], v25, v26);
        if (v27)
        {
          v29 = (const void *)*((_QWORD *)this + 57);
          v30 = *((_QWORD *)this + 58);
          v31 = bssl::Array<unsigned char>::Init((uint64_t)(v7 + 57), v30);
          v32 = v31 ^ 1;
          if (!v30)
            v32 = 1;
          if ((v32 & 1) == 0)
            memcpy((void *)v7[57], v29, v30);
          if (v31)
          {
            v33 = (const void *)*((_QWORD *)this + 52);
            v34 = *((_QWORD *)this + 53);
            v35 = bssl::Array<unsigned char>::Init((uint64_t)(v7 + 52), v34);
            v36 = v35 ^ 1;
            if (!v34)
              v36 = 1;
            if ((v36 & 1) == 0)
              memcpy((void *)v7[52], v33, v34);
            if (v35)
            {
              v37 = (const void *)*((_QWORD *)this + 54);
              v38 = *((_QWORD *)this + 55);
              v39 = bssl::Array<unsigned char>::Init((uint64_t)(v7 + 54), v38);
              v40 = v39 ^ 1;
              if (!v38)
                v40 = 1;
              if ((v40 & 1) == 0)
                memcpy((void *)v7[54], v37, v38);
              if ((v39 & 1) != 0)
              {
LABEL_21:
                if ((v3 & 1) == 0)
                  goto LABEL_22;
                v17 = (const void *)*((_QWORD *)this + 30);
                v18 = *((_QWORD *)this + 31);
                v19 = bssl::Array<unsigned char>::Init((uint64_t)(v7 + 30), v18);
                v20 = v19 ^ 1;
                if (!v18)
                  v20 = 1;
                if ((v20 & 1) == 0)
                  memcpy((void *)v7[30], v17, v18);
                if (v19)
                {
LABEL_22:
                  v21 = *((_BYTE *)v7 + 448) | 4;
                  *((_BYTE *)v7 + 448) = v21;
                  *((_BYTE *)v7 + 448) = *((_BYTE *)this + 448) & 0x80 | v21 & 0x7F;
LABEL_23:
                  *a3 = v7;
                  return;
                }
              }
            }
          }
        }
      }
    }
  }
  *a3 = 0;
  SSL_SESSION_free((SSL_SESSION *)v7);
}

void sub_1B4F8524C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, SSL_SESSION *a9)
{
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](&a9, 0);
  _Unwind_Resume(a1);
}

uint64_t bssl::Array<unsigned char>::Init(uint64_t a1, unint64_t a2)
{
  uint64_t result;

  OPENSSL_free(*(_QWORD **)a1);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  if (a2)
  {
    result = (uint64_t)OPENSSL_malloc(a2);
    *(_QWORD *)a1 = result;
    if (!result)
      return result;
    *(_QWORD *)(a1 + 8) = a2;
  }
  return 1;
}

_QWORD *bssl::New<ssl_session_st,bssl::SSL_X509_METHOD const*&>(void **a1)
{
  _QWORD *result;
  CRYPTO_EX_DATA *v3;

  result = OPENSSL_malloc(0x1D8uLL);
  if (result)
    return (_QWORD *)ssl_session_st::ssl_session_st((uint64_t)result, *a1, v3);
  return result;
}

uint64_t ssl_session_st::ssl_session_st(uint64_t a1, void *a2, CRYPTO_EX_DATA *a3)
{
  *(_QWORD *)a1 = 1;
  *(_WORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_OWORD *)(a1 + 108) = 0u;
  *(_OWORD *)(a1 + 117) = 0u;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = a2;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 65;
  *(int32x2_t *)(a1 + 192) = vdup_n_s32(0x1C20u);
  *(_DWORD *)(a1 + 380) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_DWORD *)(a1 + 388) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 361) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_BYTE *)(a1 + 448) &= 0x80u;
  *(_QWORD *)(a1 + 456) = 0;
  *(_QWORD *)(a1 + 464) = 0;
  *(_DWORD *)(a1 + 384) = 0;
  CRYPTO_new_ex_data(a1 + 216, a2, a3);
  *(_QWORD *)(a1 + 200) = time(0);
  return a1;
}

void sub_1B4F853E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
  _QWORD **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  bssl::Array<unsigned char>::~Array(v13);
  bssl::Array<unsigned char>::~Array(v11 + 432);
  bssl::Array<unsigned char>::~Array(v11 + 416);
  bssl::Array<unsigned char>::~Array(v12);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)(v11 + 272), 0);
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)(v11 + 264), 0);
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)(v11 + 256), 0);
  bssl::Array<unsigned char>::~Array(v11 + 240);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)(v11 + 144), 0);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100](v10, 0);
  _Unwind_Resume(a1);
}

int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
  **(_QWORD **)&class_index = 0;
  return class_index;
}

void ssl_session_st::~ssl_session_st(ssl_session_st *this)
{
  CRYPTO_free_ex_data((int)&bssl::g_ex_data_class, this, (CRYPTO_EX_DATA *)&this->ciphers);
  ((void (*)(ssl_session_st *))this->peer->ex_pcpathlen)(this);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].references);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].sess_cert);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].sid_ctx[20]);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].sid_ctx[4]);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&this->tlsext_ticklen, 0);
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)&this->tlsext_tick, 0);
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)&this->tlsext_hostname, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)&this->prev);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&this->sess_cert, 0);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)&this->sid_ctx[28], 0);
}

void sk_pop_free_ex(unint64_t *a1, void (*a2)(uint64_t), uint64_t a3)
{
  unint64_t v4;
  unint64_t v7;

  if (a1)
  {
    v4 = *a1;
    if (*a1)
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)(a1[1] + 8 * v7))
        {
          a2(a3);
          v4 = *a1;
        }
        ++v7;
      }
      while (v7 < v4);
    }
    OPENSSL_free((_QWORD *)a1[1]);
    OPENSSL_free(a1);
  }
}

void CRYPTO_BUFFER_free(unsigned int *a1)
{
  _QWORD **v2;

  if (a1)
  {
    v2 = *(_QWORD ***)a1;
    if (*(_QWORD *)a1)
    {
      CRYPTO_MUTEX_lock_write((pthread_rwlock_t *)(v2 + 1));
      if (CRYPTO_refcount_dec_and_test_zero(a1 + 6))
      {
        if ((unsigned int *)OPENSSL_lh_retrieve(*v2, (uint64_t)a1, (uint64_t (*)(_QWORD, uint64_t))lh_CRYPTO_BUFFER_call_hash_func, (unsigned int (*)(_QWORD, _QWORD, uint64_t))lh_CRYPTO_BUFFER_call_cmp_func) == a1&& (unsigned int *)OPENSSL_lh_delete(*v2, (uint64_t)a1, (uint64_t (*)(_QWORD, uint64_t))lh_CRYPTO_BUFFER_call_hash_func, (unsigned int (*)(_QWORD, _QWORD, uint64_t))lh_CRYPTO_BUFFER_call_cmp_func) != a1)
        {
          CRYPTO_BUFFER_free_cold_1();
        }
        CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)(*(_QWORD *)a1 + 8));
        goto LABEL_8;
      }
      CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)(*(_QWORD *)a1 + 8));
    }
    else if (CRYPTO_refcount_dec_and_test_zero(a1 + 6))
    {
LABEL_8:
      crypto_buffer_free_object((_QWORD **)a1);
    }
  }
}

BOOL CRYPTO_refcount_dec_and_test_zero(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  int v4;

  v1 = atomic_load(a1);
  while (v1 != -1)
  {
    if (!v1)
      abort();
    v2 = v1 - 1;
    v3 = __ldaxr(a1);
    if (v3 != v1)
    {
      __clrex();
LABEL_8:
      v4 = 0;
      goto LABEL_9;
    }
    if (__stlxr(v2, a1))
      goto LABEL_8;
    v4 = 1;
LABEL_9:
    v1 = v3;
    if (v4)
      return v2 == 0;
  }
  return 0;
}

void bssl::internal::DeleterImpl<stack_st_CRYPTO_BUFFER,void>::Free(stack_st_CRYPTO_BUFFER*)::{lambda(void (*)(void *),void *)#1}::__invoke(uint64_t a1, unsigned int *a2)
{
  CRYPTO_BUFFER_free(a2);
}

void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
  uint64_t v5;
  STACK *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  void *v10;

  if (ad->sk)
  {
    v5 = *(_QWORD *)&class_index;
    CRYPTO_MUTEX_lock_read(*(pthread_rwlock_t **)&class_index);
    if (sk_num(*(const STACK **)(v5 + 200)))
    {
      v6 = sk_dup(*(STACK **)(v5 + 200));
      CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)v5);
      if (!v6)
        return;
    }
    else
    {
      CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)v5);
      v6 = 0;
    }
    if (sk_num(v6) > (*(unsigned __int8 *)(v5 + 208) ^ 0x7FFFFFFFuLL))
      CRYPTO_free_ex_data_cold_1();
    if (sk_num(v6) >= 1)
    {
      v7 = 0;
      do
      {
        v8 = sk_value(v6, v7);
        if (*((_QWORD *)v8 + 2))
        {
          v9 = v8;
          v10 = CRYPTO_get_ex_data(ad, v7 + *(unsigned __int8 *)(v5 + 208));
          (*((void (**)(void *, void *, CRYPTO_EX_DATA *, _QWORD, _QWORD, _QWORD))v9 + 2))(obj, v10, ad, v7 + *(unsigned __int8 *)(v5 + 208), *(_QWORD *)v9, *((_QWORD *)v9 + 1));
        }
        ++v7;
      }
      while (v7 < sk_num(v6));
    }
    sk_free(v6);
    sk_free(ad->sk);
    ad->sk = 0;
  }
}

STACK *sk_deep_copy(STACK *a1, uint64_t (*a2)(uint64_t), uint64_t a3, void (*a4)(uint64_t), uint64_t a5)
{
  STACK *v9;
  STACK *v10;
  unint64_t v11;
  uint64_t v12;
  char **data;
  uint64_t i;

  v9 = sk_dup(a1);
  v10 = v9;
  if (!v9)
    return v10;
  v11 = *(_QWORD *)&v9->num;
  if (!*(_QWORD *)&v9->num)
    return v10;
  v12 = 0;
  data = v9->data;
  while (!data[v12])
  {
LABEL_7:
    if (++v12 >= v11)
      return v10;
  }
  v10->data[v12] = (char *)a2(a3);
  data = v10->data;
  if (data[v12])
  {
    v11 = *(_QWORD *)&v10->num;
    goto LABEL_7;
  }
  if (v12)
  {
    for (i = 0; i != v12; ++i)
    {
      if (v10->data[i])
        a4(a5);
    }
    data = v10->data;
  }
  OPENSSL_free(data);
  OPENSSL_free(v10);
  return 0;
}

uint64_t bssl::SSL_SESSION_dup(ssl_session_st *,int)::$_0::__invoke(uint64_t a1)
{
  CRYPTO_BUFFER_up_ref(a1);
  return a1;
}

uint64_t CRYPTO_BUFFER_up_ref(uint64_t a1)
{
  CRYPTO_refcount_inc((unsigned int *)(a1 + 24));
  return 1;
}

unsigned int *CRYPTO_refcount_inc(unsigned int *result)
{
  unsigned int v1;
  unsigned int v2;
  int v3;

  v1 = atomic_load(result);
  while (v1 != -1)
  {
    v2 = __ldaxr(result);
    if (v2 != v1)
    {
      __clrex();
LABEL_7:
      v3 = 0;
      goto LABEL_8;
    }
    if (__stlxr(v1 + 1, result))
      goto LABEL_7;
    v3 = 1;
LABEL_8:
    v1 = v2;
    if (v3)
      return result;
  }
  return result;
}

uint64_t sk_CRYPTO_BUFFER_call_copy_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

STACK *__cdecl sk_dup(STACK *st)
{
  STACK *v2;
  STACK *v3;
  char **v4;
  size_t v5;
  uint64_t v6;

  if (!st)
    return 0;
  v2 = (STACK *)OPENSSL_malloc(0x28uLL);
  v3 = v2;
  if (!v2)
    return v3;
  *(_QWORD *)&v2[1].num = 0;
  *(_OWORD *)&v2->num = 0u;
  *(_OWORD *)&v2->sorted = 0u;
  v4 = (char **)OPENSSL_malloc(8 * (uint64_t)st->comp);
  v3->data = v4;
  if (!v4)
  {
    OPENSSL_free(0);
    OPENSSL_free(v3);
    return 0;
  }
  *(_QWORD *)&v3->num = *(_QWORD *)&st->num;
  v5 = 8 * *(_QWORD *)&st->num;
  if (v5)
    memcpy(v4, st->data, v5);
  v3->sorted = st->sorted;
  v6 = *(_QWORD *)&st[1].num;
  v3->comp = st->comp;
  *(_QWORD *)&v3[1].num = v6;
  return v3;
}

uint64_t bssl::ssl_noop_x509_session_dup(bssl *this, ssl_session_st *a2, const ssl_session_st *a3)
{
  return 1;
}

BOOL SSL_set_tlsext_host_name(uint64_t a1, const char *a2)
{
  _QWORD **v3;
  _QWORD *v5;

  v3 = (_QWORD **)(a1 + 160);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)(a1 + 160), 0);
  if (!a2)
    return 1;
  if (strlen(a2) - 256 > 0xFFFFFFFFFFFFFF00)
  {
    v5 = OPENSSL_strdup(a2);
    std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100](v3, v5);
    return *v3 != 0;
  }
  else
  {
    ERR_put_error(16, 0, 213, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 2428);
    return 0;
  }
}

_QWORD *OPENSSL_strdup(const char *a1)
{
  unint64_t v2;
  _QWORD *v3;
  _QWORD *v4;

  if (!a1)
    return 0;
  v2 = strlen(a1) + 1;
  v3 = OPENSSL_malloc(v2);
  v4 = v3;
  if (v3 && v2)
    memcpy(v3, a1, v2);
  return v4;
}

void sk_free(STACK *a1)
{
  if (a1)
  {
    OPENSSL_free(a1->data);
    OPENSSL_free(a1);
  }
}

void bssl::SSLCipherPreferenceList::~SSLCipherPreferenceList(bssl::SSLCipherPreferenceList *this)
{
  OPENSSL_free(*((_QWORD **)this + 1));
  std::unique_ptr<stack_st_SSL_CIPHER,bssl::internal::Deleter>::reset[abi:ne180100]((STACK **)this, 0);
}

void crypto_buffer_free_object(_QWORD **a1)
{
  if (!*((_DWORD *)a1 + 7))
    OPENSSL_free(a1[1]);
  OPENSSL_free(a1);
}

uint64_t sk_BIGNUM_call_free_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t bssl::ssl_noop_x509_session_cache_objects(bssl *this, ssl_session_st *a2)
{
  return 1;
}

EVP_PKEY *bssl::ssl_cert_parse_pubkey@<X0>(__int128 *a1@<X0>, EVP_PKEY **a2@<X8>)
{
  EVP_PKEY *result;
  __int128 v4;
  __int128 v5;

  v5 = *a1;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if ((bssl::ssl_cert_skip_to_spki(&v5, &v4) & 1) != 0)
  {
    result = EVP_parse_public_key(&v4);
  }
  else
  {
    ERR_put_error(16, 0, 272, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 497);
    result = 0;
  }
  *a2 = result;
  return result;
}

uint64_t bssl::ssl_cert_skip_to_spki(__int128 *a1, __int128 *a2)
{
  uint64_t result;
  __int128 v4;
  __int128 v5;

  v5 = *a1;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  result = CBS_get_asn1(&v5, &v4, 536870928);
  if ((_DWORD)result)
  {
    if (CBS_len((uint64_t)&v5))
    {
      return 0;
    }
    else
    {
      result = CBS_get_asn1(&v4, a2, 536870928);
      if ((_DWORD)result)
      {
        result = CBS_get_optional_asn1(a2, 0, 0, -1610612736);
        if ((_DWORD)result)
        {
          result = CBS_get_asn1(a2, 0, 2);
          if ((_DWORD)result)
          {
            result = CBS_get_asn1(a2, 0, 536870928);
            if ((_DWORD)result)
            {
              result = CBS_get_asn1(a2, 0, 536870928);
              if ((_DWORD)result)
              {
                result = CBS_get_asn1(a2, 0, 536870928);
                if ((_DWORD)result)
                  return CBS_get_asn1(a2, 0, 536870928) != 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

EVP_PKEY *EVP_parse_public_key(__int128 *a1)
{
  int v1;
  int v2;
  EVP_PKEY *v3;
  EVP_PKEY *v5;
  unsigned int (*v6)(EVP_PKEY *, __int128 *, _QWORD *);
  char v7;
  int v8;
  _QWORD v9[2];
  __int128 v10[2];

  memset(v10, 170, sizeof(v10));
  v9[0] = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = 0xAAAAAAAAAAAAAAAALL;
  v7 = -86;
  if (!CBS_get_asn1(a1, &v10[1], 536870928)
    || !CBS_get_asn1(&v10[1], v10, 536870928)
    || !CBS_get_asn1(&v10[1], v9, 3)
    || CBS_len((uint64_t)&v10[1]))
  {
    v1 = 102;
    v2 = 107;
LABEL_6:
    ERR_put_error(6, 0, v1, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", v2);
    return 0;
  }
  v8 = -1431655766;
  if (!parse_key_type(v10, &v8))
  {
    v1 = 128;
    v2 = 111;
    goto LABEL_6;
  }
  if (!CBS_get_u8(v9, &v7) || v7)
  {
    v1 = 102;
    v2 = 118;
    goto LABEL_6;
  }
  v5 = EVP_PKEY_new();
  v3 = v5;
  if (v5 && EVP_PKEY_set_type((uint64_t)v5, v8))
  {
    v6 = (unsigned int (*)(EVP_PKEY *, __int128 *, _QWORD *))*((_QWORD *)v3->pkey.ptr + 3);
    if (v6)
    {
      if (v6(v3, v10, v9))
        return v3;
    }
    else
    {
      ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 131);
    }
  }
  EVP_PKEY_free(v3);
  return 0;
}

uint64_t EVP_PKEY_set_type(uint64_t a1, int a2)
{
  uint64_t v4;
  void (*v5)(uint64_t);
  int *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 8))
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = *(void (**)(uint64_t))(v4 + 160);
        if (v5)
        {
          v5(a1);
          *(_QWORD *)(a1 + 8) = 0;
          *(_DWORD *)(a1 + 4) = 0;
        }
      }
    }
  }
  if (a2 <= 407)
  {
    if (a2 == 6)
    {
      v6 = &rsa_asn1_meth;
      if (!a1)
        return 1;
    }
    else
    {
      if (a2 != 116)
        goto LABEL_23;
      v6 = &dsa_asn1_meth;
      if (!a1)
        return 1;
    }
LABEL_21:
    *(_QWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 4) = *v6;
    return 1;
  }
  switch(a2)
  {
    case 949:
      v6 = &ed25519_asn1_meth;
      if (!a1)
        return 1;
      goto LABEL_21;
    case 948:
      v6 = &x25519_asn1_meth;
      if (!a1)
        return 1;
      goto LABEL_21;
    case 408:
      v6 = &ec_asn1_meth;
      if (!a1)
        return 1;
      goto LABEL_21;
  }
LABEL_23:
  ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp.c", 344);
  ERR_add_error_dataf("algorithm %d", v8, v9, v10, v11, v12, v13, v14, a2);
  return 0;
}

uint64_t parse_key_type(__int128 *a1, _DWORD *a2)
{
  uint64_t result;
  unint64_t v4;
  BOOL v5;
  uint64_t v6;
  const void *v7;
  _QWORD v8[2];

  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  result = CBS_get_asn1(a1, v8, 6);
  if ((_DWORD)result)
  {
    v4 = 0;
    v5 = 1;
    while (1)
    {
      v6 = *((_QWORD *)&kASN1Methods + v4);
      if (CBS_len((uint64_t)v8) == *(unsigned __int8 *)(v6 + 13))
      {
        v7 = (const void *)CBS_data((uint64_t)v8);
        if (!*(_BYTE *)(v6 + 13) || !memcmp(v7, (const void *)(v6 + 4), *(unsigned __int8 *)(v6 + 13)))
          break;
      }
      v5 = v4++ < 4;
      if (v4 == 5)
        return 0;
    }
    *a2 = *(_DWORD *)v6;
    return v5;
  }
  return result;
}

EVP_PKEY *EVP_PKEY_new(void)
{
  EVP_PKEY *result;

  result = (EVP_PKEY *)OPENSSL_malloc(0x18uLL);
  if (result)
  {
    *(_QWORD *)&result->references = 0;
    result->pkey.ptr = 0;
    *(_QWORD *)&result->type = 1;
  }
  return result;
}

uint64_t rsa_pub_decode(uint64_t a1, __int128 *a2, __int128 *a3)
{
  RSA *v7;
  _QWORD v8[2];

  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_asn1(a2, v8, 5) || CBS_len((uint64_t)v8) || CBS_len((uint64_t)a2))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 97);
  }
  else
  {
    v7 = RSA_parse_public_key(a3);
    if (v7 && !CBS_len((uint64_t)a3))
    {
      EVP_PKEY_assign_RSA(a1, (uint64_t)v7);
      return 1;
    }
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 103);
    RSA_free(v7);
  }
  return 0;
}

uint64_t EVP_PKEY_assign_RSA(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = EVP_PKEY_set_type(a1, 6);
  if ((_DWORD)result)
  {
    *(_QWORD *)(a1 + 8) = a2;
    return a2 != 0;
  }
  return result;
}

void bssl::SSLTranscript::~SSLTranscript(bssl::SSLTranscript *this)
{
  EVP_MD_CTX_cleanup((EVP_MD_CTX *)((char *)this + 8));
  std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)this, 0);
}

EC_GROUP *__cdecl EC_GROUP_new_by_curve_name(int nid)
{
  uint64_t v2;
  uint64_t *i;
  EC_GROUP *v4;
  BN_CTX *v5;
  uint64_t v6;
  const unsigned __int8 *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  _QWORD *v13;
  uint64_t v14;
  __int128 v15;
  _OWORD v17[4];
  unint64_t v18;
  _OWORD v19[4];
  unint64_t v20;
  _OWORD v21[10];

  CRYPTO_once(&OPENSSL_built_in_curves_once, (void (*)(void))OPENSSL_built_in_curves_init);
  v2 = 0;
  for (i = &qword_1ECD85738; *((_DWORD *)i - 12) != nid; i += 7)
  {
    if (++v2 == 4)
    {
      ERR_put_error(15, 0, 123, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", 519);
      return 0;
    }
  }
  CRYPTO_MUTEX_lock_read(&built_in_groups_lock);
  v4 = (EC_GROUP *)built_in_groups[v2];
  CRYPTO_MUTEX_unlock_read(&built_in_groups_lock);
  if (!v4)
  {
    v5 = BN_CTX_new();
    if (!v5)
    {
      v12 = 0;
      v10 = 0;
      v9 = 0;
      v8 = 0;
LABEL_23:
      v14 = 0;
      goto LABEL_24;
    }
    v6 = *((unsigned __int8 *)i - 16);
    v7 = (const unsigned __int8 *)*(i - 1);
    v8 = BN_bin2bn(v7, *((unsigned __int8 *)i - 16), 0);
    if (v8)
    {
      v9 = BN_bin2bn(&v7[v6], v6, 0);
      if (v9)
      {
        v10 = BN_bin2bn(&v7[2 * v6], v6, 0);
        if (v10)
        {
          v11 = BN_bin2bn(&v7[5 * v6], v6, 0);
          if (v11)
          {
            v12 = v11;
            v13 = ec_group_new((_QWORD *)*i);
            v14 = (uint64_t)v13;
            if (v13
              && (*(unsigned int (**)(_QWORD *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *))(*v13 + 16))(v13, v8, v9, v10, v5))
            {
              *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
              *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
              v21[7] = v15;
              v21[8] = v15;
              v21[5] = v15;
              v21[6] = v15;
              v21[3] = v15;
              v21[4] = v15;
              v21[1] = v15;
              v21[2] = v15;
              v21[0] = v15;
              v19[0] = v15;
              v19[1] = v15;
              v19[2] = v15;
              v19[3] = v15;
              v20 = 0xAAAAAAAAAAAAAAAALL;
              v17[0] = v15;
              v17[1] = v15;
              v18 = 0xAAAAAAAAAAAAAAAALL;
              v17[2] = v15;
              v17[3] = v15;
              if (ec_felem_from_bytes(v14)
                && ec_felem_from_bytes(v14)
                && ec_point_set_affine_coordinates(v14, (uint64_t)v21, (uint64_t)v19, (uint64_t)v17)
                && ec_group_set_generator(v14, (uint64_t)v21, v12))
              {
                goto LABEL_25;
              }
            }
            else
            {
              ERR_put_error(15, 0, 15, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", 466);
            }
LABEL_24:
            EC_GROUP_free((EC_GROUP *)v14);
            v14 = 0;
LABEL_25:
            BN_CTX_free(v5);
            BN_free(v8);
            BN_free(v9);
            BN_free(v10);
            BN_free(v12);
            if (!v14)
              return 0;
            CRYPTO_MUTEX_lock_write(&built_in_groups_lock);
            v4 = (EC_GROUP *)built_in_groups[v2];
            if (!v4)
            {
              built_in_groups[v2] = v14;
              *(_DWORD *)(v14 + 40) = nid;
              v4 = (EC_GROUP *)v14;
              v14 = 0;
            }
            CRYPTO_MUTEX_unlock_read(&built_in_groups_lock);
            EC_GROUP_free((EC_GROUP *)v14);
            return v4;
          }
        }
        goto LABEL_22;
      }
    }
    else
    {
      v9 = 0;
    }
    v10 = 0;
LABEL_22:
    ERR_put_error(15, 0, 3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", 459);
    v12 = 0;
    goto LABEL_23;
  }
  return v4;
}

uint64_t CRYPTO_MUTEX_unlock_read(pthread_rwlock_t *a1)
{
  uint64_t result;

  result = pthread_rwlock_unlock(a1);
  if ((_DWORD)result)
    abort();
  return result;
}

uint64_t CRYPTO_MUTEX_lock_read(pthread_rwlock_t *a1)
{
  uint64_t result;

  result = pthread_rwlock_rdlock(a1);
  if ((_DWORD)result)
    abort();
  return result;
}

uint64_t eckey_pub_decode(uint64_t a1, __int128 *a2, uint64_t a3)
{
  EC_GROUP *v6;
  EC_KEY *v7;
  EC_KEY *v9;
  const unsigned __int8 *v10;
  size_t v11;

  v6 = EC_KEY_parse_curve_name(a2);
  if (!v6 || CBS_len((uint64_t)a2))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 99);
    v7 = 0;
LABEL_4:
    EC_GROUP_free(v6);
    EC_KEY_free(v7);
    return 0;
  }
  v9 = EC_KEY_new();
  v7 = v9;
  if (!v9)
    goto LABEL_4;
  if (!EC_KEY_set_group(v9, v6))
    goto LABEL_4;
  v10 = (const unsigned __int8 *)CBS_data(a3);
  v11 = CBS_len(a3);
  if (!EC_KEY_oct2key(v7, v10, v11, 0))
    goto LABEL_4;
  EC_GROUP_free(v6);
  EVP_PKEY_assign_EC_KEY(a1, (uint64_t)v7);
  return 1;
}

uint64_t EVP_PKEY_assign_EC_KEY(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = EVP_PKEY_set_type(a1, 408);
  if ((_DWORD)result)
  {
    *(_QWORD *)(a1 + 8) = a2;
    return a2 != 0;
  }
  return result;
}

int EC_KEY_set_group(EC_KEY *a1, const EC_GROUP *a2)
{
  const EC_GROUP *v4;
  EC_GROUP *v6;

  v4 = *(const EC_GROUP **)a1;
  if (v4)
  {
    if (EC_GROUP_cmp(v4, a2, 0))
    {
      ERR_put_error(15, 0, 130, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", 219);
      return 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if (*((_QWORD *)a1 + 2))
      EC_KEY_set_group_cold_2();
    if (*((_QWORD *)a1 + 1))
      EC_KEY_set_group_cold_1();
    EC_GROUP_free(0);
    v6 = EC_GROUP_dup(a2);
    *(_QWORD *)a1 = v6;
    return v6 != 0;
  }
}

EC_GROUP *EC_KEY_parse_curve_name(__int128 *a1)
{
  int *v1;
  uint64_t v2;
  int *v3;
  const void *v4;
  int v5;
  int v6;
  _QWORD v8[2];

  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_asn1(a1, v8, 6))
  {
    v1 = OPENSSL_built_in_curves();
    v2 = 0;
    while (1)
    {
      v3 = &v1[v2];
      if (CBS_len((uint64_t)v8) == LOBYTE(v1[v2 + 4]))
      {
        v4 = (const void *)CBS_data((uint64_t)v8);
        if (!*((_BYTE *)v3 + 16) || !memcmp(v4, *(const void **)&v1[v2 + 2], *((unsigned __int8 *)v3 + 16)))
          return EC_GROUP_new_by_curve_name(v1[v2]);
      }
      v2 += 14;
      if (v2 == 56)
      {
        v5 = 123;
        v6 = 342;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v5 = 128;
    v6 = 327;
LABEL_9:
    ERR_put_error(15, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", v6);
    return 0;
  }
}

int *OPENSSL_built_in_curves()
{
  CRYPTO_once(&OPENSSL_built_in_curves_once, (void (*)(void))OPENSSL_built_in_curves_init);
  return &OPENSSL_built_in_curves_storage;
}

_QWORD *EC_KEY_new_method(uint64_t a1)
{
  _QWORD *v2;
  void *v3;
  CRYPTO_EX_DATA *v4;
  _QWORD *v5;
  uint64_t ECDSA_method;
  uint64_t v7;
  unsigned int (*v8)(_QWORD *);
  uint64_t v9;

  v2 = OPENSSL_malloc(0x38uLL);
  v5 = v2;
  if (!v2)
    return v5;
  v2[6] = 0;
  *((_OWORD *)v2 + 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *(_OWORD *)v2 = 0u;
  if (!a1)
  {
    ECDSA_method = v2[5];
    if (!ECDSA_method)
      goto LABEL_5;
    goto LABEL_4;
  }
  ECDSA_method = ENGINE_get_ECDSA_method(a1);
  v5[5] = ECDSA_method;
  if (ECDSA_method)
LABEL_4:
    METHOD_ref(ECDSA_method);
LABEL_5:
  *(_QWORD *)((char *)v5 + 28) = 0x100000004;
  CRYPTO_new_ex_data((_DWORD)v5 + 48, v3, v4);
  v7 = v5[5];
  if (v7)
  {
    v8 = *(unsigned int (**)(_QWORD *))(v7 + 16);
    if (v8)
    {
      if (!v8(v5))
      {
        CRYPTO_free_ex_data((int)&g_ec_ex_data_class, v5, (CRYPTO_EX_DATA *)v5 + 3);
        v9 = v5[5];
        if (v9)
          METHOD_unref(v9);
        OPENSSL_free(v5);
        return 0;
      }
    }
  }
  return v5;
}

EC_KEY *EC_KEY_new(void)
{
  return (EC_KEY *)EC_KEY_new_method(0);
}

EC_GROUP *__cdecl EC_GROUP_dup(const EC_GROUP *a1)
{
  if (a1 && !*((_DWORD *)a1 + 10))
    CRYPTO_refcount_inc((unsigned int *)a1 + 76);
  return a1;
}

void bssl::SSL3_STATE::~SSL3_STATE(bssl::SSL3_STATE *this)
{
  bssl::Array<unsigned char>::~Array((uint64_t)this + 584);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)this + 64, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 496);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 480);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)this + 59, 0);
  std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSL_HANDSHAKE **)this + 36, 0);
  std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSL_HANDSHAKE **)this + 35, 0);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)this + 34, 0);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)this + 33, 0);
  std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)this + 30, 0);
  std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)this + 29, 0);
  std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)this + 28, 0);
  std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)this + 23, 0);
  bssl::SSLBuffer::~SSLBuffer((bssl::SSL3_STATE *)((char *)this + 104));
  bssl::SSLBuffer::~SSLBuffer((bssl::SSL3_STATE *)((char *)this + 80));
}

void bssl::SSLBuffer::~SSLBuffer(bssl::SSLBuffer *this)
{
  *((_WORD *)this + 4) = *((_WORD *)this + 5);
  *((_WORD *)this + 6) = 0;
  *((_WORD *)this + 7) = *((_WORD *)this + 8);
  if (*((_BYTE *)this + 23))
    free(*(void **)this);
}

uint64_t EVP_HPKE_CTX_cleanup(uint64_t a1)
{
  return EVP_AEAD_CTX_cleanup(a1 + 24);
}

_QWORD *ec_group_new(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  int v4;
  int v5;

  if (!a1)
  {
    v4 = 121;
    v5 = 277;
LABEL_8:
    ERR_put_error(15, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", v5);
    return 0;
  }
  if (!*a1)
  {
    v4 = 66;
    v5 = 282;
    goto LABEL_8;
  }
  v2 = OPENSSL_malloc(0x188uLL);
  v3 = v2;
  if (v2)
  {
    v2[48] = 0;
    *((_OWORD *)v2 + 22) = 0u;
    *((_OWORD *)v2 + 23) = 0u;
    *((_OWORD *)v2 + 20) = 0u;
    *((_OWORD *)v2 + 21) = 0u;
    *((_OWORD *)v2 + 18) = 0u;
    *((_OWORD *)v2 + 19) = 0u;
    *((_OWORD *)v2 + 16) = 0u;
    *((_OWORD *)v2 + 17) = 0u;
    *((_OWORD *)v2 + 14) = 0u;
    *((_OWORD *)v2 + 15) = 0u;
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_DWORD *)v2 + 76) = 1;
    *v2 = a1;
    BN_init((BIGNUM *)(v2 + 2));
    if (!((unsigned int (*)(_QWORD *))*a1)(v3))
    {
      OPENSSL_free(v3);
      return 0;
    }
  }
  return v3;
}

uint64_t CRYPTO_MUTEX_lock_write(pthread_rwlock_t *a1)
{
  uint64_t result;

  result = pthread_rwlock_wrlock(a1);
  if ((_DWORD)result)
    abort();
  return result;
}

uint64_t bssl::tls_dispatch_alert(bssl *this, ssl_st *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unint64_t v9;

  v3 = *((_QWORD *)this + 21);
  if (v3)
  {
    if (!(*(unsigned int (**)(bssl *, _QWORD, _QWORD))(v3 + 32))(this, *(unsigned int *)(*((_QWORD *)this + 6) + 204), *(unsigned __int8 *)(*((_QWORD *)this + 6) + 470)))
    {
      ERR_put_error(16, 0, 298, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", 441);
      return 0;
    }
    goto LABEL_10;
  }
  v9 = 0xAAAAAAAAAAAAAAAALL;
  v5 = bssl::do_tls_write(this, (ssl_st *)&v9, (ssl_st *)0x15, *((_QWORD *)this + 6) + 469, (const unsigned __int8 *)2);
  if ((int)v5 >= 1 && v9 != 2)
    bssl::tls_dispatch_alert();
  v4 = v5;
  if ((int)v5 >= 1)
  {
LABEL_10:
    *(_WORD *)(*((_QWORD *)this + 6) + 220) &= ~0x1000u;
    v7 = *((_QWORD *)this + 6);
    if (*(_BYTE *)(v7 + 469) == 2)
    {
      BIO_flush(*((BIO **)this + 4));
      v7 = *((_QWORD *)this + 6);
    }
    v4 = 1;
    bssl::ssl_do_msg_callback((uint64_t)this, 1, 21, v7 + 469, 2);
    bssl::ssl_do_info_callback((uint64_t)this, (const ssl_st *)0x4008);
  }
  return v4;
}

uint64_t bssl::tls13_client_handshake(bssl *this, ssl_st *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  _DWORD *cipher_by_value;
  uint64_t v9;
  unsigned int min_version;
  const ssl_st *v11;
  unsigned int max_version;
  const ssl_st *v13;
  bssl *value;
  const ssl_st *v15;
  uint64_t v16;
  int v17;
  int v18;
  _BOOL4 v19;
  uint64_t v21;
  int v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  int v26;
  _QWORD *v27;
  bssl *v28;
  __int128 v29;
  uint64_t v30;
  int v31;
  int v32;
  bssl *v33;
  __int128 v34;
  bssl *v35;
  __int128 v36;
  int v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  int v41;
  bssl *v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  unint64_t *v48;
  bssl *v49;
  uint64_t v50;
  uint64_t (*v51)(_QWORD, _QWORD);
  int v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t *v55;
  int protocol_id;
  uint64_t v57;
  BUF_MEM *v58;
  uint64_t v59;
  __int128 v60;
  _OWORD *v61;
  __int128 v62;
  BOOL v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  __int16 v67;
  void **v68;
  unint64_t v69;
  const void *v70;
  char v71;
  char v72;
  int v73;
  int v74;
  int v75;
  unint64_t *v76;
  bssl::SSL_HANDSHAKE *v77;
  const ssl_session_st *v78;
  uint64_t v79;
  SSL_SESSION *v80;
  ssl_session_st *v81;
  SSL_SESSION *v82;
  const ssl_st *v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  bssl *v87;
  bssl *v88;
  int v89;
  unsigned __int8 v90;
  uint64_t v91;
  unsigned __int8 *v92;
  unsigned __int8 *v93;
  uint64_t v94;
  uint64_t v95;
  void **v96;
  uint64_t v97;
  const void *v98;
  unint64_t v99;
  int v100;
  char v101;
  void **v102;
  uint64_t v103;
  const void *v104;
  unint64_t v105;
  int v106;
  char v107;
  bssl *v108;
  const ssl_cipher_st *v109;
  const EVP_MD *handshake_digest;
  const ssl_st *p_master_key_length;
  unint64_t *v112;
  int v113;
  bssl::SSL_HANDSHAKE *v114;
  __int128 v115;
  int v116;
  char v117;
  int v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  char *v123;
  char *v124;
  void **v125;
  unint64_t **v126;
  size_t **v127;
  _OWORD *v128;
  _OWORD *v129;
  char *v130;
  SSL_SESSION **v131;
  size_t **v132;
  char *v133;
  char *v134;
  unint64_t v135[3];
  unint64_t v136;
  unsigned __int16 *v137;
  unint64_t v138;
  _BYTE v139[32];
  __int128 v140;
  __int128 v141;
  __int128 v142;
  unsigned __int8 v143;
  _BYTE v144[32];
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  unint64_t *v150;
  unint64_t *v151[2];
  __int128 v152;
  __int128 v153;
  __int128 v154;
  uint64_t v155;

  v131 = (SSL_SESSION **)((char *)this + 1536);
  v134 = (char *)this + 232;
  v133 = (char *)this + 280;
  v155 = *MEMORY[0x1E0C80C00];
  v132 = (size_t **)((char *)this + 424);
  v126 = (unint64_t **)((char *)this + 1488);
  v127 = (size_t **)((char *)this + 464);
  v129 = (_OWORD *)((char *)this + 472);
  v130 = (char *)this + 432;
  v128 = (_OWORD *)((char *)this + 504);
  v123 = (char *)this + 184;
  v124 = (char *)this + 136;
  v125 = (void **)((char *)this + 536);
  while (2)
  {
    v3 = *((_DWORD *)this + 6);
    v4 = 1;
    switch(v3)
    {
      case 0:
        v5 = *(_QWORD *)this;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 2) == 0)
          bssl::tls13_client_handshake();
        *(_QWORD *)&v148 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v146 = v6;
        v147 = v6;
        if (!(*(unsigned int (**)(uint64_t, __int128 *))(*(_QWORD *)v5 + 24))(v5, &v146))
          goto LABEL_95;
        if ((*((_BYTE *)this + 1601) & 0x10) == 0
          && !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 112))(v5))
        {
          goto LABEL_226;
        }
        *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v141 = v7;
        v142 = v7;
        *(_OWORD *)&v139[16] = v7;
        v140 = v7;
        *(_OWORD *)v139 = v7;
        *(_WORD *)&v139[16] = 0;
        WORD4(v141) = 0;
        BYTE10(v141) = 0;
        LOBYTE(v151[0]) = 50;
        if ((bssl::parse_server_hello_tls13((uint64_t)this, (uint64_t)v139, (char *)v151, (uint64_t)&v146) & 1) == 0)
          goto LABEL_253;
        cipher_by_value = SSL_get_cipher_by_value(WORD4(v141));
        v9 = (uint64_t)cipher_by_value;
        if (!cipher_by_value
          || (min_version = SSL_CIPHER_get_min_version(cipher_by_value),
              min_version > bssl::ssl_protocol_version((bssl *)v5, v11))
          || (max_version = SSL_CIPHER_get_max_version(v9),
              max_version < bssl::ssl_protocol_version((bssl *)v5, v13))
          || (value = (bssl *)SSL_CIPHER_get_value(v9),
              (bssl::ssl_tls13_cipher_meets_policy(value, (*(unsigned __int16 *)(*(_QWORD *)(v5 + 8) + 313) >> 11) & 1) & 1) == 0))
        {
          ERR_put_error(16, 0, 242, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 208);
          bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
          goto LABEL_226;
        }
        *((_QWORD *)this + 196) = v9;
        if ((_QWORD)v140 == 32)
        {
          v16 = 0;
          do
          {
            v17 = *(unsigned __int8 *)(*(_QWORD *)&v139[24] + v16);
            v18 = bssl::kHelloRetryRequest[v16];
            v19 = v17 == v18;
          }
          while (v17 == v18 && v16++ != 31);
        }
        else
        {
          v19 = 0;
        }
        v87 = (bssl *)bssl::ssl_protocol_version((bssl *)v5, v15);
        if (!bssl::SSLTranscript::InitHash(v132, v87, *((const ssl_cipher_st **)this + 196))
          || v19 && !bssl::SSLTranscript::UpdateForHelloRetryRequest((bssl::SSLTranscript *)v132))
        {
          goto LABEL_226;
        }
        if (*((_QWORD *)this + 195))
        {
          v88 = (bssl *)bssl::ssl_protocol_version((bssl *)v5, a2);
          if (!bssl::SSLTranscript::InitHash(v127, v88, *((const ssl_cipher_st **)this + 196))
            || v19 && !bssl::SSLTranscript::UpdateForHelloRetryRequest((bssl::SSLTranscript *)v127))
          {
            goto LABEL_226;
          }
        }
        v143 = -86;
        if ((bssl::check_ech_confirmation((uint64_t)this, (ssl_st *)&v143, (char *)v151, (uint64_t)v139) & 1) == 0)
          goto LABEL_253;
        if (*((_QWORD *)this + 195))
        {
          if (v143)
            v89 = 1;
          else
            v89 = 2;
          *(_DWORD *)(*(_QWORD *)(v5 + 48) + 216) = v89;
        }
        if (!v19)
        {
          *((_DWORD *)this + 6) = 2;
          goto LABEL_242;
        }
        memset(&v144[4], 170, 20);
        *(_DWORD *)v144 = 65580;
        CBS_init(&v144[8], 0, 0);
        v137 = (unsigned __int16 *)0xAAAAAAAAAAAAAAAALL;
        v138 = 0xAAAAAAAAAAAAAAAALL;
        v136 = 0xAAAAAAAA00010033;
        CBS_init(&v137, 0, 0);
        *((_QWORD *)&v149 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v150 = (unint64_t *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v149 = 0xAAAAAAAA0001002BLL;
        CBS_init((_QWORD *)&v149 + 1, 0, 0);
        memset(v135, 170, sizeof(v135));
        if (*((_QWORD *)this + 195))
          v90 = 1;
        else
          v90 = *(_WORD *)(*((_QWORD *)this + 1) + 313) & 1;
        LOWORD(v135[0]) = -499;
        WORD1(v135[0]) = v90;
        CBS_init(&v135[1], 0, 0);
        *(_QWORD *)&v152 = v144;
        *((_QWORD *)&v152 + 1) = &v136;
        *(_QWORD *)&v153 = &v149;
        *((_QWORD *)&v153 + 1) = v135;
        if ((bssl::ssl_parse_extensions(&v142, (char *)v151, (uint64_t *)&v152, 4, 0) & 1) == 0)
          goto LABEL_253;
        v113 = BYTE3(v136);
        if (!v144[3] && !BYTE3(v136))
        {
          ERR_put_error(16, 0, 282, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 260);
          bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
          goto LABEL_226;
        }
        if (v144[3])
        {
          *(_QWORD *)&v152 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v152 + 1) = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&v144[8], (unint64_t *)&v152)
            || !CBS_len((uint64_t)&v152)
            || CBS_len((uint64_t)&v144[8]))
          {
            ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 269);
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
            goto LABEL_226;
          }
          v115 = v152;
          v116 = bssl::Array<unsigned char>::Init((uint64_t)v125, *((unint64_t *)&v152 + 1));
          v117 = v116 ^ 1;
          if (!*((_QWORD *)&v115 + 1))
            v117 = 1;
          if ((v117 & 1) == 0)
            memcpy(*v125, (const void *)v115, *((size_t *)&v115 + 1));
          if (!v116)
            goto LABEL_226;
          v113 = BYTE3(v136);
        }
        if (v113)
        {
          LOWORD(v152) = -21846;
          if (!CBS_get_u16(&v137, &v152) || CBS_len((uint64_t)&v137))
          {
            ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 283);
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
            goto LABEL_226;
          }
          if (!bssl::tls1_check_group_id((bssl **)this, (const ssl_st *)(unsigned __int16)v152))
          {
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
            ERR_put_error(16, 0, 243, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 291);
            goto LABEL_226;
          }
          v118 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 49) + 16))(*((_QWORD *)this + 49));
          v119 = (unsigned __int16)v152;
          if (v118 == (unsigned __int16)v152
            || (v120 = *((_QWORD *)this + 50)) != 0
            && (v121 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v120 + 16))(v120),
                v119 = (unsigned __int16)v152,
                v121 == (unsigned __int16)v152))
          {
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
            ERR_put_error(16, 0, 243, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 300);
            goto LABEL_226;
          }
          if (!bssl::ssl_setup_key_shares(this, v119))
            goto LABEL_226;
        }
        if (!bssl::ssl_hash_message((uint64_t)this, (uint64_t)&v146)
          || *(_DWORD *)(*(_QWORD *)(v5 + 48) + 216) == 1
          && !bssl::SSLTranscript::Update(v127, *((const void **)&v147 + 1), v148))
        {
          goto LABEL_226;
        }
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5))
        {
          bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 10);
          ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 324);
          goto LABEL_226;
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
        *(_WORD *)(*(_QWORD *)(v5 + 48) + 220) |= 0x4000u;
        v4 = 1;
        *((_DWORD *)this + 6) = 1;
        if ((*((_BYTE *)this + 1601) & 8) != 0)
        {
          *(_DWORD *)(*(_QWORD *)(v5 + 48) + 256) = 8;
          v73 = bssl::close_early_data((uint64_t)this, 0);
          goto LABEL_149;
        }
        goto LABEL_243;
      case 1:
        v30 = *(_QWORD *)(*(_QWORD *)this + 48);
        if (*(_DWORD *)(v30 + 204))
          bssl::tls13_client_handshake();
        if (*(_DWORD *)(v30 + 216) == 1 && !bssl::ssl_encrypt_client_hello((uint64_t)this, 0, 0)
          || !bssl::ssl_add_client_hello(this, (bssl::SSL_HANDSHAKE *)a2))
        {
          goto LABEL_226;
        }
        bssl::ssl_done_writing_client_hello(this, (bssl::SSL_HANDSHAKE *)a2);
        *((_DWORD *)this + 6) = 2;
        goto LABEL_50;
      case 2:
        v5 = *(_QWORD *)this;
        *(_QWORD *)&v148 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v38 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v38 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v146 = v38;
        v147 = v38;
        if (!(*(unsigned int (**)(uint64_t, __int128 *))(*(_QWORD *)v5 + 24))(v5, &v146))
          goto LABEL_95;
        *(_QWORD *)&v39 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v141 = v39;
        v142 = v39;
        *(_OWORD *)&v139[16] = v39;
        v140 = v39;
        *(_OWORD *)v139 = v39;
        *(_WORD *)&v139[16] = 0;
        WORD4(v141) = 0;
        BYTE10(v141) = 0;
        LOBYTE(v151[0]) = 50;
        if ((bssl::parse_server_hello_tls13((uint64_t)this, (uint64_t)v139, (char *)v151, (uint64_t)&v146) & 1) == 0)
          goto LABEL_253;
        if ((_QWORD)v140 != 32)
          goto LABEL_118;
        v40 = 0;
        while (*(unsigned __int8 *)(*(_QWORD *)&v139[24] + v40) == bssl::kHelloRetryRequest[v40])
        {
          if (++v40 == 32)
          {
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 10);
            ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 378);
            goto LABEL_226;
          }
        }
LABEL_118:
        protocol_id = SSL_CIPHER_get_protocol_id(*((_QWORD *)this + 196));
        if (protocol_id != WORD4(v141))
        {
          ERR_put_error(16, 0, 242, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 384);
          bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
          goto LABEL_226;
        }
        v57 = *(_QWORD *)(v5 + 48);
        if (*(_DWORD *)(v57 + 216) != 1)
          goto LABEL_124;
        if ((*(_WORD *)(v57 + 220) & 0x4000) == 0)
          goto LABEL_123;
        LOBYTE(v152) = -86;
        if ((bssl::check_ech_confirmation((uint64_t)this, (ssl_st *)&v152, (char *)v151, (uint64_t)v139) & 1) == 0)
        {
          v86 = LOBYTE(v151[0]);
LABEL_225:
          bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, v86);
          goto LABEL_226;
        }
        if (!(_BYTE)v152)
        {
          ERR_put_error(16, 0, 321, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 398);
          v86 = 47;
          goto LABEL_225;
        }
LABEL_123:
        v58 = (BUF_MEM *)*((_QWORD *)this + 58);
        *((_QWORD *)this + 58) = 0;
        std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)v132, v58);
        EVP_MD_CTX_move((uint64_t)v130, v129);
        *((_DWORD *)this + 94) = *((_DWORD *)this + 95);
        v59 = *(_QWORD *)(v5 + 48);
        v60 = v128[1];
        *(_OWORD *)(v59 + 48) = *v128;
        *(_OWORD *)(v59 + 64) = v60;
        v57 = *(_QWORD *)(v5 + 48);
LABEL_124:
        v61 = (_OWORD *)CBS_data((uint64_t)&v139[24]);
        v62 = v61[1];
        *(_OWORD *)(v57 + 16) = *v61;
        *(_OWORD *)(v57 + 32) = v62;
        if (*(_QWORD *)(v5 + 104))
          v63 = *(_DWORD *)(*(_QWORD *)(v5 + 48) + 216) != 2;
        else
          v63 = 0;
        *((_QWORD *)&v152 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v153 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v152 = 0xAAAAAAAA00010033;
        CBS_init((_QWORD *)&v152 + 1, 0, 0);
        memset(&v144[4], 170, 20);
        strcpy(v144, ")");
        v144[2] = v63;
        v144[3] = 0;
        CBS_init(&v144[8], 0, 0);
        v137 = (unsigned __int16 *)0xAAAAAAAAAAAAAAAALL;
        v138 = 0xAAAAAAAAAAAAAAAALL;
        v136 = 0xAAAAAAAA0001002BLL;
        CBS_init(&v137, 0, 0);
        *(_QWORD *)&v149 = &v152;
        *((_QWORD *)&v149 + 1) = v144;
        v150 = &v136;
        if ((bssl::ssl_parse_extensions(&v142, (char *)v151, (uint64_t *)&v149, 3, 0) & 1) == 0)
          goto LABEL_253;
        LOWORD(v135[0]) = -21846;
        if (!BYTE3(v136)
          || !CBS_get_u16(&v137, v135)
          || CBS_len((uint64_t)&v137)
          || LOWORD(v135[0]) != *(unsigned __int16 *)(v5 + 16))
        {
          ERR_put_error(16, 0, 288, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 433);
          bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
          goto LABEL_226;
        }
        LOBYTE(v151[0]) = 50;
        if (v144[3])
        {
          if ((bssl::ssl_ext_pre_shared_key_parse_serverhello((uint64_t)this, (char *)v151, (unsigned __int16 **)&v144[8]) & 1) == 0)
          {
LABEL_253:
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, LOBYTE(v151[0]));
            goto LABEL_226;
          }
          v79 = *(_QWORD *)(v5 + 104);
          if (*(unsigned __int16 *)(v79 + 4) != *(unsigned __int16 *)(v5 + 16))
          {
            ERR_put_error(16, 0, 188, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 447);
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
            goto LABEL_226;
          }
          if (*(_DWORD *)(*(_QWORD *)(v79 + 208) + 36) != *(_DWORD *)(*((_QWORD *)this + 196) + 36))
          {
            ERR_put_error(16, 0, 268, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 453);
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
            goto LABEL_226;
          }
          if (!bssl::ssl_session_is_context_valid(this, (const bssl::SSL_HANDSHAKE *)v79, v78))
          {
            ERR_put_error(16, 0, 101, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 461);
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
            goto LABEL_226;
          }
          *(_WORD *)(*(_QWORD *)(v5 + 48) + 220) |= 0x40u;
          *((_DWORD *)this + 400) |= 0x2000000u;
          bssl::SSL_SESSION_dup(*(bssl **)(v5 + 104), 0, &v149);
          v80 = (SSL_SESSION *)v149;
          *(_QWORD *)&v149 = 0;
          std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v131, v80);
          v82 = (SSL_SESSION *)v149;
          *(_QWORD *)&v149 = 0;
          if (v82)
            SSL_SESSION_free(v82);
          if (!*v131)
          {
LABEL_235:
            bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 80);
LABEL_226:
            v4 = 0;
            goto LABEL_243;
          }
          bssl::ssl_set_session((ssl_st **)v5, 0, v81);
          bssl::ssl_session_renew_timeout((bssl *)v5, (ssl_st *)*v131, (ssl_session_st *)*(unsigned int *)(*(_QWORD *)(v5 + 128) + 300));
        }
        else if ((bssl::ssl_get_new_session(this, v77) & 1) == 0)
        {
          goto LABEL_235;
        }
        *(_QWORD *)(*((_QWORD *)this + 192) + 208) = *((_QWORD *)this + 196);
        v108 = (bssl *)bssl::ssl_protocol_version((bssl *)v5, v83);
        handshake_digest = bssl::ssl_get_handshake_digest(v108, *((_QWORD *)this + 196), v109);
        EVP_MD_size(handshake_digest);
        if ((*(_WORD *)(*(_QWORD *)(v5 + 48) + 220) & 0x40) != 0)
          p_master_key_length = (const ssl_st *)&(*v131)->master_key_length;
        else
          p_master_key_length = (const ssl_st *)&bssl::kZeroes;
        if (!bssl::tls13_init_key_schedule((uint64_t)this, p_master_key_length))
          goto LABEL_226;
        if (!BYTE3(v152))
        {
          ERR_put_error(16, 0, 258, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 500);
          bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 109);
          goto LABEL_226;
        }
        v149 = 0uLL;
        LOBYTE(v151[0]) = 50;
        if ((bssl::ssl_ext_key_share_parse_serverhello((uint64_t)this, (uint64_t)&v149, (char *)v151, (unsigned __int16 **)&v152 + 1) & 1) != 0)
        {
          if (bssl::tls13_advance_key_schedule((uint64_t)this)
            && bssl::ssl_hash_message((uint64_t)this, (uint64_t)&v146)
            && bssl::tls13_derive_handshake_secrets(this, v114)
            && ((*((_BYTE *)this + 1601) & 8) != 0 && !*(_QWORD *)(v5 + 168)
             || (bssl::tls13_set_traffic_key(v5, (const ssl_session_st *)2, 1, *((bssl **)this + 192), v124, *((_QWORD *)this + 4)) & 1) != 0)&& (bssl::tls13_set_traffic_key(v5, (const ssl_session_st *)2, 0, *((bssl **)this + 192), v123, *((_QWORD *)this + 4)) & 1) != 0)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
            *((_DWORD *)this + 6) = 3;
            v4 = 1;
            goto LABEL_276;
          }
        }
        else
        {
          bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, LOBYTE(v151[0]));
        }
        v4 = 0;
LABEL_276:
        OPENSSL_free((_QWORD *)v149);
LABEL_243:
        if (*((_DWORD *)this + 6) != v3)
          bssl::ssl_do_info_callback(*(_QWORD *)this, (const ssl_st *)0x1001);
        if ((_DWORD)v4 == 1)
          continue;
        return v4;
      case 3:
        v28 = *(bssl **)this;
        *(_QWORD *)&v140 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v29 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)v139 = v29;
        *(_OWORD *)&v139[16] = v29;
        if (!(*(unsigned int (**)(bssl *, _BYTE *))(*(_QWORD *)v28 + 24))(v28, v139))
          goto LABEL_95;
        if (!bssl::ssl_check_message_type(v28, (uint64_t)v139, 8))
          goto LABEL_226;
        v146 = *(_OWORD *)&v139[8];
        *(_QWORD *)&v152 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v152 + 1) = 0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&v146, (unint64_t *)&v152)
          || CBS_len((uint64_t)&v146))
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 556);
          bssl::ssl_send_alert(v28, (ssl_st *)2, 50);
          goto LABEL_226;
        }
        if ((bssl::ssl_parse_serverhello_tlsext((uint64_t)this, &v152) & 1) == 0)
        {
          ERR_put_error(16, 0, 190, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 562);
          goto LABEL_226;
        }
        v66 = *((_QWORD *)v28 + 6);
        v67 = *(_WORD *)(v66 + 220);
        if ((v67 & 0x800) == 0)
          goto LABEL_140;
        if ((v67 & 0x40) == 0)
          bssl::tls13_client_handshake();
        if (*(_DWORD *)(v66 + 216) == 2)
          bssl::tls13_client_handshake();
        v84 = *((_QWORD *)this + 193);
        v85 = *((_QWORD *)this + 192);
        if (*(_QWORD *)(v84 + 208) != *(_QWORD *)(v85 + 208))
        {
          ERR_put_error(16, 0, 304, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 575);
          bssl::ssl_send_alert(v28, (ssl_st *)2, 47);
          goto LABEL_226;
        }
        v91 = *(_QWORD *)(v84 + 408);
        if (v91 != *(_QWORD *)(v66 + 504))
          goto LABEL_227;
        if (!v91)
          goto LABEL_211;
        v92 = *(unsigned __int8 **)(v66 + 496);
        v93 = *(unsigned __int8 **)(v84 + 400);
        v94 = v91 - 1;
        do
        {
          v95 = v94;
          if (*v93 != *v92)
          {
LABEL_227:
            ERR_put_error(16, 0, 277, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 581);
            bssl::ssl_send_alert(v28, (ssl_st *)2, 47);
            goto LABEL_226;
          }
          ++v93;
          ++v92;
          --v94;
        }
        while (v95);
LABEL_211:
        if ((*((_BYTE *)this + 1603) & 4) != 0 || (*(_BYTE *)(v85 + 448) & 0x40) != 0)
        {
          ERR_put_error(16, 0, 279, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 589);
          bssl::ssl_send_alert(v28, (ssl_st *)2, 47);
          goto LABEL_226;
        }
        *(_BYTE *)(v85 + 448) = *(_BYTE *)(v84 + 448) & 0x40 | *(_BYTE *)(v85 + 448) & 0xBF;
        v96 = (void **)(*((_QWORD *)this + 192) + 416);
        v97 = *((_QWORD *)this + 193);
        v98 = *(const void **)(v97 + 416);
        v99 = *(_QWORD *)(v97 + 424);
        v100 = bssl::Array<unsigned char>::Init((uint64_t)v96, v99);
        v101 = v100 ^ 1;
        if (!v99)
          v101 = 1;
        if ((v101 & 1) == 0)
          memcpy(*v96, v98, v99);
        if (!v100)
          goto LABEL_272;
        v102 = (void **)(*((_QWORD *)this + 192) + 432);
        v103 = *((_QWORD *)this + 193);
        v104 = *(const void **)(v103 + 432);
        v105 = *(_QWORD *)(v103 + 440);
        v106 = bssl::Array<unsigned char>::Init((uint64_t)v102, v105);
        v107 = v106 ^ 1;
        if (!v105)
          v107 = 1;
        if ((v107 & 1) == 0)
          memcpy(*v102, v104, v105);
        if (!v106)
          goto LABEL_272;
        v66 = *((_QWORD *)v28 + 6);
LABEL_140:
        v68 = (void **)&(*v131)[1].sid_ctx[4];
        v70 = *(const void **)(v66 + 496);
        v69 = *(_QWORD *)(v66 + 504);
        v71 = bssl::Array<unsigned char>::Init((uint64_t)v68, v69);
        v72 = v71 ^ 1;
        if (!v69)
          v72 = 1;
        if ((v72 & 1) == 0)
          memcpy(*v68, v70, v69);
        if ((v71 & 1) == 0)
        {
LABEL_272:
          bssl::ssl_send_alert(v28, (ssl_st *)2, 80);
          goto LABEL_226;
        }
        if (!bssl::ssl_hash_message((uint64_t)this, (uint64_t)v139))
          goto LABEL_226;
        (*(void (**)(bssl *))(*(_QWORD *)v28 + 32))(v28);
        *((_DWORD *)this + 6) = 4;
        if ((*((_BYTE *)this + 1601) & 8) == 0 || (*(_WORD *)(*((_QWORD *)v28 + 6) + 220) & 0x800) != 0)
          goto LABEL_242;
        v73 = bssl::close_early_data((uint64_t)this, 2);
LABEL_149:
        if (v73)
          v4 = 13;
        else
          v4 = 0;
        goto LABEL_243;
      case 4:
        v28 = *(bssl **)this;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x40) != 0)
        {
          if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x800) != 0
            || !*(_BYTE *)(*((_QWORD *)v28 + 15) + 496))
          {
            v26 = 8;
          }
          else
          {
            v26 = 7;
          }
LABEL_241:
          *((_DWORD *)this + 6) = v26;
LABEL_242:
          v4 = 1;
          goto LABEL_243;
        }
        *(_QWORD *)&v140 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v44 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v44 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)v139 = v44;
        *(_OWORD *)&v139[16] = v44;
        if (!(*(unsigned int (**)(bssl *, _BYTE *))(*(_QWORD *)v28 + 24))(v28, v139))
        {
LABEL_95:
          v4 = 3;
          goto LABEL_243;
        }
        if (v139[1] != 13)
          goto LABEL_240;
        *((_QWORD *)&v146 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v147 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v146 = 0xAAAAAAAA0001000DLL;
        CBS_init((_QWORD *)&v146 + 1, 0, 0);
        *((_QWORD *)&v152 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v153 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v152 = 0xAAAAAAAA0001002FLL;
        CBS_init((_QWORD *)&v152 + 1, 0, 0);
        *(_OWORD *)v144 = *(_OWORD *)&v139[8];
        v136 = 0xAAAAAAAAAAAAAAAALL;
        v137 = (unsigned __int16 *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v149 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v149 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v135[0] = 0xAAAAAAAAAAAAAAAALL;
        v135[1] = 0xAAAAAAAAAAAAAAAALL;
        v143 = 50;
        if (!CBS_get_u8_length_prefixed((unsigned __int8 **)v144, &v136)
          || CBS_len((uint64_t)&v136)
          || !CBS_get_u16_length_prefixed((unsigned __int8 **)v144, (unint64_t *)&v149)
          || CBS_len((uint64_t)v144)
          || ((v151[0] = (unint64_t *)&v146,
               v151[1] = (unint64_t *)&v152,
               v74 = bssl::ssl_parse_extensions(&v149, (char *)&v143, (uint64_t *)v151, 2, 1),
               BYTE3(v146))
            ? (v75 = v74)
            : (v75 = 0),
              v75 != 1
           || !CBS_get_u16_length_prefixed((unsigned __int8 **)&v146 + 1, v135)
           || (bssl::tls1_parse_peer_sigalgs((bssl **)this, (ssl_st *)v135) & 1) == 0))
        {
          bssl::ssl_send_alert(v28, (ssl_st *)2, v143);
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 665);
          goto LABEL_226;
        }
        if (BYTE3(v152))
        {
          bssl::ssl_parse_client_CA_list((uint64_t)v28, &v143, (unsigned __int8 **)&v152 + 1, (STACK **)v151);
          v76 = v151[0];
          v151[0] = 0;
          std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](v126, v76);
          std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](v151, 0);
          if (!*v126)
          {
            bssl::ssl_send_alert(v28, (ssl_st *)2, v143);
            goto LABEL_226;
          }
        }
        else
        {
          v112 = (unint64_t *)sk_new_null();
          std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](v126, v112);
          if (!*v126)
            goto LABEL_272;
        }
        *((_DWORD *)this + 400) |= 0x20u;
        (*(void (**)(bssl *))(*(_QWORD *)(*((_QWORD *)v28 + 15) + 8) + 80))(this);
        if (bssl::ssl_hash_message((uint64_t)this, (uint64_t)v139))
        {
          (*(void (**)(bssl *))(*(_QWORD *)v28 + 32))(v28);
LABEL_240:
          v26 = 5;
          goto LABEL_241;
        }
        goto LABEL_226;
      case 5:
        v33 = *(bssl **)this;
        *(_QWORD *)&v140 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v34 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)v139 = v34;
        *(_OWORD *)&v139[16] = v34;
        if (!(*(unsigned int (**)(bssl *, _BYTE *))(*(_QWORD *)v33 + 24))(v33, v139))
          goto LABEL_95;
        if (v139[1] != 25 && !bssl::ssl_check_message_type(v33, (uint64_t)v139, 11)
          || !bssl::tls13_process_certificate((uint64_t *)this, (uint64_t)v139, 0)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)v139))
        {
          goto LABEL_226;
        }
        (*(void (**)(bssl *))(*(_QWORD *)v33 + 32))(v33);
        v26 = 6;
        goto LABEL_241;
      case 6:
        v35 = *(bssl **)this;
        *(_QWORD *)&v140 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v36 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v36 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)v139 = v36;
        *(_OWORD *)&v139[16] = v36;
        if (!(*(unsigned int (**)(bssl *, _BYTE *))(*(_QWORD *)v35 + 24))(v35, v139))
          goto LABEL_95;
        v37 = bssl::ssl_verify_peer_cert(this, (bssl::SSL_HANDSHAKE *)a2);
        if (v37 == 1)
          goto LABEL_226;
        if (v37 == 2)
        {
          v4 = 16;
          v32 = 6;
          goto LABEL_98;
        }
        if (!bssl::ssl_check_message_type(v35, (uint64_t)v139, 15)
          || !bssl::tls13_process_certificate_verify((uint64_t)this, (uint64_t)v139)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)v139))
        {
          goto LABEL_226;
        }
        (*(void (**)(bssl *))(*(_QWORD *)v35 + 32))(v35);
        v4 = 1;
        v32 = 8;
        goto LABEL_98;
      case 7:
        v31 = bssl::ssl_reverify_peer_cert((bssl **)this, (bssl::SSL_HANDSHAKE *)1);
        if (v31 == 1)
          goto LABEL_226;
        if (v31 == 2)
          v32 = 7;
        else
          v32 = 8;
        if (v31 == 2)
          v4 = 16;
        else
          v4 = 1;
        goto LABEL_98;
      case 8:
        v42 = *(bssl **)this;
        *(_QWORD *)&v140 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v43 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v43 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)v139 = v43;
        *(_OWORD *)&v139[16] = v43;
        if (!(*(unsigned int (**)(bssl *, _BYTE *))(*(_QWORD *)v42 + 24))(v42, v139))
          goto LABEL_95;
        if (!bssl::ssl_check_message_type(v42, (uint64_t)v139, 20))
          goto LABEL_226;
        if (!bssl::tls13_process_finished((char *)this, (uint64_t)v139, 0))
          goto LABEL_226;
        if (!bssl::ssl_hash_message((uint64_t)this, (uint64_t)v139))
          goto LABEL_226;
        bssl::SSLTranscript::DigestLen((bssl::SSLTranscript *)v132);
        if (!bssl::tls13_advance_key_schedule((uint64_t)this)
          || !bssl::tls13_derive_application_secrets(this, (bssl::SSL_HANDSHAKE *)a2))
        {
          goto LABEL_226;
        }
        if ((*(unsigned int (**)(bssl *))(*(_QWORD *)v42 + 40))(v42))
        {
          bssl::ssl_send_alert(v42, (ssl_st *)2, 10);
          ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 777);
          goto LABEL_226;
        }
        (*(void (**)(bssl *))(*(_QWORD *)v42 + 32))(v42);
        v26 = 9;
        goto LABEL_241;
      case 9:
        v27 = *(_QWORD **)this;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x800) == 0)
          goto LABEL_39;
        if (v27[21])
          goto LABEL_38;
        *(_QWORD *)&v64 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v64 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v139[16] = v64;
        v140 = v64;
        *(_OWORD *)v139 = v64;
        CBB_zero(v139);
        *(_QWORD *)&v65 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v65 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v147 = v65;
        v148 = v65;
        v146 = v65;
        if (!(*(unsigned int (**)(_QWORD *, _BYTE *, __int128 *, uint64_t))(*v27 + 88))(v27, v139, &v146, 5)|| (bssl::ssl_add_message_cbb((uint64_t)v27, (uint64_t)v139) & 1) == 0)
        {
          goto LABEL_135;
        }
        CBB_cleanup((uint64_t)v139);
LABEL_38:
        if (!bssl::close_early_data((uint64_t)this, 2))
          goto LABEL_226;
LABEL_39:
        v26 = 10;
        goto LABEL_241;
      case 10:
        if ((*(_BYTE *)(*((_QWORD *)this + 192) + 448) & 0x40) == 0)
          goto LABEL_35;
        v23 = *(_QWORD *)this;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x800) != 0)
          goto LABEL_35;
        *(_QWORD *)&v24 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v139[16] = v24;
        v140 = v24;
        *(_OWORD *)v139 = v24;
        CBB_zero(v139);
        *(_QWORD *)&v25 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v147 = v25;
        v148 = v25;
        v146 = v25;
        v153 = v25;
        v154 = v25;
        v152 = v25;
        *(_OWORD *)&v144[16] = v25;
        v145 = v25;
        *(_OWORD *)v144 = v25;
        if (!(*(unsigned int (**)(uint64_t, _BYTE *, __int128 *, uint64_t))(*(_QWORD *)v23 + 88))(v23, v139, &v146, 8)|| !CBB_add_u16_length_prefixed((uint64_t *)&v146, (uint64_t)&v152)|| !CBB_add_u16((uint64_t)&v152, 0x4469u)|| !CBB_add_u16_length_prefixed((uint64_t *)&v152, (uint64_t)v144)|| !CBB_add_bytes((uint64_t)v144, *(const void **)&(*v131)[1].sid_ctx[20], *(_QWORD *)&(*v131)[1].sid_ctx[28])|| (bssl::ssl_add_message_cbb(v23, (uint64_t)v139) & 1) == 0)
        {
          goto LABEL_135;
        }
        CBB_cleanup((uint64_t)v139);
LABEL_35:
        v26 = 11;
        goto LABEL_241;
      case 11:
        if ((*((_BYTE *)this + 1600) & 0x20) == 0)
          goto LABEL_97;
        v49 = *(bssl **)this;
        if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 216) == 2)
        {
          SSL_certs_clear(*(_QWORD *)this);
        }
        else
        {
          v50 = *(_QWORD *)(*((_QWORD *)this + 1) + 32);
          v51 = *(uint64_t (**)(_QWORD, _QWORD))(v50 + 72);
          if (v51)
          {
            v52 = v51(*(_QWORD *)this, *(_QWORD *)(v50 + 80));
            if (!v52)
            {
              bssl::ssl_send_alert(v49, (ssl_st *)2, 80);
              ERR_put_error(16, 0, 126, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 854);
              goto LABEL_226;
            }
            if (v52 < 0)
            {
              *((_DWORD *)this + 6) = 11;
              v4 = 8;
              goto LABEL_243;
            }
          }
        }
        if (bssl::ssl_on_certificate_selected(this, (bssl::SSL_HANDSHAKE *)a2)
          && bssl::tls13_add_certificate(this, (bssl::SSL_HANDSHAKE *)a2, v53, v54, v55))
        {
          v26 = 12;
          goto LABEL_241;
        }
        goto LABEL_226;
      case 12:
        if ((bssl::ssl_has_certificate(this, (const bssl::SSL_HANDSHAKE *)a2)
           || bssl::ssl_has_client_raw_public_key_certificate(this, a2))
          && (v41 = bssl::tls13_add_certificate_verify((EVP_PKEY **)this, (bssl::SSL_HANDSHAKE *)a2)) != 0)
        {
          if (v41 == 2)
            goto LABEL_226;
          if (v41 != 1)
            bssl::tls13_client_handshake();
          v4 = 9;
          v32 = 12;
        }
        else
        {
LABEL_97:
          v32 = 13;
        }
LABEL_98:
        *((_DWORD *)this + 6) = v32;
        goto LABEL_243;
      case 13:
        v21 = *(_QWORD *)this;
        v22 = *((_DWORD *)this + 400);
        *((_DWORD *)this + 400) = v22 | 0x2000000;
        if ((v22 & 0x4000000) == 0)
          goto LABEL_21;
        *(_QWORD *)&v45 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v45 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v139[16] = v45;
        v140 = v45;
        *(_OWORD *)v139 = v45;
        CBB_zero(v139);
        *(_QWORD *)&v46 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v46 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v147 = v46;
        v148 = v46;
        v146 = v46;
        if (!(*(unsigned int (**)(uint64_t, _BYTE *, __int128 *, uint64_t))(*(_QWORD *)v21 + 88))(v21, v139, &v146, 203)|| !bssl::tls1_write_channel_id((uint64_t)this, (uint64_t *)&v146, v47, v48)|| (bssl::ssl_add_message_cbb(v21, (uint64_t)v139) & 1) == 0)
        {
LABEL_135:
          CBB_cleanup((uint64_t)v139);
          goto LABEL_226;
        }
        CBB_cleanup((uint64_t)v139);
LABEL_21:
        if (!bssl::tls13_add_finished((bssl **)this, (bssl::SSL_HANDSHAKE *)a2)
          || !bssl::tls13_set_traffic_key(v21, (const ssl_session_st *)3, 1, *((bssl **)this + 192), v134, *((_QWORD *)this + 4))|| !bssl::tls13_set_traffic_key(v21, (const ssl_session_st *)3, 0, *((bssl **)this + 192), v133, *((_QWORD *)this + 4))|| !bssl::tls13_derive_resumption_secret(this, (bssl::SSL_HANDSHAKE *)a2))
        {
          goto LABEL_226;
        }
        *((_DWORD *)this + 6) = 14;
LABEL_50:
        v4 = 4;
        goto LABEL_243;
      case 14:
        return v4;
      default:
        goto LABEL_226;
    }
  }
}

void sub_1B4F88554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t bssl::ssl_do_info_callback(uint64_t this, const ssl_st *a2)
{
  uint64_t (*v2)(void);

  v2 = *(uint64_t (**)(void))(this + 112);
  if (v2)
    return v2();
  v2 = *(uint64_t (**)(void))(*(_QWORD *)(this + 120) + 392);
  if (v2)
    return v2();
  return this;
}

uint64_t bssl::ssl_hash_message(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)a2)
    return 1;
  else
    return bssl::SSLTranscript::Update((_QWORD **)(a1 + 424), *(const void **)(a2 + 24), *(_QWORD *)(a2 + 32));
}

BOOL bssl::ssl_check_message_type(bssl *a1, uint64_t a2, int a3)
{
  int v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(unsigned __int8 *)(a2 + 1);
  if (v4 != a3)
  {
    bssl::ssl_send_alert(a1, (ssl_st *)2, 10);
    ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 219);
    ERR_add_error_dataf("got type %d, wanted type %d", v6, v7, v8, v9, v10, v11, v12, *(_BYTE *)(a2 + 1));
  }
  return v4 == a3;
}

uint64_t bssl::tls13_set_traffic_key(uint64_t a1, const ssl_session_st *a2, uint64_t a3, bssl *this, const void *a5, size_t a6)
{
  bssl::SSLAEADContext *v12;
  unsigned int v13;
  bssl::SSLAEADContext *v14;
  size_t v15;
  const void *v16;
  bssl::SSLAEADContext *v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  const ssl_session_st *v21;
  EVP_MD *digest;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int16 *v28;
  char v29;
  bssl::SSLAEADContext *v30;
  unsigned __int8 *v31;
  uint64_t (*v32)(uint64_t, const ssl_session_st *, bssl::SSLAEADContext **, const void *, size_t);
  char v33;
  uint64_t (*v34)(uint64_t, const ssl_session_st *, bssl::SSLAEADContext **, const void *, size_t);
  char v35;
  bssl::SSLAEADContext *v37;
  bssl::SSLAEADContext *v38;
  bssl::SSLAEADContext *v39;
  uint64_t v40;
  unsigned __int8 *v41;
  bssl::SSLAEADContext *v42;
  _QWORD v43[3];
  _OWORD v44[5];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v12 = (bssl::SSLAEADContext *)bssl::ssl_session_protocol_version(this, a2);
  v13 = v12;
  v42 = 0;
  if (*(_QWORD *)(a1 + 168))
  {
    bssl::SSLAEADContext::CreatePlaceholderForQUIC(v12, *((_QWORD *)this + 26), v44);
    v14 = *(bssl::SSLAEADContext **)&v44[0];
    *(_QWORD *)&v44[0] = 0;
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v42, v14);
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)v44, 0);
    v15 = a6;
    v16 = a5;
  }
  else
  {
    v40 = 0xAAAAAAAAAAAAAAAALL;
    v41 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
    v19 = *((_QWORD *)this + 26);
    v20 = SSL_is_dtls((unsigned __int8 **)a1) != 0;
    if ((bssl::ssl_cipher_get_evp_aead((void **)&v41, &v40, &v40, v19, v13, v20) & 1) == 0)
      goto LABEL_20;
    digest = (EVP_MD *)bssl::ssl_session_get_digest(this, v21);
    v23 = EVP_AEAD_key_length(v41);
    *(_QWORD *)&v24 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v44[3] = v24;
    v44[4] = v24;
    v44[1] = v24;
    v44[2] = v24;
    v44[0] = v24;
    if (!bssl::hkdf_expand_label((int)v44, v23, digest, (uint64_t)a5, a6, "key", 3uLL, v25, 0, 0))
      goto LABEL_20;
    v26 = EVP_AEAD_nonce_length((uint64_t)v41);
    memset(v43, 170, sizeof(v43));
    if (!bssl::hkdf_expand_label((int)v43, v26, digest, (uint64_t)a5, a6, "iv", 2uLL, v27, 0, 0))
      goto LABEL_20;
    v28 = (unsigned __int16 *)*((unsigned __int16 *)this + 2);
    v29 = SSL_is_dtls((unsigned __int8 **)a1) != 0;
    bssl::SSLAEADContext::Create(a3, v28, v29, *((_QWORD *)this + 26), v44, v23, 0, 0, &v39, v43, v26);
    v30 = v39;
    v39 = 0;
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v42, v30);
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v39, 0);
    v15 = 0;
    v16 = 0;
  }
  v17 = v42;
  if (!v42)
  {
LABEL_20:
    v18 = 0;
    goto LABEL_21;
  }
  if (a6 < 0x31)
  {
    v31 = *(unsigned __int8 **)a1;
    if ((_DWORD)a3)
    {
      v32 = (uint64_t (*)(uint64_t, const ssl_session_st *, bssl::SSLAEADContext **, const void *, size_t))*((_QWORD *)v31 + 18);
      v42 = 0;
      v37 = v17;
      v33 = v32(a1, a2, &v37, v16, v15);
      std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v37, 0);
      if ((v33 & 1) != 0)
      {
        if (a6)
          memmove((void *)(*(_QWORD *)(a1 + 48) + 296), a5, a6);
        *(_BYTE *)(*(_QWORD *)(a1 + 48) + 440) = a6;
LABEL_19:
        v18 = 1;
        goto LABEL_21;
      }
    }
    else
    {
      v34 = (uint64_t (*)(uint64_t, const ssl_session_st *, bssl::SSLAEADContext **, const void *, size_t))*((_QWORD *)v31 + 17);
      v42 = 0;
      v38 = v17;
      v35 = v34(a1, a2, &v38, v16, v15);
      std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v38, 0);
      if ((v35 & 1) != 0)
      {
        if (a6)
          memmove((void *)(*(_QWORD *)(a1 + 48) + 344), a5, a6);
        *(_BYTE *)(*(_QWORD *)(a1 + 48) + 441) = a6;
        goto LABEL_19;
      }
    }
    goto LABEL_20;
  }
  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", 211);
  v18 = 0;
LABEL_21:
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v42, 0);
  return v18;
}

void sub_1B4F889A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  bssl::SSLAEADContext *v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, bssl::SSLAEADContext *);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)va, 0);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)va1, 0);
  _Unwind_Resume(a1);
}

const EVP_MD *bssl::ssl_get_handshake_digest(bssl *this, uint64_t a2, const ssl_cipher_st *a3)
{
  int v3;

  v3 = *(_DWORD *)(a2 + 36);
  if (v3 == 4)
    return EVP_sha384();
  if (v3 == 2)
    return EVP_sha256();
  if (v3 != 1)
    bssl::ssl_get_handshake_digest();
  if (this >= 0x303)
    return EVP_sha256();
  return (const EVP_MD *)EVP_md5_sha1();
}

const EVP_MD *bssl::ssl_session_get_digest(bssl *this, const ssl_session_st *a2)
{
  bssl *v3;
  const ssl_cipher_st *v4;

  v3 = (bssl *)bssl::ssl_session_protocol_version(this, a2);
  return bssl::ssl_get_handshake_digest(v3, *((_QWORD *)this + 26), v4);
}

uint64_t bssl::ssl_session_protocol_version(bssl *this, const ssl_session_st *a2)
{
  unsigned __int16 v3;

  v3 = -21846;
  if ((bssl::ssl_protocol_version_from_wire((bssl *)&v3, (unsigned __int16 *)*((unsigned __int16 *)this + 2)) & 1) == 0)
    bssl::ssl_session_protocol_version();
  return v3;
}

void bssl::SSLAEADContext::~SSLAEADContext(bssl::SSLAEADContext *this)
{
  EVP_AEAD_CTX_cleanup((uint64_t)this + 8);
}

uint64_t EVP_AEAD_CTX_cleanup(uint64_t result)
{
  _QWORD *v1;

  if (*(_QWORD *)result)
  {
    v1 = (_QWORD *)result;
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    *v1 = 0;
  }
  return result;
}

const EVP_MD *EVP_sha256(void)
{
  CRYPTO_once(&EVP_sha256_once, (void (*)(void))EVP_sha256_init);
  return (const EVP_MD *)&EVP_sha256_storage;
}

void bssl::SSLAEADContext::Create(uint64_t a1@<X0>, unsigned __int16 *a2@<X1>, char a3@<W2>, uint64_t a4@<X3>, _OWORD *a5@<X4>, size_t a6@<X5>, const void *a7@<X6>, size_t a8@<X7>, bssl::SSLAEADContext **a9@<X8>, const void *a10, size_t a11)
{
  int evp_aead;
  int v20;
  __int128 v22;
  bssl::SSLAEADContext *v23;
  bssl::SSLAEADContext *v24;
  int v25;
  uint64_t v26;
  int v27;
  size_t v28;
  char v29;
  char v30;
  const char *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int16 v35;
  unsigned __int8 *v36;
  uint64_t v37;
  char v38;
  __int16 v39;
  _OWORD __dst[5];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v39 = (__int16)a2;
  v38 = a3;
  v36 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  v37 = a4;
  v35 = -21846;
  v33 = 0xAAAAAAAAAAAAAAAALL;
  v34 = 0xAAAAAAAAAAAAAAAALL;
  if (bssl::ssl_protocol_version_from_wire((bssl *)&v35, a2))
  {
    evp_aead = bssl::ssl_cipher_get_evp_aead((void **)&v36, &v34, &v33, a4, v35, a3);
    v20 = v33 == a11 ? evp_aead : 0;
    if (v20 == 1 && v34 == a8)
    {
      *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __dst[3] = v22;
      __dst[4] = v22;
      __dst[1] = v22;
      __dst[2] = v22;
      __dst[0] = v22;
      if (a8)
      {
        if (a8 + a6 + a11 >= 0x51)
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_aead_ctx.cc", 80);
          goto LABEL_10;
        }
        memcpy(__dst, a7, a8);
        if (a6)
          memcpy((char *)__dst + a8, a5, a6);
        if (a11)
          memcpy((char *)__dst + a8 + a6, a10, a11);
        a5 = __dst;
        a6 += a8 + a11;
      }
      v23 = (bssl::SSLAEADContext *)bssl::New<bssl::SSLAEADContext,unsigned short &,BOOL &,ssl_cipher_st const*&>(&v39, &v38, &v37);
      v24 = v23;
      if (!v23)
      {
LABEL_39:
        *a9 = v24;
        return;
      }
      v25 = bssl::SSLAEADContext::ProtocolVersion(v23);
      if (v25 != v35)
      {
        v31 = "aead_ctx->ProtocolVersion() == protocol_version";
        v32 = 97;
        goto LABEL_46;
      }
      if (!EVP_AEAD_CTX_init_with_direction((_QWORD *)v24 + 1, v36, (uint64_t)a5, a6, 0, a1))
      {
        *a9 = 0;
        bssl::Delete<bssl::SSLAEADContext>(v24);
        return;
      }
      if ((unint64_t)EVP_AEAD_nonce_length((uint64_t)v36) > 0x18)
      {
        v31 = "EVP_AEAD_nonce_length(aead) <= EVP_AEAD_MAX_NONCE_LENGTH";
        v32 = 105;
        goto LABEL_46;
      }
      *((_BYTE *)v24 + 621) = EVP_AEAD_nonce_length((uint64_t)v36);
      if (a8)
      {
        if (v35 < 0x304u)
        {
          *((_BYTE *)v24 + 625) |= 0xBu;
          goto LABEL_39;
        }
        v31 = "protocol_version < TLS1_3_VERSION";
        v32 = 139;
      }
      else
      {
        if (a11 > 0xC)
        {
          v31 = "fixed_iv.size() <= sizeof(aead_ctx->fixed_nonce_)";
          v32 = 110;
          goto LABEL_46;
        }
        if (a11)
          memcpy((char *)v24 + 608, a10, a11);
        *((_BYTE *)v24 + 620) = a11;
        v26 = v37;
        v27 = *(_DWORD *)(v37 + 28);
        if ((v27 & 0x40) != 0)
        {
          *((_BYTE *)v24 + 625) |= 4u;
          v27 = *(_DWORD *)(v26 + 28);
          v29 = 8;
        }
        else
        {
          v28 = *((unsigned __int8 *)v24 + 621);
          if (a11 > v28)
          {
            v31 = "fixed_iv.size() <= aead_ctx->variable_nonce_len_";
            v32 = 120;
            goto LABEL_46;
          }
          v29 = v28 - a11;
        }
        *((_BYTE *)v24 + 621) = v29;
        if ((v27 & 0x18) != 0)
          *((_BYTE *)v24 + 625) |= 1u;
        if (v35 < 0x304u)
          goto LABEL_39;
        v30 = *((_BYTE *)v24 + 625);
        *((_BYTE *)v24 + 621) = 8;
        *((_BYTE *)v24 + 625) = v30 & 0xEA | 0x14;
        if (a11 >= 8)
          goto LABEL_39;
        v31 = "fixed_iv.size() >= aead_ctx->variable_nonce_len_";
        v32 = 136;
      }
LABEL_46:
      __assert_rtn("Create", "ssl_aead_ctx.cc", v32, v31);
    }
  }
  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_aead_ctx.cc", 70);
LABEL_10:
  *a9 = 0;
}

void sub_1B4F88E80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t EVP_AEAD_nonce_length(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1);
}

uint64_t bssl::ssl_cipher_get_evp_aead(void **a1, uint64_t *a2, uint64_t *a3, uint64_t a4, unsigned int a5, char a6)
{
  uint64_t result;
  char v8;
  char v9;
  int v13;
  void *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  void *v18;
  void *v19;
  uint64_t v20;

  result = 0;
  *a1 = 0;
  *a2 = 0;
  *a3 = 0;
  if (a5 == 771)
    v8 = a6;
  else
    v8 = 1;
  if (a5 == 772)
    v9 = a6;
  else
    v9 = 1;
  switch(*(_DWORD *)(a4 + 32))
  {
    case 1:
      result = 0;
      v13 = *(_DWORD *)(a4 + 28);
      if (v13 > 3)
      {
        if (v13 == 4)
        {
          if (a5 == 769)
          {
            v14 = EVP_aead_aes_256_cbc_sha1_tls_implicit_iv();
            goto LABEL_35;
          }
          v19 = EVP_aead_aes_256_cbc_sha1_tls();
LABEL_42:
          *a1 = v19;
          goto LABEL_43;
        }
        if (v13 == 32)
        {
          v19 = EVP_aead_null_sha1_tls();
          goto LABEL_42;
        }
      }
      else
      {
        if (v13 == 1)
        {
          if (a5 == 769)
          {
            *a1 = EVP_aead_des_ede3_cbc_sha1_tls_implicit_iv();
            v20 = 8;
LABEL_36:
            *a3 = v20;
LABEL_43:
            v15 = 20;
            goto LABEL_44;
          }
          v19 = EVP_aead_des_ede3_cbc_sha1_tls();
          goto LABEL_42;
        }
        if (v13 == 2)
        {
          if (a5 == 769)
          {
            v14 = EVP_aead_aes_128_cbc_sha1_tls_implicit_iv();
LABEL_35:
            *a1 = v14;
            v20 = 16;
            goto LABEL_36;
          }
          v19 = EVP_aead_aes_128_cbc_sha1_tls();
          goto LABEL_42;
        }
      }
      return result;
    case 2:
      if (*(_DWORD *)(a4 + 28) != 2)
        return 0;
      *a1 = EVP_aead_aes_128_cbc_sha256_tls();
      v15 = 32;
      goto LABEL_44;
    case 4:
      if (*(_DWORD *)(a4 + 28) != 4)
        return 0;
      *a1 = EVP_aead_aes_256_cbc_sha384_tls();
      v15 = 48;
LABEL_44:
      *a2 = v15;
      return 1;
    case 8:
      v16 = *(_DWORD *)(a4 + 28);
      switch(v16)
      {
        case 64:
          v17 = 12;
          v18 = EVP_aead_chacha20_poly1305();
          break;
        case 16:
          v17 = 4;
          if ((v8 & 1) != 0)
          {
            if ((v9 & 1) != 0)
              v18 = EVP_aead_aes_256_gcm();
            else
              v18 = EVP_aead_aes_256_gcm_tls13();
          }
          else
          {
            v18 = EVP_aead_aes_256_gcm_tls12();
          }
          break;
        case 8:
          v17 = 4;
          if ((v8 & 1) != 0)
          {
            if ((v9 & 1) != 0)
              v18 = EVP_aead_aes_128_gcm();
            else
              v18 = EVP_aead_aes_128_gcm_tls13();
          }
          else
          {
            v18 = EVP_aead_aes_128_gcm_tls12();
          }
          break;
        default:
          return 0;
      }
      *a1 = v18;
      *a3 = v17;
      if (a5 >= 0x304)
        *a3 = EVP_AEAD_nonce_length((uint64_t)v18);
      return 1;
    default:
      return result;
  }
}

int *EVP_aead_aes_256_gcm_tls13()
{
  CRYPTO_once(&EVP_aead_aes_256_gcm_tls13_once, (void (*)(void))EVP_aead_aes_256_gcm_tls13_init);
  return &EVP_aead_aes_256_gcm_tls13_storage;
}

const EVP_MD *EVP_sha384(void)
{
  CRYPTO_once(&EVP_sha384_once, (void (*)(void))EVP_sha384_init);
  return (const EVP_MD *)&EVP_sha384_storage;
}

uint64_t CRYPTO_once(pthread_once_t *a1, void (*a2)(void))
{
  uint64_t result;

  result = pthread_once(a1, a2);
  if ((_DWORD)result)
    abort();
  return result;
}

_QWORD *bssl::New<bssl::SSLAEADContext,unsigned short &,BOOL &,ssl_cipher_st const*&>(__int16 *a1, char *a2, _QWORD *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  __int16 v8;
  char v9;

  v6 = OPENSSL_malloc(0x278uLL);
  v7 = v6;
  if (v6)
  {
    v8 = *a1;
    v9 = *a2;
    *v6 = *a3;
    EVP_AEAD_CTX_zero(v6 + 1);
    *((_WORD *)v7 + 310) = 0;
    *((_WORD *)v7 + 311) = v8;
    *((_BYTE *)v7 + 624) = v9;
    *((_BYTE *)v7 + 625) &= 0xE0u;
    v7[76] = 0;
    *((_DWORD *)v7 + 154) = 0;
  }
  return v7;
}

void EVP_AEAD_CTX_zero(void *a1)
{
  bzero(a1, 0x258uLL);
}

uint64_t EVP_AEAD_CTX_init_with_direction(_QWORD *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t (*v7)(_QWORD *, uint64_t, uint64_t, uint64_t);
  uint64_t result;

  if (*a2 != a4)
  {
    ERR_put_error(30, 0, 120, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", 78);
    goto LABEL_6;
  }
  *a1 = a2;
  v7 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t, uint64_t))*((_QWORD *)a2 + 1);
  if (v7)
  {
    result = v7(a1, a3, a4, a5);
    if ((_DWORD)result)
      return result;
    goto LABEL_6;
  }
  result = (*((uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))a2 + 2))(a1, a3, a4, a5, a6);
  if (!(_DWORD)result)
  {
LABEL_6:
    result = 0;
    *a1 = 0;
  }
  return result;
}

uint64_t aead_aes_gcm_init_with_dir(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  unint64_t v6;
  int v7;
  int v8;
  size_t *v9;
  void *v10;
  uint64_t result;

  if (8 * a3 != 128 && 8 * a3 != 256)
  {
    v7 = 102;
    v8 = 215;
    goto LABEL_9;
  }
  if (a4)
    v6 = a4;
  else
    v6 = 16;
  if (v6 >= 0x11)
  {
    v7 = 116;
    v8 = 224;
LABEL_9:
    ERR_put_error(30, 0, v7, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_aes.m", v8);
    return 0;
  }
  if (a5 == 1)
    v9 = (size_t *)ccaes_gcm_encrypt_mode();
  else
    v9 = (size_t *)ccaes_gcm_decrypt_mode();
  *(_QWORD *)(a1 + 8) = v9;
  v10 = malloc_type_malloc(*v9, 0x3C23FF4EuLL);
  *(_QWORD *)(a1 + 16) = v10;
  if (!v10 || ccgcm_init())
  {
    free((void *)(a1 + 8));
    return 0;
  }
  *(_BYTE *)(a1 + 24) = v6;
  *(_QWORD *)(a1 + 48) = 0;
  result = 1;
  *(_BYTE *)(a1 + 64) = 1;
  *(_BYTE *)(a1 + 592) = v6;
  return result;
}

uint64_t EVP_AEAD_key_length(unsigned __int8 *a1)
{
  return *a1;
}

BOOL bssl::hkdf_extract_to_secret(uint64_t a1, bssl::SSLTranscript *this)
{
  int v3;
  EVP_MD *v4;
  int v5;
  unint64_t v7;

  v7 = 0xAAAAAAAAAAAAAAAALL;
  v3 = a1 + 40;
  v4 = (EVP_MD *)bssl::SSLTranscript::Digest(this);
  v5 = HKDF_extract(v3, &v7, v4);
  if (v5 && v7 != *(_QWORD *)(a1 + 32))
    bssl::hkdf_extract_to_secret();
  return v5 != 0;
}

uint64_t HKDF_extract(int a1, _QWORD *a2, EVP_MD *md)
{
  int v5;

  v5 = EVP_MD_type(md);
  boringssl_crypto_hash_nid_to_cc_digest(v5);
  if (cchkdf_extract())
    return 0;
  *a2 = EVP_MD_size(md);
  return 1;
}

int EVP_MD_size(const EVP_MD *md)
{
  return md->pkey_type;
}

uint64_t bssl::ssl_verify_peer_cert(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  size_t v12;
  unsigned int *v13;
  unsigned int *v14;
  uint64_t result;
  uint64_t (*v16)(uint64_t, unsigned __int8 *);
  int v17;
  int v18;
  bssl *v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, _QWORD);
  int v22;
  int v23;
  unsigned __int8 v24;

  v3 = *(_QWORD *)this;
  v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 472);
  if (!v4)
  {
    v24 = 46;
    v16 = *(uint64_t (**)(uint64_t, unsigned __int8 *))(*((_QWORD *)this + 1) + 48);
    if (v16)
    {
      result = v16(v3, &v24);
      if ((_DWORD)result == 1)
      {
        if (*(_BYTE *)(*((_QWORD *)this + 1) + 312))
        {
          result = 1;
        }
        else
        {
          ERR_clear_error();
          result = 0;
        }
        *(_QWORD *)(*((_QWORD *)this + 192) + 184) = 50;
        if (!(_DWORD)result)
          goto LABEL_32;
        goto LABEL_22;
      }
      if (!(_DWORD)result)
      {
        *(_QWORD *)(*((_QWORD *)this + 192) + 184) = 0;
        goto LABEL_32;
      }
    }
    else
    {
      result = (*(unsigned int (**)(_QWORD, bssl *, unsigned __int8 *))(*(_QWORD *)(*(_QWORD *)(v3 + 120)
                                                                                             + 8)
                                                                                 + 72))(*((_QWORD *)this + 192), this, &v24) ^ 1;
    }
    if (!(_DWORD)result)
    {
LABEL_32:
      if ((*(_BYTE *)(v3 + 180) & 1) != 0)
        return 0;
      if ((*(_WORD *)(*((_QWORD *)this + 1) + 313) & 4) == 0)
        return 0;
      v20 = *(_QWORD *)(v3 + 120);
      v21 = *(uint64_t (**)(uint64_t, _QWORD))(v20 + 808);
      if (!v21)
        return 0;
      v22 = v21(v3, *(_QWORD *)(v20 + 816));
      if (v22 > 0)
        return 0;
      v23 = v22;
      ERR_put_error(16, 0, 289, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 431);
      if (v23)
        v18 = 80;
      else
        v18 = 113;
LABEL_24:
      v19 = (bssl *)v3;
LABEL_27:
      bssl::ssl_send_alert(v19, (ssl_st *)2, v18);
      return 1;
    }
LABEL_22:
    if ((_DWORD)result != 1)
      return result;
    ERR_put_error(16, 0, 125, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 419);
    v18 = v24;
    goto LABEL_24;
  }
  if ((*(_BYTE *)(v3 + 180) & 1) != 0)
    bssl::ssl_verify_peer_cert();
  v5 = sk_num(*(const STACK **)(v4 + 144));
  if (v5 != sk_num(*(const STACK **)(*((_QWORD *)this + 192) + 144)))
  {
    v17 = 341;
LABEL_26:
    ERR_put_error(16, 0, 273, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", v17);
    v19 = (bssl *)v3;
    v18 = 47;
    goto LABEL_27;
  }
  if (sk_num(*(const STACK **)(*((_QWORD *)this + 192) + 144)))
  {
    v6 = 0;
    while (1)
    {
      v7 = sk_value(*(const STACK **)(v4 + 144), v6);
      v8 = sk_value(*(const STACK **)(*((_QWORD *)this + 192) + 144), v6);
      v9 = CRYPTO_BUFFER_len((uint64_t)v7);
      if (v9 != CRYPTO_BUFFER_len((uint64_t)v8))
        break;
      v10 = (const void *)CRYPTO_BUFFER_data((uint64_t)v7);
      v11 = (const void *)CRYPTO_BUFFER_data((uint64_t)v8);
      v12 = CRYPTO_BUFFER_len((uint64_t)v7);
      if (v12)
      {
        if (memcmp(v10, v11, v12))
          break;
      }
      if (++v6 >= (unint64_t)sk_num(*(const STACK **)(*((_QWORD *)this + 192) + 144)))
        goto LABEL_10;
    }
    v17 = 356;
    goto LABEL_26;
  }
LABEL_10:
  v13 = *(unsigned int **)(v4 + 264);
  if (v13)
    CRYPTO_BUFFER_up_ref(*(_QWORD *)(v4 + 264));
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)(*((_QWORD *)this + 192) + 264), v13);
  v14 = *(unsigned int **)(v4 + 256);
  if (v14)
    CRYPTO_BUFFER_up_ref(*(_QWORD *)(v4 + 256));
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)(*((_QWORD *)this + 192) + 256), v14);
  result = 0;
  *(_QWORD *)(*((_QWORD *)this + 192) + 184) = *(_QWORD *)(v4 + 184);
  return result;
}

uint64_t boringssl_context_certificate_verify_callback(const SSL *a1, char *a2)
{
  char *v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  int is_server;
  uint64_t v11;
  const __CFArray *v12;
  uint64_t v13;
  const EVP_PKEY *v14;
  CFIndex v15;
  const __CFData *ValueAtIndex;
  const __CFData *v17;
  CFIndex Length;
  const UInt8 *BytePtr;
  EVP_PKEY *v20;
  EVP_PKEY *v21;
  int v22;
  char v23;
  id WeakRetained;
  void *v25;
  _BYTE *v26;
  char v27;
  id v28;
  _BYTE *v29;
  _BOOL4 v30;
  SSL_SESSION *session;
  id v32;
  __SecTrust **v33;
  void *v34;
  uint64_t v35;
  int v37;
  id v38;
  void *v39;
  int *v40;
  _BYTE *v41;
  char v42;
  id v43;
  _BYTE *v44;
  _BOOL4 v45;
  NSObject *v46;
  id v47;
  void *v48;
  _BYTE *v49;
  char v50;
  id v51;
  _BYTE *v52;
  _BOOL4 v53;
  _BYTE *v54;
  char v55;
  id v56;
  _BYTE *v57;
  _BOOL4 v58;
  NSObject *v59;
  id v60;
  void *v61;
  NSObject *v62;
  NSObject *v63;
  id v64;
  void *v65;
  id v66;
  id v67;
  _QWORD v68[4];
  __SecTrust **v69;
  uint64_t v70;
  _BYTE buf[18];
  __int16 v72;
  void *v73;
  __int16 v74;
  id v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  v5 = SSL_get_ex_data(a1, 0);
  if (!v5)
    return 1;
  v6 = (uint64_t)v5;
  if (*(_DWORD *)v5 != -1252936367)
    return 1;
  v7 = v5[1];
  if (!v7)
    return 1;
  if (*(_QWORD *)(v7 + 368) || *(_QWORD *)(v7 + 376))
  {
    v8 = SSL_get_ex_data(a1, 0);
    if (!v8)
      return 1;
    if (*(_DWORD *)v8 != -1252936367)
      return 1;
    v9 = v8[1];
    if (!v9)
      return 1;
    is_server = SSL_is_server((uint64_t)a1);
    v11 = 376;
    if (!is_server)
      v11 = 368;
    v12 = *(const __CFArray **)(v9 + v11);
    if (v12)
    {
      v13 = SSL_get0_peer_pubkey((uint64_t)a1);
      if (!v13)
      {
        v23 = 46;
        goto LABEL_34;
      }
      v14 = (const EVP_PKEY *)v13;
      if (CFArrayGetCount(v12) < 1)
      {
LABEL_22:
        v23 = 42;
LABEL_34:
        *a2 = v23;
        return 1;
      }
      v15 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v12, v15);
        if (!ValueAtIndex)
          break;
        v17 = ValueAtIndex;
        Length = CFDataGetLength(ValueAtIndex);
        BytePtr = CFDataGetBytePtr(v17);
        if (!Length)
          break;
        if (!BytePtr)
          break;
        memset(buf, 170, 16);
        CBS_init(buf, (uint64_t)BytePtr, Length);
        v20 = EVP_parse_public_key((__int128 *)buf);
        if (!v20)
          break;
        v21 = v20;
        v22 = EVP_PKEY_cmp(v14, v20);
        EVP_PKEY_free(v21);
        if (v22 == 1)
          return 0;
        if (++v15 >= CFArrayGetCount(v12))
          goto LABEL_22;
      }
    }
    v23 = 80;
    goto LABEL_34;
  }
  if ((*(_BYTE *)(v7 + 558) & 0xC) == 8)
  {
    WeakRetained = objc_loadWeakRetained((id *)(v7 + 16));
    if (WeakRetained)
    {
      v25 = WeakRetained;
      v26 = objc_loadWeakRetained((id *)(v7 + 16));
      v27 = v26[475];

      if ((v27 & 1) != 0)
        return 2;
    }
    v28 = objc_loadWeakRetained((id *)(v7 + 16));
    if (v28)
    {
      v29 = objc_loadWeakRetained((id *)(v7 + 16));
      v30 = (v29[475] & 1) == 0;

    }
    else
    {
      v30 = 1;
    }

    v35 = 2;
    if (v30 && g_boringssl_log)
    {
      v46 = (id)g_boringssl_log;
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        boringssl_context_certificate_verify_callback_cold_1(v7 + 16, v46);

      return 2;
    }
  }
  else
  {
    if ((*(_BYTE *)(v7 + 558) & 4) != 0)
    {
      v37 = *(unsigned __int8 *)(v7 + 320);
      v38 = objc_loadWeakRetained((id *)(v7 + 16));
      v39 = v38;
      if (!v37)
      {
        if (!v38
          || (v54 = objc_loadWeakRetained((id *)(v7 + 16)),
              v55 = v54[475],
              v54,
              v39,
              (v55 & 1) == 0))
        {
          v56 = objc_loadWeakRetained((id *)(v7 + 16));
          if (v56)
          {
            v57 = objc_loadWeakRetained((id *)(v7 + 16));
            v58 = (v57[475] & 1) == 0;

          }
          else
          {
            v58 = 1;
          }

          if (v58)
          {
            if (g_boringssl_log)
            {
              v63 = (id)g_boringssl_log;
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
              {
                v64 = objc_loadWeakRetained((id *)(v7 + 16));
                if (v64)
                {
                  v2 = (char *)objc_loadWeakRetained((id *)(v7 + 16));
                  v65 = v2 + 391;
                }
                else
                {
                  v65 = &unk_1B50022E3;
                }
                v67 = objc_loadWeakRetained((id *)(v7 + 16));
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "boringssl_context_certificate_verify_callback";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 1948;
                v72 = 2082;
                v73 = v65;
                v74 = 2048;
                v75 = v67;
                _os_log_impl(&dword_1B4F6D000, v63, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] Certificate verification result: FAIL", buf, 0x26u);

                if (v64)
              }

            }
          }
        }
        *a2 = boringssl_helper_convert_trusterror_to_alertcode(*(_DWORD *)(v7 + 324));
        return 1;
      }
      v40 = &OBJC_IVAR___boringssl_concrete_nw_protocol_boringssl_logging_disabled;
      if (!v38
        || (v41 = objc_loadWeakRetained((id *)(v7 + 16)),
            v42 = v41[475],
            v41,
            v39,
            (v42 & 1) == 0))
      {
        v43 = objc_loadWeakRetained((id *)(v7 + 16));
        if (v43)
        {
          v44 = objc_loadWeakRetained((id *)(v7 + 16));
          v45 = (v44[475] & 1) == 0;

        }
        else
        {
          v45 = 1;
        }

        v35 = 0;
        if (!v45 || !g_boringssl_log)
          return v35;
        v59 = (id)g_boringssl_log;
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          v60 = objc_loadWeakRetained((id *)(v7 + 16));
          if (v60)
          {
            v40 = (int *)objc_loadWeakRetained((id *)(v7 + 16));
            v61 = (char *)v40 + 391;
          }
          else
          {
            v61 = &unk_1B50022E3;
          }
          v66 = objc_loadWeakRetained((id *)(v7 + 16));
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "boringssl_context_certificate_verify_callback";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1945;
          v72 = 2082;
          v73 = v61;
          v74 = 2048;
          v75 = v66;
          _os_log_impl(&dword_1B4F6D000, v59, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] Certificate verification result: OK", buf, 0x26u);

          if (v60)
        }

      }
      return 0;
    }
    session = SSL_get_session(a1);
    if ((boringssl_session_set_peer_verification_state_from_session(v6, (uint64_t)session) & 1) != 0)
    {
      v32 = (id)v7;
      v68[0] = MEMORY[0x1E0C809B0];
      v68[1] = 3221225472;
      v68[2] = __boringssl_context_certificate_verify_callback_block_invoke;
      v68[3] = &unk_1E6879248;
      v70 = v6;
      v33 = (__SecTrust **)v32;
      v69 = v33;
      v34 = (void *)MEMORY[0x1B5E45624](v68);
      if ((boringssl_context_evaluate_trust_async(v6, v33[45], v34) & 1) != 0)
      {
        v35 = 2;
      }
      else
      {
        *a2 = 80;
        v35 = 1;
      }

    }
    else
    {
      v47 = objc_loadWeakRetained((id *)(v7 + 16));
      if (v47)
      {
        v48 = v47;
        v49 = objc_loadWeakRetained((id *)(v7 + 16));
        v50 = v49[475];

        if ((v50 & 1) != 0)
          return 1;
      }
      v51 = objc_loadWeakRetained((id *)(v7 + 16));
      if (v51)
      {
        v52 = objc_loadWeakRetained((id *)(v7 + 16));
        v53 = (v52[475] & 1) == 0;

      }
      else
      {
        v53 = 1;
      }

      v35 = 1;
      if (v53 && g_boringssl_log)
      {
        v62 = (id)g_boringssl_log;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
          boringssl_context_certificate_verify_callback_cold_2(v7 + 16, v62);

        return 1;
      }
    }
  }
  return v35;
}

uint64_t bssl::tls_set_read_state(bssl *a1, const ssl_st *a2, bssl::SSLAEADContext **a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t (**v11)(bssl *, const ssl_st *, _QWORD, uint64_t, uint64_t);
  uint64_t v12;
  uint64_t v13;
  bssl::SSLAEADContext *v14;

  if (bssl::tls_has_unprocessed_handshake_data(a1, a2))
  {
    ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_method.cc", 90);
    bssl::ssl_send_alert(a1, (ssl_st *)2, 10);
    return 0;
  }
  v11 = (uint64_t (**)(bssl *, const ssl_st *, _QWORD, uint64_t, uint64_t))*((_QWORD *)a1 + 21);
  if (!v11)
    goto LABEL_8;
  v12 = *(_QWORD *)(*((_QWORD *)a1 + 6) + 280);
  if (v12 && (*(_BYTE *)(v12 + 1602) & 0x10) != 0 || (result = (*v11)(a1, a2, *(_QWORD *)*a3, a4, a5), (_DWORD)result))
  {
    if ((_DWORD)a2 == 1)
      return 1;
LABEL_8:
    v13 = *((_QWORD *)a1 + 6);
    *(_QWORD *)v13 = 0;
    v14 = *a3;
    *a3 = 0;
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)(v13 + 264), v14);
    *(_DWORD *)(*((_QWORD *)a1 + 6) + 200) = (_DWORD)a2;
    return 1;
  }
  return result;
}

uint64_t bssl::tls_set_write_state(bssl *a1, ssl_st *a2, bssl::SSLAEADContext **a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  bssl::SSLAEADContext *v14;

  result = bssl::tls_flush_pending_hs_data(a1, a2);
  if ((_DWORD)result)
  {
    v11 = *((_QWORD *)a1 + 21);
    if (!v11)
      goto LABEL_7;
    v12 = *(_QWORD *)(*((_QWORD *)a1 + 6) + 280);
    if (v12 && (*(_BYTE *)(v12 + 1602) & 0x10) != 0
      || (result = (*(uint64_t (**)(bssl *, ssl_st *, _QWORD, uint64_t, uint64_t))(v11 + 8))(a1, a2, *(_QWORD *)*a3, a4, a5), (_DWORD)result))
    {
      if ((_DWORD)a2 == 1)
        return 1;
LABEL_7:
      v13 = *((_QWORD *)a1 + 6);
      *(_QWORD *)(v13 + 8) = 0;
      v14 = *a3;
      *a3 = 0;
      std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)(v13 + 272), v14);
      *(_DWORD *)(*((_QWORD *)a1 + 6) + 204) = (_DWORD)a2;
      return 1;
    }
  }
  return result;
}

uint64_t bssl::SSLTranscript::InitHash(size_t **this, bssl *a2, const ssl_cipher_st *a3)
{
  const EVP_MD *handshake_digest;
  uint64_t result;

  handshake_digest = bssl::ssl_get_handshake_digest(a2, (uint64_t)a3, a3);
  if (EVP_MD_CTX_md((const EVP_MD_CTX *)(this + 1)) == handshake_digest)
    return 1;
  result = EVP_DigestInit_ex((EVP_MD_CTX *)(this + 1), handshake_digest, 0);
  if ((_DWORD)result)
    return EVP_DigestUpdate((EVP_MD_CTX *)(this + 1), (const void *)(*this)[1], **this) != 0;
  return result;
}

uint64_t bssl::tls13_advance_key_schedule(uint64_t a1)
{
  __int128 v2;
  bssl::SSLTranscript *v3;
  const EVP_MD *v4;
  uint64_t result;
  uint64_t v6;
  EVP_MD *v7;
  uint64_t v8;
  unsigned int size;
  unsigned __int8 md[16];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12 = v2;
  v13 = v2;
  *(_OWORD *)md = v2;
  v11 = v2;
  size = -1431655766;
  v3 = (bssl::SSLTranscript *)(a1 + 424);
  v4 = bssl::SSLTranscript::Digest((bssl::SSLTranscript *)(a1 + 424));
  result = EVP_Digest(0, 0, md, &size, v4, 0);
  if ((_DWORD)result)
  {
    v6 = *(_QWORD *)(a1 + 32);
    v7 = (EVP_MD *)bssl::SSLTranscript::Digest(v3);
    result = bssl::hkdf_expand_label(a1 + 40, v6, v7, a1 + 40, *(_QWORD *)(a1 + 32), "derived", 7uLL, v8, md, size);
    if ((_DWORD)result)
      return bssl::hkdf_extract_to_secret(a1, v3);
  }
  return result;
}

uint64_t bssl::derive_secret_with_transcript(uint64_t a1, int a2, int a3, bssl::SSLTranscript *this, const void *a5, size_t a6)
{
  __int128 v12;
  uint64_t result;
  EVP_MD *v14;
  uint64_t v15;
  unint64_t v16;
  unsigned __int8 v17[16];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19 = v12;
  v20 = v12;
  *(_OWORD *)v17 = v12;
  v18 = v12;
  v16 = 0xAAAAAAAAAAAAAAAALL;
  result = bssl::SSLTranscript::GetHash(this, v17, &v16);
  if ((_DWORD)result)
  {
    v14 = (EVP_MD *)bssl::SSLTranscript::Digest(this);
    return bssl::hkdf_expand_label(a2, a3, v14, a1 + 40, *(_QWORD *)(a1 + 32), a5, a6, v15, v17, v16);
  }
  return result;
}

const EVP_MD *bssl::SSLTranscript::Digest(bssl::SSLTranscript *this)
{
  return EVP_MD_CTX_md((const EVP_MD_CTX *)((char *)this + 8));
}

uint64_t bssl::SSLTranscript::GetHash(bssl::SSLTranscript *this, unsigned __int8 *a2, unint64_t *a3)
{
  __int128 v6;
  uint64_t v7;
  unsigned int s;
  EVP_MD_CTX ctx;

  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.digest = v6;
  *(_OWORD *)&ctx.flags = v6;
  EVP_MD_CTX_init(&ctx);
  s = -1431655766;
  if (EVP_MD_CTX_copy_ex(&ctx, (const EVP_MD_CTX *)((char *)this + 8)) && EVP_DigestFinal_ex(&ctx, a2, &s))
  {
    *a3 = s;
    v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  EVP_MD_CTX_cleanup(&ctx);
  return v7;
}

void sub_1B4F8A278(_Unwind_Exception *a1, uint64_t a2, EVP_MD_CTX *ctx, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t ctxa)
{
  EVP_MD_CTX_cleanup((EVP_MD_CTX *)&ctxa);
  _Unwind_Resume(a1);
}

void EVP_MD_CTX_init(EVP_MD_CTX *ctx)
{
  *(_OWORD *)&ctx->digest = 0u;
  *(_OWORD *)&ctx->flags = 0u;
}

int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned __int8 *md, unsigned int *s)
{
  const EVP_MD *digest;

  if (ctx->digest->pkey_type >= 0x41u)
    EVP_DigestFinal_ex_cold_1();
  ((void (*)(void))ctx->digest->update)();
  digest = ctx->digest;
  if (s)
    *s = digest->pkey_type;
  OPENSSL_cleanse(ctx->engine, HIDWORD(digest->final));
  return 1;
}

void OPENSSL_cleanse(void *ptr, size_t len)
{
  if (len)
    bzero(ptr, len);
}

uint64_t digest_final_wrapper(uint64_t a1)
{
  return digest_final(*(_QWORD *)(a1 + 8));
}

uint64_t digest_final(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    digest_final_cold_1();
  result = CCDigestFinal();
  if ((_DWORD)result)
    digest_final_cold_2();
  return result;
}

int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
{
  uint64_t (**v4)(void);
  uint64_t v5;
  unint64_t v6;
  const EVP_MD *digest;
  ENGINE *engine;
  unint64_t v9;
  ENGINE *v10;
  size_t final_high;
  void *md_data;

  if (!in)
    goto LABEL_13;
  if (!in->flags)
  {
    digest = in->digest;
    if (in->digest)
    {
      v6 = 0;
LABEL_9:
      if (out->digest == digest)
      {
        engine = out->engine;
        out->engine = 0;
LABEL_16:
        EVP_MD_CTX_cleanup(out);
        out->digest = in->digest;
        out->engine = engine;
        if (in->digest)
        {
          final_high = HIDWORD(in->digest->final);
          if ((_DWORD)final_high)
            memcpy(engine, in->engine, final_high);
        }
        md_data = in->md_data;
        out->flags = v6;
        out->md_data = md_data;
        LODWORD(v5) = 1;
        if (v6 && !md_data)
          EVP_MD_CTX_copy_ex_cold_1();
        return v5;
      }
      v9 = HIDWORD(digest->final);
      if (!(_DWORD)v9)
        EVP_MD_CTX_copy_ex_cold_2();
      v10 = (ENGINE *)OPENSSL_malloc(v9);
      if (v10)
      {
        engine = v10;
        goto LABEL_16;
      }
      if (v6)
        (*(void (**)(unint64_t))in->md_data)(v6);
LABEL_14:
      LODWORD(v5) = 0;
      return v5;
    }
LABEL_13:
    ERR_put_error(29, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/digest/digest.c", 138);
    goto LABEL_14;
  }
  v4 = (uint64_t (**)(void))in->md_data;
  if (!v4)
    EVP_MD_CTX_copy_ex_cold_3();
  v5 = v4[1]();
  if (v5)
  {
    v6 = v5;
    digest = in->digest;
    if (!in->digest)
    {
      engine = 0;
      goto LABEL_16;
    }
    goto LABEL_9;
  }
  return v5;
}

uint64_t bssl::SSLTranscript::Update(_QWORD **a1, const void *a2, size_t a3)
{
  _QWORD *v6;
  uint64_t result;
  EVP_MD_CTX *v8;

  v6 = *a1;
  if (!v6 || (result = BUF_MEM_append(v6, a2, a3), (_DWORD)result))
  {
    v8 = (EVP_MD_CTX *)(a1 + 1);
    if (EVP_MD_CTX_md(v8))
      EVP_DigestUpdate(v8, a2, a3);
    return 1;
  }
  return result;
}

const EVP_MD *__cdecl EVP_MD_CTX_md(const EVP_MD *ctx)
{
  if (ctx)
    return *(const EVP_MD **)&ctx->type;
  return ctx;
}

int EVP_Digest(const void *data, size_t count, unsigned __int8 *md, unsigned int *size, const EVP_MD *type, ENGINE *impl)
{
  int v10;
  EVP_MD_CTX v12;

  memset(&v12, 0, sizeof(v12));
  v10 = EVP_DigestInit_ex(&v12, type, (ENGINE *)md);
  if (v10)
  {
    ((void (*)(EVP_MD_CTX *, const void *, size_t))v12.digest->init)(&v12, data, count);
    EVP_DigestFinal_ex(&v12, md, size);
  }
  EVP_MD_CTX_cleanup(&v12);
  return v10;
}

uint64_t bssl::parse_server_hello_tls13(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t result;

  result = bssl::ssl_parse_server_hello(a2, a3, a4);
  if ((_DWORD)result)
  {
    if (*(_WORD *)(a2 + 16) == 771
      && !*(_BYTE *)(a2 + 58)
      && CBS_mem_equal(a2 + 40, (char *)(a1 + 1611), *(unsigned __int8 *)(a1 + 1643))
      && CBS_len(a2 + 64))
    {
      return 1;
    }
    else
    {
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 120);
      result = 0;
      *a3 = 50;
    }
  }
  return result;
}

BOOL CBS_mem_equal(uint64_t a1, char *a2, uint64_t a3)
{
  return *(_QWORD *)(a1 + 8) == a3 && CRYPTO_memcmp(*(char **)a1, a2, a3) == 0;
}

uint64_t CRYPTO_memcmp(char *a1, char *a2, uint64_t a3)
{
  unsigned __int8 v3;
  char v4;
  char v5;
  char v6;

  if (!a3)
    return 0;
  v3 = 0;
  do
  {
    v5 = *a1++;
    v4 = v5;
    v6 = *a2++;
    v3 |= v6 ^ v4;
    --a3;
  }
  while (a3);
  return v3;
}

uint64_t bssl::ssl_parse_server_hello(uint64_t a1, char *a2, uint64_t a3)
{
  unint64_t *v5;
  int v6;
  uint64_t result;
  char v8;
  __int128 v9;

  if (*(_BYTE *)(a3 + 1) == 2)
  {
    *(_OWORD *)a1 = *(_OWORD *)(a3 + 24);
    v9 = *(_OWORD *)(a3 + 8);
    if (CBS_get_u16((unsigned __int16 **)&v9, (_WORD *)(a1 + 16))
      && CBS_get_bytes((uint64_t *)&v9, (_QWORD *)(a1 + 24), 0x20uLL)
      && CBS_get_u8_length_prefixed((unsigned __int8 **)&v9, (unint64_t *)(a1 + 40))
      && (unint64_t)CBS_len(a1 + 40) <= 0x20
      && CBS_get_u16((unsigned __int16 **)&v9, (_WORD *)(a1 + 56))
      && CBS_get_u8(&v9, (_BYTE *)(a1 + 58)))
    {
      v5 = (unint64_t *)(a1 + 64);
      CBS_init(v5, 0, 0);
      if ((!CBS_len((uint64_t)&v9) || CBS_get_u16_length_prefixed((unsigned __int8 **)&v9, v5))
        && !CBS_len((uint64_t)&v9))
      {
        return 1;
      }
      v6 = 758;
    }
    else
    {
      v6 = 748;
    }
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", v6);
    result = 0;
    v8 = 50;
  }
  else
  {
    ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 736);
    result = 0;
    v8 = 10;
  }
  *a2 = v8;
  return result;
}

uint64_t CBS_get_u8_length_prefixed(unsigned __int8 **a1, unint64_t *a2)
{
  return cbs_get_length_prefixed(a1, a2, 1uLL);
}

int *EVP_aead_aes_128_gcm_tls13()
{
  CRYPTO_once(&EVP_aead_aes_128_gcm_tls13_once, (void (*)(void))EVP_aead_aes_128_gcm_tls13_init);
  return &EVP_aead_aes_128_gcm_tls13_storage;
}

void aead_aes_gcm_cleanup(uint64_t a1)
{
  void *v2;

  if (a1 && *(_QWORD *)(a1 + 16))
  {
    cc_clear();
    v2 = *(void **)(a1 + 16);
    if (v2)
    {
      free(v2);
      *(_QWORD *)(a1 + 16) = 0;
    }
  }
}

void EVP_MD_CTX_copy_ex_cold_1()
{
  __assert_rtn("EVP_MD_CTX_copy_ex", "digest.c", 180, "out->pctx == NULL || out->pctx_ops != NULL");
}

uint64_t boringssl_context_evaluate_trust_async(uint64_t a1, __SecTrust *a2, void *a3)
{
  char *v3;
  id v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  id *v10;
  id WeakRetained;
  void *v12;
  unsigned __int8 *v13;
  id v14;
  _BYTE *v15;
  _BOOL4 v16;
  id *v18;
  id v19;
  void *v20;
  _BYTE *v21;
  char v22;
  id v23;
  _BYTE *v24;
  _BOOL4 v25;
  NSObject *v26;
  id v27;
  void *v28;
  NSObject *v29;
  id v30;
  void *v31;
  id v32;
  uint64_t v33;
  id v34;
  int v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  void *v40;
  __int16 v41;
  id v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v6 = a3;
  v7 = v6;
  if (a1 && *(_DWORD *)a1 == -1252936367)
  {
    v8 = 0;
    if (v6)
    {
      if (a2)
      {
        v9 = *(_QWORD *)(a1 + 8);
        if (v9)
        {
          if (*(_QWORD *)(v9 + 120) && *(_QWORD *)(v9 + 128))
          {
            v10 = (id *)(v9 + 16);
            WeakRetained = objc_loadWeakRetained((id *)(v9 + 16));
            if (!WeakRetained
              || (v12 = WeakRetained,
                  v13 = (unsigned __int8 *)objc_loadWeakRetained(v10),
                  v3 = (char *)v13[475],
                  v13,
                  v12,
                  (v3 & 1) == 0))
            {
              v14 = objc_loadWeakRetained(v10);
              if (v14)
              {
                v15 = objc_loadWeakRetained(v10);
                v16 = (v15[475] & 1) == 0;

              }
              else
              {
                v16 = 1;
              }

              if (v16)
              {
                if (g_boringssl_log)
                {
                  v29 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
                  {
                    v30 = objc_loadWeakRetained(v10);
                    if (v30)
                    {
                      v3 = (char *)objc_loadWeakRetained(v10);
                      v31 = v3 + 391;
                    }
                    else
                    {
                      v31 = &unk_1B50022E3;
                    }
                    v34 = objc_loadWeakRetained(v10);
                    v35 = 136446978;
                    v36 = "boringssl_context_evaluate_trust_async";
                    v37 = 1024;
                    v38 = 1783;
                    v39 = 2082;
                    v40 = v31;
                    v41 = 2048;
                    v42 = v34;
                    _os_log_impl(&dword_1B4F6D000, v29, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] Performing external trust evaluation", (uint8_t *)&v35, 0x26u);

                    if (v30)
                  }

                }
              }
            }
            boringssl_session_update_metadata(a1);
            v33 = boringssl_context_evaluate_trust_async_external(a1, a2, v7);
          }
          else
          {
            v18 = (id *)(v9 + 16);
            v19 = objc_loadWeakRetained((id *)(v9 + 16));
            if (!v19
              || (v20 = v19,
                  v21 = objc_loadWeakRetained(v18),
                  v22 = v21[475],
                  v21,
                  v20,
                  (v22 & 1) == 0))
            {
              v23 = objc_loadWeakRetained(v18);
              if (v23)
              {
                v24 = objc_loadWeakRetained(v18);
                v25 = (v24[475] & 1) == 0;

              }
              else
              {
                v25 = 1;
              }

              if (v25)
              {
                if (g_boringssl_log)
                {
                  v26 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                  {
                    v27 = objc_loadWeakRetained(v18);
                    if (v27)
                    {
                      v3 = (char *)objc_loadWeakRetained(v18);
                      v28 = v3 + 391;
                    }
                    else
                    {
                      v28 = &unk_1B50022E3;
                    }
                    v32 = objc_loadWeakRetained(v18);
                    v35 = 136446978;
                    v36 = "boringssl_context_evaluate_trust_async";
                    v37 = 1024;
                    v38 = 1787;
                    v39 = 2082;
                    v40 = v28;
                    v41 = 2048;
                    v42 = v32;
                    _os_log_impl(&dword_1B4F6D000, v26, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] Performing local trust evaluation", (uint8_t *)&v35, 0x26u);

                    if (v27)
                  }

                }
              }
            }
            v33 = boringssl_context_evaluate_trust_async_internal(a1, (uint64_t)a2, v7);
          }
          v8 = v33;
        }
      }
    }
  }
  else
  {
    v8 = 0;
  }

  return v8;
}

uint64_t boringssl_context_evaluate_trust_async_external(uint64_t a1, __SecTrust *a2, void *a3)
{
  id v5;
  void *v6;
  uint64_t v7;
  _QWORD *v8;
  sec_trust_t v9;
  uint64_t v10;
  void *v11;
  BOOL v12;
  _QWORD *v13;
  id *v14;
  void *v15;
  id WeakRetained;
  void *v17;
  _BYTE *v18;
  char v19;
  id v20;
  _BYTE *v21;
  _BOOL4 v22;
  NSObject *v24;
  id v25;
  void *v26;
  id v27;
  NSObject *v28;
  char *v29;
  _QWORD v30[4];
  id *v31;
  NSObject *v32;
  id v33;
  id v34;
  uint64_t v35;
  id v36;
  __SecTrust *v37;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  void *v43;
  __int16 v44;
  id v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = v5;
  if (a1 && *(_DWORD *)a1 == -1252936367)
  {
    v7 = 0;
    if (v5)
    {
      if (a2)
      {
        v8 = *(_QWORD **)(a1 + 8);
        if (v8)
        {
          v9 = sec_trust_create(a2);
          v10 = MEMORY[0x1B5E45624](v8[15]);
          v11 = (void *)v10;
          if (v9)
            v12 = v10 == 0;
          else
            v12 = 1;
          v7 = !v12;
          if (!v12)
          {
            v13 = v8;
            v30[0] = MEMORY[0x1E0C809B0];
            v30[1] = 3221225472;
            v30[2] = __boringssl_context_evaluate_trust_async_external_block_invoke;
            v30[3] = &unk_1E68790C8;
            v35 = a1;
            v36 = v13;
            v14 = v13;
            v31 = v14;
            v33 = v6;
            v37 = a2;
            v34 = v11;
            v32 = v9;
            v15 = (void *)MEMORY[0x1B5E45624](v30);
            *((_BYTE *)v14 + 558) |= 8u;
            WeakRetained = objc_loadWeakRetained(v14 + 2);
            if (!WeakRetained
              || (v17 = WeakRetained,
                  v18 = objc_loadWeakRetained(v14 + 2),
                  v19 = v18[475],
                  v18,
                  v17,
                  (v19 & 1) == 0))
            {
              v20 = objc_loadWeakRetained(v14 + 2);
              if (v20)
              {
                v21 = objc_loadWeakRetained(v14 + 2);
                v22 = (v21[475] & 1) == 0;

              }
              else
              {
                v22 = 1;
              }

              if (v22)
              {
                if (g_boringssl_log)
                {
                  v24 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
                  {
                    v25 = objc_loadWeakRetained(v14 + 2);
                    if (v25)
                    {
                      v29 = (char *)objc_loadWeakRetained(v14 + 2);
                      v26 = v29 + 391;
                    }
                    else
                    {
                      v26 = &unk_1B50022E3;
                    }
                    v27 = objc_loadWeakRetained(v14 + 2);
                    *(_DWORD *)buf = 136446978;
                    v39 = "boringssl_context_evaluate_trust_async_external";
                    v40 = 1024;
                    v41 = 1768;
                    v42 = 2082;
                    v43 = v26;
                    v44 = 2048;
                    v45 = v27;
                    _os_log_impl(&dword_1B4F6D000, v24, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] Asyncing for external verify block", buf, 0x26u);

                    if (v25)
                  }

                }
              }
            }
            if (v15)
            {
              v28 = v14[16];
              if (v28)
              {
                v14[63] = (char *)v14[63] + 1;
                dispatch_async(v28, v15);
              }
            }

          }
        }
      }
    }
  }
  else
  {
    v7 = 0;
  }

  return v7;
}

_QWORD *bssl::SSLAEADContext::CreatePlaceholderForQUIC@<X0>(bssl::SSLAEADContext *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *result;
  char v6;
  uint64_t v7;
  __int16 v8;

  v8 = (__int16)this;
  v7 = a2;
  v6 = 0;
  result = bssl::New<bssl::SSLAEADContext,unsigned short &,BOOL &,ssl_cipher_st const*&>(&v8, &v6, &v7);
  *a3 = result;
  return result;
}

_QWORD *boringssl_context_set_encryption_secrets(const SSL *a1)
{
  _QWORD *result;

  result = SSL_get_ex_data(a1, 0);
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && result[1])
    {
      boringssl_session_update_metadata((uint64_t)result);
      return (_QWORD *)nw_protocol_options_access_handle();
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t bssl::check_ech_confirmation(uint64_t a1, ssl_st *a2, char *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  _BOOL8 v13;
  uint64_t v14;
  char v15;
  unint64_t *v17;
  unint64_t v18;
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a4 + 32) == 32)
  {
    v8 = 0;
    while (*(unsigned __int8 *)(*(_QWORD *)(a4 + 24) + v8) == bssl::kHelloRetryRequest[v8])
    {
      if (++v8 == 32)
      {
        v19[0] = 0xAAAAAAAAAAAAAAAALL;
        v19[1] = 0xAAAAAAAAAAAAAAAALL;
        v18 = 0xAAAAAAAA0001FE0DLL;
        CBS_init(v19, 0, 0);
        v17 = &v18;
        if (!bssl::ssl_parse_extensions((__int128 *)(a4 + 64), a3, (uint64_t *)&v17, 1, 1))
          return 0;
        if (!BYTE3(v18))
          goto LABEL_13;
        if (CBS_len((uint64_t)v19) == 8)
        {
          v9 = CBS_data((uint64_t)v19);
          v11 = v9 - CBS_data(a4);
          v12 = 1;
          goto LABEL_10;
        }
        ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 148);
        v13 = 0;
        v15 = 50;
        goto LABEL_15;
      }
    }
  }
  v11 = bssl::ssl_ech_confirmation_signal_hello_offset(*(unsigned __int8 ***)a1, a2);
  v12 = 0;
LABEL_10:
  if (*(_QWORD *)(a1 + 1560))
  {
    v18 = 0xAAAAAAAAAAAAAAAALL;
    v13 = bssl::ssl_ech_accept_confirmation(a1, (int)&v18, 8, a1 + 504, 32, (bssl::SSLTranscript *)(a1 + 464), v12, v10, *(char **)a4, *(_QWORD *)(a4 + 8), v11);
    if (v13)
    {
      v14 = CBS_data(a4);
      LOBYTE(a2->version) = CRYPTO_memcmp((char *)(v14 + v11), (char *)&v18, 8) == 0;
    }
    else
    {
      v15 = 80;
LABEL_15:
      *a3 = v15;
    }
  }
  else
  {
LABEL_13:
    LOBYTE(a2->version) = 0;
    return 1;
  }
  return v13;
}

uint64_t bssl::tls13_derive_handshake_secrets(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3;
  unsigned __int8 *v4;
  bssl::SSLTranscript *v5;

  v3 = *(_QWORD *)this;
  v4 = (unsigned __int8 *)this + 136;
  v5 = (bssl *)((char *)this + 424);
  if (bssl::derive_secret_with_transcript((uint64_t)this, (int)this + 136, *((_QWORD *)this + 4), (bssl *)((char *)this + 424), "c hs traffic", 0xCuLL)&& bssl::ssl_log_secret(v3, "CLIENT_HANDSHAKE_TRAFFIC_SECRET", v4, *((_QWORD *)this + 4))&& bssl::derive_secret_with_transcript((uint64_t)this, (int)this + 184, *((_QWORD *)this + 4), v5, "s hs traffic", 0xCuLL))
  {
    return bssl::ssl_log_secret(v3, "SERVER_HANDSHAKE_TRAFFIC_SECRET", (unsigned __int8 *)this + 184, *((_QWORD *)this + 4));
  }
  else
  {
    return 0;
  }
}

uint64_t bssl::ssl_tls13_cipher_meets_policy(bssl *this, int a2)
{
  if (!a2)
    return 1;
  if (((_DWORD)this - 4865) >= 3)
    bssl::ssl_tls13_cipher_meets_policy();
  return (3u >> (((_BYTE)this - 1) & 7)) & 1;
}

uint64_t SSL_CIPHER_get_value(uint64_t a1)
{
  if (HIBYTE(*(_DWORD *)(a1 + 16)) != 3)
    SSL_CIPHER_get_protocol_id_cold_1();
  return (unsigned __int16)*(_DWORD *)(a1 + 16);
}

uint64_t bssl::tls13_process_certificate_verify(uint64_t a1, uint64_t a2)
{
  return bssl::tls13_process_certificate_verify_with_transcript(a1, a2, 0, 0, 0);
}

uint64_t bssl::ssl_ech_confirmation_signal_hello_offset(unsigned __int8 **this, const ssl_st *a2)
{
  if (SSL_is_dtls(this))
    return 38;
  else
    return 30;
}

_QWORD *boringssl_context_set_read_secret(const SSL *a1)
{
  return boringssl_context_set_encryption_secrets(a1);
}

_QWORD *boringssl_context_set_write_secret(const SSL *a1)
{
  return boringssl_context_set_encryption_secrets(a1);
}

void *EVP_aead_aes_128_gcm_tls12()
{
  return &aead_aes_128_gcm;
}

void *EVP_aead_aes_256_gcm_tls12()
{
  return &aead_aes_256_gcm;
}

uint64_t bssl::SSLTranscript::UpdateForHelloRetryRequest(bssl::SSLTranscript *this)
{
  __int128 v2;
  uint64_t result;
  size_t v4;
  const EVP_MD *v5;
  __int16 v6;
  char v7;
  char v8;
  unint64_t v9;
  unsigned __int8 v10[16];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)this)
    **(_QWORD **)this = 0;
  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12 = v2;
  v13 = v2;
  *(_OWORD *)v10 = v2;
  v11 = v2;
  v9 = 0xAAAAAAAAAAAAAAAALL;
  result = bssl::SSLTranscript::GetHash(this, v10, &v9);
  if ((_DWORD)result)
  {
    v6 = 254;
    v7 = 0;
    v4 = v9;
    v8 = v9;
    v5 = EVP_MD_CTX_md((const EVP_MD_CTX *)((char *)this + 8));
    result = EVP_DigestInit_ex((EVP_MD_CTX *)((char *)this + 8), v5, 0);
    if ((_DWORD)result)
    {
      result = bssl::SSLTranscript::Update((_QWORD **)this, &v6, 4uLL);
      if ((_DWORD)result)
        return bssl::SSLTranscript::Update((_QWORD **)this, v10, v4);
    }
  }
  return result;
}

uint64_t bssl::tls1_configure_aead(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t **a4, char *a5, const ssl_cipher_st *a6)
{
  size_t v6;
  size_t v12;
  unint64_t v13;
  uint64_t v14;
  ssl_session_st *v15;
  size_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  ssl_session_st *v20;
  size_t v21;
  uint64_t v22;
  _OWORD *v23;
  unsigned __int16 *v24;
  char v25;
  bssl::SSLAEADContext *v26;
  uint64_t v27;
  uint64_t (*v28)(uint64_t, uint64_t, bssl::SSLAEADContext **, _QWORD, _QWORD);
  bssl::SSLAEADContext **v29;
  uint64_t v30;
  uint64_t (*v31)(uint64_t, uint64_t, bssl::SSLAEADContext **, _QWORD, _QWORD);
  bssl::SSLAEADContext *v33;
  bssl::SSLAEADContext *v34;
  bssl::SSLAEADContext *v35;
  unint64_t var68[15];

  v6 = (size_t)a6;
  memset(var68, 170, 24);
  if (!bssl::get_key_block_lengths((bssl *)a1, (const ssl_st *)&var68[2], &var68[1], var68, a4[26], a6))
    return 0;
  v12 = var68[1];
  v13 = 2 * (var68[1] + var68[2] + var68[0]);
  v14 = *(_QWORD *)(a3 + 8);
  if (!v14)
  {
    if (!bssl::Array<unsigned char>::Init(a3, 2 * (var68[1] + var68[2] + var68[0]))
      || !bssl::generate_key_block(a1, *(ssl_session_st **)a3, *(_QWORD *)(a3 + 8), (bssl *)a4))
    {
      return 0;
    }
    v14 = *(_QWORD *)(a3 + 8);
  }
  if (v14 != v13)
    bssl::tls1_configure_aead();
  v15 = *(ssl_session_st **)a3;
  if (((*(_BYTE *)(a1 + 180) & 1) == 0) == (_DWORD)a2)
  {
    if (v13 >= var68[2])
      v16 = var68[2];
    else
      v16 = v13;
    if (v13 >= 2 * var68[2] && v13 >= 2 * (var68[2] + v12))
    {
      v17 = 2 * var68[2];
      v18 = 2 * (var68[2] + v12);
      v19 = var68[0];
      v20 = v15;
      goto LABEL_21;
    }
LABEL_38:
    abort();
  }
  if (v13 < var68[2])
    goto LABEL_38;
  v17 = v12 + 2 * var68[2];
  if (v13 < v17)
    goto LABEL_38;
  v16 = v13 - var68[2] >= var68[2] ? var68[2] : v13 - var68[2];
  v19 = var68[0];
  v18 = var68[0] + 2 * (var68[2] + v12);
  if (v13 < v18)
    goto LABEL_38;
  v20 = (ssl_session_st *)((char *)v15 + var68[2]);
LABEL_21:
  if (v13 - v17 < v12)
    v12 = v13 - v17;
  v21 = v13 - v18;
  if (v13 - v18 >= v19)
    v21 = v19;
  if (v6)
  {
    if (v6 != v19)
      return 0;
  }
  else
  {
    a5 = (char *)v15 + v18;
    v6 = v21;
  }
  v23 = (_OWORD *)((char *)&v15->ssl_version + v17);
  v35 = (bssl::SSLAEADContext *)0xAAAAAAAAAAAAAAAALL;
  v24 = (unsigned __int16 *)*(unsigned __int16 *)(a1 + 16);
  v25 = SSL_is_dtls((unsigned __int8 **)a1) != 0;
  bssl::SSLAEADContext::Create(a2, v24, v25, (uint64_t)a4[26], v23, v12, v20, v16, &v35, a5, v6);
  v26 = v35;
  if (v35)
  {
    v27 = *(_QWORD *)a1;
    if ((_DWORD)a2)
    {
      v28 = *(uint64_t (**)(uint64_t, uint64_t, bssl::SSLAEADContext **, _QWORD, _QWORD))(v27 + 144);
      v35 = 0;
      v29 = &v33;
      v33 = v26;
      v30 = v28(a1, 3, &v33, 0, 0);
    }
    else
    {
      v31 = *(uint64_t (**)(uint64_t, uint64_t, bssl::SSLAEADContext **, _QWORD, _QWORD))(v27 + 136);
      v34 = v35;
      v35 = 0;
      v29 = &v34;
      v30 = v31(a1, 3, &v34, 0, 0);
    }
    v22 = v30;
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](v29, 0);
  }
  else
  {
    v22 = 0;
  }
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v35, 0);
  return v22;
}

void sub_1B4F8B690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  bssl::SSLAEADContext *v5;
  va_list va;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, bssl::SSLAEADContext *);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)va, 0);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)va1, 0);
  _Unwind_Resume(a1);
}

uint64_t bssl::get_key_block_lengths(bssl *this, const ssl_st *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5, const ssl_cipher_st *a6)
{
  unsigned int v11;
  char v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  unint64_t v16;
  int v17;
  int v18;
  unsigned __int8 *v20;

  v20 = 0;
  v11 = bssl::ssl_protocol_version(this, a2);
  v12 = SSL_is_dtls((unsigned __int8 **)this) != 0;
  if ((bssl::ssl_cipher_get_evp_aead((void **)&v20, (uint64_t *)&a2->version, (uint64_t *)a4, (uint64_t)a5, v11, v12) & 1) == 0)
  {
    v17 = 130;
    v18 = 173;
    goto LABEL_6;
  }
  v13 = EVP_AEAD_key_length(v20);
  *a3 = v13;
  if (*(_QWORD *)&a2->version)
  {
    v14 = *a4 + *(_QWORD *)&a2->version;
    v15 = v13 >= v14;
    v16 = v13 - v14;
    if (!v15)
    {
      v17 = 68;
      v18 = 183;
LABEL_6:
      ERR_put_error(16, 0, v17, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/t1_enc.cc", v18);
      return 0;
    }
    *a3 = v16;
  }
  return 1;
}

BOOL bssl::generate_key_block(uint64_t a1, ssl_session_st *a2, size_t a3, bssl *this)
{
  char *v7;
  unint64_t v8;
  uint64_t *digest;

  v7 = (char *)this + 16;
  v8 = *((int *)this + 3);
  digest = (uint64_t *)bssl::ssl_session_get_digest(this, a2);
  return CRYPTO_tls1_prf(digest, a2, a3, v7, v8, "key expansion", 0xDuLL, (const unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 16), 0x20uLL, (const unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 48), 0x20uLL) == 1;
}

uint64_t bssl::ssl_send_finished(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2;
  uint64_t v3;
  __int128 v4;
  char v5;
  uint64_t v6;
  __int128 v8;
  __int128 v9;
  _OWORD v10[3];
  _OWORD v11[3];
  size_t __n;
  _OWORD __src[4];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)this;
  v3 = *((_QWORD *)this + 192);
  if (!v3)
    v3 = *(_QWORD *)(v2 + 104);
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __src[2] = v4;
  __src[3] = v4;
  __src[0] = v4;
  __src[1] = v4;
  __n = 0xAAAAAAAAAAAAAAAALL;
  if (!bssl::SSLTranscript::GetFinishedMAC((bssl *)((char *)this + 424), (unsigned __int8 *)__src, &__n, (const ssl_session_st *)v3, *(_BYTE *)(v2 + 180) & 1)|| !bssl::ssl_log_secret(v2, "CLIENT_RANDOM", (unsigned __int8 *)(v3 + 16), *(int *)(v3 + 12)))
  {
    return 0;
  }
  v5 = __n;
  if (__n >= 0xD)
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 569);
    return 0;
  }
  if ((*(_BYTE *)(v2 + 180) & 1) != 0)
  {
    if (__n)
      memcpy((void *)(*(_QWORD *)(v2 + 48) + 457), __src, __n);
    *(_BYTE *)(*(_QWORD *)(v2 + 48) + 456) = v5;
  }
  else
  {
    if (__n)
      memcpy((void *)(*(_QWORD *)(v2 + 48) + 443), __src, __n);
    *(_BYTE *)(*(_QWORD *)(v2 + 48) + 455) = v5;
  }
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = v8;
  v11[2] = v8;
  v11[0] = v8;
  CBB_zero(v11);
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[1] = v9;
  v10[2] = v9;
  v10[0] = v9;
  if ((*(unsigned int (**)(uint64_t, _OWORD *, _OWORD *, uint64_t))(*(_QWORD *)v2 + 88))(v2, v11, v10, 20)
    && CBB_add_bytes((uint64_t)v10, __src, __n)
    && (bssl::ssl_add_message_cbb(v2, (uint64_t)v11) & 1) != 0)
  {
    v6 = 1;
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 586);
    v6 = 0;
  }
  CBB_cleanup((uint64_t)v11);
  return v6;
}

void sub_1B4F8B9F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t bssl::tls13_derive_application_secrets(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3;
  bssl::SSLTranscript *v4;

  v3 = *(_QWORD *)this;
  v4 = (bssl *)((char *)this + 424);
  *(_BYTE *)(*(_QWORD *)(v3 + 48) + 442) = bssl::SSLTranscript::DigestLen((bssl *)((char *)this + 424));
  if (bssl::derive_secret_with_transcript((uint64_t)this, (int)this + 232, *((_QWORD *)this + 4), v4, "c ap traffic", 0xCuLL)&& bssl::ssl_log_secret(v3, "CLIENT_TRAFFIC_SECRET_0", (unsigned __int8 *)this + 232, *((_QWORD *)this + 4))&& bssl::derive_secret_with_transcript((uint64_t)this, (int)this + 280, *((_QWORD *)this + 4), v4, "s ap traffic", 0xCuLL)&& bssl::ssl_log_secret(
                       v3,
                       "SERVER_TRAFFIC_SECRET_0",
                       (unsigned __int8 *)this + 280,
                       *((_QWORD *)this + 4))
    && bssl::derive_secret_with_transcript((uint64_t)this, *(_QWORD *)(v3 + 48) + 392, *(unsigned __int8 *)(*(_QWORD *)(v3 + 48) + 442), v4, "exp master", 0xAuLL))
  {
    return bssl::ssl_log_secret(v3, "EXPORTER_SECRET", (unsigned __int8 *)(*(_QWORD *)(v3 + 48) + 392), *(unsigned __int8 *)(*(_QWORD *)(v3 + 48) + 442));
  }
  else
  {
    return 0;
  }
}

uint64_t bssl::ssl_log_secret(uint64_t a1, const char *a2, unsigned __int8 *a3, uint64_t a4)
{
  __int128 v8;
  size_t v9;
  size_t v10;
  BOOL v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD v15[2];
  _OWORD v16[3];

  if (!*(_QWORD *)(*(_QWORD *)(a1 + 120) + 776))
    return 1;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[1] = v8;
  v16[2] = v8;
  v16[0] = v8;
  CBB_zero(v16);
  v15[0] = 0;
  v15[1] = 0;
  v9 = strlen(a2);
  if (!CBB_init((uint64_t)v16, v9 + 2 * a4 + 67)
    || (v10 = strlen(a2), !CBB_add_bytes((uint64_t)v16, a2, v10))
    || !CBB_add_u8((uint64_t)v16, 0x20u)
    || !bssl::cbb_add_hex((uint64_t)v16, (unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 48), 32)
    || !CBB_add_u8((uint64_t)v16, 0x20u)
    || !bssl::cbb_add_hex((uint64_t)v16, a3, a4)
    || !CBB_add_u8((uint64_t)v16, 0))
  {
    v12 = 0;
    goto LABEL_12;
  }
  v11 = bssl::CBBFinishArray((uint64_t)v16, (uint64_t)v15);
  v12 = (_QWORD *)v15[0];
  if (!v11)
  {
LABEL_12:
    v13 = 0;
    goto LABEL_13;
  }
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 120) + 776))(a1, v15[0]);
  v13 = 1;
LABEL_13:
  OPENSSL_free(v12);
  CBB_cleanup((uint64_t)v16);
  return v13;
}

void sub_1B4F8BC88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  CBB_cleanup((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t bssl::ext_ec_point_add_extension(uint64_t *a1)
{
  uint64_t result;
  __int128 v3;
  _OWORD v4[3];
  _OWORD v5[3];

  result = CBB_add_u16((uint64_t)a1, 0xBu);
  if ((_DWORD)result)
  {
    *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v5[1] = v3;
    v5[2] = v3;
    v4[2] = v3;
    v5[0] = v3;
    v4[0] = v3;
    v4[1] = v3;
    result = CBB_add_u16_length_prefixed(a1, (uint64_t)v5);
    if ((_DWORD)result)
    {
      result = CBB_add_u8_length_prefixed((uint64_t *)v5, (uint64_t)v4);
      if ((_DWORD)result)
      {
        result = CBB_add_u8((uint64_t)v4, 0);
        if ((_DWORD)result)
          return CBB_flush(a1) != 0;
      }
    }
  }
  return result;
}

uint64_t bssl::tls13_add_finished(bssl **this, bssl::SSL_HANDSHAKE *a2)
{
  bssl *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  _OWORD v8[3];
  _OWORD v9[3];
  unsigned __int8 v10[8];
  _OWORD v11[4];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  *(_QWORD *)v10 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[2] = v3;
  v11[3] = v3;
  v11[0] = v3;
  v11[1] = v3;
  if ((bssl::tls13_finished_mac((bssl *)this, (bssl::SSL_HANDSHAKE *)v11, v10, (unint64_t *)(*((_BYTE *)v2 + 180) & 1)) & 1) != 0)
  {
    *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[1] = v4;
    v9[2] = v4;
    v9[0] = v4;
    CBB_zero(v9);
    *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v8[1] = v5;
    v8[2] = v5;
    v8[0] = v5;
    if ((*(unsigned int (**)(bssl *, _OWORD *, _OWORD *, uint64_t))(*(_QWORD *)v2 + 88))(v2, v9, v8, 20)
      && CBB_add_bytes((uint64_t)v8, v11, *(size_t *)v10))
    {
      v6 = bssl::ssl_add_message_cbb((uint64_t)v2, (uint64_t)v9);
    }
    else
    {
      v6 = 0;
    }
    CBB_cleanup((uint64_t)v9);
  }
  else
  {
    bssl::ssl_send_alert(v2, (ssl_st *)2, 80);
    ERR_put_error(16, 0, 142, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 814);
    return 0;
  }
  return v6;
}

void sub_1B4F8BE50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t bssl::ssl_ext_key_share_parse_serverhello(uint64_t a1, uint64_t a2, char *a3, unsigned __int16 **a4)
{
  uint64_t result;
  char v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  _WORD v14[9];

  memset(v14, 170, sizeof(v14));
  if (CBS_get_u16(a4, v14)
    && CBS_get_u16_length_prefixed((unsigned __int8 **)a4, (unint64_t *)&v14[1])
    && !CBS_len((uint64_t)a4))
  {
    v10 = *(_QWORD *)(a1 + 392);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10);
    if (v11 != v14[0])
    {
      v12 = *(_QWORD *)(a1 + 400);
      if (!v12 || (v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12), v13 != v14[0]))
      {
        *a3 = 47;
        ERR_put_error(16, 0, 243, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2400);
        return 0;
      }
      v10 = *(_QWORD *)(a1 + 400);
    }
    if (((*(uint64_t (**)(uint64_t, uint64_t, char *, _QWORD, _QWORD))(*(_QWORD *)v10 + 40))(v10, a2, a3, *(_QWORD *)&v14[1], *(_QWORD *)&v14[5]) & 1) != 0)
    {
      *(_WORD *)(*(_QWORD *)(a1 + 1536) + 6) = v14[0];
      std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)(a1 + 392), 0);
      std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)(a1 + 400), 0);
      return 1;
    }
    result = 0;
    v9 = 80;
  }
  else
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2391);
    result = 0;
    v9 = 50;
  }
  *a3 = v9;
  return result;
}

BOOL bssl::ssl_setup_key_shares(bssl *this, unint64_t a2)
{
  _QWORD *v4;
  _QWORD **v5;
  _QWORD **v6;
  char *v7;
  _BOOL8 v8;
  __int128 v9;
  unint64_t v10;
  __int128 v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  __int16 *v16;
  unsigned int grease_value;
  uint64_t v19;
  _BOOL4 v21;
  _QWORD *v23;
  _OWORD v24[3];
  _OWORD v25[3];

  v4 = *(_QWORD **)this;
  v5 = (_QWORD **)((char *)this + 392);
  std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)this + 49, 0);
  v6 = (_QWORD **)((char *)this + 400);
  std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)this + 50, 0);
  v7 = (char *)this + 616;
  OPENSSL_free(*((_QWORD **)this + 77));
  *(_OWORD *)((char *)this + 616) = 0u;
  if (*((unsigned __int16 *)this + 15) >= 0x304u)
  {
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v25[1] = v9;
    v25[2] = v9;
    v25[0] = v9;
    CBB_zero(v25);
    if (!CBB_init((uint64_t)v25, 0x40uLL))
      goto LABEL_23;
    if ((_DWORD)a2)
    {
LABEL_5:
      v10 = 0;
LABEL_6:
      *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v24[1] = v11;
      v24[2] = v11;
      v24[0] = v11;
      bssl::SSLKeyShare::Create((_QWORD *)a2, &v23);
      v12 = v23;
      v23 = 0;
      std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](v5, v12);
      std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](&v23, 0);
      if (*v5)
      {
        if (CBB_add_u16((uint64_t)v25, a2))
        {
          if (CBB_add_u16_length_prefixed((uint64_t *)v25, (uint64_t)v24))
          {
            if (((*(uint64_t (**)(_QWORD, _OWORD *))(**v5 + 24))(*v5, v24) & 1) != 0)
            {
              if (!(_DWORD)v10
                || (bssl::SSLKeyShare::Create((_QWORD *)v10, &v23),
                    v13 = v23,
                    v23 = 0,
                    std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](v6, v13),
                    std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](&v23, 0),
                    *v6)
                && CBB_add_u16((uint64_t)v25, v10)
                && CBB_add_u16_length_prefixed((uint64_t *)v25, (uint64_t)v24)
                && ((*(uint64_t (**)(_QWORD, _OWORD *))(**v6 + 24))(*v6, v24) & 1) != 0)
              {
                v8 = bssl::CBBFinishArray((uint64_t)v25, (uint64_t)v7);
LABEL_24:
                CBB_cleanup((uint64_t)v25);
                return v8;
              }
            }
          }
        }
      }
LABEL_23:
      v8 = 0;
      goto LABEL_24;
    }
    if ((*(_WORD *)(v4[15] + 840) & 0x20) != 0)
    {
      grease_value = bssl::ssl_get_grease_value((uint64_t)this, 1u);
      if (!CBB_add_u16((uint64_t)v25, grease_value)
        || !CBB_add_u16((uint64_t)v25, 1u)
        || !CBB_add_u8((uint64_t)v25, 0))
      {
        goto LABEL_23;
      }
    }
    v14 = *((_QWORD *)this + 1);
    v15 = *(_QWORD *)(v14 + 112);
    if (v15)
    {
      v16 = *(__int16 **)(v14 + 104);
      a2 = (unsigned __int16)*v16;
      if (v15 == 1)
        goto LABEL_5;
    }
    else
    {
      v16 = &bssl::kDefaultGroups;
      a2 = 29;
      v15 = 4;
    }
    v19 = 1;
    while (1)
    {
      v21 = (a2 - 65073) < 2 || (_DWORD)a2 == 16696;
      v10 = (unsigned __int16)v16[v19];
      if ((v10 - 65073) < 2 || (_DWORD)v10 == 16696)
      {
        if (!v21)
          goto LABEL_42;
      }
      else if (v21)
      {
LABEL_42:
        if ((_DWORD)v10 == (_DWORD)a2)
          __assert_rtn("ssl_setup_key_shares", "extensions.cc", 2335, "second_group_id != group_id");
        goto LABEL_43;
      }
      v10 = 0;
LABEL_43:
      if (!(_DWORD)v10 && ++v19 < v15)
        continue;
      goto LABEL_6;
    }
  }
  return 1;
}

void sub_1B4F8C294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  CBB_cleanup((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *bssl::SSLKeyShare::Create@<X0>(_QWORD *this@<X0>, _QWORD *a2@<X8>)
{
  int v3;
  void (**v4)(bssl::_anonymous_namespace_::X25519KeyShare *__hidden);
  _QWORD *v5;
  int v6;
  int v7;
  _QWORD *v8;

  if ((int)this <= 16695)
  {
    switch((int)this)
    {
      case 21:
        v7 = 713;
        v3 = 21;
        goto LABEL_12;
      case 23:
        v7 = 415;
        v3 = 23;
        goto LABEL_12;
      case 24:
        v7 = 715;
        v3 = 24;
        goto LABEL_12;
      case 25:
        v7 = 716;
        v3 = 25;
LABEL_12:
        v6 = v3;
        v5 = v8;
        v8 = 0;
        *a2 = v5;
      case 29:
        this = OPENSSL_malloc(0x28uLL);
        if (!this)
          goto LABEL_20;
        v4 = &off_1E686D968;
        goto LABEL_19;
      default:
        goto LABEL_22;
    }
  }
  switch((_DWORD)this)
  {
    case 0x4138:
      this = OPENSSL_malloc(0x738uLL);
      if (this)
      {
        v4 = &off_1E686D918;
        goto LABEL_19;
      }
      break;
    case 0xFE31:
      this = OPENSSL_malloc(8uLL);
      if (this)
      {
        v4 = &off_1E686DA08;
        goto LABEL_19;
      }
      break;
    case 0xFE32:
      this = OPENSSL_malloc(8uLL);
      if (this)
      {
        v4 = &off_1E686D9B8;
LABEL_19:
        *this = v4;
      }
      break;
    default:
LABEL_22:
      *a2 = 0;
      return this;
  }
LABEL_20:
  *a2 = this;
  return this;
}

BOOL bssl::`anonymous namespace'::X25519KeyShare::Offer(uint64_t a1, uint64_t a2)
{
  __int128 v3;
  _OWORD v5[2];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v5[0] = v3;
  v5[1] = v3;
  X25519_keypair(v5, (unsigned __int8 *)(a1 + 8));
  return CBB_add_bytes(a2, v5, 0x20uLL) != 0;
}

_BYTE *X25519_keypair(_BYTE *a1, unsigned __int8 *buf)
{
  RAND_bytes(buf, 32);
  *buf |= 7u;
  buf[31] = buf[31] & 0x3F | 0x80;
  return X25519_public_from_private(a1, (uint64_t)buf);
}

uint64_t bssl::ssl_add_client_hello(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  const ssl_session_st *v7;
  unint64_t v8;
  uint64_t (*v9)(uint64_t, void **);
  uint64_t v10;
  void *v12;
  size_t v13;
  void *v14;
  size_t v15;
  char v16;
  _OWORD v17[3];
  _OWORD v18[3];

  v3 = *(_QWORD *)this;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v18[1] = v4;
  v18[2] = v4;
  v18[0] = v4;
  CBB_zero(v18);
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[1] = v5;
  v17[2] = v5;
  v17[0] = v5;
  v6 = *((_QWORD *)this + 195);
  v16 = -86;
  v14 = 0;
  v15 = 0;
  if (!(*(unsigned int (**)(uint64_t, _OWORD *, _OWORD *, uint64_t))(*(_QWORD *)v3 + 88))(v3, v18, v17, 1))
    goto LABEL_9;
  v7 = (const ssl_session_st *)(2 * (v6 != 0));
  if (!bssl::ssl_write_client_hello_without_extensions((uint64_t)this, (uint64_t *)v17, (int)v7, 0))
    goto LABEL_9;
  v8 = CBB_len((uint64_t)v17);
  if (!bssl::ssl_add_clienthello_tlsext((uint64_t)this, (uint64_t *)v17, 0, &v16, v7, v8)
    || ((*(uint64_t (**)(uint64_t, _OWORD *, void **))(*(_QWORD *)v3 + 96))(v3, v18, &v14) & 1) == 0)
  {
    goto LABEL_9;
  }
  if (!v16)
    goto LABEL_8;
  if (v6)
    __assert_rtn("ssl_add_client_hello", "handshake_client.cc", 386, "type != ssl_client_hello_outer");
  if (bssl::tls13_write_psk_binder((uint64_t *)this, (ssl_session_st *)((char *)this + 424), (char *)v14, v15, 0))
  {
LABEL_8:
    v9 = *(uint64_t (**)(uint64_t, void **))(*(_QWORD *)v3 + 104);
    OPENSSL_free(0);
    v12 = v14;
    v13 = v15;
    v14 = 0;
    v15 = 0;
    v10 = v9(v3, &v12);
    OPENSSL_free(v12);
    v12 = 0;
    v13 = 0;
  }
  else
  {
LABEL_9:
    v10 = 0;
  }
  OPENSSL_free(v14);
  CBB_cleanup((uint64_t)v18);
  return v10;
}

void sub_1B4F8C668(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  bssl::Array<unsigned char>::~Array((uint64_t)va1);
  CBB_cleanup(v2 - 80);
  _Unwind_Resume(a1);
}

uint64_t bssl::tls_init_message(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  if (CBB_init((uint64_t)a2, 0x40uLL)
    && CBB_add_u8((uint64_t)a2, a4)
    && CBB_add_u24_length_prefixed(a2, a3))
  {
    return 1;
  }
  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 176);
  CBB_cleanup((uint64_t)a2);
  return 0;
}

uint64_t CBB_add_u24_length_prefixed(uint64_t *a1, uint64_t a2)
{
  return cbb_add_length_prefixed(a1, a2, 3u);
}

BOOL bssl::ssl_add_clienthello_tlsext(uint64_t a1, uint64_t *a2, uint64_t *a3, _BYTE *a4, const ssl_session_st *a5, uint64_t a6)
{
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  unsigned int v14;
  uint64_t *v15;
  uint64_t j;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  __int16 *v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t *v23;
  unsigned int v24;
  _QWORD *v25;
  size_t v26;
  __int128 v27;
  _QWORD *v28;
  size_t v29;
  _QWORD *v30;
  size_t v31;
  unint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  _BOOL8 v35;
  uint64_t v38;
  __int128 v39;
  unsigned int grease_value;
  uint64_t i;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  _BOOL4 v45;
  uint64_t *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int v56;
  uint64_t v57;
  const ssl_session_st *v58;
  const EVP_MD *digest;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  _BOOL4 v63;
  unint64_t v64;
  size_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  _BYTE *v76;
  _BYTE *v77;
  _OWORD v78[3];
  _OWORD v79[3];
  _OWORD v80[3];
  _OWORD v81[3];
  _OWORD v82[3];
  __int128 v83;
  __int128 v84;
  __int128 v85;

  *a4 = 0;
  if ((_DWORD)a5 != 1)
  {
    if (a3)
      bssl::ssl_add_clienthello_tlsext();
    v38 = *(_QWORD *)a1;
    *(_QWORD *)&v39 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v84 = v39;
    v85 = v39;
    v83 = v39;
    if (!CBB_add_u16_length_prefixed(a2, (uint64_t)&v83))
    {
      v47 = 3874;
LABEL_52:
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v47);
      return 0;
    }
    *(_DWORD *)(a1 + 376) = 0;
    if ((*(_WORD *)(*(_QWORD *)(v38 + 120) + 840) & 0x20) != 0)
    {
      grease_value = bssl::ssl_get_grease_value(a1, 2u);
      if (!bssl::add_padding_extension((uint64_t *)&v83, grease_value, 0))
        return 0;
    }
    v75 = a2;
    v77 = a4;
    for (i = 0; i != 27; ++i)
    {
      v42 = i;
      if (*(_QWORD *)(a1 + 720))
        v42 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 712) + i);
      v43 = CBB_len((uint64_t)&v83);
      if (!(*(unsigned int (**)(uint64_t, __int128 *, __int128 *, const ssl_session_st *))&bssl::kExtensions[20 * v42 + 4])(a1, &v83, &v83, a5))
      {
        ERR_put_error(16, 0, 147, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 3897);
        ERR_add_error_dataf("extension %u", v48, v49, v50, v51, v52, v53, v54, bssl::kExtensions[20 * v42]);
        return 0;
      }
      v44 = CBB_len((uint64_t)&v83);
      if (v44 != v43)
        *(_DWORD *)(a1 + 376) |= 1 << v42;
    }
    v45 = v44 - v43 == 4;
    if ((*(_WORD *)(*(_QWORD *)(v38 + 120) + 840) & 0x20) != 0)
    {
      v56 = bssl::ssl_get_grease_value(a1, 3u);
      v45 = 0;
      v35 = 0;
      v46 = v75;
      if (!bssl::add_padding_extension((uint64_t *)&v83, v56, 1uLL))
        return v35;
    }
    else
    {
      v46 = v75;
    }
    v57 = *(_QWORD *)a1;
    if (bssl::should_offer_psk((uint64_t *)a1, a5))
    {
      digest = bssl::ssl_session_get_digest(*(bssl **)(v57 + 104), v58);
      v60 = EVP_MD_size(digest) + *(_QWORD *)(*(_QWORD *)(v57 + 104) + 248) + 15;
    }
    else
    {
      v60 = 0;
    }
    if (SSL_is_dtls((unsigned __int8 **)v38)
      || *(_QWORD *)(v38 + 168)
      || (*(_WORD *)(*(_QWORD *)(v38 + 48) + 220) & 0x4000) != 0)
    {
LABEL_74:
      v73 = CBB_len((uint64_t)&v83);
      if ((bssl::ext_pre_shared_key_add_clienthello((uint64_t *)a1, (uint64_t *)&v83, v77, a5) & 1) != 0)
      {
        if (v60 != CBB_len((uint64_t)&v83) - v73)
          bssl::ssl_add_clienthello_tlsext();
        if (!CBB_len((uint64_t)&v83))
          CBB_discard_child(v46);
        return CBB_flush(v46) != 0;
      }
      v47 = 3971;
      goto LABEL_52;
    }
    v61 = a6 + v60 + CBB_len((uint64_t)&v83);
    v62 = v61 + 6;
    v63 = v60 == 0;
    v64 = v61 + 11;
    v65 = v45 & v63;
    if (!v45 || !v63)
      v64 = v62;
    if ((v64 & 0xFFFFFFFFFFFFFF00) == 0x100)
    {
      if (v62 > 0x1FB)
      {
        v65 = 1;
        goto LABEL_73;
      }
      v65 = 508 - v62;
    }
    if (!v65)
      goto LABEL_74;
LABEL_73:
    if (!bssl::add_padding_extension((uint64_t *)&v83, 0x15u, v65))
      return 0;
    goto LABEL_74;
  }
  v10 = *(_QWORD *)a1;
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v84 = v11;
  v85 = v11;
  v83 = v11;
  CBB_zero(&v83);
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v82[1] = v12;
  v82[2] = v12;
  v82[0] = v12;
  CBB_zero(v82);
  *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v81[1] = v13;
  v81[2] = v13;
  v80[2] = v13;
  v81[0] = v13;
  v80[0] = v13;
  v80[1] = v13;
  if (CBB_add_u16_length_prefixed(a2, (uint64_t)v81)
    && CBB_add_u16_length_prefixed(a3, (uint64_t)v80)
    && CBB_init((uint64_t)&v83, 0x40uLL)
    && CBB_init((uint64_t)v82, 0x40uLL))
  {
    *(_DWORD *)(a1 + 380) = 0;
    if ((*(_WORD *)(*(_QWORD *)(v10 + 120) + 840) & 0x20) == 0
      || (v14 = bssl::ssl_get_grease_value(a1, 2u), bssl::add_padding_extension((uint64_t *)&v83, v14, 0))
      && CBB_add_u16((uint64_t)v82, v14))
    {
      v74 = v10;
      v76 = a4;
      v15 = a2;
      for (j = 0; j != 27; ++j)
      {
        v17 = j;
        if (*(_QWORD *)(a1 + 720))
          v17 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 712) + j);
        v18 = CBB_len((uint64_t)v81);
        v19 = CBB_len((uint64_t)&v83);
        v20 = &bssl::kExtensions[20 * v17];
        if (((*((uint64_t (**)(uint64_t, _OWORD *, __int128 *, uint64_t))v20 + 1))(a1, v81, &v83, 1) & 1) == 0)
        {
          ERR_put_error(16, 0, 147, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 3790);
          ERR_add_error_dataf("extension %u", v66, v67, v68, v69, v70, v71, v72, *v20);
          goto LABEL_71;
        }
        v21 = CBB_len((uint64_t)v81);
        v22 = CBB_len((uint64_t)&v83);
        if (v21 != v18 && v22 != v19)
          __assert_rtn("ssl_add_clienthello_tlsext_inner", "extensions.cc", 3799, "bytes_written == 0 || bytes_written_compressed == 0");
        if (v21 != v18 || v22 != v19)
          *(_DWORD *)(a1 + 380) |= 1 << v17;
        if (v22 != v19 && !CBB_add_u16((uint64_t)v82, (unsigned __int16)*v20))
          goto LABEL_71;
      }
      v23 = v15;
      if ((*(_WORD *)(*(_QWORD *)(v74 + 120) + 840) & 0x20) == 0
        || (v24 = bssl::ssl_get_grease_value(a1, 3u), bssl::add_padding_extension((uint64_t *)&v83, v24, 1uLL))
        && CBB_add_u16((uint64_t)v82, v24))
      {
        v25 = CBB_data((uint64_t)v81);
        v26 = CBB_len((uint64_t)v81);
        if (CBB_add_bytes((uint64_t)v80, v25, v26))
        {
          if (!CBB_len((uint64_t)&v83))
            goto LABEL_85;
          *(_QWORD *)&v27 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v79[1] = v27;
          v79[2] = v27;
          v78[2] = v27;
          v79[0] = v27;
          v78[0] = v27;
          v78[1] = v27;
          v28 = CBB_data((uint64_t)&v83);
          v29 = CBB_len((uint64_t)&v83);
          if (CBB_add_bytes((uint64_t)v81, v28, v29))
          {
            if (CBB_add_u16((uint64_t)v80, 0xFD00u))
            {
              if (CBB_add_u16_length_prefixed((uint64_t *)v80, (uint64_t)v79))
              {
                if (CBB_add_u8_length_prefixed((uint64_t *)v79, (uint64_t)v78))
                {
                  v30 = CBB_data((uint64_t)v82);
                  v31 = CBB_len((uint64_t)v82);
                  if (CBB_add_bytes((uint64_t)v78, v30, v31))
                  {
                    if (CBB_flush((uint64_t *)v80))
                    {
LABEL_85:
                      v32 = CBB_len((uint64_t)v81);
                      if (bssl::ext_pre_shared_key_add_clienthello((uint64_t *)a1, (uint64_t *)v81, v76, (const ssl_session_st *)1))
                      {
                        v33 = CBB_data((uint64_t)v81);
                        v34 = CBB_len((uint64_t)v81);
                        if (CBB_add_bytes((uint64_t)v80, (char *)v33 + v32, v34 - v32))
                        {
                          if (CBB_flush(v23))
                          {
                            v35 = CBB_flush(a3) != 0;
                            goto LABEL_50;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_71:
    v35 = 0;
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 3766);
    v35 = 0;
  }
LABEL_50:
  CBB_cleanup((uint64_t)v82);
  CBB_cleanup((uint64_t)&v83);
  return v35;
}

void sub_1B4F8CDFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  CBB_cleanup(v1 - 192);
  CBB_cleanup(v1 - 144);
  _Unwind_Resume(a1);
}

unint64_t CBB_len(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t result;

  if (*(_QWORD *)a1)
    CBB_len_cold_2();
  if (!*(_BYTE *)(a1 + 8))
    return *(_QWORD *)(a1 + 24);
  v1 = *(_QWORD *)(a1 + 24) + *(unsigned __int8 *)(a1 + 32);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  result = v2 - v1;
  if (v2 < v1)
    CBB_len_cold_1();
  return result;
}

uint64_t bssl::ssl_get_grease_value(uint64_t a1, unsigned int a2)
{
  int v3;
  uint64_t result;

  v3 = *(_BYTE *)(a1 + a2 + 1644) & 0xF0 | 0xA;
  result = v3 | (v3 << 8);
  if (a2 == 3)
  {
    if (v3 == (*(_BYTE *)(a1 + 1646) & 0xF0 | 0xA))
      return result ^ 0x1010;
    else
      return result;
  }
  return result;
}

BOOL bssl::add_padding_extension(uint64_t *a1, unsigned int a2, size_t a3)
{
  __int128 v5;
  _OWORD v7[3];

  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v5;
  v7[2] = v5;
  v7[0] = v5;
  if (CBB_add_u16((uint64_t)a1, a2)
    && CBB_add_u16_length_prefixed(a1, (uint64_t)v7)
    && CBB_add_zeros((uint64_t)v7, a3))
  {
    return CBB_flush(a1) != 0;
  }
  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 3745);
  return 0;
}

uint64_t CBB_add_zeros(uint64_t a1, size_t a2)
{
  uint64_t result;
  void *v4;

  v4 = (void *)0xAAAAAAAAAAAAAAAALL;
  result = CBB_add_space(a1, &v4, a2);
  if ((_DWORD)result)
  {
    if (a2)
      bzero(v4, a2);
    return 1;
  }
  return result;
}

uint64_t bssl::ext_quic_transport_params_add_clienthello_impl(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v6;
  __int128 v8;
  unsigned int v9;
  uint64_t result;
  _OWORD v11[3];

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(*(_QWORD *)a1 + 168);
  if (!*(_QWORD *)(v3 + 248))
  {
    if (!v4)
      return 1;
LABEL_13:
    ERR_put_error(16, 0, 305, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2650);
    return 0;
  }
  if (!v4)
    goto LABEL_13;
  if (*(unsigned __int16 *)(a1 + 28) <= 0x303u)
    bssl::ext_quic_transport_params_add_clienthello_impl();
  v6 = *(_WORD *)(v3 + 313) & 0x200;
  if (a3 != v6 >> 9)
    return 1;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = v8;
  v11[2] = v8;
  v11[0] = v8;
  if (v6)
    v9 = 65445;
  else
    v9 = 57;
  result = CBB_add_u16((uint64_t)a2, v9);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v11);
    if ((_DWORD)result)
    {
      result = CBB_add_bytes((uint64_t)v11, *(const void **)(*(_QWORD *)(a1 + 8) + 240), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 248));
      if ((_DWORD)result)
        return CBB_flush(a2) != 0;
    }
  }
  return result;
}

bssl *bssl::should_offer_psk(uint64_t *a1, const ssl_session_st *a2)
{
  bssl *result;
  uint64_t v4;
  int v5;
  unsigned int v6;

  if (*((unsigned __int16 *)a1 + 15) < 0x304u)
    return 0;
  v4 = *a1;
  result = *(bssl **)(*a1 + 104);
  if (result)
  {
    v5 = (int)a2;
    v6 = bssl::ssl_session_protocol_version(result, a2);
    result = 0;
    if (v5 != 2 && v6 >= 0x304)
      return (bssl *)((*(_WORD *)(*(_QWORD *)(v4 + 48) + 220) & 0x4000) == 0
                   || *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 104) + 208) + 36) == *(_DWORD *)(a1[196] + 36));
  }
  return result;
}

uint64_t bssl::ssl_add_message_cbb(uint64_t a1, uint64_t a2)
{
  uint64_t (*v3)(uint64_t, void **);
  uint64_t v4;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;

  v8 = 0;
  v9 = 0;
  if ((*(unsigned int (**)(uint64_t, uint64_t, void **))(*(_QWORD *)a1 + 96))(a1, a2, &v8))
  {
    v3 = *(uint64_t (**)(uint64_t, void **))(*(_QWORD *)a1 + 104);
    OPENSSL_free(0);
    v6 = v8;
    v7 = v9;
    v8 = 0;
    v9 = 0;
    v4 = v3(a1, &v6);
    OPENSSL_free(v6);
    v6 = 0;
    v7 = 0;
  }
  else
  {
    v4 = 0;
  }
  OPENSSL_free(v8);
  return v4;
}

void sub_1B4F8D1CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  bssl::Array<unsigned char>::~Array((uint64_t)&a11);
  _Unwind_Resume(a1);
}

BOOL bssl::tls_finish_message(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return bssl::CBBFinishArray(a2, a3);
}

uint64_t bssl::tls_add_message(bssl *this, unint64_t *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t result;
  BUF_MEM **v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  size_t v15;
  size_t v16;
  char *v17;
  BUF_MEM *v18;
  unint64_t v19;
  const unsigned __int8 *v20;
  char v21;
  uint64_t v22;

  v4 = *a2;
  v5 = a2[1];
  if (*((_QWORD *)this + 21) || **(_QWORD **)(*((_QWORD *)this + 6) + 272))
  {
    while (1)
    {
      if (!v5)
        goto LABEL_30;
      v6 = *((_QWORD *)this + 6);
      v9 = *(_QWORD *)(v6 + 232);
      v8 = (BUF_MEM **)(v6 + 232);
      result = v9;
      v10 = *((unsigned __int16 *)this + 9);
      if (!v9)
        break;
      if (*(_QWORD *)result < v10)
        goto LABEL_8;
      result = bssl::tls_flush_pending_hs_data(this, (ssl_st *)a2);
      if (!(_DWORD)result)
        return result;
      v11 = *((_QWORD *)this + 6);
      v12 = *(_QWORD *)(v11 + 232);
      v8 = (BUF_MEM **)(v11 + 232);
      result = v12;
      if (v12)
      {
LABEL_8:
        v13 = 0;
        v14 = *(_QWORD *)result;
      }
      else
      {
        v14 = 0;
        v13 = 1;
      }
      v15 = *((unsigned __int16 *)this + 9) - v14;
      if (v5 >= v15)
        v16 = v15;
      else
        v16 = v5;
      if (!v16)
LABEL_35:
        bssl::tls_add_message();
      v17 = (char *)(v4 + v16);
      v5 -= v16;
      if (v13)
        goto LABEL_21;
      if (!result)
        return result;
LABEL_22:
      result = BUF_MEM_append((_QWORD *)result, (const void *)v4, v16);
      v4 = (unint64_t)v17;
      if (!(_DWORD)result)
        return result;
    }
    if (v5 >= v10)
      v16 = *((unsigned __int16 *)this + 9);
    else
      v16 = v5;
    if (!v16)
      goto LABEL_35;
    v17 = (char *)(v4 + v16);
    v5 -= v16;
LABEL_21:
    v18 = BUF_MEM_new();
    std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v8, v18);
    result = *(_QWORD *)(*((_QWORD *)this + 6) + 232);
    if (!result)
      return result;
    goto LABEL_22;
  }
  while (v5)
  {
    if (v5 >= *((unsigned __int16 *)this + 9))
      v19 = *((unsigned __int16 *)this + 9);
    else
      v19 = v5;
    v20 = (const unsigned __int8 *)(v4 + v19);
    v5 -= v19;
    v21 = bssl::add_record_to_flight(this, (ssl_st *)0x16, v4, (const unsigned __int8 *)v19);
    v4 = (unint64_t)v20;
    if ((v21 & 1) == 0)
      return 0;
  }
LABEL_30:
  bssl::ssl_do_msg_callback((uint64_t)this, 1, 22, *a2, a2[1]);
  v22 = *(_QWORD *)(*((_QWORD *)this + 6) + 280);
  if (!v22)
    return 1;
  result = bssl::SSLTranscript::Update((_QWORD **)(v22 + 424), (const void *)*a2, a2[1]);
  if ((_DWORD)result)
    return 1;
  return result;
}

uint64_t bssl::ext_quic_transport_params_add_clienthello_legacy(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return bssl::ext_quic_transport_params_add_clienthello_impl(a1, a3, 1);
}

uint64_t bssl::ext_server_certificate_type_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];
  _OWORD v8[3];

  if (*(unsigned __int16 *)(a1 + 30) < 0x304u || !*(_QWORD *)(*(_QWORD *)(a1 + 8) + 176))
    return 1;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v5;
  v8[2] = v5;
  v7[2] = v5;
  v8[0] = v5;
  v7[0] = v5;
  v7[1] = v5;
  result = CBB_add_u16((uint64_t)a3, 0x14u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      result = CBB_add_u8_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        result = CBB_add_bytes((uint64_t)v7, *(const void **)(*(_QWORD *)(a1 + 8) + 168), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 176));
        if ((_DWORD)result)
          return CBB_flush(a3) != 0;
      }
    }
  }
  return result;
}

uint64_t bssl::ext_client_certificate_type_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];
  _OWORD v8[3];

  if (*(unsigned __int16 *)(a1 + 30) < 0x304u || !*(_QWORD *)(*(_QWORD *)(a1 + 8) + 208))
    return 1;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v5;
  v8[2] = v5;
  v7[2] = v5;
  v8[0] = v5;
  v7[0] = v5;
  v7[1] = v5;
  result = CBB_add_u16((uint64_t)a3, 0x13u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      result = CBB_add_u8_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        result = CBB_add_bytes((uint64_t)v7, *(const void **)(*(_QWORD *)(a1 + 8) + 200), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 208));
        if ((_DWORD)result)
          return CBB_flush(a3) != 0;
      }
    }
  }
  return result;
}

uint64_t bssl::ext_psk_key_exchange_modes_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  __int128 v5;
  _OWORD v6[3];
  _OWORD v7[3];

  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    return 1;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v5;
  v7[2] = v5;
  v6[2] = v5;
  v7[0] = v5;
  v6[0] = v5;
  v6[1] = v5;
  result = CBB_add_u16((uint64_t)a3, 0x2Du);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v7);
    if ((_DWORD)result)
    {
      result = CBB_add_u8_length_prefixed((uint64_t *)v7, (uint64_t)v6);
      if ((_DWORD)result)
      {
        result = CBB_add_u8((uint64_t)v6, 1u);
        if ((_DWORD)result)
          return CBB_flush(a3) != 0;
      }
    }
  }
  return result;
}

uint64_t bssl::ext_quic_transport_params_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return bssl::ext_quic_transport_params_add_clienthello_impl(a1, a3, 0);
}

uint64_t bssl::ext_delegated_credential_add_clienthello()
{
  return 1;
}

uint64_t bssl::ext_supported_versions_add_clienthello(unsigned __int16 *a1, uint64_t *a2, uint64_t *a3, int a4)
{
  uint64_t result;
  uint64_t v7;
  __int128 v9;
  unsigned int grease_value;
  unsigned int v11;
  int v12;
  _OWORD v13[3];
  _OWORD v14[3];

  if (a1[15] < 0x304u)
    return 1;
  v7 = *(_QWORD *)a1;
  if (a1[14] <= 0x303u)
    a3 = a2;
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = v9;
  v14[2] = v9;
  v13[2] = v9;
  v14[0] = v9;
  v13[0] = v9;
  v13[1] = v9;
  result = CBB_add_u16((uint64_t)a3, 0x2Bu);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v14);
    if ((_DWORD)result)
    {
      result = CBB_add_u8_length_prefixed((uint64_t *)v14, (uint64_t)v13);
      if ((_DWORD)result)
      {
        if ((*(_WORD *)(*(_QWORD *)(v7 + 120) + 840) & 0x20) == 0
          || (grease_value = bssl::ssl_get_grease_value((uint64_t)a1, 4u),
              result = CBB_add_u16((uint64_t)v13, grease_value),
              (_DWORD)result))
        {
          if (a4 == 1)
            v11 = 772;
          else
            v11 = 0;
          v12 = bssl::ssl_add_supported_versions((bssl *)a1, (uint64_t)v13, v11);
          result = 0;
          if (v12)
            return CBB_flush(a3) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ext_supported_groups_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t result;
  __int128 v7;
  unsigned int grease_value;
  uint64_t v9;
  uint64_t v10;
  __int16 *v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  _OWORD v15[3];
  _OWORD v16[3];

  v5 = *(_QWORD *)a1;
  result = CBB_add_u16((uint64_t)a3, 0xAu);
  if ((_DWORD)result)
  {
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v16[1] = v7;
    v16[2] = v7;
    v15[2] = v7;
    v16[0] = v7;
    v15[0] = v7;
    v15[1] = v7;
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v16);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v16, (uint64_t)v15);
      if ((_DWORD)result)
      {
        if ((*(_WORD *)(*(_QWORD *)(v5 + 120) + 840) & 0x20) == 0
          || (grease_value = bssl::ssl_get_grease_value(a1, 1u),
              result = CBB_add_u16((uint64_t)v15, grease_value),
              (_DWORD)result))
        {
          v9 = *(_QWORD *)(a1 + 8);
          v10 = *(_QWORD *)(v9 + 112);
          if (v10)
          {
            v11 = *(__int16 **)(v9 + 104);
          }
          else
          {
            v11 = &bssl::kDefaultGroups;
            v10 = 4;
          }
          v12 = 2 * v10;
          while (1)
          {
            v13 = (unsigned __int16)*v11;
            v14 = v13 - 65073 < 2 || v13 == 16696;
            if (!v14 || *(unsigned __int16 *)(a1 + 30) >= 0x304u)
            {
              result = CBB_add_u16((uint64_t)v15, v13);
              if (!(_DWORD)result)
                break;
            }
            ++v11;
            v12 -= 2;
            if (!v12)
              return CBB_flush(a3) != 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ext_ticket_request_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v6;
  __int128 v7;
  _OWORD v8[3];

  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    return 1;
  v6 = *(_QWORD *)(a1 + 8);
  if (!*(_BYTE *)(v6 + 232) && !*(_BYTE *)(v6 + 233))
    return 1;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v7;
  v8[2] = v7;
  v8[0] = v7;
  result = CBB_add_u16((uint64_t)a3, 0x3Au);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      result = CBB_add_u8((uint64_t)v8, *(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 232));
      if ((_DWORD)result)
      {
        result = CBB_add_u8((uint64_t)v8, *(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 233));
        if ((_DWORD)result)
          return CBB_flush(a3) != 0;
      }
    }
  }
  return result;
}

uint64_t bssl::ext_pre_shared_key_add_clienthello(uint64_t *a1, uint64_t *a2, _BYTE *a3, const ssl_session_st *a4)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  const ssl_session_st *v12;
  const EVP_MD *digest;
  size_t v14;
  __int128 v15;
  uint64_t result;
  _OWORD v17[3];
  _OWORD v18[3];
  _OWORD v19[3];
  _OWORD v20[3];
  _OWORD v21[3];
  _QWORD v22[2];

  v6 = *a1;
  *a3 = 0;
  if (!bssl::should_offer_psk(a1, a4))
    return 1;
  v22[0] = 0xAAAAAAAAAAAAAAAALL;
  v22[1] = 0xAAAAAAAAAAAAAAAALL;
  bssl::ssl_get_current_time(v6, (uint64_t)v22);
  v7 = v22[0];
  v8 = *(_QWORD *)(v6 + 104);
  v9 = *(_DWORD *)(v8 + 200);
  v10 = *(_DWORD *)(v8 + 384);
  v11 = *(char *)(v8 + 448);
  digest = bssl::ssl_session_get_digest((bssl *)v8, v12);
  v14 = EVP_MD_size(digest);
  *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v21[1] = v15;
  v21[2] = v15;
  v21[0] = v15;
  v20[1] = v15;
  v20[2] = v15;
  v19[2] = v15;
  v20[0] = v15;
  v19[0] = v15;
  v19[1] = v15;
  v18[1] = v15;
  v18[2] = v15;
  v17[2] = v15;
  v18[0] = v15;
  v17[0] = v15;
  v17[1] = v15;
  result = CBB_add_u16((uint64_t)a2, 0x29u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v21);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v21, (uint64_t)v20);
      if ((_DWORD)result)
      {
        result = CBB_add_u16_length_prefixed((uint64_t *)v20, (uint64_t)v19);
        if ((_DWORD)result)
        {
          result = CBB_add_bytes((uint64_t)v19, *(const void **)(*(_QWORD *)(v6 + 104) + 240), *(_QWORD *)(*(_QWORD *)(v6 + 104) + 248));
          if ((_DWORD)result)
          {
            result = CBB_add_u32((uint64_t)v20, (v10 + 1000 * (v7 - v9)) & ~(v11 >> 31));
            if ((_DWORD)result)
            {
              result = CBB_add_u16_length_prefixed((uint64_t *)v21, (uint64_t)v18);
              if ((_DWORD)result)
              {
                result = CBB_add_u8_length_prefixed((uint64_t *)v18, (uint64_t)v17);
                if ((_DWORD)result)
                {
                  result = CBB_add_zeros((uint64_t)v17, v14);
                  if ((_DWORD)result)
                  {
                    *a3 = 1;
                    return CBB_flush(a2) != 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t bssl::cert_compression_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  char v9;
  uint64_t result;
  _OWORD v12[3];
  _OWORD v13[3];

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 120);
  v4 = *(_QWORD *)(v3 + 720);
  if (!v4)
    return 1;
  v6 = *(_QWORD *)(v3 + 728);
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v13[1] = v7;
  v13[2] = v7;
  v8 = v6 + 24 * v4;
  v12[2] = v7;
  v13[0] = v7;
  v12[0] = v7;
  v12[1] = v7;
  v9 = 1;
  while (2)
  {
    for (v6 += 24; !*(_QWORD *)(v6 - 16); v6 += 24)
    {
      if (v6 == v8)
      {
        if ((v9 & 1) != 0)
          return 1;
        return CBB_flush(a3) != 0;
      }
    }
    if ((v9 & 1) == 0
      || (result = CBB_add_u16((uint64_t)a3, 0x1Bu), (_DWORD)result)
      && (result = CBB_add_u16_length_prefixed(a3, (uint64_t)v13), (_DWORD)result)
      && (result = CBB_add_u8_length_prefixed((uint64_t *)v13, (uint64_t)v12), (_DWORD)result))
    {
      result = CBB_add_u16((uint64_t)v12, *(unsigned __int16 *)(v6 - 8));
      if ((_DWORD)result)
      {
        v9 = 0;
        if (v6 != v8)
          continue;
        return CBB_flush(a3) != 0;
      }
    }
    break;
  }
  return result;
}

uint64_t bssl::ext_early_data_add_clienthello(_BYTE *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t result;

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 48);
  if ((*(_WORD *)(v3 + 220) & 0x4000) != 0)
  {
    if (!*(_DWORD *)(v3 + 256))
      bssl::ext_early_data_add_clienthello();
    return 1;
  }
  if ((a1[1601] & 0x10) == 0)
    return 1;
  result = CBB_add_u16((uint64_t)a3, 0x2Au);
  if ((_DWORD)result)
  {
    result = CBB_add_u16((uint64_t)a3, 0);
    if ((_DWORD)result)
      return CBB_flush(a3) != 0;
  }
  return result;
}

uint64_t bssl::ext_channel_id_add_clienthello(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int is_dtls;
  uint64_t result;

  if (!*(_QWORD *)(*(_QWORD *)(a1 + 8) + 120))
    return 1;
  is_dtls = SSL_is_dtls(*(unsigned __int8 ***)a1);
  result = 1;
  if (a4 != 2 && !is_dtls)
  {
    result = CBB_add_u16(a2, 0x7550u);
    if ((_DWORD)result)
      return CBB_add_u16(a2, 0) != 0;
  }
  return result;
}

uint64_t bssl::ext_key_share_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  __int128 v6;
  _OWORD v7[3];
  _OWORD v8[3];

  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    return 1;
  if (!*(_QWORD *)(a1 + 624))
    bssl::ext_key_share_add_clienthello();
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v6;
  v8[2] = v6;
  v7[2] = v6;
  v8[0] = v6;
  v7[0] = v6;
  v7[1] = v6;
  result = CBB_add_u16((uint64_t)a3, 0x33u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        result = CBB_add_bytes((uint64_t)v7, *(const void **)(a1 + 616), *(_QWORD *)(a1 + 624));
        if ((_DWORD)result)
          return CBB_flush(a3) != 0;
      }
    }
  }
  return result;
}

uint64_t bssl::ext_ec_point_add_clienthello(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  if (a4 == 1 || *(unsigned __int16 *)(a1 + 28) > 0x303u)
    return 1;
  else
    return bssl::ext_ec_point_add_extension(a2);
}

uint64_t bssl::ext_sigalgs_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  __int128 v6;
  _OWORD v7[3];
  _OWORD v8[3];

  if (*(unsigned __int16 *)(a1 + 30) < 0x303u)
    return 1;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v6;
  v8[2] = v6;
  v7[2] = v6;
  v8[0] = v6;
  v7[0] = v6;
  v7[1] = v6;
  result = CBB_add_u16((uint64_t)a3, 0xDu);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        result = bssl::tls12_add_verify_sigalgs(a1, (uint64_t)v7);
        if ((_DWORD)result)
          return CBB_flush(a3) != 0;
      }
    }
  }
  return result;
}

uint64_t bssl::ext_ticket_add_clienthello(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v9;
  const ssl_session_st *v10;
  bssl *v11;
  uint64_t v12;
  size_t v13;
  const void *v14;
  __int128 v15;
  _OWORD v16[3];
  uint64_t v17;
  uint64_t v18;

  result = 1;
  if (a4 != 1)
  {
    v17 = v4;
    v18 = v5;
    if (*(unsigned __int16 *)(a1 + 28) <= 0x303u)
    {
      v9 = *(_QWORD *)a1;
      if ((SSL_get_options(*(_QWORD *)a1) & 0x4000) != 0)
      {
        return 1;
      }
      else
      {
        if ((*(_WORD *)(*(_QWORD *)(v9 + 48) + 220) & 0x20) == 0
          && (v11 = *(bssl **)(v9 + 104)) != 0
          && *((_QWORD *)v11 + 31)
          && bssl::ssl_session_protocol_version(v11, v10) <= 0x303)
        {
          v12 = *(_QWORD *)(v9 + 104);
          v14 = *(const void **)(v12 + 240);
          v13 = *(_QWORD *)(v12 + 248);
        }
        else
        {
          v13 = 0;
          v14 = 0;
        }
        *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v16[1] = v15;
        v16[2] = v15;
        v16[0] = v15;
        result = CBB_add_u16((uint64_t)a2, 0x23u);
        if ((_DWORD)result)
        {
          result = CBB_add_u16_length_prefixed(a2, (uint64_t)v16);
          if ((_DWORD)result)
          {
            result = CBB_add_bytes((uint64_t)v16, v14, v13);
            if ((_DWORD)result)
              return CBB_flush(a2) != 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ext_cookie_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];
  _OWORD v8[3];

  if (!*(_QWORD *)(a1 + 544))
    return 1;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v5;
  v8[2] = v5;
  v7[2] = v5;
  v8[0] = v5;
  v7[0] = v5;
  v7[1] = v5;
  result = CBB_add_u16((uint64_t)a3, 0x2Cu);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        result = CBB_add_bytes((uint64_t)v7, *(const void **)(a1 + 536), *(_QWORD *)(a1 + 544));
        if ((_DWORD)result)
          return CBB_flush(a3) != 0;
      }
    }
  }
  return result;
}

uint64_t bssl::ext_srtp_add_clienthello(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  unsigned __int8 **v4;
  const STACK *srtp_profiles;
  const STACK *v6;
  __int128 v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  _OWORD v13[3];
  _OWORD v14[3];

  v4 = (unsigned __int8 **)*a1;
  srtp_profiles = (const STACK *)SSL_get_srtp_profiles(*a1);
  if (!srtp_profiles)
    return 1;
  v6 = srtp_profiles;
  if (!sk_num(srtp_profiles) || !SSL_is_dtls(v4))
    return 1;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = v7;
  v14[2] = v7;
  v13[2] = v7;
  v14[0] = v7;
  v13[0] = v7;
  v13[1] = v7;
  result = CBB_add_u16((uint64_t)a3, 0xEu);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v14);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v14, (uint64_t)v13);
      if ((_DWORD)result)
      {
        v9 = sk_num(v6);
        if (v9)
        {
          v10 = v9;
          v11 = 0;
          while (1)
          {
            v12 = sk_value(v6, v11);
            result = CBB_add_u16((uint64_t)v13, *((unsigned __int16 *)v12 + 4));
            if (!(_DWORD)result)
              break;
            if (v10 == ++v11)
              goto LABEL_11;
          }
        }
        else
        {
LABEL_11:
          result = CBB_add_u8((uint64_t)v14, 0);
          if ((_DWORD)result)
            return CBB_flush(a3) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ext_ocsp_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  __int128 v5;
  _OWORD v6[3];

  if ((*(_WORD *)(*(_QWORD *)(a1 + 8) + 313) & 4) == 0)
    return 1;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = v5;
  v6[2] = v5;
  v6[0] = v5;
  result = CBB_add_u16((uint64_t)a3, 5u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v6);
    if ((_DWORD)result)
    {
      result = CBB_add_u8((uint64_t)v6, 1u);
      if ((_DWORD)result)
      {
        result = CBB_add_u16((uint64_t)v6, 0);
        if ((_DWORD)result)
        {
          result = CBB_add_u16((uint64_t)v6, 0);
          if ((_DWORD)result)
            return CBB_flush(a3) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ext_alps_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  __int128 v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _OWORD v12[3];
  _OWORD v13[3];
  _OWORD v14[3];

  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    return 1;
  v4 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v4 + 136)
    || !*(_QWORD *)(v4 + 144)
    || (*(_WORD *)(*(_QWORD *)(*(_QWORD *)a1 + 48) + 220) & 0x20) != 0)
  {
    return 1;
  }
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = v6;
  v14[2] = v6;
  v14[0] = v6;
  v13[1] = v6;
  v13[2] = v6;
  v12[2] = v6;
  v13[0] = v6;
  v12[0] = v6;
  v12[1] = v6;
  result = CBB_add_u16((uint64_t)a3, 0x4469u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v14);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v14, (uint64_t)v13);
      if ((_DWORD)result)
      {
        v8 = *(_QWORD *)(a1 + 8);
        v9 = *(_QWORD *)(v8 + 144);
        if (v9)
        {
          v10 = *(_QWORD *)(v8 + 152);
          v11 = v10 + 32 * v9;
          while (1)
          {
            result = CBB_add_u8_length_prefixed((uint64_t *)v13, (uint64_t)v12);
            if (!(_DWORD)result)
              break;
            result = CBB_add_bytes((uint64_t)v12, *(const void **)v10, *(_QWORD *)(v10 + 8));
            if (!(_DWORD)result)
              break;
            v10 += 32;
            if (v10 == v11)
              return CBB_flush(a3) != 0;
          }
        }
        else
        {
          return CBB_flush(a3) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ext_alpn_add_clienthello(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  __int128 v6;
  uint64_t result;
  _OWORD v8[3];
  _OWORD v9[3];

  v3 = *a1;
  if (!*(_QWORD *)(a1[1] + 136))
  {
    if (*(_QWORD *)(v3 + 168))
    {
      ERR_put_error(16, 0, 307, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1433);
      return 0;
    }
    return 1;
  }
  if ((*(_WORD *)(*(_QWORD *)(v3 + 48) + 220) & 0x20) != 0)
    return 1;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v6;
  v9[2] = v6;
  v8[2] = v6;
  v9[0] = v6;
  v8[0] = v6;
  v8[1] = v6;
  result = CBB_add_u16((uint64_t)a3, 0x10u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a3, (uint64_t)v9);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v9, (uint64_t)v8);
      if ((_DWORD)result)
      {
        result = CBB_add_bytes((uint64_t)v8, *(const void **)(a1[1] + 128), *(_QWORD *)(a1[1] + 136));
        if ((_DWORD)result)
          return CBB_flush(a3) != 0;
      }
    }
  }
  return result;
}

uint64_t bssl::ext_sni_add_clienthello(_QWORD *a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v5;
  const void *v6;
  size_t v7;
  __int128 v8;
  uint64_t result;
  _OWORD v10[3];
  _OWORD v11[3];
  _OWORD v12[3];

  if (a4 == 2)
  {
    v5 = a1[195];
    v6 = *(const void **)(v5 + 32);
    v7 = *(_QWORD *)(v5 + 40);
  }
  else
  {
    v6 = *(const void **)(*a1 + 160);
    if (!v6)
      return 1;
    v7 = strlen(*(const char **)(*a1 + 160));
  }
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[1] = v8;
  v12[2] = v8;
  v12[0] = v8;
  v11[1] = v8;
  v11[2] = v8;
  v10[2] = v8;
  v11[0] = v8;
  v10[0] = v8;
  v10[1] = v8;
  result = CBB_add_u16((uint64_t)a2, 0);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v12);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v12, (uint64_t)v11);
      if ((_DWORD)result)
      {
        result = CBB_add_u8((uint64_t)v11, 0);
        if ((_DWORD)result)
        {
          result = CBB_add_u16_length_prefixed((uint64_t *)v11, (uint64_t)v10);
          if ((_DWORD)result)
          {
            result = CBB_add_bytes((uint64_t)v10, v6, v7);
            if ((_DWORD)result)
              return CBB_flush(a2) != 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t CBB_add_u16_length_prefixed(uint64_t *a1, uint64_t a2)
{
  return cbb_add_length_prefixed(a1, a2, 2u);
}

uint64_t bssl::ext_sct_add_clienthello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if ((*(_WORD *)(*(_QWORD *)(a1 + 8) + 313) & 2) == 0)
    return 1;
  result = CBB_add_u16(a3, 0x12u);
  if ((_DWORD)result)
    return CBB_add_u16(a3, 0) != 0;
  return result;
}

uint64_t bssl::ext_npn_add_clienthello(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5;
  uint64_t result;

  v5 = *a1;
  if (!*(_QWORD *)(*(_QWORD *)(v5 + 120) + 592)
    || (*(_WORD *)(*(_QWORD *)(v5 + 48) + 220) & 0x20) != 0
    || SSL_is_dtls((unsigned __int8 **)v5))
  {
    return 1;
  }
  result = 1;
  if (a4 != 1 && *((unsigned __int16 *)a1 + 14) <= 0x303u)
  {
    result = CBB_add_u16(a2, 0x3374u);
    if ((_DWORD)result)
      return CBB_add_u16(a2, 0) != 0;
  }
  return result;
}

uint64_t bssl::ext_ems_add_clienthello(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result;

  result = 1;
  if (a4 != 1 && *(unsigned __int16 *)(a1 + 28) <= 0x303u)
  {
    result = CBB_add_u16(a2, 0x17u);
    if ((_DWORD)result)
      return CBB_add_u16(a2, 0) != 0;
  }
  return result;
}

uint64_t bssl::ext_ech_add_clienthello(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t result;
  int v6;
  __int128 v8;
  _OWORD v9[3];

  if (a4 == 1)
  {
    result = CBB_add_u16((uint64_t)a2, 0xFE0Du);
    if ((_DWORD)result)
    {
      result = CBB_add_u16((uint64_t)a2, 1u);
      if ((_DWORD)result)
      {
        v6 = CBB_add_u8((uint64_t)a2, 1u);
        return v6 != 0;
      }
    }
  }
  else if (*(_QWORD *)(a1 + 576))
  {
    *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[1] = v8;
    v9[2] = v8;
    v9[0] = v8;
    result = CBB_add_u16((uint64_t)a2, 0xFE0Du);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed(a2, (uint64_t)v9);
      if ((_DWORD)result)
      {
        result = CBB_add_u8((uint64_t)v9, 0);
        if ((_DWORD)result)
        {
          result = CBB_add_bytes((uint64_t)v9, *(const void **)(a1 + 568), *(_QWORD *)(a1 + 576));
          if ((_DWORD)result)
          {
            v6 = CBB_flush(a2);
            return v6 != 0;
          }
        }
      }
    }
  }
  else
  {
    return 1;
  }
  return result;
}

uint64_t bssl::ext_ri_add_clienthello(unsigned __int16 *a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t result;
  uint64_t v6;
  __int128 v8;
  _OWORD v9[3];
  _OWORD v10[3];

  result = 1;
  if (a4 != 1 && a1[14] <= 0x303u)
  {
    v6 = *(_QWORD *)a1;
    if ((*(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 48) + 455) != 0) != (*(_WORD *)(*(_QWORD *)(*(_QWORD *)a1 + 48)
                                                                                   + 220) & 0x20u) >> 5)
      bssl::ext_ri_add_clienthello();
    *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v10[1] = v8;
    v10[2] = v8;
    v9[2] = v8;
    v10[0] = v8;
    v9[0] = v8;
    v9[1] = v8;
    result = CBB_add_u16((uint64_t)a2, 0xFF01u);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed(a2, (uint64_t)v10);
      if ((_DWORD)result)
      {
        result = CBB_add_u8_length_prefixed((uint64_t *)v10, (uint64_t)v9);
        if ((_DWORD)result)
        {
          result = CBB_add_bytes((uint64_t)v9, (const void *)(*(_QWORD *)(v6 + 48) + 443), *(unsigned __int8 *)(*(_QWORD *)(v6 + 48) + 455));
          if ((_DWORD)result)
            return CBB_flush(a2) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ssl_write_client_hello_without_extensions(uint64_t a1, uint64_t *a2, int a3, char a4)
{
  uint64_t v8;
  uint64_t result;
  const void *v10;
  __int128 v11;
  uint64_t v12;
  _BOOL4 v13;
  __int128 v14;
  unsigned int grease_value;
  int is_opaque;
  char v17;
  unsigned int v18;
  STACK *ciphers;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  int v24;
  int v25;
  char *v26;
  uint64_t v27;
  unsigned int protocol_id;
  uint64_t v30;
  _OWORD v31[3];
  _OWORD v32[3];

  v8 = *(_QWORD *)a1;
  result = CBB_add_u16((uint64_t)a2, *(unsigned __int16 *)(a1 + 1604));
  if (!(_DWORD)result)
    return result;
  v10 = (const void *)(a3 == 1 ? a1 + 504 : *(_QWORD *)(v8 + 48) + 48);
  result = CBB_add_bytes((uint64_t)a2, v10, 0x20uLL);
  if (!(_DWORD)result)
    return result;
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v31[1] = v11;
  v31[2] = v11;
  v31[0] = v11;
  result = CBB_add_u8_length_prefixed(a2, (uint64_t)v31);
  if (!(_DWORD)result)
    return result;
  if ((*(_WORD *)(*(_QWORD *)(v8 + 48) + 220) & 0x20) == 0 && (a4 & 1) == 0)
  {
    result = CBB_add_bytes((uint64_t)v31, (const void *)(a1 + 1611), *(unsigned __int8 *)(a1 + 1643));
    if (!(_DWORD)result)
      return result;
  }
  if (SSL_is_dtls((unsigned __int8 **)v8))
  {
    result = CBB_add_u8_length_prefixed(a2, (uint64_t)v31);
    if (!(_DWORD)result)
      return result;
    result = CBB_add_bytes((uint64_t)v31, *(const void **)(a1 + 552), *(_QWORD *)(a1 + 560));
    if (!(_DWORD)result)
      return result;
  }
  v12 = *(_QWORD *)a1;
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) == 0;
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v32[1] = v14;
  v32[2] = v14;
  v32[0] = v14;
  if (!CBB_add_u16_length_prefixed(a2, (uint64_t)v32))
    return 0;
  if ((*(_WORD *)(*(_QWORD *)(v12 + 120) + 840) & 0x20) != 0)
  {
    grease_value = bssl::ssl_get_grease_value(a1, 0);
    if (!CBB_add_u16((uint64_t)v32, grease_value))
      return 0;
  }
  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    goto LABEL_33;
  is_opaque = RSA_is_opaque();
  v17 = *(_BYTE *)(*(_QWORD *)(**(_QWORD **)(a1 + 8) + 120) + 240);
  if (is_opaque)
  {
    if ((*(_BYTE *)(*(_QWORD *)(**(_QWORD **)(a1 + 8) + 120) + 240) & 2) == 0)
      goto LABEL_23;
    if (CBB_add_u16((uint64_t)v32, 0x1301u))
    {
      v17 = *(_BYTE *)(*(_QWORD *)(**(_QWORD **)(a1 + 8) + 120) + 240);
      if ((v17 & 2) == 0)
        goto LABEL_23;
      if (CBB_add_u16((uint64_t)v32, 0x1302u))
      {
        v17 = *(_BYTE *)(*(_QWORD *)(**(_QWORD **)(a1 + 8) + 120) + 240);
LABEL_23:
        if ((v17 & 4) != 0)
        {
          v18 = 4867;
          goto LABEL_25;
        }
        goto LABEL_33;
      }
    }
    return 0;
  }
  if ((*(_BYTE *)(*(_QWORD *)(**(_QWORD **)(a1 + 8) + 120) + 240) & 4) != 0)
  {
    if (!CBB_add_u16((uint64_t)v32, 0x1303u))
      return 0;
    v17 = *(_BYTE *)(*(_QWORD *)(**(_QWORD **)(a1 + 8) + 120) + 240);
  }
  if ((v17 & 2) == 0)
    goto LABEL_33;
  if (!CBB_add_u16((uint64_t)v32, 0x1301u))
    return 0;
  if ((*(_BYTE *)(*(_QWORD *)(**(_QWORD **)(a1 + 8) + 120) + 240) & 2) != 0)
  {
    v18 = 4866;
LABEL_25:
    if (!CBB_add_u16((uint64_t)v32, v18))
      return 0;
  }
LABEL_33:
  if (a3 != 1 && *(unsigned __int16 *)(a1 + 28) <= 0x303u)
  {
    ciphers = SSL_get_ciphers((const SSL *)v12);
    v20 = sk_num(ciphers);
    if (!v20)
      goto LABEL_48;
    v21 = v20;
    v22 = 0;
    v23 = 0;
    v24 = 8 * v13;
    v25 = 4 * v13;
    v30 = v20 - 1;
    do
    {
      while (1)
      {
        v26 = sk_value(ciphers, v23);
        if ((*((_DWORD *)v26 + 5) & v24) != 0)
          break;
        v27 = (uint64_t)v26;
        if ((*((_DWORD *)v26 + 6) & v25) != 0
          || SSL_CIPHER_get_min_version(v26) > *(unsigned __int16 *)(a1 + 30)
          || SSL_CIPHER_get_max_version(v27) < *(unsigned __int16 *)(a1 + 28))
        {
          break;
        }
        protocol_id = SSL_CIPHER_get_protocol_id(v27);
        if (!CBB_add_u16((uint64_t)v32, protocol_id))
          return 0;
        v22 = 1;
        if (v30 == v23++)
          goto LABEL_50;
      }
      ++v23;
    }
    while (v21 != v23);
    if ((v22 & 1) == 0)
    {
LABEL_48:
      if (*(unsigned __int16 *)(a1 + 30) <= 0x303u)
      {
        ERR_put_error(16, 0, 175, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 311);
        return 0;
      }
    }
  }
LABEL_50:
  if ((*(_BYTE *)(v12 + 149) & 4) != 0 && !CBB_add_u16((uint64_t)v32, 0x5600u))
    return 0;
  result = CBB_flush(a2);
  if ((_DWORD)result)
  {
    result = CBB_add_u8((uint64_t)a2, 1u);
    if ((_DWORD)result)
      return CBB_add_u8((uint64_t)a2, 0) != 0;
  }
  return result;
}

uint64_t CBB_add_u16(uint64_t a1, unsigned int a2)
{
  return cbb_add_u(a1, a2, 2uLL);
}

uint64_t SSL_CIPHER_get_min_version(_DWORD *a1)
{
  if (a1[5] == 16 || a1[6] == 8)
    return 772;
  if (a1[9] == 1)
    return 768;
  return 771;
}

uint64_t SSL_CIPHER_get_max_version(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20) == 16)
  {
    return 772;
  }
  else if (*(_DWORD *)(a1 + 24) == 8)
  {
    return 772;
  }
  else
  {
    return 771;
  }
}

uint64_t SSL_CIPHER_get_protocol_id(uint64_t a1)
{
  if (HIBYTE(*(_DWORD *)(a1 + 16)) != 3)
    SSL_CIPHER_get_protocol_id_cold_1();
  return (unsigned __int16)*(_DWORD *)(a1 + 16);
}

BOOL bssl::tls12_add_verify_sigalgs(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  __int16 *v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  BOOL v9;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(v3 + 280);
  if (v4)
  {
    v5 = *(__int16 **)(v3 + 272);
  }
  else
  {
    v5 = &bssl::kVerifySignatureAlgorithms;
    v4 = 11;
  }
  v6 = 2 * v4 - 2;
  do
  {
    v7 = (unsigned __int16)*v5++;
    v8 = CBB_add_u16(a2, v7);
    if (v8)
      v9 = v6 == 0;
    else
      v9 = 1;
    v6 -= 2;
  }
  while (!v9);
  return v8 != 0;
}

uint64_t SSL_get_srtp_profiles(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  if (!a1)
    return 0;
  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
    SSL_get_srtp_profiles_cold_1();
  v2 = *(_QWORD *)(v1 + 288);
  if (!v2)
    return *(_QWORD *)(*(_QWORD *)(a1 + 120) + 712);
  return v2;
}

uint64_t bssl::`anonymous namespace'::X25519KeyShare::GroupID(bssl::_anonymous_namespace_::X25519KeyShare *this)
{
  return 29;
}

uint64_t bssl::tls13_process_finished(char *a1, uint64_t a2, int a3)
{
  bssl *v4;
  __int128 v5;
  char *v6;
  uint64_t v7;
  uint64_t result;
  unsigned __int8 v9[8];
  _OWORD v10[4];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v4 = *(bssl **)a1;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[2] = v5;
  v10[3] = v5;
  v10[0] = v5;
  v10[1] = v5;
  if (a3)
  {
    if ((*((_BYTE *)v4 + 180) & 1) == 0)
      bssl::tls13_process_finished();
    v6 = a1 + 328;
    v7 = *((_QWORD *)a1 + 4);
  }
  else
  {
    *(_QWORD *)v9 = 0xAAAAAAAAAAAAAAAALL;
    result = bssl::tls13_finished_mac((bssl *)a1, (bssl::SSL_HANDSHAKE *)v10, v9, (unint64_t *)((*((_BYTE *)v4 + 180) & 1) == 0));
    if (!(_DWORD)result)
      return result;
    v7 = *(_QWORD *)v9;
    v6 = (char *)v10;
  }
  if (CBS_mem_equal(a2 + 8, v6, v7))
    return 1;
  bssl::ssl_send_alert(v4, (ssl_st *)2, 51);
  ERR_put_error(16, 0, 142, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 472);
  return 0;
}

uint64_t bssl::tls13_finished_mac(bssl *this, bssl::SSL_HANDSHAKE *a2, unsigned __int8 *a3, unint64_t *a4)
{
  int v4;
  uint64_t v8;
  __int128 v9;
  bssl::SSLTranscript *v10;
  uint64_t result;
  uint64_t v12;
  char *v13;
  EVP_MD *v14;
  unint64_t v15;
  unsigned __int8 v16[16];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v4 = (int)a4;
  v20 = *MEMORY[0x1E0C80C00];
  v8 = *((_QWORD *)this + 4);
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v18 = v9;
  v19 = v9;
  *(_OWORD *)v16 = v9;
  v17 = v9;
  v15 = 0xAAAAAAAAAAAAAAAALL;
  v10 = (bssl *)((char *)this + 424);
  result = bssl::SSLTranscript::GetHash((bssl *)((char *)this + 424), v16, &v15);
  if ((_DWORD)result)
  {
    v12 = 136;
    if (v4)
      v12 = 184;
    v13 = (char *)this + v12;
    v14 = (EVP_MD *)bssl::SSLTranscript::Digest(v10);
    return bssl::tls13_verify_data((unsigned __int8 *)a2, a3, v14, (uint64_t)v13, v8, v16, v15);
  }
  return result;
}

uint64_t bssl::tls13_verify_data(unsigned __int8 *a1, _QWORD *a2, EVP_MD *md, uint64_t a4, uint64_t a5, const unsigned __int8 *a6, size_t a7)
{
  __int128 v14;
  int v15;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t result;
  unsigned int md_len;
  _OWORD key[4];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  key[2] = v14;
  key[3] = v14;
  key[0] = v14;
  key[1] = v14;
  v15 = EVP_MD_size(md);
  md_len = 0;
  v17 = bssl::hkdf_expand_label((int)key, v15, md, a4, a5, "finished", 8uLL, v16, 0, 0);
  result = 0;
  if (v17)
  {
    result = (uint64_t)HMAC(md, key, v15, a6, a7, a1, &md_len);
    if (result)
    {
      *a2 = md_len;
      return 1;
    }
  }
  return result;
}

unsigned __int8 *__cdecl HMAC(const EVP_MD *evp_md, const void *key, int key_len, const unsigned __int8 *d, size_t n, unsigned __int8 *md, unsigned int *md_len)
{
  unsigned __int8 *v9;
  int v10;
  uint64_t v11;
  unsigned int *v12;
  void *v13;
  void *v14;
  unsigned int v15;
  void *v16;

  if (md)
    v9 = md;
  else
    v9 = (unsigned __int8 *)&HMAC_static_out_buffer;
  v10 = EVP_MD_type(evp_md);
  v11 = boringssl_crypto_hash_nid_to_cc_digest(v10);
  if (v11)
  {
    v12 = (unsigned int *)v11;
    v13 = malloc_type_malloc(((*(_QWORD *)(v11 + 8) + *(_QWORD *)(v11 + 16) + 19) & 0xFFFFFFFFFFFFFFF8) + *(_QWORD *)(v11 + 8), 0x16E08630uLL);
    if (!v13)
      return 0;
    v14 = v13;
    cchmac_init();
    cchmac_update();
    cchmac_final();
    cc_clear();
    free(v14);
    if (md_len)
    {
      v15 = *v12;
LABEL_13:
      *md_len = v15;
    }
  }
  else
  {
    v16 = (void *)g_boringssl_log;
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      HMAC_cold_1(v16, evp_md);
    v9 = 0;
    if (md_len)
    {
      v15 = 0;
      goto LABEL_13;
    }
  }
  return v9;
}

uint64_t SSL_get_options(uint64_t a1)
{
  return *(unsigned int *)(a1 + 144);
}

uint64_t bssl::SSLTranscript::GetFinishedMAC(bssl::SSLTranscript *this, unsigned __int8 *a2, unint64_t *a3, const ssl_session_st *a4, int a5)
{
  __int128 v10;
  uint64_t result;
  const char *v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unsigned __int8 v16[16];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v18 = v10;
  v19 = v10;
  *(_OWORD *)v16 = v10;
  v17 = v10;
  v15 = 0xAAAAAAAAAAAAAAAALL;
  result = bssl::SSLTranscript::GetHash(this, v16, &v15);
  if ((_DWORD)result)
  {
    if (a5)
      v12 = "server finished";
    else
      v12 = "client finished";
    v13 = (uint64_t *)EVP_MD_CTX_md((const EVP_MD_CTX *)((char *)this + 8));
    result = bssl::tls1_prf(v13, a2, 0xCuLL, (char *)&a4->master_key_length, *(int *)&a4->key_arg[4], (const unsigned __int8 *)v12, 0xFuLL, v14, v16, v15, 0, 0);
    if ((_DWORD)result)
    {
      *a3 = 12;
      return 1;
    }
  }
  return result;
}

BOOL bssl::tls1_prf(uint64_t *a1, _BYTE *a2, size_t a3, char *a4, unint64_t a5, const unsigned __int8 *a6, size_t a7, uint64_t a8, const unsigned __int8 *a9, size_t a10, const unsigned __int8 *a11, size_t a12)
{
  return CRYPTO_tls1_prf(a1, a2, a3, a4, a5, a6, a7, a9, a10, a11, a12) == 1;
}

uint64_t CRYPTO_tls1_prf(uint64_t *a1, _BYTE *a2, size_t a3, char *a4, unint64_t a5, const unsigned __int8 *a6, size_t a7, const unsigned __int8 *a8, size_t len, const unsigned __int8 *a10, size_t a11)
{
  EVP_MD *v18;
  uint64_t result;

  if (!a3)
    return 1;
  bzero(a2, a3);
  if (EVP_md5_sha1() == a1)
  {
    v18 = (EVP_MD *)EVP_md5();
    result = tls1_P_hash(a2, a3, v18, a4, a5 - (a5 >> 1), a6, a7, a8, len, a10, a11);
    if (!(_DWORD)result)
      return result;
    a4 += a5 >> 1;
    a5 -= a5 >> 1;
    a1 = (uint64_t *)EVP_sha1();
  }
  return tls1_P_hash(a2, a3, (EVP_MD *)a1, a4, a5, a6, a7, a8, len, a10, a11);
}

uint64_t *EVP_md5_sha1()
{
  CRYPTO_once(&EVP_md5_sha1_once, (void (*)(void))EVP_md5_sha1_init);
  return &EVP_md5_sha1_storage;
}

void bssl::`anonymous namespace'::ECKeyShare::~ECKeyShare(BIGNUM **this)
{
  *this = (BIGNUM *)&off_1E686D8C8;
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100](this + 1, 0);
}

{
  *this = (BIGNUM *)&off_1E686D8C8;
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100](this + 1, 0);
  abort();
}

_QWORD *bssl::MakeUnique<bssl::`anonymous namespace'::ECKeyShare,int,int>@<X0>(int *a1@<X0>, int *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *result;
  _QWORD *v7;
  int v8;
  int v9;

  result = OPENSSL_malloc(0x20uLL);
  v7 = result;
  if (result)
  {
    v8 = *a1;
    v9 = *a2;
    *v7 = &off_1E686D8C8;
    v7[1] = 0;
    result = EC_GROUP_new_by_curve_name(v8);
    v7[2] = result;
    *((_WORD *)v7 + 12) = v9;
  }
  *a3 = v7;
  return result;
}

void sub_1B4F8F1CC(_Unwind_Exception *a1)
{
  BIGNUM **v1;

  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t bssl::`anonymous namespace'::ECKeyShare::GroupID(bssl::_anonymous_namespace_::ECKeyShare *this)
{
  return *((unsigned __int16 *)this + 12);
}

uint64_t bssl::tls13_init_key_schedule(uint64_t a1, const ssl_st *a2)
{
  size_t **v3;
  bssl::SSLTranscript *v4;
  const ssl_cipher_st *v5;
  uint64_t result;

  v3 = (size_t **)(a1 + 424);
  v4 = (bssl::SSLTranscript *)bssl::ssl_protocol_version(*(bssl **)a1, a2);
  result = bssl::init_key_schedule((bssl *)a1, v3, v4, *(ssl_cipher_st **)(a1 + 1568), v5);
  if ((_DWORD)result)
  {
    if ((*(_BYTE *)(a1 + 1602) & 8) == 0)
      bssl::SSLTranscript::FreeBuffer((BUF_MEM **)v3);
    return bssl::hkdf_extract_to_secret(a1, (bssl::SSLTranscript *)v3);
  }
  return result;
}

void bssl::SSLTranscript::FreeBuffer(BUF_MEM **this)
{
  std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](this, 0);
}

uint64_t bssl::init_key_schedule(bssl *this, size_t **a2, bssl::SSLTranscript *a3, ssl_cipher_st *a4, const ssl_cipher_st *a5)
{
  uint64_t inited;
  unint64_t v8;
  size_t v9;

  inited = bssl::SSLTranscript::InitHash(a2, a3, a4);
  if ((_DWORD)inited)
  {
    v8 = bssl::SSLTranscript::DigestLen((bssl::SSLTranscript *)a2);
    bssl::SSL_HANDSHAKE::ResizeSecrets((uint64_t)this, v8);
    v9 = *((_QWORD *)this + 4);
    if (v9)
      bzero((char *)this + 40, v9);
  }
  return inited;
}

uint64_t bssl::SSL_HANDSHAKE::ResizeSecrets(uint64_t this, unint64_t a2)
{
  if (a2 >= 0x31)
    abort();
  *(_QWORD *)(this + 32) = a2;
  return this;
}

uint64_t bssl::tls13_derive_resumption_secret(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  bssl::SSLTranscript *v3;
  int v5;
  uint64_t v6;

  v3 = (bssl *)((char *)this + 424);
  if ((unint64_t)bssl::SSLTranscript::DigestLen((bssl *)((char *)this + 424)) < 0x31)
  {
    v5 = bssl::SSLTranscript::DigestLen(v3);
    v6 = *((_QWORD *)this + 192);
    *(_DWORD *)(v6 + 12) = v5;
    return bssl::derive_secret_with_transcript((uint64_t)this, (int)v6 + 16, v5, v3, "res master", 0xAuLL);
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", 325);
    return 0;
  }
}

uint64_t bssl::SSLTranscript::DigestLen(bssl::SSLTranscript *this)
{
  const EVP_MD *v1;

  v1 = EVP_MD_CTX_md((const EVP_MD_CTX *)((char *)this + 8));
  return EVP_MD_size(v1);
}

uint64_t __boringssl_session_cache_pop_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v6;

  v6 = a3;
  if (a2)
    sec_array_append();
  else
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a3);

  return 1;
}

uint64_t bssl::tls_add_change_cipher_spec(bssl *this, ssl_st *a2)
{
  uint64_t v3;

  if (!bssl::tls_flush_pending_hs_data(this, a2)
    || !*((_QWORD *)this + 21)
    && !bssl::add_record_to_flight(this, (ssl_st *)0x14, (unint64_t)&bssl::tls_add_change_cipher_spec(ssl_st *)::kChangeCipherSpec, (const unsigned __int8 *)1))
  {
    return 0;
  }
  v3 = 1;
  bssl::ssl_do_msg_callback((uint64_t)this, 1, 20, (uint64_t)&bssl::tls_add_change_cipher_spec(ssl_st *)::kChangeCipherSpec, 1);
  return v3;
}

uint64_t __nw_protocol_boringssl_write_frames_block_invoke(_QWORD *a1, void *a2)
{
  id v3;
  int v4;
  uint64_t v5;
  const void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v15;
  void *v16;
  void *__src;
  _DWORD v18[3];
  __int16 v19;
  int v20;
  __int16 v21;
  void *v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  void *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = nw_frame_uses_external_data();
  v5 = a1[4];
  v6 = *(const void **)(v5 + 176);
  if (v6)
  {
    memcpy((void *)(a1[7] + *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24)), v6, *(unsigned int *)(v5 + 184));
    *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) += *(_DWORD *)(a1[4] + 184);
    v7 = a1[4];
    v8 = *(void **)(v7 + 168);
    *(_QWORD *)(v7 + 168) = 0;

    *(_QWORD *)(a1[4] + 176) = 0;
    *(_DWORD *)(a1[4] + 184) = 0;
  }
  else if (v4)
  {
    __src = 0;
    nw_frame_get_external_data();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = v9;
    if (v9)
    {
      v11 = nw_dispatch_data_create_subrange_map(v9, 0, 0, &__src);
      if (v11)
      {
        *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      }
      else
      {
        v12 = a1[4];
        if (!v12 || (*(_BYTE *)(v12 + 475) & 1) == 0)
        {
          v13 = g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
            {
              v15 = a1[4];
              v16 = (void *)(v15 + 391);
              if (!v15)
                v16 = &unk_1B50022E3;
              v18[0] = 136447746;
              *(_QWORD *)&v18[1] = "nw_protocol_boringssl_write_frames_block_invoke";
              v19 = 1024;
              v20 = 1002;
              v21 = 2082;
              v22 = v16;
              v23 = 2048;
              v24 = v15;
              v25 = 2112;
              v26 = v10;
              v27 = 1024;
              v28 = 0;
              v29 = 1024;
              v30 = 0;
              _os_log_error_impl(&dword_1B4F6D000, v13, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] Failed to flatten external data %@ (offset %u, unclaimed %u)", (uint8_t *)v18, 0x3Cu);
            }
          }
        }
      }

    }
  }
  else
  {
    v18[0] = 0;
    nw_frame_unclaimed_bytes();
    *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
  }
  if ((id)a1[5] != v3)
  {
    nw_frame_array_remove();
    nw_frame_finalize();
  }

  return 1;
}

uint64_t __nw_dispatch_data_create_subrange_map_block_invoke(_QWORD *a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  id v10;
  unint64_t v11;
  size_t v12;
  size_t v13;
  BOOL v14;
  unint64_t v15;
  const void *v16;
  size_t v17;
  uint64_t v18;
  id *v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  uint64_t alloc;
  uint64_t v24;
  void *v25;

  v10 = a2;
  v11 = a1[8];
  if (a5 + a3 > v11)
  {
    v12 = a1[9];
    v13 = v12 + v11;
    if (v12 + v11 > a3)
    {
      v14 = v11 >= a3;
      v15 = v11 - a3;
      if (v11 > a3)
        a3 = a1[8];
      if (!v14)
        v15 = 0;
      v16 = (const void *)(a4 + v15);
      v17 = a5 - v15;
      v18 = *(_QWORD *)(a1[4] + 8);
      v20 = *(_QWORD *)(v18 + 40);
      v19 = (id *)(v18 + 40);
      if (v20)
        goto LABEL_8;
      if (v17 >= v12)
      {
        objc_storeStrong(v19, a2);
        v22 = 0;
        *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = a1[9];
        *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = v16;
        goto LABEL_17;
      }
      alloc = dispatch_data_create_alloc();
      v24 = *(_QWORD *)(a1[4] + 8);
      v25 = *(void **)(v24 + 40);
      *(_QWORD *)(v24 + 40) = alloc;

      if (*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 40))
      {
        *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24);
        v11 = a1[8];
        v13 = a1[9] + v11;
LABEL_8:
        if (v17 + a3 <= v13)
          v21 = v17;
        else
          v21 = v13 - a3;
        memcpy((void *)(*(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) + a3 - v11), v16, v21);
        *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) += v21;
        goto LABEL_12;
      }
    }
    v22 = 0;
    goto LABEL_17;
  }
LABEL_12:
  v22 = 1;
LABEL_17:

  return v22;
}

uint64_t boringssl_session_write(_QWORD *a1, const void *a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  SSL *v6;
  uint64_t error;
  id WeakRetained;
  void *v9;
  _BYTE *v10;
  char v11;
  id v12;
  _BYTE *v13;
  char v14;
  NSObject *v16;

  if (!a1)
    return 0;
  if (*(_DWORD *)a1 != -1252936367)
    return 0;
  v4 = a1[1];
  if (!v4)
    return 0;
  v5 = 0;
  if (a3)
  {
    if (a2)
    {
      v6 = *(SSL **)(v4 + 400);
      if (v6)
      {
        v5 = SSL_write(v6, a2, a3);
        if ((int)v5 <= 0)
        {
          error = SSL_get_error(*(const SSL **)(v4 + 400), v5);
          WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
          if (!WeakRetained
            || (v9 = WeakRetained,
                v10 = objc_loadWeakRetained((id *)(v4 + 16)),
                v11 = v10[475],
                v10,
                v9,
                (v11 & 1) == 0))
          {
            v12 = objc_loadWeakRetained((id *)(v4 + 16));
            if (v12)
            {
              v13 = objc_loadWeakRetained((id *)(v4 + 16));
              v14 = v13[475] & 1;

            }
            else
            {
              v14 = 0;
            }

            if ((v14 & 1) == 0 && datapath_logging_enabled && g_boringssl_log)
            {
              v16 = (id)g_boringssl_log;
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                boringssl_session_write_cold_1(v4, error, v16);

            }
          }
          if ((_DWORD)error == 3)
            ++*(_QWORD *)(v4 + 488);
          else
            ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))boringssl_session_handshake_error_print, a1);
        }
      }
    }
  }
  return v5;
}

int SSL_write(SSL *ssl, const void *buf, int num)
{
  int v6;
  int v7;
  int result;
  uint64_t v9;
  char v10;
  uint64_t v11;

  *((_DWORD *)ssl->handshake_func + 49) = 0;
  ERR_clear_error();
  ERR_clear_system_error();
  if (*(_QWORD *)&ssl->hit)
  {
    v6 = 66;
    v7 = 1315;
LABEL_3:
    ERR_put_error(16, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", v7);
    return -1;
  }
  if (!*(_QWORD *)&ssl->rwstate)
  {
    v6 = 226;
    v7 = 1320;
    goto LABEL_3;
  }
  v11 = 0;
  v10 = 0;
  do
  {
    v9 = *((_QWORD *)ssl->handshake_func + 35);
    if (v9 && (*(_WORD *)(v9 + 1600) & 0x4008) == 0)
    {
      result = SSL_do_handshake(ssl);
      if (result < 0)
        return result;
      if (!result)
      {
        v6 = 215;
        v7 = 1335;
        goto LABEL_3;
      }
    }
    if (num < 0)
    {
      v6 = 111;
      v7 = 1341;
      goto LABEL_3;
    }
    result = (*(uint64_t (**)(SSL *, char *, uint64_t *, const void *, _QWORD))(*(_QWORD *)&ssl->version + 72))(ssl, &v10, &v11, buf, num);
  }
  while (v10);
  if (result >= 1)
    return v11;
  return result;
}

void nw_protocol_boringssl_frame_output_finalizer(void *a1, uint64_t a2, void *a3)
{
  id v4;
  id v5;
  void *v6;
  void *buffer;

  v4 = a1;
  v5 = a3;
  v6 = v5;
  if ((!v5 || (*((_BYTE *)v5 + 475) & 1) == 0)
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_frame_output_finalizer_cold_1();
  }
  if (v4 && v6)
  {
    nw_frame_array_remove();
    if (nw_frame_uses_external_data())
    {
      nw_frame_set_external_data();
    }
    else
    {
      buffer = (void *)nw_frame_get_buffer();
      if (buffer)
        free(buffer);
    }
    nw_frame_reset();

  }
}

uint64_t bssl::tls_write_app_data(uint64_t a1, ssl_st *a2, unint64_t *a3, uint64_t a4, unint64_t a5)
{
  uint64_t v10;
  int v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t result;
  unint64_t v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  BOOL v23;
  unint64_t v24;
  const unsigned __int8 *v25;
  unint64_t v26;
  unint64_t v27;

  if ((bssl::ssl_can_write((bssl *)a1, a2) & 1) == 0)
    bssl::tls_write_app_data();
  v10 = *(_QWORD *)(a1 + 48);
  if (!**(_QWORD **)(v10 + 272))
    bssl::tls_write_app_data();
  LOBYTE(a2->version) = 0;
  if (*(_DWORD *)(v10 + 176))
  {
    v11 = 194;
    v12 = 140;
    goto LABEL_7;
  }
  v13 = *(_QWORD *)(v10 + 144);
  v14 = a5 - v13;
  if (a5 < v13)
  {
    v11 = 111;
    v12 = 152;
LABEL_7:
    ERR_put_error(16, 0, v11, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", v12);
    return 0xFFFFFFFFLL;
  }
  v16 = a4 + v13;
  if ((*(_BYTE *)(a1 + 180) & 1) != 0 || !SSL_in_early_data(a1))
    v17 = 0;
  else
    v17 = (*(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 280) + 1601) >> 6) & 1;
  while (1)
  {
    v18 = *(unsigned __int16 *)(a1 + 18);
    if (v17)
    {
      v19 = *(_QWORD *)(a1 + 48);
      v20 = *(_QWORD *)(v19 + 280);
      v21 = *(unsigned __int16 *)(v20 + 1608);
      v22 = *(_DWORD *)(*(_QWORD *)(v20 + 1544) + 388);
      v23 = v22 >= v21;
      v24 = v22 - v21;
      if ((_DWORD)v24 == 0 || !v23)
      {
        *(_QWORD *)(v19 + 144) = v13;
        *(_DWORD *)(v20 + 1600) &= ~0x4000u;
        LOBYTE(a2->version) = 1;
        return 0xFFFFFFFFLL;
      }
      if (v24 < v18)
        v18 = v24;
    }
    v25 = (const unsigned __int8 *)(v14 >= v18 ? v18 : v14);
    v27 = 0xAAAAAAAAAAAAAAAALL;
    result = bssl::do_tls_write((bssl *)a1, (ssl_st *)&v27, (ssl_st *)0x17, v16, v25);
    if ((int)result <= 0)
      break;
    v26 = v27;
    if (v27 > (unint64_t)v25)
      bssl::tls_write_app_data();
    if (v17)
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 280) + 1608) += v27;
    v13 += v26;
    v14 -= v26;
    if (!v14 || (*(_BYTE *)(a1 + 148) & 1) != 0)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 48) + 144) = 0;
      *a3 = v13;
      return result;
    }
    v16 += v26;
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 48) + 144) = v13;
  return result;
}

uint64_t bssl::ssl_can_write(bssl *this, const ssl_st *a2)
{
  uint64_t v2;
  unsigned int v3;

  v2 = *(_QWORD *)(*((_QWORD *)this + 6) + 280);
  if (!v2)
    return 1;
  v3 = *(_DWORD *)(v2 + 1600);
  if ((v3 & 8) != 0)
    return 1;
  else
    return (v3 >> 14) & 1;
}

uint64_t bssl::tls_flush_flight(BIO **this, ssl_st *a2)
{
  ssl_st *v3;
  BIO *v4;
  int v5;
  int v6;
  BIO *v7;
  char *cb_arg;
  uint64_t result;
  BIO *v10;
  BIO *v11;
  unint64_t init;
  char *v13;
  uint64_t v14;
  BIO *v15;
  int v16;
  BIO *v17;

  if (!bssl::tls_flush_pending_hs_data((bssl *)this, a2))
    return 0xFFFFFFFFLL;
  v4 = this[21];
  if (v4)
  {
    if (LODWORD(this[6][1].prev_bio))
    {
      v5 = 194;
      v6 = 291;
LABEL_12:
      ERR_put_error(16, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", v6);
      return 0xFFFFFFFFLL;
    }
    if (!(*(unsigned int (**)(BIO **))&v4->init)(this))
    {
      v5 = 298;
      v6 = 296;
      goto LABEL_12;
    }
  }
  v7 = this[6];
  cb_arg = v7[2].cb_arg;
  if (!cb_arg)
    return 1;
  if (LODWORD(v7[1].prev_bio))
  {
    v5 = 194;
    v6 = 306;
    goto LABEL_12;
  }
  if (*(_QWORD *)cb_arg >> 31)
  {
    v5 = 68;
    v6 = 312;
    goto LABEL_12;
  }
  if (WORD2(v7[1].method))
  {
    result = bssl::ssl_write_buffer_flush((bssl *)this, v3);
    if ((int)result <= 0)
    {
      HIDWORD(this[6][1].num_read) = 3;
      return result;
    }
  }
  v10 = this[4];
  if (!v10)
  {
    v5 = 119;
    v6 = 327;
    goto LABEL_12;
  }
  v11 = this[6];
  init = v11[2].init;
  v13 = v11[2].cb_arg;
  v14 = *(_QWORD *)v13;
  if (*(_QWORD *)v13 <= init)
  {
LABEL_21:
    v16 = BIO_flush(v10);
    v17 = this[6];
    if (v16 <= 0)
    {
      HIDWORD(v17[1].num_read) = 3;
      return 0xFFFFFFFFLL;
    }
    std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)&v17[2].cb_arg, 0);
    this[6][2].init = 0;
    return 1;
  }
  while (1)
  {
    result = BIO_write(this[4], (const void *)(*((_QWORD *)v13 + 1) + init), v14 - init);
    v15 = this[6];
    if ((int)result <= 0)
      break;
    init = (v15[2].init + result);
    v15[2].init = init;
    v13 = v15[2].cb_arg;
    v14 = *(_QWORD *)v13;
    if (*(_QWORD *)v13 <= init)
    {
      v10 = this[4];
      goto LABEL_21;
    }
  }
  HIDWORD(v15[1].num_read) = 3;
  return result;
}

uint64_t bssl::add_record_to_flight(bssl *a1, ssl_st *a2, unint64_t a3, const unsigned __int8 *a4)
{
  uint64_t v4;
  BUF_MEM **v9;
  uint64_t v10;
  BUF_MEM *v11;
  uint64_t v12;
  const unsigned __int8 *v13;
  BOOL v14;
  _QWORD *v15;
  unint64_t v16;
  _BOOL4 v17;
  uint64_t result;
  unsigned __int8 v19[8];

  v4 = *((_QWORD *)a1 + 6);
  if (*(_QWORD *)(v4 + 232))
    bssl::add_record_to_flight();
  if (*(_DWORD *)(v4 + 248))
    bssl::add_record_to_flight();
  v10 = *(_QWORD *)(v4 + 240);
  v9 = (BUF_MEM **)(v4 + 240);
  if (!v10)
  {
    v11 = BUF_MEM_new();
    std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v9, v11);
    if (!*(_QWORD *)(*((_QWORD *)a1 + 6) + 240))
      return 0;
  }
  v12 = SSL_max_seal_overhead((uint64_t)a1);
  v13 = &a4[v12];
  v14 = __CFADD__(v12, a4);
  v15 = *(_QWORD **)(*((_QWORD *)a1 + 6) + 240);
  v16 = (unint64_t)&v13[*v15];
  v17 = __CFADD__(*v15, v13);
  if (v14 || v17)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 154);
    return 0;
  }
  *(_QWORD *)v19 = 0xAAAAAAAAAAAAAAAALL;
  result = BUF_MEM_reserve((uint64_t)v15, v16);
  if ((_DWORD)result)
  {
    result = bssl::tls_seal_record(a1, (ssl_st *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 6) + 240) + 8)+ **(_QWORD **)(*((_QWORD *)a1 + 6) + 240)), v19, v13, a2, a3, a4);
    if ((_DWORD)result)
    {
      **(_QWORD **)(*((_QWORD *)a1 + 6) + 240) += *(_QWORD *)v19;
      return 1;
    }
  }
  return result;
}

uint64_t bssl::do_tls_write(bssl *this, ssl_st *a2, ssl_st *a3, unint64_t a4, const unsigned __int8 *a5)
{
  uint64_t v10;
  unint64_t v11;
  uint64_t result;
  ssl_st *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  const ssl_st *v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  size_t v22;
  const void *v23;
  unint64_t v24;
  uint64_t v25;
  const unsigned __int8 *v26;
  BOOL v27;
  _BOOL4 v28;
  int v29;
  ssl_st *v30;
  uint64_t v31;
  unsigned __int8 v32[8];

  v10 = *((_QWORD *)this + 6);
  v11 = *(_QWORD *)(v10 + 160);
  if (v11
    && (v11 > (unint64_t)a5
     || (*((_BYTE *)this + 148) & 2) == 0 && *(_QWORD *)(v10 + 152) != a4
     || *(unsigned __int8 *)(v10 + 168) != (_DWORD)a3))
  {
    v16 = 118;
    v17 = 212;
LABEL_10:
    ERR_put_error(16, 0, v16, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", v17);
    return 0xFFFFFFFFLL;
  }
  result = bssl::ssl_write_buffer_flush(this, a2);
  if ((int)result < 1)
    return result;
  v14 = *((_QWORD *)this + 6);
  v15 = *(_QWORD *)(v14 + 160);
  if (v15)
  {
    *(_QWORD *)&a2->version = v15;
    result = 1;
    *(_QWORD *)(v14 + 152) = 0;
    *(_QWORD *)(v14 + 160) = 0;
    return result;
  }
  if ((unint64_t)a5 > 0x4000 || *(_WORD *)(v14 + 116))
  {
    v16 = 68;
    v17 = 232;
    goto LABEL_10;
  }
  if (!bssl::tls_flush_pending_hs_data(this, v13))
    return 0xFFFFFFFFLL;
  v19 = *((_QWORD *)this + 6);
  v20 = *(_QWORD **)(v19 + 240);
  if (v20)
  {
    v21 = *(unsigned int *)(v19 + 248);
    v22 = *v20 - v21;
    if (*v20 < v21)
      abort();
    v23 = (const void *)(v20[1] + v21);
  }
  else
  {
    v22 = 0;
    v23 = 0;
  }
  v24 = v22;
  if (a5)
  {
    v25 = SSL_max_seal_overhead((uint64_t)this);
    v26 = &a5[v25];
    v27 = __CFADD__(v25, a5);
    v24 = (unint64_t)&v26[v22];
    v28 = __CFADD__(v26, v22);
    if (v27 || v28)
    {
      v16 = 69;
      v17 = 256;
      goto LABEL_10;
    }
  }
  if (!v24)
  {
    *(_QWORD *)&a2->version = 0;
    return 1;
  }
  v29 = bssl::ssl_seal_align_prefix_len((unsigned __int8 **)this, v18);
  if (!bssl::SSLBuffer::EnsureCap((bssl::SSLBuffer *)(v14 + 104), v29 + (int)v22, v24))
    return 0xFFFFFFFFLL;
  if (v22)
  {
    memcpy((void *)(*(_QWORD *)(v14 + 104) + *(unsigned __int16 *)(v14 + 112) + *(unsigned __int16 *)(v14 + 116)), v23, v22);
    std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)(*((_QWORD *)this + 6) + 240), 0);
    *(_DWORD *)(*((_QWORD *)this + 6) + 248) = 0;
    bssl::SSLBuffer::DidWrite(v14 + 104, v22);
  }
  if (a5)
  {
    *(_QWORD *)v32 = 0xAAAAAAAAAAAAAAAALL;
    if (!bssl::tls_seal_record(this, (ssl_st *)(*(_QWORD *)(v14 + 104)+ *(unsigned __int16 *)(v14 + 112)+ *(unsigned __int16 *)(v14 + 116)), v32, (const unsigned __int8 *)(*(unsigned __int16 *)(v14 + 118)- (unint64_t)*(unsigned __int16 *)(v14 + 116)), a3, a4, a5))return 0xFFFFFFFFLL;
    bssl::SSLBuffer::DidWrite(v14 + 104, *(unint64_t *)v32);
  }
  *(_WORD *)(*((_QWORD *)this + 6) + 220) &= ~0x400u;
  result = bssl::ssl_write_buffer_flush(this, v30);
  if ((int)result > 0)
  {
    *(_QWORD *)&a2->version = a5;
    return 1;
  }
  if (a5)
  {
    v31 = *((_QWORD *)this + 6);
    *(_QWORD *)(v31 + 152) = a4;
    *(_QWORD *)(v31 + 160) = a5;
    *(_BYTE *)(*((_QWORD *)this + 6) + 168) = (_BYTE)a3;
  }
  return result;
}

uint64_t bssl::tls_flush_pending_hs_data(bssl *this, ssl_st *a2)
{
  uint64_t v2;
  uint64_t v3;
  const unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *((_QWORD *)this + 6);
  v3 = *(_QWORD *)(v2 + 232);
  if (!v3)
    return 1;
  v4 = *(const unsigned __int8 **)v3;
  if (!*(_QWORD *)v3)
    return 1;
  *(_QWORD *)(v2 + 232) = 0;
  v5 = *((_QWORD *)this + 21);
  if (v5)
  {
    v6 = *(_QWORD *)(*((_QWORD *)this + 6) + 280);
    if (v6 && (*(_BYTE *)(v6 + 1602) & 0x10) != 0 || (*(unsigned int (**)(void))(v5 + 16))())
    {
      v7 = 1;
    }
    else
    {
      ERR_put_error(16, 0, 298, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 257);
      v7 = 0;
    }
  }
  else
  {
    v7 = bssl::add_record_to_flight(this, (ssl_st *)0x16, *(_QWORD *)(v3 + 8), v4);
  }
  BUF_MEM_free((BUF_MEM *)v3);
  return v7;
}

void sub_1B4F904A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_write_buffer_flush(bssl *this, ssl_st *a2)
{
  int is_dtls;
  uint64_t v4;
  uint64_t result;
  unsigned __int16 v6;
  unsigned __int16 v7;
  unsigned int v8;

  if (!*((_QWORD *)this + 4))
  {
    ERR_put_error(16, 0, 119, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_buffer.cc", 322);
    return 0xFFFFFFFFLL;
  }
  is_dtls = SSL_is_dtls((unsigned __int8 **)this);
  v4 = *((_QWORD *)this + 6);
  if (is_dtls)
  {
    if (*(_WORD *)(v4 + 116))
    {
      result = BIO_write(*((BIO **)this + 4), (const void *)(*(_QWORD *)(v4 + 104) + *(unsigned __int16 *)(v4 + 112)), *(unsigned __int16 *)(v4 + 116));
      if ((int)result <= 0)
        *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 3;
      else
        result = 1;
      *(_WORD *)(v4 + 112) = *(_WORD *)(v4 + 114);
      *(_WORD *)(v4 + 116) = 0;
      *(_WORD *)(v4 + 118) = *(_WORD *)(v4 + 120);
      return result;
    }
    return 1;
  }
  v6 = *(_WORD *)(v4 + 116);
  if (!v6)
  {
LABEL_12:
    *(_WORD *)(v4 + 112) = *(_WORD *)(v4 + 114);
    *(_WORD *)(v4 + 116) = 0;
    *(_WORD *)(v4 + 118) = *(_WORD *)(v4 + 120);
    return 1;
  }
  v7 = *(_WORD *)(v4 + 112);
  while (1)
  {
    result = BIO_write(*((BIO **)this + 4), (const void *)(*(_QWORD *)(v4 + 104) + v7), v6);
    if ((int)result <= 0)
      break;
    v8 = *(unsigned __int16 *)(v4 + 116);
    if (result > v8)
      abort();
    v7 = *(_WORD *)(v4 + 112) + result;
    *(_WORD *)(v4 + 112) = v7;
    v6 = v8 - result;
    *(_WORD *)(v4 + 116) = v6;
    *(_WORD *)(v4 + 118) -= result;
    if (!v6)
      goto LABEL_12;
  }
  *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 3;
  return result;
}

uint64_t bssl::tls_seal_record(bssl *this, ssl_st *a2, unsigned __int8 *a3, const unsigned __int8 *a4, ssl_st *a5, unint64_t a6, const unsigned __int8 *a7)
{
  const ssl_st *v15;
  uint64_t v16;
  bssl::SSLAEADContext *v17;
  _BOOL8 v18;
  int v19;
  int v20;
  _BOOL4 v22;
  const unsigned __int8 *v23;
  uint64_t result;
  const ssl_st *v25;
  const unsigned __int8 *v26;
  char *v27;
  char *v28;
  const ssl_cipher_st *v29;
  unint64_t v30;
  unint64_t v31;
  int v32;
  char v33;
  unint64_t v34;

  if (&a4[(_QWORD)a2] > (const unsigned __int8 *)a6 && &a7[a6] > (const unsigned __int8 *)a2)
  {
    v19 = 189;
    v20 = 516;
LABEL_22:
    ERR_put_error(16, 0, v19, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", v20);
    return 0;
  }
  v16 = bssl::tls_seal_scatter_prefix_len(this, a5, (unint64_t)a7);
  v31 = 0xAAAAAAAAAAAAAAAALL;
  v17 = *(bssl::SSLAEADContext **)(*((_QWORD *)this + 6) + 272);
  if (*(_QWORD *)v17)
    v18 = bssl::SSLAEADContext::ProtocolVersion(v17) > 0x303;
  else
    v18 = 0;
  v22 = (_DWORD)a5 == 23 && (unint64_t)a7 > 1;
  v23 = a7;
  if (v22)
    v23 = &a7[-bssl::ssl_needs_record_splitting(this, v15)];
  result = bssl::SSLAEADContext::SuffixLen(*(bssl::SSLAEADContext **)(*((_QWORD *)this + 6) + 272), &v31, (uint64_t)v23, v18);
  if (!(_DWORD)result)
    return result;
  v26 = &a7[v16];
  if (__CFADD__(v16, a7) || __CFADD__(v31, v26))
  {
    v19 = 200;
    v20 = 527;
    goto LABEL_22;
  }
  if (&v26[v31] > a4)
  {
    v19 = 121;
    v20 = 531;
    goto LABEL_22;
  }
  v27 = (char *)a2 + v16;
  v28 = (char *)&a7[(_QWORD)a2 + v16];
  if (!v22 || !bssl::ssl_needs_record_splitting(this, v25))
  {
    if ((bssl::do_seal_record(this, a2, v27, v28, (unsigned __int8 *)a5, (char *)a6, a7) & 1) == 0)
      return 0;
LABEL_37:
    *(_QWORD *)a3 = &v26[v31];
    return 1;
  }
  if (bssl::SSLAEADContext::ExplicitNonceLen(*(bssl::SSLAEADContext **)(*((_QWORD *)this + 6) + 272)))
    bssl::tls_seal_record();
  result = bssl::do_seal_record(this, a2, (char *)&a2->type + 1, (char *)&a2->type + 2, (unsigned __int8 *)0x17, (char *)a6, (const unsigned __int8 *)1);
  if ((_DWORD)result)
  {
    v34 = 0xAAAAAAAAAAAAAAAALL;
    if (!bssl::SSLAEADContext::SuffixLen(*(bssl::SSLAEADContext **)(*((_QWORD *)this + 6) + 272), &v34, 1, 0))
      bssl::tls_seal_record();
    v30 = v34;
    if (bssl::ssl_cipher_get_record_split_len(**(bssl ***)(*((_QWORD *)this + 6) + 272), v29) != v30 + 1)
      bssl::tls_seal_record();
    v33 = -86;
    v32 = -1431655766;
    result = bssl::do_seal_record(this, (ssl_st *)&v32, v27 + 1, v28, (unsigned __int8 *)0x17, (char *)(a6 + 1), a7 - 1);
    if ((_DWORD)result)
    {
      if (bssl::tls_seal_scatter_prefix_len(this, (const ssl_st *)0x17, (unint64_t)a7) != v30 + 10)
        bssl::tls_seal_record();
      *(int *)((char *)&a2->type + v30 + 2) = v32;
      *v27 = v33;
      goto LABEL_37;
    }
  }
  return result;
}

BOOL bssl::SSLAEADContext::SuffixLen(bssl::SSLAEADContext *this, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (*(_QWORD *)this)
    return EVP_AEAD_CTX_tag_len((uint64_t *)this + 1, (uint64_t *)a2, a3, a4) != 0;
  *a2 = a4;
  return 1;
}

uint64_t EVP_AEAD_CTX_tag_len(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t (*v6)(void);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  if (a4 && !*(_DWORD *)(v5 + 4))
    EVP_AEAD_CTX_tag_len_cold_1();
  v6 = *(uint64_t (**)(void))(v5 + 64);
  if (v6)
  {
    v7 = v6();
LABEL_8:
    v9 = 1;
    goto LABEL_9;
  }
  v8 = *((unsigned __int8 *)a1 + 592);
  v7 = v8 + a4;
  if (!__CFADD__(v8, a4))
    goto LABEL_8;
  ERR_put_error(30, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", 281);
  v7 = 0;
  v9 = 0;
LABEL_9:
  *a2 = v7;
  return v9;
}

uint64_t bssl::do_seal_record(bssl *this, ssl_st *a2, char *a3, char *a4, unsigned __int8 *a5, char *a6, const unsigned __int8 *a7)
{
  char v9;
  bssl::SSLAEADContext *v14;
  unsigned int v15;
  uint64_t v16;
  char *v17;
  const unsigned __int8 *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  char v32;

  v9 = (char)a5;
  v32 = (char)a5;
  v14 = *(bssl::SSLAEADContext **)(*((_QWORD *)this + 6) + 272);
  if (*(_QWORD *)v14)
  {
    v15 = bssl::SSLAEADContext::ProtocolVersion(*(bssl::SSLAEADContext **)(*((_QWORD *)this + 6) + 272));
    if (v15 < 0x304)
    {
      v16 = 0;
    }
    else
    {
      v9 = 23;
      v16 = 1;
    }
    if (v15 >= 0x304)
      v17 = &v32;
    else
      v17 = 0;
  }
  else
  {
    v16 = 0;
    v17 = 0;
  }
  v30 = 0xAAAAAAAAAAAAAAAALL;
  v31 = 0xAAAAAAAAAAAAAAAALL;
  if (!bssl::SSLAEADContext::SuffixLen(v14, &v31, (uint64_t)a7, v16)
    || (bssl::SSLAEADContext::CiphertextLen(v14, &v30, (unint64_t)a7, v16) & 1) == 0)
  {
    v25 = 200;
    v26 = 384;
LABEL_25:
    ERR_put_error(16, 0, v25, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", v26);
    return 0;
  }
  v28 = v17;
  v29 = a4;
  v18 = &a7[(_QWORD)a6];
  if (a6 != a3 && v18 > (const unsigned __int8 *)a3 && &a7[(_QWORD)a3] > (const unsigned __int8 *)a6)
    bssl::do_seal_record();
  if (SSL_is_dtls((unsigned __int8 **)this))
    v19 = 13;
  else
    v19 = 5;
  v20 = bssl::SSLAEADContext::ExplicitNonceLen(*(bssl::SSLAEADContext **)(*((_QWORD *)this + 6) + 264));
  if (v18 > (const unsigned __int8 *)a2 && (char *)a2 + v19 + v20 > a6)
    bssl::do_seal_record();
  if (v18 > (const unsigned __int8 *)v29 && &v29[v31] > a6)
    bssl::do_seal_record();
  LOBYTE(a2->version) = v9;
  v21 = bssl::SSLAEADContext::RecordVersion(v14);
  *(_WORD *)((char *)&a2->version + 1) = __rev16(v21);
  *(_WORD *)((char *)&a2->version + 3) = bswap32((unsigned __int16)v30) >> 16;
  v23 = *(_QWORD *)(*((_QWORD *)this + 6) + 8);
  if (v23 == -1)
  {
    v25 = 69;
    v26 = 408;
    goto LABEL_25;
  }
  if (!bssl::SSLAEADContext::SealScatter((uint64_t)v14, (char *)&a2->type + 1, a3, v29, a2->version, v21, v23, v22, (uint64_t)a2, 5, a6, (uint64_t)a7, v28, v16))return 0;
  ++*(_QWORD *)(*((_QWORD *)this + 6) + 8);
  v24 = 1;
  bssl::ssl_do_msg_callback((uint64_t)this, 1, 256, (uint64_t)a2, 5);
  return v24;
}

uint64_t bssl::SSLAEADContext::SealScatter(uint64_t a1, char *a2, char *a3, char *a4, char a5, __int16 a6, unint64_t a7, int a8, uint64_t a9, uint64_t a10, char *__src, uint64_t a12, void *a13, uint64_t a14)
{
  uint64_t v20;
  char *v21;
  int v22;
  int v23;
  int v24;
  char *v25;
  uint64_t result;
  uint64_t v27;
  char v28;
  char *v29;
  size_t v30;
  char v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  char *v35;
  _BYTE *v36;
  size_t v37;
  char v38;
  int v39;
  uint64_t v40;
  char *v41;
  unint64_t v42;
  size_t v43;
  _QWORD __dst[3];
  _QWORD v45[4];

  v45[2] = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 625) & 1) != 0)
    v20 = *(unsigned __int8 *)(a1 + 621);
  else
    v20 = 0;
  v43 = 0xAAAAAAAAAAAAAAAALL;
  if (*(_QWORD *)a1)
  {
    v21 = a4;
    v22 = EVP_AEAD_CTX_tag_len((uint64_t *)(a1 + 8), (uint64_t *)&v43, a12, a14);
    a4 = v21;
    if (!v22)
    {
      v23 = 200;
      v24 = 322;
LABEL_16:
      ERR_put_error(16, 0, v23, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_aead_ctx.cc", v24);
      return 0;
    }
  }
  else
  {
    v43 = a14;
  }
  v25 = &__src[a12];
  if (__src != a3 && v25 > a3 && &a3[a12] > __src || v25 > a2 && &a2[v20] > __src || v25 > a4 && &a4[v43] > __src)
  {
    v23 = 189;
    v24 = 328;
    goto LABEL_16;
  }
  v27 = (uint64_t)a13;
  if (!*(_QWORD *)a1)
  {
    if (a12)
    {
      v29 = a4;
      memmove(a3, __src, a12);
      a4 = v29;
    }
    if (a14)
      memmove(a4, a13, a14);
    return 1;
  }
  *(_QWORD *)((char *)v45 + 5) = 0xAAAAAAAAAAAAAAAALL;
  v45[0] = 0xAAAAAAAAAAAAAAAALL;
  v28 = *(_BYTE *)(a1 + 625);
  if ((v28 & 0x10) == 0)
  {
    v45[0] = bswap64(a7);
    LOBYTE(v45[1]) = a5;
    BYTE1(v45[1]) = HIBYTE(a6);
    BYTE2(v45[1]) = a6;
    if ((v28 & 8) == 0)
      *(_WORD *)((char *)&v45[1] + 3) = bswap32(a12) >> 16;
  }
  memset(__dst, 170, sizeof(__dst));
  v30 = *(unsigned __int8 *)(a1 + 620);
  v41 = a4;
  if ((v28 & 4) != 0)
  {
    v30 -= *(unsigned __int8 *)(a1 + 621);
    if (!v30)
      goto LABEL_33;
    v40 = (uint64_t)a13;
    v31 = v28;
    bzero(__dst, v30);
  }
  else
  {
    if (!*(_BYTE *)(a1 + 620))
    {
      v30 = 0;
      if ((v28 & 2) == 0)
      {
LABEL_34:
        if (*(_BYTE *)(a1 + 621) != 8)
          bssl::SSLAEADContext::SealScatter();
        v32 = v27;
        *(_QWORD *)((char *)__dst + v30) = bswap64(a7);
        v33 = 8;
        if ((v28 & 1) == 0)
          goto LABEL_47;
        goto LABEL_41;
      }
      goto LABEL_38;
    }
    v40 = (uint64_t)a13;
    v31 = v28;
    memcpy(__dst, (const void *)(a1 + 608), v30);
  }
  v28 = v31;
  v27 = v40;
LABEL_33:
  if ((v28 & 2) == 0)
    goto LABEL_34;
LABEL_38:
  if ((v28 & 1) == 0)
    bssl::SSLAEADContext::SealScatter();
  result = RAND_bytes((unsigned __int8 *)__dst + v30, *(unsigned __int8 *)(a1 + 621));
  if ((_DWORD)result)
  {
    v32 = v27;
    v33 = *(unsigned __int8 *)(a1 + 621);
    v28 = *(_BYTE *)(a1 + 625);
    if ((v28 & 1) == 0)
    {
LABEL_47:
      v34 = v30 + v33;
      if ((v28 & 4) != 0)
      {
        if (v34 != *(unsigned __int8 *)(a1 + 620))
          bssl::SSLAEADContext::SealScatter();
        if (*(_BYTE *)(a1 + 620))
        {
          v35 = (char *)(a1 + 608);
          v36 = __dst;
          v37 = v30 + v33;
          do
          {
            v38 = *v35++;
            *v36++ ^= v38;
            --v37;
          }
          while (v37);
        }
      }
      v42 = 0xAAAAAAAAAAAAAAAALL;
      v39 = EVP_AEAD_CTX_seal_scatter((uint64_t *)(a1 + 8), a3, v41, &v42, v43, (uint64_t)__dst, v34, __src, a12, v32, a14);
      result = v39 != 0;
      if (v39)
      {
        if (v42 != v43)
          bssl::SSLAEADContext::SealScatter();
      }
      return result;
    }
LABEL_41:
    if ((v28 & 4) != 0)
      bssl::SSLAEADContext::SealScatter();
    if (v25 > a2 && &a2[v33] > __src)
    {
      v23 = 189;
      v24 = 374;
      goto LABEL_16;
    }
    if (v33)
    {
      memcpy(a2, (char *)__dst + *(unsigned __int8 *)(a1 + 620), v33);
      v28 = *(_BYTE *)(a1 + 625);
    }
    goto LABEL_47;
  }
  return result;
}

uint64_t bssl::SSLAEADContext::CiphertextLen(bssl::SSLAEADContext *this, unint64_t *a2, unint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v8;
  unint64_t v9;
  uint64_t v11;

  v11 = 0xAAAAAAAAAAAAAAAALL;
  if (*(_QWORD *)this)
  {
    result = EVP_AEAD_CTX_tag_len((uint64_t *)this + 1, &v11, a3, a4);
    if (!(_DWORD)result)
      return result;
  }
  else
  {
    v11 = a4;
  }
  if ((*((_BYTE *)this + 625) & 1) != 0)
    v8 = *((unsigned __int8 *)this + 621);
  else
    v8 = 0;
  v9 = v8 + a3 + v11;
  v11 = v9;
  if (v9 < a3 || v9 >= 0xFFFF)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_aead_ctx.cc", 207);
    return 0;
  }
  else
  {
    *a2 = v9;
    return 1;
  }
}

uint64_t bssl::tls_seal_scatter_prefix_len(bssl *this, const ssl_st *a2, unint64_t a3)
{
  const ssl_cipher_st *v4;

  if ((_DWORD)a2 == 23 && a3 >= 2 && bssl::ssl_needs_record_splitting(this, a2))
    return bssl::ssl_cipher_get_record_split_len(**(bssl ***)(*((_QWORD *)this + 6) + 272), v4) + 9;
  else
    return bssl::SSLAEADContext::ExplicitNonceLen(*(bssl::SSLAEADContext **)(*((_QWORD *)this + 6) + 272)) + 5;
}

uint64_t SSL_max_seal_overhead(uint64_t a1)
{
  const ssl_st *v3;
  uint64_t v4;
  uint64_t v5;
  bssl::SSLAEADContext *v6;

  if (SSL_is_dtls((unsigned __int8 **)a1))
    return bssl::dtls_max_seal_overhead(a1, 1);
  v4 = bssl::SSLAEADContext::MaxOverhead(*(bssl::SSLAEADContext **)(*(_QWORD *)(a1 + 48) + 272));
  v5 = v4 + 5;
  v6 = *(bssl::SSLAEADContext **)(*(_QWORD *)(a1 + 48) + 272);
  if (*(_QWORD *)v6)
  {
    if (bssl::SSLAEADContext::ProtocolVersion(v6) > 0x303)
      v5 = v4 + 6;
  }
  return v5 << bssl::ssl_needs_record_splitting((bssl *)a1, v3);
}

BOOL bssl::ssl_needs_record_splitting(bssl *this, const ssl_st *a2)
{
  bssl::SSLAEADContext *v3;

  v3 = *(bssl::SSLAEADContext **)(*((_QWORD *)this + 6) + 272);
  return *(_QWORD *)v3
      && bssl::SSLAEADContext::ProtocolVersion(v3) <= 0x301
      && (*((_BYTE *)this + 149) & 1) != 0
      && SSL_CIPHER_is_block_cipher(**(_QWORD **)(*((_QWORD *)this + 6) + 272));
}

int BIO_write(BIO *b, const void *data, int len)
{
  int (__cdecl *bwrite)(BIO *, const char *, int);
  int result;
  int v6;
  int v7;

  if (!b || !b->method || (bwrite = b->method->bwrite) == 0)
  {
    v6 = 115;
    v7 = 163;
LABEL_9:
    ERR_put_error(17, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio.c", v7);
    return -2;
  }
  if (!LODWORD(b->callback))
  {
    v6 = 114;
    v7 = 167;
    goto LABEL_9;
  }
  if (len < 1)
    return 0;
  result = ((uint64_t (*)(BIO *, const void *))bwrite)(b, data);
  if (result >= 1)
    b->next_bio = (bio_st *)((char *)b->next_bio + result);
  return result;
}

uint64_t boringssl_bio_write(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;

  if (!a2)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    result = (*(uint64_t (**)(_QWORD))(v3 + 16))(*(_QWORD *)v3);
    if ((int)result > 0)
      return result;
    BIO_set_retry_write(a1);
  }
  return 0xFFFFFFFFLL;
}

uint64_t nw_protocol_boringssl_write_bytes(void *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  int v12;
  uint64_t v13;
  void *v14;
  int v15;
  void *v16;
  _QWORD v17[3];
  int v18;
  _QWORD v19[4];

  v5 = a1;
  v6 = v5;
  v7 = 0xFFFFFFFFLL;
  if (!v5
    || !a2
    || !(_DWORD)a3
    || boringssl_session_get_state(v5[42]) > 3
    || (boringssl_session_is_cancelled(v6[42]) & 1) != 0)
  {
    goto LABEL_17;
  }
  if ((*((_BYTE *)v6 + 475) & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_write_bytes_cold_14();
  }
  v8 = v6[5];
  if (!v8 || (v9 = *(_QWORD *)(v8 + 24)) == 0 || !*(_QWORD *)(v9 + 88))
  {
    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_write_bytes_cold_1();
    }
    goto LABEL_16;
  }
  if ((*((_BYTE *)v6 + 390) & 2) != 0)
  {
    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_write_bytes_cold_13();
    }
  }
  else if ((*((_BYTE *)v6 + 475) & 1) == 0
         && g_boringssl_log
         && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_write_bytes_cold_12();
  }
  nw_frame_array_init();
  memset(v19, 170, sizeof(v19));
  nw_frame_array_init();
  if (boringssl_context_is_dtls(v6[42]))
    v11 = 1;
  else
    v11 = 0xFFFFFFFFLL;
  v12 = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)(v8 + 24) + 88))(v8, v6 + 1, 1, a3, v11, &v19[2]);
  if (nw_frame_array_is_empty())
  {
    if ((*((_BYTE *)v6 + 390) & 2) != 0)
    {
      if ((*((_BYTE *)v6 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_write_bytes_cold_3();
      }
    }
    else if ((*((_BYTE *)v6 + 475) & 1) == 0
           && g_boringssl_log
           && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_write_bytes_cold_2();
    }
LABEL_16:
    v7 = 0;
    goto LABEL_17;
  }
  if (!v12)
  {
    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_write_bytes_cold_4();
    }
    goto LABEL_16;
  }
  nw_frame_array_first();
  v13 = objc_claimAutoreleasedReturnValue();
  if (v13)
  {
    v14 = (void *)v13;
    v15 = a3;
    while (1)
    {
      nw_frame_array_next();
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(v17[0]) = 0;
      nw_frame_unclaimed_bytes();
      nw_frame_array_remove();

      if (!v16)
        break;
      v14 = v16;
    }
  }
  else
  {
    v16 = 0;
    v15 = a3;
  }
  if ((nw_frame_array_is_empty() & 1) != 0)
  {
    if ((*((_BYTE *)v6 + 390) & 2) != 0)
    {
      if ((*((_BYTE *)v6 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_write_bytes_cold_7();
      }
    }
    else if ((*((_BYTE *)v6 + 475) & 1) == 0
           && g_boringssl_log
           && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_write_bytes_cold_6();
    }
  }
  else
  {
    if (*(_QWORD *)(*(_QWORD *)(v8 + 24) + 96))
    {
      (*(void (**)(void))(*(_QWORD *)(v6[5] + 24) + 96))();
      v7 = (a3 - v15);
      if ((*((_BYTE *)v6 + 390) & 2) != 0)
      {
        if ((*((_BYTE *)v6 + 475) & 1) == 0
          && datapath_logging_enabled
          && g_boringssl_log
          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          nw_protocol_boringssl_write_bytes_cold_10();
        }
      }
      else if ((*((_BYTE *)v6 + 475) & 1) == 0
             && g_boringssl_log
             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_write_bytes_cold_9();
      }
      goto LABEL_62;
    }
    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_write_bytes_cold_8();
    }
  }
  v7 = 0;
LABEL_62:
  if ((nw_frame_array_is_empty() & 1) == 0)
  {
    v17[0] = 0;
    v17[1] = v17;
    v17[2] = 0x2020000000;
    v18 = 0;
    nw_frame_array_foreach();
    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_write_bytes_cold_5();
    }
    _Block_object_dispose(v17, 8);
  }

LABEL_17:
  return v7;
}

void sub_1B4F91870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t EVP_AEAD_CTX_seal_scatter(uint64_t *a1, char *a2, char *a3, _QWORD *a4, size_t a5, uint64_t a6, uint64_t a7, char *a8, size_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v15;
  char *v16;
  BOOL v17;
  int v18;
  int v19;
  uint64_t result;
  uint64_t v21;

  v15 = (unint64_t)&a8[a9];
  v16 = &a2[a9];
  if (a8 != a2 && (v15 > (unint64_t)a2 ? (v17 = v16 > a8) : (v17 = 0), v17)
    || &a3[a5] > a2 && v16 > a3
    || &a3[a5] > a8 && v15 > (unint64_t)a3)
  {
    v18 = 115;
    v19 = 162;
LABEL_11:
    ERR_put_error(30, 0, v18, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", v19);
    goto LABEL_12;
  }
  v21 = *a1;
  if (a11 && !*(_DWORD *)(v21 + 4))
  {
    v18 = 112;
    v19 = 167;
    goto LABEL_11;
  }
  if ((*(unsigned int (**)(uint64_t *, char *, char *, _QWORD *, size_t))(v21 + 40))(a1, a2, a3, a4, a5))
    return 1;
LABEL_12:
  if (a9)
    bzero(a2, a9);
  if (a5)
    bzero(a3, a5);
  result = 0;
  *a4 = 0;
  return result;
}

BOOL aead_aes_gcm_seal_scatter(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  unint64_t v14;
  int v15;
  int v16;
  int v18;
  _BOOL8 result;

  if (!a7)
  {
    v15 = 111;
    v16 = 291;
    goto LABEL_15;
  }
  v14 = *(unsigned __int8 *)(a1 + 24) + a11;
  if (v14 < *(unsigned __int8 *)(a1 + 592))
  {
    v15 = 117;
    v16 = 295;
LABEL_15:
    ERR_put_error(30, 0, v15, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_aes.m", v16);
    return 0;
  }
  if (v14 > a5)
  {
    v15 = 103;
    v16 = 299;
    goto LABEL_15;
  }
  if (!*(_QWORD *)(a1 + 8) || !*(_QWORD *)(a1 + 16))
  {
    v15 = 112;
    v16 = 303;
    goto LABEL_15;
  }
  v18 = ccgcm_reset();
  if (ccgcm_set_iv() | v18)
  {
    if (g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        aead_aes_gcm_seal_scatter_cold_6();
    }
    v15 = 107;
    v16 = 311;
    goto LABEL_15;
  }
  if (a13 && ccgcm_aad())
  {
    if (!g_boringssl_log)
      return 0;
    result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      aead_aes_gcm_seal_scatter_cold_5();
      return 0;
    }
  }
  else if (ccgcm_update())
  {
    if (!g_boringssl_log)
      return 0;
    result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      aead_aes_gcm_seal_scatter_cold_4();
      return 0;
    }
  }
  else if (a11 && ccgcm_update())
  {
    if (!g_boringssl_log)
      return 0;
    result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      aead_aes_gcm_seal_scatter_cold_3();
      return 0;
    }
  }
  else
  {
    if (ccgcm_finalize())
    {
      if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        aead_aes_gcm_seal_scatter_cold_2();
      v15 = 123;
      v16 = 340;
      goto LABEL_15;
    }
    *a4 = *(unsigned __int8 *)(a1 + 592) + a11;
    if (!ccgcm_reset())
      return 1;
    if (!g_boringssl_log)
      return 0;
    result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      aead_aes_gcm_seal_scatter_cold_1();
      return 0;
    }
  }
  return result;
}

BOOL aead_aes_gcm_tls13_seal_scatter(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  unint64_t v13;
  unint64_t v14;
  int v15;
  int v16;
  unint64_t v17;

  if (a7 != 12)
  {
    v15 = 121;
    v16 = 478;
LABEL_9:
    ERR_put_error(30, 0, v15, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_aes.m", v16);
    return 0;
  }
  v13 = bswap64(*(_QWORD *)(a6 + 4));
  if (*(_BYTE *)(a1 + 64))
  {
    *(_QWORD *)(a1 + 56) = v13;
    *(_BYTE *)(a1 + 64) = 0;
    v14 = v13;
  }
  else
  {
    v14 = *(_QWORD *)(a1 + 56);
  }
  v17 = v14 ^ v13;
  if (v17 == -1 || v17 < *(_QWORD *)(a1 + 48))
  {
    v15 = 125;
    v16 = 498;
    goto LABEL_9;
  }
  *(_QWORD *)(a1 + 48) = v17 + 1;
  return aead_aes_gcm_seal_scatter(a1, a2, a3, a4, a5, a6, 12, a8, a9, a10, a11, a12, a13);
}

uint64_t bssl::ssl_seal_align_prefix_len(unsigned __int8 **this, const ssl_st *a2)
{
  int is_dtls;
  uint64_t v4;
  const ssl_st *v5;
  uint64_t v6;
  const ssl_cipher_st *v8;

  is_dtls = SSL_is_dtls(this);
  v4 = bssl::SSLAEADContext::ExplicitNonceLen(*((bssl::SSLAEADContext **)this[6] + 34));
  v6 = v4;
  if (is_dtls)
    return v4 + 13;
  if (bssl::ssl_needs_record_splitting((bssl *)this, v5))
    return v6 + bssl::ssl_cipher_get_record_split_len(**((bssl ***)this[6] + 34), v8) + 10;
  return v6 + 5;
}

uint64_t bssl::SSLBuffer::DidWrite(uint64_t this, unint64_t a2)
{
  uint64_t v2;

  v2 = *(unsigned __int16 *)(this + 12);
  if ((unint64_t)*(unsigned __int16 *)(this + 14) - v2 < a2)
    abort();
  *(_WORD *)(this + 12) = v2 + a2;
  return this;
}

uint64_t BIO_flush(BIO *a1)
{
  return BIO_ctrl(a1, 11, 0, 0);
}

uint64_t boringssl_bio_ctrl(uint64_t a1, int a2, int a3)
{
  uint64_t result;

  result = 1;
  if (a2 > 103)
  {
    if ((a2 - 104) >= 2)
      return 0;
  }
  else
  {
    switch(a2)
    {
      case 8:
        return *(int *)(a1 + 12);
      case 9:
        *(_DWORD *)(a1 + 12) = a3;
        return 1;
      case 11:
        break;
      default:
        return 0;
    }
  }
  return result;
}

uint64_t BIO_ctrl(uint64_t bp, int cmd, uint64_t larg, void *parg)
{
  uint64_t (*v4)(void);

  if (bp)
  {
    if (*(_QWORD *)bp && (v4 = *(uint64_t (**)(void))(*(_QWORD *)bp + 48)) != 0)
    {
      return v4();
    }
    else
    {
      ERR_put_error(17, 0, 115, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio.c", 213);
      return -2;
    }
  }
  return bp;
}

uint64_t boringssl_context_flush_flight(const SSL *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  id WeakRetained;
  uint64_t v6;

  v1 = SSL_get_ex_data(a1, 0);
  if (!v1)
    return 0;
  v2 = (uint64_t)v1;
  if (*(_DWORD *)v1 != -1252936367)
    return 0;
  v3 = v1[1];
  if (!v3
    || boringssl_session_get_state((uint64_t)v1) > 3
    || (boringssl_session_is_cancelled(v2) & 1) != 0)
  {
    return 0;
  }
  WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
  v6 = nw_protocol_boringssl_flush_flight(WeakRetained);

  return v6;
}

uint64_t nw_protocol_boringssl_flush_flight(void *a1)
{
  _QWORD *v1;

  v1 = a1;
  if ((nw_frame_array_is_empty() & 1) == 0)
    (*(void (**)(void))(*(_QWORD *)(v1[35] + 24) + 96))();
  if ((nw_frame_array_is_empty() & 1) == 0)
    (*(void (**)(void))(*(_QWORD *)(v1[36] + 24) + 96))();
  if ((nw_frame_array_is_empty() & 1) == 0)
    (*(void (**)(void))(*(_QWORD *)(v1[37] + 24) + 96))();
  if ((nw_frame_array_is_empty() & 1) == 0)
    (*(void (**)(void))(*(_QWORD *)(v1[38] + 24) + 96))();

  return 1;
}

uint64_t boringssl_context_add_message(const SSL *a1, unsigned int a2, const void *a3, size_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  id WeakRetained;
  uint64_t v12;

  v7 = SSL_get_ex_data(a1, 0);
  if (!v7)
    return 0;
  v8 = (uint64_t)v7;
  if (*(_DWORD *)v7 != -1252936367)
    return 0;
  v9 = v7[1];
  if (!v9
    || boringssl_session_get_state((uint64_t)v7) > 3
    || (boringssl_session_is_cancelled(v8) & 1) != 0)
  {
    return 0;
  }
  if (a2 - 1 >= 3)
    a2 = 0;
  WeakRetained = objc_loadWeakRetained((id *)(v9 + 16));
  v12 = nw_protocol_boringssl_write_message(WeakRetained, a2, a3, a4);

  return v12;
}

uint64_t nw_protocol_boringssl_write_message(void *a1, unsigned int a2, const void *a3, size_t a4)
{
  id v7;
  void *v8;
  uint64_t v9;
  void *v10;
  dispatch_data_t v11;
  uint64_t v12;
  void *v13;
  _QWORD v15[2];

  v7 = a1;
  v8 = v7;
  if (a2 > 3)
    v9 = 0;
  else
    v9 = *((_QWORD *)v7 + a2 + 35);
  v15[0] = 0xAAAAAAAAAAAAAAAALL;
  v15[1] = 0xAAAAAAAAAAAAAAAALL;
  nw_frame_array_init();
  if ((*(unsigned int (**)(uint64_t, uint64_t, size_t, size_t, uint64_t, _QWORD *))(*(_QWORD *)(v9 + 24) + 88))(v9, (uint64_t)v8 + 8, a4, a4, 1, v15) == 1)
  {
    nw_frame_array_first();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    if (nw_frame_uses_external_data())
    {
      v11 = dispatch_data_create(a3, a4, 0, 0);
      nw_frame_set_external_data();

    }
    else
    {
      v13 = (void *)nw_frame_unclaimed_bytes();
      memcpy(v13, a3, a4);
    }
    v12 = 0;
    if (nw_frame_claim())
    {
      nw_frame_collapse();
      nw_frame_unclaim();
      v12 = 1;
      nw_frame_array_remove();
      nw_frame_array_append();
    }

  }
  else
  {
    v12 = 0;
  }

  return v12;
}

void nw_protocol_boringssl_write_bytes_cold_9()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136447234;
  OUTLINED_FUNCTION_9_0();
  OUTLINED_FUNCTION_6_0();
  OUTLINED_FUNCTION_10_0(&dword_1B4F6D000, v0, v1, "%{public}s(%d) %{public}s[%p] total bytes written: %u", v2);
  OUTLINED_FUNCTION_12_0();
}

void nw_protocol_boringssl_write_bytes_cold_12()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136447234;
  OUTLINED_FUNCTION_9_0();
  OUTLINED_FUNCTION_6_0();
  OUTLINED_FUNCTION_10_0(&dword_1B4F6D000, v0, v1, "%{public}s(%d) %{public}s[%p] write request: %u", v2);
  OUTLINED_FUNCTION_12_0();
}

void nw_protocol_boringssl_deallocate_options(void *a1, _QWORD *a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  const void *v28;
  const void *v29;
  void *v30;
  id v31;

  v31 = a1;
  if (a2)
  {
    v3 = (void *)a2[1];
    if (v3)
    {
      free(v3);
      a2[1] = 0;
    }
    v4 = (void *)a2[2];
    if (v4)
    {
      free(v4);
      a2[2] = 0;
    }
    v5 = (void *)a2[5];
    a2[5] = 0;

    v6 = (void *)a2[29];
    a2[29] = 0;

    v7 = (void *)a2[6];
    a2[6] = 0;

    v8 = (void *)a2[7];
    a2[7] = 0;

    v9 = (void *)a2[11];
    a2[11] = 0;

    v10 = (void *)a2[12];
    a2[12] = 0;

    v11 = (void *)a2[13];
    a2[13] = 0;

    v12 = (void *)a2[14];
    a2[14] = 0;

    v13 = (void *)a2[15];
    a2[15] = 0;

    v14 = (void *)a2[16];
    a2[16] = 0;

    v15 = (void *)a2[22];
    a2[22] = 0;

    v16 = (void *)a2[23];
    a2[23] = 0;

    v17 = (void *)a2[9];
    a2[9] = 0;

    v18 = (void *)a2[24];
    a2[24] = 0;

    v19 = (void *)a2[17];
    a2[17] = 0;

    v20 = (void *)a2[18];
    a2[18] = 0;

    v21 = (void *)a2[19];
    a2[19] = 0;

    v22 = (void *)a2[20];
    a2[20] = 0;

    v23 = (void *)a2[21];
    a2[21] = 0;

    v24 = (void *)a2[41];
    a2[41] = 0;

    v25 = (void *)a2[33];
    a2[33] = 0;

    v26 = (void *)a2[32];
    a2[32] = 0;

    v27 = (void *)a2[10];
    a2[10] = 0;

    a2[43] = 0;
    v28 = (const void *)a2[35];
    if (v28)
      CFRelease(v28);
    a2[35] = 0;
    v29 = (const void *)a2[36];
    if (v29)
      CFRelease(v29);
    a2[36] = 0;
    v30 = (void *)a2[42];
    if (v30)
    {
      free(v30);
      a2[42] = 0;
    }
    a2[44] = 0;
    cc_clear();
    free(a2);
  }
  else
  {
    cc_clear();
  }

}

void __boringssl_metrics_log_metric_block_invoke()
{
  if ((SecTrustReportNetworkingAnalytics() & 1) == 0
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
  {
    __boringssl_metrics_log_metric_block_invoke_cold_1();
  }
}

BOOL __boringssl_context_update_encryption_level_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  int level;
  uint64_t v6;
  uint64_t v7;
  int v8;
  id WeakRetained;
  void *v10;
  _BYTE *v11;
  char v12;
  uint64_t v13;
  id v14;
  _BYTE *v15;
  _BOOL4 v16;
  NSObject *v17;
  NSObject *v18;
  int v19;
  uint64_t v20;
  int v21;
  id v22;
  void *v23;
  _BYTE *v24;
  char v25;
  uint64_t v26;
  id v27;
  _BYTE *v28;
  _BOOL4 v29;
  NSObject *v30;
  NSObject *v31;
  id v33;
  uint64_t v34;
  id v35;
  uint64_t v36;
  _BOOL4 v37;
  char *v38;
  _BOOL4 v39;
  char *v40;
  id v41;
  int v42;
  id v43;
  int v44;
  void *v45;
  void *v46;
  void *v47;
  _BOOL4 v48;
  _BOOL4 v49;
  void *v50;
  void *v51;
  _QWORD v52[4];
  id v53;
  id v54;
  _QWORD block[4];
  id v56;
  id v57;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  void *v63;
  __int16 v64;
  id v65;
  __int16 v66;
  int v67;
  __int16 v68;
  int v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (a2 && *(_QWORD *)(a2 + 160) && *(_QWORD *)(a2 + 168))
  {
    v4 = (void *)MEMORY[0x1B5E45624]();
    level = SSL_quic_read_level(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 400));
    v6 = *(_QWORD *)(a1 + 32);
    v7 = MEMORY[0x1E0C809B0];
    if (level != *(_DWORD *)(v6 + 548))
    {
      v8 = level;
      WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
      if (!WeakRetained
        || (v10 = WeakRetained,
            v11 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16)),
            v12 = v11[475],
            v11,
            v10,
            (v12 & 1) == 0))
      {
        v13 = *(_QWORD *)(a1 + 32);
        if (v13)
        {
          v14 = objc_loadWeakRetained((id *)(v13 + 16));
          if (v14)
          {
            v15 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
            v16 = (v15[475] & 1) == 0;

          }
          else
          {
            v16 = 1;
          }

        }
        else
        {
          v16 = 1;
        }
        if (v16 && g_boringssl_log)
        {
          v17 = (id)g_boringssl_log;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            v33 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
            v34 = *(_QWORD *)(a1 + 32);
            v50 = v33;
            if (v33)
            {
              v37 = v34 != 0;
              if (v34)
              {
                v38 = (char *)objc_loadWeakRetained((id *)(v34 + 16));
                v34 = *(_QWORD *)(a1 + 32);
              }
              else
              {
                v38 = 0;
              }
              v48 = v37;
              v45 = v38;
              v46 = v38 + 391;
            }
            else
            {
              v48 = 0;
              v46 = &unk_1B50022E3;
            }
            v41 = objc_loadWeakRetained((id *)(v34 + 16));
            v42 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 548);
            *(_DWORD *)buf = 136447490;
            v59 = "boringssl_context_update_encryption_level_block_invoke";
            v60 = 1024;
            v61 = 2449;
            v62 = 2082;
            v63 = v46;
            v64 = 2048;
            v65 = v41;
            v66 = 1024;
            v67 = v42;
            v68 = 1024;
            v69 = v8;
            _os_log_debug_impl(&dword_1B4F6D000, v17, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] encryption_read_level %u -> %u", buf, 0x32u);

            if (v48)
          }

        }
      }
      *(_DWORD *)(*(_QWORD *)(a1 + 32) + 548) = v8;
      v18 = *(NSObject **)(a2 + 168);
      block[0] = v7;
      block[1] = 3221225472;
      block[2] = __boringssl_context_update_encryption_level_block_invoke_213;
      block[3] = &unk_1E6879190;
      v57 = v4;
      v56 = *(id *)(a1 + 32);
      dispatch_async(v18, block);

      v6 = *(_QWORD *)(a1 + 32);
    }
    v19 = SSL_quic_write_level(*(_QWORD *)(v6 + 400));
    v20 = *(_QWORD *)(a1 + 32);
    if (v19 != *(_DWORD *)(v20 + 552))
    {
      v21 = v19;
      v22 = objc_loadWeakRetained((id *)(v20 + 16));
      if (!v22
        || (v23 = v22,
            v24 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16)),
            v25 = v24[475],
            v24,
            v23,
            (v25 & 1) == 0))
      {
        v26 = *(_QWORD *)(a1 + 32);
        if (v26)
        {
          v27 = objc_loadWeakRetained((id *)(v26 + 16));
          if (v27)
          {
            v28 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
            v29 = (v28[475] & 1) == 0;

          }
          else
          {
            v29 = 1;
          }

        }
        else
        {
          v29 = 1;
        }
        if (v29 && g_boringssl_log)
        {
          v30 = (id)g_boringssl_log;
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            v35 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
            v36 = *(_QWORD *)(a1 + 32);
            v51 = v35;
            if (v35)
            {
              v39 = v36 != 0;
              if (v36)
              {
                v40 = (char *)objc_loadWeakRetained((id *)(v36 + 16));
                v36 = *(_QWORD *)(a1 + 32);
              }
              else
              {
                v40 = 0;
              }
              v49 = v39;
              v45 = v40;
              v47 = v40 + 391;
            }
            else
            {
              v49 = 0;
              v47 = &unk_1B50022E3;
            }
            v43 = objc_loadWeakRetained((id *)(v36 + 16));
            v44 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 552);
            *(_DWORD *)buf = 136447490;
            v59 = "boringssl_context_update_encryption_level_block_invoke_2";
            v60 = 1024;
            v61 = 2458;
            v62 = 2082;
            v63 = v47;
            v64 = 2048;
            v65 = v43;
            v66 = 1024;
            v67 = v44;
            v68 = 1024;
            v69 = v21;
            _os_log_debug_impl(&dword_1B4F6D000, v30, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] encryption_write_level %u -> %u", buf, 0x32u);

            if (v49)
          }

        }
      }
      *(_DWORD *)(*(_QWORD *)(a1 + 32) + 552) = v21;
      v31 = *(NSObject **)(a2 + 168);
      v52[0] = v7;
      v52[1] = 3221225472;
      v52[2] = __boringssl_context_update_encryption_level_block_invoke_215;
      v52[3] = &unk_1E6879190;
      v54 = v4;
      v53 = *(id *)(a1 + 32);
      dispatch_async(v31, v52);

    }
  }
  return a2 != 0;
}

uint64_t SSL_quic_write_level(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 48) + 204);
}

uint64_t SSL_quic_read_level(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 48) + 200);
}

uint64_t ec_GFp_mont_group_init(uint64_t a1)
{
  uint64_t result;

  result = ec_GFp_simple_group_init(a1);
  *(_QWORD *)(a1 + 312) = 0;
  return result;
}

uint64_t ec_GFp_simple_group_init(uint64_t a1)
{
  BN_init((BIGNUM *)(a1 + 56));
  *(_DWORD *)(a1 + 224) = 0;
  return 1;
}

BOOL bssl::`anonymous namespace'::ECKeyShare::Offer(uint64_t a1, uint64_t a2)
{
  BIGNUM **v2;
  BIGNUM *v5;
  uint64_t v6;
  BIGNUM *v7;
  uint64_t v8;
  EC_POINT *v9;
  EC_POINT *v10;
  _BOOL8 v11;

  v2 = (BIGNUM **)(a1 + 8);
  if (*(_QWORD *)(a1 + 8))
  v5 = BN_new();
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100](v2, v5);
  v6 = *(_QWORD *)(a1 + 16);
  if (!v6)
    return 0;
  v7 = *v2;
  if (!v7)
    return 0;
  v8 = EC_GROUP_get0_order(v6);
  if (!BN_rand_range_ex((uint64_t)v7, 1uLL, v8))
    return 0;
  v9 = EC_POINT_new(*(const EC_GROUP **)(a1 + 16));
  if (!v9)
    return 0;
  v10 = v9;
  if (EC_POINT_mul(*(const EC_GROUP **)(a1 + 16), v9, *(const BIGNUM **)(a1 + 8), 0, 0, 0))
    v11 = EC_POINT_point2cbb(a2, *(EC_GROUP **)(a1 + 16), v10, POINT_CONVERSION_UNCOMPRESSED, 0) != 0;
  else
    v11 = 0;
  EC_POINT_free(v10);
  return v11;
}

void sub_1B4F92BA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<ec_point_st,bssl::internal::Deleter>::reset[abi:ne180100]((EC_POINT **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t EC_GROUP_get0_order(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 16;
  if (BN_is_zero(a1 + 16))
    EC_GROUP_get0_order_cold_1();
  return v1;
}

uint64_t BN_rand_range_ex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = bn_wexpand((_QWORD **)a1, *(int *)(a3 + 8));
  if ((_DWORD)result)
  {
    result = bn_rand_range_words(*(uint64_t **)a1, a2, *(unint64_t **)a3, *(int *)(a3 + 8), (uint64_t)&BN_rand_range_ex_kDefaultAdditionalData);
    if ((_DWORD)result)
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a3 + 8);
      return 1;
    }
  }
  return result;
}

uint64_t bn_rand_range_words(uint64_t *a1, unint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  unint64_t v11;
  size_t v12;
  unint64_t v13;
  int v14;
  unint64_t v16;
  unint64_t v17;

  v16 = 0xAAAAAAAAAAAAAAAALL;
  v17 = 0xAAAAAAAAAAAAAAAALL;
  result = bn_range_to_mask(&v17, &v16, a2, a3, a4);
  if ((_DWORD)result)
  {
    v11 = v17;
    v12 = 8 * (a4 - v17);
    if (v12)
      bzero(&a1[v17], v12);
    v13 = v16;
    v14 = -100;
    while (!__CFADD__(v14++, 1))
    {
      RAND_bytes_with_additional_data(a1, 8 * v11, a5);
      a1[v11 - 1] &= v13;
      if (bn_in_range_words(a1, a2, (uint64_t *)a3, v11))
        return 1;
    }
    ERR_put_error(3, 0, 115, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/random.c", 271);
    return 0;
  }
  return result;
}

uint64_t bn_range_to_mask(_QWORD *a1, unint64_t *a2, unint64_t a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  while (a5)
  {
    v5 = a5 - 1;
    v6 = a4[--a5];
    if (v6)
    {
      if (v5 || *a4 > a3)
      {
        v7 = v6 | (v6 >> 1) | ((v6 | (v6 >> 1)) >> 2);
        v8 = v7 | (v7 >> 4) | ((v7 | (v7 >> 4)) >> 8);
        *a1 = v5 + 1;
        *a2 = v8 | (v8 >> 16) | ((v8 | (v8 >> 16)) >> 32);
        return 1;
      }
      break;
    }
  }
  ERR_put_error(3, 0, 108, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/random.c", 230);
  return 0;
}

uint64_t bn_in_range_words(uint64_t *a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unsigned int v8;

  if (a2)
  {
    if (a4)
    {
      v4 = 0;
      v5 = a4 - 1;
      if (a4 != 1)
      {
        v6 = a1 + 1;
        do
        {
          v7 = *v6++;
          v4 |= v7;
          --v5;
        }
        while (v5);
      }
      v8 = ~(((v4 - 1) & ~v4 & (((*a1 - a2) ^ *a1 | *a1 ^ a2) ^ *a1)) >> 63);
    }
    else
    {
      v8 = 0;
    }
  }
  else
  {
    v8 = -1;
  }
  return bn_less_than_words(a1, a3, a4) & v8;
}

uint64_t ec_GFp_mont_group_set_curve(uint64_t a1, BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  BN_MONT_CTX *v10;
  uint64_t result;

  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 312));
  v10 = BN_MONT_CTX_new_for_modulus(a2, a5);
  *(_QWORD *)(a1 + 312) = v10;
  if (v10)
  {
    if (ec_GFp_simple_group_set_curve(a1, a2, a3, a4, a5))
    {
      return 1;
    }
    else
    {
      BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 312));
      result = 0;
      *(_QWORD *)(a1 + 312) = 0;
    }
  }
  else
  {
    ERR_put_error(15, 0, 3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_montgomery.c", 98);
    return 0;
  }
  return result;
}

uint64_t ec_group_set_generator(uint64_t a1, uint64_t a2, BIGNUM *b)
{
  const BIGNUM *v6;
  uint64_t result;
  int v8;
  int v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  BIGNUM r;

  if (*(_QWORD *)(a1 + 8))
    ec_group_set_generator_cold_3();
  v6 = (const BIGNUM *)(a1 + 16);
  result = (uint64_t)BN_copy((BIGNUM *)(a1 + 16), b);
  if (result)
  {
    bn_set_minimal_width((uint64_t)v6);
    BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 48));
    result = (uint64_t)BN_MONT_CTX_new_for_modulus(v6, 0);
    *(_QWORD *)(a1 + 48) = result;
    if (result)
    {
      v8 = BN_cmp((const BIGNUM *)(a1 + 56), b);
      *(_DWORD *)(a1 + 228) = v8 > 0;
      if (v8 < 1)
        goto LABEL_7;
      memset(&r, 170, sizeof(r));
      BN_init(&r);
      if (BN_sub(&r, (const BIGNUM *)(a1 + 56), b))
      {
        v9 = bn_copy_words((void *)(a1 + 232), *(int *)(a1 + 64), (uint64_t)&r);
        BN_free(&r);
        if (v9)
        {
LABEL_7:
          result = (uint64_t)EC_POINT_new((const EC_GROUP *)a1);
          *(_QWORD *)(a1 + 8) = result;
          if (result)
          {
            *(_OWORD *)(result + 8) = *(_OWORD *)a2;
            v10 = *(_OWORD *)(a2 + 16);
            v11 = *(_OWORD *)(a2 + 32);
            v12 = *(_OWORD *)(a2 + 48);
            *(_QWORD *)(result + 72) = *(_QWORD *)(a2 + 64);
            *(_OWORD *)(result + 56) = v12;
            *(_OWORD *)(result + 40) = v11;
            *(_OWORD *)(result + 24) = v10;
            v13 = *(_OWORD *)(a2 + 104);
            v14 = *(_OWORD *)(a2 + 120);
            v15 = *(_OWORD *)(a2 + 88);
            *(_QWORD *)(result + 144) = *(_QWORD *)(a2 + 136);
            *(_OWORD *)(result + 112) = v13;
            *(_OWORD *)(result + 128) = v14;
            *(_OWORD *)(result + 96) = v15;
            *(_OWORD *)(result + 80) = *(_OWORD *)(a2 + 72);
            v17 = *(_OWORD *)(a1 + 352);
            v16 = *(_OWORD *)(a1 + 368);
            v18 = *(_QWORD *)(a1 + 384);
            *(_OWORD *)(result + 168) = *(_OWORD *)(a1 + 336);
            *(_QWORD *)(result + 216) = v18;
            *(_OWORD *)(result + 200) = v16;
            *(_OWORD *)(result + 184) = v17;
            *(_OWORD *)(result + 152) = *(_OWORD *)(a1 + 320);
            if (!ec_felem_equal(a1, (char *)(a1 + 320), (char *)(*(_QWORD *)(a1 + 8) + 152)))
              ec_group_set_generator_cold_1();
            if (CRYPTO_refcount_dec_and_test_zero((unsigned int *)(a1 + 304)))
              ec_group_set_generator_cold_2();
            return 1;
          }
          return result;
        }
      }
      else
      {
        BN_free(&r);
      }
      return 0;
    }
  }
  return result;
}

void RSA_free(RSA *r)
{
  uint64_t v2;
  unsigned int v3;
  RSA_METHOD *meth;
  ENGINE *engine;

  if (r && CRYPTO_refcount_dec_and_test_zero((unsigned int *)&r->dmq1))
  {
    CRYPTO_free_ex_data((int)&g_ex_data_class, r, (CRYPTO_EX_DATA *)&r->dmp1);
    BN_clear_free((BIGNUM *)r->version);
    BN_clear_free((BIGNUM *)r->meth);
    BN_clear_free((BIGNUM *)r->engine);
    BN_clear_free(r->n);
    BN_clear_free(r->e);
    BN_clear_free(r->d);
    BN_clear_free(r->p);
    BN_clear_free(r->q);
    BN_MONT_CTX_free(r[1]._method_mod_n);
    BN_MONT_CTX_free(r[1]._method_mod_p);
    BN_MONT_CTX_free(r[1]._method_mod_q);
    if (r[2].version)
    {
      v2 = 0;
      v3 = 1;
      do
      {
        BN_BLINDING_free(*((BN_BLINDING **)&r[2].meth->name + v2));
        v2 = v3;
      }
      while (r[2].version > (unint64_t)v3++);
    }
    meth = (RSA_METHOD *)r[2].meth;
    if (meth)
    {
      free(meth);
      r[2].meth = 0;
    }
    engine = r[2].engine;
    if (engine)
    {
      free(engine);
      r[2].engine = 0;
    }
    CRYPTO_MUTEX_cleanup((pthread_rwlock_t *)&r->iqmp);
    free(r);
  }
}

void BN_MONT_CTX_free(BN_MONT_CTX *mont)
{
  if (mont)
  {
    BN_free((BIGNUM *)mont);
    BN_free((BIGNUM *)&mont->RR.neg);
    OPENSSL_free(mont);
  }
}

void ssl_ctx_st::~ssl_ctx_st(ssl_ctx_st *this)
{
  SSL_CTX_flush_sessions(this, 0);
  CRYPTO_free_ex_data((int)&bssl::g_ex_data_class_ssl_ctx, this, (CRYPTO_EX_DATA *)&this->generate_session_id);
  CRYPTO_MUTEX_cleanup((pthread_rwlock_t *)&this->cipher_list_by_id);
  OPENSSL_lh_free(&this->comp_methods->num);
  (*(void (**)(ssl_ctx_st *))&this->cipher_list[4].num)(this);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].msg_callback);
  std::unique_ptr<ssl_ech_keys_st,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)&this[1].info_callback, 0);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)&this[1].comp_methods, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].sha1);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].rsa_md5);
  std::unique_ptr<stack_st_SRTP_PROTECTION_PROFILE,bssl::internal::Deleter>::reset[abi:ne180100](&this[1].ex_data.sk, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].client_cert_cb);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].default_passwd_callback);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].app_verify_callback);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].stats.sess_cache_full);
  bssl::Array<unsigned char>::~Array((uint64_t)&this[1].stats.sess_accept_renegotiate);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)&this[1].session_cache_size, 0);
  std::unique_ptr<bssl::TicketKey,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)&this[1].cert_store, 0);
  std::unique_ptr<bssl::TicketKey,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)&this[1].cipher_list_by_id, 0);
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)this->tlsext_tick_key_name, 0);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&this->quiet_shutdown, 0);
  std::unique_ptr<bssl::SSLCipherPreferenceList,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLCipherPreferenceList **)&this->md5, 0);
}

void bssl::SSL_CONFIG::~SSL_CONFIG(STACK **this)
{
  int (__cdecl *comp)(const char *const *, const char *const *);

  comp = (*this)[3].comp;
  if (comp)
    (*(void (**)(STACK **))(*((_QWORD *)comp + 1) + 96))(this);
  bssl::Array<unsigned char>::~Array((uint64_t)(this + 37));
  std::unique_ptr<stack_st_SRTP_PROTECTION_PROFILE,bssl::internal::Deleter>::reset[abi:ne180100](this + 36, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)(this + 34));
  bssl::Array<unsigned char>::~Array((uint64_t)(this + 32));
  bssl::Array<unsigned char>::~Array((uint64_t)(this + 30));
  bssl::Array<unsigned char>::~Array((uint64_t)(this + 27));
  bssl::Array<unsigned char>::~Array((uint64_t)(this + 25));
  bssl::Array<unsigned char>::~Array((uint64_t)(this + 23));
  bssl::Array<unsigned char>::~Array((uint64_t)(this + 21));
  bssl::Array<bssl::ALPSConfig>::~Array((uint64_t)(this + 19));
  bssl::Array<unsigned char>::~Array((uint64_t)(this + 16));
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)this + 15, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)(this + 13));
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)this + 11, 0);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)this + 7, 0);
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)this + 4, 0);
  std::unique_ptr<bssl::SSLCipherPreferenceList,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLCipherPreferenceList **)this + 3, 0);
}

uint64_t bssl::Array<bssl::ALPSConfig>::~Array(uint64_t a1)
{
  bssl::Array<bssl::ALPSConfig>::Reset(a1, 0, 0);
  return a1;
}

void bssl::Array<bssl::ALPSConfig>::Reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  if (*(_QWORD *)(a1 + 8))
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = *(_QWORD *)a1 + v6;
      bssl::Array<unsigned char>::~Array(v8 + 16);
      bssl::Array<unsigned char>::~Array(v8);
      ++v7;
      v6 += 32;
    }
    while (v7 < *(_QWORD *)(a1 + 8));
  }
  OPENSSL_free(*(_QWORD **)a1);
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
}

void SSL_CTX_flush_sessions(SSL_CTX *ctx, uint64_t tm)
{
  STACK *comp_methods;
  pthread_rwlock_t *v3;
  _QWORD v4[3];
  _QWORD v5[2];

  comp_methods = ctx->comp_methods;
  v4[0] = ctx;
  v4[2] = comp_methods;
  if (comp_methods)
  {
    v4[1] = tm;
    v3 = (pthread_rwlock_t *)0xAAAAAAAAAAAAAAAALL;
    bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_write),&(CRYPTO_MUTEX_unlock_write)>::MutexLockBase(&v3, (pthread_rwlock_t *)&ctx->cipher_list_by_id);
    v5[0] = timeout_doall_arg;
    v5[1] = v4;
    OPENSSL_lh_doall_arg((uint64_t)comp_methods, (void (*)(_QWORD, uint64_t))lh_SSL_SESSION_call_doall_arg, (uint64_t)v5);
    CRYPTO_MUTEX_unlock_read(v3);
  }
}

void sub_1B4F9350C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, pthread_rwlock_t *a9)
{
  CRYPTO_MUTEX_unlock_read(a9);
  _Unwind_Resume(a1);
}

void lh_maybe_resize(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;

  if (!*(_DWORD *)(a1 + 24))
  {
    v1 = *(_QWORD *)(a1 + 16);
    if (v1 <= 0xF)
      lh_maybe_resize_cold_1();
    if (*(_QWORD *)a1 / v1 < 3)
    {
      if (v1 < 0x11 || v1 <= *(_QWORD *)a1)
        return;
      v3 = v1 >> 1;
      if (v3 <= 0x10)
        v2 = 16;
      else
        v2 = v3;
    }
    else
    {
      if ((uint64_t)v1 < 1)
        return;
      v2 = 2 * v1;
    }
    lh_rebucket(a1, v2);
  }
}

pthread_rwlock_t **bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_write),&(CRYPTO_MUTEX_unlock_write)>::MutexLockBase(pthread_rwlock_t **a1, pthread_rwlock_t *a2)
{
  *a1 = a2;
  if (!a2)
    bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_read),&(CRYPTO_MUTEX_unlock_read)>::MutexLockBase();
  CRYPTO_MUTEX_lock_write(a2);
  return a1;
}

void OPENSSL_lh_free(_QWORD *a1)
{
  unint64_t v2;
  unint64_t i;
  _QWORD *v4;
  _QWORD *v5;

  if (a1)
  {
    v2 = a1[2];
    if (v2)
    {
      for (i = 0; i < v2; ++i)
      {
        v4 = *(_QWORD **)(a1[1] + 8 * i);
        if (v4)
        {
          do
          {
            v5 = (_QWORD *)v4[1];
            OPENSSL_free(v4);
            v4 = v5;
          }
          while (v5);
          v2 = a1[2];
        }
      }
    }
    OPENSSL_free((_QWORD *)a1[1]);
    OPENSSL_free(a1);
  }
}

void OPENSSL_lh_doall_arg(uint64_t a1, void (*a2)(_QWORD, uint64_t), uint64_t a3)
{
  int v6;
  int v7;
  unint64_t v8;
  unint64_t i;
  _QWORD *v10;
  _QWORD *v11;

  if (a1)
  {
    v6 = *(_DWORD *)(a1 + 24);
    if (v6 == -1)
    {
      v7 = -1;
    }
    else
    {
      v7 = v6 + 1;
      *(_DWORD *)(a1 + 24) = v6 + 1;
    }
    v8 = *(_QWORD *)(a1 + 16);
    if (v8)
    {
      for (i = 0; i < v8; ++i)
      {
        v10 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8 * i);
        if (v10)
        {
          do
          {
            v11 = (_QWORD *)v10[1];
            a2(*v10, a3);
            v10 = v11;
          }
          while (v11);
          v8 = *(_QWORD *)(a1 + 16);
        }
      }
      v7 = *(_DWORD *)(a1 + 24);
    }
    if (v7 != -1)
      *(_DWORD *)(a1 + 24) = v7 - 1;
    lh_maybe_resize(a1);
  }
}

uint64_t ec_GFp_simple_group_set_curve(uint64_t a1, BIGNUM *a, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  BIGNUM *v10;
  BIGNUM *v11;
  const BIGNUM *v12;
  uint64_t v13;

  if (BN_num_bits(a) >= 3 && BN_is_odd((uint64_t)a))
  {
    BN_CTX_start(a5);
    v10 = BN_CTX_get(a5);
    if (v10
      && (v11 = v10, BN_copy((BIGNUM *)(a1 + 56), a))
      && (BN_set_negative((BIGNUM *)(a1 + 56), 0),
          bn_set_minimal_width(a1 + 56),
          ec_bignum_to_felem(a1, a1 + 80, a3))
      && ec_bignum_to_felem(a1, a1 + 152, a4)
      && (v12 = BN_value_one(), ec_bignum_to_felem(a1, a1 + 320, v12))
      && BN_copy(v11, a3)
      && BN_add_word(v11, 3uLL))
    {
      *(_DWORD *)(a1 + 224) = BN_cmp(v11, (const BIGNUM *)(a1 + 56)) == 0;
      v13 = 1;
    }
    else
    {
      v13 = 0;
    }
    BN_CTX_end(a5);
  }
  else
  {
    ERR_put_error(15, 0, 110, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/simple.c", 106);
    return 0;
  }
  return v13;
}

BIGNUM *__cdecl BN_copy(BIGNUM *a, const BIGNUM *b)
{
  BIGNUM *v3;
  uint64_t top;

  if (b == a)
    return (BIGNUM *)b;
  v3 = a;
  if (!bn_wexpand(&a->d, b->top))
    return 0;
  top = b->top;
  if ((_DWORD)top)
  {
    memcpy(v3->d, b->d, 8 * top);
    LODWORD(top) = b->top;
  }
  v3->top = top;
  v3->neg = b->neg;
  return v3;
}

uint64_t ec_bignum_to_felem(uint64_t a1, uint64_t a2, const BIGNUM *a3)
{
  const BIGNUM *v6;
  unsigned int v7;
  unsigned int v8;
  __int128 v9;
  _OWORD v11[4];
  __int16 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v6 = (const BIGNUM *)(a1 + 56);
  v7 = BN_num_bytes((const BIGNUM *)(a1 + 56));
  if (v7 >= 0x43)
    ec_bignum_to_felem_cold_1();
  v8 = v7;
  v12 = -21846;
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[2] = v9;
  v11[3] = v9;
  v11[0] = v9;
  v11[1] = v9;
  if (!BN_is_negative((uint64_t)a3)
    && BN_cmp(a3, v6) < 0
    && BN_bn2bin_padded((char *)v11, v8, (uint64_t)a3))
  {
    return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, _QWORD))(*(_QWORD *)a1 + 136))(a1, a2, v11, v8);
  }
  ERR_put_error(15, 0, 101, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/felem.c", 33);
  return 0;
}

int BN_cmp(const BIGNUM *a, const BIGNUM *b)
{
  int neg;
  int result;

  if (a && b)
  {
    neg = a->neg;
    if (neg == b->neg)
    {
      result = bn_cmp_words_consttime((uint64_t *)a->d, a->top, (uint64_t *)b->d, b->top);
      if (neg)
        return -result;
    }
    else if (neg)
    {
      return -1;
    }
    else
    {
      return 1;
    }
  }
  else if (a)
  {
    return -1;
  }
  else
  {
    return b != 0;
  }
  return result;
}

BN_MONT_CTX *BN_MONT_CTX_new_for_modulus(const BIGNUM *a1, BN_CTX *a2)
{
  BN_MONT_CTX *v4;
  BN_MONT_CTX *v5;

  v4 = BN_MONT_CTX_new();
  v5 = v4;
  if (!v4 || !BN_MONT_CTX_set(v4, a1, a2))
  {
    BN_MONT_CTX_free(v5);
    return 0;
  }
  return v5;
}

int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)
{
  BN_CTX *v5;
  int d;
  int v7;

  if (!bn_mont_ctx_set_N_and_n0((uint64_t)mont, mod))
    return 0;
  if (ctx)
  {
    v5 = 0;
    goto LABEL_5;
  }
  ctx = BN_CTX_new();
  v5 = ctx;
  if (!ctx)
    return 0;
LABEL_5:
  d = (int)mont->N.d;
  BN_zero((uint64_t)mont);
  v7 = BN_set_bit((BIGNUM *)mont, d << 7)
    && BN_div(0, (BIGNUM *)mont, (const BIGNUM *)mont, (const BIGNUM *)&mont->RR.neg, ctx)
    && bn_resize_words((uint64_t)mont, SLODWORD(mont->N.d)) != 0;
  BN_CTX_free(v5);
  return v7;
}

void BN_CTX_free(BN_CTX *c)
{
  if (c)
  {
    if (*((_QWORD *)c + 4))
    {
      if (!*((_BYTE *)c + 40))
        BN_CTX_free_cold_1();
    }
    sk_pop_free_ex(*(unint64_t **)c, (void (*)(uint64_t))sk_BIGNUM_call_free_func, (uint64_t)BN_free);
    OPENSSL_free(*((_QWORD **)c + 1));
    OPENSSL_free(c);
  }
}

uint64_t bn_resize_words(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  size_t v12;

  v4 = *(int *)(a1 + 8);
  v5 = v4 > a2;
  v6 = v4 - a2;
  if (v5)
  {
    v7 = 0;
    v8 = (uint64_t *)(*(_QWORD *)a1 + 8 * a2);
    do
    {
      v9 = *v8++;
      v7 |= v9;
      --v6;
    }
    while (v6);
    if (v7)
    {
      ERR_put_error(3, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/bn.c", 399);
      return 0;
    }
    goto LABEL_10;
  }
  result = bn_wexpand((_QWORD **)a1, a2);
  if ((_DWORD)result)
  {
    v11 = *(int *)(a1 + 8);
    v12 = 8 * (a2 - v11);
    if (v12)
      bzero((void *)(*(_QWORD *)a1 + 8 * v11), v12);
LABEL_10:
    *(_DWORD *)(a1 + 8) = a2;
    return 1;
  }
  return result;
}

int BN_set_bit(BIGNUM *a, int n)
{
  char v2;
  signed int v4;
  int result;
  uint64_t top;

  if (n < 0)
    return 0;
  v2 = n;
  v4 = n >> 6;
  if (a->top <= (signed int)(n >> 6))
  {
    result = bn_wexpand(&a->d, (v4 + 1));
    if (!result)
      return result;
    top = a->top;
    if (v4 >= (int)top)
      bzero(&a->d[top], 8 * (v4 - top) + 8);
    a->top = v4 + 1;
  }
  result = 1;
  a->d[v4] |= 1 << (v2 & 0x3F);
  return result;
}

BN_MONT_CTX *BN_MONT_CTX_new(void)
{
  BIGNUM *v0;
  BIGNUM *v1;

  v0 = (BIGNUM *)OPENSSL_malloc(0x40uLL);
  v1 = v0;
  if (v0)
  {
    *(_OWORD *)&v0[1].top = 0u;
    *(_OWORD *)&v0[2].d = 0u;
    *(_OWORD *)&v0->d = 0u;
    *(_OWORD *)&v0->neg = 0u;
    BN_init(v0);
    BN_init(v1 + 1);
  }
  return (BN_MONT_CTX *)v1;
}

void BN_init(BIGNUM *a1)
{
  a1->d = 0;
  *(_QWORD *)&a1->top = 0;
  *(_QWORD *)&a1->neg = 0;
}

BOOL ec_GFp_simple_is_on_curve(_DWORD *a1, uint64_t a2)
{
  void (*v4)(_DWORD *, _OWORD *, uint64_t);
  void (*v5)(_DWORD *, _OWORD *, _OWORD *, _OWORD *);
  __int128 v6;
  __int128 v7;
  uint64_t *v8;
  int v9;
  _OWORD v11[4];
  unint64_t v12;
  _OWORD v13[4];
  unint64_t v14;
  _OWORD v15[4];
  unint64_t v16;
  _OWORD v17[4];
  unint64_t v18;

  v5 = *(void (**)(_DWORD *, _OWORD *, _OWORD *, _OWORD *))(*(_QWORD *)a1 + 112);
  v4 = *(void (**)(_DWORD *, _OWORD *, uint64_t))(*(_QWORD *)a1 + 120);
  v18 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[2] = v6;
  v17[3] = v6;
  v17[0] = v6;
  v17[1] = v6;
  v4(a1, v17, a2);
  v16 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v15[2] = v7;
  v15[3] = v7;
  v15[0] = v7;
  v15[1] = v7;
  v14 = 0xAAAAAAAAAAAAAAAALL;
  v13[2] = v7;
  v13[3] = v7;
  v13[0] = v7;
  v13[1] = v7;
  v12 = 0xAAAAAAAAAAAAAAAALL;
  v11[2] = v7;
  v11[3] = v7;
  v8 = (uint64_t *)(a2 + 144);
  v11[0] = v7;
  v11[1] = v7;
  v4(a1, v15, a2 + 144);
  v4(a1, v13, (uint64_t)v15);
  v5(a1, v11, v13, v15);
  if (a1[56])
  {
    ec_felem_add((uint64_t)a1, (unint64_t *)v15, (const unint64_t *)v13, (const unint64_t *)v13);
    ec_felem_add((uint64_t)a1, (unint64_t *)v15, (const unint64_t *)v15, (const unint64_t *)v13);
    ec_felem_sub((uint64_t)a1, (unint64_t *)v17, (const unint64_t *)v17, (const unint64_t *)v15);
  }
  else
  {
    v5(a1, v15, v13, (_OWORD *)a1 + 5);
    ec_felem_add((uint64_t)a1, (unint64_t *)v17, (const unint64_t *)v17, (const unint64_t *)v15);
  }
  v5(a1, v17, v17, (_OWORD *)a2);
  v5(a1, v15, a1 + 38, v11);
  ec_felem_add((uint64_t)a1, (unint64_t *)v17, (const unint64_t *)v17, (const unint64_t *)v15);
  v4(a1, v15, a2 + 72);
  ec_felem_sub((uint64_t)a1, (unint64_t *)v15, (const unint64_t *)v15, (const unint64_t *)v17);
  v9 = ec_felem_non_zero_mask((uint64_t)a1, (uint64_t *)v15);
  return (ec_felem_non_zero_mask((uint64_t)a1, v8) & v9 & 1) == 0;
}

int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
{
  int v10;
  int v11;
  int v12;
  int v13;
  BIGNUM *v14;
  int v15;
  uint64_t top;
  uint64_t v17;
  BIGNUM *v18;
  uint64_t v19;
  int v20;
  BIGNUM *v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  unint64_t *v26;
  unint64_t v27;
  int neg;
  unint64_t *v29;
  unint64_t *v30;
  unint64_t v31;
  int v32;
  unint64_t *v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  const unint64_t *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t i;
  BOOL v42;
  unsigned __int128 v43;
  int v45;
  BIGNUM *v46;
  int n;
  unint64_t v48;
  unint64_t *v49;
  int v50;
  unint64_t v51;
  int num[2];
  BIGNUM *v53;
  BIGNUM *v54;
  BIGNUM *r;

  v10 = bn_minimal_width((uint64_t)m);
  v11 = bn_minimal_width((uint64_t)d);
  if (v10 >= 1 && !m->d[v10 - 1] || v11 >= 1 && !d->d[v11 - 1])
  {
    v12 = 111;
    v13 = 212;
    goto LABEL_8;
  }
  if (!BN_is_zero((uint64_t)d))
  {
    BN_CTX_start(ctx);
    v54 = BN_CTX_get(ctx);
    v53 = BN_CTX_get(ctx);
    v14 = BN_CTX_get(ctx);
    if (!dv)
      dv = BN_CTX_get(ctx);
    r = v14;
    if (!v14)
      goto LABEL_47;
    if (!dv)
      goto LABEL_47;
    v15 = BN_num_bits(d) & 0x3F;
    if (!BN_lshift(r, d, 64 - v15))
      goto LABEL_47;
    bn_set_minimal_width((uint64_t)r);
    r->neg = 0;
    n = 128 - v15;
    if (!BN_lshift(v53, m, 128 - v15))
      goto LABEL_47;
    bn_set_minimal_width((uint64_t)v53);
    v53->neg = 0;
    top = v53->top;
    v17 = r->top;
    if ((int)top <= (int)v17 + 1)
    {
      if (!bn_wexpand(&v53->d, v17 + 2))
        goto LABEL_47;
      v18 = v53;
      v22 = v53->top;
      v21 = r;
      v23 = r->top;
      v20 = v23 + 2;
      v49 = v53->d;
      if ((int)v22 < v23 + 2)
        bzero(&v53->d[v22], 8 * (v23 - v22 + 1) + 8);
    }
    else
    {
      if (!bn_wexpand(&v53->d, top + 1))
        goto LABEL_47;
      v18 = v53;
      v19 = v53->top;
      v49 = v53->d;
      v53->d[v19] = 0;
      v20 = v19 + 1;
      v21 = r;
    }
    v18->top = v20;
    v24 = v21->top;
    v25 = v20 - v24;
    v26 = v21->d;
    *(_QWORD *)num = v24;
    if (v24 == 1)
      v27 = 0;
    else
      v27 = v26[v24 - 2];
    v51 = v26[v24 - 1];
    neg = m->neg;
    dv->neg = d->neg ^ neg;
    if (bn_wexpand(&dv->d, v25 + 1))
    {
      dv->top = v25 - 1;
      v29 = dv->d;
      if (bn_wexpand(&v54->d, *(_QWORD *)num + 1))
      {
        v30 = &v29[v25 - 1];
        v46 = rem;
        v45 = neg;
        if (dv->top)
          --v30;
        else
          dv->neg = 0;
        v31 = v51;
        if (v25 >= 2)
        {
          v32 = 0;
          v33 = &v49[v25];
          v34 = &v49[v20 - 1];
          v50 = v25 - 1;
          v48 = v27;
          do
          {
            if (*v34 == v31)
            {
              v35 = -1;
            }
            else
            {
              v38 = *(v34 - 1);
              v35 = __udivti3();
              v39 = v38 - v31 * v35;
              v40 = (v35 * (unsigned __int128)v27) >> 64;
              for (i = v35 * v27; __PAIR128__(v39, *(v34 - 2)) < __PAIR128__(v40, i); i = v43)
              {
                --v35;
                v42 = __CFADD__(v39, v31);
                v39 += v31;
                if (v42)
                  break;
                v43 = __PAIR128__(v40, i) - v27;
                v40 = *((_QWORD *)&v43 + 1);
              }
            }
            v36 = bn_mul_words(v54->d, r->d, num[0], v35);
            v37 = v54->d;
            v54->d[*(_QWORD *)num] = v36;
            --v33;
            if (bn_sub_words(v33, v33, v37, num[0] + 1))
            {
              --v35;
              if (bn_add_words(v33, v33, r->d, num[0]))
                ++*v34;
            }
            v27 = v48;
            v31 = v51;
            *v30-- = v35;
            ++v32;
            --v34;
          }
          while (v32 != v50);
        }
        bn_set_minimal_width((uint64_t)v53);
        if (!v46)
          goto LABEL_46;
        if (BN_rshift(v46, v53, n))
        {
          if (!BN_is_zero((uint64_t)v46))
            v46->neg = v45;
LABEL_46:
          bn_set_minimal_width((uint64_t)dv);
          BN_CTX_end(ctx);
          return 1;
        }
      }
    }
LABEL_47:
    BN_CTX_end(ctx);
    return 0;
  }
  v12 = 105;
  v13 = 217;
LABEL_8:
  ERR_put_error(3, 0, v12, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/div.c", v13);
  return 0;
}

uint64_t bn_set_minimal_width(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  BOOL v4;
  uint64_t v5;

  v1 = *(unsigned int *)(result + 8);
  v2 = 8 * v1 - 8;
  v3 = *(_DWORD *)(result + 8);
  while (1)
  {
    v4 = __OFSUB__(v3--, 1);
    if (v3 < 0 != v4)
      break;
    v5 = *(_QWORD *)(*(_QWORD *)result + v2);
    v2 -= 8;
    if (v5)
    {
      *(_DWORD *)(result + 8) = v3 + 1;
      return result;
    }
  }
  *(_DWORD *)(result + 8) = v1 & ((int)v1 >> 31);
  if ((v1 & 0x80000000) == 0)
    *(_DWORD *)(result + 16) = 0;
  return result;
}

BOOL BN_is_zero(uint64_t a1)
{
  return bn_fits_in_words(a1, 0);
}

BIGNUM *__cdecl BN_CTX_get(BN_CTX *ctx)
{
  char *v2;
  const STACK *v3;
  uint64_t v4;
  char *v5;

  if (!*((_BYTE *)ctx + 40))
  {
    v3 = *(const STACK **)ctx;
    if (*(_QWORD *)ctx || (v3 = sk_new_null(), (*(_QWORD *)ctx = v3) != 0))
    {
      v4 = *((_QWORD *)ctx + 4);
      if (v4 != sk_num(v3) || (v5 = (char *)BN_new()) != 0 && sk_push(*(STACK **)ctx, v5))
      {
        v2 = sk_value(*(const STACK **)ctx, *((_QWORD *)ctx + 4));
        BN_zero((uint64_t)v2);
        ++*((_QWORD *)ctx + 4);
        return (BIGNUM *)v2;
      }
      ERR_put_error(3, 0, 116, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/ctx.c", 172);
      BN_free((BIGNUM *)v5);
    }
    v2 = 0;
    *((_BYTE *)ctx + 40) = 1;
    return (BIGNUM *)v2;
  }
  if (!*((_BYTE *)ctx + 41))
    return 0;
  ERR_put_error(3, 0, 116, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/ctx.c", 155);
  v2 = 0;
  *((_BYTE *)ctx + 41) = 0;
  return (BIGNUM *)v2;
}

uint64_t BN_zero(uint64_t result)
{
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 8) = 0;
  return result;
}

uint64_t bn_minimal_width(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t i;
  BOOL v5;

  v2 = *(unsigned int *)(a1 + 8);
  result = v2 & ((int)v2 >> 31);
  for (i = 8 * v2 - 8; ; i -= 8)
  {
    v5 = __OFSUB__((_DWORD)v2, 1);
    LODWORD(v2) = v2 - 1;
    if ((int)v2 < 0 != v5)
      break;
    if (*(_QWORD *)(*(_QWORD *)a1 + i))
      return (v2 + 1);
  }
  return result;
}

int BN_lshift(BIGNUM *r, const BIGNUM *a, int n)
{
  unsigned int v6;
  unsigned int v7;
  int result;
  unint64_t *d;
  unint64_t *v10;
  unint64_t top;
  char v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t *v17;
  unint64_t v18;

  if (n < 0)
  {
    ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/shift.c", 73);
    return 0;
  }
  else
  {
    r->neg = a->neg;
    v6 = n >> 6;
    v7 = (n >> 6) + 1;
    result = bn_wexpand(&r->d, (int)(v7 + a->top));
    if (result)
    {
      d = a->d;
      v10 = r->d;
      top = a->top;
      r->d[(int)(top + v6)] = 0;
      v12 = n & 0x3F;
      if ((n & 0x3F) != 0)
      {
        if ((int)top >= 1)
        {
          v13 = d - 1;
          v14 = top;
          do
          {
            v15 = v13[v14];
            v10[(int)(v6 + v14)] |= v15 >> (64 - v12);
            v10[v6 - 1 + v14] = v15 << v12;
            v16 = v14-- > 1;
          }
          while (v16);
        }
      }
      else if ((int)top >= 1)
      {
        v17 = d - 1;
        v18 = top;
        do
        {
          v10[v6 - 1 + v18] = v17[v18];
          v16 = v18-- > 1;
        }
        while (v16);
      }
      if (n >= 0x40)
      {
        bzero(v10, 8 * v6);
        LODWORD(top) = a->top;
      }
      r->top = v7 + top;
      bn_set_minimal_width((uint64_t)r);
      return 1;
    }
  }
  return result;
}

uint64_t ec_point_set_affine_coordinates(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const unint64_t *v8;
  void (*v9)(uint64_t, _OWORD *, _OWORD *, uint64_t);
  void (*v10)(uint64_t, _OWORD *, uint64_t);
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _OWORD v28[4];
  unint64_t v29;
  _OWORD v30[4];
  unint64_t v31;

  v8 = (const unint64_t *)(a1 + 152);
  v9 = *(void (**)(uint64_t, _OWORD *, _OWORD *, uint64_t))(*(_QWORD *)a1 + 112);
  v10 = *(void (**)(uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 120);
  v31 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v30[2] = v11;
  v30[3] = v11;
  v30[0] = v11;
  v30[1] = v11;
  v29 = 0xAAAAAAAAAAAAAAAALL;
  v28[2] = v11;
  v28[3] = v11;
  v28[0] = v11;
  v28[1] = v11;
  v10(a1, v30, a4);
  v10(a1, v28, a3);
  ec_felem_add(a1, (unint64_t *)v28, (const unint64_t *)v28, (const unint64_t *)(a1 + 80));
  v9(a1, v28, v28, a3);
  ec_felem_add(a1, (unint64_t *)v28, (const unint64_t *)v28, v8);
  if (ec_felem_equal(a1, (char *)v30, (char *)v28))
  {
    *(_OWORD *)a2 = *(_OWORD *)a3;
    v12 = *(_OWORD *)(a3 + 16);
    v13 = *(_OWORD *)(a3 + 32);
    v14 = *(_OWORD *)(a3 + 48);
    *(_QWORD *)(a2 + 64) = *(_QWORD *)(a3 + 64);
    *(_OWORD *)(a2 + 32) = v13;
    *(_OWORD *)(a2 + 48) = v14;
    *(_OWORD *)(a2 + 16) = v12;
    v16 = *(_OWORD *)(a4 + 32);
    v15 = *(_OWORD *)(a4 + 48);
    v17 = *(_QWORD *)(a4 + 64);
    *(_OWORD *)(a2 + 88) = *(_OWORD *)(a4 + 16);
    *(_QWORD *)(a2 + 136) = v17;
    *(_OWORD *)(a2 + 120) = v15;
    *(_OWORD *)(a2 + 104) = v16;
    *(_OWORD *)(a2 + 72) = *(_OWORD *)a4;
    return 1;
  }
  else
  {
    ERR_put_error(15, 0, 120, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", 840);
    v19 = *(_QWORD *)(a1 + 8);
    if (v19)
    {
      if (!ec_felem_equal(a1, (char *)(a1 + 320), (char *)(v19 + 152)))
        ec_point_set_affine_coordinates_cold_1();
      result = 0;
      v20 = *(_QWORD *)(a1 + 8);
      *(_OWORD *)a2 = *(_OWORD *)(v20 + 8);
      v21 = *(_OWORD *)(v20 + 24);
      v22 = *(_OWORD *)(v20 + 40);
      v23 = *(_OWORD *)(v20 + 56);
      *(_QWORD *)(a2 + 64) = *(_QWORD *)(v20 + 72);
      *(_OWORD *)(a2 + 32) = v22;
      *(_OWORD *)(a2 + 48) = v23;
      *(_OWORD *)(a2 + 16) = v21;
      v24 = *(_QWORD *)(a1 + 8);
      *(_OWORD *)(a2 + 72) = *(_OWORD *)(v24 + 80);
      v25 = *(_OWORD *)(v24 + 96);
      v26 = *(_OWORD *)(v24 + 112);
      v27 = *(_OWORD *)(v24 + 128);
      *(_QWORD *)(a2 + 136) = *(_QWORD *)(v24 + 144);
      *(_OWORD *)(a2 + 120) = v27;
      *(_OWORD *)(a2 + 104) = v26;
      *(_OWORD *)(a2 + 88) = v25;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void bn_mod_mul_montgomery_small(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t a4, uint64_t a5)
{
  __int128 v10;
  uint64_t v11;
  _OWORD v12[9];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a4 > 9 || *(_DWORD *)(a5 + 32) != a4)
    goto LABEL_8;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[7] = v10;
  v12[8] = v10;
  v12[5] = v10;
  v12[6] = v10;
  v12[3] = v10;
  v12[4] = v10;
  v12[1] = v10;
  v12[2] = v10;
  v12[0] = v10;
  v11 = 2 * a4;
  if (a2 == a3)
    bn_sqr_small((unint64_t *)v12, v11, a2, a4);
  else
    bn_mul_small((unint64_t *)v12, v11, a2, a4, a3, a4);
  if (!bn_from_montgomery_in_place(a1, a4, (unint64_t *)v12, 2 * a4, a5))
LABEL_8:
    abort();
  OPENSSL_cleanse(v12, 16 * a4);
}

void bn_mul_small(unint64_t *a1, uint64_t a2, unint64_t *a3, unint64_t a4, unint64_t *a5, unint64_t a6)
{
  if (a6 + a4 != a2)
    abort();
  if (a4 == 8 && a6 == 8)
    bn_mul_comba8(a1, a3, a5);
  else
    bn_mul_normal(a1, a3, a4, a5, a6);
}

void bn_mul_normal(unint64_t *a1, unint64_t *a2, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  const unint64_t *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;

  if (a3 < a5)
    v6 = a5;
  else
    v6 = a3;
  if (a3 < a5)
    v7 = a2;
  else
    v7 = a4;
  if (a3 < a5)
    v8 = a3;
  else
    v8 = a5;
  if (a3 < a5)
    v9 = a4;
  else
    v9 = a2;
  if (v8)
  {
    a1[v6] = bn_mul_words(a1, v9, v6, *v7);
    if (v8 != 1)
    {
      v10 = 0;
      v11 = v7 + 2;
      v12 = 4 - v8;
      v13 = &a1[v6 + 4];
      do
      {
        v13[v10 - 3] = bn_mul_add_words(&a1[v10 + 1], v9, v6, v11[v10 - 1]);
        if (v12 == 2)
          break;
        v13[v10 - 2] = bn_mul_add_words(&a1[v10 + 2], v9, v6, v11[v10]);
        if (v12 == 1)
          break;
        v13[v10 - 1] = bn_mul_add_words(&a1[v10 + 3], v9, v6, v11[v10 + 1]);
        if (!v12)
          break;
        v13[v10] = bn_mul_add_words(&a1[v10 + 4], v9, v6, v11[v10 + 2]);
        v12 += 4;
        v10 += 4;
      }
      while (v12 != 3);
    }
  }
  else if (8 * v6)
  {
    bzero(a1, 8 * v6);
  }
}

uint64_t bn_from_montgomery_in_place(unint64_t *a1, unint64_t num, unint64_t *rp, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;

  v5 = *(int *)(a5 + 32);
  if (v5 == num && 2 * v5 == a4)
  {
    v11 = *(unint64_t **)(a5 + 24);
    v12 = 0;
    if ((_DWORD)v5)
    {
      v13 = *(_QWORD *)(a5 + 48);
      if (num <= 1)
        v14 = 1;
      else
        v14 = num;
      v15 = rp;
      do
      {
        v16 = bn_mul_add_words(v15, v11, num, *v15 * v13);
        v17 = v15[num];
        v18 = v16 + v12 + v17;
        v12 = (v12 | (v16 + v12 != 0)) & (unint64_t)(v18 <= v17);
        v15[num] = v18;
        ++v15;
        --v14;
      }
      while (v14);
    }
    bn_reduce_once(a1, &rp[num], v12, v11, num);
    return 1;
  }
  else
  {
    ERR_put_error(3, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/montgomery.c", 295);
    return 0;
  }
}

unint64_t bn_mul_add_words(unint64_t *rp, const unint64_t *ap, int num, unint64_t w)
{
  uint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  uint64_t v8;
  unsigned __int128 v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unsigned __int128 v32;

  if (!*(_QWORD *)&num)
    return 0;
  if (*(_QWORD *)&num < 4uLL)
  {
    v4 = 0;
    do
    {
LABEL_25:
      v27 = *ap++;
      v28 = (v27 * (unsigned __int128)w) >> 64;
      v29 = v27 * w;
      v6 = __CFADD__(*rp, v4);
      v30 = *rp + v4;
      v31 = v6;
      v32 = __PAIR128__(v31, v30) + __PAIR128__(v28, v29);
      v4 = (__PAIR128__(v31, v30) + __PAIR128__(v28, v29)) >> 64;
      *rp++ = v32;
      --*(_QWORD *)&num;
    }
    while (*(_QWORD *)&num);
    return v4;
  }
  v4 = 0;
  do
  {
    v5 = rp[1];
    v6 = __CFADD__(*rp, v4);
    v7 = *rp + v4;
    v8 = v6;
    v9 = __PAIR128__(v8, v7) + *ap * (unsigned __int128)w;
    *rp = v9;
    v10 = ap[1];
    v11 = (v10 * (unsigned __int128)w) >> 64;
    v12 = v10 * w;
    v6 = __CFADD__(v12, v5);
    v13 = v12 + v5;
    if (v6)
      ++v11;
    v6 = __CFADD__(v13, *((_QWORD *)&v9 + 1));
    v14 = v13 + *((_QWORD *)&v9 + 1);
    if (v6)
      v15 = v11 + 1;
    else
      v15 = v11;
    rp[1] = v14;
    v16 = ap[2];
    v17 = rp[2];
    v18 = rp[3];
    v6 = __CFADD__(v16 * w, v17);
    v19 = v16 * w + v17;
    v20 = (v16 * (unsigned __int128)w) >> 64;
    if (v6)
      ++v20;
    v6 = __CFADD__(v19, v15);
    v21 = v19 + v15;
    if (v6)
      ++v20;
    rp[2] = v21;
    v22 = ap[3];
    v23 = (v22 * (unsigned __int128)w) >> 64;
    v24 = v22 * w;
    v6 = __CFADD__(v24, v18);
    v25 = v24 + v18;
    if (v6)
      ++v23;
    v6 = __CFADD__(v25, v20);
    v26 = v25 + v20;
    if (v6)
      v4 = v23 + 1;
    else
      v4 = v23;
    rp[3] = v26;
    ap += 4;
    rp += 4;
    *(_QWORD *)&num -= 4;
  }
  while (*(_QWORD *)&num >= 4uLL);
  if (*(_QWORD *)&num)
    goto LABEL_25;
  return v4;
}

uint64_t bn_reduce_once(unint64_t *a1, unint64_t *a2, uint64_t a3, unint64_t *bp, uint64_t num)
{
  uint64_t v8;

  if (a1 == a2)
    bn_reduce_once_cold_1();
  v8 = a3 - bn_sub_words(a1, a2, bp, num);
  if (v8 && v8 != -1)
    bn_reduce_once_cold_2();
  bn_select_words((uint64_t *)a1, v8, (uint64_t *)a2, (uint64_t *)a1, num);
  return v8;
}

unint64_t bn_sub_words(unint64_t *rp, const unint64_t *ap, const unint64_t *bp, int num)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;

  if (!*(_QWORD *)&num)
    return 0;
  if (*(_QWORD *)&num < 4uLL)
  {
    v4 = 0;
    do
    {
LABEL_22:
      v16 = *ap++;
      v15 = v16;
      v17 = *bp++;
      v18 = v15 - (v4 + v17);
      v4 = v4 & (v15 == v17);
      if (v15 < v17)
        v4 = 1;
      *rp++ = v18;
      --*(_QWORD *)&num;
    }
    while (*(_QWORD *)&num);
    return v4;
  }
  v4 = 0;
  do
  {
    v5 = *ap - (v4 + *bp);
    v4 = v4 & (*ap == *bp);
    if (*ap < *bp)
      v4 = 1;
    *rp = v5;
    v6 = ap[1];
    v7 = bp[1];
    v8 = v6 - (v7 + v4);
    if (v6 != v7)
      v4 = 0;
    if (v6 < v7)
      v4 = 1;
    rp[1] = v8;
    v9 = ap[2];
    v10 = bp[2];
    v11 = v9 - (v10 + v4);
    if (v9 != v10)
      v4 = 0;
    if (v9 < v10)
      v4 = 1;
    rp[2] = v11;
    v12 = ap[3];
    v13 = bp[3];
    v14 = v12 - (v13 + v4);
    if (v12 != v13)
      v4 = 0;
    if (v12 < v13)
      v4 = 1;
    rp[3] = v14;
    ap += 4;
    bp += 4;
    rp += 4;
    *(_QWORD *)&num -= 4;
  }
  while (*(_QWORD *)&num >= 4uLL);
  if (*(_QWORD *)&num)
    goto LABEL_22;
  return v4;
}

uint64_t *bn_select_words(uint64_t *result, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  for (; a5; --a5)
  {
    v6 = *a3++;
    v5 = v6;
    v7 = *a4++;
    *result++ = ~a2 & v7 | a2 & v5;
  }
  return result;
}

unint64_t bn_mul_words(unint64_t *rp, const unint64_t *ap, int num, unint64_t w)
{
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;

  if (!*(_QWORD *)&num)
    return 0;
  if (*(_QWORD *)&num < 4uLL)
  {
    v4 = 0;
    do
    {
LABEL_20:
      v23 = *ap++;
      v24 = (v23 * (unsigned __int128)w) >> 64;
      v25 = v23 * w + v4;
      if (__CFADD__(v23 * w, v4))
        v4 = v24 + 1;
      else
        v4 = v24;
      *rp++ = v25;
      --*(_QWORD *)&num;
    }
    while (*(_QWORD *)&num);
    return v4;
  }
  v4 = 0;
  do
  {
    v5 = *ap * w;
    v6 = __CFADD__(v5, v4);
    v7 = v5 + v4;
    if (v6)
      v8 = ((*ap * (unsigned __int128)w) >> 64) + 1;
    else
      v8 = (*ap * (unsigned __int128)w) >> 64;
    *rp = v7;
    v9 = ap[1];
    v10 = (v9 * (unsigned __int128)w) >> 64;
    v11 = v9 * w;
    v6 = __CFADD__(v11, v8);
    v12 = v11 + v8;
    if (v6)
      v13 = v10 + 1;
    else
      v13 = v10;
    rp[1] = v12;
    v14 = ap[2];
    v15 = (v14 * (unsigned __int128)w) >> 64;
    v16 = v14 * w;
    v6 = __CFADD__(v16, v13);
    v17 = v16 + v13;
    if (v6)
      v18 = v15 + 1;
    else
      v18 = v15;
    rp[2] = v17;
    v19 = ap[3];
    v20 = (v19 * (unsigned __int128)w) >> 64;
    v21 = v19 * w;
    v6 = __CFADD__(v21, v18);
    v22 = v21 + v18;
    if (v6)
      v4 = v20 + 1;
    else
      v4 = v20;
    rp[3] = v22;
    ap += 4;
    rp += 4;
    *(_QWORD *)&num -= 4;
  }
  while (*(_QWORD *)&num >= 4uLL);
  if (*(_QWORD *)&num)
    goto LABEL_20;
  return v4;
}

void ec_GFp_mont_felem_sqr(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  bn_mod_mul_montgomery_small(a2, a3, a3, *(int *)(a1 + 64), *(_QWORD *)(a1 + 312));
}

void bn_sqr_small(unint64_t *a1, uint64_t a2, unint64_t *a3, unint64_t a4)
{
  __int128 v5;
  _OWORD v6[9];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a4 > 9 || 2 * a4 != a2)
    abort();
  if (a4 == 8)
  {
    bn_sqr_comba8(a1, a3);
  }
  else if (a4 == 4)
  {
    bn_sqr_comba4(a1, a3);
  }
  else
  {
    *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v6[7] = v5;
    v6[8] = v5;
    v6[5] = v5;
    v6[6] = v5;
    v6[3] = v5;
    v6[4] = v5;
    v6[1] = v5;
    v6[2] = v5;
    v6[0] = v5;
    bn_sqr_normal(a1, (uint64_t)a3, a4, (unint64_t *)v6);
    OPENSSL_cleanse(v6, 16 * a4);
  }
}

_QWORD *bn_sqr_comba4(_QWORD *result, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unsigned __int128 v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _BOOL8 v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;

  v2 = (*a2 * (unsigned __int128)*a2) >> 64;
  *result = *a2 * *a2;
  v3 = a2[1];
  v4 = (*a2 * (unsigned __int128)v3) >> 64;
  v5 = *a2 * v3;
  v6 = __CFADD__(v5, v2);
  v7 = v5 + v2;
  if (v6)
    v8 = v4 + 1;
  else
    v8 = v4;
  v6 = __CFADD__(v7, v5);
  v9 = v7 + v5;
  if (v6)
    v10 = v4 + 1;
  else
    v10 = v4;
  result[1] = v9;
  v12 = *a2;
  v11 = a2[1];
  v13 = (v11 * (unsigned __int128)v11) >> 64;
  v14 = v11 * v11;
  v6 = __CFADD__(v14, v10 + v8);
  v15 = v14 + v10 + v8;
  if (v6)
    v16 = v13 + 1;
  else
    v16 = v13;
  v6 = __CFADD__(__CFADD__(v10, v8), v16);
  v17 = __CFADD__(v10, v8) + v16;
  v18 = v6;
  v19 = a2[2];
  v20 = (v12 * (unsigned __int128)v19) >> 64;
  v21 = v12 * v19;
  v6 = __CFADD__(v15, v21);
  v22 = v15 + v21;
  if (v6)
    v23 = v20 + 1;
  else
    v23 = v20;
  v6 = __CFADD__(v17, v23);
  v24 = v17 + v23;
  v25 = v6;
  v6 = __CFADD__(v22, v21);
  v26 = v22 + v21;
  if (v6)
    v27 = v20 + 1;
  else
    v27 = v20;
  v6 = __CFADD__(v24, v27);
  v28 = v24 + v27;
  v29 = v18 + v6 + v25;
  result[2] = v26;
  v31 = a2[2];
  v30 = a2[3];
  v32 = a2[1];
  v33 = (*a2 * (unsigned __int128)v30) >> 64;
  v34 = *a2 * v30;
  v6 = __CFADD__(v34, v28);
  v35 = v34 + v28;
  if (v6)
    v36 = v33 + 1;
  else
    v36 = v33;
  v37 = v29 + v36;
  v6 = __CFADD__(v35, v34);
  v38 = v35 + v34;
  if (v6)
    v39 = v33 + 1;
  else
    v39 = v33;
  v6 = __CFADD__(v37, v39);
  v40 = v37 + v39;
  v41 = v6;
  if (__CFADD__(v29, v36))
    v42 = v41 + 1;
  else
    v42 = v41;
  v43 = (v32 * (unsigned __int128)v31) >> 64;
  v44 = v32 * v31;
  v6 = __CFADD__(v38, v44);
  v45 = v38 + v44;
  if (v6)
    v46 = v43 + 1;
  else
    v46 = v43;
  v6 = __CFADD__(v40, v46);
  v47 = v40 + v46;
  v48 = v6;
  v6 = __CFADD__(v45, v44);
  v49 = v45 + v44;
  if (v6)
    v50 = v43 + 1;
  else
    v50 = v43;
  v51 = __PAIR128__(v42, v47) + __PAIR128__(v48, v50);
  result[3] = v49;
  v52 = a2[1];
  v53 = a2[2] * a2[2] + v51;
  v54 = *((_QWORD *)&v51 + 1) + v51;
  v55 = __CFADD__(*((_QWORD *)&v51 + 1), (_QWORD)v51);
  v56 = a2[3];
  v57 = (v52 * (unsigned __int128)v56) >> 64;
  v58 = v52 * v56;
  v6 = __CFADD__(v53, v58);
  v59 = v53 + v58;
  if (v6)
    v60 = v57 + 1;
  else
    v60 = v57;
  v6 = __CFADD__(v54, v60);
  v61 = v54 + v60;
  v62 = v6;
  v6 = __CFADD__(v59, v58);
  v63 = v59 + v58;
  if (v6)
    v64 = v57 + 1;
  else
    v64 = v57;
  v6 = __CFADD__(v61, v64);
  v65 = v61 + v64;
  v66 = v55 + v6 + v62;
  result[4] = v63;
  v68 = a2[2];
  v67 = a2[3];
  v69 = (v68 * (unsigned __int128)v67) >> 64;
  v70 = v68 * v67;
  v6 = __CFADD__(v70, v65);
  v71 = v70 + v65;
  if (v6)
    v72 = v69 + 1;
  else
    v72 = v69;
  v73 = v66 + v72;
  v6 = __CFADD__(v71, v70);
  v74 = v71 + v70;
  if (v6)
    v75 = v69 + 1;
  else
    v75 = v69;
  v6 = __CFADD__(v73, v75);
  v76 = v73 + v75;
  v77 = v6;
  result[5] = v74;
  v78 = a2[3];
  v79 = (v78 * (unsigned __int128)v78) >> 64;
  v80 = v78 * v78;
  v6 = __CFADD__(v80, v76);
  v81 = v80 + v76;
  if (v6)
    v82 = v79 + 1;
  else
    v82 = v79;
  result[6] = v81;
  result[7] = v77 + __CFADD__(v66, v72) + v82;
  return result;
}

uint64_t ec_felem_add(uint64_t a1, unint64_t *a2, const unint64_t *a3, const unint64_t *a4)
{
  __int128 v4;
  _OWORD v6[4];
  unint64_t v7;

  v7 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6[2] = v4;
  v6[3] = v4;
  v6[0] = v4;
  v6[1] = v4;
  return bn_mod_add_words(a2, a3, a4, *(const unint64_t **)(a1 + 56), (unint64_t *)v6, *(int *)(a1 + 64));
}

uint64_t bn_reduce_once_in_place(unint64_t *ap, uint64_t a2, const unint64_t *a3, unint64_t *rp, uint64_t num)
{
  uint64_t v8;

  v8 = a2 - bn_sub_words(rp, ap, a3, num);
  if (v8 && v8 != -1)
    bn_reduce_once_in_place_cold_1();
  bn_select_words((uint64_t *)ap, v8, (uint64_t *)ap, (uint64_t *)rp, num);
  return v8;
}

uint64_t bn_mod_add_words(unint64_t *a1, const unint64_t *a2, const unint64_t *a3, const unint64_t *a4, unint64_t *a5, uint64_t num)
{
  unint64_t v10;

  v10 = bn_add_words(a1, a2, a3, num);
  return bn_reduce_once_in_place(a1, v10, a4, a5, num);
}

unint64_t bn_add_words(unint64_t *rp, const unint64_t *ap, const unint64_t *bp, int num)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t StatusReg;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  BOOL v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;

  if (!*(_QWORD *)&num)
    return 0;
  if (*(_QWORD *)&num < 4uLL)
  {
    v4 = 0;
    do
    {
LABEL_23:
      v27 = *ap++;
      v26 = v27;
      v29 = *bp++;
      v28 = v29;
      v16 = __CFADD__(v26, v4);
      v30 = v26 + v4;
      v31 = v16;
      v16 = __CFADD__(v30, v28);
      v32 = v30 + v28;
      if (v16)
        v4 = v31 + 1;
      else
        v4 = v31;
      *rp++ = v32;
      --*(_QWORD *)&num;
    }
    while (*(_QWORD *)&num);
    return v4;
  }
  v4 = 0;
  do
  {
    v5 = *bp;
    v16 = __CFADD__(*ap, v4);
    v6 = *ap + v4;
    v7 = v16;
    *rp = v6 + v5;
    v8 = ap[1];
    v9 = bp[1];
    v16 = __CFADD__(v9, v8);
    v10 = v9 + v8;
    v11 = v16;
    v12 = v7 + __CFADD__(v6, v5) + v10;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
    rp[1] = v12;
    v14 = ap[2];
    v15 = bp[2];
    v16 = __CFADD__(v15, v14);
    v17 = v15 + v14;
    v18 = v16;
    _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
    v19 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
    rp[2] = v11 + v16 + v17;
    v20 = ap[3];
    v21 = bp[3];
    v22 = __CFADD__(v21, v20);
    v23 = v21 + v20;
    v24 = v22;
    _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v19);
    v25 = v18 + v22 + v23;
    if (__CFADD__(v22, v23) | __CFADD__(v18, v22 + v23))
      v4 = v24 + 1;
    else
      v4 = v24;
    rp[3] = v25;
    ap += 4;
    bp += 4;
    rp += 4;
    *(_QWORD *)&num -= 4;
  }
  while (*(_QWORD *)&num >= 4uLL);
  if (*(_QWORD *)&num)
    goto LABEL_23;
  return v4;
}

void ec_GFp_mont_felem_mul(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  bn_mod_mul_montgomery_small(a2, a3, a4, *(int *)(a1 + 64), *(_QWORD *)(a1 + 312));
}

BOOL ec_felem_equal(uint64_t a1, char *a2, char *a3)
{
  return CRYPTO_memcmp(a2, a3, 8 * *(int *)(a1 + 64)) == 0;
}

void BN_CTX_start(BN_CTX *ctx)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v6;

  if (!*((_BYTE *)ctx + 40))
  {
    v2 = *((_QWORD *)ctx + 4);
    v3 = *((_QWORD *)ctx + 2);
    if (v3 != *((_QWORD *)ctx + 3))
    {
      v6 = (_QWORD *)*((_QWORD *)ctx + 1);
      goto LABEL_14;
    }
    if (v3)
      v4 = (3 * v3) >> 1;
    else
      v4 = 32;
    if (v4 > v3 && v4 >> 61 == 0)
    {
      v6 = OPENSSL_realloc(*((_QWORD **)ctx + 1), 8 * v4);
      if (v6)
      {
        *((_QWORD *)ctx + 1) = v6;
        *((_QWORD *)ctx + 3) = v4;
        v3 = *((_QWORD *)ctx + 2);
LABEL_14:
        v6[v3] = v2;
        ++*((_QWORD *)ctx + 2);
        return;
      }
    }
    *((_WORD *)ctx + 20) = 257;
  }
}

void BN_CTX_end(BN_CTX *ctx)
{
  uint64_t v1;
  uint64_t v2;

  if (!*((_BYTE *)ctx + 40))
  {
    v1 = *((_QWORD *)ctx + 2);
    if (!v1)
      BN_CTX_end_cold_1();
    v2 = v1 - 1;
    *((_QWORD *)ctx + 2) = v2;
    *((_QWORD *)ctx + 4) = *(_QWORD *)(*((_QWORD *)ctx + 1) + 8 * v2);
  }
}

uint64_t bn_mont_ctx_set_N_and_n0(uint64_t a1, const BIGNUM *a2)
{
  int v4;
  int v5;

  if (BN_is_zero((uint64_t)a2))
  {
    v4 = 105;
    v5 = 164;
LABEL_3:
    ERR_put_error(3, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/montgomery.c", v5);
    return 0;
  }
  if (!BN_is_odd((uint64_t)a2))
  {
    v4 = 104;
    v5 = 168;
    goto LABEL_3;
  }
  if (BN_is_negative((uint64_t)a2))
  {
    v4 = 109;
    v5 = 172;
    goto LABEL_3;
  }
  if (!bn_fits_in_words((uint64_t)a2, 0x400uLL))
  {
    v4 = 102;
    v5 = 176;
    goto LABEL_3;
  }
  if (!BN_copy((BIGNUM *)(a1 + 24), a2))
  {
    v4 = 68;
    v5 = 182;
    goto LABEL_3;
  }
  bn_set_minimal_width(a1 + 24);
  *(_QWORD *)(a1 + 48) = bn_mont_n0((unint64_t **)(a1 + 24));
  *(_QWORD *)(a1 + 56) = 0;
  return 1;
}

BOOL bn_fits_in_words(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;

  v2 = *(int *)(a1 + 8);
  v3 = v2 > a2;
  v4 = v2 - a2;
  if (!v3)
    return 1;
  v5 = 0;
  v6 = (uint64_t *)(*(_QWORD *)a1 + 8 * a2);
  do
  {
    v7 = *v6++;
    v5 |= v7;
    --v4;
  }
  while (v4);
  return v5 == 0;
}

uint64_t BN_is_odd(uint64_t a1)
{
  if (*(int *)(a1 + 8) < 1)
    return 0;
  else
    return **(_DWORD **)a1 & 1;
}

unint64_t bn_mont_n0(unint64_t **a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unint64_t result;

  if (BN_is_zero((uint64_t)a1))
    bn_mont_n0_cold_6();
  if (BN_is_negative((uint64_t)a1))
    bn_mont_n0_cold_5();
  if (!BN_is_odd((uint64_t)a1))
    bn_mont_n0_cold_1();
  v2 = **a1;
  if ((v2 & 1) == 0)
    bn_mont_n0_cold_2();
  v3 = 0;
  v4 = 64;
  v5 = 1;
  do
  {
    v6 = 1 << v4;
    if ((v4 & 0x40) != 0)
      v7 = 0;
    else
      v7 = 1 << v4;
    if ((v4 & 0x40) == 0)
      v6 = 0;
    if (v6 != v5 - (((v3 * (unsigned __int128)v2) >> 64) + (v3 * v2 != 0)) || v7 != -(uint64_t)(v3 * v2))
      bn_mont_n0_cold_4();
    v9 = -(v5 & 1);
    v5 = (v2 & v9 & v5) + ((v2 & v9 ^ v5) >> 1);
    result = v9 & 0x8000000000000000 | (v3 >> 1);
    v3 = result;
    --v4;
  }
  while (v4);
  if (-(uint64_t)(result * v2) ^ 1 | (unint64_t)(v5
                                                      - (((result * (unsigned __int128)v2) >> 64)
                                                       + (result * v2 != 0))))
    bn_mont_n0_cold_3();
  return result;
}

int BN_rshift(BIGNUM *r, const BIGNUM *a, int n)
{
  int result;

  if (n < 0)
  {
    ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/shift.c", 158);
    return 0;
  }
  else
  {
    result = bn_wexpand(&r->d, a->top);
    if (result)
    {
      bn_rshift_words((char *)r->d, (uint64_t)a->d, n, a->top);
      r->neg = a->neg;
      r->top = a->top;
      bn_set_minimal_width((uint64_t)r);
      return 1;
    }
  }
  return result;
}

void bn_rshift_words(char *__dst, uint64_t a2, unsigned int a3, unint64_t a4)
{
  char *v5;
  unint64_t v6;
  uint64_t v7;
  char v9;
  uint64_t v10;
  _QWORD *v11;
  char *v12;
  size_t v13;

  v5 = __dst;
  v6 = a3 >> 6;
  v7 = a4 - v6;
  if (a4 <= v6)
  {
    if (!a4)
      return;
    v13 = 8 * a4;
LABEL_14:
    bzero(__dst, v13);
    return;
  }
  v9 = a3 & 0x3F;
  if ((a3 & 0x3F) != 0)
  {
    if (a4 - 1 > v6)
    {
      v10 = ~v6 + a4;
      v11 = (_QWORD *)(a2 + 8 * v6 + 8);
      v12 = __dst;
      do
      {
        *(_QWORD *)v12 = (*v11 << (64 - v9)) | (*(v11 - 1) >> v9);
        v12 += 8;
        ++v11;
        --v10;
      }
      while (v10);
    }
    *(_QWORD *)&__dst[8 * (a4 - 1 - v6)] = *(_QWORD *)(a2 + 8 * (a4 - 1)) >> v9;
  }
  else if (8 * v7)
  {
    memmove(__dst, (const void *)(a2 + 8 * v6), 8 * v7);
  }
  if (a3 >= 0x40)
  {
    v13 = 8 * v6;
    __dst = &v5[8 * a4 + -8 * v6];
    goto LABEL_14;
  }
}

uint64_t *ec_felem_sub(uint64_t a1, unint64_t *a2, const unint64_t *a3, const unint64_t *a4)
{
  __int128 v4;
  _OWORD v6[4];
  unint64_t v7;

  v7 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6[2] = v4;
  v6[3] = v4;
  v6[0] = v4;
  v6[1] = v4;
  return bn_mod_sub_words(a2, a3, a4, *(const unint64_t **)(a1 + 56), (unint64_t *)v6, *(int *)(a1 + 64));
}

uint64_t *bn_mod_sub_words(unint64_t *a1, const unint64_t *a2, const unint64_t *a3, const unint64_t *a4, unint64_t *a5, uint64_t num)
{
  unint64_t v10;

  v10 = bn_sub_words(a1, a2, a3, num);
  bn_add_words(a5, a1, a4, num);
  return bn_select_words((uint64_t *)a1, -(uint64_t)v10, (uint64_t *)a5, (uint64_t *)a1, num);
}

const BIGNUM *BN_value_one(void)
{
  CRYPTO_once(&BN_value_one_once, (void (*)(void))BN_value_one_init);
  return (const BIGNUM *)&BN_value_one_storage;
}

int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  const BIGNUM *v3;
  int neg;
  const BIGNUM *v6;
  int v7;
  int result;
  int v9;

  v3 = b;
  neg = b->neg;
  if (a->neg)
  {
    if (neg)
    {
      v6 = a;
      goto LABEL_10;
    }
    v7 = 1;
LABEL_7:
    result = bn_uadd_consttime((uint64_t)r, (uint64_t)a, (uint64_t)b);
    if (!result)
      return result;
    goto LABEL_15;
  }
  if (neg)
  {
    v7 = 0;
    goto LABEL_7;
  }
  v6 = b;
  v3 = a;
LABEL_10:
  if (BN_ucmp(v3, v6) < 0)
  {
    result = bn_usub_consttime((uint64_t)r, (uint64_t)v6, (uint64_t)v3);
    if (!result)
      return result;
    v7 = 1;
    goto LABEL_15;
  }
  v9 = bn_usub_consttime((uint64_t)r, (uint64_t)v3, (uint64_t)v6);
  v7 = 0;
  result = 0;
  if (v9)
  {
LABEL_15:
    bn_set_minimal_width((uint64_t)r);
    r->neg = v7;
    return 1;
  }
  return result;
}

uint64_t bn_usub_consttime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  int v7;
  uint64_t result;
  unint64_t v9;
  int v10;
  unint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  int v15;

  v6 = *(_DWORD *)(a3 + 8);
  v7 = *(_DWORD *)(a2 + 8);
  if (v6 > v7)
  {
    if (!bn_fits_in_words(a3, v7))
    {
      v15 = 232;
      goto LABEL_11;
    }
    v7 = *(_DWORD *)(a2 + 8);
    v6 = v7;
  }
  result = bn_wexpand((_QWORD **)a1, v7);
  if (!(_DWORD)result)
    return result;
  v9 = bn_sub_words(*(unint64_t **)a1, *(const unint64_t **)a2, *(const unint64_t **)a3, v6);
  v10 = *(_DWORD *)(a2 + 8);
  if (v6 < v10)
  {
    v11 = (unint64_t *)(*(_QWORD *)a2 + 8 * v6);
    v12 = (_QWORD *)(*(_QWORD *)a1 + 8 * v6);
    v13 = v10 - (uint64_t)v6;
    do
    {
      v14 = *v11++;
      *v12++ = v14 - v9;
      v9 = v14 < v9;
      --v13;
    }
    while (v13);
  }
  if (v9)
  {
    v15 = 251;
LABEL_11:
    ERR_put_error(3, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/add.c", v15);
    return 0;
  }
  *(_DWORD *)(a1 + 8) = v10;
  *(_DWORD *)(a1 + 16) = 0;
  return 1;
}

int BN_ucmp(const BIGNUM *a, const BIGNUM *b)
{
  return bn_cmp_words_consttime((uint64_t *)a->d, a->top, (uint64_t *)b->d, b->top);
}

void BN_set_negative(BIGNUM *b, int n)
{
  _BOOL4 v3;

  v3 = n && !BN_is_zero((uint64_t)b);
  b->neg = v3;
}

int BN_add_word(BIGNUM *a, unint64_t w)
{
  unint64_t v2;
  uint64_t v5;
  uint64_t top;
  unint64_t v7;
  BOOL v8;

  if (w)
  {
    v2 = w;
    if (BN_is_zero((uint64_t)a))
      return BN_set_word(a, v2);
    if (a->neg)
    {
      a->neg = 0;
      LODWORD(v2) = BN_sub_word(a, v2);
      if (!BN_is_zero((uint64_t)a))
        a->neg = a->neg == 0;
      return v2;
    }
    v5 = 0;
    top = a->top;
    while ((top & ~((int)top >> 31)) != v5)
    {
      v7 = a->d[v5];
      v8 = __CFADD__(v7, v2);
      a->d[v5++] = v7 + v2;
      v2 = 1;
      if (!v8)
        return v2;
    }
    if ((top & 0x80000000) == 0)
    {
      if (!bn_wexpand(&a->d, top + 1))
      {
        LODWORD(v2) = 0;
        return v2;
      }
      ++a->top;
      a->d[top] = v2;
    }
  }
  LODWORD(v2) = 1;
  return v2;
}

void ec_group_set_generator_cold_3()
{
  __assert_rtn("ec_group_set_generator", "ec.c", 306, "group->generator == NULL");
}

void SSL_free(SSL *ssl)
{
  _QWORD *v1;

  if (ssl)
  {
    ssl_st::~ssl_st(ssl);
    OPENSSL_free(v1);
  }
}

void ssl_st::~ssl_st(ssl_st *this)
{
  CRYPTO_free_ex_data((int)&bssl::g_ex_data_class_ssl, this, (CRYPTO_EX_DATA *)&this->d1);
  std::unique_ptr<bssl::SSL_CONFIG,bssl::internal::Deleter>::reset[abi:ne180100]((STACK ***)&this->method, 0);
  if (*(_QWORD *)&this->version)
    (*(void (**)(ssl_st *))(*(_QWORD *)&this->version + 16))(this);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)&this->msg_callback_arg, 0);
  std::unique_ptr<ssl_ctx_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_CTX **)&this->s3, 0);
  std::unique_ptr<ssl_ctx_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_CTX **)&this->s2, 0);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)&this->packet, 0);
  std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100](&this->bbio, 0);
  std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100](&this->wbio, 0);
  std::unique_ptr<bssl::SSL_CONFIG,bssl::internal::Deleter>::reset[abi:ne180100]((STACK ***)&this->method, 0);
}

RSA *__cdecl RSA_new_method(ENGINE *engine)
{
  uint64_t *v1;
  uint64_t *v2;
  int v3;
  void *v4;
  CRYPTO_EX_DATA *v5;
  unsigned int (*v6)(uint64_t *);

  v1 = (uint64_t *)malloc_type_malloc(0x180uLL, 0x10B0040B1D60C94uLL);
  v2 = v1;
  if (v1)
  {
    *((_OWORD *)v1 + 22) = 0u;
    *((_OWORD *)v1 + 23) = 0u;
    *((_OWORD *)v1 + 20) = 0u;
    *((_OWORD *)v1 + 21) = 0u;
    *((_OWORD *)v1 + 18) = 0u;
    *((_OWORD *)v1 + 19) = 0u;
    *((_OWORD *)v1 + 16) = 0u;
    *((_OWORD *)v1 + 17) = 0u;
    *((_OWORD *)v1 + 14) = 0u;
    *((_OWORD *)v1 + 15) = 0u;
    *((_OWORD *)v1 + 12) = 0u;
    *((_OWORD *)v1 + 13) = 0u;
    *((_OWORD *)v1 + 10) = 0u;
    *((_OWORD *)v1 + 11) = 0u;
    *((_OWORD *)v1 + 8) = 0u;
    *((_OWORD *)v1 + 9) = 0u;
    *((_OWORD *)v1 + 6) = 0u;
    *((_OWORD *)v1 + 7) = 0u;
    *((_OWORD *)v1 + 4) = 0u;
    *((_OWORD *)v1 + 5) = 0u;
    *((_OWORD *)v1 + 2) = 0u;
    *((_OWORD *)v1 + 3) = 0u;
    *(_OWORD *)v1 = 0u;
    *((_OWORD *)v1 + 1) = 0u;
    CRYPTO_once(&RSA_default_method_once, (void (*)(void))RSA_default_method_init);
    *v2 = (uint64_t)&RSA_default_method_storage;
    METHOD_ref((uint64_t)&RSA_default_method_storage);
    v3 = *(_DWORD *)(*v2 + 72);
    *((_DWORD *)v2 + 20) = 1;
    *((_DWORD *)v2 + 21) = v3;
    CRYPTO_MUTEX_init((pthread_rwlock_t *)(v2 + 11));
    CRYPTO_new_ex_data((_DWORD)v2 + 72, v4, v5);
    v6 = *(unsigned int (**)(uint64_t *))(*v2 + 16);
    if (v6 && !v6(v2))
    {
      CRYPTO_MUTEX_cleanup((pthread_rwlock_t *)(v2 + 11));
      METHOD_unref(*v2);
      free(v2);
      return 0;
    }
  }
  else
  {
    ERR_put_error(4, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", 76);
  }
  return (RSA *)v2;
}

uint64_t bssl::tls13_process_certificate_verify_with_transcript(uint64_t a1, uint64_t a2, char a3, const void *a4, size_t a5)
{
  bssl *v9;
  bssl *v10;
  int v11;
  uint64_t v12;
  unsigned int v14;
  int v15;
  void *v16;
  size_t v17;
  unsigned __int8 v18;
  _BYTE v19[18];
  __int128 v20;

  if (!*(_QWORD *)(a1 + 1528))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 406);
    return 0;
  }
  v9 = *(bssl **)a1;
  v20 = *(_OWORD *)(a2 + 8);
  memset(v19, 170, sizeof(v19));
  if (CBS_get_u16((unsigned __int16 **)&v20, v19)
    && CBS_get_u16_length_prefixed((unsigned __int8 **)&v20, (unint64_t *)&v19[2])
    && !CBS_len((uint64_t)&v20))
  {
    v18 = 50;
    if (!bssl::tls12_check_peer_sigalg((bssl *)a1, (const bssl::SSL_HANDSHAKE *)&v18, (unsigned __int8 *)*(unsigned __int16 *)v19))
    {
      v11 = v18;
      v10 = v9;
      goto LABEL_6;
    }
    *(_WORD *)(*(_QWORD *)(a1 + 1536) + 8) = *(_WORD *)v19;
    v16 = 0;
    v17 = 0;
    if ((a3 & 1) != 0)
      v14 = 3;
    else
      v14 = *((_BYTE *)v9 + 180) & 1;
    if (bssl::tls13_get_cert_verify_signature_input(a1, (uint64_t)&v16, v14, a4, a5))
    {
      if (bssl::ssl_public_key_verify(v9, *(uint64_t *)&v19[2], *(uint64_t *)&v19[10], (evp_pkey_st *)*(unsigned __int16 *)v19, *(const ssl_st **)(a1 + 1528), v16, v17))
      {
        v12 = 1;
LABEL_21:
        OPENSSL_free(v16);
        return v12;
      }
      ERR_put_error(16, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 441);
      v15 = 51;
    }
    else
    {
      v15 = 80;
    }
    bssl::ssl_send_alert(v9, (ssl_st *)2, v15);
    v12 = 0;
    goto LABEL_21;
  }
  ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 415);
  v10 = v9;
  v11 = 50;
LABEL_6:
  bssl::ssl_send_alert(v10, (ssl_st *)2, v11);
  return 0;
}

void sub_1B4F95FA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_parse_serverhello_tlsext(uint64_t a1, __int128 *a2)
{
  bssl *v3;
  unsigned int v4;
  const char *v5;
  uint64_t v6;
  uint64_t (**v7)();
  int v8;
  uint64_t v9;
  uint64_t (**v10)();
  uint64_t v11;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  bssl *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  __int128 v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int8 v42;
  unint64_t v43[2];
  unsigned __int16 v44;
  __int128 v45;

  v3 = *(bssl **)a1;
  v45 = *a2;
  if (!bssl::tls1_check_duplicate_extensions(&v45))
    goto LABEL_20;
  v4 = 0;
  if (CBS_len((uint64_t)&v45))
  {
    v5 = "extension %u";
    while (2)
    {
      v44 = -21846;
      v43[0] = 0xAAAAAAAAAAAAAAAALL;
      v43[1] = 0xAAAAAAAAAAAAAAAALL;
      if (CBS_get_u16((unsigned __int16 **)&v45, &v44)
        && CBS_get_u16_length_prefixed((unsigned __int8 **)&v45, v43))
      {
        v6 = 0;
        v7 = off_1E686D1B8;
        while (*((unsigned __int16 *)v7 - 8) != v44)
        {
          ++v6;
          v7 += 5;
          if (v6 == 27)
          {
            v14 = 4126;
LABEL_21:
            ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v14);
            ERR_add_error_dataf(v5, v15, v16, v17, v18, v19, v20, v21, v44);
            v13 = 110;
            goto LABEL_22;
          }
        }
        v8 = 1 << v6;
        if ((*(_DWORD *)(a1 + 376) & (1 << v6)) == 0)
        {
          v14 = 4137;
          v5 = "extension :%u";
          goto LABEL_21;
        }
        v42 = 50;
        if ((((uint64_t (*)(uint64_t, unsigned __int8 *, unint64_t *))*v7)(a1, &v42, v43) & 1) == 0)
        {
          ERR_put_error(16, 0, 149, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4147);
          ERR_add_error_dataf("extension %u", v35, v36, v37, v38, v39, v40, v41, v44);
          v13 = v42;
          goto LABEL_22;
        }
        v4 |= v8;
        if (CBS_len((uint64_t)&v45))
          continue;
        goto LABEL_13;
      }
      break;
    }
LABEL_20:
    v13 = 50;
    goto LABEL_22;
  }
LABEL_13:
  v9 = 0;
  v10 = off_1E686D1B8;
  do
  {
    if (((v4 >> v9) & 1) == 0)
    {
      LOBYTE(v43[0]) = 50;
      if ((((uint64_t (*)(uint64_t, unint64_t *, _QWORD))*v10)(a1, v43, 0) & 1) == 0)
      {
        ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4160);
        ERR_add_error_dataf("extension %u", v23, v24, v25, v26, v27, v28, v29, *((_WORD *)v10 - 8));
        v13 = LOBYTE(v43[0]);
        goto LABEL_22;
      }
    }
    ++v9;
    v10 += 5;
  }
  while (v9 != 27);
  v11 = *(_QWORD *)(a1 + 1536);
  if (!v11 || (*(_BYTE *)(v11 + 448) & 0x40) == 0)
    return 1;
  v3 = *(bssl **)a1;
  v30 = *(_QWORD *)(*(_QWORD *)a1 + 48);
  v31 = *(unsigned __int8 **)(v30 + 504);
  if (!v31)
  {
    ERR_put_error(16, 0, 308, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4203);
    v22 = v3;
    v13 = 47;
    goto LABEL_23;
  }
  v45 = 0uLL;
  if ((bssl::ssl_get_local_application_settings(a1, (unsigned __int8 **)&v45, *(unsigned __int8 **)(v30 + 496), v31) & 1) != 0)
  {
    v32 = v45;
    v33 = bssl::Array<unsigned char>::Init(v11 + 416, *((unint64_t *)&v45 + 1));
    v34 = v33;
    if (*((_QWORD *)&v32 + 1))
    {
      if (v33)
        memcpy(*(void **)(v11 + 416), (const void *)v32, *((size_t *)&v32 + 1));
    }
    if (v34)
      return 1;
    v13 = 80;
  }
  else
  {
    ERR_put_error(16, 0, 259, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4212);
    v13 = 47;
  }
LABEL_22:
  v22 = v3;
LABEL_23:
  bssl::ssl_send_alert(v22, (ssl_st *)2, v13);
  return 0;
}

BOOL bssl::forbid_parse_serverhello(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  if (a3)
  {
    *a2 = 110;
    ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 556);
  }
  return a3 == 0;
}

uint64_t bssl::ext_quic_transport_params_parse_serverhello_impl(uint64_t a1, ssl_st *a2, uint64_t a3, int a4)
{
  bssl *v6;
  void **v8;
  const void *v9;
  unint64_t v10;
  uint64_t result;

  v6 = *(bssl **)a1;
  if (!a3)
  {
    if (((*(_WORD *)(*(_QWORD *)(a1 + 8) + 313) & 0x200) == 0) != a4 && *((_QWORD *)v6 + 21))
    {
      result = 0;
      LOBYTE(a2->version) = 109;
      return result;
    }
    return 1;
  }
  if (!*((_QWORD *)v6 + 21))
    bssl::ext_quic_transport_params_parse_serverhello_impl();
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) != 772)
    bssl::ext_quic_transport_params_parse_serverhello_impl();
  if (a4 != (unsigned __int16)(*(_WORD *)(*(_QWORD *)(a1 + 8) + 313) & 0x200) >> 9)
    bssl::ext_quic_transport_params_parse_serverhello_impl();
  v8 = (void **)(*((_QWORD *)v6 + 6) + 584);
  v9 = *(const void **)a3;
  v10 = *(_QWORD *)(a3 + 8);
  result = bssl::Array<unsigned char>::Init((uint64_t)v8, v10);
  if (v10 && (_DWORD)result)
  {
    memcpy(*v8, v9, v10);
    return 1;
  }
  return result;
}

BOOL bssl::ext_ocsp_parse_serverhello(uint64_t a1, const ssl_st *a2, uint64_t a3)
{
  const ssl_cipher_st *v5;
  _BOOL8 result;

  if (!a3)
    return 1;
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) > 0x303 || CBS_len(a3))
    return 0;
  result = bssl::ssl_cipher_uses_certificate_auth(*(bssl **)(a1 + 1568), v5);
  if (result)
  {
    *(_DWORD *)(a1 + 1600) |= 0x40u;
    return 1;
  }
  return result;
}

uint64_t bssl::ext_quic_transport_params_parse_serverhello_legacy(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  return bssl::ext_quic_transport_params_parse_serverhello_impl(a1, a2, a3, 1);
}

uint64_t bssl::ext_server_certificate_type_parse_serverhello(uint64_t a1, _BYTE *a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  int v8;
  unsigned __int8 v9;
  _QWORD v10[2];

  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    return 1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(v4 + 176);
  if (!v5)
    return 1;
  if (a3)
  {
    v10[0] = *(_QWORD *)(v4 + 168);
    v10[1] = v5;
    v9 = -86;
    if (CBS_get_u8(a3, &v9) && bssl::ssl_is_certificate_type_allowed(v10, v9))
    {
      *(_BYTE *)(a1 + 730) = v9;
      *(_DWORD *)(a1 + 1600) |= 0x400000u;
      return 1;
    }
    v8 = 3196;
  }
  else
  {
    v8 = 3179;
  }
  ERR_put_error(16, 0, 228, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v8);
  result = 0;
  *a2 = 47;
  return result;
}

uint64_t bssl::ext_client_certificate_type_parse_serverhello(uint64_t a1, _BYTE *a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  int v8;
  unsigned __int8 v9;
  _QWORD v10[2];

  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    return 1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(v4 + 208);
  if (!v5)
    return 1;
  if (a3)
  {
    v10[0] = *(_QWORD *)(v4 + 200);
    v10[1] = v5;
    v9 = -86;
    if (CBS_get_u8(a3, &v9) && bssl::ssl_is_certificate_type_allowed(v10, v9))
    {
      *(_BYTE *)(a1 + 731) = v9;
      *(_DWORD *)(a1 + 1600) |= 0x800000u;
      return 1;
    }
    v8 = 3317;
  }
  else
  {
    v8 = 3300;
  }
  ERR_put_error(16, 0, 228, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v8);
  result = 0;
  *a2 = 47;
  return result;
}

uint64_t bssl::ext_quic_transport_params_parse_serverhello(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  return bssl::ext_quic_transport_params_parse_serverhello_impl(a1, a2, a3, 0);
}

uint64_t bssl::ext_supported_groups_parse_serverhello()
{
  return 1;
}

BOOL bssl::ext_ticket_request_parse_serverhello(uint64_t a1, _BYTE *a2, _QWORD *a3)
{
  _BOOL8 result;
  uint64_t v6;
  int u8;
  char v8;

  if (!a3)
    return 1;
  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    return 1;
  v6 = *(_QWORD *)(a1 + 8);
  if (!*(_BYTE *)(v6 + 232) && !*(_BYTE *)(v6 + 233))
    return 1;
  v8 = -86;
  u8 = CBS_get_u8(a3, &v8);
  result = u8 != 0;
  if (u8)
    *(_BYTE *)(a1 + 734) = v8;
  else
    *a2 = 47;
  return result;
}

BOOL bssl::cert_compression_parse_serverhello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 == 0;
}

uint64_t bssl::ext_early_data_parse_serverhello(uint64_t *a1, _BYTE *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v6;
  __int16 v7;
  int v8;
  uint64_t v9;
  __int16 v10;

  v3 = *a1;
  if (a3)
  {
    if ((*(_WORD *)(*(_QWORD *)(v3 + 48) + 220) & 0x4000) != 0)
      bssl::ext_early_data_parse_serverhello();
    if (CBS_len(a3))
    {
      result = 0;
      *a2 = 50;
      return result;
    }
    v9 = *(_QWORD *)(v3 + 48);
    v10 = *(_WORD *)(v9 + 220);
    if ((v10 & 0x40) == 0)
    {
      *a2 = 110;
      ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2249);
      return 0;
    }
    *(_DWORD *)(v9 + 256) = 2;
    *(_WORD *)(v9 + 220) = v10 | 0x800;
  }
  else
  {
    v6 = *(_QWORD *)(v3 + 48);
    if ((*((_BYTE *)a1 + 1601) & 0x10) == 0 || (v7 = *(_WORD *)(v6 + 220), (v7 & 0x4000) != 0))
    {
      if (!*(_DWORD *)(v6 + 256))
        bssl::ext_early_data_parse_serverhello();
    }
    else
    {
      if ((v7 & 0x40) != 0)
        v8 = 4;
      else
        v8 = 6;
      *(_DWORD *)(v6 + 256) = v8;
    }
  }
  return 1;
}

uint64_t bssl::ext_channel_id_parse_serverhello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    if (SSL_is_dtls(*(unsigned __int8 ***)a1))
      bssl::ext_channel_id_parse_serverhello();
    if (!*(_QWORD *)(*(_QWORD *)(a1 + 8) + 120))
      bssl::ext_channel_id_parse_serverhello();
    if (CBS_len(a3))
      return 0;
    *(_DWORD *)(a1 + 1600) |= 0x4000000u;
  }
  return 1;
}

uint64_t bssl::ext_ec_point_parse_serverhello(bssl **a1, ssl_st *a2, unsigned __int8 **a3)
{
  uint64_t result;
  void *v6;
  size_t v7;
  unint64_t v8[2];

  if (!a3)
    return 1;
  if (bssl::ssl_protocol_version(*a1, a2) > 0x303)
    return 0;
  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  result = CBS_get_u8_length_prefixed(a3, v8);
  if (!(_DWORD)result)
    return result;
  if (CBS_len((uint64_t)a3))
    return 0;
  v6 = (void *)CBS_data((uint64_t)v8);
  v7 = CBS_len((uint64_t)v8);
  if (v7 && memchr(v6, 0, v7))
    return 1;
  result = 0;
  LOBYTE(a2->version) = 47;
  return result;
}

uint64_t bssl::ext_ticket_parse_serverhello(uint64_t a1, const ssl_st *a2, uint64_t a3)
{
  bssl *v5;

  if (a3)
  {
    v5 = *(bssl **)a1;
    if (bssl::ssl_protocol_version(*(bssl **)a1, a2) > 0x303)
      return 0;
    if ((SSL_get_options((uint64_t)v5) & 0x4000) != 0)
      bssl::ext_ticket_parse_serverhello();
    if (CBS_len(a3))
      return 0;
    *(_DWORD *)(a1 + 1600) |= 0x10000u;
  }
  return 1;
}

uint64_t bssl::ext_srtp_parse_serverhello(unsigned __int8 ***a1, _BYTE *a2, unsigned __int8 **a3)
{
  unsigned __int8 **v5;
  uint64_t result;
  int v7;
  int v8;
  const STACK *srtp_profiles;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  unsigned __int16 v14;
  unint64_t v15[4];

  if (a3)
  {
    v5 = *a1;
    if (!SSL_is_dtls(*a1))
      bssl::ext_srtp_parse_serverhello();
    memset(v15, 170, sizeof(v15));
    v14 = -21846;
    if (!CBS_get_u16_length_prefixed(a3, &v15[2])
      || !CBS_get_u16((unsigned __int16 **)&v15[2], &v14)
      || CBS_len((uint64_t)&v15[2])
      || !CBS_get_u8_length_prefixed(a3, v15)
      || CBS_len((uint64_t)a3))
    {
      ERR_put_error(16, 0, 116, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1786);
      return 0;
    }
    if (CBS_len((uint64_t)v15))
    {
      v7 = 115;
      v8 = 1792;
LABEL_16:
      ERR_put_error(16, 0, v7, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v8);
      result = 0;
      *a2 = 47;
      return result;
    }
    srtp_profiles = (const STACK *)SSL_get_srtp_profiles((uint64_t)v5);
    v10 = sk_num(srtp_profiles);
    if (!v10)
    {
LABEL_15:
      v7 = 116;
      v8 = 1805;
      goto LABEL_16;
    }
    v11 = v10;
    v12 = 0;
    while (1)
    {
      v13 = sk_value(srtp_profiles, v12);
      if (*((_QWORD *)v13 + 1) == v14)
        break;
      if (v11 == ++v12)
        goto LABEL_15;
    }
    *((_QWORD *)v5[6] + 75) = v13;
  }
  return 1;
}

uint64_t bssl::ext_alps_parse_serverhello(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  bssl *v4;
  uint64_t v5;
  uint64_t result;
  void **v9;
  unint64_t v10;
  const void *v11;
  int v12;
  char v13;

  if (!a3)
    return 1;
  v4 = *(bssl **)a1;
  if ((*(_WORD *)(*((_QWORD *)v4 + 6) + 220) & 0x20) != 0)
    bssl::ext_alps_parse_serverhello();
  v5 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v5 + 136))
    bssl::ext_alps_parse_serverhello();
  if (!*(_QWORD *)(v5 + 144))
    bssl::ext_alps_parse_serverhello();
  if (bssl::ssl_protocol_version(v4, a2) <= 0x303)
  {
    LOBYTE(a2->version) = 110;
    ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 3029);
    return 0;
  }
  v9 = (void **)(*(_QWORD *)(a1 + 1536) + 432);
  v11 = *(const void **)a3;
  v10 = *(_QWORD *)(a3 + 8);
  v12 = bssl::Array<unsigned char>::Init((uint64_t)v9, v10);
  v13 = v12;
  if (v10)
  {
    if (v12)
      memcpy(*v9, v11, v10);
  }
  if ((v13 & 1) != 0)
  {
    *(_BYTE *)(*(_QWORD *)(a1 + 1536) + 448) |= 0x40u;
    return 1;
  }
  result = 0;
  LOBYTE(a2->version) = 80;
  return result;
}

uint64_t bssl::ext_alpn_parse_serverhello(uint64_t *a1, char *a2, unsigned __int8 **a3)
{
  uint64_t v4;
  uint64_t result;
  void **v8;
  const void *v9;
  size_t v10;
  int v11;
  char v12;
  char v13;
  unint64_t v14[4];

  v4 = *a1;
  if (!a3)
  {
    if (*(_QWORD *)(v4 + 168))
    {
      ERR_put_error(16, 0, 307, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1462);
      result = 0;
      v13 = 120;
LABEL_18:
      *a2 = v13;
      return result;
    }
    return 1;
  }
  if ((*(_WORD *)(*(_QWORD *)(v4 + 48) + 220) & 0x20) != 0)
    bssl::ext_alpn_parse_serverhello();
  if (!*(_QWORD *)(a1[1] + 136))
    bssl::ext_alpn_parse_serverhello();
  if ((*((_BYTE *)a1 + 1601) & 0x80) != 0)
  {
    *a2 = 47;
    ERR_put_error(16, 0, 170, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1475);
    return 0;
  }
  memset(v14, 170, sizeof(v14));
  result = CBS_get_u16_length_prefixed(a3, &v14[2]);
  if (!(_DWORD)result)
    return result;
  if (CBS_len((uint64_t)a3))
    return 0;
  result = CBS_get_u8_length_prefixed((unsigned __int8 **)&v14[2], v14);
  if ((_DWORD)result)
  {
    result = CBS_len((uint64_t)v14);
    if (result)
    {
      if (!CBS_len((uint64_t)&v14[2]))
      {
        if ((bssl::ssl_is_alpn_protocol_allowed(a1, (unsigned __int8 *)v14[0], v14[1]) & 1) == 0)
        {
          ERR_put_error(16, 0, 259, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1492);
          v13 = 47;
          goto LABEL_24;
        }
        v8 = (void **)(*(_QWORD *)(v4 + 48) + 496);
        v9 = (const void *)v14[0];
        v10 = v14[1];
        v11 = bssl::Array<unsigned char>::Init((uint64_t)v8, v14[1]);
        v12 = v11;
        if (v10)
        {
          if (v11)
            memcpy(*v8, v9, v10);
        }
        if ((v12 & 1) == 0)
        {
          v13 = 80;
LABEL_24:
          result = 0;
          goto LABEL_18;
        }
        return 1;
      }
      return 0;
    }
  }
  return result;
}

BOOL bssl::ext_sni_parse_serverhello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return !a3 || CBS_len(a3) == 0;
}

uint64_t bssl::ext_sct_parse_serverhello(uint64_t a1, ssl_st *a2, __int128 *a3)
{
  bssl *v6;
  unsigned int **v7;
  unsigned int *v8;
  uint64_t result;
  char v10;

  if (!a3)
    return 1;
  v6 = *(bssl **)a1;
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) > 0x303)
    goto LABEL_8;
  if ((*(_WORD *)(*(_QWORD *)(a1 + 8) + 313) & 2) == 0)
    bssl::ext_sct_parse_serverhello();
  if (bssl::ssl_is_sct_list_valid(a3))
  {
    if ((*(_WORD *)(*((_QWORD *)v6 + 6) + 220) & 0x40) != 0)
      return 1;
    v7 = (unsigned int **)(*(_QWORD *)(a1 + 1536) + 256);
    v8 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)a3, *(_QWORD ***)(*((_QWORD *)v6 + 15) + 792));
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](v7, v8);
    if (*(_QWORD *)(*(_QWORD *)(a1 + 1536) + 256))
      return 1;
    v10 = 80;
  }
  else
  {
LABEL_8:
    v10 = 50;
  }
  result = 0;
  LOBYTE(a2->version) = v10;
  return result;
}

uint64_t bssl::ext_npn_parse_serverhello(uint64_t a1, ssl_st *a2, unsigned __int8 **a3)
{
  bssl *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  void **v10;
  const void *v11;
  size_t v12;
  int v13;
  char v14;
  unsigned __int8 v15;
  unint64_t v16[2];

  if (a3)
  {
    v6 = *(bssl **)a1;
    if (bssl::ssl_protocol_version(*(bssl **)a1, a2) > 0x303)
      return 0;
    if ((*(_WORD *)(*((_QWORD *)v6 + 6) + 220) & 0x20) != 0)
      bssl::ext_npn_parse_serverhello();
    if (SSL_is_dtls((unsigned __int8 **)v6))
      bssl::ext_npn_parse_serverhello();
    if (!*(_QWORD *)(*((_QWORD *)v6 + 15) + 592))
      bssl::ext_npn_parse_serverhello();
    if (*(_QWORD *)(*((_QWORD *)v6 + 6) + 504))
    {
      LOBYTE(a2->version) = 47;
      ERR_put_error(16, 0, 170, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1246);
      return 0;
    }
    v8 = CBS_data((uint64_t)a3);
    v9 = CBS_len((uint64_t)a3);
    while (CBS_len((uint64_t)a3))
    {
      v16[0] = 0xAAAAAAAAAAAAAAAALL;
      v16[1] = 0xAAAAAAAAAAAAAAAALL;
      if (!CBS_get_u8_length_prefixed(a3, v16) || !CBS_len((uint64_t)v16))
        return 0;
    }
    v16[0] = 0xAAAAAAAAAAAAAAAALL;
    v15 = -86;
    if ((*(unsigned int (**)(bssl *, unint64_t *, unsigned __int8 *, uint64_t, uint64_t, _QWORD))(*((_QWORD *)v6 + 15) + 592))(v6, v16, &v15, v8, v9, *(_QWORD *)(*((_QWORD *)v6 + 15) + 600)))
    {
      goto LABEL_21;
    }
    v10 = (void **)(*((_QWORD *)v6 + 6) + 480);
    v11 = (const void *)v16[0];
    v12 = v15;
    v13 = bssl::Array<unsigned char>::Init((uint64_t)v10, v15);
    v14 = v13;
    if (v12)
    {
      if (v13)
        memcpy(*v10, v11, v12);
    }
    if ((v14 & 1) == 0)
    {
LABEL_21:
      result = 0;
      LOBYTE(a2->version) = 80;
      return result;
    }
    *(_DWORD *)(a1 + 1600) |= 0x8000u;
  }
  return 1;
}

uint64_t bssl::ext_ems_parse_serverhello(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  bssl *v5;
  uint64_t result;
  uint64_t v8;

  v5 = *(bssl **)a1;
  if (a3)
  {
    if (bssl::ssl_protocol_version(*(bssl **)a1, a2) > 0x303 || CBS_len(a3))
      return 0;
    *(_DWORD *)(a1 + 1600) |= 0x20000u;
  }
  v8 = *(_QWORD *)(*((_QWORD *)v5 + 6) + 472);
  if (!v8 || ((*(_DWORD *)(a1 + 1600) >> 17) & 1) == (*(_BYTE *)(v8 + 448) & 1))
    return 1;
  ERR_put_error(16, 0, 263, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 955);
  result = 0;
  LOBYTE(a2->version) = 47;
  return result;
}

uint64_t bssl::ext_ech_parse_serverhello(bssl **a1, ssl_st *a2, unsigned __int8 **a3)
{
  bssl *v6;
  uint64_t result;
  void **v8;
  unint64_t v9;
  unsigned __int8 *v10;
  int v11;
  char v12;
  char v13;

  if (!a3)
    return 1;
  v6 = *a1;
  if (bssl::ssl_protocol_version(*a1, a2) < 0x304 || *(_DWORD *)(*((_QWORD *)v6 + 6) + 216) == 1)
  {
    LOBYTE(a2->version) = 110;
    ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 681);
    return 0;
  }
  if (bssl::ssl_is_valid_ech_config_list(*a3, a3[1]))
  {
    if (*(_DWORD *)(*((_QWORD *)v6 + 6) + 216) != 2)
      return 1;
    v8 = (void **)(a1 + 73);
    v10 = *a3;
    v9 = (unint64_t)a3[1];
    v11 = bssl::Array<unsigned char>::Init((uint64_t)v8, v9);
    v12 = v11;
    if (v9)
    {
      if (v11)
        memcpy(*v8, v10, v9);
    }
    if ((v12 & 1) != 0)
      return 1;
    result = 0;
    v13 = 80;
  }
  else
  {
    result = 0;
    v13 = 50;
  }
  LOBYTE(a2->version) = v13;
  return result;
}

uint64_t bssl::ext_ri_parse_serverhello(bssl **a1, ssl_st *a2, unsigned __int8 **a3)
{
  bssl *v5;
  uint64_t v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  BOOL v12;
  unsigned int v13;
  uint64_t result;
  char v15;
  char *v16;
  int v17;
  unint64_t v18[2];

  v5 = *a1;
  if (a3 && bssl::ssl_protocol_version(*a1, a2) >= 0x304)
    goto LABEL_21;
  v6 = *((_QWORD *)v5 + 6);
  v7 = *(_WORD *)(v6 + 220);
  if ((v7 & 0x20) != 0 && (a3 != 0) == ((v7 & 0x100) == 0))
  {
    LOBYTE(a2->version) = 40;
    ERR_put_error(16, 0, 202, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 793);
    return 0;
  }
  else
  {
    if (a3)
    {
      v8 = *(unsigned __int8 *)(v6 + 455);
      v9 = *(unsigned __int8 *)(v6 + 456);
      v10 = v9 + v8;
      if ((_DWORD)v8)
        v11 = 1;
      else
        v11 = v10 == 0;
      if (!v11)
        bssl::ext_ri_parse_serverhello();
      if ((_DWORD)v9)
        v12 = 1;
      else
        v12 = v10 == 0;
      if (!v12)
        bssl::ext_ri_parse_serverhello();
      v13 = v7 & 0x20;
      if (((_DWORD)v8 != 0) != v13 >> 5)
        bssl::ext_ri_parse_serverhello();
      if (((_DWORD)v9 != 0) != v13 >> 5)
        bssl::ext_ri_parse_serverhello();
      v18[0] = 0xAAAAAAAAAAAAAAAALL;
      v18[1] = 0xAAAAAAAAAAAAAAAALL;
      if (!CBS_get_u8_length_prefixed(a3, v18) || CBS_len((uint64_t)a3))
      {
        ERR_put_error(16, 0, 201, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 823);
LABEL_21:
        result = 0;
        v15 = 47;
LABEL_22:
        LOBYTE(a2->version) = v15;
        return result;
      }
      if (CBS_len((uint64_t)v18) != v10)
      {
        v17 = 830;
        goto LABEL_28;
      }
      v16 = (char *)CBS_data((uint64_t)v18);
      if (CRYPTO_memcmp(v16, (char *)(*((_QWORD *)v5 + 6) + 443), *(unsigned __int8 *)(*((_QWORD *)v5 + 6) + 455)))
      {
        v17 = 842;
LABEL_28:
        ERR_put_error(16, 0, 202, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v17);
        result = 0;
        v15 = 40;
        goto LABEL_22;
      }
      if (CRYPTO_memcmp(&v16[*(unsigned __int8 *)(*((_QWORD *)v5 + 6) + 455)], (char *)(*((_QWORD *)v5 + 6) + 457), *(unsigned __int8 *)(*((_QWORD *)v5 + 6) + 456)))
      {
        v17 = 854;
        goto LABEL_28;
      }
      *(_WORD *)(*((_QWORD *)v5 + 6) + 220) |= 0x100u;
    }
    return 1;
  }
}

uint64_t bssl::ssl_is_alpn_protocol_allowed(_QWORD *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t result;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned __int8 *i;
  uint64_t v11;
  unsigned __int8 *v12;
  unint64_t v13;
  unsigned __int8 *v14[2];

  v3 = a1[1];
  v4 = *(unsigned __int8 **)(v3 + 136);
  if (!v4)
    return 0;
  if ((*(_WORD *)(*(_QWORD *)(*a1 + 120) + 840) & 0x80) != 0)
    return 1;
  v14[0] = *(unsigned __int8 **)(v3 + 128);
  v14[1] = v4;
  v12 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  v13 = 0xAAAAAAAAAAAAAAAALL;
  for (result = CBS_len((uint64_t)v14); result; result = CBS_len((uint64_t)v14))
  {
    result = CBS_get_u8_length_prefixed(v14, (unint64_t *)&v12);
    if (!(_DWORD)result)
      break;
    if (v13 == a3)
    {
      if (!a3)
        return 1;
      v8 = v12;
      v9 = a3 - 1;
      for (i = a2; ; ++i)
      {
        v11 = v9;
        if (*v8 != *i)
          break;
        ++v8;
        --v9;
        if (!v11)
          return 1;
      }
    }
  }
  return result;
}

uint64_t bssl::tls1_check_duplicate_extensions(__int128 *a1)
{
  unint64_t v2;
  _BOOL8 v3;
  uint64_t v4;
  size_t v5;
  int v6;
  uint64_t v8;
  unint64_t v9;
  int v10;
  BOOL v11;
  unint64_t v12[2];
  void *v13;
  size_t v14;
  __int128 v15;

  v2 = 0;
  v15 = *a1;
  while (CBS_len((uint64_t)&v15))
  {
    LOWORD(v12[0]) = -21846;
    v13 = (void *)0xAAAAAAAAAAAAAAAALL;
    v14 = 0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_u16((unsigned __int16 **)&v15, v12))
    {
      ++v2;
      if (CBS_get_u16_length_prefixed((unsigned __int8 **)&v15, (unint64_t *)&v13))
        continue;
    }
    return 0;
  }
  if (v2)
  {
    v13 = 0;
    v14 = 0;
    if ((bssl::Array<unsigned short>::Init((uint64_t)&v13, v2) & 1) != 0)
    {
      v15 = *a1;
      if (v14)
      {
        v4 = 0;
        v5 = 0;
        while (1)
        {
          v12[0] = 0xAAAAAAAAAAAAAAAALL;
          v12[1] = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_u16((unsigned __int16 **)&v15, (char *)v13 + v4)
            || !CBS_get_u16_length_prefixed((unsigned __int8 **)&v15, v12))
          {
            break;
          }
          ++v5;
          v4 += 2;
          if (v5 >= v14)
            goto LABEL_13;
        }
      }
      else
      {
LABEL_13:
        if (CBS_len((uint64_t)&v15))
          __assert_rtn("tls1_check_duplicate_extensions", "extensions.cc", 193, "CBS_len(&extensions) == 0");
        qsort(v13, v14, 2uLL, (int (__cdecl *)(const void *, const void *))bssl::compare_uint16_t);
        if (v2 < 2)
        {
          v3 = 1;
LABEL_19:
          OPENSSL_free(v13);
          return v3;
        }
        v6 = *((unsigned __int16 *)v13 + 1);
        if (*(unsigned __int16 *)v13 != v6)
        {
          v8 = 2;
          do
          {
            v9 = v8;
            if (v2 == v8)
              break;
            v10 = *((unsigned __int16 *)v13 + v8++);
            v11 = v6 == v10;
            v6 = *((unsigned __int16 *)v13 + v9);
          }
          while (!v11);
          v3 = v9 >= v2;
          goto LABEL_19;
        }
      }
    }
    v3 = 0;
    goto LABEL_19;
  }
  return 1;
}

void sub_1B4F975DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t CBS_get_u16_length_prefixed(unsigned __int8 **a1, unint64_t *a2)
{
  return cbs_get_length_prefixed(a1, a2, 2uLL);
}

uint64_t nw_protocol_boringssl_connect(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(void);
  uint64_t v8;
  uint64_t v9;
  void (*v10)(void);
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  int server_mode;
  void *v18;
  uint64_t v19;
  uint64_t (*v20)(void);

  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 40);
    if (v2)
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_connect_cold_4();
      }
      if (*(_QWORD *)(v2 + 336) && (*(_BYTE *)(v2 + 390) & 1) == 0)
      {
        (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(v1 + 48) + 24) + 112))();
        v3 = objc_claimAutoreleasedReturnValue();
        if (!v3)
        {
          if ((*(_BYTE *)(v2 + 475) & 1) == 0 && g_boringssl_log)
          {
            result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
            if (!(_DWORD)result)
              return result;
            nw_protocol_boringssl_connect_cold_1();
          }
          return 0;
        }
        v4 = (void *)v3;
        v5 = *(_QWORD *)(v1 + 32);
        if (v5)
        {
          v6 = *(_QWORD *)(v5 + 24);
          if (v6)
          {
            v7 = *(void (**)(void))(v6 + 248);
            if (v7)
              v7();
          }
        }
        if (nw_parameters_get_server_mode())
        {
          v8 = *(_QWORD *)(v1 + 48);
          if (v8)
          {
            v9 = *(_QWORD *)(v8 + 24);
            if (v9)
            {
              v10 = *(void (**)(void))(v9 + 128);
              if (v10)
              {
                v10();
                v11 = (void *)objc_claimAutoreleasedReturnValue();
                v12 = (void *)nw_parameters_copy_context();
                v13 = (void *)nw_context_copy_registered_endpoint();

                v14 = nw_endpoint_copy_association();
                v15 = *(void **)(v2 + 328);
                *(_QWORD *)(v2 + 328) = v14;

              }
            }
          }
        }
        v16 = *(_QWORD *)(v2 + 336);
        server_mode = nw_parameters_get_server_mode();
        if ((boringssl_context_ssl_context_create(v16, server_mode) & 1) == 0)
        {
          if ((*(_BYTE *)(v2 + 475) & 1) == 0
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            nw_protocol_boringssl_connect_cold_2();
          }

          return 0;
        }
        v18 = (void *)nw_parameters_copy_protocol_options_legacy();
        if (v18)
          nw_protocol_options_get_log_id_str();
        *(_BYTE *)(v2 + 390) |= 1u;

      }
      result = *(_QWORD *)(v1 + 32);
      if (!result)
        return result;
      v19 = *(_QWORD *)(result + 24);
      if (v19)
      {
        v20 = *(uint64_t (**)(void))(v19 + 24);
        if (v20)
          return v20();
      }
    }
    return 0;
  }
  return result;
}

uint64_t boringssl_context_ssl_context_create(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  id WeakRetained;
  id *v6;
  id v7;
  SSL_METHOD *v8;
  uint64_t v9;
  char v10;

  v2 = a1;
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367 && (v3 = *(_QWORD *)(a1 + 8)) != 0)
    {
      WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));

      if (WeakRetained)
      {
        v6 = (id *)objc_loadWeakRetained((id *)(v3 + 16));
        v7 = v6[41];

      }
      else
      {
        v7 = 0;
      }
      v8 = (SSL_METHOD *)TLS_with_buffers_method();
      v9 = boringssl_context_restore_ssl_context((void *)v3, v7, v8);
      *(_QWORD *)(v3 + 408) = v9;
      if (a2)
        v10 = 16;
      else
        v10 = 0;
      *(_BYTE *)(v3 + 556) = *(_BYTE *)(v3 + 556) & 0xCF | v10;
      if (v9)
        v2 = boringssl_context_configure_defaults(v2);
      else
        v2 = 0;

    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t boringssl_context_restore_ssl_context(void *a1, void *a2, SSL_METHOD *a3)
{
  uint64_t v3;
  unint64_t v4;
  id *v7;
  id v8;
  id v9;
  void *cached_content_for_protocol;
  id WeakRetained;
  _BYTE *v12;
  id v13;
  _BYTE *v14;
  int v15;
  NSObject *v16;
  void *v17;
  id v18;
  id v19;
  uint64_t v20;
  uint64_t *v21;
  id v22;
  _BYTE *v23;
  _BOOL4 v24;
  id v25;
  _BYTE *v26;
  _BOOL4 v27;
  NSObject *v29;
  id v30;
  void *v31;
  id v32;
  SSL_CTX *v33;
  uint64_t v34;
  id v35;
  boringssl_concrete_boringssl_context_state *v36;
  void *v37;
  void *v38;
  id v39;
  id v40;
  uint64_t v41;
  id *v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  void *v53;
  __int16 v54;
  id v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a2;
  v44 = 0;
  v45 = &v44;
  v46 = 0x2020000000;
  v47 = 0;
  if (v8)
  {
    v9 = nw_protocol_boringssl_copy_definition();
    cached_content_for_protocol = (void *)nw_association_get_cached_content_for_protocol();

    if (cached_content_for_protocol)
    {
      WeakRetained = objc_loadWeakRetained(v7 + 2);
      v3 = (uint64_t)&OBJC_IVAR___boringssl_concrete_nw_protocol_boringssl_logging_disabled;
      if (!WeakRetained
        || (v12 = objc_loadWeakRetained(v7 + 2),
            v4 = (v12[475] & 1) == 0,
            v12,
            WeakRetained,
            (_DWORD)v4))
      {
        v13 = objc_loadWeakRetained(v7 + 2);
        if (v13)
        {
          v14 = objc_loadWeakRetained(v7 + 2);
          v3 = (v14[475] & 1) == 0;

        }
        else
        {
          v3 = 1;
        }

        v15 = g_boringssl_log ? v3 : 0;
        if (v15 == 1)
        {
          v16 = (id)g_boringssl_log;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
          {
            v3 = (uint64_t)objc_loadWeakRetained(v7 + 2);
            if (v3)
            {
              v4 = (unint64_t)objc_loadWeakRetained(v7 + 2);
              v17 = (void *)(v4 + 391);
            }
            else
            {
              v17 = &unk_1B50022E3;
            }
            v18 = objc_loadWeakRetained(v7 + 2);
            *(_DWORD *)buf = 136446978;
            v49 = "boringssl_context_restore_ssl_context";
            v50 = 1024;
            v51 = 2611;
            v52 = 2082;
            v53 = v17;
            v54 = 2048;
            v55 = v18;
            _os_log_impl(&dword_1B4F6D000, v16, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Reusing context", buf, 0x26u);

            if (v3)
          }

        }
      }
      v19 = cached_content_for_protocol;
      v43 = v7;
      sec_array_apply();

    }
  }
  v20 = v45[3];
  if (v20)
  {
    SSL_CTX_up_ref(v20);
    v21 = v45;
    if (!v8)
      goto LABEL_49;
    goto LABEL_42;
  }
  v22 = objc_loadWeakRetained(v7 + 2);
  if (!v22
    || (v23 = objc_loadWeakRetained(v7 + 2), v24 = (v23[475] & 1) == 0, v23, v22, v24))
  {
    v25 = objc_loadWeakRetained(v7 + 2);
    if (v25)
    {
      v26 = objc_loadWeakRetained(v7 + 2);
      v27 = (v26[475] & 1) == 0;

    }
    else
    {
      v27 = 1;
    }

    if (g_boringssl_log && v27)
    {
      v29 = (id)g_boringssl_log;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
      {
        v30 = objc_loadWeakRetained(v7 + 2);
        if (v30)
        {
          v3 = (uint64_t)objc_loadWeakRetained(v7 + 2);
          v31 = (void *)(v3 + 391);
        }
        else
        {
          v31 = &unk_1B50022E3;
        }
        v32 = objc_loadWeakRetained(v7 + 2);
        *(_DWORD *)buf = 136446978;
        v49 = "boringssl_context_restore_ssl_context";
        v50 = 1024;
        v51 = 2627;
        v52 = 2082;
        v53 = v31;
        v54 = 2048;
        v55 = v32;
        _os_log_impl(&dword_1B4F6D000, v29, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] New context", buf, 0x26u);

        if (v30)
      }

    }
  }
  v33 = SSL_CTX_new(a3);
  v21 = v45;
  v45[3] = (uint64_t)v33;
  if (v8)
  {
LABEL_42:
    v34 = v21[3];
    v35 = v8;
    if (v34)
    {
      v36 = boringssl_context_state_create(v34);
      if (v36)
      {
        v37 = (void *)sec_array_create();
        v38 = v37;
        if (v37)
        {
          v39 = v37;
          sec_array_append();
          v40 = nw_protocol_boringssl_copy_definition();
          time(0);
          nw_association_set_cached_content_for_protocol();

        }
      }

    }
    v21 = v45;
  }
LABEL_49:
  v41 = v21[3];
  _Block_object_dispose(&v44, 8);

  return v41;
}

void sub_1B4F97E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t boringssl_context_configure_defaults(uint64_t a1)
{
  uint64_t v1;
  SSL_CTX *v2;
  int v3;

  if (*(_DWORD *)a1 != -1252936367)
    return 0;
  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
    return 0;
  SSL_CTX_set_allow_unknown_alpn_protos(*(_QWORD *)(v1 + 408), 1);
  SSL_CTX_set_info_callback(*(SSL_CTX **)(v1 + 408), (void (__cdecl *)(const SSL *, int, int))boringssl_context_info_handler);
  SSL_CTX_set_session_cache_mode(*(_QWORD *)(v1 + 408), 3);
  v2 = *(SSL_CTX **)(v1 + 408);
  if ((*(_BYTE *)(v1 + 556) & 0x10) != 0)
  {
    v3 = 0;
  }
  else
  {
    SSL_CTX_sess_set_new_cb(v2, (int (__cdecl *)(ssl_st *, SSL_SESSION *))boringssl_context_new_session_handler);
    v2 = *(SSL_CTX **)(v1 + 408);
    v3 = 3;
  }
  SSL_CTX_set_custom_verify((uint64_t)v2, v3, (uint64_t)boringssl_context_certificate_verify_callback);
  return 1;
}

void *TLS_with_buffers_method()
{
  return &TLS_with_buffers_method::kMethod;
}

uint64_t SSL_CTX_set_session_cache_mode(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = *(unsigned int *)(a1 + 292);
  *(_DWORD *)(a1 + 292) = a2;
  return v2;
}

void SSL_CTX_set_info_callback(SSL_CTX *ctx, void (__cdecl *cb)(const SSL *, int, int))
{
  ctx->param = (X509_VERIFY_PARAM *)cb;
}

uint64_t SSL_CTX_set_custom_verify(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)(result + 456) = a2;
  *(_QWORD *)(result + 352) = a3;
  return result;
}

uint64_t SSL_CTX_set_allow_unknown_alpn_protos(uint64_t result, int a2)
{
  *(_WORD *)(result + 840) = *(_WORD *)(result + 840) & 0xFF7F | ((a2 != 0) << 7);
  return result;
}

void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx, int (__cdecl *new_session_cb)(ssl_st *, SSL_SESSION *))
{
  ctx->cert = (cert_st *)new_session_cb;
}

void bssl::ssl_cert_dup(bssl *this@<X0>, bssl::CERT **a2@<X8>)
{
  _QWORD *v5;
  bssl::CERT *v6;
  uint64_t v7;
  STACK *v8;
  unint64_t *v9;
  EVP_PKEY *v10;
  const void *v11;
  uint64_t v12;
  void **v13;
  bssl::CERT *v14;
  unsigned int *v15;
  bssl::CERT *v16;
  unsigned int *v17;
  __int128 v18;
  bssl::DC *v19;
  EVP_PKEY *v20;
  uint64_t v21;
  bssl::CERT *v22;

  v5 = OPENSSL_malloc(0xB0uLL);
  if (!v5)
  {
    v16 = 0;
LABEL_20:
    v22 = 0;
    goto LABEL_21;
  }
  v6 = (bssl::CERT *)v5;
  v7 = *((_QWORD *)this + 6);
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *(_OWORD *)v5 = 0u;
  v5[6] = v7;
  *(_OWORD *)(v5 + 7) = 0u;
  *(_OWORD *)(v5 + 9) = 0u;
  *(_OWORD *)(v5 + 11) = 0u;
  *(_OWORD *)(v5 + 13) = 0u;
  *(_OWORD *)(v5 + 15) = 0u;
  *(_OWORD *)((char *)v5 + 129) = 0u;
  v5[20] = 0;
  v5[21] = 0;
  v5[19] = 0;
  v22 = (bssl::CERT *)v5;
  v8 = (STACK *)*((_QWORD *)this + 1);
  if (!v8
    || (v9 = (unint64_t *)sk_deep_copy(v8, (uint64_t (*)(uint64_t))sk_CRYPTO_BUFFER_call_copy_func, (uint64_t)bssl::buffer_up_ref, (void (*)(uint64_t))sk_CRYPTO_BUFFER_call_free_func, (uint64_t)CRYPTO_BUFFER_free), std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)v6 + 1, v9), v6 = v22, *((_QWORD *)v22 + 1)))
  {
    v10 = *(EVP_PKEY **)this;
    if (*(_QWORD *)this)
    {
      EVP_PKEY_up_ref(*(unsigned int **)this);
      v6 = v22;
    }
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)v6, v10);
    *((_QWORD *)v6 + 5) = *((_QWORD *)this + 5);
    v11 = (const void *)*((_QWORD *)this + 7);
    v12 = *((_QWORD *)this + 8);
    v13 = (void **)((char *)v6 + 56);
    if (bssl::Array<unsigned short>::Init((uint64_t)v13, v12))
    {
      if (2 * v12)
        memcpy(*v13, v11, 2 * v12);
      v14 = v22;
      *(_OWORD *)((char *)v22 + 72) = *(_OWORD *)((char *)this + 72);
      (*(void (**)(void))(*((_QWORD *)v14 + 6) + 24))();
      v15 = (unsigned int *)*((_QWORD *)this + 12);
      if (v15)
        CRYPTO_BUFFER_up_ref(*((_QWORD *)this + 12));
      v16 = v22;
      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)v22 + 12, v15);
      v17 = (unsigned int *)*((_QWORD *)this + 13);
      if (v17)
      {
        CRYPTO_BUFFER_up_ref(*((_QWORD *)this + 13));
        v16 = v22;
      }
      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)v16 + 13, v17);
      *((_BYTE *)v16 + 112) = *((_BYTE *)this + 112);
      v18 = *(_OWORD *)((char *)this + 113);
      *(_OWORD *)((char *)v16 + 129) = *(_OWORD *)((char *)this + 129);
      *(_OWORD *)((char *)v16 + 113) = v18;
      v19 = (bssl::DC *)*((_QWORD *)this + 19);
      if (!v19
        || (bssl::DC::Dup(v19, &v21),
            v16 = v22,
            std::unique_ptr<bssl::DC,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)v22 + 19, v21),
            *((_QWORD *)v16 + 19)))
      {
        v20 = (EVP_PKEY *)*((_QWORD *)this + 20);
        if (v20)
        {
          EVP_PKEY_up_ref(*((unsigned int **)this + 20));
          v16 = v22;
        }
        std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)v16 + 20, v20);
        *((_QWORD *)v16 + 21) = *((_QWORD *)this + 21);
        goto LABEL_20;
      }
    }
  }
  v16 = 0;
LABEL_21:
  *a2 = v16;
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100](&v22, 0);
}

void sub_1B4F98144(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)va, 0);
  _Unwind_Resume(a1);
}

SSL *__cdecl SSL_new(SSL_CTX *ctx)
{
  ssl_st *v1;
  STACK **v2;
  SSL_METHOD *method;
  ssl2_state_st *v4;
  bssl::CERT *v5;
  int (__cdecl **p_ssl_accept)(SSL *);
  ssl_st *v7;
  SSL_METHOD *v8;
  ssl2_state_st *v9;
  unsigned __int8 *rbuf;
  uint64_t wbuf;
  void **p_ssl_read_bytes;
  const void *v13;
  unint64_t v14;
  void **p_ssl_ctrl;
  int v16;
  char v17;
  unsigned __int8 *msg_callback;
  uint64_t msg_callback_arg;
  void **p_ssl_connect;
  ssl_st *v21;
  ssl2_state_st *v22;
  const char *session_cache_size;
  SSL_METHOD *v24;
  _QWORD *v25;
  EVP_PKEY *write_ptr;
  EVP_PKEY **p_ssl_dispatch_alert;
  ssl2_state_st *v28;
  ssl_st *v29;
  const void *v30;
  unint64_t v31;
  void **p_num_ciphers;
  int v33;
  int (__cdecl *app_verify_callback)(X509_STORE_CTX *, void *);
  unint64_t app_verify_arg;
  void **p_get_ssl_method;
  int v37;
  pem_password_cb *default_passwd_callback;
  unint64_t default_passwd_callback_userdata;
  void **p_ssl3_enc;
  int v41;
  int (__cdecl *client_cert_cb)(SSL *, X509 **, EVP_PKEY **);
  unint64_t app_gen_cookie_cb;
  void **p_ssl_callback_ctrl;
  int v45;
  ssl_st *v46;
  SSL *v47;
  ssl_st *v49;
  STACK **v50;
  ssl_st *v51;
  SSL_CTX *v52;

  v52 = ctx;
  if (!ctx)
  {
    ERR_put_error(16, 0, 185, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 624);
    return 0;
  }
  bssl::New<ssl_st,ssl_ctx_st *&>((ssl2_state_st **)&v52);
  v51 = v1;
  if (!v1)
    goto LABEL_40;
  v49 = v1;
  bssl::New<bssl::SSL_CONFIG,ssl_st *>(&v49);
  v50 = 0;
  std::unique_ptr<bssl::SSL_CONFIG,bssl::internal::Deleter>::reset[abi:ne180100]((STACK ***)&v51->method, v2);
  std::unique_ptr<bssl::SSL_CONFIG,bssl::internal::Deleter>::reset[abi:ne180100](&v50, 0);
  method = v51->method;
  if (!method)
    goto LABEL_40;
  v4 = (ssl2_state_st *)v52;
  LODWORD(method->ssl_new) = v52->ex_data.dummy;
  bssl::ssl_cert_dup(*(bssl **)&v4[1].ract_data_length, (bssl::CERT **)&v50);
  v5 = (bssl::CERT *)v50;
  p_ssl_accept = &v51->method->ssl_accept;
  v50 = 0;
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)p_ssl_accept, v5);
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)&v50, 0);
  v7 = v51;
  v8 = v51->method;
  if (!v8->ssl_accept)
    goto LABEL_40;
  v9 = (ssl2_state_st *)v52;
  LOBYTE(v8[1].ssl_renegotiate) = *(_DWORD *)&v52->tlsext_tick_hmac_key[8];
  v8->ssl_connect = (int (__cdecl *)(SSL *))v9[1].mac_data;
  v7->method->ssl_read = *(int (__cdecl **)(SSL *, void *, int))&v9[1].escape;
  *(_WORD *)((char *)&v7->method[1].ssl_renegotiate + 1) = *(_WORD *)((_BYTE *)&v7->method[1].ssl_renegotiate + 1) & 0xFFDF | (32 * (*(_WORD *)&v9[2].challenge[4] & 1));
  *(_WORD *)((char *)&v7->method[1].ssl_renegotiate + 1) = *(_WORD *)((_BYTE *)&v7->method[1].ssl_renegotiate + 1) & 0xFBFF | (16 * *(_WORD *)&v9[2].challenge[4]) & 0x400;
  *(_WORD *)((char *)&v7->method[1].ssl_renegotiate + 1) = *(_WORD *)((_BYTE *)&v7->method[1].ssl_renegotiate + 1) & 0xF7FF | *(_WORD *)&v9[2].challenge[4] & 0x800;
  rbuf = v9[2].rbuf;
  wbuf = (uint64_t)v9[2].wbuf;
  p_ssl_read_bytes = (void **)&v7->method->ssl_read_bytes;
  if (!bssl::Array<unsigned short>::Init((uint64_t)p_ssl_read_bytes, wbuf))
    goto LABEL_40;
  if (2 * wbuf)
    memcpy(*p_ssl_read_bytes, rbuf, 2 * wbuf);
  v13 = *(const void **)&v52[1].stats.sess_accept_renegotiate;
  v14 = *(_QWORD *)&v52[1].stats.sess_miss;
  p_ssl_ctrl = (void **)&v51->method->ssl_ctrl;
  v16 = bssl::Array<unsigned char>::Init((uint64_t)p_ssl_ctrl, v14);
  v17 = v16 ^ 1;
  if (!v14)
    v17 = 1;
  if ((v17 & 1) == 0)
    memcpy(*p_ssl_ctrl, v13, v14);
  if (!v16)
    goto LABEL_40;
  msg_callback = (unsigned __int8 *)v52[1].msg_callback;
  msg_callback_arg = (uint64_t)v52[1].msg_callback_arg;
  p_ssl_connect = (void **)&v51->method[1].ssl_connect;
  if (!bssl::Array<unsigned short>::Init((uint64_t)p_ssl_connect, msg_callback_arg))
    goto LABEL_40;
  if (2 * msg_callback_arg)
    memcpy(*p_ssl_connect, msg_callback, 2 * msg_callback_arg);
  v21 = v51;
  v22 = (ssl2_state_st *)v52;
  session_cache_size = (const char *)v52[1].session_cache_size;
  v24 = v51->method;
  if (session_cache_size)
  {
    v25 = OPENSSL_strdup(session_cache_size);
    std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)&v24->ssl_peek, v25);
    v21 = v51;
    v24 = v51->method;
    if (!v24->ssl_peek)
    {
LABEL_40:
      v47 = 0;
      goto LABEL_41;
    }
    v22 = (ssl2_state_st *)v52;
  }
  v24->ssl_write = *(int (__cdecl **)(SSL *, const void *, int))&v22[1].key_material[4];
  v21->method->ssl_shutdown = *(int (__cdecl **)(SSL *))&v22[1].key_material[12];
  v21->method->ssl_renegotiate = *(int (__cdecl **)(SSL *))&v22[1].key_material[20];
  *(_WORD *)((char *)&v21->method[1].ssl_renegotiate + 1) = *(_WORD *)((_BYTE *)&v21->method[1].ssl_renegotiate + 1) & 0xFFF7 | (*(_WORD *)&v22[2].challenge[4] >> 1) & 8;
  write_ptr = (EVP_PKEY *)v22[2].write_ptr;
  if (write_ptr)
  {
    EVP_PKEY_up_ref((unsigned int *)v22[2].write_ptr);
    v21 = v51;
  }
  p_ssl_dispatch_alert = (EVP_PKEY **)&v21->method->ssl_dispatch_alert;
  v50 = 0;
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](p_ssl_dispatch_alert, write_ptr);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)&v50, 0);
  v29 = v51;
  v28 = (ssl2_state_st *)v52;
  *(_WORD *)((char *)&v51->method[1].ssl_renegotiate + 1) = *(_WORD *)((_BYTE *)&v51->method[1].ssl_renegotiate + 1) & 0xFFFD | (LOWORD(v52[1].verify_mode) >> 2) & 2;
  *(_WORD *)((char *)&v29->method[1].ssl_renegotiate + 1) = *(_WORD *)((_BYTE *)&v29->method[1].ssl_renegotiate + 1) & 0xFFFB | *(_WORD *)&v28[2].challenge[4] & 4;
  *(_WORD *)((char *)&v29->method[1].ssl_renegotiate + 1) = *(_WORD *)((_BYTE *)&v29->method[1].ssl_renegotiate + 1) & 0xFFBF | (*(_WORD *)&v28[2].challenge[4] >> 3) & 0x40;
  *(_QWORD *)&v29->hit = *(_QWORD *)&v28->key_material[20];
  v30 = *(const void **)v28[1].tmp.ccl;
  v31 = *(_QWORD *)&v28[1].tmp.ccl[8];
  p_num_ciphers = (void **)&v29->method->num_ciphers;
  v33 = bssl::Array<unsigned char>::Init((uint64_t)p_num_ciphers, v31) ^ 1;
  if (!v31)
    LOBYTE(v33) = 1;
  if ((v33 & 1) == 0)
    memcpy(*p_num_ciphers, v30, v31);
  app_verify_callback = v52[1].app_verify_callback;
  app_verify_arg = (unint64_t)v52[1].app_verify_arg;
  p_get_ssl_method = (void **)&v51->method->get_ssl_method;
  v37 = bssl::Array<unsigned char>::Init((uint64_t)p_get_ssl_method, app_verify_arg) ^ 1;
  if (!app_verify_arg)
    LOBYTE(v37) = 1;
  if ((v37 & 1) == 0)
    memcpy(*p_get_ssl_method, app_verify_callback, app_verify_arg);
  default_passwd_callback = v52[1].default_passwd_callback;
  default_passwd_callback_userdata = (unint64_t)v52[1].default_passwd_callback_userdata;
  p_ssl3_enc = (void **)&v51->method->ssl3_enc;
  v41 = bssl::Array<unsigned char>::Init((uint64_t)p_ssl3_enc, default_passwd_callback_userdata) ^ 1;
  if (!default_passwd_callback_userdata)
    LOBYTE(v41) = 1;
  if ((v41 & 1) == 0)
    memcpy(*p_ssl3_enc, default_passwd_callback, default_passwd_callback_userdata);
  client_cert_cb = v52[1].client_cert_cb;
  app_gen_cookie_cb = (unint64_t)v52[1].app_gen_cookie_cb;
  p_ssl_callback_ctrl = (void **)&v51->method->ssl_callback_ctrl;
  v45 = bssl::Array<unsigned char>::Init((uint64_t)p_ssl_callback_ctrl, app_gen_cookie_cb) ^ 1;
  if (!app_gen_cookie_cb)
    LOBYTE(v45) = 1;
  if ((v45 & 1) == 0)
    memcpy(*p_ssl_callback_ctrl, client_cert_cb, app_gen_cookie_cb);
  v46 = v51;
  LOWORD(v51->method[1].version) = v52[1].app_verify_cookie_cb;
  if (!(*(unsigned int (**)(ssl_st *))(*(_QWORD *)&v46->version + 8))(v46)
    || ((*(uint64_t (**)(_QWORD))(*(_QWORD *)&v51->s2->escape + 88))(*((_QWORD *)v51->handshake_func + 35)) & 1) == 0)
  {
    goto LABEL_40;
  }
  v47 = v51;
  v51 = 0;
LABEL_41:
  std::unique_ptr<ssl_st,bssl::internal::Deleter>::reset[abi:ne180100](&v51, 0);
  return v47;
}

void sub_1B4F98614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::unique_ptr<ssl_st,bssl::internal::Deleter>::reset[abi:ne180100]((ssl_st **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t bssl::Array<unsigned short>::Init(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  OPENSSL_free(*(_QWORD **)a1);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  if (!a2)
    return 1;
  if ((a2 & 0x8000000000000000) == 0)
  {
    result = (uint64_t)OPENSSL_malloc(2 * a2);
    *(_QWORD *)a1 = result;
    if (!result)
      return result;
    *(_QWORD *)(a1 + 8) = a2;
    return 1;
  }
  ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/internal.h", 312);
  return 0;
}

SSL_CTX *__cdecl SSL_CTX_new(SSL_METHOD *meth)
{
  uint64_t v1;
  uint64_t v2;
  bssl::CERT *v3;
  unint64_t *v4;
  bssl::CERT *v6;
  uint64_t v7;
  const ssl_method_st *v8;

  v8 = meth;
  if (!meth)
  {
    ERR_put_error(16, 0, 186, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 551);
    return 0;
  }
  bssl::New<ssl_ctx_st,ssl_method_st const*&>(&v8);
  v2 = v1;
  v7 = v1;
  if (v1)
  {
    bssl::New<bssl::CERT,bssl::SSL_X509_METHOD const* const&>((uint64_t *)&v8->ssl_clear);
    v6 = 0;
    std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)(v2 + 432), v3);
    std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100](&v6, 0);
    *(_QWORD *)(v2 + 256) = OPENSSL_lh_new((uint64_t)ssl_session_hash, (uint64_t)ssl_session_cmp);
    v4 = (unint64_t *)sk_new_null();
    std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)(v2 + 400), v4);
    if (!*(_QWORD *)(v2 + 432)
      || !*(_QWORD *)(v2 + 256)
      || !*(_QWORD *)(v2 + 400)
      || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)(v2 + 8) + 120))(v2) & 1) == 0)
    {
      goto LABEL_11;
    }
    if (!bssl::ssl_create_cipher_list((bssl::SSLCipherPreferenceList **)(v2 + 232), (uint64_t)"ALL", 1)
      || !SSL_CTX_set_max_proto_version((_BYTE **)v2, LOWORD(v8->version))
      || !SSL_CTX_set_min_proto_version((_BYTE **)v2, LOWORD(v8->version)))
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 575);
LABEL_11:
      v7 = 0;
      SSL_CTX_free((SSL_CTX *)v2);
      return 0;
    }
  }
  return (SSL_CTX *)v2;
}

void sub_1B4F987FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::unique_ptr<ssl_ctx_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_CTX **)va, 0);
  _Unwind_Resume(a1);
}

double bssl::New<bssl::CERT,bssl::SSL_X509_METHOD const* const&>(uint64_t *a1)
{
  _QWORD *v2;
  double result;

  v2 = OPENSSL_malloc(0xB0uLL);
  if (v2)
    return bssl::CERT::CERT((uint64_t)v2, *a1);
  return result;
}

double bssl::CERT::CERT(uint64_t a1, uint64_t a2)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_QWORD *)(a1 + 48) = a2;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 129) = 0u;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  return result;
}

void bssl::New<ssl_ctx_st,ssl_method_st const*&>(const ssl_method_st **a1)
{
  ssl_ctx_st *v2;

  v2 = (ssl_ctx_st *)OPENSSL_malloc(0x350uLL);
  if (v2)
    ssl_ctx_st::ssl_ctx_st(v2, *a1);
}

void ssl_ctx_st::ssl_ctx_st(ssl_ctx_st *this, const ssl_method_st *a2)
{
  int v2;
  void *v3;
  CRYPTO_EX_DATA *v4;

  v2 = (int)this;
  *(_OWORD *)&this->method = *(_OWORD *)&a2->ssl_new;
  this->ex_data.dummy = 0;
  *((_BYTE *)&this->ex_data.dummy + 4) = 2;
  this->rsa_md5 = 0;
  this->md5 = 0;
  this->extra_certs = 0;
  this->comp_methods = 0;
  this->info_callback = (void (__cdecl *)(const SSL *, int, int))20480;
  this->client_CA = 0;
  this->options = 0;
  this->mode = 0x200000000;
  this->max_cert_list = 0x2A30000001C20;
  *(_QWORD *)&this->read_ahead = 0;
  this->msg_callback = 0;
  this->cert = 0;
  LODWORD(this->msg_callback_arg) = 1;
  *(_OWORD *)&this->sid_ctx[8] = 0u;
  *(_OWORD *)&this->sid_ctx[24] = 0u;
  *(_OWORD *)&this->verify_mode = 0u;
  this->param = 0;
  *(_QWORD *)&this->quiet_shutdown = 0;
  LODWORD(this->tlsext_servername_callback) = 0;
  this->client_cert_engine = 0;
  *(int (__cdecl **)(SSL *, int *, void *))((char *)&this->tlsext_servername_callback + 4) = (int (__cdecl *)(SSL *, int *, void *))0x1900000000008;
  *(_QWORD *)&this->tlsext_tick_key_name[8] = 0;
  *(_QWORD *)this->tlsext_tick_hmac_key = 0;
  *(_DWORD *)&this->tlsext_tick_hmac_key[8] = 0;
  *(_QWORD *)this->tlsext_tick_key_name = 0;
  *(_OWORD *)this->tlsext_tick_aes_key = 0u;
  *(_OWORD *)&this->tlsext_ticket_key_cb = 0u;
  LOBYTE(this->tlsext_status_arg) = 0;
  WORD1(this->tlsext_status_arg) = 0x4000;
  *(_OWORD *)&this[1].method = 0u;
  *(_OWORD *)&this[1].cipher_list_by_id = 0u;
  *(_OWORD *)&this[1].sessions = 0u;
  *(_OWORD *)&this[1].session_cache_head = 0u;
  *(_OWORD *)&this[1].session_cache_mode = 0u;
  *(_OWORD *)&this[1].new_session_cb = 0u;
  *(_OWORD *)&this[1].get_session_cb = 0u;
  *(_OWORD *)&this[1].stats.sess_connect_good = 0u;
  *(_OWORD *)&this[1].stats.sess_miss = 0u;
  *(_OWORD *)&this[1].stats.sess_cb_hit = 0u;
  *(_OWORD *)&this[1].app_verify_arg = 0u;
  *(_OWORD *)&this[1].default_passwd_callback_userdata = 0u;
  *(_OWORD *)((char *)&this[1].client_cert_cb + 2) = 0u;
  *(_OWORD *)&this[1].cert = 0u;
  *(_OWORD *)&this[1].msg_callback = 0u;
  *(_OWORD *)&this[1].client_CA = 0u;
  *(_OWORD *)&this[1].mode = 0u;
  *(_OWORD *)&this[1].sha1 = 0u;
  *(_OWORD *)&this[1].comp_methods = 0u;
  LOWORD(this[1].verify_mode) &= 0xF000u;
  this[1].ex_data = 0u;
  *(_OWORD *)&this[1].rsa_md5 = 0u;
  CRYPTO_MUTEX_init((pthread_rwlock_t *)&this->cipher_list_by_id);
  CRYPTO_new_ex_data(v2 + 384, v3, v4);
}

void sub_1B4F989D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, _Unwind_Exception *exception_object)
{
  bssl::CERT **v16;
  uint64_t v17;
  STACK **v18;

  bssl::Array<unsigned char>::~Array(v17 + 824);
  std::unique_ptr<ssl_ech_keys_st,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)(v17 + 768), 0);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)(v17 + 760), 0);
  bssl::Array<unsigned char>::~Array(v17 + 744);
  bssl::Array<unsigned char>::~Array(v17 + 728);
  std::unique_ptr<stack_st_SRTP_PROTECTION_PROFILE,bssl::internal::Deleter>::reset[abi:ne180100](v18, 0);
  bssl::Array<unsigned char>::~Array(v17 + 688);
  bssl::Array<unsigned char>::~Array(v17 + 672);
  bssl::Array<unsigned char>::~Array(v17 + 656);
  bssl::Array<unsigned char>::~Array(v17 + 640);
  bssl::Array<unsigned char>::~Array(v17 + 624);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)(v17 + 544), 0);
  std::unique_ptr<bssl::TicketKey,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)(v17 + 528), 0);
  std::unique_ptr<bssl::TicketKey,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)(v17 + 520), 0);
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100](v16, 0);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)(v17 + 400), 0);
  std::unique_ptr<bssl::SSLCipherPreferenceList,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLCipherPreferenceList **)(v17 + 232), 0);
  _Unwind_Resume(a1);
}

uint64_t CRYPTO_MUTEX_init(pthread_rwlock_t *a1)
{
  uint64_t result;

  result = pthread_rwlock_init(a1, 0);
  if ((_DWORD)result)
    abort();
  return result;
}

uint64_t SSL_CTX_set_min_proto_version(_BYTE **a1, int a2)
{
  _BYTE *v3;
  __int16 *v4;
  __int16 v6;

  v4 = (__int16 *)a1 + 109;
  v3 = *a1;
  if (a2)
    return bssl::set_version_bound(v3, v4, a2);
  if (*v3)
    v6 = -257;
  else
    v6 = 769;
  *v4 = v6;
  return 1;
}

uint64_t SSL_CTX_set_max_proto_version(_BYTE **a1, int a2)
{
  _BYTE *v3;
  __int16 *v4;
  __int16 v6;

  v4 = (__int16 *)(a1 + 27);
  v3 = *a1;
  if (a2)
    return bssl::set_version_bound(v3, v4, a2);
  if (*v3)
    v6 = -259;
  else
    v6 = 772;
  *v4 = v6;
  return 1;
}

_QWORD *OPENSSL_lh_new(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  size_t v7;

  v4 = OPENSSL_malloc(0x30uLL);
  v5 = v4;
  if (v4)
  {
    v4[1] = 0u;
    v4[2] = 0u;
    *v4 = 0u;
    *((_QWORD *)v4 + 2) = 16;
    v6 = OPENSSL_malloc(0x80uLL);
    v5[1] = v6;
    if (v6)
    {
      v7 = 8 * v5[2];
      if (v7)
        bzero(v6, v7);
      v5[4] = a2;
      v5[5] = a1;
    }
    else
    {
      OPENSSL_free(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t bssl::ssl_noop_x509_ssl_ctx_new(bssl *this, ssl_ctx_st *a2)
{
  return 1;
}

uint64_t bssl::ssl_noop_x509_ssl_new(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  return 1;
}

uint64_t bssl::tls_new(unsigned __int8 **this, ssl_st *a2)
{
  bssl::SSL3_STATE *v3;
  _BOOL8 v4;
  bssl::SSLAEADContext *v5;
  _BOOL8 v6;
  bssl::SSLAEADContext *v7;
  bssl::SSL_HANDSHAKE *v8;
  bssl::SSLAEADContext **v9;
  uint64_t v10;
  bssl::SSLAEADContext *v12;
  bssl::SSLAEADContext **v13;

  bssl::New<bssl::SSL3_STATE>();
  v13 = (bssl::SSLAEADContext **)v3;
  if (!v3)
    goto LABEL_6;
  v4 = SSL_is_dtls(this) != 0;
  bssl::SSLAEADContext::CreateNullCipher((bssl::SSLAEADContext *)v4, &v12);
  v5 = v12;
  v12 = 0;
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](v13 + 33, v5);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v12, 0);
  v6 = SSL_is_dtls(this) != 0;
  bssl::SSLAEADContext::CreateNullCipher((bssl::SSLAEADContext *)v6, &v12);
  v7 = v12;
  v12 = 0;
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](v13 + 34, v7);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v12, 0);
  bssl::ssl_handshake_new((ssl_st *)this, &v12);
  v8 = v12;
  v12 = 0;
  std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100](v13 + 35, v8);
  std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100](&v12, 0);
  v9 = v13;
  if (!v13[33])
    goto LABEL_6;
  if (v13[34] && v13[35])
  {
    v13 = 0;
    this[6] = (unsigned __int8 *)v9;
    *((_WORD *)this + 8) = 771;
    v10 = 1;
  }
  else
  {
LABEL_6:
    v10 = 0;
  }
  std::unique_ptr<bssl::SSL3_STATE,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSL3_STATE **)&v13, 0);
  return v10;
}

void sub_1B4F98D14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<bssl::SSL3_STATE,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSL3_STATE **)va, 0);
  _Unwind_Resume(a1);
}

_QWORD *bssl::SSLAEADContext::CreateNullCipher@<X0>(bssl::SSLAEADContext *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;
  int v4;
  char v5;

  v5 = (char)this;
  v4 = 0;
  result = bssl::New<bssl::SSLAEADContext,int,BOOL &,decltype(nullptr)>(&v4, &v5);
  *a2 = result;
  return result;
}

_QWORD *bssl::New<bssl::SSLAEADContext,int,BOOL &,decltype(nullptr)>(int *a1, char *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  int v6;
  char v7;

  v4 = OPENSSL_malloc(0x278uLL);
  v5 = v4;
  if (v4)
  {
    v6 = *a1;
    v7 = *a2;
    *v4 = 0;
    EVP_AEAD_CTX_zero(v4 + 1);
    *((_WORD *)v5 + 310) = 0;
    *((_WORD *)v5 + 311) = v6;
    *((_BYTE *)v5 + 624) = v7;
    *((_BYTE *)v5 + 625) &= 0xE0u;
    v5[76] = 0;
    *((_DWORD *)v5 + 154) = 0;
  }
  return v5;
}

double bssl::New<bssl::SSL_CONFIG,ssl_st *>(ssl_st **a1)
{
  bssl::SSL_CONFIG *v2;
  double result;

  v2 = (bssl::SSL_CONFIG *)OPENSSL_malloc(0x140uLL);
  if (v2)
    return bssl::SSL_CONFIG::SSL_CONFIG(v2, *a1);
  return result;
}

double bssl::New<bssl::SSL3_STATE>()
{
  _QWORD *v0;
  double result;

  v0 = OPENSSL_malloc(0x260uLL);
  if (v0)
  {
    *((_DWORD *)v0 + 43) = 0;
    *((_DWORD *)v0 + 44) = 0;
    *((_DWORD *)v0 + 54) = 0;
    *((_WORD *)v0 + 110) = 0;
    result = 0.0;
    *(_OWORD *)v0 = 0u;
    *((_OWORD *)v0 + 1) = 0u;
    *((_OWORD *)v0 + 2) = 0u;
    *((_OWORD *)v0 + 3) = 0u;
    *((_OWORD *)v0 + 4) = 0u;
    *((_OWORD *)v0 + 5) = 0u;
    *((_WORD *)v0 + 48) = 0;
    *(_QWORD *)((char *)v0 + 111) = 0;
    *(_QWORD *)((char *)v0 + 103) = 0;
    *(_DWORD *)((char *)v0 + 118) = 0;
    *(_OWORD *)((char *)v0 + 127) = 0u;
    *(_OWORD *)((char *)v0 + 143) = 0u;
    *(_OWORD *)((char *)v0 + 153) = 0u;
    v0[24] = 0;
    v0[25] = 0;
    *(_QWORD *)((char *)v0 + 205) = 0;
    v0[23] = 0;
    *((_DWORD *)v0 + 64) = 0;
    *((_OWORD *)v0 + 14) = 0u;
    *((_OWORD *)v0 + 15) = 0u;
    *(_OWORD *)(v0 + 33) = 0u;
    *(_OWORD *)(v0 + 35) = 0u;
    *(_OWORD *)(v0 + 37) = 0u;
    *(_OWORD *)(v0 + 39) = 0u;
    *(_OWORD *)(v0 + 41) = 0u;
    *(_OWORD *)(v0 + 43) = 0u;
    *(_OWORD *)(v0 + 45) = 0u;
    *(_OWORD *)(v0 + 47) = 0u;
    *(_OWORD *)(v0 + 49) = 0u;
    *(_OWORD *)(v0 + 51) = 0u;
    *(_OWORD *)(v0 + 53) = 0u;
    *(_OWORD *)(v0 + 55) = 0u;
    *(_OWORD *)((char *)v0 + 455) = 0u;
    *(_OWORD *)(v0 + 59) = 0u;
    *(_OWORD *)(v0 + 61) = 0u;
    *(_OWORD *)(v0 + 63) = 0u;
    *(_OWORD *)(v0 + 65) = 0u;
    *(_OWORD *)(v0 + 67) = 0u;
    *(_OWORD *)(v0 + 69) = 0u;
    *(_OWORD *)(v0 + 71) = 0u;
    *(_OWORD *)(v0 + 73) = 0u;
    v0[75] = 0;
  }
  return result;
}

void bssl::New<ssl_st,ssl_ctx_st *&>(ssl2_state_st **a1)
{
  ssl_st *v2;

  v2 = (ssl_st *)OPENSSL_malloc(0xB8uLL);
  if (v2)
    ssl_st::ssl_st(v2, *a1);
}

void ssl_st::ssl_st(ssl_st *this, ssl2_state_st *a2)
{
  __int16 v4;
  __int128 v5;
  unsigned int *p_cipher_spec_length;
  ssl2_state_st *s2;
  unsigned int padding;
  void *v9;
  CRYPTO_EX_DATA *v10;

  *(_QWORD *)&this->version = *(_QWORD *)&a2->three_byte_header;
  this->method = 0;
  v4 = *(_WORD *)&a2[1].challenge[6];
  *(_QWORD *)&this->server = 0;
  *(_OWORD *)&this->rwstate = 0u;
  *(_OWORD *)&this->wbio = 0u;
  v5 = *(_OWORD *)&a2[1].wact_data_length;
  this->packet = 0;
  LOWORD(this->rbio) = 0;
  WORD1(this->rbio) = v4;
  *(_OWORD *)&this->quiet_shutdown = v5;
  this->init_buf = 0;
  this->init_msg = 0;
  this->init_num = 1000;
  p_cipher_spec_length = &a2->tmp.cipher_spec_length;
  *(_QWORD *)&this->packet_length = 0;
  CRYPTO_refcount_inc(&a2->tmp.cipher_spec_length);
  this->s2 = a2;
  CRYPTO_refcount_inc(p_cipher_spec_length);
  s2 = this->s2;
  *(_QWORD *)&this->read_ahead = s2[1].write_ptr;
  padding = s2[1].padding;
  this->msg_callback_arg = 0;
  this->s3 = (ssl3_state_st *)a2;
  LODWORD(this->msg_callback) = padding;
  *(_QWORD *)&this->hit = 0;
  LODWORD(this->param) = 0;
  LOBYTE(padding) = BYTE4(this->param);
  BYTE4(this->param) = padding & 0xFE;
  LOBYTE(padding) = s2[2].challenge[4] & 2 | padding & 0xFC;
  BYTE4(this->param) = padding;
  BYTE4(this->param) = s2[2].challenge[5] & 4 | padding & 0xFB;
  CRYPTO_new_ex_data((_DWORD)this + 136, v9, v10);
}

void sub_1B4F98FF8(_Unwind_Exception *a1)
{
  STACK ***v1;
  BIO **v2;
  uint64_t v3;
  uint64_t v4;
  SSL_CTX **v5;
  _QWORD **v6;

  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100](v6, 0);
  std::unique_ptr<ssl_ctx_st,bssl::internal::Deleter>::reset[abi:ne180100](v5, 0);
  std::unique_ptr<ssl_ctx_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_CTX **)(v4 + 16), 0);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)v4, 0);
  std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100]((BIO **)(v3 + 32), 0);
  std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100](v2, 0);
  std::unique_ptr<bssl::SSL_CONFIG,bssl::internal::Deleter>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void bssl::ssl_handshake_new(ssl_st *this@<X0>, bssl::SSL_HANDSHAKE **a2@<X8>)
{
  BUF_MEM **v4;
  SSL_METHOD *method;
  bssl::SSL_HANDSHAKE *v6;
  BUF_MEM **v7;
  ssl_st *v8;

  v8 = this;
  v4 = (BUF_MEM **)bssl::New<bssl::SSL_HANDSHAKE,ssl_st *&>(&v8);
  v7 = v4;
  if (v4 && bssl::SSLTranscript::Init(v4 + 53))
  {
    method = v8->method;
    v6 = (bssl::SSL_HANDSHAKE *)v7;
    v7[1] = (BUF_MEM *)method;
    if (!method)
      __assert_rtn("ssl_handshake_new", "handshake.cc", 210, "hs->config");
    v7 = 0;
  }
  else
  {
    v6 = 0;
  }
  *a2 = v6;
  std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSL_HANDSHAKE **)&v7, 0);
}

void sub_1B4F99104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, bssl::SSL_HANDSHAKE *a9)
{
  std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100](&a9, 0);
  _Unwind_Resume(a1);
}

bssl::SSL_HANDSHAKE *bssl::New<bssl::SSL_HANDSHAKE,ssl_st *&>(ssl_st **a1)
{
  bssl::SSL_HANDSHAKE *result;

  result = (bssl::SSL_HANDSHAKE *)OPENSSL_malloc(0x678uLL);
  if (result)
    return bssl::SSL_HANDSHAKE::SSL_HANDSHAKE(result, *a1);
  return result;
}

bssl::SSL_HANDSHAKE *bssl::SSL_HANDSHAKE::SSL_HANDSHAKE(bssl::SSL_HANDSHAKE *this, ssl_st *a2)
{
  *(_QWORD *)this = a2;
  *((_DWORD *)this + 4) = 1;
  *(_OWORD *)((char *)this + 36) = 0u;
  *(_OWORD *)((char *)this + 52) = 0u;
  *(_OWORD *)((char *)this + 68) = 0u;
  *(_OWORD *)((char *)this + 84) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
  *(_OWORD *)((char *)this + 116) = 0u;
  *(_OWORD *)((char *)this + 132) = 0u;
  *(_OWORD *)((char *)this + 148) = 0u;
  *(_OWORD *)((char *)this + 164) = 0u;
  *(_OWORD *)((char *)this + 180) = 0u;
  *(_OWORD *)((char *)this + 196) = 0u;
  *(_OWORD *)((char *)this + 212) = 0u;
  *(_OWORD *)((char *)this + 228) = 0u;
  *(_OWORD *)((char *)this + 244) = 0u;
  *((_DWORD *)this + 101) = 0;
  *(_OWORD *)((char *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 260) = 0u;
  *(_OWORD *)((char *)this + 276) = 0u;
  *(_OWORD *)((char *)this + 292) = 0u;
  *(_OWORD *)((char *)this + 308) = 0u;
  *(_OWORD *)((char *)this + 324) = 0u;
  *(_OWORD *)((char *)this + 340) = 0u;
  *(_OWORD *)((char *)this + 356) = 0u;
  *(_OWORD *)((char *)this + 372) = 0u;
  *(_OWORD *)((char *)this + 388) = 0u;
  bssl::SSLTranscript::SSLTranscript((bssl::SSL_HANDSHAKE *)((char *)this + 424));
  bssl::SSLTranscript::SSLTranscript((bssl::SSL_HANDSHAKE *)((char *)this + 464));
  *((_WORD *)this + 366) = 0;
  *((_BYTE *)this + 734) = 0;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 536) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  *(_OWORD *)((char *)this + 568) = 0u;
  *(_OWORD *)((char *)this + 584) = 0u;
  *(_OWORD *)((char *)this + 600) = 0u;
  *(_OWORD *)((char *)this + 616) = 0u;
  *(_OWORD *)((char *)this + 632) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  *(_OWORD *)((char *)this + 712) = 0u;
  EVP_HPKE_CTX_zero((uint64_t)this + 736);
  *((_QWORD *)this + 199) = 0;
  *(_OWORD *)((char *)this + 1560) = 0u;
  *(_OWORD *)((char *)this + 1576) = 0u;
  *(_OWORD *)((char *)this + 1528) = 0u;
  *(_OWORD *)((char *)this + 1544) = 0u;
  *(_OWORD *)((char *)this + 1496) = 0u;
  *(_OWORD *)((char *)this + 1512) = 0u;
  *(_OWORD *)((char *)this + 1464) = 0u;
  *(_OWORD *)((char *)this + 1480) = 0u;
  *((_DWORD *)this + 400) &= 0xF8000000;
  *(_OWORD *)((char *)this + 1604) = 0u;
  *(_OWORD *)((char *)this + 1620) = 0u;
  *(_OWORD *)((char *)this + 1635) = 0u;
  if (!*(_QWORD *)this)
    __assert_rtn("SSL_HANDSHAKE", "handshake.cc", 161, "ssl");
  RAND_bytes((unsigned __int8 *)this + 1644, 7);
  return this;
}

void sub_1B4F992F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, bssl::SSLTranscript *a11, bssl::SSLTranscript *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v16;
  uint64_t i;

  bssl::Array<unsigned char>::~Array(v16 + 712);
  bssl::Array<unsigned char>::~Array(v16 + 696);
  bssl::Array<unsigned char>::~Array(v16 + 680);
  bssl::Array<unsigned char>::~Array(v16 + 664);
  bssl::Array<unsigned char>::~Array(v16 + 648);
  bssl::Array<unsigned char>::~Array(v16 + 632);
  bssl::Array<unsigned char>::~Array(v16 + 616);
  bssl::Array<unsigned char>::~Array(v16 + 600);
  bssl::Array<unsigned char>::~Array(v16 + 584);
  bssl::Array<unsigned char>::~Array(v16 + 568);
  bssl::Array<unsigned char>::~Array(v16 + 552);
  bssl::Array<unsigned char>::~Array(v16 + 536);
  bssl::SSLTranscript::~SSLTranscript(a11);
  bssl::SSLTranscript::~SSLTranscript(a12);
  for (i = 0; i != -16; i -= 8)
    std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)(v16 + 400 + i), 0);
  std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)(v16 + 384), 0);
  _Unwind_Resume(a1);
}

bssl::SSLTranscript *bssl::SSLTranscript::SSLTranscript(bssl::SSLTranscript *this)
{
  *(_QWORD *)this = 0;
  EVP_MD_CTX_init((EVP_MD_CTX *)((char *)this + 8));
  return this;
}

void sub_1B4F9949C(_Unwind_Exception *a1)
{
  BUF_MEM **v1;

  std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

double bssl::SSL_CONFIG::SSL_CONFIG(bssl::SSL_CONFIG *this, ssl_st *a2)
{
  double result;

  *(_QWORD *)this = a2;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *(_OWORD *)((char *)this + 218) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *(_OWORD *)((char *)this + 297) = 0u;
  *(_WORD *)((char *)this + 313) &= 0xF800u;
  if (!a2)
    __assert_rtn("SSL_CONFIG", "ssl_lib.cc", 721, "ssl");
  return result;
}

void sub_1B4F99578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, _Unwind_Exception *exception_object)
{
  uint64_t v16;
  uint64_t v17;

  bssl::Array<unsigned char>::~Array(v16 + 296);
  std::unique_ptr<stack_st_SRTP_PROTECTION_PROFILE,bssl::internal::Deleter>::reset[abi:ne180100]((STACK **)(v16 + 288), 0);
  bssl::Array<unsigned char>::~Array(v16 + 272);
  bssl::Array<unsigned char>::~Array(v16 + 256);
  bssl::Array<unsigned char>::~Array(v17);
  bssl::Array<unsigned char>::~Array(v16 + 216);
  bssl::Array<unsigned char>::~Array(v16 + 200);
  bssl::Array<unsigned char>::~Array(v16 + 184);
  bssl::Array<unsigned char>::~Array(v16 + 168);
  bssl::Array<bssl::ALPSConfig>::~Array(v16 + 152);
  bssl::Array<unsigned char>::~Array(v16 + 128);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)(v16 + 120), 0);
  bssl::Array<unsigned char>::~Array(v16 + 104);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)(v16 + 88), 0);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)(v16 + 56), 0);
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)(v16 + 32), 0);
  std::unique_ptr<bssl::SSLCipherPreferenceList,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLCipherPreferenceList **)(v16 + 24), 0);
  _Unwind_Resume(a1);
}

void EVP_HPKE_CTX_zero(uint64_t a1)
{
  bzero((void *)a1, 0x2D8uLL);
  EVP_AEAD_CTX_zero((void *)(a1 + 24));
}

BOOL bssl::tls12_check_peer_sigalg(bssl *this, const bssl::SSL_HANDSHAKE *a2, unsigned __int8 *a3)
{
  int v3;
  uint64_t v5;
  uint64_t v6;
  __int16 *v7;
  uint64_t v8;
  int v9;

  v3 = (int)a3;
  v5 = *((_QWORD *)this + 1);
  v6 = *(_QWORD *)(v5 + 280);
  if (v6)
  {
    v7 = *(__int16 **)(v5 + 272);
  }
  else
  {
    v7 = &bssl::kVerifySignatureAlgorithms;
    v6 = 11;
  }
  v8 = 2 * v6;
  while (1)
  {
    v9 = (unsigned __int16)*v7;
    if (v9 == (_DWORD)a3)
      break;
    ++v7;
    v8 -= 2;
    if (!v8)
    {
      ERR_put_error(16, 0, 245, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 507);
      *(_BYTE *)a2 = 47;
      return v9 == v3;
    }
  }
  return v9 == v3;
}

uint64_t METHOD_ref(uint64_t result)
{
  if (!*(_BYTE *)(result + 4))
    METHOD_ref_cold_1();
  return result;
}

void SSL_CTX_free(SSL_CTX *a1)
{
  _QWORD *v2;

  if (a1)
  {
    if (CRYPTO_refcount_dec_and_test_zero((unsigned int *)&a1->msg_callback_arg))
    {
      ssl_ctx_st::~ssl_ctx_st(a1);
      OPENSSL_free(v2);
    }
  }
}

void bssl::CERT::~CERT(bssl::CERT *this)
{
  bssl::ssl_cert_clear_certs((uint64_t)this);
  (*(void (**)(bssl::CERT *))(*((_QWORD *)this + 6) + 16))(this);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)this + 20, 0);
  std::unique_ptr<bssl::DC,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)this + 19, 0);
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)this + 13, 0);
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)this + 12, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)this + 56);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)this + 1, 0);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)this, 0);
}

void bssl::ssl_cert_clear_certs(uint64_t a1)
{
  if (a1)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 8))();
    std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)(a1 + 8), 0);
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)a1, 0);
    *(_QWORD *)(a1 + 40) = 0;
    std::unique_ptr<bssl::DC,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)(a1 + 152), 0);
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)(a1 + 160), 0);
    *(_QWORD *)(a1 + 168) = 0;
  }
}

void bssl::tls_free(bssl *this, ssl_st *a2)
{
  bssl::SSL3_STATE *v3;
  _QWORD *v4;

  if (this)
  {
    v3 = (bssl::SSL3_STATE *)*((_QWORD *)this + 6);
    if (v3)
    {
      bssl::SSL3_STATE::~SSL3_STATE(v3);
      OPENSSL_free(v4);
      *((_QWORD *)this + 6) = 0;
    }
  }
}

void METHOD_ref_cold_1()
{
  __assert_rtn("METHOD_ref", "engine.c", 87, "((struct openssl_method_common_st*) method_in)->is_static");
}

BOOL bssl::SSLTranscript::Init(BUF_MEM **this)
{
  BUF_MEM *v2;
  BUF_MEM *v3;
  EVP_MD_CTX *v4;

  v2 = BUF_MEM_new();
  std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](this, v2);
  v3 = *this;
  if (*this)
  {
    v4 = (EVP_MD_CTX *)(this + 1);
    EVP_MD_CTX_cleanup(v4);
    EVP_MD_CTX_init(v4);
  }
  return v3 != 0;
}

uint64_t boringssl_session_handshake_start(_QWORD *a1)
{
  char *v1;
  uint64_t v3;
  SSL *v4;
  int v5;
  uint64_t result;
  int v7;
  id WeakRetained;
  void *v9;
  unsigned __int8 *v10;
  id v11;
  _BYTE *v12;
  _BOOL4 v13;
  NSObject *v14;
  id v15;
  void *v16;
  id v17;
  void *v18;
  const char *v19;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  void *v25;
  __int16 v26;
  id v27;
  __int16 v28;
  const char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v3 = a1[1];
  if (!v3 || !*(_QWORD *)(v3 + 400))
    return 0xFFFFFFFFLL;
  *(_QWORD *)(v3 + 424) = boringssl_helper_get_current_time_ms();
  v4 = *(SSL **)(v3 + 400);
  if ((*(_BYTE *)(v3 + 556) & 0x10) != 0)
    v5 = SSL_accept(v4);
  else
    v5 = SSL_connect(v4);
  if (v5 <= 0)
    return boringssl_session_handshake_incomplete(a1, v5, 0);
  v7 = SSL_in_early_data(*(_QWORD *)(v3 + 400));
  WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
  if (WeakRetained)
  {
    v9 = WeakRetained;
    v10 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16));
    v1 = (char *)v10[475];

    if ((v1 & 1) != 0)
      return 0;
  }
  v11 = objc_loadWeakRetained((id *)(v3 + 16));
  if (v11)
  {
    v12 = objc_loadWeakRetained((id *)(v3 + 16));
    v13 = (v12[475] & 1) == 0;

  }
  else
  {
    v13 = 1;
  }

  result = 0;
  if (v13 && g_boringssl_log)
  {
    v14 = (id)g_boringssl_log;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v15)
      {
        v1 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
        v16 = v1 + 391;
      }
      else
      {
        v16 = &unk_1B50022E3;
      }
      v17 = objc_loadWeakRetained((id *)(v3 + 16));
      v18 = v17;
      v20 = 136447234;
      v21 = "boringssl_session_handshake_start";
      v19 = "true";
      v22 = 1024;
      v23 = 288;
      v24 = 2082;
      if (!v7)
        v19 = "false";
      v25 = v16;
      v26 = 2048;
      v27 = v17;
      v28 = 2082;
      v29 = v19;
      _os_log_impl(&dword_1B4F6D000, v14, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] In early data: %{public}s", (uint8_t *)&v20, 0x30u);

      if (v15)
    }

    return 0;
  }
  return result;
}

uint64_t boringssl_session_handshake_continue(SSL *a1)
{
  return boringssl_session_handshake_continue_inner(a1, 0);
}

int SSL_do_handshake(SSL *s)
{
  BOOL *v2;
  bssl *v3;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(SSL *, uint64_t, uint64_t);
  int (__cdecl *handshake_func)(SSL *);
  bssl::SSL_HANDSHAKE *v8;
  ssl_st *v9;
  char v11;

  *((_DWORD *)s->handshake_func + 49) = 0;
  ERR_clear_error();
  ERR_clear_system_error();
  if (!*(_QWORD *)&s->rwstate)
  {
    ERR_put_error(16, 0, 134, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 862);
    LODWORD(v4) = -1;
    return v4;
  }
  v3 = (bssl *)*((_QWORD *)s->handshake_func + 35);
  if (!v3 || (*((_BYTE *)v3 + 1600) & 8) != 0)
    goto LABEL_13;
  v11 = 0;
  v4 = bssl::ssl_run_handshake(v3, (bssl::SSL_HANDSHAKE *)&v11, v2);
  if ((BYTE4(s->param) & 1) != 0)
    v5 = 8194;
  else
    v5 = 4098;
  v6 = *(void (**)(SSL *, uint64_t, uint64_t))&s->packet_length;
  if (v6 || (v6 = *(void (**)(SSL *, uint64_t, uint64_t))&s->s2[1].rbuf_offs) != 0)
    v6(s, v5, v4);
  if ((int)v4 >= 1)
  {
    if (!v11)
    {
      handshake_func = s->handshake_func;
      v8 = (bssl::SSL_HANDSHAKE *)*((_QWORD *)handshake_func + 35);
      *((_QWORD *)handshake_func + 35) = 0;
      std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSL_HANDSHAKE **)handshake_func + 36, v8);
      std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSL_HANDSHAKE **)s->handshake_func + 35, 0);
      bssl::ssl_maybe_shed_handshake_config((bssl *)s, v9);
    }
LABEL_13:
    LODWORD(v4) = 1;
  }
  return v4;
}

uint64_t bssl::ssl_run_handshake(bssl *this, bssl::SSL_HANDSHAKE *a2, BOOL *a3)
{
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t result;
  int v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  char v17;
  ssl_st *v18;
  unsigned __int8 v19[9];

  v5 = *(_QWORD *)this;
  while (2)
  {
    v6 = *((_DWORD *)this + 4);
    switch(v6)
    {
      case 0:
        ERR_restore_state(*((_QWORD **)this + 48));
        return 0xFFFFFFFFLL;
      case 2:
      case 3:
      case 15:
        if (!*(_QWORD *)(v5 + 168))
        {
          v19[0] = 50;
          v18 = 0;
          if (v6 == 15)
            v7 = bssl::ssl_open_change_cipher_spec((_QWORD *)v5, &v18, v19);
          else
            v7 = bssl::ssl_open_handshake((_QWORD *)v5, &v18, v19);
          v8 = v7;
          if (v7 == 4 && *((_DWORD *)this + 4) == 2 && (ERR_peek_error() & 0xFF000FFF) == 0x10000410)
            ERR_put_error(16, 0, 154, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 670);
          v17 = -86;
          result = bssl::ssl_handle_open_record((bssl *)v5, &v17, v8, v18, v19[0]);
          if ((int)result <= 0)
            return result;
          if (!v17)
          {
            bssl::SSLBuffer::DiscardConsumed((_WORD *)(*(_QWORD *)(v5 + 48) + 80));
LABEL_18:
            v10 = (*(uint64_t (**)(bssl *, bssl::SSL_HANDSHAKE *, BOOL *))(v5 + 40))(this, a2, a3);
            *((_DWORD *)this + 4) = v10;
            if (v10 == 1)
            {
              if ((*(_BYTE *)(v5 + 180) & 1) == 0 && *(_DWORD *)(*(_QWORD *)(v5 + 48) + 216) == 2)
                bssl::ssl_run_handshake();
              *(_BYTE *)a2 = 0;
              return 1;
            }
            if (!v10)
            {
              v11 = ERR_save_state();
              std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)this + 48, (uint64_t)v11);
              return 0xFFFFFFFFLL;
            }
          }
          continue;
        }
        if (v6 == 15)
          bssl::ssl_run_handshake();
        v12 = *(_QWORD *)(v5 + 48);
        v13 = 2;
LABEL_42:
        *(_DWORD *)(v12 + 196) = v13;
        v14 = 1;
LABEL_43:
        *((_DWORD *)this + 4) = v14;
        return 0xFFFFFFFFLL;
      case 4:
        result = (*(uint64_t (**)(uint64_t, bssl::SSL_HANDSHAKE *, BOOL *))(*(_QWORD *)v5 + 120))(v5, a2, a3);
        if ((int)result <= 0)
          return result;
        goto LABEL_18;
      case 5:
        v12 = *(_QWORD *)(v5 + 48);
        v13 = 12;
        goto LABEL_42;
      case 6:
        v12 = *(_QWORD *)(v5 + 48);
        v13 = 17;
        goto LABEL_42;
      case 7:
        result = (*(uint64_t (**)(uint64_t, bssl::SSL_HANDSHAKE *, BOOL *))(*(_QWORD *)v5 + 120))(v5, a2, a3);
        if ((int)result < 1)
          return result;
        *(_DWORD *)(*(_QWORD *)(v5 + 48) + 196) = 18;
        v14 = 7;
        goto LABEL_43;
      case 8:
        v12 = *(_QWORD *)(v5 + 48);
        v13 = 4;
        goto LABEL_42;
      case 9:
        v12 = *(_QWORD *)(v5 + 48);
        v13 = 13;
        goto LABEL_42;
      case 10:
        v12 = *(_QWORD *)(v5 + 48);
        v13 = 11;
        goto LABEL_42;
      case 11:
        v12 = *(_QWORD *)(v5 + 48);
        v13 = 14;
        goto LABEL_42;
      case 12:
        if ((*(_BYTE *)(v5 + 180) & 1) == 0 && *(_DWORD *)(*(_QWORD *)(v5 + 48) + 216) == 2)
          bssl::ssl_run_handshake();
        result = 1;
        *(_BYTE *)a2 = 1;
        *((_DWORD *)this + 4) = 1;
        return result;
      case 13:
        v15 = *(_QWORD *)(v5 + 48);
        if (!*(_DWORD *)(v15 + 256))
          bssl::ssl_run_handshake();
        if ((*((_BYTE *)this + 1601) & 0x40) != 0)
          bssl::ssl_run_handshake();
        v16 = 15;
        goto LABEL_47;
      case 14:
        if ((*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 280) + 1601) & 0x20) != 0)
        {
          result = 1;
          *(_BYTE *)a2 = 1;
          return result;
        }
        *((_DWORD *)this + 4) = 1;
        goto LABEL_18;
      case 16:
        v12 = *(_QWORD *)(v5 + 48);
        v13 = 16;
        goto LABEL_42;
      case 17:
        v15 = *(_QWORD *)(v5 + 48);
        v16 = 20;
LABEL_47:
        *(_DWORD *)(v15 + 196) = v16;
        return 0xFFFFFFFFLL;
      default:
        goto LABEL_18;
    }
  }
}

uint64_t bssl::ssl_open_handshake(_QWORD *a1, _QWORD *a2, _BYTE *a3)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v7;
  uint64_t *v8;
  _QWORD *v9;

  *a2 = 0;
  v4 = a1[6];
  if (*(_DWORD *)(v4 + 172) == 2)
  {
    ERR_restore_state(*(_QWORD **)(v4 + 184));
    *a3 = 0;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD *))(*a1 + 48))(a1);
    if ((_DWORD)result != 4)
      return result;
    v7 = a1[6];
    *(_DWORD *)(v7 + 172) = 2;
    v8 = (uint64_t *)(v7 + 184);
    v9 = ERR_save_state();
    std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100](v8, (uint64_t)v9);
  }
  return 4;
}

uint64_t bssl::tls_open_handshake(uint64_t a1, unsigned __int8 **a2, ssl_st *a3, char *__s2, unsigned __int16 *a5)
{
  uint64_t v10;
  __int16 v11;
  uint64_t result;
  int v13;
  int v14;
  int v15;
  int v16;
  char v17;
  const void *v18;
  size_t v19;
  char v20;

  *a2 = 0;
  if ((*(_BYTE *)(a1 + 180) & 1) == 0 || (v10 = *(_QWORD *)(a1 + 48), v11 = *(_WORD *)(v10 + 220), (v11 & 4) != 0))
  {
LABEL_19:
    v20 = -86;
    v18 = 0;
    v19 = 0;
    result = bssl::tls_open_record((bssl *)a1, &v20, (uint64_t)&v18, a2, a3, (unsigned __int16 *)__s2, a5);
    if ((_DWORD)result)
      return result;
    if ((*(_BYTE *)(a1 + 180) & 1) != 0 || v20 != 23)
    {
      if (v20 == 22)
      {
        if ((bssl::tls_append_handshake_data(a1, v18, v19) & 1) != 0)
          return 0;
        v17 = 80;
        goto LABEL_29;
      }
    }
    else if (!**(_QWORD **)(*(_QWORD *)(a1 + 48) + 264))
    {
      v15 = 281;
      v16 = 619;
LABEL_28:
      ERR_put_error(16, 0, v15, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", v16);
      v17 = 10;
LABEL_29:
      LOBYTE(a3->version) = v17;
      return 4;
    }
    v15 = 225;
    v16 = 625;
    goto LABEL_28;
  }
  if ((unint64_t)a5 <= 4)
  {
    *a2 = (unsigned __int8 *)5;
    return 2;
  }
  if (!strncmp("GET ", __s2, 4uLL)
    || !strncmp("POST ", __s2, 5uLL)
    || !strncmp("HEAD ", __s2, 5uLL)
    || !strncmp("PUT ", __s2, 4uLL))
  {
    v13 = 156;
    v14 = 581;
LABEL_17:
    ERR_put_error(16, 0, v13, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", v14);
    LOBYTE(a3->version) = 0;
    return 4;
  }
  if (!strncmp("CONNE", __s2, 5uLL))
  {
    v13 = 155;
    v14 = 586;
    goto LABEL_17;
  }
  if ((*__s2 & 0x80000000) == 0 || __s2[2] != 1 || __s2[3] != 3)
  {
    *(_WORD *)(v10 + 220) = v11 | 4;
    goto LABEL_19;
  }
  result = bssl::read_v2_client_hello(a1, (unint64_t *)a2, __s2, (unint64_t)a5);
  if ((_DWORD)result)
  {
    if ((_DWORD)result == 4)
      LOBYTE(a3->version) = 0;
  }
  else
  {
    *(_WORD *)(*(_QWORD *)(a1 + 48) + 220) |= 4u;
  }
  return result;
}

uint64_t bssl::ssl_client_handshake(bssl *this, ssl_session_st *a2)
{
  unsigned __int16 *v3;
  int v4;
  uint64_t v5;
  unsigned __int16 *v6;
  __int128 v7;
  int is_dtls;
  ssl_session_st *v9;
  unsigned int v10;
  __int16 v11;
  __int16 v12;
  uint64_t v13;
  const ssl_session_st *v14;
  uint64_t v15;
  unsigned int (*v16)(uint64_t, __int128 *, __int128 *, _BYTE *, __int128 *, _BYTE *, _OWORD *, unsigned int *);
  __int128 v17;
  SSL_SESSION *v18;
  uint64_t v19;
  int v20;
  size_t v21;
  int v22;
  _QWORD *v23;
  int v24;
  uint64_t finished;
  bssl *v26;
  __int128 v27;
  __int128 v28;
  const ssl_cipher_st *v29;
  bssl *v30;
  int v31;
  int v32;
  char *v33;
  __int128 v34;
  unsigned int v35;
  int v36;
  int v37;
  bssl *v38;
  __int128 v39;
  int v40;
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  unint64_t v44;
  bssl *v45;
  __int128 v46;
  int v47;
  BOOL v48;
  int v49;
  uint64_t v50;
  int v51;
  bssl *v52;
  __int128 v53;
  __int128 v54;
  unsigned __int16 *v55;
  const ssl_st *v56;
  int v57;
  int v58;
  int v59;
  __int128 v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  bssl *v65;
  __int128 v66;
  ssl_st *v67;
  __int128 v68;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  __int128 v73;
  SSL_SESSION *v74;
  SSL_SESSION **v75;
  SSL_SESSION *v76;
  SSL_SESSION *v77;
  uint64_t v78;
  uint64_t v79;
  SSL_SESSION **v80;
  SSL_SESSION *v81;
  bssl *v82;
  bssl *v83;
  __int128 v84;
  const SSL *v85;
  uint64_t v86;
  int (__cdecl *handshake_func)(SSL *);
  uint64_t v88;
  uint64_t (*v89)(_QWORD, _QWORD);
  int v90;
  bssl::SSL_HANDSHAKE *v91;
  uint64_t v92;
  unsigned int v93;
  SSL_SESSION *v94;
  _QWORD *v95;
  __int128 v96;
  size_t v97;
  const ssl_session_st *v98;
  SSL_SESSION *v99;
  SSL_SESSION *v100;
  int v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  uint64_t v106;
  unint64_t *v107;
  __int128 v108;
  const ssl_st *v109;
  char v110;
  char v111;
  const RSA *v112;
  __int128 v113;
  unsigned int v114;
  uint64_t v115;
  unsigned int v116;
  int v117;
  __int128 v118;
  int v119;
  uint64_t v120;
  int v121;
  uint64_t v122;
  __int128 v123;
  char v124;
  char v125;
  bssl *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  int master_secret;
  SSL_SESSION *v131;
  const ssl_st *v132;
  uint64_t v133;
  unsigned int v134;
  bssl::SSL_HANDSHAKE *v135;
  int v136;
  uint64_t v137;
  _OWORD *v138;
  __int128 v139;
  uint64_t v140;
  uint64_t v141;
  __int128 v142;
  __int128 v143;
  ssl_session_st *v144;
  bssl *v145;
  SSL_SESSION *v146;
  void **p_prev;
  __int128 v148;
  int v149;
  char v150;
  const unsigned __int8 *v151;
  size_t v152;
  __int128 v153;
  char v154;
  char v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  const ssl_cipher_st *v159;
  const ssl_st *v160;
  const evp_pkey_st *v161;
  SSL_SESSION *v162;
  unsigned int *v163;
  uint64_t v164;
  unint64_t *v165;
  uint64_t v166;
  _DWORD *cipher_by_value;
  uint64_t v168;
  uint64_t v169;
  unsigned int min_version;
  const ssl_st *v171;
  unsigned int max_version;
  const ssl_st *v173;
  STACK *ciphers;
  ssl_session_st *v175;
  uint64_t v176;
  __int128 v177;
  uint64_t v178;
  const void *v179;
  size_t v180;
  char v181;
  uint64_t v182;
  unsigned __int8 *v183;
  unsigned __int8 *v184;
  uint64_t v185;
  uint64_t v186;
  int v187;
  bssl::SSL_HANDSHAKE *v188;
  int v189;
  SSL_SESSION *v190;
  const void *v191;
  const ssl_st *v192;
  size_t v193;
  bssl *v194;
  const ssl_cipher_st *v195;
  uint64_t v196;
  int v197;
  uint64_t v198;
  __int16 v199;
  unint64_t **v201;
  void **v202;
  SSL_SESSION **v203;
  void **v204;
  _QWORD **v205;
  _QWORD **v206;
  char *__dst;
  void **v208;
  unsigned __int8 *buf;
  _QWORD **v210;
  EVP_PKEY **v211;
  BUF_MEM **v212;
  char *v213;
  bssl::SSL_HANDSHAKE *v214;
  SSL_SESSION **v215;
  unsigned int v216;
  _BYTE __n[12];
  void *v218;
  size_t v219;
  _OWORD v220[2];
  __int128 v221;
  __int128 v222;
  __int128 v223;
  __int128 v224;
  __int128 v225;
  __int128 v226;
  __int128 v227;
  __int128 v228;
  __int128 v229;
  __int128 v230;
  __int128 v231;
  __int128 v232;
  __int128 v233;
  __int128 v234;
  __int128 __src;
  __int128 v236;
  __int128 v237;
  __int128 v238;
  __int128 __b[64];
  __int128 v240;
  __int128 v241;
  __int128 v242;
  __int128 v243;
  __int128 v244;
  __int128 v245;
  uint64_t v246;

  v215 = (SSL_SESSION **)((char *)this + 1536);
  v246 = *MEMORY[0x1E0C80C00];
  v211 = (EVP_PKEY **)((char *)this + 1528);
  v212 = (BUF_MEM **)((char *)this + 424);
  v204 = (void **)((char *)this + 1504);
  v201 = (unint64_t **)((char *)this + 1488);
  v210 = (_QWORD **)((char *)this + 1480);
  v205 = (_QWORD **)((char *)this + 400);
  v206 = (_QWORD **)((char *)this + 392);
  v202 = (void **)((char *)this + 696);
  v3 = (unsigned __int16 *)((char *)this + 30);
  __dst = (char *)this + 1611;
  v208 = (void **)((char *)this + 552);
  v203 = (SSL_SESSION **)((char *)this + 1544);
  v213 = (char *)this + 88;
  v214 = (bssl *)((char *)this + 28);
  buf = (unsigned __int8 *)this + 504;
  while (2)
  {
    v4 = *((_DWORD *)this + 5);
    switch(v4)
    {
      case 0:
        v5 = *(_QWORD *)this;
        bssl::ssl_do_info_callback(*(_QWORD *)this, (const ssl_st *)0x10);
        *(_WORD *)(*(_QWORD *)(v5 + 48) + 220) &= ~0x40u;
        if (!bssl::ssl_get_version_range(this, v214, v3, v6))
          goto LABEL_451;
        *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v243 = v7;
        v244 = v7;
        v218 = (void *)0xAAAAAAAAAAAAAAAALL;
        if (!bssl::ssl_select_ech_config((uint64_t)this, (uint64_t)&v243, 32, &v218))
          goto LABEL_451;
        is_dtls = SSL_is_dtls(*(unsigned __int8 ***)this);
        v10 = *((unsigned __int16 *)this + 15);
        if (v10 >= 0x303)
          v11 = 771;
        else
          v11 = *((_WORD *)this + 15);
        if (v10 <= 0x302)
          v12 = -257;
        else
          v12 = -259;
        if (!is_dtls)
          v12 = v11;
        *((_WORD *)this + 802) = v12;
        v13 = *(_QWORD *)(v5 + 104);
        if (v13
          && ((*(_BYTE *)(v13 + 448) & 0x10) != 0
           || !bssl::ssl_supports_version(this, (const bssl::SSL_HANDSHAKE *)*(unsigned __int16 *)(v13 + 4))
           || *((_QWORD *)this + 195)
           && bssl::ssl_session_protocol_version(*(bssl **)(v5 + 104), v14) < 0x304
           || !SSL_SESSION_is_resumable(*(_QWORD *)(v5 + 104))
           || !bssl::ssl_session_is_time_valid((bssl *)v5, *(const ssl_st **)(v5 + 104), v9)
           || (*(_QWORD *)(v5 + 168) == 0) == (*(_BYTE *)(*(_QWORD *)(v5 + 104) + 448) & 0x20) >> 5
           || (*(_WORD *)(*(_QWORD *)(v5 + 48) + 220) & 0x20) != 0))
        {
          bssl::ssl_set_session((ssl_st **)v5, 0, v9);
        }
        if (!RAND_bytes((unsigned __int8 *)(*(_QWORD *)(v5 + 48) + 48), 32)
          || *((_QWORD *)this + 195) && !RAND_bytes(buf, 32))
        {
          goto LABEL_451;
        }
        if (*(_QWORD *)(v5 + 168))
          goto LABEL_27;
        v120 = *(_QWORD *)(v5 + 104);
        if (!v120)
          goto LABEL_359;
        v121 = *(_DWORD *)(v120 + 64);
        v122 = *(_QWORD *)(v120 + 248);
        if (v121)
        {
          if (!v122)
          {
            *((_BYTE *)this + 1643) = v121;
            if ((_BYTE)v121)
              memcpy(__dst, (const void *)(v120 + 68), v121);
            goto LABEL_27;
          }
        }
        else if (!v122)
        {
LABEL_359:
          if (*v3 < 0x304u)
            goto LABEL_27;
        }
        *((_BYTE *)this + 1643) = 32;
        if (!RAND_bytes((unsigned __int8 *)__dst, 32))
          goto LABEL_451;
LABEL_27:
        v15 = *(_QWORD *)this;
        if (*((unsigned __int16 *)this + 14) >= 0x304u && !*(_QWORD *)(v15 + 104))
        {
          v16 = *(unsigned int (**)(uint64_t, __int128 *, __int128 *, _BYTE *, __int128 *, _BYTE *, _OWORD *, unsigned int *))(*(_QWORD *)(v15 + 8) + 80);
          if (v16)
          {
            *(_QWORD *)&v240 = 0;
            memset(__b, 170, sizeof(__b));
            *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v237 = v17;
            v238 = v17;
            __src = v17;
            v236 = v17;
            v233 = v17;
            v234 = v17;
            v231 = v17;
            v232 = v17;
            v229 = v17;
            v230 = v17;
            v227 = v17;
            v228 = v17;
            v225 = v17;
            v226 = v17;
            v223 = v17;
            v224 = v17;
            v221 = v17;
            v222 = v17;
            v220[0] = v17;
            v220[1] = v17;
            v216 = 256;
            *(_QWORD *)__n = 0x40000000040;
            if (!v16(v15, &v240, __b, &__n[4], &__src, __n, v220, &v216) && (_QWORD)v240)
            {
              v18 = SSL_SESSION_new();
              v19 = (uint64_t)v18;
              LOWORD(v18->key_arg_length) = 772;
              v18->cipher_id = v240;
              v20 = *(_DWORD *)__n;
              if (*(_DWORD *)__n <= 0x2Fu)
              {
                memcpy(&v18->master_key_length, &__src, *(unsigned int *)__n);
                *(_DWORD *)(v19 + 12) = v20;
              }
              v21 = v216;
              if (v216 - 1 <= 0xFE && bssl::Array<unsigned char>::Init(v19 + 400, v216))
                memcpy(*(void **)(v19 + 400), v220, v21);
              SSL_SESSION_set_ticket(v19, __b, *(unsigned int *)&__n[4]);
              *(_DWORD *)(v19 + 388) = ((__int16)(*(unsigned __int8 *)(v15 + 180) << 13) >> 15) & 0x3800;
              *(_BYTE *)(v19 + 448) |= 0x80u;
              SSL_set_session((SSL *)v15, (SSL_SESSION *)v19);
            }
            v15 = *(_QWORD *)this;
          }
        }
        if ((*(_BYTE *)(v15 + 180) & 1) != 0)
          bssl::ssl_client_handshake();
        if ((*(_BYTE *)(v15 + 180) & 4) == 0)
        {
          v22 = 1;
LABEL_369:
          *(_DWORD *)(*(_QWORD *)(v5 + 48) + 256) = v22;
          goto LABEL_370;
        }
        if (*v3 < 0x304u)
        {
          v22 = 3;
          goto LABEL_369;
        }
        v126 = *(bssl **)(v15 + 104);
        if (!v126)
        {
          v22 = 5;
          goto LABEL_369;
        }
        if (bssl::ssl_session_protocol_version(v126, a2) < 0x304
          || (v127 = *(_QWORD *)(v15 + 104), !*(_DWORD *)(v127 + 388)))
        {
          v22 = 7;
          goto LABEL_369;
        }
        v128 = *(_QWORD *)(v127 + 408);
        if (!v128)
          goto LABEL_313;
        if (!bssl::ssl_is_alpn_protocol_allowed(this, *(unsigned __int8 **)(v127 + 400), v128))
        {
          v22 = 9;
          goto LABEL_369;
        }
        v129 = *(_QWORD *)(v15 + 104);
        if ((*(_BYTE *)(v129 + 448) & 0x40) == 0)
        {
LABEL_313:
          *((_DWORD *)this + 400) |= 0x1000u;
LABEL_370:
          if (bssl::ssl_setup_key_shares(this, 0)
            && bssl::ssl_setup_extension_permutation(this, (bssl::SSL_HANDSHAKE *)a2)
            && bssl::ssl_encrypt_client_hello((uint64_t)this, &v243, (size_t)v218)
            && bssl::ssl_add_client_hello(this, (bssl::SSL_HANDSHAKE *)a2))
          {
            *((_DWORD *)this + 5) = 1;
            goto LABEL_48;
          }
          goto LABEL_451;
        }
        __b[0] = 0uLL;
        if (bssl::ssl_get_local_application_settings((uint64_t)this, (unsigned __int8 **)__b, *(unsigned __int8 **)(v129 + 400), *(unsigned __int8 **)(v129 + 408)))
        {
          v182 = *(_QWORD *)(v15 + 104);
          if (*((_QWORD *)&__b[0] + 1) == *(_QWORD *)(v182 + 424))
          {
            if (!*((_QWORD *)&__b[0] + 1))
              goto LABEL_313;
            v183 = *(unsigned __int8 **)(v182 + 416);
            v184 = *(unsigned __int8 **)&__b[0];
            v185 = *((_QWORD *)&__b[0] + 1) - 1;
            while (1)
            {
              v186 = v185;
              if (*v184 != *v183)
                break;
              ++v184;
              ++v183;
              --v185;
              if (!v186)
                goto LABEL_313;
            }
          }
        }
        v22 = 14;
        goto LABEL_369;
      case 1:
        v61 = *(_QWORD *)this;
        if (SSL_is_dtls(*(unsigned __int8 ***)this))
        {
          v40 = 3;
          goto LABEL_471;
        }
        if ((*((_BYTE *)this + 1601) & 0x10) == 0)
        {
LABEL_198:
          v40 = 4;
          goto LABEL_471;
        }
        bssl::SSLAEADContext::SetVersionIfNullCipher(*(_QWORD *)(*(_QWORD *)(v61 + 48) + 272), *(_WORD *)(*(_QWORD *)(v61 + 104) + 4));
        if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v61 + 112))(v61)
          || !bssl::tls13_init_early_key_schedule(this, *(ssl_cipher_st ***)(v61 + 104), v98)
          || !bssl::tls13_derive_early_secret(this, (bssl::SSL_HANDSHAKE *)a2))
        {
          goto LABEL_451;
        }
        v99 = *(SSL_SESSION **)(v61 + 104);
        if (v99)
          SSL_SESSION_up_ref(*(unsigned int **)(v61 + 104));
        std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v203, v99);
        v40 = 2;
        goto LABEL_471;
      case 2:
        v50 = *(_QWORD *)this;
        if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)this + 120) + 496))
          goto LABEL_210;
        v51 = bssl::ssl_reverify_peer_cert((bssl **)this, 0);
        if (v51 == 1)
          goto LABEL_451;
        if (v51 == 2)
        {
          finished = 16;
LABEL_212:
          *((_DWORD *)this + 5) = v51;
          goto LABEL_473;
        }
        v50 = *(_QWORD *)this;
LABEL_210:
        if (bssl::tls13_set_traffic_key(v50, (const ssl_session_st *)1, 1, *((bssl **)this + 193), v213, *((_QWORD *)this + 4)))
        {
          *((_DWORD *)this + 400) |= 0x4800u;
          finished = 12;
          v51 = 4;
          goto LABEL_212;
        }
        goto LABEL_451;
      case 3:
        v38 = *(bssl **)this;
        if (!SSL_is_dtls(*(unsigned __int8 ***)this))
          bssl::ssl_client_handshake();
        if (*v3 >= 0x304u)
          bssl::ssl_client_handshake();
        *(_QWORD *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v60 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v60 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v60;
        __b[1] = v60;
        if (!(*(unsigned int (**)(bssl *, __int128 *))(*(_QWORD *)v38 + 24))(v38, __b))
          goto LABEL_180;
        if (BYTE1(__b[0]) != 3)
          goto LABEL_198;
        v220[0] = *(__int128 *)((char *)__b + 8);
        *(_QWORD *)&__src = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&__src + 1) = 0xAAAAAAAAAAAAAAAALL;
        LOWORD(v243) = -21846;
        if (!CBS_get_u16((unsigned __int16 **)v220, &v243)
          || !CBS_get_u8_length_prefixed((unsigned __int8 **)v220, (unint64_t *)&__src)
          || CBS_len((uint64_t)v220))
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 708);
          bssl::ssl_send_alert(v38, (ssl_st *)2, 50);
          goto LABEL_451;
        }
        v123 = __src;
        v124 = bssl::Array<unsigned char>::Init((uint64_t)v208, *((unint64_t *)&__src + 1));
        v125 = v124 ^ 1;
        if (!*((_QWORD *)&v123 + 1))
          v125 = 1;
        if ((v125 & 1) == 0)
          memcpy(*v208, (const void *)v123, *((size_t *)&v123 + 1));
        if ((v124 & 1) == 0)
          goto LABEL_429;
        (*(void (**)(bssl *))(*(_QWORD *)v38 + 32))(v38);
        if (!bssl::SSLTranscript::Init(v212)
          || !bssl::ssl_add_client_hello(this, (bssl::SSL_HANDSHAKE *)a2))
        {
          goto LABEL_451;
        }
        finished = 4;
        *((_DWORD *)this + 5) = 4;
        goto LABEL_473;
      case 4:
        v41 = *(_QWORD *)this;
        *(_QWORD *)&v221 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v42 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v42 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v220[0] = v42;
        v220[1] = v42;
        if (!(*(unsigned int (**)(uint64_t, _OWORD *))(*(_QWORD *)v41 + 24))(v41, v220))
        {
          finished = 2;
          goto LABEL_473;
        }
        *(_QWORD *)&v43 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v43 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[3] = v43;
        __b[4] = v43;
        __b[1] = v43;
        __b[2] = v43;
        __b[0] = v43;
        LOWORD(__b[1]) = 0;
        WORD4(__b[3]) = 0;
        BYTE10(__b[3]) = 0;
        LOWORD(v218) = -21846;
        __n[4] = 50;
        if (!bssl::ssl_parse_server_hello((uint64_t)__b, &__n[4], (uint64_t)v220))
          goto LABEL_71;
        v44 = LOWORD(__b[1]);
        if (LOWORD(__b[1]) != 771)
          goto LABEL_325;
        *((_QWORD *)&__src + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v236 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&__src = 0xAAAAAAAA0001002BLL;
        CBS_init((_QWORD *)&__src + 1, 0, 0);
        v243 = __b[4];
        *(_QWORD *)&v240 = &__src;
        if (!bssl::ssl_parse_extensions(&v243, &__n[4], (uint64_t *)&v240, 1, 1))
          goto LABEL_71;
        if (BYTE3(__src))
        {
          if (!CBS_get_u16((unsigned __int16 **)&__src + 1, &v218) || CBS_len((uint64_t)&__src + 8))
          {
            __n[4] = 50;
LABEL_71:
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, __n[4]);
            goto LABEL_451;
          }
          v44 = (unsigned __int16)v218;
        }
        else
        {
          v44 = LOWORD(__b[1]);
LABEL_325:
          LOWORD(v218) = v44;
        }
        if (!bssl::ssl_supports_version(this, (const bssl::SSL_HANDSHAKE *)v44))
        {
          ERR_put_error(16, 0, 240, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 782);
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 70);
          goto LABEL_451;
        }
        v133 = *(_QWORD *)(v41 + 48);
        v134 = *(unsigned __int16 *)(v133 + 220);
        if (((v134 >> 5) & 1) != (v134 & 2) >> 1)
          bssl::ssl_client_handshake();
        if ((v134 & 2) != 0)
        {
          if ((unsigned __int16)v218 != *(unsigned __int16 *)(v41 + 16))
          {
            ERR_put_error(16, 0, 246, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 795);
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 70);
            goto LABEL_451;
          }
        }
        else
        {
          *(_WORD *)(v41 + 16) = (_WORD)v218;
          *(_WORD *)(v133 + 220) |= 2u;
          bssl::SSLAEADContext::SetVersionIfNullCipher(*(_QWORD *)(*(_QWORD *)(v41 + 48) + 272), *(_WORD *)(v41 + 16));
        }
        if (bssl::ssl_protocol_version((bssl *)v41, v132) >= 0x304)
        {
          v40 = 5;
          goto LABEL_471;
        }
        std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](v206, 0);
        std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](v205, 0);
        bssl::ssl_done_writing_client_hello(this, v135);
        v136 = *((_DWORD *)this + 400);
        if ((v136 & 0x1000) != 0)
        {
          *((_DWORD *)this + 400) = v136 & 0xFFFFBFFF;
          ERR_put_error(16, 0, 278, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 820);
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 70);
          goto LABEL_451;
        }
        v137 = *(_QWORD *)(v41 + 48);
        if (*((_QWORD *)this + 195))
          *(_DWORD *)(v137 + 216) = 2;
        v138 = (_OWORD *)CBS_data((uint64_t)&__b[1] + 8);
        v139 = v138[1];
        *(_OWORD *)(v137 + 16) = *v138;
        *(_OWORD *)(v137 + 32) = v139;
        if ((*(_BYTE *)(*(_QWORD *)(v41 + 48) + 220) & 0x20) == 0
          && bssl::ssl_supports_version(this, (const bssl::SSL_HANDSHAKE *)0x304))
        {
          v140 = 0;
          v141 = *(_QWORD *)(v41 + 48) + 40;
          while (*(unsigned __int8 *)(v141 + v140) == bssl::kTLS12DowngradeRandom[v140])
          {
            if (++v140 == 8)
            {
LABEL_438:
              ERR_put_error(16, 0, 297, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 848);
              bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
              goto LABEL_451;
            }
          }
          v164 = 0;
          while (*(unsigned __int8 *)(v141 + v164) == bssl::kTLS13DowngradeRandom[v164])
          {
            if (++v164 == 8)
              goto LABEL_438;
          }
          v166 = 0;
          while (*(unsigned __int8 *)(v141 + v166) == bssl::kJDK11DowngradeRandom[v166])
          {
            if (++v166 == 8)
              goto LABEL_438;
          }
        }
        cipher_by_value = SSL_get_cipher_by_value(WORD4(__b[3]));
        v168 = (uint64_t)cipher_by_value;
        v169 = *(_QWORD *)(*((_QWORD *)this + 1) + 64);
        if (!cipher_by_value
          || (cipher_by_value[5] & (8 * (v169 == 0))) != 0
          || (cipher_by_value[6] & (4 * (v169 == 0))) != 0
          || (min_version = SSL_CIPHER_get_min_version(cipher_by_value),
              min_version > bssl::ssl_protocol_version((bssl *)v41, v171))
          || (max_version = SSL_CIPHER_get_max_version(v168),
              max_version < bssl::ssl_protocol_version((bssl *)v41, v173))
          || (ciphers = SSL_get_ciphers((const SSL *)v41), !sk_find(ciphers, 0)))
        {
          ERR_put_error(16, 0, 242, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 864);
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
          goto LABEL_451;
        }
        *((_QWORD *)this + 196) = v168;
        v175 = (ssl_session_st *)*((unsigned __int8 *)this + 1643);
        if (*((_BYTE *)this + 1643) && CBS_mem_equal((uint64_t)&__b[2] + 8, __dst, (uint64_t)v175))
        {
          v176 = *(_QWORD *)(v41 + 104);
          if (!v176 || *(_DWORD *)(*(_QWORD *)(v41 + 48) + 216) == 2)
          {
            ERR_put_error(16, 0, 286, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 882);
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
            goto LABEL_451;
          }
          if (*(unsigned __int16 *)(v176 + 4) != *(unsigned __int16 *)(v41 + 16))
          {
            ERR_put_error(16, 0, 188, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 887);
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
            goto LABEL_451;
          }
          if (*(_QWORD *)(v176 + 208) != *((_QWORD *)this + 196))
          {
            ERR_put_error(16, 0, 187, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 892);
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
            goto LABEL_451;
          }
          if (!bssl::ssl_session_is_context_valid(this, (const bssl::SSL_HANDSHAKE *)v176, v175))
          {
            ERR_put_error(16, 0, 101, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 899);
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
            goto LABEL_451;
          }
          v198 = *(_QWORD *)(v41 + 48);
          v199 = *(_WORD *)(v198 + 220);
          if ((v199 & 0x20) != 0)
            bssl::ssl_client_handshake();
          *(_WORD *)(v198 + 220) = v199 | 0x40;
        }
        else
        {
          bssl::ssl_set_session((ssl_st **)v41, 0, v175);
          if ((bssl::ssl_get_new_session(this, v188) & 1) == 0)
            goto LABEL_430;
          v189 = CBS_len((uint64_t)&__b[2] + 8);
          v190 = *v215;
          *(_DWORD *)&(*v215)->master_key[44] = v189;
          v191 = (const void *)CBS_data((uint64_t)&__b[2] + 8);
          v193 = CBS_len((uint64_t)&__b[2] + 8);
          if (v193)
            memcpy(&v190->session_id_length, v191, v193);
          *(_QWORD *)(*((_QWORD *)this + 192) + 208) = *((_QWORD *)this + 196);
        }
        v194 = (bssl *)bssl::ssl_protocol_version((bssl *)v41, v192);
        if (!bssl::SSLTranscript::InitHash((size_t **)v212, v194, *((const ssl_cipher_st **)this + 196))
          || (bssl::ssl_hash_message((uint64_t)this, (uint64_t)v220) & 1) == 0)
        {
          goto LABEL_430;
        }
        if (*(_QWORD *)(v41 + 104) || !bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 196), v195))
          bssl::SSLTranscript::FreeBuffer(v212);
        if (BYTE10(__b[3]))
        {
          ERR_put_error(16, 0, 238, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 939);
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
          goto LABEL_451;
        }
        if ((bssl::ssl_parse_serverhello_tlsext((uint64_t)this, &__b[4]) & 1) == 0)
        {
          ERR_put_error(16, 0, 190, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 945);
          goto LABEL_451;
        }
        v196 = *(_QWORD *)(v41 + 104);
        if (!v196 || (v197 = *(_BYTE *)(v196 + 448) & 1, ((*((_DWORD *)this + 400) >> 17) & 1) == v197))
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v41 + 32))(v41);
          if (*(_QWORD *)(v41 + 104))
          {
            if (*(_BYTE *)(*(_QWORD *)(v41 + 120) + 496)
              && bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 196), (const ssl_cipher_st *)a2))
            {
              v40 = 9;
            }
            else
            {
              v40 = 18;
            }
          }
          else
          {
            v40 = 6;
          }
          goto LABEL_471;
        }
        if (v197)
          ERR_put_error(16, 0, 204, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 952);
        else
          ERR_put_error(16, 0, 205, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 954);
        bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 40);
        goto LABEL_451;
      case 5:
        finished = bssl::tls13_client_handshake(this, (ssl_st *)a2);
        if ((_DWORD)finished != 1)
          goto LABEL_473;
        v49 = 21;
        goto LABEL_183;
      case 6:
        v65 = *(bssl **)this;
        if (!bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 196), (const ssl_cipher_st *)a2))
          goto LABEL_134;
        *(_QWORD *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v66 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v66 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v66;
        __b[1] = v66;
        if (!(*(unsigned int (**)(bssl *, __int128 *))(*(_QWORD *)v65 + 24))(v65, __b))
          goto LABEL_180;
        if (!bssl::ssl_check_message_type(v65, (uint64_t)__b, 11)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)__b))
        {
          goto LABEL_451;
        }
        v220[0] = *(__int128 *)((char *)__b + 8);
        LOBYTE(__src) = 50;
        if ((bssl::ssl_parse_cert_chain((char *)&__src, (unint64_t **)&(*v215)->sess_cert, v211, 0, (unsigned __int8 **)v220, *(_QWORD ***)(*((_QWORD *)v65 + 15) + 792)) & 1) == 0)
        {
          bssl::ssl_send_alert(v65, (ssl_st *)2, __src);
          goto LABEL_451;
        }
        if (!sk_num((const STACK *)(*v215)->sess_cert)
          || CBS_len((uint64_t)v220)
          || ((*(uint64_t (**)(SSL_SESSION *))(*(_QWORD *)(*((_QWORD *)v65 + 15) + 8) + 48))(*v215) & 1) == 0)
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1015);
          bssl::ssl_send_alert(v65, (ssl_st *)2, 50);
          goto LABEL_451;
        }
        v67 = (ssl_st *)*((_QWORD *)this + 191);
        sk_value(*(const STACK **)(*((_QWORD *)this + 192) + 144), 0);
        if ((bssl::ssl_check_leaf_certificate((uint64_t)this, v67) & 1) == 0)
        {
          bssl::ssl_send_alert(v65, (ssl_st *)2, 47);
          goto LABEL_451;
        }
        (*(void (**)(bssl *))(*(_QWORD *)v65 + 32))(v65);
LABEL_134:
        v40 = 7;
        goto LABEL_471;
      case 7:
        if ((*((_BYTE *)this + 1600) & 0x40) == 0)
          goto LABEL_109;
        v38 = *(bssl **)this;
        *(_QWORD *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v73 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v73 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v73;
        __b[1] = v73;
        if (!(*(unsigned int (**)(bssl *, __int128 *))(*(_QWORD *)v38 + 24))(v38, __b))
          goto LABEL_180;
        if (BYTE1(__b[0]) != 22)
          goto LABEL_109;
        if (!bssl::ssl_hash_message((uint64_t)this, (uint64_t)__b))
          goto LABEL_451;
        v220[0] = *(__int128 *)((char *)__b + 8);
        *(_QWORD *)&__src = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&__src + 1) = 0xAAAAAAAAAAAAAAAALL;
        LOBYTE(v243) = -86;
        if (!CBS_get_u8(v220, &v243)
          || v243 != 1
          || !CBS_get_u24_length_prefixed((unsigned __int8 **)v220, (unint64_t *)&__src)
          || !CBS_len((uint64_t)&__src)
          || CBS_len((uint64_t)v220))
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1064);
          bssl::ssl_send_alert(v38, (ssl_st *)2, 50);
          goto LABEL_451;
        }
        v162 = *v215;
        v163 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&__src, *(_QWORD ***)(*((_QWORD *)v38 + 15) + 792));
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)&v162->tlsext_tick, v163);
        if (!(*v215)->tlsext_tick)
          goto LABEL_429;
        (*(void (**)(bssl *))(*(_QWORD *)v38 + 32))(v38);
LABEL_109:
        v40 = 8;
        goto LABEL_471;
      case 8:
        if (bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 196), (const ssl_cipher_st *)a2))
        {
          v72 = bssl::ssl_verify_peer_cert(this, (bssl::SSL_HANDSHAKE *)a2);
          if (v72 == 1)
            goto LABEL_451;
          v48 = v72 == 2;
          if (v72 == 2)
            v49 = 8;
          else
            v49 = 10;
LABEL_149:
          if (v48)
            finished = 16;
          else
            finished = 1;
        }
        else
        {
          finished = 1;
          v49 = 10;
        }
LABEL_183:
        *((_DWORD *)this + 5) = v49;
        goto LABEL_473;
      case 9:
        if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)this + 120) + 496))
          bssl::ssl_client_handshake();
        v47 = bssl::ssl_reverify_peer_cert((bssl **)this, (bssl::SSL_HANDSHAKE *)1);
        if (v47 == 1)
          goto LABEL_451;
        v48 = v47 == 2;
        if (v47 == 2)
          v49 = 9;
        else
          v49 = 18;
        goto LABEL_149;
      case 10:
        v41 = *(_QWORD *)this;
        *(_QWORD *)&v221 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v68 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v68 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v220[0] = v68;
        v220[1] = v68;
        if (!(*(unsigned int (**)(uint64_t, _OWORD *))(*(_QWORD *)v41 + 24))(v41, v220))
          goto LABEL_180;
        if (BYTE1(v220[0]) == 12)
        {
          if (!bssl::ssl_hash_message((uint64_t)this, (uint64_t)v220))
            goto LABEL_451;
          v69 = *((_QWORD *)this + 196);
          v70 = *(_DWORD *)(v69 + 20);
          v71 = *(_DWORD *)(v69 + 24);
          __src = *(_OWORD *)((char *)v220 + 8);
          if ((v71 & 4) != 0)
          {
            *((_QWORD *)&__b[0] + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_QWORD *)&__b[0] = 0xAAAAAAAAAAAAAAAALL;
            if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&__src, (unint64_t *)__b))
            {
              ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1151);
              v117 = 50;
              goto LABEL_323;
            }
            if ((unint64_t)CBS_len((uint64_t)__b) > 0x80 || CBS_contains_zero_byte((uint64_t)__b))
            {
              ERR_put_error(16, 0, 136, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1165);
              v117 = 40;
              goto LABEL_323;
            }
            *(_QWORD *)&v243 = 0;
            if (CBS_len((uint64_t)__b) && !CBS_strdup((uint64_t)__b, (_QWORD **)&v243))
            {
LABEL_430:
              bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 80);
              goto LABEL_451;
            }
            std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100](v210, (_QWORD *)v243);
            if ((v70 & 2) == 0)
              goto LABEL_142;
          }
          else if ((v70 & 2) == 0)
          {
LABEL_142:
            if ((v70 & 8) == 0)
            {
              ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1211);
              bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 10);
              goto LABEL_451;
            }
            goto LABEL_401;
          }
          LOBYTE(v240) = -86;
          LOWORD(v243) = -21846;
          *((_QWORD *)&__b[0] + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_QWORD *)&__b[0] = 0xAAAAAAAAAAAAAAAALL;
          if (CBS_get_u8(&__src, &v240)
            && v240 == 3
            && CBS_get_u16((unsigned __int16 **)&__src, &v243)
            && CBS_get_u8_length_prefixed((unsigned __int8 **)&__src, (unint64_t *)__b))
          {
            if (bssl::tls1_check_group_id((bssl **)this, (const ssl_st *)(unsigned __int16)v243))
            {
              HIWORD((*v215)->key_arg_length) = v243;
              v153 = __b[0];
              v154 = bssl::Array<unsigned char>::Init((uint64_t)v202, *((unint64_t *)&__b[0] + 1));
              v155 = v154 ^ 1;
              if (!*((_QWORD *)&v153 + 1))
                v155 = 1;
              if ((v155 & 1) == 0)
                memcpy(*v202, (const void *)v153, *((size_t *)&v153 + 1));
              if ((v154 & 1) == 0)
                goto LABEL_451;
LABEL_401:
              *(_QWORD *)&v243 = 0xAAAAAAAAAAAAAAAALL;
              *((_QWORD *)&v243 + 1) = 0xAAAAAAAAAAAAAAAALL;
              v156 = CBS_data((uint64_t)v220 + 8);
              v157 = CBS_len((uint64_t)v220 + 8);
              v158 = CBS_len((uint64_t)&__src);
              CBS_init(&v243, v156, v157 - v158);
              if (!bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 196), v159))
              {
                if (v71 != 4)
                  bssl::ssl_client_handshake();
                if (CBS_len((uint64_t)&__src))
                {
                  ERR_put_error(16, 0, 151, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1282);
                  bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 50);
LABEL_451:
                  finished = 0;
                  goto LABEL_473;
                }
                goto LABEL_469;
              }
              *(_WORD *)&__n[4] = 0;
              if (bssl::ssl_protocol_version((bssl *)v41, v160) < 0x303)
              {
                if ((bssl::tls1_get_legacy_signature_algorithm((bssl *)&__n[4], (unsigned __int16 *)*v211, v161) & 1) == 0)
                {
                  ERR_put_error(16, 0, 193, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1240);
                  bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 43);
                  goto LABEL_451;
                }
              }
              else
              {
                if (!CBS_get_u16((unsigned __int16 **)&__src, &__n[4]))
                {
                  ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1228);
                  bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 50);
                  goto LABEL_451;
                }
                LOBYTE(__b[0]) = 50;
                if (!bssl::tls12_check_peer_sigalg(this, (const bssl::SSL_HANDSHAKE *)__b, (unsigned __int8 *)*(unsigned __int16 *)&__n[4]))
                {
                  bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, LOBYTE(__b[0]));
                  goto LABEL_451;
                }
                *(_WORD *)(*v215)->key_arg = *(_WORD *)&__n[4];
              }
              *(_QWORD *)&v240 = 0xAAAAAAAAAAAAAAAALL;
              *((_QWORD *)&v240 + 1) = 0xAAAAAAAAAAAAAAAALL;
              if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&__src, (unint64_t *)&v240)
                || CBS_len((uint64_t)&__src))
              {
                ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1249);
                bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 50);
                goto LABEL_451;
              }
              *(_QWORD *)&v177 = 0xAAAAAAAAAAAAAAAALL;
              *((_QWORD *)&v177 + 1) = 0xAAAAAAAAAAAAAAAALL;
              __b[1] = v177;
              __b[2] = v177;
              __b[0] = v177;
              CBB_zero(__b);
              v218 = 0;
              v219 = 0;
              v178 = CBS_len((uint64_t)&v243);
              if (CBB_init((uint64_t)__b, v178 + 64)
                && CBB_add_bytes((uint64_t)__b, (const void *)(*(_QWORD *)(v41 + 48) + 48), 0x20uLL)
                && CBB_add_bytes((uint64_t)__b, (const void *)(*(_QWORD *)(v41 + 48) + 16), 0x20uLL)
                && (v179 = (const void *)CBS_data((uint64_t)&v243),
                    v180 = CBS_len((uint64_t)&v243),
                    CBB_add_bytes((uint64_t)__b, v179, v180))
                && bssl::CBBFinishArray((uint64_t)__b, (uint64_t)&v218))
              {
                if (bssl::ssl_public_key_verify((bssl *)v41, v240, *((uint64_t *)&v240 + 1), (evp_pkey_st *)*(unsigned __int16 *)&__n[4], (const ssl_st *)*v211, v218, v219))
                {
                  v181 = 1;
                  goto LABEL_468;
                }
                ERR_put_error(16, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1273);
                v187 = 51;
              }
              else
              {
                ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1265);
                v187 = 80;
              }
              bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, v187);
              v181 = 0;
LABEL_468:
              bssl::Array<unsigned char>::~Array((uint64_t)&v218);
              CBB_cleanup((uint64_t)__b);
              if ((v181 & 1) == 0)
                goto LABEL_451;
LABEL_469:
              (*(void (**)(uint64_t))(*(_QWORD *)v41 + 32))(v41);
              goto LABEL_470;
            }
            ERR_put_error(16, 0, 243, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1200);
            v117 = 47;
          }
          else
          {
            ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1193);
            v117 = 50;
          }
LABEL_323:
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, v117);
          goto LABEL_451;
        }
        if (bssl::ssl_cipher_requires_server_key_exchange(*((bssl **)this + 196), (const ssl_cipher_st *)a2))
        {
          ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1129);
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 10);
          goto LABEL_451;
        }
LABEL_470:
        v40 = 11;
LABEL_471:
        *((_DWORD *)this + 5) = v40;
LABEL_472:
        finished = 1;
LABEL_473:
        if (*((_DWORD *)this + 5) != v4)
          bssl::ssl_do_info_callback(*(_QWORD *)this, (const ssl_st *)0x1001);
        if ((_DWORD)finished == 1)
          continue;
        return finished;
      case 11:
        v38 = *(bssl **)this;
        if (!bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 196), (const ssl_cipher_st *)a2))
          goto LABEL_62;
        *(_QWORD *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v39 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v39;
        __b[1] = v39;
        if (!(*(unsigned int (**)(bssl *, __int128 *))(*(_QWORD *)v38 + 24))(v38, __b))
          goto LABEL_180;
        if (BYTE1(__b[0]) == 14)
        {
          bssl::SSLTranscript::FreeBuffer(v212);
LABEL_62:
          v40 = 12;
          goto LABEL_471;
        }
        if (!bssl::ssl_check_message_type(v38, (uint64_t)__b, 13)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)__b))
        {
          goto LABEL_451;
        }
        v220[0] = *(__int128 *)((char *)__b + 8);
        *(_QWORD *)&__src = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&__src + 1) = 0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_u8_length_prefixed((unsigned __int8 **)v220, (unint64_t *)&__src))
        {
          bssl::ssl_send_alert(v38, (ssl_st *)2, 50);
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1323);
          goto LABEL_451;
        }
        v108 = __src;
        v110 = bssl::Array<unsigned char>::Init((uint64_t)v204, *((unint64_t *)&__src + 1));
        v111 = v110 ^ 1;
        if (!*((_QWORD *)&v108 + 1))
          v111 = 1;
        if ((v111 & 1) == 0)
          memcpy(*v204, (const void *)v108, *((size_t *)&v108 + 1));
        if ((v110 & 1) == 0)
        {
LABEL_429:
          bssl::ssl_send_alert(v38, (ssl_st *)2, 80);
          goto LABEL_451;
        }
        if (bssl::ssl_protocol_version(v38, v109) >= 0x303)
        {
          *(_QWORD *)&v243 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v243 + 1) = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_u16_length_prefixed((unsigned __int8 **)v220, (unint64_t *)&v243)
            || (bssl::tls1_parse_peer_sigalgs((bssl **)this, (ssl_st *)&v243) & 1) == 0)
          {
            bssl::ssl_send_alert(v38, (ssl_st *)2, 50);
            ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1337);
            goto LABEL_451;
          }
        }
        LOBYTE(v240) = 50;
        *(_QWORD *)&v243 = 0xAAAAAAAAAAAAAAAALL;
        bssl::ssl_parse_client_CA_list((uint64_t)v38, &v240, (unsigned __int8 **)v220, (STACK **)&v243);
        if ((_QWORD)v243)
        {
          if (CBS_len((uint64_t)v220))
          {
            bssl::ssl_send_alert(v38, (ssl_st *)2, 50);
            ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1352);
            finished = 0;
          }
          else
          {
            *((_DWORD *)this + 400) |= 0x20u;
            v165 = (unint64_t *)v243;
            *(_QWORD *)&v243 = 0;
            std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](v201, v165);
            (*(void (**)(bssl *))(*(_QWORD *)(*((_QWORD *)v38 + 15) + 8) + 80))(this);
            (*(void (**)(bssl *))(*(_QWORD *)v38 + 32))(v38);
            *((_DWORD *)this + 5) = 12;
            finished = 1;
          }
        }
        else
        {
          bssl::ssl_send_alert(v38, (ssl_st *)2, v240);
          finished = 0;
        }
        std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&v243, 0);
        goto LABEL_473;
      case 12:
        v45 = *(bssl **)this;
        *(_QWORD *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v46 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v46 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v46;
        __b[1] = v46;
        if (!(*(unsigned int (**)(bssl *, __int128 *))(*(_QWORD *)v45 + 24))(v45, __b))
          goto LABEL_180;
        if (!bssl::ssl_check_message_type(v45, (uint64_t)__b, 14)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)__b))
        {
          goto LABEL_451;
        }
        if (CBS_len((uint64_t)__b + 8))
        {
          bssl::ssl_send_alert(v45, (ssl_st *)2, 50);
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1380);
          goto LABEL_451;
        }
        if ((*(unsigned int (**)(bssl *))(*(_QWORD *)v45 + 40))(v45))
        {
          bssl::ssl_send_alert(v45, (ssl_st *)2, 10);
          ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1387);
          goto LABEL_451;
        }
        (*(void (**)(bssl *))(*(_QWORD *)v45 + 32))(v45);
        v40 = 13;
        goto LABEL_471;
      case 13:
        if ((*((_BYTE *)this + 1600) & 0x20) == 0)
          goto LABEL_123;
        v82 = *(bssl **)this;
        if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 216) == 2)
        {
          SSL_certs_clear(*(_QWORD *)this);
        }
        else
        {
          v88 = *(_QWORD *)(*((_QWORD *)this + 1) + 32);
          v89 = *(uint64_t (**)(_QWORD, _QWORD))(v88 + 72);
          if (v89)
          {
            v90 = v89(*(_QWORD *)this, *(_QWORD *)(v88 + 80));
            if (!v90)
            {
              bssl::ssl_send_alert(v82, (ssl_st *)2, 80);
              ERR_put_error(16, 0, 126, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1414);
              goto LABEL_451;
            }
            if (v90 < 0)
            {
              *((_DWORD *)this + 5) = 13;
              finished = 8;
              goto LABEL_473;
            }
          }
        }
        if (!bssl::ssl_has_certificate(this, (const bssl::SSL_HANDSHAKE *)a2))
          bssl::SSLTranscript::FreeBuffer(v212);
        if (bssl::ssl_on_certificate_selected(this, v91)
          && bssl::ssl_output_cert_chain(this, (bssl::SSL_HANDSHAKE *)a2))
        {
LABEL_123:
          v40 = 14;
          goto LABEL_471;
        }
        goto LABEL_451;
      case 14:
        v26 = *(bssl **)this;
        *(_QWORD *)&v27 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v236 = v27;
        v237 = v27;
        __src = v27;
        CBB_zero(&__src);
        *(_QWORD *)&v28 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v244 = v28;
        v245 = v28;
        v243 = v28;
        if (((*(uint64_t (**)(bssl *, __int128 *, __int128 *, uint64_t))(*(_QWORD *)v26 + 88))(v26, &__src, &v243, 16) & 1) == 0)
        {
          finished = 0;
          goto LABEL_367;
        }
        v218 = 0;
        v219 = 0;
        v30 = (bssl *)*((_QWORD *)this + 196);
        v31 = *((_DWORD *)v30 + 5);
        v32 = *((_DWORD *)v30 + 6);
        if (!bssl::ssl_cipher_uses_certificate_auth(v30, v29))
          goto LABEL_52;
        v33 = sk_value((const STACK *)(*v215)->sess_cert, 0);
        *((_QWORD *)&__b[0] + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&__b[0] = 0xAAAAAAAAAAAAAAAALL;
        CRYPTO_BUFFER_init_CBS((uint64_t)v33, __b);
        if ((bssl::ssl_cert_check_key_usage(__b, 2 * (v31 & 1u)) & 1) != 0)
          goto LABEL_52;
        if ((*(_WORD *)(*((_QWORD *)this + 1) + 313) & 0x10) != 0 || EVP_PKEY_id((uint64_t)*v211) != 6)
          goto LABEL_365;
        ERR_clear_error();
        *(_WORD *)(*((_QWORD *)v26 + 6) + 220) |= 0x8000u;
LABEL_52:
        *(_QWORD *)&v34 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[14] = v34;
        __b[15] = v34;
        __b[12] = v34;
        __b[13] = v34;
        __b[10] = v34;
        __b[11] = v34;
        __b[8] = v34;
        __b[9] = v34;
        __b[6] = v34;
        __b[7] = v34;
        __b[4] = v34;
        __b[5] = v34;
        __b[2] = v34;
        __b[3] = v34;
        __b[0] = v34;
        __b[1] = v34;
        if ((v32 & 4) != 0)
        {
          v92 = *((_QWORD *)this + 1);
          if (!*(_QWORD *)(v92 + 64))
          {
            v36 = 1482;
            v37 = 196;
            goto LABEL_271;
          }
          LOBYTE(v227) = 0;
          v225 = 0u;
          v226 = 0u;
          v223 = 0u;
          v224 = 0u;
          v221 = 0u;
          v222 = 0u;
          memset(v220, 0, sizeof(v220));
          v93 = (*(uint64_t (**)(bssl *, _QWORD, _OWORD *, uint64_t, __int128 *, uint64_t))(v92 + 64))(v26, *v210, v220, 129, __b, 256);
          v35 = v93;
          if (!v93)
          {
            ERR_put_error(16, 0, 195, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1492);
            bssl::ssl_send_alert(v26, (ssl_st *)2, 40);
            goto LABEL_365;
          }
          if (v93 >= 0x101)
            __assert_rtn("do_send_client_key_exchange", "handshake_client.cc", 1496, "psk_len <= PSK_MAX_PSK_LEN");
          v94 = *v215;
          v95 = OPENSSL_strdup((const char *)v220);
          std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)&v94->sid_ctx[28], v95);
          if (!*(_QWORD *)&(*v215)->sid_ctx[28])
            goto LABEL_365;
          *(_QWORD *)&v96 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v96 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v241 = v96;
          v242 = v96;
          v240 = v96;
          if (!CBB_add_u16_length_prefixed((uint64_t *)&v243, (uint64_t)&v240))
            goto LABEL_365;
          v97 = OPENSSL_strnlen((uint64_t)v220, 0x81uLL);
          if (!CBB_add_bytes((uint64_t)&v240, v220, v97) || !CBB_flush((uint64_t *)&v243))
            goto LABEL_365;
        }
        else
        {
          v35 = 0;
        }
        if ((v31 & 1) != 0)
        {
          OPENSSL_free(v218);
          v218 = 0;
          v219 = 0;
          v218 = OPENSSL_malloc(0x30uLL);
          if (!v218)
            goto LABEL_365;
          v219 = 48;
          v112 = (const RSA *)EVP_PKEY_get0_RSA((uint64_t)*v211);
          if (!v112)
          {
            ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1521);
            finished = 0;
            goto LABEL_366;
          }
          *(_BYTE *)v218 = *((_BYTE *)this + 1605);
          *((_BYTE *)v218 + 1) = *((_BYTE *)this + 1604);
          if (!RAND_bytes((unsigned __int8 *)v218 + 2, 46))
            goto LABEL_365;
          *(_QWORD *)&v113 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v113 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v220[1] = v113;
          v221 = v113;
          v220[0] = v113;
          *(_QWORD *)&v240 = 0xAAAAAAAAAAAAAAAALL;
          *(_QWORD *)&__n[4] = 0xAAAAAAAAAAAAAAAALL;
          if (!CBB_add_u16_length_prefixed((uint64_t *)&v243, (uint64_t)v220))
            goto LABEL_365;
          v114 = RSA_size(v112);
          if (!CBB_reserve((uint64_t)v220, &v240, v114))
            goto LABEL_365;
          v115 = v240;
          v116 = RSA_size(v112);
          if (!RSA_encrypt((uint64_t)v112, (uint64_t *)&__n[4], v115, v116, (uint64_t)v218, v219, 1)
            || !CBB_did_write((uint64_t)v220, *(uint64_t *)&__n[4])
            || !CBB_flush((uint64_t *)&v243))
          {
            goto LABEL_365;
          }
          goto LABEL_317;
        }
        if ((v31 & 2) == 0)
        {
          if ((v31 & 8) == 0)
          {
            bssl::ssl_send_alert(v26, (ssl_st *)2, 40);
            v36 = 1571;
            v37 = 68;
LABEL_271:
            ERR_put_error(16, 0, v37, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", v36);
            finished = 0;
            goto LABEL_366;
          }
          if (!bssl::Array<unsigned char>::Init((uint64_t)&v218, v35))
            goto LABEL_365;
          if (v219)
            bzero(v218, v219);
          goto LABEL_317;
        }
        *(_QWORD *)&v118 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v118 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v220[1] = v118;
        v221 = v118;
        v220[0] = v118;
        if (!CBB_add_u8_length_prefixed((uint64_t *)&v243, (uint64_t)v220))
          goto LABEL_365;
        *(_QWORD *)&v240 = 0xAAAAAAAAAAAAAAAALL;
        bssl::SSLKeyShare::Create((_QWORD *)HIWORD((*v215)->key_arg_length), &v240);
        v119 = 50;
        __n[4] = 50;
        if (!(_QWORD)v240)
          goto LABEL_363;
        if (((*(uint64_t (**)(_QWORD, _OWORD *, void **, _BYTE *, _QWORD, _QWORD))(*(_QWORD *)v240 + 32))(v240, v220, &v218, &__n[4], *((_QWORD *)this + 87), *((_QWORD *)this + 88)) & 1) != 0)
        {
          if (CBB_flush((uint64_t *)&v243))
          {
            OPENSSL_free(*v202);
            *v202 = 0;
            v202[1] = 0;
            std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)&v240, 0);
LABEL_317:
            if ((v32 & 4) == 0)
            {
LABEL_318:
              if (bssl::ssl_add_message_cbb((uint64_t)v26, (uint64_t)&__src))
              {
                master_secret = bssl::tls1_generate_master_secret((uint64_t *)this, (_BYTE *)(*((_QWORD *)this + 192) + 16), (char *)v218, v219);
                v131 = *v215;
                *(_DWORD *)&(*v215)->key_arg[4] = master_secret;
                if (master_secret)
                {
                  LOBYTE(v131[1].verify_result) = v131[1].verify_result & 0xFE | ((*((_DWORD *)this + 400) & 0x20000) != 0);
                  *((_DWORD *)this + 5) = 15;
                  finished = 1;
                  goto LABEL_366;
                }
              }
              goto LABEL_365;
            }
            *(_QWORD *)&v142 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v142 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v220[1] = v142;
            v221 = v142;
            v220[0] = v142;
            CBB_zero(v220);
            *(_QWORD *)&v143 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v143 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v241 = v143;
            v242 = v143;
            v240 = v143;
            if (CBB_init((uint64_t)v220, v219 + v35 + 4)
              && CBB_add_u16_length_prefixed((uint64_t *)v220, (uint64_t)&v240)
              && CBB_add_bytes((uint64_t)&v240, v218, v219)
              && CBB_add_u16_length_prefixed((uint64_t *)v220, (uint64_t)&v240)
              && CBB_add_bytes((uint64_t)&v240, __b, v35)
              && bssl::CBBFinishArray((uint64_t)v220, (uint64_t)&v218))
            {
              CBB_cleanup((uint64_t)v220);
              goto LABEL_318;
            }
            CBB_cleanup((uint64_t)v220);
LABEL_365:
            finished = 0;
LABEL_366:
            OPENSSL_free(v218);
LABEL_367:
            CBB_cleanup((uint64_t)&__src);
            goto LABEL_473;
          }
        }
        else
        {
          v119 = __n[4];
LABEL_363:
          bssl::ssl_send_alert(v26, (ssl_st *)2, v119);
        }
        std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((_QWORD **)&v240, 0);
        goto LABEL_365;
      case 15:
        if ((*((_BYTE *)this + 1600) & 0x20) == 0
          || (v52 = *(bssl **)this, !bssl::ssl_has_certificate(this, (const bssl::SSL_HANDSHAKE *)a2)))
        {
          v40 = 16;
          goto LABEL_471;
        }
        if (!bssl::ssl_has_private_key(this, (const ssl_st *)a2))
          bssl::ssl_client_handshake();
        *(_QWORD *)&v53 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v53 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[1] = v53;
        __b[2] = v53;
        __b[0] = v53;
        CBB_zero(__b);
        *(_QWORD *)&v54 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v54 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v220[1] = v54;
        v221 = v54;
        v220[0] = v54;
        v236 = v54;
        v237 = v54;
        __src = v54;
        if (((*(uint64_t (**)(bssl *, __int128 *, _OWORD *, uint64_t))(*(_QWORD *)v52 + 88))(v52, __b, v220, 15) & 1) == 0)goto LABEL_277;
        LOWORD(v218) = -21846;
        if ((bssl::tls1_choose_signature_algorithm(this, (ssl_st *)&v218, v55) & 1) == 0)
        {
          bssl::ssl_send_alert(v52, (ssl_st *)2, 40);
LABEL_277:
          finished = 0;
          goto LABEL_278;
        }
        if (bssl::ssl_protocol_version(v52, v56) < 0x303
          || CBB_add_u16((uint64_t)v220, (unsigned __int16)v218))
        {
          v57 = EVP_PKEY_size(*((EVP_PKEY **)this + 190));
          *(_QWORD *)&v243 = 0xAAAAAAAAAAAAAAAALL;
          if (!CBB_add_u16_length_prefixed((uint64_t *)v220, (uint64_t)&__src)
            || !CBB_reserve((uint64_t)&__src, &v243, v57))
          {
            goto LABEL_277;
          }
          *(_QWORD *)&v240 = v57;
          v58 = bssl::ssl_private_key_sign((uint64_t)this, (ssl_st *)v243, (unint64_t *)&v240, v57, (evp_pkey_st *)(unsigned __int16)v218, *(unsigned __int8 **)(*((_QWORD *)this + 53) + 8), **((_QWORD **)this + 53));
          if (v58 == 1)
          {
            finished = 9;
            v59 = 15;
          }
          else
          {
            if (v58 == 2
              || !CBB_did_write((uint64_t)&__src, v240)
              || !bssl::ssl_add_message_cbb((uint64_t)v52, (uint64_t)__b))
            {
              goto LABEL_277;
            }
            bssl::SSLTranscript::FreeBuffer(v212);
            finished = 1;
            v59 = 16;
          }
          *((_DWORD *)this + 5) = v59;
        }
        else
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1631);
          finished = 0;
        }
LABEL_278:
        CBB_cleanup((uint64_t)__b);
        goto LABEL_473;
      case 16:
        v23 = *(_QWORD **)this;
        *((_DWORD *)this + 400) |= 0x2000000u;
        if (!(*(unsigned int (**)(_QWORD *, ssl_session_st *))(*v23 + 112))(v23, a2)
          || !bssl::tls1_change_cipher_state((uint64_t *)this, 1))
        {
          goto LABEL_451;
        }
        v24 = *((_DWORD *)this + 400);
        if ((v24 & 0x8000) != 0)
        {
          v101 = *(_DWORD *)(v23[6] + 488);
          *(_QWORD *)&v102 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v102 + 1) = 0xAAAAAAAAAAAAAAAALL;
          __b[1] = v102;
          __b[2] = v102;
          __b[0] = v102;
          CBB_zero(__b);
          *(_QWORD *)&v103 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v103 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v220[1] = v103;
          v221 = v103;
          v220[0] = v103;
          v236 = v103;
          v237 = v103;
          __src = v103;
          if (!(*(unsigned int (**)(_QWORD *, __int128 *, _OWORD *, uint64_t))(*v23 + 88))(v23, __b, v220, 67)|| !CBB_add_u8_length_prefixed((uint64_t *)v220, (uint64_t)&__src)|| !CBB_add_bytes((uint64_t)&__src, *(const void **)(v23[6] + 480), *(_QWORD *)(v23[6] + 488))|| !CBB_add_u8_length_prefixed((uint64_t *)v220, (uint64_t)&__src)|| !CBB_add_bytes((uint64_t)&__src, &bssl::do_send_client_finished(bssl::SSL_HANDSHAKE *)::kZero, 32 - (((_BYTE)v101 + 2) & 0x1F))|| (bssl::ssl_add_message_cbb((uint64_t)v23, (uint64_t)__b) & 1) == 0)
          {
            ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1691);
            CBB_cleanup((uint64_t)__b);
            goto LABEL_451;
          }
          CBB_cleanup((uint64_t)__b);
          if ((*((_DWORD *)this + 400) & 0x4000000) == 0)
            goto LABEL_46;
        }
        else if ((v24 & 0x4000000) == 0)
        {
          goto LABEL_46;
        }
        *(_QWORD *)&v104 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v104 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[1] = v104;
        __b[2] = v104;
        __b[0] = v104;
        CBB_zero(__b);
        *(_QWORD *)&v105 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v105 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v220[1] = v105;
        v221 = v105;
        v220[0] = v105;
        if (!(*(unsigned int (**)(_QWORD *, __int128 *, _OWORD *, uint64_t))(*v23 + 88))(v23, __b, v220, 203)|| !bssl::tls1_write_channel_id((uint64_t)this, (uint64_t *)v220, v106, v107)|| (bssl::ssl_add_message_cbb((uint64_t)v23, (uint64_t)__b) & 1) == 0)
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1702);
          CBB_cleanup((uint64_t)__b);
          goto LABEL_451;
        }
        CBB_cleanup((uint64_t)__b);
LABEL_46:
        if (!bssl::ssl_send_finished(this, (bssl::SSL_HANDSHAKE *)a2))
          goto LABEL_451;
        *((_DWORD *)this + 5) = 17;
LABEL_48:
        finished = 4;
        goto LABEL_473;
      case 17:
        v62 = *(_QWORD *)this;
        if (*(_QWORD *)(*(_QWORD *)this + 104))
        {
          v40 = 21;
          goto LABEL_471;
        }
        if (!bssl::tls1_record_handshake_hashes_for_channel_id(this, (bssl::SSL_HANDSHAKE *)a2))
          goto LABEL_451;
        *((_DWORD *)this + 5) = 18;
        if ((SSL_get_mode(v62) & 0x80) == 0)
          goto LABEL_472;
        v85 = *(const SSL **)this;
        if (SSL_is_dtls(*(unsigned __int8 ***)this))
          goto LABEL_472;
        if (SSL_version(v85) != 771)
          goto LABEL_472;
        v86 = *((_QWORD *)this + 196);
        if (*(_DWORD *)(v86 + 20) != 2)
          goto LABEL_472;
        if (*(_DWORD *)(v86 + 32) != 8)
          goto LABEL_472;
        handshake_func = v85->handshake_func;
        if (*((_DWORD *)handshake_func + 54) == 2
          || (*(_WORD *)&v85->s2[2].challenge[4] & 0x100) == 0
          && !*((_QWORD *)handshake_func + 63)
          && !*((_QWORD *)handshake_func + 61))
        {
          goto LABEL_472;
        }
        if ((*(_WORD *)(*(_QWORD *)(v62 + 48) + 220) & 0x20) != 0)
          goto LABEL_472;
        *((_DWORD *)this + 400) |= 0x4400u;
        finished = 12;
        goto LABEL_473;
      case 18:
        if ((*((_BYTE *)this + 1602) & 1) == 0)
          goto LABEL_136;
        v83 = *(bssl **)this;
        *(_QWORD *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v84 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v84 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v84;
        __b[1] = v84;
        if (!(*(unsigned int (**)(bssl *, __int128 *))(*(_QWORD *)v83 + 24))(v83, __b))
        {
LABEL_180:
          finished = 3;
          goto LABEL_473;
        }
        if (!bssl::ssl_check_message_type(v83, (uint64_t)__b, 4)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)__b))
        {
          goto LABEL_451;
        }
        v220[0] = *(__int128 *)((char *)__b + 8);
        *(_QWORD *)&__src = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&__src + 1) = 0xAAAAAAAAAAAAAAAALL;
        LODWORD(v240) = -1431655766;
        if (!CBS_get_u32((uint64_t *)v220, (int *)&v240)
          || !CBS_get_u16_length_prefixed((unsigned __int8 **)v220, (unint64_t *)&__src)
          || CBS_len((uint64_t)v220))
        {
          bssl::ssl_send_alert(v83, (ssl_st *)2, 50);
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1806);
          goto LABEL_451;
        }
        if (!CBS_len((uint64_t)&__src))
        {
          *((_DWORD *)this + 400) &= ~0x10000u;
          (*(void (**)(bssl *))(*(_QWORD *)v83 + 32))(v83);
          goto LABEL_136;
        }
        v145 = (bssl *)*((_QWORD *)v83 + 13);
        if (!v145)
          goto LABEL_382;
        if (*v215)
          bssl::ssl_client_handshake();
        bssl::SSL_SESSION_dup(v145, (ssl_session_st *)2, &v243);
        v146 = (SSL_SESSION *)v243;
        *(_QWORD *)&v243 = 0;
        std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v215, v146);
        std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)&v243, 0);
        if (*v215)
        {
          LOBYTE((*v215)[1].sid_ctx_length) |= 1u;
LABEL_382:
          bssl::ssl_session_rebase_time(v83, (ssl_st *)*v215, v144);
          p_prev = (void **)&(*v215)->prev;
          v148 = __src;
          v149 = bssl::Array<unsigned char>::Init((uint64_t)p_prev, *((unint64_t *)&__src + 1));
          v150 = v149 ^ 1;
          if (!*((_QWORD *)&v148 + 1))
            v150 = 1;
          if ((v150 & 1) == 0)
            memcpy(*p_prev, (const void *)v148, *((size_t *)&v148 + 1));
          if (v149)
          {
            *(_DWORD *)(*((_QWORD *)this + 192) + 380) = v240;
            v151 = (const unsigned __int8 *)CBS_data((uint64_t)&__src);
            v152 = CBS_len((uint64_t)&__src);
            SHA256(v151, v152, (unsigned __int8 *)(*((_QWORD *)this + 192) + 68));
            *(_DWORD *)(*((_QWORD *)this + 192) + 64) = 32;
            (*(void (**)(bssl *))(*(_QWORD *)v83 + 32))(v83);
LABEL_136:
            *((_DWORD *)this + 5) = 19;
            finished = 15;
            goto LABEL_473;
          }
        }
        goto LABEL_451;
      case 19:
        if (!bssl::tls1_change_cipher_state((uint64_t *)this, 0))
          goto LABEL_451;
        v40 = 20;
        goto LABEL_471;
      case 20:
        v63 = *(_QWORD *)this;
        finished = bssl::ssl_get_finished(this, (bssl::SSL_HANDSHAKE *)a2);
        if ((_DWORD)finished != 1)
          goto LABEL_473;
        if (*(_QWORD *)(v63 + 104))
          v49 = 16;
        else
          v49 = 21;
        goto LABEL_183;
      case 21:
        v64 = *(_QWORD *)this;
        if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 216) == 2)
        {
          *((_DWORD *)this + 400) |= 2u;
          bssl::ssl_send_alert((bssl *)v64, (ssl_st *)2, 121);
          ERR_put_error(16, 0, 319, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1884);
          goto LABEL_451;
        }
        (*(void (**)(_QWORD, ssl_session_st *))(*(_QWORD *)v64 + 128))(*(_QWORD *)this, a2);
        v74 = *v215;
        if (!*v215)
        {
          v100 = *(SSL_SESSION **)(v64 + 104);
          if (!v100)
            bssl::ssl_client_handshake();
          SSL_SESSION_up_ref(*(unsigned int **)(v64 + 104));
          v80 = (SSL_SESSION **)(*(_QWORD *)(v64 + 48) + 472);
          v81 = v100;
          goto LABEL_229;
        }
        bssl::SSL_SESSION_dup((bssl *)*v215, (ssl_session_st *)3, __b);
        v75 = (SSL_SESSION **)(*(_QWORD *)(v64 + 48) + 472);
        v76 = *(SSL_SESSION **)&__b[0];
        *(_QWORD *)&__b[0] = 0;
        std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v75, v76);
        v77 = *(SSL_SESSION **)&__b[0];
        *(_QWORD *)&__b[0] = 0;
        if (v77)
          SSL_SESSION_free(v77);
        v78 = *(_QWORD *)(v64 + 48);
        v79 = *(_QWORD *)(v78 + 472);
        if (v79)
        {
          if ((*(_WORD *)(v78 + 220) & 0x20) == 0)
            *(_BYTE *)(v79 + 448) &= ~4u;
          v80 = v215;
          v81 = 0;
LABEL_229:
          std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v80, v81);
          *((_DWORD *)this + 400) |= 8u;
          *(_WORD *)(*(_QWORD *)(v64 + 48) + 220) |= 0x20u;
          if (v74)
            bssl::ssl_update_cache((bssl *)v64, (ssl_st *)a2);
          v40 = 22;
          goto LABEL_471;
        }
        goto LABEL_451;
      case 22:
        bssl::ssl_do_info_callback(*(_QWORD *)this, (const ssl_st *)0x20);
        return 1;
      default:
        goto LABEL_451;
    }
  }
}

void sub_1B4F9CC6C(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

_QWORD *bssl::tls_append_handshake_data(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v6;
  _QWORD *result;
  BUF_MEM **v8;
  _QWORD *v9;
  BUF_MEM *v10;

  v6 = *(_QWORD *)(a1 + 48);
  v9 = *(_QWORD **)(v6 + 224);
  v8 = (BUF_MEM **)(v6 + 224);
  result = v9;
  if (v9)
    return (_QWORD *)(BUF_MEM_append(result, a2, a3) != 0);
  v10 = BUF_MEM_new();
  std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v8, v10);
  result = *(_QWORD **)(*(_QWORD *)(a1 + 48) + 224);
  if (result)
    return (_QWORD *)(BUF_MEM_append(result, a2, a3) != 0);
  return result;
}

uint64_t BUF_MEM_append(_QWORD *a1, const void *a2, size_t a3)
{
  size_t v5;
  uint64_t result;

  if (!a3)
    return 1;
  v5 = *a1 + a3;
  if (__CFADD__(*a1, a3))
  {
    ERR_put_error(7, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/buf/buf.c", 137);
    return 0;
  }
  else
  {
    result = BUF_MEM_reserve((uint64_t)a1, *a1 + a3);
    if ((_DWORD)result)
    {
      memcpy((void *)(a1[1] + *a1), a2, a3);
      *a1 = v5;
      return 1;
    }
  }
  return result;
}

uint64_t BUF_MEM_reserve(uint64_t a1, unint64_t a2)
{
  int v2;
  unint64_t v4;
  uint64_t result;

  if (*(_QWORD *)(a1 + 16) >= a2)
    return 1;
  if (a2 < 0xFFFFFFFFFFFFFFFDLL)
  {
    if (a2 >= 0xBFFFFFFFFFFFFFFDLL)
    {
      v2 = 101;
      goto LABEL_9;
    }
    v4 = (2 * (((a2 + 3) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
    result = (uint64_t)OPENSSL_realloc(*(_QWORD **)(a1 + 8), v4);
    if (!result)
      return result;
    *(_QWORD *)(a1 + 8) = result;
    *(_QWORD *)(a1 + 16) = v4;
    return 1;
  }
  v2 = 95;
LABEL_9:
  ERR_put_error(7, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/buf/buf.c", v2);
  return 0;
}

void BUF_MEM_free(BUF_MEM *a)
{
  if (a)
  {
    OPENSSL_free((_QWORD *)a->data);
    OPENSSL_free(a);
  }
}

BUF_MEM *BUF_MEM_new(void)
{
  BUF_MEM *result;

  result = (BUF_MEM *)OPENSSL_malloc(0x18uLL);
  if (result)
  {
    *(_QWORD *)&result->length = 0;
    result->data = 0;
    *(_QWORD *)&result->max = 0;
  }
  return result;
}

int RAND_bytes(unsigned __int8 *buf, int num)
{
  CRYPTO_sysrand((uint64_t)buf, *(uint64_t *)&num);
  return 1;
}

uint64_t CRYPTO_sysrand(uint64_t a1, uint64_t a2)
{
  uint64_t (**v4)(_QWORD, uint64_t, uint64_t);

  v4 = (uint64_t (**)(_QWORD, uint64_t, uint64_t))ccrng();
  if (!v4)
    abort();
  return (*v4)(v4, a2, a1);
}

BOOL bssl::ssl_cipher_uses_certificate_auth(bssl *this, const ssl_cipher_st *a2)
{
  return (*((_BYTE *)this + 24) & 3) != 0;
}

uint64_t bssl::ssl_add_supported_versions(bssl *this, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t result;

  if (***(_BYTE ***)this)
    v6 = 4;
  else
    v6 = 8;
  if (***(_BYTE ***)this)
    v7 = (unsigned __int16 *)&bssl::kDTLSVersions;
  else
    v7 = (unsigned __int16 *)&bssl::kTLSVersions;
  do
  {
    v8 = *v7;
    if (!bssl::ssl_supports_version(this, (const bssl::SSL_HANDSHAKE *)*v7))
      goto LABEL_15;
    v9 = v8;
    if (v8 - 769 >= 4)
    {
      if (v8 == 65277)
      {
        v9 = 771;
      }
      else
      {
        if (v8 != 65279)
          goto LABEL_15;
        v9 = 770;
      }
    }
    if (v9 >= a3)
    {
      result = CBB_add_u16(a2, v8);
      if (!(_DWORD)result)
        return result;
    }
LABEL_15:
    ++v7;
    v6 -= 2;
  }
  while (v6);
  return 1;
}

BOOL bssl::ssl_supports_version(bssl *this, const bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2;
  unsigned __int16 *v3;
  uint64_t v4;
  int v5;
  int v6;
  BOOL v7;

  v2 = 8;
  if (***(_BYTE ***)this)
    v2 = 4;
  v3 = (unsigned __int16 *)&bssl::kDTLSVersions;
  if (!***(_BYTE ***)this)
    v3 = (unsigned __int16 *)&bssl::kTLSVersions;
  v4 = v2 - 2;
  do
  {
    v6 = *v3++;
    v5 = v6;
    v7 = v6 == (_DWORD)a2 || v4 == 0;
    v4 -= 2;
  }
  while (!v7);
  if (v5 != (_DWORD)a2)
    return 0;
  if (((_DWORD)a2 - 769) >= 4)
  {
    if ((_DWORD)a2 == 65277)
    {
      LODWORD(a2) = 771;
    }
    else
    {
      if ((_DWORD)a2 != 65279)
        return 0;
      LODWORD(a2) = 770;
    }
  }
  if (*((unsigned __int16 *)this + 14) > a2)
    return 0;
  return a2 <= *((unsigned __int16 *)this + 15);
}

uint64_t bssl::ssl_select_ech_config(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  void *v10;
  char v11;
  uint64_t v12;
  __int128 v13;
  int is_opaque;
  unsigned __int16 *v15;
  uint64_t v16;
  int v17;
  unsigned __int16 *v18;
  BOOL v19;
  void *v20;
  __int128 v21;
  __int128 v22;
  _QWORD *v23;
  size_t v24;
  _QWORD *v25;
  uint64_t *v27;
  BUF_MEM **v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _OWORD v33[3];
  char v34;
  void *v35[2];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  unint64_t v39;
  unsigned __int16 *v40[2];
  unsigned __int8 *v41[2];
  unsigned __int16 v42[5];

  *a4 = 0;
  if (*(unsigned __int16 *)(a1 + 30) < 0x304u
    || (v4 = a1, v5 = *(_QWORD *)(a1 + 8), (v6 = *(unsigned __int8 **)(v5 + 304)) == 0))
  {
LABEL_45:
    LOBYTE(v4) = 1;
    return v4 & 1;
  }
  v41[0] = *(unsigned __int8 **)(v5 + 296);
  v41[1] = v6;
  v40[0] = (unsigned __int16 *)0xAAAAAAAAAAAAAAAALL;
  v40[1] = (unsigned __int16 *)0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_u16_length_prefixed(v41, (unint64_t *)v40)
    && CBS_len((uint64_t)v40)
    && !CBS_len((uint64_t)v41))
  {
    v30 = a2;
    v31 = a3;
    v28 = (BUF_MEM **)(v4 + 464);
    v29 = (_QWORD *)(v4 + 736);
    v27 = (uint64_t *)(v4 + 1560);
    while (CBS_len((uint64_t)v40))
    {
      *(_OWORD *)v35 = 0u;
      v36 = 0u;
      v37 = 0u;
      v38 = 0u;
      v39 = 0xAAAAAAAA00000000;
      v34 = -86;
      if ((bssl::parse_ech_config(v40, (uint64_t)v35, &v34, 0) & 1) != 0)
      {
        v10 = EVP_hpke_x25519_hkdf_sha256();
        v11 = 1;
        if (v34 && (unsigned __int16)v39 == 32)
        {
          v12 = (uint64_t)v10;
          v13 = v38;
          is_opaque = RSA_is_opaque();
          v33[0] = v13;
          if (CBS_len((uint64_t)v33))
          {
            v15 = 0;
            while (1)
            {
              LOWORD(v32) = -21846;
              v42[0] = -21846;
              if (!CBS_get_u16((unsigned __int16 **)v33, &v32)
                || !CBS_get_u16((unsigned __int16 **)v33, v42))
              {
                break;
              }
              v16 = 0;
              v17 = v42[0];
              while (1)
              {
                v18 = (unsigned __int16 *)bssl::kSupportedAEADs[v16]();
                if (EVP_HPKE_KDF_id(v18) == v17)
                  break;
                if (++v16 == 3)
                  goto LABEL_24;
              }
              if (v18)
                v19 = (unsigned __int16)v32 == 1;
              else
                v19 = 0;
              if (!v19)
              {
LABEL_24:
                v18 = v15;
                goto LABEL_25;
              }
              if (v15)
              {
                if (is_opaque)
                  goto LABEL_24;
                if (v42[0] != 3)
                  v18 = v15;
              }
LABEL_25:
              v15 = v18;
              if (!CBS_len((uint64_t)v33))
              {
                if (!v18)
                  break;
                v20 = EVP_hpke_hkdf_sha256();
                *(_QWORD *)&v21 = 0xAAAAAAAAAAAAAAAALL;
                *((_QWORD *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
                v33[1] = v21;
                v33[2] = v21;
                v33[0] = v21;
                CBB_zero(v33);
                if (CBB_init((uint64_t)v33, (unint64_t)v35[1] + 8)
                  && CBB_add_bytes((uint64_t)v33, "tls ech", 8uLL)
                  && CBB_add_bytes((uint64_t)v33, v35[0], (size_t)v35[1])
                  && (v22 = v36,
                      v23 = CBB_data((uint64_t)v33),
                      v24 = CBB_len((uint64_t)v33),
                      EVP_HPKE_CTX_setup_sender(v29, v30, (uint64_t)a4, v31, v12, (uint64_t)v20, (uint64_t)v18, v22, *((uint64_t *)&v22 + 1), v23, v24))&& bssl::SSLTranscript::Init(v28))
                {
                  v25 = bssl::New<bssl::ECHConfig,bssl::ECHConfig>((uint64_t)v35);
                  v32 = 0;
                  std::unique_ptr<bssl::ECHConfig,bssl::internal::Deleter>::reset[abi:ne180100](v27, (uint64_t)v25);
                  std::unique_ptr<bssl::ECHConfig,bssl::internal::Deleter>::reset[abi:ne180100](&v32, 0);
                  LOBYTE(v4) = *v27 != 0;
                }
                else
                {
                  LOBYTE(v4) = 0;
                }
                CBB_cleanup((uint64_t)v33);
                v11 = 0;
                goto LABEL_41;
              }
            }
          }
          v11 = 1;
        }
      }
      else
      {
        v11 = 0;
        LOBYTE(v4) = 0;
      }
LABEL_41:
      OPENSSL_free((_QWORD *)v35[0]);
      if ((v11 & 1) == 0)
        return v4 & 1;
    }
    goto LABEL_45;
  }
  LOBYTE(v4) = 0;
  return v4 & 1;
}

void sub_1B4F9D4B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  CBB_cleanup((uint64_t)&a19);
  bssl::Array<unsigned char>::~Array((uint64_t)&a27);
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_get_version_range(bssl *this, const bssl::SSL_HANDSHAKE *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  uint64_t v7;
  unsigned int v8;
  int is_dtls;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  uint64_t v16;
  char v17;
  BOOL v18;
  unsigned int v19;

  v7 = *(_QWORD *)this;
  v8 = *(_DWORD *)(v7 + 144);
  is_dtls = SSL_is_dtls((unsigned __int8 **)v7);
  v10 = v8 & 0xEFFFFFFF | (((v8 >> 26) & 1) << 28);
  if (!is_dtls)
    v10 = v8;
  v11 = *((_QWORD *)this + 1);
  v12 = *(unsigned __int16 *)(v11 + 10);
  if (v12 - 769 >= 4)
  {
    if (v12 == 65277)
    {
      v12 = 771;
    }
    else
    {
      if (v12 != 65279)
        goto LABEL_12;
      v12 = 770;
    }
  }
  v13 = *(unsigned __int16 *)(v11 + 8);
  if (v13 - 769 >= 4)
  {
    if (v13 == 65277)
    {
      v13 = 771;
      goto LABEL_14;
    }
    if (v13 == 65279)
    {
      v13 = 770;
      goto LABEL_14;
    }
LABEL_12:
    v14 = 68;
    v15 = 187;
LABEL_30:
    ERR_put_error(16, 0, v14, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_versions.cc", v15);
    return 0;
  }
LABEL_14:
  v16 = 0;
  v17 = 0;
  if (*(_QWORD *)(*(_QWORD *)this + 168))
    v18 = v12 >= 0x304;
  else
    v18 = 1;
  if (!v18)
    LOWORD(v12) = 772;
  do
  {
    v19 = (unsigned __int16)bssl::kProtocolVersions[v16];
    if (v19 >= (unsigned __int16)v12)
    {
      if (v13 < v19)
        break;
      if ((*(_DWORD *)&bssl::kProtocolVersions[v16 + 2] & v10) != 0)
      {
        if ((v17 & 1) != 0)
        {
          LOWORD(v13) = bssl::kProtocolVersions[v16 - 4];
          goto LABEL_32;
        }
        v17 = 0;
      }
      else
      {
        if ((v17 & 1) == 0)
          LOWORD(v12) = bssl::kProtocolVersions[v16];
        v17 = 1;
      }
    }
    v16 += 4;
  }
  while (v16 != 16);
  if ((v17 & 1) == 0)
  {
    v14 = 280;
    v15 = 234;
    goto LABEL_30;
  }
LABEL_32:
  *(_WORD *)a2 = v12;
  *a3 = v13;
  return 1;
}

int SSL_connect(SSL *ssl)
{
  if (!*(_QWORD *)&ssl->rwstate)
  {
    BYTE4(ssl->param) &= ~1u;
    *(_QWORD *)&ssl->rwstate = bssl::ssl_client_handshake;
  }
  return SSL_do_handshake(ssl);
}

uint64_t bssl::ssl_setup_extension_permutation(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2;
  __int128 v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t i;
  uint64_t j;
  unint64_t v9;
  char v10;
  unsigned __int8 buf[16];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  if ((*(_WORD *)(*((_QWORD *)this + 1) + 313) & 0x400) == 0)
    return 1;
  v18[0] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16 = v4;
  v17 = v4;
  v14 = v4;
  v15 = v4;
  *(_OWORD *)buf = v4;
  v13 = v4;
  if (RAND_bytes(buf, 104) && (OPENSSL_free(0), v5 = OPENSSL_malloc(0x1BuLL), (v6 = v5) != 0))
  {
    for (i = 0; i != 27; ++i)
      *((_BYTE *)v5 + i) = i;
    for (j = 0; j != -26; --j)
    {
      v9 = *((unsigned int *)v18 + j + 1) % (unint64_t)(j + 27);
      v10 = *((_BYTE *)v5 + j + 26);
      *((_BYTE *)v5 + j + 26) = *((_BYTE *)v5 + v9);
      *((_BYTE *)v5 + v9) = v10;
    }
    OPENSSL_free(*((_QWORD **)this + 89));
    *((_QWORD *)this + 89) = v6;
    *((_QWORD *)this + 90) = 27;
    v2 = 1;
  }
  else
  {
    v2 = 0;
  }
  OPENSSL_free(0);
  return v2;
}

void sub_1B4F9D7E4(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t bssl::ssl_encrypt_client_hello(uint64_t a1, const void *a2, size_t a3)
{
  _QWORD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t v14;
  const char *v15;
  size_t v16;
  uint64_t v17;
  _BOOL8 v18;
  unsigned __int16 *v19;
  unsigned __int16 *v20;
  unsigned int v21;
  __int128 v22;
  unsigned __int8 v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  unsigned int v28;
  uint64_t v29;
  char v31;
  uint64_t v32;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  size_t v35;
  uint64_t v36;
  size_t v37;
  __int128 v38;
  unsigned int v39;
  unsigned int v40;
  __int128 v41;
  unint64_t v42;
  size_t v43;
  uint64_t v44;
  char *v45;
  size_t v46;
  unsigned __int8 *v47[2];
  __int128 v48;
  __int128 v49;
  size_t v50;
  char *v51;
  size_t v52;
  void *v53;
  size_t v54;
  char v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  unsigned __int8 buf[16];
  __int128 v63;
  __int128 v64;
  unsigned __int8 v65[16];
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 1560))
  {
    v6 = *(_QWORD **)a1;
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v63 = v7;
    v64 = v7;
    *(_OWORD *)buf = v7;
    CBB_zero(buf);
    *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v60 = v8;
    v61 = v8;
    v59 = v8;
    CBB_zero(&v59);
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v57 = v9;
    v58 = v9;
    v56 = v9;
    v55 = -86;
    v53 = 0;
    v54 = 0;
    if (!(*(unsigned int (**)(_QWORD *, unsigned __int8 *, __int128 *, uint64_t))(*v6 + 88))(v6, buf, &v56, 1)|| !CBB_init((uint64_t)&v59, 0x100uLL)|| !bssl::ssl_write_client_hello_without_extensions(a1, (uint64_t *)&v56, 1, 0)|| !bssl::ssl_write_client_hello_without_extensions(a1, (uint64_t *)&v59, 1, 1)|| (v10 = CBB_len((uint64_t)&v56), !bssl::ssl_add_clienthello_tlsext(a1, (uint64_t *)&v56, (uint64_t *)&v59, &v55, (const ssl_session_st *)1, v10))|| ((*(uint64_t (**)(_QWORD *, unsigned __int8 *, void **))(*v6 + 96))(v6, buf, &v53) & 1) == 0)
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/encrypted_client_hello.cc", 787);
      v18 = 0;
LABEL_20:
      OPENSSL_free(v53);
      CBB_cleanup((uint64_t)&v59);
      CBB_cleanup((uint64_t)buf);
      return v18;
    }
    v11 = v54;
    if (v55)
    {
      *(_QWORD *)&v68 = 0xAAAAAAAAAAAAAAAALL;
      if ((bssl::tls13_write_psk_binder((uint64_t *)a1, (ssl_session_st *)(a1 + 464), (char *)v53, v54, (size_t *)&v68) & 1) == 0)
      {
LABEL_40:
        v18 = 0;
        goto LABEL_20;
      }
      v12 = CBB_data((uint64_t)&v59);
      v13 = CBB_len((uint64_t)&v59);
      if (v13 < (unint64_t)v68)
        abort();
      v11 = v54;
      if (v54 < (unint64_t)v68)
        abort();
      if ((_QWORD)v68)
      {
        memcpy((char *)v12 + v13 - v68, (char *)v53 + v54 - v68, v68);
        v11 = v54;
      }
    }
    bssl::ssl_do_msg_callback((uint64_t)v6, 1, 257, (uint64_t)v53, v11);
    if (bssl::SSLTranscript::Update((_QWORD **)(a1 + 464), v53, v54))
    {
      v14 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 1560) + 66);
      v15 = (const char *)v6[20];
      if (v15)
      {
        v16 = strlen(v15);
        if (v14 >= v16)
          v17 = v14 - v16;
        else
          v17 = 0;
      }
      else
      {
        v17 = v14 + 9;
      }
      v31 = CBB_len((uint64_t)&v59);
      v51 = 0;
      v52 = 0;
      if (!CBB_add_zeros((uint64_t)&v59, ((-v31 - (_BYTE)v17) & 0x1F) + v17))
        goto LABEL_60;
      if (!bssl::CBBFinishArray((uint64_t)&v59, (uint64_t)&v51))
        goto LABEL_60;
      v32 = a1 + 736;
      v33 = (unsigned __int16 *)RSA_get0_e((const EC_KEY *)(a1 + 736));
      v34 = (unsigned __int16 *)RSA_get0_n(a1 + 736);
      v35 = v52;
      v36 = EVP_HPKE_AEAD_aead((uint64_t)v34);
      v37 = EVP_AEAD_max_overhead(v36) + v35;
      v50 = v37;
      *(_QWORD *)&v38 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v38 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v69 = v38;
      v70 = v38;
      v67 = v38;
      v68 = v38;
      *(_OWORD *)v65 = v38;
      v66 = v38;
      if (!CBB_init((uint64_t)buf, 0x100uLL))
        goto LABEL_60;
      v39 = EVP_HPKE_KDF_id(v33);
      if (CBB_add_u16((uint64_t)buf, v39)
        && (v40 = EVP_HPKE_KDF_id(v34), CBB_add_u16((uint64_t)buf, v40))
        && CBB_add_u8((uint64_t)buf, *(unsigned __int8 *)(*(_QWORD *)(a1 + 1560) + 67))
        && CBB_add_u16_length_prefixed((uint64_t *)buf, (uint64_t)&v68)
        && CBB_add_bytes((uint64_t)&v68, a2, a3)
        && CBB_add_u16_length_prefixed((uint64_t *)buf, (uint64_t)v65)
        && CBB_add_zeros((uint64_t)v65, v37)
        && bssl::CBBFinishArray((uint64_t)buf, a1 + 568))
      {
        *(_QWORD *)&v41 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v48 = v41;
        v49 = v41;
        *(_OWORD *)v47 = v41;
        CBB_zero(v47);
        if (CBB_init((uint64_t)v47, 0x100uLL)
          && bssl::ssl_write_client_hello_without_extensions(a1, (uint64_t *)v47, 2, 0)
          && (v42 = CBB_len((uint64_t)v47),
              bssl::ssl_add_clienthello_tlsext(a1, (uint64_t *)v47, 0, &v55, (const ssl_session_st *)2, v42)))
        {
          if (v55)
            __assert_rtn("ssl_encrypt_client_hello", "encrypted_client_hello.cc", 871, "!needs_psk_binder");
          v43 = *(_QWORD *)(a1 + 576);
          if (v43 < v37)
            abort();
          v44 = *(_QWORD *)(a1 + 568);
          v45 = v51;
          v46 = v52;
          CBB_data((uint64_t)v47);
          CBB_len((uint64_t)v47);
          if (EVP_HPKE_CTX_seal(v32, (char *)(v44 + v43 - v37), &v50, v37, v45, v46))
            v18 = v50 == v37;
          else
            v18 = 0;
        }
        else
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/encrypted_client_hello.cc", 865);
          v18 = 0;
        }
        CBB_cleanup((uint64_t)v47);
      }
      else
      {
LABEL_60:
        v18 = 0;
      }
      bssl::Array<unsigned char>::~Array((uint64_t)&v51);
      goto LABEL_20;
    }
    goto LABEL_40;
  }
  if (*(unsigned __int16 *)(a1 + 30) < 0x304u || (*(_WORD *)(*(_QWORD *)(a1 + 8) + 313) & 1) == 0)
    return 1;
  if (RSA_is_opaque())
    v19 = (unsigned __int16 *)EVP_hpke_aes_128_gcm();
  else
    v19 = (unsigned __int16 *)EVP_hpke_chacha20_poly1305();
  v20 = v19;
  v21 = *(unsigned __int8 *)(a1 + 1650);
  *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v68 = v22;
  v69 = v22;
  *(_OWORD *)v65 = v22;
  v66 = v22;
  X25519_keypair(&v68, v65);
  *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
  RAND_bytes(buf, 8);
  v23 = buf[0];
  v24 = EVP_HPKE_AEAD_aead((uint64_t)v20);
  v25 = EVP_AEAD_max_overhead(v24);
  *(_QWORD *)&v26 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v26 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v63 = v26;
  v64 = v26;
  *(_OWORD *)buf = v26;
  CBB_zero(buf);
  *(_QWORD *)&v27 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v60 = v27;
  v61 = v27;
  v58 = v27;
  v59 = v27;
  v56 = v27;
  v57 = v27;
  v47[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  v18 = CBB_init((uint64_t)buf, 0x100uLL)
     && CBB_add_u16((uint64_t)buf, 1u)
     && (v28 = EVP_HPKE_KDF_id(v20), CBB_add_u16((uint64_t)buf, v28))
     && CBB_add_u8((uint64_t)buf, v21)
     && CBB_add_u16_length_prefixed((uint64_t *)buf, (uint64_t)&v59)
     && CBB_add_bytes((uint64_t)&v59, &v68, 0x20uLL)
     && CBB_add_u16_length_prefixed((uint64_t *)buf, (uint64_t)&v56)
     && (v29 = ((32 * (v23 & 3)) | 0x80) + v25, CBB_add_space((uint64_t)&v56, v47, v29))
     && RAND_bytes(v47[0], v29)
     && bssl::CBBFinishArray((uint64_t)buf, a1 + 568);
  CBB_cleanup((uint64_t)buf);
  return v18;
}

void sub_1B4F9DE68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  CBB_cleanup((uint64_t)&a9);
  bssl::Array<unsigned char>::~Array((uint64_t)&a16);
  bssl::Array<unsigned char>::~Array((uint64_t)&a18);
  CBB_cleanup((uint64_t)&a27);
  CBB_cleanup((uint64_t)&a33);
  _Unwind_Resume(a1);
}

uint64_t bssl::SSLAEADContext::SetVersionIfNullCipher(uint64_t this, __int16 a2)
{
  if (!*(_QWORD *)this)
    *(_WORD *)(this + 622) = a2;
  return this;
}

void bssl::tls_on_handshake_complete(bssl *this, ssl_st *a2)
{
  uint64_t v2;
  BUF_MEM **v3;
  _QWORD *v4;
  _QWORD *v5;

  v2 = *((_QWORD *)this + 6);
  if ((*(_WORD *)(v2 + 220) & 0x10) != 0)
    bssl::tls_on_handshake_complete();
  v5 = *(_QWORD **)(v2 + 224);
  v3 = (BUF_MEM **)(v2 + 224);
  v4 = v5;
  if (v5)
  {
    if (*v4)
      bssl::tls_on_handshake_complete();
    std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v3, 0);
  }
}

void bssl::ssl_update_cache(bssl *this, ssl_st *a2)
{
  uint64_t v3;
  uint64_t v4;
  int is_server;
  int v6;
  int v7;
  SSL_SESSION *v8;
  int v9;
  int v10;
  uint64_t tm[2];
  SSL_SESSION *ses;
  uint64_t v13;

  v3 = *((_QWORD *)this + 16);
  v4 = *(_QWORD *)(*((_QWORD *)this + 6) + 472);
  is_server = SSL_is_server((uint64_t)this);
  if ((*(_BYTE *)(v4 + 448) & 4) == 0 && (*(_DWORD *)(v4 + 64) || *(_QWORD *)(v4 + 248)))
  {
    v6 = is_server ? 2 : 1;
    v7 = *(_DWORD *)(v3 + 292);
    if ((v7 & v6) != 0)
    {
      if ((v7 & 0x200) == 0 && (*((_BYTE *)this + 180) & 1) != 0)
      {
        CRYPTO_refcount_inc((unsigned int *)v4);
        v13 = v4;
        tm[0] = 0xAAAAAAAAAAAAAAAALL;
        bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_write),&(CRYPTO_MUTEX_unlock_write)>::MutexLockBase((pthread_rwlock_t **)tm, (pthread_rwlock_t *)(v3 + 16));
        ses = (SSL_SESSION *)v4;
        v13 = 0;
        bssl::add_session_locked(v3, &ses);
        v8 = ses;
        ses = 0;
        if (v8)
          SSL_SESSION_free(v8);
        if ((*(_BYTE *)(v3 + 292) & 0x80) != 0)
        {
          CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)tm[0]);
        }
        else
        {
          v9 = *(_DWORD *)(v3 + 288);
          if (v9 <= 253)
            v10 = v9 + 1;
          else
            v10 = 0;
          *(_DWORD *)(v3 + 288) = v10;
          CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)tm[0]);
          if (v9 > 253)
          {
            tm[0] = 0xAAAAAAAAAAAAAAAALL;
            tm[1] = 0xAAAAAAAAAAAAAAAALL;
            bssl::ssl_get_current_time((uint64_t)this, (uint64_t)tm);
            SSL_CTX_flush_sessions((SSL_CTX *)v3, tm[0]);
          }
        }
      }
      if (*(_QWORD *)(v3 + 304))
      {
        CRYPTO_refcount_inc((unsigned int *)v4);
        tm[0] = v4;
        if (!(*(unsigned int (**)(bssl *, uint64_t))(v3 + 304))(this, v4))
        {
          tm[0] = 0;
          SSL_SESSION_free((SSL_SESSION *)v4);
        }
      }
    }
  }
}

void sub_1B4F9E0C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t SSL_is_server(uint64_t a1)
{
  return *(_BYTE *)(a1 + 180) & 1;
}

uint64_t bssl::ssl_get_finished(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3;
  __int128 v4;
  uint64_t result;
  __int128 v6;
  const ssl_session_st *v7;
  char v8;
  int v9;
  int v10;
  size_t __n;
  __int128 v12;
  __int128 v13;
  size_t v14;
  _OWORD __src[4];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)this;
  v14 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12 = v4;
  v13 = v4;
  if (!(*(unsigned int (**)(uint64_t, __int128 *))(*(_QWORD *)v3 + 24))(v3, &v12))
    return 3;
  result = bssl::ssl_check_message_type((bssl *)v3, (uint64_t)&v12, 20);
  if ((_DWORD)result)
  {
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __src[2] = v6;
    __src[3] = v6;
    __src[0] = v6;
    __src[1] = v6;
    __n = 0xAAAAAAAAAAAAAAAALL;
    v7 = (const ssl_session_st *)*((_QWORD *)this + 192);
    if (!v7)
      v7 = *(const ssl_session_st **)(*(_QWORD *)this + 104);
    result = bssl::SSLTranscript::GetFinishedMAC((bssl *)((char *)this + 424), (unsigned __int8 *)__src, &__n, v7, (*(_BYTE *)(v3 + 180) & 1) == 0);
    if ((_DWORD)result)
    {
      if ((_BYTE)v12
        || (result = bssl::SSLTranscript::Update((_QWORD **)this + 53, *((const void **)&v13 + 1), v14), (_DWORD)result))
      {
        if (!CBS_mem_equal((uint64_t)&v12 + 8, (char *)__src, __n))
        {
          bssl::ssl_send_alert((bssl *)v3, (ssl_st *)2, 51);
          v9 = 142;
          v10 = 519;
          goto LABEL_23;
        }
        v8 = __n;
        if (__n >= 0xD)
        {
          v9 = 68;
          v10 = 526;
LABEL_23:
          ERR_put_error(16, 0, v9, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", v10);
          return 0;
        }
        if ((*(_BYTE *)(v3 + 180) & 1) != 0)
        {
          if (__n)
            memcpy((void *)(*(_QWORD *)(v3 + 48) + 443), __src, __n);
          *(_BYTE *)(*(_QWORD *)(v3 + 48) + 455) = v8;
        }
        else
        {
          if (__n)
            memcpy((void *)(*(_QWORD *)(v3 + 48) + 457), __src, __n);
          *(_BYTE *)(*(_QWORD *)(v3 + 48) + 456) = v8;
        }
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3))
        {
          bssl::ssl_send_alert((bssl *)v3, (ssl_st *)2, 10);
          v9 = 255;
          v10 = 541;
          goto LABEL_23;
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
        return 1;
      }
    }
  }
  return result;
}

uint64_t bssl::tls1_change_cipher_state(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t **v5;

  v3 = *a1;
  v4 = (uint64_t)(a1 + 197);
  v5 = (unint64_t **)bssl::ssl_handshake_session(a1);
  return bssl::tls1_configure_aead(v3, a2, v4, v5, 0, 0);
}

int sk_find(STACK *st, char *data)
{
  char *v2;
  unsigned int (*v3)(_QWORD, char **, unint64_t *);
  STACK *v5;
  unsigned int (*v6)(_QWORD, char **, unint64_t *);
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char **v10;
  unint64_t v11;
  char **v12;
  char *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  BOOL v18;
  unint64_t v20;
  char *v21;

  v21 = v2;
  if (!st)
    return (int)st;
  v5 = st;
  if (*(_QWORD *)&st[1].num)
  {
    if (v2)
    {
      v6 = v3;
      v7 = *(_QWORD *)&st->num;
      if (!st->sorted && v7 >= 2)
      {
        v8 = 0;
        while (1)
        {
          v20 = 0xAAAAAAAAAAAAAAAALL;
          v20 = (unint64_t)v5->data[v8];
          if (!v6(*(_QWORD *)&v5[1].num, &v21, &v20))
            break;
          if ((unint64_t)++v8 >= *(_QWORD *)&v5->num)
            goto LABEL_31;
        }
        if (data)
          *(_QWORD *)data = v8;
LABEL_35:
        LODWORD(st) = 1;
        return (int)st;
      }
      if (v7)
      {
        v14 = 0;
        while (1)
        {
          v15 = v7 - v14 - 1;
          v16 = v14 + (v15 >> 1);
          if (__CFADD__(v14, v15 >> 1) || v16 >= v7)
            sk_find_cold_1();
          v20 = 0xAAAAAAAAAAAAAAAALL;
          v20 = (unint64_t)v5->data[v16];
          v17 = v6(*(_QWORD *)&v5[1].num, &v21, &v20);
          if (v17 < 1)
          {
            if (v17 < 0)
            {
              v7 = v16;
            }
            else
            {
              if (v7 - v14 == 1)
              {
                if (data)
                  *(_QWORD *)data = v16;
                goto LABEL_35;
              }
              v18 = v16 + 1 >= v7;
              v7 = v16 + 1;
              if (v18)
                sk_find_cold_3();
            }
          }
          else
          {
            v14 = v16 + 1;
          }
          if (v14 >= v7)
          {
            if (v14 != v7)
              sk_find_cold_2();
            break;
          }
        }
      }
    }
LABEL_31:
    LODWORD(st) = 0;
    return (int)st;
  }
  v9 = *(_QWORD *)&st->num;
  if (!*(_QWORD *)&st->num)
    goto LABEL_31;
  v10 = st->data;
  if (*v10 != v2)
  {
    v11 = 0;
    v12 = v10 + 1;
    while (v9 - 1 != v11)
    {
      v13 = v12[v11++];
      if (v13 == v2)
      {
        LODWORD(st) = v11 < v9;
        goto LABEL_37;
      }
    }
    goto LABEL_31;
  }
  v11 = 0;
  LODWORD(st) = 1;
LABEL_37:
  if (data)
    *(_QWORD *)data = v11;
  return (int)st;
}

void bssl::ssl_set_session(ssl_st **this, SSL_SESSION *a2, ssl_session_st *a3)
{
  SSL_SESSION **v3;

  v3 = (SSL_SESSION **)(this + 13);
  if (this[13] != (ssl_st *)a2)
  {
    if (a2)
      CRYPTO_refcount_inc((unsigned int *)a2);
    std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v3, a2);
  }
}

uint64_t bssl::tls1_record_handshake_hashes_for_channel_id(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t result;
  unint64_t v4;

  if (*(_QWORD *)(*(_QWORD *)this + 104))
    return 0;
  v4 = 0xAAAAAAAAAAAAAAAALL;
  result = bssl::SSLTranscript::GetHash((bssl *)((char *)this + 424), (unsigned __int8 *)(*((_QWORD *)this + 192) + 312), &v4);
  if ((_DWORD)result)
    *(_BYTE *)(*((_QWORD *)this + 192) + 376) = v4;
  return result;
}

uint64_t bssl::tls1_generate_master_secret(uint64_t *a1, _BYTE *a2, char *a3, unint64_t a4)
{
  uint64_t v7;
  uint64_t *v8;
  int v9;
  __int128 v10;
  bssl::SSLTranscript *v11;
  uint64_t *v12;
  unint64_t v14;
  unsigned __int8 v15[16];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if ((*((_BYTE *)a1 + 1602) & 2) != 0)
  {
    *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v17 = v10;
    v18 = v10;
    *(_OWORD *)v15 = v10;
    v16 = v10;
    v14 = 0xAAAAAAAAAAAAAAAALL;
    v11 = (bssl::SSLTranscript *)(a1 + 53);
    if (!bssl::SSLTranscript::GetHash((bssl::SSLTranscript *)(a1 + 53), v15, &v14))
      return 0;
    v12 = (uint64_t *)bssl::SSLTranscript::Digest(v11);
    v9 = CRYPTO_tls1_prf(v12, a2, 0x30uLL, a3, a4, "extended master secret", 0x16uLL, v15, v14, 0, 0);
  }
  else
  {
    v7 = *a1;
    v8 = (uint64_t *)bssl::SSLTranscript::Digest((bssl::SSLTranscript *)(a1 + 53));
    v9 = CRYPTO_tls1_prf(v8, a2, 0x30uLL, a3, a4, "master secret", 0xDuLL, (const unsigned __int8 *)(*(_QWORD *)(v7 + 48) + 48), 0x20uLL, (const unsigned __int8 *)(*(_QWORD *)(v7 + 48) + 16), 0x20uLL);
  }
  if (v9 == 1)
    return 48;
  return 0;
}

uint64_t bssl::SSLKeyShare::Accept(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;

  *a4 = 80;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, a3, a4, a5, a6);
  return result;
}

uint64_t SSL_get_mode(uint64_t a1)
{
  return *(unsigned int *)(a1 + 148);
}

_QWORD *CRYPTO_BUFFER_init_CBS(uint64_t a1, _QWORD *a2)
{
  return CBS_init(a2, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16));
}

void bssl::ssl_run_handshake()
{
  __assert_rtn("ssl_run_handshake", "handshake.cc", 640, "hs->wait != ssl_hs_read_change_cipher_spec");
}

{
  __assert_rtn("ssl_run_handshake", "handshake.cc", 772, "ssl->s3->ech_status != ssl_ech_rejected");
}

{
  __assert_rtn("ssl_run_handshake", "handshake.cc", 741, "ssl->s3->early_data_reason != ssl_early_data_unknown");
}

{
  __assert_rtn("ssl_run_handshake", "handshake.cc", 742, "!hs->can_early_write");
}

{
  __assert_rtn("ssl_run_handshake", "handshake.cc", 749, "ssl->s3->ech_status != ssl_ech_rejected");
}

uint64_t nw_protocol_boringssl_finalize_output_frames(uint64_t a1)
{
  _BYTE *v1;
  char v2;
  uint64_t v3;

  if (!a1)
    return 0;
  v1 = *(_BYTE **)(a1 + 40);
  if (!v1)
    return 0;
  v2 = v1[475];
  if ((v2 & 1) == 0 && datapath_logging_enabled && g_boringssl_log)
  {
    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      nw_protocol_boringssl_finalize_output_frames_cold_2();
    v2 = v1[475];
  }
  if ((v2 & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_finalize_output_frames_cold_1();
  }
  v3 = 1;
  nw_frame_array_append_array();
  nw_protocol_boringssl_write_frames(v1);
  return v3;
}

void nw_protocol_boringssl_write_frames(void *a1)
{
  _BYTE *v1;
  void *v2;
  void *v3;
  BOOL v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  NSObject *v9;
  int v10;
  void *alloc;
  void *v12;
  id v13;
  _BYTE *v14;
  _QWORD *v15;
  id v16;
  _BYTE buf[28];
  __int16 v18;
  _BYTE *v19;
  __int16 v20;
  unsigned int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if ((v1[475] & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_write_frames_cold_3();
  }
  if ((nw_frame_array_is_empty() & 1) == 0)
  {
    if ((v1[390] & 8) == 0)
    {
      v1[390] |= 8u;
      nw_frame_array_first();
      v2 = (void *)objc_claimAutoreleasedReturnValue();
      nw_frame_array_next();
      v3 = (void *)objc_claimAutoreleasedReturnValue();
      v4 = v3 == 0;

      if (!v4)
      {
        v5 = nw_frame_array_unclaimed_length();
        if (*((_QWORD *)v1 + 22))
        {
          v6 = nw_frame_unclaimed_length();
          v7 = v5 - v6;
          if (v5 < v6)
          {
            if ((v1[475] & 1) == 0
              && g_boringssl_log
              && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_FAULT))
            {
              nw_protocol_boringssl_write_frames_cold_1();
            }
            goto LABEL_24;
          }
          v8 = *((_DWORD *)v1 + 46);
          v5 = v7 + v8;
          if (__CFADD__(v7, v8))
          {
            if ((v1[475] & 1) == 0)
            {
              v9 = g_boringssl_log;
              if (g_boringssl_log)
              {
                if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_FAULT))
                {
                  v10 = *((_DWORD *)v1 + 46);
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "nw_protocol_boringssl_write_frames";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = 970;
                  *(_WORD *)&buf[18] = 2082;
                  *(_QWORD *)&buf[20] = v1 + 391;
                  v18 = 2048;
                  v19 = v1;
                  v20 = 1024;
                  v21 = v5;
                  v22 = 1024;
                  v23 = v10;
                  _os_log_fault_impl(&dword_1B4F6D000, v9, OS_LOG_TYPE_FAULT, "%{public}s(%d) %{public}s[%p] unable to write frame array of length %u and pending buffer %u", buf, 0x32u);
                }
              }
            }
            goto LABEL_24;
          }
        }
        alloc = (void *)dispatch_data_create_alloc();
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x2020000000;
        *(_DWORD *)&buf[24] = 0;
        v15 = v1;
        v16 = v2;
        nw_frame_array_foreach();
        v12 = (void *)v15[21];
        v15[21] = alloc;
        v13 = alloc;

        *((_QWORD *)v1 + 22) = 0;
        *((_DWORD *)v15 + 46) = v5;

        _Block_object_dispose(buf, 8);
      }
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      buf[24] = 1;
      v14 = v1;
      nw_frame_array_foreach();
      v1[390] &= ~8u;
      v14[388] = (v14[388] & 0xDF | (32 * *(_BYTE *)(*(_QWORD *)&buf[8] + 24))) ^ 0x20;

      _Block_object_dispose(buf, 8);
LABEL_24:

      goto LABEL_25;
    }
    if ((v1[475] & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_write_frames_cold_2();
    }
  }
LABEL_25:

}

void sub_1B4F9EC90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_boringssl_add_input_handler(uint64_t a1, unsigned __int8 *src)
{
  uint64_t v2;
  uint64_t v4;
  char v6;
  uint64_t v7;
  void *v8;
  void *v9;
  _QWORD *v10;
  uint64_t v11;
  int attribution;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t v15;

  if (!a1)
    return 0;
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(v2 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        if (g_boringssl_log)
        {
          v15 = a1;
          v14 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
          a1 = v15;
          if (v14)
          {
            nw_protocol_boringssl_add_input_handler_cold_7();
            a1 = v15;
          }
        }
      }
    }
    if (!src || (v4 = *((_QWORD *)src + 3)) == 0 || !*(_QWORD *)(v4 + 176))
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_add_input_handler_cold_1();
      }
      return 0;
    }
    if (!*(_QWORD *)(v4 + 112))
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_add_input_handler_cold_2();
      }
      return 0;
    }
    if (*(_QWORD *)(a1 + 48))
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_add_input_handler_cold_6();
      }
      return 0;
    }
    *(_QWORD *)(a1 + 48) = src;
    uuid_copy((unsigned __int8 *)(v2 + 8), src);
    *((_QWORD *)src + 4) = v2 + 8;
    if ((*(unsigned int (**)(unsigned __int8 *))(*((_QWORD *)src + 3) + 176))(src))
      v6 = 16;
    else
      v6 = 0;
    *(_BYTE *)(v2 + 389) = *(_BYTE *)(v2 + 389) & 0xEF | v6;
    (*(void (**)(unsigned __int8 *))(*((_QWORD *)src + 3) + 112))(src);
    v7 = objc_claimAutoreleasedReturnValue();
    v8 = *(void **)(v2 + 312);
    *(_QWORD *)(v2 + 312) = v7;

    if (!*(_QWORD *)(v2 + 312))
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_add_input_handler_cold_3();
      }
      return 0;
    }
    if (nw_parameters_get_logging_disabled())
      *(_BYTE *)(v2 + 475) |= 1u;
    v9 = (void *)nw_parameters_copy_context();
    v10 = boringssl_context_create_with_nw_context((void *)v2, v9);
    *(_QWORD *)(v2 + 336) = v10;
    if (v10)
    {
      v11 = (uint64_t)v10;
      attribution = nw_parameters_get_attribution(*(nw_parameters_t *)(v2 + 312));
      boringssl_context_set_attribution(v11, attribution);
      v13 = boringssl_bio_create(v2, (uint64_t)nw_protocol_boringssl_read_bytes, (uint64_t)nw_protocol_boringssl_write_bytes);
      *(_QWORD *)(v2 + 344) = v13;
      if (v13)
      {
        v2 = 1;
LABEL_39:

        return v2;
      }
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_add_input_handler_cold_5();
      }
    }
    else if ((*(_BYTE *)(v2 + 475) & 1) == 0
           && g_boringssl_log
           && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_add_input_handler_cold_4();
    }
    v2 = 0;
    goto LABEL_39;
  }
  return v2;
}

uint64_t boringssl_context_set_attribution(uint64_t result, int a2)
{
  uint64_t v2;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v2 = *(_QWORD *)(result + 8)) != 0)
    {
      *(_QWORD *)(v2 + 272) = a2 == 2;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t boringssl_bio_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  BIO *v7;
  _QWORD *v8;

  v3 = 0;
  if (a2 && a3)
  {
    v7 = BIO_new(&methods_boringssl_bio);
    if (v7)
    {
      v3 = (uint64_t)v7;
      v8 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
      if (v8)
      {
        *v8 = a1;
        v8[1] = a2;
        v8[2] = a3;
        *(_QWORD *)(v3 + 32) = v8;
      }
      else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        boringssl_bio_create_cold_2();
      }
    }
    else
    {
      v3 = g_boringssl_log;
      if (g_boringssl_log)
      {
        if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          boringssl_bio_create_cold_1();
        return 0;
      }
    }
  }
  return v3;
}

BIO *__cdecl BIO_new(BIO_METHOD *type)
{
  BIO *v2;
  BIO *v3;
  int (__cdecl *create)(BIO *);

  v2 = (BIO *)OPENSSL_malloc(0x40uLL);
  v3 = v2;
  if (v2)
  {
    *(_OWORD *)&v2->method = 0u;
    *(_OWORD *)&v2->cb_arg = 0u;
    *(_OWORD *)&v2->flags = 0u;
    *(_OWORD *)&v2->ptr = 0u;
    v2->method = type;
    HIDWORD(v2->callback) = 1;
    v2->shutdown = 1;
    create = type->create;
    if (create)
    {
      if (!((unsigned int (*)(BIO *))create)(v2))
      {
        OPENSSL_free(v3);
        return 0;
      }
    }
  }
  return v3;
}

uint64_t boringssl_bio_new(uint64_t a1)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return 1;
}

SSL_CTX *boringssl_session_create(SSL_CTX *result)
{
  SSL_CTX *v1;
  STACK *cipher_list;
  STACK *v3;
  __int16 min_dtls_version_allowed;
  __int16 max_dtls_version_allowed;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  unint64_t v8;

  if (result)
  {
    v1 = result;
    if (LODWORD(result->method) != -1252936367)
      return 0;
    cipher_list = result->cipher_list;
    if (!cipher_list)
      return 0;
    result = (SSL_CTX *)cipher_list[12].comp;
    if (result)
    {
      *(_QWORD *)&cipher_list[12].sorted = SSL_new(result);
      result = *(SSL_CTX **)&cipher_list[12].sorted;
      if (result)
      {
        if ((BYTE4(cipher_list[17].data) & 0x10) != 0)
          SSL_set_accept_state((SSL *)result);
        else
          SSL_set_connect_state((SSL *)result);
        if (LODWORD(v1->method) == -1252936367)
        {
          v3 = v1->cipher_list;
          if (v3)
          {
            if ((BYTE4(v3[17].data) & 0x20) != 0)
              min_dtls_version_allowed = boringssl_config_get_min_dtls_version_allowed();
            else
              min_dtls_version_allowed = boringssl_config_get_min_tls_version_allowed();
            WORD1(v3[1].comp) = min_dtls_version_allowed;
            if ((BYTE4(v3[17].data) & 0x20) != 0)
              max_dtls_version_allowed = boringssl_config_get_max_dtls_version_allowed();
            else
              max_dtls_version_allowed = boringssl_config_get_max_tls_version_allowed();
            LOWORD(v3[1].comp) = max_dtls_version_allowed;
            boringssl_context_set_min_version((uint64_t)v1, WORD1(v3[1].comp));
            boringssl_context_set_max_version((uint64_t)v1, (unsigned __int16)v3[1].comp);
            SSL_set_msg_callback(*(SSL **)&v3[12].sorted, (void (__cdecl *)(int, int, int, const void *, size_t, SSL *, void *))boringssl_context_message_handler);
            SSL_set_msg_callback_arg(*(_QWORD *)&v3[12].sorted, (uint64_t)v1);
            SSL_set_cert_cb(*(_QWORD *)&v3[12].sorted, (uint64_t)boringssl_context_certificate_request_callback, (uint64_t)v1);
            v8 = 0;
            v6 = (unsigned __int16 *)boringssl_ciphers_copy_default_ciphersuites(&v8);
            v7 = v6;
            if (v6 && v8)
            {
              boringssl_context_set_cipher_suites((uint64_t)v1, v6, v8);
            }
            else if (!v6)
            {
              return (SSL_CTX *)(SSL_set_ex_data(*(SSL **)&cipher_list[12].sorted, 0, v1) == 1);
            }
            free(v7);
            return (SSL_CTX *)(SSL_set_ex_data(*(SSL **)&cipher_list[12].sorted, 0, v1) == 1);
          }
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t boringssl_context_set_min_version(uint64_t a1, uint64_t a2)
{
  char *v2;
  uint64_t v4;
  uint64_t v6;
  int v7;
  uint64_t result;
  int v9;
  id v10;
  void *v11;
  _BYTE *v12;
  char v13;
  id v14;
  _BYTE *v15;
  _BOOL4 v16;
  id WeakRetained;
  void *v18;
  _BYTE *v19;
  char v20;
  id v21;
  _BYTE *v22;
  _BOOL4 v23;
  NSObject *v24;
  NSObject *v25;
  id v26;
  void *v27;
  id v28;
  int v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  void *v34;
  __int16 v35;
  id v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 8);
  if (!v4 || !*(_QWORD *)(v4 + 400))
    return 0xFFFFFFFFLL;
  if (os_variant_has_internal_content()
    && boringssl_config_get_restricted_mode_state()
    && (*(_DWORD *)a1 != -1252936367 || (v6 = *(_QWORD *)(a1 + 8)) == 0 || (*(_BYTE *)(v6 + 556) & 0x20) != 0
      ? (v7 = boringssl_config_restricted_mode_restrict_dtls_version(a2))
      : (v7 = boringssl_config_restricted_mode_restrict_tls_version(a2)),
        v9 = v7,
        v7 != (_DWORD)a2))
  {
    WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
    if (!WeakRetained
      || (v18 = WeakRetained,
          v19 = objc_loadWeakRetained((id *)(v4 + 16)),
          v20 = v19[475],
          v19,
          v18,
          (v20 & 1) == 0))
    {
      v21 = objc_loadWeakRetained((id *)(v4 + 16));
      if (v21)
      {
        v22 = objc_loadWeakRetained((id *)(v4 + 16));
        v23 = (v22[475] & 1) == 0;

      }
      else
      {
        v23 = 1;
      }

      if (v23)
      {
        if (g_boringssl_log)
        {
          v25 = (id)g_boringssl_log;
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
          {
            v26 = objc_loadWeakRetained((id *)(v4 + 16));
            if (v26)
            {
              v2 = (char *)objc_loadWeakRetained((id *)(v4 + 16));
              v27 = v2 + 391;
            }
            else
            {
              v27 = &unk_1B50022E3;
            }
            v28 = objc_loadWeakRetained((id *)(v4 + 16));
            v29 = 136447490;
            v30 = "boringssl_context_set_min_version";
            v31 = 1024;
            v32 = 182;
            v33 = 2082;
            v34 = v27;
            v35 = 2048;
            v36 = v28;
            v37 = 1024;
            v38 = a2;
            v39 = 1024;
            v40 = v9;
            _os_log_debug_impl(&dword_1B4F6D000, v25, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Restricted mode: Provided minimum version (0x%x) was capped to (0x%x).", (uint8_t *)&v29, 0x32u);

            if (v26)
          }

        }
      }
    }
  }
  else
  {
    LOWORD(v9) = a2;
  }
  if (SSL_set_min_proto_version(*(_QWORD *)(v4 + 400), (unsigned __int16)v9))
  {
    result = 0;
    *(_WORD *)(v4 + 58) = v9;
    return result;
  }
  v10 = objc_loadWeakRetained((id *)(v4 + 16));
  if (v10)
  {
    v11 = v10;
    v12 = objc_loadWeakRetained((id *)(v4 + 16));
    v13 = v12[475];

    if ((v13 & 1) != 0)
      return 0;
  }
  v14 = objc_loadWeakRetained((id *)(v4 + 16));
  if (v14)
  {
    v15 = objc_loadWeakRetained((id *)(v4 + 16));
    v16 = (v15[475] & 1) == 0;

  }
  else
  {
    v16 = 1;
  }

  result = 0;
  if (v16 && g_boringssl_log)
  {
    v24 = (id)g_boringssl_log;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      boringssl_context_set_min_version_cold_1(v4 + 16, v24);

    return 0;
  }
  return result;
}

uint64_t boringssl_config_get_restricted_mode_state()
{
  uint64_t result;

  result = os_variant_has_internal_content();
  if ((_DWORD)result)
  {
    if (check_and_init_restricted_mode_onceToken != -1)
      dispatch_once(&check_and_init_restricted_mode_onceToken, &__block_literal_global_255);
    return boringssl_config_restricted_mode_status;
  }
  return result;
}

uint64_t SSL_set_min_proto_version(uint64_t a1, int a2)
{
  uint64_t v2;
  _BYTE *v4;
  __int16 *v5;
  __int16 v7;

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0;
  v4 = *(_BYTE **)a1;
  v5 = (__int16 *)(v2 + 10);
  if (a2)
    return bssl::set_version_bound(v4, v5, a2);
  if (*v4)
    v7 = -257;
  else
    v7 = 769;
  *v5 = v7;
  return 1;
}

uint64_t bssl::set_version_bound(_BYTE *a1, _WORD *a2, int a3)
{
  uint64_t v5;
  unsigned __int16 *v6;
  uint64_t v7;
  int v8;
  int v9;
  BOOL v10;

  if ((a3 - 769) >= 4 && a3 != 65279 && a3 != 65277)
    goto LABEL_21;
  v5 = 8;
  if (*a1)
    v5 = 4;
  v6 = (unsigned __int16 *)&bssl::kDTLSVersions;
  if (!*a1)
    v6 = (unsigned __int16 *)&bssl::kTLSVersions;
  v7 = v5 - 2;
  do
  {
    v9 = *v6++;
    v8 = v9;
    v10 = v9 == a3 || v7 == 0;
    v7 -= 2;
  }
  while (!v10);
  if (v8 == a3)
  {
    *a2 = a3;
    return 1;
  }
  else
  {
LABEL_21:
    ERR_put_error(16, 0, 234, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_versions.cc", 130);
    return 0;
  }
}

uint64_t SSL_set_msg_callback_arg(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 72) = a2;
  return result;
}

void SSL_set_msg_callback(SSL *ssl, void (__cdecl *cb)(int, int, int, const void *, size_t, SSL *, void *))
{
  *(_QWORD *)&ssl->quiet_shutdown = cb;
}

_QWORD *boringssl_context_create_with_nw_context(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  _QWORD *v6;
  boringssl_concrete_boringssl_ctx *v7;
  boringssl_concrete_boringssl_ctx *v8;
  id v9;
  uint64_t singleton;
  OS_nw_protocol_metadata *metadata;
  boringssl_concrete_boringssl_ctx *v12;
  _QWORD *v13;
  id WeakRetained;
  void *v15;
  _BYTE *v16;
  char v17;
  id v18;
  _BYTE *v19;
  _BOOL4 v20;
  NSObject *v21;

  v3 = a1;
  v4 = a2;
  v5 = v4;
  v6 = 0;
  if (v3 && v4)
  {
    v7 = objc_alloc_init(boringssl_concrete_boringssl_ctx);
    v8 = v7;
    if (v7)
    {
      v7->ssl_state = 0;
      v7->peer_trust_result = 0;
      v7->max_allowed_tls_version = boringssl_config_get_max_tls_version_allowed();
      v8->max_allowed_dtls_version = boringssl_config_get_max_dtls_version_allowed();
      v8->min_allowed_tls_version = boringssl_config_get_min_tls_version_allowed();
      v8->min_allowed_dtls_version = boringssl_config_get_min_dtls_version_allowed();
      v9 = nw_protocol_boringssl_copy_definition();
      singleton = nw_protocol_metadata_create_singleton();
      metadata = v8->metadata;
      v8->metadata = (OS_nw_protocol_metadata *)singleton;

      boringssl_log_open();
      objc_storeWeak((id *)&v8->boringssl_handle, v3);
      objc_storeStrong((id *)&v8->async_context, a2);
      v12 = v8;
      v13 = malloc_type_malloc(0x10uLL, 0x10800407411B482uLL);
      if (v13)
      {
        v6 = v13;
        v12->legacy_context = (boringssl_legacy_ctx *)v13;
        *(_DWORD *)v13 = -1252936367;
        v13[1] = v12;
LABEL_17:

        goto LABEL_18;
      }
      WeakRetained = objc_loadWeakRetained((id *)&v8->boringssl_handle);
      if (!WeakRetained
        || (v15 = WeakRetained,
            v16 = objc_loadWeakRetained((id *)&v8->boringssl_handle),
            v17 = v16[475],
            v16,
            v15,
            (v17 & 1) == 0))
      {
        v18 = objc_loadWeakRetained((id *)&v8->boringssl_handle);
        if (v18)
        {
          v19 = objc_loadWeakRetained((id *)&v8->boringssl_handle);
          v20 = (v19[475] & 1) == 0;

        }
        else
        {
          v20 = 1;
        }

        v6 = 0;
        if (!v20 || !g_boringssl_log)
          goto LABEL_17;
        v21 = (id)g_boringssl_log;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          boringssl_context_create_with_nw_context_cold_1(&v8->boringssl_handle, v21);

      }
    }
    v6 = 0;
    goto LABEL_17;
  }
LABEL_18:

  return v6;
}

uint64_t boringssl_config_get_max_tls_version_allowed()
{
  return 772;
}

uint64_t boringssl_config_get_min_tls_version_allowed()
{
  return 769;
}

uint64_t ssl_do_post_handshake(uint64_t a1, uint64_t a2)
{
  if (bssl::ssl_protocol_version((bssl *)a1, (const ssl_st *)a2) >= 0x304)
    return bssl::tls13_post_handshake((bssl *)a1, a2);
  if ((*(_BYTE *)(a1 + 180) & 1) != 0)
  {
    ERR_put_error(16, 0, 182, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 1146);
    goto LABEL_8;
  }
  if (*(_BYTE *)(a2 + 1) || CBS_len(a2 + 8))
  {
    bssl::ssl_send_alert((bssl *)a1, (ssl_st *)2, 50);
    ERR_put_error(16, 0, 110, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 1153);
    return 0;
  }
  if (*(_DWORD *)(a1 + 176) != 3)
  {
    *(_WORD *)(*(_QWORD *)(a1 + 48) + 220) |= 0x2000u;
    if (*(_DWORD *)(a1 + 176) != 4 && !SSL_renegotiate((SSL *)a1))
    {
LABEL_8:
      bssl::ssl_send_alert((bssl *)a1, (ssl_st *)2, 100);
      return 0;
    }
  }
  return 1;
}

uint64_t bssl::tls13_process_new_session_ticket(bssl *a1, uint64_t a2)
{
  _BOOL8 v2;
  SSL_SESSION *v4;
  uint64_t v5;
  unsigned int (*v6)(bssl *, SSL_SESSION *);
  SSL_SESSION *ses;
  __int128 v9;

  if (*(_DWORD *)(*((_QWORD *)a1 + 6) + 176))
    return 1;
  v9 = *(_OWORD *)(a2 + 8);
  ses = (SSL_SESSION *)0xAAAAAAAAAAAAAAAALL;
  bssl::tls13_create_session_with_ticket(a1, (uint64_t *)&v9, &ses);
  v4 = ses;
  v2 = ses != 0;
  if (ses)
  {
    v5 = *((_QWORD *)a1 + 16);
    if ((*(_BYTE *)(v5 + 292) & 1) == 0
      || (v6 = *(unsigned int (**)(bssl *, SSL_SESSION *))(v5 + 304)) == 0
      || !v6(a1, ses))
    {
      ses = 0;
      SSL_SESSION_free(v4);
    }
  }
  return v2;
}

void sub_1B4F9FB18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)va, 0);
  _Unwind_Resume(a1);
}

void SSL_SESSION_free(SSL_SESSION *ses)
{
  _QWORD *v2;

  if (ses)
  {
    if (CRYPTO_refcount_dec_and_test_zero((unsigned int *)ses))
    {
      ssl_session_st::~ssl_session_st(ses);
      OPENSSL_free(v2);
    }
  }
}

uint64_t boringssl_context_new_session_handler(const SSL *a1, uint64_t a2)
{
  unint64_t v2;
  char *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  id WeakRetained;
  void *v9;
  _BYTE *v10;
  char v11;
  id v12;
  _BYTE *v13;
  _BOOL4 v14;
  NSObject *v15;
  id v16;
  void *v17;
  id v18;
  boringssl_concrete_boringssl_session_state *v19;
  _QWORD *v20;
  id v21;
  void *v22;
  _BYTE *v23;
  char v24;
  id v25;
  _BYTE *v26;
  _BOOL4 v27;
  id v28;
  void *v29;
  _BYTE *v30;
  char v31;
  id v32;
  _BYTE *v33;
  _BOOL4 v34;
  NSObject *v35;
  id v36;
  NSObject *v37;
  id v38;
  void *v39;
  id v40;
  _QWORD *v41;
  void *v42;
  void *v43;
  id v44;
  void *v45;
  unsigned __int8 *v46;
  id v47;
  _BYTE *v48;
  NSObject *v49;
  id v50;
  void *v51;
  _BYTE *v52;
  char v53;
  id v54;
  _BYTE *v55;
  _BOOL4 v56;
  NSObject *v57;
  id v58;
  void *v59;
  id v60;
  id v61;
  char *v63;
  void *v64;
  _QWORD block[4];
  id v66;
  uint8_t buf[4];
  const char *v68;
  __int16 v69;
  int v70;
  __int16 v71;
  void *v72;
  __int16 v73;
  id v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      v4 = (char *)a1;
      v5 = SSL_get_ex_data(a1, 0);
      if (v5)
      {
        v6 = (uint64_t)v5;
        if (*(_DWORD *)v5 == -1252936367)
        {
          v7 = v5[1];
          if (v7)
          {
            WeakRetained = objc_loadWeakRetained((id *)(v7 + 16));
            if (!WeakRetained
              || (v9 = WeakRetained,
                  v10 = objc_loadWeakRetained((id *)(v7 + 16)),
                  v11 = v10[475],
                  v10,
                  v9,
                  (v11 & 1) == 0))
            {
              v12 = objc_loadWeakRetained((id *)(v7 + 16));
              if (v12)
              {
                v13 = objc_loadWeakRetained((id *)(v7 + 16));
                v14 = (v13[475] & 1) == 0;

              }
              else
              {
                v14 = 1;
              }

              if (v14)
              {
                if (g_boringssl_log)
                {
                  v15 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
                  {
                    v16 = objc_loadWeakRetained((id *)(v7 + 16));
                    if (v16)
                    {
                      v2 = (unint64_t)objc_loadWeakRetained((id *)(v7 + 16));
                      v17 = (void *)(v2 + 391);
                    }
                    else
                    {
                      v17 = &unk_1B50022E3;
                    }
                    v18 = objc_loadWeakRetained((id *)(v7 + 16));
                    *(_DWORD *)buf = 136446978;
                    v68 = "boringssl_context_new_session_handler";
                    v69 = 1024;
                    v70 = 1473;
                    v71 = 2082;
                    v72 = v17;
                    v73 = 2048;
                    v74 = v18;
                    _os_log_impl(&dword_1B4F6D000, v15, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] New session available", buf, 0x26u);

                    if (v16)
                  }

                }
              }
            }
            v19 = boringssl_session_state_create(a2, (unsigned __int8 *)(v7 + 224));
            if (v19)
            {
              objc_storeStrong((id *)(v7 + 392), v19);
              if (*(_QWORD *)(v7 + 168))
              {
                boringssl_session_update_metadata(v6);
                v20 = (id)v7;
                v21 = objc_loadWeakRetained((id *)(v7 + 16));
                if (!v21
                  || (v22 = v21,
                      v23 = objc_loadWeakRetained((id *)(v7 + 16)),
                      v24 = v23[475],
                      v23,
                      v22,
                      (v24 & 1) == 0))
                {
                  v25 = objc_loadWeakRetained((id *)(v7 + 16));
                  if (v25)
                  {
                    v26 = objc_loadWeakRetained((id *)(v7 + 16));
                    v27 = (v26[475] & 1) == 0;

                  }
                  else
                  {
                    v27 = 1;
                  }

                  if (v27)
                  {
                    if (g_boringssl_log)
                    {
                      v35 = (id)g_boringssl_log;
                      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                      {
                        v36 = objc_loadWeakRetained((id *)(v7 + 16));
                        if (v36)
                        {
                          v63 = (char *)objc_loadWeakRetained((id *)(v7 + 16));
                          v64 = v63 + 391;
                        }
                        else
                        {
                          v64 = &unk_1B50022E3;
                        }
                        v40 = objc_loadWeakRetained((id *)(v7 + 16));
                        *(_DWORD *)buf = 136446978;
                        v68 = "boringssl_context_new_session_handler";
                        v69 = 1024;
                        v70 = 1486;
                        v71 = 2082;
                        v72 = v64;
                        v73 = 2048;
                        v74 = v40;
                        _os_log_impl(&dword_1B4F6D000, v35, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] Asyncing for session update block", buf, 0x26u);

                        if (v36)
                      }

                    }
                  }
                }
                v2 = v20[22];
                block[0] = MEMORY[0x1E0C809B0];
                block[1] = 3221225472;
                block[2] = __boringssl_context_new_session_handler_block_invoke;
                block[3] = &unk_1E686E748;
                v41 = v20;
                v42 = v41;
                v66 = v41;
                v43 = v41;
                if (v2)
                {
                  ++v41[63];
                  dispatch_async((dispatch_queue_t)v2, block);
                  v43 = v66;
                }

              }
              if (*(_QWORD *)(v7 + 32))
              {
                v44 = objc_loadWeakRetained((id *)(v7 + 16));
                if (!v44
                  || (v45 = v44,
                      v46 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v7 + 16)),
                      v2 = v46[475],
                      v46,
                      v45,
                      (v2 & 1) == 0))
                {
                  v47 = objc_loadWeakRetained((id *)(v7 + 16));
                  if (v47)
                  {
                    v48 = objc_loadWeakRetained((id *)(v7 + 16));
                    v2 = (v48[475] & 1) == 0;

                  }
                  else
                  {
                    v2 = 1;
                  }

                  if ((_DWORD)v2)
                  {
                    if (g_boringssl_log)
                    {
                      v49 = (id)g_boringssl_log;
                      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
                        boringssl_context_new_session_handler_cold_1(v7 + 16, v49);

                    }
                  }
                }
                boringssl_session_cache_push(*(void **)(v7 + 32), v19);
              }
              if (SSL_session_reused((uint64_t)v4) && *(_QWORD *)(v7 + 360))
              {
                v50 = objc_loadWeakRetained((id *)(v7 + 16));
                if (!v50
                  || (v51 = v50,
                      v52 = objc_loadWeakRetained((id *)(v7 + 16)),
                      v53 = v52[475],
                      v52,
                      v51,
                      (v53 & 1) == 0))
                {
                  v54 = objc_loadWeakRetained((id *)(v7 + 16));
                  if (v54)
                  {
                    v55 = objc_loadWeakRetained((id *)(v7 + 16));
                    v56 = (v55[475] & 1) == 0;

                  }
                  else
                  {
                    v56 = 1;
                  }

                  if (v56)
                  {
                    if (g_boringssl_log)
                    {
                      v57 = (id)g_boringssl_log;
                      if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
                      {
                        v58 = objc_loadWeakRetained((id *)(v7 + 16));
                        if (v58)
                        {
                          v2 = (unint64_t)objc_loadWeakRetained((id *)(v7 + 16));
                          v59 = (void *)(v2 + 391);
                        }
                        else
                        {
                          v59 = &unk_1B50022E3;
                        }
                        v61 = objc_loadWeakRetained((id *)(v7 + 16));
                        *(_DWORD *)buf = 136446978;
                        v68 = "boringssl_context_new_session_handler";
                        v69 = 1024;
                        v70 = 1502;
                        v71 = 2082;
                        v72 = v59;
                        v73 = 2048;
                        v74 = v61;
                        _os_log_impl(&dword_1B4F6D000, v57, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Rebuilding session state for resumed session", buf, 0x26u);

                        if (v58)
                      }

                    }
                  }
                }
                boringssl_session_set_peer_verification_state_from_session(v6, a2);
              }
            }
            else
            {
              v28 = objc_loadWeakRetained((id *)(v7 + 16));
              if (!v28
                || (v29 = v28,
                    v30 = objc_loadWeakRetained((id *)(v7 + 16)),
                    v31 = v30[475],
                    v30,
                    v29,
                    (v31 & 1) == 0))
              {
                v32 = objc_loadWeakRetained((id *)(v7 + 16));
                if (v32)
                {
                  v33 = objc_loadWeakRetained((id *)(v7 + 16));
                  v34 = (v33[475] & 1) == 0;

                }
                else
                {
                  v34 = 1;
                }

                if (v34)
                {
                  if (g_boringssl_log)
                  {
                    v37 = (id)g_boringssl_log;
                    if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
                    {
                      v38 = objc_loadWeakRetained((id *)(v7 + 16));
                      if (v38)
                      {
                        v4 = (char *)objc_loadWeakRetained((id *)(v7 + 16));
                        v39 = v4 + 391;
                      }
                      else
                      {
                        v39 = &unk_1B50022E3;
                      }
                      v60 = objc_loadWeakRetained((id *)(v7 + 16));
                      *(_DWORD *)buf = 136446978;
                      v68 = "boringssl_context_new_session_handler";
                      v69 = 1024;
                      v70 = 1477;
                      v71 = 2082;
                      v72 = v39;
                      v73 = 2048;
                      v74 = v60;
                      _os_log_impl(&dword_1B4F6D000, v37, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] boringssl_session_state_create failed", buf, 0x26u);

                      if (v38)
                    }

                  }
                }
              }
            }

          }
        }
      }
    }
  }
  return 0;
}

boringssl_concrete_boringssl_session_state *boringssl_session_state_create(uint64_t a1, unsigned __int8 *a2)
{
  boringssl_concrete_boringssl_session_state *v2;
  boringssl_concrete_boringssl_session_state *v5;
  boringssl_concrete_boringssl_session_state *v6;

  v2 = 0;
  if (a1 && a2)
  {
    v5 = objc_alloc_init(boringssl_concrete_boringssl_session_state);
    v6 = v5;
    if (v5)
    {
      v5->cached_content_type = 1;
      v5->used_extended_master_secret = SSL_SESSION_used_extended_master_secret(a1);
      memcpy(&v6->remote_address, a2, *a2);
      if (SSL_SESSION_to_bytes(a1, &v6->serialized_session, &v6->serialized_session_length))
      {
        v2 = v6;
LABEL_13:

        return v2;
      }
      if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        boringssl_session_state_create_cold_2();
    }
    else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      boringssl_session_state_create_cold_1();
    }
    v2 = 0;
    goto LABEL_13;
  }
  return v2;
}

void boringssl_session_cache_push(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  id v6;
  id v7;
  id v8;

  v8 = a1;
  v3 = a2;
  if (v8 && v3)
  {
    v4 = boringssl_session_cache_copy_queue();
    if (!v4)
    {
      v5 = (void *)sec_array_create();
      if (!v5)
      {
        v4 = 0;
LABEL_9:

        goto LABEL_10;
      }
      v4 = v5;
    }
    sec_array_append();
    v6 = nw_protocol_boringssl_copy_definition();
    time(0);
    nw_association_set_cached_content_for_protocol();

    if ((unint64_t)sec_array_get_count() >= 2)
      v7 = boringssl_session_cache_pop(v8);
    goto LABEL_9;
  }
LABEL_10:

}

uint64_t SSL_SESSION_used_extended_master_secret(uint64_t a1)
{
  if (*(unsigned __int16 *)(a1 + 4) <= 0x303u)
    return *(_BYTE *)(a1 + 448) & 1;
  else
    return 1;
}

BOOL SSL_SESSION_to_bytes(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  __int128 v6;
  _BOOL8 v7;
  _QWORD *v8;
  _OWORD v10[3];

  if ((*(_BYTE *)(a1 + 448) & 4) != 0)
  {
    *a3 = 13;
    v8 = OPENSSL_memdup("NOT RESUMABLE", 0xDuLL);
    *a2 = v8;
    return v8 != 0;
  }
  else
  {
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v10[1] = v6;
    v10[2] = v6;
    v10[0] = v6;
    CBB_zero(v10);
    v7 = CBB_init((uint64_t)v10, 0x100uLL)
      && bssl::SSL_SESSION_to_bytes_full(a1, (uint64_t *)v10, 0)
      && CBB_finish((uint64_t)v10, a2, a3) != 0;
    CBB_cleanup((uint64_t)v10);
  }
  return v7;
}

void sub_1B4FA059C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CBB_cleanup((uint64_t)&a9);
  _Unwind_Resume(a1);
}

id boringssl_session_cache_pop(void *a1)
{
  id v1;
  void *v2;
  id v3;
  id v4;
  id v5;
  id v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t);
  void (*v12)(uint64_t);
  id v13;

  v1 = a1;
  v2 = boringssl_session_cache_copy_queue();
  if (v2 || (v2 = (void *)sec_array_create()) != 0)
  {
    v8 = 0;
    v9 = &v8;
    v10 = 0x3032000000;
    v11 = __Block_byref_object_copy__0;
    v12 = __Block_byref_object_dispose__0;
    v13 = 0;
    v7 = (id)sec_array_create();
    sec_array_apply();
    v3 = nw_protocol_boringssl_copy_definition();
    v4 = v7;
    time(0);
    nw_association_set_cached_content_for_protocol();

    v5 = (id)v9[5];
    _Block_object_dispose(&v8, 8);

  }
  else
  {
    v5 = 0;
  }

  return v5;
}

void sub_1B4FA06F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *boringssl_session_cache_copy_queue()
{
  id v0;
  void *cached_content_for_protocol;
  id v2;

  v0 = nw_protocol_boringssl_copy_definition();
  cached_content_for_protocol = (void *)nw_association_get_cached_content_for_protocol();

  if (cached_content_for_protocol)
    v2 = cached_content_for_protocol;
  return cached_content_for_protocol;
}

id nw_protocol_boringssl_copy_definition()
{
  if (nw_protocol_boringssl_copy_definition_onceToken != -1)
    dispatch_once(&nw_protocol_boringssl_copy_definition_onceToken, &__block_literal_global_127);
  return (id)nw_protocol_boringssl_copy_definition_definition;
}

void bssl::tls13_create_session_with_ticket(bssl *a1@<X0>, uint64_t *a2@<X1>, SSL_SESSION **a3@<X8>)
{
  ssl_session_st *v6;
  const void *v7;
  size_t v8;
  void **p_prev;
  int v10;
  char v11;
  SSL_SESSION *v12;
  SSL_SESSION *v13;
  int v14;
  SSL_SESSION *v15;
  const unsigned __int8 *v16;
  size_t v17;
  unsigned __int8 v18;
  _DWORD v19[6];
  __int128 v20;
  unint64_t v21[4];
  unsigned int v22;
  SSL_SESSION *ses;
  uint64_t v24[2];

  v24[1] = *MEMORY[0x1E0C80C00];
  ses = (SSL_SESSION *)0xAAAAAAAAAAAAAAAALL;
  bssl::SSL_SESSION_dup(*(bssl **)(*((_QWORD *)a1 + 6) + 472), (ssl_session_st *)2, &ses);
  if (!ses)
  {
    *a3 = 0;
    return;
  }
  bssl::ssl_session_rebase_time(a1, (ssl_st *)ses, v6);
  v22 = -1431655766;
  memset(v21, 170, sizeof(v21));
  *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u32(a2, (int *)&v22)
    || !CBS_get_u32(a2, (int *)&ses[1].session_id[24])
    || !CBS_get_u8_length_prefixed((unsigned __int8 **)a2, &v21[2])
    || !CBS_get_u16_length_prefixed((unsigned __int8 **)a2, v21))
  {
    goto LABEL_13;
  }
  v7 = (const void *)v21[0];
  v8 = v21[1];
  p_prev = (void **)&ses->prev;
  v10 = bssl::Array<unsigned char>::Init((uint64_t)&ses->prev, v21[1]);
  v11 = v10 ^ 1;
  if (!v8)
    v11 = 1;
  if ((v11 & 1) == 0)
    memcpy(*p_prev, v7, v8);
  if (!v10
    || !CBS_get_u16_length_prefixed((unsigned __int8 **)a2, (unint64_t *)&v20)
    || CBS_len((uint64_t)a2))
  {
LABEL_13:
    bssl::ssl_send_alert(a1, (ssl_st *)2, 50);
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 1092);
LABEL_14:
    *a3 = 0;
    goto LABEL_15;
  }
  v13 = ses;
  if (ses->compress_meth > v22)
    ses->compress_meth = v22;
  if (!bssl::tls13_derive_session_psk(&v13->ssl_version, (const ssl_session_st *)v21[2], v21[3]))
    goto LABEL_14;
  memset(&v19[1], 170, 20);
  v19[0] = 65578;
  CBS_init(&v19[2], 0, 0);
  v18 = 50;
  v24[0] = (uint64_t)v19;
  if ((bssl::ssl_parse_extensions(&v20, (char *)&v18, v24, 1, 1) & 1) == 0)
  {
    bssl::ssl_send_alert(a1, (ssl_st *)2, v18);
    goto LABEL_29;
  }
  if (!HIBYTE(v19[0]))
    goto LABEL_33;
  if (CBS_get_u32((uint64_t *)&v19[2], (int *)&ses[1].session_id[28]) && !CBS_len((uint64_t)&v19[2]))
  {
    if (*((_QWORD *)a1 + 21) && *(_DWORD *)&ses[1].session_id[28] != -1)
    {
      bssl::ssl_send_alert(a1, (ssl_st *)2, 47);
      v14 = 1127;
      goto LABEL_27;
    }
LABEL_33:
    v16 = (const unsigned __int8 *)CBS_data((uint64_t)v21);
    v17 = CBS_len((uint64_t)v21);
    SHA256(v16, v17, (unsigned __int8 *)&ses->session_id_length);
    v15 = ses;
    *(_DWORD *)&ses->master_key[44] = 32;
    LOBYTE(v15[1].verify_result) = v15[1].verify_result & 0xF3 | 8;
    ses = 0;
    goto LABEL_34;
  }
  bssl::ssl_send_alert(a1, (ssl_st *)2, 50);
  v14 = 1118;
LABEL_27:
  ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", v14);
LABEL_29:
  v15 = 0;
LABEL_34:
  *a3 = v15;
LABEL_15:
  v12 = ses;
  ses = 0;
  if (v12)
    SSL_SESSION_free(v12);
}

void sub_1B4FA0A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t CBS_get_u32(uint64_t *a1, int *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v5;
  int v6;
  uint64_t v7;

  v2 = a1[1];
  v3 = v2 - 4;
  if (v2 < 4)
    return 0;
  v5 = 0;
  v6 = 0;
  v7 = *a1;
  *a1 += 4;
  a1[1] = v3;
  do
    v6 = *(unsigned __int8 *)(v7 + v5++) | (v6 << 8);
  while (v5 != 4);
  *a2 = v6;
  return 1;
}

BOOL bssl::tls13_derive_session_psk(int *a1, const ssl_session_st *a2, size_t a3)
{
  EVP_MD *digest;
  uint64_t v7;

  digest = (EVP_MD *)bssl::ssl_session_get_digest((bssl *)a1, a2);
  return bssl::hkdf_expand_label((_DWORD)a1 + 16, a1[3], digest, (uint64_t)(a1 + 4), a1[3], "resumption", 0xAuLL, v7, a2, a3);
}

uint64_t bssl::tls13_post_handshake(bssl *this, uint64_t a2)
{
  int v3;
  uint64_t v4;
  unsigned __int8 v5;
  int v6;
  uint64_t result;
  int v8;
  bssl *v9;
  int v10;
  unsigned __int8 v11;
  __int128 v12;

  v3 = *(unsigned __int8 *)(a2 + 1);
  v4 = *((_QWORD *)this + 6);
  if (v3 != 24)
  {
    *(_BYTE *)(v4 + 212) = 0;
    if (v3 == 4 && (*((_BYTE *)this + 180) & 1) == 0)
      return bssl::tls13_process_new_session_ticket(this, a2);
    bssl::ssl_send_alert(this, (ssl_st *)2, 10);
    ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 894);
    return 0;
  }
  v5 = *(_BYTE *)(v4 + 212) + 1;
  *(_BYTE *)(v4 + 212) = v5;
  if (*((_QWORD *)this + 21) || v5 >= 0x21u)
  {
    ERR_put_error(16, 0, 260, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 879);
    v9 = this;
    v10 = 10;
LABEL_18:
    bssl::ssl_send_alert(v9, (ssl_st *)2, v10);
    return 0;
  }
  v12 = *(_OWORD *)(a2 + 8);
  v11 = -86;
  if (!CBS_get_u8(&v12, &v11) || CBS_len((uint64_t)&v12) || v11 >= 2u)
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 855);
    v9 = this;
    v10 = 50;
    goto LABEL_18;
  }
  v6 = bssl::tls13_rotate_traffic_key((const SSL *)this, 0);
  result = 0;
  if (v6)
  {
    if (v11 != 1)
      return 1;
    if ((*(_WORD *)(*((_QWORD *)this + 6) + 220) & 0x400) != 0)
      return 1;
    v8 = bssl::tls13_add_key_update(this, 0);
    result = 0;
    if (v8)
      return 1;
  }
  return result;
}

unsigned __int8 *__cdecl SHA256(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  SHA256_CTX v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  memset(&v5.Nl, 0, 76);
  *(_OWORD *)v5.h = xmmword_1B5012580;
  *(_OWORD *)&v5.h[4] = xmmword_1B5012590;
  v5.md_len = 32;
  SHA256_Update(&v5, d, n);
  sha256_final_impl(md, v5.md_len, (uint64_t)&v5);
  OPENSSL_cleanse(&v5, 0x70uLL);
  return md;
}

uint64_t sha256_final_impl(_DWORD *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int32x2_t *v4;
  uint64_t v7;
  int8x8_t v8;
  uint64_t v9;
  uint64_t result;
  unint64_t v11;
  unsigned int v12;

  v3 = *(unsigned int *)(a3 + 104);
  if (v3 >= 0x40)
    sha256_final_impl_cold_1();
  v4 = (int32x2_t *)a3;
  v7 = a3 + 40;
  v8 = *(int8x8_t *)(a3 + 32);
  *(_BYTE *)(a3 + 40 + v3) = 0x80;
  v9 = v3 + 1;
  if (v3 < 0x38)
  {
    if (v3 == 55)
      goto LABEL_8;
  }
  else
  {
    if ((_DWORD)v3 != 63)
      bzero((void *)(v7 + v9), 63 - v3);
    sha256_block_data_order((unint64_t)v4, (unsigned int *)v7, 1);
    v9 = 0;
  }
  bzero((void *)(v7 + v9), 56 - v9);
LABEL_8:
  v4[12] = vrev64_s32((int32x2_t)vrev32_s8(v8));
  sha256_block_data_order((unint64_t)v4, (unsigned int *)v7, 1);
  result = 0;
  v4[13].i32[0] = 0;
  *(_OWORD *)v7 = 0u;
  *(_OWORD *)(v7 + 16) = 0u;
  *(_OWORD *)(v7 + 32) = 0u;
  *(_OWORD *)(v7 + 48) = 0u;
  if (a2 <= 0x20)
  {
    if ((a2 & 3) != 0)
      sha256_final_impl_cold_2();
    if (a2 >= 4)
    {
      v11 = a2 >> 2;
      do
      {
        v12 = v4->i32[0];
        v4 = (int32x2_t *)((char *)v4 + 4);
        *a1++ = bswap32(v12);
        --v11;
      }
      while (v11);
    }
    return 1;
  }
  return result;
}

unint64_t sha256_block_data_order(unint64_t result, unsigned int *a2, uint64_t a3)
{
  unsigned int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  unint64_t v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unint64_t v32;
  int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  unint64_t v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  unint64_t v44;
  int v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  int v50;
  unint64_t v51;
  int v52;
  int v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  unint64_t v57;
  int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  unint64_t v63;
  int v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  unint64_t v69;
  int v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  int v75;
  unint64_t v76;
  int v77;
  int v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  unint64_t v82;
  int v83;
  int v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  unint64_t v88;
  int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  unint64_t v94;
  int v95;
  unsigned int v96;
  unsigned int v97;
  unsigned int v98;
  int v99;
  unint64_t v100;
  int v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  int v105;
  unint64_t v106;
  int v107;
  unsigned int v108;
  unsigned int v109;
  int *v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  unsigned int v114;
  unsigned int v115;
  int v116;
  unint64_t v117;
  int v118;
  unint64_t v119;
  int v120;
  unint64_t v121;
  uint64_t v122;
  int v123;
  int v124;
  unsigned int v125;
  int v126;
  int v127;
  unint64_t v128;
  int v129;
  int v130;
  int v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int v134;
  int v135;
  int v136;
  unint64_t v137;
  int v138;
  int v139;
  int v140;
  int v141;
  unint64_t v142;
  unint64_t v143;
  int v144;
  int v145;
  unsigned int v146;
  unsigned int v147;
  int v148;
  unint64_t v149;
  int v150;
  uint64_t v151;
  unsigned int v152;
  int v153;
  int v154;
  int v155;
  unint64_t v156;
  int v157;
  int v158;
  unsigned int v159;
  int v160;
  int v161;
  int v162;
  unint64_t v163;
  int v164;
  uint64_t v165;
  int v166;
  int v167;
  unsigned int v168;
  int v169;
  int v170;
  unint64_t v171;
  int v172;
  int v173;
  unsigned int v174;
  unsigned int v175;
  int v176;
  unsigned int v177;
  unint64_t v178;
  uint64_t v179;
  int v180;
  unsigned int v181;
  int v182;
  int v183;
  unint64_t v184;
  int v185;
  unsigned int v186;
  int v187;
  int v188;
  int v189;
  int v190;
  unint64_t v191;
  uint64_t v192;
  unsigned int v193;
  int v194;
  int v195;
  unint64_t v196;
  int v197;
  int v198;
  unsigned int v199;
  unint64_t v200;
  unint64_t v201;
  uint64_t v202;
  int v203;
  int v204;
  unint64_t v205;
  int v206;
  unsigned int v207;
  unsigned int v208;
  int v209;
  unint64_t v210;
  uint64_t v211;
  int v212;
  int v213;
  unint64_t v214;
  int v215;
  int v216;
  _DWORD *v217;
  int v218;
  int v219;
  int v220;
  int v221;
  int v222;
  int v223;
  int v224;
  unsigned int v225;
  unsigned int *v226;
  uint64_t v227;
  _DWORD v228[16];
  uint64_t v229;

  v217 = (_DWORD *)result;
  v229 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v3 = *(_DWORD *)result;
    v4 = *(_DWORD *)(result + 4);
    v6 = *(_DWORD *)(result + 8);
    v5 = *(_DWORD *)(result + 12);
    v8 = *(_DWORD *)(result + 16);
    v7 = *(_DWORD *)(result + 20);
    v9 = *(_DWORD *)(result + 24);
    LODWORD(result) = *(_DWORD *)(result + 28);
    do
    {
      v227 = a3;
      v10 = bswap32(*a2);
      HIDWORD(v11) = v8;
      LODWORD(v11) = v8;
      v12 = (v11 >> 6) ^ __ROR4__(v8, 11);
      v13 = __PAIR64__(v3, __ROR4__(v8, 25));
      v218 = result;
      v14 = (v7 & v8) + result + (v9 & ~v8) + v10 + (v12 ^ v13) + 1116352408;
      LODWORD(v13) = v3;
      v222 = v5;
      v15 = v14 + v5;
      v16 = ((v6 ^ v4) & v3 ^ v6 & v4) + ((v13 >> 2) ^ __ROR4__(v3, 13) ^ __ROR4__(v3, 22)) + v14;
      v17 = bswap32(a2[1]);
      HIDWORD(v13) = v15;
      LODWORD(v13) = v15;
      v228[0] = v10;
      v228[1] = v17;
      v18 = (v13 >> 6) ^ __ROR4__(v15, 11);
      v19 = __PAIR64__(v16, __ROR4__(v15, 25));
      v219 = v9;
      v20 = v9 + v17 + (v7 & ~v15) + (v15 & v8) + 1899447441 + (v18 ^ v19);
      LODWORD(v19) = v16;
      v223 = v6;
      v21 = v20 + v6;
      v22 = ((v19 >> 2) ^ __ROR4__(v16, 13) ^ __ROR4__(v16, 22)) + (v16 & (v4 ^ v3) ^ v4 & v3) + v20;
      v23 = bswap32(a2[2]);
      HIDWORD(v19) = v21;
      LODWORD(v19) = v21;
      v24 = (v19 >> 6) ^ __ROR4__(v21, 11);
      v26 = __PAIR64__(v22, __ROR4__(v21, 25));
      v25 = v24 ^ v26;
      v220 = v7;
      LODWORD(v26) = v22;
      v27 = v7 + v23 + (v8 & ~v21) + (v21 & v15) - 1245643825 + v25;
      v224 = v4;
      v28 = v27 + v4;
      v29 = ((v26 >> 2) ^ __ROR4__(v22, 13) ^ __ROR4__(v22, 22)) + (v22 & (v16 ^ v3) ^ v16 & v3) + v27;
      v30 = bswap32(a2[3]);
      v228[2] = v23;
      v228[3] = v30;
      HIDWORD(v26) = v28;
      LODWORD(v26) = v28;
      v31 = (v26 >> 6) ^ __ROR4__(v28, 11);
      v32 = __PAIR64__(v29, __ROR4__(v28, 25));
      v221 = v8;
      v33 = v8 + v30 + (v15 & ~v28) + (v28 & v21) - 373957723 + (v31 ^ v32);
      LODWORD(v32) = v29;
      v225 = v3;
      v34 = v33 + v3;
      v35 = ((v32 >> 2) ^ __ROR4__(v29, 13) ^ __ROR4__(v29, 22)) + (v29 & (v22 ^ v16) ^ v22 & v16) + v33;
      v36 = bswap32(a2[4]);
      HIDWORD(v32) = v34;
      LODWORD(v32) = v34;
      v37 = (v32 >> 6) ^ __ROR4__(v34, 11);
      v38 = __PAIR64__(v35, __ROR4__(v34, 25));
      v39 = v15 + v36 + (v21 & ~v34) + (v34 & v28) + 961987163 + (v37 ^ v38);
      LODWORD(v38) = v35;
      v40 = v39 + v16;
      v41 = ((v38 >> 2) ^ __ROR4__(v35, 13) ^ __ROR4__(v35, 22)) + (v35 & (v29 ^ v22) ^ v29 & v22) + v39;
      v42 = bswap32(a2[5]);
      v228[4] = v36;
      v228[5] = v42;
      HIDWORD(v38) = v40;
      LODWORD(v38) = v40;
      v43 = (v38 >> 6) ^ __ROR4__(v40, 11);
      v44 = __PAIR64__(v41, __ROR4__(v40, 25));
      v45 = v42 + v21 + (v28 & ~v40) + (v40 & v34) + 1508970993 + (v43 ^ v44);
      LODWORD(v44) = v41;
      v46 = v45 + v22;
      v47 = ((v44 >> 2) ^ __ROR4__(v41, 13) ^ __ROR4__(v41, 22)) + (v41 & (v35 ^ v29) ^ v35 & v29) + v45;
      v48 = bswap32(a2[6]);
      v49 = v48 + v28 + (v34 & ~v46) + (v46 & v40);
      HIDWORD(v44) = v46;
      LODWORD(v44) = v46;
      v50 = (v44 >> 6) ^ __ROR4__(v46, 11);
      v51 = __PAIR64__(v47, __ROR4__(v46, 25));
      v52 = v49 - 1841331548 + (v50 ^ v51);
      LODWORD(v51) = v47;
      v53 = v52 + v29;
      v54 = ((v51 >> 2) ^ __ROR4__(v47, 13) ^ __ROR4__(v47, 22)) + (v47 & (v41 ^ v35) ^ v41 & v35) + v52;
      v55 = bswap32(a2[7]);
      HIDWORD(v51) = v53;
      LODWORD(v51) = v53;
      v228[6] = v48;
      v228[7] = v55;
      v56 = (v51 >> 6) ^ __ROR4__(v53, 11);
      v57 = __PAIR64__(v54, __ROR4__(v53, 25));
      v58 = v55 + v34 + (v40 & ~v53) + (v53 & v46) - 1424204075 + (v56 ^ v57);
      LODWORD(v57) = v54;
      v59 = v58 + v35;
      v60 = ((v57 >> 2) ^ __ROR4__(v54, 13) ^ __ROR4__(v54, 22)) + (v54 & (v47 ^ v41) ^ v47 & v41) + v58;
      HIDWORD(v57) = v59;
      LODWORD(v57) = v59;
      v61 = bswap32(a2[8]);
      v62 = (v57 >> 6) ^ __ROR4__(v59, 11);
      v63 = __PAIR64__(v60, __ROR4__(v59, 25));
      v64 = v61 + v40 + (v46 & ~v59) + (v59 & v53) - 670586216 + (v62 ^ v63);
      LODWORD(v63) = v60;
      v65 = v64 + v41;
      v66 = ((v63 >> 2) ^ __ROR4__(v60, 13) ^ __ROR4__(v60, 22)) + (v60 & (v54 ^ v47) ^ v54 & v47) + v64;
      v67 = bswap32(a2[9]);
      v228[8] = v61;
      v228[9] = v67;
      HIDWORD(v63) = v65;
      LODWORD(v63) = v65;
      v68 = (v63 >> 6) ^ __ROR4__(v65, 11);
      v69 = __PAIR64__(v66, __ROR4__(v65, 25));
      v70 = v67 + v46 + (v53 & ~v65) + (v65 & v59) + 310598401 + (v68 ^ v69);
      LODWORD(v69) = v66;
      v71 = v70 + v47;
      v72 = ((v69 >> 2) ^ __ROR4__(v66, 13) ^ __ROR4__(v66, 22)) + (v66 & (v60 ^ v54) ^ v60 & v54) + v70;
      v73 = bswap32(a2[10]);
      v74 = v73 + v53 + (v59 & ~v71) + (v71 & v65);
      HIDWORD(v69) = v71;
      LODWORD(v69) = v71;
      v75 = (v69 >> 6) ^ __ROR4__(v71, 11);
      v76 = __PAIR64__(v72, __ROR4__(v71, 25));
      v77 = v74 + 607225278 + (v75 ^ v76);
      LODWORD(v76) = v72;
      v78 = v77 + v54;
      v79 = ((v76 >> 2) ^ __ROR4__(v72, 13) ^ __ROR4__(v72, 22)) + (v72 & (v66 ^ v60) ^ v66 & v60) + v77;
      v80 = bswap32(a2[11]);
      v228[10] = v73;
      v228[11] = v80;
      HIDWORD(v76) = v78;
      LODWORD(v76) = v78;
      v81 = (v76 >> 6) ^ __ROR4__(v78, 11);
      v82 = __PAIR64__(v79, __ROR4__(v78, 25));
      v83 = v80 + v59 + (v65 & ~v78) + (v78 & v71) + 1426881987 + (v81 ^ v82);
      LODWORD(v82) = v79;
      v84 = v83 + v60;
      v85 = ((v82 >> 2) ^ __ROR4__(v79, 13) ^ __ROR4__(v79, 22)) + (v79 & (v72 ^ v66) ^ v72 & v66) + v83;
      v86 = bswap32(a2[12]);
      HIDWORD(v82) = v84;
      LODWORD(v82) = v84;
      v87 = (v82 >> 6) ^ __ROR4__(v84, 11);
      v88 = __PAIR64__(v85, __ROR4__(v84, 25));
      v89 = v86 + v65 + (v71 & ~v84) + (v84 & v78) + 1925078388 + (v87 ^ v88);
      LODWORD(v88) = v85;
      v90 = v89 + v66;
      v91 = ((v88 >> 2) ^ __ROR4__(v85, 13) ^ __ROR4__(v85, 22)) + (v85 & (v79 ^ v72) ^ v79 & v72) + v89;
      v92 = bswap32(a2[13]);
      HIDWORD(v88) = v90;
      LODWORD(v88) = v90;
      v228[12] = v86;
      v228[13] = v92;
      v93 = (v88 >> 6) ^ __ROR4__(v90, 11);
      v94 = __PAIR64__(v91, __ROR4__(v90, 25));
      v95 = v92 + v71 + (v78 & ~v90) + (v90 & v84) - 2132889090 + (v93 ^ v94);
      LODWORD(v94) = v91;
      v96 = v95 + v72;
      v97 = ((v94 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v85 ^ v79) ^ v85 & v79) + v95;
      HIDWORD(v94) = v96;
      LODWORD(v94) = v95 + v72;
      v226 = a2;
      v98 = bswap32(a2[14]);
      v99 = (v94 >> 6) ^ __ROR4__(v96, 11);
      v100 = __PAIR64__(v97, __ROR4__(v96, 25));
      v101 = v98 + v78 + (v84 & ~v96) + (v96 & v90) - 1680079193 + (v99 ^ v100);
      LODWORD(v100) = v97;
      v102 = v101 + v79;
      v103 = ((v100 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v85) ^ v91 & v85) + v101;
      v104 = bswap32(a2[15]);
      v228[14] = v98;
      v228[15] = v104;
      HIDWORD(v100) = v102;
      LODWORD(v100) = v102;
      v105 = (v100 >> 6) ^ __ROR4__(v102, 11);
      v106 = __PAIR64__(v103, __ROR4__(v102, 25));
      v107 = v104 + v84 + (v90 & ~v102) + (v102 & v96) - 1046744716 + (v105 ^ v106);
      LODWORD(v106) = v103;
      v108 = v107 + v85;
      v109 = ((v106 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v107;
      v110 = &dword_1B50125FC;
      v111 = 31;
      do
      {
        v112 = v111 - 15;
        v113 = ((int)v111 - 14) & 9;
        v114 = v228[v113];
        v115 = v228[((_BYTE)v111 - 1) & 0xE];
        HIDWORD(v117) = v114;
        LODWORD(v117) = v114;
        v116 = v117 >> 7;
        v119 = __PAIR64__(v115, __ROR4__(v114, 18));
        v118 = v116 ^ v119;
        LODWORD(v119) = v115;
        v120 = v119 >> 17;
        v121 = __PAIR64__(v108, __ROR4__(v115, 19));
        v122 = (v111 - 15) & 8;
        v123 = v120 ^ v121 ^ (v115 >> 10);
        LODWORD(v121) = v108;
        v124 = (v111 - 15) & 8;
        v125 = (v118 ^ (v114 >> 3)) + v228[((int)v111 - 6) & 9] + v228[v122] + v123;
        v126 = (v121 >> 6) ^ __ROR4__(v108, 11);
        v128 = __PAIR64__(v109, __ROR4__(v108, 25));
        v127 = v126 ^ v128;
        LODWORD(v128) = v109;
        v129 = *(v110 - 6);
        v130 = v127 + (v102 & v108) + v90 + (v96 & ~v108) + *(v110 - 7);
        v228[v122] = v125;
        LODWORD(v122) = ((v97 ^ v103) & v109 ^ v97 & v103) + ((v128 >> 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22));
        v131 = v130 + v125;
        v132 = v131 + v91;
        HIDWORD(v128) = v228[v124 | 2];
        LODWORD(v128) = HIDWORD(v128);
        v133 = v122 + v131;
        v134 = v228[v111 & 0xF];
        v135 = (v128 >> 7) ^ __ROR4__(HIDWORD(v128), 18) ^ (HIDWORD(v128) >> 3);
        HIDWORD(v128) = v134;
        LODWORD(v128) = v134;
        v136 = v128 >> 17;
        v137 = __PAIR64__(v132, __ROR4__(v134, 19));
        v138 = v228[((int)v111 - 5) & 0xALL] + v114 + (v136 ^ v137 ^ (v134 >> 10));
        LODWORD(v137) = v132;
        v139 = v138 + v135;
        v140 = (v137 >> 6) ^ __ROR4__(v132, 11);
        v142 = __PAIR64__(v133, __ROR4__(v132, 25));
        v141 = v140 ^ v142;
        LODWORD(v142) = v133;
        v228[v113] = v139;
        LODWORD(v113) = (v142 >> 2) ^ __ROR4__(v133, 13);
        v143 = __PAIR64__(v125, __ROR4__(v133, 22));
        v144 = (v102 & ~v132) + v96 + (v132 & v108) + v129 + v139 + v141;
        v145 = (v113 ^ v143) + (v133 & (v103 ^ v109) ^ v103 & v109);
        v146 = v144 + v97;
        v147 = v228[v124 | 3];
        LODWORD(v143) = v125;
        v148 = v143 >> 17;
        HIDWORD(v143) = v147;
        LODWORD(v143) = v147;
        LODWORD(v122) = (v143 >> 7) ^ __ROR4__(v147, 18);
        v149 = __PAIR64__(v146, __ROR4__(v125, 19));
        v150 = v148 ^ v149 ^ (v125 >> 10);
        v151 = ((int)v111 - 13) & 0xALL;
        v152 = v145 + v144;
        v153 = v228[((int)v111 - 4) & 0xBLL] + v228[v151] + (v122 ^ (v147 >> 3)) + v150;
        LODWORD(v149) = v146;
        v154 = (v149 >> 6) ^ __ROR4__(v146, 11);
        v156 = __PAIR64__(v152, __ROR4__(v146, 25));
        v155 = v154 ^ v156;
        v228[v151] = v153;
        LODWORD(v151) = *(v110 - 4);
        v157 = *(v110 - 5) + v102 + v153;
        LODWORD(v156) = v152;
        v158 = ((v156 >> 2) ^ __ROR4__(v152, 13) ^ __ROR4__(v152, 22)) + (v152 & (v133 ^ v109) ^ v133 & v109);
        v159 = v228[v124 | 4];
        v160 = v157 + (v108 & ~v146) + (v146 & v132) + v155;
        HIDWORD(v156) = v159;
        LODWORD(v156) = v159;
        v161 = v156 >> 7;
        LODWORD(v122) = v228[v124 | 1];
        v163 = __PAIR64__(v122, __ROR4__(v159, 18));
        v162 = v161 ^ v163;
        LODWORD(v163) = v122;
        v164 = v162 ^ (v159 >> 3);
        v165 = ((int)v111 - 12) & 0xBLL;
        v166 = v160 + v103;
        v167 = v164
             + v228[((_BYTE)v111 - 3) & 0xC]
             + v228[v165]
             + ((v163 >> 17) ^ __ROR4__(v122, 19) ^ (v122 >> 10));
        v168 = v158 + v160;
        HIDWORD(v163) = v166;
        LODWORD(v163) = v166;
        v169 = (v163 >> 6) ^ __ROR4__(v166, 11);
        v171 = __PAIR64__(v168, __ROR4__(v166, 25));
        v170 = v169 ^ v171;
        v228[v165] = v167;
        LODWORD(v171) = v168;
        v172 = v151 + v108 + v167 + (v132 & ~v166) + (v166 & v146) + v170;
        v173 = ((v171 >> 2) ^ __ROR4__(v168, 13) ^ __ROR4__(v168, 22)) + (v168 & (v152 ^ v133) ^ v152 & v133);
        v174 = v172 + v109;
        v175 = v228[v124 | 5];
        HIDWORD(v171) = v175;
        LODWORD(v171) = v175;
        v176 = (v171 >> 7) ^ __ROR4__(v175, 18);
        v177 = v228[v124 | 2];
        HIDWORD(v171) = v177;
        LODWORD(v171) = v177;
        LODWORD(v165) = v171 >> 17;
        v178 = __PAIR64__(v174, __ROR4__(v177, 19));
        v179 = ((_BYTE)v111 - 11) & 0xC;
        v180 = (v176 ^ (v175 >> 3)) + v228[((int)v111 - 2) & 0xDLL] + v228[v179] + (v165 ^ v178 ^ (v177 >> 10));
        v181 = v173 + v172;
        LODWORD(v178) = v174;
        v182 = (v178 >> 6) ^ __ROR4__(v174, 11);
        v184 = __PAIR64__(v181, __ROR4__(v174, 25));
        v183 = v182 ^ v184;
        v228[v179] = v180;
        LODWORD(v165) = *(v110 - 2);
        LODWORD(v184) = v181;
        LODWORD(v151) = ((v184 >> 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + (v181 & (v168 ^ v152) ^ v168 & v152);
        v185 = *(v110 - 3) + v180 + v132 + (v146 & ~v174) + (v174 & v166) + v183;
        v90 = v185 + v133;
        v186 = v228[v124 | 6];
        HIDWORD(v184) = v186;
        LODWORD(v184) = v186;
        v187 = v184 >> 7;
        LODWORD(v113) = v228[v124 | 3];
        HIDWORD(v184) = v113;
        LODWORD(v184) = v113;
        v188 = v184 >> 17;
        v189 = v187 ^ __ROR4__(v186, 18) ^ (v186 >> 3);
        v191 = __PAIR64__(v90, __ROR4__(v113, 19));
        v190 = v188 ^ v191;
        v192 = ((int)v111 - 10) & 0xDLL;
        v91 = v151 + v185;
        v193 = v228[v192] + v115 + v189 + (v190 ^ (v113 >> 10));
        LODWORD(v191) = v90;
        v194 = (v191 >> 6) ^ __ROR4__(v90, 11);
        v196 = __PAIR64__(v91, __ROR4__(v90, 25));
        v195 = v194 ^ v196;
        v228[v192] = v193;
        LODWORD(v196) = v91;
        v197 = v165 + v193 + v146 + (v166 & ~v90) + (v90 & v174) + v195;
        v198 = ((v196 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v181 ^ v168) ^ v181 & v168);
        LODWORD(v179) = v228[v124 | 7];
        v96 = v197 + v152;
        HIDWORD(v196) = v179;
        LODWORD(v196) = v179;
        LODWORD(v113) = v196 >> 7;
        v199 = v228[v124 | 4];
        v200 = __PAIR64__(v199, __ROR4__(v179, 18));
        LODWORD(v179) = v113 ^ v200 ^ (v179 >> 3);
        LODWORD(v200) = v199;
        LODWORD(v113) = v200 >> 17;
        v201 = __PAIR64__(v96, __ROR4__(v199, 19));
        v202 = ((_BYTE)v111 - 9) & 0xE;
        LODWORD(v179) = v228[v202] + v134 + v179 + (v113 ^ v201 ^ (v199 >> 10));
        v97 = v198 + v197;
        LODWORD(v201) = v96;
        v203 = (v201 >> 6) ^ __ROR4__(v96, 11);
        v205 = __PAIR64__(v97, __ROR4__(v96, 25));
        v204 = v203 ^ v205;
        v228[v202] = v179;
        LODWORD(v205) = v97;
        v206 = *(v110 - 1) + v179 + v166 + (v174 & ~v96) + (v96 & v90) + v204;
        v102 = v206 + v168;
        v103 = ((v205 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v181) ^ v91 & v181) + v206;
        v207 = v228[v124 ^ 8];
        HIDWORD(v205) = v207;
        LODWORD(v205) = v207;
        LODWORD(v179) = v205 >> 7;
        v208 = v228[v124 | 5];
        HIDWORD(v205) = v208;
        LODWORD(v205) = v208;
        LODWORD(v113) = v205 >> 17;
        v209 = v179 ^ __ROR4__(v207, 18) ^ (v207 >> 3);
        v210 = __PAIR64__(v102, __ROR4__(v208, 19));
        v211 = ((_BYTE)v111 - 8) & 0xF;
        LODWORD(v179) = v113 ^ v210 ^ (v208 >> 10);
        LODWORD(v210) = v102;
        v212 = (v210 >> 6) ^ __ROR4__(v102, 11);
        v213 = v228[v211] + v209 + v125 + v179;
        v214 = __PAIR64__(v103, __ROR4__(v102, 25));
        LODWORD(v179) = v212 ^ v214;
        v215 = *v110;
        v110 += 8;
        v228[v211] = v213;
        LODWORD(v214) = v103;
        v216 = v215 + v213 + v174 + (v90 & ~v102) + (v102 & v96) + v179;
        v108 = v216 + v181;
        v109 = ((v214 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v216;
        v111 += 8;
      }
      while (v112 < 0x38);
      a2 = v226 + 16;
      v3 = v109 + v225;
      v4 = v103 + v224;
      *v217 = v109 + v225;
      v217[1] = v103 + v224;
      v6 = v97 + v223;
      v5 = v91 + v222;
      v217[2] = v97 + v223;
      v217[3] = v91 + v222;
      v8 = v108 + v221;
      v7 = v102 + v220;
      v217[4] = v108 + v221;
      v217[5] = v102 + v220;
      v9 = v96 + v219;
      result = v90 + v218;
      v217[6] = v96 + v219;
      v217[7] = result;
      a3 = v227 - 1;
    }
    while (v227 != 1);
  }
  return result;
}

int SHA256_Update(SHA256_CTX *c, const void *data, size_t len)
{
  size_t v3;
  unsigned int *v4;
  unsigned int *v6;
  size_t v7;
  uint64_t num;
  uint64_t v9;

  if (len)
  {
    v3 = len;
    v4 = (unsigned int *)data;
    v6 = c->data;
    v7 = *(_QWORD *)&c->Nl + 8 * len;
    *(_QWORD *)&c->Nl = v7;
    num = c->num;
    if ((_DWORD)num)
    {
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy((char *)v6 + num, data, len);
        c->num += v3;
        return 1;
      }
      v9 = 64 - num;
      if ((_DWORD)num != 64)
        memcpy((char *)v6 + num, data, 64 - num);
      sha256_block_data_order((unint64_t)c, v6, 1);
      v4 = (unsigned int *)((char *)v4 + v9);
      v3 -= v9;
      c->num = 0;
      *(_OWORD *)v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      *((_OWORD *)v6 + 2) = 0u;
      *((_OWORD *)v6 + 3) = 0u;
    }
    if (v3 >= 0x40)
    {
      sha256_block_data_order((unint64_t)c, v4, v3 >> 6);
      v4 = (unsigned int *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->num = v3;
      memcpy(v6, v4, v3);
    }
  }
  return 1;
}

void boringssl_log_open()
{
  if (boringssl_log_open_onceToken != -1)
    dispatch_once(&boringssl_log_open_onceToken, &__block_literal_global_1);
}

uint64_t boringssl_config_get_min_dtls_version_allowed()
{
  return 65279;
}

uint64_t boringssl_config_get_max_dtls_version_allowed()
{
  return 65277;
}

uint64_t boringssl_context_set_max_version(uint64_t a1, unsigned __int16 a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  id *v6;
  id WeakRetained;
  void *v8;
  _BYTE *v9;
  char v10;
  id v11;
  _BYTE *v12;
  _BOOL4 v13;
  NSObject *v14;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(v2 + 400);
  if (!v3)
    return 0xFFFFFFFFLL;
  if (SSL_set_max_proto_version(v3, a2))
  {
    result = 0;
    *(_WORD *)(v2 + 56) = a2;
    return result;
  }
  v6 = (id *)(v2 + 16);
  WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  if (WeakRetained)
  {
    v8 = WeakRetained;
    v9 = objc_loadWeakRetained(v6);
    v10 = v9[475];

    if ((v10 & 1) != 0)
      return 0;
  }
  v11 = objc_loadWeakRetained(v6);
  if (v11)
  {
    v12 = objc_loadWeakRetained(v6);
    v13 = (v12[475] & 1) == 0;

  }
  else
  {
    v13 = 1;
  }

  result = 0;
  if (v13 && g_boringssl_log)
  {
    v14 = (id)g_boringssl_log;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      boringssl_context_set_max_version_cold_1(v6, v14);

    return 0;
  }
  return result;
}

void *boringssl_ciphers_copy_default_ciphersuites(unint64_t *a1)
{
  NSObject *v2;
  int *v3;
  uint64_t v4;
  int v6;
  __int16 v7;

  if (os_variant_has_internal_content() && boringssl_config_get_restricted_mode_state())
  {
    v7 = 0;
    v2 = g_boringssl_log;
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      boringssl_ciphers_copy_default_ciphersuites_cold_1(v2);
    v3 = (int *)&v7;
    v4 = 1;
  }
  else
  {
    v6 = 0x10000;
    v3 = &v6;
    v4 = 2;
  }
  return boringssl_ciphers_copy_supported_list_for_groups((uint64_t)v3, v4, a1);
}

void *boringssl_ciphers_copy_supported_list_for_groups(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  CFMutableDataRef Mutable;
  __CFData *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t i;
  unint64_t Length;
  void *v12;
  void *v13;
  const UInt8 *BytePtr;
  UInt8 bytes[2];
  unint64_t v17;

  *a3 = 0;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (!Mutable)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      boringssl_ciphers_copy_supported_list_for_groups_cold_1();
    return 0;
  }
  v6 = Mutable;
  if (a2)
  {
    v7 = 0;
    do
    {
      v17 = 0;
      v8 = sec_protocol_helper_ciphersuite_group_to_ciphersuite_list();
      if (v17)
      {
        v9 = v8;
        for (i = 0; i < v17; ++i)
        {
          *(_WORD *)bytes = -21846;
          *(_WORD *)bytes = *(_WORD *)(v9 + 2 * i);
          CFDataAppendBytes(v6, bytes, 2);
        }
      }
      ++v7;
    }
    while (v7 != a2);
  }
  Length = CFDataGetLength(v6);
  v12 = malloc_type_malloc(Length & 0xFFFFFFFFFFFFFFFELL, 0xA711486EuLL);
  if (!v12)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      boringssl_ciphers_copy_supported_list_for_groups_cold_2();
    CFRelease(v6);
    return 0;
  }
  v13 = v12;
  BytePtr = CFDataGetBytePtr(v6);
  memcpy(v13, BytePtr, Length & 0xFFFFFFFFFFFFFFFELL);
  *a3 = Length >> 1;
  CFRelease(v6);
  return v13;
}

uint64_t SSL_set_max_proto_version(uint64_t a1, int a2)
{
  uint64_t v2;
  _BYTE *v4;
  __int16 *v5;
  __int16 v7;

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0;
  v4 = *(_BYTE **)a1;
  v5 = (__int16 *)(v2 + 8);
  if (a2)
    return bssl::set_version_bound(v4, v5, a2);
  if (*v4)
    v7 = -259;
  else
    v7 = 772;
  *v5 = v7;
  return 1;
}

void SSL_set_connect_state(SSL *s)
{
  BYTE4(s->param) &= ~1u;
  *(_QWORD *)&s->rwstate = bssl::ssl_client_handshake;
}

uint64_t SSL_set_cert_cb(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(result + 8);
  if (v3)
  {
    v4 = *(_QWORD *)(v3 + 32);
    *(_QWORD *)(v4 + 72) = a2;
    *(_QWORD *)(v4 + 80) = a3;
  }
  return result;
}

int SSL_set_ex_data(SSL *ssl, int idx, void *data)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)&ssl->d1, idx, data);
}

int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)
{
  STACK *sk;
  unint64_t v7;
  int v8;
  uint64_t v9;

  if (idx < 0)
    abort();
  sk = ad->sk;
  if (sk || (sk = sk_new_null(), (ad->sk = sk) != 0))
  {
    v7 = sk_num(sk);
    v8 = idx;
    if (v7 > idx)
    {
LABEL_8:
      sk_set(ad->sk, v8, (char *)val);
      LODWORD(sk) = 1;
    }
    else
    {
      v9 = idx - v7 + 1;
      while (1)
      {
        sk = (STACK *)sk_push(ad->sk, 0);
        if (!sk)
          break;
        if (!--v9)
          goto LABEL_8;
      }
    }
  }
  return (int)sk;
}

char *__cdecl sk_set(STACK *a1, int a2, char *a3)
{
  if (!a1 || *(_QWORD *)&a1->num <= *(_QWORD *)&a2)
    return 0;
  a1->data[*(_QWORD *)&a2] = a3;
  return a3;
}

uint64_t bssl::ssl_get_new_session(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v5;
  char v6;
  const ssl_st *v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  size_t v13;
  char v14;
  char v15;
  SSL_SESSION **v16;
  uint64_t v17;
  void *v18[2];
  uint64_t v19;

  v2 = *(_QWORD *)this;
  if ((*(_BYTE *)(*(_QWORD *)this + 149) & 2) != 0)
  {
    ERR_put_error(16, 0, 209, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_session.cc", 358);
    return 0;
  }
  v18[0] = *(void **)(*(_QWORD *)(v2 + 120) + 8);
  result = (uint64_t)bssl::New<ssl_session_st,bssl::SSL_X509_METHOD const*&>(v18);
  v19 = result;
  if (!result)
    return result;
  v5 = result;
  v6 = *(_BYTE *)(result + 448) & 0xEF | (16 * (*(_BYTE *)(v2 + 180) & 1));
  *(_BYTE *)(result + 448) = v6;
  *(_WORD *)(result + 4) = *(_WORD *)(v2 + 16);
  *(_BYTE *)(result + 448) = v6 & 0xDF | (32 * (*(_QWORD *)(v2 + 168) != 0));
  v18[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  v18[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  bssl::ssl_get_current_time(v2, (uint64_t)v18);
  *(void **)(v5 + 200) = v18[0];
  v8 = bssl::ssl_protocol_version((bssl *)v2, v7);
  v9 = *(_QWORD *)(v2 + 128);
  if (v8 < 0x304)
  {
    v10 = *(_DWORD *)(v9 + 296);
    v11 = v10;
  }
  else
  {
    v10 = *(_DWORD *)(v9 + 300);
    v11 = 604800;
  }
  *(_DWORD *)(v5 + 192) = v10;
  *(_DWORD *)(v5 + 196) = v11;
  v12 = *(_QWORD *)(*((_QWORD *)this + 1) + 32);
  v13 = *(unsigned __int8 *)(v12 + 112);
  if (v13 >= 0x21)
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_session.cc", 390);
    v19 = 0;
    SSL_SESSION_free((SSL_SESSION *)v5);
    return 0;
  }
  if (*(_BYTE *)(v12 + 112))
  {
    memcpy((void *)(v5 + 101), (const void *)(v12 + 113), v13);
    v14 = *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 1) + 32) + 112);
  }
  else
  {
    v14 = 0;
  }
  *(_BYTE *)(v5 + 100) = v14;
  v15 = *(_BYTE *)(v5 + 448);
  *(_QWORD *)(v5 + 184) = 65;
  *(_BYTE *)(v5 + 448) = v15 & 0x7B | 4;
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)this + 192, (SSL_SESSION *)v5);
  v17 = *(_QWORD *)(v2 + 104);
  v16 = (SSL_SESSION **)(v2 + 104);
  if (v17)
    std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v16, 0);
  return 1;
}

void sub_1B4FA2258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)va, 0);
  _Unwind_Resume(a1);
}

int8x8_t bssl::ssl_session_rebase_time(bssl *this, ssl_st *a2, ssl_session_st *a3)
{
  int8x8_t result;
  EVP_CIPHER_CTX *enc_read_ctx;
  EVP_CIPHER_CTX *v6;
  BOOL v7;
  unint64_t v8;
  STACK *cipher_list_by_id;
  uint64x2_t v10;
  _QWORD v11[2];

  v11[0] = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = 0xAAAAAAAAAAAAAAAALL;
  bssl::ssl_get_current_time((uint64_t)this, (uint64_t)v11);
  enc_read_ctx = a2->enc_read_ctx;
  v6 = (EVP_CIPHER_CTX *)v11[0];
  v7 = v11[0] >= (unint64_t)enc_read_ctx;
  v8 = v11[0] - (_QWORD)enc_read_ctx;
  if (v7)
  {
    a2->enc_read_ctx = (EVP_CIPHER_CTX *)v11[0];
    cipher_list_by_id = a2->cipher_list_by_id;
    v10.i64[0] = cipher_list_by_id;
    v10.i64[1] = HIDWORD(cipher_list_by_id);
    result = vbic_s8((int8x8_t)vsub_s32((int32x2_t)cipher_list_by_id, vdup_n_s32(v8)), (int8x8_t)vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(v8), v10)));
    a2->cipher_list_by_id = (STACK *)result;
  }
  else
  {
    a2->cipher_list_by_id = 0;
    a2->enc_read_ctx = v6;
  }
  return result;
}

uint64_t bssl::ssl_ctx_get_current_time(uint64_t a1, uint64_t a2)
{
  uint64_t (*v3)(_QWORD, timeval *);
  uint64_t result;
  __darwin_time_t tv_sec;
  timeval v6;

  v3 = *(uint64_t (**)(_QWORD, timeval *))(a1 + 784);
  if (v3)
  {
    v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v6.tv_usec = 0xAAAAAAAAAAAAAAAALL;
    result = v3(0, &v6);
    tv_sec = v6.tv_sec;
    if (v6.tv_sec < 0)
      bssl::ssl_ctx_get_current_time();
  }
  else
  {
    v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v6.tv_usec = 0xAAAAAAAAAAAAAAAALL;
    result = gettimeofday(&v6, 0);
    tv_sec = v6.tv_sec;
    if (v6.tv_sec < 0)
      bssl::ssl_ctx_get_current_time();
  }
  *(_QWORD *)a2 = tv_sec;
  *(_DWORD *)(a2 + 8) = v6.tv_usec;
  return result;
}

uint64_t bssl::ssl_get_current_time(uint64_t a1, uint64_t a2)
{
  return bssl::ssl_ctx_get_current_time(*(_QWORD *)(a1 + 120), a2);
}

#error "1B4FA23F0: call analysis failed (funcsize=43)"

#error "1B4FA24BC: call analysis failed (funcsize=45)"

void OUTLINED_FUNCTION_7_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x26u);
}

#error "1B4FA25B4: call analysis failed (funcsize=45)"

#error "1B4FA2680: call analysis failed (funcsize=45)"

void OUTLINED_FUNCTION_16_0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x2Cu);
}

void OUTLINED_FUNCTION_18(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x30u);
}

void OUTLINED_FUNCTION_14(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x30u);
}

id OUTLINED_FUNCTION_13@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;

  return objc_loadWeakRetained((id *)(v1 + a1));
}

void bssl::ssl_ctx_get_current_time()
{
  __assert_rtn("ssl_ctx_get_current_time", "ssl_lib.cc", 406, "0");
}

{
  __assert_rtn("ssl_ctx_get_current_time", "ssl_lib.cc", 378, "0");
}

uint64_t nw_protocol_boringssl_waiting_for_output(uint64_t result)
{
  uint64_t v1;
  NSObject *v2;
  unsigned int v3;

  if (result)
  {
    v1 = *(_QWORD *)(result + 40);
    if (v1)
    {
      if ((*(_BYTE *)(v1 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_waiting_for_output_cold_2();
      }
      result = boringssl_session_in_early_data(*(_QWORD *)(v1 + 336));
      if ((_DWORD)result)
        result = boringssl_session_get_state(*(_QWORD *)(v1 + 336)) < 2;
      if ((*(_BYTE *)(v1 + 475) & 1) == 0)
      {
        v2 = g_boringssl_log;
        if (g_boringssl_log)
        {
          v3 = result;
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
            nw_protocol_boringssl_waiting_for_output_cold_1(v1, v3, v2);
          return v3;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void nw_protocol_boringssl_waiting_for_output_cold_1(uint64_t a1, uint64_t a2, NSObject *a3)
{
  const char *v3;
  _BYTE v4[40];

  *(_DWORD *)v4 = 136447234;
  *(_QWORD *)&v4[4] = "nw_protocol_boringssl_waiting_for_output";
  v3 = "false";
  *(_WORD *)&v4[12] = 1024;
  *(_DWORD *)&v4[14] = 2022;
  *(_QWORD *)&v4[20] = a1 + 391;
  *(_WORD *)&v4[18] = 2082;
  *(_WORD *)&v4[28] = 2048;
  if ((a2 & 1) != 0)
    v3 = "true";
  *(_QWORD *)&v4[30] = a1;
  *(_WORD *)&v4[38] = 2082;
  OUTLINED_FUNCTION_17_0(&dword_1B4F6D000, a2, a3, "%{public}s(%d) %{public}s[%p] Waiting for output: %{public}s", *(_QWORD *)v4, *(_QWORD *)&v4[8], *(_QWORD *)&v4[16], *(_QWORD *)&v4[24], *(_QWORD *)&v4[32], v3);
  OUTLINED_FUNCTION_12_0();
}

void OUTLINED_FUNCTION_19(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x32u);
}

void OUTLINED_FUNCTION_19_0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Cu);
}

uint64_t __nw_protocol_boringssl_input_available_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  char v4;
  uint64_t v5;

  v3 = a2;
  nw_frame_unclaimed_bytes();
  v4 = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 272) + 16))();
  v5 = *(_QWORD *)(a1 + 32);
  if ((v4 & 1) == 0
    && (!v5 || (*(_BYTE *)(v5 + 475) & 1) == 0)
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
  {
    __nw_protocol_boringssl_input_available_block_invoke_cold_1();
  }
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1;
}

_QWORD *__boringssl_context_set_enable_message_mode_block_invoke(uint64_t a1, int a2, const void *a3, size_t a4)
{
  _QWORD *result;
  unsigned int v6;

  switch(a2)
  {
    case 0:
    case 1:
    case 2:
      goto LABEL_5;
    case 3:
      result = SSL_provide_quic_data(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 400), 3, a3, a4);
      if (!(_DWORD)result)
        return result;
      v6 = SSL_process_quic_post_handshake(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 400));
      return (_QWORD *)(v6 != 0);
    default:
      a2 = -1431655766;
LABEL_5:
      v6 = SSL_provide_quic_data(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 400), a2, a3, a4);
      return (_QWORD *)(v6 != 0);
  }
}

_QWORD *SSL_provide_quic_data(uint64_t a1, int a2, const void *a3, size_t a4)
{
  uint64_t v5;
  _QWORD *v8;
  int v9;
  int v10;

  if (!*(_QWORD *)(a1 + 168))
  {
    v9 = 66;
    v10 = 839;
    goto LABEL_10;
  }
  v5 = *(_QWORD *)(a1 + 48);
  if (*(_DWORD *)(v5 + 200) != a2)
  {
    v9 = 299;
    v10 = 844;
    goto LABEL_10;
  }
  v8 = *(_QWORD **)(v5 + 224);
  if (v8)
    v8 = (_QWORD *)*v8;
  if (__CFADD__(v8, a4) || (unint64_t)v8 + a4 > SSL_quic_max_handshake_flight_len(a1, a2))
  {
    v9 = 150;
    v10 = 851;
LABEL_10:
    ERR_put_error(16, 0, v9, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", v10);
    return 0;
  }
  return bssl::tls_append_handshake_data(a1, a3, a4);
}

uint64_t SSL_quic_max_handshake_flight_len(uint64_t a1, int a2)
{
  unsigned int v2;

  v2 = 0x4000;
  switch(a2)
  {
    case 0:
    case 3:
      return v2;
    case 2:
      if ((*(_BYTE *)(a1 + 180) & 1) != 0)
      {
        if ((*(_BYTE *)(*(_QWORD *)(a1 + 8) + 312) & 1) == 0)
          return 0x4000;
        v2 = *(_DWORD *)(a1 + 152);
      }
      else
      {
        v2 = 2 * *(_DWORD *)(a1 + 152);
      }
      if (v2 > 0x4000)
        return v2;
      return 0x4000;
    default:
      return 0;
  }
}

uint64_t SSL_process_quic_post_handshake(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  __int128 v4;
  uint64_t v6;
  uint64_t *v7;
  _QWORD *v8;
  _OWORD v9[2];
  unint64_t v10;

  *(_DWORD *)(a1[6] + 196) = 0;
  ERR_clear_error();
  ERR_clear_system_error();
  v2 = a1[6];
  v3 = *(_QWORD *)(v2 + 280);
  if (!v3 || (*(_BYTE *)(v3 + 1600) & 8) != 0)
  {
    if (*(_DWORD *)(v2 + 172) == 2)
    {
      ERR_restore_state(*(_QWORD **)(v2 + 184));
    }
    else
    {
      v10 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v9[0] = v4;
      v9[1] = v4;
      if (!(*(unsigned int (**)(_QWORD *, _OWORD *))(*a1 + 24))(a1, v9))
        return 1;
      while (ssl_do_post_handshake((uint64_t)a1, (uint64_t)v9))
      {
        (*(void (**)(_QWORD *))(*a1 + 32))(a1);
        if (((*(uint64_t (**)(_QWORD *, _OWORD *))(*a1 + 24))(a1, v9) & 1) == 0)
          return 1;
      }
      v6 = a1[6];
      *(_DWORD *)(v6 + 172) = 2;
      v7 = (uint64_t *)(v6 + 184);
      v8 = ERR_save_state();
      std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100](v7, (uint64_t)v8);
    }
  }
  else
  {
    ERR_put_error(16, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 1178);
  }
  return 0;
}

void __boringssl_context_evaluate_trust_async_external_block_invoke_2(uint64_t a1)
{
  id v2;
  id v3;

  v2 = *(id *)(a1 + 32);
  v3 = *(id *)(a1 + 40);
  nw_queue_context_async_if_needed();

}

nw_protocol *nw_protocol_boringssl_create()
{
  boringssl_concrete_nw_protocol_boringssl *v0;
  boringssl_concrete_nw_protocol_boringssl *v1;
  nw_protocol *p_protocol;
  boringssl_concrete_nw_protocol_boringssl *v3;

  v0 = objc_alloc_init(boringssl_concrete_nw_protocol_boringssl);
  v1 = v0;
  if (v0)
  {
    p_protocol = &v0->protocol;
    v0->protocol.identifier = (nw_protocol_identifier *)&g_boringssl_protocol_identifier;
    v0->protocol.callbacks = (nw_protocol_callbacks *)&g_boringssl_protocol_callbacks;
    v3 = v0;
    v3->protocol.handle = v3;
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    v3->input_frame_byte_count = 0;
    *((_BYTE *)v3 + 388) &= ~0x80u;
    v3->read_func = boringssl_session_read;
    v3->write_func = boringssl_session_write;
    v3->handshake_func = boringssl_session_handshake_negotiate;
    v3->handshake_timer = 0;
  }
  else
  {
    p_protocol = 0;
  }

  return p_protocol;
}

uint64_t __boringssl_logging_register_debug_log_updates_block_invoke()
{
  uint64_t result;

  result = network_config_register_boringssl_log_debug_updates();
  datapath_logging_enabled = result;
  return result;
}

uint64_t bssl::ssl_open_change_cipher_spec(_QWORD *a1, _QWORD *a2, _BYTE *a3)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v7;
  uint64_t *v8;
  _QWORD *v9;

  *a2 = 0;
  v4 = a1[6];
  if (*(_DWORD *)(v4 + 172) == 2)
  {
    ERR_restore_state(*(_QWORD **)(v4 + 184));
    *a3 = 0;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD *))(*a1 + 56))(a1);
    if ((_DWORD)result != 4)
      return result;
    v7 = a1[6];
    *(_DWORD *)(v7 + 172) = 2;
    v8 = (uint64_t *)(v7 + 184);
    v9 = ERR_save_state();
    std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100](v8, (uint64_t)v9);
  }
  return 4;
}

uint64_t bssl::tls_open_change_cipher_spec(bssl *a1, unsigned __int8 **a2, ssl_st *a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  uint64_t result;
  char v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;

  v11 = -86;
  v9 = 0;
  v10 = 0;
  result = bssl::tls_open_record(a1, &v11, (uint64_t)&v9, a2, a3, a4, a5);
  if (!(_DWORD)result)
  {
    if (v11 == 20)
    {
      if (v10 == 1 && *v9 == 1)
      {
        bssl::ssl_do_msg_callback((uint64_t)a1, 0, 20, (uint64_t)v9, 1);
        return 0;
      }
      ERR_put_error(16, 0, 103, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", 383);
      v8 = 47;
    }
    else
    {
      ERR_put_error(16, 0, 225, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", 377);
      v8 = 10;
    }
    LOBYTE(a3->version) = v8;
    return 4;
  }
  return result;
}

BOOL __boringssl_context_set_encryption_secrets_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  dispatch_data_t v5;
  const void *v6;
  dispatch_data_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  void (**v11)(_QWORD, _QWORD, _QWORD, _QWORD);

  if (a2 && *(_QWORD *)(a2 + 144) && *(_QWORD *)(a2 + 152))
  {
    v4 = *(const void **)(a1 + 32);
    if (v4)
      v5 = dispatch_data_create(v4, *(_QWORD *)(a1 + 40), 0, 0);
    else
      v5 = 0;
    v6 = *(const void **)(a1 + 48);
    if (v6)
      v7 = dispatch_data_create(v6, *(_QWORD *)(a1 + 40), 0, 0);
    else
      v7 = 0;
    v8 = *(_DWORD *)(a1 + 56);
    if (v8 - 1 >= 3)
      v9 = 0;
    else
      v9 = v8;
    v10 = MEMORY[0x1B5E45624](*(_QWORD *)(a2 + 144));
    v11 = (void (**)(_QWORD, _QWORD, _QWORD, _QWORD))v10;
    if (v5)
      (*(void (**)(uint64_t, uint64_t, uint64_t, dispatch_data_t))(v10 + 16))(v10, v9, 1, v5);
    if (v7)
      ((void (**)(_QWORD, uint64_t, _QWORD, dispatch_data_t))v11)[2](v11, v9, 0, v7);

  }
  return a2 != 0;
}

void HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md, ENGINE *impl)
{
  size_t v6;
  const EVP_MD *v9;
  __int128 v10;
  unint64_t v11;
  uint64_t v12;
  int8x16_t v13;
  size_t v14;
  uint64_t v15;
  int8x16_t v16;
  size_t v17;
  unsigned int s;
  unsigned __int8 mda[16];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _OWORD d[8];
  uint64_t v28;

  v6 = *(_QWORD *)&len;
  v28 = *MEMORY[0x1E0C80C00];
  if (md)
    v9 = md;
  else
    v9 = ctx->md;
  if (!key && v9 == ctx->md)
    goto LABEL_6;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  d[6] = v10;
  d[7] = v10;
  d[4] = v10;
  d[5] = v10;
  d[2] = v10;
  d[3] = v10;
  d[0] = v10;
  d[1] = v10;
  v25 = v10;
  v26 = v10;
  v23 = v10;
  v24 = v10;
  v21 = v10;
  v22 = v10;
  *(_OWORD *)mda = v10;
  v20 = v10;
  s = -1431655766;
  v11 = EVP_MD_block_size(v9);
  if (v11 >= 0x81)
    HMAC_Init_ex_cold_1();
  if (v11 >= v6)
  {
    if (v6)
      __memcpy_chk();
    s = v6;
  }
  else
  {
    if (!EVP_DigestInit_ex(&ctx->md_ctx, v9, impl)
      || !EVP_DigestUpdate(&ctx->md_ctx, key, v6)
      || !EVP_DigestFinal_ex(&ctx->md_ctx, mda, &s))
    {
      return;
    }
    LODWORD(v6) = s;
  }
  if ((_DWORD)v6 != 128)
    bzero(&mda[v6], 128 - v6);
  v12 = 0;
  v13.i64[0] = 0x3636363636363636;
  v13.i64[1] = 0x3636363636363636;
  do
  {
    d[v12] = veorq_s8(*(int8x16_t *)&mda[v12 * 16], v13);
    ++v12;
  }
  while (v12 != 8);
  if (EVP_DigestInit_ex(&ctx->i_ctx, v9, impl))
  {
    v14 = EVP_MD_block_size(v9);
    if (EVP_DigestUpdate(&ctx->i_ctx, d, v14))
    {
      v15 = 0;
      v16.i64[0] = 0x5C5C5C5C5C5C5C5CLL;
      v16.i64[1] = 0x5C5C5C5C5C5C5C5CLL;
      do
      {
        d[v15] = veorq_s8(*(int8x16_t *)&mda[v15 * 16], v16);
        ++v15;
      }
      while (v15 != 8);
      if (EVP_DigestInit_ex(&ctx->o_ctx, v9, impl))
      {
        v17 = EVP_MD_block_size(v9);
        if (EVP_DigestUpdate(&ctx->o_ctx, d, v17))
        {
          ctx->md = v9;
LABEL_6:
          EVP_MD_CTX_copy_ex(&ctx->md_ctx, &ctx->i_ctx);
        }
      }
    }
  }
}

int EVP_MD_block_size(const EVP_MD *md)
{
  return (int)md->final;
}

void boringssl_metrics_log_configuration_data(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  const char *v5;
  unsigned int min_protocol_version;
  const char *v7;
  unsigned int max_protocol_version;
  const char *v9;
  uint64_t configured_ciphersuite_set;
  const char *v11;
  char session_ticket_enabled;
  const char *v13;
  BOOL ticket_offered;
  const char *v15;
  char v16;
  const char *v17;
  BOOL psk_was_negotiated;
  const char *v19;
  BOOL v20;
  const char *v21;
  char is_probe;
  const char *v23;
  char GREASE_enabled;
  const char *v25;
  char ats_enforced;
  const char *v27;
  uint64_t ats_minimum_rsa_key_size;
  const char *v29;
  uint64_t ats_minimum_ecdsa_key_size;
  const char *v31;
  unsigned int ats_minimum_signature_algorithm;
  uint64_t experiment_identifer;
  const char *v34;
  const char *v35;
  xpc_object_t xdict;

  v3 = a2;
  if (*(_DWORD *)a1 == -1252936367)
  {
    v4 = *(_QWORD *)(a1 + 8);
    if (v4)
    {
      v5 = (const char *)TLS_METRIC_MIN_PROTOCOL_VERSION;
      xdict = v3;
      min_protocol_version = boringssl_context_get_min_protocol_version(a1);
      xpc_dictionary_set_uint64(xdict, v5, min_protocol_version);
      v7 = (const char *)TLS_METRIC_MAX_PROTOCOL_VERSION;
      max_protocol_version = boringssl_context_get_max_protocol_version(a1);
      xpc_dictionary_set_uint64(xdict, v7, max_protocol_version);
      v9 = (const char *)TLS_METRIC_CONFIGURED_CIPHERSUITE_SET;
      configured_ciphersuite_set = boringssl_context_get_configured_ciphersuite_set(a1);
      xpc_dictionary_set_uint64(xdict, v9, configured_ciphersuite_set);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_FALSE_START_ENABLED, *(_BYTE *)(v4 + 556) >> 7);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_SESSION_RESUMED, *(_BYTE *)(v4 + 557) >> 7);
      v11 = (const char *)TLS_METRIC_TICKET_ENABLED;
      session_ticket_enabled = boringssl_context_get_session_ticket_enabled(a1);
      xpc_dictionary_set_BOOL(xdict, v11, session_ticket_enabled);
      v13 = (const char *)TLS_METRIC_TICKET_OFFERED;
      ticket_offered = boringssl_session_get_ticket_offered(a1);
      xpc_dictionary_set_BOOL(xdict, v13, ticket_offered);
      v15 = (const char *)TLS_METRIC_RESUMPTION_ATTEMPTED;
      v16 = boringssl_session_attempted_resumption(a1);
      xpc_dictionary_set_BOOL(xdict, v15, v16);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_OCSP_ENABLED, (*(_BYTE *)(v4 + 556) & 8) != 0);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_SCT_ENABLED, (*(_BYTE *)(v4 + 556) & 4) != 0);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_VERIFY_BLOCK_USED, *(_QWORD *)(v4 + 120) != 0);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_CHALLENGE_BLOCK_USED, *(_QWORD *)(v4 + 136) != 0);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_DTLS, (*(_BYTE *)(v4 + 556) & 0x20) != 0);
      v17 = (const char *)TLS_METRIC_PSK_USED;
      psk_was_negotiated = boringssl_session_get_psk_was_negotiated(a1);
      xpc_dictionary_set_BOOL(xdict, v17, psk_was_negotiated);
      v19 = (const char *)TLS_METRIC_PSK_CONFIGURED;
      v20 = boringssl_psk_cache_get_count(*(_QWORD *)(v4 + 40)) != 0;
      xpc_dictionary_set_BOOL(xdict, v19, v20);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_CLIENT_MODE, (*(_BYTE *)(v4 + 556) & 0x10) == 0);
      v21 = (const char *)TLS_METRIC_IS_PROBE;
      is_probe = boringssl_context_get_is_probe(a1);
      xpc_dictionary_set_BOOL(xdict, v21, is_probe);
      v23 = (const char *)TLS_METRIC_GREASE_ENABLED;
      GREASE_enabled = boringssl_context_get_GREASE_enabled(a1);
      xpc_dictionary_set_BOOL(xdict, v23, GREASE_enabled);
      v25 = (const char *)TLS_METRIC_ATS_ENFORCED;
      ats_enforced = boringssl_context_get_ats_enforced(a1);
      xpc_dictionary_set_BOOL(xdict, v25, ats_enforced);
      v27 = (const char *)TLS_METRIC_ATS_MINIMUM_RSA_KEY_SIZE;
      ats_minimum_rsa_key_size = boringssl_context_get_ats_minimum_rsa_key_size(a1);
      xpc_dictionary_set_uint64(xdict, v27, ats_minimum_rsa_key_size);
      v29 = (const char *)TLS_METRIC_ATS_MINIMUM_ECDSA_KEY_SIZE;
      ats_minimum_ecdsa_key_size = boringssl_context_get_ats_minimum_ecdsa_key_size(a1);
      xpc_dictionary_set_uint64(xdict, v29, ats_minimum_ecdsa_key_size);
      v31 = (const char *)TLS_METRIC_ATS_MINIMUM_SIGNATURE_ALGORITHM;
      ats_minimum_signature_algorithm = boringssl_context_get_ats_minimum_signature_algorithm(a1);
      xpc_dictionary_set_uint64(xdict, v31, ats_minimum_signature_algorithm);
      experiment_identifer = boringssl_context_get_experiment_identifer(a1);
      v34 = (const char *)TLS_METRIC_EXPERIMENT_IDENTIFIER;
      if (experiment_identifer)
        v35 = (const char *)boringssl_context_get_experiment_identifer(a1);
      else
        v35 = (const char *)TLS_METRIC_DEFAULT_EMPTY_STRING;
      xpc_dictionary_set_string(xdict, v34, v35);
      v3 = xdict;
    }
  }

}

BOOL boringssl_session_get_psk_was_negotiated(_BOOL8 result)
{
  uint64_t v1;

  if (result)
    return *(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0 && *(char *)(v1 + 559) < 0;
  return result;
}

uint64_t boringssl_session_attempted_resumption(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return (*(unsigned __int8 *)(v1 + 558) >> 6) & 1;
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_psk_cache_get_count(uint64_t a1)
{
  if (a1 && *(_QWORD *)(a1 + 8))
    return sec_array_get_count();
  else
    return 0;
}

uint64_t boringssl_context_get_session_ticket_enabled(uint64_t a1)
{
  uint64_t v1;

  if (a1 && *(_DWORD *)a1 == -1252936367 && (v1 = *(_QWORD *)(a1 + 8)) != 0)
    return (*(unsigned __int8 *)(v1 + 557) >> 4) & 1;
  else
    return 1;
}

uint64_t boringssl_context_get_min_protocol_version(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(unsigned __int16 *)(v1 + 58);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_context_get_max_protocol_version(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(unsigned __int16 *)(v1 + 56);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_context_get_experiment_identifer(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 96);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_context_get_configured_ciphersuite_set(uint64_t a1)
{
  uint64_t v1;
  const SSL *v2;
  STACK *ciphers;

  if (a1
    && *(_DWORD *)a1 == -1252936367
    && (v1 = *(_QWORD *)(a1 + 8)) != 0
    && (v2 = *(const SSL **)(v1 + 400)) != 0
    && (ciphers = SSL_get_ciphers(v2)) != 0)
  {
    return boringssl_ciphers_create_set_bitmask(ciphers);
  }
  else
  {
    return 0;
  }
}

STACK *__cdecl SSL_get_ciphers(STACK *s)
{
  char **data;
  STACK **v2;

  if (s)
  {
    data = s->data;
    if (!data)
      SSL_get_ciphers_cold_1();
    v2 = (STACK **)data[3];
    if (!v2)
      v2 = (STACK **)*((_QWORD *)s[3].comp + 29);
    return *v2;
  }
  return s;
}

uint64_t boringssl_context_get_ats_minimum_signature_algorithm(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(unsigned int *)(v1 + 544);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_context_get_ats_minimum_rsa_key_size(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 528);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_context_get_ats_minimum_ecdsa_key_size(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_QWORD *)(v1 + 536);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_context_get_ats_enforced(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return (*(unsigned __int8 *)(v1 + 559) >> 3) & 1;
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_context_get_GREASE_enabled(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_BYTE *)(v1 + 560) & 1;
    else
      return 0;
  }
  return result;
}

void nw_protocol_boringssl_connected(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(void);
  uint64_t v8;
  uint64_t v9;
  unsigned int (*v10)(void);
  NSObject *v11;
  NSObject *v12;
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = a1[5];
    if (v3)
    {
      if ((*(_BYTE *)(v3 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_connected_cold_3();
      }
      v5 = a1[6];
      if (v5 && (v6 = *(_QWORD *)(v5 + 24)) != 0 && (v7 = *(void (**)(void))(v6 + 40)) != 0)
      {
        if (*(_QWORD *)(v3 + 336))
        {
          v7();
          if (a1[4] == a2)
          {
            if (boringssl_session_get_state(*(_QWORD *)(v3 + 336)) == 2)
            {
              if ((*(_BYTE *)(v3 + 475) & 1) == 0)
              {
                v12 = g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO))
                  {
                    v13 = 136446978;
                    v14 = "nw_protocol_boringssl_connected";
                    v15 = 1024;
                    v16 = 1611;
                    v17 = 2082;
                    v18 = v3 + 391;
                    v19 = 2048;
                    v20 = v3;
                    _os_log_impl(&dword_1B4F6D000, v12, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Already connected, reporting.", (uint8_t *)&v13, 0x26u);
                  }
                }
              }
              (*(void (**)(void))(*(_QWORD *)(a1[6] + 24) + 40))();
            }
            else if ((*(_BYTE *)(v3 + 388) & 4) != 0)
            {
              if ((*(_BYTE *)(v3 + 475) & 1) == 0)
              {
                v11 = g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO))
                  {
                    v13 = 136446978;
                    v14 = "nw_protocol_boringssl_connected";
                    v15 = 1024;
                    v16 = 1618;
                    v17 = 2082;
                    v18 = v3 + 391;
                    v19 = 2048;
                    v20 = v3;
                    _os_log_impl(&dword_1B4F6D000, v11, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Already started the negotiation. Skipping.", (uint8_t *)&v13, 0x26u);
                  }
                }
              }
            }
            else
            {
              *(_BYTE *)(v3 + 388) |= 4u;
              v8 = a1[4];
              if (v8)
              {
                v9 = *(_QWORD *)(v8 + 24);
                if (v9)
                {
                  v10 = *(unsigned int (**)(void))(v9 + 216);
                  if (v10)
                  {
                    if (v10())
                      *(_BYTE *)(v3 + 389) |= 0x80u;
                  }
                }
              }
              if (!boringssl_session_get_state(*(_QWORD *)(v3 + 336)))
                nw_protocol_boringssl_begin_connection((uint64_t)a1);
            }
          }
        }
        else if ((*(_BYTE *)(v3 + 475) & 1) == 0
               && g_boringssl_log
               && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        {
          nw_protocol_boringssl_connected_cold_2();
        }
      }
      else if ((*(_BYTE *)(v3 + 475) & 1) == 0
             && g_boringssl_log
             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_connected_cold_1();
      }
    }
  }
}

void nw_protocol_boringssl_begin_connection(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;
  char v4;
  uint64_t v5;
  int is_probe;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  sockaddr *address;
  const char *subject_name;
  char *v12;
  size_t v13;
  uint64_t v14;
  void *v15;
  NSObject *v16;
  NSObject *v17;
  nw_protocol_definition_t v18;
  void *v19;
  void *v20;
  char v21;
  nw_protocol_definition_t v22;
  char v23;
  int early_data_enabled;
  char v25;
  char v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  NSObject *v33;
  BOOL v34;
  const char *v35;
  void *v36;
  _QWORD v37[5];
  _BYTE buf[28];
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  const char *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
  {
    if ((*(_BYTE *)(v1 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_begin_connection_cold_11();
    }
    (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24) + 112))();
    v3 = objc_claimAutoreleasedReturnValue();
    if (v3)
    {
      if (nw_parameters_get_server_mode())
        v4 = 8;
      else
        v4 = 0;
      *(_BYTE *)(v1 + 389) = *(_BYTE *)(v1 + 389) & 0xF7 | v4;
      v5 = *(_QWORD *)(v1 + 336);
      is_probe = nw_parameters_get_is_probe();
      boringssl_context_set_is_probe(v5, is_probe);
      boringssl_context_set_protocol_alert_callback(*(_QWORD *)(v1 + 336), &__block_literal_global_138);
      v7 = *(_QWORD *)(v1 + 336);
      v37[0] = MEMORY[0x1E0C809B0];
      v37[1] = 3221225472;
      v37[2] = __nw_protocol_boringssl_begin_connection_block_invoke_2;
      v37[3] = &__block_descriptor_40_e50_v16__0__boringssl_concrete_nw_protocol_boringssl_8lu32l8;
      v37[4] = v1;
      boringssl_context_set_connected_callback(v7, v37);
      if ((boringssl_session_create(*(SSL_CTX **)(v1 + 336)) & 1) != 0)
      {
        if ((boringssl_session_set_bio(*(_QWORD *)(v1 + 336), *(BIO **)(v1 + 344), *(BIO **)(v1 + 344)) & 1) != 0)
        {
          (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24) + 136))();
          v8 = objc_claimAutoreleasedReturnValue();
          v9 = v8;
          if (v8)
          {
            if (nw_endpoint_get_type(v8) == nw_endpoint_type_address)
            {
              address = (sockaddr *)nw_endpoint_get_address(v9);
              boringssl_context_set_remote_address(*(_QWORD **)(v1 + 336), &address->sa_len);
            }
            if (nw_parameters_get_sensitive_redacted_for_endpoint())
              *(_BYTE *)(v1 + 475) |= 2u;
            if ((*(_BYTE *)(v1 + 389) & 8) != 0
              || (subject_name = (const char *)nw_protocol_boringssl_get_subject_name((void *)v1, v9),
                  (v12 = (char *)subject_name) == 0)
              || (v13 = strlen(subject_name),
                  (boringssl_session_set_peer_hostname(*(_QWORD *)(v1 + 336), v12, v13) & 1) != 0))
            {
              if (os_variant_allows_internal_security_policies()
                && nw_parameters_get_enable_tls_keylog())
              {
                boringssl_context_enable_keylog(*(_QWORD *)(v1 + 336));
              }
              v36 = (void *)nw_parameters_copy_protocol_options_legacy();
              if (v36)
              {
                *(_QWORD *)buf = 0;
                *(_QWORD *)&buf[8] = buf;
                *(_QWORD *)&buf[16] = 0x2020000000;
                buf[24] = 0;
                nw_protocol_options_access_handle();
                boringssl_context_set_enable_message_mode(*(_QWORD **)(v1 + 336), *(unsigned __int8 *)(*(_QWORD *)&buf[8] + 24));
                v14 = objc_claimAutoreleasedReturnValue();
                v15 = *(void **)(v1 + 272);
                *(_QWORD *)(v1 + 272) = v14;

                v16 = nw_parameters_copy_default_protocol_stack(v3);
                v17 = nw_protocol_stack_copy_original_proxied_transport_protocol();
                if (v17 || (v17 = nw_protocol_stack_copy_transport_protocol(v16)) != 0)
                {
                  v18 = nw_protocol_options_copy_definition(v17);
                  if (v18)
                  {
                    v19 = (void *)nw_protocol_copy_quic_connection_definition();
                    if (MEMORY[0x1B5E453F0](v18, v19))
                    {

                    }
                    else
                    {
                      v20 = (void *)nw_protocol_copy_quic_stream_definition();
                      v21 = MEMORY[0x1B5E453F0](v18, v20);

                      if ((v21 & 1) == 0)
                      {
                        v22 = nw_protocol_copy_tcp_definition();
                        MEMORY[0x1B5E453F0](v18, v22);

                      }
                    }
                  }

                }
                v23 = boringssl_session_apply_protocol_options_for_transport(*(_QWORD *)(v1 + 336), v36);
                if ((v23 & 1) != 0)
                {
                  early_data_enabled = boringssl_session_get_early_data_enabled(*(_QWORD *)(v1 + 336));
                  v25 = *(_BYTE *)(v1 + 389);
                  if (early_data_enabled | ((v25 & 0x20) >> 5))
                    v26 = 32;
                  else
                    v26 = 0;
                  *(_BYTE *)(v1 + 389) = v26 | v25 & 0xDF;
                }
                else
                {
                  if ((*(_BYTE *)(v1 + 475) & 1) == 0
                    && g_boringssl_log
                    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                  {
                    nw_protocol_boringssl_begin_connection_cold_8();
                  }
                  nw_protocol_boringssl_internal_error((void *)v1, -9810);
                  nw_protocol_boringssl_disconnect(a1);
                }

                _Block_object_dispose(buf, 8);
                if ((v23 & 1) != 0)
                {
                  if ((*(_BYTE *)(v1 + 389) & 8) == 0)
                  {
                    if (boringssl_context_get_ech_enabled(*(_QWORD *)(v1 + 336)))
                    {
                      v27 = (void *)nw_endpoint_copy_ech_config();
                      if (boringssl_session_set_ech_config(*(_QWORD *)(v1 + 336), v27))
                      {
                        if ((*(_BYTE *)(v1 + 475) & 1) == 0
                          && g_boringssl_log
                          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                        {
                          nw_protocol_boringssl_begin_connection_cold_6();
                        }
                      }
                      else if ((*(_BYTE *)(v1 + 475) & 1) == 0
                             && g_boringssl_log
                             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                      {
                        nw_protocol_boringssl_begin_connection_cold_7();
                      }

                    }
                    if (*(_QWORD *)(v1 + 312))
                    {
                      v28 = (void *)nw_endpoint_copy_original_endpoint();
                      v29 = (void *)nw_parameters_copy_context();
                      if (v29)
                      {
                        v30 = (void *)nw_context_copy_registered_endpoint();

                        v31 = nw_endpoint_copy_association();
                        v32 = *(void **)(v1 + 328);
                        *(_QWORD *)(v1 + 328) = v31;

                        boringssl_session_set_association(*(_QWORD *)(v1 + 336), *(void **)(v1 + 328));
                      }
                      else
                      {
                        if ((*(_BYTE *)(v1 + 475) & 1) == 0
                          && g_boringssl_log
                          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                        {
                          nw_protocol_boringssl_begin_connection_cold_5();
                        }
                        v30 = v28;
                      }

                    }
                    else if ((*(_BYTE *)(v1 + 475) & 1) == 0
                           && g_boringssl_log
                           && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                    {
                      nw_protocol_boringssl_begin_connection_cold_4();
                    }
                  }
                  boringssl_session_clear_eap_metadata(*(_QWORD *)(v1 + 336));
                  nw_protocol_boringssl_handshake_negotiate((void *)v1);
                }
              }
              else
              {
                if ((*(_BYTE *)(v1 + 475) & 1) == 0
                  && g_boringssl_log
                  && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                {
                  nw_protocol_boringssl_begin_connection_cold_3();
                }
                ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))nw_protocol_error_print, *(void **)(v1 + 336));
                nw_protocol_boringssl_internal_error((void *)v1, -9854);
                nw_protocol_boringssl_disconnect(v1 + 8);
              }

            }
            else
            {
              if ((*(_BYTE *)(v1 + 475) & 1) == 0)
              {
                v33 = g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                  {
                    v34 = (*(_BYTE *)(v1 + 475) & 2) == 0;
                    *(_DWORD *)buf = 136447234;
                    *(_QWORD *)&buf[4] = "nw_protocol_boringssl_begin_connection";
                    if (v34)
                      v35 = v12;
                    else
                      v35 = "redacted";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = 457;
                    *(_WORD *)&buf[18] = 2082;
                    *(_QWORD *)&buf[20] = v1 + 391;
                    v39 = 2048;
                    v40 = v1;
                    v41 = 2082;
                    v42 = v35;
                    _os_log_error_impl(&dword_1B4F6D000, v33, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] boringssl_session_set_peer_hostname(%{public}s) failed", buf, 0x30u);
                  }
                }
              }
              nw_protocol_boringssl_internal_error((void *)v1, -9810);
              nw_protocol_boringssl_disconnect(a1);
            }
          }
          else if ((*(_BYTE *)(v1 + 475) & 1) == 0
                 && g_boringssl_log
                 && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            nw_protocol_boringssl_begin_connection_cold_2();
          }

        }
        else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        {
          nw_protocol_boringssl_begin_connection_cold_9();
        }
      }
      else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_begin_connection_cold_10();
      }
    }
    else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_begin_connection_cold_1();
    }

  }
}

void sub_1B4FA4498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t boringssl_context_get_ech_enabled(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return (*(unsigned __int8 *)(v1 + 560) >> 3) & 1;
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_set_peer_hostname(uint64_t a1, char *__s1, size_t __n)
{
  uint64_t v4;
  uint64_t v6;
  void *v7;
  int is_valid_sni_value;
  id WeakRetained;
  void *v10;
  _BYTE *v11;
  char v12;
  id v13;
  _BYTE *v14;
  _BOOL4 v15;
  id v17;
  void *v18;
  _BYTE *v19;
  char v20;
  id v21;
  _BYTE *v22;
  _BOOL4 v23;
  NSObject *v24;

  if (!a1 || *(_DWORD *)a1 != -1252936367)
    return 0;
  v4 = 0;
  if (__n - 256 < 0xFFFFFFFFFFFFFF01)
    return v4;
  if (!__s1)
    return v4;
  v6 = *(_QWORD *)(a1 + 8);
  if (!v6)
    return v4;
  v4 = *(_QWORD *)(v6 + 400);
  if (!v4)
    return v4;
  v7 = *(void **)(v6 + 80);
  if (v7)
  {
    free(v7);
    *(_QWORD *)(v6 + 80) = 0;
  }
  *(_QWORD *)(v6 + 80) = strndup(__s1, __n);
  if (!*(_QWORD *)(v6 + 80))
    return 0;
  is_valid_sni_value = boringssl_helper_is_valid_sni_value((uint64_t)__s1, __n);
  if ((is_valid_sni_value & 1) != 0)
  {
    if (!SSL_set_tlsext_host_name(v4, __s1))
    {
      WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
      if (!WeakRetained
        || (v10 = WeakRetained,
            v11 = objc_loadWeakRetained((id *)(v6 + 16)),
            v12 = v11[475],
            v11,
            v10,
            (v12 & 1) == 0))
      {
        v13 = objc_loadWeakRetained((id *)(v6 + 16));
        if (v13)
        {
          v14 = objc_loadWeakRetained((id *)(v6 + 16));
          v15 = (v14[475] & 1) == 0;

        }
        else
        {
          v15 = 1;
        }

        v4 = 0;
        if (v15 && g_boringssl_log)
        {
          v24 = (id)g_boringssl_log;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            boringssl_session_set_peer_hostname_cold_1(v6, v24);
LABEL_33:
          v4 = is_valid_sni_value ^ 1u;

          return v4;
        }
        return v4;
      }
      return 0;
    }
    return 1;
  }
  v17 = objc_loadWeakRetained((id *)(v6 + 16));
  if (v17)
  {
    v18 = v17;
    v19 = objc_loadWeakRetained((id *)(v6 + 16));
    v20 = v19[475];

    if ((v20 & 1) != 0)
      return 1;
  }
  v21 = objc_loadWeakRetained((id *)(v6 + 16));
  if (v21)
  {
    v22 = objc_loadWeakRetained((id *)(v6 + 16));
    v23 = (v22[475] & 1) == 0;

  }
  else
  {
    v23 = 1;
  }

  v4 = 1;
  if (v23 && g_boringssl_log)
  {
    v24 = (id)g_boringssl_log;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      boringssl_session_set_peer_hostname_cold_2(v6, v24);
    goto LABEL_33;
  }
  return v4;
}

uint64_t boringssl_helper_is_valid_sni_value(uint64_t a1, uint64_t a2)
{
  uint64_t IsDNSName;
  uint64_t v4;
  CFStringRef v5;
  CFStringRef v6;
  _OWORD v8[16];
  uint64_t v9;

  IsDNSName = 0;
  v9 = *MEMORY[0x1E0C80C00];
  if (a1 && (unint64_t)(a2 - 1) <= 0xFE)
  {
    memset(v8, 0, sizeof(v8));
    __memcpy_chk();
    v4 = 0;
    while (*((_BYTE *)v8 + v4) && *((_BYTE *)v8 + v4) != 42)
    {
      if (a2 == ++v4)
      {
        v5 = CFStringCreateWithCString(0, (const char *)v8, 0x8000100u);
        if (v5)
        {
          v6 = v5;
          IsDNSName = SecFrameworkIsDNSName();
          CFRelease(v6);
          return IsDNSName;
        }
        return 0;
      }
    }
    return 0;
  }
  return IsDNSName;
}

void boringssl_session_set_association(uint64_t a1, void *a2)
{
  uint64_t v2;
  id v4;
  void *v5;
  uint64_t v6;
  boringssl_concrete_boringssl_session_cache *v7;
  void *v8;
  id v9;
  void *v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  BOOL is_session_state;
  id WeakRetained;
  _BYTE *v17;
  char v18;
  id v19;
  _BYTE *v20;
  _BOOL4 v21;
  _BYTE *v22;
  char v23;
  id v24;
  _BYTE *v25;
  NSObject *v26;
  id v27;
  void *v28;
  NSObject *v29;
  id v30;
  void *v31;
  _BYTE *v32;
  char v33;
  id v34;
  _BYTE *v35;
  _BOOL4 v36;
  NSObject *v37;
  id v38;
  void *v39;
  id v40;
  void *v41;
  const char *v42;
  id v43;
  void *v44;
  const char *v45;
  int v46;
  id v47;
  void *v48;
  _BYTE *v49;
  char v50;
  id v51;
  _BYTE *v52;
  _BOOL4 v53;
  id v54;
  void *v55;
  id v56;
  void *v57;
  char v58;
  const char *v59;
  const char *v60;
  char *v61;
  uint8_t buf[4];
  const char *v63;
  __int16 v64;
  int v65;
  __int16 v66;
  void *v67;
  __int16 v68;
  id v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  const char *v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  v5 = v4;
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      if (v4)
      {
        v6 = *(_QWORD *)(a1 + 8);
        if (v6)
        {
          v7 = boringssl_session_cache_create_with_association(v4);
          v8 = *(void **)(v6 + 32);
          *(_QWORD *)(v6 + 32) = v7;

          if ((boringssl_context_get_is_probe(a1) & 1) == 0)
          {
            v9 = *(id *)(v6 + 32);
            v10 = v9;
            if (*(_DWORD *)a1 != -1252936367)
              goto LABEL_73;
            v11 = *(_QWORD *)(a1 + 8);
            v12 = !v9 || v11 == 0;
            if (v12)
              goto LABEL_73;
            boringssl_session_cache_pop(v9);
            v13 = objc_claimAutoreleasedReturnValue();
            if (v13)
            {
              v14 = (void *)v13;
              is_session_state = boringssl_session_state_is_session_state(v13);
              WeakRetained = objc_loadWeakRetained((id *)(v11 + 16));
              v2 = (uint64_t)WeakRetained;
              if (is_session_state)
              {
                if (!WeakRetained
                  || (v17 = objc_loadWeakRetained((id *)(v11 + 16)),
                      v18 = v17[475],
                      v17,
                      (id)v2,
                      (v18 & 1) == 0))
                {
                  v19 = objc_loadWeakRetained((id *)(v11 + 16));
                  if (v19)
                  {
                    v20 = objc_loadWeakRetained((id *)(v11 + 16));
                    v21 = (v20[475] & 1) == 0;

                  }
                  else
                  {
                    v21 = 1;
                  }

                  if (v21)
                  {
                    if (g_boringssl_log)
                    {
                      v26 = (id)g_boringssl_log;
                      if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
                      {
                        v27 = objc_loadWeakRetained((id *)(v11 + 16));
                        if (v27)
                        {
                          v61 = (char *)objc_loadWeakRetained((id *)(v11 + 16));
                          v28 = v61 + 391;
                        }
                        else
                        {
                          v28 = &unk_1B50022E3;
                        }
                        v43 = objc_loadWeakRetained((id *)(v11 + 16));
                        v44 = v43;
                        v12 = (*(_BYTE *)(v11 + 556) & 0x10) == 0;
                        *(_DWORD *)buf = 136447234;
                        v63 = "boringssl_session_install_association_state";
                        if (v12)
                          v45 = "Client";
                        else
                          v45 = "Server";
                        v64 = 1024;
                        v65 = 1416;
                        v66 = 2082;
                        v67 = v28;
                        v68 = 2048;
                        v69 = v43;
                        v70 = 2082;
                        v71 = v45;
                        _os_log_impl(&dword_1B4F6D000, v26, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] %{public}s session cache hit", buf, 0x30u);

                        if (v27)
                      }

                    }
                  }
                }
                v46 = boringssl_session_set_session_state(a1, v14);
                v47 = objc_loadWeakRetained((id *)(v11 + 16));
                if (v47)
                {
                  v48 = v47;
                  v49 = objc_loadWeakRetained((id *)(v11 + 16));
                  v50 = v49[475];

                  if ((v50 & 1) != 0)
                    goto LABEL_72;
                }
                v51 = objc_loadWeakRetained((id *)(v11 + 16));
                if (v51)
                {
                  v52 = objc_loadWeakRetained((id *)(v11 + 16));
                  v53 = (v52[475] & 1) == 0;

                }
                else
                {
                  v53 = 1;
                }

                if (!v53 || !g_boringssl_log)
                  goto LABEL_72;
                v37 = (id)g_boringssl_log;
                if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
                {
                  v54 = objc_loadWeakRetained((id *)(v11 + 16));
                  if (v54)
                  {
                    v61 = (char *)objc_loadWeakRetained((id *)(v11 + 16));
                    v55 = v61 + 391;
                  }
                  else
                  {
                    v55 = &unk_1B50022E3;
                  }
                  v56 = objc_loadWeakRetained((id *)(v11 + 16));
                  v57 = v56;
                  v58 = *(_BYTE *)(v11 + 556);
                  v59 = "Server";
                  v63 = "boringssl_session_install_association_state";
                  v64 = 1024;
                  v12 = (v58 & 0x10) == 0;
                  v65 = 1419;
                  v60 = "not set";
                  v67 = v55;
                  *(_DWORD *)buf = 136447490;
                  if (v12)
                    v59 = "Client";
                  v66 = 2082;
                  v68 = 2048;
                  if (v46)
                    v60 = "set";
                  v69 = v56;
                  v70 = 2082;
                  v71 = v59;
                  v72 = 2082;
                  v73 = v60;
                  _os_log_impl(&dword_1B4F6D000, v37, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] %{public}s session state %{public}s.", buf, 0x3Au);

                  if (v54)
                }
                goto LABEL_53;
              }
              if (!WeakRetained
                || (v22 = objc_loadWeakRetained((id *)(v11 + 16)),
                    v23 = v22[475],
                    v22,
                    (id)v2,
                    (v23 & 1) == 0))
              {
                v24 = objc_loadWeakRetained((id *)(v11 + 16));
                if (v24)
                {
                  v25 = objc_loadWeakRetained((id *)(v11 + 16));
                  v2 = (v25[475] & 1) == 0;

                }
                else
                {
                  v2 = 1;
                }

                if ((_DWORD)v2)
                {
                  if (g_boringssl_log)
                  {
                    v29 = (id)g_boringssl_log;
                    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                      boringssl_session_set_association_cold_1(v11, v29);

                  }
                }
              }

            }
            v30 = objc_loadWeakRetained((id *)(v11 + 16));
            if (v30)
            {
              v31 = v30;
              v32 = objc_loadWeakRetained((id *)(v11 + 16));
              v33 = v32[475];

              if ((v33 & 1) != 0)
              {
                v14 = 0;
LABEL_72:

LABEL_73:
                goto LABEL_74;
              }
            }
            v34 = objc_loadWeakRetained((id *)(v11 + 16));
            if (v34)
            {
              v35 = objc_loadWeakRetained((id *)(v11 + 16));
              v36 = (v35[475] & 1) == 0;

            }
            else
            {
              v36 = 1;
            }

            v14 = 0;
            if (!v36 || !g_boringssl_log)
              goto LABEL_72;
            v37 = (id)g_boringssl_log;
            if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
            {
              v38 = objc_loadWeakRetained((id *)(v11 + 16));
              if (v38)
              {
                v2 = (uint64_t)objc_loadWeakRetained((id *)(v11 + 16));
                v39 = (void *)(v2 + 391);
              }
              else
              {
                v39 = &unk_1B50022E3;
              }
              v40 = objc_loadWeakRetained((id *)(v11 + 16));
              v41 = v40;
              v12 = (*(_BYTE *)(v11 + 556) & 0x10) == 0;
              *(_DWORD *)buf = 136447234;
              v63 = "boringssl_session_install_association_state";
              if (v12)
                v42 = "Client";
              else
                v42 = "Server";
              v64 = 1024;
              v65 = 1421;
              v66 = 2082;
              v67 = v39;
              v68 = 2048;
              v69 = v40;
              v70 = 2082;
              v71 = v42;
              _os_log_impl(&dword_1B4F6D000, v37, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] %{public}s session cache miss", buf, 0x30u);

              if (v38)
            }
            v14 = 0;
LABEL_53:

            goto LABEL_72;
          }
        }
      }
    }
  }
LABEL_74:

}

uint64_t boringssl_context_get_is_probe(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return (*(unsigned __int8 *)(v1 + 559) >> 2) & 1;
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_get_early_data_enabled(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(_BYTE *)(v1 + 559) & 1;
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_clear_eap_metadata(uint64_t result)
{
  if (result && *(_DWORD *)result == -1252936367)
  {
    if (*(_QWORD *)(result + 8))
      return nw_protocol_metadata_access_handle();
  }
  return result;
}

boringssl_concrete_boringssl_session_cache *boringssl_session_cache_create_with_association(void *a1)
{
  id v2;
  boringssl_concrete_boringssl_session_cache *v3;
  boringssl_concrete_boringssl_session_cache *v4;

  v2 = a1;
  v3 = objc_alloc_init(boringssl_concrete_boringssl_session_cache);
  v4 = v3;
  if (v3)
    objc_storeStrong((id *)&v3->association, a1);

  return v4;
}

uint64_t __boringssl_session_clear_eap_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)(a2 + 320);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a2 + 320) = 0;
  }
  return 1;
}

void boringssl_context_set_protocol_alert_callback(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  id v7;

  v3 = a2;
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      v4 = *(_QWORD *)(a1 + 8);
      if (v4)
      {
        v7 = v3;
        v5 = MEMORY[0x1B5E45624]();
        v6 = *(void **)(v4 + 280);
        *(_QWORD *)(v4 + 280) = v5;

        v3 = v7;
      }
    }
  }

}

uint64_t boringssl_context_set_is_probe(uint64_t result, int a2)
{
  uint64_t v2;
  char v3;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      v2 = *(_QWORD *)(result + 8);
      if (v2)
      {
        if (a2)
          v3 = 4;
        else
          v3 = 0;
        *(_BYTE *)(v2 + 559) = *(_BYTE *)(v2 + 559) & 0xFB | v3;
      }
    }
  }
  return result;
}

void boringssl_context_set_connected_callback(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  id v7;

  v3 = a2;
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      v4 = *(_QWORD *)(a1 + 8);
      if (v4)
      {
        v7 = v3;
        v5 = MEMORY[0x1B5E45624]();
        v6 = *(void **)(v4 + 288);
        *(_QWORD *)(v4 + 288) = v5;

        v3 = v7;
      }
    }
  }

}

void *nw_protocol_boringssl_get_subject_name(void *a1, void *a2)
{
  _QWORD *v3;
  NSObject *v4;
  NSObject *v5;
  void *v6;
  void *v7;
  NSObject *v8;
  void *endpoint_name;
  uint64_t v10;
  NSObject *v11;
  void *v12;
  NSObject *v13;
  void *v14;
  char v16;

  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3 && v4)
  {
    v6 = (void *)nw_endpoint_copy_proxy_original_endpoint();
    v7 = v6;
    if (v6)
    {
      v8 = v6;

      v5 = v8;
    }
    v16 = 0;
    endpoint_name = (void *)nw_protocol_boringssl_get_endpoint_name(v5, &v16);
    v5 = v5;
    v10 = nw_endpoint_copy_parent_endpoint();
    v11 = v5;
    if (v10)
    {
      v12 = (void *)v10;
      v13 = v5;
      do
      {
        v11 = v12;

        v12 = (void *)nw_endpoint_copy_parent_endpoint();
        v13 = v11;
      }
      while (v12);
    }
    if (nw_endpoint_get_type(v11) == (nw_endpoint_type_url|nw_endpoint_type_address))
    {
      if (v16 && endpoint_name)
        free(endpoint_name);
      v16 = 0;
      endpoint_name = (void *)nw_protocol_boringssl_get_endpoint_name(v11, &v16);
    }
    if (v16)
    {
      v14 = (void *)v3[44];
      if (v14)
        free(v14);
      v3[44] = endpoint_name;
    }

  }
  else
  {
    endpoint_name = 0;
  }

  return endpoint_name;
}

uint64_t nw_protocol_boringssl_get_endpoint_name(void *a1, _BYTE *a2)
{
  NSObject *v3;
  uint64_t hostname;
  uint64_t parent_endpoint_domain;

  v3 = a1;
  if (nw_endpoint_get_type(v3) == nw_endpoint_type_host)
  {
    hostname = (uint64_t)nw_endpoint_get_hostname(v3);
LABEL_10:
    parent_endpoint_domain = hostname;
    goto LABEL_11;
  }
  if (nw_endpoint_get_type(v3) != nw_endpoint_type_address)
  {
    if (nw_endpoint_get_type(v3) == nw_endpoint_type_bonjour_service)
    {
      hostname = nw_endpoint_get_bonjour_fullname();
    }
    else
    {
      if (nw_endpoint_get_type(v3) != (nw_endpoint_type_url|nw_endpoint_type_address))
      {
        parent_endpoint_domain = 0;
        goto LABEL_11;
      }
      hostname = nw_endpoint_get_srv_name();
    }
    goto LABEL_10;
  }
  parent_endpoint_domain = nw_endpoint_get_parent_endpoint_domain();
  if (!parent_endpoint_domain)
  {
    parent_endpoint_domain = (uint64_t)nw_endpoint_copy_address_string(v3);
    *a2 = 1;
  }
LABEL_11:

  return parent_endpoint_domain;
}

uint64_t boringssl_session_set_bio(uint64_t result, BIO *a2, BIO *a3)
{
  uint64_t v3;
  uint64_t v6;

  if (result)
  {
    v3 = result;
    if (*(_DWORD *)result != -1252936367)
      return 0;
    result = 0;
    if (a3)
    {
      if (a2)
      {
        v6 = *(_QWORD *)(v3 + 8);
        if (v6)
        {
          if (*(_QWORD *)(v6 + 400))
          {
            BIO_up_ref((uint64_t)a2);
            SSL_set_bio(*(SSL **)(v6 + 400), a2, a3);
            return 1;
          }
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t boringssl_session_apply_protocol_options_for_transport(uint64_t a1, void *a2)
{
  id v4;
  uint64_t v5;
  uint64_t v6;
  id v8;

  v4 = a2;
  if (a1 && *(_DWORD *)a1 == -1252936367 && (v5 = *(_QWORD *)(a1 + 8)) != 0)
  {
    objc_storeStrong((id *)(v5 + 512), a2);
    v8 = v4;
    v6 = nw_protocol_options_access_handle();

  }
  else
  {
    v6 = 0;
  }

  return v6;
}

_QWORD *boringssl_context_set_remote_address(_QWORD *result, unsigned __int8 *a2)
{
  uint64_t v2;
  int v3;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      if (a2)
      {
        v2 = result[1];
        if (v2)
        {
          v3 = a2[1];
          if (v3 == 30 || v3 == 2)
            return memcpy((void *)(v2 + 224), a2, *a2);
        }
      }
    }
  }
  return result;
}

_QWORD *boringssl_context_set_enable_message_mode(_QWORD *a1, int a2)
{
  uint64_t v2;
  id *v6;
  id WeakRetained;
  void *v8;
  _BYTE *v9;
  char v10;
  id v11;
  _BYTE *v12;
  _BOOL4 v13;
  NSObject *v14;
  _QWORD v15[5];

  if (a1)
  {
    if (*(_DWORD *)a1 != -1252936367)
      goto LABEL_8;
    v2 = a1[1];
    if (!v2 || a2 == 0)
      goto LABEL_8;
    if (SSL_set_quic_method(*(_QWORD *)(v2 + 400), (uint64_t)&boringssl_quic_method))
    {
      v15[0] = MEMORY[0x1E0C809B0];
      v15[1] = 3221225472;
      v15[2] = __boringssl_context_set_enable_message_mode_block_invoke;
      v15[3] = &__block_descriptor_40_e15_B28__0i8r_12Q20lu32l8;
      v15[4] = v2;
      a1 = (_QWORD *)MEMORY[0x1B5E45624](v15);
      return a1;
    }
    v6 = (id *)(v2 + 16);
    WeakRetained = objc_loadWeakRetained(v6);
    if (WeakRetained)
    {
      v8 = WeakRetained;
      v9 = objc_loadWeakRetained(v6);
      v10 = v9[475];

      if ((v10 & 1) != 0)
        goto LABEL_8;
    }
    v11 = objc_loadWeakRetained(v6);
    if (v11)
    {
      v12 = objc_loadWeakRetained(v6);
      v13 = (v12[475] & 1) == 0;

    }
    else
    {
      v13 = 1;
    }

    a1 = 0;
    if (v13 && g_boringssl_log)
    {
      v14 = (id)g_boringssl_log;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        boringssl_context_set_enable_message_mode_cold_1(v6, v14);

LABEL_8:
      a1 = 0;
    }
  }
  return a1;
}

void SSL_set_bio(SSL *s, BIO *rbio, BIO *wbio)
{
  BIO **p_wbio;
  BIO *v7;
  BIO **p_bbio;
  BIO *v9;
  BOOL v10;

  p_wbio = &s->wbio;
  v7 = s->wbio;
  if (*(_OWORD *)&s->wbio != __PAIR128__((unint64_t)wbio, (unint64_t)rbio))
  {
    if (rbio && rbio == wbio)
    {
      BIO_up_ref((uint64_t)rbio);
      v7 = *p_wbio;
    }
    p_bbio = &s->bbio;
    if (v7 == rbio
      || ((v9 = *p_bbio, std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100](p_wbio, rbio), v9 == wbio)
        ? (v10 = v7 == v9)
        : (v10 = 1),
          v10))
    {
      std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100](p_bbio, wbio);
    }
  }
}

uint64_t BIO_up_ref(uint64_t a1)
{
  CRYPTO_refcount_inc((unsigned int *)(a1 + 28));
  return 1;
}

int BIO_free(BIO *a)
{
  BIO *v1;
  BIO *v2;
  int result;
  int (__cdecl *destroy)(BIO *);

  if (!a)
    return 1;
  v1 = a;
  while (1)
  {
    v2 = v1;
    result = CRYPTO_refcount_dec_and_test_zero((unsigned int *)&v1->shutdown);
    if (!result)
      break;
    v1 = *(BIO **)&v1->num;
    *(_QWORD *)&v2->num = 0;
    if (v2->method)
    {
      destroy = v2->method->destroy;
      if (destroy)
        ((void (*)(BIO *))destroy)(v2);
    }
    OPENSSL_free(v2);
    if (!v1)
      return 1;
  }
  return result;
}

uint64_t SSL_set_quic_method(uint64_t a1, uint64_t a2)
{
  if (**(_BYTE **)a1)
    return 0;
  *(_QWORD *)(a1 + 168) = a2;
  return 1;
}

uint64_t boringssl_bio_free(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 12))
    {
      *(_DWORD *)(result + 8) = 0;
      *(_DWORD *)(result + 16) = 0;
    }
    return 1;
  }
  return result;
}

BOOL boringssl_session_state_is_session_state(_BOOL8 result)
{
  if (result)
    return *(unsigned __int8 *)(result + 8) == 1;
  return result;
}

uint64_t boringssl_session_set_session_state(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  int used_extended_master_secret;
  BOOL has_remote_address;
  id v9;
  void *v10;
  _BYTE *v11;
  char v12;
  id v13;
  _BYTE *v14;
  _BOOL4 v15;
  SSL_SESSION *inner_session;
  SSL_SESSION *v17;
  id v18;
  void *v19;
  _BYTE *v20;
  char v21;
  id v22;
  _BYTE *v23;
  _BOOL4 v24;
  id WeakRetained;
  void *v26;
  _BYTE *v27;
  char v28;
  id v29;
  _BYTE *v30;
  _BOOL4 v31;
  NSObject *v32;
  NSObject *v33;

  v3 = a2;
  v4 = v3;
  if (!a1 || *(_DWORD *)a1 != -1252936367)
    goto LABEL_40;
  v5 = 0;
  if (v3)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      used_extended_master_secret = boringssl_session_state_get_used_extended_master_secret((uint64_t)v3);
      has_remote_address = boringssl_session_state_has_remote_address(v4, (unsigned __int8 *)(v6 + 224));
      if (used_extended_master_secret || has_remote_address)
      {
        inner_session = boringssl_session_state_create_inner_session((uint64_t)v4, v6);
        if (inner_session)
        {
          v17 = inner_session;
          if (!boringssl_session_can_resume_with_state((void *)v6, (uint64_t)inner_session))
          {
            WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
            if (!WeakRetained
              || (v26 = WeakRetained,
                  v27 = objc_loadWeakRetained((id *)(v6 + 16)),
                  v28 = v27[475],
                  v27,
                  v26,
                  (v28 & 1) == 0))
            {
              v29 = objc_loadWeakRetained((id *)(v6 + 16));
              if (v29)
              {
                v30 = objc_loadWeakRetained((id *)(v6 + 16));
                v31 = (v30[475] & 1) == 0;

              }
              else
              {
                v31 = 1;
              }

              if (v31)
              {
                if (g_boringssl_log)
                {
                  v33 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
                    boringssl_session_set_session_state_cold_2(v6, v33);

                }
              }
            }
            SSL_SESSION_free(v17);
            goto LABEL_40;
          }
          SSL_set_session(*(SSL **)(v6 + 400), v17);
          *(_BYTE *)(v6 + 558) |= 0x40u;
          *(_BYTE *)(v6 + 558) = *(_BYTE *)(v6 + 558) & 0x7F | (SSL_SESSION_has_ticket((uint64_t)v17) << 7);
          SSL_SESSION_free(v17);
          v5 = 1;
        }
        else
        {
          v18 = objc_loadWeakRetained((id *)(v6 + 16));
          if (v18)
          {
            v19 = v18;
            v20 = objc_loadWeakRetained((id *)(v6 + 16));
            v21 = v20[475];

            if ((v21 & 1) != 0)
              goto LABEL_40;
          }
          v22 = objc_loadWeakRetained((id *)(v6 + 16));
          if (v22)
          {
            v23 = objc_loadWeakRetained((id *)(v6 + 16));
            v24 = (v23[475] & 1) == 0;

          }
          else
          {
            v24 = 1;
          }

          v5 = 0;
          if (v24 && g_boringssl_log)
          {
            v32 = (id)g_boringssl_log;
            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              boringssl_session_set_session_state_cold_1(v6, v32);
            goto LABEL_32;
          }
        }
      }
      else
      {
        v9 = objc_loadWeakRetained((id *)(v6 + 16));
        if (v9)
        {
          v10 = v9;
          v11 = objc_loadWeakRetained((id *)(v6 + 16));
          v12 = v11[475];

          if ((v12 & 1) != 0)
            goto LABEL_40;
        }
        v13 = objc_loadWeakRetained((id *)(v6 + 16));
        if (v13)
        {
          v14 = objc_loadWeakRetained((id *)(v6 + 16));
          v15 = (v14[475] & 1) == 0;

        }
        else
        {
          v15 = 1;
        }

        v5 = 0;
        if (v15 && g_boringssl_log)
        {
          v32 = (id)g_boringssl_log;
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
            boringssl_session_set_session_state_cold_3(v6, v32);
LABEL_32:

LABEL_40:
          v5 = 0;
        }
      }
    }
  }

  return v5;
}

BOOL boringssl_session_state_has_remote_address(void *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  _BOOL8 v5;
  const void *v6;
  size_t v7;

  v3 = a1;
  v4 = v3;
  v5 = 0;
  if (v3 && a2)
  {
    v6 = v3 + 12;
    v7 = v4[12];
    v5 = (_DWORD)v7 == *a2 && memcmp(v6, a2, v7) == 0;
  }

  return v5;
}

uint64_t boringssl_session_state_get_used_extended_master_secret(uint64_t result)
{
  if (result)
    return *(unsigned __int8 *)(result + 9);
  return result;
}

SSL_SESSION *boringssl_session_state_create_inner_session(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
    return SSL_SESSION_from_bytes(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a2 + 408));
  else
    return 0;
}

BOOL boringssl_session_can_resume_with_state(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  _BOOL8 v5;

  v3 = a1;
  v4 = v3;
  v5 = 0;
  if (v3 && a2)
    v5 = (*((_BYTE *)v3 + 559) & 1) != 0 || SSL_SESSION_get_protocol_version(a2) != 772;

  return v5;
}

uint64_t SSL_SESSION_get_protocol_version(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 4);
}

SSL_SESSION *SSL_SESSION_from_bytes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  SSL_SESSION *v4;
  SSL_SESSION *v6;
  __int128 v7;

  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  CBS_init(&v7, a1, a2);
  v6 = (SSL_SESSION *)0xAAAAAAAAAAAAAAAALL;
  bssl::SSL_SESSION_parse(&v7, *(uint64_t (***)(void))(a3 + 8), *(_QWORD ***)(a3 + 792), (unint64_t *)&v6);
  v4 = v6;
  if (v6 && CBS_len((uint64_t)&v7))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 869);
    v6 = 0;
    SSL_SESSION_free(v4);
    return 0;
  }
  return v4;
}

void sub_1B4FA5DB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)va, 0);
  _Unwind_Resume(a1);
}

void bssl::SSL_SESSION_parse(__int128 *a1@<X0>, uint64_t (**a2)(void)@<X1>, _QWORD **a3@<X2>, unint64_t *a4@<X8>)
{
  SSL_SESSION *v8;
  void *cipher_by_value;
  unint64_t v10;
  const void *v11;
  size_t v12;
  int v13;
  unint64_t v14;
  const void *v15;
  size_t v16;
  int v17;
  _BYTE *v18;
  char v19;
  unint64_t v20;
  int v21;
  int v22;
  unint64_t v23;
  _OWORD *v24;
  __int128 v25;
  unint64_t v26;
  unint64_t *v27;
  unsigned int *v28;
  STACK *v29;
  unsigned int *v30;
  STACK *v31;
  unint64_t v32;
  unsigned int *v33;
  unsigned int *v34;
  void **v35;
  int v36;
  char v37;
  unsigned int *v38;
  unsigned int *v39;
  void **v40;
  int v41;
  char v42;
  int v43;
  unint64_t v44;
  unsigned int **v45;
  unint64_t v46;
  char v47;
  char v48;
  unsigned int *v49[3];
  int v50;
  int v51;
  int v52;
  unsigned int *v53;
  unsigned int *v54;
  unint64_t v55;
  unsigned int *v56;
  int v57;
  int v58;
  __int128 v59;
  _QWORD v60[2];
  int v61[5];
  unint64_t v62[3];
  _QWORD v63[4];
  _WORD v64[12];
  __int16 v65;
  __int128 v66[2];
  unint64_t v67;

  v67 = 0xAAAAAAAAAAAAAAAALL;
  bssl::ssl_session_new(a2, &v67);
  if (!v67)
  {
    *a4 = 0;
    return;
  }
  memset(v66, 170, sizeof(v66));
  v65 = -21846;
  if (!CBS_get_asn1(a1, &v66[1], 536870928)
    || !CBS_get_asn1_uint64(&v66[1], (unint64_t *)v66 + 1)
    || *((_QWORD *)&v66[0] + 1) != 1
    || !CBS_get_asn1_uint64(&v66[1], (unint64_t *)v66)
    || *(_QWORD *)&v66[0] >> 16
    || (bssl::ssl_protocol_version_from_wire((bssl *)&v65, (unsigned __int16 *)LOWORD(v66[0])) & 1) == 0)
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 553);
    goto LABEL_13;
  }
  *(_WORD *)(v67 + 4) = v66[0];
  memset(v64, 170, 18);
  if (!CBS_get_asn1(&v66[1], &v64[1], 4)
    || !CBS_get_u16((unsigned __int16 **)&v64[1], v64)
    || CBS_len((uint64_t)&v64[1]))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 563);
LABEL_13:
    *a4 = 0;
    goto LABEL_14;
  }
  cipher_by_value = SSL_get_cipher_by_value(v64[0]);
  *(_QWORD *)(v67 + 208) = cipher_by_value;
  if (!cipher_by_value)
  {
    ERR_put_error(16, 0, 237, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 568);
    goto LABEL_13;
  }
  memset(v63, 170, sizeof(v63));
  if (!CBS_get_asn1(&v66[1], &v63[2], 4)
    || (unint64_t)CBS_len((uint64_t)&v63[2]) > 0x20
    || !CBS_get_asn1(&v66[1], v63, 4)
    || (unint64_t)CBS_len((uint64_t)v63) >= 0x31)
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 577);
    goto LABEL_13;
  }
  v10 = v67;
  v11 = (const void *)CBS_data((uint64_t)&v63[2]);
  v12 = CBS_len((uint64_t)&v63[2]);
  if (v12)
    memcpy((void *)(v10 + 68), v11, v12);
  v13 = CBS_len((uint64_t)&v63[2]);
  v14 = v67;
  *(_DWORD *)(v67 + 64) = v13;
  v15 = (const void *)CBS_data((uint64_t)v63);
  v16 = CBS_len((uint64_t)v63);
  if (v16)
    memcpy((void *)(v14 + 16), v15, v16);
  v17 = CBS_len((uint64_t)v63);
  *(_DWORD *)(v67 + 12) = v17;
  memset(v62, 170, sizeof(v62));
  if (!CBS_get_asn1(&v66[1], &v62[1], -1610612735)
    || !CBS_get_asn1_uint64((__int128 *)&v62[1], (unint64_t *)(v67 + 200))
    || !CBS_get_asn1(&v66[1], &v62[1], -1610612734)
    || !CBS_get_asn1_uint64((__int128 *)&v62[1], v62)
    || HIDWORD(v62[0]))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 592);
    goto LABEL_13;
  }
  *(_DWORD *)(v67 + 192) = v62[0];
  memset(v61, 170, sizeof(v61));
  if (!CBS_get_optional_asn1(&v66[1], &v61[1], v61, -1610612733) || v61[0] && !CBS_len((uint64_t)&v61[1]))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 602);
    goto LABEL_13;
  }
  if (!bssl::SSL_SESSION_parse_bounded_octet_string(&v66[1], (void *)(v67 + 101), (_BYTE *)(v67 + 100), 0x20u, -1610612732)|| !bssl::SSL_SESSION_parse_long(&v66[1], (_QWORD *)(v67 + 184)))
  {
    goto LABEL_13;
  }
  v60[0] = 0xAAAAAAAAAAAAAAAALL;
  v60[1] = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_optional_asn1(&v66[1], v60, 0, -1610612730))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 619);
    goto LABEL_13;
  }
  if (!bssl::SSL_SESSION_parse_string(&v66[1], (_QWORD **)(v67 + 136))
    || !bssl::SSL_SESSION_parse_u32(&v66[1], (_DWORD *)(v67 + 380), -1610612727, 0)
    || (bssl::SSL_SESSION_parse_octet_string(&v66[1], (void **)(v67 + 240), -1610612726) & 1) == 0)
  {
    goto LABEL_13;
  }
  if (CBS_peek_asn1_tag(&v66[1], -1610612723))
  {
    *(_QWORD *)&v59 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v59 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (!CBS_get_asn1(&v66[1], &v62[1], -1610612723)
      || !CBS_get_asn1((__int128 *)&v62[1], &v59, 4)
      || CBS_len((uint64_t)&v59) != 32
      || CBS_len((uint64_t)&v62[1]))
    {
      ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 637);
      goto LABEL_13;
    }
    v23 = v67;
    v24 = (_OWORD *)CBS_data((uint64_t)&v59);
    v25 = v24[1];
    *(_OWORD *)(v23 + 280) = *v24;
    *(_OWORD *)(v23 + 296) = v25;
    v18 = (_BYTE *)v67;
    v19 = *(_BYTE *)(v67 + 448) | 2;
  }
  else
  {
    v18 = (_BYTE *)v67;
    v19 = *(_BYTE *)(v67 + 448) & 0xFD;
  }
  v18[448] = v19;
  if (!bssl::SSL_SESSION_parse_bounded_octet_string(&v66[1], v18 + 312, v18 + 376, 0x40u, -1610612722)
    || !bssl::SSL_SESSION_parse_crypto_buffer(&v66[1], (unsigned int **)(v67 + 256), -1610612721, a3)
    || !bssl::SSL_SESSION_parse_crypto_buffer(&v66[1], (unsigned int **)(v67 + 264), -1610612720, a3))
  {
    goto LABEL_13;
  }
  v58 = -1431655766;
  if (!CBS_get_optional_asn1_BOOL(&v66[1], &v58, -1610612719, 0))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 663);
    goto LABEL_13;
  }
  v20 = v67;
  *(_BYTE *)(v67 + 448) = *(_BYTE *)(v67 + 448) & 0xFE | (v58 != 0);
  if (!bssl::SSL_SESSION_parse_u16(&v66[1], (_WORD *)(v20 + 6), -1610612718))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 669);
    goto LABEL_13;
  }
  *(_QWORD *)&v59 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v59 + 1) = 0xAAAAAAAAAAAAAAAALL;
  CBS_init(&v59, 0, 0);
  v57 = -1431655766;
  if (!CBS_get_optional_asn1(&v66[1], &v59, &v57, -1610612717))
    goto LABEL_67;
  v21 = v57;
  if (!v57)
  {
    v22 = v61[0];
    goto LABEL_69;
  }
  if (!CBS_len((uint64_t)&v59))
  {
LABEL_67:
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 679);
    goto LABEL_13;
  }
  v21 = v57;
  v22 = v61[0];
  if (v57 && !v61[0])
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 683);
    goto LABEL_13;
  }
LABEL_69:
  if (!(v22 | v21))
    goto LABEL_81;
  v26 = v67;
  v27 = (unint64_t *)sk_new_null();
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)(v26 + 144), v27);
  if (!*(_QWORD *)(v67 + 144))
    goto LABEL_13;
  if (!v61[0])
    goto LABEL_75;
  v28 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v61[1], a3);
  v54 = v28;
  if (!v28)
  {
LABEL_110:
    *a4 = 0;
    v45 = &v54;
LABEL_114:
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](v45, 0);
    goto LABEL_14;
  }
  v29 = *(STACK **)(v67 + 144);
  v54 = 0;
  v56 = v28;
  if (!sk_push(v29, (char *)v28))
  {
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v56, 0);
    goto LABEL_110;
  }
  v56 = 0;
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v56, 0);
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v54, 0);
LABEL_75:
  while (CBS_len((uint64_t)&v59))
  {
    v54 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
    v55 = 0xAAAAAAAAAAAAAAAALL;
    if (!CBS_get_any_asn1_element(&v59, &v54, 0, 0) || !CBS_len((uint64_t)&v54))
    {
      ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 704);
      goto LABEL_13;
    }
    v49[1] = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
    v30 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v54, a3);
    v49[1] = v30;
    if (!v30)
      goto LABEL_113;
    v31 = *(STACK **)(v67 + 144);
    v49[1] = 0;
    v53 = v30;
    if (!sk_push(v31, (char *)v30))
    {
      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v53, 0);
LABEL_113:
      *a4 = 0;
      v45 = &v49[1];
      goto LABEL_114;
    }
    v53 = 0;
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v53, 0);
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v49[1], 0);
  }
LABEL_81:
  v54 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
  v55 = 0xAAAAAAAAAAAAAAAALL;
  v52 = -1431655766;
  if (!CBS_get_optional_asn1_octet_string(&v66[1], &v54, &v52, -1610612715)
    || v52 && !CBS_get_u32((uint64_t *)&v54, (int *)(v67 + 384))
    || CBS_len((uint64_t)&v54))
  {
    goto LABEL_13;
  }
  *(_BYTE *)(v67 + 448) = *(_BYTE *)(v67 + 448) & 0xF7 | (8 * (v52 != 0));
  v51 = -1431655766;
  if (!CBS_get_optional_asn1_BOOL(&v66[1], &v51, -1610612714, 1))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 730);
    goto LABEL_13;
  }
  v32 = v67;
  *(_BYTE *)(v67 + 448) = *(_BYTE *)(v67 + 448) & 0xEF | (16 * (v51 != 0));
  v50 = -1431655766;
  if (!bssl::SSL_SESSION_parse_u16(&v66[1], (_WORD *)(v32 + 8), -1610612713)
    || !bssl::SSL_SESSION_parse_u32(&v66[1], (_DWORD *)(v67 + 388), -1610612712, 0)
    || !bssl::SSL_SESSION_parse_u32(&v66[1], (_DWORD *)(v67 + 196), -1610612711, *(_DWORD *)(v67 + 192))
    || !bssl::SSL_SESSION_parse_octet_string(&v66[1], (void **)(v67 + 400), -1610612710)
    || !CBS_get_optional_asn1_BOOL(&v66[1], &v50, -1610612709, 0)
    || (bssl::SSL_SESSION_parse_octet_string(&v66[1], (void **)(v67 + 456), -1610612708) & 1) == 0)
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 751);
    goto LABEL_13;
  }
  memset(v49, 170, sizeof(v49));
  if (!CBS_get_optional_asn1_octet_string(&v66[1], &v49[1], (_DWORD *)v49 + 1, -1610612707))
    goto LABEL_105;
  v33 = v49[1];
  v34 = v49[2];
  v35 = (void **)(v67 + 416);
  v36 = bssl::Array<unsigned char>::Init(v67 + 416, (unint64_t)v49[2]);
  v37 = v36 ^ 1;
  if (!v34)
    v37 = 1;
  if ((v37 & 1) == 0)
    memcpy(*v35, v33, (size_t)v34);
  if (!v36 || !CBS_get_optional_asn1_octet_string(&v66[1], &v49[1], v49, -1610612706))
    goto LABEL_105;
  v38 = v49[1];
  v39 = v49[2];
  v40 = (void **)(v67 + 432);
  v41 = bssl::Array<unsigned char>::Init(v67 + 432, (unint64_t)v49[2]);
  v42 = v41 ^ 1;
  if (!v39)
    v42 = 1;
  if ((v42 & 1) == 0)
    memcpy(*v40, v38, (size_t)v39);
  if (!v41 || CBS_len((uint64_t)&v66[1]))
  {
LABEL_105:
    v43 = 764;
    goto LABEL_106;
  }
  v46 = v67;
  v47 = *(_BYTE *)(v67 + 448) & 0xDF | (32 * (v50 != 0));
  *(_BYTE *)(v67 + 448) = v47;
  v48 = BYTE4(v49[0]);
  if (HIDWORD(v49[0]) != LODWORD(v49[0]))
    goto LABEL_122;
  if (HIDWORD(v49[0]))
  {
    if (*(_QWORD *)(v46 + 408))
    {
      v48 = 64;
      goto LABEL_120;
    }
LABEL_122:
    v43 = 772;
    goto LABEL_106;
  }
LABEL_120:
  *(_BYTE *)(v46 + 448) = v48 | v47 & 0x3F;
  if ((a2[6]() & 1) != 0)
  {
    v44 = v67;
    v67 = 0;
    goto LABEL_107;
  }
  v43 = 781;
LABEL_106:
  ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", v43);
  v44 = 0;
LABEL_107:
  *a4 = v44;
LABEL_14:
  v8 = (SSL_SESSION *)v67;
  v67 = 0;
  if (v8)
    SSL_SESSION_free(v8);
}

void sub_1B4FA68E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)(v1 - 72), 0);
  _Unwind_Resume(a1);
}

uint64_t CBS_get_asn1_uint64(__int128 *a1, unint64_t *a2)
{
  uint64_t result;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unsigned __int8 *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned __int8 *v11;
  unint64_t v12;

  v11 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  v12 = 0xAAAAAAAAAAAAAAAALL;
  result = cbs_get_asn1(a1, &v11, 2, 1);
  if ((_DWORD)result)
  {
    result = CBS_is_unsigned_asn1_integer(&v11);
    if ((_DWORD)result)
    {
      *a2 = 0;
      v4 = v12;
      if (v12)
      {
        v5 = 0;
        v6 = 0;
        v7 = v11;
        v8 = v12 - 1;
        do
        {
          *a2 = v6 << 8;
          v9 = v7[v5] | (v6 << 8);
          *a2 = v9;
          v10 = v5 + 1;
          if (v8 == v5)
            break;
          ++v5;
          v6 = v9;
        }
        while (!HIBYTE(v9));
        return v10 >= v4;
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

BOOL CBS_is_unsigned_asn1_integer(unsigned __int8 **a1)
{
  unsigned __int8 *v1;
  unsigned int v2;
  int v3;
  _BOOL4 v4;
  int v5;

  v1 = a1[1];
  if (v1)
  {
    v2 = **a1;
    v3 = v2 >> 7;
    if (v1 == (unsigned __int8 *)1)
    {
      v4 = 1;
    }
    else
    {
      v5 = (char)(*a1)[1];
      v4 = (**a1 || v5 < 0) && (v2 != 255 || v5 >= 0);
    }
  }
  else
  {
    v4 = 0;
    v3 = -1431655766;
  }
  return !v3 && v4;
}

uint64_t bssl::SSL_SESSION_parse_octet_string(__int128 *a1, void **a2, int a3)
{
  const void *v4;
  size_t v5;
  uint64_t result;
  BOOL v7;
  unint64_t v8;
  size_t v9;

  v8 = 0xAAAAAAAAAAAAAAAALL;
  v9 = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_optional_asn1_octet_string(a1, &v8, 0, a3))
  {
    v4 = (const void *)v8;
    v5 = v9;
    result = bssl::Array<unsigned char>::Init((uint64_t)a2, v9);
    if (v5)
      v7 = (_DWORD)result == 0;
    else
      v7 = 1;
    if (!v7)
    {
      memcpy(*a2, v4, v5);
      return 1;
    }
  }
  else
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 448);
    return 0;
  }
  return result;
}

uint64_t CBS_get_optional_asn1_octet_string(__int128 *a1, _QWORD *a2, _DWORD *a3, int a4)
{
  uint64_t result;
  int asn1;
  int v8[5];

  memset(v8, 170, sizeof(v8));
  result = CBS_get_optional_asn1(a1, &v8[1], v8, a4);
  if ((_DWORD)result)
  {
    if (!v8[0])
    {
      *a2 = 0;
      a2[1] = 0;
      if (!a3)
        return 1;
      goto LABEL_7;
    }
    if (!a2)
      CBS_get_optional_asn1_octet_string_cold_1();
    asn1 = cbs_get_asn1((__int128 *)&v8[1], a2, 4, 1);
    result = 0;
    if (asn1 && !*(_QWORD *)&v8[3])
    {
      if (!a3)
        return 1;
LABEL_7:
      *a3 = v8[0];
      return 1;
    }
  }
  return result;
}

uint64_t bssl::SSL_SESSION_parse_u32(__int128 *a1, _DWORD *a2, int a3, unsigned int a4)
{
  BOOL v5;
  unint64_t v7;

  v7 = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_optional_asn1_uint64(a1, &v7, a3, a4))
    v5 = HIDWORD(v7) == 0;
  else
    v5 = 0;
  if (v5)
  {
    *a2 = v7;
    return 1;
  }
  else
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 512);
    return 0;
  }
}

uint64_t CBS_get_optional_asn1_uint64(__int128 *a1, unint64_t *a2, int a3, unint64_t a4)
{
  uint64_t result;
  int asn1_uint64;
  int v8[5];

  memset(v8, 170, sizeof(v8));
  result = CBS_get_optional_asn1(a1, &v8[1], v8, a3);
  if ((_DWORD)result)
  {
    if (v8[0])
    {
      asn1_uint64 = CBS_get_asn1_uint64((__int128 *)&v8[1], a2);
      result = 0;
      if (!asn1_uint64 || *(_QWORD *)&v8[3])
        return result;
    }
    else
    {
      *a2 = a4;
    }
    return 1;
  }
  return result;
}

uint64_t CBS_get_optional_asn1_BOOL(__int128 *a1, int *a2, int a3, int a4)
{
  uint64_t result;
  int asn1;
  int v8;
  __int128 v9[2];

  memset(v9, 170, sizeof(v9));
  v8 = -1431655766;
  result = CBS_get_optional_asn1(a1, &v9[1], &v8, a3);
  if ((_DWORD)result)
  {
    if (!v8)
    {
LABEL_9:
      *a2 = a4;
      return 1;
    }
    asn1 = cbs_get_asn1(&v9[1], v9, 1, 1);
    result = 0;
    if (asn1 && *((_QWORD *)&v9[0] + 1) == 1 && !*((_QWORD *)&v9[1] + 1))
    {
      a4 = **(_BYTE **)&v9[0];
      if (**(_BYTE **)&v9[0])
      {
        if (a4 != 255)
          return 0;
        a4 = 1;
      }
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t bssl::SSL_SESSION_parse_bounded_octet_string(__int128 *a1, void *a2, _BYTE *a3, unsigned int a4, int a5)
{
  const void *v9;
  size_t v10;
  _QWORD v11[2];

  v11[0] = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_optional_asn1_octet_string(a1, v11, 0, a5)
    && CBS_len((uint64_t)v11) <= (unint64_t)a4)
  {
    v9 = (const void *)CBS_data((uint64_t)v11);
    v10 = CBS_len((uint64_t)v11);
    if (v10)
      memcpy(a2, v9, v10);
    *a3 = CBS_len((uint64_t)v11);
    return 1;
  }
  else
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 485);
    return 0;
  }
}

BOOL bssl::SSL_SESSION_parse_crypto_buffer(__int128 *a1, unsigned int **a2, int a3, _QWORD **a4)
{
  unsigned int *v9;
  __int128 v10[2];

  if (!CBS_peek_asn1_tag(a1, a3))
    return 1;
  memset(v10, 170, sizeof(v10));
  if (CBS_get_asn1(a1, &v10[1], a3)
    && CBS_get_asn1(&v10[1], v10, 4)
    && !CBS_len((uint64_t)&v10[1]))
  {
    v9 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)v10, a4);
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](a2, v9);
    return *a2 != 0;
  }
  else
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 466);
    return 0;
  }
}

uint64_t bssl::SSL_SESSION_parse_u16(__int128 *a1, _WORD *a2, int a3)
{
  unint64_t v5;

  v5 = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_optional_asn1_uint64(a1, &v5, a3, 0) && v5 < 0x10000)
  {
    *a2 = v5;
    return 1;
  }
  else
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 525);
    return 0;
  }
}

uint64_t CBS_get_any_asn1_element(__int128 *a1, _QWORD *a2, _DWORD *a3, unint64_t *a4)
{
  return cbs_get_any_asn1_element(a1, a2, a3, a4, 0, 0, 0);
}

_QWORD *bssl::ssl_session_new@<X0>(void *a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;
  void *v4;

  v4 = a1;
  result = bssl::New<ssl_session_st,bssl::SSL_X509_METHOD const*&>(&v4);
  *a2 = result;
  return result;
}

BOOL bssl::SSL_SESSION_parse_string(__int128 *a1, _QWORD **a2)
{
  int v3;
  _BOOL8 result;
  _QWORD **v5;
  _QWORD *v6;
  _QWORD *v7;
  _DWORD v8[5];

  memset(v8, 170, sizeof(v8));
  if (!CBS_get_optional_asn1_octet_string(a1, &v8[1], v8, -1610612728))
  {
    v3 = 422;
    goto LABEL_6;
  }
  if (!v8[0])
  {
    v5 = a2;
    v6 = 0;
LABEL_10:
    std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100](v5, v6);
    return 1;
  }
  if (CBS_contains_zero_byte((uint64_t)&v8[1]))
  {
    v3 = 427;
LABEL_6:
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", v3);
    return 0;
  }
  v7 = 0;
  result = CBS_strdup((uint64_t)&v8[1], &v7);
  if (result)
  {
    v6 = v7;
    v5 = a2;
    goto LABEL_10;
  }
  return result;
}

uint64_t bssl::SSL_SESSION_parse_long(__int128 *a1, _QWORD *a2)
{
  unint64_t v4;

  v4 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_optional_asn1_uint64(a1, &v4, -1610612731, 0) || (v4 & 0x8000000000000000) != 0)
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 499);
    return 0;
  }
  else
  {
    *a2 = v4;
    return 1;
  }
}

int RSA_verify(int type, const unsigned __int8 *m, unsigned int m_length, unsigned __int8 *sigbuf, unsigned int siglen, RSA *rsa)
{
  uint64_t v7;
  size_t v9;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  int v20;
  size_t v21;
  size_t v22;
  void *__s2;

  if (!rsa)
  {
    v12 = 67;
    v13 = 373;
    goto LABEL_11;
  }
  v7 = *(_QWORD *)&siglen;
  v9 = *(_QWORD *)&m_length;
  if (BN_num_bytes((const BIGNUM *)rsa->version) >= 0x401)
  {
    v12 = 500;
    v13 = 377;
LABEL_11:
    ERR_put_error(4, 0, v12, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v13);
    return 0;
  }
  v14 = BN_num_bytes((const BIGNUM *)rsa->version);
  v22 = 0xAAAAAAAAAAAAAAAALL;
  __s2 = 0;
  v21 = 0xAAAAAAAAAAAAAAAALL;
  v20 = 0;
  if (!rsa->version || !rsa->meth)
  {
    v12 = 144;
    v13 = 386;
    goto LABEL_11;
  }
  if (type == 114 && v9 != 36)
  {
    v12 = 125;
    v13 = 391;
    goto LABEL_11;
  }
  v17 = (unsigned __int8 *)malloc_type_malloc(v14, 0x212454D0uLL);
  if (!v17)
  {
    v12 = 65;
    v13 = 397;
    goto LABEL_11;
  }
  v19 = v17;
  if (RSA_verify_raw((uint64_t)rsa, &v21, v17, v18, (uint64_t)sigbuf, v7, 1)
    && RSA_add_pkcs1_prefix(&__s2, &v22, &v20, type, m, v9))
  {
    if (v21 == v22 && !memcmp(v19, __s2, v21))
    {
      v15 = 1;
      goto LABEL_20;
    }
    ERR_put_error(4, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", 410);
  }
  v15 = 0;
LABEL_20:
  free(v19);
  if (v20 && __s2)
    free(__s2);
  return v15;
}

uint64_t bssl::`anonymous namespace'::ECKeyShare::Finish(uint64_t a1, uint64_t a2, _BYTE *a3, const unsigned __int8 *a4, size_t a5)
{
  EC_POINT *v10;
  EC_POINT *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  int degree;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v19;
  unint64_t v20;
  BIGNUM *v21;
  EC_POINT *v22;
  EC_POINT *v23;

  if (!*(_QWORD *)(a1 + 16))
  if (!*(_QWORD *)(a1 + 8))
  *a3 = 80;
  v10 = EC_POINT_new(*(const EC_GROUP **)(a1 + 16));
  v23 = v10;
  v11 = EC_POINT_new(*(const EC_GROUP **)(a1 + 16));
  v22 = v11;
  v12 = BN_new();
  v13 = v12;
  v21 = v12;
  if (v10 && v11 && v12)
  {
    if (a5 && *a4 == 4 && EC_POINT_oct2point(*(const EC_GROUP **)(a1 + 16), v10, a4, a5, 0))
    {
      if (EC_POINT_mul(*(const EC_GROUP **)(a1 + 16), v11, 0, v10, *(const BIGNUM **)(a1 + 8), 0)
        && EC_POINT_get_affine_coordinates_GFp(*(const EC_GROUP **)(a1 + 16), v11, v13, 0, 0))
      {
        v19 = 0;
        v20 = 0;
        degree = EC_GROUP_get_degree(*(const EC_GROUP **)(a1 + 16));
        if (bssl::Array<unsigned char>::Init((uint64_t)&v19, (degree + 7) >> 3)
          && BN_bn2bin_padded(v19, v20, (uint64_t)v13))
        {
          OPENSSL_free(*(_QWORD **)a2);
          v15 = v20;
          *(_QWORD *)a2 = v19;
          *(_QWORD *)(a2 + 8) = v15;
          v19 = 0;
          v20 = 0;
          v16 = 1;
        }
        else
        {
          v16 = 0;
        }
        bssl::Array<unsigned char>::~Array((uint64_t)&v19);
      }
      else
      {
        v16 = 0;
      }
    }
    else
    {
      ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_key_share.cc", 85);
      v16 = 0;
      *a3 = 50;
    }
    v21 = 0;
    goto LABEL_18;
  }
  v16 = 0;
  v17 = 0;
  v21 = 0;
  if (v12)
  {
LABEL_18:
    BN_free(v13);
    v17 = v16;
  }
  v22 = 0;
  if (v11)
    EC_POINT_free(v11);
  v23 = 0;
  if (v10)
    EC_POINT_free(v10);
  return v17;
}

void sub_1B4FA74C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  BIGNUM *v6;
  va_list va1;
  EC_POINT *v8;
  va_list va2;
  va_list va3;

  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v6 = va_arg(va2, BIGNUM *);
  va_copy(va3, va2);
  v8 = va_arg(va3, EC_POINT *);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100]((BIGNUM **)va1, 0);
  std::unique_ptr<ec_point_st,bssl::internal::Deleter>::reset[abi:ne180100]((EC_POINT **)va2, 0);
  std::unique_ptr<ec_point_st,bssl::internal::Deleter>::reset[abi:ne180100]((EC_POINT **)va3, 0);
  _Unwind_Resume(a1);
}

uint64_t ec_point_mul_no_self_test(const EC_GROUP *a1, uint64_t a2, BN_CTX *a3, const EC_GROUP **a4, const BIGNUM *a5, BN_CTX *a6)
{
  int v7;
  int v8;
  BN_CTX *v15;
  uint64_t v16;
  BN_CTX *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  unint64_t v40;
  _OWORD v41[4];
  unint64_t v42;

  if ((a4 != 0) != (a5 == 0) && ((unint64_t)a3 | (unint64_t)a5) != 0)
  {
    if (EC_GROUP_cmp(a1, *(const EC_GROUP **)a2, a3) || a4 && EC_GROUP_cmp(a1, *a4, v15))
    {
      v7 = 106;
      v8 = 958;
      goto LABEL_8;
    }
    if (a6)
    {
      v18 = 0;
    }
    else
    {
      a6 = BN_CTX_new();
      v18 = a6;
      if (!a6)
        goto LABEL_23;
    }
    if (!a3
      || (*(_QWORD *)&v31 = 0xAAAAAAAAAAAAAAAALL,
          *(_QWORD *)&v19 = 0xAAAAAAAAAAAAAAAALL,
          *((_QWORD *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL,
          v29 = v19,
          v30 = v19,
          v27 = v19,
          v28 = v19,
          arbitrary_bignum_to_scalar((uint64_t)a1, &v27, (const BIGNUM *)a3, a6))
      && ec_point_mul_scalar_base(a1, a2 + 8, (uint64_t)&v27))
    {
      if (!a5)
      {
LABEL_25:
        v16 = 1;
        goto LABEL_26;
      }
      v42 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v41[2] = v20;
      v41[3] = v20;
      v41[0] = v20;
      v41[1] = v20;
      v40 = 0xAAAAAAAAAAAAAAAALL;
      v38 = v20;
      v39 = v20;
      v36 = v20;
      v37 = v20;
      v34 = v20;
      v35 = v20;
      v32 = v20;
      v33 = v20;
      v30 = v20;
      v31 = v20;
      v28 = v20;
      v29 = v20;
      v27 = v20;
      if (arbitrary_bignum_to_scalar((uint64_t)a1, v41, a5, a6)
        && ec_point_mul_scalar(a1, (uint64_t)&v27, (uint64_t)(a4 + 1), (uint64_t)v41))
      {
        if (a3)
        {
          (*(void (**)(const EC_GROUP *, uint64_t, uint64_t, __int128 *))(*(_QWORD *)a1 + 40))(a1, a2 + 8, a2 + 8, &v27);
        }
        else
        {
          v21 = v38;
          *(_OWORD *)(a2 + 168) = v37;
          *(_OWORD *)(a2 + 184) = v21;
          *(_OWORD *)(a2 + 200) = v39;
          v22 = v34;
          *(_OWORD *)(a2 + 104) = v33;
          *(_OWORD *)(a2 + 120) = v22;
          v23 = v36;
          *(_OWORD *)(a2 + 136) = v35;
          *(_OWORD *)(a2 + 152) = v23;
          v24 = v30;
          *(_OWORD *)(a2 + 40) = v29;
          *(_OWORD *)(a2 + 56) = v24;
          v25 = v32;
          *(_OWORD *)(a2 + 72) = v31;
          *(_OWORD *)(a2 + 88) = v25;
          v26 = v28;
          *(_OWORD *)(a2 + 8) = v27;
          *(_QWORD *)(a2 + 216) = v40;
          *(_OWORD *)(a2 + 24) = v26;
        }
        goto LABEL_25;
      }
    }
LABEL_23:
    v16 = 0;
LABEL_26:
    BN_CTX_free(v18);
    return v16;
  }
  v7 = 67;
  v8 = 952;
LABEL_8:
  ERR_put_error(15, 0, v7, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", v8);
  return 0;
}

BN_CTX *BN_CTX_new(void)
{
  BN_CTX *result;

  result = (BN_CTX *)OPENSSL_malloc(0x30uLL);
  if (result)
  {
    *(_OWORD *)((char *)result + 26) = 0u;
    *(_OWORD *)result = 0u;
    *((_OWORD *)result + 1) = 0u;
  }
  return result;
}

uint64_t arbitrary_bignum_to_scalar(uint64_t a1, void *a2, const BIGNUM *a3, BN_CTX *a4)
{
  _BOOL8 v8;
  BIGNUM *v9;
  uint64_t v10;

  if (ec_bignum_to_scalar(a1, a2, (uint64_t)a3))
    return 1;
  ERR_clear_error();
  BN_CTX_start(a4);
  v9 = BN_CTX_get(a4);
  v8 = v9
    && (v10 = (uint64_t)v9, BN_nnmod(v9, a3, (const BIGNUM *)(a1 + 16), a4))
    && ec_bignum_to_scalar(a1, a2, v10) != 0;
  BN_CTX_end(a4);
  return v8;
}

uint64_t ec_bignum_to_scalar(uint64_t a1, void *__dst, uint64_t a3)
{
  if (bn_copy_words(__dst, *(int *)(a1 + 24), a3)
    && bn_less_than_words((uint64_t *)__dst, *(uint64_t **)(a1 + 16), *(int *)(a1 + 24)))
  {
    return 1;
  }
  ERR_put_error(15, 0, 133, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/scalar.c", 28);
  return 0;
}

uint64_t bn_copy_words(void *__dst, unint64_t a2, uint64_t a3)
{
  int v3;
  int v4;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  size_t v13;

  if (*(_DWORD *)(a3 + 16))
  {
    v3 = 109;
    v4 = 317;
LABEL_3:
    ERR_put_error(3, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/bn.c", v4);
    return 0;
  }
  v8 = *(int *)(a3 + 8);
  v9 = v8 - a2;
  if (v8 > a2)
  {
    v10 = 0;
    v11 = (uint64_t *)(*(_QWORD *)a3 + 8 * a2);
    do
    {
      v12 = *v11++;
      v10 |= v12;
      --v9;
    }
    while (v9);
    v8 = a2;
    if (v10)
    {
      v3 = 102;
      v4 = 324;
      goto LABEL_3;
    }
  }
  v13 = 8 * a2;
  if (v13)
    bzero(__dst, v13);
  if (8 * v8)
    memcpy(__dst, *(const void **)a3, 8 * v8);
  return 1;
}

uint64_t bssl::ssl_check_leaf_certificate(uint64_t a1, ssl_st *a2)
{
  const evp_pkey_st *v4;
  int v5;
  const EC_KEY *v6;
  const EC_GROUP *v7;
  unsigned __int16 *curve_name;
  int v10;
  int v11;
  bssl::SSL_HANDSHAKE *v12;

  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) >= 0x304)
    bssl::ssl_check_leaf_certificate();
  v5 = *(_DWORD *)(*(_QWORD *)(a1 + 1568) + 24);
  if ((bssl::ssl_cipher_auth_mask_for_key((bssl *)a2, v4) & v5) != 0)
  {
    if (EVP_PKEY_id((uint64_t)a2) != 408)
      return 1;
    v6 = (const EC_KEY *)EVP_PKEY_get0_EC_KEY((uint64_t)a2);
    LOWORD(v12) = -21846;
    v7 = EC_KEY_get0_group(v6);
    curve_name = (unsigned __int16 *)EC_GROUP_get_curve_name(v7);
    if (bssl::ssl_nid_to_group_id((bssl *)&v12, curve_name)
      && bssl::tls1_check_group_id((bssl **)a1, (const ssl_st *)(unsigned __int16)v12)
      && EC_KEY_get_conv_form(v6) == POINT_CONVERSION_UNCOMPRESSED)
    {
      return 1;
    }
    v10 = 107;
    v11 = 728;
  }
  else
  {
    v10 = 241;
    v11 = 716;
  }
  ERR_put_error(16, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", v11);
  return 0;
}

BOOL bssl::tls1_check_group_id(bssl **this, const ssl_st *a2)
{
  int v2;
  unsigned int v4;
  _BOOL8 result;
  bssl *v6;
  uint64_t v7;
  __int16 *v8;
  uint64_t v9;
  int v10;
  BOOL v11;

  v2 = (int)a2;
  if (((_DWORD)a2 - 65073) >= 2)
  {
    if (!(_DWORD)a2)
      return 0;
    if ((_DWORD)a2 != 16696)
      goto LABEL_6;
  }
  v4 = bssl::ssl_protocol_version(*this, a2);
  result = 0;
  if (v2)
  {
    if (v4 >= 0x304)
    {
LABEL_6:
      v6 = this[1];
      v7 = *((_QWORD *)v6 + 14);
      if (v7)
      {
        v8 = (__int16 *)*((_QWORD *)v6 + 13);
      }
      else
      {
        v8 = &bssl::kDefaultGroups;
        v7 = 4;
      }
      v9 = 2 * v7 - 2;
      do
      {
        v10 = (unsigned __int16)*v8++;
        result = v10 == v2;
        v11 = v10 == v2 || v9 == 0;
        v9 -= 2;
      }
      while (!v11);
    }
  }
  return result;
}

uint64_t bssl::ssl_cipher_auth_mask_for_key(bssl *this, const evp_pkey_st *a2)
{
  int v2;

  v2 = EVP_PKEY_id((uint64_t)this);
  if (v2 == 6)
    return 1;
  if (v2 == 949 || v2 == 408)
    return 2;
  return 0;
}

BOOL bssl::ssl_public_key_verify(bssl *a1, uint64_t a2, uint64_t a3, evp_pkey_st *a4, const ssl_st *a5, const void *a6, size_t a7)
{
  __int128 v14;
  _BOOL8 v15;
  EVP_MD_CTX v17;

  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v17.digest = v14;
  *(_OWORD *)&v17.flags = v14;
  EVP_MD_CTX_init(&v17);
  v15 = (bssl::setup_ctx(a1, (ssl_st *)&v17, a5, a4, 1) & 1) != 0
     && EVP_DigestVerify((uint64_t)&v17, a2, a3, a6, a7) != 0;
  EVP_MD_CTX_cleanup(&v17);
  return v15;
}

void sub_1B4FA7BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  EVP_MD_CTX_cleanup((EVP_MD_CTX *)&a9);
  _Unwind_Resume(a1);
}

uint64_t bssl::setup_ctx(bssl *this, ssl_st *a2, const ssl_st *a3, evp_pkey_st *a4, int a5)
{
  int v6;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  __int16 *v12;
  int v13;
  const EVP_MD *v14;
  uint64_t *v15;

  v6 = (int)a4;
  if (!bssl::pkey_supports_algorithm(this, a3, a4))
  {
    ERR_put_error(16, 0, 245, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_privkey.cc", 189);
    return 0;
  }
  if (v6 == 65281)
  {
    v9 = 0;
  }
  else
  {
    v11 = 0;
    v12 = &word_1E686D6B0;
    do
    {
      v13 = (unsigned __int16)*v12;
      v12 += 16;
      --v11;
    }
    while (v13 != v6);
    if (v11 == -12)
    {
      v14 = 0;
      v9 = 12;
      goto LABEL_11;
    }
    v9 = -v11;
  }
  v14 = (const EVP_MD *)(*((uint64_t (**)(void))&bssl::kSignatureAlgorithms + 4 * v9 + 2))();
LABEL_11:
  v15 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  if (a5)
  {
    result = EVP_DigestVerifyInit((uint64_t)a2, &v15, v14, 0, (uint64_t)a3);
    if (!(_DWORD)result)
      return result;
  }
  else
  {
    result = EVP_DigestSignInit((uint64_t)a2, &v15, v14, 0, (uint64_t)a3);
    if (!(_DWORD)result)
      return result;
  }
  if ((unint64_t)(v9 - 8) < 0xFFFFFFFFFFFFFFFDLL)
    return 1;
  result = EVP_PKEY_CTX_set_rsa_padding(v15);
  if ((_DWORD)result)
  {
    result = EVP_PKEY_CTX_set_rsa_pss_saltlen(v15);
    if ((_DWORD)result)
      return 1;
  }
  return result;
}

uint64_t EVP_PKEY_CTX_ctrl(uint64_t *a1, int a2, int a3)
{
  uint64_t v3;
  uint64_t (*v4)(void);
  int v5;
  int v6;
  int v7;

  if (!a1 || (v3 = *a1) == 0 || (v4 = *(uint64_t (**)(void))(v3 + 112)) == 0)
  {
    v6 = 101;
    v7 = 195;
    goto LABEL_11;
  }
  if (a2 != -1 && *(_DWORD *)v3 != a2)
  {
    v6 = 125;
    v7 = 199;
    goto LABEL_11;
  }
  v5 = *((_DWORD *)a1 + 8);
  if (!v5)
  {
    v6 = 123;
    v7 = 204;
    goto LABEL_11;
  }
  if (a3 != -1 && (v5 & a3) == 0)
  {
    v6 = 114;
    v7 = 209;
LABEL_11:
    ERR_put_error(6, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", v7);
    return 0;
  }
  return v4();
}

uint64_t pkey_rsa_ctrl(uint64_t a1, int a2, int a3, _QWORD *a4)
{
  uint64_t v5;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = *(_QWORD *)(a1 + 40);
  switch(a2)
  {
    case 4097:
      if (a3 > 6 || ((1 << a3) & 0x5A) == 0)
        goto LABEL_21;
      v11 = *(_QWORD *)(v5 + 24);
      if (a3 == 3 && v11)
      {
        ERR_put_error(6, 0, 115, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa.c", 377);
LABEL_21:
        v8 = 109;
        v9 = 405;
        goto LABEL_45;
      }
      if (a3 == 4)
      {
        if ((*(_BYTE *)(a1 + 32) & 0xC0) == 0)
          goto LABEL_21;
      }
      else
      {
        if (a3 != 6)
          goto LABEL_54;
        if ((*(_BYTE *)(a1 + 32) & 0x18) == 0)
          goto LABEL_21;
      }
      if (!v11)
        *(_QWORD *)(v5 + 24) = EVP_sha1();
LABEL_54:
      *(_DWORD *)(v5 + 16) = a3;
      return 1;
    case 4098:
      v7 = *(_DWORD *)(v5 + 16);
      goto LABEL_23;
    case 4099:
    case 4100:
      if (*(_DWORD *)(v5 + 16) != 6)
      {
        v8 = 116;
        v9 = 422;
        goto LABEL_45;
      }
      if (a2 == 4100)
      {
        v7 = *(_DWORD *)(v5 + 40);
LABEL_23:
        *(_DWORD *)a4 = v7;
      }
      else
      {
        if (a3 < -2)
          return 0;
        *(_DWORD *)(v5 + 40) = a3;
      }
      return 1;
    case 4101:
      if (a3 <= 255)
      {
        v8 = 112;
        v9 = 437;
        goto LABEL_45;
      }
      *(_DWORD *)v5 = a3;
      return 1;
    case 4102:
      if (!a4)
        return 0;
      BN_free(*(BIGNUM **)(v5 + 8));
      *(_QWORD *)(v5 + 8) = a4;
      return 1;
    case 4103:
    case 4104:
      if (*(_DWORD *)(v5 + 16) != 4)
      {
        v8 = 115;
        v9 = 454;
        goto LABEL_45;
      }
      if (a2 == 4104)
        goto LABEL_14;
      goto LABEL_37;
    case 4105:
    case 4106:
      if ((*(_DWORD *)(v5 + 16) | 2) != 6)
      {
        v8 = 113;
        v9 = 479;
        goto LABEL_45;
      }
      if (a2 != 4106)
      {
        *(_QWORD *)(v5 + 32) = a4;
        return 1;
      }
      v10 = *(_QWORD *)(v5 + 32);
      if (v10)
        goto LABEL_15;
      goto LABEL_14;
    case 4107:
      if (*(_DWORD *)(v5 + 16) == 4)
      {
        OPENSSL_free(*(_QWORD **)(v5 + 56));
        v12 = a4[1];
        *(_QWORD *)(v5 + 56) = *a4;
        *(_QWORD *)(v5 + 64) = v12;
        return 1;
      }
      v8 = 115;
      v9 = 495;
      goto LABEL_45;
    case 4108:
      if (*(_DWORD *)(v5 + 16) == 4)
      {
        CBS_init(a4, *(_QWORD *)(v5 + 56), *(_QWORD *)(v5 + 64));
        return 1;
      }
      v8 = 115;
      v9 = 507;
      goto LABEL_45;
    default:
      if (a2 == 1)
      {
        if (!a4 || *(_DWORD *)(v5 + 16) != 3)
        {
LABEL_37:
          *(_QWORD *)(v5 + 24) = a4;
          return 1;
        }
        v8 = 115;
        v9 = 377;
        goto LABEL_45;
      }
      if (a2 != 2)
      {
        v8 = 101;
        v9 = 514;
LABEL_45:
        ERR_put_error(6, 0, v8, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa.c", v9);
        return 0;
      }
LABEL_14:
      v10 = *(_QWORD *)(v5 + 24);
LABEL_15:
      *a4 = v10;
      return 1;
  }
}

uint64_t do_sigver_init(uint64_t a1, _QWORD *a2, const EVP_MD *a3, ENGINE *a4, uint64_t a5, int a6)
{
  uint64_t result;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  if (!*(_QWORD *)(a1 + 16))
  {
    result = (uint64_t)EVP_PKEY_CTX_new(a5, (uint64_t)a4);
    *(_QWORD *)(a1 + 16) = result;
    if (!result)
      return result;
  }
  CRYPTO_once(&md_pctx_ops_once, md_pctx_ops_init);
  *(_QWORD *)(a1 + 24) = &md_pctx_ops_storage;
  v12 = *(uint64_t **)(a1 + 16);
  if (a6 == 1)
  {
    result = EVP_PKEY_verify_init(v12);
    if (!(_DWORD)result)
      return result;
  }
  else
  {
    result = EVP_PKEY_sign_init(v12);
    if (!(_DWORD)result)
      return result;
  }
  if (!a3)
  {
    v14 = 56;
    if (!a6)
      v14 = 40;
    if (*(_QWORD *)(**(_QWORD **)(a1 + 16) + v14))
    {
      ERR_put_error(6, 0, 119, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/digestsign/digestsign.c", 109);
      return 0;
    }
    goto LABEL_18;
  }
  result = EVP_PKEY_CTX_set_signature_md(*(uint64_t **)(a1 + 16));
  if ((_DWORD)result)
  {
    v13 = 56;
    if (!a6)
      v13 = 40;
    if (!*(_QWORD *)(**(_QWORD **)(a1 + 16) + v13)
      || (result = EVP_DigestInit_ex((EVP_MD_CTX *)a1, a3, a4), (_DWORD)result))
    {
LABEL_18:
      if (a2)
        *a2 = *(_QWORD *)(a1 + 16);
      return 1;
    }
  }
  return result;
}

_QWORD *evp_pkey_ctx_new(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  int (*v8)(_QWORD *);

  v6 = OPENSSL_malloc(0x30uLL);
  v7 = v6;
  if (v6)
  {
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *(_OWORD *)v6 = 0u;
    *v6 = a3;
    v6[1] = a2;
    *((_DWORD *)v6 + 8) = 0;
    if (a1)
    {
      EVP_PKEY_up_ref(a1);
      v7[2] = a1;
    }
    v8 = *(int (**)(_QWORD *))(a3 + 8);
    if (v8 && v8(v7) <= 0)
    {
      EVP_PKEY_free((EVP_PKEY *)v7[2]);
      OPENSSL_free(v7);
      return 0;
    }
  }
  return v7;
}

BOOL bssl::pkey_supports_algorithm(bssl *this, const ssl_st *a2, evp_pkey_st *a3)
{
  int v3;
  uint64_t v6;
  int *i;
  int v9;
  const ssl_st *v10;
  int v11;
  const ssl_st *v12;
  const EC_KEY *v15;
  const EC_GROUP *v16;

  v3 = (int)a3;
  v6 = -13;
  for (i = &dword_1E686D698; *((unsigned __int16 *)i - 4) != (_DWORD)a3; i += 8)
  {
    if (__CFADD__(v6++, 1))
      return 0;
  }
  v9 = EVP_PKEY_id((uint64_t)a2);
  if (v9 != *(i - 1))
    return 0;
  v11 = v9;
  if (bssl::ssl_protocol_version(this, v10) > 0x302)
  {
    if (v3 != 65281)
    {
      if (bssl::ssl_protocol_version(this, v12) >= 0x304)
      {
        if (v11 == 408)
        {
          if ((unint64_t)(v6 + 1) < 0xFFFFFFFFFFFFFFFDLL)
            return 0;
          v15 = (const EC_KEY *)EVP_PKEY_get0_EC_KEY((uint64_t)a2);
          v16 = EC_KEY_get0_group(v15);
          if (EC_GROUP_get_curve_name(v16) != *i)
            return 0;
        }
        else if (v11 == 6 && (unint64_t)(v6 + 5) < 0xFFFFFFFFFFFFFFFDLL)
        {
          return 0;
        }
      }
      return 1;
    }
    return 0;
  }
  return v3 == 65281 || v3 == 515;
}

uint64_t EVP_PKEY_id(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t EVP_PKEY_verify_init(uint64_t *a1)
{
  uint64_t v1;

  if (a1 && (v1 = *a1) != 0 && (*(_QWORD *)(v1 + 56) || *(_QWORD *)(v1 + 64)))
  {
    *((_DWORD *)a1 + 8) = 16;
    return 1;
  }
  else
  {
    ERR_put_error(6, 0, 125, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", 243);
    return 0;
  }
}

_QWORD *EVP_PKEY_CTX_new(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (a1 && (v3 = *(_QWORD *)(a1 + 16)) != 0)
  {
    v4 = *(_QWORD *)(v3 + 16);
    if (v4)
      return evp_pkey_ctx_new((unsigned int *)a1, a2, v4);
    ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", 123);
    ERR_add_error_dataf("algorithm %d", v6, v7, v8, v9, v10, v11, v12, **(_DWORD **)(a1 + 16));
  }
  else
  {
    ERR_put_error(6, 0, 67, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", 117);
  }
  return 0;
}

_OWORD *EVP_PKEY_CTX_dup(uint64_t a1)
{
  _OWORD *v2;
  _OWORD *v3;
  unsigned int *v4;
  unsigned int *v5;

  if (!*(_QWORD *)a1 || !*(_QWORD *)(*(_QWORD *)a1 + 16))
    return 0;
  v2 = OPENSSL_malloc(0x30uLL);
  v3 = v2;
  if (v2)
  {
    v2[1] = 0u;
    v2[2] = 0u;
    *v2 = 0u;
    *v2 = *(_OWORD *)a1;
    *((_DWORD *)v2 + 8) = *(_DWORD *)(a1 + 32);
    v4 = *(unsigned int **)(a1 + 16);
    if (v4)
    {
      EVP_PKEY_up_ref(v4);
      *((_QWORD *)v3 + 2) = *(_QWORD *)(a1 + 16);
    }
    v5 = *(unsigned int **)(a1 + 24);
    if (v5)
    {
      EVP_PKEY_up_ref(v5);
      *((_QWORD *)v3 + 3) = *(_QWORD *)(a1 + 24);
    }
    if ((*(int (**)(_OWORD *, uint64_t))(*(_QWORD *)a1 + 16))(v3, a1) <= 0)
    {
      *(_QWORD *)v3 = 0;
      EVP_PKEY_CTX_free((EVP_PKEY **)v3);
      ERR_put_error(6, 0, 6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", 183);
      return 0;
    }
  }
  return v3;
}

uint64_t EVP_PKEY_up_ref(unsigned int *a1)
{
  CRYPTO_refcount_inc(a1);
  return 1;
}

uint64_t EVP_DigestVerifyInit(uint64_t a1, _QWORD *a2, const EVP_MD *a3, ENGINE *a4, uint64_t a5)
{
  return do_sigver_init(a1, a2, a3, a4, a5, 1);
}

uint64_t EVP_DigestVerify(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5)
{
  uint64_t v6;
  uint64_t (*v8)(void);

  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(*(_QWORD *)v6 + 56))
  {
    if (EVP_DigestVerifyUpdate(a1, a4, a5))
      return EVP_DigestVerifyFinal(a1);
  }
  else
  {
    v8 = *(uint64_t (**)(void))(*(_QWORD *)v6 + 64);
    if (v8)
      return v8();
    ERR_put_error(6, 0, 125, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/digestsign/digestsign.c", 255);
  }
  return 0;
}

uint64_t EVP_DigestVerifyUpdate(uint64_t a1, const void *a2, size_t a3)
{
  if (*(_QWORD *)(**(_QWORD **)(a1 + 16) + 56))
    return EVP_DigestUpdate((EVP_MD_CTX *)a1, a2, a3);
  ERR_put_error(6, 0, 125, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/digestsign/digestsign.c", 144);
  return 0;
}

BOOL EVP_DigestVerifyFinal(uint64_t a1)
{
  __int128 v2;
  _BOOL8 v3;
  unsigned int s;
  EVP_MD_CTX ctx;
  unsigned __int8 md[16];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(**(_QWORD **)(a1 + 16) + 56))
  {
    *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&ctx.digest = v2;
    *(_OWORD *)&ctx.flags = v2;
    v9 = v2;
    v10 = v2;
    *(_OWORD *)md = v2;
    v8 = v2;
    s = -1431655766;
    EVP_MD_CTX_init(&ctx);
    v3 = EVP_MD_CTX_copy_ex(&ctx, (const EVP_MD_CTX *)a1)
      && EVP_DigestFinal_ex(&ctx, md, &s)
      && EVP_PKEY_verify(*(_DWORD **)(a1 + 16)) != 0;
    EVP_MD_CTX_cleanup(&ctx);
  }
  else
  {
    ERR_put_error(6, 0, 125, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/digestsign/digestsign.c", 186);
    return 0;
  }
  return v3;
}

uint64_t EVP_PKEY_verify(_DWORD *a1)
{
  uint64_t (*v1)(void);
  int v3;
  int v4;

  if (a1 && *(_QWORD *)a1 && (v1 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 56)) != 0)
  {
    if (a1[8] == 16)
      return v1();
    v3 = 126;
    v4 = 257;
  }
  else
  {
    v3 = 125;
    v4 = 253;
  }
  ERR_put_error(6, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", v4);
  return 0;
}

uint64_t EVP_PKEY_CTX_set_signature_md(uint64_t *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, -1, 56);
}

uint64_t pkey_rsa_verify(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  RSA *v12;
  EVP_MD *v13;
  int v14;
  int v15;
  uint64_t result;
  int v17;
  BOOL v18;
  unint64_t v19;

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16);
  v12 = *(RSA **)(v11 + 8);
  v13 = *(EVP_MD **)(v10 + 24);
  if (v13)
  {
    v14 = *(_DWORD *)(v10 + 16);
    if (v14 != 6)
    {
      if (v14 == 1)
      {
        v15 = EVP_MD_type(*(const EVP_MD **)(v10 + 24));
        return RSA_verify(v15, a4, a5, a2, a3, v12);
      }
      return 0;
    }
    return RSA_verify_pss_mgf1(*(_QWORD *)(v11 + 8), a4, a5, v13, *(const EVP_MD **)(v10 + 32), *(_DWORD *)(v10 + 40), (uint64_t)a2, a3);
  }
  else
  {
    v19 = 0xAAAAAAAAAAAAAAAALL;
    v17 = EVP_PKEY_size((EVP_PKEY *)v11);
    result = setup_tbuf(v10, a1);
    if (!(_DWORD)result)
      return result;
    if (RSA_verify_raw((uint64_t)v12, &v19, *(unsigned __int8 **)(v10 + 48), v17, (uint64_t)a2, a3, *(_DWORD *)(v10 + 16)))v18 = v19 == a5;
    else
      v18 = 0;
    if (!v18)
      return 0;
    return CRYPTO_memcmp((char *)a4, *(char **)(v10 + 48), a5) == 0;
  }
}

uint64_t pkey_rsa_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  const BIGNUM *v7;

  result = pkey_rsa_init(a1);
  if ((_DWORD)result)
  {
    v5 = *(_QWORD *)(a2 + 40);
    v6 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)v6 = *(_DWORD *)v5;
    v7 = *(const BIGNUM **)(v5 + 8);
    if (!v7 || (result = (uint64_t)BN_dup(v7), (*(_QWORD *)(v6 + 8) = result) != 0))
    {
      *(_DWORD *)(v6 + 16) = *(_DWORD *)(v5 + 16);
      *(_OWORD *)(v6 + 24) = *(_OWORD *)(v5 + 24);
      *(_DWORD *)(v6 + 40) = *(_DWORD *)(v5 + 40);
      if (*(_QWORD *)(v5 + 56))
      {
        OPENSSL_free(*(_QWORD **)(v6 + 56));
        result = (uint64_t)OPENSSL_memdup(*(const void **)(v5 + 56), *(_QWORD *)(v5 + 64));
        *(_QWORD *)(v6 + 56) = result;
        if (!result)
          return result;
        *(_QWORD *)(v6 + 64) = *(_QWORD *)(v5 + 64);
      }
      return 1;
    }
  }
  return result;
}

uint64_t pkey_rsa_init(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = OPENSSL_malloc(0x48uLL);
  if (!v2)
    return 0;
  *(_OWORD *)v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  v2[8] = 0;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *(_DWORD *)v2 = 2048;
  v3 = 1;
  *((_DWORD *)v2 + 4) = 1;
  *((_DWORD *)v2 + 10) = -2;
  *(_QWORD *)(a1 + 40) = v2;
  return v3;
}

uint64_t RSA_verify_pss_mgf1(uint64_t a1, const void *a2, uint64_t a3, EVP_MD *md, const EVP_MD *a5, int a6, uint64_t a7, uint64_t a8)
{
  size_t v15;
  int v16;
  int v17;
  unsigned __int8 *v18;
  uint64_t v19;
  char *v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t v25;

  if (EVP_MD_size(md) == a3)
  {
    if (a1)
      v15 = BN_num_bytes(*(const BIGNUM **)(a1 + 8));
    else
      v15 = 0;
    v25 = v15;
    v18 = (unsigned __int8 *)malloc_type_malloc(v15, 0xF68727C8uLL);
    if (v18)
    {
      v20 = (char *)v18;
      if (RSA_verify_raw(a1, &v25, v18, v19, a7, a8, 3))
      {
        v21 = v25;
        if (a1)
          v22 = BN_num_bytes(*(const BIGNUM **)(a1 + 8));
        else
          v22 = 0;
        if (v21 == v22)
        {
          v23 = RSA_verify_PKCS1_PSS_mgf1(a1, a2, md, a5, v20, a6);
LABEL_17:
          free(v20);
          return v23;
        }
        ERR_put_error(4, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", 354);
      }
      v23 = 0;
      goto LABEL_17;
    }
    v16 = 65;
    v17 = 344;
  }
  else
  {
    v16 = 125;
    v17 = 337;
  }
  ERR_put_error(4, 0, v16, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v17);
  return 0;
}

uint64_t RSA_verify_raw(uint64_t a1, _QWORD *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  int v11;
  int v12;
  const BIGNUM *v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  int v25;
  int v26;
  unint64_t v27;
  void *v28;

  if (!a1)
  {
    v11 = 67;
    v12 = 216;
    goto LABEL_19;
  }
  if (BN_num_bytes(*(const BIGNUM **)(a1 + 8)) >= 0x401)
  {
    v11 = 500;
    v12 = 220;
LABEL_19:
    ERR_put_error(4, 0, v11, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v12);
    return 0;
  }
  v27 = 0xAAAAAAAAAAAAAAAALL;
  v28 = 0;
  v13 = *(const BIGNUM **)(a1 + 8);
  if (!v13 || !*(_QWORD *)(a1 + 16))
  {
    v11 = 144;
    v12 = 229;
    goto LABEL_19;
  }
  v14 = BN_num_bytes(v13);
  if (!RSA_public_key_to_bytes(&v28, &v27, a1) || !v28)
    return 0;
  v15 = ccrsa_import_pub_n();
  v16 = malloc_type_malloc(24 * v15 + 40, 0x24977F40uLL);
  if (!v16)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      RSA_verify_raw_cold_1();
    return 0;
  }
  v17 = v16;
  *v16 = v15;
  v18 = malloc_type_malloc(8 * v15, 0x100004000313F17uLL);
  v19 = malloc_type_malloc(8 * v15, 0x100004000313F17uLL);
  v20 = v19;
  if (!v18 || !v19)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      RSA_verify_raw_cold_2();
    free(v17);
    if (v18)
      free(v18);
    if (v20)
      free(v20);
    return 0;
  }
  ccn_zero();
  ccn_zero();
  ccn_read_uint();
  if (ccrsa_import_pub() || ccrsa_pub_crypt())
    goto LABEL_14;
  if (a7 == 3)
  {
    *a2 = v14;
    ccn_write_uint_padded();
    v23 = a3;
    if ((v14 & 0x80000000) == 0)
    {
LABEL_34:
      *a2 = v14;
      v21 = 1;
LABEL_43:
      if (v23 != a3 && v23)
        free(v23);
      goto LABEL_15;
    }
    goto LABEL_39;
  }
  v24 = (unsigned __int8 *)malloc_type_malloc(v14, 0x99993DA3uLL);
  if (v24)
  {
    v23 = v24;
    *a2 = v14;
    ccn_write_uint_padded();
    if (a7 != 1)
    {
      v25 = 143;
      v26 = 296;
      goto LABEL_42;
    }
    if (RSA_padding_check_PKCS1_type_1(a3, (int)a2, (const unsigned __int8 *)v14, (int)v23, v14))
    {
      v14 = *(_DWORD *)a2;
      if ((*(_DWORD *)a2 & 0x80000000) == 0)
        goto LABEL_34;
    }
LABEL_39:
    v25 = 136;
    v26 = 301;
LABEL_42:
    ERR_put_error(4, 0, v25, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v26);
    v21 = 0;
    goto LABEL_43;
  }
  ERR_put_error(4, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", 277);
LABEL_14:
  v21 = 0;
LABEL_15:
  if (v28)
  {
    OPENSSL_free(v28);
    v28 = 0;
  }
  free(v18);
  free(v20);
  free(v17);
  return v21;
}

uint64_t RSA_public_key_to_bytes(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  __int128 v6;
  _OWORD v8[3];

  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v6;
  v8[2] = v6;
  v8[0] = v6;
  CBB_zero(v8);
  if (CBB_init((uint64_t)v8, 0)
    && RSA_marshal_public_key((uint64_t *)v8, a3)
    && CBB_finish((uint64_t)v8, a1, a2))
  {
    return 1;
  }
  ERR_put_error(4, 0, 121, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", 145);
  CBB_cleanup((uint64_t)v8);
  return 0;
}

uint64_t RSA_marshal_public_key(uint64_t *a1, uint64_t a2)
{
  __int128 v4;
  _OWORD v6[3];

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = v4;
  v6[2] = v4;
  v6[0] = v4;
  if (CBB_add_asn1(a1, (uint64_t)v6, 0x20000010u)
    && marshal_integer_0((uint64_t *)v6, *(const BIGNUM **)(a2 + 8))
    && marshal_integer_0((uint64_t *)v6, *(const BIGNUM **)(a2 + 16))
    && CBB_flush(a1))
  {
    return 1;
  }
  ERR_put_error(4, 0, 121, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", 132);
  return 0;
}

uint64_t marshal_integer(uint64_t *a1, const BIGNUM *a2)
{
  if (a2)
    return BN_marshal_asn1(a1, a2);
  ERR_put_error(10, 0, 67, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/dsa/dsa_asn1.c", 144);
  return 0;
}

uint64_t marshal_integer_0(uint64_t *a1, const BIGNUM *a2)
{
  if (a2)
    return BN_marshal_asn1(a1, a2);
  ERR_put_error(4, 0, 144, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", 84);
  return 0;
}

uint64_t RSA_verify_PKCS1_PSS_mgf1(uint64_t a1, const void *a2, const EVP_MD *a3, const EVP_MD *a4, char *a5, int a6)
{
  const EVP_MD *v11;
  __int128 v12;
  size_t v13;
  size_t v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v26;
  unsigned __int8 *v27;
  _BYTE *v28;
  unint64_t v29;
  char v30;
  unint64_t v31;
  int v32;
  unint64_t v33;
  int v34;
  int v35;
  __int128 v36;
  char *__s2;
  uint64_t v38;
  EVP_MD_CTX ctx;
  unsigned __int8 md[16];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (a4)
    v11 = a4;
  else
    v11 = a3;
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.digest = v12;
  *(_OWORD *)&ctx.flags = v12;
  EVP_MD_CTX_init(&ctx);
  v13 = EVP_MD_size(a3);
  v14 = v13;
  if (a6 == -2)
    goto LABEL_9;
  if (a6 == -1)
  {
    a6 = v13;
    goto LABEL_9;
  }
  if (a6 > -3)
  {
LABEL_9:
    v17 = (BN_num_bits(*(const BIGNUM **)(a1 + 8)) - 1) & 7;
    v18 = RSA_size((const RSA *)a1);
    if (*a5 >> v17)
    {
      v15 = 122;
      v16 = 523;
      goto LABEL_21;
    }
    v19 = v18;
    if (v17)
      v20 = a5;
    else
      v20 = a5 + 1;
    if (v17)
      v21 = 0;
    else
      v21 = -1;
    v22 = v18 - (unint64_t)(v17 == 0);
    if (v22 < v14 + 2 || (a6 & 0x80000000) == 0 && v22 < v14 + 2 + a6)
    {
      v15 = 113;
      v16 = 533;
      goto LABEL_21;
    }
    if (v20[v22 - 1] != 188)
    {
      v15 = 127;
      v16 = 537;
      goto LABEL_21;
    }
    v38 = v21;
    v26 = v22 + ~v14;
    v27 = (unsigned __int8 *)OPENSSL_malloc(v26);
    v24 = v27;
    if (v27)
    {
      __s2 = &v20[v26];
      if (PKCS1_MGF1(v27, v26, (const unsigned __int8 *)&v20[v26], v14, v11))
      {
        if (v26)
        {
          v28 = v24;
          v29 = v26;
          do
          {
            v30 = *v20++;
            *v28++ ^= v30;
            --v29;
          }
          while (v29);
        }
        if (v17)
          *(_BYTE *)v24 &= 0xFFu >> (8 - v17);
        v31 = 0;
        do
        {
          v32 = *((unsigned __int8 *)v24 + v31);
          v33 = v31 + 1;
          if (v31 >= v26 - 1)
            break;
          ++v31;
        }
        while (!v32);
        if (v32 == 1)
        {
          if (a6 < 0 || ~v14 + v38 + v19 - a6 == v33)
          {
            *(_QWORD *)&v36 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v36 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v42 = v36;
            v43 = v36;
            *(_OWORD *)md = v36;
            v41 = v36;
            if (!EVP_DigestInit_ex(&ctx, a3, 0)
              || !EVP_DigestUpdate(&ctx, &kPSSZeroes, 8uLL)
              || !EVP_DigestUpdate(&ctx, a2, v14)
              || !EVP_DigestUpdate(&ctx, (char *)v24 + v33, v26 - v33)
              || !EVP_DigestFinal_ex(&ctx, md, 0))
            {
              goto LABEL_41;
            }
            if (!v14 || !memcmp(md, __s2, v14))
            {
              v23 = 1;
              goto LABEL_22;
            }
            v34 = 105;
            v35 = 582;
          }
          else
          {
            v34 = 138;
            v35 = 570;
          }
        }
        else
        {
          v34 = 139;
          v35 = 564;
        }
        ERR_put_error(4, 0, v34, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v35);
      }
    }
LABEL_41:
    v23 = 0;
    goto LABEL_22;
  }
  v15 = 138;
  v16 = 516;
LABEL_21:
  ERR_put_error(4, 0, v15, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v16);
  v23 = 0;
  v24 = 0;
LABEL_22:
  OPENSSL_free(v24);
  EVP_MD_CTX_cleanup(&ctx);
  return v23;
}

int RSA_size(const RSA *a1)
{
  if (a1)
    LODWORD(a1) = BN_num_bytes((const BIGNUM *)a1->version);
  return (int)a1;
}

uint64_t EVP_PKEY_CTX_set_rsa_pss_saltlen(uint64_t *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, 24);
}

uint64_t EVP_PKEY_CTX_set_rsa_padding(uint64_t *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, -1);
}

int ECDSA_verify(int type, const unsigned __int8 *dgst, int dgstlen, const unsigned __int8 *sig, int siglen, EC_KEY *eckey)
{
  const EC_GROUP *v7;
  int curve_name;
  _QWORD *cc_curve_parameters;
  void *v10;
  void *v11;
  int result;
  BOOL v13;
  unsigned __int8 *out;

  out = 0;
  i2o_ECPublicKey(eckey, &out);
  if (!out)
  {
    if (g_boringssl_log)
    {
      result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      ECDSA_verify_cold_1();
    }
    return 0;
  }
  v7 = EC_KEY_get0_group(eckey);
  curve_name = EC_GROUP_get_curve_name(v7);
  cc_curve_parameters = (_QWORD *)boringssl_ecdsa_get_cc_curve_parameters(curve_name);
  if (!cc_curve_parameters)
    goto LABEL_17;
  v10 = malloc_type_malloc(24 * *cc_curve_parameters + 16, 0x9A0B341BuLL);
  if (!v10)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      ECDSA_verify_cold_2();
LABEL_17:
    if (out)
    {
      cc_clear();
      OPENSSL_free(out);
    }
    return 0;
  }
  v11 = v10;
  if (ccec_import_pub())
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      ECDSA_verify_cold_4();
    if (out)
    {
      cc_clear();
      OPENSSL_free(out);
    }
    free(v11);
    return 0;
  }
  if (ccec_verify())
    v13 = g_boringssl_log == 0;
  else
    v13 = 1;
  if (!v13 && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    ECDSA_verify_cold_3();
  if (out)
  {
    cc_clear();
    OPENSSL_free(out);
  }
  free(v11);
  return 0;
}

const EC_GROUP *__cdecl EC_KEY_get0_group(const EC_KEY *a1)
{
  return *(const EC_GROUP **)a1;
}

int EC_GROUP_get_curve_name(const EC_GROUP *a1)
{
  return *((_DWORD *)a1 + 10);
}

uint64_t pkey_ec_verify(uint64_t a1, unsigned __int8 *sig, int siglen, unsigned __int8 *dgst, int dgstlen)
{
  return ECDSA_verify(0, dgst, dgstlen, sig, siglen, *(EC_KEY **)(*(_QWORD *)(a1 + 16) + 8));
}

uint64_t pkey_ec_ctrl(uint64_t a1, int a2, int nid, EVP_MD *md)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v7;
  int v8;
  int v9;
  int v10;

  v4 = *(_QWORD *)(a1 + 40);
  if (a2 <= 2)
  {
    if (a2 == 1)
    {
      v8 = EVP_MD_type(md);
      if ((v8 - 672) < 4 || v8 == 64)
      {
        *(_QWORD *)v4 = md;
        return 1;
      }
      v9 = 111;
      v10 = 182;
      goto LABEL_13;
    }
    if (a2 == 2)
    {
      *(_QWORD *)&md->type = *(_QWORD *)v4;
      return 1;
    }
LABEL_12:
    v9 = 101;
    v10 = 208;
LABEL_13:
    ERR_put_error(6, 0, v9, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec.c", v10);
    return 0;
  }
  if (a2 == 3)
    return 1;
  if (a2 != 4109)
    goto LABEL_12;
  result = (uint64_t)EC_GROUP_new_by_curve_name(nid);
  if (result)
  {
    v7 = result;
    EC_GROUP_free(*(EC_GROUP **)(v4 + 8));
    *(_QWORD *)(v4 + 8) = v7;
    return 1;
  }
  return result;
}

uint64_t pkey_ec_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = pkey_ec_init(a1);
  if ((_DWORD)result)
  {
    **(_QWORD **)(a1 + 40) = **(_QWORD **)(a2 + 40);
    return 1;
  }
  return result;
}

uint64_t pkey_ec_init(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = OPENSSL_malloc(0x10uLL);
  if (!v2)
    return 0;
  *v2 = 0;
  v2[1] = 0;
  v3 = 1;
  *(_QWORD *)(a1 + 40) = v2;
  return v3;
}

uint64_t boringssl_ecdsa_get_cc_curve_parameters(int a1)
{
  if (a1 > 714)
  {
    if (a1 == 715)
      JUMPOUT(0x1B5E44CC4);
    if (a1 == 716)
      return ccec_cp_521();
  }
  else
  {
    if (a1 == 415)
      JUMPOUT(0x1B5E44CB8);
    if (a1 == 713)
      JUMPOUT(0x1B5E44CACLL);
  }
  if (g_boringssl_log)
  {
    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      boringssl_ecdsa_get_cc_curve_parameters_cold_1();
  }
  return 0;
}

int EC_KEY_set_public_key(EC_KEY *a1, const EC_POINT *a2)
{
  const EC_GROUP *v3;
  int v5;
  int v6;
  EC_POINT *v8;

  v3 = *(const EC_GROUP **)a1;
  if (!v3)
  {
    v5 = 114;
    v6 = 264;
    goto LABEL_6;
  }
  if (a2 && EC_GROUP_cmp(v3, *(const EC_GROUP **)a2, 0))
  {
    v5 = 130;
    v6 = 269;
LABEL_6:
    ERR_put_error(15, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", v6);
    return 0;
  }
  EC_POINT_free(*((EC_POINT **)a1 + 1));
  v8 = EC_POINT_dup(a2, *(const EC_GROUP **)a1);
  *((_QWORD *)a1 + 1) = v8;
  return v8 != 0;
}

EC_POINT *__cdecl EC_POINT_dup(const EC_POINT *a1, const EC_GROUP *a2)
{
  EC_POINT *v3;
  EC_POINT *v4;

  if (!a1)
    return 0;
  v3 = EC_POINT_new(a2);
  v4 = v3;
  if (!v3 || !EC_POINT_copy(v3, a1))
  {
    EC_POINT_free(v4);
    return 0;
  }
  return v4;
}

int EC_POINT_copy(EC_POINT *a1, const EC_POINT *a2)
{
  BN_CTX *v2;

  if (EC_GROUP_cmp(*(const EC_GROUP **)a1, *(const EC_GROUP **)a2, v2))
  {
    ERR_put_error(15, 0, 106, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", 713);
    return 0;
  }
  else
  {
    if (a1 != a2)
      ec_GFp_simple_point_copy((uint64_t)a1 + 8, (uint64_t)a2 + 8);
    return 1;
  }
}

int i2o_ECPublicKey(EC_KEY *a, unsigned __int8 **out)
{
  __int128 v4;
  int v5;
  _OWORD v7[3];

  if (a)
  {
    *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v7[1] = v4;
    v7[2] = v4;
    v7[0] = v4;
    if (CBB_init((uint64_t)v7, 0)
      && EC_POINT_point2cbb((uint64_t)v7, *(EC_GROUP **)a, *((EC_POINT **)a + 1), (point_conversion_form_t)*((_DWORD *)a + 7), 0))
    {
      v5 = CBB_finish_i2d((uint64_t)v7, (void **)out);
      return v5 & ~(v5 >> 31);
    }
    else
    {
      CBB_cleanup((uint64_t)v7);
      return -1;
    }
  }
  else
  {
    ERR_put_error(15, 0, 67, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", 521);
    return 0;
  }
}

unint64_t ec_point_to_bytes(uint64_t a1, uint64_t a2, int a3, char *a4, unint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  char v11;
  __int128 v12;
  unint64_t v14;
  _OWORD v15[4];
  __int16 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v9 = ec_point_byte_len(a1, a3);
  if (v9 <= a5)
  {
    v10 = v9;
    v14 = 0xAAAAAAAAAAAAAAAALL;
    ec_felem_to_bytes(a1);
    if (BN_num_bytes((const BIGNUM *)(a1 + 56)) != 0xAAAAAAAAAAAAAAAALL)
      ec_point_to_bytes_cold_2();
    if (a3 == 4)
    {
      ec_felem_to_bytes(a1);
      if (v14 != BN_num_bytes((const BIGNUM *)(a1 + 56)))
        ec_point_to_bytes_cold_1();
      v11 = 4;
    }
    else
    {
      v16 = -21846;
      *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v15[2] = v12;
      v15[3] = v12;
      v15[0] = v12;
      v15[1] = v12;
      ec_felem_to_bytes(a1);
      v11 = (*((_BYTE *)v15 + v14 - 1) & 1) + a3;
    }
    *a4 = v11;
  }
  else
  {
    ERR_put_error(15, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", 97);
    return 0;
  }
  return v10;
}

void ec_GFp_mont_felem_to_bytes(uint64_t a1, char *a2, unint64_t *a3, uint64_t a4)
{
  __int128 v7;
  _OWORD v8[4];
  unint64_t v9;

  v9 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[2] = v7;
  v8[3] = v7;
  v8[0] = v7;
  v8[1] = v7;
  bn_from_montgomery_small((unint64_t *)v8, *(int *)(a1 + 64), a4, *(int *)(a1 + 64), *(_QWORD *)(a1 + 312));
  ec_GFp_simple_felem_to_bytes(a1, a2, a3, (char *)v8);
}

void ec_GFp_simple_felem_to_bytes(uint64_t a1, char *a2, unint64_t *a3, char *a4)
{
  unint64_t v8;

  v8 = BN_num_bytes((const BIGNUM *)(a1 + 56));
  bn_words_to_big_endian(a2, v8, a4, *(int *)(a1 + 64));
  *a3 = v8;
}

void bn_from_montgomery_small(unint64_t *a1, unint64_t num, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v7;
  _OWORD v10[9];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (num > 9)
    goto LABEL_11;
  v7 = 2 * num;
  if (*(_DWORD *)(a5 + 32) != num || v7 < a4)
    goto LABEL_11;
  memset(v10, 0, sizeof(v10));
  if (a4)
    __memcpy_chk();
  if (!bn_from_montgomery_in_place(a1, num, (unint64_t *)v10, v7, a5))
LABEL_11:
    abort();
  OPENSSL_cleanse(v10, 16 * num);
}

uint64_t ec_felem_to_bytes(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 128))(a1);
}

int EC_POINT_oct2point(const EC_GROUP *a1, EC_POINT *a2, const unsigned __int8 *buf, size_t len, BN_CTX *a5)
{
  int v10;
  int v11;
  int v12;
  int v14;
  __int128 v15;
  int v16;
  char *v17;
  unsigned int v18;
  BN_CTX *v20;
  BIGNUM *v21;
  const BIGNUM *v22;
  _OWORD v23[9];

  if (EC_GROUP_cmp(a1, *(const EC_GROUP **)a2, 0))
  {
    v10 = 106;
    v11 = 205;
LABEL_3:
    ERR_put_error(15, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", v11);
    return 0;
  }
  if (!len)
  {
    v10 = 100;
    v11 = 140;
    goto LABEL_3;
  }
  v14 = *buf;
  if (v14 != 4)
  {
    v18 = BN_num_bytes((const BIGNUM *)((char *)a1 + 56));
    if ((v14 & 0xFE) != 2 || v18 + 1 != len)
    {
      v10 = 109;
      v11 = 162;
      goto LABEL_3;
    }
    if (a5)
    {
      v20 = 0;
    }
    else
    {
      a5 = BN_CTX_new();
      v20 = a5;
      if (!a5)
        return 0;
    }
    BN_CTX_start(a5);
    v21 = BN_CTX_get(a5);
    if (v21)
    {
      v22 = v21;
      if (BN_bin2bn(buf + 1, v18, v21))
      {
        if (BN_ucmp(v22, (const BIGNUM *)((char *)a1 + 56)) < 0)
        {
          v12 = EC_POINT_set_compressed_coordinates_GFp(a1, a2, v22, v14 & 1, a5);
          goto LABEL_25;
        }
        ERR_put_error(15, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", 186);
      }
    }
    v12 = 0;
LABEL_25:
    BN_CTX_end(a5);
    BN_CTX_free(v20);
    return v12;
  }
  *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[7] = v15;
  v23[8] = v15;
  v23[5] = v15;
  v23[6] = v15;
  v23[3] = v15;
  v23[4] = v15;
  v23[1] = v15;
  v23[2] = v15;
  v23[0] = v15;
  v16 = ec_point_from_uncompressed((uint64_t)a1, (uint64_t)v23, buf, len);
  v17 = (char *)a2 + 8;
  if (v16)
  {
    ec_affine_to_jacobian((uint64_t)a1, (uint64_t)v17, (uint64_t)v23);
    return 1;
  }
  ec_set_to_safe_point((uint64_t)a1, (uint64_t)v17);
  return 0;
}

uint64_t EC_POINT_point2cbb(uint64_t a1, EC_GROUP *a2, EC_POINT *a3, point_conversion_form_t form, BN_CTX *a5)
{
  uint64_t result;
  size_t v11;
  unsigned __int8 *buf;

  result = EC_POINT_point2oct(a2, a3, form, 0, 0, a5);
  if (result)
  {
    v11 = result;
    buf = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
    result = CBB_add_space(a1, &buf, result);
    if ((_DWORD)result)
      return EC_POINT_point2oct(a2, a3, form, buf, v11, a5) == v11;
  }
  return result;
}

size_t EC_POINT_point2oct(const EC_GROUP *a1, const EC_POINT *a2, point_conversion_form_t form, unsigned __int8 *buf, size_t len, BN_CTX *a6)
{
  int v11;
  int v12;
  __int128 v14;
  _OWORD v15[9];

  if (EC_GROUP_cmp(a1, *(const EC_GROUP **)a2, 0))
  {
    v11 = 106;
    v12 = 215;
  }
  else
  {
    if (buf)
    {
      *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v15[7] = v14;
      v15[8] = v14;
      v15[5] = v14;
      v15[6] = v14;
      v15[3] = v14;
      v15[4] = v14;
      v15[1] = v14;
      v15[2] = v14;
      v15[0] = v14;
      if (ec_jacobian_to_affine((uint64_t)a1, (uint64_t)v15, (uint64_t)a2 + 8))
        return ec_point_to_bytes((uint64_t)a1, (uint64_t)v15, form, (char *)buf, len);
      return 0;
    }
    if (!ec_GFp_simple_is_at_infinity((uint64_t)a1, (uint64_t)a2 + 8))
      return ec_point_byte_len((uint64_t)a1, form);
    v11 = 119;
    v12 = 222;
  }
  ERR_put_error(15, 0, v11, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", v12);
  return 0;
}

int EC_GROUP_cmp(const EC_GROUP *a1, const EC_GROUP *a2, BN_CTX *a3)
{
  int v5;

  if (a1 == a2)
    return 0;
  v5 = *((_DWORD *)a1 + 10);
  if (v5 != *((_DWORD *)a2 + 10))
    return 1;
  if (v5)
    return 0;
  return *(_QWORD *)a1 != *(_QWORD *)a2
      || !*((_QWORD *)a1 + 1)
      || !*((_QWORD *)a2 + 1)
      || BN_cmp((const BIGNUM *)((char *)a1 + 16), (const BIGNUM *)((char *)a2 + 16))
      || BN_cmp((const BIGNUM *)((char *)a1 + 56), (const BIGNUM *)((char *)a2 + 56))
      || !ec_felem_equal((uint64_t)a1, (char *)a1 + 80, (char *)a2 + 80)
      || !ec_felem_equal((uint64_t)a1, (char *)a1 + 152, (char *)a2 + 152)
      || ec_GFp_simple_points_equal((uint64_t)a1, *((_QWORD *)a1 + 1) + 8, *((_QWORD *)a2 + 1) + 8) == 0;
}

uint64_t ec_point_byte_len(uint64_t a1, int a2)
{
  unsigned int v3;
  uint64_t v4;

  if (a2 == 2 || a2 == 4)
  {
    v3 = BN_num_bytes((const BIGNUM *)(a1 + 56));
    v4 = v3;
    if (a2 != 4)
      v4 = 0;
    return v4 + v3 + 1;
  }
  else
  {
    ERR_put_error(15, 0, 111, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", 79);
    return 0;
  }
}

uint64_t ec_point_from_uncompressed(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  __int128 v7;
  uint64_t result;
  _OWORD v9[4];
  unint64_t v10;
  _OWORD v11[4];
  unint64_t v12;

  if (((2 * BN_num_bytes((const BIGNUM *)(a1 + 56))) | 1) == a4 && *a3 == 4)
  {
    v12 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v11[2] = v7;
    v11[3] = v7;
    v11[0] = v7;
    v11[1] = v7;
    v10 = 0xAAAAAAAAAAAAAAAALL;
    v9[2] = v7;
    v9[3] = v7;
    v9[0] = v7;
    v9[1] = v7;
    result = ec_felem_from_bytes(a1);
    if ((_DWORD)result)
    {
      result = ec_felem_from_bytes(a1);
      if ((_DWORD)result)
        return ec_point_set_affine_coordinates(a1, a2, (uint64_t)v11, (uint64_t)v9) != 0;
    }
  }
  else
  {
    ERR_put_error(15, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", 122);
    return 0;
  }
  return result;
}

uint64_t ec_felem_from_bytes(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
}

uint64_t ec_jacobian_to_affine(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 24))(a1, a3, a2, a2 + 72);
}

__n128 ec_affine_to_jacobian(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __n128 result;

  *(_OWORD *)a2 = *(_OWORD *)a3;
  v3 = *(_OWORD *)(a3 + 16);
  v4 = *(_OWORD *)(a3 + 32);
  v5 = *(_OWORD *)(a3 + 48);
  *(_QWORD *)(a2 + 64) = *(_QWORD *)(a3 + 64);
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)(a2 + 48) = v5;
  *(_OWORD *)(a2 + 16) = v3;
  v6 = *(_OWORD *)(a3 + 104);
  v7 = *(_OWORD *)(a3 + 120);
  v8 = *(_QWORD *)(a3 + 136);
  *(_OWORD *)(a2 + 88) = *(_OWORD *)(a3 + 88);
  *(_QWORD *)(a2 + 136) = v8;
  *(_OWORD *)(a2 + 120) = v7;
  *(_OWORD *)(a2 + 104) = v6;
  *(_OWORD *)(a2 + 72) = *(_OWORD *)(a3 + 72);
  v10 = *(_OWORD *)(a1 + 352);
  v9 = *(_OWORD *)(a1 + 368);
  v11 = *(_OWORD *)(a1 + 336);
  *(_QWORD *)(a2 + 208) = *(_QWORD *)(a1 + 384);
  *(_OWORD *)(a2 + 176) = v10;
  *(_OWORD *)(a2 + 192) = v9;
  *(_OWORD *)(a2 + 160) = v11;
  result = *(__n128 *)(a1 + 320);
  *(__n128 *)(a2 + 144) = result;
  return result;
}

__n128 ec_GFp_simple_point_copy(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __n128 result;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  v2 = *(_OWORD *)(a2 + 16);
  v3 = *(_OWORD *)(a2 + 32);
  v4 = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)(a1 + 16) = v2;
  v5 = *(_OWORD *)(a2 + 104);
  v6 = *(_OWORD *)(a2 + 120);
  v7 = *(_QWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 136) = v7;
  *(_OWORD *)(a1 + 120) = v6;
  *(_OWORD *)(a1 + 104) = v5;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  v9 = *(_OWORD *)(a2 + 176);
  v8 = *(_OWORD *)(a2 + 192);
  v10 = *(_OWORD *)(a2 + 160);
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
  *(_OWORD *)(a1 + 176) = v9;
  *(_OWORD *)(a1 + 192) = v8;
  *(_OWORD *)(a1 + 160) = v10;
  result = *(__n128 *)(a2 + 144);
  *(__n128 *)(a1 + 144) = result;
  return result;
}

uint64_t CBB_finish_i2d(uint64_t a1, void **a2)
{
  char *v5;
  size_t v6;
  size_t __n;
  void *__src;

  if (*(_BYTE *)(a1 + 8))
    CBB_finish_i2d_cold_2();
  if ((*(_BYTE *)(a1 + 40) & 1) == 0)
    CBB_finish_i2d_cold_1();
  __n = 0xAAAAAAAAAAAAAAAALL;
  __src = (void *)0xAAAAAAAAAAAAAAAALL;
  if (!CBB_finish(a1, &__src, &__n))
  {
    CBB_cleanup(a1);
    return 0xFFFFFFFFLL;
  }
  if (__n >> 31)
  {
    OPENSSL_free(__src);
    return 0xFFFFFFFFLL;
  }
  if (a2)
  {
    v5 = (char *)*a2;
    if (*a2)
    {
      if (__n)
      {
        memcpy(v5, __src, __n);
        v6 = __n;
        v5 = (char *)*a2;
      }
      else
      {
        v6 = 0;
      }
      *a2 = &v5[v6];
    }
    else
    {
      *a2 = __src;
      __src = 0;
    }
  }
  OPENSSL_free(__src);
  return __n;
}

uint64_t EVP_PKEY_get0_EC_KEY(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 408)
    return *(_QWORD *)(a1 + 8);
  ERR_put_error(6, 0, 106, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp.c", 310);
  return 0;
}

uint64_t ec_point_mul_scalar_base(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  int v6;
  int v7;

  if (a3)
  {
    (*(void (**)(_DWORD *))(*(_QWORD *)a1 + 64))(a1);
    if (ec_GFp_simple_is_on_curve(a1, a2))
      return 1;
    v6 = 68;
    v7 = 1079;
  }
  else
  {
    v6 = 67;
    v7 = 1070;
  }
  ERR_put_error(15, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", v7);
  return 0;
}

uint64_t ec_point_mul_scalar(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  int v8;

  if (a3 && a4)
  {
    (*(void (**)(_DWORD *))(*(_QWORD *)a1 + 56))(a1);
    if (ec_GFp_simple_is_on_curve(a1, a2))
      return 1;
    v7 = 68;
    v8 = 1060;
  }
  else
  {
    v7 = 67;
    v8 = 1051;
  }
  ERR_put_error(15, 0, v7, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", v8);
  return 0;
}

double ec_GFp_nistp256_point_mul_base(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  char v5;
  __int128 v6;
  uint64_t v7;
  unint64_t v8;
  __int128 v9;
  __int128 v10;
  double result;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v5 = 0;
  v25 = *MEMORY[0x1E0C80C00];
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17 = v6;
  v18 = v6;
  v15 = v6;
  v16 = v6;
  v7 = 223;
  v13 = v6;
  v14 = v6;
  do
  {
    if ((v5 & 1) != 0)
      fiat_p256_point_double((uint64_t *)&v19, (uint64_t *)&v21, (uint64_t *)&v23, (unint64_t *)&v19, (unint64_t *)&v21, (unint64_t *)&v23);
    fiat_p256_select_point_affine((8 * ((*(_QWORD *)(a3 + 8 * ((v7 + 32) >> 6)) >> (v7 + 96)) & 1)) | (4 * ((*(_QWORD *)(a3 + 8 * ((v7 - 32) >> 6)) >> (v7 + 96)) & 1)) | (2 * ((*(_QWORD *)(a3 + 8 * ((v7 - 96) >> 6)) >> (v7 + 96)) & 1)) | (*(_QWORD *)(a3 + 8 * ((v7 - 160) >> 6)) >> (v7 + 96)) & 1, (uint64_t)&unk_1B5017810, &v13);
    if ((v5 & 1) != 0)
    {
      fiat_p256_point_add((uint64_t *)&v19, (uint64_t *)&v21, (uint64_t *)&v23, (uint64_t)&v19, (uint64_t)&v21, (unint64_t *)&v23, 1, (unint64_t *)&v13, (unint64_t *)&v15, (unint64_t *)&v17);
    }
    else
    {
      v19 = v13;
      v20 = v14;
      v21 = v15;
      v22 = v16;
      v23 = v17;
      v24 = v18;
    }
    fiat_p256_select_point_affine((8 * ((*(_QWORD *)(a3 + 8 * (v7 >> 6)) >> v7) & 1)) | (4* ((*(_QWORD *)(a3+ 8* ((v7 - 64) >> 6)) >> (v7 + 64)) & 1)) | (2 * ((*(_QWORD *)(a3 + 8 * ((v7 - 128) >> 6)) >> (v7 + 64)) & 1)) | (*(_QWORD *)(a3 + 8 * ((v7 - 192) >> 6)) >> (v7 + 64)) & 1, (uint64_t)&fiat_p256_g_pre_comp, &v13);
    v5 = 1;
    fiat_p256_point_add((uint64_t *)&v19, (uint64_t *)&v21, (uint64_t *)&v23, (uint64_t)&v19, (uint64_t)&v21, (unint64_t *)&v23, 1, (unint64_t *)&v13, (unint64_t *)&v15, (unint64_t *)&v17);
    v8 = v7 - 193;
    --v7;
  }
  while (v8 < 0x20);
  v9 = v20;
  *a2 = v19;
  a2[1] = v9;
  v10 = v22;
  *(_OWORD *)((char *)a2 + 72) = v21;
  *(_OWORD *)((char *)a2 + 88) = v10;
  result = *(double *)&v23;
  v12 = v24;
  a2[9] = v23;
  a2[10] = v12;
  return result;
}

int EC_GROUP_get_degree(const EC_GROUP *a1)
{
  return BN_num_bits((const BIGNUM *)((char *)a1 + 56));
}

int RSA_padding_check_PKCS1_type_1(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len)
{
  int v5;
  int v6;
  size_t *v7;
  uint64_t v8;
  uint64_t v9;
  size_t v11;

  if (*(_QWORD *)&rsa_len <= 1uLL)
  {
    v5 = 116;
    v6 = 103;
LABEL_11:
    ERR_put_error(4, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v6);
    return 0;
  }
  if (**(_BYTE **)&fl || *(_BYTE *)(*(_QWORD *)&fl + 1) != 1)
  {
    v5 = 107;
    v6 = 109;
    goto LABEL_11;
  }
  if (*(_QWORD *)&rsa_len < 3uLL)
    goto LABEL_14;
  v7 = *(size_t **)&tlen;
  v8 = 0;
  v9 = *(_QWORD *)&rsa_len - 2;
  while (*(unsigned __int8 *)(*(_QWORD *)&fl + v8 + 2) == 255)
  {
    if (v9 == ++v8)
      goto LABEL_14;
  }
  if (*(_BYTE *)(*(_QWORD *)&fl + v8 + 2))
  {
    v5 = 102;
    v6 = 121;
    goto LABEL_11;
  }
  if (v9 == v8)
  {
LABEL_14:
    v5 = 131;
    v6 = 127;
    goto LABEL_11;
  }
  if ((unint64_t)(v8 + 2) <= 9)
  {
    v5 = 103;
    v6 = 132;
    goto LABEL_11;
  }
  v11 = *(_QWORD *)&rsa_len - v8 - 3;
  if (v11 > (unint64_t)f)
  {
    v5 = 113;
    v6 = 140;
    goto LABEL_11;
  }
  if (*(_QWORD *)&rsa_len - 3 != v8)
    memcpy(to, (const void *)(*(_QWORD *)&fl + v8 + 3), v11);
  *v7 = v11;
  return 1;
}

uint64_t RSA_add_pkcs1_prefix(_QWORD *a1, size_t *a2, _DWORD *a3, int a4, const void *a5, size_t a6)
{
  uint64_t result;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  char *v16;
  size_t v17;
  size_t v18;
  char *v19;
  char *v20;

  if (a4 == 114)
  {
    if (a6 == 36)
    {
      *a1 = a5;
      *a2 = 36;
      *a3 = 0;
      return 1;
    }
    v14 = 125;
    v15 = 498;
  }
  else
  {
    v12 = 0;
    v13 = 4;
    while (v13 != a4)
    {
      v13 = *(_DWORD *)&kPKCS1SigPrefixes[v12 + 24];
      v12 += 24;
      if (v12 == 144)
      {
        v14 = 142;
        v15 = 541;
        goto LABEL_14;
      }
    }
    v16 = (char *)&kPKCS1SigPrefixes[v12];
    v17 = kPKCS1SigPrefixes[v12 + 4];
    if ((int)v17 + (int)a6 >= v17)
    {
      v18 = (v17 + a6);
      v19 = (char *)malloc_type_malloc(v18, 0x8413B575uLL);
      if (v19)
      {
        v20 = v19;
        memcpy(v19, v16 + 5, v17);
        memcpy(&v20[v17], a5, a6);
        *a1 = v20;
        *a2 = v18;
        result = 1;
        *a3 = 1;
        return result;
      }
      v14 = 65;
      v15 = 527;
    }
    else
    {
      v14 = 140;
      v15 = 521;
    }
  }
LABEL_14:
  ERR_put_error(4, 0, v14, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v15);
  return 0;
}

BOOL bssl::ssl_nid_to_group_id(bssl *this, unsigned __int16 *a2)
{
  uint64_t v2;
  int v3;

  v2 = 0;
  while (1)
  {
    if (v3 == (_DWORD)a2)
      break;
    v2 += 8;
    if (v2 == 64)
      return v3 == (_DWORD)a2;
  }
  return v3 == (_DWORD)a2;
}

point_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *a1)
{
  return *((_DWORD *)a1 + 7);
}

unsigned __int16 *__boringssl_session_apply_protocol_options_for_transport_block_invoke(uint64_t a1, unsigned __int16 *a2)
{
  NSObject *v4;
  unsigned int *v5;
  uint64_t v6;
  int sct_enabled;
  uint64_t v8;
  int ocsp_enabled;
  uint64_t v10;
  int renegotiation_enabled;
  uint64_t v12;
  char resumption_enabled;
  uint64_t v14;
  int tickets_enabled;
  uint64_t v16;
  int false_start_enabled;
  uint64_t v18;
  unint64_t v19;
  int is_opaque;
  int v21;
  uint64_t v22;
  int v23;
  _BOOL4 enable_encrypted_client_hello;
  uint64_t v25;
  id WeakRetained;
  void *v27;
  _BYTE *v28;
  char v29;
  uint64_t v30;
  id v31;
  _BYTE *v32;
  _BOOL4 v33;
  NSObject *v34;
  const unsigned __int8 *v35;
  unsigned __int8 *v36;
  char *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  unsigned int v42;
  uint64_t v43;
  int v44;
  char *v45;
  size_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  boringssl_concrete_boringssl_session_state *v51;
  int v52;
  uint64_t v53;
  id v54;
  void *v55;
  _BYTE *v56;
  char v57;
  uint64_t v58;
  id v59;
  _BYTE *v60;
  _BOOL4 v61;
  NSObject *v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  id v66;
  char v67;
  void *v68;
  id v69;
  void *v70;
  _BYTE *v71;
  char v72;
  id v73;
  _BYTE *v74;
  _BOOL4 v75;
  const char *v76;
  id v77;
  unint64_t v78;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  xpc_object_t v84;
  void *v85;
  id v86;
  boringssl_concrete_boringssl_psk_cache *v87;
  uint64_t v88;
  void *v89;
  int tls13_external_psk_enabled;
  uint64_t v91;
  id v92;
  void *v93;
  _BYTE *v94;
  char v95;
  uint64_t v96;
  id v97;
  _BYTE *v98;
  _BOOL4 v99;
  id v100;
  void *v101;
  _BYTE *v102;
  char v103;
  uint64_t v104;
  id v105;
  _BYTE *v106;
  _BOOL4 v107;
  uint64_t v108;
  id v109;
  char v110;
  void *v111;
  NSObject *v112;
  uint64_t v113;
  uint64_t v114;
  char *v115;
  uint64_t v116;
  NSObject *v117;
  uint64_t v118;
  uint64_t v119;
  char *v120;
  uint64_t v121;
  void *v122;
  char v123;
  void *v124;
  void *v125;
  char v126;
  void *v127;
  char *v128;
  uint64_t v129;
  NSObject *v130;
  void *v131;
  id v132;
  void *v133;
  id v134;
  uint64_t i;
  uint64_t v136;
  uint64_t v137;
  void *v138;
  NSObject *v139;
  size_t size;
  void *v141;
  uint64_t v142;
  uint64_t v143;
  id v144;
  void *v145;
  _BYTE *v146;
  char v147;
  uint64_t v148;
  id v149;
  _BYTE *v150;
  _BOOL4 v151;
  NSObject *v152;
  void *v153;
  uint64_t v154;
  _BOOL4 quic_use_legacy_codepoint;
  id v156;
  void *v157;
  uint64_t v158;
  id v159;
  uint64_t v160;
  uint64_t v161;
  void *v162;
  uint64_t v163;
  uint64_t v164;
  void *v165;
  uint64_t v166;
  uint64_t v167;
  void *v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  const __CFArray *v172;
  CFAllocatorRef *v173;
  const __CFArray *v174;
  uint64_t v175;
  id v176;
  void *v177;
  _BYTE *v178;
  char v179;
  uint64_t v180;
  id v181;
  _BYTE *v182;
  _BOOL4 v183;
  NSObject *v184;
  id v185;
  uint64_t v186;
  _BOOL4 v187;
  char *v188;
  id v189;
  uint64_t v190;
  int v191;
  int v192;
  id v193;
  const char *redacted_identity;
  unsigned __int8 *v195;
  int v196;
  int v197;
  int v198;
  int v199;
  uint64_t v201;
  id v202;
  char v203;
  void *v204;
  char *v205;
  uint64_t v206;
  const char *v207;
  void *v208;
  void *v209;
  void *v210;
  void *v211;
  _BOOL4 v212;
  void *v213;
  _BOOL4 v214;
  _BOOL4 v215;
  _BOOL4 v216;
  void *v217;
  _BOOL4 v218;
  uint64_t v219;
  _BOOL4 v220;
  id v221;
  id v222;
  id v223;
  id v224;
  NSObject *options;
  _QWORD applier[5];
  uint8_t buf[4];
  const char *v228;
  __int16 v229;
  int v230;
  __int16 v231;
  void *v232;
  __int16 v233;
  id v234;
  __int16 v235;
  _BYTE v236[10];
  __int16 v237;
  const char *v238;
  __int16 v239;
  int v240;
  __int16 v241;
  int v242;
  __int16 v243;
  int v244;
  __int16 v245;
  int v246;
  __int16 v247;
  int v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;

  v251 = *MEMORY[0x1E0C80C00];
  v4 = *(id *)(a1 + 32);
  if (!a2)
    goto LABEL_279;
  if (a2[1])
    boringssl_context_set_max_version(*(_QWORD *)(a1 + 40), a2[1]);
  if (*a2)
    boringssl_context_set_min_version(*(_QWORD *)(a1 + 40), *a2);
  v5 = (unsigned int *)((char *)a2 + 361);
  boringssl_context_set_fallback(*(_QWORD *)(a1 + 40), (*(_DWORD *)((char *)a2 + 361) >> 7) & 1);
  v6 = *(_QWORD *)(a1 + 40);
  if ((*(_DWORD *)((_BYTE *)a2 + 361) & 0x2000) != 0)
  {
    sct_enabled = 1;
  }
  else if ((*(_DWORD *)((_BYTE *)a2 + 361) & 0x4000) != 0)
  {
    sct_enabled = 0;
  }
  else
  {
    sct_enabled = boringssl_config_get_sct_enabled();
  }
  boringssl_context_set_sct_enable(v6, sct_enabled);
  v8 = *(_QWORD *)(a1 + 40);
  if ((*v5 & 0x8000) != 0)
  {
    ocsp_enabled = 1;
  }
  else if ((*v5 & 0x10000) != 0)
  {
    ocsp_enabled = 0;
  }
  else
  {
    ocsp_enabled = boringssl_config_get_ocsp_enabled();
  }
  boringssl_context_set_ocsp_enable(v8, ocsp_enabled);
  v10 = *(_QWORD *)(a1 + 40);
  if ((*v5 & 0x200000) != 0)
  {
    renegotiation_enabled = 1;
  }
  else if ((*v5 & 0x400000) != 0)
  {
    renegotiation_enabled = 0;
  }
  else
  {
    renegotiation_enabled = boringssl_config_get_renegotiation_enabled();
  }
  boringssl_context_set_renegotiation(v10, renegotiation_enabled);
  v12 = *(_QWORD *)(a1 + 40);
  if ((*v5 & 0x80000) != 0)
  {
    resumption_enabled = 1;
  }
  else if ((*v5 & 0x100000) != 0)
  {
    resumption_enabled = 0;
  }
  else
  {
    resumption_enabled = boringssl_config_get_resumption_enabled();
  }
  boringssl_context_set_resumption(v12, resumption_enabled);
  v14 = *(_QWORD *)(a1 + 40);
  if ((*v5 & 0x800) != 0)
  {
    tickets_enabled = 1;
  }
  else if ((*v5 & 0x100000) != 0)
  {
    tickets_enabled = 0;
  }
  else
  {
    tickets_enabled = boringssl_config_get_tickets_enabled();
  }
  boringssl_context_set_session_ticket_enabled(v14, tickets_enabled);
  v16 = *(_QWORD *)(a1 + 40);
  if ((*v5 & 0x200) != 0)
  {
    false_start_enabled = 1;
  }
  else if ((*v5 & 0x400) != 0)
  {
    false_start_enabled = 0;
  }
  else
  {
    false_start_enabled = boringssl_config_get_false_start_enabled();
  }
  boringssl_context_set_false_start(v16, false_start_enabled);
  boringssl_session_set_early_data_enabled(*(_QWORD *)(a1 + 40), (*v5 >> 23) & 1);
  v18 = *v5;
  v19 = v18 | ((unint64_t)*((unsigned __int8 *)a2 + 365) << 32);
  if ((v18 & 0x800000) != 0 && (*(_BYTE *)(*(_QWORD *)(a1 + 48) + 556) & 0x10) != 0 && *(_DWORD *)(a1 + 56) == 2)
  {
    boringssl_session_set_quic_early_data_context(*(_QWORD *)(a1 + 40), *((const char **)a2 + 42), *((_QWORD *)a2 + 44));
    v19 = *v5 | ((unint64_t)*((unsigned __int8 *)a2 + 365) << 32);
  }
  boringssl_context_set_enforce_ev(*(_QWORD *)(a1 + 40), (v19 >> 17) & 1);
  boringssl_context_set_ats_enforced(*(_QWORD *)(a1 + 40), *v5 & 1);
  boringssl_context_set_ats_minimum_rsa_key_size(*(_QWORD *)(a1 + 40), *((_QWORD *)a2 + 38));
  boringssl_context_set_ats_minimum_ecdsa_key_size(*(_QWORD *)(a1 + 40), *((_QWORD *)a2 + 39));
  boringssl_context_set_ats_minimum_signature_algorithm(*(_QWORD *)(a1 + 40), *((_DWORD *)a2 + 80));
  options = v4;
  if (*(_WORD *)(*(_QWORD *)(a1 + 48) + 56) == 772)
  {
    is_opaque = RSA_is_opaque();
    if ((*v5 & 0x40000000) != 0)
      v21 = ((*(unsigned int *)((char *)a2 + 361) | ((unint64_t)*((unsigned __int8 *)a2 + 365) << 32)) >> 29) & 1;
    else
      v21 = is_opaque;
    boringssl_context_set_certificate_compression(*(_QWORD *)(a1 + 40), v21);
    v22 = *(_QWORD *)(a1 + 40);
    if (((*v5 | ((unint64_t)*((unsigned __int8 *)a2 + 365) << 32)) & 0x200000000) != 0)
      v23 = 1;
    else
      v23 = RSA_is_opaque();
    boringssl_context_set_GREASE_enabled(v22, v23);
    enable_encrypted_client_hello = sec_protocol_options_get_enable_encrypted_client_hello(v4);
    v25 = *(_QWORD *)(a1 + 48);
    if (!v25)
      goto LABEL_56;
    WeakRetained = objc_loadWeakRetained((id *)(v25 + 16));
    if (!WeakRetained
      || (v27 = WeakRetained,
          v28 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16)),
          v29 = v28[475],
          v28,
          v27,
          (v29 & 1) == 0))
    {
      v30 = *(_QWORD *)(a1 + 48);
      if (!v30)
        goto LABEL_56;
      v31 = objc_loadWeakRetained((id *)(v30 + 16));
      if (v31)
      {
        v32 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16));
        v33 = (v32[475] & 1) == 0;

      }
      else
      {
        v33 = 1;
      }

      if (v33)
      {
LABEL_56:
        if (g_boringssl_log)
        {
          v34 = (id)g_boringssl_log;
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
          {
            v108 = *(_QWORD *)(a1 + 48);
            if (v108)
            {
              v128 = (char *)objc_loadWeakRetained((id *)(v108 + 16));
              v129 = *(_QWORD *)(a1 + 48);
              v213 = v128;
              if (v128)
              {
                v220 = v129 != 0;
                if (v129)
                {
                  v128 = (char *)objc_loadWeakRetained((id *)(v129 + 16));
                  v129 = *(_QWORD *)(a1 + 48);
                }
                else
                {
                  v128 = 0;
                }
                v111 = v128 + 391;
              }
              else
              {
                v220 = 0;
                v111 = &unk_1B50022E3;
              }
              v211 = v128;
              if (v129)
              {
                v109 = objc_loadWeakRetained((id *)(v129 + 16));
                v110 = 0;
              }
              else
              {
                v109 = 0;
                v110 = 1;
              }
            }
            else
            {
              v220 = 0;
              v109 = 0;
              v110 = 1;
              v111 = &unk_1B50022E3;
            }
            v228 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
            v229 = 1024;
            v207 = "disabled";
            v230 = 1787;
            v231 = 2082;
            *(_DWORD *)buf = 136447234;
            if (enable_encrypted_client_hello)
              v207 = "enabled";
            v232 = v111;
            v233 = 2048;
            v234 = v109;
            v235 = 2080;
            *(_QWORD *)v236 = v207;
            _os_log_debug_impl(&dword_1B4F6D000, v34, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] ECH is %s", buf, 0x30u);
            if ((v110 & 1) == 0)

            if (v220)
            if (v108)

          }
        }
      }
    }
    boringssl_context_set_ech_grease_enabled(*(_QWORD *)(a1 + 40), enable_encrypted_client_hello);
  }
  v249 = 0;
  v250 = 0;
  v35 = (const unsigned __int8 *)(a2 + 12);
  v36 = (unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 252);
  if (*(_OWORD *)(a2 + 12) == 0)
    MEMORY[0x1B5E45900](v36, v35);
  else
    uuid_copy(v36, v35);
  v37 = (char *)*((_QWORD *)a2 + 2);
  if (v37)
    v38 = boringssl_context_set_experiment_identifier(*(_QWORD *)(a1 + 40), v37);
  else
    v38 = 1;
  if (*((_QWORD *)a2 + 30) && *((_QWORD *)a2 + 31))
  {
    v39 = MEMORY[0x1B5E45624]();
    v40 = *(_QWORD *)(a1 + 48);
    v41 = *(void **)(v40 + 216);
    *(_QWORD *)(v40 + 216) = v39;

    objc_storeStrong((id *)(*(_QWORD *)(a1 + 48) + 208), *((id *)a2 + 31));
  }
  v42 = *v5;
  if ((*v5 & 0x10000000) != 0)
  {
    if ((v42 & 0x4000000) != 0)
      v44 = 3;
    else
      v44 = (v42 >> 27) & ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 556) & 0x10) >> 4);
    v43 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v43 = *(_QWORD *)(a1 + 40);
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 556) & 0x10) != 0)
      v44 = 0;
    else
      v44 = 3;
  }
  boringssl_context_set_verify_mode(v43, v44);
  v45 = (char *)*((_QWORD *)a2 + 1);
  if (v45)
  {
    v46 = strlen(*((const char **)a2 + 1));
    boringssl_session_set_peer_hostname(*(_QWORD *)(a1 + 40), v45, v46);
  }
  if ((*v5 & 0x20) != 0)
  {
    v47 = *(_QWORD *)(a1 + 40);
    if (v47)
    {
      if (*(_DWORD *)v47 == -1252936367)
      {
        v48 = *(_QWORD *)(v47 + 8);
        if (v48)
        {
          v49 = *(_QWORD *)(v48 + 400);
          if (v49)
          {
            if (!SSL_set_tlsext_host_name(v49, 0))
            {
              v69 = objc_loadWeakRetained((id *)(v48 + 16));
              if (!v69
                || (v70 = v69,
                    v71 = objc_loadWeakRetained((id *)(v48 + 16)),
                    v72 = v71[475],
                    v71,
                    v70,
                    (v72 & 1) == 0))
              {
                v73 = objc_loadWeakRetained((id *)(v48 + 16));
                if (v73)
                {
                  v74 = objc_loadWeakRetained((id *)(v48 + 16));
                  v75 = (v74[475] & 1) == 0;

                }
                else
                {
                  v75 = 1;
                }

                if (v75)
                {
                  if (g_boringssl_log)
                  {
                    v130 = (id)g_boringssl_log;
                    if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
                      __boringssl_session_apply_protocol_options_for_transport_block_invoke_cold_1(v48, v130);

                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v50 = (void *)*((_QWORD *)a2 + 24);
  if (v50)
  {
    v51 = boringssl_session_state_create_from_dispatch_data(*(void **)(a1 + 48), v50);
    v52 = boringssl_session_set_session_state(*(_QWORD *)(a1 + 40), v51);
    v53 = *(_QWORD *)(a1 + 48);
    if (!v53)
      goto LABEL_95;
    v54 = objc_loadWeakRetained((id *)(v53 + 16));
    if (!v54
      || (v55 = v54,
          v56 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16)),
          v57 = v56[475],
          v56,
          v55,
          (v57 & 1) == 0))
    {
      v58 = *(_QWORD *)(a1 + 48);
      if (!v58)
        goto LABEL_95;
      v59 = objc_loadWeakRetained((id *)(v58 + 16));
      if (v59)
      {
        v60 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16));
        v61 = (v60[475] & 1) == 0;

      }
      else
      {
        v61 = 1;
      }

      if (v61)
      {
LABEL_95:
        if (g_boringssl_log)
        {
          v62 = (id)g_boringssl_log;
          if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
          {
            v63 = *(_QWORD *)(a1 + 48);
            v219 = v63;
            if (v63)
            {
              v64 = (char *)objc_loadWeakRetained((id *)(v63 + 16));
              v65 = *(_QWORD *)(a1 + 48);
              v211 = v64;
              if (v64)
              {
                v214 = v65 != 0;
                if (v65)
                {
                  v64 = (char *)objc_loadWeakRetained((id *)(v65 + 16));
                  v65 = *(_QWORD *)(a1 + 48);
                }
                else
                {
                  v64 = 0;
                }
                v68 = v64 + 391;
              }
              else
              {
                v214 = 0;
                v68 = &unk_1B50022E3;
              }
              v209 = v64;
              if (v65)
              {
                v66 = objc_loadWeakRetained((id *)(v65 + 16));
                v67 = 0;
              }
              else
              {
                v66 = 0;
                v67 = 1;
              }
            }
            else
            {
              v214 = 0;
              v66 = 0;
              v67 = 1;
              v68 = &unk_1B50022E3;
            }
            v228 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
            v229 = 1024;
            v76 = "not set";
            v230 = 1836;
            *(_DWORD *)buf = 136447234;
            v231 = 2082;
            if (v52)
              v76 = "set";
            v232 = v68;
            v233 = 2048;
            v234 = v66;
            v235 = 2082;
            *(_QWORD *)v236 = v76;
            _os_log_impl(&dword_1B4F6D000, v62, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Session state %{public}s.", buf, 0x30u);
            if ((v67 & 1) == 0)

            if (v214)
            if (v219)

          }
        }
      }
    }

  }
  v77 = *((id *)a2 + 6);
  if (v77)
    boringssl_context_set_alpn_protocol_list(*(_QWORD *)(a1 + 40), v77, *(_DWORD *)(a1 + 56));
  v78 = *v5 | ((unint64_t)*((unsigned __int8 *)a2 + 365) << 32);
  if ((v78 & 0x800000000) != 0)
    boringssl_context_set_allow_unknown_alpn_protos(*(_QWORD *)(a1 + 40), (v78 >> 34) & 1);
  v79 = (void *)*((_QWORD *)a2 + 7);
  if (v79)
    v38 &= boringssl_context_set_identity(*(_QWORD *)(a1 + 40), v79);
  v80 = (void *)*((_QWORD *)a2 + 8);
  if (v80)
  {
    v81 = (void *)*((_QWORD *)a2 + 27);
    if (v81)
    {
      v82 = (void *)*((_QWORD *)a2 + 25);
      if (v82)
      {
        v83 = (void *)*((_QWORD *)a2 + 26);
        if (v83)
          v38 &= boringssl_context_set_external_identity(*(_QWORD *)(a1 + 40), v80, v82, v83, v81);
      }
    }
  }
  v84 = xpc_array_create(0, 0);
  v85 = (void *)*((_QWORD *)a2 + 9);
  if (v85)
  {
    v86 = v85;
    v87 = boringssl_psk_cache_create_with_context(*(void **)(a1 + 48));
    v88 = *(_QWORD *)(a1 + 48);
    v89 = *(void **)(v88 + 40);
    *(_QWORD *)(v88 + 40) = v87;

    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = __boringssl_session_apply_protocol_options_for_transport_block_invoke_12;
    applier[3] = &__block_descriptor_40_e36_B24__0Q8__NSObject_OS_xpc_object__16lu32l8;
    applier[4] = *(_QWORD *)(a1 + 48);
    xpc_array_apply(v86, applier);
    if (!xpc_array_get_count(v86))
    {
LABEL_212:
      v137 = *((_QWORD *)a2 + 32);
      if (v137)
      {
        v138 = (void *)*((_QWORD *)a2 + 33);
        if (v138)
          boringssl_psk_cache_set_selection_block_and_queue(*(void **)(*(_QWORD *)(a1 + 48) + 40), v137, v138);
      }

      goto LABEL_216;
    }
    if (boringssl_context_get_min_protocol_version(*(_QWORD *)(a1 + 40)) == 772)
    {
      tls13_external_psk_enabled = boringssl_config_get_tls13_external_psk_enabled();
      v91 = *(_QWORD *)(a1 + 48);
      if (tls13_external_psk_enabled)
      {
        if (!v91)
          goto LABEL_155;
        v92 = objc_loadWeakRetained((id *)(v91 + 16));
        if (!v92
          || (v93 = v92,
              v94 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16)),
              v95 = v94[475],
              v94,
              v93,
              (v95 & 1) == 0))
        {
          v96 = *(_QWORD *)(a1 + 48);
          if (!v96)
            goto LABEL_155;
          v97 = objc_loadWeakRetained((id *)(v96 + 16));
          if (v97)
          {
            v98 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16));
            v99 = (v98[475] & 1) == 0;

          }
          else
          {
            v99 = 1;
          }

          if (v99)
          {
LABEL_155:
            if (g_boringssl_log)
            {
              v112 = (id)g_boringssl_log;
              if (os_log_type_enabled(v112, OS_LOG_TYPE_INFO))
              {
                v221 = v77;
                v113 = *(_QWORD *)(a1 + 48);
                if (v113)
                {
                  v114 = *(_QWORD *)(a1 + 48);
                  v115 = (char *)objc_loadWeakRetained((id *)(v113 + 16));
                  v116 = *(_QWORD *)(a1 + 48);
                  v211 = v115;
                  if (v115)
                  {
                    v215 = v116 != 0;
                    if (v116)
                    {
                      v115 = (char *)objc_loadWeakRetained((id *)(v116 + 16));
                      v116 = *(_QWORD *)(a1 + 48);
                    }
                    else
                    {
                      v115 = 0;
                    }
                    v124 = v115 + 391;
                  }
                  else
                  {
                    v215 = 0;
                    v124 = &unk_1B50022E3;
                  }
                  v209 = v115;
                  if (v116)
                  {
                    v131 = v124;
                    v132 = objc_loadWeakRetained((id *)(v116 + 16));
                    v124 = v131;
                    v122 = v132;
                    v123 = 0;
                  }
                  else
                  {
                    v122 = 0;
                    v123 = 1;
                  }
                }
                else
                {
                  v114 = 0;
                  v215 = 0;
                  v122 = 0;
                  v123 = 1;
                  v124 = &unk_1B50022E3;
                }
                *(_DWORD *)buf = 136446978;
                v228 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
                v229 = 1024;
                v230 = 1912;
                v231 = 2082;
                v232 = v124;
                v233 = 2048;
                v234 = v122;
                _os_log_impl(&dword_1B4F6D000, v112, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Using TLS 1.3 external PSK callback", buf, 0x26u);
                if ((v123 & 1) == 0)

                if (v215)
                v77 = v221;
                if (v114)

              }
            }
          }
        }
        SSL_set_psk_client13_ext_callback(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 400), (uint64_t)boringssl_session_psk_client13_ext_callback_handler);
        goto LABEL_210;
      }
      if (!v91)
        goto LABEL_163;
      v100 = objc_loadWeakRetained((id *)(v91 + 16));
      if (!v100
        || (v101 = v100,
            v102 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16)),
            v103 = v102[475],
            v102,
            v101,
            (v103 & 1) == 0))
      {
        v104 = *(_QWORD *)(a1 + 48);
        if (!v104)
          goto LABEL_163;
        v105 = objc_loadWeakRetained((id *)(v104 + 16));
        if (v105)
        {
          v106 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16));
          v107 = (v106[475] & 1) == 0;

        }
        else
        {
          v107 = 1;
        }

        if (v107)
        {
LABEL_163:
          if (g_boringssl_log)
          {
            v117 = (id)g_boringssl_log;
            if (os_log_type_enabled(v117, OS_LOG_TYPE_INFO))
            {
              v222 = v77;
              v118 = *(_QWORD *)(a1 + 48);
              if (v118)
              {
                v119 = *(_QWORD *)(a1 + 48);
                v120 = (char *)objc_loadWeakRetained((id *)(v118 + 16));
                v121 = *(_QWORD *)(a1 + 48);
                v211 = v120;
                if (v120)
                {
                  v216 = v121 != 0;
                  if (v121)
                  {
                    v120 = (char *)objc_loadWeakRetained((id *)(v121 + 16));
                    v121 = *(_QWORD *)(a1 + 48);
                  }
                  else
                  {
                    v120 = 0;
                  }
                  v127 = v120 + 391;
                }
                else
                {
                  v216 = 0;
                  v127 = &unk_1B50022E3;
                }
                v209 = v120;
                if (v121)
                {
                  v133 = v127;
                  v134 = objc_loadWeakRetained((id *)(v121 + 16));
                  v127 = v133;
                  v125 = v134;
                  v126 = 0;
                }
                else
                {
                  v125 = 0;
                  v126 = 1;
                }
              }
              else
              {
                v119 = 0;
                v216 = 0;
                v125 = 0;
                v126 = 1;
                v127 = &unk_1B50022E3;
              }
              *(_DWORD *)buf = 136446978;
              v228 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
              v229 = 1024;
              v230 = 1916;
              v231 = 2082;
              v232 = v127;
              v233 = 2048;
              v234 = v125;
              _os_log_impl(&dword_1B4F6D000, v117, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] TLS 1.3 external PSK callback is not enabled", buf, 0x26u);
              if ((v126 & 1) == 0)

              if (v216)
              v77 = v222;
              if (v119)

            }
          }
        }
      }
    }
    SSL_set_psk_server_callback(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 400), (uint64_t)boringssl_session_server_psk_callback_handler);
    SSL_set_psk_client_callback(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 400), (uint64_t)boringssl_session_client_psk_callback_handler);
    for (i = 0; i != 4; ++i)
      xpc_array_set_uint64(v84, 0xFFFFFFFFFFFFFFFFLL, (unsigned __int16)g_boringssl_private_key_methods_block_invoke_supported_psk_ciphersuites[i]);
LABEL_210:
    v136 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 400);
    if (v136)
      SSL_set_options(v136, 0x400000u);
    goto LABEL_212;
  }
LABEL_216:
  v139 = *((_QWORD *)a2 + 10);
  if (v139)
  {
    size = dispatch_data_get_size(v139);
    v141 = malloc_type_malloc(size + 1, 0xC6B76924uLL);
    bzero(v141, size + 1);
    v142 = boringssl_helper_dispatch_data_copyout(*((NSObject **)a2 + 10), (uint64_t)v141, size);
    v143 = *(_QWORD *)(a1 + 48);
    if (v142 == size)
    {
      SSL_use_psk_identity_hint(*(_QWORD *)(v143 + 400), (char *)v141);
    }
    else
    {
      if (!v143)
        goto LABEL_228;
      v144 = objc_loadWeakRetained((id *)(v143 + 16));
      if (!v144
        || (v145 = v144,
            v146 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16)),
            v147 = v146[475],
            v146,
            v145,
            (v147 & 1) == 0))
      {
        v148 = *(_QWORD *)(a1 + 48);
        if (!v148)
          goto LABEL_228;
        v149 = objc_loadWeakRetained((id *)(v148 + 16));
        if (v149)
        {
          v150 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16));
          v151 = (v150[475] & 1) == 0;

        }
        else
        {
          v151 = 1;
        }

        if (v151)
        {
LABEL_228:
          if (g_boringssl_log)
          {
            v152 = (id)g_boringssl_log;
            if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
            {
              v224 = v77;
              v201 = *(_QWORD *)(a1 + 48);
              if (v201)
              {
                v205 = (char *)objc_loadWeakRetained((id *)(v201 + 16));
                v206 = *(_QWORD *)(a1 + 48);
                v211 = v205;
                if (v205)
                {
                  v218 = v206 != 0;
                  if (v206)
                  {
                    v205 = (char *)objc_loadWeakRetained((id *)(v206 + 16));
                    v206 = *(_QWORD *)(a1 + 48);
                  }
                  else
                  {
                    v205 = 0;
                  }
                  v204 = v205 + 391;
                }
                else
                {
                  v218 = 0;
                  v204 = &unk_1B50022E3;
                }
                v209 = v205;
                if (v206)
                {
                  v202 = objc_loadWeakRetained((id *)(v206 + 16));
                  v203 = 0;
                }
                else
                {
                  v202 = 0;
                  v203 = 1;
                }
              }
              else
              {
                v218 = 0;
                v202 = 0;
                v203 = 1;
                v204 = &unk_1B50022E3;
              }
              *(_DWORD *)buf = 136446978;
              v228 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
              v229 = 1024;
              v230 = 1963;
              v231 = 2082;
              v232 = v204;
              v233 = 2048;
              v234 = v202;
              _os_log_error_impl(&dword_1B4F6D000, v152, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] Failed to copy PSK hint data", buf, 0x26u);
              if ((v203 & 1) == 0)

              if (v218)
              v77 = v224;
              if (v201)

            }
          }
        }
      }
    }
    if (v141)
      free(v141);
  }
  v153 = (void *)*((_QWORD *)a2 + 17);
  if (v153)
  {
    v38 &= boringssl_context_set_quic_transport_parameters(*(_QWORD *)(a1 + 40), v153);
    v154 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 400);
    quic_use_legacy_codepoint = sec_protocol_options_get_quic_use_legacy_codepoint(options);
    SSL_set_quic_use_legacy_codepoint(v154, quic_use_legacy_codepoint);
  }
  v156 = *((id *)a2 + 5);
  if (v156)
  {
    v157 = v156;
    if (v84)
    {
      boringssl_helper_xpc_array_union(v156, v84);
      v158 = objc_claimAutoreleasedReturnValue();

      v157 = (void *)v158;
    }
    boringssl_context_set_ciphersuites_from_list(*(_QWORD *)(a1 + 40), v157);
  }
  else
  {
    if (v84)
      boringssl_context_set_ciphersuites_from_list(*(_QWORD *)(a1 + 40), v84);
    v157 = 0;
  }
  v159 = *((id *)a2 + 29);
  if (v159)
    boringssl_context_set_key_exchange_groups(*(_QWORD *)(a1 + 40), v159);
  if (*((_QWORD *)a2 + 15))
  {
    v160 = MEMORY[0x1B5E45624]();
    v161 = *(_QWORD *)(a1 + 48);
    v162 = *(void **)(v161 + 120);
    *(_QWORD *)(v161 + 120) = v160;

    objc_storeStrong((id *)(*(_QWORD *)(a1 + 48) + 128), *((id *)a2 + 16));
  }
  if (*((_QWORD *)a2 + 13))
  {
    v163 = MEMORY[0x1B5E45624]();
    v164 = *(_QWORD *)(a1 + 48);
    v165 = *(void **)(v164 + 136);
    *(_QWORD *)(v164 + 136) = v163;

    objc_storeStrong((id *)(*(_QWORD *)(a1 + 48) + 144), *((id *)a2 + 14));
  }
  if (*((_QWORD *)a2 + 11))
  {
    v166 = MEMORY[0x1B5E45624]();
    v167 = *(_QWORD *)(a1 + 48);
    v168 = *(void **)(v167 + 152);
    *(_QWORD *)(v167 + 152) = v166;

    objc_storeStrong((id *)(*(_QWORD *)(a1 + 48) + 160), *((id *)a2 + 12));
  }
  if (*((_QWORD *)a2 + 22))
  {
    v169 = MEMORY[0x1B5E45624]();
    v170 = *(_QWORD *)(a1 + 48);
    v171 = *(void **)(v170 + 168);
    *(_QWORD *)(v170 + 168) = v169;

    objc_storeStrong((id *)(*(_QWORD *)(a1 + 48) + 176), *((id *)a2 + 23));
  }
  objc_storeStrong((id *)(*(_QWORD *)(a1 + 48) + 512), *(id *)(a1 + 32));
  v172 = (const __CFArray *)*((_QWORD *)a2 + 35);
  v173 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (v172)
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 368) = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v172);
    v38 &= boringssl_context_set_raw_public_key_certificate(*(_DWORD **)(a1 + 40), *((CFArrayRef *)a2 + 35), 1);
  }
  v174 = (const __CFArray *)*((_QWORD *)a2 + 36);
  if (v174)
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 376) = CFArrayCreateCopy(*v173, v174);
    v38 &= boringssl_context_set_raw_public_key_certificate(*(_DWORD **)(a1 + 40), *((CFArrayRef *)a2 + 36), 0);
  }
  *(_BYTE *)(*(_QWORD *)(a1 + 48) + 384) = *((_BYTE *)a2 + 296);
  *(_BYTE *)(*(_QWORD *)(a1 + 48) + 385) = *((_BYTE *)a2 + 297);
  a2 = (unsigned __int16 *)(v38 & boringssl_context_set_ticket_request(*(_QWORD *)(a1 + 40), *(_BYTE *)(*(_QWORD *)(a1 + 48) + 384), *(_BYTE *)(*(_QWORD *)(a1 + 48) + 385)));
  if ((_DWORD)a2 == 1)
  {
    v175 = *(_QWORD *)(a1 + 48);
    if (!v175)
      goto LABEL_266;
    v176 = objc_loadWeakRetained((id *)(v175 + 16));
    if (!v176
      || (v177 = v176,
          v178 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16)),
          v179 = v178[475],
          v178,
          v177,
          (v179 & 1) == 0))
    {
      v180 = *(_QWORD *)(a1 + 48);
      if (!v180)
        goto LABEL_266;
      v181 = objc_loadWeakRetained((id *)(v180 + 16));
      if (v181)
      {
        v182 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16));
        v183 = (v182[475] & 1) == 0;

      }
      else
      {
        v183 = 1;
      }

      if (v183)
      {
LABEL_266:
        if (g_boringssl_log)
        {
          v184 = (id)g_boringssl_log;
          if (os_log_type_enabled(v184, OS_LOG_TYPE_DEFAULT))
          {
            v185 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 48) + 16));
            v186 = *(_QWORD *)(a1 + 48);
            v217 = v185;
            v223 = v77;
            if (v185)
            {
              v187 = v186 != 0;
              if (v186)
              {
                v188 = (char *)objc_loadWeakRetained((id *)(v186 + 16));
                v186 = *(_QWORD *)(a1 + 48);
              }
              else
              {
                v188 = 0;
              }
              v208 = v188;
              v210 = v188 + 391;
              v212 = v187;
            }
            else
            {
              v212 = 0;
              v210 = &unk_1B50022E3;
            }
            v189 = objc_loadWeakRetained((id *)(v186 + 16));
            v190 = *(_QWORD *)(a1 + 48);
            v191 = *(unsigned __int16 *)(v190 + 58);
            v192 = *(unsigned __int16 *)(v190 + 56);
            v193 = objc_loadWeakRetained((id *)(v190 + 16));
            redacted_identity = nw_protocol_boringssl_get_redacted_identity((uint64_t)v193, *(const char **)(*(_QWORD *)(a1 + 48) + 80));
            v195 = *(unsigned __int8 **)(a1 + 48);
            v196 = (v195[557] >> 4) & 1;
            v197 = v195[556] >> 7;
            v198 = (v195[559] >> 1) & 1;
            v199 = (v195[559] >> 3) & 1;
            LODWORD(v195) = (v195[560] >> 3) & 1;
            *(_DWORD *)buf = 136449026;
            v228 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
            v229 = 1024;
            v230 = 2040;
            v231 = 2082;
            v232 = v210;
            v233 = 2048;
            v234 = v189;
            v235 = 1024;
            *(_DWORD *)v236 = v191;
            *(_WORD *)&v236[4] = 1024;
            *(_DWORD *)&v236[6] = v192;
            v237 = 2082;
            v238 = redacted_identity;
            v239 = 1024;
            v240 = v196;
            v241 = 1024;
            v242 = v197;
            v243 = 1024;
            v244 = v198;
            v245 = 1024;
            v246 = v199;
            v247 = 1024;
            v248 = (int)v195;
            _os_log_impl(&dword_1B4F6D000, v184, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] TLS configured [min_version(0x%04x) max_version(0x%04x) name(%{public}s) tickets(%{BOOL}d) false_start(%{BOOL}d) enforce_ev(%{BOOL}d) enforce_ats(%{BOOL}d) ech(%{BOOL}d)]", buf, 0x5Au);

            if (v212)
            v77 = v223;
          }

        }
      }
    }
  }

  v4 = options;
LABEL_279:

  return a2;
}

uint64_t boringssl_context_set_verify_mode(uint64_t a1, int a2)
{
  char *v2;
  uint64_t v3;
  id v5;
  void *v6;
  unsigned __int8 *v7;
  id v8;
  _BYTE *v9;
  _BOOL4 v10;
  id WeakRetained;
  void *v13;
  _BYTE *v14;
  char v15;
  id v16;
  _BYTE *v17;
  _BOOL4 v18;
  id v19;
  void *v20;
  _BYTE *v21;
  char v22;
  id v23;
  _BYTE *v24;
  _BOOL4 v25;
  NSObject *v26;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  const char *v32;
  uint64_t v33;
  int v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  void *v39;
  __int16 v40;
  id v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3 || !*(_QWORD *)(v3 + 408))
    return 0xFFFFFFFFLL;
  if ((*(_BYTE *)(v3 + 556) & 0x10) != 0)
  {
    if (a2 == 3)
    {
      WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
      if (WeakRetained)
      {
        v13 = WeakRetained;
        v14 = objc_loadWeakRetained((id *)(v3 + 16));
        v15 = v14[475];

        if ((v15 & 1) != 0)
          goto LABEL_51;
      }
      v16 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v16)
      {
        v17 = objc_loadWeakRetained((id *)(v3 + 16));
        v18 = (v17[475] & 1) == 0;

      }
      else
      {
        v18 = 1;
      }

      if (!v18 || !g_boringssl_log)
        goto LABEL_51;
      v26 = (id)g_boringssl_log;
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        goto LABEL_50;
      v27 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v27)
      {
        v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
        v28 = v2 + 391;
      }
      else
      {
        v28 = &unk_1B50022E3;
      }
      v31 = objc_loadWeakRetained((id *)(v3 + 16));
      v34 = 136446978;
      v35 = "boringssl_context_set_verify_mode";
      v36 = 1024;
      v37 = 593;
      v38 = 2082;
      v39 = v28;
      v40 = 2048;
      v41 = v31;
      v32 = "%{public}s(%d) %{public}s[%p] Requiring client cert";
    }
    else if (a2 == 1)
    {
      v19 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v19)
      {
        v20 = v19;
        v21 = objc_loadWeakRetained((id *)(v3 + 16));
        v22 = v21[475];

        if ((v22 & 1) != 0)
          goto LABEL_51;
      }
      v23 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v23)
      {
        v24 = objc_loadWeakRetained((id *)(v3 + 16));
        v25 = (v24[475] & 1) == 0;

      }
      else
      {
        v25 = 1;
      }

      if (!v25 || !g_boringssl_log)
        goto LABEL_51;
      v26 = (id)g_boringssl_log;
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        goto LABEL_50;
      v27 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v27)
      {
        v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
        v29 = v2 + 391;
      }
      else
      {
        v29 = &unk_1B50022E3;
      }
      v31 = objc_loadWeakRetained((id *)(v3 + 16));
      v34 = 136446978;
      v35 = "boringssl_context_set_verify_mode";
      v36 = 1024;
      v37 = 597;
      v38 = 2082;
      v39 = v29;
      v40 = 2048;
      v41 = v31;
      v32 = "%{public}s(%d) %{public}s[%p] Will request optional client cert";
    }
    else
    {
      if (a2)
        goto LABEL_51;
      v5 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v5)
      {
        v6 = v5;
        v7 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16));
        v2 = (char *)v7[475];

        if ((v2 & 1) != 0)
          goto LABEL_51;
      }
      v8 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v8)
      {
        v9 = objc_loadWeakRetained((id *)(v3 + 16));
        v10 = (v9[475] & 1) == 0;

      }
      else
      {
        v10 = 1;
      }

      if (!v10 || !g_boringssl_log)
        goto LABEL_51;
      v26 = (id)g_boringssl_log;
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        goto LABEL_50;
      v27 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v27)
      {
        v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
        v30 = v2 + 391;
      }
      else
      {
        v30 = &unk_1B50022E3;
      }
      v31 = objc_loadWeakRetained((id *)(v3 + 16));
      v34 = 136446978;
      v35 = "boringssl_context_set_verify_mode";
      v36 = 1024;
      v37 = 589;
      v38 = 2082;
      v39 = v30;
      v40 = 2048;
      v41 = v31;
      v32 = "%{public}s(%d) %{public}s[%p] Not requesting client cert";
    }
    _os_log_impl(&dword_1B4F6D000, v26, OS_LOG_TYPE_DEFAULT, v32, (uint8_t *)&v34, 0x26u);

    if (v27)
LABEL_50:

  }
LABEL_51:
  v33 = *(_QWORD *)(v3 + 400);
  if (v33)
    SSL_set_custom_verify(v33, a2, (uint64_t)boringssl_context_certificate_verify_callback);
  else
    SSL_CTX_set_custom_verify(*(_QWORD *)(v3 + 408), a2, (uint64_t)boringssl_context_certificate_verify_callback);
  return 0;
}

const char *nw_protocol_boringssl_get_redacted_identity(uint64_t a1, const char *a2)
{
  const char *v2;

  if (!a1)
    return "redacted";
  v2 = "nil";
  if (a2)
    v2 = a2;
  if ((*(_BYTE *)(a1 + 475) & 2) != 0)
    return "redacted";
  else
    return v2;
}

uint64_t boringssl_session_set_early_data_enabled(uint64_t result, int a2)
{
  uint64_t v2;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      v2 = *(_QWORD *)(result + 8);
      if (v2)
      {
        result = *(_QWORD *)(v2 + 400);
        if (result)
        {
          *(_BYTE *)(v2 + 559) = *(_BYTE *)(v2 + 559) & 0xFE | a2;
          return SSL_set_early_data_enabled(result, a2);
        }
      }
    }
  }
  return result;
}

id boringssl_helper_xpc_array_union(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  id v6;
  xpc_object_t v7;
  uint64_t v8;
  _QWORD v10[5];
  _QWORD applier[5];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t (*v15)(uint64_t, uint64_t);
  void (*v16)(uint64_t);
  id v17;

  v3 = a1;
  v4 = a2;
  v5 = v4;
  v6 = 0;
  if (v3 && v4)
  {
    v12 = 0;
    v13 = &v12;
    v14 = 0x3032000000;
    v15 = __Block_byref_object_copy__1;
    v16 = __Block_byref_object_dispose__1;
    v17 = (id)0xAAAAAAAAAAAAAAAALL;
    v7 = xpc_array_create(0, 0);
    v8 = MEMORY[0x1E0C809B0];
    v17 = v7;
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = __boringssl_helper_xpc_array_union_block_invoke;
    applier[3] = &unk_1E686F4E8;
    applier[4] = &v12;
    xpc_array_apply(v3, applier);
    v10[0] = v8;
    v10[1] = 3221225472;
    v10[2] = __boringssl_helper_xpc_array_union_block_invoke_2;
    v10[3] = &unk_1E686F4E8;
    v10[4] = &v12;
    xpc_array_apply(v5, v10);
    v6 = (id)v13[5];
    _Block_object_dispose(&v12, 8);

  }
  return v6;
}

void sub_1B4FACB68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL boringssl_context_set_ticket_request(_BOOL8 result, char a2, char a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v3 = *(_QWORD *)(result + 8)) != 0)
    {
      v4 = *(_QWORD *)(v3 + 400);
      if (v4)
        v5 = SSL_use_ticket_request(v4, a2, a3);
      else
        v5 = SSL_CTX_use_ticket_request(*(_QWORD *)(v3 + 408), a2, a3);
      return v5 == 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t boringssl_context_set_session_ticket_enabled(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  char v4;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(v2 + 400);
  if (!v3)
    return 0xFFFFFFFFLL;
  if (a2)
  {
    SSL_clear_options(v3, 0x4000);
    v4 = 16;
  }
  else
  {
    SSL_set_options(v3, 0x4000u);
    v4 = 0;
  }
  result = 0;
  *(_BYTE *)(v2 + 557) = *(_BYTE *)(v2 + 557) & 0xEF | v4;
  return result;
}

uint64_t boringssl_context_set_sct_enable(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  char v6;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(v2 + 408);
  if (!v3)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = *(_QWORD *)(v2 + 400);
  if (a2)
    v6 = 4;
  else
    v6 = 0;
  *(_BYTE *)(v2 + 556) = *(_BYTE *)(v2 + 556) & 0xFB | v6;
  if (a2)
  {
    if (v5)
      SSL_enable_signed_cert_timestamps(v5);
    else
      SSL_CTX_enable_signed_cert_timestamps(v3);
    return 0;
  }
  return result;
}

uint64_t boringssl_context_set_resumption(uint64_t a1, char a2)
{
  uint64_t v2;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
    result = 0;
  else
    result = 0xFFFFFFFFLL;
  if (v2)
  {
    if ((a2 & 1) == 0)
    {
      SSL_CTX_set_session_cache_mode(*(_QWORD *)(v2 + 408), 0);
      return 0;
    }
  }
  return result;
}

uint64_t boringssl_context_set_renegotiation(uint64_t a1, int a2)
{
  uint64_t v2;
  bssl *v3;
  uint64_t v4;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = *(bssl **)(v2 + 400);
  if (!v3)
    return 0xFFFFFFFFLL;
  if (a2)
    v4 = 2;
  else
    v4 = 0;
  SSL_set_renegotiate_mode(v3, (ssl_st *)v4);
  return 0;
}

void bssl::ssl_maybe_shed_handshake_config(bssl *this, ssl_st *a2)
{
  uint64_t v2;
  STACK ***v3;

  if (!*(_QWORD *)(*((_QWORD *)this + 6) + 280))
  {
    v3 = (STACK ***)((char *)this + 8);
    v2 = *((_QWORD *)this + 1);
    if (v2)
    {
      if ((*(_WORD *)(v2 + 313) & 0x80) != 0 && !bssl::ssl_can_renegotiate(this, a2))
        std::unique_ptr<bssl::SSL_CONFIG,bssl::internal::Deleter>::reset[abi:ne180100](v3, 0);
    }
  }
}

uint64_t boringssl_context_set_ocsp_enable(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  char v4;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(v2 + 400);
  if (!v3)
    return 0xFFFFFFFFLL;
  if (a2)
  {
    SSL_enable_ocsp_stapling(v3);
    v4 = 8;
  }
  else
  {
    v4 = 0;
  }
  result = 0;
  *(_BYTE *)(v2 + 556) = *(_BYTE *)(v2 + 556) & 0xF7 | v4;
  return result;
}

uint64_t boringssl_context_set_false_start(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  char v4;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(v2 + 400);
  if (!v3)
    return 0xFFFFFFFFLL;
  if (a2)
  {
    v4 = 0x80;
    SSL_set_mode(v3, 0x80u);
  }
  else
  {
    SSL_clear_mode(v3, 128);
    v4 = 0;
  }
  result = 0;
  *(_BYTE *)(v2 + 556) = *(_BYTE *)(v2 + 556) & 0x7F | v4;
  return result;
}

uint64_t boringssl_context_set_fallback(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  char v4;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(v2 + 400);
  if (!v3)
    return 0xFFFFFFFFLL;
  if (a2)
  {
    SSL_set_mode(v3, 0x400u);
    v4 = 64;
  }
  else
  {
    SSL_clear_mode(v3, 1024);
    v4 = 0;
  }
  result = 0;
  *(_BYTE *)(v2 + 556) = *(_BYTE *)(v2 + 556) & 0xBF | v4;
  return result;
}

uint64_t SSL_clear_mode(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = *(_DWORD *)(a1 + 148) & ~a2;
  *(_DWORD *)(a1 + 148) = v2;
  return v2;
}

uint64_t boringssl_context_set_enforce_ev(uint64_t result, int a2)
{
  uint64_t v2;
  char v3;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      v2 = *(_QWORD *)(result + 8);
      if (v2)
      {
        if (a2)
          v3 = 2;
        else
          v3 = 0;
        *(_BYTE *)(v2 + 559) = *(_BYTE *)(v2 + 559) & 0xFD | v3;
      }
    }
  }
  return result;
}

uint64_t boringssl_context_set_ech_grease_enabled(uint64_t result, int a2)
{
  uint64_t v2;
  char v3;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      v2 = *(_QWORD *)(result + 8);
      if (v2)
      {
        result = *(_QWORD *)(v2 + 400);
        if (result)
        {
          if (a2)
            v3 = 8;
          else
            v3 = 0;
          *(_BYTE *)(v2 + 560) = *(_BYTE *)(v2 + 560) & 0xF7 | v3;
          return SSL_set_enable_ech_grease(result, a2);
        }
      }
    }
  }
  return result;
}

void boringssl_context_set_ciphersuites_from_list(uint64_t a1, void *a2)
{
  id v3;
  size_t count;
  unsigned __int16 *v5;
  id v6;
  _QWORD applier[4];
  id v8;
  unsigned __int16 *v9;

  v3 = a2;
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      if (v3)
      {
        if (*(_QWORD *)(a1 + 8))
        {
          v6 = v3;
          count = xpc_array_get_count(v3);
          v5 = (unsigned __int16 *)malloc_type_malloc(2 * count, 0x1000040BDFB0063uLL);
          v3 = v6;
          if (v5)
          {
            applier[0] = MEMORY[0x1E0C809B0];
            applier[1] = 3221225472;
            applier[2] = __boringssl_context_set_ciphersuites_from_list_block_invoke;
            applier[3] = &unk_1E6878F88;
            v8 = v6;
            v9 = v5;
            xpc_array_apply(v8, applier);
            if (count)
              boringssl_context_set_cipher_suites(a1, v5, count);
            free(v5);

            v3 = v6;
          }
        }
      }
    }
  }

}

uint64_t boringssl_context_set_certificate_compression(uint64_t result, int a2)
{
  uint64_t v2;
  BOOL v3;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      v2 = *(_QWORD *)(result + 8);
      result = v2 != 0;
      if (v2)
        v3 = a2 == 0;
      else
        v3 = 1;
      if (!v3)
      {
        result = *(_QWORD *)(v2 + 408);
        if (result)
        {
          *(_BYTE *)(v2 + 559) |= 0x20u;
          return SSL_CTX_add_cert_compression_alg(result, 1, (uint64_t)boringssl_context_zlib_compress_data, (uint64_t)boringssl_context_zlib_uncompress_data) == 1;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void boringssl_context_set_ats_minimum_signature_algorithm(uint64_t a1, int a2)
{
  char *v2;
  uint64_t v3;
  id WeakRetained;
  void *v6;
  unsigned __int8 *v7;
  id v8;
  _BYTE *v9;
  _BOOL4 v10;
  NSObject *v11;
  id v12;
  void *v13;
  id v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  void *v20;
  __int16 v21;
  id v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      v3 = *(_QWORD *)(a1 + 8);
      if (v3)
      {
        WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
        if (!WeakRetained
          || (v6 = WeakRetained,
              v7 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16)),
              v2 = (char *)v7[475],
              v7,
              v6,
              (v2 & 1) == 0))
        {
          v8 = objc_loadWeakRetained((id *)(v3 + 16));
          if (v8)
          {
            v9 = objc_loadWeakRetained((id *)(v3 + 16));
            v10 = (v9[475] & 1) == 0;

          }
          else
          {
            v10 = 1;
          }

          if (v10)
          {
            if (g_boringssl_log)
            {
              v11 = (id)g_boringssl_log;
              if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
              {
                v12 = objc_loadWeakRetained((id *)(v3 + 16));
                if (v12)
                {
                  v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
                  v13 = v2 + 391;
                }
                else
                {
                  v13 = &unk_1B50022E3;
                }
                v14 = objc_loadWeakRetained((id *)(v3 + 16));
                v15 = 136447234;
                v16 = "boringssl_context_set_ats_minimum_signature_algorithm";
                v17 = 1024;
                v18 = 680;
                v19 = 2082;
                v20 = v13;
                v21 = 2048;
                v22 = v14;
                v23 = 1026;
                v24 = a2;
                _os_log_impl(&dword_1B4F6D000, v11, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] set %{public}d", (uint8_t *)&v15, 0x2Cu);

                if (v12)
              }

            }
          }
        }
        *(_DWORD *)(v3 + 544) = a2;
      }
    }
  }
}

void boringssl_context_set_ats_minimum_rsa_key_size(uint64_t a1, uint64_t a2)
{
  char *v2;
  uint64_t v3;
  id WeakRetained;
  void *v6;
  unsigned __int8 *v7;
  id v8;
  _BYTE *v9;
  _BOOL4 v10;
  NSObject *v11;
  id v12;
  void *v13;
  id v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  void *v20;
  __int16 v21;
  id v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      v3 = *(_QWORD *)(a1 + 8);
      if (v3)
      {
        WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
        if (!WeakRetained
          || (v6 = WeakRetained,
              v7 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16)),
              v2 = (char *)v7[475],
              v7,
              v6,
              (v2 & 1) == 0))
        {
          v8 = objc_loadWeakRetained((id *)(v3 + 16));
          if (v8)
          {
            v9 = objc_loadWeakRetained((id *)(v3 + 16));
            v10 = (v9[475] & 1) == 0;

          }
          else
          {
            v10 = 1;
          }

          if (v10)
          {
            if (g_boringssl_log)
            {
              v11 = (id)g_boringssl_log;
              if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
              {
                v12 = objc_loadWeakRetained((id *)(v3 + 16));
                if (v12)
                {
                  v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
                  v13 = v2 + 391;
                }
                else
                {
                  v13 = &unk_1B50022E3;
                }
                v14 = objc_loadWeakRetained((id *)(v3 + 16));
                v15 = 136447234;
                v16 = "boringssl_context_set_ats_minimum_rsa_key_size";
                v17 = 1024;
                v18 = 661;
                v19 = 2082;
                v20 = v13;
                v21 = 2048;
                v22 = v14;
                v23 = 2050;
                v24 = a2;
                _os_log_impl(&dword_1B4F6D000, v11, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] set %{public}zu", (uint8_t *)&v15, 0x30u);

                if (v12)
              }

            }
          }
        }
        *(_QWORD *)(v3 + 528) = a2;
      }
    }
  }
}

void boringssl_context_set_ats_minimum_ecdsa_key_size(uint64_t a1, uint64_t a2)
{
  char *v2;
  uint64_t v3;
  id WeakRetained;
  void *v6;
  unsigned __int8 *v7;
  id v8;
  _BYTE *v9;
  _BOOL4 v10;
  NSObject *v11;
  id v12;
  void *v13;
  id v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  void *v20;
  __int16 v21;
  id v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      v3 = *(_QWORD *)(a1 + 8);
      if (v3)
      {
        WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
        if (!WeakRetained
          || (v6 = WeakRetained,
              v7 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16)),
              v2 = (char *)v7[475],
              v7,
              v6,
              (v2 & 1) == 0))
        {
          v8 = objc_loadWeakRetained((id *)(v3 + 16));
          if (v8)
          {
            v9 = objc_loadWeakRetained((id *)(v3 + 16));
            v10 = (v9[475] & 1) == 0;

          }
          else
          {
            v10 = 1;
          }

          if (v10)
          {
            if (g_boringssl_log)
            {
              v11 = (id)g_boringssl_log;
              if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
              {
                v12 = objc_loadWeakRetained((id *)(v3 + 16));
                if (v12)
                {
                  v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
                  v13 = v2 + 391;
                }
                else
                {
                  v13 = &unk_1B50022E3;
                }
                v14 = objc_loadWeakRetained((id *)(v3 + 16));
                v15 = 136447234;
                v16 = "boringssl_context_set_ats_minimum_ecdsa_key_size";
                v17 = 1024;
                v18 = 670;
                v19 = 2082;
                v20 = v13;
                v21 = 2048;
                v22 = v14;
                v23 = 2050;
                v24 = a2;
                _os_log_impl(&dword_1B4F6D000, v11, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] set %{public}zu", (uint8_t *)&v15, 0x30u);

                if (v12)
              }

            }
          }
        }
        *(_QWORD *)(v3 + 536) = a2;
      }
    }
  }
}

void boringssl_context_set_ats_enforced(uint64_t a1, int a2)
{
  char *v2;
  uint64_t v3;
  id WeakRetained;
  void *v6;
  unsigned __int8 *v7;
  id v8;
  _BYTE *v9;
  _BOOL4 v10;
  NSObject *v11;
  id v12;
  void *v13;
  id v14;
  void *v15;
  const char *v16;
  char v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  void *v23;
  __int16 v24;
  id v25;
  __int16 v26;
  const char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      v3 = *(_QWORD *)(a1 + 8);
      if (v3)
      {
        WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
        if (!WeakRetained
          || (v6 = WeakRetained,
              v7 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16)),
              v2 = (char *)v7[475],
              v7,
              v6,
              (v2 & 1) == 0))
        {
          v8 = objc_loadWeakRetained((id *)(v3 + 16));
          if (v8)
          {
            v9 = objc_loadWeakRetained((id *)(v3 + 16));
            v10 = (v9[475] & 1) == 0;

          }
          else
          {
            v10 = 1;
          }

          if (v10)
          {
            if (g_boringssl_log)
            {
              v11 = (id)g_boringssl_log;
              if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
              {
                v12 = objc_loadWeakRetained((id *)(v3 + 16));
                if (v12)
                {
                  v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
                  v13 = v2 + 391;
                }
                else
                {
                  v13 = &unk_1B50022E3;
                }
                v14 = objc_loadWeakRetained((id *)(v3 + 16));
                v15 = v14;
                v18 = 136447234;
                v19 = "boringssl_context_set_ats_enforced";
                v16 = "false";
                v20 = 1024;
                v21 = 652;
                if (a2)
                  v16 = "true";
                v22 = 2082;
                v23 = v13;
                v24 = 2048;
                v25 = v14;
                v26 = 2082;
                v27 = v16;
                _os_log_impl(&dword_1B4F6D000, v11, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] set %{public}s", (uint8_t *)&v18, 0x30u);

                if (v12)
              }

            }
          }
        }
        if (a2)
          v17 = 8;
        else
          v17 = 0;
        *(_BYTE *)(v3 + 559) = *(_BYTE *)(v3 + 559) & 0xF7 | v17;
      }
    }
  }
}

BOOL boringssl_context_set_alpn_protocol_list(uint64_t a1, void *a2, unsigned int a3)
{
  id v5;
  void *v6;
  _BOOL8 v7;
  _QWORD *v8;
  id v9;
  size_t count;
  size_t v11;
  size_t v12;
  size_t v13;
  uint64_t v14;
  void *v15;
  size_t v16;
  const char *string;
  uint64_t uint64;
  uint64_t v19;
  size_t v20;
  size_t v21;
  const char *v22;
  size_t v23;
  size_t v24;
  void *v26;
  id v27;
  id *v28;
  id v29;
  void *v30;
  _BYTE *v31;
  char v32;
  id v33;
  _BYTE *v34;
  _BOOL4 v35;
  id *v36;
  id v37;
  void *v38;
  _BYTE *v39;
  char v40;
  id v41;
  _BYTE *v42;
  _BOOL4 v43;
  id *v44;
  id v45;
  void *v46;
  _BYTE *v47;
  char v48;
  id v49;
  _BYTE *v50;
  _BOOL4 v51;
  id *v52;
  id WeakRetained;
  void *v54;
  _BYTE *v55;
  char v56;
  id v57;
  _BYTE *v58;
  _BOOL4 v59;
  id *v60;
  id v61;
  void *v62;
  _BYTE *v63;
  char v64;
  id v65;
  _BYTE *v66;
  _BOOL4 v67;
  NSObject *v68;
  id v69;
  void *v70;
  size_t v71;
  size_t v72;
  _BYTE *v73;
  _BYTE *v74;
  size_t v75;
  uint64_t v76;
  const char *v77;
  size_t v78;
  id *v79;
  id v80;
  void *v81;
  _BYTE *v82;
  char v83;
  id v84;
  _BYTE *v85;
  _BOOL4 v86;
  id *v87;
  id v88;
  void *v89;
  _BYTE *v90;
  char v91;
  id v92;
  _BYTE *v93;
  _BOOL4 v94;
  NSObject *v95;
  NSObject *v96;
  id v97;
  void *v98;
  id v99;
  id v100;
  id v101;
  id v102;
  char *v103;
  NSObject *log;
  unsigned __int8 *loga;
  os_log_t logb;
  uint64_t v107;
  char *v108;
  id v109;
  xpc_object_t xarray;
  uint8_t buf[4];
  const char *v112;
  __int16 v113;
  int v114;
  __int16 v115;
  void *v116;
  __int16 v117;
  id v118;
  __int16 v119;
  size_t v120;
  __int16 v121;
  const char *redacted_identity;
  uint64_t v123;

  v123 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = v5;
  if (!a1 || *(_DWORD *)a1 != -1252936367)
    goto LABEL_23;
  v7 = 0;
  if (!v5)
    goto LABEL_24;
  v8 = *(_QWORD **)(a1 + 8);
  if (!v8)
    goto LABEL_24;
  if (!xpc_array_get_count(v5) || !v8[50] || !v8[51])
  {
LABEL_23:
    v7 = 0;
    goto LABEL_24;
  }
  v107 = v8[50];
  v108 = v8;
  v9 = v6;
  xarray = xpc_array_create(0, 0);
  count = xpc_array_get_count(v9);
  if (!count)
  {
    v12 = 0;
LABEL_26:
    v26 = xarray;
    v27 = xarray;
    goto LABEL_74;
  }
  v11 = count;
  v12 = 0;
  v13 = 0;
  v14 = a3;
  v109 = v9;
  while (1)
  {
    xpc_array_get_value(v9, v13);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    if (MEMORY[0x1B5E45A2C]() != MEMORY[0x1E0C81390])
    {
      if (MEMORY[0x1B5E45A2C](v15) == MEMORY[0x1E0C812C8])
      {
        if (xpc_array_get_count(v15) == 2)
        {
          v16 = v12;
          string = xpc_array_get_string(v15, 0);
          uint64 = xpc_array_get_uint64(v15, 1uLL);
          if (string)
          {
            v19 = uint64;
            v20 = strlen(string);
            v21 = v20;
            if (v20 < 0x100)
            {
              if (v19 == v14)
              {
                v12 = v16 + v20 + 1;
                xpc_array_set_string(xarray, 0xFFFFFFFFFFFFFFFFLL, string);
              }
              else
              {
                v12 = v16;
              }
              v9 = v109;
              goto LABEL_21;
            }
            v52 = (id *)(v108 + 16);
            WeakRetained = objc_loadWeakRetained((id *)v108 + 2);
            v12 = v16;
            if (WeakRetained)
            {
              v54 = WeakRetained;
              v55 = objc_loadWeakRetained(v52);
              v56 = v55[475];

              if ((v56 & 1) != 0)
                goto LABEL_73;
            }
            v57 = objc_loadWeakRetained(v52);
            if (v57)
            {
              v58 = objc_loadWeakRetained(v52);
              v59 = (v58[475] & 1) == 0;

            }
            else
            {
              v59 = 1;
            }

            if (!v59 || !g_boringssl_log)
              goto LABEL_73;
            v68 = (id)g_boringssl_log;
            if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
            {
              log = v68;
              v69 = objc_loadWeakRetained(v52);
              if (v69)
              {
                v103 = (char *)objc_loadWeakRetained(v52);
                v70 = v103 + 391;
              }
              else
              {
                v70 = &unk_1B50022E3;
              }
              v99 = objc_loadWeakRetained(v52);
              v100 = v99;
              *(_DWORD *)buf = 136447490;
              v112 = "boringssl_context_copy_validated_alpn_array";
              v113 = 1024;
              v114 = 1129;
              v115 = 2082;
              v116 = v70;
              v117 = 2048;
              v118 = v99;
              v119 = 2048;
              v120 = v21;
              v121 = 2082;
              redacted_identity = nw_protocol_boringssl_get_redacted_identity((uint64_t)v100, string);
              v68 = log;
              _os_log_error_impl(&dword_1B4F6D000, log, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] ALPN protocol exceeds length restrictions (%zu): %{public}s", buf, 0x3Au);

              if (v69)
              v12 = v16;
            }
          }
          else
          {
            v44 = (id *)(v108 + 16);
            v45 = objc_loadWeakRetained((id *)v108 + 2);
            if (v45)
            {
              v46 = v45;
              v47 = objc_loadWeakRetained(v44);
              v48 = v47[475];

              if ((v48 & 1) != 0)
                goto LABEL_73;
            }
            v49 = objc_loadWeakRetained(v44);
            if (v49)
            {
              v50 = objc_loadWeakRetained(v44);
              v51 = (v50[475] & 1) == 0;

            }
            else
            {
              v51 = 1;
            }

            if (!v51 || !g_boringssl_log)
              goto LABEL_73;
            v68 = (id)g_boringssl_log;
            if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
              boringssl_context_set_alpn_protocol_list_cold_3(v44, v68);
          }
        }
        else
        {
          v36 = (id *)(v108 + 16);
          v37 = objc_loadWeakRetained((id *)v108 + 2);
          if (v37)
          {
            v38 = v37;
            v39 = objc_loadWeakRetained(v36);
            v40 = v39[475];

            if ((v40 & 1) != 0)
              goto LABEL_73;
          }
          v41 = objc_loadWeakRetained(v36);
          if (v41)
          {
            v42 = objc_loadWeakRetained(v36);
            v43 = (v42[475] & 1) == 0;

          }
          else
          {
            v43 = 1;
          }

          if (!v43 || !g_boringssl_log)
            goto LABEL_73;
          v68 = (id)g_boringssl_log;
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
            boringssl_context_set_alpn_protocol_list_cold_4(v36, v15, v68);
        }
      }
      else
      {
        v28 = (id *)(v108 + 16);
        v29 = objc_loadWeakRetained((id *)v108 + 2);
        if (v29)
        {
          v30 = v29;
          v31 = objc_loadWeakRetained(v28);
          v32 = v31[475];

          if ((v32 & 1) != 0)
            goto LABEL_73;
        }
        v33 = objc_loadWeakRetained(v28);
        if (v33)
        {
          v34 = objc_loadWeakRetained(v28);
          v35 = (v34[475] & 1) == 0;

        }
        else
        {
          v35 = 1;
        }

        if (!v35 || !g_boringssl_log)
          goto LABEL_73;
        v68 = (id)g_boringssl_log;
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
          boringssl_context_set_alpn_protocol_list_cold_5(v28, v15, v68);
      }
LABEL_72:

      goto LABEL_73;
    }
    v22 = xpc_array_get_string(v9, v13);
    v23 = strlen(v22);
    v24 = v23;
    if (v23 >= 0x100)
      break;
    v12 += v23 + 1;
    xpc_array_set_string(xarray, 0xFFFFFFFFFFFFFFFFLL, v22);
LABEL_21:

    if (v11 == ++v13)
      goto LABEL_26;
  }
  v60 = (id *)(v108 + 16);
  v61 = objc_loadWeakRetained((id *)v108 + 2);
  if (!v61
    || (v62 = v61, v63 = objc_loadWeakRetained(v60),
                   v64 = v63[475],
                   v63,
                   v62,
                   (v64 & 1) == 0))
  {
    v65 = objc_loadWeakRetained(v60);
    if (v65)
    {
      v66 = objc_loadWeakRetained(v60);
      v67 = (v66[475] & 1) == 0;

    }
    else
    {
      v67 = 1;
    }

    if (v67)
    {
      if (g_boringssl_log)
      {
        v68 = (id)g_boringssl_log;
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        {
          logb = (os_log_t)v12;
          v97 = objc_loadWeakRetained(v60);
          if (v97)
          {
            v103 = (char *)objc_loadWeakRetained(v60);
            v98 = v103 + 391;
          }
          else
          {
            v98 = &unk_1B50022E3;
          }
          v101 = objc_loadWeakRetained(v60);
          v102 = v101;
          *(_DWORD *)buf = 136447490;
          v112 = "boringssl_context_copy_validated_alpn_array";
          v113 = 1024;
          v114 = 1116;
          v115 = 2082;
          v116 = v98;
          v117 = 2048;
          v118 = v101;
          v119 = 2048;
          v120 = v24;
          v121 = 2082;
          redacted_identity = nw_protocol_boringssl_get_redacted_identity((uint64_t)v102, v22);
          _os_log_error_impl(&dword_1B4F6D000, v68, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] ALPN protocol exceeds length restrictions (%zu): %{public}s", buf, 0x3Au);

          if (v97)
          v12 = (size_t)logb;
        }
        goto LABEL_72;
      }
    }
  }
LABEL_73:

  v27 = 0;
  v9 = v109;
  v26 = xarray;
LABEL_74:

  if (!v27)
    goto LABEL_103;
  v71 = xpc_array_get_count(v27);
  if (!v71)
  {
    v79 = (id *)(v108 + 16);
    v80 = objc_loadWeakRetained((id *)v108 + 2);
    if (!v80
      || (v81 = v80,
          v82 = objc_loadWeakRetained(v79),
          v83 = v82[475],
          v82,
          v81,
          (v83 & 1) == 0))
    {
      v84 = objc_loadWeakRetained(v79);
      if (v84)
      {
        v85 = objc_loadWeakRetained(v79);
        v86 = (v85[475] & 1) == 0;

      }
      else
      {
        v86 = 1;
      }

      v7 = 0;
      if (v86 && g_boringssl_log)
      {
        v95 = (id)g_boringssl_log;
        if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
          boringssl_context_set_alpn_protocol_list_cold_1(v79, v95);

        goto LABEL_103;
      }
      goto LABEL_104;
    }
LABEL_103:
    v7 = 0;
    goto LABEL_104;
  }
  v72 = v71;
  v73 = malloc_type_malloc(v12, 0x4D396D69uLL);
  if (v73)
  {
    v74 = v73;
    loga = (unsigned __int8 *)v12;
    v75 = 0;
    v76 = 0;
    do
    {
      v77 = xpc_array_get_string(v27, v75);
      v78 = strlen(v77);
      v74[v76] = v78;
      memcpy(&v74[v76 + 1], v77, v78);
      v76 += v78 + 1;
      ++v75;
    }
    while (v72 != v75);
    if ((v108[556] & 0x10) != 0)
    {
      SSL_set_alpn_select_cb(v107, (uint64_t)boringssl_context_select_alpn_callback, a1);
      v7 = 1;
    }
    else
    {
      v7 = SSL_set_alpn_protos(v107, v74, loga) == 0;
    }
    free(v74);
    v108[557] |= 0x40u;
    objc_storeStrong((id *)v108 + 8, v27);
    goto LABEL_104;
  }
  v87 = (id *)(v108 + 16);
  v88 = objc_loadWeakRetained((id *)v108 + 2);
  if (v88)
  {
    v89 = v88;
    v90 = objc_loadWeakRetained(v87);
    v91 = v90[475];

    if ((v91 & 1) != 0)
      goto LABEL_103;
  }
  v92 = objc_loadWeakRetained(v87);
  if (v92)
  {
    v93 = objc_loadWeakRetained(v87);
    v94 = (v93[475] & 1) == 0;

  }
  else
  {
    v94 = 1;
  }

  v7 = 0;
  if (v94 && g_boringssl_log)
  {
    v96 = (id)g_boringssl_log;
    if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
      boringssl_context_set_alpn_protocol_list_cold_2(v87, v12, v96);

    goto LABEL_103;
  }
LABEL_104:

LABEL_24:
  return v7;
}

uint64_t boringssl_context_set_GREASE_enabled(uint64_t result, int a2)
{
  uint64_t v2;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      v2 = *(_QWORD *)(result + 8);
      if (v2)
      {
        result = *(_QWORD *)(v2 + 408);
        if (result)
        {
          *(_BYTE *)(v2 + 560) = *(_BYTE *)(v2 + 560) & 0xFE | a2;
          return SSL_CTX_set_grease_enabled(result, a2);
        }
      }
    }
  }
  return result;
}

uint64_t boringssl_config_get_sct_enabled()
{
  return 1;
}

uint64_t boringssl_config_get_renegotiation_enabled()
{
  return 1;
}

uint64_t boringssl_config_get_ocsp_enabled()
{
  return 1;
}

uint64_t SSL_use_ticket_request(uint64_t a1, char a2, char a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return 0;
  *(_BYTE *)(v3 + 232) = a2;
  *(_BYTE *)(v3 + 233) = a3;
  return 1;
}

void SSL_set_renegotiate_mode(bssl *this, ssl_st *a2)
{
  *((_DWORD *)this + 44) = (_DWORD)a2;
  bssl::ssl_maybe_shed_handshake_config(this, a2);
}

uint64_t SSL_set_enable_ech_grease(uint64_t result, int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  if (v2)
    *(_WORD *)(v2 + 313) = *(_WORD *)(v2 + 313) & 0xFFFE | (a2 != 0);
  return result;
}

uint64_t SSL_set_early_data_enabled(uint64_t result, int a2)
{
  *(_BYTE *)(result + 180) = *(_BYTE *)(result + 180) & 0xFB | (4 * (a2 != 0));
  return result;
}

uint64_t SSL_set_custom_verify(uint64_t result, char a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(result + 8);
  if (v3)
  {
    *(_BYTE *)(v3 + 312) = a2;
    *(_QWORD *)(v3 + 48) = a3;
  }
  return result;
}

uint64_t SSL_set_alpn_protos(uint64_t a1, void *a2, unsigned __int8 *a3)
{
  uint64_t v3;
  void **v7;
  int v8;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    if (!a3)
    {
      v8 = bssl::Array<unsigned char>::Init(v3 + 128, 0);
      return v8 ^ 1u;
    }
    if ((bssl::ssl_is_valid_alpn_list((unsigned __int8 *)a2, a3) & 1) != 0)
    {
      v7 = (void **)(*(_QWORD *)(a1 + 8) + 128);
      v8 = bssl::Array<unsigned char>::Init((uint64_t)v7, (unint64_t)a3);
      if (v8)
        memcpy(*v7, a2, (size_t)a3);
      return v8 ^ 1u;
    }
    ERR_put_error(16, 0, 315, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 2524);
  }
  return 1;
}

uint64_t bssl::ssl_is_valid_alpn_list(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t result;
  unint64_t v3[2];
  unsigned __int8 *v4[2];

  v4[0] = a1;
  v4[1] = a2;
  result = CBS_len((uint64_t)v4);
  if (result)
  {
    if (CBS_len((uint64_t)v4))
    {
      while (1)
      {
        v3[0] = 0xAAAAAAAAAAAAAAAALL;
        v3[1] = 0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_u8_length_prefixed(v4, v3) || !CBS_len((uint64_t)v3))
          break;
        if (!CBS_len((uint64_t)v4))
          return 1;
      }
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t SSL_enable_signed_cert_timestamps(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 8);
  if (v1)
    *(_WORD *)(v1 + 313) |= 2u;
  return result;
}

uint64_t SSL_enable_ocsp_stapling(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 8);
  if (v1)
    *(_WORD *)(v1 + 313) |= 4u;
  return result;
}

uint64_t SSL_CTX_set_grease_enabled(uint64_t result, int a2)
{
  *(_WORD *)(result + 840) = *(_WORD *)(result + 840) & 0xFFDF | (32 * (a2 != 0));
  return result;
}

uint64_t SSL_CTX_add_cert_compression_alg(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  __int16 v6;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;

  if (!(a3 | a4))
    SSL_CTX_add_cert_compression_alg_cold_1();
  v6 = a2;
  v8 = *(_QWORD *)(a1 + 720);
  if (v8)
  {
    v9 = 24 * v8;
    v10 = (unsigned __int16 *)(*(_QWORD *)(a1 + 728) + 16);
    while (1)
    {
      v11 = *v10;
      v10 += 12;
      if (v11 == a2)
        return 0;
      v9 -= 24;
      if (!v9)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    result = bssl::GrowableArray<bssl::CertCompressionAlg>::MaybeGrow((unint64_t *)(a1 + 720));
    if ((_DWORD)result)
    {
      v13 = *(_QWORD *)(a1 + 720);
      v14 = *(_QWORD *)(a1 + 728) + 24 * v13;
      *(_QWORD *)v14 = a3;
      *(_QWORD *)(v14 + 8) = a4;
      *(_WORD *)(v14 + 16) = v6;
      *(_QWORD *)(a1 + 720) = v13 + 1;
    }
  }
  return result;
}

uint64_t bssl::Array<bssl::CertCompressionAlg>::Init(uint64_t a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;

  OPENSSL_free(*(_QWORD **)a1);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  if (!a2)
    return 1;
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/internal.h", 312);
    return 0;
  }
  result = (uint64_t)OPENSSL_malloc(24 * a2);
  *(_QWORD *)a1 = result;
  if (result)
  {
    v5 = 0;
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
    {
      v7 = *(_QWORD *)a1 + v5;
      *(_QWORD *)v7 = 0;
      *(_QWORD *)(v7 + 8) = 0;
      *(_WORD *)(v7 + 16) = 0;
      ++v6;
      v5 += 24;
    }
    while (v6 < *(_QWORD *)(a1 + 8));
    return 1;
  }
  return result;
}

uint64_t bssl::GrowableArray<bssl::CertCompressionAlg>::MaybeGrow(unint64_t *a1)
{
  _QWORD **v1;
  unint64_t v2;
  uint64_t v4;
  uint64_t v6;
  unint64_t v7;
  char *v8;
  __int128 *v9;
  char *v10;
  __int128 v11;
  _QWORD *v12;
  unint64_t v13;
  void *v14;
  unint64_t v15;

  v1 = (_QWORD **)(a1 + 1);
  v2 = a1[2];
  if (!v2)
    return bssl::Array<bssl::CertCompressionAlg>::Init((uint64_t)(a1 + 1), 0x10uLL);
  if (*a1 < v2)
    return 1;
  if ((v2 & 0x8000000000000000) != 0)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/internal.h", 427);
    return 0;
  }
  else
  {
    v14 = 0;
    v15 = 0;
    v4 = bssl::Array<bssl::CertCompressionAlg>::Init((uint64_t)&v14, 2 * v2);
    if ((v4 & 1) != 0)
    {
      if (a1[2])
      {
        v6 = 0;
        v7 = 0;
        v8 = (char *)v14;
        do
        {
          v9 = (__int128 *)(a1[1] + v6);
          v10 = &v8[v6];
          v11 = *v9;
          *((_WORD *)v10 + 8) = *((_WORD *)v9 + 8);
          *(_OWORD *)v10 = v11;
          ++v7;
          v6 += 24;
        }
        while (v7 < a1[2]);
      }
      OPENSSL_free(*v1);
      v12 = 0;
      v13 = v15;
      a1[1] = (unint64_t)v14;
      a1[2] = v13;
      v14 = 0;
      v15 = 0;
    }
    else
    {
      v12 = v14;
    }
    OPENSSL_free(v12);
  }
  return v4;
}

void sub_1B4FAE808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t SSL_set_options(uint64_t a1, unsigned int a2)
{
  uint64_t v2;

  v2 = *(_DWORD *)(a1 + 144) | a2;
  *(_DWORD *)(a1 + 144) = v2;
  return v2;
}

uint64_t SSL_set_quic_use_legacy_codepoint(uint64_t result, int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  if (v2)
    *(_WORD *)(v2 + 313) = *(_WORD *)(v2 + 313) & 0xFDFF | ((a2 != 0) << 9);
  return result;
}

uint64_t SSL_clear_options(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = *(_DWORD *)(a1 + 144) & ~a2;
  *(_DWORD *)(a1 + 144) = v2;
  return v2;
}

uint64_t nw_protocol_boringssl_get_output_frames(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t v6;
  size_t v8;
  uint64_t v10;
  int state;
  char v12;
  void *external;
  id v15;
  _BOOL4 v16;
  NSObject *v17;
  int v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v6 = *(_QWORD *)(a1 + 40);
  if (!v6)
    return 0;
  LODWORD(v8) = a4;
  if ((*(_BYTE *)(v6 + 475) & 1) == 0)
  {
    if (datapath_logging_enabled)
    {
      if (g_boringssl_log)
      {
        v18 = a5;
        v16 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
        a5 = v18;
        if (v16)
        {
          nw_protocol_boringssl_get_output_frames_cold_6();
          a5 = v18;
        }
      }
    }
  }
  v10 = 0;
  if (a5 && a6)
  {
    if ((*(_BYTE *)(v6 + 388) & 0x20) != 0)
    {
      if ((*(_BYTE *)(v6 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_get_output_frames_cold_5();
      }
      return 0;
    }
    state = boringssl_session_get_state(*(_QWORD *)(v6 + 336));
    v12 = boringssl_session_in_early_data(*(_QWORD *)(v6 + 336));
    if (state == 2 || (v12 & 1) != 0)
    {
      if ((*(_BYTE *)(v6 + 475) & 1) == 0)
      {
        if (datapath_logging_enabled)
        {
          v17 = g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136447490;
              v20 = "nw_protocol_boringssl_get_output_frames";
              v21 = 1024;
              v22 = 1717;
              v23 = 2082;
              v24 = v6 + 391;
              v25 = 2048;
              v26 = v6;
              v27 = 1024;
              v28 = a3;
              v29 = 1024;
              v30 = v8;
              _os_log_debug_impl(&dword_1B4F6D000, v17, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] get output frames min bytes %u max bytes %u", buf, 0x32u);
            }
          }
        }
      }
      nw_frame_array_init();
      if (v8 >= 0x4000)
        v8 = 0x4000;
      else
        v8 = v8;
      if ((*(_BYTE *)(v6 + 389) & 0x10) != 0)
      {
        external = (void *)nw_frame_create_external();
        if (!external)
        {
          if ((*(_BYTE *)(v6 + 475) & 1) == 0
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            nw_protocol_boringssl_get_output_frames_cold_3();
          }
          return 0;
        }
      }
      else
      {
        if ((_DWORD)v8 && !malloc_type_malloc(v8, 0x3627E065uLL))
        {
          if ((*(_BYTE *)(v6 + 475) & 1) == 0
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            nw_protocol_boringssl_get_output_frames_cold_2();
          }
          return 0;
        }
        external = (void *)nw_frame_create();
        if (!external)
        {
          if ((*(_BYTE *)(v6 + 475) & 1) == 0
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            nw_protocol_boringssl_get_output_frames_cold_1();
          }
          return 0;
        }
      }
      v15 = external;
      nw_frame_array_append();
      v10 = 1;
      nw_frame_array_append();

      return v10;
    }
    if ((*(_BYTE *)(v6 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_get_output_frames_cold_4();
    }
    return 0;
  }
  return v10;
}

void md_pctx_ops_init()
{
  md_pctx_ops_storage = (uint64_t)EVP_PKEY_CTX_free;
  unk_1ECD85580 = EVP_PKEY_CTX_dup;
}

double RSA_default_method_init()
{
  double result;

  result = 0.0;
  xmmword_1ECD85950 = 0u;
  unk_1ECD85960 = 0u;
  xmmword_1ECD85930 = 0u;
  unk_1ECD85940 = 0u;
  RSA_default_method_storage = 0u;
  BYTE4(RSA_default_method_storage) = 1;
  return result;
}

void __boringssl_log_open_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.network", "boringssl");
  v1 = (void *)g_boringssl_log;
  g_boringssl_log = (uint64_t)v0;

  if (boringssl_logging_register_debug_log_updates_onceToken != -1)
    dispatch_once(&boringssl_logging_register_debug_log_updates_onceToken, &__block_literal_global_3);
}

uint64_t thread_local_init()
{
  uint64_t result;

  result = pthread_key_create((pthread_key_t *)&g_thread_local_key, (void (__cdecl *)(void *))thread_local_destructor);
  g_thread_local_key_created = result == 0;
  return result;
}

void __boringssl_metrics_log_connection_block_invoke()
{
  dispatch_queue_t v0;
  void *v1;

  v0 = dispatch_queue_create("com.apple.network.boringssl.metrics_queue", 0);
  v1 = (void *)boringssl_context_metrics_queue;
  boringssl_context_metrics_queue = (uint64_t)v0;

}

double BN_value_one_init()
{
  double result;

  BN_value_one_storage = (uint64_t)&BN_value_one_do_init_kOneLimbs;
  *(_QWORD *)&result = 0x100000001;
  *(_OWORD *)algn_1ECD85810 = xmmword_1B5022AE0;
  return result;
}

void __boringssl_context_evaluate_trust_async_external_block_invoke(uint64_t a1)
{
  char *v1;
  id v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  id WeakRetained;
  void *v8;
  _BYTE *v9;
  char v10;
  uint64_t v11;
  id v12;
  _BYTE *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  _BOOL4 v17;
  id v18;
  char v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[4];
  id v23;
  id v24;
  __int128 v25;
  uint64_t v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  void *v32;
  __int16 v33;
  id v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (boringssl_session_get_state(*(_QWORD *)(a1 + 64)) > 3
    || boringssl_session_is_cancelled(*(_QWORD *)(a1 + 64)))
  {
    *(_BYTE *)(*(_QWORD *)(a1 + 72) + 558) &= ~8u;
    return;
  }
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 3221225472;
  v22[2] = __boringssl_context_evaluate_trust_async_external_block_invoke_2;
  v22[3] = &unk_1E68790A0;
  v23 = *(id *)(a1 + 32);
  v25 = *(_OWORD *)(a1 + 64);
  v3 = *(id *)(a1 + 48);
  v4 = *(_QWORD *)(a1 + 80);
  v24 = v3;
  v26 = v4;
  v5 = (void *)MEMORY[0x1B5E45624](v22);
  v6 = *(_QWORD *)(a1 + 32);
  if (!v6)
    goto LABEL_10;
  WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
  if (WeakRetained)
  {
    v8 = WeakRetained;
    v9 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
    v10 = v9[475];

    if ((v10 & 1) != 0)
      goto LABEL_16;
  }
  v11 = *(_QWORD *)(a1 + 32);
  if (v11)
  {
    v12 = objc_loadWeakRetained((id *)(v11 + 16));
    if (v12)
    {
      v13 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
      v14 = (v13[475] & 1) == 0;

    }
    else
    {
      v14 = 1;
    }

    if (!(_DWORD)v14)
      goto LABEL_16;
  }
  else
  {
LABEL_10:
    v14 = 1;
  }
  if (g_boringssl_log)
  {
    v15 = (id)g_boringssl_log;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
LABEL_15:

      goto LABEL_16;
    }
    v16 = *(_QWORD *)(a1 + 32);
    if (v16)
    {
      v14 = (uint64_t)objc_loadWeakRetained((id *)(v16 + 16));
      v21 = *(_QWORD *)(a1 + 32);
      if (v14)
      {
        v17 = v21 != 0;
        if (v21)
        {
          v1 = (char *)objc_loadWeakRetained((id *)(v21 + 16));
          v21 = *(_QWORD *)(a1 + 32);
        }
        else
        {
          v1 = 0;
        }
        v20 = v1 + 391;
      }
      else
      {
        v17 = 0;
        v20 = &unk_1B50022E3;
      }
      if (v21)
      {
        v18 = objc_loadWeakRetained((id *)(v21 + 16));
        v19 = 0;
      }
      else
      {
        v18 = 0;
        v19 = 1;
      }
    }
    else
    {
      v17 = 0;
      v18 = 0;
      v19 = 1;
      v20 = &unk_1B50022E3;
    }
    *(_DWORD *)buf = 136446978;
    v28 = "boringssl_context_evaluate_trust_async_external_block_invoke";
    v29 = 1024;
    v30 = 1763;
    v31 = 2082;
    v32 = v20;
    v33 = 2048;
    v34 = v18;
    _os_log_debug_impl(&dword_1B4F6D000, v15, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Invoking verify block", buf, 0x26u);
    if ((v19 & 1) != 0)
    {
      if (!v17)
        goto LABEL_30;
    }
    else
    {

      if (!v17)
      {
LABEL_30:
        if (!v16)
          goto LABEL_15;
        goto LABEL_34;
      }
    }

    if (!v16)
      goto LABEL_15;
LABEL_34:

    goto LABEL_15;
  }
LABEL_16:
  (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();

}

double EVP_sha256_init()
{
  double result;

  EVP_sha256_storage = 0x20000002A0;
  dword_1ECD859B8 = 0;
  qword_1ECD859C0 = (uint64_t)sha256_init;
  unk_1ECD859C8 = digest_update_wrapper;
  qword_1ECD859D0 = (uint64_t)digest_final_wrapper;
  *(_QWORD *)&result = 0x40800000040;
  qword_1ECD859D8 = 0x40800000040;
  return result;
}

uint64_t *OPENSSL_built_in_curves_init()
{
  uint64_t *result;

  OPENSSL_built_in_curves_storage = 716;
  qword_1ECD85710 = (uint64_t)&OPENSSL_built_in_curves_do_init_kOIDP521;
  byte_1ECD85718 = 5;
  qword_1ECD85720 = (uint64_t)"NIST P-521";
  byte_1ECD85728 = 66;
  qword_1ECD85730 = (uint64_t)&kP521Params;
  qword_1ECD85738 = (uint64_t)EC_GFp_mont_method();
  dword_1ECD85740 = 715;
  qword_1ECD85748 = (uint64_t)&OPENSSL_built_in_curves_do_init_kOIDP384;
  byte_1ECD85750 = 5;
  qword_1ECD85758 = (uint64_t)"NIST P-384";
  byte_1ECD85760 = 48;
  qword_1ECD85768 = (uint64_t)&kP384Params;
  qword_1ECD85770 = (uint64_t)EC_GFp_mont_method();
  dword_1ECD85778 = 415;
  qword_1ECD85780 = (uint64_t)&OPENSSL_built_in_curves_do_init_kOIDP256;
  byte_1ECD85788 = 8;
  qword_1ECD85790 = (uint64_t)"NIST P-256";
  byte_1ECD85798 = 32;
  qword_1ECD857A0 = (uint64_t)&kP256Params;
  qword_1ECD857A8 = (uint64_t)EC_GFp_nistp256_method();
  dword_1ECD857B0 = 713;
  qword_1ECD857B8 = (uint64_t)&OPENSSL_built_in_curves_do_init_kOIDP224;
  byte_1ECD857C0 = 5;
  qword_1ECD857C8 = (uint64_t)"NIST P-224";
  byte_1ECD857D0 = 28;
  qword_1ECD857D8 = (uint64_t)&kP224Params;
  result = EC_GFp_nistp224_method();
  qword_1ECD857E0 = (uint64_t)result;
  return result;
}

const EC_METHOD *EC_GFp_mont_method(void)
{
  CRYPTO_once(&EC_GFp_mont_method_once, EC_GFp_mont_method_init);
  return (const EC_METHOD *)&EC_GFp_mont_method_storage;
}

uint64_t *EC_GFp_nistp256_method()
{
  CRYPTO_once(&EC_GFp_nistp256_method_once, EC_GFp_nistp256_method_init);
  return &EC_GFp_nistp256_method_storage;
}

uint64_t *EC_GFp_nistp224_method()
{
  CRYPTO_once(&EC_GFp_nistp224_method_once, EC_GFp_nistp224_method_init);
  return &EC_GFp_nistp224_method_storage;
}

uint64_t nw_protocol_boringssl_disconnect(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t (*v4)(void);

  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 40);
    if (v2)
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_disconnect_cold_1();
      }
      result = *(_QWORD *)(v2 + 336);
      if (result)
      {
        *(_BYTE *)(v2 + 388) &= ~0x20u;
        if (boringssl_session_get_state(result) <= 3)
        {
          boringssl_session_set_state(*(_QWORD *)(v2 + 336), 3);
          boringssl_session_disconnect(*(_QWORD *)(v2 + 336));
        }
        boringssl_session_set_state(*(_QWORD *)(v2 + 336), 4);
        result = *(_QWORD *)(v1 + 32);
        if (result)
        {
          v3 = *(_QWORD *)(result + 24);
          if (v3)
          {
            v4 = *(uint64_t (**)(void))(v3 + 32);
            if (v4)
              return v4();
          }
        }
      }
    }
  }
  return result;
}

uint64_t boringssl_session_disconnect(uint64_t a1)
{
  uint64_t v2;
  SSL *v3;
  int v4;
  uint64_t v5;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1252936367)
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = *(SSL **)(v2 + 400);
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = SSL_shutdown(v3);
  if (*(_DWORD *)a1 == -1252936367)
  {
    v5 = *(_QWORD *)(a1 + 8);
    if (v5)
      *(_DWORD *)(v5 + 300) = 3;
  }
  return (v4 >> 31);
}

int SSL_shutdown(SSL *s)
{
  int (__cdecl *handshake_func)(SSL *);
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v8;

  *((_DWORD *)s->handshake_func + 49) = 0;
  ERR_clear_error();
  ERR_clear_system_error();
  if (!*(_QWORD *)&s->rwstate)
  {
    v5 = 226;
    v6 = 1387;
LABEL_12:
    ERR_put_error(16, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", v6);
    return -1;
  }
  handshake_func = s->handshake_func;
  v3 = *((_QWORD *)handshake_func + 35);
  if (v3 && (*(_BYTE *)(v3 + 1600) & 8) == 0)
    return 1;
  if ((BYTE4(s->param) & 2) != 0)
  {
    *(_QWORD *)((char *)handshake_func + 172) = 0x100000001;
    return 1;
  }
  if (*((_DWORD *)handshake_func + 44) != 1)
  {
    v8 = bssl::ssl_send_alert_impl((bssl *)s, (ssl_st *)1, 0);
    goto LABEL_18;
  }
  if ((*((_WORD *)handshake_func + 110) & 0x1000) != 0)
  {
    v8 = (*(uint64_t (**)(SSL *))(*(_QWORD *)&s->version + 80))(s);
LABEL_18:
    if (v8 < 1)
      return -1;
    return *((_DWORD *)s->handshake_func + 43) == 1;
  }
  v4 = *((_DWORD *)handshake_func + 43);
  if (v4 != 1)
  {
    if (**(_BYTE **)&s->version)
    {
      if (v4 == 2)
      {
        ERR_restore_state(*((_QWORD **)handshake_func + 23));
        return -1;
      }
      *((_DWORD *)handshake_func + 43) = 1;
      return *((_DWORD *)s->handshake_func + 43) == 1;
    }
    if ((int)ssl_read_impl(s) >= 1)
    {
      v5 = 291;
      v6 = 1434;
      goto LABEL_12;
    }
    if (*((_DWORD *)s->handshake_func + 43) != 1)
      return -1;
  }
  return *((_DWORD *)s->handshake_func + 43) == 1;
}

uint64_t bssl::ssl_send_alert_impl(bssl *this, ssl_st *a2, int a3)
{
  uint64_t v3;
  int v4;

  v3 = *((_QWORD *)this + 6);
  if (*(_DWORD *)(v3 + 176))
  {
    ERR_put_error(16, 0, 194, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", 412);
    return 0xFFFFFFFFLL;
  }
  if ((_DWORD)a2 != 1 || a3)
  {
    if ((_DWORD)a2 != 2)
      bssl::ssl_send_alert_impl();
    if (!a3)
      bssl::ssl_send_alert_impl();
    v4 = 2;
  }
  else
  {
    v4 = 1;
  }
  *(_DWORD *)(v3 + 176) = v4;
  *(_WORD *)(v3 + 220) |= 0x1000u;
  *(_BYTE *)(*((_QWORD *)this + 6) + 469) = (_BYTE)a2;
  *(_BYTE *)(*((_QWORD *)this + 6) + 470) = a3;
  if (*(_WORD *)(*((_QWORD *)this + 6) + 116))
    return 0xFFFFFFFFLL;
  return (*(uint64_t (**)(bssl *))(*(_QWORD *)this + 80))(this);
}

double bssl::ssl_done_writing_client_hello(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  _OWORD *v3;
  double result;

  v3 = (_OWORD *)((char *)this + 568);
  OPENSSL_free(*((_QWORD **)this + 71));
  *v3 = 0u;
  OPENSSL_free(*((_QWORD **)this + 67));
  *(_OWORD *)((char *)this + 536) = 0u;
  OPENSSL_free(*((_QWORD **)this + 77));
  result = 0.0;
  *(_OWORD *)((char *)this + 616) = 0u;
  return result;
}

void __boringssl_session_state_copy_serialized_session_state_block_invoke(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

uint64_t boringssl_session_copy_serialized_session(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
    {
      boringssl_session_state_copy_serialized_session_state(*(void **)(v1 + 392));
      return objc_claimAutoreleasedReturnValue();
    }
    else
    {
      return 0;
    }
  }
  return result;
}

dispatch_data_t boringssl_session_state_copy_serialized_session_state(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  size_t v3;
  size_t v4;
  dispatch_data_t v5;
  char v7;
  size_t v8;
  _BYTE *v9;
  const void *v10;
  const void *v11;
  _QWORD destructor[5];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  void *v16;

  v1 = a1;
  v2 = v1;
  if (!v1)
  {
LABEL_14:
    v5 = 0;
    goto LABEL_15;
  }
  v3 = *((unsigned __int8 *)v1 + 12);
  v4 = v1[6];
  if (~v4 < v3)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      boringssl_session_state_copy_serialized_session_state_cold_1();
    goto LABEL_14;
  }
  if (~v4 == v3)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      boringssl_session_state_copy_serialized_session_state_cold_2();
    goto LABEL_14;
  }
  if (v4 + 1 == ~v3)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      boringssl_session_state_copy_serialized_session_state_cold_3();
    goto LABEL_14;
  }
  v7 = *((_BYTE *)v1 + 8);
  v8 = v4 + v3 + 2;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = (void *)0xAAAAAAAAAAAAAAAALL;
  v16 = malloc_type_malloc(v8, 0xBDCE5635uLL);
  v9 = (_BYTE *)v14[3];
  if (v9)
  {
    v10 = (const void *)v2[5];
    *v9 = v7;
    *(_BYTE *)(v14[3] + 1) = *((_BYTE *)v2 + 12);
    memcpy((void *)(v14[3] + 2), (char *)v2 + 12, *((unsigned __int8 *)v2 + 12));
    memcpy((void *)(*((unsigned __int8 *)v2 + 12) + v14[3] + 2), v10, v4);
    v11 = (const void *)v14[3];
    destructor[0] = MEMORY[0x1E0C809B0];
    destructor[1] = 3221225472;
    destructor[2] = __boringssl_session_state_copy_serialized_session_state_block_invoke;
    destructor[3] = &unk_1E686EBB0;
    destructor[4] = &v13;
    v5 = dispatch_data_create(v11, v8, 0, destructor);
  }
  else
  {
    v5 = (dispatch_data_t)g_boringssl_log;
    if (g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        boringssl_session_state_copy_serialized_session_state_cold_4();
      v5 = 0;
    }
  }
  _Block_object_dispose(&v13, 8);
LABEL_15:

  return v5;
}

uint64_t nw_protocol_boringssl_remove_input_handler(uint64_t result, uint64_t a2, int a3)
{
  _QWORD *v3;
  uint64_t v4;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(void);
  void *v10;
  _BOOL4 v11;
  uint64_t v12;

  if (result)
  {
    v3 = (_QWORD *)result;
    v4 = *(_QWORD *)(result + 40);
    if (!v4)
      return 0;
    if ((*(_BYTE *)(v4 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        if (g_boringssl_log)
        {
          v12 = a2;
          v11 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
          a2 = v12;
          if (v11)
          {
            nw_protocol_boringssl_remove_input_handler_cold_1();
            a2 = v12;
          }
        }
      }
    }
    *(_QWORD *)(a2 + 32) = 0;
    if (v3[6] == a2)
    {
      v3[6] = 0;
      *(_DWORD *)(v4 + 376) = 0;
      v6 = *(void **)(v4 + 368);
      *(_QWORD *)(v4 + 368) = 0;

      nw_frame_array_foreach();
      nw_frame_array_foreach();
      nw_frame_array_foreach();
      nw_frame_array_foreach();
      nw_frame_array_foreach();
      v7 = v3[4];
      if (v7)
      {
        v8 = *(_QWORD *)(v7 + 24);
        if (v8)
        {
          v9 = *(void (**)(void))(v8 + 8);
          if (v9)
            v9();
        }
      }
      if (a3)
      {
        v10 = (void *)v3[5];
        v3[5] = 0;

      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void nw_protocol_boringssl_cleanup(void *a1)
{
  _QWORD *v1;
  void *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  SSL *v6;
  uint64_t v7;
  _QWORD *v8;
  BIO *v9;
  void *v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;

  v1 = a1;
  if (v1)
  {
    v12 = v1;
    v2 = (void *)MEMORY[0x1B5E4551C]();
    v3 = v12;
    v4 = v12[42];
    if (v4)
    {
      v5 = *(_QWORD **)(v4 + 8);
      v6 = (SSL *)v5[50];
      if (v6)
      {
        SSL_set_msg_callback(v6, 0);
        SSL_set_msg_callback_arg(v5[50], 0);
      }
      v7 = v5[5];
      if (v7)
        boringssl_psk_cache_clear_context(v7);

      v3 = v12;
    }
    v3[42] = 0;
    objc_autoreleasePoolPop(v2);
    v13 = v12;
    nw_frame_array_foreach();
    v8 = v13;
    nw_frame_array_foreach();
    v9 = (BIO *)v8[43];
    if (v9)
    {
      boringssl_bio_destroy(v9);
      v8[43] = 0;
    }
    v10 = (void *)v8[21];
    if (v10)
    {
      v8[21] = 0;

      v8[22] = 0;
      *((_DWORD *)v8 + 46) = 0;
    }
    if (v8[40])
    {
      nw_queue_cancel_source();
      v8[40] = 0;
    }
    v11 = (void *)v8[44];
    if (v11)
    {
      free(v11);
      v8[44] = 0;
    }

    v1 = v12;
  }

}

void boringssl_bio_destroy(BIO *a)
{
  void *v2;

  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    boringssl_bio_destroy_cold_1();
    if (!a)
      return;
  }
  else if (!a)
  {
    return;
  }
  v2 = *(void **)&a->flags;
  if (v2)
    free(v2);
  BIO_free(a);
}

void boringssl_session_destroy(uint64_t a1)
{
  uint64_t v1;
  SSL *v2;

  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      v1 = *(_QWORD *)(a1 + 8);
      if (v1)
      {
        v2 = *(SSL **)(v1 + 400);
        if (v2)
        {
          SSL_free(v2);
          *(_QWORD *)(v1 + 400) = 0;
          *(_DWORD *)(v1 + 300) = 5;
        }
      }
    }
  }
}

void boringssl_context_ssl_context_destroy(uint64_t a1)
{
  uint64_t v1;
  SSL_CTX *v2;

  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      v1 = *(_QWORD *)(a1 + 8);
      if (v1)
      {
        v2 = *(SSL_CTX **)(v1 + 408);
        if (v2)
        {
          SSL_CTX_free(v2);
          *(_QWORD *)(v1 + 408) = 0;
        }
      }
    }
  }
}

void boringssl_bio_destroy_cold_1()
{
  os_log_t v0;
  uint8_t v1[14];
  int v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_0_0();
  v2 = 196;
  _os_log_debug_impl(&dword_1B4F6D000, v0, OS_LOG_TYPE_DEBUG, "%{public}s(%d) ", v1, 0x12u);
  OUTLINED_FUNCTION_2_1();
}

void __check_and_init_restricted_mode_block_invoke()
{
  const __CFNumber *v0;
  const __CFNumber *v1;

  v0 = (const __CFNumber *)MGCopyAnswer();
  if (v0)
  {
    v1 = v0;
    CFNumberGetValue(v0, kCFNumberIntType, &boringssl_config_restricted_mode_status);
    CFRelease(v1);
  }
}

void nw_protocol_boringssl_deallocate_metadata(void *a1, _QWORD *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;

  v3 = a1;
  if (a2)
  {
    v21 = v3;
    v4 = (void *)a2[5];
    if (v4)
    {
      free(v4);
      a2[5] = 0;
    }
    v5 = (void *)a2[22];
    if (v5)
    {
      free(v5);
      a2[22] = 0;
    }
    v6 = (void *)a2[6];
    if (v6)
    {
      free(v6);
      a2[6] = 0;
    }
    v7 = (void *)a2[7];
    if (v7)
    {
      free(v7);
      a2[7] = 0;
    }
    v8 = (void *)a2[40];
    if (v8)
    {
      free(v8);
      a2[40] = 0;
    }
    v9 = (void *)a2[10];
    a2[10] = 0;

    v10 = (void *)a2[11];
    a2[11] = 0;

    v11 = (void *)a2[12];
    a2[12] = 0;

    v12 = (void *)a2[13];
    a2[13] = 0;

    v13 = (void *)a2[14];
    a2[14] = 0;

    v14 = (void *)a2[15];
    a2[15] = 0;

    v15 = (void *)a2[16];
    a2[16] = 0;

    v16 = (void *)a2[17];
    a2[17] = 0;

    v17 = (void *)a2[18];
    a2[18] = 0;

    v18 = (void *)a2[19];
    a2[19] = 0;

    v19 = (void *)a2[20];
    a2[20] = 0;

    v20 = (void *)a2[21];
    a2[21] = 0;

    free(a2);
    v3 = v21;
  }

}

uint64_t __nw_protocol_boringssl_copy_definition_block_invoke()
{
  uint64_t v0;
  void *v1;

  if (nw_protocol_boringssl_identifier_onceToken != -1)
    dispatch_once(&nw_protocol_boringssl_identifier_onceToken, &__block_literal_global_0);
  v0 = nw_protocol_definition_create_with_identifier();
  v1 = (void *)nw_protocol_boringssl_copy_definition_definition;
  nw_protocol_boringssl_copy_definition_definition = v0;

  nw_protocol_definition_set_options_allocator();
  nw_protocol_definition_set_metadata_allocator();
  nw_protocol_definition_set_options_equality_check();
  nw_protocol_definition_set_options_comparator();
  return nw_protocol_definition_set_cache_entry_deallocator();
}

void __boringssl_context_evaluate_trust_async_external_block_invoke_3(uint64_t a1)
{
  char *BlockSize;
  uint64_t v2;
  uint64_t v4;
  id WeakRetained;
  void *v6;
  _BYTE *v7;
  char v8;
  uint64_t v9;
  id v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  void *v15;
  _BYTE *v16;
  char v17;
  uint64_t v18;
  id v19;
  _BYTE *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  _BOOL4 v25;
  id v26;
  char v27;
  void *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  _BOOL4 v32;
  char v33;
  void *v34;
  int v35;
  SecKeyRef *v36;
  SecKeyRef *v37;
  uint64_t v38;
  uint64_t v39;
  id v40;
  void *v41;
  _BYTE *v42;
  char v43;
  uint64_t v44;
  id v45;
  _BYTE *v46;
  uint64_t v47;
  uint64_t v48;
  id v49;
  void *v50;
  _BYTE *v51;
  char v52;
  uint64_t v53;
  id v54;
  _BYTE *v55;
  uint64_t v56;
  uint64_t AlgorithmId;
  id v58;
  void *v59;
  unsigned __int8 *v60;
  id v61;
  _BYTE *v62;
  id v63;
  void *v64;
  _BYTE *v65;
  char v66;
  uint64_t v67;
  id v68;
  _BYTE *v69;
  uint64_t v70;
  id v71;
  void *v72;
  unsigned __int8 *v73;
  id v74;
  _BYTE *v75;
  uint64_t SignatureHashAlgorithm;
  unsigned int v77;
  id v78;
  void *v79;
  unsigned __int8 *v80;
  id v81;
  _BYTE *v82;
  NSObject *v83;
  uint64_t v84;
  id v85;
  void (*v86)(void);
  id v87;
  void *v88;
  unsigned __int8 *v89;
  id v90;
  _BYTE *v91;
  unsigned __int8 *v92;
  id v93;
  _BYTE *v94;
  NSObject *v95;
  uint64_t v96;
  uint64_t v97;
  NSObject *v98;
  uint64_t v99;
  _BOOL4 v100;
  id v101;
  char v102;
  void *v103;
  uint64_t v104;
  _BOOL4 v105;
  id v106;
  char v107;
  void *v108;
  uint64_t v109;
  _BOOL4 v110;
  id v111;
  char v112;
  void *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  _QWORD v118[4];
  id v119;
  uint64_t v120;
  uint8_t buf[4];
  const char *v122;
  __int16 v123;
  int v124;
  __int16 v125;
  void *v126;
  __int16 v127;
  uint64_t v128;
  __int16 v129;
  int v130;
  uint64_t v131;

  v131 = *MEMORY[0x1E0C80C00];
  if (boringssl_session_get_state(*(_QWORD *)(a1 + 48)) > 3
    || (boringssl_session_is_cancelled(*(_QWORD *)(a1 + 48)) & 1) != 0)
  {
    v4 = *(_QWORD *)(a1 + 32);
    if (!v4)
      goto LABEL_9;
    WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
    if (WeakRetained)
    {
      v6 = WeakRetained;
      v7 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
      v8 = v7[475];

      if ((v8 & 1) != 0)
        goto LABEL_110;
    }
    v9 = *(_QWORD *)(a1 + 32);
    if (v9)
    {
      v10 = objc_loadWeakRetained((id *)(v9 + 16));
      if (v10)
      {
        v11 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
        v12 = (v11[475] & 1) == 0;

      }
      else
      {
        v12 = 1;
      }

      if (!(_DWORD)v12)
        goto LABEL_110;
    }
    else
    {
LABEL_9:
      v12 = 1;
    }
    if (!g_boringssl_log)
    {
LABEL_110:
      *(_BYTE *)(*(_QWORD *)(a1 + 56) + 558) &= ~8u;
      v86 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
LABEL_111:
      v86();
      return;
    }
    v22 = (id)g_boringssl_log;
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      goto LABEL_43;
    v23 = *(_QWORD *)(a1 + 32);
    if (!v23)
    {
      v25 = 0;
      v26 = 0;
      v27 = 1;
      v28 = &unk_1B50022E3;
      goto LABEL_39;
    }
    v12 = (uint64_t)objc_loadWeakRetained((id *)(v23 + 16));
    v24 = *(_QWORD *)(a1 + 32);
    if (v12)
    {
      v25 = v24 != 0;
      if (v24)
      {
        BlockSize = (char *)objc_loadWeakRetained((id *)(v24 + 16));
        v24 = *(_QWORD *)(a1 + 32);
      }
      else
      {
        BlockSize = 0;
      }
      v28 = BlockSize + 391;
      if (v24)
        goto LABEL_38;
    }
    else
    {
      v25 = 0;
      v28 = &unk_1B50022E3;
      if (v24)
      {
LABEL_38:
        v26 = objc_loadWeakRetained((id *)(v24 + 16));
        v27 = 0;
LABEL_39:
        *(_DWORD *)buf = 136446978;
        v122 = "boringssl_context_evaluate_trust_async_external_block_invoke";
        v123 = 1024;
        v124 = 1756;
        v125 = 2082;
        v126 = v28;
        v127 = 2048;
        v128 = (uint64_t)v26;
        _os_log_impl(&dword_1B4F6D000, v22, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] Cancelled during verify block", buf, 0x26u);
        if ((v27 & 1) != 0)
        {
          if (!v25)
            goto LABEL_41;
        }
        else
        {

          if (!v25)
          {
LABEL_41:
            if (v23)
LABEL_42:

LABEL_43:
            goto LABEL_110;
          }
        }

        if (!v23)
          goto LABEL_43;
        goto LABEL_42;
      }
    }
    v26 = 0;
    v27 = 1;
    goto LABEL_39;
  }
  v13 = *(_QWORD *)(a1 + 32);
  if (!v13)
    goto LABEL_16;
  v14 = objc_loadWeakRetained((id *)(v13 + 16));
  if (v14)
  {
    v15 = v14;
    v16 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
    v17 = v16[475];

    if ((v17 & 1) != 0)
      goto LABEL_59;
  }
  v18 = *(_QWORD *)(a1 + 32);
  if (!v18)
  {
LABEL_16:
    v21 = 1;
    goto LABEL_30;
  }
  v19 = objc_loadWeakRetained((id *)(v18 + 16));
  if (v19)
  {
    v20 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
    v21 = (v20[475] & 1) == 0;

  }
  else
  {
    v21 = 1;
  }

  if ((_DWORD)v21)
  {
LABEL_30:
    if (!g_boringssl_log)
      goto LABEL_59;
    v29 = (id)g_boringssl_log;
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_58;
    v30 = *(_QWORD *)(a1 + 32);
    if (v30)
    {
      v21 = (uint64_t)objc_loadWeakRetained((id *)(v30 + 16));
      v31 = *(_QWORD *)(a1 + 32);
      if (v21)
      {
        v32 = v31 != 0;
        if (v31)
        {
          BlockSize = (char *)objc_loadWeakRetained((id *)(v31 + 16));
          v31 = *(_QWORD *)(a1 + 32);
        }
        else
        {
          BlockSize = 0;
        }
        v34 = BlockSize + 391;
      }
      else
      {
        v32 = 0;
        v34 = &unk_1B50022E3;
      }
      if (v31)
      {
        v2 = (uint64_t)objc_loadWeakRetained((id *)(v31 + 16));
        v33 = 0;
      }
      else
      {
        v2 = 0;
        v33 = 1;
      }
    }
    else
    {
      v32 = 0;
      v2 = 0;
      v33 = 1;
      v34 = &unk_1B50022E3;
    }
    v35 = *(unsigned __int8 *)(a1 + 72);
    *(_DWORD *)buf = 136447234;
    v122 = "boringssl_context_evaluate_trust_async_external_block_invoke_3";
    v123 = 1024;
    v124 = 1724;
    v125 = 2082;
    v126 = v34;
    v127 = 2048;
    v128 = v2;
    v129 = 1024;
    v130 = v35;
    _os_log_impl(&dword_1B4F6D000, v29, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] Returning from external verify block with result: %{BOOL}d", buf, 0x2Cu);
    if ((v33 & 1) != 0)
    {
      if (!v32)
        goto LABEL_56;
    }
    else
    {

      if (!v32)
      {
LABEL_56:
        if (!v30)
        {
LABEL_58:

          goto LABEL_59;
        }
LABEL_57:

        goto LABEL_58;
      }
    }

    if (!v30)
      goto LABEL_58;
    goto LABEL_57;
  }
LABEL_59:
  if (!*(_BYTE *)(a1 + 72))
    goto LABEL_110;
  v36 = (SecKeyRef *)*(id *)(a1 + 32);
  v37 = v36;
  if (!v36 || (*((_BYTE *)v36 + 559) & 8) == 0)
    goto LABEL_62;
  BlockSize = (char *)SecKeyGetBlockSize(v36[43]);
  AlgorithmId = SecKeyGetAlgorithmId();
  if (AlgorithmId == 3)
  {
    if (v37[67])
    {
      v71 = objc_loadWeakRetained((id *)v37 + 2);
      if (!v71
        || (v72 = v71,
            v73 = (unsigned __int8 *)objc_loadWeakRetained((id *)v37 + 2),
            v2 = v73[475],
            v73,
            v72,
            (v2 & 1) == 0))
      {
        v74 = objc_loadWeakRetained((id *)v37 + 2);
        if (v74)
        {
          v75 = objc_loadWeakRetained((id *)v37 + 2);
          v2 = (v75[475] & 1) == 0;

        }
        else
        {
          v2 = 1;
        }

        v38 = 4294957413;
        if ((_DWORD)v2 && g_boringssl_log)
        {
          v2 = (uint64_t)(id)g_boringssl_log;
          if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR))
            __boringssl_context_evaluate_trust_async_external_block_invoke_3_cold_5(v37 + 2, BlockSize, v2);
          goto LABEL_164;
        }
        goto LABEL_63;
      }
      goto LABEL_137;
    }
  }
  else if (AlgorithmId == 1 && BlockSize < (char *)v37[66])
  {
    v58 = objc_loadWeakRetained((id *)v37 + 2);
    if (!v58
      || (v59 = v58,
          v60 = (unsigned __int8 *)objc_loadWeakRetained((id *)v37 + 2),
          v2 = v60[475],
          v60,
          v59,
          (v2 & 1) == 0))
    {
      v61 = objc_loadWeakRetained((id *)v37 + 2);
      if (v61)
      {
        v62 = objc_loadWeakRetained((id *)v37 + 2);
        v2 = (v62[475] & 1) == 0;

      }
      else
      {
        v2 = 1;
      }

      v38 = 4294957413;
      if ((_DWORD)v2 && g_boringssl_log)
      {
        v2 = (uint64_t)(id)g_boringssl_log;
        if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR))
          __boringssl_context_evaluate_trust_async_external_block_invoke_3_cold_4(v37 + 2, BlockSize, v2);
LABEL_164:

        goto LABEL_63;
      }
      goto LABEL_63;
    }
LABEL_137:
    v38 = 4294957413;
    goto LABEL_63;
  }
  if (!CFArrayGetValueAtIndex(v37[44], 0))
  {
    BlockSize = (char *)(v37 + 2);
    v87 = objc_loadWeakRetained((id *)v37 + 2);
    if (!v87
      || (v88 = v87,
          v89 = (unsigned __int8 *)objc_loadWeakRetained((id *)v37 + 2),
          v2 = v89[475],
          v89,
          v88,
          (v2 & 1) == 0))
    {
      v90 = objc_loadWeakRetained((id *)v37 + 2);
      if (v90)
      {
        v91 = objc_loadWeakRetained((id *)v37 + 2);
        v2 = (v91[475] & 1) == 0;

      }
      else
      {
        v2 = 1;
      }

      v38 = 4294957412;
      if ((_DWORD)v2 && g_boringssl_log)
      {
        v2 = (uint64_t)(id)g_boringssl_log;
        if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR))
          __boringssl_context_evaluate_trust_async_external_block_invoke_3_cold_1(v37 + 2, v2);
        goto LABEL_164;
      }
      goto LABEL_63;
    }
    goto LABEL_122;
  }
  SignatureHashAlgorithm = SecCertificateGetSignatureHashAlgorithm();
  v77 = *((_DWORD *)v37 + 136);
  BlockSize = (char *)(v37 + 2);
  v78 = objc_loadWeakRetained((id *)v37 + 2);
  v79 = v78;
  if (SignatureHashAlgorithm >= v77)
  {
    if (v78)
    {
      v92 = (unsigned __int8 *)objc_loadWeakRetained((id *)v37 + 2);
      v2 = v92[475];

      if ((v2 & 1) != 0)
      {
LABEL_62:
        v38 = 0;
        goto LABEL_63;
      }
    }
    v93 = objc_loadWeakRetained((id *)v37 + 2);
    if (v93)
    {
      v94 = objc_loadWeakRetained((id *)v37 + 2);
      v2 = (v94[475] & 1) == 0;

    }
    else
    {
      v2 = 1;
    }

    v38 = 0;
    if ((_DWORD)v2 && g_boringssl_log)
    {
      v2 = (uint64_t)(id)g_boringssl_log;
      if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_DEBUG))
        __boringssl_context_evaluate_trust_async_external_block_invoke_3_cold_3(v37 + 2, v2);
      v38 = 0;
      goto LABEL_164;
    }
    goto LABEL_63;
  }
  if (v78)
  {
    v80 = (unsigned __int8 *)objc_loadWeakRetained((id *)v37 + 2);
    v2 = v80[475];

    if ((v2 & 1) != 0)
    {
LABEL_122:
      v38 = 4294957412;
      goto LABEL_63;
    }
  }
  v81 = objc_loadWeakRetained((id *)v37 + 2);
  if (v81)
  {
    v82 = objc_loadWeakRetained((id *)v37 + 2);
    v2 = (v82[475] & 1) == 0;

  }
  else
  {
    v2 = 1;
  }

  v38 = 4294957412;
  if ((_DWORD)v2 && g_boringssl_log)
  {
    v2 = (uint64_t)(id)g_boringssl_log;
    if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR))
      __boringssl_context_evaluate_trust_async_external_block_invoke_3_cold_2(v37 + 2, SignatureHashAlgorithm, v2);
    goto LABEL_164;
  }
LABEL_63:

  v39 = *(_QWORD *)(a1 + 32);
  if ((_DWORD)v38 && (*(_BYTE *)(v39 + 559) & 8) != 0)
  {
    v40 = objc_loadWeakRetained((id *)(v39 + 16));
    if (v40)
    {
      v41 = v40;
      v42 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
      v43 = v42[475];

      if ((v43 & 1) != 0)
        goto LABEL_109;
    }
    v44 = *(_QWORD *)(a1 + 32);
    if (v44)
    {
      v45 = objc_loadWeakRetained((id *)(v44 + 16));
      if (v45)
      {
        v46 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
        v47 = (v46[475] & 1) == 0;

      }
      else
      {
        v47 = 1;
      }

    }
    else
    {
      v47 = 1;
    }
    if (!(_DWORD)v47 || !g_boringssl_log)
      goto LABEL_109;
    v83 = (id)g_boringssl_log;
    if (!os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
    {
LABEL_108:

LABEL_109:
      v84 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 280);
      v85 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 56) + 16));
      (*(void (**)(uint64_t, id, _QWORD, uint64_t))(v84 + 16))(v84, v85, 0, v38);

      goto LABEL_110;
    }
    v99 = *(_QWORD *)(a1 + 32);
    if (v99)
    {
      v47 = (uint64_t)objc_loadWeakRetained((id *)(v99 + 16));
      v114 = *(_QWORD *)(a1 + 32);
      if (v47)
      {
        v100 = v114 != 0;
        if (v114)
        {
          v2 = (uint64_t)objc_loadWeakRetained((id *)(v114 + 16));
          v114 = *(_QWORD *)(a1 + 32);
        }
        else
        {
          v2 = 0;
        }
        v103 = (void *)(v2 + 391);
      }
      else
      {
        v100 = 0;
        v103 = &unk_1B50022E3;
      }
      if (v114)
      {
        v101 = objc_loadWeakRetained((id *)(v114 + 16));
        v102 = 0;
      }
      else
      {
        v101 = 0;
        v102 = 1;
      }
    }
    else
    {
      v100 = 0;
      v101 = 0;
      v102 = 1;
      v103 = &unk_1B50022E3;
    }
    *(_DWORD *)buf = 136446978;
    v122 = "boringssl_context_evaluate_trust_async_external_block_invoke";
    v123 = 1024;
    v124 = 1736;
    v125 = 2082;
    v126 = v103;
    v127 = 2048;
    v128 = (uint64_t)v101;
    _os_log_debug_impl(&dword_1B4F6D000, v83, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Generating ATS violation error", buf, 0x26u);
    if ((v102 & 1) != 0)
    {
      if (!v100)
        goto LABEL_190;
    }
    else
    {

      if (!v100)
      {
LABEL_190:
        if (!v99)
          goto LABEL_108;
        goto LABEL_194;
      }
    }

    if (!v99)
      goto LABEL_108;
LABEL_194:

    goto LABEL_108;
  }
  v48 = *(_QWORD *)(a1 + 56);
  if ((*(_BYTE *)(v48 + 559) & 0x18) != 8)
  {
    v63 = objc_loadWeakRetained((id *)(v39 + 16));
    if (v63)
    {
      v64 = v63;
      v65 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
      v66 = v65[475];

      if ((v66 & 1) != 0)
        goto LABEL_136;
    }
    v67 = *(_QWORD *)(a1 + 32);
    if (v67)
    {
      v68 = objc_loadWeakRetained((id *)(v67 + 16));
      if (v68)
      {
        v69 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
        v70 = (v69[475] & 1) == 0;

      }
      else
      {
        v70 = 1;
      }

    }
    else
    {
      v70 = 1;
    }
    if (!(_DWORD)v70 || !g_boringssl_log)
      goto LABEL_136;
    v98 = (id)g_boringssl_log;
    if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
    {
LABEL_135:

LABEL_136:
      *(_BYTE *)(*(_QWORD *)(a1 + 56) + 558) &= ~8u;
      v86 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
      goto LABEL_111;
    }
    v109 = *(_QWORD *)(a1 + 32);
    if (v109)
    {
      v70 = (uint64_t)objc_loadWeakRetained((id *)(v109 + 16));
      v116 = *(_QWORD *)(a1 + 32);
      if (v70)
      {
        v110 = v116 != 0;
        if (v116)
        {
          BlockSize = (char *)objc_loadWeakRetained((id *)(v116 + 16));
          v116 = *(_QWORD *)(a1 + 32);
        }
        else
        {
          BlockSize = 0;
        }
        v113 = BlockSize + 391;
      }
      else
      {
        v110 = 0;
        v113 = &unk_1B50022E3;
      }
      if (v116)
      {
        v111 = objc_loadWeakRetained((id *)(v116 + 16));
        v112 = 0;
      }
      else
      {
        v111 = 0;
        v112 = 1;
      }
    }
    else
    {
      v110 = 0;
      v111 = 0;
      v112 = 1;
      v113 = &unk_1B50022E3;
    }
    v117 = *(unsigned __int8 *)(a1 + 72);
    *(_DWORD *)buf = 136447234;
    v122 = "boringssl_context_evaluate_trust_async_external_block_invoke_2";
    v123 = 1024;
    v124 = 1751;
    v125 = 2082;
    v126 = v113;
    v127 = 2048;
    v128 = (uint64_t)v111;
    v129 = 1024;
    v130 = v117;
    _os_log_debug_impl(&dword_1B4F6D000, v98, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Setting verify result to %{BOOL}d", buf, 0x2Cu);
    if ((v112 & 1) != 0)
    {
      if (!v110)
        goto LABEL_214;
    }
    else
    {

      if (!v110)
      {
LABEL_214:
        if (!v109)
          goto LABEL_135;
        goto LABEL_218;
      }
    }

    if (!v109)
      goto LABEL_135;
LABEL_218:

    goto LABEL_135;
  }
  v49 = objc_loadWeakRetained((id *)(v48 + 16));
  if (v49)
  {
    v50 = v49;
    v51 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 56) + 16));
    v52 = v51[475];

    if ((v52 & 1) != 0)
      goto LABEL_129;
  }
  v53 = *(_QWORD *)(a1 + 56);
  if (v53)
  {
    v54 = objc_loadWeakRetained((id *)(v53 + 16));
    if (v54)
    {
      v55 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 56) + 16));
      v56 = (v55[475] & 1) == 0;

    }
    else
    {
      v56 = 1;
    }

  }
  else
  {
    v56 = 1;
  }
  if (!(_DWORD)v56 || !g_boringssl_log)
    goto LABEL_129;
  v95 = (id)g_boringssl_log;
  if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
  {
    v104 = *(_QWORD *)(a1 + 56);
    if (v104)
    {
      v56 = (uint64_t)objc_loadWeakRetained((id *)(v104 + 16));
      v115 = *(_QWORD *)(a1 + 56);
      if (v56)
      {
        v105 = v115 != 0;
        if (v115)
        {
          BlockSize = (char *)objc_loadWeakRetained((id *)(v115 + 16));
          v115 = *(_QWORD *)(a1 + 56);
        }
        else
        {
          BlockSize = 0;
        }
        v108 = BlockSize + 391;
      }
      else
      {
        v105 = 0;
        v108 = &unk_1B50022E3;
      }
      if (v115)
      {
        v106 = objc_loadWeakRetained((id *)(v115 + 16));
        v107 = 0;
      }
      else
      {
        v106 = 0;
        v107 = 1;
      }
    }
    else
    {
      v105 = 0;
      v106 = 0;
      v107 = 1;
      v108 = &unk_1B50022E3;
    }
    *(_DWORD *)buf = 136446978;
    v122 = "boringssl_context_evaluate_trust_async_external_block_invoke";
    v123 = 1024;
    v124 = 1745;
    v125 = 2082;
    v126 = v108;
    v127 = 2048;
    v128 = (uint64_t)v106;
    _os_log_debug_impl(&dword_1B4F6D000, v95, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Performing local ATS trust evaluation", buf, 0x26u);
    if ((v107 & 1) != 0)
    {
      if (!v105)
        goto LABEL_202;
    }
    else
    {

      if (!v105)
      {
LABEL_202:
        if (!v104)
          goto LABEL_128;
        goto LABEL_206;
      }
    }

    if (!v104)
      goto LABEL_128;
LABEL_206:

  }
LABEL_128:

LABEL_129:
  v118[0] = MEMORY[0x1E0C809B0];
  v118[1] = 3221225472;
  v118[2] = __boringssl_context_evaluate_trust_async_external_block_invoke_203;
  v118[3] = &unk_1E6879050;
  v96 = *(_QWORD *)(a1 + 64);
  v120 = *(_QWORD *)(a1 + 56);
  v97 = *(_QWORD *)(a1 + 48);
  v119 = *(id *)(a1 + 40);
  boringssl_context_evaluate_trust_async_internal(v97, v96, v118);

}

void __boringssl_context_certificate_verify_callback_block_invoke(uint64_t a1, char a2)
{
  uint64_t v2;
  uint64_t v3;
  id WeakRetained;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if (*(_DWORD *)v2 == -1252936367)
    {
      v3 = *(_QWORD *)(v2 + 8);
      if (v3)
      {
        *(_BYTE *)(v3 + 320) = a2;
        *(_BYTE *)(v3 + 558) |= 4u;
      }
    }
  }
  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
  nw_protocol_boringssl_handshake_negotiate(WeakRetained);

}

void __boringssl_context_new_session_handler_block_invoke(uint64_t a1)
{
  char *v1;
  uint64_t v3;
  id WeakRetained;
  void *v5;
  _BYTE *v6;
  char v7;
  uint64_t v8;
  id v9;
  _BYTE *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL4 v15;
  id v16;
  char v17;
  void *v18;
  int v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  void *v24;
  __int16 v25;
  id v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 168) + 16))();
  v3 = *(_QWORD *)(a1 + 32);
  if (!v3)
    goto LABEL_7;
  WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
  if (WeakRetained)
  {
    v5 = WeakRetained;
    v6 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
    v7 = v6[475];

    if ((v7 & 1) != 0)
      return;
  }
  v8 = *(_QWORD *)(a1 + 32);
  if (!v8)
  {
LABEL_7:
    v11 = 1;
    goto LABEL_10;
  }
  v9 = objc_loadWeakRetained((id *)(v8 + 16));
  if (v9)
  {
    v10 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
    v11 = (v10[475] & 1) == 0;

  }
  else
  {
    v11 = 1;
  }

  if ((_DWORD)v11)
  {
LABEL_10:
    if (!g_boringssl_log)
      return;
    v12 = (id)g_boringssl_log;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      goto LABEL_26;
    v13 = *(_QWORD *)(a1 + 32);
    if (!v13)
    {
      v15 = 0;
      v16 = 0;
      v17 = 1;
      v18 = &unk_1B50022E3;
      goto LABEL_22;
    }
    v11 = (uint64_t)objc_loadWeakRetained((id *)(v13 + 16));
    v14 = *(_QWORD *)(a1 + 32);
    if (v11)
    {
      v15 = v14 != 0;
      if (v14)
      {
        v1 = (char *)objc_loadWeakRetained((id *)(v14 + 16));
        v14 = *(_QWORD *)(a1 + 32);
      }
      else
      {
        v1 = 0;
      }
      v18 = v1 + 391;
      if (v14)
        goto LABEL_21;
    }
    else
    {
      v15 = 0;
      v18 = &unk_1B50022E3;
      if (v14)
      {
LABEL_21:
        v16 = objc_loadWeakRetained((id *)(v14 + 16));
        v17 = 0;
LABEL_22:
        v19 = 136446978;
        v20 = "boringssl_context_new_session_handler_block_invoke";
        v21 = 1024;
        v22 = 1489;
        v23 = 2082;
        v24 = v18;
        v25 = 2048;
        v26 = v16;
        _os_log_impl(&dword_1B4F6D000, v12, OS_LOG_TYPE_DEFAULT, "%{public}s(%d) %{public}s[%p] Returning from session update block", (uint8_t *)&v19, 0x26u);
        if ((v17 & 1) != 0)
        {
          if (!v15)
            goto LABEL_24;
        }
        else
        {

          if (!v15)
          {
LABEL_24:
            if (!v13)
            {
LABEL_26:

              return;
            }
LABEL_25:

            goto LABEL_26;
          }
        }

        if (!v13)
          goto LABEL_26;
        goto LABEL_25;
      }
    }
    v16 = 0;
    v17 = 1;
    goto LABEL_22;
  }
}

void __nw_protocol_boringssl_identifier_block_invoke()
{
  qword_1ECD85E60 = 0;
  g_boringssl_protocol_identifier = 0u;
  *(_OWORD *)algn_1ECD85E50 = 0u;
  g_boringssl_protocol_callbacks = 0u;
  *(_OWORD *)&qword_1ECD85E80 = 0u;
  xmmword_1ECD85E90 = 0u;
  unk_1ECD85EA0 = 0u;
  xmmword_1ECD85EB0 = 0u;
  unk_1ECD85EC0 = 0u;
  xmmword_1ECD85ED0 = 0u;
  unk_1ECD85EE0 = 0u;
  xmmword_1ECD85EF0 = 0u;
  unk_1ECD85F00 = 0u;
  xmmword_1ECD85F10 = 0u;
  unk_1ECD85F20 = 0u;
  xmmword_1ECD85F30 = 0u;
  unk_1ECD85F40 = 0u;
  xmmword_1ECD85F50 = 0u;
  unk_1ECD85F60 = 0u;
  xmmword_1ECD85F70 = 0u;
  __strlcpy_chk();
  qword_1ECD85E60 = 0x100000004;
  nw_protocol_set_default_one_to_one_callbacks();
  *(_QWORD *)&g_boringssl_protocol_callbacks = nw_protocol_boringssl_add_input_handler;
  *((_QWORD *)&g_boringssl_protocol_callbacks + 1) = nw_protocol_boringssl_remove_input_handler;
  *((_QWORD *)&xmmword_1ECD85EB0 + 1) = nw_protocol_boringssl_output_available;
  unk_1ECD85EC0 = nw_protocol_boringssl_get_input_frames;
  qword_1ECD85F28 = (uint64_t)nw_protocol_boringssl_input_finished;
  *(_QWORD *)&xmmword_1ECD85F30 = nw_protocol_boringssl_output_finished;
  qword_1ECD85EC8 = (uint64_t)nw_protocol_boringssl_get_output_frames;
  *(_QWORD *)&xmmword_1ECD85ED0 = nw_protocol_boringssl_finalize_output_frames;
  qword_1ECD85E80 = (uint64_t)nw_protocol_boringssl_replace_input_handler;
  unk_1ECD85E88 = nw_protocol_boringssl_connect;
  *(_QWORD *)&xmmword_1ECD85E90 = nw_protocol_boringssl_disconnect;
  *((_QWORD *)&xmmword_1ECD85E90 + 1) = nw_protocol_boringssl_connected;
  *(_QWORD *)&xmmword_1ECD85F70 = nw_protocol_boringssl_reset;
  qword_1ECD85F48 = (uint64_t)nw_protocol_boringssl_waiting_for_output;
  *(_QWORD *)&xmmword_1ECD85F50 = nw_protocol_boringssl_copy_info;
  qword_1ECD85EA8 = (uint64_t)nw_protocol_boringssl_error;
  *(_QWORD *)&xmmword_1ECD85EB0 = nw_protocol_boringssl_input_available;
  nw_protocol_register();
  boringssl_log_open();
}

double EVP_sha384_init()
{
  double result;

  EVP_sha384_storage = 0x30000002A1;
  dword_1ECD85978 = 0;
  qword_1ECD85980 = (uint64_t)sha384_init;
  unk_1ECD85988 = digest_update_wrapper;
  qword_1ECD85990 = (uint64_t)digest_final_wrapper;
  *(_QWORD *)&result = 0x40800000080;
  qword_1ECD85998 = 0x40800000080;
  return result;
}

double EVP_aead_aes_128_gcm_tls13_init()
{
  double result;

  *(_OWORD *)algn_1ECD85538 = 0u;
  xmmword_1ECD85548 = 0u;
  unk_1ECD85568 = 0u;
  *(_QWORD *)&result = 269487120;
  EVP_aead_aes_128_gcm_tls13_storage = 269487120;
  dword_1ECD85534 = 1;
  qword_1ECD85540 = (uint64_t)aead_aes_gcm_init_with_dir;
  *(_QWORD *)&xmmword_1ECD85548 = aead_aes_gcm_cleanup;
  qword_1ECD85558 = (uint64_t)aead_aes_gcm_tls13_seal_scatter;
  unk_1ECD85560 = aead_aes_gcm_open_gather;
  return result;
}

uint64_t __boringssl_config_get_whitelisted_bundle_identifier_block_invoke()
{
  uint64_t result;
  uint64_t v1;
  const char *v2;
  BOOL v3;
  BOOL v4;
  BOOL v5;
  uint64_t v6;

  getpid();
  result = csops();
  if ((_DWORD)result == -1
    && (result = (uint64_t)__error(), *(_DWORD *)result == 34)
    && (v1 = bswap32(0xAAAAAAAA), (v1 - 1025) >= 0xFFFFFC07)
    && (getpid(), result = csops(), !(_DWORD)result))
  {
    csops_identifier_data_csops_data[v1] = 0;
    v3 = qword_1ECD859F4 == 0x6C7070612E6D6F63 && word_1ECD859FC == 11877;
    if (v3
      || (qword_1ECD859F4 == 0x6C7070612E6D6F63 ? (v4 = *(_QWORD *)&word_1ECD859FC == 0x6565685364412E65) : (v4 = 0),
          v4 ? (v5 = unk_1ECD85A03 == 0x656E6F68507465) : (v5 = 0),
          v5))
    {
LABEL_22:
      result = (uint64_t)strdup((const char *)&qword_1ECD859F4);
      v2 = (const char *)result;
    }
    else
    {
      v6 = 1;
      v2 = "redacted_bundle_id";
      while (v6 != 251)
      {
        result = strcmp(top_bundles[v6++], (const char *)&qword_1ECD859F4);
        if (!(_DWORD)result)
        {
          if ((unint64_t)(v6 - 2) <= 0xF9)
            goto LABEL_22;
          v2 = "redacted_bundle_id";
          break;
        }
      }
    }
  }
  else
  {
    v2 = "no_bundle_id";
  }
  global_bundle_identifier = (uint64_t)v2;
  return result;
}

uint64_t boringssl_context_zlib_uncompress_data(const SSL *a1, uint64_t *a2, size_t a3, char *a4, uint64_t a5)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  void *v13;
  id *v15;
  id v16;
  _BYTE *v17;
  _BOOL4 v18;
  id v19;
  _BYTE *v20;
  _BOOL4 v21;
  id *v22;
  id WeakRetained;
  _BYTE *v24;
  _BOOL4 v25;
  id v26;
  _BYTE *v27;
  _BOOL4 v28;
  NSObject *v30;
  NSObject *v32;
  id v33;
  void *v34;
  id v35;
  uint64_t v36;
  _QWORD v37[8];
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  int v45;
  __int16 v46;
  void *v47;
  __int16 v48;
  id v49;
  __int16 v50;
  size_t v51;
  __int16 v52;
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v9 = SSL_get_ex_data(a1, 0);
  if (!v9 || *(_DWORD *)v9 != -1252936367)
    return 0;
  v10 = 0;
  if (a3)
  {
    if (a2)
    {
      v11 = v9[1];
      if (v11)
      {
        v12 = malloc_type_malloc(a3, 0x611F108CuLL);
        if (v12)
        {
          v13 = v12;
          v38 = 0;
          v39 = &v38;
          v40 = 0x2020000000;
          v41 = 0;
          v37[0] = MEMORY[0x1E0C809B0];
          v37[1] = 3221225472;
          v37[2] = __boringssl_context_zlib_uncompress_data_block_invoke;
          v37[3] = &unk_1E6879220;
          v37[4] = &v38;
          v37[5] = a3;
          v37[6] = v11;
          v37[7] = v12;
          if ((boringssl_helper_zlib_decompress_data((void *)v11, (uint64_t)a4, a5, v37) & 1) != 0)
          {
            if (v39[3] == a3)
            {
              *a2 = CRYPTO_BUFFER_new(v13, a3, 0);
              free(v13);
              *(_BYTE *)(v11 + 559) |= 0x40u;
              v10 = 1;
              *(_WORD *)(v11 + 336) = 1;
LABEL_40:
              _Block_object_dispose(&v38, 8);
              return v10;
            }
            v22 = (id *)(v11 + 16);
            WeakRetained = objc_loadWeakRetained((id *)(v11 + 16));
            if (!WeakRetained
              || (v24 = objc_loadWeakRetained(v22),
                  v25 = (v24[475] & 1) == 0,
                  v24,
                  WeakRetained,
                  v25))
            {
              v26 = objc_loadWeakRetained(v22);
              if (v26)
              {
                v27 = objc_loadWeakRetained(v22);
                v28 = (v27[475] & 1) == 0;

              }
              else
              {
                v28 = 1;
              }

              if (g_boringssl_log && v28)
              {
                v32 = (id)g_boringssl_log;
                if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                {
                  v33 = objc_loadWeakRetained(v22);
                  if (v33)
                  {
                    a4 = (char *)objc_loadWeakRetained(v22);
                    v34 = a4 + 391;
                  }
                  else
                  {
                    v34 = &unk_1B50022E3;
                  }
                  v35 = objc_loadWeakRetained(v22);
                  v36 = v39[3];
                  *(_DWORD *)buf = 136447490;
                  v43 = "boringssl_context_zlib_uncompress_data";
                  v44 = 1024;
                  v45 = 785;
                  v46 = 2082;
                  v47 = v34;
                  v48 = 2048;
                  v49 = v35;
                  v50 = 2048;
                  v51 = a3;
                  v52 = 2048;
                  v53 = v36;
                  _os_log_error_impl(&dword_1B4F6D000, v32, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] Incorrect uncompressed length. Expected %zu, got %zu", buf, 0x3Au);

                  if (v33)
                }

              }
            }
          }
          else
          {
            v15 = (id *)(v11 + 16);
            v16 = objc_loadWeakRetained((id *)(v11 + 16));
            if (!v16
              || (v17 = objc_loadWeakRetained(v15), v18 = (v17[475] & 1) == 0, v17, v16, v18))
            {
              v19 = objc_loadWeakRetained(v15);
              if (v19)
              {
                v20 = objc_loadWeakRetained(v15);
                v21 = (v20[475] & 1) == 0;

              }
              else
              {
                v21 = 1;
              }

              if (g_boringssl_log && v21)
              {
                v30 = (id)g_boringssl_log;
                if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
                  boringssl_context_zlib_uncompress_data_cold_2(v15, v30);

              }
            }
          }
          v10 = 0;
          goto LABEL_40;
        }
        if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          boringssl_context_zlib_uncompress_data_cold_1();
        return 0;
      }
    }
  }
  return v10;
}

void sub_1B4FB1C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t boringssl_helper_zlib_decompress_data(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id *v7;
  id v8;
  unsigned int (**v9)(_QWORD, _QWORD, _QWORD);
  uint64_t v10;
  id WeakRetained;
  void *v12;
  _BYTE *v13;
  char v14;
  id v15;
  _BYTE *v16;
  _BOOL4 v17;
  uInt v18;
  uint64_t v19;
  NSObject *v20;
  z_stream v22;
  _BYTE __b[1024];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a4;
  v9 = (unsigned int (**)(_QWORD, _QWORD, _QWORD))v8;
  v10 = 0;
  if (v7 && a2 && a3 && v8)
  {
    memset(&v22, 0, sizeof(v22));
    if (inflateInit_(&v22, "1.2.12", 112))
    {
      WeakRetained = objc_loadWeakRetained(v7 + 2);
      if (WeakRetained)
      {
        v12 = WeakRetained;
        v13 = objc_loadWeakRetained(v7 + 2);
        v14 = v13[475];

        if ((v14 & 1) != 0)
        {
LABEL_28:
          v10 = 0;
          goto LABEL_31;
        }
      }
      v15 = objc_loadWeakRetained(v7 + 2);
      if (v15)
      {
        v16 = objc_loadWeakRetained(v7 + 2);
        v17 = (v16[475] & 1) == 0;

      }
      else
      {
        v17 = 1;
      }

      v10 = 0;
      if (v17 && g_boringssl_log)
      {
        v20 = (id)g_boringssl_log;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          boringssl_helper_zlib_decompress_data_cold_1(v7, v20);

        goto LABEL_28;
      }
    }
    else
    {
      memset(__b, 170, sizeof(__b));
      while (1)
      {
        v18 = a3 - LODWORD(v22.total_in);
        if (a3 - v22.total_in >= 0x400)
          v18 = 1024;
        v22.avail_in = v18;
        if (!v18)
          break;
        v22.avail_out = 1024;
        v22.next_in = (Bytef *)(a2 + v22.total_in);
        v22.next_out = __b;
        v19 = inflate(&v22, 0);
        if ((_DWORD)v19 == 2)
        {
          v10 = 4294967293;
        }
        else
        {
          v10 = v19;
          if ((v19 + 4) < 2)
            goto LABEL_21;
        }
        if (!((unsigned int (**)(_QWORD, _BYTE *, uint64_t))v9)[2](v9, __b, 1024 - v22.avail_out))
        {
LABEL_21:
          v10 = 0;
          goto LABEL_30;
        }
        if ((_DWORD)v10 == 1)
          goto LABEL_30;
      }
      v10 = 1;
LABEL_30:
      inflateEnd(&v22);
    }
  }
LABEL_31:

  return v10;
}

BOOL __boringssl_context_zlib_uncompress_data_block_invoke(_QWORD *a1, const void *a2, size_t __n)
{
  char *v3;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  id v9;
  void *v10;
  _BYTE *v11;
  char v12;
  uint64_t v13;
  id v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  id WeakRetained;
  void *v19;
  _BYTE *v20;
  char v21;
  uint64_t v22;
  id v23;
  _BYTE *v24;
  NSObject *v25;
  uint64_t v26;
  _BOOL4 v27;
  id v28;
  char v29;
  void *v30;
  char v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  void *v41;
  __int16 v42;
  id v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  v7 = a1[5] - v6;
  if (v7 < __n)
  {
    v17 = a1[6];
    if (!v17)
      goto LABEL_15;
    WeakRetained = objc_loadWeakRetained((id *)(v17 + 16));
    if (WeakRetained)
    {
      v19 = WeakRetained;
      v20 = objc_loadWeakRetained((id *)(a1[6] + 16));
      v21 = v20[475];

      if ((v21 & 1) != 0)
        return v7 >= __n;
    }
    v22 = a1[6];
    if (v22)
    {
      v23 = objc_loadWeakRetained((id *)(v22 + 16));
      if (v23)
      {
        v24 = objc_loadWeakRetained((id *)(a1[6] + 16));
        v16 = (v24[475] & 1) == 0;

      }
      else
      {
        v16 = 1;
      }

      if (!(_DWORD)v16)
        return v7 >= __n;
    }
    else
    {
LABEL_15:
      v16 = 1;
    }
    if (g_boringssl_log)
    {
      v25 = (id)g_boringssl_log;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        v26 = a1[6];
        if (v26)
        {
          v16 = (uint64_t)objc_loadWeakRetained((id *)(v26 + 16));
          v35 = a1[6];
          if (v16)
          {
            v27 = v35 != 0;
            if (v35)
            {
              v3 = (char *)objc_loadWeakRetained((id *)(v35 + 16));
              v35 = a1[6];
            }
            else
            {
              v3 = 0;
            }
            v33 = v3 + 391;
          }
          else
          {
            v27 = 0;
            v33 = &unk_1B50022E3;
          }
          if (v35)
          {
            v28 = objc_loadWeakRetained((id *)(v35 + 16));
            v32 = 0;
          }
          else
          {
            v28 = 0;
            v32 = 1;
          }
        }
        else
        {
          v27 = 0;
          v28 = 0;
          v32 = 1;
          v33 = &unk_1B50022E3;
        }
        v36 = 136446978;
        v37 = "boringssl_context_zlib_uncompress_data_block_invoke";
        v38 = 1024;
        v39 = 770;
        v40 = 2082;
        v41 = v33;
        v42 = 2048;
        v43 = v28;
        _os_log_error_impl(&dword_1B4F6D000, v25, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] Uncompressed data length exceeded buffer bounds", (uint8_t *)&v36, 0x26u);
        if ((v32 & 1) != 0)
          goto LABEL_52;
LABEL_51:

LABEL_52:
        if (v27)

        if (v26)
      }
LABEL_26:

    }
  }
  else
  {
    memcpy((void *)(a1[7] + v6), a2, __n);
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) += __n;
    v8 = a1[6];
    if (!v8)
      goto LABEL_14;
    v9 = objc_loadWeakRetained((id *)(v8 + 16));
    if (v9)
    {
      v10 = v9;
      v11 = objc_loadWeakRetained((id *)(a1[6] + 16));
      v12 = v11[475];

      if ((v12 & 1) != 0)
        return v7 >= __n;
    }
    v13 = a1[6];
    if (v13)
    {
      v14 = objc_loadWeakRetained((id *)(v13 + 16));
      if (v14)
      {
        v15 = objc_loadWeakRetained((id *)(a1[6] + 16));
        v16 = (v15[475] & 1) == 0;

      }
      else
      {
        v16 = 1;
      }

      if (!(_DWORD)v16)
        return v7 >= __n;
    }
    else
    {
LABEL_14:
      v16 = 1;
    }
    if (g_boringssl_log)
    {
      v25 = (id)g_boringssl_log;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        v26 = a1[6];
        if (v26)
        {
          v16 = (uint64_t)objc_loadWeakRetained((id *)(v26 + 16));
          v34 = a1[6];
          if (v16)
          {
            v27 = v34 != 0;
            if (v34)
            {
              v3 = (char *)objc_loadWeakRetained((id *)(v34 + 16));
              v34 = a1[6];
            }
            else
            {
              v3 = 0;
            }
            v30 = v3 + 391;
          }
          else
          {
            v27 = 0;
            v30 = &unk_1B50022E3;
          }
          if (v34)
          {
            v28 = objc_loadWeakRetained((id *)(v34 + 16));
            v29 = 0;
          }
          else
          {
            v28 = 0;
            v29 = 1;
          }
        }
        else
        {
          v27 = 0;
          v28 = 0;
          v29 = 1;
          v30 = &unk_1B50022E3;
        }
        v36 = 136446978;
        v37 = "boringssl_context_zlib_uncompress_data_block_invoke";
        v38 = 1024;
        v39 = 775;
        v40 = 2082;
        v41 = v30;
        v42 = 2048;
        v43 = v28;
        _os_log_debug_impl(&dword_1B4F6D000, v25, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Wrote decompressed certificate data", (uint8_t *)&v36, 0x26u);
        if ((v29 & 1) != 0)
          goto LABEL_52;
        goto LABEL_51;
      }
      goto LABEL_26;
    }
  }
  return v7 >= __n;
}

uint64_t CRYPTO_BUFFER_new(const void *a1, unint64_t a2, _QWORD **a3)
{
  return crypto_buffer_new(a1, a2, 0, a3);
}

double EVP_aead_aes_256_gcm_tls13_init()
{
  double result;

  unk_1ECD858E0 = 0u;
  xmmword_1ECD858F0 = 0u;
  unk_1ECD85910 = 0u;
  *(_QWORD *)&result = 269487136;
  EVP_aead_aes_256_gcm_tls13_storage = 269487136;
  dword_1ECD858DC = 1;
  qword_1ECD858E8 = (uint64_t)aead_aes_gcm_init_with_dir;
  *(_QWORD *)&xmmword_1ECD858F0 = aead_aes_gcm_cleanup;
  qword_1ECD85900 = (uint64_t)aead_aes_gcm_tls13_seal_scatter;
  unk_1ECD85908 = aead_aes_gcm_open_gather;
  return result;
}

void EC_GFp_nistp224_method_init()
{
  EC_GFp_nistp224_method_storage = (uint64_t)ec_GFp_simple_group_init;
  *(_QWORD *)algn_1ECD85658 = ec_GFp_simple_group_finish;
  qword_1ECD85660 = (uint64_t)ec_GFp_simple_group_set_curve;
  unk_1ECD85668 = ec_GFp_nistp224_point_get_affine_coordinates;
  qword_1ECD85678 = (uint64_t)ec_GFp_nistp224_add;
  unk_1ECD85680 = ec_GFp_nistp224_dbl;
  qword_1ECD85688 = (uint64_t)ec_GFp_nistp224_point_mul;
  unk_1ECD85690 = ec_GFp_nistp224_point_mul_base;
  qword_1ECD856A0 = (uint64_t)ec_GFp_nistp224_point_mul_public;
  qword_1ECD856C0 = (uint64_t)ec_GFp_nistp224_felem_mul;
  unk_1ECD856C8 = ec_GFp_nistp224_felem_sqr;
  qword_1ECD856D0 = (uint64_t)ec_GFp_simple_felem_to_bytes;
  unk_1ECD856D8 = ec_GFp_simple_felem_from_bytes;
  qword_1ECD856F0 = (uint64_t)ec_simple_scalar_inv0_montgomery;
  unk_1ECD856F8 = ec_simple_scalar_to_montgomery_inv_vartime;
  qword_1ECD85700 = (uint64_t)ec_GFp_simple_cmp_x_coordinate;
}

void EC_GFp_nistp256_method_init()
{
  EC_GFp_nistp256_method_storage = (uint64_t)ec_GFp_mont_group_init;
  *(_QWORD *)algn_1ECD85828 = ec_GFp_mont_group_finish;
  qword_1ECD85830 = (uint64_t)ec_GFp_mont_group_set_curve;
  unk_1ECD85838 = ec_GFp_nistp256_point_get_affine_coordinates;
  qword_1ECD85848 = (uint64_t)ec_GFp_nistp256_add;
  unk_1ECD85850 = ec_GFp_nistp256_dbl;
  qword_1ECD85858 = (uint64_t)ec_GFp_nistp256_point_mul;
  unk_1ECD85860 = ec_GFp_nistp256_point_mul_base;
  qword_1ECD85870 = (uint64_t)ec_GFp_nistp256_point_mul_public;
  qword_1ECD85890 = (uint64_t)ec_GFp_mont_felem_mul;
  unk_1ECD85898 = ec_GFp_mont_felem_sqr;
  qword_1ECD858A0 = (uint64_t)ec_GFp_mont_felem_to_bytes;
  unk_1ECD858A8 = ec_GFp_mont_felem_from_bytes;
  qword_1ECD858B0 = (uint64_t)ec_GFp_mont_felem_reduce;
  unk_1ECD858B8 = ec_GFp_mont_felem_exp;
  qword_1ECD858C0 = (uint64_t)ec_simple_scalar_inv0_montgomery;
  unk_1ECD858C8 = ec_simple_scalar_to_montgomery_inv_vartime;
  qword_1ECD858D0 = (uint64_t)ec_GFp_nistp256_cmp_x_coordinate;
}

void EC_GFp_mont_method_init()
{
  EC_GFp_mont_method_storage = (uint64_t)ec_GFp_mont_group_init;
  unk_1ECD855A0 = ec_GFp_mont_group_finish;
  qword_1ECD855A8 = (uint64_t)ec_GFp_mont_group_set_curve;
  unk_1ECD855B0 = ec_GFp_mont_point_get_affine_coordinates;
  qword_1ECD855B8 = (uint64_t)ec_GFp_mont_jacobian_to_affine_batch;
  unk_1ECD855C0 = ec_GFp_mont_add;
  qword_1ECD855C8 = (uint64_t)ec_GFp_mont_dbl;
  unk_1ECD855D0 = ec_GFp_mont_mul;
  qword_1ECD855D8 = (uint64_t)ec_GFp_mont_mul_base;
  unk_1ECD855E0 = ec_GFp_mont_mul_batch;
  qword_1ECD855F0 = (uint64_t)ec_GFp_mont_mul_public_batch;
  unk_1ECD855F8 = ec_GFp_mont_init_precomp;
  qword_1ECD85600 = (uint64_t)ec_GFp_mont_mul_precomp;
  unk_1ECD85608 = ec_GFp_mont_felem_mul;
  qword_1ECD85610 = (uint64_t)ec_GFp_mont_felem_sqr;
  unk_1ECD85618 = ec_GFp_mont_felem_to_bytes;
  qword_1ECD85620 = (uint64_t)ec_GFp_mont_felem_from_bytes;
  unk_1ECD85628 = ec_GFp_mont_felem_reduce;
  qword_1ECD85630 = (uint64_t)ec_GFp_mont_felem_exp;
  unk_1ECD85638 = ec_simple_scalar_inv0_montgomery;
  qword_1ECD85640 = (uint64_t)ec_simple_scalar_to_montgomery_inv_vartime;
  unk_1ECD85648 = ec_GFp_mont_cmp_x_coordinate;
}

double EVP_md5_sha1_init()
{
  double result;

  EVP_md5_sha1_storage = 0x2400000072;
  dword_1ECD85508 = 0;
  qword_1ECD85510 = (uint64_t)md5_sha1_init;
  unk_1ECD85518 = md5_sha1_update;
  qword_1ECD85520 = (uint64_t)md5_sha1_final;
  *(_QWORD *)&result = 0x81000000040;
  qword_1ECD85528 = 0x81000000040;
  return result;
}

uint64_t __nw_protocol_boringssl_remove_input_handler_block_invoke(uint64_t a1, void *a2)
{
  id v2;

  v2 = a2;
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1;
}

void thread_local_destructor(char *a1)
{
  uint64_t i;
  void (*v3)(_QWORD);
  _OWORD v4[2];
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a1 && !pthread_mutex_lock(&g_destructors_lock))
  {
    v4[0] = g_destructors;
    v4[1] = unk_1ECD85E08;
    v5 = qword_1ECD85E18;
    pthread_mutex_unlock(&g_destructors_lock);
    for (i = 0; i != 40; i += 8)
    {
      v3 = *(void (**)(_QWORD))((char *)v4 + i);
      if (v3)
        v3(*(_QWORD *)&a1[i]);
    }
    free(a1);
  }
}

void parse_integer_cold_1()
{
  __assert_rtn("parse_integer", "dsa_asn1.c", 133, "*out == NULL");
}

void parse_integer_cold_1_0()
{
  __assert_rtn("parse_integer", "rsa_asn1.c", 73, "*out == NULL");
}

uint64_t nw_protocol_boringssl_error(uint64_t result, uint64_t a2, uint64_t __errnum)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  __int16 v27;
  char *v28;
  char __strerrbuf[16];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE v34[21];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!result)
    return result;
  v3 = result;
  v4 = *(_QWORD *)(result + 40);
  if (!v4)
    return result;
  if ((*(_BYTE *)(v4 + 475) & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_error_cold_1();
  }
  *(_DWORD *)(v4 + 384) = __errnum;
  v33 = 0u;
  memset(v34, 0, sizeof(v34));
  v31 = 0u;
  v32 = 0u;
  *(_OWORD *)__strerrbuf = 0u;
  v30 = 0u;
  strerror_r(__errnum, __strerrbuf, 0x64uLL);
  if (boringssl_session_get_state(*(_QWORD *)(v4 + 336)) < 2)
  {
    if ((*(_BYTE *)(v4 + 388) & 4) != 0)
    {
      if ((*(_BYTE *)(v4 + 389) & 0xC0) == 0x80)
        goto LABEL_16;
      if ((*(_BYTE *)(v4 + 475) & 1) != 0)
        goto LABEL_16;
      v14 = g_boringssl_log;
      if (!g_boringssl_log || !os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_16;
      v17 = 136447490;
      v18 = "nw_protocol_boringssl_error";
      v19 = 1024;
      v20 = 1971;
      v21 = 2082;
      v22 = v4 + 391;
      v23 = 2048;
      v24 = v4;
      v25 = 1024;
      v26 = __errnum;
      v27 = 2080;
      v28 = __strerrbuf;
      v13 = "%{public}s(%d) %{public}s[%p] Lower protocol stack error during TLS handshake. [%d: %s]";
    }
    else
    {
      if ((*(_BYTE *)(v4 + 475) & 1) != 0)
        goto LABEL_16;
      v14 = g_boringssl_log;
      if (!g_boringssl_log || !os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_16;
      v17 = 136447490;
      v18 = "nw_protocol_boringssl_error";
      v19 = 1024;
      v20 = 1973;
      v21 = 2082;
      v22 = v4 + 391;
      v23 = 2048;
      v24 = v4;
      v25 = 1024;
      v26 = __errnum;
      v27 = 2080;
      v28 = __strerrbuf;
      v13 = "%{public}s(%d) %{public}s[%p] Lower protocol stack error pre TLS handshake. [%d: %s]";
    }
    v12 = v14;
    goto LABEL_29;
  }
  if ((*(_BYTE *)(v4 + 475) & 1) == 0)
  {
    if (g_boringssl_log)
    {
      v11 = g_boringssl_log;
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEFAULT))
      {
        v12 = v11;
        v17 = 136447490;
        v18 = "nw_protocol_boringssl_error";
        v19 = 1024;
        v20 = 1968;
        v21 = 2082;
        v22 = v4 + 391;
        v23 = 2048;
        v24 = v4;
        v25 = 1024;
        v26 = __errnum;
        v27 = 2080;
        v28 = __strerrbuf;
        v13 = "%{public}s(%d) %{public}s[%p] Lower protocol stack error post TLS handshake. [%d: %s]";
LABEL_29:
        _os_log_impl(&dword_1B4F6D000, v12, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v17, 0x36u);
      }
    }
  }
LABEL_16:
  result = *(_QWORD *)(v3 + 48);
  if (result)
  {
    v15 = *(_QWORD *)(result + 24);
    if (v15)
    {
      v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v15 + 56);
      if (v16)
        return v16(result, a2, __errnum, v7, v8, v9, v10);
    }
  }
  return result;
}

void err_state_free(void **a1)
{
  uint64_t i;
  void **v3;

  if (a1)
  {
    for (i = 0; i != 48; i += 3)
    {
      v3 = &a1[i];
      free(a1[i + 1]);
      *v3 = 0;
      v3[1] = 0;
      v3[2] = 0;
    }
    free(a1[49]);
    free(a1);
  }
}

BOOL bssl::ssl_session_is_time_valid(bssl *this, const ssl_st *a2, const ssl_session_st *a3)
{
  EVP_CIPHER_CTX *enc_read_ctx;
  _QWORD v6[2];

  if (!a2)
    return 0;
  v6[0] = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = 0xAAAAAAAAAAAAAAAALL;
  bssl::ssl_get_current_time((uint64_t)this, (uint64_t)v6);
  enc_read_ctx = a2->enc_read_ctx;
  return v6[0] >= (unint64_t)enc_read_ctx
      && v6[0] - (_QWORD)enc_read_ctx < (unint64_t)LODWORD(a2->cipher_list_by_id);
}

void bssl::ssl_client_handshake()
{
  __assert_rtn("do_finish_client_handshake", "handshake_client.cc", 1911, "ssl->session != nullptr");
}

{
  __assert_rtn("should_offer_early_data", "handshake_client.cc", 472, "!ssl->server");
}

{
  __assert_rtn("do_read_hello_verify_request", "handshake_client.cc", 687, "SSL_is_dtls(ssl)");
}

{
  __assert_rtn("do_read_hello_verify_request", "handshake_client.cc", 691, "hs->max_version < TLS1_3_VERSION");
}

{
  __assert_rtn("do_read_server_hello", "handshake_client.cc", 904, "!ssl->s3->initial_handshake_complete");
}

{
  __assert_rtn("do_read_server_hello", "handshake_client.cc", 787, "ssl->s3->have_version == ssl->s3->initial_handshake_complete");
}

{
  __assert_rtn("do_reverify_server_certificate", "handshake_client.cc", 1103, "hs->ssl->ctx->reverify_on_resume");
}

{
  __assert_rtn("do_read_server_key_exchange", "handshake_client.cc", 1279, "alg_a == SSL_aPSK");
}

{
  __assert_rtn("do_send_client_certificate_verify", "handshake_client.cc", 1615, "ssl_has_private_key(hs)");
}

{
  __assert_rtn("do_read_session_ticket", "handshake_client.cc", 1824, "!hs->new_session");
}

void bssl::tls_next_message()
{
  __assert_rtn("tls_next_message", "s3_both.cc", 644, "0");
}

void ssl_read_impl()
{
  __assert_rtn("ssl_read_impl", "ssl_lib.cc", 1263, "!ssl->s3->pending_app_data.empty()");
}

int SSL_set_session(SSL *to, SSL_SESSION *session)
{
  ssl_session_st *v2;
  int (__cdecl *handshake_func)(SSL *);
  uint64_t v4;

  handshake_func = to->handshake_func;
  if ((*((_WORD *)handshake_func + 110) & 0x20) != 0
    || (v4 = *((_QWORD *)handshake_func + 35)) == 0
    || *(_DWORD *)(v4 + 20))
  {
    abort();
  }
  bssl::ssl_set_session((ssl_st **)to, session, v2);
  return 1;
}

BOOL SSL_SESSION_is_resumable(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 448) & 4) != 0)
    return 0;
  if (*(_DWORD *)(a1 + 64))
    return 1;
  return *(_QWORD *)(a1 + 248) != 0;
}

EC_KEY *EC_KEY_parse_private_key(__int128 *a1, EC_KEY *a2)
{
  EC_GROUP *v3;
  EC_GROUP *v4;
  const EC_GROUP *v5;
  int v6;
  int v7;
  EC_KEY *v9;
  const unsigned __int8 *v10;
  int v11;
  BIGNUM *v12;
  EC_POINT *v13;
  EC_POINT *v14;
  const unsigned __int8 *v15;
  size_t v16;
  int v17;
  char v18;
  __int128 v19[2];
  unint64_t v20;
  __int128 v21[2];

  memset(v21, 170, sizeof(v21));
  v20 = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_asn1(a1, &v21[1], 536870928)
    && CBS_get_asn1_uint64(&v21[1], &v20)
    && v20 == 1
    && CBS_get_asn1(&v21[1], v21, 4))
  {
    if (CBS_peek_asn1_tag(&v21[1], -1610612736))
    {
      *(_QWORD *)&v19[1] = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v19[1] + 1) = 0xAAAAAAAAAAAAAAAALL;
      if (CBS_get_asn1(&v21[1], &v19[1], -1610612736))
      {
        v3 = EC_KEY_parse_parameters(&v19[1]);
        v4 = v3;
        if (v3)
        {
          v5 = v3;
          if (a2)
          {
            v5 = a2;
            if (EC_GROUP_cmp(a2, v3, 0))
            {
              v6 = 130;
              v7 = 108;
LABEL_33:
              ERR_put_error(15, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", v7);
              goto LABEL_34;
            }
          }
          if (CBS_len((uint64_t)&v19[1]))
          {
            v6 = 128;
            v7 = 112;
            goto LABEL_33;
          }
LABEL_16:
          v9 = EC_KEY_new();
          a2 = v9;
          if (!v9 || !EC_KEY_set_group(v9, v5))
            goto LABEL_35;
          v10 = (const unsigned __int8 *)CBS_data((uint64_t)v21);
          v11 = CBS_len((uint64_t)v21);
          v12 = BN_bin2bn(v10, v11, 0);
          v13 = EC_POINT_new(v5);
          *((_QWORD *)a2 + 1) = v13;
          if (!v12 || !v13 || !EC_KEY_set_private_key(a2, v12))
            goto LABEL_36;
          if (CBS_peek_asn1_tag(&v21[1], -1610612735))
          {
            memset(v19, 170, sizeof(v19));
            v18 = -86;
            if (!CBS_get_asn1(&v21[1], &v19[1], -1610612735)
              || !CBS_get_asn1(&v19[1], v19, 3)
              || !CBS_get_u8(v19, &v18)
              || v18
              || !CBS_len((uint64_t)v19)
              || (v14 = (EC_POINT *)*((_QWORD *)a2 + 1),
                  v15 = (const unsigned __int8 *)CBS_data((uint64_t)v19),
                  v16 = CBS_len((uint64_t)v19),
                  !EC_POINT_oct2point(v5, v14, v15, v16, 0))
              || CBS_len((uint64_t)&v19[1]))
            {
              v17 = 152;
LABEL_42:
              ERR_put_error(15, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", v17);
              goto LABEL_36;
            }
            *((_DWORD *)a2 + 7) = *(_BYTE *)CBS_data((uint64_t)v19) & 0xFE;
          }
          else
          {
            if (!ec_point_mul_scalar_base(v5, *((_QWORD *)a2 + 1) + 8, *((_QWORD *)a2 + 2) + 24))
              goto LABEL_36;
            *((_DWORD *)a2 + 6) |= 2u;
          }
          if (!CBS_len((uint64_t)&v21[1]))
          {
            if (EC_KEY_check_key(a2))
            {
              BN_free(v12);
              EC_GROUP_free(v4);
              return a2;
            }
            goto LABEL_36;
          }
          v17 = 172;
          goto LABEL_42;
        }
      }
      else
      {
        ERR_put_error(15, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", 97);
        v4 = 0;
      }
LABEL_34:
      a2 = 0;
LABEL_35:
      v12 = 0;
LABEL_36:
      EC_KEY_free(a2);
      BN_free(v12);
      EC_GROUP_free(v4);
      return 0;
    }
    if (!a2)
    {
      ERR_put_error(15, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", 118);
      v4 = 0;
      goto LABEL_35;
    }
    v4 = 0;
    v5 = a2;
    goto LABEL_16;
  }
  ERR_put_error(15, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", 82);
  return 0;
}

EC_GROUP *EC_KEY_parse_parameters(__int128 *a1)
{
  _DWORD *v2;
  BOOL v3;
  int v4;
  int v5;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  __int128 v14[2];
  __int128 v15[2];
  __int128 v16[2];
  char v17;
  unint64_t v18;
  int v19;
  _QWORD v20[4];
  __int128 v21[2];
  __int128 v22[2];

  if (!CBS_peek_asn1_tag(a1, 536870928))
    return EC_KEY_parse_curve_name(a1);
  memset(v16, 170, sizeof(v16));
  memset(v15, 170, sizeof(v15));
  memset(v14, 170, sizeof(v14));
  memset(v22, 170, sizeof(v22));
  memset(v21, 170, sizeof(v21));
  memset(v20, 170, sizeof(v20));
  v19 = -1431655766;
  v18 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_asn1(a1, &v22[1], 536870928)
    || !CBS_get_asn1_uint64(&v22[1], &v18)
    || v18 != 1
    || !CBS_get_asn1(&v22[1], v22, 536870928)
    || !CBS_get_asn1(v22, &v21[1], 6)
    || CBS_len((uint64_t)&v21[1]) != 7
    || ((v2 = (_DWORD *)CBS_data((uint64_t)&v21[1]), *v2 == -834107862)
      ? (v3 = *(_DWORD *)((char *)v2 + 3) == 16858574)
      : (v3 = 0),
        !v3
     || !CBS_get_asn1(v22, &v16[1], 2)
     || !CBS_is_unsigned_asn1_integer((unsigned __int8 **)&v16[1])
     || CBS_len((uint64_t)v22)
     || !CBS_get_asn1(&v22[1], v21, 536870928)
     || !CBS_get_asn1(v21, v16, 4)
     || !CBS_get_asn1(v21, &v15[1], 4)
     || !CBS_get_optional_asn1(v21, 0, 0, 3)
     || CBS_len((uint64_t)v21)
     || !CBS_get_asn1(&v22[1], &v20[2], 4)
     || !CBS_get_asn1(&v22[1], v14, 2)
     || !CBS_is_unsigned_asn1_integer((unsigned __int8 **)v14)
     || !CBS_get_optional_asn1(&v22[1], v20, &v19, 2)
     || CBS_len((uint64_t)&v22[1])))
  {
    v4 = 128;
    v5 = 278;
LABEL_13:
    ERR_put_error(15, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", v5);
    return 0;
  }
  if (v19 && (CBS_len((uint64_t)v20) != 1 || *(_BYTE *)CBS_data((uint64_t)v20) != 1))
  {
    v4 = 123;
    v5 = 286;
    goto LABEL_13;
  }
  v17 = -86;
  if (!CBS_get_u8(&v20[2], &v17) || v17 != 4)
  {
    v4 = 111;
    v5 = 294;
    goto LABEL_13;
  }
  if ((CBS_len((uint64_t)&v20[2]) & 1) != 0)
  {
    v4 = 128;
    v5 = 299;
    goto LABEL_13;
  }
  v7 = (unint64_t)CBS_len((uint64_t)&v20[2]) >> 1;
  v8 = CBS_data((uint64_t)&v20[2]);
  CBS_init(v15, v8, v7);
  v9 = CBS_data((uint64_t)&v20[2]);
  CBS_init(&v14[1], v9 + v7, v7);
  v10 = OPENSSL_built_in_curves();
  v11 = 0;
  while (1)
  {
    v12 = &v10[v11];
    v13 = LOBYTE(v10[v11 + 8]);
    if (integers_equal(&v16[1], *(char **)&v10[v11 + 10], v13)
      && integers_equal(v16, (char *)(*((_QWORD *)v12 + 5) + v13), v13)
      && integers_equal(&v15[1], (char *)(*((_QWORD *)v12 + 5) + 2 * v13), v13)
      && integers_equal(v15, (char *)(*((_QWORD *)v12 + 5) + 3 * v13), v13)
      && integers_equal(&v14[1], (char *)(*((_QWORD *)v12 + 5) + 4 * v13), v13)
      && integers_equal(v14, (char *)(*((_QWORD *)v12 + 5) + 5 * v13), v13))
    {
      return EC_GROUP_new_by_curve_name(v10[v11]);
    }
    v11 += 14;
    if (v11 == 56)
    {
      v4 = 123;
      v5 = 403;
      goto LABEL_13;
    }
  }
}

uint64_t EC_KEY_marshal_private_key(uint64_t *a1, uint64_t a2, char a3)
{
  __int128 v6;
  const BIGNUM *v7;
  unint64_t v8;
  const BIGNUM *v9;
  __int128 v10;
  __int128 v11;
  int v13;
  int v14;
  _OWORD v15[3];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _OWORD v19[3];
  _OWORD v20[3];

  if (a2 && *(_QWORD *)a2 && *(_QWORD *)(a2 + 16))
  {
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v20[1] = v6;
    v20[2] = v6;
    v20[0] = v6;
    v19[1] = v6;
    v19[2] = v6;
    v19[0] = v6;
    if (CBB_add_asn1(a1, (uint64_t)v20, 0x20000010u)
      && CBB_add_asn1_uint64((uint64_t *)v20, 1uLL)
      && CBB_add_asn1((uint64_t *)v20, (uint64_t)v19, 4u)
      && (v7 = (const BIGNUM *)EC_GROUP_get0_order(*(_QWORD *)a2),
          v8 = BN_num_bytes(v7),
          v9 = RSA_get0_e((const EC_KEY *)a2),
          BN_bn2cbb_padded((uint64_t)v19, v8, (uint64_t)v9)))
    {
      if ((a3 & 1) != 0
        || (*(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL,
            *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL,
            v17 = v10,
            v18 = v10,
            v16 = v10,
            CBB_add_asn1((uint64_t *)v20, (uint64_t)&v16, 0xA0000000))
        && EC_KEY_marshal_curve_name((uint64_t *)&v16, *(EC_GROUP **)a2)
        && CBB_flush((uint64_t *)v20))
      {
        if ((a3 & 2) != 0)
          goto LABEL_30;
        if (!*(_QWORD *)(a2 + 8))
          goto LABEL_30;
        *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v17 = v11;
        v18 = v11;
        v15[2] = v11;
        v16 = v11;
        v15[0] = v11;
        v15[1] = v11;
        if (!CBB_add_asn1((uint64_t *)v20, (uint64_t)&v16, 0xA0000001))
          goto LABEL_26;
        if (CBB_add_asn1((uint64_t *)&v16, (uint64_t)v15, 3u)
          && CBB_add_u8((uint64_t)v15, 0)
          && EC_POINT_point2cbb((uint64_t)v15, *(EC_GROUP **)a2, *(EC_POINT **)(a2 + 8), (point_conversion_form_t)*(_DWORD *)(a2 + 28), 0)&& CBB_flush((uint64_t *)v20))
        {
LABEL_30:
          if (CBB_flush(a1))
            return 1;
          v13 = 129;
          v14 = 237;
        }
        else
        {
LABEL_26:
          v13 = 129;
          v14 = 231;
        }
      }
      else
      {
        v13 = 129;
        v14 = 215;
      }
    }
    else
    {
      v13 = 129;
      v14 = 206;
    }
  }
  else
  {
    v13 = 67;
    v14 = 195;
  }
  ERR_put_error(15, 0, v13, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", v14);
  return 0;
}

uint64_t EC_KEY_marshal_curve_name(uint64_t *a1, EC_GROUP *a2)
{
  int curve_name;
  int v4;
  int *v5;
  int *v6;
  uint64_t v7;
  int v8;
  uint64_t result;
  __int128 v10;
  _OWORD v11[3];

  curve_name = EC_GROUP_get_curve_name(a2);
  if (curve_name)
  {
    v4 = curve_name;
    v5 = OPENSSL_built_in_curves();
    v6 = v5;
    v7 = 0;
    while (v5[v7] != v4)
    {
      v7 += 14;
      if (v7 == 56)
      {
        v8 = 364;
        goto LABEL_7;
      }
    }
    *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v11[1] = v10;
    v11[2] = v10;
    v11[0] = v10;
    result = CBB_add_asn1(a1, (uint64_t)v11, 6u);
    if ((_DWORD)result)
    {
      result = CBB_add_bytes((uint64_t)v11, *(const void **)&v6[v7 + 2], LOBYTE(v6[v7 + 4]));
      if ((_DWORD)result)
        return CBB_flush(a1) != 0;
    }
  }
  else
  {
    v8 = 349;
LABEL_7:
    ERR_put_error(15, 0, 123, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", v8);
    return 0;
  }
  return result;
}

BOOL integers_equal(__int128 *a1, char *a2, uint64_t a3)
{
  char *v5;
  __int128 i;

  for (i = *a1; CBS_len((uint64_t)&i) && !*(_BYTE *)CBS_data((uint64_t)&i); CBS_skip(&i, 1uLL))
    ;
  if (a3)
  {
    v5 = &a2[a3];
    while (!*a2)
    {
      ++a2;
      if (!--a3)
      {
        a2 = v5;
        return CBS_mem_equal((uint64_t)&i, a2, a3);
      }
    }
  }
  return CBS_mem_equal((uint64_t)&i, a2, a3);
}

EC_KEY *__cdecl d2i_ECPrivateKey(EC_KEY **a, const unsigned __int8 **in, uint64_t len)
{
  EC_KEY *v6;
  EC_KEY *v7;
  EC_KEY *v8;
  __int128 v10;

  if (a && (v6 = *a) != 0)
  {
    v7 = EC_KEY_get0_group(v6);
    if (len < 0)
    {
LABEL_4:
      ERR_put_error(15, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", 427);
      return 0;
    }
  }
  else
  {
    v7 = 0;
    if (len < 0)
      goto LABEL_4;
  }
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  CBS_init(&v10, (uint64_t)*in, len);
  v8 = EC_KEY_parse_private_key(&v10, v7);
  if (v8)
  {
    if (a)
    {
      EC_KEY_free(*a);
      *a = v8;
    }
    *in = (const unsigned __int8 *)CBS_data((uint64_t)&v10);
  }
  return v8;
}

int i2d_ECPrivateKey(EC_KEY *a, unsigned __int8 **out)
{
  __int128 v4;
  char enc_flags;
  _OWORD v7[3];

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v4;
  v7[2] = v4;
  v7[0] = v4;
  if (CBB_init((uint64_t)v7, 0))
  {
    enc_flags = EC_KEY_get_enc_flags(a);
    if (EC_KEY_marshal_private_key((uint64_t *)v7, (uint64_t)a, enc_flags))
      return CBB_finish_i2d((uint64_t)v7, (void **)out);
  }
  CBB_cleanup((uint64_t)v7);
  return -1;
}

uint64_t ed25519_pub_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _OWORD *v6;
  uint64_t v7;

  if (CBS_len(a2))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 119);
    return 0;
  }
  else
  {
    v6 = (_OWORD *)CBS_data(a3);
    v7 = CBS_len(a3);
    return ed25519_set_pub_raw(a1, v6, v7);
  }
}

uint64_t ed25519_pub_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  __int128 v4;
  _OWORD v6[3];
  _OWORD v7[3];
  _OWORD v8[3];
  _OWORD v9[3];

  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v4;
  v9[2] = v4;
  v9[0] = v4;
  v8[1] = v4;
  v8[2] = v4;
  v7[2] = v4;
  v8[0] = v4;
  v7[0] = v4;
  v7[1] = v4;
  v6[1] = v4;
  v6[2] = v4;
  v6[0] = v4;
  if (CBB_add_asn1(a1, (uint64_t)v9, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v8, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v8, (uint64_t)v7, 6u)
    && CBB_add_bytes((uint64_t)v7, &unk_1E686E0F4, 3uLL)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v6, 3u)
    && CBB_add_u8((uint64_t)v6, 0)
    && CBB_add_bytes((uint64_t)v6, (const void *)(v3 + 32), 0x20uLL)
    && CBB_flush(a1))
  {
    return 1;
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 140);
  return 0;
}

BOOL ed25519_pub_cmp(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = *(_QWORD **)(a2 + 8);
  v4 = v2[4];
  v5 = v2[5];
  v6 = v3[4];
  v7 = v3[5];
  v9 = v2[6];
  v8 = v2[7];
  v11 = v3[6];
  v10 = v3[7];
  return v4 == v6 && v5 == v7 && v9 == v11 && v8 == v10;
}

uint64_t ed25519_priv_decode(uint64_t a1, uint64_t a2, __int128 *a3)
{
  unsigned __int8 *v6;
  uint64_t v7;
  _QWORD v8[2];

  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_len(a2) || !CBS_get_asn1(a3, v8, 4) || CBS_len((uint64_t)a3))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 163);
    return 0;
  }
  else
  {
    v6 = (unsigned __int8 *)CBS_data((uint64_t)v8);
    v7 = CBS_len((uint64_t)v8);
    return ed25519_set_priv_raw(a1, v6, v7);
  }
}

uint64_t ed25519_priv_encode(uint64_t *a1, uint64_t a2)
{
  _BYTE *v2;
  __int128 v4;
  int v6;
  int v7;
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];
  _OWORD v11[3];
  _OWORD v12[3];

  v2 = *(_BYTE **)(a2 + 8);
  if (v2[64])
  {
    *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v12[1] = v4;
    v12[2] = v4;
    v11[2] = v4;
    v12[0] = v4;
    v11[0] = v4;
    v11[1] = v4;
    v10[1] = v4;
    v10[2] = v4;
    v9[2] = v4;
    v10[0] = v4;
    v9[0] = v4;
    v9[1] = v4;
    v8[1] = v4;
    v8[2] = v4;
    v8[0] = v4;
    if (CBB_add_asn1(a1, (uint64_t)v12, 0x20000010u)
      && CBB_add_asn1_uint64((uint64_t *)v12, 0)
      && CBB_add_asn1((uint64_t *)v12, (uint64_t)v11, 0x20000010u)
      && CBB_add_asn1((uint64_t *)v11, (uint64_t)v10, 6u)
      && CBB_add_bytes((uint64_t)v10, &unk_1E686E0F4, 3uLL)
      && CBB_add_asn1((uint64_t *)v12, (uint64_t)v9, 4u)
      && CBB_add_asn1((uint64_t *)v9, (uint64_t)v8, 4u)
      && CBB_add_bytes((uint64_t)v8, v2, 0x20uLL)
      && CBB_flush(a1))
    {
      return 1;
    }
    v6 = 105;
    v7 = 190;
  }
  else
  {
    v6 = 130;
    v7 = 173;
  }
  ERR_put_error(6, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", v7);
  return 0;
}

uint64_t ed25519_set_priv_raw(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  _QWORD *v5;
  _QWORD *v6;
  __int128 v7;
  uint64_t v8;
  _OWORD v10[2];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a3 != 32)
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 33);
    return 0;
  }
  v5 = OPENSSL_malloc(0x41uLL);
  if (!v5)
    return 0;
  v6 = v5;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[0] = v7;
  v10[1] = v7;
  ED25519_keypair_from_seed((uint64_t)v10, v5, a2);
  v8 = 1;
  *((_BYTE *)v6 + 64) = 1;
  OPENSSL_free(*(_QWORD **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = v6;
  return v8;
}

uint64_t ed25519_set_pub_raw(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  __int128 v7;

  if (a3 == 32)
  {
    result = (uint64_t)OPENSSL_malloc(0x41uLL);
    if (result)
    {
      v6 = result;
      v7 = a2[1];
      *(_OWORD *)(result + 32) = *a2;
      *(_OWORD *)(result + 48) = v7;
      *(_BYTE *)(result + 64) = 0;
      OPENSSL_free(*(_QWORD **)(a1 + 8));
      *(_QWORD *)(a1 + 8) = v6;
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 55);
    return 0;
  }
  return result;
}

uint64_t ed25519_get_priv_raw(uint64_t a1, _OWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  __int128 v7;

  v3 = *(_QWORD *)(a1 + 8);
  if (!*(_BYTE *)(v3 + 64))
  {
    v4 = 130;
    v5 = 76;
    goto LABEL_6;
  }
  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      v4 = 100;
      v5 = 86;
LABEL_6:
      ERR_put_error(6, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", v5);
      return 0;
    }
    v7 = *(_OWORD *)(v3 + 16);
    *a2 = *(_OWORD *)v3;
    a2[1] = v7;
  }
  *a3 = 32;
  return 1;
}

uint64_t ed25519_get_pub_raw(uint64_t a1, _OWORD *a2, _QWORD *a3)
{
  uint64_t v4;
  __int128 v5;

  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 105);
      return 0;
    }
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(_OWORD *)(v4 + 48);
    *a2 = *(_OWORD *)(v4 + 32);
    a2[1] = v5;
  }
  *a3 = 32;
  return 1;
}

uint64_t ed25519_size()
{
  return 64;
}

uint64_t ed25519_bits()
{
  return 253;
}

void ed25519_free(uint64_t a1)
{
  OPENSSL_free(*(_QWORD **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
}

char *boringssl_ciphers_create_configuration_string(uint64_t a1, uint64_t a2)
{
  char *v2;
  CFMutableStringRef Mutable;
  __CFString *v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  const char *v10;
  const char *v11;
  CFIndex v12;
  char *v13;

  v2 = 0;
  if (a1 && a2)
  {
    Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (Mutable)
    {
      v6 = Mutable;
      v7 = 0;
      v8 = 0;
      do
      {
        v9 = v7;
        while (1)
        {
          v10 = boringssl_ciphers_value_to_string(*(unsigned __int16 *)(a1 + 2 * v9));
          if (v10)
            break;
          if (a2 == ++v9)
          {
            if ((v8 & 1) != 0)
              goto LABEL_14;
            if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
              boringssl_ciphers_create_configuration_string_cold_3();
LABEL_23:
            CFRelease(v6);
            return 0;
          }
        }
        v11 = v10;
        if ((v8 & 1) != 0)
          CFStringAppend(v6, CFSTR(":"));
        CFStringAppendCString(v6, v11, 0x8000100u);
        v7 = v9 + 1;
        v8 = 1;
      }
      while (a2 - 1 != v9);
LABEL_14:
      v12 = CFStringGetLength(v6) + 1;
      v13 = (char *)malloc_type_malloc(v12, 0x66DE259AuLL);
      if (!v13)
      {
        if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          boringssl_ciphers_create_configuration_string_cold_1();
        goto LABEL_23;
      }
      v2 = v13;
      if (CFStringGetCString(v6, v13, v12, 0x8000100u))
      {
        CFRelease(v6);
        return v2;
      }
      if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        boringssl_ciphers_create_configuration_string_cold_2();
      CFRelease(v6);
      free(v2);
    }
    return 0;
  }
  return v2;
}

void boringssl_session_update_eap_metadata(uint64_t a1)
{
  uint64_t v2;
  _QWORD v3[3];
  char v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      v2 = *(_QWORD *)(a1 + 8);
      if (v2)
      {
        if (*(_QWORD *)(v2 + 400) && *(_DWORD *)(v2 + 300) == 2)
        {
          v9 = 0;
          v10 = &v9;
          v11 = 0x2020000000;
          v12 = 0;
          v5 = 0;
          v6 = &v5;
          v7 = 0x2020000000;
          v8 = 0;
          v3[0] = 0;
          v3[1] = v3;
          v3[2] = 0x2020000000;
          v4 = 0;
          nw_protocol_options_access_handle();
          if (v6[3] && v10[3])
          {
            if (*(_DWORD *)a1 == -1252936367)
            {
              if (*(_QWORD *)(a1 + 8))
                nw_protocol_metadata_access_handle();
            }
            nw_protocol_metadata_access_handle();
          }
          _Block_object_dispose(v3, 8);
          _Block_object_dispose(&v5, 8);
          _Block_object_dispose(&v9, 8);
        }
      }
    }
  }
}

void sub_1B4FB420C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 144), 8);
  _Block_object_dispose((const void *)(v29 - 112), 8);
  _Unwind_Resume(a1);
}

BOOL __boringssl_session_update_eap_metadata_block_invoke(_QWORD *a1, uint64_t a2)
{
  char *v2;
  int negotiated_tls_protocol_version;
  uint64_t v6;
  id WeakRetained;
  void *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  id v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  id v15;
  void *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  id v19;
  _BYTE *v20;
  uint64_t v21;
  id v22;
  void *v23;
  unsigned __int8 *v24;
  uint64_t v25;
  id v26;
  _BYTE *v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  _BOOL4 v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  _BOOL4 v37;
  id v38;
  char v39;
  void *v40;
  id v41;
  char v42;
  void *v43;
  uint64_t v44;
  _BOOL4 v45;
  id v46;
  char v47;
  void *v48;
  uint64_t v50;
  int v51;
  const char *v52;
  __int16 v53;
  int v54;
  __int16 v55;
  void *v56;
  __int16 v57;
  id v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return a2 != 0;
  negotiated_tls_protocol_version = sec_protocol_metadata_get_negotiated_tls_protocol_version(*(sec_protocol_metadata_t *)(a1[7] + 520));
  if (*(_BYTE *)(a2 + 360) == 1)
  {
    v6 = a1[7];
    if (negotiated_tls_protocol_version == 772)
    {
      if (!v6)
        goto LABEL_23;
      WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
      if (WeakRetained)
      {
        v8 = WeakRetained;
        v9 = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1[7] + 16));
        v2 = (char *)v9[475];

        if ((v2 & 1) != 0)
          goto LABEL_62;
      }
      v10 = a1[7];
      if (v10)
      {
        v11 = objc_loadWeakRetained((id *)(v10 + 16));
        if (v11)
        {
          v12 = objc_loadWeakRetained((id *)(a1[7] + 16));
          v13 = (v12[475] & 1) == 0;

        }
        else
        {
          v13 = 1;
        }

        if (!(_DWORD)v13)
          goto LABEL_62;
      }
      else
      {
LABEL_23:
        v13 = 1;
      }
      if (!g_boringssl_log)
      {
LABEL_62:
        *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = "EXPORTER_EAP_TLS_Key_Material";
        *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = 29;
        *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
        return a2 != 0;
      }
      v30 = (id)g_boringssl_log;
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
        goto LABEL_61;
      v31 = a1[7];
      if (v31)
      {
        v13 = (uint64_t)objc_loadWeakRetained((id *)(v31 + 16));
        v32 = a1[7];
        if (v13)
        {
          v33 = v32 != 0;
          if (v32)
          {
            v2 = (char *)objc_loadWeakRetained((id *)(v32 + 16));
            v32 = a1[7];
          }
          else
          {
            v2 = 0;
          }
          v40 = v2 + 391;
        }
        else
        {
          v33 = 0;
          v40 = &unk_1B50022E3;
        }
        if (v32)
        {
          v38 = objc_loadWeakRetained((id *)(v32 + 16));
          v39 = 0;
        }
        else
        {
          v38 = 0;
          v39 = 1;
        }
      }
      else
      {
        v33 = 0;
        v38 = 0;
        v39 = 1;
        v40 = &unk_1B50022E3;
      }
      v51 = 136446978;
      v52 = "boringssl_session_update_eap_metadata_block_invoke";
      v53 = 1024;
      v54 = 101;
      v55 = 2082;
      v56 = v40;
      v57 = 2048;
      v58 = v38;
      _os_log_impl(&dword_1B4F6D000, v30, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] TLS handshake is complete using TLS 1.3 version", (uint8_t *)&v51, 0x26u);
      if ((v39 & 1) != 0)
      {
        if (!v33)
          goto LABEL_59;
      }
      else
      {

        if (!v33)
        {
LABEL_59:
          if (v31)
LABEL_60:

LABEL_61:
          goto LABEL_62;
        }
      }

      if (!v31)
        goto LABEL_61;
      goto LABEL_60;
    }
    if (!v6)
      goto LABEL_24;
    v22 = objc_loadWeakRetained((id *)(v6 + 16));
    if (v22)
    {
      v23 = v22;
      v24 = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1[7] + 16));
      v2 = (char *)v24[475];

      if ((v2 & 1) != 0)
        goto LABEL_76;
    }
    v25 = a1[7];
    if (v25)
    {
      v26 = objc_loadWeakRetained((id *)(v25 + 16));
      if (v26)
      {
        v27 = objc_loadWeakRetained((id *)(a1[7] + 16));
        v28 = (v27[475] & 1) == 0;

      }
      else
      {
        v28 = 1;
      }

      if (!(_DWORD)v28)
        goto LABEL_76;
    }
    else
    {
LABEL_24:
      v28 = 1;
    }
    if (!g_boringssl_log)
    {
LABEL_76:
      *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = "client EAP encryption";
      *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = 21;
      return a2 != 0;
    }
    v34 = (id)g_boringssl_log;
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
      goto LABEL_75;
    v35 = a1[7];
    if (v35)
    {
      v28 = (uint64_t)objc_loadWeakRetained((id *)(v35 + 16));
      v36 = a1[7];
      if (v28)
      {
        v37 = v36 != 0;
        if (v36)
        {
          v2 = (char *)objc_loadWeakRetained((id *)(v36 + 16));
          v36 = a1[7];
        }
        else
        {
          v2 = 0;
        }
        v43 = v2 + 391;
      }
      else
      {
        v37 = 0;
        v43 = &unk_1B50022E3;
      }
      if (v36)
      {
        v41 = objc_loadWeakRetained((id *)(v36 + 16));
        v42 = 0;
      }
      else
      {
        v41 = 0;
        v42 = 1;
      }
    }
    else
    {
      v37 = 0;
      v41 = 0;
      v42 = 1;
      v43 = &unk_1B50022E3;
    }
    v51 = 136446978;
    v52 = "boringssl_session_update_eap_metadata_block_invoke";
    v53 = 1024;
    v54 = 106;
    v55 = 2082;
    v56 = v43;
    v57 = 2048;
    v58 = v41;
    _os_log_impl(&dword_1B4F6D000, v34, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] TLS handshake is complete using legacy TLS version", (uint8_t *)&v51, 0x26u);
    if ((v42 & 1) != 0)
    {
      if (!v37)
        goto LABEL_73;
    }
    else
    {

      if (!v37)
      {
LABEL_73:
        if (v35)
LABEL_74:

LABEL_75:
        goto LABEL_76;
      }
    }

    if (!v35)
      goto LABEL_75;
    goto LABEL_74;
  }
  v14 = a1[7];
  if (!v14)
    goto LABEL_16;
  v15 = objc_loadWeakRetained((id *)(v14 + 16));
  if (v15)
  {
    v16 = v15;
    v17 = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1[7] + 16));
    v2 = (char *)v17[475];

    if ((v2 & 1) != 0)
      return a2 != 0;
  }
  v18 = a1[7];
  if (v18)
  {
    v19 = objc_loadWeakRetained((id *)(v18 + 16));
    if (v19)
    {
      v20 = objc_loadWeakRetained((id *)(a1[7] + 16));
      v21 = (v20[475] & 1) == 0;

    }
    else
    {
      v21 = 1;
    }

    if (!(_DWORD)v21)
      return a2 != 0;
  }
  else
  {
LABEL_16:
    v21 = 1;
  }
  if (g_boringssl_log)
  {
    v29 = (id)g_boringssl_log;
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
LABEL_29:

      return a2 != 0;
    }
    v44 = a1[7];
    if (v44)
    {
      v21 = (uint64_t)objc_loadWeakRetained((id *)(v44 + 16));
      v50 = a1[7];
      if (v21)
      {
        v45 = v50 != 0;
        if (v50)
        {
          v2 = (char *)objc_loadWeakRetained((id *)(v50 + 16));
          v50 = a1[7];
        }
        else
        {
          v2 = 0;
        }
        v48 = v2 + 391;
      }
      else
      {
        v45 = 0;
        v48 = &unk_1B50022E3;
      }
      if (v50)
      {
        v46 = objc_loadWeakRetained((id *)(v50 + 16));
        v47 = 0;
      }
      else
      {
        v46 = 0;
        v47 = 1;
      }
    }
    else
    {
      v45 = 0;
      v46 = 0;
      v47 = 1;
      v48 = &unk_1B50022E3;
    }
    v51 = 136446978;
    v52 = "boringssl_session_update_eap_metadata_block_invoke";
    v53 = 1024;
    v54 = 112;
    v55 = 2082;
    v56 = v48;
    v57 = 2048;
    v58 = v46;
    _os_log_error_impl(&dword_1B4F6D000, v29, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] Unexpected EAP method", (uint8_t *)&v51, 0x26u);
    if ((v47 & 1) != 0)
    {
      if (!v45)
        goto LABEL_92;
    }
    else
    {

      if (!v45)
      {
LABEL_92:
        if (!v44)
          goto LABEL_29;
        goto LABEL_96;
      }
    }

    if (!v44)
      goto LABEL_29;
LABEL_96:

    goto LABEL_29;
  }
  return a2 != 0;
}

uint64_t __boringssl_session_update_eap_metadata_block_invoke_4(uint64_t a1, uint64_t a2)
{
  char *v2;
  ssl_st *v5;
  void *v6;
  uint64_t v7;
  id WeakRetained;
  void *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  id v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  void *v17;
  unsigned __int8 *v18;
  uint64_t v19;
  id v20;
  _BYTE *v21;
  NSObject *v22;
  uint64_t v23;
  _BOOL4 v24;
  id v25;
  char v26;
  void *v27;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  int v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  void *v38;
  __int16 v39;
  id v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v5 = (ssl_st *)malloc_type_malloc(0x80uLL, 0x432D5733uLL);
  *(_QWORD *)(a2 + 320) = v5;
  if (v5)
  {
    if (SSL_export_keying_material(*(bssl **)(*(_QWORD *)(a1 + 64) + 400), v5, 0x80uLL, *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(const void **)(a1 + 72), *(_QWORD *)(a1 + 80), *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24)))return 1;
    v6 = *(void **)(a2 + 320);
    if (v6)
      free(v6);
    *(_QWORD *)(a2 + 320) = 0;
    v7 = *(_QWORD *)(a1 + 56);
    if (!v7)
      goto LABEL_18;
    WeakRetained = objc_loadWeakRetained((id *)(v7 + 16));
    if (WeakRetained)
    {
      v9 = WeakRetained;
      v10 = (unsigned __int8 *)objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 56) + 16));
      v2 = (char *)v10[475];

      if ((v2 & 1) != 0)
        return 1;
    }
    v11 = *(_QWORD *)(a1 + 56);
    if (v11)
    {
      v12 = objc_loadWeakRetained((id *)(v11 + 16));
      if (v12)
      {
        v13 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 56) + 16));
        v14 = (v13[475] & 1) == 0;

      }
      else
      {
        v14 = 1;
      }

      if (!(_DWORD)v14)
        return 1;
    }
    else
    {
LABEL_18:
      v14 = 1;
    }
    if (g_boringssl_log)
    {
      v22 = (id)g_boringssl_log;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        goto LABEL_29;
      v23 = *(_QWORD *)(a1 + 56);
      if (v23)
      {
        v14 = (uint64_t)objc_loadWeakRetained((id *)(v23 + 16));
        v31 = *(_QWORD *)(a1 + 56);
        if (v14)
        {
          v24 = v31 != 0;
          if (v31)
          {
            v2 = (char *)objc_loadWeakRetained((id *)(v31 + 16));
            v31 = *(_QWORD *)(a1 + 56);
          }
          else
          {
            v2 = 0;
          }
          v29 = v2 + 391;
        }
        else
        {
          v24 = 0;
          v29 = &unk_1B50022E3;
        }
        if (v31)
        {
          v25 = objc_loadWeakRetained((id *)(v31 + 16));
          v26 = 0;
        }
        else
        {
          v25 = 0;
          v26 = 1;
        }
      }
      else
      {
        v24 = 0;
        v25 = 0;
        v26 = 1;
        v29 = &unk_1B50022E3;
      }
      v33 = 136446978;
      v34 = "boringssl_session_update_eap_metadata_block_invoke";
      v35 = 1024;
      v36 = 142;
      v37 = 2082;
      v38 = v29;
      v39 = 2048;
      v40 = v25;
      v32 = "%{public}s(%d) %{public}s[%p] EAP key material computation failed";
      goto LABEL_53;
    }
  }
  else
  {
    v15 = *(_QWORD *)(a1 + 56);
    if (!v15)
      goto LABEL_17;
    v16 = objc_loadWeakRetained((id *)(v15 + 16));
    if (v16)
    {
      v17 = v16;
      v18 = (unsigned __int8 *)objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 56) + 16));
      v2 = (char *)v18[475];

      if ((v2 & 1) != 0)
        return 1;
    }
    v19 = *(_QWORD *)(a1 + 56);
    if (v19)
    {
      v20 = objc_loadWeakRetained((id *)(v19 + 16));
      if (v20)
      {
        v21 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 56) + 16));
        v14 = (v21[475] & 1) == 0;

      }
      else
      {
        v14 = 1;
      }

      if (!(_DWORD)v14)
        return 1;
    }
    else
    {
LABEL_17:
      v14 = 1;
    }
    if (g_boringssl_log)
    {
      v22 = (id)g_boringssl_log;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
LABEL_29:

        return 1;
      }
      v23 = *(_QWORD *)(a1 + 56);
      if (v23)
      {
        v14 = (uint64_t)objc_loadWeakRetained((id *)(v23 + 16));
        v30 = *(_QWORD *)(a1 + 56);
        if (v14)
        {
          v24 = v30 != 0;
          if (v30)
          {
            v2 = (char *)objc_loadWeakRetained((id *)(v30 + 16));
            v30 = *(_QWORD *)(a1 + 56);
          }
          else
          {
            v2 = 0;
          }
          v27 = v2 + 391;
        }
        else
        {
          v24 = 0;
          v27 = &unk_1B50022E3;
        }
        if (v30)
        {
          v25 = objc_loadWeakRetained((id *)(v30 + 16));
          v26 = 0;
        }
        else
        {
          v25 = 0;
          v26 = 1;
        }
      }
      else
      {
        v24 = 0;
        v25 = 0;
        v26 = 1;
        v27 = &unk_1B50022E3;
      }
      v33 = 136446978;
      v34 = "boringssl_session_update_eap_metadata_block_invoke";
      v35 = 1024;
      v36 = 131;
      v37 = 2082;
      v38 = v27;
      v39 = 2048;
      v40 = v25;
      v32 = "%{public}s(%d) %{public}s[%p] EAP key material allocation failed";
LABEL_53:
      _os_log_error_impl(&dword_1B4F6D000, v22, OS_LOG_TYPE_ERROR, v32, (uint8_t *)&v33, 0x26u);
      if ((v26 & 1) != 0)
      {
        if (!v24)
          goto LABEL_55;
      }
      else
      {

        if (!v24)
        {
LABEL_55:
          if (!v23)
            goto LABEL_29;
          goto LABEL_59;
        }
      }

      if (!v23)
        goto LABEL_29;
LABEL_59:

      goto LABEL_29;
    }
  }
  return 1;
}

uint64_t boringssl_session_handshake_continue_inner(SSL *a1, char a2)
{
  char *v2;
  SSL_METHOD *method;
  SSL *num_ciphers;
  int v7;
  uint64_t result;
  id WeakRetained;
  void *v10;
  unsigned __int8 *v11;
  id v12;
  _BYTE *v13;
  _BOOL4 v14;
  NSObject *v15;
  id v16;
  void *v17;
  id v18;
  SSL_SESSION *session;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  void *v25;
  __int16 v26;
  id v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0xFFFFFFFFLL;
  if (a1->version != -1252936367)
    return 0xFFFFFFFFLL;
  method = a1->method;
  if (!method)
    return 0xFFFFFFFFLL;
  num_ciphers = (SSL *)method[1].num_ciphers;
  if (!num_ciphers)
    return 0xFFFFFFFFLL;
  v7 = SSL_do_handshake(num_ciphers);
  if (v7 != 1)
    return boringssl_session_handshake_incomplete(a1, v7, a2);
  result = SSL_in_false_start((uint64_t)method[1].num_ciphers);
  if ((_DWORD)result)
  {
    WeakRetained = objc_loadWeakRetained((id *)&method->ssl_clear);
    if (!WeakRetained
      || (v10 = WeakRetained,
          v11 = (unsigned __int8 *)objc_loadWeakRetained((id *)&method->ssl_clear),
          v2 = (char *)v11[475],
          v11,
          v10,
          (v2 & 1) == 0))
    {
      v12 = objc_loadWeakRetained((id *)&method->ssl_clear);
      if (v12)
      {
        v13 = objc_loadWeakRetained((id *)&method->ssl_clear);
        v14 = (v13[475] & 1) == 0;

      }
      else
      {
        v14 = 1;
      }

      if (v14)
      {
        if (g_boringssl_log)
        {
          v15 = (id)g_boringssl_log;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
          {
            v16 = objc_loadWeakRetained((id *)&method->ssl_clear);
            if (v16)
            {
              v2 = (char *)objc_loadWeakRetained((id *)&method->ssl_clear);
              v17 = v2 + 391;
            }
            else
            {
              v17 = &unk_1B50022E3;
            }
            v18 = objc_loadWeakRetained((id *)&method->ssl_clear);
            v20 = 136446978;
            v21 = "boringssl_session_handshake_continue_inner";
            v22 = 1024;
            v23 = 210;
            v24 = 2082;
            v25 = v17;
            v26 = 2048;
            v27 = v18;
            _os_log_impl(&dword_1B4F6D000, v15, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Connected in False Start.", (uint8_t *)&v20, 0x26u);

            if (v16)
          }

        }
      }
    }
    BYTE5(method[2].ssl_renegotiate_check) |= 1u;
    session = SSL_get_session((const SSL *)method[1].num_ciphers);
    boringssl_session_set_peer_verification_state_from_session((uint64_t)a1, (uint64_t)session);
    boringssl_session_finish_handshake(a1);
    return 0;
  }
  return result;
}

uint64_t boringssl_session_handshake_error_print(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  id WeakRetained;
  void *v6;
  _BYTE *v7;
  char v8;
  id v9;
  _BYTE *v10;
  _BOOL4 v11;
  uint64_t result;
  NSObject *v13;

  if (!a3)
    return 0;
  if (*(_DWORD *)a3 != -1252936367)
    return 0;
  v3 = *(_QWORD *)(a3 + 8);
  if (!v3)
    return 0;
  WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
  if (WeakRetained)
  {
    v6 = WeakRetained;
    v7 = objc_loadWeakRetained((id *)(v3 + 16));
    v8 = v7[475];

    if ((v8 & 1) != 0)
      return 1;
  }
  v9 = objc_loadWeakRetained((id *)(v3 + 16));
  if (v9)
  {
    v10 = objc_loadWeakRetained((id *)(v3 + 16));
    v11 = (v10[475] & 1) == 0;

  }
  else
  {
    v11 = 1;
  }

  result = 1;
  if (v11 && g_boringssl_log)
  {
    v13 = (id)g_boringssl_log;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      boringssl_session_handshake_error_print_cold_1(v3, a1, v13);

    return 1;
  }
  return result;
}

_QWORD *boringssl_session_export_secret_with_context(uint64_t a1, size_t a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v6;
  _QWORD *v12;
  _QWORD *v13;
  ssl_st *v14;
  void *v15;

  if (!a1)
    return 0;
  if (*(_DWORD *)a1 != -1252936367)
    return 0;
  v6 = *(_QWORD *)(a1 + 8);
  if (!v6 || !*(_QWORD *)(v6 + 400))
    return 0;
  v12 = malloc_type_malloc(0x10uLL, 0x1010040466105CCuLL);
  v13 = v12;
  if (v12)
  {
    *v12 = a6;
    v14 = (ssl_st *)malloc_type_malloc(a6, 0x5AC6C4FuLL);
    v13[1] = v14;
    if (!v14)
    {
LABEL_10:
      free(v13);
      return 0;
    }
    if (!SSL_export_keying_material(*(bssl **)(v6 + 400), v14, *v13, a3, a2, a5, a4, 1))
    {
      v15 = (void *)v13[1];
      if (v15)
        free(v15);
      goto LABEL_10;
    }
  }
  return v13;
}

_QWORD *boringssl_session_export_secret(uint64_t a1, size_t a2, const void *a3, size_t a4)
{
  return boringssl_session_export_secret_with_context(a1, a2, a3, 0, 0, a4);
}

dispatch_data_t boringssl_session_export_secret_data(uint64_t a1, size_t a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  _QWORD *v6;
  _QWORD *v7;
  dispatch_data_t v8;
  void *v9;

  if (!a1)
    return 0;
  if (*(_DWORD *)a1 != -1252936367)
    return 0;
  if (!*(_QWORD *)(a1 + 8))
    return 0;
  v6 = boringssl_session_export_secret_with_context(a1, a2, a3, a4, a5, a6);
  if (!v6)
    return 0;
  v7 = v6;
  v8 = dispatch_data_create((const void *)v6[1], *v6, 0, 0);
  v9 = (void *)v7[1];
  if (v9)
    free(v9);
  free(v7);
  return v8;
}

dispatch_data_t boringssl_session_copy_authenticator(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7;
  void *v8;
  dispatch_data_t v9;
  uint64_t v10;
  const __CFArray *v11;
  int v12;
  unsigned __int8 *v14;
  void *v15;

  v7 = a2;
  v8 = v7;
  if (a1 && *(_DWORD *)a1 == -1252936367)
  {
    v9 = 0;
    if (v7)
    {
      v10 = *(_QWORD *)(a1 + 8);
      if (v10)
      {
        v11 = boringssl_identity_create_from_identity(v7);
        if (v11
          && boringssl_context_set_temporary_identity(a1, v8)
          && (v14 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL,
              v15 = 0,
              v12 = SSL_generate_authenticator(*(_QWORD *)(v10 + 400), a3, a4, &v15, &v14),
              boringssl_context_set_temporary_identity(a1, 0),
              v12))
        {
          v9 = dispatch_data_create(v15, (size_t)v14, 0, 0);
          OPENSSL_free(v15);
        }
        else
        {
          v9 = 0;
        }

      }
    }
  }
  else
  {
    v9 = 0;
  }

  return v9;
}

sec_trust_t boringssl_session_copy_authenticator_trust(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sec_trust_t v3;
  uint64_t v4;
  SSL_SESSION *session;
  const STACK *v6;
  __CFArray *v7;
  __CFArray *v8;
  const void *SSLWithKeyUsage;
  const void *v10;
  id v11;
  void *v12;
  _BYTE *v13;
  char v14;
  id v15;
  _BYTE *v16;
  _BOOL4 v17;
  id WeakRetained;
  void *v19;
  _BYTE *v20;
  char v21;
  id v22;
  _BYTE *v23;
  _BOOL4 v24;
  NSObject *v25;
  SecTrustRef trust;

  if (!a1 || *(_DWORD *)a1 != -1252936367)
    return 0;
  v3 = 0;
  if (a3)
  {
    if (a2)
    {
      v4 = *(_QWORD *)(a1 + 8);
      if (v4)
      {
        if (SSL_validate_authenticator(*(_QWORD *)(v4 + 400), a2, a3))
        {
          session = SSL_get_session(*(const SSL **)(v4 + 400));
          v6 = (const STACK *)SSL_SESSION_get0_peer_certificates((uint64_t)session);
          v7 = boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs((void *)v4, v6);
          if (v7)
          {
            v8 = v7;
            SSLWithKeyUsage = (const void *)SecPolicyCreateSSLWithKeyUsage();
            if (SSLWithKeyUsage)
            {
              v10 = SSLWithKeyUsage;
              trust = 0;
              SecTrustCreateWithCertificates(v8, SSLWithKeyUsage, &trust);
              CFRelease(v10);
              CFRelease(v8);
              if (trust)
              {
                v3 = sec_trust_create(trust);
                CFRelease(trust);
                return v3;
              }
            }
            else
            {
              CFRelease(v8);
            }
            return 0;
          }
          WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
          if (WeakRetained)
          {
            v19 = WeakRetained;
            v20 = objc_loadWeakRetained((id *)(v4 + 16));
            v21 = v20[475];

            if ((v21 & 1) != 0)
              return 0;
          }
          v22 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v22)
          {
            v23 = objc_loadWeakRetained((id *)(v4 + 16));
            v24 = (v23[475] & 1) == 0;

          }
          else
          {
            v24 = 1;
          }

          v3 = 0;
          if (v24 && g_boringssl_log)
          {
            v25 = (id)g_boringssl_log;
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              boringssl_session_copy_authenticator_trust_cold_2(v4, v25);
LABEL_30:

            return 0;
          }
        }
        else
        {
          v11 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v11)
          {
            v12 = v11;
            v13 = objc_loadWeakRetained((id *)(v4 + 16));
            v14 = v13[475];

            if ((v14 & 1) != 0)
              return 0;
          }
          v15 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v15)
          {
            v16 = objc_loadWeakRetained((id *)(v4 + 16));
            v17 = (v16[475] & 1) == 0;

          }
          else
          {
            v17 = 1;
          }

          v3 = 0;
          if (v17 && g_boringssl_log)
          {
            v25 = (id)g_boringssl_log;
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              boringssl_session_copy_authenticator_trust_cold_1(v4, v25);
            goto LABEL_30;
          }
        }
      }
    }
  }
  return v3;
}

uint64_t boringssl_session_get_stack_error(uint64_t a1)
{
  uint64_t v1;
  id WeakRetained;
  id v3;
  uint64_t error;

  if (!a1)
    return 0;
  if (*(_DWORD *)a1 != -1252936367)
    return 0;
  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
    return 0;
  WeakRetained = objc_loadWeakRetained((id *)(v1 + 16));

  if (!WeakRetained)
    return 0;
  v3 = objc_loadWeakRetained((id *)(v1 + 16));
  error = nw_protocol_boringssl_get_error((uint64_t)v3);

  return error;
}

uint64_t boringssl_session_get_current_handshake_state(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
      return *(unsigned int *)(v1 + 304);
    else
      return 0;
  }
  return result;
}

uint64_t boringssl_session_get_ech_was_used(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(_QWORD *)(result + 8)) != 0)
    {
      result = *(_QWORD *)(v1 + 400);
      if (result)
        return SSL_ech_accepted(result);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t boringssl_session_set_ech_config(uint64_t a1, void *a2)
{
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t size;
  unsigned __int8 *v9;
  id WeakRetained;
  void *v11;
  _BYTE *v12;
  char v13;
  id v14;
  _BYTE *v15;
  _BOOL4 v16;
  NSObject *v17;

  v3 = a2;
  v4 = v3;
  if (!a1 || *(_DWORD *)a1 != -1252936367)
    goto LABEL_21;
  v5 = 0;
  if (v3)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      v7 = *(_QWORD *)(v6 + 400);
      if (!v7)
        goto LABEL_21;
      size = dispatch_data_get_size(v3);
      if (!size)
        goto LABEL_21;
      v9 = (unsigned __int8 *)size;
      v5 = (uint64_t)malloc_type_malloc(size, 0xAD8D9952uLL);
      if (v5)
      {
        boringssl_helper_dispatch_data_copyout(v4, v5, (uint64_t)v9);
        if (SSL_set1_ech_config_list(v7, (unsigned __int8 *)v5, v9))
        {
          free((void *)v5);
          v5 = 1;
          goto LABEL_22;
        }
        WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
        if (!WeakRetained
          || (v11 = WeakRetained,
              v12 = objc_loadWeakRetained((id *)(v6 + 16)),
              v13 = v12[475],
              v12,
              v11,
              (v13 & 1) == 0))
        {
          v14 = objc_loadWeakRetained((id *)(v6 + 16));
          if (v14)
          {
            v15 = objc_loadWeakRetained((id *)(v6 + 16));
            v16 = (v15[475] & 1) == 0;

          }
          else
          {
            v16 = 1;
          }

          if (v16)
          {
            if (g_boringssl_log)
            {
              v17 = (id)g_boringssl_log;
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
                boringssl_session_set_ech_config_cold_1(v6, v17);

            }
          }
        }
        free((void *)v5);
LABEL_21:
        v5 = 0;
      }
    }
  }
LABEL_22:

  return v5;
}

uint64_t boringssl_private_key_sign_callback(const SSL *a1, uint64_t a2, unint64_t *a3, unint64_t a4, int a5, const void *a6, size_t a7)
{
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  dispatch_data_t v16;
  void *v17;
  unsigned int v18;
  uint64_t v19;
  _QWORD v21[5];

  v13 = SSL_get_ex_data(a1, 0);
  if (!v13)
    return 2;
  v14 = v13;
  if (*(_DWORD *)v13 != -1252936367)
    return 2;
  v15 = (_QWORD *)v13[1];
  if (!v15)
    return 2;
  boringssl_session_update_metadata((uint64_t)v13);
  v16 = dispatch_data_create(a6, a7, 0, 0);
  v17 = (void *)v15[13];
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3221225472;
  v21[2] = __boringssl_private_key_sign_callback_block_invoke;
  v21[3] = &__block_descriptor_40_e45_v20__0__boringssl_concrete_boringssl_ctx_8B16l;
  v21[4] = v14;
  v18 = boringssl_identity_private_key_sign(v17, a2, a3, a4, a5, v16, v15, v21);
  if (v18 > 2)
    v19 = 2;
  else
    v19 = dword_1B5011F98[v18];

  return v19;
}

uint64_t boringssl_private_key_decrypt_callback(const SSL *a1, void *a2, size_t *a3, size_t a4, const void *a5, size_t a6)
{
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  dispatch_data_t v14;
  void *v15;
  unsigned int v16;
  uint64_t v17;
  _QWORD v19[5];

  v11 = SSL_get_ex_data(a1, 0);
  if (!v11)
    return 2;
  v12 = v11;
  if (*(_DWORD *)v11 != -1252936367)
    return 2;
  v13 = (_QWORD *)v11[1];
  if (!v13)
    return 2;
  boringssl_session_update_metadata((uint64_t)v11);
  v14 = dispatch_data_create(a5, a6, 0, 0);
  v15 = (void *)v13[13];
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 3221225472;
  v19[2] = __boringssl_private_key_decrypt_callback_block_invoke;
  v19[3] = &__block_descriptor_40_e45_v20__0__boringssl_concrete_boringssl_ctx_8B16l;
  v19[4] = v12;
  v16 = boringssl_identity_private_key_decrypt(v15, a2, a3, a4, v14, v13, v19);
  if (v16 > 2)
    v17 = 2;
  else
    v17 = dword_1B5011F98[v16];

  return v17;
}

uint64_t boringssl_private_key_complete(const SSL *a1, uint64_t a2, size_t *a3, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  unsigned int v9;

  v7 = SSL_get_ex_data(a1, 0);
  if (v7
    && *(_DWORD *)v7 == -1252936367
    && (v8 = v7[1]) != 0
    && (v9 = boringssl_identity_private_key_complete(*(void **)(v8 + 104), a2, a3, a4), v9 <= 2))
  {
    return dword_1B5011F98[v9];
  }
  else
  {
    return 2;
  }
}

uint64_t __boringssl_session_apply_protocol_options_for_transport_block_invoke_12(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;
  void *v6;
  void *v7;
  size_t bytes;
  size_t v9;
  const void *v10;
  NSObject *v11;
  uint64_t v12;
  dispatch_data_t v13;
  const void *v14;
  size_t v15;
  NSObject *v16;
  dispatch_data_t v17;
  boringssl_concrete_boringssl_psk *v18;
  void *v19;
  void *v20;
  _QWORD v22[6];
  _QWORD destructor[6];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  size_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  size_t length;

  v4 = a3;
  xpc_array_get_value(v4, 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  xpc_array_get_value(v4, 1uLL);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = 0;
  v37 = &v36;
  v38 = 0x2020000000;
  length = 0xAAAAAAAAAAAAAAAALL;
  length = xpc_data_get_length(v5);
  v32 = 0;
  v33 = &v32;
  v34 = 0x2020000000;
  v35 = (void *)0xAAAAAAAAAAAAAAAALL;
  v35 = malloc_type_malloc(v37[3], 0xCF95FB48uLL);
  v28 = 0;
  v29 = &v28;
  v30 = 0x2020000000;
  v31 = 0xAAAAAAAAAAAAAAAALL;
  v31 = xpc_data_get_length(v6);
  v24 = 0;
  v25 = &v24;
  v26 = 0x2020000000;
  v27 = (void *)0xAAAAAAAAAAAAAAAALL;
  v27 = malloc_type_malloc(v29[3], 0x10DD0AFEuLL);
  v7 = (void *)v33[3];
  if (v7)
  {
    if (v25[3])
    {
      bytes = xpc_data_get_bytes(v5, v7, 0, v37[3]);
      v9 = xpc_data_get_bytes(v6, (void *)v25[3], 0, v29[3]);
      if (bytes == v37[3] && v9 == v29[3])
      {
        v10 = (const void *)v33[3];
        v11 = dispatch_workloop_copy_current();
        v12 = MEMORY[0x1E0C809B0];
        destructor[0] = MEMORY[0x1E0C809B0];
        destructor[1] = 3221225472;
        destructor[2] = __boringssl_session_apply_protocol_options_for_transport_block_invoke_2;
        destructor[3] = &unk_1E686E688;
        destructor[4] = &v36;
        destructor[5] = &v32;
        v13 = dispatch_data_create(v10, bytes, v11, destructor);

        v14 = (const void *)v25[3];
        v15 = v29[3];
        v16 = dispatch_workloop_copy_current();
        v22[0] = v12;
        v22[1] = 3221225472;
        v22[2] = __boringssl_session_apply_protocol_options_for_transport_block_invoke_14;
        v22[3] = &unk_1E686E688;
        v22[4] = &v28;
        v22[5] = &v24;
        v17 = dispatch_data_create(v14, v15, v16, v22);

        v18 = boringssl_psk_create(v13, v17);
        boringssl_psk_cache_add_psk(*(void **)(*(_QWORD *)(a1 + 32) + 40), v18);

        goto LABEL_12;
      }
      cc_clear();
      v19 = (void *)v33[3];
      if (v19)
      {
        free(v19);
        v33[3] = 0;
      }
      cc_clear();
    }
    else
    {
      free((void *)v33[3]);
      v33[3] = 0;
    }
  }
  v20 = (void *)v25[3];
  if (v20)
  {
    free(v20);
    v25[3] = 0;
  }
LABEL_12:
  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v28, 8);
  _Block_object_dispose(&v32, 8);
  _Block_object_dispose(&v36, 8);

  return 1;
}

void sub_1B4FB6004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  uint64_t v30;

  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose((const void *)(v30 - 136), 8);
  _Unwind_Resume(a1);
}

void __boringssl_session_apply_protocol_options_for_transport_block_invoke_2(uint64_t a1)
{
  void *v2;

  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    __boringssl_session_apply_protocol_options_for_transport_block_invoke_2_cold_1();
  cc_clear();
  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

void __boringssl_session_apply_protocol_options_for_transport_block_invoke_14(uint64_t a1)
{
  void *v2;

  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    __boringssl_session_apply_protocol_options_for_transport_block_invoke_14_cold_1();
  cc_clear();
  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

const SSL *boringssl_session_psk_client13_ext_callback_handler(const SSL *result)
{
  if (result)
  {
    result = (const SSL *)SSL_get_ex_data(result, 0);
    if (result)
    {
      if (result->version == -1252936367 && result->method)
        return (const SSL *)(nw_protocol_options_access_handle() ^ 1);
      else
        return 0;
    }
  }
  return result;
}

size_t boringssl_session_server_psk_callback_handler(const SSL *a1, const char *a2, uint64_t a3, unsigned int a4)
{
  _QWORD *v7;
  uint64_t v8;
  id WeakRetained;
  void *v10;
  _BYTE *v11;
  char v12;
  id v13;
  _BYTE *v14;
  _BOOL4 v15;
  size_t size;
  id v18;
  void *v19;
  _BYTE *v20;
  char v21;
  id v22;
  _BYTE *v23;
  _BOOL4 v24;
  NSObject *v25;
  id psk;
  NSObject *v27;
  NSObject *v28;
  size_t v29;
  dispatch_data_t v30;
  id v31;
  void *v32;
  _BYTE *v33;
  char v34;
  id v35;
  _BYTE *v36;
  _BOOL4 v37;
  NSObject *v38;

  if (a1)
  {
    v7 = SSL_get_ex_data(a1, 0);
    if (v7)
    {
      if (*(_DWORD *)v7 == -1252936367)
      {
        v8 = v7[1];
        if (v8)
        {
          nw_protocol_metadata_access_handle();
          if (a2 && *a2)
          {
            WeakRetained = objc_loadWeakRetained((id *)(v8 + 16));
            if (!WeakRetained
              || (v10 = WeakRetained,
                  v11 = objc_loadWeakRetained((id *)(v8 + 16)),
                  v12 = v11[475],
                  v11,
                  v10,
                  (v12 & 1) == 0))
            {
              v13 = objc_loadWeakRetained((id *)(v8 + 16));
              if (v13)
              {
                v14 = objc_loadWeakRetained((id *)(v8 + 16));
                v15 = (v14[475] & 1) == 0;

              }
              else
              {
                v15 = 1;
              }

              if (v15)
              {
                if (g_boringssl_log)
                {
                  v28 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
                    boringssl_session_server_psk_callback_handler_cold_3(v8, v28);

                }
              }
            }
            v29 = strlen(a2);
            v30 = dispatch_data_create(a2, v29, 0, 0);
            psk = boringssl_psk_cache_lookup_psk(*(void **)(v8 + 40), v30, *(void **)(v8 + 520));

            if (!psk)
              goto LABEL_34;
          }
          else
          {
            v18 = objc_loadWeakRetained((id *)(v8 + 16));
            if (!v18
              || (v19 = v18,
                  v20 = objc_loadWeakRetained((id *)(v8 + 16)),
                  v21 = v20[475],
                  v20,
                  v19,
                  (v21 & 1) == 0))
            {
              v22 = objc_loadWeakRetained((id *)(v8 + 16));
              if (v22)
              {
                v23 = objc_loadWeakRetained((id *)(v8 + 16));
                v24 = (v23[475] & 1) == 0;

              }
              else
              {
                v24 = 1;
              }

              if (v24)
              {
                if (g_boringssl_log)
                {
                  v25 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
                    boringssl_session_server_psk_callback_handler_cold_2(v8, v25);

                }
              }
            }
            psk = boringssl_psk_cache_copy_first_psk(*(void **)(v8 + 40));
            if (!psk)
            {
LABEL_34:
              v31 = objc_loadWeakRetained((id *)(v8 + 16));
              if (!v31
                || (v32 = v31,
                    v33 = objc_loadWeakRetained((id *)(v8 + 16)),
                    v34 = v33[475],
                    v33,
                    v32,
                    (v34 & 1) == 0))
              {
                v35 = objc_loadWeakRetained((id *)(v8 + 16));
                if (v35)
                {
                  v36 = objc_loadWeakRetained((id *)(v8 + 16));
                  v37 = (v36[475] & 1) == 0;

                }
                else
                {
                  v37 = 1;
                }

                size = 0;
                if (!v37 || !g_boringssl_log)
                  goto LABEL_45;
                v38 = (id)g_boringssl_log;
                if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
                  boringssl_session_server_psk_callback_handler_cold_1(v8, v38);

              }
              size = 0;
LABEL_45:

              return size;
            }
          }
          v27 = boringssl_psk_copy_key((id *)psk);
          size = dispatch_data_get_size(v27);
          if (size)
          {
            *(_BYTE *)(v8 + 559) |= 0x80u;
            boringssl_helper_dispatch_data_copyout(v27, a3, a4);
          }

          goto LABEL_45;
        }
      }
    }
  }
  return 0;
}

size_t boringssl_session_client_psk_callback_handler(const SSL *a1, const char *a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6)
{
  size_t v6;
  _QWORD *v11;
  uint64_t v12;
  id WeakRetained;
  void *v14;
  _BYTE *v15;
  char v16;
  id v17;
  _BYTE *v18;
  _BOOL4 v19;
  _BYTE *v21;
  char v22;
  id v23;
  _BYTE *v24;
  _BOOL4 v25;
  NSObject *v26;
  size_t v27;
  dispatch_data_t v28;
  NSObject *v29;
  id *v30;
  id *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  size_t size;
  uint64_t v37;
  id v38;
  void *v39;
  _BYTE *v40;
  char v41;
  id v42;
  _BYTE *v43;
  _BOOL4 v44;

  if (a1)
  {
    LODWORD(v6) = a6;
    v11 = SSL_get_ex_data(a1, 0);
    if (v11)
    {
      if (*(_DWORD *)v11 == -1252936367)
      {
        v12 = v11[1];
        if (v12)
        {
          nw_protocol_metadata_access_handle();
          WeakRetained = objc_loadWeakRetained((id *)(v12 + 16));
          v14 = WeakRetained;
          if (a2)
          {
            if (!WeakRetained
              || (v15 = objc_loadWeakRetained((id *)(v12 + 16)),
                  v16 = v15[475],
                  v15,
                  v14,
                  (v16 & 1) == 0))
            {
              v17 = objc_loadWeakRetained((id *)(v12 + 16));
              if (v17)
              {
                v18 = objc_loadWeakRetained((id *)(v12 + 16));
                v19 = (v18[475] & 1) == 0;

              }
              else
              {
                v19 = 1;
              }

              if (v19)
              {
                if (g_boringssl_log)
                {
                  v26 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
                    boringssl_session_client_psk_callback_handler_cold_3(v12, v26);

                }
              }
            }
            v27 = strlen(a2);
            v28 = dispatch_data_create(a2, v27, 0, 0);
LABEL_30:
            v30 = (id *)boringssl_psk_cache_lookup_psk(*(void **)(v12 + 40), v28, *(void **)(v12 + 520));
            v31 = v30;
            if (v30)
            {
              v32 = boringssl_psk_copy_identity(v30);
              v33 = v32;
              if (v32 && dispatch_data_get_size(v32))
                boringssl_helper_dispatch_data_copyout(v33, a3, a4);
              v34 = boringssl_psk_copy_key(v31);
              v35 = v34;
              if (v34)
              {
                size = dispatch_data_get_size(v34);
                v37 = v6;
                if (size >= v6)
                  v6 = v6;
                else
                  v6 = size;
                boringssl_helper_dispatch_data_copyout(v35, a5, v37);
              }
              else
              {
                v6 = 0;
              }
              *(_BYTE *)(v12 + 559) |= 0x80u;

            }
            else
            {
              v38 = objc_loadWeakRetained((id *)(v12 + 16));
              if (v38)
              {
                v39 = v38;
                v40 = objc_loadWeakRetained((id *)(v12 + 16));
                v41 = v40[475];

                if ((v41 & 1) != 0)
                {
                  v6 = 0;
                  goto LABEL_46;
                }
              }
              v42 = objc_loadWeakRetained((id *)(v12 + 16));
              if (v42)
              {
                v43 = objc_loadWeakRetained((id *)(v12 + 16));
                v44 = (v43[475] & 1) == 0;

              }
              else
              {
                v44 = 1;
              }

              v6 = 0;
              if (!v44 || !g_boringssl_log)
                goto LABEL_46;
              v33 = (id)g_boringssl_log;
              if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
                boringssl_session_client_psk_callback_handler_cold_1(v12, v33);
              v6 = 0;
            }

LABEL_46:
            return v6;
          }
          if (!WeakRetained
            || (v21 = objc_loadWeakRetained((id *)(v12 + 16)),
                v22 = v21[475],
                v21,
                v14,
                (v22 & 1) == 0))
          {
            v23 = objc_loadWeakRetained((id *)(v12 + 16));
            if (v23)
            {
              v24 = objc_loadWeakRetained((id *)(v12 + 16));
              v25 = (v24[475] & 1) == 0;

            }
            else
            {
              v25 = 1;
            }

            v28 = 0;
            if (!v25 || !g_boringssl_log)
              goto LABEL_30;
            v29 = (id)g_boringssl_log;
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
              boringssl_session_client_psk_callback_handler_cold_2(v12, v29);

          }
          v28 = 0;
          goto LABEL_30;
        }
      }
    }
  }
  return 0;
}

void __boringssl_context_start_handshake_timer_block_invoke(uint64_t a1)
{
  char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  ssl_st *v5;
  bssl *v6;
  id WeakRetained;
  void *v8;
  unsigned __int8 *v9;
  id v10;
  _BYTE *v11;
  _BOOL4 v12;
  NSObject *v13;
  id v14;
  void *v15;
  id v16;
  _QWORD *v17;
  uint64_t v18;
  id v19;
  _QWORD *v20;
  id v21;
  id v22;
  _BYTE v23[18];
  __int16 v24;
  void *v25;
  __int16 v26;
  id v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  ++*(_QWORD *)(*(_QWORD *)(a1 + 32) + 328);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if (*(_DWORD *)v2 == -1252936367)
    {
      v3 = *(_QWORD *)(v2 + 8);
      if (v3)
      {
        if ((*(_BYTE *)(v3 + 556) & 0x20) != 0)
        {
          v4 = *(_QWORD *)(v3 + 400);
          if (!v4
            || (memset(v23, 170, 16), !DTLSv1_get_timeout(v4, (unint64_t *)v23))
            || *(_QWORD *)v23
            || *(_DWORD *)&v23[8]
            || (v6 = *(bssl **)(v3 + 400)) != 0 && DTLSv1_handle_timeout(v6, v5) == 1)
          {
            boringssl_context_start_handshake_timer(v2);
          }
          else
          {
            WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
            if (!WeakRetained
              || (v8 = WeakRetained,
                  v9 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16)),
                  v1 = (char *)v9[475],
                  v9,
                  v8,
                  (v1 & 1) == 0))
            {
              v10 = objc_loadWeakRetained((id *)(v3 + 16));
              if (v10)
              {
                v11 = objc_loadWeakRetained((id *)(v3 + 16));
                v12 = (v11[475] & 1) == 0;

              }
              else
              {
                v12 = 1;
              }

              if (v12)
              {
                if (g_boringssl_log)
                {
                  v13 = (id)g_boringssl_log;
                  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
                  {
                    v14 = objc_loadWeakRetained((id *)(v3 + 16));
                    if (v14)
                    {
                      v1 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
                      v15 = v1 + 391;
                    }
                    else
                    {
                      v15 = &unk_1B50022E3;
                    }
                    v16 = objc_loadWeakRetained((id *)(v3 + 16));
                    *(_DWORD *)v23 = 136447234;
                    *(_QWORD *)&v23[4] = "boringssl_context_handle_handshake_timer";
                    *(_WORD *)&v23[12] = 1024;
                    *(_DWORD *)&v23[14] = 342;
                    v24 = 2082;
                    v25 = v15;
                    v26 = 2048;
                    v27 = v16;
                    v28 = 1024;
                    v29 = 10;
                    _os_log_impl(&dword_1B4F6D000, v13, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Handshake took more than %d seconds to complete, closing this session", v23, 0x2Cu);

                    if (v14)
                  }

                }
              }
            }
            v17 = objc_loadWeakRetained((id *)(v3 + 16));
            v18 = v17[40];

            if (v18)
            {
              v19 = objc_loadWeakRetained((id *)(v3 + 16));
              nw_queue_cancel_source();

              v20 = objc_loadWeakRetained((id *)(v3 + 16));
              v20[40] = 0;

            }
            v21 = objc_loadWeakRetained((id *)(v3 + 16));
            nw_protocol_boringssl_internal_error(v21, 60);

            v22 = objc_loadWeakRetained((id *)(v3 + 16));
            nw_protocol_boringssl_disconnect((uint64_t)v22 + 8);

          }
        }
      }
    }
  }
}

void __boringssl_context_start_handshake_timer_block_invoke_2(uint64_t a1)
{
  char *v1;
  uint64_t v3;
  id WeakRetained;
  void *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  id v8;
  _BYTE *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  _BOOL4 v13;
  id v14;
  char v15;
  void *v16;
  uint64_t v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  void *v23;
  __int16 v24;
  id v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 32);
  if (!v3)
    goto LABEL_7;
  WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
  if (WeakRetained)
  {
    v5 = WeakRetained;
    v6 = (unsigned __int8 *)objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
    v1 = (char *)v6[475];

    if ((v1 & 1) != 0)
      return;
  }
  v7 = *(_QWORD *)(a1 + 32);
  if (!v7)
  {
LABEL_7:
    v10 = 1;
    goto LABEL_10;
  }
  v8 = objc_loadWeakRetained((id *)(v7 + 16));
  if (v8)
  {
    v9 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
    v10 = (v9[475] & 1) == 0;

  }
  else
  {
    v10 = 1;
  }

  if ((_DWORD)v10)
  {
LABEL_10:
    if (!g_boringssl_log)
      return;
    v11 = (id)g_boringssl_log;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      goto LABEL_12;
    v12 = *(_QWORD *)(a1 + 32);
    if (v12)
    {
      v10 = (uint64_t)objc_loadWeakRetained((id *)(v12 + 16));
      v17 = *(_QWORD *)(a1 + 32);
      if (v10)
      {
        v13 = v17 != 0;
        if (v17)
        {
          v1 = (char *)objc_loadWeakRetained((id *)(v17 + 16));
          v17 = *(_QWORD *)(a1 + 32);
        }
        else
        {
          v1 = 0;
        }
        v16 = v1 + 391;
      }
      else
      {
        v13 = 0;
        v16 = &unk_1B50022E3;
      }
      if (v17)
      {
        v14 = objc_loadWeakRetained((id *)(v17 + 16));
        v15 = 0;
      }
      else
      {
        v14 = 0;
        v15 = 1;
      }
    }
    else
    {
      v13 = 0;
      v14 = 0;
      v15 = 1;
      v16 = &unk_1B50022E3;
    }
    v18 = 136446978;
    v19 = "boringssl_context_start_handshake_timer_block_invoke_2";
    v20 = 1024;
    v21 = 374;
    v22 = 2082;
    v23 = v16;
    v24 = 2048;
    v25 = v14;
    _os_log_debug_impl(&dword_1B4F6D000, v11, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] Cancelling TLS handshake timer", (uint8_t *)&v18, 0x26u);
    if ((v15 & 1) != 0)
    {
      if (!v13)
        goto LABEL_27;
    }
    else
    {

      if (!v13)
      {
LABEL_27:
        if (!v12)
          goto LABEL_12;
        goto LABEL_31;
      }
    }

    if (!v12)
    {
LABEL_12:

      return;
    }
LABEL_31:

    goto LABEL_12;
  }
}

void __boringssl_private_key_sign_callback_block_invoke(uint64_t a1, void *a2, int a3)
{
  id *v5;
  uint64_t v6;
  uint64_t v7;
  id WeakRetained;
  id *v9;

  v5 = a2;
  if (a3)
  {
    v6 = *(_QWORD *)(a1 + 32);
    if (!v6
      || *(_DWORD *)v6 != -1252936367
      || (v7 = *(_QWORD *)(v6 + 8)) == 0
      || *(_DWORD *)(v7 + 300) <= 3u && (*(_BYTE *)(v7 + 556) & 2) == 0)
    {
      v9 = v5;
      WeakRetained = objc_loadWeakRetained(v5 + 2);
      nw_protocol_boringssl_handshake_negotiate(WeakRetained);

      v5 = v9;
    }
  }

}

void __boringssl_private_key_decrypt_callback_block_invoke(uint64_t a1, void *a2, int a3)
{
  id *v5;
  uint64_t v6;
  uint64_t v7;
  id WeakRetained;
  id *v9;

  v5 = a2;
  if (a3)
  {
    v6 = *(_QWORD *)(a1 + 32);
    if (!v6
      || *(_DWORD *)v6 != -1252936367
      || (v7 = *(_QWORD *)(v6 + 8)) == 0
      || *(_DWORD *)(v7 + 300) <= 3u && (*(_BYTE *)(v7 + 556) & 2) == 0)
    {
      v9 = v5;
      WeakRetained = objc_loadWeakRetained(v5 + 2);
      nw_protocol_boringssl_handshake_negotiate(WeakRetained);

      v5 = v9;
    }
  }

}

uint64_t __boringssl_session_psk_client13_ext_callback_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  unint64_t length;
  void *v10;
  size_t v11;
  id v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  id v19;
  uint64_t v21;
  id WeakRetained;
  void *v23;
  _BYTE *v24;
  char v25;
  uint64_t v26;
  id v27;
  _BYTE *v28;
  _BOOL4 v29;
  NSObject *v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  id v34;
  void *v35;
  void *v36;
  void *v37;
  const void *bytes_ptr;
  void *v39;
  const void *v40;
  void *v41;
  const char *string_ptr;
  void *v43;
  void *v44;
  char v45;
  _BOOL4 v46;
  uint64_t v47;
  void *v48;
  size_t v49;
  void *v50;
  uint8_t buf[4];
  const char *v52;
  __int16 v53;
  int v54;
  __int16 v55;
  void *v56;
  __int16 v57;
  id v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v4 = *(id *)(a2 + 72);
  v5 = v4;
  if (v4 && xpc_array_get_count(v4))
  {
    xpc_array_get_array(v5, 0);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = v6;
    if (!v6 || xpc_array_get_count(v6) != 2)
    {
      v18 = 0;
LABEL_27:

      goto LABEL_28;
    }
    xpc_array_get_value(v7, 0);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    length = xpc_data_get_length(v8);
    xpc_array_get_value(v7, 1uLL);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = xpc_data_get_length(v10);
    v12 = *(id *)(a2 + 48);
    v13 = v12;
    v50 = v12;
    if (!v12)
    {
      v17 = 0;
      goto LABEL_20;
    }
    if (!xpc_array_get_count(v12))
    {
      v17 = 0;
      v13 = 0;
      goto LABEL_20;
    }
    v48 = v10;
    xpc_array_get_value(v13, 0);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = MEMORY[0x1B5E45A2C]();
    v16 = MEMORY[0x1E0C81390];
    if (v15 == MEMORY[0x1E0C81390])
    {
      v19 = v14;
    }
    else
    {
      if (MEMORY[0x1B5E45A2C](v14) != MEMORY[0x1E0C812C8])
      {
        v17 = 0;
        goto LABEL_18;
      }
      xpc_array_get_value(v14, 0);
      v19 = (id)objc_claimAutoreleasedReturnValue();
    }
    v17 = v19;
    if (v19 && MEMORY[0x1B5E45A2C](v19) == v16)
    {
      v13 = (void *)xpc_string_get_length(v17);
      goto LABEL_19;
    }
LABEL_18:
    v13 = 0;
LABEL_19:
    v10 = v48;

LABEL_20:
    v18 = 0;
    if (!length || !v11)
      goto LABEL_26;
    if (length > **(unsigned int **)(a1 + 32)
      || v11 > **(unsigned int **)(a1 + 40)
      || (unint64_t)v13 > **(unsigned int **)(a1 + 48))
    {
      v18 = 0;
LABEL_26:

      goto LABEL_27;
    }
    v49 = v11;
    v21 = *(_QWORD *)(a1 + 56);
    if (!v21)
      goto LABEL_36;
    WeakRetained = objc_loadWeakRetained((id *)(v21 + 16));
    if (WeakRetained)
    {
      v23 = WeakRetained;
      v24 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 56) + 16));
      v25 = v24[475];

      if ((v25 & 1) != 0)
      {
LABEL_60:
        **(_QWORD **)(a1 + 64) = SSL_get_cipher_by_value(4865);
        **(_DWORD **)(a1 + 32) = length;
        v37 = *(void **)(a1 + 72);
        bytes_ptr = xpc_data_get_bytes_ptr(v8);
        memcpy(v37, bytes_ptr, length);
        **(_DWORD **)(a1 + 40) = v49;
        v39 = *(void **)(a1 + 80);
        v40 = xpc_data_get_bytes_ptr(v10);
        memcpy(v39, v40, v49);
        **(_DWORD **)(a1 + 48) = (_DWORD)v13;
        if (v13)
        {
          v41 = *(void **)(a1 + 88);
          string_ptr = xpc_string_get_string_ptr(v17);
          memcpy(v41, string_ptr, (size_t)v13);
        }
        v18 = 1;
        goto LABEL_26;
      }
    }
    v26 = *(_QWORD *)(a1 + 56);
    if (v26)
    {
      v27 = objc_loadWeakRetained((id *)(v26 + 16));
      if (v27)
      {
        v28 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 56) + 16));
        v29 = (v28[475] & 1) == 0;

      }
      else
      {
        v29 = 1;
      }

    }
    else
    {
LABEL_36:
      v29 = 1;
    }
    if (v29 && g_boringssl_log)
    {
      v30 = (id)g_boringssl_log;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
      {
        v31 = *(_QWORD *)(a1 + 56);
        v47 = v31;
        if (v31)
        {
          v32 = (char *)objc_loadWeakRetained((id *)(v31 + 16));
          v33 = *(_QWORD *)(a1 + 56);
          v44 = v32;
          if (v32)
          {
            v46 = v33 != 0;
            if (v33)
            {
              v32 = (char *)objc_loadWeakRetained((id *)(v33 + 16));
              v33 = *(_QWORD *)(a1 + 56);
            }
            else
            {
              v32 = 0;
            }
            v35 = v32 + 391;
          }
          else
          {
            v46 = 0;
            v35 = &unk_1B50022E3;
          }
          v43 = v32;
          if (v33)
          {
            v34 = objc_loadWeakRetained((id *)(v33 + 16));
            v45 = 0;
          }
          else
          {
            v34 = 0;
            v45 = 1;
          }
        }
        else
        {
          v34 = 0;
          v45 = 1;
          v46 = 0;
          v35 = &unk_1B50022E3;
        }
        *(_DWORD *)buf = 136446978;
        v52 = "boringssl_session_psk_client13_ext_callback_handler_block_invoke";
        v53 = 1024;
        v54 = 1715;
        v55 = 2082;
        v56 = v35;
        v57 = 2048;
        v36 = v34;
        v58 = v34;
        _os_log_impl(&dword_1B4F6D000, v30, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] Running TLS 1.3 external PSK client callback", buf, 0x26u);
        if ((v45 & 1) == 0)

        if (v46)
        if (v47)

      }
    }
    goto LABEL_60;
  }
  v18 = 0;
LABEL_28:

  return v18;
}

BOOL __boringssl_session_server_psk_callback_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v3;
  void *v4;

  if (a2)
  {
    v3 = boringssl_psk_cache_copy_psk_object_array(*(void **)(*(_QWORD *)(a1 + 32) + 40));
    v4 = *(void **)(a2 + 96);
    *(_QWORD *)(a2 + 96) = v3;

  }
  return a2 != 0;
}

BOOL __boringssl_session_client_psk_callback_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v3;
  void *v4;

  if (a2)
  {
    v3 = boringssl_psk_cache_copy_psk_object_array(*(void **)(*(_QWORD *)(a1 + 32) + 40));
    v4 = *(void **)(a2 + 96);
    *(_QWORD *)(a2 + 96) = v3;

  }
  return a2 != 0;
}

id OUTLINED_FUNCTION_20()
{
  uint64_t v0;
  int *v1;

  return objc_loadWeakRetained((id *)(v0 + *v1));
}

const char *OUTLINED_FUNCTION_21()
{
  unsigned int v0;

  return boringssl_helper_get_ssl_error_code_description(v0);
}

uint64_t __nw_protocol_boringssl_write_bytes_block_invoke(uint64_t a1)
{
  nw_frame_finalize();
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return 1;
}

void nw_protocol_boringssl_internal_error(void *a1, int a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;

  v3 = a1;
  v4 = v3;
  if (v3 && (*((_BYTE *)v3 + 390) & 4) == 0)
  {
    *((_BYTE *)v3 + 390) |= 4u;
    v5 = v3[42];
    v7 = v4;
    if (v5)
    {
      boringssl_context_set_internal_error(v5, a2);
      boringssl_metrics_log_connection_failure(v7[42]);
      boringssl_metrics_log_ech(v7[42]);
      v4 = v7;
    }
    v6 = v4[7];
    if (v6 && (*((_BYTE *)v4 + 388) & 4) != 0)
    {
      (*(void (**)(void))(*(_QWORD *)(v6 + 24) + 56))();
      v4 = v7;
    }
  }

}

__int128 *nw_protocol_boringssl_identifier()
{
  if (nw_protocol_boringssl_identifier_onceToken != -1)
    dispatch_once(&nw_protocol_boringssl_identifier_onceToken, &__block_literal_global_0);
  return &g_boringssl_protocol_identifier;
}

uint64_t nw_protocol_boringssl_replace_input_handler(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int (*v5)(uint64_t);
  char v6;
  _BOOL4 v7;
  _BOOL4 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v3 = *(_QWORD *)(result + 40);
    if (!v3)
      return 0;
    if ((*(_BYTE *)(v3 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        if (g_boringssl_log)
        {
          v12 = result;
          v14 = a2;
          v11 = a3;
          v7 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
          a2 = v14;
          v8 = v7;
          a3 = v11;
          result = v12;
          if (v8)
          {
            nw_protocol_boringssl_replace_input_handler_cold_1();
            a3 = v11;
            result = v12;
            a2 = v14;
          }
        }
      }
    }
    if (*(_QWORD *)(result + 48) == a2)
    {
      *(_QWORD *)(result + 48) = a3;
      *(_QWORD *)(a3 + 32) = result;
      v4 = *(_QWORD *)(a3 + 24);
      if (v4 && (v5 = *(unsigned int (**)(uint64_t))(v4 + 176)) != 0 && v5(a3))
        v6 = *(_BYTE *)(v3 + 389) | 0x10;
      else
        v6 = *(_BYTE *)(v3 + 389) & 0xEF;
      *(_BYTE *)(v3 + 389) = v6;
      return 1;
    }
    else
    {
      if ((*(_BYTE *)(v3 + 475) & 1) != 0)
        return 0;
      v9 = result;
      v15 = a2;
      result = g_boringssl_log;
      if (g_boringssl_log)
      {
        v13 = g_boringssl_log;
        result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
          v10 = *(_QWORD *)(v9 + 48);
          *(_DWORD *)buf = 136447490;
          v17 = "nw_protocol_boringssl_replace_input_handler";
          v18 = 1024;
          v19 = 1193;
          v20 = 2082;
          v21 = v3 + 391;
          v22 = 2048;
          v23 = v3;
          v24 = 2048;
          v25 = v10;
          v26 = 2048;
          v27 = v15;
          _os_log_error_impl(&dword_1B4F6D000, v13, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] old input handler does not match (%p != %p)", buf, 0x3Au);
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t nw_protocol_boringssl_reset(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(void);

  if (!a1)
    return 0;
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(v2 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_reset_cold_4();
    }
    nw_protocol_boringssl_cleanup((void *)v2);
    v3 = (void *)nw_parameters_copy_context();
    if (v3)
    {
      v4 = boringssl_context_create_with_nw_context((void *)v2, v3);
      *(_QWORD *)(v2 + 336) = v4;
      if (v4)
      {
        v5 = boringssl_bio_create(v2, (uint64_t)nw_protocol_boringssl_read_bytes, (uint64_t)nw_protocol_boringssl_write_bytes);
        *(_QWORD *)(v2 + 344) = v5;
        if (v5)
        {
          *(_OWORD *)(v2 + 280) = 0u;
          *(_OWORD *)(v2 + 296) = 0u;
          v6 = *(void **)(v2 + 368);
          *(_QWORD *)(v2 + 368) = 0;

          *(_QWORD *)(v2 + 376) = 0;
          *(_BYTE *)(v2 + 388) &= 0x1Au;
          *(_BYTE *)(v2 + 389) &= 0x18u;
          *(_BYTE *)(v2 + 390) &= 0xF8u;
          v7 = *(_QWORD *)(a1 + 32);
          if (v7 && (v8 = *(_QWORD *)(v7 + 24)) != 0 && (v9 = *(uint64_t (**)(void))(v8 + 256)) != 0)
            v2 = v9();
          else
            v2 = 1;
          goto LABEL_23;
        }
        if ((*(_BYTE *)(v2 + 475) & 1) == 0
          && g_boringssl_log
          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        {
          nw_protocol_boringssl_reset_cold_3();
        }
      }
      else if ((*(_BYTE *)(v2 + 475) & 1) == 0
             && g_boringssl_log
             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_reset_cold_2();
      }
    }
    else if ((*(_BYTE *)(v2 + 475) & 1) == 0
           && g_boringssl_log
           && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_reset_cold_1();
    }
    v2 = 0;
LABEL_23:

  }
  return v2;
}

uint64_t nw_protocol_boringssl_get_error(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 384);
  return result;
}

uint64_t nw_protocol_error_print()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    nw_protocol_error_print_cold_1();
  return 1;
}

id nw_dispatch_data_create_subrange_map(void *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  NSObject *v7;
  NSObject *v8;
  id v9;
  id v10;
  _QWORD v12[10];
  _QWORD v13[4];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t (*v25)(uint64_t, uint64_t);
  void (*v26)(uint64_t);
  id v27;

  v7 = a1;
  v8 = v7;
  if (a4)
  {
    if (a3)
    {
      v22 = 0;
      v23 = &v22;
      v24 = 0x3032000000;
      v25 = __Block_byref_object_copy_;
      v26 = __Block_byref_object_dispose_;
      v27 = 0;
      v18 = 0;
      v19 = &v18;
      v20 = 0x2020000000;
      v21 = 0;
      v14 = 0;
      v15 = &v14;
      v16 = 0x2020000000;
      v17 = 0;
      v13[0] = 0;
      v13[1] = v13;
      v13[2] = 0x2020000000;
      v13[3] = 0;
      v12[0] = MEMORY[0x1E0C809B0];
      v12[1] = 3221225472;
      v12[2] = __nw_dispatch_data_create_subrange_map_block_invoke;
      v12[3] = &unk_1E686E888;
      v12[8] = a2;
      v12[9] = a3;
      v12[4] = &v22;
      v12[5] = &v18;
      v12[6] = &v14;
      v12[7] = v13;
      dispatch_data_apply(v7, v12);
      v9 = 0;
      if (v19[3] == a3)
      {
        *a4 = v15[3];
        v9 = (id)v23[5];
      }
      _Block_object_dispose(v13, 8);
      _Block_object_dispose(&v14, 8);
      _Block_object_dispose(&v18, 8);
      _Block_object_dispose(&v22, 8);

    }
    else
    {
      v9 = (id)MEMORY[0x1E0C80D00];
      v10 = MEMORY[0x1E0C80D00];
    }
  }
  else
  {
    v9 = 0;
  }

  return v9;
}

BOOL __nw_protocol_boringssl_write_frames_block_invoke_129(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  id v9;
  void *v10;
  uint64_t v11;
  BOOL v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  void *v19;
  NSObject *v21;
  uint64_t v22;
  void *v23;
  int v24;
  uint64_t v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  void *v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  void *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v25 = 0;
  v24 = 0;
  v5 = (uint64_t *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(v4 + 176);
  if (v6)
  {
    v25 = *(_QWORD *)(v4 + 176);
    v24 = *(_DWORD *)(v4 + 184);
  }
  else if (nw_frame_uses_external_data())
  {
    nw_frame_get_external_data();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = v7;
    if (v7)
    {
      v9 = nw_dispatch_data_create_subrange_map(v7, 0, 0, &v25);
      v10 = *(void **)(*v5 + 168);
      *(_QWORD *)(*v5 + 168) = v9;

      v11 = *v5;
      if (*(_QWORD *)(*v5 + 168))
      {
        *(_QWORD *)(v11 + 176) = v25;
        *(_DWORD *)(*v5 + 184) = 0;
      }
      else if ((*(_BYTE *)(v11 + 475) & 1) == 0)
      {
        v21 = g_boringssl_log;
        if (g_boringssl_log)
        {
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            v22 = *v5;
            v23 = (void *)(*v5 + 391);
            if (!*v5)
              v23 = &unk_1B50022E3;
            *(_DWORD *)buf = 136447746;
            v27 = "nw_protocol_boringssl_write_frames_block_invoke";
            v28 = 1024;
            v29 = 1046;
            v30 = 2082;
            v31 = v23;
            v32 = 2048;
            v33 = v22;
            v34 = 2112;
            v35 = v8;
            v36 = 1024;
            v37 = 0;
            v38 = 1024;
            v39 = 0;
            _os_log_error_impl(&dword_1B4F6D000, v21, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] Failed to flatten external data %@ (offset %u, unclaimed %u)", buf, 0x3Cu);
          }
        }
      }
    }

    v6 = v25;
  }
  else
  {
    v6 = nw_frame_unclaimed_bytes();
    v25 = v6;
  }
  if (v6)
    v12 = v24 == 0;
  else
    v12 = 1;
  if (!v12)
  {
    v13 = (*(uint64_t (**)(_QWORD))(*v5 + 88))(*(_QWORD *)(*v5 + 336));
    v14 = v13;
    if (v13 >= 1)
    {
      v15 = *(_QWORD *)(*v5 + 176);
      if (v15)
      {
        *(_QWORD *)(*v5 + 176) = v15 + v13;
        *(_DWORD *)(*v5 + 184) -= v13;
      }
      else
      {
        nw_frame_claim();
      }
    }
    v16 = v24;
    if ((v24 & 0x80000000) == 0)
      goto LABEL_19;
    if ((!*v5 || (*(_BYTE *)(*v5 + 475) & 1) == 0) && g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        __nw_protocol_boringssl_write_frames_block_invoke_129_cold_1();
      v16 = v24;
      if ((v24 & 0x80000000) == 0)
      {
LABEL_19:
        if (v14 < v16)
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
      }
    }
  }
  v17 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v18 = *(unsigned __int8 *)(v17 + 24);
  if (*(_BYTE *)(v17 + 24))
  {
    v19 = *(void **)(*v5 + 168);
    *(_QWORD *)(*v5 + 168) = 0;

    *(_QWORD *)(*v5 + 176) = 0;
    *(_DWORD *)(*v5 + 184) = 0;
    nw_frame_array_remove();
    nw_frame_finalize();
  }

  return v18 != 0;
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{

}

uint64_t __nw_protocol_boringssl_remove_input_handler_block_invoke_2(uint64_t a1, void *a2)
{
  id v2;

  v2 = a2;
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1;
}

uint64_t __nw_protocol_boringssl_remove_input_handler_block_invoke_3(uint64_t a1, void *a2)
{
  id v2;

  v2 = a2;
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1;
}

uint64_t __nw_protocol_boringssl_remove_input_handler_block_invoke_4(uint64_t a1, void *a2)
{
  id v2;

  v2 = a2;
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1;
}

uint64_t __nw_protocol_boringssl_remove_input_handler_block_invoke_5(uint64_t a1, void *a2)
{
  id v2;

  v2 = a2;
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1;
}

void __nw_protocol_boringssl_get_input_frames_block_invoke(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = (uint64_t *)(a1 + 32);
  if ((boringssl_session_get_state(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 336)) & 0xFFFFFFFE) == 2)
  {
    v2 = *v1;
    if ((!*v1 || (*(_BYTE *)(v2 + 475) & 1) == 0) && datapath_logging_enabled && g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        __nw_protocol_boringssl_get_input_frames_block_invoke_cold_1();
      v2 = *v1;
    }
    *(_BYTE *)(v2 + 388) &= ~0x80u;
    nw_boringssl_read(*v1 + 8);
  }
}

BOOL __nw_protocol_boringssl_get_input_frames_block_invoke_133(uint64_t a1, void *a2)
{
  id v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  _BOOL8 v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >= *(_DWORD *)(a1 + 72)
    || *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) >= *(_DWORD *)(a1 + 76))
  {
LABEL_19:
    v8 = 0;
    goto LABEL_20;
  }
  v4 = nw_frame_unclaimed_length();
  v5 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) + v4;
  v6 = *(_DWORD *)(a1 + 76);
  v7 = v4;
  v8 = v5 <= v6;
  if (v5 > v6)
  {
    v9 = *(_QWORD *)(a1 + 48);
    v10 = v3;
    if (v9)
    {
      v11 = *(_QWORD *)(v9 + 40);
      if (v11)
      {
        if ((*(_BYTE *)(v11 + 475) & 1) == 0
          && datapath_logging_enabled
          && g_boringssl_log
          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          __nw_protocol_boringssl_get_input_frames_block_invoke_133_cold_3();
        }
        v12 = nw_frame_unclaimed_bytes();
        if ((*(_BYTE *)(v11 + 475) & 1) == 0)
        {
          v13 = g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136447490;
              v17 = "nw_protocol_boringssl_create_trimmed_input_frame";
              v18 = 1024;
              v19 = 1768;
              v20 = 2082;
              v21 = v11 + 391;
              v22 = 2048;
              v23 = v11;
              v24 = 2048;
              v25 = v12;
              v26 = 1024;
              v27 = 0;
              _os_log_error_impl(&dword_1B4F6D000, v13, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] Cannot copy frame, buffer=%p length=%u", buf, 0x36u);
            }
          }
        }
      }
    }

    v14 = *(_QWORD *)(a1 + 56);
    if ((!v14 || (*(_BYTE *)(v14 + 475) & 1) == 0)
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      __nw_protocol_boringssl_get_input_frames_block_invoke_133_cold_1();
    }
    goto LABEL_19;
  }
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 56) + 390) & 0x10) != 0)
  {
    nw_frame_set_is_wake_packet();
    *(_BYTE *)(*(_QWORD *)(a1 + 56) + 390) &= ~0x10u;
  }
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v7;
  nw_frame_array_remove();
  nw_frame_array_append();
LABEL_20:

  return v8;
}

void __nw_protocol_boringssl_begin_connection_block_invoke(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  id v5;

  v5 = a2;
  nw_protocol_boringssl_internal_error(v5, a4);
  nw_protocol_boringssl_disconnect((uint64_t)v5 + 8);

}

void __nw_protocol_boringssl_begin_connection_block_invoke_2(uint64_t a1, void *a2)
{
  _QWORD *v3;

  v3 = a2;
  if (boringssl_session_in_early_data(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 336)))
    (*(void (**)(void))(*(_QWORD *)(v3[7] + 24) + 40))();

}

BOOL __nw_protocol_boringssl_begin_connection_block_invoke_142(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (a2)
  {
    v4 = *(_QWORD *)(a2 + 328);
    if (v4)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 280) = (*(uint64_t (**)(uint64_t, _QWORD))(v4 + 16))(v4, 0);
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 288) = (*(uint64_t (**)(void))(*(_QWORD *)(a2 + 328) + 16))();
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 296) = (*(uint64_t (**)(void))(*(_QWORD *)(a2 + 328) + 16))();
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 304) = (*(uint64_t (**)(void))(*(_QWORD *)(a2 + 328) + 16))();
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    }
  }
  return a2 != 0;
}

uint64_t __nw_protocol_boringssl_cleanup_block_invoke(uint64_t a1, void *a2)
{
  id v2;
  void *buffer;

  v2 = a2;
  buffer = (void *)nw_frame_get_buffer();
  if (nw_frame_buffer_get_manager())
    nw_mem_buffer_free();
  else
    free(buffer);
  nw_frame_reset();
  nw_frame_array_remove();

  return 1;
}

uint64_t __nw_protocol_boringssl_cleanup_block_invoke_2(uint64_t a1, void *a2)
{
  id v2;
  void *buffer;

  v2 = a2;
  if (nw_frame_uses_external_data())
  {
    nw_frame_set_external_data();
  }
  else
  {
    buffer = (void *)nw_frame_get_buffer();
    free(buffer);
  }
  nw_frame_reset();
  nw_frame_array_remove();

  return 1;
}

void OUTLINED_FUNCTION_21_0(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

const EVP_MD *EVP_md5(void)
{
  CRYPTO_once(&EVP_md5_once, (void (*)(void))EVP_md5_init);
  return (const EVP_MD *)&EVP_md5_storage;
}

double EVP_md5_init()
{
  double result;

  EVP_md5_storage = 0x1000000004;
  dword_1EF0F4558 = 0;
  qword_1EF0F4560 = (uint64_t)md5_init;
  unk_1EF0F4568 = digest_update_wrapper;
  qword_1EF0F4570 = (uint64_t)digest_final_wrapper;
  *(_QWORD *)&result = 0x40800000040;
  qword_1EF0F4578 = 0x40800000040;
  return result;
}

const EVP_MD *EVP_sha1(void)
{
  CRYPTO_once(&EVP_sha1_once, (void (*)(void))EVP_sha1_init);
  return (const EVP_MD *)&EVP_sha1_storage;
}

double EVP_sha1_init()
{
  double result;

  EVP_sha1_storage = 0x1400000040;
  dword_1EF0F4518 = 0;
  qword_1EF0F4520 = (uint64_t)sha1_init;
  unk_1EF0F4528 = digest_update_wrapper;
  qword_1EF0F4530 = (uint64_t)digest_final_wrapper;
  *(_QWORD *)&result = 0x40800000040;
  qword_1EF0F4538 = 0x40800000040;
  return result;
}

const EVP_MD *EVP_sha224(void)
{
  CRYPTO_once(&EVP_sha224_once, (void (*)(void))EVP_sha224_init);
  return (const EVP_MD *)&EVP_sha224_storage;
}

double EVP_sha224_init()
{
  double result;

  EVP_sha224_storage = 0x1C000002A3;
  dword_1EF0F4588 = 0;
  qword_1EF0F4590 = (uint64_t)sha224_init;
  unk_1EF0F4598 = digest_update_wrapper;
  qword_1EF0F45A0 = (uint64_t)digest_final_wrapper;
  *(_QWORD *)&result = 0x40800000040;
  qword_1EF0F45A8 = 0x40800000040;
  return result;
}

const EVP_MD *EVP_sha512(void)
{
  CRYPTO_once(&EVP_sha512_once, (void (*)(void))EVP_sha512_init);
  return (const EVP_MD *)&EVP_sha512_storage;
}

double EVP_sha512_init()
{
  double result;

  EVP_sha512_storage = 0x40000002A2;
  dword_1ECD854D8 = 0;
  qword_1ECD854E0 = (uint64_t)sha512_init;
  unk_1ECD854E8 = digest_update_wrapper;
  qword_1ECD854F0 = (uint64_t)digest_final_wrapper;
  *(_QWORD *)&result = 0x40800000080;
  qword_1ECD854F8 = 0x40800000080;
  return result;
}

uint64_t md5_init(uint64_t a1)
{
  return digest_init(*(_QWORD *)(a1 + 8));
}

uint64_t sha1_init(uint64_t a1)
{
  return digest_init(*(_QWORD *)(a1 + 8));
}

uint64_t sha224_init(uint64_t a1)
{
  return digest_init(*(_QWORD *)(a1 + 8));
}

uint64_t sha512_init(uint64_t a1)
{
  return digest_init(*(_QWORD *)(a1 + 8));
}

uint64_t md5_sha1_init(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  digest_init(v1);
  return digest_init(v1 + 1032);
}

uint64_t md5_sha1_update(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  digest_update(v1);
  return digest_update(v1 + 1032);
}

uint64_t md5_sha1_final(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  digest_final(v1);
  return digest_final(v1 + 1032);
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{

}

uint64_t lh_CRYPTO_BUFFER_call_hash_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t lh_CRYPTO_BUFFER_call_cmp_func(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](SSL_SESSION **a1, SSL_SESSION *a2)
{
  SSL_SESSION *v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    SSL_SESSION_free(v3);
}

void std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    ERR_SAVE_STATE_free(v3);
}

void std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](BUF_MEM **a1, BUF_MEM *a2)
{
  BUF_MEM *v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    BUF_MEM_free(v3);
}

void std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](bssl::SSLAEADContext **a1, bssl::SSLAEADContext *a2)
{
  bssl::SSLAEADContext *v3;
  _QWORD *v4;

  v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    bssl::SSLAEADContext::~SSLAEADContext(v3);
    OPENSSL_free(v4);
  }
}

void std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100](bssl::SSL_HANDSHAKE **a1, bssl::SSL_HANDSHAKE *a2)
{
  bssl::SSL_HANDSHAKE *v3;
  _QWORD *v4;

  v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    bssl::SSL_HANDSHAKE::~SSL_HANDSHAKE(v3);
    OPENSSL_free(v4);
  }
}

void std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100](_QWORD **a1, _QWORD *a2)
{
  _QWORD *v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    OPENSSL_free(v3);
}

void std::unique_ptr<bssl::SSL3_STATE,bssl::internal::Deleter>::reset[abi:ne180100](bssl::SSL3_STATE **a1, bssl::SSL3_STATE *a2)
{
  bssl::SSL3_STATE *v3;
  _QWORD *v4;

  v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    bssl::SSL3_STATE::~SSL3_STATE(v3);
    OPENSSL_free(v4);
  }
}

void bssl::hm_fragment::~hm_fragment(bssl::hm_fragment *this)
{
  OPENSSL_free(*((_QWORD **)this + 1));
  OPENSSL_free(*((_QWORD **)this + 2));
}

uint64_t bssl::dtls1_open_handshake(uint64_t a1, unsigned __int8 **a2, char *a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  uint64_t result;
  const ssl_st *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  uint64_t v16;
  unsigned __int8 *v17;
  int v18;
  __int128 v19;
  bssl::hm_fragment *v20;
  int v21;
  _QWORD *v22;
  bssl::hm_fragment *v23;
  unint64_t v24;
  _QWORD *v25;
  bssl::hm_fragment **v26;
  uint64_t v27;
  const void *v28;
  size_t v29;
  char v30;
  int v31;
  int v32;
  int v33;
  _QWORD v34[2];
  _QWORD v35[3];
  uint64_t v36[2];
  _BYTE *v37;
  uint64_t v38;
  char v39;
  bssl::hm_fragment *v40;
  bssl::hm_fragment *v41;
  _OWORD v42[3];

  v39 = -86;
  v37 = 0;
  v38 = 0;
  result = bssl::dtls_open_record((bssl *)a1, &v39, (uint64_t)&v37, a2, a3, a4, a5);
  if ((_DWORD)result)
    return result;
  if (v39 == 20)
  {
    if (!**(_QWORD **)(*(_QWORD *)(a1 + 48) + 264))
    {
      if (v38 != 1 || *v37 != 1)
      {
        v31 = 103;
        v32 = 325;
        goto LABEL_64;
      }
      **(_BYTE **)(a1 + 56) |= 1u;
      bssl::ssl_do_msg_callback(a1, 0, 20, (uint64_t)v37, v38);
      return 0;
    }
    v33 = 319;
LABEL_58:
    ERR_put_error(16, 0, 225, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", v33);
    v30 = 10;
    goto LABEL_65;
  }
  if (v39 != 22)
  {
    if (v39 == 23)
    {
      if (**(_QWORD **)(*(_QWORD *)(a1 + 48) + 264))
        return 1;
      v33 = 306;
    }
    else
    {
      v33 = 341;
    }
    goto LABEL_58;
  }
  v36[0] = 0xAAAAAAAAAAAAAAAALL;
  v36[1] = 0xAAAAAAAAAAAAAAAALL;
  CBS_init(v36, (uint64_t)v37, v38);
  result = CBS_len((uint64_t)v36);
  if (!result)
    return result;
  while (1)
  {
    memset(v35, 170, 20);
    v34[0] = 0xAAAAAAAAAAAAAAAALL;
    v34[1] = 0xAAAAAAAAAAAAAAAALL;
    if ((bssl::dtls1_parse_fragment(v36, (uint64_t)v35, v34) & 1) == 0)
    {
      ERR_put_error(16, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 353);
      v30 = 50;
      goto LABEL_65;
    }
    v9 = HIDWORD(v35[1]);
    v10 = HIDWORD(v35[0]);
    if (HIDWORD(v35[1]) > HIDWORD(v35[0])
      || (v11 = LODWORD(v35[2]) + (unint64_t)HIDWORD(v35[1]), v11 > HIDWORD(v35[0]))
      || bssl::ssl_max_handshake_message_len((bssl *)a1, v8) < v10)
    {
      v31 = 150;
      v32 = 364;
      goto LABEL_64;
    }
    v12 = *(_QWORD *)(a1 + 56);
    v13 = *(unsigned __int16 *)(v12 + 26);
    if (*(_WORD *)(v12 + 2) == 1)
    {
      v14 = LOWORD(v35[1]) == v13;
      v13 = LOWORD(v35[1]);
      if (!v14)
      {
        v33 = 371;
        goto LABEL_58;
      }
    }
    if (LOWORD(v35[1]) >= v13 && v13 + 7 >= LOWORD(v35[1]))
      break;
LABEL_52:
    result = CBS_len((uint64_t)v36);
    if (!result)
      return result;
  }
  if ((int)(LOWORD(v35[1]) - v13) > 6)
    goto LABEL_68;
  v16 = (LOWORD(v35[1]) - 7 * ((613566757 * (unint64_t)LOWORD(v35[1])) >> 32));
  v17 = *(unsigned __int8 **)(v12 + 8 * v16 + 48);
  if (!v17)
  {
    *(_QWORD *)&v19 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v42[1] = v19;
    v42[2] = v19;
    v42[0] = v19;
    CBB_zero(v42);
    v20 = (bssl::hm_fragment *)OPENSSL_malloc(0x18uLL);
    if (v20)
    {
      *((_QWORD *)v20 + 1) = 0;
      *((_QWORD *)v20 + 2) = 0;
      v41 = v20;
      *(_BYTE *)v20 = v35[0];
      *((_WORD *)v20 + 1) = v35[1];
      v21 = HIDWORD(v35[0]);
      *((_DWORD *)v20 + 1) = HIDWORD(v35[0]);
      v22 = OPENSSL_malloc((v21 + 12));
      *((_QWORD *)v41 + 1) = v22;
      if (!v22
        || !CBB_init_fixed((uint64_t)v42, (uint64_t)v22, 12)
        || !CBB_add_u8((uint64_t)v42, LOBYTE(v35[0]))
        || !CBB_add_u24((uint64_t)v42, HIDWORD(v35[0]))
        || !CBB_add_u16((uint64_t)v42, LOWORD(v35[1]))
        || !CBB_add_u24((uint64_t)v42, 0)
        || !CBB_add_u24((uint64_t)v42, HIDWORD(v35[0]))
        || !CBB_finish((uint64_t)v42, 0, 0))
      {
        goto LABEL_43;
      }
      if (HIDWORD(v35[0]))
      {
        if (HIDWORD(v35[0]) >= 0xFFFFFFF9)
        {
          ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 183);
LABEL_43:
          v23 = 0;
          goto LABEL_44;
        }
        v24 = ((unint64_t)HIDWORD(v35[0]) + 7) >> 3;
        v25 = OPENSSL_malloc(v24);
        *((_QWORD *)v41 + 2) = v25;
        if (!v25)
          goto LABEL_43;
        bzero(v25, v24);
      }
      v23 = v41;
    }
    else
    {
      v23 = 0;
    }
    v41 = 0;
LABEL_44:
    v40 = v23;
    std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100](&v41, 0);
    CBB_cleanup((uint64_t)v42);
    v26 = (bssl::hm_fragment **)(*(_QWORD *)(a1 + 56) + 8 * v16 + 48);
    v40 = 0;
    std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100](v26, v23);
    std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100](&v40, 0);
    v17 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 8 * v16 + 48);
    if (!v17)
    {
LABEL_68:
      v30 = 80;
      goto LABEL_65;
    }
    v18 = *((_DWORD *)v17 + 1);
    goto LABEL_46;
  }
  if (*((unsigned __int16 *)v17 + 1) != LOWORD(v35[1]))
    bssl::dtls1_open_handshake();
  if (*v17 == LOBYTE(v35[0]))
  {
    v18 = *((_DWORD *)v17 + 1);
    if (v18 == HIDWORD(v35[0]))
    {
LABEL_46:
      if (v18 != (_DWORD)v10)
        bssl::dtls1_open_handshake();
      if (*((_QWORD *)v17 + 2))
      {
        if (!(_DWORD)v10)
          bssl::dtls1_open_handshake();
        v27 = *((_QWORD *)v17 + 1);
        v28 = (const void *)CBS_data((uint64_t)v34);
        v29 = CBS_len((uint64_t)v34);
        if (v29)
          memcpy((void *)(v27 + v9 + 12), v28, v29);
        bssl::dtls1_hm_fragment_mark((bssl *)v17, v9, v11);
      }
      goto LABEL_52;
    }
  }
  v31 = 152;
  v32 = 277;
LABEL_64:
  ERR_put_error(16, 0, v31, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", v32);
  v30 = 47;
LABEL_65:
  *a3 = v30;
  return 4;
}

void sub_1B4FB9304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  bssl::hm_fragment *v13;
  va_list va;
  va_list va1;

  va_start(va1, a12);
  va_start(va, a12);
  v13 = va_arg(va1, bssl::hm_fragment *);
  std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::hm_fragment **)va, 0);
  CBB_cleanup((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t bssl::dtls1_parse_fragment(uint64_t *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  int *v7;

  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  result = CBS_get_u8(a1, (_BYTE *)a2);
  if ((_DWORD)result)
  {
    result = CBS_get_u24(a1, (int *)(a2 + 4));
    if ((_DWORD)result)
    {
      result = CBS_get_u16((unsigned __int16 **)a1, (_WORD *)(a2 + 8));
      if ((_DWORD)result)
      {
        result = CBS_get_u24(a1, (int *)(a2 + 12));
        if ((_DWORD)result)
        {
          v7 = (int *)(a2 + 16);
          result = CBS_get_u24(a1, v7);
          if ((_DWORD)result)
            return CBS_get_bytes(a1, a3, *v7) != 0;
        }
      }
    }
  }
  return result;
}

void bssl::dtls1_hm_fragment_mark(bssl *this, unint64_t a2, unint64_t a3)
{
  unint64_t v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;
  int v8;
  int v9;
  _BYTE *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 *v16;
  int v17;
  unint64_t v18;

  if (a2 > a3
    || ((v4 = *((unsigned int *)this + 1), (v5 = *((_QWORD *)this + 2)) != 0) ? (v6 = v4 >= a3) : (v6 = 0), !v6))
  {
    bssl::dtls1_hm_fragment_mark();
  }
  if (!(_DWORD)v4)
    bssl::dtls1_hm_fragment_mark();
  if (a2 == a3)
    return;
  v7 = a2 >> 3;
  v8 = -1 << (a2 & 7);
  if (a2 >> 3 == a3 >> 3)
  {
    v9 = v8 & ~(-1 << (a3 & 7));
    v10 = (_BYTE *)(v5 + v7);
LABEL_15:
    *v10 |= v9;
    goto LABEL_16;
  }
  v11 = a3 >> 3;
  *(_BYTE *)(v5 + v7) |= v8;
  v12 = v7 + 1;
  if (v7 + 1 < a3 >> 3)
  {
    do
      *(_BYTE *)(*((_QWORD *)this + 2) + v12++) = -1;
    while (v11 != v12);
  }
  if ((a3 & 7) != 0)
  {
    v9 = ~(-1 << (a3 & 7));
    v10 = (_BYTE *)(*((_QWORD *)this + 2) + v11);
    goto LABEL_15;
  }
LABEL_16:
  v13 = v4 >> 3;
  v14 = (_QWORD *)*((_QWORD *)this + 2);
  if (v4 < 8)
  {
LABEL_23:
    v18 = v4 & 7;
    if (!v18 || *((unsigned __int8 *)v14 + v13) == ~(-1 << v18))
    {
      OPENSSL_free(v14);
      *((_QWORD *)this + 2) = 0;
    }
  }
  else
  {
    if (v13 <= 1)
      v15 = 1;
    else
      v15 = v4 >> 3;
    v16 = (unsigned __int8 *)*((_QWORD *)this + 2);
    while (1)
    {
      v17 = *v16++;
      if (v17 != 255)
        break;
      if (!--v15)
        goto LABEL_23;
    }
  }
}

uint64_t bssl::dtls1_get_message(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 56);
  v3 = *(_QWORD *)(v2
                 + 8
                 * (unsigned __int16)(*(_WORD *)(v2 + 26)
                                    - 7
                                    * ((((unsigned __int16)(*(_WORD *)(v2 + 26)
                                                          - ((9363 * *(unsigned __int16 *)(v2 + 26)) >> 16)) >> 1)
                                      + ((9363 * *(unsigned __int16 *)(v2 + 26)) >> 16)) >> 2))
                 + 48);
  if (!v3 || *(_QWORD *)(v3 + 16))
    return 0;
  *(_BYTE *)(a2 + 1) = *(_BYTE *)v3;
  CBS_init((_QWORD *)(a2 + 8), *(_QWORD *)(v3 + 8) + 12, *(unsigned int *)(v3 + 4));
  CBS_init((_QWORD *)(a2 + 24), *(_QWORD *)(v3 + 8), (*(_DWORD *)(v3 + 4) + 12));
  *(_BYTE *)a2 = 0;
  if ((*(_WORD *)(*(_QWORD *)(a1 + 48) + 220) & 0x10) == 0)
  {
    bssl::ssl_do_msg_callback(a1, 0, 22, *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32));
    *(_WORD *)(*(_QWORD *)(a1 + 48) + 220) |= 0x10u;
  }
  return 1;
}

void bssl::dtls1_next_message(bssl *this, ssl_st *a2)
{
  uint64_t v3;
  uint64_t v4;
  bssl::hm_fragment **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;

  if ((*(_WORD *)(*((_QWORD *)this + 6) + 220) & 0x10) == 0)
    bssl::dtls1_next_message();
  v3 = *((_QWORD *)this + 7);
  v4 = v3
     + 8
     * (unsigned __int16)(*(_WORD *)(v3 + 26)
                        - 7
                        * ((((unsigned __int16)(*(_WORD *)(v3 + 26)
                                              - ((9363 * *(unsigned __int16 *)(v3 + 26)) >> 16)) >> 1)
                          + ((9363 * *(unsigned __int16 *)(v3 + 26)) >> 16)) >> 2));
  v7 = *(_QWORD *)(v4 + 48);
  v5 = (bssl::hm_fragment **)(v4 + 48);
  v6 = v7;
  if (!v7 || *(_QWORD *)(v6 + 16))
    bssl::dtls1_next_message();
  std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100](v5, 0);
  v8 = *((_QWORD *)this + 6);
  ++*(_WORD *)(*((_QWORD *)this + 7) + 26);
  *(_WORD *)(v8 + 220) &= ~0x10u;
  v9 = (_BYTE *)*((_QWORD *)this + 7);
  if ((*v9 & 2) != 0)
    *v9 |= 4u;
}

void std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100](bssl::hm_fragment **a1, bssl::hm_fragment *a2)
{
  bssl::hm_fragment *v3;
  _QWORD *v4;

  v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    bssl::hm_fragment::~hm_fragment(v3);
    OPENSSL_free(v4);
  }
}

BOOL bssl::dtls_has_unprocessed_handshake_data(bssl *this, const ssl_st *a2)
{
  unint64_t v2;
  uint64_t v3;
  unsigned __int16 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;

  v2 = 0;
  v3 = *((_QWORD *)this + 7);
  v4 = *(_WORD *)(v3 + 26)
     - 7
     * ((((unsigned __int16)(*(_WORD *)(v3 + 26) - ((9363 * *(unsigned __int16 *)(v3 + 26)) >> 16)) >> 1)
       + ((9363 * *(unsigned __int16 *)(v3 + 26)) >> 16)) >> 2);
  v5 = v4;
  v6 = v3 + 48;
  v7 = v6 + 8 * v4;
  v8 = 1;
  do
  {
    if ((*(_WORD *)(*((_QWORD *)this + 6) + 220) & 0x10) != 0 && v5 == v2)
    {
      if (!*(_QWORD *)v7 || *(_QWORD *)(*(_QWORD *)v7 + 16))
        bssl::dtls_has_unprocessed_handshake_data();
    }
    else if (*(_QWORD *)(v6 + 8 * v2))
    {
      return v8;
    }
    v8 = v2++ < 6;
  }
  while (v2 != 7);
  return v8;
}

uint64_t bssl::dtls1_open_change_cipher_spec(uint64_t a1, unsigned __int8 **a2, char *a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  char *v5;
  char v6;
  uint64_t result;

  v5 = *(char **)(a1 + 56);
  v6 = *v5;
  if ((*v5 & 1) != 0)
    goto LABEL_5;
  result = bssl::dtls1_open_handshake(a1, a2, a3, a4, a5);
  if ((_DWORD)result)
    return result;
  v5 = *(char **)(a1 + 56);
  v6 = *v5;
  if ((*v5 & 1) == 0)
    return 1;
LABEL_5:
  result = 0;
  *v5 = v6 & 0xFE;
  return result;
}

void bssl::dtls_clear_outgoing_messages(bssl *this, ssl_st *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;

  v3 = *((_QWORD *)this + 7);
  if (*(_BYTE *)(v3 + 272))
  {
    v4 = 0;
    v5 = 104;
    do
    {
      v6 = (_QWORD *)(v3 + v5);
      OPENSSL_free(*(_QWORD **)(v3 + v5));
      *v6 = 0;
      v6[1] = 0;
      ++v4;
      v3 = *((_QWORD *)this + 7);
      v5 += 24;
    }
    while (v4 < *(unsigned __int8 *)(v3 + 272));
  }
  *(_WORD *)(v3 + 272) = 0;
  *(_DWORD *)(v3 + 276) = 0;
  *(_BYTE *)v3 &= ~2u;
  **((_BYTE **)this + 7) &= ~4u;
}

uint64_t bssl::dtls1_init_message(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  uint64_t result;

  result = CBB_init((uint64_t)a2, 0x40uLL);
  if ((_DWORD)result)
  {
    result = CBB_add_u8((uint64_t)a2, a4);
    if ((_DWORD)result)
    {
      result = CBB_add_u24((uint64_t)a2, 0);
      if ((_DWORD)result)
      {
        result = CBB_add_u16((uint64_t)a2, *(unsigned __int16 *)(*(_QWORD *)(a1 + 56) + 24));
        if ((_DWORD)result)
        {
          result = CBB_add_u24((uint64_t)a2, 0);
          if ((_DWORD)result)
            return CBB_add_u24_length_prefixed(a2, a3) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t bssl::dtls1_finish_message(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;

  if (bssl::CBBFinishArray(a2, (uint64_t)a3) && a3[1] > 0xBuLL)
  {
    v5 = *a3;
    *(_WORD *)(v5 + 1) = *(_WORD *)(*a3 + 9);
    *(_BYTE *)(v5 + 3) = *(_BYTE *)(v5 + 11);
    return 1;
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 517);
    return 0;
  }
}

uint64_t bssl::dtls1_add_message(bssl *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  void *v7[2];

  OPENSSL_free(0);
  v4 = *(void **)(a2 + 8);
  v7[0] = *(void **)a2;
  v7[1] = v4;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v5 = bssl::add_outgoing(a1, 0, (uint64_t)v7);
  OPENSSL_free((_QWORD *)v7[0]);
  return v5;
}

void sub_1B4FB9978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t bssl::add_outgoing(bssl *this, ssl_st *a2, uint64_t a3)
{
  char v4;
  uint64_t v6;
  ssl_st *v7;
  unsigned int v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = (char)a2;
  v6 = *((_QWORD *)this + 7);
  if ((*(_BYTE *)v6 & 2) != 0)
  {
    bssl::dtls1_stop_timer((uint64_t)this, a2);
    bssl::dtls_clear_outgoing_messages(this, v7);
    v6 = *((_QWORD *)this + 7);
  }
  v8 = *(unsigned __int8 *)(v6 + 272);
  if (v8 > 6 || (v9 = *(_QWORD *)(a3 + 8), HIDWORD(v9)))
    bssl::add_outgoing();
  if ((v4 & 1) != 0)
    goto LABEL_10;
  v10 = *(_QWORD *)(*((_QWORD *)this + 6) + 280);
  if (!v10)
  {
LABEL_9:
    ++*(_WORD *)(v6 + 24);
LABEL_10:
    v11 = v6 + 24 * v8;
    OPENSSL_free(*(_QWORD **)(v11 + 104));
    *(_QWORD *)(v11 + 104) = 0;
    *(_QWORD *)(v11 + 112) = 0;
    v12 = *(_QWORD *)(a3 + 8);
    *(_QWORD *)(v11 + 104) = *(_QWORD *)a3;
    *(_QWORD *)(v11 + 112) = v12;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    v13 = *((_QWORD *)this + 7);
    *(_WORD *)(v11 + 120) = *(_WORD *)(v13 + 4);
    *(_BYTE *)(v11 + 122) = v4;
    ++*(_BYTE *)(v13 + 272);
    return 1;
  }
  if (bssl::SSLTranscript::Update((_QWORD **)(v10 + 424), *(const void **)a3, v9))
  {
    v6 = *((_QWORD *)this + 7);
    v8 = *(unsigned __int8 *)(v6 + 272);
    goto LABEL_9;
  }
  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 567);
  return 0;
}

uint64_t bssl::dtls1_add_change_cipher_spec(bssl *this, ssl_st *a2)
{
  uint64_t v2;
  void *v4[2];

  v4[0] = 0;
  v4[1] = 0;
  v2 = bssl::add_outgoing(this, (ssl_st *)1, (uint64_t)v4);
  OPENSSL_free((_QWORD *)v4[0]);
  return v2;
}

void sub_1B4FB9AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t bssl::dtls1_flush_flight(bssl *this, ssl_st *a2)
{
  ssl_st *v3;

  **((_BYTE **)this + 7) |= 2u;
  bssl::dtls1_start_timer(this, a2);
  return bssl::send_flight(this, v3);
}

uint64_t bssl::send_flight(bssl *this, ssl_st *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char v9;
  unsigned __int8 v10;
  char *v11;
  unint64_t v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  __int128 v27;
  size_t v28;
  __int128 v29;
  char *v30;
  const void *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  int v38;
  _BYTE v39[12];
  void *v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  _OWORD v44[3];
  _OWORD v45[3];
  _QWORD v46[3];
  uint64_t v47[5];

  if (*(_DWORD *)(*((_QWORD *)this + 6) + 176))
  {
    v2 = 194;
    v3 = 763;
LABEL_3:
    ERR_put_error(16, 0, v2, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", v3);
    return 0xFFFFFFFFLL;
  }
  if (!*((_QWORD *)this + 4))
  {
    v2 = 119;
    v3 = 768;
    goto LABEL_3;
  }
  if (*(_DWORD *)(*((_QWORD *)this + 7) + 280) <= 0xE3u && (SSL_get_options((uint64_t)this) & 0x1000) == 0)
  {
    v6 = BIO_ctrl(*((BIO **)this + 4), 40, 0, 0);
    if (v6 > 0x40000000 || v6 < 0xE4)
    {
      *(_DWORD *)(*((_QWORD *)this + 7) + 280) = 1472;
      BIO_ctrl(*((BIO **)this + 4), 42, 1472, 0);
    }
    else
    {
      *(_DWORD *)(*((_QWORD *)this + 7) + 280) = v6;
    }
  }
  v7 = *(unsigned int *)(*((_QWORD *)this + 7) + 280);
  if (v7 <= 0xE3)
    bssl::send_flight();
  v40 = 0;
  v41 = 0;
  if (!bssl::Array<unsigned char>::Init((uint64_t)&v40, v7))
  {
LABEL_64:
    v4 = 0xFFFFFFFFLL;
    goto LABEL_65;
  }
  while (2)
  {
    v8 = *((_QWORD *)this + 7);
    if (*(unsigned __int8 *)(v8 + 273) >= *(unsigned __int8 *)(v8 + 272))
    {
      if ((int)BIO_flush(*((BIO **)this + 4)) > 0)
      {
        v4 = 1;
        goto LABEL_65;
      }
      *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 3;
      goto LABEL_64;
    }
    *(_DWORD *)&v39[8] = 0;
    v9 = 0;
    v38 = *(_DWORD *)(v8 + 276);
    *(_QWORD *)v39 = *(unsigned __int8 *)(v8 + 273);
    v10 = *(_BYTE *)(v8 + 273);
    v11 = (char *)v40;
    v12 = v41;
    while (1)
    {
      v13 = v10;
      v42 = 0xAAAAAAAAAAAAAAAALL;
      v14 = *(unsigned __int16 *)(v8 + 4);
      if (*(_WORD *)(v8 + 4))
      {
        v15 = *(unsigned __int16 *)(v8 + 24 * v13 + 120);
        if (v14 - 1 == v15)
        {
          v16 = 0;
          goto LABEL_22;
        }
      }
      else
      {
        v15 = *(unsigned __int16 *)(v8 + 24 * v13 + 120);
      }
      if (v15 != v14)
      {
        ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 632);
        goto LABEL_64;
      }
      v16 = 1;
LABEL_22:
      v17 = bssl::dtls_max_seal_overhead((uint64_t)this, v16);
      v18 = bssl::dtls_seal_prefix_len((uint64_t)this, v16);
      if (!*(_BYTE *)(v8 + 24 * v13 + 122))
        break;
      if (v17 + 1 > v12)
        goto LABEL_59;
      if (!bssl::dtls_seal_record((uint64_t)this, (unint64_t)v11, &v42, v12, 20, (char *)&bssl::seal_next_message(ssl_st *,unsigned char *,unsigned long *,unsigned long,bssl::DTLS_OUTGOING_MESSAGE const*)::kChangeCipherSpec, 1uLL, v16))goto LABEL_64;
      bssl::ssl_do_msg_callback((uint64_t)this, 1, 20, (uint64_t)&bssl::seal_next_message(ssl_st *,unsigned char *,unsigned long *,unsigned long,bssl::DTLS_OUTGOING_MESSAGE const*)::kChangeCipherSpec, 1);
      v19 = v42;
      *(_QWORD *)&v39[4] += v42;
LABEL_53:
      v12 -= v19;
      v11 += v19;
      v8 = *((_QWORD *)this + 7);
      v10 = *(_BYTE *)(v8 + 273) + 1;
      *(_BYTE *)(v8 + 273) = v10;
      v9 = 1;
      if (*(unsigned __int8 *)(v8 + 272) <= v10)
        goto LABEL_60;
    }
    v20 = v18;
    memset(v47, 170, 32);
    memset(v46, 170, 20);
    CBS_init(&v47[2], *(_QWORD *)(v8 + 24 * v13 + 104), *(_QWORD *)(v8 + 24 * v13 + 112));
    v21 = bssl::dtls1_parse_fragment(&v47[2], (uint64_t)v46, v47);
    if (HIDWORD(v46[1]))
      v22 = 0;
    else
      v22 = v21;
    if (v22 != 1
      || (v23 = LODWORD(v46[2]), CBS_len((uint64_t)v47) != v23)
      || (v24 = HIDWORD(v46[0]), CBS_len((uint64_t)v47) != v24)
      || !CBS_skip(v47, *(unsigned int *)(*((_QWORD *)this + 7) + 276))
      || CBS_len((uint64_t)&v47[2]))
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 667);
      goto LABEL_64;
    }
    if (v17 + 13 > v12)
      goto LABEL_59;
    v25 = v12 - v20;
    if (v12 < v20)
      goto LABEL_59;
    v26 = CBS_len((uint64_t)v47);
    *(_QWORD *)&v27 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v45[1] = v27;
    v45[2] = v27;
    if (v26 >= v12 - v17 - 12)
      v28 = v12 - v17 - 12;
    else
      v28 = v26;
    v45[0] = v27;
    CBB_zero(v45);
    *(_QWORD *)&v29 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v44[1] = v29;
    v44[2] = v29;
    v44[0] = v29;
    v30 = &v11[v20];
    v43 = 0xAAAAAAAAAAAAAAAALL;
    if (CBB_init_fixed((uint64_t)v45, (uint64_t)v30, v25)
      && CBB_add_u8((uint64_t)v45, LOBYTE(v46[0]))
      && CBB_add_u24((uint64_t)v45, HIDWORD(v46[0]))
      && CBB_add_u16((uint64_t)v45, LOWORD(v46[1]))
      && CBB_add_u24((uint64_t)v45, *(_DWORD *)(*((_QWORD *)this + 7) + 276))
      && CBB_add_u24_length_prefixed((uint64_t *)v45, (uint64_t)v44)
      && (v31 = (const void *)CBS_data((uint64_t)v47), CBB_add_bytes((uint64_t)v44, v31, v28))
      && CBB_finish((uint64_t)v45, 0, &v43))
    {
      bssl::ssl_do_msg_callback((uint64_t)this, 1, 22, (uint64_t)v30, v43);
      if ((bssl::dtls_seal_record((uint64_t)this, (unint64_t)v11, &v42, v12, 22, v30, v43, v16) & 1) != 0)
      {
        v32 = CBS_len((uint64_t)v47);
        v33 = *((_QWORD *)this + 7);
        if (v28 == v32)
        {
          v34 = 0;
          v35 = 3;
        }
        else
        {
          v34 = *(_DWORD *)(v33 + 276) + v28;
          v35 = 2;
        }
        *(_DWORD *)(v33 + 276) = v34;
      }
      else
      {
        v35 = 0;
      }
    }
    else
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 693);
      v35 = 0;
    }
    CBB_cleanup((uint64_t)v45);
    if ((v35 - 2) < 2)
    {
      v19 = v42;
      *(_QWORD *)&v39[4] += v42;
      if (v35 == 2)
        goto LABEL_60;
      goto LABEL_53;
    }
    if (!v35)
      goto LABEL_64;
LABEL_59:
    if ((v9 & 1) == 0)
    {
      ERR_put_error(16, 0, 169, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 753);
      goto LABEL_64;
    }
LABEL_60:
    v4 = BIO_write(*((BIO **)this + 4), v40, *(int *)&v39[4]);
    if ((int)v4 > 0)
      continue;
    break;
  }
  v36 = *((_QWORD *)this + 7);
  *(_BYTE *)(v36 + 273) = v39[0];
  *(_DWORD *)(v36 + 276) = v38;
  *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 3;
LABEL_65:
  OPENSSL_free(v40);
  return v4;
}

void sub_1B4FBA0A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  CBB_cleanup((uint64_t)va1);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t bssl::dtls1_retransmit_outgoing_messages(bssl *this, ssl_st *a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 7);
  *(_BYTE *)(v2 + 273) = 0;
  *(_DWORD *)(v2 + 276) = 0;
  return bssl::send_flight(this, a2);
}

uint64_t bssl::dtls1_min_mtu(bssl *this)
{
  return 228;
}

uint64_t SSL_state_int(uint64_t a1, bssl::SSL_HANDSHAKE *a2)
{
  bssl *v3;

  v3 = *(bssl **)(*(_QWORD *)(a1 + 48) + 280);
  if (!v3)
    return 724109320;
  if ((*(_BYTE *)(a1 + 180) & 1) != 0)
    return bssl::ssl_server_handshake_int_state(v3, a2);
  return bssl::ssl_client_handshake_int_state(v3, a2);
}

uint64_t bssl::tls13_init_early_key_schedule(bssl *this, ssl_cipher_st **a2, const ssl_session_st *a3)
{
  size_t **v5;
  bssl::SSLTranscript *v6;
  const ssl_cipher_st *v7;
  uint64_t result;

  if ((*(_BYTE *)(*(_QWORD *)this + 180) & 1) != 0)
    bssl::tls13_init_early_key_schedule();
  if (*((_QWORD *)this + 195))
    v5 = (size_t **)((char *)this + 464);
  else
    v5 = (size_t **)((char *)this + 424);
  v6 = (bssl::SSLTranscript *)bssl::ssl_session_protocol_version((bssl *)a2, (const ssl_session_st *)a2);
  result = bssl::init_key_schedule(this, v5, v6, a2[26], v7);
  if ((_DWORD)result)
    return bssl::hkdf_extract_to_secret((uint64_t)this, (bssl::SSLTranscript *)v5);
  return result;
}

uint64_t bssl::tls13_derive_early_secret(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3;
  bssl::SSLTranscript *v4;
  uint64_t result;

  v3 = *(_QWORD *)this;
  if ((*(_BYTE *)(*(_QWORD *)this + 180) & 1) != 0 || !*((_QWORD *)this + 195))
    v4 = (bssl *)((char *)this + 424);
  else
    v4 = (bssl *)((char *)this + 464);
  result = bssl::derive_secret_with_transcript((uint64_t)this, (int)this + 88, *((_QWORD *)this + 4), v4, "c e traffic", 0xBuLL);
  if ((_DWORD)result)
    return bssl::ssl_log_secret(v3, "CLIENT_EARLY_TRAFFIC_SECRET", (unsigned __int8 *)this + 88, *((_QWORD *)this + 4));
  return result;
}

uint64_t bssl::tls13_rotate_traffic_key(const SSL *a1, uint64_t a2)
{
  int (__cdecl *handshake_func)(SSL *);
  uint64_t v5;
  const void *v6;
  size_t v7;
  bssl *session;
  const ssl_session_st *v9;
  EVP_MD *digest;
  uint64_t v11;
  uint64_t result;

  handshake_func = a1->handshake_func;
  v5 = 440;
  if ((_DWORD)a2)
  {
    v6 = (char *)handshake_func + 296;
  }
  else
  {
    v5 = 441;
    v6 = (char *)handshake_func + 344;
  }
  v7 = *((unsigned __int8 *)handshake_func + v5);
  session = (bssl *)SSL_get_session(a1);
  digest = (EVP_MD *)bssl::ssl_session_get_digest(session, v9);
  result = bssl::hkdf_expand_label((int)v6, v7, digest, (uint64_t)v6, v7, "traffic upd", 0xBuLL, v11, 0, 0);
  if ((_DWORD)result)
    return bssl::tls13_set_traffic_key((uint64_t)a1, (const ssl_session_st *)3, a2, session, v6, v7);
  return result;
}

uint64_t bssl::tls13_export_keying_material(const SSL *a1, int a2, int a3, uint64_t a4, uint64_t a5, const void *a6, size_t a7, uint64_t a8, const void *a9, size_t a10)
{
  bssl *session;
  const ssl_session_st *v17;
  EVP_MD *digest;
  __int128 v19;
  uint64_t result;
  size_t v21;
  size_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int size;
  _OWORD v29[4];
  unsigned __int8 v30[16];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _OWORD md[4];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!a5)
    bssl::tls13_export_keying_material();
  session = (bssl *)SSL_get_session(a1);
  digest = (EVP_MD *)bssl::ssl_session_get_digest(session, v17);
  *(_QWORD *)&v19 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
  md[2] = v19;
  md[3] = v19;
  md[0] = v19;
  md[1] = v19;
  v32 = v19;
  v33 = v19;
  *(_OWORD *)v30 = v19;
  v31 = v19;
  v27 = -1431655766;
  size = -1431655766;
  result = EVP_Digest(a9, a10, (unsigned __int8 *)md, &size, digest, 0);
  if ((_DWORD)result)
  {
    result = EVP_Digest(0, 0, v30, &v27, digest, 0);
    if ((_DWORD)result)
    {
      v22 = v27;
      v21 = size;
      *(_QWORD *)&v23 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v29[2] = v23;
      v29[3] = v23;
      v29[0] = v23;
      v29[1] = v23;
      v24 = EVP_MD_size(digest);
      result = bssl::hkdf_expand_label((int)v29, v24, digest, a4, a5, a6, a7, v25, v30, v22);
      if ((_DWORD)result)
        return bssl::hkdf_expand_label(a2, a3, digest, (uint64_t)v29, v24, "exporter", 8uLL, v26, md, v21);
    }
  }
  return result;
}

uint64_t bssl::tls13_write_psk_binder(uint64_t *a1, ssl_session_st *a2, char *a3, size_t a4, size_t *a5)
{
  uint64_t v9;
  const EVP_MD *digest;
  size_t v11;
  __int128 v12;
  unsigned int v13;
  uint64_t v14;
  unint64_t v16;
  _OWORD __src[4];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v9 = *a1;
  digest = bssl::ssl_session_get_digest(*(bssl **)(*a1 + 104), a2);
  v11 = EVP_MD_size(digest);
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __src[2] = v12;
  __src[3] = v12;
  __src[0] = v12;
  __src[1] = v12;
  v16 = 0xAAAAAAAAAAAAAAAALL;
  v13 = bssl::tls13_psk_binder((unsigned __int8 *)__src, (ssl_session_st *)&v16, *(bssl **)(v9 + 104), (size_t **)a2, a3, a4, v11 + 3, *(unsigned __int8 *)(*(_QWORD *)(v9 + 104) + 448) >> 7);
  if (v16 == v11)
    v14 = v13;
  else
    v14 = 0;
  if ((v14 & 1) != 0)
  {
    if (a4 < v11)
      abort();
    if (v11)
      memcpy(&a3[a4 - v11], __src, v11);
    if (a5)
      *a5 = v11;
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", 497);
  }
  return v14;
}

uint64_t bssl::tls13_psk_binder(unsigned __int8 *a1, ssl_session_st *a2, bssl *this, size_t **a4, const void *a5, size_t a6, size_t a7, int a8)
{
  EVP_MD *digest;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  __int128 v21;
  uint64_t v22;
  EVP_MD_CTX ctx;
  unsigned int s;
  uint64_t v26;
  unsigned int size;
  unsigned __int8 v28[16];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _OWORD v32[4];
  _OWORD v33[4];
  unsigned __int8 md[16];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  digest = (EVP_MD *)bssl::ssl_session_get_digest(this, a2);
  *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v36 = v15;
  v37 = v15;
  *(_OWORD *)md = v15;
  v35 = v15;
  size = -1431655766;
  memset(v33, 0, sizeof(v33));
  v26 = 0xAAAAAAAAAAAAAAAALL;
  memset(v32, 0, sizeof(v32));
  v16 = EVP_MD_size(digest);
  if (!EVP_Digest(0, 0, md, &size, digest, 0) || !HKDF_extract((int)v33, &v26, digest))
    return 0;
  v18 = a8 ? "ext binder" : "res binder";
  if (!bssl::hkdf_expand_label((int)v32, v16, digest, (uint64_t)v33, v26, v18, 0xAuLL, v17, md, size))
    return 0;
  if (a6 < a7)
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", 453);
    return 0;
  }
  if (a6 >= a6 - a7)
    a6 -= a7;
  *(_QWORD *)&v21 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v30 = v21;
  v31 = v21;
  *(_OWORD *)v28 = v21;
  v29 = v21;
  s = -1431655766;
  *(_OWORD *)&ctx.digest = v21;
  *(_OWORD *)&ctx.flags = v21;
  EVP_MD_CTX_init(&ctx);
  if (bssl::SSLTranscript::CopyToHashContext(a4, &ctx, digest)
    && EVP_DigestUpdate(&ctx, a5, a6)
    && EVP_DigestFinal_ex(&ctx, v28, &s)
    && bssl::tls13_verify_data(a1, a2, digest, (uint64_t)v32, v16, v28, s))
  {
    v22 = *(_QWORD *)&a2->ssl_version;
    if (v22 != EVP_MD_size(digest))
      __assert_rtn("tls13_psk_binder", "tls13_enc.cc", 472, "*out_len == EVP_MD_size(digest)");
    v19 = 1;
  }
  else
  {
    v19 = 0;
  }
  EVP_MD_CTX_cleanup(&ctx);
  return v19;
}

void sub_1B4FBA7E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, EVP_MD_CTX *ctx)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t bssl::tls13_verify_psk_binder(uint64_t a1, bssl *a2, uint64_t a3, unsigned __int8 **a4)
{
  __int128 v6;
  size_t **v7;
  const void *v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int v14;
  int v15;
  unint64_t v17[2];
  uint64_t v18;
  _OWORD v19[4];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[2] = v6;
  v19[3] = v6;
  v19[0] = v6;
  v19[1] = v6;
  v7 = (size_t **)(a1 + 424);
  v17[1] = 0xAAAAAAAAAAAAAAAALL;
  v18 = 0;
  v17[0] = 0xAAAAAAAAAAAAAAAALL;
  v8 = *(const void **)(a3 + 24);
  v9 = *(_QWORD *)(a3 + 32);
  v10 = CBS_len((uint64_t)a4);
  if (bssl::tls13_psk_binder((unsigned __int8 *)v19, (ssl_session_st *)&v18, a2, v7, v8, v9, v10 + 2, 0)
    && CBS_get_u8_length_prefixed(a4, v17))
  {
    v11 = CBS_len((uint64_t)v17);
    if (v11 == v18)
    {
      v12 = v11;
      v13 = (char *)CBS_data((uint64_t)v17);
      if (!CRYPTO_memcmp(v13, (char *)v19, v12))
        return 1;
    }
    v14 = 142;
    v15 = 533;
  }
  else
  {
    v14 = 68;
    v15 = 522;
  }
  ERR_put_error(16, 0, v14, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", v15);
  return 0;
}

BOOL bssl::ssl_ech_accept_confirmation(int a1, int a2, uint64_t a3, int a4, int a5, bssl::SSLTranscript *a6, int a7, int a8, char *d, unint64_t a10, unint64_t a11)
{
  _BOOL8 v11;
  __int128 v16;
  size_t v17;
  const EVP_MD *v18;
  __int128 v19;
  EVP_MD *v20;
  EVP_MD *v21;
  uint64_t v22;
  const char *v23;
  size_t v24;
  uint64_t v26;
  EVP_MD_CTX ctx;
  unsigned int s;
  _OWORD v29[4];
  unsigned __int8 md[16];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a10 >= a11 + 8)
  {
    *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v32 = v16;
    v33 = v16;
    if (a10 >= a11)
      v17 = a11;
    else
      v17 = a10;
    v31 = v16;
    *(_OWORD *)md = v16;
    s = -1431655766;
    *(_OWORD *)&ctx.digest = v16;
    *(_OWORD *)&ctx.flags = v16;
    EVP_MD_CTX_init(&ctx);
    v18 = bssl::SSLTranscript::Digest(a6);
    if (!bssl::SSLTranscript::CopyToHashContext((size_t **)a6, &ctx, v18))
      goto LABEL_20;
    if (!EVP_DigestUpdate(&ctx, d, v17))
      goto LABEL_20;
    if (!EVP_DigestUpdate(&ctx, &bssl::ssl_ech_accept_confirmation(bssl::SSL_HANDSHAKE const*,bssl::Span<unsigned char>,bssl::Span<unsigned char const>,bssl::SSLTranscript const&,BOOL,bssl::Span<unsigned char const>,unsigned long)::kZeros, 8uLL))goto LABEL_20;
    if (!EVP_DigestUpdate(&ctx, &d[a11 + 8], a10 - (a11 + 8)))
      goto LABEL_20;
    if (!EVP_DigestFinal_ex(&ctx, md, &s))
      goto LABEL_20;
    *(_QWORD *)&v19 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v29[2] = v19;
    v29[3] = v19;
    v29[0] = v19;
    v29[1] = v19;
    v26 = 0xAAAAAAAAAAAAAAAALL;
    v20 = (EVP_MD *)bssl::SSLTranscript::Digest(a6);
    bssl::SSLTranscript::DigestLen(a6);
    if (HKDF_extract((int)v29, &v26, v20))
    {
      if (a3 != 8)
        __assert_rtn("ssl_ech_accept_confirmation", "tls13_enc.cc", 583, "out.size() == ECH_CONFIRMATION_SIGNAL_LEN");
      v21 = (EVP_MD *)bssl::SSLTranscript::Digest(a6);
      if (a7)
        v23 = "hrr ech accept confirmation";
      else
        v23 = "ech accept confirmation";
      if (a7)
        v24 = 27;
      else
        v24 = 23;
      v11 = bssl::hkdf_expand_label(a2, 8, v21, (uint64_t)v29, v26, v23, v24, v22, md, s);
    }
    else
    {
LABEL_20:
      v11 = 0;
    }
    EVP_MD_CTX_cleanup(&ctx);
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", 558);
    return 0;
  }
  return v11;
}

void sub_1B4FBAB94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, EVP_MD_CTX *ctx)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a)
{
  *(_QWORD *)&a->final[8] = 0;
  *(_OWORD *)&a->flags = 0u;
  *(_OWORD *)&a->final_used = 0u;
  *(_OWORD *)&a->buf[24] = 0u;
  *(_OWORD *)&a->app_data = 0u;
  *(_OWORD *)&a->iv[8] = 0u;
  *(_OWORD *)&a->buf[8] = 0u;
  *(_OWORD *)&a->encrypt = 0u;
  *(_OWORD *)&a->oiv[8] = 0u;
  *(_OWORD *)&a->cipher = 0u;
}

int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a)
{
  void (*v2)(EVP_CIPHER_CTX *);

  if (a->cipher)
  {
    v2 = *(void (**)(EVP_CIPHER_CTX *))&a->cipher->ctx_size;
    if (v2)
      v2(a);
  }
  OPENSSL_free(*(_QWORD **)&a->encrypt);
  *(_QWORD *)&a->final[8] = 0;
  *(_OWORD *)&a->flags = 0u;
  *(_OWORD *)&a->final_used = 0u;
  *(_OWORD *)&a->buf[24] = 0u;
  *(_OWORD *)&a->app_data = 0u;
  *(_OWORD *)&a->iv[8] = 0u;
  *(_OWORD *)&a->buf[8] = 0u;
  *(_OWORD *)&a->encrypt = 0u;
  *(_OWORD *)&a->oiv[8] = 0u;
  *(_OWORD *)&a->cipher = 0u;
  return 1;
}

int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv, int enc)
{
  uint64_t v10;
  const EVP_CIPHER *v11;
  unint64_t flags_low;
  _QWORD *v13;
  int v14;
  int v15;
  unsigned int block_size;
  BOOL v17;
  int v18;
  int flags_high;
  size_t iv_len;
  unsigned __int8 *v22;
  const unsigned __int8 *v23;

  if (enc == -1)
  {
    v10 = *(unsigned int *)&ctx->oiv[4];
  }
  else
  {
    v10 = enc != 0;
    *(_DWORD *)&ctx->oiv[4] = v10;
  }
  v11 = ctx->cipher;
  if (cipher)
  {
    if (v11)
    {
      EVP_CIPHER_CTX_cleanup(ctx);
      *(_DWORD *)&ctx->oiv[4] = v10;
    }
    ctx->cipher = cipher;
    flags_low = LODWORD(cipher->flags);
    if ((_DWORD)flags_low)
    {
      v13 = OPENSSL_malloc(flags_low);
      *(_QWORD *)&ctx->encrypt = v13;
      if (!v13)
      {
        ctx->cipher = 0;
        return (int)v13;
      }
      v11 = ctx->cipher;
    }
    else
    {
      *(_QWORD *)&ctx->encrypt = 0;
      v11 = cipher;
    }
    *(_DWORD *)ctx->oiv = cipher->key_len;
    *(_DWORD *)&ctx->oiv[8] = 0;
    if ((v11->flags & 0x20000000000) == 0)
      goto LABEL_16;
    if (EVP_CIPHER_CTX_ctrl(ctx, 0, 0, 0))
    {
      v11 = ctx->cipher;
      goto LABEL_16;
    }
    ctx->cipher = 0;
    v14 = 107;
    v15 = 179;
LABEL_27:
    ERR_put_error(30, 0, v14, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v15);
LABEL_28:
    LODWORD(v13) = 0;
    return (int)v13;
  }
  if (!v11)
  {
    v14 = 114;
    v15 = 184;
    goto LABEL_27;
  }
LABEL_16:
  block_size = v11->block_size;
  v17 = block_size > 0x10;
  v18 = (1 << block_size) & 0x10102;
  if (v17 || v18 == 0)
    EVP_CipherInit_ex_cold_1();
  flags_high = HIDWORD(v11->flags);
  if ((flags_high & 0x100) == 0)
  {
    switch(flags_high & 0x3F)
    {
      case 0:
      case 1:
        break;
      case 2:
        goto LABEL_30;
      case 3:
        ctx->key_len = 0;
LABEL_30:
        iv_len = v11->iv_len;
        if (iv_len >= 0x11)
          EVP_CipherInit_ex_cold_2();
        if (iv && (_DWORD)iv_len)
        {
          memcpy(&ctx->oiv[12], iv, iv_len);
          LODWORD(iv_len) = v11->iv_len;
        }
        if (!(_DWORD)iv_len)
          break;
        iv_len = iv_len;
        v23 = &ctx->oiv[12];
        v22 = &ctx->iv[12];
LABEL_36:
        memcpy(v22, v23, iv_len);
        break;
      case 4:
      case 5:
        ctx->key_len = 0;
        if (!iv)
          break;
        iv_len = v11->iv_len;
        if (!(_DWORD)iv_len)
          break;
        v22 = &ctx->iv[12];
        v23 = iv;
        goto LABEL_36;
      default:
        goto LABEL_28;
    }
  }
  if (!key && (v11->flags & 0x8000000000) == 0
    || (LODWORD(v13) = ((uint64_t (*)(EVP_CIPHER_CTX *, const unsigned __int8 *, const unsigned __int8 *, uint64_t))v11->do_cipher)(ctx, key, iv, v10), (_DWORD)v13))
  {
    HIDWORD(ctx->app_data) = 0;
    *(&ctx->key_len + 1) = 0;
    LODWORD(v13) = 1;
    *(_DWORD *)&ctx->final[8] = 0;
  }
  return (int)v13;
}

int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
{
  uint64_t (*set_asn1_parameters)(void);
  int result;
  int v6;
  int v7;

  if (ctx->cipher)
  {
    set_asn1_parameters = (uint64_t (*)(void))ctx->cipher->set_asn1_parameters;
    if (set_asn1_parameters)
    {
      result = set_asn1_parameters();
      if (result != -1)
        return result;
      v6 = 105;
      v7 = 622;
    }
    else
    {
      v6 = 104;
      v7 = 616;
    }
  }
  else
  {
    v6 = 114;
    v7 = 611;
  }
  ERR_put_error(30, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v7);
  return 0;
}

uint64_t EVP_CIPHER_CTX_mode(uint64_t a1)
{
  return *(_DWORD *)(*(_QWORD *)a1 + 20) & 0x3F;
}

int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher->iv_len;
}

int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 1);
}

int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 0);
}

int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  int v5;
  int v6;
  unsigned int v7;
  const EVP_CIPHER *cipher;
  int block_size;
  const unsigned __int8 *v12;
  unsigned __int8 *v14;
  int app_data_high;
  size_t v16;
  int result;
  int v18;
  int v19;
  uint64_t v20;

  if (*(_DWORD *)&ctx->final[8])
  {
    v5 = 66;
    v6 = 260;
LABEL_17:
    ERR_put_error(30, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v6);
    return 0;
  }
  v7 = inl;
  *(_DWORD *)&ctx->final[8] = 1;
  cipher = ctx->cipher;
  block_size = ctx->cipher->block_size;
  if (block_size >= 2 && (block_size ^ 0x7FFFFFFF) < inl)
  {
    v5 = 69;
    v6 = 272;
    goto LABEL_17;
  }
  v12 = in;
  v14 = out;
  if ((cipher->flags & 0x40000000000) != 0)
  {
    v18 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, _QWORD))cipher->cleanup)(ctx, out, in, inl);
    if (v18 < 0)
      return 0;
    *outl = v18;
    goto LABEL_35;
  }
  if (inl <= 0)
  {
    result = 0;
    *outl = 0;
    if (!inl)
      goto LABEL_35;
    return result;
  }
  app_data_high = HIDWORD(ctx->app_data);
  if (!app_data_high)
  {
    if (block_remainder((uint64_t)ctx, inl))
    {
      app_data_high = HIDWORD(ctx->app_data);
      goto LABEL_12;
    }
    result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, _QWORD))ctx->cipher->cleanup)(ctx, v14, v12, v7);
    if (!result)
    {
      *outl = 0;
      return result;
    }
    *outl = v7;
LABEL_35:
    *(_DWORD *)&ctx->final[8] = 0;
    return 1;
  }
LABEL_12:
  if (block_size >= 33)
    EVP_EncryptUpdate_cold_1();
  if (app_data_high)
  {
    v16 = block_size - (uint64_t)app_data_high;
    if ((int)v7 < (int)v16)
    {
      memcpy(&ctx->buf[app_data_high + 12], v12, v7);
      HIDWORD(ctx->app_data) += v7;
      *outl = 0;
      goto LABEL_35;
    }
    if (block_size != app_data_high)
      memcpy(&ctx->buf[app_data_high + 12], v12, v16);
    result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, unsigned __int8 *, _QWORD))ctx->cipher->cleanup)(ctx, v14, &ctx->buf[12], block_size);
    if (!result)
      return result;
    v12 += v16;
    v14 += block_size;
    v7 -= v16;
  }
  else
  {
    block_size = 0;
  }
  *outl = block_size;
  v19 = block_remainder((uint64_t)ctx, v7);
  v20 = v7 - v19;
  if ((int)v20 < 1)
  {
LABEL_32:
    if (v19)
      memcpy(&ctx->buf[12], &v12[(int)v20], v19);
    HIDWORD(ctx->app_data) = v19;
    goto LABEL_35;
  }
  result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, uint64_t))ctx->cipher->cleanup)(ctx, v14, v12, v20);
  if (result)
  {
    *outl += v20;
    goto LABEL_32;
  }
  return result;
}

uint64_t block_remainder(uint64_t a1, unsigned int a2)
{
  int v2;

  v2 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  if (!v2)
    block_remainder_cold_1();
  if ((v2 & (v2 - 1)) != 0)
    block_remainder_cold_2();
  return (v2 - 1) & a2;
}

int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl)
{
  int v3;
  int v4;
  int result;
  const EVP_CIPHER *cipher;
  uint64_t block_size;
  int v11;
  uint64_t app_data_high;

  if (*(_DWORD *)&ctx->final[8])
  {
    v3 = 66;
    v4 = 353;
LABEL_3:
    ERR_put_error(30, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v4);
    return 0;
  }
  cipher = ctx->cipher;
  if ((ctx->cipher->flags & 0x40000000000) != 0)
  {
    v11 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, _QWORD, _QWORD))cipher->cleanup)(ctx, out, 0, 0);
    if (v11 < 0)
      return 0;
    *outl = v11;
    return 1;
  }
  block_size = cipher->block_size;
  if (block_size >= 0x21)
    EVP_EncryptFinal_ex_cold_1();
  if ((_DWORD)block_size == 1)
    goto LABEL_8;
  app_data_high = HIDWORD(ctx->app_data);
  if ((ctx->oiv[9] & 8) != 0)
  {
    if ((_DWORD)app_data_high)
    {
      v3 = 106;
      v4 = 379;
      goto LABEL_3;
    }
LABEL_8:
    *outl = 0;
    return 1;
  }
  if (block_size > app_data_high)
    memset(&ctx->buf[app_data_high + 12], block_size - app_data_high, (block_size + ~(_DWORD)app_data_high) + 1);
  result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, unsigned __int8 *, uint64_t))cipher->cleanup)(ctx, out, &ctx->buf[12], block_size);
  if (result)
  {
    *outl = block_size;
    return 1;
  }
  return result;
}

int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  int v5;
  int v6;
  const EVP_CIPHER *cipher;
  size_t block_size;
  unsigned __int8 *v14;
  int v15;
  int result;
  int v17;
  int v18;

  if (*(_DWORD *)&ctx->final[8])
  {
    v5 = 66;
    v6 = 403;
LABEL_22:
    ERR_put_error(30, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v6);
    return 0;
  }
  cipher = ctx->cipher;
  block_size = ctx->cipher->block_size;
  if (block_size >= 2 && (int)(block_size ^ 0x7FFFFFFF) < inl)
  {
    v5 = 69;
    v6 = 411;
    goto LABEL_22;
  }
  v14 = out;
  if ((cipher->flags & 0x40000000000) != 0)
  {
    v17 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, _QWORD))cipher->cleanup)(ctx, out, in, inl);
    v18 = v17 & ~(v17 >> 31);
    result = v17 >= 0;
    *outl = v18;
    return result;
  }
  if (inl <= 0)
  {
    *outl = 0;
    return inl == 0;
  }
  if ((ctx->oiv[9] & 8) != 0)
    return EVP_EncryptUpdate(ctx, out, outl, in, inl);
  if (block_size >= 0x21)
    EVP_DecryptUpdate_cold_1();
  v15 = *(&ctx->key_len + 1);
  if (v15)
  {
    if ((_DWORD)block_size)
      memcpy(out, &ctx->flags, block_size);
    v14 += block_size;
  }
  result = EVP_EncryptUpdate(ctx, v14, outl, in, inl);
  if (result)
  {
    if (block_size < 2 || HIDWORD(ctx->app_data))
    {
      *(&ctx->key_len + 1) = 0;
      if (!v15)
        return 1;
    }
    else
    {
      *outl -= block_size;
      *(&ctx->key_len + 1) = 1;
      memcpy(&ctx->flags, &v14[*outl], block_size);
      if (!v15)
        return 1;
    }
    *outl += block_size;
    return 1;
  }
  return result;
}

int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *outm, int *outl)
{
  int v3;
  int v4;
  const EVP_CIPHER *cipher;
  unsigned int block_size;
  int v9;
  uint64_t v10;
  unsigned int v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  unint64_t *p_flags;
  uint64_t v16;
  unsigned __int8 v17;

  *outl = 0;
  if (*(_DWORD *)&ctx->final[8])
  {
    v3 = 66;
    v4 = 470;
LABEL_3:
    ERR_put_error(30, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v4);
    return 0;
  }
  cipher = ctx->cipher;
  if ((ctx->cipher->flags & 0x40000000000) != 0)
  {
    v9 = ((uint64_t (*)(void))cipher->cleanup)();
    if (v9 < 0)
      return 0;
    *outl = v9;
  }
  else if ((ctx->oiv[9] & 8) != 0)
  {
    if (HIDWORD(ctx->app_data))
    {
      v3 = 106;
      v4 = 487;
      goto LABEL_3;
    }
  }
  else
  {
    block_size = cipher->block_size;
    if (block_size >= 2)
    {
      if (HIDWORD(ctx->app_data) || !*(&ctx->key_len + 1))
      {
        v3 = 123;
        v4 = 496;
        goto LABEL_3;
      }
      if (block_size >= 0x21)
        EVP_DecryptFinal_ex_cold_1();
      v10 = block_size - 1;
      v11 = *((unsigned __int8 *)&ctx->flags + v10);
      if (*((_BYTE *)&ctx->flags + v10))
        v12 = block_size >= v11;
      else
        v12 = 0;
      if (!v12)
      {
        v3 = 101;
        v4 = 505;
        goto LABEL_3;
      }
      v13 = *((unsigned __int8 *)&ctx->flags + v10);
      do
      {
        if (*((unsigned __int8 *)&ctx->flags + v10) != v11)
        {
          v3 = 101;
          v4 = 511;
          goto LABEL_3;
        }
        LODWORD(v10) = v10 - 1;
        --v13;
      }
      while (v13);
      v14 = block_size - v11;
      if ((int)v14 >= 1)
      {
        p_flags = &ctx->flags;
        v16 = v14;
        do
        {
          v17 = *(_BYTE *)p_flags;
          p_flags = (unint64_t *)((char *)p_flags + 1);
          *outm++ = v17;
          --v16;
        }
        while (v16);
      }
      *outl = v14;
    }
  }
  return 1;
}

int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher->block_size;
}

int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad)
{
  *(_DWORD *)&c->oiv[8] = *(_DWORD *)&c->oiv[8] & 0xFFFFF7FF | ((pad == 0) << 11);
  return 1;
}

int EVP_CIPHER_key_length(const EVP_CIPHER *cipher)
{
  return cipher->key_len;
}

int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher)
{
  return cipher->iv_len;
}

const BIGNUM *__cdecl RSA_get0_e(const EC_KEY *a1)
{
  return (const BIGNUM *)*((_QWORD *)a1 + 2);
}

void ec_GFp_simple_group_finish(uint64_t a1)
{
  BN_free((BIGNUM *)(a1 + 56));
}

uint64_t ec_GFp_simple_group_get_curve(uint64_t a1, BIGNUM *a, BIGNUM *a3, BIGNUM *a4)
{
  uint64_t result;

  if (!a || (result = (uint64_t)BN_copy(a, (const BIGNUM *)(a1 + 56))) != 0)
  {
    if (!a3 || (result = ec_felem_to_bignum(a1, a3, a1 + 80), (_DWORD)result))
    {
      if (!a4)
        return 1;
      result = ec_felem_to_bignum(a1, a4, a1 + 152);
      if ((_DWORD)result)
        return 1;
    }
  }
  return result;
}

double ec_GFp_simple_point_set_to_infinity(uint64_t a1, uint64_t a2)
{
  return ec_GFp_simple_point_init(a2);
}

unint64_t ec_GFp_simple_invert(uint64_t a1, uint64_t a2)
{
  return ec_felem_neg(a1, (unint64_t *)(a2 + 72), (const unint64_t *)(a2 + 72));
}

uint64_t ec_GFp_simple_points_equal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  void (*v6)(uint64_t, _OWORD *, uint64_t);
  void (*v7)(uint64_t, _OWORD *, _OWORD *, uint64_t *);
  __int128 v8;
  uint64_t *v9;
  uint64_t *v10;
  int v11;
  _OWORD v13[4];
  unint64_t v14;
  _OWORD v15[4];
  unint64_t v16;
  _OWORD v17[4];
  unint64_t v18;
  _OWORD v19[4];
  unint64_t v20;

  v3 = a3;
  v7 = *(void (**)(uint64_t, _OWORD *, _OWORD *, uint64_t *))(*(_QWORD *)a1 + 112);
  v6 = *(void (**)(uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 120);
  v20 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[2] = v8;
  v19[3] = v8;
  v19[0] = v8;
  v19[1] = v8;
  v18 = 0xAAAAAAAAAAAAAAAALL;
  v17[2] = v8;
  v17[3] = v8;
  v17[0] = v8;
  v17[1] = v8;
  v16 = 0xAAAAAAAAAAAAAAAALL;
  v15[2] = v8;
  v15[3] = v8;
  v15[0] = v8;
  v15[1] = v8;
  v14 = 0xAAAAAAAAAAAAAAAALL;
  v13[2] = v8;
  v13[3] = v8;
  v9 = (uint64_t *)(a3 + 144);
  v13[0] = v8;
  v13[1] = v8;
  v6(a1, v13, a3 + 144);
  v7(a1, v19, (_OWORD *)a2, (uint64_t *)v13);
  v10 = (uint64_t *)(a2 + 144);
  v6(a1, v15, a2 + 144);
  v7(a1, v17, (_OWORD *)v3, (uint64_t *)v15);
  ec_felem_sub(a1, (unint64_t *)v19, (const unint64_t *)v19, (const unint64_t *)v17);
  LODWORD(v6) = ec_felem_non_zero_mask(a1, (uint64_t *)v19);
  v7(a1, v13, v13, v9);
  v7(a1, v19, (_OWORD *)(a2 + 72), (uint64_t *)v13);
  v7(a1, v15, v15, (uint64_t *)(a2 + 144));
  v7(a1, v17, (_OWORD *)(v3 + 72), (uint64_t *)v15);
  ec_felem_sub(a1, (unint64_t *)v19, (const unint64_t *)v19, (const unint64_t *)v17);
  LODWORD(a2) = ec_felem_non_zero_mask(a1, (uint64_t *)v19) | v6;
  LODWORD(v3) = ec_felem_non_zero_mask(a1, v10);
  v11 = ec_felem_non_zero_mask(a1, v9);
  return (v3 & ~(_BYTE)a2) & v11 & 1 | (((v11 | v3) & 1) == 0);
}

uint64_t ec_GFp_simple_cmp_x_coordinate(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result;
  __int128 v7;
  _OWORD v8[4];
  unint64_t v9;

  result = ec_felem_non_zero_mask(a1, (uint64_t *)(a2 + 144));
  if (result)
  {
    v9 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v8[2] = v7;
    v8[3] = v7;
    v8[0] = v7;
    v8[1] = v7;
    result = ec_get_x_coordinate_as_scalar(a1, (unint64_t *)v8, a2);
    if ((_DWORD)result)
      return ec_scalar_equal_vartime(a1, v8, a3);
  }
  return result;
}

uint64_t BN_MONT_CTX_new_consttime(const BIGNUM *a1, BN_CTX *a2)
{
  BN_MONT_CTX *v4;
  uint64_t v5;

  v4 = BN_MONT_CTX_new();
  v5 = (uint64_t)v4;
  if (!v4
    || !bn_mont_ctx_set_N_and_n0((uint64_t)v4, a1)
    || !bn_mod_exp_base_2_consttime((BIGNUM *)v5, *(_DWORD *)(v5 + 32) << 7, (const BIGNUM *)(v5 + 24), a2)|| !bn_resize_words(v5, *(int *)(v5 + 32)))
  {
    BN_MONT_CTX_free((BN_MONT_CTX *)v5);
    return 0;
  }
  return v5;
}

uint64_t BN_to_montgomery(BIGNUM *a1, const BIGNUM *a2, BIGNUM *mont, BN_CTX *ctx)
{
  return BN_mod_mul_montgomery(a1, a2, mont, (BN_MONT_CTX *)mont, ctx);
}

int BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_MONT_CTX *mont, BN_CTX *ctx)
{
  int v6;
  BIGNUM *v12;
  uint64_t v13;

  if (!a->neg && !b->neg)
  {
    BN_CTX_start(ctx);
    v12 = BN_CTX_get(ctx);
    if (v12)
    {
      v13 = (uint64_t)v12;
      if (a == b)
      {
        if (bn_sqr_consttime(v12, (BIGNUM *)a, ctx))
          goto LABEL_8;
      }
      else if (bn_mul_consttime(v12, (BIGNUM *)a, (BIGNUM *)b, ctx))
      {
LABEL_8:
        v6 = BN_from_montgomery_word((uint64_t)r, v13, (uint64_t)mont);
LABEL_11:
        BN_CTX_end(ctx);
        return v6;
      }
    }
    v6 = 0;
    goto LABEL_11;
  }
  ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/montgomery.c", 422);
  return 0;
}

int BN_from_montgomery(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont, BN_CTX *ctx)
{
  BIGNUM *v8;
  uint64_t v9;
  int v10;

  BN_CTX_start(ctx);
  v8 = BN_CTX_get(ctx);
  if (v8 && (v9 = (uint64_t)v8, BN_copy(v8, a)))
    v10 = BN_from_montgomery_word((uint64_t)r, v9, (uint64_t)mont);
  else
    v10 = 0;
  BN_CTX_end(ctx);
  return v10;
}

uint64_t BN_from_montgomery_word(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  unint64_t v8;

  if (*(_DWORD *)(a2 + 16))
  {
    ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/montgomery.c", 324);
    return 0;
  }
  else
  {
    v6 = *(int *)(a3 + 32);
    if ((_DWORD)v6)
    {
      result = bn_resize_words(a2, 2 * v6);
      if ((_DWORD)result)
      {
        result = bn_wexpand((_QWORD **)a1, *(int *)(a3 + 32));
        if ((_DWORD)result)
        {
          v8 = *(int *)(a3 + 32);
          *(_DWORD *)(a1 + 8) = v8;
          *(_DWORD *)(a1 + 16) = 0;
          return bn_from_montgomery_in_place(*(unint64_t **)a1, v8, *(unint64_t **)a2, *(int *)(a2 + 8), a3);
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      return 1;
    }
  }
  return result;
}

uint64_t bn_one_to_montgomery(BIGNUM *r, BIGNUM *a, BN_CTX *ctx)
{
  unint64_t top;
  uint64_t result;
  unint64_t *d;
  unint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  top = a[1].top;
  if ((int)top < 1 || (a[1].d[(top - 1)] & 0x8000000000000000) == 0)
    return BN_from_montgomery(r, a, (BN_MONT_CTX *)a, ctx);
  result = bn_wexpand(&r->d, top);
  if ((_DWORD)result)
  {
    d = a[1].d;
    v8 = r->d;
    *r->d = -(uint64_t)*d;
    v9 = a[1].top;
    if ((int)v9 >= 2)
    {
      v10 = (uint64_t *)(v8 + 1);
      v11 = (uint64_t *)(d + 1);
      v12 = v9 - 1;
      do
      {
        v13 = *v11++;
        *v10++ = ~v13;
        --v12;
      }
      while (v12);
    }
    r->top = v9;
    r->neg = 0;
    return 1;
  }
  return result;
}

int SHA384_Init(SHA512_CTX *c)
{
  *(_OWORD *)c->h = xmmword_1B5012150;
  *(_OWORD *)&c->h[2] = xmmword_1B5012160;
  *(_OWORD *)&c->h[4] = xmmword_1B5012170;
  *(_OWORD *)&c->h[6] = xmmword_1B5012180;
  c->Nl = 0;
  c->Nh = 0;
  *(_QWORD *)&c->num = 0x3000000000;
  return 1;
}

int SHA512_Init(SHA512_CTX *c)
{
  *(_OWORD *)c->h = xmmword_1B5012190;
  *(_OWORD *)&c->h[2] = xmmword_1B50121A0;
  *(_OWORD *)&c->h[4] = xmmword_1B50121B0;
  *(_OWORD *)&c->h[6] = xmmword_1B50121C0;
  c->Nl = 0;
  c->Nh = 0;
  *(_QWORD *)&c->num = 0x4000000000;
  return 1;
}

unsigned __int8 *__cdecl SHA512(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  __int128 v4;
  SHA512_CTX v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v6.u.p[96] = v4;
  *(_OWORD *)&v6.u.p[112] = v4;
  *(_OWORD *)&v6.u.p[64] = v4;
  *(_OWORD *)&v6.u.p[80] = v4;
  *(_OWORD *)&v6.u.p[32] = v4;
  *(_OWORD *)&v6.u.p[48] = v4;
  *(_OWORD *)v6.u.d = v4;
  *(_OWORD *)&v6.u.p[16] = v4;
  *(_OWORD *)v6.h = xmmword_1B5012190;
  *(_OWORD *)&v6.h[2] = xmmword_1B50121A0;
  *(_OWORD *)&v6.h[4] = xmmword_1B50121B0;
  *(_OWORD *)&v6.h[6] = xmmword_1B50121C0;
  v6.Nl = 0;
  v6.Nh = 0;
  *(_QWORD *)&v6.num = 0x4000000000;
  SHA512_Update(&v6, d, n);
  sha512_final_impl(md, v6.md_len, (int8x16_t *)&v6);
  OPENSSL_cleanse(&v6, 0xD8uLL);
  return md;
}

int SHA512_Update(SHA512_CTX *c, const void *data, size_t len)
{
  size_t v3;
  unint64_t *v4;
  SHA512state_st::$61765161EF95A25BF6D9F15268D2C4E6 *p_u;
  uint64_t num;
  uint64_t v8;
  size_t v9;
  char *v10;

  if (len)
  {
    v3 = len;
    v4 = (unint64_t *)data;
    p_u = &c->u;
    *(_OWORD *)&c->Nl += __PAIR128__(len >> 61, 8 * len);
    num = c->num;
    if ((_DWORD)num)
    {
      v8 = 128 - num;
      v9 = len - (128 - num);
      if (len < 128 - num)
      {
        memcpy((char *)p_u + num, data, len);
        LODWORD(v3) = c->num + v3;
LABEL_12:
        c->num = v3;
        return 1;
      }
      if ((_DWORD)num != 128)
        memcpy((char *)p_u + num, data, 128 - num);
      c->num = 0;
      v4 = (unint64_t *)((char *)v4 + v8);
      sha512_block_data_order((unint64_t)c, p_u->d, 1);
      v3 = v9;
    }
    if (v3 >= 0x80)
    {
      sha512_block_data_order((unint64_t)c, v4, v3 >> 7);
      v10 = (char *)v4 + v3;
      v3 &= 0x7Fu;
      v4 = (unint64_t *)&v10[-v3];
    }
    if (v3)
    {
      memcpy(p_u, v4, v3);
      goto LABEL_12;
    }
  }
  return 1;
}

int SHA512_Final(unsigned __int8 *md, SHA512_CTX *c)
{
  return sha512_final_impl(md, c->md_len, (int8x16_t *)c);
}

uint64_t sha512_final_impl(_QWORD *a1, unint64_t a2, int8x16_t *a3)
{
  int8x16_t *v3;
  unint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  int8x16_t v9;
  unint64_t v10;
  unint64_t v11;

  v3 = a3;
  v6 = (unint64_t *)&a3[5];
  v7 = a3[13].u32[0];
  a3[5].i8[v7] = 0x80;
  v8 = v7 + 1;
  if (v7 < 0x70)
  {
    if (v7 == 111)
      goto LABEL_7;
  }
  else
  {
    if ((_DWORD)v7 != 127)
      bzero((char *)v6 + v8, 127 - v7);
    sha512_block_data_order((unint64_t)v3, v6, 1);
    v8 = 0;
  }
  bzero((char *)v6 + v8, 112 - v8);
LABEL_7:
  v9 = vrev64q_s8(v3[4]);
  v3[12] = vextq_s8(v9, v9, 8uLL);
  sha512_block_data_order((unint64_t)v3, v6, 1);
  if (!a1)
    return 0;
  if ((a2 & 7) != 0)
    sha512_final_impl_cold_1();
  if (a2 >= 8)
  {
    v10 = a2 >> 3;
    do
    {
      v11 = v3->i64[0];
      v3 = (int8x16_t *)((char *)v3 + 8);
      *a1++ = bswap64(v11);
      --v10;
    }
    while (v10);
  }
  return 1;
}

void SHA512_Transform(SHA512_CTX *c, const unsigned __int8 *data)
{
  sha512_block_data_order((unint64_t)c, (unint64_t *)data, 1);
}

unint64_t sha512_block_data_order(unint64_t result, unint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t *v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  char *v81;
  char *v82;
  char *v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  char *v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;

  v123 = (_QWORD *)result;
  if (a3)
  {
    v4 = *(_QWORD *)result;
    v3 = *(_QWORD *)(result + 8);
    v6 = *(_QWORD *)(result + 16);
    v5 = *(_QWORD *)(result + 24);
    v8 = *(_QWORD *)(result + 32);
    v7 = *(_QWORD *)(result + 40);
    v10 = *(_QWORD *)(result + 48);
    v9 = *(_QWORD *)(result + 56);
    do
    {
      v132 = a3;
      v138 = 0;
      v139 = bswap64(*a2);
      v124 = v9;
      v11 = (v7 & v8)
          + v9
          + (v10 & ~v8)
          + v139
          + (__ROR8__(v8, 14) ^ __ROR8__(v8, 18) ^ __ROR8__(v8, 41))
          + 0x428A2F98D728AE22;
      v128 = v5;
      v12 = v11 + v5;
      v13 = ((v6 ^ v3) & v4 ^ v6 & v3) + (__ROR8__(v4, 28) ^ __ROR8__(v4, 34) ^ __ROR8__(v4, 39)) + v11;
      v14 = bswap64(a2[1]);
      v125 = v10;
      v15 = v10
          + v14
          + (v7 & ~v12)
          + (v12 & v8)
          + 0x7137449123EF65CDLL
          + (__ROR8__(v12, 14) ^ __ROR8__(v12, 18) ^ __ROR8__(v12, 41));
      v129 = v6;
      v16 = v15 + v6;
      v17 = (__ROR8__(v13, 28) ^ __ROR8__(v13, 34) ^ __ROR8__(v13, 39)) + (v13 & (v3 ^ v4) ^ v3 & v4) + v15;
      v18 = bswap64(a2[2]);
      v126 = v7;
      v19 = v7
          + v18
          + (v8 & ~v16)
          + (v16 & v12)
          - 0x4A3F043013B2C4D1
          + (__ROR8__(v15 + v6, 14) ^ __ROR8__(v15 + v6, 18) ^ __ROR8__(v16, 41));
      v130 = v3;
      v20 = v19 + v3;
      v21 = (__ROR8__(v17, 28) ^ __ROR8__(v17, 34) ^ __ROR8__(v17, 39)) + (v17 & (v13 ^ v4) ^ v13 & v4) + v19;
      v22 = bswap64(a2[3]);
      v127 = v8;
      v23 = v8
          + v22
          + (v12 & ~v20)
          + (v20 & v16)
          - 0x164A245A7E762444
          + (__ROR8__(v20, 14) ^ __ROR8__(v20, 18) ^ __ROR8__(v20, 41));
      v131 = v4;
      v24 = v23 + v4;
      v25 = (__ROR8__(v21, 28) ^ __ROR8__(v21, 34) ^ __ROR8__(v21, 39)) + (v21 & (v17 ^ v13) ^ v17 & v13) + v23;
      v26 = bswap64(a2[4]);
      v27 = v12
          + v26
          + (v16 & ~v24)
          + (v24 & v20)
          + 0x3956C25BF348B538
          + (__ROR8__(v24, 14) ^ __ROR8__(v24, 18) ^ __ROR8__(v24, 41));
      v28 = v27 + v13;
      v29 = (__ROR8__(v25, 28) ^ __ROR8__(v25, 34) ^ __ROR8__(v25, 39)) + (v25 & (v21 ^ v17) ^ v21 & v17) + v27;
      v30 = bswap64(a2[5]);
      v31 = v30
          + v16
          + (v20 & ~v28)
          + (v28 & v24)
          + 0x59F111F1B605D019
          + (__ROR8__(v28, 14) ^ __ROR8__(v28, 18) ^ __ROR8__(v28, 41));
      v32 = v31 + v17;
      v33 = (__ROR8__(v29, 28) ^ __ROR8__(v29, 34) ^ __ROR8__(v29, 39)) + (v29 & (v25 ^ v21) ^ v25 & v21) + v31;
      v34 = bswap64(a2[6]);
      v35 = v34
          + v20
          + (v24 & ~v32)
          + (v32 & v28)
          - 0x6DC07D5B50E6B065
          + (__ROR8__(v32, 14) ^ __ROR8__(v32, 18) ^ __ROR8__(v32, 41));
      v36 = v35 + v21;
      v37 = (__ROR8__(v33, 28) ^ __ROR8__(v33, 34) ^ __ROR8__(v33, 39)) + (v33 & (v29 ^ v25) ^ v29 & v25) + v35;
      v137 = bswap64(a2[7]);
      v38 = v137
          + v24
          + (v28 & ~v36)
          + (v36 & v32)
          - 0x54E3A12A25927EE8
          + (__ROR8__(v36, 14) ^ __ROR8__(v36, 18) ^ __ROR8__(v36, 41));
      v39 = v38 + v25;
      v40 = (__ROR8__(v37, 28) ^ __ROR8__(v37, 34) ^ __ROR8__(v37, 39)) + (v37 & (v33 ^ v29) ^ v33 & v29) + v38;
      v136 = bswap64(a2[8]);
      v41 = v136
          + v28
          + (v32 & ~v39)
          + (v39 & v36)
          - 0x27F855675CFCFDBELL
          + (__ROR8__(v39, 14) ^ __ROR8__(v39, 18) ^ __ROR8__(v39, 41));
      v42 = v41 + v29;
      v43 = (__ROR8__(v40, 28) ^ __ROR8__(v40, 34) ^ __ROR8__(v40, 39)) + (v40 & (v37 ^ v33) ^ v37 & v33) + v41;
      v135 = bswap64(a2[9]);
      v44 = v135
          + v32
          + (v36 & ~v42)
          + (v42 & v39)
          + 0x12835B0145706FBELL
          + (__ROR8__(v42, 14) ^ __ROR8__(v42, 18) ^ __ROR8__(v42, 41));
      v45 = v44 + v33;
      v46 = (__ROR8__(v43, 28) ^ __ROR8__(v43, 34) ^ __ROR8__(v43, 39)) + (v43 & (v40 ^ v37) ^ v40 & v37) + v44;
      v134 = bswap64(a2[10]);
      v47 = v134
          + v36
          + (v39 & ~v45)
          + (v45 & v42)
          + 0x243185BE4EE4B28CLL
          + (__ROR8__(v45, 14) ^ __ROR8__(v45, 18) ^ __ROR8__(v45, 41));
      v48 = v47 + v37;
      v49 = (__ROR8__(v46, 28) ^ __ROR8__(v46, 34) ^ __ROR8__(v46, 39)) + (v46 & (v43 ^ v40) ^ v43 & v40) + v47;
      v50 = bswap64(a2[11]);
      v51 = v50
          + v39
          + (v42 & ~v48)
          + (v48 & v45)
          + 0x550C7DC3D5FFB4E2
          + (__ROR8__(v48, 14) ^ __ROR8__(v48, 18) ^ __ROR8__(v48, 41));
      v52 = v51 + v40;
      v53 = (__ROR8__(v49, 28) ^ __ROR8__(v49, 34) ^ __ROR8__(v49, 39)) + (v49 & (v46 ^ v43) ^ v46 & v43) + v51;
      v54 = bswap64(a2[12]);
      v55 = v54
          + v42
          + (v45 & ~v52)
          + (v52 & v48)
          + 0x72BE5D74F27B896FLL
          + (__ROR8__(v52, 14) ^ __ROR8__(v52, 18) ^ __ROR8__(v52, 41));
      v56 = v55 + v43;
      v57 = (__ROR8__(v53, 28) ^ __ROR8__(v53, 34) ^ __ROR8__(v53, 39)) + (v53 & (v49 ^ v46) ^ v49 & v46) + v55;
      v58 = bswap64(a2[13]);
      v59 = v58
          + v45
          + (v48 & ~v56)
          + (v56 & v52)
          - 0x7F214E01C4E9694FLL
          + (__ROR8__(v55 + v43, 14) ^ __ROR8__(v55 + v43, 18) ^ __ROR8__(v56, 41));
      v60 = v59 + v46;
      v61 = (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + (v57 & (v53 ^ v49) ^ v53 & v49) + v59;
      v62 = bswap64(a2[14]);
      v63 = v62
          + v48
          + (v52 & ~v60)
          + (v60 & v56)
          - 0x6423F958DA38EDCBLL
          + (__ROR8__(v59 + v46, 14) ^ __ROR8__(v59 + v46, 18) ^ __ROR8__(v60, 41));
      result = v63 + v49;
      v64 = (__ROR8__(v61, 28) ^ __ROR8__(v61, 34) ^ __ROR8__(v61, 39)) + (v61 & (v57 ^ v53) ^ v57 & v53) + v63;
      v65 = bswap64(a2[15]);
      v66 = v65
          + v52
          + (v56 & ~result)
          + (result & v60)
          - 0x3E640E8B3096D96CLL
          + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
      v67 = v139;
      v68 = v66 + v53;
      v69 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v61 ^ v57) ^ v61 & v57) + v66;
      v70 = &qword_1B50122D8;
      do
      {
        v133 = v50;
        v71 = (__ROR8__(v14, 1) ^ __ROR8__(v14, 8) ^ (v14 >> 7))
            + v67
            + v135
            + (__ROR8__(v62, 19) ^ __ROR8__(v62, 61) ^ (v62 >> 6));
        v72 = (__ROR8__(v68, 14) ^ __ROR8__(v68, 18) ^ __ROR8__(v68, 41))
            + (result & v68)
            + v56
            + (v60 & ~v68)
            + *(v70 - 15)
            + v71;
        v73 = v72 + v57;
        v74 = ((v61 ^ v64) & v69 ^ v61 & v64) + (__ROR8__(v69, 28) ^ __ROR8__(v69, 34) ^ __ROR8__(v69, 39)) + v72;
        v75 = v54;
        v76 = (__ROR8__(v18, 1) ^ __ROR8__(v18, 8) ^ (v18 >> 7))
            + v14
            + v134
            + (__ROR8__(v65, 19) ^ __ROR8__(v65, 61) ^ (v65 >> 6));
        v77 = v76
            + v60
            + *(v70 - 14)
            + (result & ~v73)
            + (v73 & v68)
            + (__ROR8__(v73, 14) ^ __ROR8__(v73, 18) ^ __ROR8__(v73, 41));
        v78 = v77 + v61;
        v79 = (__ROR8__(v74, 28) ^ __ROR8__(v74, 34) ^ __ROR8__(v74, 39)) + (v74 & (v64 ^ v69) ^ v64 & v69) + v77;
        v140 = v71;
        v80 = (__ROR8__(v22, 1) ^ __ROR8__(v22, 8) ^ (v22 >> 7))
            + v18
            + v50
            + (__ROR8__(v71, 19) ^ __ROR8__(v71, 61) ^ (v71 >> 6));
        v81 = (char *)(v80
                     + result
                     + *(v70 - 13)
                     + (v68 & ~v78)
                     + (v78 & v73)
                     + (__ROR8__(v77 + v61, 14) ^ __ROR8__(v77 + v61, 18) ^ __ROR8__(v78, 41)));
        v82 = &v81[v64];
        v83 = &v81[(__ROR8__(v79, 28) ^ __ROR8__(v79, 34) ^ __ROR8__(v79, 39)) + (v79 & (v74 ^ v69) ^ v74 & v69)];
        v84 = (__ROR8__(v26, 1) ^ __ROR8__(v26, 8) ^ (v26 >> 7))
            + v22
            + v54
            + (__ROR8__(v76, 19) ^ __ROR8__(v76, 61) ^ (v76 >> 6));
        v85 = v84
            + v68
            + *(v70 - 12)
            + (v73 & ~(unint64_t)v82)
            + ((unint64_t)v82 & v78)
            + (__ROR8__(&v81[v64], 14) ^ __ROR8__(&v81[v64], 18) ^ __ROR8__(&v81[v64], 41));
        v86 = v85 + v69;
        v87 = (__ROR8__(v83, 28) ^ __ROR8__(v83, 34) ^ __ROR8__(v83, 39))
            + ((unint64_t)v83 & (v79 ^ v74) ^ v79 & v74)
            + v85;
        v26 += (__ROR8__(v30, 1) ^ __ROR8__(v30, 8) ^ (v30 >> 7))
             + v58
             + (__ROR8__(v80, 19) ^ __ROR8__(v80, 61) ^ (v80 >> 6));
        v88 = v73
            + *(v70 - 11)
            + v26
            + (v78 & ~v86)
            + (v86 & (unint64_t)v82)
            + (__ROR8__(v85 + v69, 14) ^ __ROR8__(v85 + v69, 18) ^ __ROR8__(v86, 41));
        v89 = v88 + v74;
        v90 = (__ROR8__(v87, 28) ^ __ROR8__(v87, 34) ^ __ROR8__(v87, 39))
            + (v87 & ((unint64_t)v83 ^ v79) ^ (unint64_t)v83 & v79)
            + v88;
        v30 += (__ROR8__(v34, 1) ^ __ROR8__(v34, 8) ^ (v34 >> 7))
             + v62
             + (__ROR8__(v84, 19) ^ __ROR8__(v84, 61) ^ (v84 >> 6));
        v91 = *(v70 - 10)
            + v78
            + v30
            + ((unint64_t)v82 & ~v89)
            + (v89 & v86)
            + (__ROR8__(v89, 14) ^ __ROR8__(v89, 18) ^ __ROR8__(v89, 41));
        v92 = v91 + v79;
        v93 = (__ROR8__(v90, 28) ^ __ROR8__(v90, 34) ^ __ROR8__(v90, 39))
            + (v90 & (v87 ^ (unint64_t)v83) ^ v87 & (unint64_t)v83)
            + v91;
        v34 += (__ROR8__(v137, 1) ^ __ROR8__(v137, 8) ^ (v137 >> 7))
             + v65
             + (__ROR8__(v26, 19) ^ __ROR8__(v26, 61) ^ (v26 >> 6));
        v94 = (unint64_t)&v82[*(v70 - 9)
                                   + v34
                                   + (v86 & ~v92)
                                   + (v92 & v89)
                                   + (__ROR8__(v92, 14) ^ __ROR8__(v92, 18) ^ __ROR8__(v92, 41))];
        v95 = &v83[v94];
        v96 = (__ROR8__(v93, 28) ^ __ROR8__(v93, 34) ^ __ROR8__(v93, 39)) + (v93 & (v90 ^ v87) ^ v90 & v87) + v94;
        v97 = (__ROR8__(v136, 1) ^ __ROR8__(v136, 8) ^ (v136 >> 7))
            + v137
            + v140
            + (__ROR8__(v30, 19) ^ __ROR8__(v30, 61) ^ (v30 >> 6));
        v98 = *(v70 - 8)
            + v97
            + v86
            + (v89 & ~(unint64_t)v95)
            + ((unint64_t)v95 & v92)
            + (__ROR8__(&v83[v94], 14) ^ __ROR8__(&v83[v94], 18) ^ __ROR8__(v95, 41));
        v99 = v98 + v87;
        v100 = (__ROR8__(v96, 28) ^ __ROR8__(v96, 34) ^ __ROR8__(v96, 39)) + (v96 & (v93 ^ v90) ^ v93 & v90) + v98;
        v101 = (__ROR8__(v135, 1) ^ __ROR8__(v135, 8) ^ (v135 >> 7))
             + v136
             + v76
             + (__ROR8__(v34, 19) ^ __ROR8__(v34, 61) ^ (v34 >> 6));
        v102 = *(v70 - 7)
             + v101
             + v89
             + (v92 & ~v99)
             + (v99 & (unint64_t)v95)
             + (__ROR8__(v99, 14) ^ __ROR8__(v99, 18) ^ __ROR8__(v99, 41));
        v103 = v102 + v90;
        v104 = (__ROR8__(v100, 28) ^ __ROR8__(v100, 34) ^ __ROR8__(v100, 39)) + (v100 & (v96 ^ v93) ^ v96 & v93) + v102;
        v105 = (__ROR8__(v134, 1) ^ __ROR8__(v134, 8) ^ (v134 >> 7))
             + v135
             + v80
             + (__ROR8__(v97, 19) ^ __ROR8__(v97, 61) ^ (v97 >> 6));
        v106 = *(v70 - 6)
             + v105
             + v92
             + ((unint64_t)v95 & ~v103)
             + (v103 & v99)
             + (__ROR8__(v103, 14) ^ __ROR8__(v103, 18) ^ __ROR8__(v103, 41));
        v107 = v106 + v93;
        v108 = (__ROR8__(v104, 28) ^ __ROR8__(v104, 34) ^ __ROR8__(v104, 39))
             + (v104 & (v100 ^ v96) ^ v100 & v96)
             + v106;
        v109 = (__ROR8__(v133, 1) ^ __ROR8__(v133, 8) ^ (v133 >> 7))
             + v134
             + v84
             + (__ROR8__(v101, 19) ^ __ROR8__(v101, 61) ^ (v101 >> 6));
        v110 = (uint64_t)&v95[*(v70 - 5)
                           + v109
                           + (v99 & ~v107)
                           + (v107 & v103)
                           + (__ROR8__(v107, 14) ^ __ROR8__(v107, 18) ^ __ROR8__(v107, 41))];
        v111 = v110 + v96;
        v112 = (__ROR8__(v108, 28) ^ __ROR8__(v108, 34) ^ __ROR8__(v108, 39))
             + (v108 & (v104 ^ v100) ^ v104 & v100)
             + v110;
        v135 = v105;
        v50 = (__ROR8__(v75, 1) ^ __ROR8__(v75, 8) ^ (v75 >> 7))
            + v133
            + v26
            + (__ROR8__(v105, 19) ^ __ROR8__(v105, 61) ^ (v105 >> 6));
        v113 = *(v70 - 4)
             + v50
             + v99
             + (v103 & ~v111)
             + (v111 & v107)
             + (__ROR8__(v110 + v96, 14) ^ __ROR8__(v110 + v96, 18) ^ __ROR8__(v111, 41));
        v114 = v113 + v100;
        v115 = (__ROR8__(v112, 28) ^ __ROR8__(v112, 34) ^ __ROR8__(v112, 39))
             + (v112 & (v108 ^ v104) ^ v108 & v104)
             + v113;
        v134 = v109;
        v54 = (__ROR8__(v58, 1) ^ __ROR8__(v58, 8) ^ (v58 >> 7))
            + v75
            + v30
            + (__ROR8__(v109, 19) ^ __ROR8__(v109, 61) ^ (v109 >> 6));
        v116 = *(v70 - 3)
             + v54
             + v103
             + (v107 & ~v114)
             + (v114 & v111)
             + (__ROR8__(v114, 14) ^ __ROR8__(v114, 18) ^ __ROR8__(v114, 41));
        v56 = v116 + v104;
        v57 = (__ROR8__(v115, 28) ^ __ROR8__(v115, 34) ^ __ROR8__(v115, 39))
            + (v115 & (v112 ^ v108) ^ v112 & v108)
            + v116;
        v58 += (__ROR8__(v62, 1) ^ __ROR8__(v62, 8) ^ (v62 >> 7))
             + v34
             + (__ROR8__(v50, 19) ^ __ROR8__(v50, 61) ^ (v50 >> 6));
        v117 = *(v70 - 2)
             + v58
             + v107
             + (v111 & ~v56)
             + (v56 & v114)
             + (__ROR8__(v116 + v104, 14) ^ __ROR8__(v116 + v104, 18) ^ __ROR8__(v56, 41));
        v60 = v117 + v108;
        v61 = (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + (v57 & (v115 ^ v112) ^ v115 & v112) + v117;
        v137 = v97;
        v118 = (__ROR8__(v65, 1) ^ __ROR8__(v65, 8) ^ (v65 >> 7)) + v62 + v97;
        v18 = v80;
        v62 = v118 + (__ROR8__(v54, 19) ^ __ROR8__(v54, 61) ^ (v54 >> 6));
        v67 = v140;
        v119 = *(v70 - 1)
             + v62
             + v111
             + (v114 & ~v60)
             + (v60 & v56)
             + (__ROR8__(v60, 14) ^ __ROR8__(v60, 18) ^ __ROR8__(v60, 41));
        result = v119 + v112;
        v64 = (__ROR8__(v61, 28) ^ __ROR8__(v61, 34) ^ __ROR8__(v61, 39)) + (v61 & (v57 ^ v115) ^ v57 & v115) + v119;
        v136 = v101;
        v120 = (__ROR8__(v140, 1) ^ __ROR8__(v140, 8) ^ (v140 >> 7)) + v65 + v101;
        v22 = v84;
        v65 = v120 + (__ROR8__(v58, 19) ^ __ROR8__(v58, 61) ^ (v58 >> 6));
        v121 = *v70;
        v70 += 16;
        v122 = v121
             + v65
             + v114
             + (v56 & ~result)
             + (result & v60)
             + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
        v68 = v122 + v115;
        v69 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v61 ^ v57) ^ v61 & v57) + v122;
        v14 = v76;
        v138 += 16;
      }
      while (v138 < 0x40);
      v4 = v69 + v131;
      v3 = v64 + v130;
      *v123 = v69 + v131;
      v123[1] = v64 + v130;
      v6 = v61 + v129;
      v5 = v57 + v128;
      v123[2] = v61 + v129;
      v123[3] = v57 + v128;
      v8 = v68 + v127;
      v7 = result + v126;
      v123[4] = v68 + v127;
      v123[5] = result + v126;
      v10 = v60 + v125;
      v9 = v56 + v124;
      a2 += 16;
      v123[6] = v60 + v125;
      v123[7] = v56 + v124;
      a3 = v132 - 1;
    }
    while (v132 != 1);
  }
  return result;
}

uint64_t bssl::tls13_server_handshake(bssl *this, bssl::SSL_HANDSHAKE *a2, unsigned __int16 *a3)
{
  SSL_SESSION **v4;
  int v5;
  uint64_t v6;
  bssl *v7;
  CRYPTO_EX_DATA v8;
  char v9;
  BOOL v10;
  uint64_t v11;
  const ssl_st *v12;
  unsigned int v13;
  uint64_t v14;
  const ssl_st *v15;
  bssl *v16;
  int v17;
  bssl *v18;
  __int128 v19;
  bssl *v20;
  uint64_t v21;
  __int128 v22;
  CRYPTO_EX_DATA v23;
  unsigned int protocol_id;
  unsigned __int16 *v25;
  int v26;
  unsigned int (*v27)(uint64_t, char *);
  char v28;
  uint64_t v29;
  CRYPTO_EX_DATA v30;
  uint64_t v31;
  uint64_t v32;
  char extension;
  uint64_t v34;
  unsigned __int16 *v35;
  SSL_SESSION **v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  bssl *v42;
  __int128 v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  unsigned __int8 **v47;
  uint64_t v48;
  _OWORD *v49;
  uint64_t v50;
  _OWORD *v51;
  __int128 v52;
  bssl *v53;
  CRYPTO_EX_DATA v54;
  __int128 v55;
  uint64_t v56;
  int u8;
  int v58;
  int v59;
  bssl *v60;
  BOOL v61;
  bssl *v62;
  __int128 v63;
  int v64;
  bssl *v65;
  __int128 v66;
  unint64_t v67;
  char v68;
  __int128 v69;
  _QWORD *v70;
  _OWORD *v71;
  __int128 v72;
  CRYPTO_EX_DATA v73;
  __int128 v74;
  unsigned int v75;
  __int128 v76;
  const ssl_st *v77;
  int v78;
  __int128 v79;
  int version_low;
  int v81;
  int v82;
  void **v83;
  const void *v84;
  size_t v85;
  int v86;
  char v87;
  SSL_SESSION *v88;
  int v89;
  int v90;
  int v91;
  void *v92;
  unint64_t v93;
  SSL_SESSION *v94;
  SSL_SESSION *v95;
  uint64_t v96;
  unsigned __int8 *v97;
  unsigned __int8 *v98;
  uint64_t v99;
  uint64_t v100;
  SSL_SESSION *v101;
  int v102;
  uint64_t v103;
  unsigned __int8 *v104;
  unsigned __int8 *v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unsigned __int16 *v110;
  int v111;
  unsigned __int16 *v112;
  unint64_t v113;
  int v114;
  uint64_t (*v115)(unsigned __int8 **, char *);
  bssl::SSL_HANDSHAKE *v116;
  const bssl::SSL_HANDSHAKE *v117;
  unsigned int v118;
  uint64_t v119;
  unsigned int v120;
  int v121;
  bssl::SSL_HANDSHAKE *v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t *v126;
  int v127;
  const void *v128;
  unint64_t v129;
  void **v130;
  const ssl_st *v131;
  int v132;
  char v133;
  SSL_SESSION **v134;
  SSL_SESSION *v135;
  const void *v136;
  unint64_t v137;
  void **p_sess_cert;
  int v139;
  char v140;
  uint64_t v141;
  const void *v142;
  unint64_t v143;
  void **v144;
  int v145;
  char v146;
  unsigned int (*v147)(char *);
  bssl *v148;
  const ssl_cipher_st *v149;
  const EVP_MD *handshake_digest;
  const ssl_st *p_master_key_length;
  uint64_t v152;
  int v153;
  int v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  __int128 v158;
  const bssl::SSL_CONFIG *v159;
  __int128 v160;
  SSL_SESSION **v162;
  char *v163;
  char *v164;
  EC_KEY *v165;
  uint64_t *v166;
  char *v167;
  char *v168;
  char *__dst;
  bssl::SSL_HANDSHAKE *v170;
  char *v171;
  size_t **v172;
  char *v173;
  ssl_st d;

  v4 = (SSL_SESSION **)((char *)this + 1536);
  v168 = (char *)this + 232;
  *(unsigned __int8 **)((char *)&d.tlsext_ocsp_resp + 1) = (unsigned __int8 *)*MEMORY[0x1E0C80C00];
  v171 = (char *)this + 88;
  v172 = (size_t **)((char *)this + 424);
  v173 = (char *)this + 136;
  v167 = (char *)this + 280;
  __dst = (char *)this + 1611;
  v170 = (bssl *)((char *)this + 328);
  v163 = (char *)this + 184;
  v164 = (char *)this + 632;
  v165 = (bssl *)((char *)this + 736);
  v166 = (uint64_t *)((char *)this + 600);
  while (2)
  {
    v5 = *((_DWORD *)this + 6);
    v6 = 1;
    switch(v5)
    {
      case 0:
        v7 = *(bssl **)this;
        *(unint64_t *)((char *)&d.options + 1) = 0xAAAAAAAAAAAAAAAALL;
        v8.sk = (STACK *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v8.dummy = 0xAAAAAAAAAAAAAAAALL;
        *(CRYPTO_EX_DATA *)((char *)&d.ex_data + 1) = v8;
        *(CRYPTO_EX_DATA *)((char *)&d.client_CA + 1) = v8;
        *(CRYPTO_EX_DATA *)((char *)&d.init_buf + 1) = v8;
        *(CRYPTO_EX_DATA *)((char *)&d.init_num + 1) = v8;
        *(CRYPTO_EX_DATA *)((char *)&d.handshake_func + 1) = v8;
        *(CRYPTO_EX_DATA *)((char *)&d.quiet_shutdown + 1) = v8;
        *(CRYPTO_EX_DATA *)((char *)&d.rbio + 1) = v8;
        *(CRYPTO_EX_DATA *)((char *)&d.bbio + 1) = v8;
        *(CRYPTO_EX_DATA *)((char *)&d.version + 1) = v8;
        if (!bssl::SSL_HANDSHAKE::GetClientHello((uint64_t *)this, (uint64_t)&d.ex_data.sk + 1, (uint64_t)&d.version + 1))goto LABEL_365;
        v9 = BYTE1(d.server);
        if (*((_QWORD *)v7 + 21))
          v10 = *(_QWORD *)((char *)&d.server + 1) == 0;
        else
          v10 = 1;
        if (!v10)
        {
          ERR_put_error(16, 0, 306, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 237);
          bssl::ssl_send_alert(v7, (ssl_st *)2, 47);
          goto LABEL_365;
        }
        if (*(_QWORD *)((char *)&d.server + 1))
          memcpy(__dst, *(const void **)((char *)&d.handshake_func + 1), *(size_t *)((char *)&d.server + 1));
        *((_BYTE *)this + 1643) = v9;
        *(_WORD *)&d.sid_ctx[13] = -21846;
        if ((bssl::tls1_get_shared_group(this, (const ssl_st *)&d.sid_ctx[13], a3) & 1) == 0)
        {
          ERR_put_error(16, 0, 266, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 247);
          bssl::ssl_send_alert(v7, (ssl_st *)2, 40);
          goto LABEL_365;
        }
        v11 = *(unsigned __int16 *)&d.sid_ctx[13];
        *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = (int (__cdecl *)(int, X509_STORE_CTX *))0xAAAAAAAAAAAAAAAALL;
        *(void (__cdecl **)(const SSL *, int, int))((char *)&d.info_callback + 1) = (void (__cdecl *)(const SSL *, int, int))0xAAAAAAAAAAAAAAAALL;
        CBS_init((int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1), *(uint64_t *)((char *)&d.quiet_shutdown + 1), *(uint64_t *)((char *)&d.state + 1));
        v13 = bssl::ssl_protocol_version(v7, v12);
        v14 = bssl::ssl_choose_tls13_cipher(*(unsigned __int16 **)((char *)&d.verify_callback + 1), *(unsigned __int16 **)((char *)&d.info_callback + 1), v13, v11, (*(unsigned __int16 *)(*((_QWORD *)v7 + 1) + 313) >> 11) & 1);
        *((_QWORD *)this + 196) = v14;
        if (!v14)
        {
          ERR_put_error(16, 0, 184, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 255);
          bssl::ssl_send_alert(v7, (ssl_st *)2, 40);
          goto LABEL_365;
        }
        BYTE1(d.verify_callback) = 50;
        if ((bssl::ssl_negotiate_alpn((uint64_t)this, (char *)&d.verify_callback + 1, (uint64_t)&d.version + 1) & 1) == 0)
        {
          bssl::ssl_send_alert(v7, (ssl_st *)2, BYTE1(d.verify_callback));
          goto LABEL_365;
        }
        v16 = (bssl *)bssl::ssl_protocol_version(v7, v15);
        if (!bssl::SSLTranscript::InitHash(v172, v16, *((const ssl_cipher_st **)this + 196)))
          goto LABEL_365;
        *((_DWORD *)this + 6) = 1;
        goto LABEL_366;
      case 1:
        v29 = *(_QWORD *)this;
        *(unint64_t *)((char *)&d.options + 1) = 0xAAAAAAAAAAAAAAAALL;
        v30.sk = (STACK *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v30.dummy = 0xAAAAAAAAAAAAAAAALL;
        *(CRYPTO_EX_DATA *)((char *)&d.ex_data + 1) = v30;
        *(CRYPTO_EX_DATA *)((char *)&d.client_CA + 1) = v30;
        *(CRYPTO_EX_DATA *)((char *)&d.init_buf + 1) = v30;
        *(CRYPTO_EX_DATA *)((char *)&d.init_num + 1) = v30;
        *(CRYPTO_EX_DATA *)((char *)&d.handshake_func + 1) = v30;
        *(CRYPTO_EX_DATA *)((char *)&d.quiet_shutdown + 1) = v30;
        *(CRYPTO_EX_DATA *)((char *)&d.rbio + 1) = v30;
        *(CRYPTO_EX_DATA *)((char *)&d.bbio + 1) = v30;
        *(CRYPTO_EX_DATA *)((char *)&d.version + 1) = v30;
        if (!bssl::SSL_HANDSHAKE::GetClientHello((uint64_t *)this, (uint64_t)&d.ex_data.sk + 1, (uint64_t)&d.version + 1))goto LABEL_365;
        v162 = v4;
        LOBYTE(d.version) = 50;
        v31 = *(_QWORD *)(v29 + 48);
        v32 = *(_QWORD *)this;
        *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = (int (__cdecl *)(int, X509_STORE_CTX *))0xAAAAAAAAAAAAAAAALL;
        *(void (__cdecl **)(const SSL *, int, int))((char *)&d.info_callback + 1) = (void (__cdecl *)(const SSL *, int, int))0xAAAAAAAAAAAAAAAALL;
        extension = bssl::ssl_client_hello_get_extension((uint64_t)&d.version + 1, (int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1), 41);
        if ((extension & 1) == 0)
          goto LABEL_58;
        *(_QWORD *)&d.sid_ctx[13] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&d.sid_ctx[21] = 0xAAAAAAAAAAAAAAAALL;
        if ((bssl::ssl_client_hello_get_extension((uint64_t)&d.version + 1, &d.sid_ctx[13], 45) & 1) == 0)
        {
          LOBYTE(d.version) = 109;
          ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 297);
LABEL_187:
          v34 = 0;
LABEL_188:
          version_low = LOBYTE(d.version);
          goto LABEL_241;
        }
        *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = (void (__cdecl *)(SSL *, int, int, unsigned __int8 *, int, void *))0xAAAAAAAAAAAAAAAALL;
        *(void **)((char *)&d.tlsext_debug_arg + 1) = (void *)0xAAAAAAAAAAAAAAAALL;
        *(const EVP_MD **)((char *)&d.read_hash + 1) = (const EVP_MD *)0xAAAAAAAAAAAAAAAALL;
        *(COMP_CTX **)((char *)&d.expand + 1) = (COMP_CTX *)0xAAAAAAAAAAAAAAAALL;
        *(_DWORD *)((char *)&d.max_cert_list + 1) = -1431655766;
        if ((bssl::ssl_ext_pre_shared_key_parse_clienthello((uint64_t)this, (unint64_t *)((char *)&d.tlsext_debug_cb + 1), (const EVP_MD **)((char *)&d.read_hash + 1), (int *)((char *)&d.max_cert_list + 1), (char *)&d, (uint64_t)&d.version + 1, (unsigned __int8 **)((char *)&d.verify_callback + 1)) & 1) == 0)goto LABEL_187;
        if ((*((_BYTE *)this + 1600) & 0x10) != 0)
        {
          BYTE1(d.sid_ctx_length) = -86;
          *(_QWORD *)((char *)&d.packet_length + 1) = 0;
          v81 = bssl::ssl_process_ticket((uint64_t *)this, (SSL_SESSION **)((char *)&d.packet_length + 1), (_BYTE *)&d.sid_ctx_length + 1, *(const unsigned __int8 **)((char *)&d.tlsext_debug_cb + 1), *(unint64_t *)((char *)&d.tlsext_debug_arg + 1), 0, 0);
          v82 = v81;
          if (v81)
          {
            v34 = 0;
            if (v81 == 3)
              LOBYTE(d.version) = 80;
LABEL_233:
            v88 = *(SSL_SESSION **)((char *)&d.packet_length + 1);
            *(_QWORD *)((char *)&d.packet_length + 1) = 0;
            if (v88)
LABEL_234:
              SSL_SESSION_free(v88);
            switch(v82)
            {
              case 0:
                bssl::SSL_SESSION_dup((bssl *)v34, 0, (int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1));
                v94 = *(SSL_SESSION **)((char *)&d.verify_callback + 1);
                *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = 0;
                std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v162, v94);
                v95 = *(SSL_SESSION **)((char *)&d.verify_callback + 1);
                *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = 0;
                if (v95)
                  SSL_SESSION_free(v95);
                if (!*v162)
                  goto LABEL_240;
                *(_WORD *)(*(_QWORD *)(v29 + 48) + 220) |= 0x40u;
                *((_DWORD *)this + 400) |= 0x2000000u;
                bssl::ssl_session_renew_timeout((bssl *)v29, *((ssl_st **)this + 192), (ssl_session_st *)*(unsigned int *)(*(_QWORD *)(v29 + 128) + 300));
                goto LABEL_59;
              case 1:
                *((_DWORD *)this + 6) = 1;
                v6 = 11;
                goto LABEL_243;
              case 2:
                if (v34)
                  __assert_rtn("do_select_session", "tls13_server.cc", 397, "!session");
                goto LABEL_58;
              case 3:
                goto LABEL_188;
              default:
                goto LABEL_59;
            }
          }
          if (bssl::ssl_session_is_resumable(this, *(const STACK ***)((char *)&d.packet_length + 1), (const ssl_session_st *)a3))
          {
            v88 = *(SSL_SESSION **)((char *)&d.packet_length + 1);
            if ((*(_BYTE *)(*(_QWORD *)((char *)&d.packet_length + 1) + 448) & 8) == 0)
            {
              v34 = 0;
              *(_QWORD *)((char *)&d.packet_length + 1) = 0;
              v82 = 2;
              goto LABEL_234;
            }
            *(_DWORD *)((char *)&d.max_cert_list + 1) = (*(_DWORD *)((char *)&d.max_cert_list + 1)
                                                       - *(_DWORD *)(*(_QWORD *)((char *)&d.packet_length + 1) + 384))
                                                      / 0x3E8u;
            *(void **)((char *)&d.msg_callback_arg + 1) = (void *)0xAAAAAAAAAAAAAAAALL;
            *(_QWORD *)((char *)&d.hit + 1) = 0xAAAAAAAAAAAAAAAALL;
            bssl::ssl_get_current_time(v32, (uint64_t)&d.msg_callback_arg + 1);
            a2 = *(bssl::SSL_HANDSHAKE **)((char *)&d.packet_length + 1);
            v92 = *(void **)(*(_QWORD *)((char *)&d.packet_length + 1) + 200);
            v93 = (char *)*(void **)((char *)&d.msg_callback_arg + 1) - (char *)v92;
            if (*(void **)((char *)&d.msg_callback_arg + 1) < v92)
              __assert_rtn("select_session", "tls13_server.cc", 344, "now.tv_sec >= session->time");
            if (!(v93 >> 31))
            {
              *(_DWORD *)(v31 + 252) = *(_DWORD *)((char *)&d.max_cert_list + 1) - v93;
              if ((bssl::tls13_verify_psk_binder((uint64_t)this, a2, (uint64_t)&d.ex_data.sk + 1, (unsigned __int8 **)((char *)&d.read_hash + 1)) & 1) != 0)
              {
                v82 = 0;
                v34 = *(_QWORD *)((char *)&d.packet_length + 1);
                *(_QWORD *)((char *)&d.packet_length + 1) = 0;
              }
              else
              {
                v34 = 0;
                LOBYTE(d.version) = 51;
                v82 = 3;
              }
              goto LABEL_233;
            }
          }
          v34 = 0;
          v82 = 2;
          goto LABEL_233;
        }
LABEL_58:
        v34 = 0;
        if ((bssl::ssl_get_new_session(this, a2) & 1) == 0)
        {
LABEL_240:
          version_low = 80;
          goto LABEL_241;
        }
LABEL_59:
        if ((bssl::ssl_negotiate_alps((bssl **)this, &d, (uint64_t)&d.version + 1) & 1) == 0)
          goto LABEL_188;
        *(_QWORD *)(*((_QWORD *)this + 192) + 208) = *((_QWORD *)this + 196);
        if ((bssl::tls1_get_shared_group(this, (const ssl_st *)(*((_QWORD *)this + 192) + 6), v35) & 1) == 0)
        {
          ERR_put_error(16, 0, 266, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 441);
          version_low = 40;
          goto LABEL_241;
        }
        BYTE1(d.verify_callback) = -86;
        if ((bssl::ssl_ext_key_share_parse_clienthello((uint64_t)this, (BOOL *)&d.verify_callback + 1, 0, &d, (uint64_t)&d.version + 1) & 1) == 0)
        {
          version_low = LOBYTE(d.version);
          goto LABEL_241;
        }
        v36 = v162;
        if ((*(_BYTE *)(v29 + 180) & 4) == 0)
        {
          v37 = *(_QWORD *)(v29 + 48);
          v38 = 1;
LABEL_64:
          *(_DWORD *)(v37 + 256) = v38;
          goto LABEL_309;
        }
        if ((extension & 1) == 0)
        {
          v37 = *(_QWORD *)(v29 + 48);
          v91 = 5;
          goto LABEL_308;
        }
        if (!v34)
        {
          v37 = *(_QWORD *)(v29 + 48);
          v91 = 6;
          goto LABEL_308;
        }
        if (!*(_DWORD *)(v34 + 388))
        {
          v37 = *(_QWORD *)(v29 + 48);
          v91 = 7;
          goto LABEL_308;
        }
        v89 = *((_DWORD *)this + 400);
        if ((v89 & 0x1000) == 0)
        {
          v37 = *(_QWORD *)(v29 + 48);
          v38 = 4;
          goto LABEL_64;
        }
        v37 = *(_QWORD *)(v29 + 48);
        if ((v89 & 0x4000000) != 0)
        {
          v91 = 10;
          goto LABEL_308;
        }
        v96 = *(_QWORD *)(v37 + 504);
        if (v96 != *(_QWORD *)(v34 + 408))
          goto LABEL_276;
        if (v96)
        {
          v97 = *(unsigned __int8 **)(v34 + 400);
          v98 = *(unsigned __int8 **)(v37 + 496);
          v99 = v96 - 1;
          while (1)
          {
            v100 = v99;
            if (*v98 != *v97)
              break;
            ++v98;
            ++v97;
            --v99;
            if (!v100)
              goto LABEL_261;
          }
LABEL_276:
          v91 = 9;
          goto LABEL_308;
        }
LABEL_261:
        v101 = *v162;
        v102 = *(unsigned __int8 *)(v34 + 448);
        if (((v102 ^ LOBYTE((*v162)[1].verify_result)) & 0x40) != 0)
          goto LABEL_307;
        v103 = *(_QWORD *)&v101[1].sid_ctx[28];
        if (v103 != *(_QWORD *)(v34 + 424))
          goto LABEL_307;
        if (v103)
        {
          v104 = *(unsigned __int8 **)(v34 + 416);
          v105 = *(unsigned __int8 **)&v101[1].sid_ctx[20];
          v106 = v103 - 1;
          while (1)
          {
            v107 = v106;
            if (*v105 != *v104)
              break;
            ++v105;
            ++v104;
            --v106;
            if (!v107)
              goto LABEL_267;
          }
LABEL_307:
          v91 = 14;
LABEL_308:
          *(_DWORD *)(v37 + 256) = v91;
          goto LABEL_309;
        }
LABEL_267:
        if ((*(_DWORD *)(v37 + 252) - 61) <= 0xFFFFFF86)
        {
          v108 = 12;
          goto LABEL_381;
        }
        if ((v102 & 0x20) != 0)
        {
          v156 = *(_QWORD *)(v34 + 464);
          if (!v156)
            goto LABEL_380;
          v157 = *((_QWORD *)this + 1);
          if (*(_QWORD *)(v157 + 264) != v156)
            goto LABEL_380;
          if (CRYPTO_memcmp(*(char **)(v157 + 256), *(char **)(v34 + 456), v156))
          {
            v37 = *(_QWORD *)(v29 + 48);
LABEL_380:
            v108 = 13;
LABEL_381:
            *(_DWORD *)(v37 + 256) = v108;
            goto LABEL_382;
          }
        }
        if (BYTE1(d.verify_callback))
        {
          if (*((_QWORD *)this + 196) != *(_QWORD *)(v34 + 208))
            __assert_rtn("do_select_session", "tls13_server.cc", 487, "hs->new_cipher == session->cipher");
          v155 = *(_QWORD *)(v29 + 48);
          *(_DWORD *)(v155 + 256) = 2;
          *(_WORD *)(v155 + 220) |= 0x800u;
          v37 = *(_QWORD *)(v29 + 48);
        }
        else
        {
          v37 = *(_QWORD *)(v29 + 48);
          *(_DWORD *)(v37 + 256) = 8;
        }
LABEL_382:
        v36 = v162;
LABEL_309:
        v128 = *(const void **)(v37 + 496);
        v129 = *(_QWORD *)(v37 + 504);
        v130 = (void **)&(*v36)[1].sid_ctx[4];
        v132 = bssl::Array<unsigned char>::Init((uint64_t)v130, v129);
        v133 = v132 ^ 1;
        if (!v129)
          v133 = 1;
        if ((v133 & 1) == 0)
          memcpy(*v130, v128, v129);
        if (!v132)
          goto LABEL_339;
        v134 = v162;
        if ((*(_WORD *)(*(_QWORD *)(v29 + 48) + 220) & 0x800) != 0)
        {
          v135 = *v162;
          if (((*v162)[1].verify_result & 0x40) != 0)
          {
            v136 = *(const void **)(v34 + 432);
            v137 = *(_QWORD *)(v34 + 440);
            p_sess_cert = (void **)&v135[1].sess_cert;
            v139 = bssl::Array<unsigned char>::Init((uint64_t)&v135[1].sess_cert, v137);
            v140 = v139 ^ 1;
            if (!v137)
              v140 = 1;
            if ((v140 & 1) == 0)
              memcpy(*p_sess_cert, v136, v137);
            v134 = v162;
            if (!v139)
              goto LABEL_339;
          }
        }
        if ((*(_BYTE *)(v29 + 180) & 4) != 0 && *(_QWORD *)(v29 + 168))
        {
          v141 = *((_QWORD *)this + 1);
          v142 = *(const void **)(v141 + 256);
          v143 = *(_QWORD *)(v141 + 264);
          v144 = (void **)(*((_QWORD *)this + 192) + 456);
          v145 = bssl::Array<unsigned char>::Init((uint64_t)v144, v143);
          v146 = v145 ^ 1;
          if (!v143)
            v146 = 1;
          if ((v146 & 1) == 0)
            memcpy(*v144, v142, v143);
          v134 = v162;
          if (!v145)
            goto LABEL_339;
        }
        v147 = *(unsigned int (**)(char *))(*(_QWORD *)(v29 + 120) + 488);
        if (v147)
        {
          v134 = v162;
          if (!v147((char *)&d.version + 1))
          {
            ERR_put_error(16, 0, 133, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 524);
LABEL_339:
            version_low = 80;
LABEL_241:
            bssl::ssl_send_alert((bssl *)v29, (ssl_st *)2, version_low);
            goto LABEL_242;
          }
        }
        v148 = (bssl *)bssl::ssl_protocol_version((bssl *)v29, v131);
        handshake_digest = bssl::ssl_get_handshake_digest(v148, *((_QWORD *)this + 196), v149);
        EVP_MD_size(handshake_digest);
        if ((*(_WORD *)(*(_QWORD *)(v29 + 48) + 220) & 0x40) != 0)
          p_master_key_length = (const ssl_st *)&(*v134)->master_key_length;
        else
          p_master_key_length = (const ssl_st *)&bssl::kZeroes;
        if (!bssl::tls13_init_key_schedule((uint64_t)this, p_master_key_length)
          || (bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.ex_data.sk + 1) & 1) == 0)
        {
          goto LABEL_242;
        }
        v152 = *(_QWORD *)(v29 + 48);
        if ((*(_WORD *)(v152 + 220) & 0x800) != 0)
        {
          if ((bssl::tls13_derive_early_secret(this, a2) & 1) == 0)
            goto LABEL_242;
        }
        else if ((*((_BYTE *)this + 1601) & 0x10) != 0)
        {
          *(_WORD *)(v152 + 220) |= 1u;
        }
        if (BYTE1(d.verify_callback))
        {
          if (bssl::resolve_ecdhe_secret((uint64_t)this, (uint64_t)&d.version + 1))
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v29 + 32))(v29);
            OPENSSL_free((_QWORD *)*v166);
            *v166 = 0;
            v166[1] = 0;
            v153 = 4;
LABEL_346:
            *((_DWORD *)this + 6) = v153;
            v6 = 1;
            goto LABEL_243;
          }
        }
        else
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v29 + 32))(v29);
          if ((bssl::SSLTranscript::UpdateForHelloRetryRequest((bssl::SSLTranscript *)v172) & 1) != 0)
          {
            v153 = 2;
            goto LABEL_346;
          }
        }
LABEL_242:
        v6 = 0;
LABEL_243:
        if (v34)
          SSL_SESSION_free((SSL_SESSION *)v34);
        v4 = v162;
LABEL_366:
        if (*((_DWORD *)this + 6) != v5)
          bssl::ssl_do_info_callback(*(_QWORD *)this, (const ssl_st *)0x2001);
        if ((_DWORD)v6 == 1)
          continue;
        return v6;
      case 2:
        if ((*((_BYTE *)this + 1602) & 0x10) != 0)
          goto LABEL_77;
        v21 = *(_QWORD *)this;
        *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.rbio + 1) = v22;
        *(_OWORD *)((char *)&d.bbio + 1) = v22;
        *(_OWORD *)((char *)&d.version + 1) = v22;
        CBB_zero((int *)((char *)&d.version + 1));
        v23.sk = (STACK *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v23.dummy = 0xAAAAAAAAAAAAAAAALL;
        *(CRYPTO_EX_DATA *)((char *)&d.client_CA + 1) = v23;
        *(CRYPTO_EX_DATA *)((char *)&d.options + 1) = v23;
        *(CRYPTO_EX_DATA *)((char *)&d.debug + 1) = v23;
        *(CRYPTO_EX_DATA *)((char *)&d.ex_data + 1) = v23;
        *(CRYPTO_EX_DATA *)((char *)&d.verify_callback + 1) = v23;
        *(CRYPTO_EX_DATA *)((char *)&d.error + 1) = v23;
        *(CRYPTO_EX_DATA *)&d.sid_ctx[29] = v23;
        *(CRYPTO_EX_DATA *)((char *)&d.generate_session_id + 1) = v23;
        *(CRYPTO_EX_DATA *)&d.sid_ctx[13] = v23;
        *(_WORD *)((char *)&d.msg_callback_arg + 1) = -21846;
        if (!(*(unsigned int (**)(uint64_t, char *, char *, uint64_t))(*(_QWORD *)v21 + 88))(v21, (char *)&d.version + 1, (char *)&d.ex_data.sk + 1, 2)|| !CBB_add_u16((uint64_t)&d.ex_data.sk + 1, 0x303u)|| !CBB_add_bytes((uint64_t)&d.ex_data.sk + 1, bssl::kHelloRetryRequest, 0x20uLL)|| !CBB_add_u8_length_prefixed((uint64_t *)((char *)&d.ex_data.sk + 1), (uint64_t)&d.verify_callback + 1)|| !CBB_add_bytes((uint64_t)&d.verify_callback + 1, __dst, *((unsigned __int8 *)this + 1643))|| (protocol_id = SSL_CIPHER_get_protocol_id(*((_QWORD *)this + 196)), !CBB_add_u16((uint64_t)&d.ex_data.sk + 1, protocol_id))|| !CBB_add_u8((uint64_t)&d.ex_data.sk + 1, 0)|| !bssl::tls1_get_shared_group(this, (const ssl_st *)((char *)&d.msg_callback_arg + 1), v25)|| !CBB_add_u16_length_prefixed((uint64_t *)((char *)&d.ex_data.sk + 1), (uint64_t)&d.sid_ctx[13])|| !CBB_add_u16((uint64_t)&d.sid_ctx[13], 0x2Bu)|| !CBB_add_u16((uint64_t)&d.sid_ctx[13], 2u)|| !CBB_add_u16((uint64_t)&d.sid_ctx[13], *(unsigned __int16 *)(v21 + 16))|| !CBB_add_u16((uint64_t)&d.sid_ctx[13], 0x33u)
          || !CBB_add_u16((uint64_t)&d.sid_ctx[13], 2u)
          || !CBB_add_u16((uint64_t)&d.sid_ctx[13], *(unsigned __int16 *)((char *)&d.msg_callback_arg + 1))
          || (*((_BYTE *)this + 1600) & 1) != 0
          && (!CBB_add_u16((uint64_t)&d.sid_ctx[13], 0xFE0Du)
           || !CBB_add_u16((uint64_t)&d.sid_ctx[13], 8u)
           || !CBB_add_zeros((uint64_t)&d.sid_ctx[13], 8uLL)))
        {
          v6 = 0;
          goto LABEL_306;
        }
        *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = 0;
        *(void **)((char *)&d.tlsext_debug_arg + 1) = 0;
        if (((*(uint64_t (**)(uint64_t, char *, char *))(*(_QWORD *)v21 + 96))(v21, (char *)&d.version + 1, (char *)&d.tlsext_debug_cb + 1) & 1) == 0)goto LABEL_347;
        if ((*((_BYTE *)this + 1600) & 1) != 0)
        {
          if (*(void **)((char *)&d.tlsext_debug_arg + 1) <= (void *)7)
            abort();
          if (!bssl::ssl_ech_accept_confirmation((int)this, *(_DWORD *)((char *)&d.tlsext_debug_arg + 1) - 8 + *(_DWORD *)((char *)&d.tlsext_debug_cb + 1), 8, *(_QWORD *)(v21 + 48) + 48, 32, (bssl::SSLTranscript *)v172, 1, v26, *(char **)((char *)&d.tlsext_debug_cb + 1), *(unint64_t *)((char *)&d.tlsext_debug_arg + 1), *(unint64_t *)((char *)&d.tlsext_debug_arg + 1) - 8))goto LABEL_347;
        }
        v27 = *(unsigned int (**)(uint64_t, char *))(*(_QWORD *)v21 + 104);
        *(const EVP_MD **)((char *)&d.read_hash + 1) = 0;
        *(COMP_CTX **)((char *)&d.expand + 1) = 0;
        OPENSSL_free(0);
        *(const EVP_MD **)((char *)&d.read_hash + 1) = *(const EVP_MD **)((char *)&d.tlsext_debug_cb + 1);
        *(COMP_CTX **)((char *)&d.expand + 1) = *(COMP_CTX **)((char *)&d.tlsext_debug_arg + 1);
        *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = 0;
        *(void **)((char *)&d.tlsext_debug_arg + 1) = 0;
        if (v27(v21, (char *)&d.read_hash + 1))
        {
          v28 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v21 + 112))(v21);
          OPENSSL_free(*(_QWORD **)((char *)&d.read_hash + 1));
          *(const EVP_MD **)((char *)&d.read_hash + 1) = 0;
          *(COMP_CTX **)((char *)&d.expand + 1) = 0;
          if ((v28 & 1) != 0)
          {
            *(_WORD *)(*(_QWORD *)(v21 + 48) + 220) |= 0x4000u;
            *((_DWORD *)this + 6) = 3;
            v6 = 4;
          }
          else
          {
LABEL_347:
            v6 = 0;
          }
        }
        else
        {
          OPENSSL_free(*(_QWORD **)((char *)&d.read_hash + 1));
          v6 = 0;
          *(const EVP_MD **)((char *)&d.read_hash + 1) = 0;
          *(COMP_CTX **)((char *)&d.expand + 1) = 0;
        }
        OPENSSL_free(*(_QWORD **)((char *)&d.tlsext_debug_cb + 1));
LABEL_306:
        CBB_cleanup((uint64_t)&d.version + 1);
        goto LABEL_366;
      case 3:
        v53 = *(bssl **)this;
        *(unint64_t *)((char *)&d.options + 1) = 0xAAAAAAAAAAAAAAAALL;
        v54.sk = (STACK *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v54.dummy = 0xAAAAAAAAAAAAAAAALL;
        *(CRYPTO_EX_DATA *)((char *)&d.ex_data + 1) = v54;
        *(CRYPTO_EX_DATA *)((char *)&d.client_CA + 1) = v54;
        if (!(*(unsigned int (**)(bssl *, char *))(*(_QWORD *)v53 + 24))(v53, (char *)&d.ex_data.sk + 1))
          goto LABEL_184;
        if (!bssl::ssl_check_message_type(v53, (uint64_t)&d.ex_data.sk + 1, 1))
          goto LABEL_365;
        *(_QWORD *)&v55 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v55 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.init_buf + 1) = v55;
        *(_OWORD *)((char *)&d.init_num + 1) = v55;
        *(_OWORD *)((char *)&d.handshake_func + 1) = v55;
        *(_OWORD *)((char *)&d.quiet_shutdown + 1) = v55;
        *(_OWORD *)((char *)&d.rbio + 1) = v55;
        *(_OWORD *)((char *)&d.bbio + 1) = v55;
        *(_OWORD *)((char *)&d.version + 1) = v55;
        if ((bssl::ssl_client_hello_init((uint64_t)v53, (uint64_t)&d.version + 1, *(unsigned __int16 **)((char *)&d.ex_data.dummy + 1), *(unsigned __int16 **)((char *)&d.client_CA + 1)) & 1) == 0)
        {
          ERR_put_error(16, 0, 131, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 639);
          bssl::ssl_send_alert(v53, (ssl_st *)2, 50);
          goto LABEL_365;
        }
        v56 = *((_QWORD *)v53 + 6);
        if (*(_DWORD *)(v56 + 216) != 1)
          goto LABEL_353;
        *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = (int (__cdecl *)(int, X509_STORE_CTX *))0xAAAAAAAAAAAAAAAALL;
        *(void (__cdecl **)(const SSL *, int, int))((char *)&d.info_callback + 1) = (void (__cdecl *)(const SSL *, int, int))0xAAAAAAAAAAAAAAAALL;
        if ((bssl::ssl_client_hello_get_extension((uint64_t)&d.version + 1, (int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1), 65037) & 1) == 0)
        {
          ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 650);
          bssl::ssl_send_alert(v53, (ssl_st *)2, 109);
          goto LABEL_365;
        }
        *(_WORD *)((char *)&d.read_hash + 1) = -21846;
        *(_WORD *)((char *)&d.msg_callback_arg + 1) = -21846;
        BYTE1(d.packet_length) = -86;
        BYTE1(d.max_cert_list) = -86;
        *(_QWORD *)&d.sid_ctx[13] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&d.sid_ctx[21] = 0xAAAAAAAAAAAAAAAALL;
        *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = (void (__cdecl *)(SSL *, int, int, unsigned __int8 *, int, void *))0xAAAAAAAAAAAAAAAALL;
        *(void **)((char *)&d.tlsext_debug_arg + 1) = (void *)0xAAAAAAAAAAAAAAAALL;
        u8 = CBS_get_u8((int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1), (_BYTE *)&d.packet_length + 1);
        v58 = 50;
        v59 = 665;
        if (!u8 || BYTE1(d.packet_length))
          goto LABEL_107;
        if (!CBS_get_u16((unsigned __int16 **)((char *)&d.verify_callback + 1), (const EVP_MD **)((char *)&d.read_hash + 1))|| !CBS_get_u16((unsigned __int16 **)((char *)&d.verify_callback + 1), (void **)((char *)&d.msg_callback_arg + 1))|| !CBS_get_u8((int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1), (_BYTE *)&d.max_cert_list + 1)|| !CBS_get_u16_length_prefixed((unsigned __int8 **)((char *)&d.verify_callback + 1), (unint64_t *)&d.sid_ctx[13])|| !CBS_get_u16_length_prefixed((unsigned __int8 **)((char *)&d.verify_callback + 1), (unint64_t *)((char *)&d.tlsext_debug_cb + 1))|| CBS_len((uint64_t)&d.verify_callback + 1))
        {
          v59 = 665;
LABEL_107:
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", v59);
          bssl::ssl_send_alert(v53, (ssl_st *)2, v58);
          goto LABEL_365;
        }
        v109 = *(unsigned __int16 *)((char *)&d.read_hash + 1);
        v110 = (unsigned __int16 *)RSA_get0_e(v165);
        if (v109 != EVP_HPKE_KDF_id(v110)
          || (v111 = *(unsigned __int16 *)((char *)&d.msg_callback_arg + 1),
              v112 = (unsigned __int16 *)RSA_get0_n((uint64_t)v165),
              v111 != EVP_HPKE_KDF_id(v112))
          || BYTE1(d.max_cert_list) != *((unsigned __int8 *)this + 1610)
          || CBS_len((uint64_t)&d.sid_ctx[13]))
        {
          v58 = 47;
          v59 = 674;
          goto LABEL_107;
        }
        BYTE1(d.sid_ctx_length) = 50;
        LOBYTE(d.version) = -86;
        if ((bssl::ssl_client_hello_decrypt((uint64_t *)this, (_BYTE *)&d.sid_ctx_length + 1, &d, v166, (int *)((char *)&d.version + 1), *(char **)((char *)&d.tlsext_debug_cb + 1), *(unint64_t *)((char *)&d.tlsext_debug_arg + 1)) & 1) == 0)
        {
          ERR_put_error(16, 0, 138, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 686);
          bssl::ssl_send_alert(v53, (ssl_st *)2, BYTE1(d.sid_ctx_length));
          goto LABEL_365;
        }
        if ((bssl::SSL_HANDSHAKE::GetClientHello((uint64_t *)this, (uint64_t)&d.ex_data.sk + 1, (uint64_t)&d.version + 1) & 1) == 0)
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 693);
          goto LABEL_365;
        }
        v56 = *((_QWORD *)v53 + 6);
LABEL_353:
        if ((*(_WORD *)(v56 + 220) & 0x40) != 0)
        {
          *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = (int (__cdecl *)(int, X509_STORE_CTX *))0xAAAAAAAAAAAAAAAALL;
          *(void (__cdecl **)(const SSL *, int, int))((char *)&d.info_callback + 1) = (void (__cdecl *)(const SSL *, int, int))0xAAAAAAAAAAAAAAAALL;
          if ((bssl::ssl_client_hello_get_extension((uint64_t)&d.version + 1, (int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1), 41) & 1) == 0)
          {
            ERR_put_error(16, 0, 303, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 709);
            bssl::ssl_send_alert(v53, (ssl_st *)2, 47);
            goto LABEL_365;
          }
          *(_QWORD *)&d.sid_ctx[13] = 0xAAAAAAAAAAAAAAAALL;
          *(_QWORD *)&d.sid_ctx[21] = 0xAAAAAAAAAAAAAAAALL;
          *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = (void (__cdecl *)(SSL *, int, int, unsigned __int8 *, int, void *))0xAAAAAAAAAAAAAAAALL;
          *(void **)((char *)&d.tlsext_debug_arg + 1) = (void *)0xAAAAAAAAAAAAAAAALL;
          *(_DWORD *)((char *)&d.read_hash + 1) = -1431655766;
          BYTE1(d.msg_callback_arg) = 50;
          if ((bssl::ssl_ext_pre_shared_key_parse_clienthello((uint64_t)this, (unint64_t *)&d.sid_ctx[13], (void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1), (int *)((char *)&d.read_hash + 1), (char *)&d.msg_callback_arg + 1, (uint64_t)&d.version + 1, (unsigned __int8 **)((char *)&d.verify_callback + 1)) & 1) == 0)
          {
            v154 = BYTE1(d.msg_callback_arg);
            goto LABEL_364;
          }
          if ((bssl::tls13_verify_psk_binder((uint64_t)this, *((bssl **)this + 192), (uint64_t)&d.ex_data.sk + 1, (unsigned __int8 **)((char *)&d.tlsext_debug_cb + 1)) & 1) == 0)
          {
            v154 = 51;
LABEL_364:
            bssl::ssl_send_alert(v53, (ssl_st *)2, v154);
            goto LABEL_365;
          }
        }
        if (!bssl::resolve_ecdhe_secret((uint64_t)this, (uint64_t)&d.version + 1)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.ex_data.sk + 1))
        {
          goto LABEL_365;
        }
        if ((*(unsigned int (**)(bssl *))(*(_QWORD *)v53 + 40))(v53))
        {
          bssl::ssl_send_alert(v53, (ssl_st *)2, 10);
          ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 744);
          goto LABEL_365;
        }
        (*(void (**)(bssl *))(*(_QWORD *)v53 + 32))(v53);
        OPENSSL_free(*((_QWORD **)this + 75));
        *v166 = 0;
        v166[1] = 0;
        *((_DWORD *)this + 6) = 4;
        goto LABEL_366;
      case 4:
        v47 = *(unsigned __int8 ***)this;
        v48 = *(_QWORD *)(*(_QWORD *)this + 48);
        v49 = (_OWORD *)(v48 + 16);
        v50 = *((_QWORD *)this + 199);
        if (v50)
        {
          if ((*((_BYTE *)this + 1602) & 0x10) != 0 || *(_QWORD *)(v50 + 24) != 32)
          {
            RAND_bytes((unsigned __int8 *)(v48 + 16), 32);
            if ((*((_BYTE *)this + 1602) & 0x10) != 0)
            {
              v70 = (_QWORD *)(v50 + 16);
              if (!bssl::Array<unsigned char>::Init((uint64_t)v70, 0x20uLL))
                goto LABEL_365;
              v71 = (_OWORD *)*v70;
              v72 = *(_OWORD *)(v48 + 32);
              *v71 = *v49;
              v71[1] = v72;
            }
          }
          else
          {
            v51 = *(_OWORD **)(v50 + 16);
            v52 = v51[1];
            *v49 = *v51;
            *(_OWORD *)(v48 + 32) = v52;
          }
        }
        else
        {
          RAND_bytes((unsigned __int8 *)(v48 + 16), 32);
        }
        *(uint64_t *)((char *)&d.max_cert_list + 1) = 0;
        *(_QWORD *)((char *)&d.first_packet + 1) = 0;
        v73.sk = (STACK *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v73.dummy = 0xAAAAAAAAAAAAAAAALL;
        *(CRYPTO_EX_DATA *)((char *)&d.client_CA + 1) = v73;
        *(CRYPTO_EX_DATA *)((char *)&d.options + 1) = v73;
        *(CRYPTO_EX_DATA *)((char *)&d.ex_data + 1) = v73;
        CBB_zero((STACK **)((char *)&d.ex_data.sk + 1));
        *(_QWORD *)&v74 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v74 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.error + 1) = v74;
        *(_OWORD *)((char *)&d.debug + 1) = v74;
        *(_OWORD *)((char *)&d.generate_session_id + 1) = v74;
        *(_OWORD *)((char *)&d.verify_callback + 1) = v74;
        *(_OWORD *)&d.sid_ctx[13] = v74;
        *(_OWORD *)&d.sid_ctx[29] = v74;
        *(_OWORD *)((char *)&d.tlsext_hostname + 1) = v74;
        *(_OWORD *)((char *)&d.tlsext_status_expected + 1) = v74;
        *(_OWORD *)((char *)&d.tlsext_debug_cb + 1) = v74;
        if (!(*((unsigned int (**)(unsigned __int8 **, char *, char *, uint64_t))*v47 + 11))(v47, (char *)&d.ex_data.sk + 1, (char *)&d.verify_callback + 1, 2))goto LABEL_398;
        if (!CBB_add_u16((uint64_t)&d.verify_callback + 1, 0x303u))
          goto LABEL_398;
        if (!CBB_add_bytes((uint64_t)&d.verify_callback + 1, v47[6] + 16, 0x20uLL))
          goto LABEL_398;
        if (!CBB_add_u8_length_prefixed((uint64_t *)((char *)&d.verify_callback + 1), (uint64_t)&d.tlsext_debug_cb + 1))goto LABEL_398;
        if (!CBB_add_bytes((uint64_t)&d.tlsext_debug_cb + 1, __dst, *((unsigned __int8 *)this + 1643)))
          goto LABEL_398;
        v75 = SSL_CIPHER_get_protocol_id(*((_QWORD *)this + 196));
        if (!CBB_add_u16((uint64_t)&d.verify_callback + 1, v75))
          goto LABEL_398;
        if (!CBB_add_u8((uint64_t)&d.verify_callback + 1, 0))
          goto LABEL_398;
        if (!CBB_add_u16_length_prefixed((uint64_t *)((char *)&d.verify_callback + 1), (uint64_t)&d.sid_ctx[13]))goto LABEL_398;
        if (!bssl::ssl_ext_pre_shared_key_add_serverhello((uint64_t)this, (uint64_t *)&d.sid_ctx[13]))
          goto LABEL_398;
        if (!bssl::ssl_ext_key_share_add_serverhello((uint64_t)this, (uint64_t *)&d.sid_ctx[13]))
          goto LABEL_398;
        if (!CBB_add_u16((uint64_t)&d.sid_ctx[13], 0x2Bu))
          goto LABEL_398;
        *(_QWORD *)&v76 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v76 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.rbio + 1) = v76;
        *(_OWORD *)((char *)&d.bbio + 1) = v76;
        *(_OWORD *)((char *)&d.version + 1) = v76;
        if (!CBB_add_u16_length_prefixed((uint64_t *)&d.sid_ctx[13], (uint64_t)&d.version + 1)
          || !CBB_add_u16((uint64_t)&d.version + 1, *(unsigned __int16 *)(*(_QWORD *)this + 16))
          || !CBB_flush((uint64_t *)&d.sid_ctx[13])
          || ((*((uint64_t (**)(unsigned __int8 **, char *, char *))*v47 + 12))(v47, (char *)&d.ex_data.sk + 1, (char *)&d.max_cert_list + 1) & 1) == 0)
        {
          goto LABEL_398;
        }
        v78 = *((_DWORD *)this + 400);
        if (*((_DWORD *)v47[6] + 54) == 1)
        {
          if ((v78 & 1) == 0)
            __assert_rtn("do_send_server_hello", "tls13_server.cc", 791, "ssl->s3->ech_status != ssl_ech_accepted || hs->ech_is_inner");
        }
        else if ((v78 & 1) == 0)
        {
          goto LABEL_281;
        }
        v113 = bssl::ssl_ech_confirmation_signal_hello_offset(v47, v77);
        if (!bssl::ssl_ech_accept_confirmation((int)this, v48 + 40, 8, *((_DWORD *)v47 + 12) + 48, 32, (bssl::SSLTranscript *)v172, 0, v114, *(char **)((char *)&d.max_cert_list + 1), *(unint64_t *)((char *)&d.first_packet + 1), v113))goto LABEL_398;
        if (*(_QWORD *)((char *)&d.first_packet + 1) < v113)
          abort();
        *(_QWORD *)(*(uint64_t *)((char *)&d.max_cert_list + 1) + v113) = *(_QWORD *)(v48 + 40);
LABEL_281:
        v115 = (uint64_t (*)(unsigned __int8 **, char *))*((_QWORD *)*v47 + 13);
        *(_QWORD *)((char *)&d.sid_ctx_length + 1) = 0;
        *(_QWORD *)&d.sid_ctx[5] = 0;
        OPENSSL_free(0);
        *(_QWORD *)((char *)&d.sid_ctx_length + 1) = *(uint64_t *)((char *)&d.max_cert_list + 1);
        *(_QWORD *)&d.sid_ctx[5] = *(_QWORD *)((char *)&d.first_packet + 1);
        *(uint64_t *)((char *)&d.max_cert_list + 1) = 0;
        *(_QWORD *)((char *)&d.first_packet + 1) = 0;
        LOBYTE(v115) = v115(v47, (char *)&d.sid_ctx_length + 1);
        OPENSSL_free(*(_QWORD **)((char *)&d.sid_ctx_length + 1));
        *(_QWORD *)((char *)&d.sid_ctx_length + 1) = 0;
        *(_QWORD *)&d.sid_ctx[5] = 0;
        if ((v115 & 1) == 0)
          goto LABEL_398;
        OPENSSL_free(*(_QWORD **)v164);
        *(_QWORD *)v164 = 0;
        *((_QWORD *)v164 + 1) = 0;
        if ((v47[6][221] & 0x40) == 0 && !(*((unsigned int (**)(unsigned __int8 **))*v47 + 14))(v47))
          goto LABEL_398;
        if (!bssl::tls13_derive_handshake_secrets(this, v116)
          || (bssl::tls13_set_traffic_key((uint64_t)v47, (const ssl_session_st *)2, 1, *((bssl **)this + 192), v163, *((_QWORD *)this + 4)) & 1) == 0|| !(*((unsigned int (**)(unsigned __int8 **, char *, char *, uint64_t))*v47 + 11))(v47, (char *)&d.ex_data.sk + 1, (char *)&d.verify_callback + 1, 8)|| !bssl::ssl_add_serverhello_tlsext((uint64_t)this, (uint64_t *)((char *)&d.verify_callback + 1))|| !bssl::ssl_add_message_cbb((uint64_t)v47, (uint64_t)&d.ex_data.sk + 1))
        {
          goto LABEL_398;
        }
        v118 = *((_DWORD *)this + 400);
        if ((*((_WORD *)v47[6] + 110) & 0x40) == 0)
        {
          v119 = *((_QWORD *)this + 1);
          v120 = v118 & 0xFFFFFFDF;
          v10 = (v118 & 0x4000000) == 0;
          v118 = v118 & 0xFFFFFFDF | (32 * (*(_BYTE *)(v119 + 312) & 1));
          *((_DWORD *)this + 400) = v118;
          v121 = *(_BYTE *)(v119 + 312) & 4;
          if (!v10 && v121 != 0)
            v118 = v120;
          *((_DWORD *)this + 400) = v118;
        }
        if ((v118 & 0x20) != 0)
        {
          *(_QWORD *)&v158 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v158 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)((char *)&d.rbio + 1) = v158;
          *(_OWORD *)((char *)&d.bbio + 1) = v158;
          *(_OWORD *)((char *)&d.version + 1) = v158;
          *(_OWORD *)((char *)&d.enc_write_ctx + 1) = v158;
          *(_OWORD *)((char *)&d.compress + 1) = v158;
          *(_OWORD *)((char *)&d.cipher_list_by_id + 1) = v158;
          *(_OWORD *)((char *)&d.read_hash + 1) = v158;
          *(_OWORD *)((char *)&d.msg_callback_arg + 1) = v158;
          *(_OWORD *)((char *)&d.param + 1) = v158;
          if (!(*((unsigned int (**)(unsigned __int8 **, char *, char *, uint64_t))*v47 + 11))(v47, (char *)&d.ex_data.sk + 1, (char *)&d.verify_callback + 1, 13))goto LABEL_398;
          if (!CBB_add_u8((uint64_t)&d.verify_callback + 1, 0))
            goto LABEL_398;
          if (!CBB_add_u16_length_prefixed((uint64_t *)((char *)&d.verify_callback + 1), (uint64_t)&d.version + 1))goto LABEL_398;
          if (!CBB_add_u16((uint64_t)&d.version + 1, 0xDu))
            goto LABEL_398;
          if (!CBB_add_u16_length_prefixed((uint64_t *)((char *)&d.version + 1), (uint64_t)&d.read_hash + 1))goto LABEL_398;
          if (!CBB_add_u16_length_prefixed((uint64_t *)((char *)&d.read_hash + 1), (uint64_t)&d.msg_callback_arg + 1))goto LABEL_398;
          if (!bssl::tls12_add_verify_sigalgs((uint64_t)this, (uint64_t)&d.msg_callback_arg + 1))
            goto LABEL_398;
          if (bssl::ssl_has_client_CAs(*((bssl **)this + 1), v159))
          {
            *(_QWORD *)&v160 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v160 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)((char *)&d.s3 + 1) = v160;
            *(_OWORD *)((char *)&d.read_ahead + 1) = v160;
            *(_OWORD *)((char *)&d.packet_length + 1) = v160;
            if (!CBB_add_u16((uint64_t)&d.version + 1, 0x2Fu)
              || !CBB_add_u16_length_prefixed((uint64_t *)((char *)&d.version + 1), (uint64_t)&d.packet_length + 1)|| !bssl::ssl_add_client_CA_list(this, (uint64_t *)((char *)&d.packet_length + 1))|| !CBB_flush((uint64_t *)((char *)&d.version + 1)))
            {
              goto LABEL_398;
            }
          }
          if ((bssl::ssl_add_message_cbb((uint64_t)v47, (uint64_t)&d.ex_data.sk + 1) & 1) == 0)
            goto LABEL_398;
        }
        if ((*((_WORD *)v47[6] + 110) & 0x40) != 0)
        {
          v127 = 6;
LABEL_401:
          *((_DWORD *)this + 6) = v127;
          goto LABEL_399;
        }
        if (bssl::ssl_has_certificate(this, v117)
          || bssl::ssl_has_server_raw_public_key_certificate(this, (const ssl_st *)v123))
        {
          if (!bssl::tls13_add_certificate(this, v123, v124, v125, v126))
          {
LABEL_398:
            v6 = 0;
            goto LABEL_399;
          }
          v127 = 5;
          goto LABEL_401;
        }
        ERR_put_error(16, 0, 174, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 882);
        v6 = 0;
LABEL_399:
        CBB_cleanup((uint64_t)&d.ex_data.sk + 1);
        OPENSSL_free(*(_QWORD **)((char *)&d.max_cert_list + 1));
        goto LABEL_366;
      case 5:
        v39 = bssl::tls13_add_certificate_verify((EVP_PKEY **)this, a2);
        if (v39)
        {
          if (v39 == 2)
            goto LABEL_365;
          if (v39 != 1)
            bssl::tls13_server_handshake();
          v6 = 9;
          v17 = 5;
        }
        else
        {
          v17 = 6;
        }
        goto LABEL_175;
      case 6:
        v40 = *((_DWORD *)this + 400);
        if ((v40 & 0x100000) != 0)
        {
LABEL_77:
          v6 = 17;
          goto LABEL_366;
        }
        v41 = *(_QWORD *)this;
        *((_DWORD *)this + 400) = v40 | 0x2000000;
        if (!bssl::tls13_add_finished((bssl **)this, a2))
          goto LABEL_365;
        bssl::SSLTranscript::DigestLen((bssl::SSLTranscript *)v172);
        if (!bssl::tls13_advance_key_schedule((uint64_t)this)
          || !bssl::tls13_derive_application_secrets(this, a2)
          || !bssl::tls13_set_traffic_key(v41, (const ssl_session_st *)3, 1, *((bssl **)this + 192), v167, *((_QWORD *)this + 4)))
        {
          goto LABEL_365;
        }
        *((_DWORD *)this + 6) = 7;
        if ((*((_BYTE *)this + 1602) & 8) != 0)
          v6 = 7;
        else
          v6 = 1;
        goto LABEL_366;
      case 7:
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x800) == 0)
          goto LABEL_28;
        if (*(_QWORD *)(*(_QWORD *)this + 168)
          || (bssl::SSLTranscript::Update(v172, &bssl::do_send_half_rtt_ticket(bssl::SSL_HANDSHAKE *)::kEndOfEarlyData, 4uLL) & 1) != 0)
        {
          *(_QWORD *)((char *)&d.version + 1) = 0xAAAAAAAAAAAAAAAALL;
          if (bssl::tls13_finished_mac(this, v170, (unsigned __int8 *)&d.version + 1, 0))
          {
            if (*(_QWORD *)((char *)&d.version + 1) == *((_QWORD *)this + 4))
            {
              if (SSL_is_dtls(*(unsigned __int8 ***)this))
                bssl::tls13_server_handshake();
              v67 = *((_QWORD *)this + 4);
              if (v67 >= 0x100)
                bssl::tls13_server_handshake();
              *(_WORD *)((char *)&d.ex_data.sk + 1) = 20;
              BYTE3(d.ex_data.sk) = 0;
              BYTE4(d.ex_data.sk) = v67;
              if (bssl::SSLTranscript::Update(v172, (char *)&d.ex_data.sk + 1, 4uLL)
                && bssl::SSLTranscript::Update(v172, v170, *((_QWORD *)this + 4))
                && bssl::tls13_derive_resumption_secret(this, a2)
                && (bssl::add_new_session_tickets((ssl_st **)this, (bssl::SSL_HANDSHAKE *)((char *)&d.verify_callback + 1), (BOOL *)a3) & 1) != 0)
              {
LABEL_28:
                *((_DWORD *)this + 6) = 8;
                v6 = 4;
                goto LABEL_366;
              }
            }
            else
            {
              ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 961);
            }
          }
        }
        else
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 950);
        }
        goto LABEL_365;
      case 8:
        v45 = *(_QWORD *)this;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x800) == 0)
          goto LABEL_86;
        if (!bssl::tls13_set_traffic_key(*(_QWORD *)this, (const ssl_session_st *)1, 0, *((bssl **)this + 192), v171, *((_QWORD *)this + 4)))goto LABEL_365;
        *((_DWORD *)this + 400) |= 0x6800u;
LABEL_86:
        if (*(_QWORD *)(v45 + 168))
        {
          if (!bssl::tls13_set_traffic_key(v45, (const ssl_session_st *)2, 0, *((bssl **)this + 192), v173, *((_QWORD *)this + 4)))goto LABEL_365;
          v46 = 12;
        }
        else
        {
          v46 = 14;
        }
        *((_DWORD *)this + 6) = 9;
        if ((*(_WORD *)(*(_QWORD *)(v45 + 48) + 220) & 0x800) != 0)
          v6 = v46;
        else
          v6 = 1;
        goto LABEL_366;
      case 9:
        v20 = *(bssl **)this;
        if (*(_QWORD *)(*(_QWORD *)this + 168))
          goto LABEL_26;
        if ((*(_WORD *)(*((_QWORD *)v20 + 6) + 220) & 0x800) == 0)
          goto LABEL_153;
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v79 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v79 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v79;
        *(_OWORD *)((char *)&d.rbio + 1) = v79;
        if (!(*(unsigned int (**)(bssl *, char *))(*(_QWORD *)v20 + 24))(v20, (char *)&d.version + 1))
          goto LABEL_184;
        if (!bssl::ssl_check_message_type(v20, (uint64_t)&d.version + 1, 5))
          goto LABEL_365;
        if (CBS_len((uint64_t)&d.method + 1))
        {
          bssl::ssl_send_alert(v20, (ssl_st *)2, 50);
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 1034);
        }
        else
        {
          (*(void (**)(bssl *))(*(_QWORD *)v20 + 32))(v20);
LABEL_153:
          if (bssl::tls13_set_traffic_key((uint64_t)v20, (const ssl_session_st *)2, 0, *((bssl **)this + 192), v173, *((_QWORD *)this + 4)))
          {
LABEL_26:
            v17 = 10;
            goto LABEL_175;
          }
        }
        goto LABEL_365;
      case 10:
        if ((*(_BYTE *)(*((_QWORD *)this + 192) + 448) & 0x40) == 0)
          goto LABEL_216;
        v18 = *(bssl **)this;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x800) != 0)
          goto LABEL_216;
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v19 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v19;
        *(_OWORD *)((char *)&d.rbio + 1) = v19;
        if (!(*(unsigned int (**)(bssl *, char *))(*(_QWORD *)v18 + 24))(v18, (char *)&d.version + 1))
          goto LABEL_184;
        if (!bssl::ssl_check_message_type(v18, (uint64_t)&d.version + 1, 8))
          goto LABEL_365;
        *(_OWORD *)((char *)&d.verify_callback + 1) = *(_OWORD *)((char *)&d.method + 1);
        *(_QWORD *)&d.sid_ctx[13] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&d.sid_ctx[21] = 0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_u16_length_prefixed((unsigned __int8 **)((char *)&d.verify_callback + 1), (unint64_t *)&d.sid_ctx[13])|| CBS_len((uint64_t)&d.verify_callback + 1))
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 1067);
          bssl::ssl_send_alert(v18, (ssl_st *)2, 50);
          goto LABEL_365;
        }
        *(_QWORD *)((char *)&d.ex_data.dummy + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(STACK **)((char *)&d.client_CA + 1) = (STACK *)0xAAAAAAAAAAAAAAAALL;
        *(STACK **)((char *)&d.ex_data.sk + 1) = (STACK *)0xAAAAAAAA00014469;
        CBS_init((int *)((char *)&d.ex_data.dummy + 1), 0, 0);
        BYTE1(d.read_hash) = 50;
        *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = (void (__cdecl *)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.ex_data.sk + 1);
        if ((bssl::ssl_parse_extensions((__int128 *)&d.sid_ctx[13], (char *)&d.read_hash + 1, (uint64_t *)((char *)&d.tlsext_debug_cb + 1), 1, 0) & 1) == 0)
        {
          v90 = BYTE1(d.read_hash);
LABEL_250:
          bssl::ssl_send_alert(v18, (ssl_st *)2, v90);
          goto LABEL_365;
        }
        if (!BYTE4(d.ex_data.sk))
        {
          ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 1081);
          v90 = 109;
          goto LABEL_250;
        }
        v83 = (void **)&(*v4)[1].sess_cert;
        v84 = *(const void **)((char *)&d.ex_data.dummy + 1);
        v85 = *(size_t *)((char *)&d.client_CA + 1);
        v86 = bssl::Array<unsigned char>::Init((uint64_t)v83, *(unint64_t *)((char *)&d.client_CA + 1));
        v87 = v86 ^ 1;
        if (!v85)
          v87 = 1;
        if ((v87 & 1) == 0)
          memcpy(*v83, v84, v85);
        if (!v86 || (bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.version + 1) & 1) == 0)
        {
          v90 = 80;
          goto LABEL_250;
        }
        (*(void (**)(bssl *))(*(_QWORD *)v18 + 32))(v18);
LABEL_216:
        *((_DWORD *)this + 6) = 11;
        v6 = 1;
        goto LABEL_366;
      case 11:
        v60 = *(bssl **)this;
        if ((*((_BYTE *)this + 1600) & 0x20) == 0)
        {
          if ((*(_WORD *)(*((_QWORD *)v60 + 6) + 220) & 0x40) == 0)
            (*v4)->time = 0;
          goto LABEL_111;
        }
        v68 = *(_BYTE *)(*((_QWORD *)this + 1) + 312);
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v69 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v69 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v69;
        *(_OWORD *)((char *)&d.rbio + 1) = v69;
        if (!(*(unsigned int (**)(bssl *, char *))(*(_QWORD *)v60 + 24))(v60, (char *)&d.version + 1))
        {
LABEL_184:
          v6 = 3;
          goto LABEL_366;
        }
        if (bssl::ssl_check_message_type(v60, (uint64_t)&d.version + 1, 11)
          && bssl::tls13_process_certificate((uint64_t *)this, (uint64_t)&d.version + 1, (v68 & 2) == 0)
          && bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.version + 1))
        {
          (*(void (**)(bssl *))(*(_QWORD *)v60 + 32))(v60);
          goto LABEL_148;
        }
        goto LABEL_365;
      case 12:
        v42 = *(bssl **)this;
        if (!sk_num(*(const STACK **)(*((_QWORD *)this + 192) + 144)))
          goto LABEL_111;
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v43 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v43 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v43;
        *(_OWORD *)((char *)&d.rbio + 1) = v43;
        if (!(*(unsigned int (**)(bssl *, char *))(*(_QWORD *)v42 + 24))(v42, (char *)&d.version + 1))
          goto LABEL_184;
        v44 = bssl::ssl_verify_peer_cert(this, a2);
        if (v44 == 1)
          goto LABEL_365;
        if (v44 == 2)
        {
          v6 = 16;
LABEL_148:
          v17 = 12;
LABEL_175:
          *((_DWORD *)this + 6) = v17;
          goto LABEL_366;
        }
        if (bssl::ssl_check_message_type(v42, (uint64_t)&d.version + 1, 15)
          && bssl::tls13_process_certificate_verify((uint64_t)this, (uint64_t)&d.version + 1)
          && bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.version + 1))
        {
          (*(void (**)(bssl *))(*(_QWORD *)v42 + 32))(v42);
LABEL_111:
          v17 = 13;
          goto LABEL_175;
        }
        goto LABEL_365;
      case 13:
        if ((*((_BYTE *)this + 1603) & 4) == 0)
          goto LABEL_17;
        v65 = *(bssl **)this;
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v66 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v66 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v66;
        *(_OWORD *)((char *)&d.rbio + 1) = v66;
        if (!(*(unsigned int (**)(bssl *, char *))(*(_QWORD *)v65 + 24))(v65, (char *)&d.version + 1))
          goto LABEL_184;
        if (!bssl::ssl_check_message_type(v65, (uint64_t)&d.version + 1, 203)
          || !bssl::tls1_verify_channel_id((bssl **)this, (uint64_t)&d.version + 1)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.version + 1))
        {
          goto LABEL_365;
        }
        (*(void (**)(bssl *))(*(_QWORD *)v65 + 32))(v65);
LABEL_17:
        v17 = 14;
        goto LABEL_175;
      case 14:
        v62 = *(bssl **)this;
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v63 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v63 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v63;
        *(_OWORD *)((char *)&d.rbio + 1) = v63;
        if (!(*(unsigned int (**)(bssl *, char *))(*(_QWORD *)v62 + 24))(v62, (char *)&d.version + 1))
          goto LABEL_184;
        if (!bssl::ssl_check_message_type(v62, (uint64_t)&d.version + 1, 20)
          || !bssl::tls13_process_finished((char *)this, (uint64_t)&d.version + 1, (*(unsigned __int16 *)(*((_QWORD *)v62 + 6) + 220) >> 11) & 1)|| !bssl::tls13_set_traffic_key((uint64_t)v62, (const ssl_session_st *)3, 0, *((bssl **)this + 192), v168, *((_QWORD *)this + 4)))
        {
          goto LABEL_365;
        }
        if ((*(_WORD *)(*((_QWORD *)v62 + 6) + 220) & 0x800) != 0)
        {
          v64 = 16;
          goto LABEL_204;
        }
        if (bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.version + 1)
          && bssl::tls13_derive_resumption_secret(this, a2))
        {
          v64 = 15;
LABEL_204:
          *((_DWORD *)this + 6) = v64;
          (*(void (**)(bssl *))(*(_QWORD *)v62 + 32))(v62);
          goto LABEL_366;
        }
LABEL_365:
        v6 = 0;
        goto LABEL_366;
      case 15:
        BYTE1(d.version) = -86;
        if (!bssl::add_new_session_tickets((ssl_st **)this, (bssl::SSL_HANDSHAKE *)((char *)&d.version + 1), (BOOL *)a3))goto LABEL_365;
        *((_DWORD *)this + 6) = 16;
        if (BYTE1(d.version))
          v61 = *(_QWORD *)(*(_QWORD *)this + 168) == 0;
        else
          v61 = 1;
        if (v61)
          v6 = 1;
        else
          v6 = 4;
        goto LABEL_366;
      case 16:
        return v6;
      default:
        goto LABEL_365;
    }
  }
}

void sub_1B4FBED00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,SSL_SESSION *ses)
{
  uint64_t v41;

  OPENSSL_free(*(_QWORD **)(v41 + 96));
  *(_QWORD *)(v41 + 96) = 0;
  *(_QWORD *)(v41 + 104) = 0;
  OPENSSL_free(*(_QWORD **)(v41 + 320));
  CBB_cleanup((uint64_t)&a27);
  _Unwind_Resume(a1);
}

uint64_t bssl::tls13_server_handshake_int_state(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  return (4 * *((_DWORD *)this + 6)) | 0x2B291800u;
}

const char *bssl::tls13_server_handshake_state(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2;

  v2 = *((int *)this + 6);
  if (v2 > 0x10)
    return "TLS 1.3 server unknown";
  else
    return off_1E686E9E8[v2];
}

uint64_t bssl::resolve_ecdhe_secret(uint64_t a1, uint64_t a2)
{
  bssl *v3;
  _QWORD *v4;
  uint64_t v5;
  const void *v6;
  unint64_t v7;
  int v8;
  char v9;
  const void *v10;
  unint64_t v11;
  char v12;
  char v13;
  __int128 v14;
  uint64_t v15;
  int v16;
  const void *v18;
  unint64_t v19;
  int v20;
  char v21;
  void *v22;
  size_t v23;
  char v24;
  char v25;
  _QWORD *v26;
  _OWORD v27[3];
  void *__dst;
  size_t v29;
  char v30[9];
  uint64_t v31;
  char v32;

  v3 = *(bssl **)a1;
  v4 = (_QWORD *)*(unsigned __int16 *)(*(_QWORD *)(a1 + 1536) + 6);
  v32 = -86;
  v30[2] = 0;
  *(_WORD *)&v30[3] = 0;
  *(_DWORD *)&v30[5] = 0;
  v31 = 0;
  strcpy(v30, "2");
  if ((bssl::ssl_ext_key_share_parse_clienthello(a1, (BOOL *)&v32, &v30[1], v30, a2) & 1) == 0)
  {
    bssl::ssl_send_alert(v3, (ssl_st *)2, v30[0]);
    return 0;
  }
  if (!v32)
  {
    bssl::ssl_send_alert(v3, (ssl_st *)2, 47);
    ERR_put_error(16, 0, 243, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 66);
    return 0;
  }
  __dst = 0;
  v29 = 0;
  v5 = *(_QWORD *)(a1 + 1592);
  if (!v5
    || (*(_BYTE *)(a1 + 1602) & 0x10) != 0
    || *(unsigned __int16 *)(v5 + 32) != (_DWORD)v4
    || !*(_QWORD *)(v5 + 64))
  {
    *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v27[1] = v14;
    v27[2] = v14;
    v27[0] = v14;
    CBB_zero(v27);
    v26 = (_QWORD *)0xAAAAAAAAAAAAAAAALL;
    bssl::SSLKeyShare::Create(v4, &v26);
    if (v26
      && CBB_init((uint64_t)v27, 0x20uLL)
      && (*(unsigned int (**)(_QWORD *, _OWORD *, void **, char *, _QWORD, uint64_t))(*v26 + 32))(v26, v27, &__dst, v30, *(_QWORD *)&v30[1], v31)&& bssl::CBBFinishArray((uint64_t)v27, a1 + 632))
    {
      if (!v5 || (*(_BYTE *)(a1 + 1602) & 0x10) == 0)
        goto LABEL_25;
      *(_WORD *)(v5 + 32) = (_WORD)v4;
      v18 = *(const void **)(a1 + 632);
      v19 = *(_QWORD *)(a1 + 640);
      v20 = bssl::Array<unsigned char>::Init(v5 + 40, v19);
      v21 = v20 ^ 1;
      if (!v19)
        v21 = 1;
      if ((v21 & 1) == 0)
        memcpy(*(void **)(v5 + 40), v18, v19);
      if (v20)
      {
        v22 = __dst;
        v23 = v29;
        v24 = bssl::Array<unsigned char>::Init(v5 + 56, v29);
        v25 = v24 ^ 1;
        if (!v23)
          v25 = 1;
        if ((v25 & 1) == 0)
          memcpy(*(void **)(v5 + 56), v22, v23);
        if ((v24 & 1) != 0)
        {
LABEL_25:
          std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](&v26, 0);
          CBB_cleanup((uint64_t)v27);
          goto LABEL_26;
        }
      }
      v16 = 80;
    }
    else
    {
      v16 = v30[0];
    }
    bssl::ssl_send_alert(v3, (ssl_st *)2, v16);
    std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](&v26, 0);
    CBB_cleanup((uint64_t)v27);
    goto LABEL_29;
  }
  v6 = *(const void **)(v5 + 40);
  v7 = *(_QWORD *)(v5 + 48);
  v8 = bssl::Array<unsigned char>::Init(a1 + 632, v7);
  v9 = v8 ^ 1;
  if (!v7)
    v9 = 1;
  if ((v9 & 1) == 0)
    memcpy(*(void **)(a1 + 632), v6, v7);
  if (!v8)
    goto LABEL_17;
  v10 = *(const void **)(v5 + 56);
  v11 = *(_QWORD *)(v5 + 64);
  v12 = bssl::Array<unsigned char>::Init((uint64_t)&__dst, v11);
  v13 = v12 ^ 1;
  if (!v11)
    v13 = 1;
  if ((v13 & 1) == 0)
    memcpy(__dst, v10, v11);
  if ((v12 & 1) == 0)
  {
LABEL_17:
    bssl::ssl_send_alert(v3, (ssl_st *)2, 80);
LABEL_29:
    v15 = 0;
    goto LABEL_30;
  }
LABEL_26:
  v15 = bssl::tls13_advance_key_schedule(a1);
LABEL_30:
  OPENSSL_free(__dst);
  return v15;
}

void sub_1B4FBF158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](_QWORD **a1, _QWORD *a2)
{
  _QWORD *v2;

  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    (*(void (**)(_QWORD *))*v2)(v2);
    OPENSSL_free(v2);
  }
}

uint64_t bssl::add_new_session_tickets(ssl_st **this, bssl::SSL_HANDSHAKE *a2, BOOL *a3)
{
  ssl_st *v5;
  unsigned int need_empty_fragments_low;
  unsigned int v7;
  ssl_session_st *v8;
  char v9;
  uint64_t v10;
  unsigned __int8 *v11;
  int v12;
  int v13;
  int v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  unsigned int grease_value;
  SSL_SESSION *v19;
  uint64_t result;
  _OWORD v21[3];
  _OWORD v22[3];
  _OWORD v23[3];
  _OWORD v24[3];
  _OWORD v25[3];
  _OWORD v26[3];
  char v27;
  unsigned __int8 *v28;

  if (((_BYTE)this[200] & 0x10) != 0)
  {
    v5 = *this;
    if ((SSL_get_options((uint64_t)*this) & 0x4000) == 0)
    {
      need_empty_fragments_low = LOBYTE(v5->s3->need_empty_fragments);
      v7 = *((unsigned __int8 *)this + 732);
      if (SSL_session_reused((uint64_t)v5))
        v7 = *((unsigned __int8 *)this + 733);
      if (need_empty_fragments_low <= v7)
        v9 = v7;
      else
        v9 = need_empty_fragments_low;
      LOBYTE(v5->s3->need_empty_fragments) = v9;
      bssl::ssl_session_rebase_time((bssl *)v5, this[192], v8);
      if (LOBYTE(v5->s3->need_empty_fragments) > 0x10u)
        bssl::add_new_session_tickets();
      if (!LOBYTE(v5->s3->need_empty_fragments))
      {
LABEL_44:
        result = 1;
        *(_BYTE *)a2 = 1;
        return result;
      }
      v10 = 0;
      while (1)
      {
        v28 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
        bssl::SSL_SESSION_dup((bssl *)this[192], (ssl_session_st *)2, &v28);
        if (!v28)
          return 0;
        if (!RAND_bytes(v28 + 384, 4))
        {
          v13 = 1;
          goto LABEL_40;
        }
        v11 = v28;
        v28[448] |= 8u;
        if ((BYTE4(v5->param) & 4) != 0)
        {
          if (!*(_QWORD *)&v5->hit)
          {
            v14 = 14336;
            goto LABEL_20;
          }
          if (v5->method[1].ssl_accept)
          {
            v14 = -1;
LABEL_20:
            *((_DWORD *)v11 + 97) = v14;
            v12 = 1;
            goto LABEL_21;
          }
        }
        v12 = 0;
LABEL_21:
        v27 = v10;
        *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v26[1] = v15;
        v26[2] = v15;
        v26[0] = v15;
        CBB_zero(v26);
        *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v25[1] = v16;
        v25[2] = v16;
        v25[0] = v16;
        v24[1] = v16;
        v24[2] = v16;
        v23[2] = v16;
        v24[0] = v16;
        v23[0] = v16;
        v23[1] = v16;
        v22[1] = v16;
        v22[2] = v16;
        v22[0] = v16;
        if ((*(unsigned int (**)(ssl_st *, _OWORD *, _OWORD *, uint64_t))(*(_QWORD *)&v5->version + 88))(v5, v26, v25, 4)&& CBB_add_u32((uint64_t)v25, *((_DWORD *)v28 + 48))&& CBB_add_u32((uint64_t)v25, *((_DWORD *)v28 + 96))&& CBB_add_u8_length_prefixed((uint64_t *)v25, (uint64_t)v24)&& CBB_add_bytes((uint64_t)v24, &v27, 1uLL)&& CBB_add_u16_length_prefixed((uint64_t *)v25, (uint64_t)v23)&& bssl::tls13_derive_session_psk((int *)v28, (const ssl_session_st *)&v27, 1uLL)&& bssl::ssl_encrypt_ticket(this, (uint64_t)v23, (uint64_t)v28)&& CBB_add_u16_length_prefixed((uint64_t *)v25, (uint64_t)v22)&& (!v12|| (*(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL, *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL, v21[1] = v17, v21[2] = v17, v21[0] = v17, CBB_add_u16((uint64_t)v22, 0x2Au))
           && CBB_add_u16_length_prefixed((uint64_t *)v22, (uint64_t)v21)
           && CBB_add_u32((uint64_t)v21, *((_DWORD *)v28 + 97))
           && CBB_flush((uint64_t *)v22))
          && (grease_value = bssl::ssl_get_grease_value((uint64_t)this, 5u),
              CBB_add_u16((uint64_t)v22, grease_value))
          && CBB_add_u16((uint64_t)v22, 0))
        {
          v13 = bssl::ssl_add_message_cbb((uint64_t)v5, (uint64_t)v26) ^ 1;
        }
        else
        {
          v13 = 1;
        }
        CBB_cleanup((uint64_t)v26);
LABEL_40:
        v19 = (SSL_SESSION *)v28;
        v28 = 0;
        if (v19)
          SSL_SESSION_free(v19);
        if (v13)
          return 0;
        if (++v10 >= (unint64_t)LOBYTE(v5->s3->need_empty_fragments))
          goto LABEL_44;
      }
    }
  }
  *(_BYTE *)a2 = 0;
  return 1;
}

void sub_1B4FBF4D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  CBB_cleanup(v1 - 128);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)(v1 - 72), 0);
  _Unwind_Resume(a1);
}

boringssl_concrete_boringssl_psk *boringssl_psk_create(void *a1, void *a2)
{
  id v4;
  id v5;
  boringssl_concrete_boringssl_psk *v6;
  boringssl_concrete_boringssl_psk *v7;

  v4 = a1;
  v5 = a2;
  v6 = objc_alloc_init(boringssl_concrete_boringssl_psk);
  v7 = v6;
  if (v6)
  {
    objc_storeStrong((id *)&v6->key, a1);
    objc_storeStrong((id *)&v7->identity, a2);
  }

  return v7;
}

id *boringssl_psk_copy_key(id *result)
{
  if (result)
    return (id *)result[1];
  return result;
}

id *boringssl_psk_copy_identity(id *result)
{
  if (result)
    return (id *)result[2];
  return result;
}

BOOL boringssl_psk_matches_identity_hint(_QWORD *a1, void *a2)
{
  NSObject *v3;
  NSObject *v4;
  _QWORD *v5;
  void *v6;
  _BOOL8 v7;

  if (!a1 || !a2)
    return 0;
  v3 = a1[2];
  v4 = a2;
  v5 = a1;
  boringssl_helper_dump_dispatch_data(0, v3);
  boringssl_helper_dump_dispatch_data(0, v4);
  v6 = (void *)a1[2];

  v7 = boringssl_helper_dispatch_data_equal(v6, v4);
  return v7;
}

xpc_object_t boringssl_psk_copy_xpc_object(_QWORD *a1)
{
  NSObject *v1;
  _QWORD *v2;
  xpc_object_t v3;
  NSObject *v4;
  xpc_object_t v5;
  xpc_object_t v6;

  v1 = a1[1];
  v2 = a1;
  v3 = xpc_data_create_with_dispatch_data(v1);
  v4 = v2[2];

  v5 = xpc_data_create_with_dispatch_data(v4);
  v6 = xpc_array_create(0, 0);
  xpc_array_set_value(v6, 0xFFFFFFFFFFFFFFFFLL, v3);
  xpc_array_set_value(v6, 0xFFFFFFFFFFFFFFFFLL, v5);

  return v6;
}

void __boringssl_logging_register_debug_log_updates_block_invoke_2(uint64_t a1, char a2)
{
  datapath_logging_enabled = a2;
}

uint64_t EVP_PKEY_sign_init(uint64_t *a1)
{
  uint64_t v1;

  if (a1 && (v1 = *a1) != 0 && (*(_QWORD *)(v1 + 40) || *(_QWORD *)(v1 + 48)))
  {
    *((_DWORD *)a1 + 8) = 8;
    return 1;
  }
  else
  {
    ERR_put_error(6, 0, 125, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", 219);
    return 0;
  }
}

uint64_t EVP_PKEY_sign(_DWORD *a1)
{
  uint64_t (*v1)(void);
  int v3;
  int v4;

  if (a1 && *(_QWORD *)a1 && (v1 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 40)) != 0)
  {
    if (a1[8] == 8)
      return v1();
    v3 = 126;
    v4 = 234;
  }
  else
  {
    v3 = 125;
    v4 = 230;
  }
  ERR_put_error(6, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", v4);
  return 0;
}

EC_KEY *__cdecl EC_KEY_new_by_curve_name(int nid)
{
  EC_KEY *v2;
  EC_GROUP *v3;

  v2 = (EC_KEY *)EC_KEY_new_method(0);
  if (v2)
  {
    v3 = EC_GROUP_new_by_curve_name(nid);
    *(_QWORD *)v2 = v3;
    if (!v3)
    {
      EC_KEY_free(v2);
      return 0;
    }
  }
  return v2;
}

int EC_KEY_set_private_key(EC_KEY *a1, const BIGNUM *a2)
{
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;

  v3 = *(_QWORD *)a1;
  if (!v3)
  {
    ERR_put_error(15, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", 239);
    goto LABEL_7;
  }
  ec_wrapped_scalar_new(v3);
  if (v5)
  {
    v6 = v5;
    if (!ec_bignum_to_scalar(*(_QWORD *)a1, v5 + 3, (uint64_t)a2)
      || ec_scalar_is_zero(*(_QWORD *)a1, v6 + 3))
    {
      ERR_put_error(15, 0, 113, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", 249);
      OPENSSL_free(v6);
LABEL_7:
      LODWORD(v5) = 0;
      return (int)v5;
    }
    OPENSSL_free(*((_QWORD **)a1 + 2));
    *((_QWORD *)a1 + 2) = v6;
    LODWORD(v5) = 1;
  }
  return (int)v5;
}

uint64_t EC_KEY_is_opaque(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
    return *(_DWORD *)(v1 + 48) & 1;
  else
    return 0;
}

double ec_wrapped_scalar_new(uint64_t a1)
{
  _QWORD *v2;
  double result;
  int v4;

  v2 = OPENSSL_malloc(0x60uLL);
  if (v2)
  {
    result = 0.0;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *v2 = v2 + 3;
    v4 = *(_DWORD *)(a1 + 24);
    *((_DWORD *)v2 + 2) = v4;
    *((_DWORD *)v2 + 3) = v4;
    *((_DWORD *)v2 + 5) = 2;
  }
  return result;
}

const EC_POINT *__cdecl EC_KEY_get0_public_key(const EC_KEY *a1)
{
  return (const EC_POINT *)*((_QWORD *)a1 + 1);
}

unsigned int EC_KEY_get_enc_flags(const EC_KEY *a1)
{
  return *((_DWORD *)a1 + 6);
}

int EC_KEY_check_key(const EC_KEY *a1)
{
  const EC_GROUP *v2;
  const EC_POINT *v3;
  int v4;
  int v5;
  uint64_t v7;
  __int128 v8;
  _OWORD v9[13];
  unint64_t v10;

  if (a1 && (v2 = *(const EC_GROUP **)a1) != 0 && (v3 = (const EC_POINT *)*((_QWORD *)a1 + 1)) != 0)
  {
    if (EC_POINT_is_at_infinity(v2, v3))
    {
      v4 = 119;
      v5 = 299;
    }
    else
    {
      if (EC_POINT_is_on_curve(*(const EC_GROUP **)a1, *((const EC_POINT **)a1 + 1), 0))
      {
        v7 = *((_QWORD *)a1 + 2);
        if (v7)
        {
          v10 = 0xAAAAAAAAAAAAAAAALL;
          *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v9[11] = v8;
          v9[12] = v8;
          v9[9] = v8;
          v9[10] = v8;
          v9[7] = v8;
          v9[8] = v8;
          v9[5] = v8;
          v9[6] = v8;
          v9[3] = v8;
          v9[4] = v8;
          v9[1] = v8;
          v9[2] = v8;
          v9[0] = v8;
          if (!ec_point_mul_scalar_base(*(_DWORD **)a1, (uint64_t)v9, v7 + 24))
          {
            v4 = 15;
            v5 = 317;
            goto LABEL_7;
          }
          if (!ec_GFp_simple_points_equal(*(_QWORD *)a1, (uint64_t)v9, *((_QWORD *)a1 + 1) + 8))
          {
            v4 = 113;
            v5 = 322;
            goto LABEL_7;
          }
        }
        return 1;
      }
      v4 = 120;
      v5 = 305;
    }
  }
  else
  {
    v4 = 67;
    v5 = 294;
  }
LABEL_7:
  ERR_put_error(15, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", v5);
  return 0;
}

unsigned __int8 *EC_KEY_key2buf(const EC_GROUP **a1, point_conversion_form_t a2, unsigned __int8 **a3, uint64_t a4, uint64_t a5, BN_CTX *a6)
{
  const EC_POINT *v9;
  const EC_GROUP *v10;

  if (a1)
  {
    v9 = a1[1];
    if (v9)
    {
      v10 = *a1;
      if (v10)
        return EC_POINT_point2buf(v10, v9, a2, a3, a4, a6);
    }
  }
  ERR_put_error(15, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", 412);
  return 0;
}

int EC_KEY_generate_key(EC_KEY *a1)
{
  uint64_t v2;
  const BIGNUM *v3;
  int v4;
  int v5;
  _QWORD *v7;
  _QWORD *v8;
  EC_POINT *v9;
  EC_POINT *v10;

  if (!a1 || (v2 = *(_QWORD *)a1) == 0)
  {
    v4 = 67;
    v5 = 483;
    goto LABEL_6;
  }
  v3 = (const BIGNUM *)EC_GROUP_get0_order(v2);
  if (BN_num_bits(v3) <= 0x9F)
  {
    v4 = 112;
    v5 = 489;
LABEL_6:
    ERR_put_error(15, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", v5);
    return 0;
  }
  ec_wrapped_scalar_new(*(_QWORD *)a1);
  v8 = v7;
  v9 = EC_POINT_new(*(const EC_GROUP **)a1);
  v10 = v9;
  if (!v8
    || !v9
    || !ec_random_nonzero_scalar(*(_QWORD *)a1, v8 + 3, (uint64_t)&EC_KEY_generate_key_kDefaultAdditionalData)|| !ec_point_mul_scalar_base(*(_DWORD **)a1, (uint64_t)v10 + 8, (uint64_t)(v8 + 3)))
  {
    EC_POINT_free(v10);
    OPENSSL_free(v8);
    return 0;
  }
  OPENSSL_free(*((_QWORD **)a1 + 2));
  *((_QWORD *)a1 + 2) = v8;
  EC_POINT_free(*((EC_POINT **)a1 + 1));
  *((_QWORD *)a1 + 1) = v10;
  return 1;
}

NSObject *boringssl_private_key_sign(__SecKey *a1, int a2, void *a3)
{
  NSObject *v5;
  const __CFString *v6;
  NSObject *v7;
  uint64_t v8;
  size_t v9;
  UInt8 *v10;
  UInt8 *v11;
  const __CFData *v12;
  const __CFData *Signature;
  const __CFData *v14;
  size_t Length;
  const UInt8 *BytePtr;
  dispatch_data_t v17;
  EVP_MD_CTX *v18;
  EVP_MD_CTX *v19;
  uint64_t *v20;
  __int128 v21;
  size_t BlockSize;
  uint8_t *v23;
  uint8_t *v24;
  NSObject *v25;
  uint64_t v26;
  size_t size;
  unsigned int s;
  CFErrorRef error[2];
  __int128 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = (const __CFString *)boringssl_helper_SecKeyAlgorithm_from_signature_algorithm(a2);
  if (!CFEqual(v6, (CFTypeRef)*MEMORY[0x1E0CD6EC8]))
  {
    v9 = dispatch_data_get_size(v5);
    v10 = (UInt8 *)malloc_type_malloc(v9, 0xB1CE70EAuLL);
    if (v10)
    {
      v11 = v10;
      boringssl_helper_dispatch_data_copyout(v5, (uint64_t)v10, v9);
      if (v6 != (const __CFString *)*MEMORY[0x1E0CD6E80])
      {
        v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v11, v9);
        free(v11);
        error[0] = 0;
        Signature = SecKeyCreateSignature(a1, v6, v12, error);
        if (Signature)
        {
          v14 = Signature;
          Length = CFDataGetLength(Signature);
          BytePtr = CFDataGetBytePtr(v14);
          v17 = dispatch_data_create(BytePtr, Length, 0, 0);
          if (v12)
            CFRelease(v12);
        }
        else
        {
          if (g_boringssl_log)
          {
            v25 = (id)g_boringssl_log;
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              boringssl_private_key_sign_cold_1(error, v25, v26);

          }
          if (v12)
            CFRelease(v12);
          v17 = 0;
          v7 = 0;
          v14 = error[0];
          if (!error[0])
            goto LABEL_24;
        }
        CFRelease(v14);
        v7 = v17;
        goto LABEL_24;
      }
      v18 = EVP_MD_CTX_create();
      if (v18)
      {
        v19 = v18;
        v20 = EVP_md5_sha1();
        v32 = -1431655766;
        *(_QWORD *)&v21 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)error = v21;
        v31 = v21;
        EVP_DigestInit_ex(v19, (const EVP_MD *)v20, 0);
        EVP_DigestUpdate(v19, v11, v9);
        s = 0;
        EVP_DigestFinal_ex(v19, (unsigned __int8 *)error, &s);
        EVP_MD_CTX_destroy(v19);
        BlockSize = SecKeyGetBlockSize(a1);
        v23 = (uint8_t *)malloc_type_malloc(BlockSize, 0x3C00F584uLL);
        if (v23)
        {
          v24 = v23;
          size = BlockSize;
          if (SecKeyRawSign(a1, 1u, (const uint8_t *)error, 0x24uLL, v23, &size))
            v7 = 0;
          else
            v7 = dispatch_data_create(v24, size, 0, 0);
          free(v24);
          free(v11);
          goto LABEL_24;
        }
      }
      free(v11);
    }
LABEL_23:
    v7 = 0;
    goto LABEL_24;
  }
  v7 = g_boringssl_log;
  if (g_boringssl_log)
  {
    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      boringssl_private_key_sign_cold_2(a2, v7, v8);
    goto LABEL_23;
  }
LABEL_24:

  return v7;
}

dispatch_data_t boringssl_private_key_decrypt(__SecKey *a1, void *a2)
{
  NSObject *v3;
  size_t size;
  uint8_t *v5;
  uint8_t *v6;
  char *v7;
  dispatch_data_t v8;
  char *v9;
  size_t plainTextLen;

  v3 = a2;
  size = dispatch_data_get_size(v3);
  v5 = (uint8_t *)malloc_type_malloc(size, 0x55BE1419uLL);
  if (!v5)
  {
    v8 = 0;
    goto LABEL_8;
  }
  v6 = v5;
  boringssl_helper_dispatch_data_copyout(v3, (uint64_t)v5, size);
  v7 = (char *)malloc_type_malloc(size, 0x14CC763AuLL);
  bzero(v7, size);
  plainTextLen = size;
  if (!SecKeyDecrypt(a1, 0, v6, size, (uint8_t *)v7, &plainTextLen) && plainTextLen <= size)
  {
    v9 = (char *)malloc_type_malloc(size, 0x4EB6CE1CuLL);
    bzero(v9, size);
    memcpy(&v9[size - plainTextLen], v7, plainTextLen);
    v8 = dispatch_data_create(v9, size, 0, 0);
    if (v7)
      free(v7);
    if (!v9)
      goto LABEL_6;
    goto LABEL_5;
  }
  v8 = 0;
  v9 = v7;
  if (v7)
LABEL_5:
    free(v9);
LABEL_6:
  free(v6);
LABEL_8:

  return v8;
}

uint64_t bssl::dtls1_open_app_data(bssl *a1, _OWORD *a2, unsigned __int8 **a3, char *a4, unsigned __int8 *a5, unsigned __int8 *a6)
{
  uint64_t result;
  int v13;
  ssl_st *v14;
  ssl_st *v15;
  char v16;
  _QWORD v17[3];
  uint64_t v18[4];
  __int128 v19;
  unsigned __int8 v20;

  if (SSL_in_init((uint64_t)a1))
    bssl::dtls1_open_app_data();
  v20 = -86;
  v19 = 0uLL;
  result = bssl::dtls_open_record(a1, (char *)&v20, (uint64_t)&v19, a3, a4, a5, a6);
  if (!(_DWORD)result)
  {
    v13 = v20;
    if (v20 == 22)
    {
      memset(v18, 170, sizeof(v18));
      memset(v17, 170, 20);
      CBS_init(&v18[2], v19, *((uint64_t *)&v19 + 1));
      if ((bssl::dtls1_parse_fragment(&v18[2], (uint64_t)v17, v18) & 1) == 0)
      {
        ERR_put_error(16, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_pkt.cc", 150);
        v16 = 50;
LABEL_16:
        *a4 = v16;
        return 4;
      }
      if (LOBYTE(v17[0]) == 20 && *(unsigned __int16 *)(*((_QWORD *)a1 + 7) + 26) - 1 == LOWORD(v17[1]))
      {
        if (HIDWORD(v17[1]))
          return 1;
        if (bssl::dtls1_check_timeout_num(a1, v14))
        {
          bssl::dtls1_retransmit_outgoing_messages(a1, v15);
          return 1;
        }
        *a4 = 0;
        return 4;
      }
      v13 = v20;
    }
    if (v13 == 23)
    {
      if (*((_QWORD *)&v19 + 1))
      {
        result = 0;
        *a2 = v19;
        return result;
      }
      return 1;
    }
    ERR_put_error(16, 0, 225, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_pkt.cc", 176);
    v16 = 10;
    goto LABEL_16;
  }
  return result;
}

uint64_t bssl::dtls1_write_app_data(bssl *a1, _BYTE *a2, unint64_t *a3, char *a4, unint64_t a5)
{
  int v10;
  int v11;
  uint64_t result;

  if (SSL_in_init((uint64_t)a1))
    bssl::dtls1_write_app_data();
  *a2 = 0;
  if (*(_DWORD *)(*((_QWORD *)a1 + 6) + 176))
  {
    v10 = 194;
    v11 = 195;
LABEL_6:
    ERR_put_error(16, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_pkt.cc", v11);
    return 0xFFFFFFFFLL;
  }
  if (a5 > 0x4000)
  {
    v10 = 143;
    v11 = 201;
    goto LABEL_6;
  }
  if (!a5)
  {
    *a3 = 0;
    return 1;
  }
  result = bssl::dtls1_write_record(a1, (const ssl_st *)0x17, a4, a5, 1);
  if ((int)result >= 1)
  {
    *a3 = a5;
    return 1;
  }
  return result;
}

uint64_t bssl::dtls1_write_record(bssl *this, const ssl_st *a2, char *a3, unint64_t a4, int a5)
{
  _WORD *v6;
  char v10;
  int v11;
  uint64_t v12;
  ssl_st *v13;
  uint64_t result;
  unint64_t v15;

  if (a4 > 0x4000)
    bssl::dtls1_write_record();
  v6 = (_WORD *)*((_QWORD *)this + 6);
  if (v6[58])
    bssl::dtls1_write_record();
  v10 = (char)a2;
  v15 = 0;
  v11 = bssl::ssl_seal_align_prefix_len((unsigned __int8 **)this, a2);
  v12 = SSL_max_seal_overhead((uint64_t)this);
  if (bssl::SSLBuffer::EnsureCap((bssl::SSLBuffer *)(v6 + 52), v11, v12 + a4)
    && (bssl::dtls_seal_record((uint64_t)this, *((_QWORD *)v6 + 13) + (unsigned __int16)v6[56] + (unsigned __int16)v6[58], &v15, (unsigned __int16)v6[59] - (unint64_t)(unsigned __int16)v6[58], v10, a3, a4, a5) & 1) != 0)
  {
    bssl::SSLBuffer::DidWrite((uint64_t)(v6 + 52), v15);
    LODWORD(result) = bssl::ssl_write_buffer_flush(this, v13);
    if ((int)result >= 1)
      return 1;
    else
      return result;
  }
  else
  {
    bssl::SSLBuffer::Clear(v6 + 52);
    return 0xFFFFFFFFLL;
  }
}

uint64_t bssl::dtls1_dispatch_alert(BIO **this, ssl_st *a2)
{
  uint64_t v3;
  BIO *v4;

  v3 = bssl::dtls1_write_record((bssl *)this, (const ssl_st *)0x15, (char *)&this[6][4].cb_arg + 5, 2uLL, 1);
  if ((int)v3 >= 1)
  {
    *((_WORD *)&this[6][1].ex_data.dummy + 2) &= ~0x1000u;
    v4 = this[6];
    if (BYTE5(v4[4].cb_arg) == 2)
    {
      BIO_flush(this[4]);
      v4 = this[6];
    }
    bssl::ssl_do_msg_callback((uint64_t)this, 1, 21, (uint64_t)&v4[4].cb_arg + 5, 2);
    bssl::ssl_do_info_callback((uint64_t)this, (const ssl_st *)0x4008);
  }
  return v3;
}

BOOL SSL_generate_key_block(SSL *a1, ssl_session_st *a2, size_t a3)
{
  const ssl_st *v6;
  bssl *session;

  if (SSL_in_init((uint64_t)a1) || bssl::ssl_protocol_version((bssl *)a1, v6) >= 0x304)
  {
    ERR_put_error(16, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/t1_enc.cc", 325);
    return 0;
  }
  else
  {
    session = (bssl *)SSL_get_session(a1);
    return bssl::generate_key_block((uint64_t)a1, a2, a3, session);
  }
}

uint64_t SSL_export_keying_material(bssl *this, ssl_st *a2, size_t a3, const void *a4, size_t a5, const void *a6, size_t a7, int a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  uint64_t v20;
  const void *v21;
  _BOOL8 v22;
  int v23;
  int v24;
  unint64_t v25;
  _OWORD *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  __int128 v30;
  SSL_SESSION *session;
  const ssl_session_st *v32;
  uint64_t *digest;
  void *v35;
  size_t v36;

  if ((*(_WORD *)(*((_QWORD *)this + 6) + 220) & 2) != 0
    && bssl::ssl_protocol_version(this, a2) >= 0x304)
  {
    v17 = *((_QWORD *)this + 6);
    v18 = *(unsigned __int8 *)(v17 + 442);
    if (*(_BYTE *)(v17 + 442))
    {
      if (a8)
        v19 = a7;
      else
        v19 = 0;
      v20 = v17 + 392;
      if (a8)
        v21 = a6;
      else
        v21 = 0;
      return bssl::tls13_export_keying_material((const SSL *)this, (int)a2, a3, v20, v18, a4, a5, v16, v21, v19);
    }
    v23 = 284;
    v24 = 339;
LABEL_27:
    ERR_put_error(16, 0, v23, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/t1_enc.cc", v24);
    return 0;
  }
  if (SSL_in_init((uint64_t)this) && !SSL_in_false_start((uint64_t)this))
  {
    v23 = 284;
    v24 = 355;
    goto LABEL_27;
  }
  if (a8)
  {
    if (a7 >= 0x10000)
    {
      v23 = 69;
      v24 = 362;
      goto LABEL_27;
    }
    v25 = a7 + 66;
  }
  else
  {
    v25 = 64;
  }
  v35 = 0;
  v36 = 0;
  if ((bssl::Array<unsigned char>::Init((uint64_t)&v35, v25) & 1) != 0)
  {
    v26 = v35;
    v27 = *((_QWORD *)this + 6);
    v28 = *(_OWORD *)(v27 + 64);
    *(_OWORD *)v35 = *(_OWORD *)(v27 + 48);
    v26[1] = v28;
    v29 = *((_QWORD *)this + 6);
    v30 = *(_OWORD *)(v29 + 32);
    v26[2] = *(_OWORD *)(v29 + 16);
    v26[3] = v30;
    if (a8)
    {
      *((_WORD *)v26 + 32) = bswap32(a7) >> 16;
      if (a7)
        memcpy((char *)v26 + 66, a6, a7);
    }
    session = SSL_get_session((const SSL *)this);
    digest = (uint64_t *)bssl::ssl_session_get_digest((bssl *)session, v32);
    v22 = CRYPTO_tls1_prf(digest, a2, a3, (char *)&session->master_key_length, *(int *)&session->key_arg[4], (const unsigned __int8 *)a4, a5, (const unsigned __int8 *)v35, v36, 0, 0) == 1;
  }
  else
  {
    v22 = 0;
  }
  OPENSSL_free(v35);
  return v22;
}

void sub_1B4FC0644(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](unint64_t **a1, unint64_t *a2)
{
  unint64_t *v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    sk_pop_free_ex(v3, (void (*)(uint64_t))bssl::internal::DeleterImpl<stack_st_CRYPTO_BUFFER,void>::Free(stack_st_CRYPTO_BUFFER*)::{lambda(void (*)(void *),void *)#1}::__invoke, 0);
}

uint64_t bssl::buffer_up_ref(uint64_t a1)
{
  CRYPTO_BUFFER_up_ref(a1);
  return a1;
}

void bssl::DC::Dup(bssl::DC *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  unsigned int *v6;
  EVP_PKEY *v7;

  v4 = OPENSSL_malloc(0x18uLL);
  v5 = v4;
  if (v4)
  {
    *v4 = 0;
    *((_WORD *)v4 + 4) = 0;
    v4[2] = 0;
    v6 = *(unsigned int **)this;
    if (*(_QWORD *)this)
      CRYPTO_BUFFER_up_ref(*(_QWORD *)this);
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)v5, v6);
    *((_WORD *)v5 + 4) = *((_WORD *)this + 4);
    v7 = (EVP_PKEY *)*((_QWORD *)this + 2);
    if (v7)
      EVP_PKEY_up_ref((unsigned int *)v7);
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)v5 + 2, v7);
  }
  *a2 = v5;
}

void sub_1B4FC075C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<bssl::DC,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](EVP_PKEY **a1, EVP_PKEY *a2)
{
  EVP_PKEY *v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    EVP_PKEY_free(v3);
}

void std::unique_ptr<bssl::DC,bssl::internal::Deleter>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    bssl::Delete<bssl::DC>(v3);
}

uint64_t bssl::check_leaf_cert_and_privkey(uint64_t a1, const evp_pkey_st *a2)
{
  EVP_PKEY *v3;
  bssl *v4;
  const evp_pkey_st *v5;
  uint64_t v6;
  int v7;
  EVP_PKEY *v9;
  __int128 v10;

  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  CRYPTO_BUFFER_init_CBS(a1, &v10);
  v9 = (EVP_PKEY *)0xAAAAAAAAAAAAAAAALL;
  bssl::ssl_cert_parse_pubkey(&v10, &v9);
  v3 = v9;
  if (v9)
  {
    v4 = (bssl *)EVP_PKEY_id((uint64_t)v9);
    if (bssl::ssl_is_key_type_supported(v4))
    {
      if (EVP_PKEY_id((uint64_t)v3) != 408 || (bssl::ssl_cert_check_key_usage(&v10, 0) & 1) != 0)
      {
        if (a2 && (bssl::ssl_compare_public_and_private_key(v3, a2, v5) & 1) == 0)
        {
          ERR_clear_error();
          v6 = 2;
        }
        else
        {
          v6 = 1;
        }
        goto LABEL_11;
      }
      v7 = 249;
    }
    else
    {
      v7 = 241;
    }
    ERR_put_error(16, 0, 228, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", v7);
    v6 = 0;
LABEL_11:
    v9 = 0;
    EVP_PKEY_free(v3);
    return v6;
  }
  ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 236);
  return 0;
}

void sub_1B4FC08CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)va, 0);
  _Unwind_Resume(a1);
}

BOOL bssl::ssl_has_certificate(bssl *this, const bssl::SSL_HANDSHAKE *a2)
{
  const STACK *v3;
  const ssl_st *v4;

  v3 = *(const STACK **)(*(_QWORD *)(*((_QWORD *)this + 1) + 32) + 8);
  return v3 && sk_value(v3, 0) && bssl::ssl_has_private_key(this, v4);
}

BOOL bssl::ssl_has_server_raw_public_key_certificate(bssl *this, const ssl_st *a2)
{
  return (*((_BYTE *)this + 1602) & 0x40) != 0 && *((_BYTE *)this + 730) == 2 && bssl::ssl_has_private_key(this, a2);
}

BOOL bssl::ssl_has_client_raw_public_key_certificate(bssl *this, const ssl_st *a2)
{
  return (*((_BYTE *)this + 1602) & 0x80) != 0 && *((_BYTE *)this + 731) == 2 && bssl::ssl_has_private_key(this, a2);
}

BOOL bssl::ssl_add_cert_chain(bssl *a1, const bssl::SSL_HANDSHAKE *a2)
{
  __int128 v4;
  const STACK *v5;
  uint64_t v6;
  char *v7;
  __int128 v8;
  const void *v9;
  size_t v10;
  int v11;
  int v13;
  _OWORD v14[3];
  _OWORD v15[3];

  if (!bssl::ssl_has_certificate(a1, a2))
  {
    v11 = CBB_add_u24((uint64_t)a2, 0);
    return v11 != 0;
  }
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v15[1] = v4;
  v15[2] = v4;
  v15[0] = v4;
  if (CBB_add_u24_length_prefixed((uint64_t *)a2, (uint64_t)v15))
  {
    v5 = *(const STACK **)(*(_QWORD *)(*((_QWORD *)a1 + 1) + 32) + 8);
    if (sk_num(v5))
    {
      v6 = 0;
      while (1)
      {
        v7 = sk_value(v5, v6);
        *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v14[1] = v8;
        v14[2] = v8;
        v14[0] = v8;
        if (!CBB_add_u24_length_prefixed((uint64_t *)v15, (uint64_t)v14))
          break;
        v9 = (const void *)CRYPTO_BUFFER_data((uint64_t)v7);
        v10 = CRYPTO_BUFFER_len((uint64_t)v7);
        if (!CBB_add_bytes((uint64_t)v14, v9, v10) || !CBB_flush((uint64_t *)v15))
          break;
        if (++v6 >= (unint64_t)sk_num(v5))
          goto LABEL_9;
      }
      v13 = 441;
      goto LABEL_14;
    }
LABEL_9:
    v11 = CBB_flush((uint64_t *)a2);
    return v11 != 0;
  }
  v13 = 429;
LABEL_14:
  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", v13);
  return 0;
}

uint64_t bssl::ssl_compare_public_and_private_key(const EVP_PKEY *this, const evp_pkey_st *a2, const evp_pkey_st *a3)
{
  uint64_t result;
  int v6;
  int v7;
  int v8;

  if (EVP_PKEY_is_opaque((uint64_t)a2))
    return 1;
  v6 = EVP_PKEY_cmp(this, a2) + 2;
  result = 1;
  switch(v6)
  {
    case 0:
      v7 = 128;
      v8 = 522;
      goto LABEL_7;
    case 1:
      v7 = 115;
      v8 = 519;
      goto LABEL_7;
    case 2:
      v7 = 116;
      v8 = 516;
LABEL_7:
      ERR_put_error(11, 0, v7, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", v8);
      result = 0;
      break;
    case 3:
      return result;
    default:
      bssl::ssl_compare_public_and_private_key();
  }
  return result;
}

void bssl::ssl_parse_client_CA_list(uint64_t a1@<X0>, _BYTE *a2@<X1>, unsigned __int8 **a3@<X2>, STACK **a4@<X8>)
{
  _QWORD **v8;
  unsigned int *v9;
  STACK *v10;
  unint64_t v11[2];
  unsigned __int8 *v12[2];
  STACK *st;

  v8 = *(_QWORD ***)(*(_QWORD *)(a1 + 120) + 792);
  st = sk_new_null();
  if (st)
  {
    v12[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
    v12[1] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_u16_length_prefixed(a3, (unint64_t *)v12))
    {
      while (CBS_len((uint64_t)v12))
      {
        v11[0] = 0xAAAAAAAAAAAAAAAALL;
        v11[1] = 0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_u16_length_prefixed(v12, v11))
        {
          *a2 = 50;
          ERR_put_error(16, 0, 123, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 652);
          goto LABEL_14;
        }
        v9 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)v11, v8);
        if (!v9)
          goto LABEL_8;
        if (!sk_push(st, (char *)v9))
        {
          CRYPTO_BUFFER_free(v9);
          goto LABEL_8;
        }
      }
      if (((**(uint64_t (***)(STACK *))(*(_QWORD *)(a1 + 120) + 8))(st) & 1) != 0)
      {
        v10 = st;
        st = 0;
        *a4 = v10;
        goto LABEL_15;
      }
      *a2 = 50;
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 667);
    }
    else
    {
      *a2 = 50;
      ERR_put_error(16, 0, 162, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 644);
    }
  }
  else
  {
LABEL_8:
    *a2 = 80;
  }
LABEL_14:
  *a4 = 0;
LABEL_15:
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&st, 0);
}

void sub_1B4FC0CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)va, 0);
  _Unwind_Resume(a1);
}

const STACK *bssl::ssl_has_client_CAs(bssl *this, const bssl::SSL_CONFIG *a2)
{
  const STACK *result;

  result = (const STACK *)*((_QWORD *)this + 11);
  if (result)
    return (const STACK *)(sk_num(result) != 0);
  result = *(const STACK **)(*(_QWORD *)(*(_QWORD *)this + 120) + 400);
  if (result)
    return (const STACK *)(sk_num(result) != 0);
  return result;
}

uint64_t bssl::ssl_add_client_CA_list(_QWORD *a1, uint64_t *a2)
{
  __int128 v4;
  uint64_t result;
  const STACK *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  const void *v11;
  size_t v12;
  _OWORD v13[3];
  _OWORD v14[3];

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = v4;
  v14[2] = v4;
  v13[2] = v4;
  v14[0] = v4;
  v13[0] = v4;
  v13[1] = v4;
  result = CBB_add_u16_length_prefixed(a2, (uint64_t)v14);
  if ((_DWORD)result)
  {
    v6 = *(const STACK **)(a1[1] + 88);
    if ((v6 || (v6 = *(const STACK **)(*(_QWORD *)(*a1 + 120) + 400)) != 0) && (v7 = sk_num(v6)) != 0)
    {
      v8 = v7;
      v9 = 0;
      while (1)
      {
        v10 = sk_value(v6, v9);
        result = CBB_add_u16_length_prefixed((uint64_t *)v14, (uint64_t)v13);
        if (!(_DWORD)result)
          break;
        v11 = (const void *)CRYPTO_BUFFER_data((uint64_t)v10);
        v12 = CRYPTO_BUFFER_len((uint64_t)v10);
        result = CBB_add_bytes((uint64_t)v13, v11, v12);
        if (!(_DWORD)result)
          break;
        if (v8 == ++v9)
          return CBB_flush(a2) != 0;
      }
    }
    else
    {
      return CBB_flush(a2) != 0;
    }
  }
  return result;
}

uint64_t bssl::ssl_on_certificate_selected(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3;
  const ssl_st *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t result;
  uint64_t v11;
  EVP_PKEY *v12;
  EVP_PKEY **v13;
  char *v14;
  const ssl_st *v15;
  uint64_t v16;
  EVP_PKEY *v17;
  EVP_PKEY *v18;
  __int128 v19;

  v3 = *(_QWORD *)this;
  if (!bssl::ssl_has_certificate(this, a2))
  {
    v9 = *((_DWORD *)this + 400);
    if ((v9 & 0x800000) != 0 && *((_BYTE *)this + 731) == 2)
    {
      if (bssl::ssl_has_private_key(this, v4))
        goto LABEL_2;
      v9 = *((_DWORD *)this + 400);
    }
    if ((v9 & 0x400000) == 0 || *((_BYTE *)this + 730) != 2 || !bssl::ssl_has_private_key(this, v4))
      return 1;
  }
LABEL_2:
  v5 = *((_DWORD *)this + 400);
  if ((v5 & 0x400000) != 0 && *((_BYTE *)this + 730) == 2)
  {
    if (bssl::ssl_has_private_key(this, v4))
    {
      v6 = *(_QWORD *)(v3 + 8);
      v8 = *(_QWORD *)(v6 + 184);
      v7 = *(_QWORD *)(v6 + 192);
LABEL_19:
      *(_QWORD *)&v19 = v8;
      *((_QWORD *)&v19 + 1) = v7;
      v12 = EVP_parse_public_key(&v19);
      v13 = (EVP_PKEY **)((char *)this + 1520);
      goto LABEL_26;
    }
    v5 = *((_DWORD *)this + 400);
  }
  if ((v5 & 0x800000) != 0 && *((_BYTE *)this + 731) == 2 && bssl::ssl_has_private_key(this, v4))
  {
    v11 = *(_QWORD *)(v3 + 8);
    v8 = *(_QWORD *)(v11 + 216);
    v7 = *(_QWORD *)(v11 + 224);
    goto LABEL_19;
  }
  result = (*(uint64_t (**)(bssl *))(*(_QWORD *)(*(_QWORD *)(v3 + 120) + 8) + 112))(this);
  if (!(_DWORD)result)
    return result;
  *(_QWORD *)&v19 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14 = sk_value(*(const STACK **)(*(_QWORD *)(*((_QWORD *)this + 1) + 32) + 8), 0);
  CRYPTO_BUFFER_init_CBS((uint64_t)v14, &v19);
  if (bssl::ssl_signing_with_dc(this, v15))
  {
    v16 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 32) + 152);
    v17 = *(EVP_PKEY **)(v16 + 16);
    if (v17)
      EVP_PKEY_up_ref(*(unsigned int **)(v16 + 16));
    v13 = (EVP_PKEY **)((char *)this + 1520);
    v12 = v17;
  }
  else
  {
    bssl::ssl_cert_parse_pubkey(&v19, &v18);
    v13 = (EVP_PKEY **)((char *)this + 1520);
    v12 = v18;
  }
LABEL_26:
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](v13, v12);
  return *((_QWORD *)this + 190) != 0;
}

BOOL bssl::ssl_signing_with_dc(bssl *this, const ssl_st *a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 *v7;
  int v8;
  uint64_t v9;
  int v10;
  _BOOL8 result;
  BOOL v12;

  v3 = *(_QWORD *)this;
  if ((*(_BYTE *)(v3 + 180) & 1) == 0)
    return 0;
  if ((*((_BYTE *)this + 1601) & 1) == 0)
    return 0;
  v4 = *(_QWORD **)(*((_QWORD *)this + 1) + 32);
  v5 = v4[19];
  if (!v5 || !*(_QWORD *)v5 || !v4[20] && !v4[21])
    return 0;
  if ((*(_WORD *)(*(_QWORD *)(v3 + 48) + 220) & 2) == 0)
    bssl::ssl_signing_with_dc();
  if (bssl::ssl_protocol_version((bssl *)v3, a2) < 0x304)
    return 0;
  v6 = *((_QWORD *)this + 86);
  if (!v6)
    return 0;
  v7 = (unsigned __int16 *)*((_QWORD *)this + 85);
  v8 = *(unsigned __int16 *)(v5 + 8);
  v9 = 2 * v6 - 2;
  do
  {
    v10 = *v7++;
    result = v8 == v10;
    v12 = v8 == v10 || v9 == 0;
    v9 -= 2;
  }
  while (!v12);
  return result;
}

uint64_t SSL_set_chain_and_key(uint64_t a1, uint64_t *a2, uint64_t a3, EVP_PKEY *a4, uint64_t a5)
{
  uint64_t v5;

  v5 = *(_QWORD *)(a1 + 8);
  if (v5)
    return bssl::cert_set_chain_and_key(*(_QWORD *)(v5 + 32), a2, a3, a4, a5);
  else
    return 0;
}

uint64_t bssl::cert_set_chain_and_key(uint64_t a1, uint64_t *a2, uint64_t a3, EVP_PKEY *a4, uint64_t a5)
{
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v14;
  unint64_t *v15;
  EVP_PKEY *v16;
  uint64_t v17;
  STACK *st;

  if (!a3 || !((unint64_t)a4 | a5))
  {
    v7 = 67;
    v8 = 268;
LABEL_4:
    ERR_put_error(16, 0, v7, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", v8);
    return 0;
  }
  v11 = a3;
  v12 = a2;
  if (a4 && a5)
  {
    v7 = 275;
    v8 = 273;
    goto LABEL_4;
  }
  v14 = bssl::check_leaf_cert_and_privkey(*a2, a4);
  v9 = v14;
  if (!(_DWORD)v14)
    return v9;
  if ((_DWORD)v14 == 2)
  {
    v7 = 274;
    v8 = 281;
    goto LABEL_4;
  }
  st = sk_new_null();
  if (st)
  {
    while (1)
    {
      v9 = *v12;
      if (*v12)
        CRYPTO_BUFFER_up_ref(*v12);
      v17 = v9;
      if (!sk_push(st, (char *)v9))
        break;
      v17 = 0;
      ++v12;
      if (!--v11)
      {
        if (a4)
          EVP_PKEY_up_ref((unsigned int *)a4);
        v16 = 0;
        std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)a1, a4);
        std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](&v16, 0);
        *(_QWORD *)(a1 + 40) = a5;
        v15 = (unint64_t *)st;
        st = 0;
        std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)(a1 + 8), v15);
        v9 = 1;
        goto LABEL_23;
      }
    }
    if (!v9)
      goto LABEL_23;
    CRYPTO_BUFFER_free((unsigned int *)v9);
  }
  v9 = 0;
LABEL_23:
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&st, 0);
  return v9;
}

void sub_1B4FC122C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t SSL_CTX_set_cert_cb(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(result + 432);
  *(_QWORD *)(v3 + 72) = a2;
  *(_QWORD *)(v3 + 80) = a3;
  return result;
}

uint64_t SSL_get0_peer_pubkey(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 280);
  if (v1)
    return *(_QWORD *)(v1 + 1528);
  else
    return 0;
}

BOOL set_signed_cert_timestamp_list(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v4;
  unint64_t v5;
  unsigned int *v6;
  __int128 v8;

  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  CBS_init(&v8, a2, a3);
  if ((bssl::ssl_is_sct_list_valid(&v8) & 1) != 0)
  {
    v4 = (const void *)CBS_data((uint64_t)&v8);
    v5 = CBS_len((uint64_t)&v8);
    v6 = (unsigned int *)CRYPTO_BUFFER_new(v4, v5, 0);
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)(a1 + 96), v6);
    return *(_QWORD *)(a1 + 96) != 0;
  }
  else
  {
    ERR_put_error(16, 0, 269, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 1004);
    return 0;
  }
}

BOOL SSL_set_signed_cert_timestamp_list(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  return v3 && set_signed_cert_timestamp_list(*(_QWORD *)(v3 + 32), a2, a3);
}

BOOL SSL_CTX_set_ocsp_response(uint64_t a1, const void *a2, unint64_t a3)
{
  unsigned int **v4;
  unsigned int *v5;

  v4 = (unsigned int **)(*(_QWORD *)(a1 + 432) + 104);
  v5 = (unsigned int *)CRYPTO_BUFFER_new(a2, a3, 0);
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](v4, v5);
  return *(_QWORD *)(*(_QWORD *)(a1 + 432) + 104) != 0;
}

void std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](unsigned int **a1, unsigned int *a2)
{
  unsigned int *v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    CRYPTO_BUFFER_free(v3);
}

BOOL SSL_set_ocsp_response(uint64_t a1, const void *a2, unint64_t a3)
{
  uint64_t v3;
  unsigned int **v5;
  unsigned int *v6;

  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return 0;
  v5 = (unsigned int **)(*(_QWORD *)(v3 + 32) + 104);
  v6 = (unsigned int *)CRYPTO_BUFFER_new(a2, a3, 0);
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](v5, v6);
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) + 104) != 0;
}

uint64_t sk_CRYPTO_BUFFER_call_free_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100](bssl::CERT **a1, bssl::CERT *a2)
{
  bssl::CERT *v3;
  _QWORD *v4;

  v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    bssl::CERT::~CERT(v3);
    OPENSSL_free(v4);
  }
}

void bssl::Delete<bssl::DC>(uint64_t a1)
{
  if (a1)
  {
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)(a1 + 16), 0);
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)a1, 0);
    OPENSSL_free((_QWORD *)a1);
  }
}

BOOL bssl::ssl_negotiate_version(bssl *this, char *a2, _WORD *a3, __int128 *a4)
{
  uint64_t v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  int v11;
  int u16;
  _BOOL8 v13;
  char v14;
  unsigned __int16 v16;
  __int128 v17;

  v8 = 2;
  if (***(_BYTE ***)this)
  {
    v9 = (unsigned __int16 *)&bssl::kDTLSVersions;
  }
  else
  {
    v8 = 4;
    v9 = (unsigned __int16 *)&bssl::kTLSVersions;
  }
  v10 = &v9[v8];
  do
  {
    v11 = *v9;
    if (bssl::ssl_supports_version(this, (const bssl::SSL_HANDSHAKE *)*v9)
      && (v11 != 772 || (*((_BYTE *)this + 1603) & 1) == 0))
    {
      v17 = *a4;
      while (CBS_len((uint64_t)&v17))
      {
        v16 = -21846;
        u16 = CBS_get_u16((unsigned __int16 **)&v17, &v16);
        v13 = u16 != 0;
        if (!u16)
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_versions.cc", 313);
          v14 = 50;
          goto LABEL_16;
        }
        if (v16 == v11)
        {
          *a3 = v11;
          return v13;
        }
      }
    }
    ++v9;
  }
  while (v9 != v10);
  ERR_put_error(16, 0, 240, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_versions.cc", 325);
  v13 = 0;
  v14 = 70;
LABEL_16:
  *a2 = v14;
  return v13;
}

uint64_t SSL_CTX_get_min_proto_version(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 218);
}

uint64_t SSL_CTX_get_max_proto_version(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 216);
}

const char *bssl::ssl_version_to_string(bssl *this)
{
  int v1;
  const char *result;
  const char *v3;

  v1 = (_DWORD)this - 769;
  result = "TLSv1.3";
  switch(v1)
  {
    case 0:
      result = "TLSv1";
      break;
    case 1:
      result = "TLSv1.1";
      break;
    case 2:
      result = "TLSv1.2";
      break;
    case 3:
      return result;
    default:
      v3 = "unknown";
      if ("TLSv1.3" == 65279)
        v3 = "DTLSv1";
      if ("TLSv1.3" == 65277)
        result = "DTLSv1.2";
      else
        result = v3;
      break;
  }
  return result;
}

const char *SSL_SESSION_get_version(uint64_t a1)
{
  return bssl::ssl_version_to_string((bssl *)*(unsigned __int16 *)(a1 + 4));
}

uint64_t bssl::SSLTranscript::CopyToHashContext(size_t **this, env_md_ctx_st *a2, const env_md_st *a3)
{
  const EVP_MD_CTX *v6;
  const EVP_MD *v7;
  int v8;
  int v9;
  uint64_t result;

  v6 = (const EVP_MD_CTX *)(this + 1);
  v7 = EVP_MD_CTX_md((const EVP_MD_CTX *)(this + 1));
  if (v7)
  {
    v8 = EVP_MD_type(v7);
    if (v8 == EVP_MD_type(a3))
    {
      v9 = EVP_MD_CTX_copy_ex(a2, v6);
      return v9 != 0;
    }
  }
  if (*this)
  {
    result = EVP_DigestInit_ex(a2, a3, 0);
    if (!(_DWORD)result)
      return result;
    v9 = EVP_DigestUpdate(a2, (const void *)(*this)[1], **this);
    return v9 != 0;
  }
  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_transcript.cc", 216);
  return 0;
}

uint64_t bssl::ssl_noop_x509_check_client_CA_names()
{
  return 1;
}

uint64_t bssl::ssl_noop_x509_session_verify_cert_chain(bssl *this, ssl_session_st *a2, bssl::SSL_HANDSHAKE *a3, unsigned __int8 *a4)
{
  return 0;
}

uint64_t bssl::ssl_noop_x509_ssl_auto_chain_if_needed(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  return 1;
}

uint64_t bssl::skip_early_data(bssl *this, ssl_st *a2, unsigned __int8 *a3)
{
  uint64_t v4;
  unsigned __int16 v5;

  v4 = *((_QWORD *)this + 6);
  v5 = *(_WORD *)(v4 + 208) + (_WORD)a3;
  *(_WORD *)(v4 + 208) = v5;
  if ((unint64_t)a3 > v5)
  {
    *(_WORD *)(v4 + 208) = 16385;
LABEL_4:
    ERR_put_error(16, 0, 270, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 187);
    LOBYTE(a2->version) = 10;
    return 4;
  }
  if (v5 > 0x4000u)
    goto LABEL_4;
  return 1;
}

BOOL bssl::ssl_is_key_type_supported(bssl *this)
{
  _BOOL4 v1;

  v1 = (_DWORD)this == 949;
  if ((_DWORD)this == 408)
    v1 = 1;
  return (_DWORD)this == 6 || v1;
}

BOOL bssl::ssl_has_private_key(bssl *this, const ssl_st *a2)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(*((_QWORD *)this + 1) + 32);
  return *v2 || v2[5] || bssl::ssl_signing_with_dc(this, a2);
}

uint64_t bssl::ssl_private_key_sign(uint64_t a1, ssl_st *a2, unint64_t *a3, unint64_t a4, evp_pkey_st *a5, unsigned __int8 *a6, size_t a7)
{
  bssl *v13;
  uint64_t v14;
  __int128 v15;
  int v16;
  unsigned __int8 *v17;
  size_t v18;
  unsigned __int8 *v19;
  size_t v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  const ssl_st *v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v35;
  int v36;
  char v37;
  unint64_t v38;
  int v39;
  char v40;
  EVP_MD_CTX ctx;
  __int128 v43;
  void *v44;
  uint64_t v45;

  v13 = *(bssl **)a1;
  v14 = *(_QWORD *)(a1 + 1592);
  v44 = 0;
  v45 = 0;
  if (v14)
  {
    *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&ctx.flags = v15;
    v43 = v15;
    *(_OWORD *)&ctx.digest = v15;
    CBB_zero(&ctx);
    if (!CBB_init((uint64_t)&ctx, 0x40uLL)
      || !EVP_marshal_public_key((uint64_t)&ctx, *(_QWORD *)(a1 + 1520))
      || !bssl::CBBFinishArray((uint64_t)&ctx, (uint64_t)&v44))
    {
      bssl::ssl_send_alert(v13, (ssl_st *)2, 80);
      CBB_cleanup((uint64_t)&ctx);
      goto LABEL_39;
    }
    CBB_cleanup((uint64_t)&ctx);
    v16 = *(_DWORD *)(a1 + 1600);
    if ((v16 & 0x100000) == 0 && *(unsigned __int16 *)(v14 + 72) == (_DWORD)a5 && a7 == *(_QWORD *)(v14 + 88))
    {
      if (a7)
      {
        v17 = *(unsigned __int8 **)(v14 + 80);
        v18 = a7 - 1;
        v19 = a6;
        while (1)
        {
          v20 = v18;
          if (*v19 != *v17)
            break;
          ++v19;
          ++v17;
          --v18;
          if (!v20)
            goto LABEL_12;
        }
      }
      else
      {
LABEL_12:
        if (v45 == *(_QWORD *)(v14 + 104))
        {
          if (v45)
          {
            v21 = *(unsigned __int8 **)(v14 + 96);
            v22 = (unsigned __int8 *)v44;
            v23 = v45 - 1;
            while (1)
            {
              v24 = v23;
              if (*v22 != *v21)
                break;
              ++v22;
              ++v21;
              --v23;
              if (!v24)
                goto LABEL_17;
            }
          }
          else
          {
LABEL_17:
            v25 = *(_QWORD *)(v14 + 120);
            if (v25 - 1 < a4)
            {
              *a3 = v25;
              v26 = *(_QWORD *)(v14 + 120);
              if (v26)
                memcpy(a2, *(const void **)(v14 + 112), v26);
LABEL_37:
              v33 = 0;
              goto LABEL_40;
            }
          }
        }
      }
    }
  }
  else
  {
    v16 = *(_DWORD *)(a1 + 1600);
  }
  if ((v16 & 0x2000000) != 0)
    __assert_rtn("ssl_private_key_sign", "ssl_privkey.cc", 245, "!hs->can_release_private_key");
  v27 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32);
  v28 = *(_QWORD *)(v27 + 40);
  v29 = *(const ssl_st **)v27;
  if (bssl::ssl_signing_with_dc((bssl *)a1, a2))
  {
    v30 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32);
    v29 = *(const ssl_st **)(v30 + 160);
    v28 = *(_QWORD *)(v30 + 168);
  }
  if (!v28)
  {
    *a3 = a4;
    *(_QWORD *)&v32 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&ctx.digest = v32;
    *(_OWORD *)&ctx.flags = v32;
    EVP_MD_CTX_init(&ctx);
    if (bssl::setup_ctx(v13, (ssl_st *)&ctx, v29, a5, 0)
      && EVP_DigestSign((uint64_t)&ctx, (uint64_t)a2, (uint64_t)a3, a6, a7))
    {
      EVP_MD_CTX_cleanup(&ctx);
      goto LABEL_35;
    }
    EVP_MD_CTX_cleanup(&ctx);
LABEL_39:
    v33 = 2;
    goto LABEL_40;
  }
  if ((*(_BYTE *)(a1 + 1602) & 4) != 0)
    v31 = (*(uint64_t (**)(bssl *, ssl_st *, unint64_t *, unint64_t))(v28 + 16))(v13, a2, a3, a4);
  else
    v31 = (*(uint64_t (**)(bssl *, ssl_st *, unint64_t *, unint64_t, evp_pkey_st *, unsigned __int8 *, size_t))v28)(v13, a2, a3, a4, a5, a6, a7);
  v33 = v31;
  if ((_DWORD)v31 == 2)
    ERR_put_error(16, 0, 287, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_privkey.cc", 260);
  *(_DWORD *)(a1 + 1600) = *(_DWORD *)(a1 + 1600) & 0xFFFBFFFF | (((_DWORD)v33 == 1) << 18);
  if (!(_DWORD)v33)
  {
LABEL_35:
    if (v14 && (*(_BYTE *)(a1 + 1602) & 0x10) != 0)
    {
      *(_WORD *)(v14 + 72) = (_WORD)a5;
      OPENSSL_free(*(_QWORD **)(v14 + 96));
      v35 = v45;
      *(_QWORD *)(v14 + 96) = v44;
      *(_QWORD *)(v14 + 104) = v35;
      v44 = 0;
      v45 = 0;
      v36 = bssl::Array<unsigned char>::Init(v14 + 80, a7);
      v37 = v36 ^ 1;
      if (!a7)
        v37 = 1;
      if ((v37 & 1) == 0)
        memcpy(*(void **)(v14 + 80), a6, a7);
      if (!v36)
        goto LABEL_39;
      v38 = *a3;
      v39 = bssl::Array<unsigned char>::Init(v14 + 112, v38);
      v40 = v39 ^ 1;
      if (!v38)
        v40 = 1;
      if ((v40 & 1) == 0)
        memcpy(*(void **)(v14 + 112), a2, v38);
      if (!v39)
        goto LABEL_39;
    }
    goto LABEL_37;
  }
LABEL_40:
  OPENSSL_free(v44);
  return v33;
}

void sub_1B4FC1BCC(_Unwind_Exception *a1, uint64_t a2, EVP_MD_CTX *ctx, uint64_t a4, uint64_t a5, uint64_t ctxa, uint64_t ctx_8, uint64_t ctx_16, uint64_t ctx_24, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_private_key_decrypt(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v6 = *((_DWORD *)a1 + 400);
  if ((v6 & 0x2000000) != 0)
    bssl::ssl_private_key_decrypt();
  v8 = *(uint64_t **)(a1[1] + 32);
  v9 = v8[5];
  if (v9)
  {
    v10 = *a1;
    if ((v6 & 0x40000) != 0)
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 16))(v10, a2, a3, a4);
    else
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 8))(v10, a2, a3, a4, a5, a6);
    v12 = v11;
    if ((_DWORD)v11 == 2)
      ERR_put_error(16, 0, 287, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_privkey.cc", 319);
    *((_DWORD *)a1 + 400) = a1[200] & 0xFFFBFFFF | (((_DWORD)v12 == 1) << 18);
  }
  else if (EVP_PKEY_get0_RSA(*v8))
  {
    return 2 * (RSA_decrypt() == 0);
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_privkey.cc", 328);
    return 2;
  }
  return v12;
}

BOOL bssl::ssl_private_key_supports_signature_algorithm(bssl *this, evp_pkey_st *a2)
{
  int v2;
  _BOOL8 result;
  __int16 *v5;
  uint64_t v6;
  int v7;
  int v8;
  const EVP_MD *v9;

  v2 = (int)a2;
  result = bssl::pkey_supports_algorithm(*(bssl **)this, *((const ssl_st **)this + 190), a2);
  if ((_DWORD)result)
  {
    if (v2 == 65281)
      return 1;
    v5 = &word_1E686D6B0;
    v6 = 8;
    do
    {
      v7 = (unsigned __int16)*v5;
      v5 += 16;
      --v6;
    }
    while (v7 != v2);
    if ((unint64_t)-v6 < 0xFFFFFFFFFFFFFFFDLL)
      return 1;
    v8 = EVP_PKEY_size(*((EVP_PKEY **)this + 190));
    v9 = (const EVP_MD *)(*((uint64_t (**)(void))v5 - 2))();
    return 2 * EVP_MD_size(v9) + 2 <= (unint64_t)v8;
  }
  return result;
}

uint64_t SSL_set_private_key_method(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  if (v2)
    *(_QWORD *)(*(_QWORD *)(v2 + 32) + 40) = a2;
  return result;
}

void *EVP_aead_aes_128_cbc_sha1_tls()
{
  return &aead_aes_128_cbc_sha1_tls;
}

void *EVP_aead_aes_128_cbc_sha1_tls_implicit_iv()
{
  return &aead_aes_128_cbc_sha1_tls_implicit_iv;
}

void *EVP_aead_aes_128_cbc_sha256_tls()
{
  return &aead_aes_128_cbc_sha256_tls;
}

void *EVP_aead_aes_256_cbc_sha384_tls()
{
  return &aead_aes_256_cbc_sha384_tls;
}

void *EVP_aead_aes_256_cbc_sha1_tls()
{
  return &aead_aes_256_cbc_sha1_tls;
}

void *EVP_aead_aes_256_cbc_sha1_tls_implicit_iv()
{
  return &aead_aes_256_cbc_sha1_tls_implicit_iv;
}

void *EVP_aead_des_ede3_cbc_sha1_tls()
{
  return &aead_des_ede3_cbc_sha1_tls;
}

void *EVP_aead_des_ede3_cbc_sha1_tls_implicit_iv()
{
  return &aead_des_ede3_cbc_sha1_tls_implicit_iv;
}

void *EVP_aead_null_sha1_tls()
{
  return &aead_null_sha1_tls;
}

uint64_t aead_aes_128_cbc_sha1_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  const EVP_CIPHER *v10;
  EVP_MD *v11;

  v10 = EVP_aes_128_cbc();
  v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 0);
}

void aead_tls_cleanup(uint64_t a1)
{
  EVP_CIPHER_CTX_cleanup((EVP_CIPHER_CTX *)(a1 + 8));
  HMAC_CTX_cleanup((HMAC_CTX *)(a1 + 160));
}

uint64_t aead_tls_open(uint64_t a1, unsigned __int8 *a2, size_t *a3, unint64_t a4, const unsigned __int8 *a5, uint64_t a6, const unsigned __int8 *a7, unint64_t a8, uint64_t a9, uint64_t a10)
{
  int v10;
  int v11;
  HMAC_CTX *v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  size_t v26;
  __int128 v27;
  size_t v28;
  char *v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  int v34;
  unsigned int len;
  size_t v36;
  uint64_t v37;
  size_t v38;
  int outl;
  _OWORD v40[4];
  unsigned __int8 md[16];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _BYTE data[11];
  __int16 v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 36))
  {
    v10 = 112;
    v11 = 244;
LABEL_13:
    ERR_put_error(30, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/cipher_extra/e_tls.c", v11);
    return 0;
  }
  v20 = (HMAC_CTX *)(a1 + 160);
  if (HMAC_size((const EVP_MD **)(a1 + 160)) > a8)
  {
    v10 = 101;
    v11 = 249;
    goto LABEL_13;
  }
  if (a4 < a8)
  {
    v10 = 103;
    v11 = 256;
    goto LABEL_13;
  }
  if (EVP_AEAD_nonce_length(*(_QWORD *)a1) != a6)
  {
    v10 = 111;
    v11 = 261;
    goto LABEL_13;
  }
  if (a10 != 11)
  {
    v10 = 109;
    v11 = 266;
    goto LABEL_13;
  }
  if (a8 >> 31)
  {
    v10 = 117;
    v11 = 272;
    goto LABEL_13;
  }
  if (EVP_CIPHER_CTX_mode(a1 + 8) != 2
    || *(_BYTE *)(a1 + 329)
    || (result = EVP_DecryptInit_ex((EVP_CIPHER_CTX *)(a1 + 8), 0, 0, 0, a5), (_DWORD)result))
  {
    outl = -1431655766;
    result = EVP_DecryptUpdate((EVP_CIPHER_CTX *)(a1 + 8), a2, &outl, a7, a8);
    if ((_DWORD)result)
    {
      v22 = outl;
      result = EVP_DecryptFinal_ex((EVP_CIPHER_CTX *)(a1 + 8), &a2[outl], &outl);
      if ((_DWORD)result)
      {
        if (outl + v22 != a8)
          aead_tls_open_cold_5();
        v37 = 0xAAAAAAAAAAAAAAAALL;
        v38 = 0xAAAAAAAAAAAAAAAALL;
        if (EVP_CIPHER_CTX_mode(a1 + 8) == 2)
        {
          v23 = EVP_CIPHER_CTX_block_size((const EVP_CIPHER_CTX *)(a1 + 8));
          v24 = HMAC_size(&v20->md);
          if (!EVP_tls_cbc_remove_padding(&v37, &v38, (uint64_t)a2, a8, v23, v24))
          {
            v10 = 101;
            v11 = 308;
            goto LABEL_13;
          }
          v25 = v38;
        }
        else
        {
          v37 = -1;
          v38 = a8;
          v25 = a8;
          if (HMAC_size(&v20->md) > a8)
            aead_tls_open_cold_4();
        }
        v26 = v25 - HMAC_size(&v20->md);
        *(_QWORD *)data = *(_QWORD *)a9;
        *(_DWORD *)&data[7] = *(_DWORD *)(a9 + 7);
        v46 = bswap32(v26) >> 16;
        *(_QWORD *)&v27 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v43 = v27;
        v44 = v27;
        *(_OWORD *)md = v27;
        v42 = v27;
        v36 = 0xAAAAAAAAAAAAAAAALL;
        v40[2] = v27;
        v40[3] = v27;
        v40[0] = v27;
        v40[1] = v27;
        if (EVP_CIPHER_CTX_mode(a1 + 8) == 2 && EVP_tls_cbc_record_digest_supported(v20->md))
        {
          if (!EVP_tls_cbc_digest_record(*(const EVP_MD **)(a1 + 160), md, &v36, data, (uint64_t)a2, v38, a8, a1 + 264, *(unsigned __int8 *)(a1 + 328)))
          {
            v10 = 101;
            v11 = 346;
            goto LABEL_13;
          }
          v28 = v36;
          if (v28 != HMAC_size(&v20->md))
            aead_tls_open_cold_3();
          v29 = (char *)v40;
          EVP_tls_cbc_copy_mac(v40, v36, (uint64_t)a2, v38, a8);
          v30 = v36;
        }
        else
        {
          if (EVP_CIPHER_CTX_mode(a1 + 8) == 2)
            aead_tls_open_cold_1();
          len = -1431655766;
          HMAC_Init_ex(v20, 0, 0, 0, 0);
          if (!v31)
            return 0;
          HMAC_Update(v20, data, 0xDuLL);
          if (!v32)
            return 0;
          HMAC_Update(v20, a2, v26);
          if (!v33)
            return 0;
          HMAC_Final(v20, md, &len);
          if (!v34)
            return 0;
          v30 = len;
          v36 = len;
          if (HMAC_size(&v20->md) != v30)
            aead_tls_open_cold_2();
          v29 = (char *)&a2[v26];
        }
        if (!CRYPTO_memcmp(v29, (char *)md, v30) && v37)
        {
          *a3 = v26;
          return 1;
        }
        v10 = 101;
        v11 = 380;
        goto LABEL_13;
      }
    }
  }
  return result;
}

void aead_tls_seal_scatter(uint64_t a1, unsigned __int8 *a2, void *a3, unint64_t *a4, unint64_t a5, const unsigned __int8 *a6, uint64_t a7, const unsigned __int8 *a8, unint64_t a9, uint64_t a10, uint64_t a11, unsigned __int8 *data, uint64_t a13)
{
  int v13;
  int v14;
  __int128 v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  unint64_t v29;
  unint64_t v30;
  __int128 v31;
  int v32;
  unint64_t v33;
  __int128 v34;
  int v35;
  int v36;
  int v37;
  int outl;
  unsigned int len;
  unsigned __int8 v40[2];
  unsigned __int8 out[16];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  unsigned __int8 md[16];
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)(a1 + 36))
  {
    v13 = 112;
    v14 = 128;
    goto LABEL_25;
  }
  if (a9 >> 31)
  {
    v13 = 117;
    v14 = 134;
LABEL_25:
    ERR_put_error(30, 0, v13, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/cipher_extra/e_tls.c", v14);
    return;
  }
  if (aead_tls_tag_len(a1, a9, a11) > a5)
  {
    v13 = 103;
    v14 = 139;
    goto LABEL_25;
  }
  if (EVP_AEAD_nonce_length(*(_QWORD *)a1) != a7)
  {
    v13 = 111;
    v14 = 144;
    goto LABEL_25;
  }
  if (a13 != 11)
  {
    v13 = 109;
    v14 = 149;
    goto LABEL_25;
  }
  *(_WORD *)v40 = bswap32(a9) >> 16;
  *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v59 = v22;
  v60 = v22;
  *(_OWORD *)md = v22;
  v58 = v22;
  len = -1431655766;
  HMAC_Init_ex((HMAC_CTX *)(a1 + 160), 0, 0, 0, 0);
  if (v23)
  {
    HMAC_Update((HMAC_CTX *)(a1 + 160), data, 0xBuLL);
    if (v24)
    {
      HMAC_Update((HMAC_CTX *)(a1 + 160), v40, 2uLL);
      if (v25)
      {
        HMAC_Update((HMAC_CTX *)(a1 + 160), a8, a9);
        if (v26)
        {
          HMAC_Final((HMAC_CTX *)(a1 + 160), md, &len);
          if (v27)
          {
            if (EVP_CIPHER_CTX_mode(a1 + 8) != 2
              || *(_BYTE *)(a1 + 329)
              || EVP_EncryptInit_ex((EVP_CIPHER_CTX *)(a1 + 8), 0, 0, 0, a6))
            {
              outl = -1431655766;
              if (EVP_EncryptUpdate((EVP_CIPHER_CTX *)(a1 + 8), a2, &outl, a8, a9))
              {
                v28 = EVP_CIPHER_CTX_block_size((const EVP_CIPHER_CTX *)(a1 + 8));
                v29 = v28;
                v30 = (v28 - (unint64_t)(a9 % v28)) % v28;
                if (v30)
                {
                  if (outl + v28 - v30 != a9)
                    aead_tls_seal_scatter_cold_6();
                  *(_QWORD *)&v31 = 0xAAAAAAAAAAAAAAAALL;
                  *((_QWORD *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  *(_OWORD *)out = v31;
                  v42 = v31;
                  v37 = -1431655766;
                  if (!EVP_EncryptUpdate((EVP_CIPHER_CTX *)(a1 + 8), out, &v37, md, v30))
                    return;
                  if (v37 != (_DWORD)v29)
                    aead_tls_seal_scatter_cold_5();
                  memcpy(&a2[outl], out, v29 - v30);
                  memcpy(a3, &out[v29 - v30], v30);
                  v32 = v30;
                }
                else
                {
                  v32 = 0;
                }
                if (!EVP_EncryptUpdate((EVP_CIPHER_CTX *)(a1 + 8), (unsigned __int8 *)a3 + v30, &outl, &md[v30], len - v32))return;
                v33 = v30 + outl;
                if (v29 < 2)
                  goto LABEL_36;
                if (v29 >= 0x101)
                  aead_tls_seal_scatter_cold_1();
                if (EVP_CIPHER_CTX_mode(a1 + 8) != 2)
                  aead_tls_seal_scatter_cold_4();
                *(_QWORD *)&v34 = 0xAAAAAAAAAAAAAAAALL;
                *((_QWORD *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
                v55 = v34;
                v56 = v34;
                v53 = v34;
                v54 = v34;
                v51 = v34;
                v52 = v34;
                v49 = v34;
                v50 = v34;
                v47 = v34;
                v48 = v34;
                v45 = v34;
                v46 = v34;
                v43 = v34;
                v44 = v34;
                *(_OWORD *)out = v34;
                v42 = v34;
                v35 = (len + a9) % v29;
                v36 = v29 - v35;
                if ((_DWORD)v29 != v35)
                  __memset_chk();
                if (EVP_EncryptUpdate((EVP_CIPHER_CTX *)(a1 + 8), (unsigned __int8 *)a3 + v33, &outl, out, v36))
                {
                  v33 += outl;
LABEL_36:
                  if (EVP_EncryptFinal_ex((EVP_CIPHER_CTX *)(a1 + 8), (unsigned __int8 *)a3 + v33, &outl))
                  {
                    if (outl)
                      aead_tls_seal_scatter_cold_3();
                    if (v33 != aead_tls_tag_len(a1, a9, a11))
                      aead_tls_seal_scatter_cold_2();
                    *a4 = v33;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

unint64_t aead_tls_tag_len(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const EVP_CIPHER_CTX *v4;
  uint64_t v5;
  unsigned int v6;

  if (a3)
    aead_tls_tag_len_cold_2();
  v4 = (const EVP_CIPHER_CTX *)(a1 + 8);
  v5 = HMAC_size((const EVP_MD **)(a1 + 160));
  if (EVP_CIPHER_CTX_mode((uint64_t)v4) == 2)
  {
    v6 = EVP_CIPHER_CTX_block_size(v4);
    if (!v6 || ((v6 - 1) & v6) != 0)
      aead_tls_tag_len_cold_1();
    return v6 + (v5 + a2) / (unint64_t)v6 * v6 - a2;
  }
  return v5;
}

uint64_t aead_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5, const EVP_CIPHER *a6, EVP_MD *md, int a8)
{
  size_t v15;
  size_t v16;
  uint64_t v17;
  int v18;
  int v19;
  const unsigned __int8 *v20;
  int v21;

  if (a4 && EVP_MD_size(md) != a4)
  {
    v18 = 122;
    v19 = 63;
    goto LABEL_8;
  }
  if (EVP_AEAD_key_length(*(unsigned __int8 **)a1) != a3)
  {
    v18 = 102;
    v19 = 68;
LABEL_8:
    ERR_put_error(30, 0, v18, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/cipher_extra/e_tls.c", v19);
    return 0;
  }
  v15 = EVP_MD_size(md);
  v16 = v15 + EVP_CIPHER_key_length(a6);
  if (a8)
    v17 = EVP_CIPHER_iv_length(a6);
  else
    v17 = 0;
  if (v17 + v16 != a3)
    aead_tls_init_cold_2();
  EVP_CIPHER_CTX_init((EVP_CIPHER_CTX *)(a1 + 8));
  HMAC_CTX_init((HMAC_CTX *)(a1 + 160));
  if (v15 >= 0x41)
    aead_tls_init_cold_1();
  if (v15)
    memcpy((void *)(a1 + 264), a2, v15);
  *(_BYTE *)(a1 + 328) = v15;
  *(_BYTE *)(a1 + 329) = a8;
  if (a8)
    v20 = (const unsigned __int8 *)&a2[v16];
  else
    v20 = 0;
  if (EVP_CipherInit_ex((EVP_CIPHER_CTX *)(a1 + 8), a6, 0, (const unsigned __int8 *)&a2[v15], v20, a5 == 1))
  {
    HMAC_Init_ex((HMAC_CTX *)(a1 + 160), a2, v15, md, 0);
    if (v21)
    {
      EVP_CIPHER_CTX_set_padding((EVP_CIPHER_CTX *)(a1 + 8), 0);
      return 1;
    }
  }
  EVP_CIPHER_CTX_cleanup((EVP_CIPHER_CTX *)(a1 + 8));
  HMAC_CTX_cleanup((HMAC_CTX *)(a1 + 160));
  return 0;
}

uint64_t aead_aes_128_cbc_sha1_tls_implicit_iv_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  const EVP_CIPHER *v10;
  EVP_MD *v11;

  v10 = EVP_aes_128_cbc();
  v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 1);
}

uint64_t aead_tls_get_iv(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unsigned int v6;

  v6 = EVP_CIPHER_CTX_iv_length((const EVP_CIPHER_CTX *)(a1 + 8));
  if (v6 < 2)
    return 0;
  *a2 = a1 + 60;
  *a3 = v6;
  return 1;
}

uint64_t aead_aes_128_cbc_sha256_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  const EVP_CIPHER *v10;
  EVP_MD *v11;

  v10 = EVP_aes_128_cbc();
  v11 = (EVP_MD *)EVP_sha256();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 0);
}

uint64_t aead_aes_256_cbc_sha384_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  const EVP_CIPHER *v10;
  EVP_MD *v11;

  v10 = EVP_aes_256_cbc();
  v11 = (EVP_MD *)EVP_sha384();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 0);
}

uint64_t aead_aes_256_cbc_sha1_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  const EVP_CIPHER *v10;
  EVP_MD *v11;

  v10 = EVP_aes_256_cbc();
  v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 0);
}

uint64_t aead_aes_256_cbc_sha1_tls_implicit_iv_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  const EVP_CIPHER *v10;
  EVP_MD *v11;

  v10 = EVP_aes_256_cbc();
  v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 1);
}

uint64_t aead_des_ede3_cbc_sha1_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  const EVP_CIPHER *v10;
  EVP_MD *v11;

  v10 = EVP_des_ede3_cbc();
  v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 0);
}

uint64_t aead_des_ede3_cbc_sha1_tls_implicit_iv_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  const EVP_CIPHER *v10;
  EVP_MD *v11;

  v10 = EVP_des_ede3_cbc();
  v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 1);
}

uint64_t aead_null_sha1_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  const EVP_CIPHER *v10;
  EVP_MD *v11;

  v10 = EVP_enc_null();
  v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 1);
}

int BN_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
{
  int v12;
  int v13;
  const BIGNUM *v14;
  int v16;
  unsigned int v17;
  __int128 v18;
  BIGNUM *v19;
  BIGNUM *v20;
  BN_MONT_CTX *v21;
  BN_MONT_CTX *v22;
  unsigned int v23;
  BIGNUM *v24;
  uint64_t v25;
  BIGNUM *v26;
  char v28;
  int v29;
  unsigned int v30;
  BIGNUM *v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  char v40;
  unsigned int v41;
  BN_MONT_CTX *mont;
  BIGNUM *b;
  BIGNUM *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  unint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (!BN_is_odd((uint64_t)m))
  {
    v12 = 104;
    v13 = 590;
    goto LABEL_8;
  }
  if (m->neg)
  {
    v12 = 109;
    v13 = 594;
LABEL_8:
    ERR_put_error(3, 0, v12, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/exponentiation.c", v13);
    LODWORD(v14) = 0;
    return (int)v14;
  }
  if (a->neg || (BN_ucmp(a, m) & 0x80000000) == 0)
  {
    v12 = 107;
    v13 = 599;
    goto LABEL_8;
  }
  v16 = BN_num_bits(p);
  if (v16)
  {
    v17 = v16;
    v60 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v18 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v59 = v18;
    v58 = v18;
    v57 = v18;
    v56 = v18;
    v55 = v18;
    v54 = v18;
    v53 = v18;
    v52 = v18;
    v51 = v18;
    v50 = v18;
    v49 = v18;
    v48 = v18;
    v47 = v18;
    v46 = v18;
    v45 = v18;
    BN_CTX_start(ctx);
    v19 = BN_CTX_get(ctx);
    v20 = BN_CTX_get(ctx);
    v21 = 0;
    LODWORD(v14) = 0;
    v44 = v20;
    if (!v19 || !v20)
      goto LABEL_67;
    if (m_ctx)
    {
      v22 = 0;
    }
    else
    {
      v21 = (BN_MONT_CTX *)BN_MONT_CTX_new_consttime(m, ctx);
      m_ctx = v21;
      v22 = v21;
      if (!v21)
      {
        LODWORD(v14) = 0;
LABEL_67:
        BN_MONT_CTX_free(v21);
        BN_CTX_end(ctx);
        return (int)v14;
      }
    }
    mont = v22;
    b = v19;
    if (v17 <= 0x29F)
    {
      if (v17 <= 0xEF)
      {
        if (v17 <= 0x4F)
        {
          if (v17 <= 0x17)
            v23 = 1;
          else
            v23 = 3;
        }
        else
        {
          v23 = 4;
        }
      }
      else
      {
        v23 = 5;
      }
    }
    else
    {
      v23 = 6;
    }
    if (BN_to_montgomery(v20, a, (BIGNUM *)m_ctx, ctx))
    {
      v41 = v23;
      v39 = v23 - 2;
      if (v23 < 2)
      {
LABEL_37:
        v28 = 0;
        v29 = v17 - 1;
        v30 = v41;
        v31 = b;
        while (1)
        {
          while (!BN_is_bit_set(p, v29))
          {
            if ((v28 & 1) != 0)
            {
              if (!BN_mod_mul_montgomery(v31, v31, v31, m_ctx, ctx))
                goto LABEL_65;
              if (!v29)
                goto LABEL_68;
            }
            else if (!v29)
            {
              BN_mod_exp_mont_cold_3();
            }
            --v29;
          }
          v40 = v28;
          v32 = 0;
          v33 = 1;
          if (v30 >= 2)
          {
            v34 = v29 - 1;
            if (v29 >= 1)
            {
              v32 = 0;
              v35 = v39;
              if (v34 < v39)
                v35 = v29 - 1;
              v36 = -v35;
              v37 = 1;
              do
              {
                if (BN_is_bit_set(p, v34))
                {
                  v33 = (v33 << (v37 - v32)) | 1;
                  v32 = v37;
                }
                ++v37;
                --v34;
              }
              while (v36 + v37 != 2);
            }
          }
          v31 = b;
          if ((v40 & (v32 >= 0)) == 1)
            break;
LABEL_57:
          if ((v33 & 1) == 0)
            BN_mod_exp_mont_cold_1();
          v30 = v41;
          if (v33 >= 1 << v41)
            BN_mod_exp_mont_cold_2();
          if ((v40 & 1) != 0)
          {
            if (!BN_mod_mul_montgomery(b, b, *(&v44 + (v33 >> 1)), m_ctx, ctx))
              goto LABEL_65;
          }
          else if (!BN_copy(b, *(&v44 + (v33 >> 1))))
          {
            goto LABEL_65;
          }
          if (v29 == v32)
          {
LABEL_68:
            LODWORD(v14) = BN_from_montgomery(r, v31, m_ctx, ctx) != 0;
            goto LABEL_66;
          }
          v29 += ~v32;
          v28 = 1;
        }
        v38 = v32 + 1;
        while (BN_mod_mul_montgomery(b, b, b, m_ctx, ctx))
        {
          if (!--v38)
            goto LABEL_57;
        }
      }
      else
      {
        v24 = BN_CTX_get(ctx);
        v14 = v24;
        if (!v24)
        {
LABEL_66:
          v21 = mont;
          goto LABEL_67;
        }
        if (BN_mod_mul_montgomery(v24, v20, v20, m_ctx, ctx))
        {
          v25 = 0;
          while (1)
          {
            v26 = BN_CTX_get(ctx);
            *(&v44 + v25 + 1) = v26;
            if (!v26 || !BN_mod_mul_montgomery(v26, *(&v44 + v25), v14, m_ctx, ctx))
              break;
            if ((v25++ + 2) >> (v41 - 1))
              goto LABEL_37;
          }
        }
      }
    }
LABEL_65:
    LODWORD(v14) = 0;
    goto LABEL_66;
  }
  if (BN_abs_is_word((unsigned int *)m, 1))
  {
    BN_zero((uint64_t)r);
    LODWORD(v14) = 1;
    return (int)v14;
  }
  return BN_one((uint64_t)r);
}

void bn_mod_exp_mont_small(unint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t *v7;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unsigned int v14;
  unint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unint64_t v20;
  __int128 v21;
  unsigned int v22;
  char v24;
  uint64_t v25;
  unint64_t i;
  uint64_t v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unsigned int v32;
  int is_bit_set_words;
  uint64_t v34;
  unint64_t v35;
  int j;
  unint64_t v37;
  uint64_t *v38;
  unsigned int v39;
  unint64_t num;
  _OWORD v41[4];
  unint64_t v42;
  unint64_t __b[146];

  __b[144] = *MEMORY[0x1E0C80C00];
  if (a5 >> 58 || a3 > 9 || (v7 = (uint64_t *)a6, *(_DWORD *)(a6 + 32) != a3))
    abort();
  if (!BN_is_odd(a6 + 24))
    bn_mod_exp_mont_small_cold_1();
  num = a3;
  v11 = a5 - 1;
  v12 = a5 << 6;
  do
  {
    if (v11 == -1)
    {
      bn_from_montgomery_small(a1, a3, *v7, a3, (uint64_t)v7);
      return;
    }
    v13 = *(_QWORD *)(a4 + 8 * v11--);
    v12 -= 64;
  }
  while (!v13);
  v14 = BN_num_bits_word(v13);
  v15 = v12 + v14;
  if (!v15)
    bn_mod_exp_mont_small_cold_2();
  if (v15 <= 0x29F)
  {
    if (v15 <= 0xEF)
    {
      if (v15 <= 0x17)
        v17 = 1;
      else
        v17 = 3;
      if (v15 <= 0x4F)
        v16 = v17;
      else
        v16 = 4;
    }
    else
    {
      v16 = 5;
    }
  }
  else
  {
    v16 = 6;
  }
  v18 = v14;
  if (v16 >= 5)
    v19 = 5;
  else
    v19 = v16;
  memset(__b, 170, 0x480uLL);
  if (num)
    __memcpy_chk();
  v20 = v11 + 2;
  v37 = v19 - 2;
  v39 = v19;
  if (v19 >= 2)
  {
    v42 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v21 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v41[2] = v21;
    v41[3] = v21;
    v41[0] = v21;
    v41[1] = v21;
    bn_mod_mul_montgomery_small((unint64_t *)v41, __b, __b, num, (uint64_t)v7);
    v22 = 2;
    do
      bn_mod_mul_montgomery_small(&__b[9 * v22 - 9], &__b[9 * v22 - 18], (unint64_t *)v41, num, (uint64_t)v7);
    while (!(v22++ >> (v19 - 1)));
  }
  v24 = 0;
  v25 = v18 + v12 - 1;
  v38 = v7;
  do
  {
    for (i = v25; !bn_is_bit_set_words(a4, v20, i); --i)
    {
      if ((v24 & 1) != 0)
      {
        bn_mod_mul_montgomery_small(a1, a1, a1, num, (uint64_t)v7);
        if (!i)
          goto LABEL_59;
      }
      else if (!i)
      {
        bn_mod_exp_mont_small_cold_5();
      }
    }
    if (v19 < 2 || !i)
    {
      v28 = 0;
      v32 = 1;
      v35 = num;
      if ((v24 & 1) == 0)
        goto LABEL_56;
LABEL_47:
      for (j = -1; j != v28; ++j)
        bn_mod_mul_montgomery_small(a1, a1, a1, v35, (uint64_t)v7);
LABEL_51:
      v19 = v39;
      goto LABEL_52;
    }
    v27 = 0;
    v28 = 0;
    v29 = i - 1;
    v30 = v37;
    if (i - 1 < v37)
      v30 = i - 1;
    v31 = v30 + 1;
    v32 = 1;
    do
    {
      is_bit_set_words = bn_is_bit_set_words(a4, v20, v29);
      v34 = v27 + 1;
      if (is_bit_set_words)
      {
        v32 = (v32 << (v27 - v28 + 1)) | 1;
        v28 = v27 + 1;
      }
      --v29;
      ++v27;
    }
    while (v31 != v34);
    v7 = v38;
    if ((v24 & 1) == 0)
    {
      v35 = num;
      goto LABEL_51;
    }
    v35 = num;
    v19 = v39;
    if (v28 != -1)
      goto LABEL_47;
LABEL_52:
    if ((v32 & 1) == 0)
      bn_mod_exp_mont_small_cold_3();
    if (v32 >> v19)
      bn_mod_exp_mont_small_cold_4();
    if ((v24 & 1) != 0)
    {
      bn_mod_mul_montgomery_small(a1, a1, &__b[9 * (v32 >> 1)], v35, (uint64_t)v7);
      goto LABEL_58;
    }
LABEL_56:
    if (v35)
      memcpy(a1, &__b[9 * (v32 >> 1)], 8 * num);
LABEL_58:
    v25 = i - (v28 + 1);
    v24 = 1;
  }
  while (i != v28);
LABEL_59:
  OPENSSL_cleanse(__b, 0x480uLL);
}

void bn_mod_inverse0_prime_mont_small(unint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v8;
  __int128 v9;
  unint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  _OWORD v14[4];
  unint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a3 > 9 || *(_DWORD *)(a4 + 32) != a3)
    abort();
  v8 = 0xAAAAAAAAAAAAAAAALL;
  v15 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[2] = v9;
  v14[3] = v9;
  v14[0] = v9;
  v14[1] = v9;
  if (a3 && (__memcpy_chk(), v8 = *(_QWORD *)&v14[0], *(_QWORD *)&v14[0] < 2uLL))
  {
    *(_QWORD *)&v14[0] -= 2;
    v10 = a3 - 2;
    if (a3 >= 2)
    {
      v11 = (_QWORD *)v14 + 1;
      do
      {
        v12 = v10;
        if ((*v11++)-- != 0)
          break;
        --v10;
      }
      while (v12);
    }
  }
  else
  {
    *(_QWORD *)&v14[0] = v8 - 2;
  }
  bn_mod_exp_mont_small(a1, a2, a3, (uint64_t)v14, a3, a4);
}

int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
  int v12;
  int v13;
  _BOOL4 v14;
  int top;
  BN_MONT_CTX *v17;
  BN_MONT_CTX *v18;
  int d;
  int v20;
  int v21;
  int v22;
  int v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  _QWORD *v35;
  signed int v36;
  BN_MONT_CTX *v37;
  uint64_t v38;
  uint64_t len;
  BIGNUM b;
  BIGNUM r;

  if (!BN_is_odd((uint64_t)m))
  {
    v12 = 104;
    v13 = 894;
    goto LABEL_8;
  }
  if (m->neg)
  {
    v12 = 109;
    v13 = 898;
LABEL_8:
    ERR_put_error(3, 0, v12, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/exponentiation.c", v13);
    return 0;
  }
  if (a->neg || (BN_ucmp(a, m) & 0x80000000) == 0)
  {
    v12 = 107;
    v13 = 902;
    goto LABEL_8;
  }
  top = p->top;
  if (top)
  {
    if (in_mont)
    {
      v17 = 0;
    }
    else
    {
      v18 = (BN_MONT_CTX *)BN_MONT_CTX_new_consttime(m, ctx);
      in_mont = v18;
      v17 = v18;
      if (!v18)
      {
        v14 = 0;
        v25 = 0;
        len = 0;
        v26 = 0;
        goto LABEL_64;
      }
    }
    v37 = v17;
    d = (int)in_mont->N.d;
    if (top == 1)
      v20 = 3;
    else
      v20 = 1;
    if (top <= 1)
      v21 = v20;
    else
      v21 = 4;
    if (top <= 4)
      v22 = v21;
    else
      v22 = 5;
    if (top > 14)
      v22 = 6;
    if (d >= 0x401)
      BN_mod_exp_mont_consttime_cold_1();
    v36 = v22;
    v23 = 1 << v22;
    len = 8 * d * (uint64_t)((1 << v22) + 2);
    v24 = OPENSSL_malloc(len + 64);
    if (!v24)
    {
      v14 = 0;
      v25 = 0;
      v26 = 0;
      goto LABEL_58;
    }
    v34 = v23;
    v35 = v24;
    v38 = (uint64_t)v24 + (-(int)v24 & 0x3FLL);
    if ((v38 & 0x3F) != 0)
      BN_mod_exp_mont_consttime_cold_4();
    if (d)
      bzero((void *)v38, len);
    r.d = (unint64_t *)(v38 + 8 * (d << v36));
    b.d = &r.d[d];
    b.top = 0;
    b.dmax = d;
    r.top = 0;
    r.dmax = d;
    *(_QWORD *)&b.neg = 0x200000000;
    *(_QWORD *)&r.neg = 0x200000000;
    if (!bn_one_to_montgomery(&r, (BIGNUM *)in_mont, ctx))
    {
      v14 = 0;
      v18 = v37;
      v26 = (void *)v38;
      v25 = v35;
      goto LABEL_64;
    }
    v25 = v35;
    if (bn_resize_words((uint64_t)&r, d))
    {
      if (a->neg)
        BN_mod_exp_mont_consttime_cold_3();
      if ((BN_ucmp(a, m) & 0x80000000) == 0)
        BN_mod_exp_mont_consttime_cold_2();
      if (BN_to_montgomery(&b, a, (BIGNUM *)in_mont, ctx)
        && bn_resize_words((uint64_t)&b, d))
      {
        v26 = (void *)v38;
        copy_to_prebuf((uint64_t)&r, d, v38, 0);
        copy_to_prebuf((uint64_t)&b, d, v38, 1);
        if (v36 >= 2)
        {
          if (BN_mod_mul_montgomery(&r, &b, &b, in_mont, ctx))
          {
            copy_to_prebuf((uint64_t)&r, d, v38, 2);
            if (v34 <= 4)
              v27 = 4;
            else
              v27 = v34;
            v28 = 3;
            while (BN_mod_mul_montgomery(&r, &b, &r, in_mont, ctx))
            {
              copy_to_prebuf((uint64_t)&r, d, v38, v28++);
              if (v27 == v28)
                goto LABEL_46;
            }
          }
          goto LABEL_56;
        }
LABEL_46:
        v29 = (top << 6) - 1;
        v30 = 0;
        if (((v29 % v36) & 0x80000000) == 0)
        {
          v31 = v29 % v36 + 1;
          do
          {
            v30 = BN_is_bit_set(p, v29--) + 2 * v30;
            --v31;
          }
          while (v31);
        }
        v26 = (void *)v38;
        if (!copy_from_prebuf((uint64_t)&r, d, v38, v30, v36))
        {
LABEL_56:
          v14 = 0;
LABEL_58:
          v18 = v37;
LABEL_64:
          BN_MONT_CTX_free(v18);
          if (!v25)
          {
            if (v26)
              OPENSSL_cleanse(v26, len);
          }
          OPENSSL_free(v25);
          return v14;
        }
LABEL_50:
        if (v29 < 0)
        {
          v14 = BN_from_montgomery(rr, &r, in_mont, ctx) != 0;
          goto LABEL_60;
        }
        v32 = 0;
        v33 = 0;
        while (BN_mod_mul_montgomery(&r, &r, &r, in_mont, ctx))
        {
          v33 = BN_is_bit_set(p, v29 + v32--) + 2 * v33;
          if (!(v36 + v32))
          {
            if (!copy_from_prebuf((uint64_t)&b, d, v38, v33, v36))
              break;
            v29 += v32;
            v26 = (void *)v38;
            if (BN_mod_mul_montgomery(&r, &r, &b, in_mont, ctx))
              goto LABEL_50;
            goto LABEL_56;
          }
        }
      }
    }
    v14 = 0;
LABEL_60:
    v18 = v37;
    v26 = (void *)v38;
    goto LABEL_64;
  }
  if (BN_abs_is_word((unsigned int *)m, 1))
  {
    BN_zero((uint64_t)rr);
    return 1;
  }
  return BN_one((uint64_t)rr);
}

uint64_t copy_to_prebuf(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t result;

  result = bn_copy_words((void *)(a3 + 8 * a4 * a2), a2, a1);
  if (!(_DWORD)result)
    copy_to_prebuf_cold_1();
  return result;
}

uint64_t copy_from_prebuf(uint64_t a1, int a2, uint64_t a3, int a4, char a5)
{
  uint64_t v10;
  uint64_t result;
  size_t v12;
  unsigned int v13;
  uint64_t v14;
  _QWORD *v15;

  v10 = a2;
  result = bn_wexpand((_QWORD **)a1, a2);
  if ((_DWORD)result)
  {
    v12 = 8 * v10;
    if (a2)
      bzero(*(void **)a1, v12);
    v13 = 0;
    do
    {
      if (a2 >= 1)
      {
        v14 = 0;
        v15 = *(_QWORD **)a1;
        do
        {
          v15[v14] |= *(_QWORD *)(a3 + v14 * 8) & ((((int)(v13 ^ a4) - 1) & ~(uint64_t)(int)(v13 ^ a4)) >> 63);
          ++v14;
        }
        while (a2 != v14);
      }
      ++v13;
      a3 += v12;
    }
    while (!(v13 >> a5));
    *(_DWORD *)(a1 + 8) = a2;
    return 1;
  }
  return result;
}

int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  int neg;
  int result;
  BOOL v6;
  const BIGNUM *v7;
  const BIGNUM *v8;
  int v9;

  neg = a->neg;
  if (neg == b->neg)
  {
    result = bn_uadd_consttime((uint64_t)r, (uint64_t)a, (uint64_t)b);
    if (!result)
      goto LABEL_16;
    goto LABEL_15;
  }
  v6 = neg == 0;
  if (neg)
    v7 = b;
  else
    v7 = a;
  if (v6)
    v8 = b;
  else
    v8 = a;
  if (BN_ucmp(v7, v8) < 0)
  {
    result = bn_usub_consttime((uint64_t)r, (uint64_t)v8, (uint64_t)v7);
    if (!result)
      return result;
    neg = 1;
    goto LABEL_15;
  }
  v9 = bn_usub_consttime((uint64_t)r, (uint64_t)v7, (uint64_t)v8);
  neg = 0;
  result = 0;
  if (v9)
  {
LABEL_15:
    bn_set_minimal_width((uint64_t)r);
    result = 1;
LABEL_16:
    r->neg = neg;
  }
  return result;
}

int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  int result;

  result = bn_usub_consttime((uint64_t)r, (uint64_t)a, (uint64_t)b);
  if (result)
  {
    bn_set_minimal_width((uint64_t)r);
    return 1;
  }
  return result;
}

uint64_t bn_uadd_consttime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  unint64_t v11;
  _QWORD *v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v4 = *(_DWORD *)(a2 + 8);
  v5 = *(_DWORD *)(a3 + 8);
  if (v4 >= v5)
    v6 = a3;
  else
    v6 = a2;
  if (v4 >= v5)
    v7 = a2;
  else
    v7 = a3;
  v8 = *(int *)(v7 + 8);
  v9 = *(int *)(v6 + 8);
  result = bn_wexpand((_QWORD **)a1, v8 + 1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a1 + 8) = v8 + 1;
    v11 = bn_add_words(*(unint64_t **)a1, *(const unint64_t **)v7, *(const unint64_t **)v6, v9);
    v12 = *(_QWORD **)a1;
    if ((int)v9 < (int)v8)
    {
      v13 = (uint64_t *)(*(_QWORD *)v7 + 8 * v9);
      v14 = &v12[v9];
      v15 = v8 - v9;
      do
      {
        v16 = *v13++;
        v17 = v16 + v11;
        v11 = __CFADD__(v16, v11);
        *v14++ = v17;
        --v15;
      }
      while (v15);
    }
    v12[v8] = v11;
    return 1;
  }
  return result;
}

int BN_sub_word(BIGNUM *a, unint64_t w)
{
  unint64_t v2;
  int v4;
  int result;
  int v6;
  unint64_t *d;
  unint64_t v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  if (!w)
    return 1;
  v2 = w;
  if (BN_is_zero((uint64_t)a))
  {
    v4 = BN_set_word(a, v2);
    if (v4)
      BN_set_negative(a, 1);
    return v4;
  }
  if (a->neg)
  {
    a->neg = 0;
    result = BN_add_word(a, v2);
    a->neg = 1;
    return result;
  }
  v6 = bn_minimal_width((uint64_t)a);
  d = a->d;
  v8 = *a->d;
  if (v6 != 1 || v8 >= v2)
  {
    v9 = 0;
    v10 = v8 - v2;
    if (v8 < v2)
    {
      v2 = 1;
      do
      {
        *d = v10;
        v11 = d[1];
        ++d;
        v8 = v11;
        ++v9;
        v10 = -1;
      }
      while (!v11);
    }
    v12 = v8 - v2;
    *d = v12;
    if (!v12 && v9 == a->top - 1)
      a->top = v9;
    return 1;
  }
  *d = v2 - v8;
  v4 = 1;
  a->neg = 1;
  return v4;
}

BIGNUM *__cdecl BN_mod_sqrt(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
{
  BIGNUM *v8;
  int is_bit_set;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  unsigned int v18;
  int v19;
  int v20;
  BIGNUM *v21;
  unint64_t v22;
  int v23;
  int (__cdecl *v24)(BIGNUM *, const BIGNUM *, const BIGNUM *);
  int v25;
  BIGNUM *v26;
  const BIGNUM *v27;
  const BIGNUM *i;
  int v29;
  unsigned int v30;
  BIGNUM *aa;
  BIGNUM *r;

  if (!BN_is_odd((uint64_t)n) || BN_abs_is_word((unsigned int *)n, 1))
  {
    if (!BN_abs_is_word((unsigned int *)n, 2))
    {
      ERR_put_error(3, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/sqrt.c", 88);
      return 0;
    }
    v8 = ret;
    if (ret || (v8 = BN_new()) != 0)
    {
      is_bit_set = BN_is_bit_set(a, 0);
      goto LABEL_13;
    }
LABEL_14:
    if (v8 != ret)
      BN_free(v8);
    return 0;
  }
  if (!BN_is_zero((uint64_t)a) && !BN_is_one((unsigned int *)a))
  {
    BN_CTX_start(ctx);
    v11 = BN_CTX_get(ctx);
    v12 = BN_CTX_get(ctx);
    v13 = BN_CTX_get(ctx);
    v14 = BN_CTX_get(ctx);
    v15 = BN_CTX_get(ctx);
    v16 = BN_CTX_get(ctx);
    if (!v16)
    {
LABEL_64:
      v8 = 0;
      goto LABEL_65;
    }
    v17 = v16;
    r = v12;
    v8 = ret;
    if (!ret)
    {
      v8 = BN_new();
      if (!v8)
        goto LABEL_62;
    }
    if (!BN_nnmod(v11, a, n, ctx))
      goto LABEL_62;
    v18 = 0;
    do
      ++v18;
    while (!BN_is_bit_set(n, v18));
    if (v18 == 2)
    {
      if (!bn_mod_lshift1_consttime((uint64_t)v14, (uint64_t)v11, (uint64_t)n, ctx))
        goto LABEL_62;
      if (!BN_rshift(v13, n, 3))
        goto LABEL_62;
      v13->neg = 0;
      if (!BN_mod_exp_mont(r, v14, v13, n, ctx, 0)
        || !BN_mod_sqr(v17, r, n, ctx)
        || !BN_mod_mul(v14, v14, v17, n, ctx)
        || !BN_sub_word(v14, 1uLL)
        || !BN_mod_mul(v15, v11, r, n, ctx)
        || !BN_mod_mul(v15, v15, v14, n, ctx))
      {
        goto LABEL_62;
      }
      v21 = v8;
LABEL_41:
      if (!BN_copy(v21, v15))
        goto LABEL_62;
      goto LABEL_29;
    }
    if (v18 == 1)
    {
      if (BN_rshift(v13, n, 2))
      {
        v13->neg = 0;
        if (BN_add_word(v13, 1uLL))
        {
          if (BN_mod_exp_mont(v8, v11, v13, n, ctx, 0))
          {
LABEL_29:
            if (!BN_mod_sqr(v15, v8, n, ctx))
              goto LABEL_62;
            if (!BN_cmp(v15, v11))
            {
LABEL_65:
              BN_CTX_end(ctx);
              return v8;
            }
            v19 = 110;
            v20 = 409;
            goto LABEL_61;
          }
        }
      }
LABEL_62:
      if (v8 != ret)
        BN_clear_free(v8);
      goto LABEL_64;
    }
    if (!BN_copy(v13, n))
      goto LABEL_62;
    aa = v15;
    v13->neg = 0;
    v22 = 2;
    while (1)
    {
      if (v22 <= 0x15)
        goto LABEL_52;
      v23 = BN_num_bits(n);
      if (!BN_pseudo_rand(v17, v23, 0, 0))
        goto LABEL_62;
      if ((BN_ucmp(v17, n) & 0x80000000) == 0)
      {
        v24 = BN_add;
        if (!n->neg)
          v24 = BN_sub;
        if (!((unsigned int (*)(BIGNUM *, BIGNUM *, const BIGNUM *))v24)(v17, v17, n))
          goto LABEL_62;
      }
      if (BN_is_zero((uint64_t)v17))
      {
LABEL_52:
        if (!BN_set_word(v17, v22))
          goto LABEL_62;
      }
      v25 = bn_jacobi(v17, v13, ctx);
      if (v25 < -1)
        goto LABEL_62;
      if (v25 != 1)
        break;
      if (++v22 == 82)
        goto LABEL_60;
    }
    if (v25 != -1)
    {
      if (!v25)
      {
        v19 = 114;
        v20 = 257;
        goto LABEL_61;
      }
LABEL_60:
      v19 = 115;
      v20 = 267;
      goto LABEL_61;
    }
    if (!BN_rshift(v13, v13, v18) || !BN_mod_exp_mont(v17, v17, v13, n, ctx, 0))
      goto LABEL_62;
    if (BN_is_one((unsigned int *)v17))
    {
      v19 = 114;
      v20 = 282;
LABEL_61:
      ERR_put_error(3, 0, v19, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/sqrt.c", v20);
      goto LABEL_62;
    }
    if (!BN_rshift1(v14, v13))
      goto LABEL_62;
    if (BN_is_zero((uint64_t)v14))
    {
      if (!BN_nnmod(v14, v11, n, ctx))
        goto LABEL_62;
      if (!BN_is_zero((uint64_t)v14))
      {
        if (!BN_one((uint64_t)aa))
          goto LABEL_62;
LABEL_79:
        if (BN_mod_sqr(r, aa, n, ctx) && BN_mod_mul(r, r, v11, n, ctx))
        {
          v26 = aa;
          v27 = aa;
          for (i = v11; BN_mod_mul(v26, v27, i, n, ctx); i = v17)
          {
            if (BN_is_one((unsigned int *)r))
            {
              v21 = v8;
              v15 = aa;
              goto LABEL_41;
            }
            v29 = v18 - 2;
            if (v18 < 2)
            {
LABEL_100:
              v19 = 110;
              v20 = 377;
              goto LABEL_61;
            }
            v30 = v18 - 1;
            v18 = 1;
            while (1)
            {
              if (v18 == 1)
              {
                if (!BN_mod_sqr(v14, r, n, ctx))
                  goto LABEL_62;
              }
              else if (!BN_mod_mul(v14, v14, v14, n, ctx))
              {
                goto LABEL_62;
              }
              if (BN_is_one((unsigned int *)v14))
                break;
              ++v18;
              --v29;
              --v30;
              if (v29 == -1)
                goto LABEL_100;
            }
            if (!BN_copy(v14, v17))
              goto LABEL_62;
            if (v29 >= 1)
            {
              while (BN_mod_sqr(v14, v14, n, ctx))
              {
                if ((int)--v30 < 2)
                  goto LABEL_97;
              }
              goto LABEL_62;
            }
LABEL_97:
            if (!BN_mod_mul(v17, v14, v14, n, ctx) || !BN_mod_mul(aa, aa, v14, n, ctx))
              goto LABEL_62;
            v26 = r;
            v27 = r;
          }
        }
        goto LABEL_62;
      }
    }
    else
    {
      if (!BN_mod_exp_mont(aa, v11, v14, n, ctx, 0))
        goto LABEL_62;
      if (!BN_is_zero((uint64_t)aa))
        goto LABEL_79;
    }
    BN_zero((uint64_t)v8);
    goto LABEL_65;
  }
  v8 = ret;
  if (!ret)
  {
    v8 = BN_new();
    if (!v8)
      goto LABEL_14;
  }
  is_bit_set = BN_is_one((unsigned int *)a);
LABEL_13:
  if (!BN_set_word(v8, is_bit_set))
    goto LABEL_14;
  return v8;
}

int SHA256_Init(SHA256_CTX *c)
{
  *(_OWORD *)&c->data[10] = 0u;
  *(_OWORD *)&c->data[14] = 0u;
  *(_OWORD *)&c->data[2] = 0u;
  *(_OWORD *)&c->data[6] = 0u;
  *(_OWORD *)c->h = xmmword_1B5012580;
  *(_OWORD *)&c->h[4] = xmmword_1B5012590;
  *(_OWORD *)&c->Nl = 0u;
  c->md_len = 32;
  return 1;
}

int SHA256_Final(unsigned __int8 *md, SHA256_CTX *c)
{
  return sha256_final_impl(md, c->md_len, (uint64_t)c);
}

void SHA256_Transform(SHA256_CTX *c, const unsigned __int8 *data)
{
  sha256_block_data_order((unint64_t)c, (unsigned int *)data, 1);
}

void bn_sqr_words(unint64_t *rp, const unint64_t *ap, int num)
{
  unint64_t v3;

  if (*(_QWORD *)&num)
  {
    if (*(_QWORD *)&num < 4uLL)
      goto LABEL_8;
    do
    {
      *(_OWORD *)rp = *ap * (unsigned __int128)*ap;
      *((_OWORD *)rp + 1) = ap[1] * (unsigned __int128)ap[1];
      *((_OWORD *)rp + 2) = ap[2] * (unsigned __int128)ap[2];
      *((_OWORD *)rp + 3) = ap[3] * (unsigned __int128)ap[3];
      ap += 4;
      rp += 8;
      *(_QWORD *)&num -= 4;
    }
    while (*(_QWORD *)&num >= 4uLL);
    if (*(_QWORD *)&num)
    {
LABEL_8:
      do
      {
        v3 = *ap++;
        *(_OWORD *)rp = v3 * (unsigned __int128)v3;
        rp += 2;
        --*(_QWORD *)&num;
      }
      while (*(_QWORD *)&num);
    }
  }
}

_QWORD *bn_mul_comba8(_QWORD *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  __int128 v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unsigned __int128 v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _BOOL8 v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  unsigned __int128 v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  unsigned __int128 v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  uint64_t v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  _BOOL8 v136;
  unint64_t v137;
  unint64_t v138;
  uint64_t v139;
  unint64_t v140;
  unsigned __int128 v141;
  unint64_t v142;
  uint64_t v143;
  uint64_t v144;
  _BOOL8 v145;
  unint64_t v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  unint64_t v154;
  unint64_t v155;
  uint64_t v156;
  unint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  unint64_t v162;
  unint64_t v163;
  uint64_t v164;
  unint64_t v165;
  uint64_t v166;
  uint64_t v167;
  unint64_t v168;
  uint64_t v169;
  unint64_t v170;
  unint64_t v171;
  unint64_t v172;
  unint64_t v173;
  uint64_t v174;
  unint64_t v175;
  unsigned __int128 v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  _BOOL8 v183;
  unint64_t v184;
  unint64_t v185;
  unint64_t v186;
  uint64_t v187;
  unint64_t v188;
  unsigned __int128 v189;
  unint64_t v190;
  unint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  unint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  unint64_t v201;
  unint64_t v202;
  unint64_t v203;
  unint64_t v204;
  uint64_t v205;
  unint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unint64_t v209;
  uint64_t v210;
  unint64_t v211;
  unint64_t v212;
  uint64_t v213;
  unint64_t v214;
  unsigned __int128 v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  unint64_t v219;
  uint64_t v220;
  unint64_t v221;
  uint64_t v222;
  uint64_t v223;
  _BOOL8 v224;
  unint64_t v225;
  unint64_t v226;
  uint64_t v227;
  unint64_t v228;
  unsigned __int128 v229;
  unint64_t v230;
  unint64_t v231;
  unint64_t v232;
  unint64_t v233;
  uint64_t v234;
  unint64_t v235;
  uint64_t v236;
  uint64_t v237;
  _BOOL8 v238;
  unint64_t v239;
  unint64_t v240;
  uint64_t v241;
  unint64_t v242;
  unsigned __int128 v243;
  unint64_t v244;
  uint64_t v245;
  uint64_t v246;
  _BOOL8 v247;
  unint64_t v248;
  unint64_t v249;
  uint64_t v250;
  unint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  unint64_t v256;
  unint64_t v257;
  uint64_t v258;
  unint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  unint64_t v264;
  unint64_t v265;
  uint64_t v266;
  unint64_t v267;
  uint64_t v268;
  uint64_t v269;
  unint64_t v270;
  uint64_t v271;
  unint64_t v272;
  unint64_t v273;
  unint64_t v274;
  unint64_t v275;
  uint64_t v276;
  unint64_t v277;
  unsigned __int128 v278;
  unint64_t v279;
  unint64_t v280;
  uint64_t v281;
  unint64_t v282;
  uint64_t v283;
  uint64_t v284;
  _BOOL8 v285;
  unint64_t v286;
  unint64_t v287;
  unint64_t v288;
  uint64_t v289;
  unint64_t v290;
  unsigned __int128 v291;
  unint64_t v292;
  unint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  unint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  unint64_t v303;
  unint64_t v304;
  unint64_t v305;
  unint64_t v306;
  uint64_t v307;
  unint64_t v308;
  uint64_t v309;
  uint64_t v310;
  unint64_t v311;
  uint64_t v312;
  unint64_t v313;
  unint64_t v314;
  uint64_t v315;
  unint64_t v316;
  unsigned __int128 v317;
  unint64_t v318;
  unint64_t v319;
  unint64_t v320;
  unint64_t v321;
  uint64_t v322;
  unint64_t v323;
  uint64_t v324;
  uint64_t v325;
  _BOOL8 v326;
  unint64_t v327;
  unint64_t v328;
  uint64_t v329;
  unint64_t v330;
  unsigned __int128 v331;
  unint64_t v332;
  uint64_t v333;
  uint64_t v334;
  _BOOL8 v335;
  unint64_t v336;
  unint64_t v337;
  uint64_t v338;
  unint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  unint64_t v344;
  unint64_t v345;
  uint64_t v346;
  unint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  unint64_t v352;
  unint64_t v353;
  uint64_t v354;
  unint64_t v355;
  uint64_t v356;
  uint64_t v357;
  unint64_t v358;
  uint64_t v359;
  unint64_t v360;
  unint64_t v361;
  unint64_t v362;
  uint64_t v363;
  unint64_t v364;
  unsigned __int128 v365;
  unint64_t v366;
  unint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  unint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  unint64_t v376;
  unint64_t v377;
  unint64_t v378;
  unint64_t v379;
  uint64_t v380;
  unint64_t v381;
  uint64_t v382;
  uint64_t v383;
  unint64_t v384;
  uint64_t v385;
  unint64_t v386;
  unint64_t v387;
  uint64_t v388;
  unint64_t v389;
  unsigned __int128 v390;
  unint64_t v391;
  uint64_t v392;
  uint64_t v393;
  _BOOL8 v394;
  unint64_t v395;
  unint64_t v396;
  uint64_t v397;
  unint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  unint64_t v403;
  uint64_t v404;
  unint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  unint64_t v410;
  unint64_t v411;
  unint64_t v412;
  unint64_t v413;
  uint64_t v414;
  unint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  unint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  unint64_t v425;
  unint64_t v426;
  uint64_t v427;
  unint64_t v428;
  uint64_t v429;
  uint64_t v430;

  v4 = *a3;
  v5 = *a2;
  v3 = ((unsigned __int128)*a3 * v5) >> 64;
  *result = *a3 * *a2;
  v6 = a2[1];
  v8 = *a3;
  v7 = a3[1];
  v9 = (__PAIR128__(v7, v4) * v5) >> 64;
  if (__CFADD__(v7 * *a2, v3))
    v10 = ((v7 * (unsigned __int128)*a2) >> 64) + 1;
  else
    v10 = (v7 * (unsigned __int128)*a2) >> 64;
  v11 = (v8 * (unsigned __int128)v6) >> 64;
  v12 = v8 * v6;
  v13 = __CFADD__(v12, v9);
  v14 = v12 + v9;
  if (v13)
    v15 = v11 + 1;
  else
    v15 = v11;
  result[1] = v14;
  v16 = a2[2];
  v17 = a3[1];
  v18 = (*a3 * (unsigned __int128)v16) >> 64;
  v19 = *a3 * v16;
  v13 = __CFADD__(v19, v15 + v10);
  v20 = v19 + v15 + v10;
  if (v13)
    v21 = v18 + 1;
  else
    v21 = v18;
  v13 = __CFADD__(__CFADD__(v15, v10), v21);
  v22 = __CFADD__(v15, v10) + v21;
  v23 = v13;
  v25 = *a2;
  v24 = a2[1];
  v26 = (v17 * (unsigned __int128)v24) >> 64;
  v27 = v17 * v24;
  v13 = __CFADD__(v20, v27);
  v28 = v20 + v27;
  if (v13)
    v29 = v26 + 1;
  else
    v29 = v26;
  v13 = __CFADD__(v22, v29);
  v30 = v22 + v29;
  v31 = v13;
  v32 = a3[2];
  v33 = (v32 * (unsigned __int128)v25) >> 64;
  v34 = v32 * v25;
  v13 = __CFADD__(v28, v34);
  v35 = v28 + v34;
  if (v13)
    v36 = v33 + 1;
  else
    v36 = v33;
  v13 = __CFADD__(v30, v36);
  v37 = v30 + v36;
  v38 = v23 + v13 + v31;
  result[2] = v35;
  v39 = a2[1];
  v41 = a3[2];
  v40 = a3[3];
  v42 = v40 * *a2;
  v13 = __CFADD__(v42, v37);
  v43 = v42 + v37;
  if (v13)
    v44 = ((v40 * (unsigned __int128)*a2) >> 64) + 1;
  else
    v44 = (v40 * (unsigned __int128)*a2) >> 64;
  v45 = v38 + v44;
  v46 = (v41 * (unsigned __int128)v39) >> 64;
  v47 = v41 * v39;
  v13 = __CFADD__(v43, v47);
  v48 = v43 + v47;
  if (v13)
    v49 = v46 + 1;
  else
    v49 = v46;
  v13 = __CFADD__(v45, v49);
  v50 = v45 + v49;
  v51 = v13;
  if (__CFADD__(v38, v44))
    v52 = v51 + 1;
  else
    v52 = v51;
  v53 = a2[2];
  v54 = a2[3];
  v56 = *a3;
  v55 = a3[1];
  v57 = (v55 * (unsigned __int128)v53) >> 64;
  v58 = v55 * v53;
  v13 = __CFADD__(v48, v58);
  v59 = v48 + v58;
  if (v13)
    v60 = v57 + 1;
  else
    v60 = v57;
  v13 = __CFADD__(v50, v60);
  v61 = v50 + v60;
  v62 = v13;
  v63 = (v56 * (unsigned __int128)v54) >> 64;
  v64 = v56 * v54;
  v13 = __CFADD__(v59, v64);
  v65 = v59 + v64;
  if (v13)
    v66 = v63 + 1;
  else
    v66 = v63;
  v67 = __PAIR128__(v52, v61) + __PAIR128__(v62, v66);
  result[3] = v65;
  v68 = a3[1];
  v69 = *a3 * a2[4] + v67;
  v70 = *((_QWORD *)&v67 + 1) + v67;
  v71 = __CFADD__(*((_QWORD *)&v67 + 1), (_QWORD)v67);
  v73 = a2[2];
  v72 = a2[3];
  v74 = (v68 * (unsigned __int128)v72) >> 64;
  v75 = v68 * v72;
  v13 = __CFADD__(v69, v75);
  v76 = v69 + v75;
  if (v13)
    v77 = v74 + 1;
  else
    v77 = v74;
  v13 = __CFADD__(v70, v77);
  v78 = v70 + v77;
  v79 = v13;
  v80 = a3[2];
  v81 = a3[3];
  v82 = (v80 * (unsigned __int128)v73) >> 64;
  v83 = v80 * v73;
  v13 = __CFADD__(v76, v83);
  v84 = v76 + v83;
  if (v13)
    v85 = v82 + 1;
  else
    v85 = v82;
  v13 = __CFADD__(v78, v85);
  v86 = v78 + v85;
  v87 = v71 + v13 + v79;
  v89 = *a2;
  v88 = a2[1];
  v90 = (v81 * (unsigned __int128)v88) >> 64;
  v91 = v81 * v88;
  v13 = __CFADD__(v84, v91);
  v92 = v84 + v91;
  if (v13)
    v93 = v90 + 1;
  else
    v93 = v90;
  v13 = __CFADD__(v86, v93);
  v94 = v86 + v93;
  v95 = v13;
  v96 = a3[4];
  v97 = (v96 * (unsigned __int128)v89) >> 64;
  v98 = v96 * v89;
  v13 = __CFADD__(v92, v98);
  v99 = v92 + v98;
  if (v13)
    v100 = v97 + 1;
  else
    v100 = v97;
  v101 = __PAIR128__(v87, v94) + __PAIR128__(v95, v100);
  result[4] = v99;
  v102 = a2[1];
  v103 = a3[4];
  v104 = a3[5] * *a2 + v101;
  v105 = *((_QWORD *)&v101 + 1) + v101;
  v106 = (v103 * (unsigned __int128)v102) >> 64;
  v107 = v103 * v102;
  v13 = __CFADD__(v104, v107);
  v108 = v104 + v107;
  if (v13)
    v109 = v106 + 1;
  else
    v109 = v106;
  v13 = __CFADD__(v105, v109);
  v110 = v105 + v109;
  v111 = v13;
  if (__CFADD__(*((_QWORD *)&v101 + 1), (_QWORD)v101))
    v112 = v111 + 1;
  else
    v112 = v111;
  v113 = a2[2];
  v114 = a2[3];
  v116 = a3[2];
  v115 = a3[3];
  v117 = (v115 * (unsigned __int128)v113) >> 64;
  v118 = v115 * v113;
  v13 = __CFADD__(v108, v118);
  v119 = v108 + v118;
  if (v13)
    v120 = v117 + 1;
  else
    v120 = v117;
  v13 = __CFADD__(v110, v120);
  v121 = v110 + v120;
  v122 = v13;
  v123 = (v116 * (unsigned __int128)v114) >> 64;
  v124 = v116 * v114;
  v13 = __CFADD__(v119, v124);
  v125 = v119 + v124;
  if (v13)
    v126 = v123 + 1;
  else
    v126 = v123;
  v127 = __PAIR128__(v112, v121) + __PAIR128__(v122, v126);
  v128 = a2[4];
  v129 = a2[5];
  v131 = *a3;
  v130 = a3[1];
  v132 = (v130 * (unsigned __int128)v128) >> 64;
  v133 = v130 * v128;
  v13 = __CFADD__(v125, v133);
  v134 = v125 + v133;
  if (v13)
    v135 = v132 + 1;
  else
    v135 = v132;
  v136 = __CFADD__((_QWORD)v127, v135);
  v137 = (v131 * (unsigned __int128)v129) >> 64;
  v138 = v131 * v129;
  v13 = __CFADD__(v134, v138);
  v139 = v134 + v138;
  if (v13)
    v140 = v137 + 1;
  else
    v140 = v137;
  v141 = v127 + __PAIR128__(v136, v140);
  result[5] = v139;
  v142 = a3[1];
  v143 = *a3 * a2[6] + v141;
  v144 = *((_QWORD *)&v141 + 1) + v141;
  v145 = __CFADD__(*((_QWORD *)&v141 + 1), (_QWORD)v141);
  v147 = a2[4];
  v146 = a2[5];
  v148 = (v142 * (unsigned __int128)v146) >> 64;
  v149 = v142 * v146;
  v13 = __CFADD__(v143, v149);
  v150 = v143 + v149;
  if (v13)
    v151 = v148 + 1;
  else
    v151 = v148;
  v13 = __CFADD__(v144, v151);
  v152 = v144 + v151;
  v153 = v13;
  v154 = a3[2];
  v155 = a3[3];
  v156 = (v154 * (unsigned __int128)v147) >> 64;
  v157 = v154 * v147;
  v13 = __CFADD__(v150, v157);
  v158 = v150 + v157;
  if (v13)
    v159 = v156 + 1;
  else
    v159 = v156;
  v13 = __CFADD__(v152, v159);
  v160 = v152 + v159;
  v161 = v145 + v13 + v153;
  v163 = a2[2];
  v162 = a2[3];
  v164 = (v155 * (unsigned __int128)v162) >> 64;
  v165 = v155 * v162;
  v13 = __CFADD__(v158, v165);
  v166 = v158 + v165;
  if (v13)
    v167 = v164 + 1;
  else
    v167 = v164;
  v13 = __CFADD__(v160, v167);
  v168 = v160 + v167;
  v169 = v13;
  v170 = a3[4];
  v171 = a3[5];
  v172 = (v170 * (unsigned __int128)v163) >> 64;
  v173 = v170 * v163;
  v13 = __CFADD__(v166, v173);
  v174 = v166 + v173;
  if (v13)
    v175 = v172 + 1;
  else
    v175 = v172;
  v176 = __PAIR128__(v161, v168) + __PAIR128__(v169, v175);
  v178 = *a2;
  v177 = a2[1];
  v179 = (v171 * (unsigned __int128)v177) >> 64;
  v180 = v171 * v177;
  v13 = __CFADD__(v174, v180);
  v181 = v174 + v180;
  if (v13)
    v182 = v179 + 1;
  else
    v182 = v179;
  v183 = __CFADD__((_QWORD)v176, v182);
  v184 = a3[6];
  v185 = (v184 * (unsigned __int128)v178) >> 64;
  v186 = v184 * v178;
  v13 = __CFADD__(v181, v186);
  v187 = v181 + v186;
  if (v13)
    v188 = v185 + 1;
  else
    v188 = v185;
  v189 = v176 + __PAIR128__(v183, v188);
  result[6] = v187;
  v190 = a2[1];
  v191 = a3[6];
  v192 = a3[7] * *a2 + v189;
  v193 = *((_QWORD *)&v189 + 1) + v189;
  v194 = (v191 * (unsigned __int128)v190) >> 64;
  v195 = v191 * v190;
  v13 = __CFADD__(v192, v195);
  v196 = v192 + v195;
  if (v13)
    v197 = v194 + 1;
  else
    v197 = v194;
  v13 = __CFADD__(v193, v197);
  v198 = v193 + v197;
  v199 = v13;
  if (__CFADD__(*((_QWORD *)&v189 + 1), (_QWORD)v189))
    v200 = v199 + 1;
  else
    v200 = v199;
  v201 = a2[2];
  v202 = a2[3];
  v204 = a3[4];
  v203 = a3[5];
  v205 = (v203 * (unsigned __int128)v201) >> 64;
  v206 = v203 * v201;
  v13 = __CFADD__(v196, v206);
  v207 = v196 + v206;
  if (v13)
    v208 = v205 + 1;
  else
    v208 = v205;
  v13 = __CFADD__(v198, v208);
  v209 = v198 + v208;
  v210 = v13;
  v211 = (v204 * (unsigned __int128)v202) >> 64;
  v212 = v204 * v202;
  v13 = __CFADD__(v207, v212);
  v213 = v207 + v212;
  if (v13)
    v214 = v211 + 1;
  else
    v214 = v211;
  v215 = __PAIR128__(v200, v209) + __PAIR128__(v210, v214);
  v216 = a2[4];
  v217 = a2[5];
  v219 = a3[2];
  v218 = a3[3];
  v220 = (v218 * (unsigned __int128)v216) >> 64;
  v221 = v218 * v216;
  v13 = __CFADD__(v213, v221);
  v222 = v213 + v221;
  if (v13)
    v223 = v220 + 1;
  else
    v223 = v220;
  v224 = __CFADD__((_QWORD)v215, v223);
  v225 = (v219 * (unsigned __int128)v217) >> 64;
  v226 = v219 * v217;
  v13 = __CFADD__(v222, v226);
  v227 = v222 + v226;
  if (v13)
    v228 = v225 + 1;
  else
    v228 = v225;
  v229 = v215 + __PAIR128__(v224, v228);
  v230 = a2[6];
  v231 = a2[7];
  v233 = *a3;
  v232 = a3[1];
  v234 = (v232 * (unsigned __int128)v230) >> 64;
  v235 = v232 * v230;
  v13 = __CFADD__(v227, v235);
  v236 = v227 + v235;
  if (v13)
    v237 = v234 + 1;
  else
    v237 = v234;
  v238 = __CFADD__((_QWORD)v229, v237);
  v239 = (v233 * (unsigned __int128)v231) >> 64;
  v240 = v233 * v231;
  v13 = __CFADD__(v236, v240);
  v241 = v236 + v240;
  if (v13)
    v242 = v239 + 1;
  else
    v242 = v239;
  v243 = v229 + __PAIR128__(v238, v242);
  result[7] = v241;
  v244 = a3[2];
  v245 = a3[1] * a2[7] + v243;
  v246 = *((_QWORD *)&v243 + 1) + v243;
  v247 = __CFADD__(*((_QWORD *)&v243 + 1), (_QWORD)v243);
  v249 = a2[5];
  v248 = a2[6];
  v250 = (v244 * (unsigned __int128)v248) >> 64;
  v251 = v244 * v248;
  v13 = __CFADD__(v245, v251);
  v252 = v245 + v251;
  if (v13)
    v253 = v250 + 1;
  else
    v253 = v250;
  v13 = __CFADD__(v246, v253);
  v254 = v246 + v253;
  v255 = v13;
  v256 = a3[3];
  v257 = a3[4];
  v258 = (v256 * (unsigned __int128)v249) >> 64;
  v259 = v256 * v249;
  v13 = __CFADD__(v252, v259);
  v260 = v252 + v259;
  if (v13)
    v261 = v258 + 1;
  else
    v261 = v258;
  v13 = __CFADD__(v254, v261);
  v262 = v254 + v261;
  v263 = v247 + v13 + v255;
  v265 = a2[3];
  v264 = a2[4];
  v266 = (v257 * (unsigned __int128)v264) >> 64;
  v267 = v257 * v264;
  v13 = __CFADD__(v260, v267);
  v268 = v260 + v267;
  if (v13)
    v269 = v266 + 1;
  else
    v269 = v266;
  v13 = __CFADD__(v262, v269);
  v270 = v262 + v269;
  v271 = v13;
  v272 = a3[5];
  v273 = a3[6];
  v274 = (v272 * (unsigned __int128)v265) >> 64;
  v275 = v272 * v265;
  v13 = __CFADD__(v268, v275);
  v276 = v268 + v275;
  if (v13)
    v277 = v274 + 1;
  else
    v277 = v274;
  v278 = __PAIR128__(v263, v270) + __PAIR128__(v271, v277);
  v280 = a2[1];
  v279 = a2[2];
  v281 = (v273 * (unsigned __int128)v279) >> 64;
  v282 = v273 * v279;
  v13 = __CFADD__(v276, v282);
  v283 = v276 + v282;
  if (v13)
    v284 = v281 + 1;
  else
    v284 = v281;
  v285 = __CFADD__((_QWORD)v278, v284);
  v286 = a3[7];
  v287 = (v286 * (unsigned __int128)v280) >> 64;
  v288 = v286 * v280;
  v13 = __CFADD__(v283, v288);
  v289 = v283 + v288;
  if (v13)
    v290 = v287 + 1;
  else
    v290 = v287;
  v291 = v278 + __PAIR128__(v285, v290);
  result[8] = v289;
  v292 = a2[3];
  v293 = a3[6];
  v294 = a3[7] * a2[2] + v291;
  v295 = *((_QWORD *)&v291 + 1) + v291;
  v296 = (v293 * (unsigned __int128)v292) >> 64;
  v297 = v293 * v292;
  v13 = __CFADD__(v294, v297);
  v298 = v294 + v297;
  if (v13)
    v299 = v296 + 1;
  else
    v299 = v296;
  v13 = __CFADD__(v295, v299);
  v300 = v295 + v299;
  v301 = v13;
  if (__CFADD__(*((_QWORD *)&v291 + 1), (_QWORD)v291))
    v302 = v301 + 1;
  else
    v302 = v301;
  v303 = a2[4];
  v304 = a2[5];
  v306 = a3[4];
  v305 = a3[5];
  v307 = (v305 * (unsigned __int128)v303) >> 64;
  v308 = v305 * v303;
  v13 = __CFADD__(v298, v308);
  v309 = v298 + v308;
  if (v13)
    v310 = v307 + 1;
  else
    v310 = v307;
  v13 = __CFADD__(v300, v310);
  v311 = v300 + v310;
  v312 = v13;
  v313 = (v306 * (unsigned __int128)v304) >> 64;
  v314 = v306 * v304;
  v13 = __CFADD__(v309, v314);
  v315 = v309 + v314;
  if (v13)
    v316 = v313 + 1;
  else
    v316 = v313;
  v317 = __PAIR128__(v302, v311) + __PAIR128__(v312, v316);
  v318 = a2[6];
  v319 = a2[7];
  v321 = a3[2];
  v320 = a3[3];
  v322 = (v320 * (unsigned __int128)v318) >> 64;
  v323 = v320 * v318;
  v13 = __CFADD__(v315, v323);
  v324 = v315 + v323;
  if (v13)
    v325 = v322 + 1;
  else
    v325 = v322;
  v326 = __CFADD__((_QWORD)v317, v325);
  v327 = (v321 * (unsigned __int128)v319) >> 64;
  v328 = v321 * v319;
  v13 = __CFADD__(v324, v328);
  v329 = v324 + v328;
  if (v13)
    v330 = v327 + 1;
  else
    v330 = v327;
  v331 = v317 + __PAIR128__(v326, v330);
  result[9] = v329;
  v332 = a3[4];
  v333 = a3[3] * a2[7] + v331;
  v334 = *((_QWORD *)&v331 + 1) + v331;
  v335 = __CFADD__(*((_QWORD *)&v331 + 1), (_QWORD)v331);
  v337 = a2[5];
  v336 = a2[6];
  v338 = (v332 * (unsigned __int128)v336) >> 64;
  v339 = v332 * v336;
  v13 = __CFADD__(v333, v339);
  v340 = v333 + v339;
  if (v13)
    v341 = v338 + 1;
  else
    v341 = v338;
  v13 = __CFADD__(v334, v341);
  v342 = v334 + v341;
  v343 = v13;
  v344 = a3[5];
  v345 = a3[6];
  v346 = (v344 * (unsigned __int128)v337) >> 64;
  v347 = v344 * v337;
  v13 = __CFADD__(v340, v347);
  v348 = v340 + v347;
  if (v13)
    v349 = v346 + 1;
  else
    v349 = v346;
  v13 = __CFADD__(v342, v349);
  v350 = v342 + v349;
  v351 = v335 + v13 + v343;
  v353 = a2[3];
  v352 = a2[4];
  v354 = (v345 * (unsigned __int128)v352) >> 64;
  v355 = v345 * v352;
  v13 = __CFADD__(v348, v355);
  v356 = v348 + v355;
  if (v13)
    v357 = v354 + 1;
  else
    v357 = v354;
  v13 = __CFADD__(v350, v357);
  v358 = v350 + v357;
  v359 = v13;
  v360 = a3[7];
  v361 = (v360 * (unsigned __int128)v353) >> 64;
  v362 = v360 * v353;
  v13 = __CFADD__(v356, v362);
  v363 = v356 + v362;
  if (v13)
    v364 = v361 + 1;
  else
    v364 = v361;
  v365 = __PAIR128__(v351, v358) + __PAIR128__(v359, v364);
  result[10] = v363;
  v366 = a2[5];
  v367 = a3[6];
  v368 = a3[7] * a2[4] + v365;
  v369 = *((_QWORD *)&v365 + 1) + v365;
  v370 = (v367 * (unsigned __int128)v366) >> 64;
  v371 = v367 * v366;
  v13 = __CFADD__(v368, v371);
  v372 = v368 + v371;
  if (v13)
    v373 = v370 + 1;
  else
    v373 = v370;
  v13 = __CFADD__(v369, v373);
  v374 = v369 + v373;
  v375 = v13;
  v376 = a2[6];
  v377 = a2[7];
  v379 = a3[4];
  v378 = a3[5];
  v380 = (v378 * (unsigned __int128)v376) >> 64;
  v381 = v378 * v376;
  if (__CFADD__(*((_QWORD *)&v365 + 1), (_QWORD)v365))
    ++v375;
  v13 = __CFADD__(v372, v381);
  v382 = v372 + v381;
  if (v13)
    v383 = v380 + 1;
  else
    v383 = v380;
  v13 = __CFADD__(v374, v383);
  v384 = v374 + v383;
  v385 = v13;
  v386 = (v379 * (unsigned __int128)v377) >> 64;
  v387 = v379 * v377;
  v13 = __CFADD__(v382, v387);
  v388 = v382 + v387;
  if (v13)
    v389 = v386 + 1;
  else
    v389 = v386;
  v390 = __PAIR128__(v375, v384) + __PAIR128__(v385, v389);
  result[11] = v388;
  v391 = a3[6];
  v392 = a3[5] * a2[7] + v390;
  v393 = *((_QWORD *)&v390 + 1) + v390;
  v394 = __CFADD__(*((_QWORD *)&v390 + 1), (_QWORD)v390);
  v396 = a2[5];
  v395 = a2[6];
  v397 = (v391 * (unsigned __int128)v395) >> 64;
  v398 = v391 * v395;
  v13 = __CFADD__(v392, v398);
  v399 = v392 + v398;
  if (v13)
    v400 = v397 + 1;
  else
    v400 = v397;
  v13 = __CFADD__(v393, v400);
  v401 = v393 + v400;
  v402 = v13;
  v403 = a3[7];
  v404 = (v403 * (unsigned __int128)v396) >> 64;
  v405 = v403 * v396;
  v13 = __CFADD__(v399, v405);
  v406 = v399 + v405;
  if (v13)
    v407 = v404 + 1;
  else
    v407 = v404;
  v13 = __CFADD__(v401, v407);
  v408 = v401 + v407;
  v409 = v394 + v13 + v402;
  result[12] = v406;
  v410 = a2[6];
  v411 = a2[7];
  v413 = a3[6];
  v412 = a3[7];
  v414 = (v412 * (unsigned __int128)v410) >> 64;
  v415 = v412 * v410;
  v13 = __CFADD__(v415, v408);
  v416 = v415 + v408;
  if (v13)
    v417 = v414 + 1;
  else
    v417 = v414;
  v418 = v409 + v417;
  v419 = (v413 * (unsigned __int128)v411) >> 64;
  v420 = v413 * v411;
  v13 = __CFADD__(v416, v420);
  v421 = v416 + v420;
  if (v13)
    v422 = v419 + 1;
  else
    v422 = v419;
  v13 = __CFADD__(v418, v422);
  v423 = v418 + v422;
  v424 = v13;
  result[13] = v421;
  v425 = a2[7];
  v426 = a3[7];
  v427 = (v426 * (unsigned __int128)v425) >> 64;
  v428 = v426 * v425;
  v13 = __CFADD__(v428, v423);
  v429 = v428 + v423;
  if (v13)
    v430 = v427 + 1;
  else
    v430 = v427;
  result[14] = v429;
  result[15] = v424 + __CFADD__(v409, v417) + v430;
  return result;
}

_QWORD *bn_sqr_comba8(_QWORD *result, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unsigned __int128 v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _BOOL8 v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  unsigned __int128 v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  unint64_t v98;
  unsigned __int128 v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  _BOOL8 v106;
  uint64_t v107;
  unint64_t v108;
  unsigned __int128 v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  _BOOL8 v113;
  unint64_t v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  uint64_t v133;
  uint64_t v134;
  unint64_t v135;
  unsigned __int128 v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  _BOOL8 v142;
  uint64_t v143;
  unint64_t v144;
  unsigned __int128 v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  uint64_t v149;
  unint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  unint64_t v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  unint64_t v163;
  uint64_t v164;
  uint64_t v165;
  unint64_t v166;
  unsigned __int128 v167;
  unint64_t v168;
  unint64_t v169;
  unint64_t v170;
  unint64_t v171;
  unint64_t v172;
  unint64_t v173;
  uint64_t v174;
  unint64_t v175;
  _BOOL8 v176;
  uint64_t v177;
  unint64_t v178;
  unsigned __int128 v179;
  unint64_t v180;
  unint64_t v181;
  uint64_t v182;
  unint64_t v183;
  _BOOL8 v184;
  uint64_t v185;
  unsigned __int128 v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  _BOOL8 v190;
  unint64_t v191;
  unint64_t v192;
  uint64_t v193;
  unint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  unint64_t v203;
  unint64_t v204;
  unint64_t v205;
  unint64_t v206;
  uint64_t v207;
  unint64_t v208;
  unint64_t v209;
  uint64_t v210;
  uint64_t v211;
  unint64_t v212;
  unsigned __int128 v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  uint64_t v217;
  unint64_t v218;
  _BOOL8 v219;
  uint64_t v220;
  unint64_t v221;
  unsigned __int128 v222;
  unint64_t v223;
  unint64_t v224;
  unint64_t v225;
  unint64_t v226;
  uint64_t v227;
  unint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  unint64_t v237;
  unint64_t v238;
  uint64_t v239;
  unint64_t v240;
  unint64_t v241;
  uint64_t v242;
  uint64_t v243;
  unint64_t v244;
  unsigned __int128 v245;
  unint64_t v246;
  unint64_t v247;
  unint64_t v248;
  unint64_t v249;
  uint64_t v250;
  unint64_t v251;
  _BOOL8 v252;
  uint64_t v253;
  unint64_t v254;
  unsigned __int128 v255;
  unint64_t v256;
  uint64_t v257;
  uint64_t v258;
  _BOOL8 v259;
  unint64_t v260;
  unint64_t v261;
  uint64_t v262;
  unint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  unint64_t v272;
  unint64_t v273;
  unint64_t v274;
  uint64_t v275;
  unint64_t v276;
  unint64_t v277;
  uint64_t v278;
  uint64_t v279;
  unint64_t v280;
  unsigned __int128 v281;
  unint64_t v282;
  unint64_t v283;
  unint64_t v284;
  unint64_t v285;
  uint64_t v286;
  unint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  unint64_t v296;
  unint64_t v297;
  uint64_t v298;
  unint64_t v299;
  unint64_t v300;
  uint64_t v301;
  uint64_t v302;
  unint64_t v303;
  unsigned __int128 v304;
  unint64_t v305;
  uint64_t v306;
  uint64_t v307;
  _BOOL8 v308;
  unint64_t v309;
  uint64_t v310;
  unint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  unint64_t v320;
  unint64_t v321;
  uint64_t v322;
  unint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  unint64_t v331;
  uint64_t v332;
  unint64_t v333;
  uint64_t v334;
  uint64_t v335;

  v2 = (*a2 * (unsigned __int128)*a2) >> 64;
  *result = *a2 * *a2;
  v3 = a2[1];
  v4 = (*a2 * (unsigned __int128)v3) >> 64;
  v5 = *a2 * v3;
  v6 = __CFADD__(v5, v2);
  v7 = v5 + v2;
  if (v6)
    v8 = v4 + 1;
  else
    v8 = v4;
  v6 = __CFADD__(v7, v5);
  v9 = v7 + v5;
  if (v6)
    v10 = v4 + 1;
  else
    v10 = v4;
  result[1] = v9;
  v12 = *a2;
  v11 = a2[1];
  v13 = (v11 * (unsigned __int128)v11) >> 64;
  v14 = v11 * v11;
  v6 = __CFADD__(v14, v10 + v8);
  v15 = v14 + v10 + v8;
  if (v6)
    v16 = v13 + 1;
  else
    v16 = v13;
  v6 = __CFADD__(__CFADD__(v10, v8), v16);
  v17 = __CFADD__(v10, v8) + v16;
  v18 = v6;
  v19 = a2[2];
  v20 = (v12 * (unsigned __int128)v19) >> 64;
  v21 = v12 * v19;
  v6 = __CFADD__(v15, v21);
  v22 = v15 + v21;
  if (v6)
    v23 = v20 + 1;
  else
    v23 = v20;
  v6 = __CFADD__(v17, v23);
  v24 = v17 + v23;
  v25 = v6;
  v6 = __CFADD__(v22, v21);
  v26 = v22 + v21;
  if (v6)
    v27 = v20 + 1;
  else
    v27 = v20;
  v6 = __CFADD__(v24, v27);
  v28 = v24 + v27;
  v29 = v18 + v6 + v25;
  result[2] = v26;
  v31 = a2[2];
  v30 = a2[3];
  v32 = a2[1];
  v33 = (*a2 * (unsigned __int128)v30) >> 64;
  v34 = *a2 * v30;
  v6 = __CFADD__(v34, v28);
  v35 = v34 + v28;
  if (v6)
    v36 = v33 + 1;
  else
    v36 = v33;
  v37 = v29 + v36;
  v6 = __CFADD__(v35, v34);
  v38 = v35 + v34;
  if (v6)
    v39 = v33 + 1;
  else
    v39 = v33;
  v6 = __CFADD__(v37, v39);
  v40 = v37 + v39;
  v41 = v6;
  if (__CFADD__(v29, v36))
    v42 = v41 + 1;
  else
    v42 = v41;
  v43 = (v32 * (unsigned __int128)v31) >> 64;
  v44 = v32 * v31;
  v6 = __CFADD__(v38, v44);
  v45 = v38 + v44;
  if (v6)
    v46 = v43 + 1;
  else
    v46 = v43;
  v6 = __CFADD__(v40, v46);
  v47 = v40 + v46;
  v48 = v6;
  v6 = __CFADD__(v45, v44);
  v49 = v45 + v44;
  if (v6)
    v50 = v43 + 1;
  else
    v50 = v43;
  v51 = __PAIR128__(v42, v47) + __PAIR128__(v48, v50);
  result[3] = v49;
  v52 = a2[3];
  v53 = a2[2] * a2[2] + v51;
  v54 = *((_QWORD *)&v51 + 1) + v51;
  v55 = __CFADD__(*((_QWORD *)&v51 + 1), (_QWORD)v51);
  v57 = *a2;
  v56 = a2[1];
  v58 = (v56 * (unsigned __int128)v52) >> 64;
  v59 = v56 * v52;
  v6 = __CFADD__(v53, v59);
  v60 = v53 + v59;
  if (v6)
    v61 = v58 + 1;
  else
    v61 = v58;
  v6 = __CFADD__(v54, v61);
  v62 = v54 + v61;
  v63 = v6;
  v6 = __CFADD__(v60, v59);
  v64 = v60 + v59;
  if (v6)
    v65 = v58 + 1;
  else
    v65 = v58;
  v6 = __CFADD__(v62, v65);
  v66 = v62 + v65;
  v67 = v55 + v6 + v63;
  v68 = a2[4];
  v69 = (v57 * (unsigned __int128)v68) >> 64;
  v70 = v57 * v68;
  v6 = __CFADD__(v64, v70);
  v71 = v64 + v70;
  if (v6)
    v72 = v69 + 1;
  else
    v72 = v69;
  v6 = __CFADD__(v66, v72);
  v73 = v66 + v72;
  v74 = v6;
  v6 = __CFADD__(v71, v70);
  v75 = v71 + v70;
  if (v6)
    v76 = v69 + 1;
  else
    v76 = v69;
  v77 = __PAIR128__(v67, v73) + __PAIR128__(v74, v76);
  result[4] = v75;
  v79 = a2[4];
  v78 = a2[5];
  v80 = a2[1];
  v81 = (*a2 * (unsigned __int128)v78) >> 64;
  v82 = *a2 * v78;
  v83 = v82 + v77;
  if (__CFADD__(v82, (_QWORD)v77))
    v84 = v81 + 1;
  else
    v84 = v81;
  v85 = *((_QWORD *)&v77 + 1) + v84;
  v6 = __CFADD__(v83, v82);
  v86 = v83 + v82;
  if (v6)
    v87 = v81 + 1;
  else
    v87 = v81;
  v6 = __CFADD__(v85, v87);
  v88 = v85 + v87;
  v89 = v6;
  if (__CFADD__(*((_QWORD *)&v77 + 1), v84))
    v90 = v89 + 1;
  else
    v90 = v89;
  v91 = (v80 * (unsigned __int128)v79) >> 64;
  v92 = v80 * v79;
  v6 = __CFADD__(v86, v92);
  v93 = v86 + v92;
  if (v6)
    v94 = v91 + 1;
  else
    v94 = v91;
  v6 = __CFADD__(v88, v94);
  v95 = v88 + v94;
  v96 = v6;
  v6 = __CFADD__(v93, v92);
  v97 = v93 + v92;
  if (v6)
    v98 = v91 + 1;
  else
    v98 = v91;
  v99 = __PAIR128__(v90, v95) + __PAIR128__(v96, v98);
  v101 = a2[2];
  v100 = a2[3];
  v102 = (v101 * (unsigned __int128)v100) >> 64;
  v103 = v101 * v100;
  v6 = __CFADD__(v97, v103);
  v104 = v97 + v103;
  if (v6)
    v105 = v102 + 1;
  else
    v105 = v102;
  v106 = __CFADD__((_QWORD)v99, v105);
  v6 = __CFADD__(v104, v103);
  v107 = v104 + v103;
  if (v6)
    v108 = v102 + 1;
  else
    v108 = v102;
  v109 = v99 + __PAIR128__(v106, v108);
  result[5] = v107;
  v110 = a2[2];
  v111 = a2[3] * a2[3] + v109;
  v112 = *((_QWORD *)&v109 + 1) + v109;
  v113 = __CFADD__(*((_QWORD *)&v109 + 1), (_QWORD)v109);
  v114 = a2[4];
  v115 = a2[5];
  v116 = (v110 * (unsigned __int128)v114) >> 64;
  v117 = v110 * v114;
  v6 = __CFADD__(v111, v117);
  v118 = v111 + v117;
  if (v6)
    v119 = v116 + 1;
  else
    v119 = v116;
  v6 = __CFADD__(v112, v119);
  v120 = v112 + v119;
  v121 = v6;
  v6 = __CFADD__(v118, v117);
  v122 = v118 + v117;
  if (v6)
    v123 = v116 + 1;
  else
    v123 = v116;
  v6 = __CFADD__(v120, v123);
  v124 = v120 + v123;
  v125 = v113 + v6 + v121;
  v127 = *a2;
  v126 = a2[1];
  v128 = (v126 * (unsigned __int128)v115) >> 64;
  v129 = v126 * v115;
  v6 = __CFADD__(v122, v129);
  v130 = v122 + v129;
  if (v6)
    v131 = v128 + 1;
  else
    v131 = v128;
  v6 = __CFADD__(v124, v131);
  v132 = v124 + v131;
  v133 = v6;
  v6 = __CFADD__(v130, v129);
  v134 = v130 + v129;
  if (v6)
    v135 = v128 + 1;
  else
    v135 = v128;
  v136 = __PAIR128__(v125, v132) + __PAIR128__(v133, v135);
  v137 = a2[6];
  v138 = (v127 * (unsigned __int128)v137) >> 64;
  v139 = v127 * v137;
  v6 = __CFADD__(v134, v139);
  v140 = v134 + v139;
  if (v6)
    v141 = v138 + 1;
  else
    v141 = v138;
  v142 = __CFADD__((_QWORD)v136, v141);
  v6 = __CFADD__(v140, v139);
  v143 = v140 + v139;
  if (v6)
    v144 = v138 + 1;
  else
    v144 = v138;
  v145 = v136 + __PAIR128__(v142, v144);
  result[6] = v143;
  v147 = a2[6];
  v146 = a2[7];
  v148 = a2[1];
  v149 = (*a2 * (unsigned __int128)v146) >> 64;
  v150 = *a2 * v146;
  v151 = v150 + v145;
  if (__CFADD__(v150, (_QWORD)v145))
    v152 = v149 + 1;
  else
    v152 = v149;
  v153 = *((_QWORD *)&v145 + 1) + v152;
  v6 = __CFADD__(v151, v150);
  v154 = v151 + v150;
  if (v6)
    v155 = v149 + 1;
  else
    v155 = v149;
  v6 = __CFADD__(v153, v155);
  v156 = v153 + v155;
  v157 = v6;
  if (__CFADD__(*((_QWORD *)&v145 + 1), v152))
    v158 = v157 + 1;
  else
    v158 = v157;
  v159 = (v148 * (unsigned __int128)v147) >> 64;
  v160 = v148 * v147;
  v6 = __CFADD__(v154, v160);
  v161 = v154 + v160;
  if (v6)
    v162 = v159 + 1;
  else
    v162 = v159;
  v6 = __CFADD__(v156, v162);
  v163 = v156 + v162;
  v164 = v6;
  v6 = __CFADD__(v161, v160);
  v165 = v161 + v160;
  if (v6)
    v166 = v159 + 1;
  else
    v166 = v159;
  v167 = __PAIR128__(v158, v163) + __PAIR128__(v164, v166);
  v169 = a2[4];
  v168 = a2[5];
  v170 = a2[2];
  v171 = a2[3];
  v172 = (v170 * (unsigned __int128)v168) >> 64;
  v173 = v170 * v168;
  v6 = __CFADD__(v165, v173);
  v174 = v165 + v173;
  if (v6)
    v175 = v172 + 1;
  else
    v175 = v172;
  v176 = __CFADD__((_QWORD)v167, v175);
  v6 = __CFADD__(v174, v173);
  v177 = v174 + v173;
  if (v6)
    v178 = v172 + 1;
  else
    v178 = v172;
  v179 = v167 + __PAIR128__(v176, v178);
  v180 = (v171 * (unsigned __int128)v169) >> 64;
  v181 = v171 * v169;
  v6 = __CFADD__(v177, v181);
  v182 = v177 + v181;
  if (v6)
    v183 = v180 + 1;
  else
    v183 = v180;
  v184 = __CFADD__((_QWORD)v179, v183);
  v6 = __CFADD__(v182, v181);
  v185 = v182 + v181;
  if (v6)
    ++v180;
  v186 = v179 + __PAIR128__(v184, v180);
  result[7] = v185;
  v187 = a2[3];
  v188 = a2[4] * a2[4] + v186;
  v189 = *((_QWORD *)&v186 + 1) + v186;
  v190 = __CFADD__(*((_QWORD *)&v186 + 1), (_QWORD)v186);
  v191 = a2[5];
  v192 = a2[6];
  v193 = (v187 * (unsigned __int128)v191) >> 64;
  v194 = v187 * v191;
  v6 = __CFADD__(v188, v194);
  v195 = v188 + v194;
  if (v6)
    v196 = v193 + 1;
  else
    v196 = v193;
  v6 = __CFADD__(v189, v196);
  v197 = v189 + v196;
  v198 = v6;
  v6 = __CFADD__(v195, v194);
  v199 = v195 + v194;
  if (v6)
    v200 = v193 + 1;
  else
    v200 = v193;
  v6 = __CFADD__(v197, v200);
  v201 = v197 + v200;
  v202 = v190 + v6 + v198;
  v204 = a2[1];
  v203 = a2[2];
  v205 = (v203 * (unsigned __int128)v192) >> 64;
  v206 = v203 * v192;
  v6 = __CFADD__(v199, v206);
  v207 = v199 + v206;
  if (v6)
    v208 = v205 + 1;
  else
    v208 = v205;
  v6 = __CFADD__(v201, v208);
  v209 = v201 + v208;
  v210 = v6;
  v6 = __CFADD__(v207, v206);
  v211 = v207 + v206;
  if (v6)
    v212 = v205 + 1;
  else
    v212 = v205;
  v213 = __PAIR128__(v202, v209) + __PAIR128__(v210, v212);
  v214 = a2[7];
  v215 = (v204 * (unsigned __int128)v214) >> 64;
  v216 = v204 * v214;
  v6 = __CFADD__(v211, v216);
  v217 = v211 + v216;
  if (v6)
    v218 = v215 + 1;
  else
    v218 = v215;
  v219 = __CFADD__((_QWORD)v213, v218);
  v6 = __CFADD__(v217, v216);
  v220 = v217 + v216;
  if (v6)
    v221 = v215 + 1;
  else
    v221 = v215;
  v222 = v213 + __PAIR128__(v219, v221);
  result[8] = v220;
  v224 = a2[6];
  v223 = a2[7];
  v225 = a2[2];
  v226 = a2[3];
  v227 = (v225 * (unsigned __int128)v223) >> 64;
  v228 = v225 * v223;
  v229 = v228 + v222;
  if (__CFADD__(v228, (_QWORD)v222))
    v230 = v227 + 1;
  else
    v230 = v227;
  v231 = *((_QWORD *)&v222 + 1) + v230;
  v6 = __CFADD__(v229, v228);
  v232 = v229 + v228;
  if (v6)
    v233 = v227 + 1;
  else
    v233 = v227;
  v6 = __CFADD__(v231, v233);
  v234 = v231 + v233;
  v235 = v6;
  if (__CFADD__(*((_QWORD *)&v222 + 1), v230))
    v236 = v235 + 1;
  else
    v236 = v235;
  v237 = (v226 * (unsigned __int128)v224) >> 64;
  v238 = v226 * v224;
  v6 = __CFADD__(v232, v238);
  v239 = v232 + v238;
  if (v6)
    v240 = v237 + 1;
  else
    v240 = v237;
  v6 = __CFADD__(v234, v240);
  v241 = v234 + v240;
  v242 = v6;
  v6 = __CFADD__(v239, v238);
  v243 = v239 + v238;
  if (v6)
    v244 = v237 + 1;
  else
    v244 = v237;
  v245 = __PAIR128__(v236, v241) + __PAIR128__(v242, v244);
  v247 = a2[4];
  v246 = a2[5];
  v248 = (v247 * (unsigned __int128)v246) >> 64;
  v249 = v247 * v246;
  v6 = __CFADD__(v243, v249);
  v250 = v243 + v249;
  if (v6)
    v251 = v248 + 1;
  else
    v251 = v248;
  v252 = __CFADD__((_QWORD)v245, v251);
  v6 = __CFADD__(v250, v249);
  v253 = v250 + v249;
  if (v6)
    v254 = v248 + 1;
  else
    v254 = v248;
  v255 = v245 + __PAIR128__(v252, v254);
  result[9] = v253;
  v256 = a2[6];
  v257 = a2[5] * a2[5] + v255;
  v258 = *((_QWORD *)&v255 + 1) + v255;
  v259 = __CFADD__(*((_QWORD *)&v255 + 1), (_QWORD)v255);
  v261 = a2[3];
  v260 = a2[4];
  v262 = (v260 * (unsigned __int128)v256) >> 64;
  v263 = v260 * v256;
  v6 = __CFADD__(v257, v263);
  v264 = v257 + v263;
  if (v6)
    v265 = v262 + 1;
  else
    v265 = v262;
  v6 = __CFADD__(v258, v265);
  v266 = v258 + v265;
  v267 = v6;
  v6 = __CFADD__(v264, v263);
  v268 = v264 + v263;
  if (v6)
    v269 = v262 + 1;
  else
    v269 = v262;
  v6 = __CFADD__(v266, v269);
  v270 = v266 + v269;
  v271 = v259 + v6 + v267;
  v272 = a2[7];
  v273 = (v261 * (unsigned __int128)v272) >> 64;
  v274 = v261 * v272;
  v6 = __CFADD__(v268, v274);
  v275 = v268 + v274;
  if (v6)
    v276 = v273 + 1;
  else
    v276 = v273;
  v6 = __CFADD__(v270, v276);
  v277 = v270 + v276;
  v278 = v6;
  v6 = __CFADD__(v275, v274);
  v279 = v275 + v274;
  if (v6)
    v280 = v273 + 1;
  else
    v280 = v273;
  v281 = __PAIR128__(v271, v277) + __PAIR128__(v278, v280);
  result[10] = v279;
  v283 = a2[6];
  v282 = a2[7];
  v284 = a2[4];
  v285 = a2[5];
  v286 = (v284 * (unsigned __int128)v282) >> 64;
  v287 = v284 * v282;
  v288 = v287 + v281;
  if (__CFADD__(v287, (_QWORD)v281))
    v289 = v286 + 1;
  else
    v289 = v286;
  v290 = *((_QWORD *)&v281 + 1) + v289;
  v6 = __CFADD__(v288, v287);
  v291 = v288 + v287;
  if (v6)
    v292 = v286 + 1;
  else
    v292 = v286;
  v6 = __CFADD__(v290, v292);
  v293 = v290 + v292;
  v294 = v6;
  if (__CFADD__(*((_QWORD *)&v281 + 1), v289))
    v295 = v294 + 1;
  else
    v295 = v294;
  v296 = (v285 * (unsigned __int128)v283) >> 64;
  v297 = v285 * v283;
  v6 = __CFADD__(v291, v297);
  v298 = v291 + v297;
  if (v6)
    v299 = v296 + 1;
  else
    v299 = v296;
  v6 = __CFADD__(v293, v299);
  v300 = v293 + v299;
  v301 = v6;
  v6 = __CFADD__(v298, v297);
  v302 = v298 + v297;
  if (v6)
    v303 = v296 + 1;
  else
    v303 = v296;
  v304 = __PAIR128__(v295, v300) + __PAIR128__(v301, v303);
  result[11] = v302;
  v305 = a2[5];
  v306 = a2[6] * a2[6] + v304;
  v307 = *((_QWORD *)&v304 + 1) + v304;
  v308 = __CFADD__(*((_QWORD *)&v304 + 1), (_QWORD)v304);
  v309 = a2[7];
  v310 = (v305 * (unsigned __int128)v309) >> 64;
  v311 = v305 * v309;
  v6 = __CFADD__(v306, v311);
  v312 = v306 + v311;
  if (v6)
    v313 = v310 + 1;
  else
    v313 = v310;
  v6 = __CFADD__(v307, v313);
  v314 = v307 + v313;
  v315 = v6;
  v6 = __CFADD__(v312, v311);
  v316 = v312 + v311;
  if (v6)
    v317 = v310 + 1;
  else
    v317 = v310;
  v6 = __CFADD__(v314, v317);
  v318 = v314 + v317;
  v319 = v308 + v6 + v315;
  result[12] = v316;
  v321 = a2[6];
  v320 = a2[7];
  v322 = (v321 * (unsigned __int128)v320) >> 64;
  v323 = v321 * v320;
  v6 = __CFADD__(v323, v318);
  v324 = v323 + v318;
  if (v6)
    v325 = v322 + 1;
  else
    v325 = v322;
  v326 = v319 + v325;
  v6 = __CFADD__(v324, v323);
  v327 = v324 + v323;
  if (v6)
    v328 = v322 + 1;
  else
    v328 = v322;
  v6 = __CFADD__(v326, v328);
  v329 = v326 + v328;
  v330 = v6;
  result[13] = v327;
  v331 = a2[7];
  v332 = (v331 * (unsigned __int128)v331) >> 64;
  v333 = v331 * v331;
  v6 = __CFADD__(v333, v329);
  v334 = v333 + v329;
  if (v6)
    v335 = v332 + 1;
  else
    v335 = v332;
  result[14] = v334;
  result[15] = v330 + __CFADD__(v319, v325) + v335;
  return result;
}

int BN_lshift1(BIGNUM *r, const BIGNUM *a)
{
  int result;
  int top;
  unint64_t v6;
  unint64_t *d;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;

  if (r == a)
  {
    result = bn_wexpand(&r->d, r->top + 1);
    if (!result)
      return result;
  }
  else
  {
    r->neg = a->neg;
    result = bn_wexpand(&r->d, a->top + 1);
    if (!result)
      return result;
    r->top = a->top;
  }
  top = a->top;
  if (top < 1)
    return 1;
  v6 = 0;
  d = r->d;
  v8 = a->d;
  do
  {
    v10 = *v8++;
    v9 = v10;
    *d++ = v6 | (2 * v10);
    v6 = v10 >> 63;
    --top;
  }
  while (top);
  if ((v9 & 0x8000000000000000) == 0)
    return 1;
  result = 1;
  *d = 1;
  ++r->top;
  return result;
}

uint64_t bn_rshift_secret_shift(uint64_t a1, const BIGNUM *a2, unsigned int a3, BN_CTX *ctx)
{
  BIGNUM *v8;
  char **v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;

  BN_CTX_start(ctx);
  v8 = BN_CTX_get(ctx);
  if (v8 && (v9 = (char **)v8, BN_copy((BIGNUM *)a1, a2)) && bn_wexpand((_QWORD **)v9, *(int *)(a1 + 8)))
  {
    v10 = *(_DWORD *)(a1 + 8);
    if (v10)
    {
      v11 = 0;
      v12 = v10 << 6;
      v13 = 1;
      do
      {
        bn_rshift_words(*v9, *(_QWORD *)a1, 1 << v11, *(int *)(a1 + 8));
        bn_select_words(*(uint64_t **)a1, -(uint64_t)((a3 >> v11++) & 1), (uint64_t *)*v9, *(uint64_t **)a1, *(int *)(a1 + 8));
      }
      while (v12 >> v11);
    }
    else
    {
      v13 = 1;
    }
  }
  else
  {
    v13 = 0;
  }
  BN_CTX_end(ctx);
  return v13;
}

int BN_rshift1(BIGNUM *r, const BIGNUM *a)
{
  int result;
  int top;
  unint64_t *d;
  unint64_t *v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t *v10;

  result = bn_wexpand(&r->d, a->top);
  if (result)
  {
    top = a->top;
    if (top)
    {
      d = r->d;
      v7 = a->d;
      if (top != 1)
      {
        v8 = v7 + 1;
        v9 = top - 1;
        v10 = r->d;
        do
        {
          *v10++ = *(__int128 *)(v8++ - 1) >> 1;
          --v9;
        }
        while (v9);
      }
      d[top - 1] = v7[top - 1] >> 1;
    }
    r->top = top;
    r->neg = a->neg;
    bn_set_minimal_width((uint64_t)r);
    return 1;
  }
  return result;
}

uint64_t bn_is_bit_set_words(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a3 >> 6 >= a2)
    return 0;
  else
    return (*(_QWORD *)(a1 + 8 * (a3 >> 6)) >> a3) & 1;
}

int BN_is_bit_set(const BIGNUM *a, int n)
{
  unint64_t v2;
  uint64_t v3;

  if (n < 0 || (v2 = (unint64_t)n >> 6, v2 >= a->top))
    LODWORD(v3) = 0;
  else
    return (a->d[v2] >> n) & 1;
  return v3;
}

unint64_t BN_count_low_zero_bits(unint64_t result)
{
  uint64_t v1;
  unint64_t **v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;

  v1 = *(unsigned int *)(result + 8);
  if ((int)v1 < 1)
    return 0;
  v2 = (unint64_t **)result;
  v3 = 0;
  LODWORD(result) = 0;
  v4 = 0;
  v5 = *v2;
  v6 = v1 << 6;
  do
  {
    v7 = *v5++;
    v8 = (v7 - 1) & ~v7;
    v9 = ((v7 << 32) - 1) & ~(v7 << 32);
    v10 = (v9 >> 63) & 0x20;
    v11 = ~(v9 >> 63) & v7 | (v9 >> 63) & HIDWORD(v7);
    v12 = ((v11 << 48) - 1) & ~(v11 << 48);
    v13 = (v12 >> 63) & (v11 >> 16) | ~(v12 >> 63) & v11;
    v14 = (v12 >> 63) & 0x10 | v10;
    v15 = ((v13 << 56) - 1) & ~(v13 << 56);
    v16 = (v15 >> 63) & (v13 >> 8) | v13 & ~(v15 >> 63);
    v17 = v14 | (v15 >> 63) & 8;
    v18 = ((v16 << 60) - 1) & ~(v16 << 60);
    v19 = (v18 >> 63) & (v16 >> 4) | v16 & ~(v18 >> 63);
    v20 = v17 | (v18 >> 63) & 4;
    v21 = ((v19 << 62) - 1) & ~(v19 << 62);
    v22 = (v21 >> 63) & (v19 >> 2) | v19 & ~(v21 >> 63);
    v23 = (v8 >> 63) | v4;
    v4 |= ~(v8 >> 63);
    result = (v3 | v20 | (v21 >> 63) & 2 | ((((v22 << 63) - 1) & (unint64_t)~(v22 << 63)) >> 63)) & ~v23 | result;
    v3 += 64;
  }
  while (v6 != v3);
  return result;
}

uint64_t bn_jacobi(const BIGNUM *a1, const BIGNUM *a2, BN_CTX *a3)
{
  int v6;
  int v7;
  uint64_t v8;
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  unsigned int v12;
  BIGNUM *v13;
  int v14;
  unint64_t v15;
  int top;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _BOOL4 is_zero;

  if (!BN_is_odd((uint64_t)a2))
  {
    v6 = 104;
    v7 = 73;
    goto LABEL_5;
  }
  if (!BN_is_negative((uint64_t)a2))
  {
    BN_CTX_start(a3);
    v9 = BN_CTX_get(a3);
    v10 = BN_CTX_get(a3);
    if (v10)
    {
      v11 = v10;
      if (BN_copy(v9, a1))
      {
        if (BN_copy(v11, a2))
        {
          v12 = 1;
          if (BN_is_zero((uint64_t)v9))
          {
LABEL_10:
            if (BN_is_one((unsigned int *)v11))
              v8 = v12;
            else
              v8 = 0;
            goto LABEL_39;
          }
          v13 = v11;
          while (1)
          {
            v11 = v9;
            v9 = v13;
            v14 = -1;
            do
              ++v14;
            while (!BN_is_bit_set(v11, v14));
            if (!BN_rshift(v11, v11, v14))
              break;
            if ((v14 & 1) != 0)
            {
              if (v9->top)
                v15 = *v9->d;
              else
                LOBYTE(v15) = 0;
              v12 *= bn_jacobi_tab[v15 & 7];
            }
            top = v11->top;
            if (v11->neg)
            {
              if (top)
                v17 = *v11->d;
              else
                LOBYTE(v17) = 0;
              LOBYTE(v18) = ~(_BYTE)v17;
            }
            else if (top)
            {
              v18 = *v11->d;
            }
            else
            {
              LOBYTE(v18) = 0;
            }
            if (v9->top)
              v19 = *v9->d;
            else
              LOBYTE(v19) = 0;
            if (!BN_nnmod(v9, v9, v11, a3))
              break;
            if ((v18 & v19 & 2) != 0)
              v12 = -v12;
            v11->neg = 0;
            is_zero = BN_is_zero((uint64_t)v9);
            v13 = v11;
            if (is_zero)
              goto LABEL_10;
          }
        }
      }
    }
    v8 = 4294967294;
LABEL_39:
    BN_CTX_end(a3);
    return v8;
  }
  v6 = 109;
  v7 = 79;
LABEL_5:
  ERR_put_error(3, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/jacobi.c", v7);
  return 4294967294;
}

int BIO_puts(BIO *bp, const char *buf)
{
  size_t v4;

  v4 = strlen(buf);
  if (!(v4 >> 31))
    return BIO_write(bp, buf, v4);
  ERR_put_error(17, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio.c", 197);
  return -1;
}

uint64_t BIO_int_ctrl(BIO *bp, int cmd, uint64_t larg, int iarg)
{
  int parg;

  parg = iarg;
  return BIO_ctrl(bp, cmd, larg, &parg);
}

void BIO_set_flags(BIO *b, int flags)
{
  LODWORD(b->cb_arg) |= flags;
}

uint64_t BIO_should_write(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) & 2;
}

uint64_t BIO_should_io_special(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) & 4;
}

int BIO_get_retry_reason(BIO *bio)
{
  return HIDWORD(bio->cb_arg);
}

uint64_t BIO_set_retry_write(uint64_t result)
{
  *(_DWORD *)(result + 16) |= 0xAu;
  return result;
}

uint64_t BIO_clear_retry_flags(uint64_t result)
{
  *(_QWORD *)(result + 16) = *(_DWORD *)(result + 16) & 0xFFFFFFF0;
  return result;
}

int BIO_method_type(const BIO *b)
{
  return b->method->type;
}

BIO *__cdecl BIO_find_type(BIO *b, int bio_type)
{
  int type;

  for (; b; b = *(BIO **)&b->num)
  {
    if (b->method)
    {
      type = b->method->type;
      if ((_BYTE)bio_type)
      {
        if (type == bio_type)
          return b;
      }
      else if ((type & bio_type) != 0)
      {
        return b;
      }
    }
  }
  return b;
}

int BIO_indent(BIO *b, int indent, int max)
{
  int v4;
  int v5;

  if (indent >= max)
    v4 = max;
  else
    v4 = indent;
  v5 = v4 + 1;
  while (--v5)
  {
    if (BIO_puts(b, " ") != 1)
      return 0;
  }
  return 1;
}

_QWORD *EVP_AEAD_CTX_new(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;

  v8 = OPENSSL_malloc(0x258uLL);
  bzero(v8, 0x258uLL);
  if (!EVP_AEAD_CTX_init(v8, a1, a2, a3, a4) && v8)
  {
    if (*v8)
    {
      (*(void (**)(_QWORD *))(*v8 + 24))(v8);
      *v8 = 0;
    }
    OPENSSL_free(v8);
    return 0;
  }
  return v8;
}

uint64_t EVP_AEAD_CTX_init(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_QWORD *)(a2 + 8))
    return EVP_AEAD_CTX_init_with_direction(a1, (unsigned __int8 *)a2, a3, a4, a5, 0);
  ERR_put_error(30, 0, 124, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", 65);
  *a1 = 0;
  return 0;
}

uint64_t EVP_AEAD_CTX_seal(uint64_t a1, char *a2, unint64_t *a3, size_t a4, uint64_t a5, uint64_t a6, char *a7, size_t a8)
{
  int v12;
  int v13;
  unint64_t v14;
  uint64_t result;
  unsigned int (*v16)(uint64_t, char *, char *, unint64_t *, size_t);
  unint64_t v17;

  if (__CFADD__(a8, *(unsigned __int8 *)(*(_QWORD *)a1 + 2)))
  {
    v12 = 117;
    v13 = 123;
LABEL_10:
    ERR_put_error(30, 0, v12, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", v13);
    goto LABEL_11;
  }
  if (a4 < a8)
  {
    v12 = 103;
    v13 = 128;
    goto LABEL_10;
  }
  if (a7 != a2 && &a2[a4] > a7 && &a7[a8] > a2)
  {
    v12 = 115;
    v13 = 133;
    goto LABEL_10;
  }
  v16 = *(unsigned int (**)(uint64_t, char *, char *, unint64_t *, size_t))(*(_QWORD *)a1 + 40);
  v17 = 0xAAAAAAAAAAAAAAAALL;
  if (v16(a1, a2, &a2[a8], &v17, a4 - a8))
  {
    v14 = v17 + a8;
    result = 1;
    goto LABEL_14;
  }
LABEL_11:
  if (a4)
    bzero(a2, a4);
  v14 = 0;
  result = 0;
LABEL_14:
  *a3 = v14;
  return result;
}

int RSA_up_ref(RSA *r)
{
  CRYPTO_refcount_inc((unsigned int *)&r->dmq1);
  return 1;
}

int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb)
{
  return 0;
}

uint64_t RSA_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(a1 + 8));
}

uint64_t rsa_default_size(uint64_t a1)
{
  return BN_num_bytes(*(const BIGNUM **)(a1 + 8));
}

BOOL RSA_encrypt(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  int v10;
  int v11;
  _BOOL8 v12;
  uint64_t v14;
  _QWORD *v15;
  void *v16;
  int v17;
  uint64_t v18;
  void *v19;

  if (!a1)
  {
    v10 = 67;
    v11 = 124;
    goto LABEL_7;
  }
  if (!a2)
  {
    v10 = 67;
    v11 = 128;
    goto LABEL_7;
  }
  if (BN_num_bytes(*(const BIGNUM **)(a1 + 8)) < 0x401)
  {
    v18 = 0;
    v19 = 0;
    if (!RSA_public_key_to_bytes(&v19, &v18, a1) || !v19)
      return 0;
    v14 = ccrsa_import_pub_n();
    v15 = malloc_type_malloc(24 * v14 + 40, 0xDA3DB562uLL);
    if (!v15)
    {
      if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        RSA_encrypt_cold_1();
      return 0;
    }
    v16 = v15;
    *v15 = v14;
    if (ccrsa_import_pub())
    {
      OPENSSL_free(v19);
      free(v16);
      return 0;
    }
    *a2 = ccrsa_block_size();
    switch(a7)
    {
      case 4:
        if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          RSA_encrypt_cold_2();
        v17 = 174;
        break;
      case 3:
        if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          RSA_encrypt_cold_3();
        v17 = 179;
        break;
      case 1:
        ccrng();
        v12 = ccrsa_encrypt_eme_pkcs1v15() == 0;
LABEL_32:
        OPENSSL_free(v19);
        free(v16);
        return v12;
      default:
LABEL_31:
        v12 = 0;
        goto LABEL_32;
    }
    ERR_put_error(4, 0, 143, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v17);
    goto LABEL_31;
  }
  v10 = 500;
  v11 = 132;
LABEL_7:
  ERR_put_error(4, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v11);
  return 0;
}

uint64_t rsa_default_decrypt()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    rsa_default_decrypt_cold_1();
  return 0;
}

uint64_t RSA_decrypt()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    RSA_decrypt_cold_1();
  return 0;
}

uint64_t rsa_default_sign_raw()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    rsa_default_sign_raw_cold_1();
  return 0;
}

uint64_t RSA_sign_raw()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    RSA_sign_raw_cold_1();
  return 0;
}

int RSA_sign(int type, const unsigned __int8 *m, unsigned int m_length, unsigned __int8 *sigret, unsigned int *siglen, RSA *rsa)
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    RSA_sign_cold_1();
  return 0;
}

uint64_t RSA_sign_pss_mgf1()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    RSA_sign_pss_mgf1_cold_1();
  return 0;
}

uint64_t ec_GFp_nistp224_point_get_affine_coordinates(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  int8x16_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  int8x16_t v23;
  int8x16_t v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  _OWORD v29[7];
  int8x16_t v30[2];
  int8x16_t v31;
  uint64_t v32;
  uint64_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41[2];
  int8x16_t v42[2];
  int8x16_t v43[2];
  int8x16_t v44;
  int8x16_t v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (ec_GFp_simple_is_at_infinity(a1, a2))
  {
    ERR_put_error(15, 0, 119, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/p224-64.c", 866);
    return 0;
  }
  else
  {
    v8 = *(__int128 *)(a2 + 152) >> 48;
    v9 = *(__int128 *)(a2 + 160) >> 40;
    v10 = *(_OWORD *)(a2 + 144);
    v31.i64[0] = v10 & 0xFFFFFFFFFFFFFFLL;
    v31.i64[1] = (v10 >> 56) & 0xFFFFFFFFFFFFFFLL;
    v11.i64[0] = 0xAAAAAAAAAAAAAAAALL;
    v11.i64[1] = 0xAAAAAAAAAAAAAAAALL;
    v30[0] = v11;
    v30[1] = v11;
    v29[5] = v11;
    v29[6] = v11;
    v29[3] = v11;
    v29[4] = v11;
    v29[1] = v11;
    v29[2] = v11;
    v29[0] = v11;
    v32 = v8 & 0xFFFFFFFFFFFFFFLL;
    v33 = v9 & 0xFFFFFFFFFFFFFFLL;
    v44 = v11;
    v45 = v11;
    v43[0] = v11;
    v43[1] = v11;
    v42[0] = v11;
    v42[1] = v11;
    v41[0] = v11;
    v41[1] = v11;
    v39 = v11;
    v40 = v11;
    v37 = v11;
    v38 = v11;
    v35 = v11;
    v36 = v11;
    v34 = v11;
    p224_felem_square(&v34, (unint64_t *)&v31);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)&v31, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)&v31, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)&v44);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v43);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v43);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v43, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)&v44);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    v12 = 5;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v43);
      p224_felem_reduce(v43, (unint64_t *)&v34);
      --v12;
    }
    while (v12);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v43, (unint64_t *)&v44);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v43);
    p224_felem_reduce(v42, (unint64_t *)&v34);
    v13 = 11;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v42);
      p224_felem_reduce(v42, (unint64_t *)&v34);
      --v13;
    }
    while (v13);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v42, (unint64_t *)v43);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v43);
    p224_felem_reduce(v42, (unint64_t *)&v34);
    v14 = 23;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v42);
      p224_felem_reduce(v42, (unint64_t *)&v34);
      --v14;
    }
    while (v14);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v42, (unint64_t *)v43);
    p224_felem_reduce(v42, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v42);
    p224_felem_reduce(v41, (unint64_t *)&v34);
    v15 = 47;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v41);
      p224_felem_reduce(v41, (unint64_t *)&v34);
      --v15;
    }
    while (v15);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v42, (unint64_t *)v41);
    p224_felem_reduce(v42, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v42);
    p224_felem_reduce(v41, (unint64_t *)&v34);
    v16 = 23;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v41);
      p224_felem_reduce(v41, (unint64_t *)&v34);
      --v16;
    }
    while (v16);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v43, (unint64_t *)v41);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    v17 = 6;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v43);
      p224_felem_reduce(v43, (unint64_t *)&v34);
      --v17;
    }
    while (v17);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v43, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)&v44, (unint64_t *)&v31);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    v18 = 97;
    do
    {
      p224_felem_square(&v34, (unint64_t *)&v44);
      p224_felem_reduce(&v44, (unint64_t *)&v34);
      --v18;
    }
    while (v18);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)&v44, (unint64_t *)v42);
    p224_felem_reduce(v30, (unint64_t *)&v34);
    p224_felem_square(v29, (unint64_t *)v30);
    p224_felem_reduce(&v31, (unint64_t *)v29);
    if (a3)
    {
      v19 = *(_QWORD *)(a2 + 8);
      *((_QWORD *)&v20 + 1) = v19;
      *(_QWORD *)&v20 = *(_QWORD *)a2;
      v34.i64[0] = *(_QWORD *)a2 & 0xFFFFFFFFFFFFFFLL;
      v34.i64[1] = (v20 >> 56) & 0xFFFFFFFFFFFFFFLL;
      *((_QWORD *)&v20 + 1) = *(_QWORD *)(a2 + 16);
      *(_QWORD *)&v20 = v19;
      v21 = v20 >> 48;
      v22 = *(_OWORD *)(a2 + 16);
      v23.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      v23.i64[1] = 0xAAAAAAAAAAAAAAAALL;
      v44 = v23;
      v45 = v23;
      v35.i64[0] = v21 & 0xFFFFFFFFFFFFFFLL;
      v35.i64[1] = (v22 >> 40) & 0xFFFFFFFFFFFFFFLL;
      p224_felem_mul((uint64_t)v29, (unint64_t *)&v34, (unint64_t *)&v31);
      p224_felem_reduce(&v44, (unint64_t *)v29);
      p224_felem_to_generic(a3, &v44);
    }
    if (a4)
    {
      v24.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      v24.i64[1] = 0xAAAAAAAAAAAAAAAALL;
      v44 = v24;
      v45 = v24;
      v25 = *(_QWORD *)(a2 + 80);
      *((_QWORD *)&v26 + 1) = v25;
      *(_QWORD *)&v26 = *(_QWORD *)(a2 + 72);
      v34.i64[0] = v26 & 0xFFFFFFFFFFFFFFLL;
      v34.i64[1] = (v26 >> 56) & 0xFFFFFFFFFFFFFFLL;
      *((_QWORD *)&v26 + 1) = *(_QWORD *)(a2 + 88);
      *(_QWORD *)&v26 = v25;
      v27 = (v26 >> 48) & 0xFFFFFFFFFFFFFFLL;
      v28 = *(_OWORD *)(a2 + 88);
      v35.i64[0] = v27;
      v35.i64[1] = (v28 >> 40) & 0xFFFFFFFFFFFFFFLL;
      p224_felem_mul((uint64_t)v29, (unint64_t *)&v31, (unint64_t *)v30);
      p224_felem_reduce(&v31, (unint64_t *)v29);
      p224_felem_mul((uint64_t)v29, (unint64_t *)&v34, (unint64_t *)&v31);
      p224_felem_reduce(&v44, (unint64_t *)v29);
      p224_felem_to_generic(a4, &v44);
    }
    return 1;
  }
}

uint64_t *ec_GFp_nistp224_add(uint64_t a1, uint64_t *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  unint64_t v16;
  __int128 v17;
  uint64_t v18;
  unint64_t v19;
  __int128 v20;
  uint64_t v21;
  unint64_t v22;
  __int128 v23;
  unint64_t v25[4];
  unint64_t v26[4];
  unint64_t v27[4];
  int8x16_t v28;
  uint64_t v29;
  uint64_t v30;
  int64x2_t v31;
  uint64_t v32;
  uint64_t v33;
  int8x16_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v5 = a3[1];
  *((_QWORD *)&v6 + 1) = v5;
  *(_QWORD *)&v6 = *a3;
  v34.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v34.i64[1] = (v6 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v6 + 1) = a3[2];
  *(_QWORD *)&v6 = v5;
  v7 = (v6 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v8 = *((_OWORD *)a3 + 1);
  v35 = v7;
  v36 = (v8 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v9 = a3[10];
  *((_QWORD *)&v8 + 1) = v9;
  *(_QWORD *)&v8 = a3[9];
  v31.i64[0] = v8 & 0xFFFFFFFFFFFFFFLL;
  v31.i64[1] = (v8 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v8 + 1) = a3[11];
  *(_QWORD *)&v8 = v9;
  v10 = (v8 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v11 = *(_OWORD *)(a3 + 11);
  v32 = v10;
  v33 = (v11 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v12 = a3[19];
  *((_QWORD *)&v11 + 1) = v12;
  *(_QWORD *)&v11 = a3[18];
  v28.i64[0] = v11 & 0xFFFFFFFFFFFFFFLL;
  v28.i64[1] = (v11 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v11 + 1) = a3[20];
  *(_QWORD *)&v11 = v12;
  v13 = (v11 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v14 = *((_OWORD *)a3 + 10);
  v29 = v13;
  v30 = (v14 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v15 = a4[1];
  *((_QWORD *)&v14 + 1) = v15;
  *(_QWORD *)&v14 = *a4;
  v27[0] = *a4 & 0xFFFFFFFFFFFFFFLL;
  v27[1] = (v14 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v14 + 1) = a4[2];
  *(_QWORD *)&v14 = v15;
  v16 = (v14 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v17 = *((_OWORD *)a4 + 1);
  v27[2] = v16;
  v27[3] = (v17 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v18 = a4[10];
  *((_QWORD *)&v17 + 1) = v18;
  *(_QWORD *)&v17 = a4[9];
  v26[0] = v17 & 0xFFFFFFFFFFFFFFLL;
  v26[1] = (v17 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v17 + 1) = a4[11];
  *(_QWORD *)&v17 = v18;
  v19 = (v17 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v20 = *(_OWORD *)(a4 + 11);
  v26[2] = v19;
  v26[3] = (v20 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v21 = a4[19];
  *((_QWORD *)&v20 + 1) = v21;
  *(_QWORD *)&v20 = a4[18];
  v25[0] = v20 & 0xFFFFFFFFFFFFFFLL;
  v25[1] = (v20 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v20 + 1) = a4[20];
  *(_QWORD *)&v20 = v21;
  v22 = (v20 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v23 = *((_OWORD *)a4 + 10);
  v25[2] = v22;
  v25[3] = (v23 >> 40) & 0xFFFFFFFFFFFFFFLL;
  p224_point_add(&v34, (int8x16_t *)&v31, &v28, &v34, &v31, (uint64_t)&v28, 0, v27, v26, v25);
  p224_felem_to_generic(a2, &v34);
  p224_felem_to_generic(a2 + 9, &v31);
  return p224_felem_to_generic(a2 + 18, &v28);
}

uint64_t *ec_GFp_nistp224_dbl(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  int64x2_t v15;
  uint64_t v16;
  uint64_t v17;
  int64x2_t v18;
  uint64_t v19;
  uint64_t v20;
  int8x16_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = a3[1];
  *((_QWORD *)&v5 + 1) = v4;
  *(_QWORD *)&v5 = *a3;
  v21.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v21.i64[1] = (v5 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v5 + 1) = a3[2];
  *(_QWORD *)&v5 = v4;
  v6 = (v5 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v7 = *((_OWORD *)a3 + 1);
  v22 = v6;
  v23 = (v7 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v8 = a3[10];
  *((_QWORD *)&v7 + 1) = v8;
  *(_QWORD *)&v7 = a3[9];
  v18.i64[0] = v7 & 0xFFFFFFFFFFFFFFLL;
  v18.i64[1] = (v7 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v7 + 1) = a3[11];
  *(_QWORD *)&v7 = v8;
  v9 = (v7 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v10 = *(_OWORD *)(a3 + 11);
  v19 = v9;
  v20 = (v10 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v11 = a3[19];
  *((_QWORD *)&v10 + 1) = v11;
  *(_QWORD *)&v10 = a3[18];
  v15.i64[0] = v10 & 0xFFFFFFFFFFFFFFLL;
  v15.i64[1] = (v10 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v10 + 1) = a3[20];
  *(_QWORD *)&v10 = v11;
  v12 = (v10 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v13 = *((_OWORD *)a3 + 10);
  v16 = v12;
  v17 = (v13 >> 40) & 0xFFFFFFFFFFFFFFLL;
  p224_point_double(&v21, (int8x16_t *)&v18, (int8x16_t *)&v15, (unint64_t *)&v21, &v18, &v15);
  p224_felem_to_generic(a2, &v21);
  p224_felem_to_generic(a2 + 9, &v18);
  return p224_felem_to_generic(a2 + 18, &v15);
}

uint64_t *ec_GFp_nistp224_point_mul(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  int8x16_t v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int8x16_t v14;
  unint64_t v17;
  uint64_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int64x2_t v21;
  int8x16_t v22;
  int64x2_t v23;
  int8x16_t v24;
  int8x16_t v25[2];
  int8x16_t v26;
  int8x16_t v27;
  int64x2_t v28;
  int8x16_t v29;
  int64x2_t v30;
  int8x16_t v31;
  _BYTE __b[1632];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  memset(__b, 170, sizeof(__b));
  ec_GFp_nistp224_make_precomp((uint64_t)__b, a3);
  v6.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v25[0] = v6;
  v25[1] = v6;
  v23 = (int64x2_t)v6;
  v24 = v6;
  v21 = (int64x2_t)v6;
  v22 = v6;
  v19 = v6;
  v20 = v6;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v7 = 1;
  v8 = 220;
  v30 = 0u;
  v31 = 0u;
  do
  {
    if (!v7)
      p224_point_double(&v26, (int8x16_t *)&v28, (int8x16_t *)&v30, (unint64_t *)&v26, &v28, &v30);
    if (-858993459 * v8 < 0x33333334)
    {
      if (v8 <= 0xDB)
        v10 = (*(_QWORD *)(a4 + (((v8 + 4) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 4)) & 1;
      else
        v10 = 0;
      v9 = v8 - 1;
      if (v8 - 1 <= 0xDF)
        v11 = (*(_QWORD *)(a4 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v9) & 1;
      else
        v11 = 0;
      v12 = v11 | (32 * v10) | (16
                              * ((*(_QWORD *)(a4 + (((v8 + 3) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 3)) & 1)) | (8 * ((*(_QWORD *)(a4 + (((v8 + 2) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 2)) & 1)) | (4 * ((*(_QWORD *)(a4 + (((v8 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 1)) & 1)) | (2 * ((*(_QWORD *)(a4 + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v8) & 1));
      v17 = 0xAAAAAAAAAAAAAAAALL;
      v18 = 0xAAAAAAAAAAAAAAAALL;
      ec_GFp_nistp_recode_scalar_bits(&v18, &v17, v12);
      p224_select_point(v17, 17, (uint64_t)__b, &v19);
      p224_felem_neg(v25, &v21);
      v13 = 0;
      v14 = (int8x16_t)vdupq_n_s64(-v18);
      do
      {
        *(int8x16_t *)((char *)&v21 + v13 * 16) = vbslq_s8(v14, v25[v13], *(int8x16_t *)((char *)&v21 + v13 * 16));
        ++v13;
      }
      while (v13 != 2);
      if (v7)
      {
        v28 = v21;
        v29 = v22;
        v30 = v23;
        v31 = v24;
        v26 = v19;
        v27 = v20;
      }
      else
      {
        p224_point_add(&v26, (int8x16_t *)&v28, (int8x16_t *)&v30, &v26, &v28, (uint64_t)&v30, 0, (unint64_t *)&v19, (unint64_t *)&v21, (unint64_t *)&v23);
      }
      v7 = 0;
    }
    else
    {
      v9 = v8 - 1;
    }
    v8 = v9;
  }
  while (v9 < 0xDD);
  p224_felem_to_generic(a2, &v26);
  p224_felem_to_generic(a2 + 9, &v28);
  return p224_felem_to_generic(a2 + 18, &v30);
}

uint64_t *ec_GFp_nistp224_point_mul_base(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  char v5;
  int64x2_t v6;
  unint64_t v7;
  unint64_t v8;
  int8x16_t v10;
  int64x2_t v11;
  int64x2_t v12;
  int64x2_t v13;
  int64x2_t v14;
  int64x2_t v15;
  int8x16_t v16;
  int64x2_t v17;
  int64x2_t v18;
  int64x2_t v19;
  int64x2_t v20;
  int64x2_t v21;
  uint64_t v22;

  v5 = 0;
  v22 = *MEMORY[0x1E0C80C00];
  v6.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v14 = v6;
  v15 = v6;
  v12 = v6;
  v13 = v6;
  v10 = (int8x16_t)v6;
  v11 = v6;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v7 = 111;
  v20 = 0u;
  v21 = 0u;
  do
  {
    if ((v5 & 1) != 0)
      p224_point_double(&v16, (int8x16_t *)&v18, (int8x16_t *)&v20, (unint64_t *)&v16, &v18, &v20);
    p224_select_point((8 * ((*(_QWORD *)(a3 + (((v7 + 112) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v7 - 80)) & 1)) | (4 * ((*(_QWORD *)(a3 + (((v7 + 56) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v7 - 72)) & 1)) | (2 * ((*(_QWORD *)(a3 + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v7) & 1)) | (*(_QWORD *)(a3 + (((v7 - 56) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v7 - 56)) & 1, 16, (uint64_t)&unk_1B5012D68, &v10);
    if ((v5 & 1) != 0)
    {
      p224_point_add(&v16, (int8x16_t *)&v18, (int8x16_t *)&v20, &v16, &v18, (uint64_t)&v20, 1, (unint64_t *)&v10, (unint64_t *)&v12, (unint64_t *)&v14);
    }
    else
    {
      v18 = v12;
      v19 = v13;
      v20 = v14;
      v21 = v15;
      v16 = v10;
      v17 = v11;
    }
    p224_select_point((8 * ((*(_QWORD *)(a3 + (((v7 + 84) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v7 + 84)) & 1)) | (4 * ((*(_QWORD *)(a3 + (((v7 + 28) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v7 + 28)) & 1)) | (2 * ((*(_QWORD *)(a3 + (((v7 - 28) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v7 - 28)) & 1)) | (*(_QWORD *)(a3 + (((v7 - 84) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v7 - 84)) & 1, 16, (uint64_t)&g_p224_pre_comp, &v10);
    v5 = 1;
    p224_point_add(&v16, (int8x16_t *)&v18, (int8x16_t *)&v20, &v16, &v18, (uint64_t)&v20, 1, (unint64_t *)&v10, (unint64_t *)&v12, (unint64_t *)&v14);
    v8 = v7 - 85;
    --v7;
  }
  while (v8 < 0x1C);
  p224_felem_to_generic(a2, &v16);
  p224_felem_to_generic(a2 + 9, &v18);
  return p224_felem_to_generic(a2 + 18, &v20);
}

uint64_t *ec_GFp_nistp224_point_mul_public(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int64x2_t *v15;
  int64x2_t v16;
  int64x2_t v17;
  int64x2_t v18;
  unint64_t v21;
  uint64_t v22;
  int8x16_t v23;
  int64x2_t v24;
  int64x2_t v25;
  int64x2_t v26;
  int64x2_t v27;
  int64x2_t v28;
  int8x16_t v29;
  int64x2_t v30;
  int64x2_t v31;
  int64x2_t v32;
  int64x2_t v33;
  int64x2_t v34;
  _OWORD __b[102];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  memset(__b, 170, sizeof(__b));
  ec_GFp_nistp224_make_precomp((uint64_t)__b, a4);
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v8 = 1;
  v9 = 220;
  do
  {
    if (!v8)
      p224_point_double(&v29, (int8x16_t *)&v31, (int8x16_t *)&v33, (unint64_t *)&v29, &v31, &v33);
    if (v9 <= 0x1B)
    {
      v10 = (unint64_t *)((char *)&g_p224_pre_comp
                               + 96
                               * ((8
                                 * ((*(_QWORD *)(a3 + (((v9 + 196) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 - 60)) & 1)) | (4 * ((*(_QWORD *)(a3 + (((v9 + 140) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 - 116)) & 1)) | (2 * ((*(_QWORD *)(a3 + (((v9 + 84) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 + 84)) & 1)) | (*(_QWORD *)(a3 + (((v9 + 28) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 + 28)) & 1));
      p224_point_add(&v29, (int8x16_t *)&v31, (int8x16_t *)&v33, &v29, &v31, (uint64_t)&v33, 1, v10 + 192, v10 + 196, v10 + 200);
      if (v8)
        ec_GFp_nistp224_point_mul_public_cold_1();
      v11 = (unint64_t *)((char *)&g_p224_pre_comp
                               + 96
                               * ((8
                                 * ((*(_QWORD *)(a3 + (((v9 + 168) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 - 88)) & 1)) | (4 * ((*(_QWORD *)(a3 + (((v9 + 112) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 + 112)) & 1)) | (2 * ((*(_QWORD *)(a3 + (((v9 + 56) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 + 56)) & 1)) | (*(_QWORD *)(a3 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v9) & 1));
      p224_point_add(&v29, (int8x16_t *)&v31, (int8x16_t *)&v33, &v29, &v31, (uint64_t)&v33, 1, v11, v11 + 4, v11 + 8);
    }
    if (-858993459 * v9 < 0x33333334)
    {
      if (v9 <= 0xDB)
        v12 = (*(_QWORD *)(a5 + (((v9 + 4) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 + 4)) & 1;
      else
        v12 = 0;
      if (v9 - 1 <= 0xDF)
        v13 = (*(_QWORD *)(a5 + (((v9 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 - 1)) & 1;
      else
        v13 = 0;
      v14 = v13 | (32 * v12) | (16
                              * ((*(_QWORD *)(a5 + (((v9 + 3) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 + 3)) & 1)) | (8 * ((*(_QWORD *)(a5 + (((v9 + 2) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 + 2)) & 1)) | (4 * ((*(_QWORD *)(a5 + (((v9 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v9 + 1)) & 1)) | (2 * ((*(_QWORD *)(a5 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v9) & 1));
      v21 = 0xAAAAAAAAAAAAAAAALL;
      v22 = 0xAAAAAAAAAAAAAAAALL;
      ec_GFp_nistp_recode_scalar_bits(&v22, &v21, v14);
      v15 = (int64x2_t *)&__b[6 * v21];
      v16 = v15[3];
      v25 = v15[2];
      v26 = v16;
      v17 = v15[5];
      v27 = v15[4];
      v28 = v17;
      v18 = v15[1];
      v23 = *(int8x16_t *)v15;
      v24 = v18;
      if (v22)
        p224_felem_neg((int8x16_t *)&v25, &v25);
      if (v8)
      {
        v31 = v25;
        v32 = v26;
        v33 = v27;
        v34 = v28;
        v29 = v23;
        v30 = v24;
      }
      else
      {
        p224_point_add(&v29, (int8x16_t *)&v31, (int8x16_t *)&v33, &v29, &v31, (uint64_t)&v33, 0, (unint64_t *)&v23, (unint64_t *)&v25, (unint64_t *)&v27);
      }
      v8 = 0;
      --v9;
    }
    else
    {
      --v9;
    }
  }
  while (v9 < 0xDD);
  p224_felem_to_generic(a2, &v29);
  p224_felem_to_generic(a2 + 9, &v31);
  return p224_felem_to_generic(a2 + 18, &v33);
}

uint64_t *ec_GFp_nistp224_felem_mul(uint64_t a1, uint64_t *a2, _QWORD *a3, _QWORD *a4)
{
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  unint64_t v11;
  __int128 v12;
  _OWORD v14[7];
  unint64_t v15[4];
  int8x16_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[5] = v5;
  v14[6] = v5;
  v14[3] = v5;
  v14[4] = v5;
  v14[1] = v5;
  v14[2] = v5;
  v14[0] = v5;
  v6 = a3[1];
  *((_QWORD *)&v7 + 1) = v6;
  *(_QWORD *)&v7 = *a3;
  v16.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v16.i64[1] = (v7 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v7 + 1) = a3[2];
  *(_QWORD *)&v7 = v6;
  v8 = (v7 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v9 = *((_OWORD *)a3 + 1);
  v17 = v8;
  v18 = (v9 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v10 = a4[1];
  *((_QWORD *)&v9 + 1) = v10;
  *(_QWORD *)&v9 = *a4;
  v15[0] = *a4 & 0xFFFFFFFFFFFFFFLL;
  v15[1] = (v9 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v9 + 1) = a4[2];
  *(_QWORD *)&v9 = v10;
  v11 = (v9 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v12 = *((_OWORD *)a4 + 1);
  v15[2] = v11;
  v15[3] = (v12 >> 40) & 0xFFFFFFFFFFFFFFLL;
  p224_felem_mul((uint64_t)v14, (unint64_t *)&v16, v15);
  p224_felem_reduce(&v16, (unint64_t *)v14);
  return p224_felem_to_generic(a2, &v16);
}

uint64_t *ec_GFp_nistp224_felem_sqr(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  _OWORD v10[7];
  int8x16_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = a3[1];
  *((_QWORD *)&v5 + 1) = v4;
  *(_QWORD *)&v5 = *a3;
  v11.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v11.i64[1] = (v5 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v5 + 1) = a3[2];
  *(_QWORD *)&v5 = v4;
  v6 = v5 >> 48;
  v7 = *((_OWORD *)a3 + 1);
  v12 = v6 & 0xFFFFFFFFFFFFFFLL;
  v13 = (v7 >> 40) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[5] = v8;
  v10[6] = v8;
  v10[3] = v8;
  v10[4] = v8;
  v10[1] = v8;
  v10[2] = v8;
  v10[0] = v8;
  p224_felem_square(v10, (unint64_t *)&v11);
  p224_felem_reduce(&v11, (unint64_t *)v10);
  return p224_felem_to_generic(a2, &v11);
}

_OWORD *p224_felem_square(_OWORD *result, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v2 = *a2;
  v3 = a2[1];
  v4 = 2 * *a2;
  v5 = a2[2];
  v6 = a2[3];
  *result = *a2 * (unsigned __int128)*a2;
  result[1] = 2 * v3 * (unsigned __int128)v2;
  result[2] = 2 * v5 * (unsigned __int128)v2 + v3 * (unsigned __int128)v3;
  result[3] = v6 * (unsigned __int128)(unint64_t)v4 + 2 * v5 * (unsigned __int128)v3;
  result[4] = v6 * (unsigned __int128)(2 * v3) + v5 * (unsigned __int128)v5;
  result[5] = v6 * (unsigned __int128)(2 * v5);
  result[6] = v6 * (unsigned __int128)v6;
  return result;
}

int8x16_t p224_felem_reduce(int8x16_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned __int128 v8;
  unsigned __int128 v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned __int128 v19;
  unsigned __int128 v20;
  unsigned __int128 v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unsigned __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  signed __int128 v31;
  signed __int128 v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t result;
  __int128 v39;

  v3 = *a2;
  v2 = a2[1];
  v5 = a2[2];
  v4 = a2[3];
  v7 = a2[6];
  v6 = a2[7];
  v8 = *((_OWORD *)a2 + 6);
  v9 = (v8 >> 16) + *((_OWORD *)a2 + 4);
  v10 = (unint64_t)(unsigned __int16)v8 << 40;
  v11 = __CFADD__(v10, v7);
  v12 = v10 + v7;
  if (v11)
    ++v6;
  v13 = (*((_OWORD *)a2 + 2) - *((_OWORD *)a2 + 6)) >> 64;
  v14 = a2[4] - a2[12];
  v16 = a2[10];
  v15 = a2[11];
  v17 = (unint64_t)(unsigned __int16)v16 << 40;
  v11 = __CFADD__(v14, v17);
  v18 = v14 + v17;
  if (v11)
    ++v13;
  *((_QWORD *)&v19 + 1) = v15;
  *(_QWORD *)&v19 = v16;
  v20 = __PAIR128__(v6, v12) + (v19 >> 16);
  v21 = __PAIR128__(v13, v18) + (v9 >> 16);
  v23 = v5 - v16;
  v22 = (__PAIR128__(v4, v5) - __PAIR128__(v15, v16)) >> 64;
  v24 = (unint64_t)(unsigned __int16)v9 << 40;
  v25 = v5 - v16 + v24;
  if (__CFADD__(v23, v24))
    ++v22;
  *((_QWORD *)&v26 + 1) = *((_QWORD *)&v21 + 1) + 0x7FFFFFFFFFFFFF80;
  *(_QWORD *)&v26 = v21;
  v27 = v20 + (v26 >> 56);
  v28 = (v27 >> 16) & 0xFFFF0000000000;
  v11 = __CFADD__(v25, v28);
  v29 = v25 + v28;
  if (v11)
    ++v22;
  v30 = (v21 & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v27 + 1) >> 8);
  v31 = __PAIR128__(v2, v3) - (v9 + ((unsigned __int128)v27 >> 56)) + __PAIR128__(0x8000000000000000, 0x8000);
  v32 = __PAIR128__(HIBYTE(*((_QWORD *)&v31 + 1)) + (unint64_t)__CFADD__(v29, (unint64_t)(v31 >> 56)) + v22, v29 + (unint64_t)(v31 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000);
  v33 = (unint64_t)((__PAIR128__(HIBYTE(*((_QWORD *)&v31 + 1))+ (unint64_t)__CFADD__(v29, (unint64_t)(v31 >> 56))+ v22, v29 + (unint64_t)(v31 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64) >> 56;
  v34 = v32 >> 56;
  v11 = __CFADD__(v30, v34);
  v35 = v30 + v34;
  if (v11)
    ++v33;
  v36.i64[0] = v31;
  v36.i64[1] = v32;
  v37.i64[0] = 0xFFFFFFFFFFFFFFLL;
  v37.i64[1] = 0xFFFFFFFFFFFFFFLL;
  result = vandq_s8(v36, v37);
  *a1 = result;
  *((_QWORD *)&v39 + 1) = v33;
  *(_QWORD *)&v39 = v35;
  a1[1].i64[0] = v35 & 0xFFFFFFFFFFFFFFLL;
  a1[1].i64[1] = (v39 >> 56) + (v27 & 0xFFFFFFFFFFFFFFLL);
  return result;
}

uint64_t p224_felem_mul(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v3 = *a3;
  v4 = a3[1];
  v5 = *a2;
  v6 = a2[1];
  v7 = (*a3 * (unsigned __int128)*a2) >> 64;
  *(_QWORD *)result = *a3 * *a2;
  *(_QWORD *)(result + 8) = v7;
  *(_OWORD *)(result + 16) = v6 * (unsigned __int128)v3 + v4 * (unsigned __int128)v5;
  v8 = a3[2];
  v9 = a3[3];
  v10 = a2[2];
  v11 = a2[3];
  *(_OWORD *)(result + 32) = v8 * (unsigned __int128)v5 + v6 * (unsigned __int128)v4 + v10 * (unsigned __int128)v3;
  *(_OWORD *)(result + 48) = v10 * (unsigned __int128)v4
                           + v8 * (unsigned __int128)v6
                           + v9 * (unsigned __int128)v5
                           + v11 * (unsigned __int128)v3;
  *(_OWORD *)(result + 64) = v9 * (unsigned __int128)v6 + v10 * (unsigned __int128)v8 + v11 * (unsigned __int128)v4;
  *(_OWORD *)(result + 80) = v11 * (unsigned __int128)v8 + v9 * (unsigned __int128)v10;
  *(_OWORD *)(result + 96) = v11 * (unsigned __int128)v9;
  return result;
}

uint64_t *p224_felem_to_generic(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = *a2 - HIBYTE(v4);
  v6 = v2 + (HIBYTE(v4) << 40);
  v7 = (((v3 & v4 & (v2 | 0xFFFFFFFFFFLL)) + 1) | ((*a2 + (v2 & 0xFFFFFFFFFFLL) - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v8 = v7 != 0;
  v9 = v7 - 1;
  v10 = v8;
  v11 = v10 << 63 >> 63;
  v12 = v4 & v11;
  v13 = v3 & v11;
  v14 = 0xFFFFFFFFFFLL;
  if (v8)
    v14 = -1;
  v15 = v5 + (v9 >> 63);
  v16 = v14 & v6;
  v17 = v15 + ((unint64_t)v15 >> 63 << 56);
  v18 = v16 + (v15 >> 63);
  v19 = v13 + (v18 >> 56);
  *result = v17 | (v18 << 56);
  result[1] = ((unint64_t)v18 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v19 << 48);
  result[2] = ((unint64_t)v19 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)(v12
                                                                                 + (v19 >> 56)) << 40);
  result[3] = ((v12 & 0xFFFFFFFFFFFFFFuLL) + (v19 >> 56)) >> 24;
  return result;
}

double p224_point_add(int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, int8x16_t *a4, int64x2_t *a5, uint64_t a6, int a7, unint64_t *a8, unint64_t *a9, unint64_t *a10)
{
  int8x16_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t is_zero;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  double result;
  int8x16_t v30;
  int8x16_t v31;
  uint64_t v32;
  _BOOL8 v33;
  _BOOL8 v34;
  _BOOL8 v35;
  unsigned __int128 v36;
  _BOOL8 v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int8x16_t v48;
  uint64_t v49;
  int8x16_t v50;
  uint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  int8x16_t v55;
  int8x16_t v56;
  int8x16_t v57;
  int8x16_t v62;
  uint64_t v63;
  int8x16_t v64;
  unint64_t v65;
  unint64_t v66;
  unsigned __int128 v67;
  unsigned __int128 v68;
  int8x16_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  unsigned __int128 v74;
  int8x16_t v75;
  int8x16_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t v81;
  int8x16_t v82;
  int8x16_t v83;
  int8x16_t v84;
  int8x16_t v85;
  int8x16_t v86;
  int8x16_t v87;
  int8x16_t v88;
  int8x16_t v89;
  int8x16_t v90;
  int8x16_t v91[2];
  int8x16_t v92;
  int8x16_t v93;
  int8x16_t v94;
  int8x16_t v95;
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  v14.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v14.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v94 = v14;
  v95 = v14;
  v92 = v14;
  v93 = v14;
  v91[0] = v14;
  v91[1] = v14;
  v89 = v14;
  v90 = v14;
  v87 = v14;
  v88 = v14;
  v85 = v14;
  v86 = v14;
  v83 = v14;
  v84 = v14;
  v81 = v14;
  v82 = v14;
  v79 = v14;
  v80 = v14;
  v77 = v14;
  v78 = v14;
  v75 = v14;
  v76 = v14;
  v73 = v14;
  v74 = (unsigned __int128)v14;
  v71 = v14;
  v72 = v14;
  v69 = v14;
  v70 = v14;
  v67 = (unsigned __int128)v14;
  v68 = (unsigned __int128)v14;
  if (a7)
  {
    v16 = a5->i64[0];
    v15 = a5->i64[1];
    v89.i64[0] = a5->i64[0];
    v89.i64[1] = v15;
    v18 = a5[1].i64[0];
    v17 = a5[1].i64[1];
    v90.i64[0] = v18;
    v90.i64[1] = v17;
    v62 = *a4;
    v92.i64[0] = a4->i64[0];
    v92.i64[1] = v62.i64[1];
    v64 = a4[1];
    v93 = v64;
  }
  else
  {
    p224_felem_square(&v74, a10);
    p224_felem_reduce(&v92, (unint64_t *)&v74);
    p224_felem_mul((uint64_t)&v74, (unint64_t *)&v92, a10);
    p224_felem_reduce(&v89, (unint64_t *)&v74);
    p224_felem_mul((uint64_t)&v67, (unint64_t *)&v89, (unint64_t *)a5);
    p224_felem_reduce(&v89, (unint64_t *)&v67);
    p224_felem_mul((uint64_t)&v67, (unint64_t *)&v92, (unint64_t *)a4);
    p224_felem_reduce(&v92, (unint64_t *)&v67);
    v15 = v89.i64[1];
    v16 = v89.i64[0];
    v17 = v90.i64[1];
    v18 = v90.i64[0];
    v62 = v92;
    v64 = v93;
  }
  p224_felem_square(&v74, (unint64_t *)a6);
  p224_felem_reduce(&v94, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v94, (unint64_t *)a6);
  p224_felem_reduce(v91, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)v91, a9);
  v74 = v74 - (unint64_t)v16 + __PAIR128__(1, 256);
  v19 = (unint64_t)(*(_OWORD *)&v75 - v15) >> 64;
  if ((unint64_t)(v75.i64[0] - v15) >= 0x1000000000100)
    ++v19;
  v75.i64[0] = v75.i64[0] - v15 - 0x1000000000100;
  v75.i64[1] = v19;
  v20 = (unint64_t)(*(_OWORD *)&v76 - v18) >> 64;
  if ((unint64_t)(v76.i64[0] - v18) >= 0x100)
    ++v20;
  v76.i64[0] = v76.i64[0] - v18 - 256;
  v76.i64[1] = v20;
  v21 = (unint64_t)(*(_OWORD *)&v77 - v17) >> 64;
  if ((unint64_t)(v77.i64[0] - v17) >= 0x100)
    ++v21;
  v77.i64[0] = v77.i64[0] - v17 - 256;
  v77.i64[1] = v21;
  p224_felem_reduce(v91, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v94, a8);
  v74 = v74 - v62.u64[0] + __PAIR128__(1, 256);
  v22 = (*(_OWORD *)&v75 - v62.u64[1]) >> 64;
  if (v75.i64[0] - v62.i64[1] >= 0x1000000000100uLL)
    ++v22;
  v75.i64[0] = v75.i64[0] - v62.i64[1] - 0x1000000000100;
  v75.i64[1] = v22;
  v23 = (*(_OWORD *)&v76 - v64.u64[0]) >> 64;
  if (v76.i64[0] - v64.i64[0] >= 0x100uLL)
    ++v23;
  v76.i64[0] = v76.i64[0] - v64.i64[0] - 256;
  v76.i64[1] = v23;
  v24 = (*(_OWORD *)&v77 - v64.u64[1]) >> 64;
  if (v77.i64[0] - v64.i64[1] >= 0x100uLL)
    ++v24;
  v77.i64[0] = v77.i64[0] - v64.i64[1] - 256;
  v77.i64[1] = v24;
  p224_felem_reduce(&v94, (unint64_t *)&v74);
  is_zero = p224_felem_is_zero(&v94);
  v26 = p224_felem_is_zero(v91);
  v27 = p224_felem_is_zero((_QWORD *)a6);
  v28 = p224_felem_is_zero(a10);
  if ((v26 & is_zero & ~v27 & (v28 ^ 1)) != 0)
    return p224_point_double(a1, a2, a3, (unint64_t *)a4, a5, (int64x2_t *)a6);
  v65 = v27;
  v66 = v28;
  if (a7)
  {
    v30 = *(int8x16_t *)(a6 + 16);
    v87 = *(int8x16_t *)a6;
    v88 = v30;
  }
  else
  {
    p224_felem_mul((uint64_t)&v74, (unint64_t *)a6, a10);
    p224_felem_reduce(&v87, (unint64_t *)&v74);
  }
  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v94, (unint64_t *)&v87);
  p224_felem_reduce(&v81, (unint64_t *)&v74);
  v87 = v94;
  v88 = v95;
  p224_felem_square(&v74, (unint64_t *)&v94);
  p224_felem_reduce(&v94, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v94, (unint64_t *)&v87);
  p224_felem_reduce(&v87, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v92, (unint64_t *)&v94);
  p224_felem_reduce(&v92, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v89, (unint64_t *)&v87);
  p224_felem_square(&v67, (unint64_t *)v91);
  v31 = v92;
  v32 = v93.i64[1];
  v63 = v93.i64[0];
  v33 = __CFADD__(v87.i64[0], 2 * v92.i64[0]);
  v67 = v67 - __PAIR128__(v33, v87.i64[0] + 2 * v92.i64[0]) + __PAIR128__(2, 512);
  v34 = __CFADD__(v87.i64[1], 2 * v92.i64[1]);
  v68 = v68 - __PAIR128__(v34, v87.i64[1] + 2 * v92.i64[1]) + __PAIR128__(1, 0xFFFDFFFFFFFFFE00);
  v35 = __CFADD__(v88.i64[0], 2 * v93.i64[0]);
  v36 = *(_OWORD *)&v69 - __PAIR128__(v35, v88.i64[0] + 2 * v93.i64[0]);
  v69.i64[0] = v69.i64[0] - (v88.i64[0] + 2 * v93.i64[0]) - 512;
  v69.i64[1] = ((unint64_t)v36 >= 0x200) + *((_QWORD *)&v36 + 1) + 1;
  v37 = __CFADD__(v88.i64[1], 2 * v93.i64[1]);
  v39 = v70.i64[0] - (v88.i64[1] + 2 * v93.i64[1]);
  v38 = (*(_OWORD *)&v70 - __PAIR128__(v37, v88.i64[1] + 2 * v93.i64[1])) >> 64;
  v70.i64[0] = v39 - 512;
  v70.i64[1] = (v39 >= 0x200) + v38 + 1;
  p224_felem_reduce(&v85, (unint64_t *)&v67);
  v92.i64[0] = v31.i64[0] - v85.i64[0] + 0x400000000000004;
  v92.i64[1] = v31.i64[1] - v85.i64[1] + 0x3FFFBFFFFFFFFFCLL;
  v93.i64[0] = v63 - v86.i64[0] + 0x3FFFFFFFFFFFFFCLL;
  v93.i64[1] = v32 - v86.i64[1] + 0x3FFFFFFFFFFFFFCLL;
  p224_felem_mul((uint64_t)&v67, (unint64_t *)v91, (unint64_t *)&v92);
  v40 = ((v67 - v74) >> 64) + 0x100000000000000;
  *(_QWORD *)&v67 = v67 - v74;
  *((_QWORD *)&v67 + 1) = v40;
  v41 = ((v68 - *(_OWORD *)&v75) >> 64) + 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)&v68 = v68 - v75.i64[0];
  *((_QWORD *)&v68 + 1) = v41;
  v42 = ((*(_OWORD *)&v69 - *(_OWORD *)&v76) >> 64) + 0xFFFFFFFFFFFFFFLL;
  v69.i64[0] -= v76.i64[0];
  v69.i64[1] = v42;
  v43 = ((*(_OWORD *)&v70 - *(_OWORD *)&v77) >> 64) + 0x100000000000000;
  v70.i64[0] -= v77.i64[0];
  v70.i64[1] = v43;
  v44 = ((*(_OWORD *)&v71 - *(_OWORD *)&v78) >> 64) + 0xFFFEFFFFFFFFFFLL;
  v71.i64[0] -= v78.i64[0];
  v71.i64[1] = v44;
  v45 = ((*(_OWORD *)&v72 - *(_OWORD *)&v79) >> 64) + 0xFFFFFFFFFFFFFFLL;
  v72.i64[0] -= v79.i64[0];
  v72.i64[1] = v45;
  v46 = ((*(_OWORD *)&v73 - *(_OWORD *)&v80) >> 64) + 0xFFFFFFFFFFFFFFLL;
  v73.i64[0] -= v80.i64[0];
  v73.i64[1] = v46;
  p224_felem_reduce(&v83, (unint64_t *)&v67);
  v47 = 0;
  v48 = (int8x16_t)vdupq_n_s64(-(uint64_t)v65);
  do
  {
    *(int8x16_t *)((char *)&v85 + v47 * 8) = vbslq_s8(v48, *(int8x16_t *)&a8[v47], *(int8x16_t *)((char *)&v85 + v47 * 8));
    v47 += 2;
  }
  while (v47 != 4);
  v49 = 0;
  v50 = (int8x16_t)vdupq_n_s64(-(uint64_t)v66);
  do
  {
    *(int8x16_t *)((char *)&v85 + v49 * 16) = vbslq_s8(v50, a4[v49], *(int8x16_t *)((char *)&v85 + v49 * 16));
    ++v49;
  }
  while (v49 != 2);
  for (i = 0; i != 4; i += 2)
    *(int8x16_t *)((char *)&v83 + i * 8) = vbslq_s8(v48, *(int8x16_t *)&a9[i], *(int8x16_t *)((char *)&v83 + i * 8));
  for (j = 0; j != 2; ++j)
    *(int8x16_t *)((char *)&v83 + j * 16) = vbslq_s8(v50, (int8x16_t)a5[j], *(int8x16_t *)((char *)&v83 + j * 16));
  for (k = 0; k != 4; k += 2)
    *(int8x16_t *)((char *)&v81 + k * 8) = vbslq_s8(v48, *(int8x16_t *)&a10[k], *(int8x16_t *)((char *)&v81 + k * 8));
  for (m = 0; m != 32; m += 16)
    *(int8x16_t *)((char *)&v81 + m) = vbslq_s8(v50, *(int8x16_t *)(a6 + m), *(int8x16_t *)((char *)&v81 + m));
  v55 = v86;
  *a1 = v85;
  a1[1] = v55;
  v56 = v84;
  *a2 = v83;
  a2[1] = v56;
  result = *(double *)v81.i64;
  v57 = v82;
  *a3 = v81;
  a3[1] = v57;
  return result;
}

unint64_t p224_felem_is_zero(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  return (((v1 ^ 0xFFFF0000000000 | *a1 ^ 1 | a1[3] ^ 0xFFFFFFFFFFFFFFLL | a1[2] ^ 0xFFFFFFFFFFFFFFLL) - 1) | ((v1 | *a1 | a1[2] | a1[3]) - 1) | ((v1 ^ 0xFFFE0000000000 | *a1 ^ 2 | a1[3] ^ 0x1FFFFFFFFFFFFFFLL | a1[2] ^ 0xFFFFFFFFFFFFFFuLL) - 1)) >> 63;
}

double p224_point_double(int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, unint64_t *a4, int64x2_t *a5, int64x2_t *a6)
{
  int8x16_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  uint64_t v18;
  unint64_t v19;
  BOOL v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  int64x2_t v28;
  int64x2_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  double result;
  unint64_t v46[4];
  int64x2_t v47;
  int64x2_t v48;
  int8x16_t v49[2];
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;
  int8x16_t v53;
  int8x16_t v54;
  int8x16_t v55;
  int8x16_t v56;
  int8x16_t v57;
  int8x16_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  unsigned __int128 v63;
  int8x16_t v64;
  unsigned __int128 v65;
  unsigned __int128 v66;
  unsigned __int128 v67;
  unsigned __int128 v68;
  int8x16_t v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v9.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v9.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v68 = (unsigned __int128)v9;
  v69 = v9;
  v66 = (unsigned __int128)v9;
  v67 = (unsigned __int128)v9;
  v64 = v9;
  v65 = (unsigned __int128)v9;
  v63 = (unsigned __int128)v9;
  v61 = v9;
  v62 = v9;
  v59 = v9;
  v60 = v9;
  v57 = v9;
  v58 = v9;
  v55 = v9;
  v56 = v9;
  v53 = v9;
  v54 = v9;
  v51 = v9;
  v52 = v9;
  v49[1] = v9;
  v50 = v9;
  v49[0] = v9;
  v10 = *a4;
  v11 = a4[1];
  v13 = a4[2];
  v12 = a4[3];
  p224_felem_square(&v63, (unint64_t *)a6);
  p224_felem_reduce(&v54, (unint64_t *)&v63);
  p224_felem_square(&v63, (unint64_t *)a5);
  p224_felem_reduce(&v52, (unint64_t *)&v63);
  p224_felem_mul((uint64_t)&v63, a4, (unint64_t *)&v52);
  p224_felem_reduce(&v50, (unint64_t *)&v63);
  v14 = v54;
  v47.i64[0] = v10 + 0x400000000000004 - v54.i64[0];
  v47.i64[1] = v11 + 0x3FFFBFFFFFFFFFCLL - v54.i64[1];
  v15 = v55;
  v48.i64[0] = v13 - v55.i64[0] + 0x3FFFFFFFFFFFFFCLL;
  v48.i64[1] = v12 - v55.i64[1] + 0x3FFFFFFFFFFFFFCLL;
  v46[0] = 3 * (v54.i64[0] + v10);
  v46[1] = 3 * (v54.i64[1] + v11);
  v46[2] = 3 * (v55.i64[0] + v13);
  v46[3] = 3 * (v55.i64[1] + v12);
  p224_felem_mul((uint64_t)&v63, (unint64_t *)&v47, v46);
  p224_felem_reduce(v49, (unint64_t *)&v63);
  p224_felem_square(&v63, (unint64_t *)v49);
  v16 = v50;
  v17 = v51;
  v63 = v63 - (unint64_t)(8 * v50.i64[0]) + __PAIR128__(1, 256);
  v19 = (unint64_t)(*(_OWORD *)&v64 - 8 * v50.i64[1]) >> 64;
  v18 = v64.i64[0] - 8 * v50.i64[1];
  v20 = __CFADD__(v18, 0xFFFEFFFFFFFFFF00);
  v21 = v18 - 0x1000000000100;
  if (v20)
    ++v19;
  v64.i64[0] = v21;
  v64.i64[1] = v19;
  v23 = (v65 - (unint64_t)(8 * v51.i64[0])) >> 64;
  v22 = v65 - 8 * v51.i64[0];
  v20 = v22 >= 0x100;
  v24 = v22 - 256;
  if (v20)
    ++v23;
  *(_QWORD *)&v65 = v24;
  *((_QWORD *)&v65 + 1) = v23;
  v26 = (v66 - (unint64_t)(8 * v51.i64[1])) >> 64;
  v25 = v66 - 8 * v51.i64[1];
  v20 = v25 >= 0x100;
  v27 = v25 - 256;
  if (v20)
    ++v26;
  *(_QWORD *)&v66 = v27;
  *((_QWORD *)&v66 + 1) = v26;
  p224_felem_reduce(a1, (unint64_t *)&v63);
  v28 = vaddq_s64(*a6, *a5);
  v29 = vaddq_s64(a6[1], a5[1]);
  v30 = v52.i64[0] + v14.i64[0];
  v31 = v52.i64[1] + v14.i64[1];
  v32 = v53.i64[0] + v15.i64[0];
  v33 = v53.i64[1] + v15.i64[1];
  v47 = v28;
  v48 = v29;
  p224_felem_square(&v63, (unint64_t *)&v47);
  v63 = v63 - (unint64_t)v30 + __PAIR128__(1, 256);
  v34 = (unint64_t)(*(_OWORD *)&v64 - v31) >> 64;
  if ((unint64_t)(v64.i64[0] - v31) >= 0x1000000000100)
    ++v34;
  v64.i64[0] = v64.i64[0] - v31 - 0x1000000000100;
  v64.i64[1] = v34;
  v35 = (v65 - (unint64_t)v32) >> 64;
  if ((unint64_t)(v65 - v32) >= 0x100)
    ++v35;
  *(_QWORD *)&v65 = v65 - v32 - 256;
  *((_QWORD *)&v65 + 1) = v35;
  v36 = (v66 - (unint64_t)v33) >> 64;
  if ((unint64_t)(v66 - v33) >= 0x100)
    ++v36;
  *(_QWORD *)&v66 = v66 - v33 - 256;
  *((_QWORD *)&v66 + 1) = v36;
  p224_felem_reduce(a3, (unint64_t *)&v63);
  v37 = a1->i64[1];
  v50.i64[0] = 4 * v16.i64[0] + 0x400000000000004 - a1->i64[0];
  v50.i64[1] = 4 * v16.i64[1] + 0x3FFFBFFFFFFFFFCLL - v37;
  v38 = 4 * v17.i64[1] - a1[1].i64[1] + 0x3FFFFFFFFFFFFFCLL;
  v51.i64[0] = 4 * v17.i64[0] - a1[1].i64[0] + 0x3FFFFFFFFFFFFFCLL;
  v51.i64[1] = v38;
  p224_felem_mul((uint64_t)&v63, (unint64_t *)v49, (unint64_t *)&v50);
  p224_felem_square(&v56, (unint64_t *)&v52);
  v39 = ((v63 - *(_OWORD *)&v56 * 8) >> 64) + 0x100000000000000;
  *(_QWORD *)&v63 = v63 - 8 * v56.i64[0];
  *((_QWORD *)&v63 + 1) = v39;
  v40 = *(_OWORD *)&v64 - *(_OWORD *)&v57 * 8;
  v64.i64[0] -= 8 * v57.i64[0];
  v64.i64[1] = *((_QWORD *)&v40 + 1) + 0xFFFFFFFFFFFFFFLL;
  v65 = v65 - *(_OWORD *)&v58 * 8 + __PAIR128__(0xFFFFFFFFFFFFFFLL, 0);
  v66 = v66 - *(_OWORD *)&v59 * 8 + __PAIR128__(0x100000000000000, 0);
  v67 = v67 - *(_OWORD *)&v60 * 8 + __PAIR128__(0xFFFEFFFFFFFFFFLL, 0);
  v68 = v68 - *(_OWORD *)&v61 * 8 + __PAIR128__(0xFFFFFFFFFFFFFFLL, 0);
  v41 = ((unsigned __int128)(*(_OWORD *)&v69 - *(_OWORD *)&v62 * 8) >> 64) + 0xFFFFFFFFFFFFFFLL;
  v69.i64[0] -= 8 * v62.i64[0];
  v69.i64[1] = v41;
  *(_QWORD *)&result = p224_felem_reduce(a2, (unint64_t *)&v63).u64[0];
  return result;
}

void ec_GFp_nistp224_make_precomp(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int8x16_t *v4;
  int64x2_t *v5;
  uint64_t v6;
  unint64_t v7;
  int8x16_t *v8;
  int8x16_t *v9;
  int8x16_t *v10;

  v3 = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 96) = *(_QWORD *)a2 & 0xFFFFFFFFFFFFFFLL;
  v4 = (int8x16_t *)(a1 + 96);
  *(_QWORD *)(a1 + 104) = (*(__int128 *)a2 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 112) = (*(__int128 *)(a2 + 8) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 120) = (*(__int128 *)(a2 + 16) >> 40) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 72) & 0xFFFFFFFFFFFFFFLL;
  v5 = (int64x2_t *)(a1 + 128);
  *(_QWORD *)(a1 + 136) = (*(__int128 *)(a2 + 72) >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 144) = (*(__int128 *)(a2 + 80) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 152) = (*(__int128 *)(a2 + 88) >> 40) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 144) & 0xFFFFFFFFFFFFFFLL;
  v6 = a1 + 160;
  *(_QWORD *)(a1 + 168) = (*(__int128 *)(a2 + 144) >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 176) = (*(__int128 *)(a2 + 152) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 184) = (*(__int128 *)(a2 + 160) >> 40) & 0xFFFFFFFFFFFFFFLL;
  v7 = 2;
  do
  {
    v8 = (int8x16_t *)(a1 + v3 + 192);
    v9 = (int8x16_t *)(a1 + v3 + 224);
    v10 = (int8x16_t *)(a1 + v3 + 256);
    if ((v7 & 1) != 0)
      p224_point_add(v8, v9, v10, v4, v5, v6, 0, (unint64_t *)(a1 + v3 + 96), (unint64_t *)(a1 + v3 + 128), (unint64_t *)(a1 + v3 + 160));
    else
      p224_point_double(v8, v9, v10, (unint64_t *)(a1 + 96 * (v7 >> 1)), (int64x2_t *)(a1 + 96 * (v7 >> 1) + 32), (int64x2_t *)(a1 + 96 * (v7 >> 1) + 64));
    ++v7;
    v3 += 96;
  }
  while (v3 != 1440);
}

unint64_t p224_select_point(unint64_t result, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  uint64_t i;
  uint64_t j;

  a4[4] = 0u;
  a4[5] = 0u;
  a4[2] = 0u;
  a4[3] = 0u;
  *a4 = 0u;
  a4[1] = 0u;
  if (a2)
  {
    for (i = 0; i != a2; ++i)
    {
      for (j = 0; j != 96; j += 8)
        *(_QWORD *)((char *)a4 + j) |= *(_QWORD *)(a3 + j) & (((((i ^ result | ((i ^ result) >> 4)) & 4) != 0) | (i ^ result) & 1u | (((i ^ result) & 0x10) != 0) | (((((i ^ result | ((i ^ result) >> 4)) >> 2) | i ^ result | ((i ^ result) >> 4)) & 2) != 0))
                                                            - 1);
      a3 += 96;
    }
  }
  return result;
}

double p224_felem_neg(int8x16_t *a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  _BOOL8 v4;
  unint64_t v5;
  double result;
  unint64_t v7[2];
  unsigned __int128 v8;
  unsigned __int128 v9;
  unsigned __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = 0u;
  v13 = 0u;
  v11 = 0u;
  v3 = a2[1];
  v4 = *a2 <= 0x100uLL;
  v7[0] = 256 - *a2;
  v7[1] = v4;
  v8 = 0xFFFEFFFFFFFFFF00 - __PAIR128__(v4, v3);
  v5 = a2[3];
  v9 = 0xFFFFFFFFFFFFFF00 - __PAIR128__(v2, a2[2]);
  v10 = 0xFFFFFFFFFFFFFF00 - __PAIR128__(v9, v5);
  *(_QWORD *)&result = p224_felem_reduce(a1, v7).u64[0];
  return result;
}

uint64_t bn_mod_u16_consttime(uint64_t a1, unsigned int a2)
{
  unsigned int v4;
  uint64_t v5;
  char v6;
  uint64_t result;
  unint64_t v8;
  unsigned int v9;
  unint64_t v10;
  unsigned int v11;
  unsigned __int16 v12;
  unint64_t v13;
  unsigned __int16 v14;

  if (a2 < 2)
    return 0;
  v4 = BN_num_bits_word(a2 - 1);
  if (v4 >= 0x11)
    bn_mod_u16_consttime_cold_1();
  v5 = *(unsigned int *)(a1 + 8);
  if ((int)v5 < 1)
    return 0;
  v6 = v4;
  LODWORD(result) = 0;
  v8 = v5 + 1;
  v9 = v5 - 1;
  v10 = ((unint64_t)a2 + (1 << (v6 + 32)) - 1) / a2;
  do
  {
    v11 = *(_DWORD *)(*(_QWORD *)a1 + 8 * v9 + 4);
    v12 = mod_u16(__PAIR64__(result, v11) >> 16, a2, v6, v10);
    HIDWORD(v13) = mod_u16((unsigned __int16)v11 | (v12 << 16), a2, v6, v10);
    LODWORD(v13) = *(_DWORD *)(*(_QWORD *)a1 + 8 * v9);
    v14 = mod_u16(v13 >> 16, a2, v6, v10);
    result = mod_u16((unsigned __int16)v13 | (v14 << 16), a2, v6, v10);
    --v8;
    --v9;
  }
  while (v8 > 1);
  return result;
}

uint64_t mod_u16(unsigned int a1, unsigned int a2, char a3, unsigned int a4)
{
  if (a1
     - ((((a4 * (unint64_t)a1) >> 32)
                     + ((a1 - ((a4 * (unint64_t)a1) >> 32)) >> 1)) >> (a3 - 1))
     * a2 >= a2)
    mod_u16_cold_1();
  return (unsigned __int16)(a1
                          - ((((a4 * (unint64_t)a1) >> 32)
                                          + ((a1 - ((a4 * (unint64_t)a1) >> 32)) >> 1)) >> (a3 - 1))
                          * a2);
}

BIO *__cdecl BIO_new_mem_buf(void *buf, int len)
{
  uint64_t v2;
  size_t v4;
  BIO *result;
  size_t *v6;

  v2 = *(_QWORD *)&len;
  v4 = *(_QWORD *)&len;
  if ((*(_QWORD *)&len & 0x8000000000000000) != 0)
  {
    v4 = strlen((const char *)buf);
    if (buf)
      goto LABEL_7;
  }
  else if (buf)
  {
    goto LABEL_7;
  }
  if (v2)
  {
    ERR_put_error(17, 0, 111, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio_mem.c", 75);
    return 0;
  }
LABEL_7:
  result = BIO_new(&mem_method);
  if (result)
  {
    v6 = *(size_t **)&result->flags;
    *v6 = v4;
    v6[1] = (size_t)buf;
    v6[2] = v4;
    LODWORD(result->cb_arg) |= 0x200u;
    result->init = 0;
  }
  return result;
}

uint64_t mem_write(uint64_t a1, const void *a2, uint64_t a3)
{
  BUF_MEM *v5;
  uint64_t v6;

  if ((*(_BYTE *)(a1 + 17) & 2) != 0)
  {
    ERR_put_error(17, 0, 116, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio_mem.c", 167);
    return 0xFFFFFFFFLL;
  }
  v5 = *(BUF_MEM **)(a1 + 32);
  BIO_clear_retry_flags(a1);
  v6 = *(_QWORD *)&v5->length;
  if ((int)(*(_QWORD *)&v5->length ^ 0x7FFFFFFF) < (int)a3
    || BUF_MEM_grow_clean(v5, v6 + a3) != (int)v6 + (uint64_t)(int)a3)
  {
    return 0xFFFFFFFFLL;
  }
  if ((_DWORD)a3)
    memcpy(&v5->data[(int)v6], a2, (int)a3);
  return a3;
}

size_t mem_read(uint64_t a1, void *a2, int a3)
{
  size_t v3;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  unint64_t v9;
  size_t v10;

  LODWORD(v3) = a3;
  v6 = *(_QWORD *)(a1 + 32);
  BIO_clear_retry_flags(a1);
  v7 = *(_QWORD *)v6;
  if ((int)*(_QWORD *)v6 >= (int)v3)
    v8 = v3;
  else
    v8 = *(_QWORD *)v6;
  if (v7 >= 0x7FFFFFFF)
    v3 = v3;
  else
    v3 = v8;
  if ((int)v3 < 1)
  {
    if (!v7)
    {
      v3 = *(unsigned int *)(a1 + 24);
      if ((_DWORD)v3)
        BIO_set_retry_read(a1);
    }
  }
  else
  {
    memcpy(a2, *(const void **)(v6 + 8), v3);
    v9 = *(_QWORD *)v6;
    v10 = *(_QWORD *)v6 - v3;
    *(_QWORD *)v6 = v10;
    if ((*(_BYTE *)(a1 + 17) & 2) != 0)
    {
      *(_QWORD *)(v6 + 8) += v3;
    }
    else if (v9 != v3)
    {
      memmove(*(void **)(v6 + 8), (const void *)(*(_QWORD *)(v6 + 8) + v3), v10);
    }
  }
  return v3;
}

size_t mem_gets(uint64_t a1, _BYTE *a2, int a3)
{
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  size_t result;

  v6 = *(unsigned int **)(a1 + 32);
  BIO_clear_retry_flags(a1);
  if ((int)*v6 >= a3)
    v7 = (a3 - 1);
  else
    v7 = *v6;
  if ((int)v7 <= 0)
  {
    result = 0;
    if (a3 > 0)
LABEL_14:
      *a2 = 0;
  }
  else
  {
    v8 = 0;
    while (*(_BYTE *)(*((_QWORD *)v6 + 1) + v8) != 10)
    {
      if (v7 == ++v8)
        goto LABEL_12;
    }
    LODWORD(v7) = v8 + 1;
LABEL_12:
    result = mem_read(a1, a2, v7);
    if ((int)result >= 1)
    {
      a2 += result;
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t mem_ctrl(uint64_t a1, int a2, int a3, uint64_t **a4)
{
  uint64_t result;
  uint64_t *v8;
  char *v9;
  size_t v10;
  char *v11;

  result = 0;
  v8 = *(uint64_t **)(a1 + 32);
  if (a2 > 113)
  {
    switch(a2)
    {
      case 114:
        mem_free(a1);
        *(_DWORD *)(a1 + 12) = a3;
        *(_QWORD *)(a1 + 32) = a4;
        break;
      case 115:
        if (a4)
          *a4 = v8;
        break;
      case 130:
        *(_DWORD *)(a1 + 24) = a3;
        break;
      default:
        return result;
    }
    return 1;
  }
  else
  {
    switch(a2)
    {
      case 1:
        v9 = (char *)v8[1];
        if (v9)
        {
          v10 = v8[2];
          if ((*(_BYTE *)(a1 + 17) & 2) != 0)
          {
            v11 = &v9[*v8 - v10];
            *v8 = v10;
            v8[1] = (uint64_t)v11;
          }
          else
          {
            if (v10)
              bzero(v9, v10);
            *v8 = 0;
          }
        }
        return 1;
      case 2:
        result = *v8 == 0;
        break;
      case 3:
        result = *v8;
        if (a4)
          *a4 = (uint64_t *)v8[1];
        break;
      case 8:
        result = *(int *)(a1 + 12);
        break;
      case 9:
        *(_DWORD *)(a1 + 12) = a3;
        return 1;
      case 10:
        result = *v8;
        break;
      case 11:
        return 1;
      default:
        return result;
    }
  }
  return result;
}

BUF_MEM *mem_new(uint64_t a1)
{
  BUF_MEM *result;

  result = BUF_MEM_new();
  if (result)
  {
    *(_QWORD *)(a1 + 8) = 0x100000001;
    *(_DWORD *)(a1 + 24) = -1;
    *(_QWORD *)(a1 + 32) = result;
    return (BUF_MEM *)1;
  }
  return result;
}

uint64_t mem_free(uint64_t a1)
{
  BUF_MEM *v2;

  if (*(_DWORD *)(a1 + 12))
  {
    if (*(_DWORD *)(a1 + 8))
    {
      v2 = *(BUF_MEM **)(a1 + 32);
      if (v2)
      {
        if ((*(_BYTE *)(a1 + 17) & 2) != 0)
          v2->data = 0;
        BUF_MEM_free(v2);
        *(_QWORD *)(a1 + 32) = 0;
      }
    }
  }
  return 1;
}

const EVP_CIPHER *EVP_enc_null(void)
{
  return (const EVP_CIPHER *)&n_cipher;
}

uint64_t null_init_key()
{
  return 1;
}

uint64_t null_cipher(int a1, void *__dst, void *__src, size_t __n)
{
  if (__src != __dst && __n)
    memcpy(__dst, __src, __n);
  return 1;
}

unsigned __int8 *EC_POINT_point2buf(const EC_GROUP *a1, const EC_POINT *a2, point_conversion_form_t a3, unsigned __int8 **a4, uint64_t a5, BN_CTX *a6)
{
  unsigned __int8 *result;
  size_t v11;
  BN_CTX *v12;
  unsigned __int8 *v13;

  *a4 = 0;
  result = (unsigned __int8 *)EC_POINT_point2oct(a1, a2, a3, 0, 0, a6);
  if (result)
  {
    v11 = (size_t)result;
    result = (unsigned __int8 *)OPENSSL_malloc((unint64_t)result);
    if (result)
    {
      v13 = result;
      result = (unsigned __int8 *)EC_POINT_point2oct(a1, a2, a3, result, v11, v12);
      if (result)
      {
        *a4 = v13;
      }
      else
      {
        OPENSSL_free(v13);
        return 0;
      }
    }
  }
  return result;
}

int EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *a1, EC_POINT *a2, const BIGNUM *x, int y_bit, BN_CTX *a5)
{
  int v10;
  int v11;
  _BOOL4 v12;
  BN_CTX *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  BIGNUM *v19;
  BIGNUM *v20;
  BN_CTX *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  BN_CTX *v27;

  if (!EC_GROUP_cmp(a1, *(const EC_GROUP **)a2, 0))
  {
    if (BN_is_negative((uint64_t)x) || (BN_cmp(x, (const BIGNUM *)((char *)a1 + 56)) & 0x80000000) == 0)
    {
      v10 = 107;
      v11 = 264;
      goto LABEL_6;
    }
    ERR_clear_error();
    if (a5)
    {
      v14 = 0;
    }
    else
    {
      a5 = BN_CTX_new();
      v14 = a5;
      if (!a5)
        return 0;
    }
    v27 = v14;
    v26 = y_bit != 0;
    BN_CTX_start(a5);
    v15 = BN_CTX_get(a5);
    v16 = BN_CTX_get(a5);
    v17 = BN_CTX_get(a5);
    v18 = BN_CTX_get(a5);
    v19 = BN_CTX_get(a5);
    if (!v19)
      goto LABEL_34;
    v20 = v19;
    if (!EC_GROUP_get_curve_GFp(a1, 0, v17, v18, a5)
      || !BN_mod_sqr(v16, x, (const BIGNUM *)((char *)a1 + 56), a5)
      || !BN_mod_mul(v15, v16, x, (const BIGNUM *)((char *)a1 + 56), a5))
    {
      goto LABEL_34;
    }
    if (*((_DWORD *)a1 + 56))
    {
      if (!bn_mod_lshift1_consttime((uint64_t)v16, (uint64_t)x, (uint64_t)a1 + 56, a5)
        || !bn_mod_add_consttime((uint64_t)v16, (uint64_t)v16, (uint64_t)x, (uint64_t)a1 + 56, a5)
        || !bn_mod_sub_consttime((uint64_t)v15, (uint64_t)v15, (uint64_t)v16, (uint64_t)a1 + 56, a5))
      {
        goto LABEL_34;
      }
    }
    else if (!BN_mod_mul(v16, v17, x, (const BIGNUM *)((char *)a1 + 56), a5)
           || !bn_mod_add_consttime((uint64_t)v15, (uint64_t)v15, (uint64_t)v16, (uint64_t)a1 + 56, a5))
    {
      goto LABEL_34;
    }
    if (!bn_mod_add_consttime((uint64_t)v15, (uint64_t)v15, (uint64_t)v18, (uint64_t)a1 + 56, a5))
    {
LABEL_34:
      v12 = 0;
      goto LABEL_35;
    }
    if (!BN_mod_sqrt(v20, v15, (const BIGNUM *)((char *)a1 + 56), a5))
    {
      v21 = v27;
      if ((ERR_peek_last_error() & 0xFF000FFF) == 0x300006E)
      {
        ERR_clear_error();
        v22 = 107;
        v23 = 328;
      }
      else
      {
        v22 = 3;
        v23 = 330;
      }
      ERR_put_error(15, 0, v22, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", v23);
      v12 = 0;
      goto LABEL_36;
    }
    if (BN_is_odd((uint64_t)v20) != v26)
    {
      if (BN_is_zero((uint64_t)v20))
      {
        v24 = 108;
        v25 = 337;
LABEL_33:
        ERR_put_error(15, 0, v24, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", v25);
        goto LABEL_34;
      }
      if (!BN_usub(v20, (const BIGNUM *)((char *)a1 + 56), v20))
        goto LABEL_34;
    }
    if (BN_is_odd((uint64_t)v20) == v26)
    {
      v12 = EC_POINT_set_affine_coordinates_GFp(a1, a2, x, v20, a5) != 0;
LABEL_35:
      v21 = v27;
LABEL_36:
      BN_CTX_end(a5);
      BN_CTX_free(v21);
      return v12;
    }
    v24 = 68;
    v25 = 345;
    goto LABEL_33;
  }
  v10 = 106;
  v11 = 259;
LABEL_6:
  ERR_put_error(15, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", v11);
  return 0;
}

double ec_GFp_nistp256_add(uint64_t a1, _OWORD *a2, __int128 *a3, _OWORD *a4)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  double result;
  __int128 v14;
  _OWORD v15[2];
  _OWORD v16[2];
  _OWORD v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v5 = a3[1];
  v22 = *a3;
  v23 = v5;
  v6 = *(__int128 *)((char *)a3 + 88);
  v20 = *(__int128 *)((char *)a3 + 72);
  v21 = v6;
  v7 = a3[10];
  v18 = a3[9];
  v19 = v7;
  v8 = a4[1];
  v17[0] = *a4;
  v17[1] = v8;
  v9 = *(_OWORD *)((char *)a4 + 88);
  v16[0] = *(_OWORD *)((char *)a4 + 72);
  v16[1] = v9;
  v10 = a4[10];
  v15[0] = a4[9];
  v15[1] = v10;
  fiat_p256_point_add((uint64_t *)&v22, (uint64_t *)&v20, (uint64_t *)&v18, (uint64_t)&v22, (uint64_t)&v20, (unint64_t *)&v18, 0, (unint64_t *)v17, (unint64_t *)v16, (unint64_t *)v15);
  v11 = v23;
  *a2 = v22;
  a2[1] = v11;
  v12 = v21;
  *(_OWORD *)((char *)a2 + 72) = v20;
  *(_OWORD *)((char *)a2 + 88) = v12;
  result = *(double *)&v18;
  v14 = v19;
  a2[9] = v18;
  a2[10] = v14;
  return result;
}

double ec_GFp_nistp256_dbl(uint64_t a1, _OWORD *a2, __int128 *a3)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  double result;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = a3[1];
  v15 = *a3;
  v16 = v4;
  v5 = *(__int128 *)((char *)a3 + 88);
  v13 = *(__int128 *)((char *)a3 + 72);
  v14 = v5;
  v6 = a3[10];
  v11 = a3[9];
  v12 = v6;
  fiat_p256_point_double((uint64_t *)&v15, (uint64_t *)&v13, (uint64_t *)&v11, (unint64_t *)&v15, (unint64_t *)&v13, (unint64_t *)&v11);
  v7 = v16;
  *a2 = v15;
  a2[1] = v7;
  v8 = v14;
  *(_OWORD *)((char *)a2 + 72) = v13;
  *(_OWORD *)((char *)a2 + 88) = v8;
  result = *(double *)&v11;
  v10 = v12;
  a2[9] = v11;
  a2[10] = v10;
  return result;
}

double ec_GFp_nistp256_point_mul_public(uint64_t a1, _OWORD *a2, uint64_t a3, _OWORD *a4, _DWORD *a5)
{
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t i;
  __int128 v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  _OWORD *v23;
  unint64_t *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _OWORD *v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 v32;
  BOOL v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  uint64_t v42;
  unsigned __int8 v43;
  uint64_t v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  double result;
  __int128 v53;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  _OWORD v63[16];
  char v64;
  _OWORD v65[2];
  _OWORD v66[2];
  _OWORD v67[2];
  _OWORD v68[2];
  _OWORD v69[2];
  _OWORD v70[2];
  _BYTE v71[672];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v9 = a4[1];
  v68[0] = *a4;
  v68[1] = v9;
  v10 = *(_OWORD *)((char *)a4 + 88);
  v69[0] = *(_OWORD *)((char *)a4 + 72);
  v69[1] = v10;
  memset(v71, 170, sizeof(v71));
  v11 = a4[10];
  v70[0] = a4[9];
  v70[1] = v11;
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v67[0] = v12;
  v67[1] = v12;
  v66[0] = v12;
  v66[1] = v12;
  v65[0] = v12;
  v65[1] = v12;
  fiat_p256_point_double((uint64_t *)v65, (uint64_t *)v66, (uint64_t *)v67, (unint64_t *)v68, (unint64_t *)v69, (unint64_t *)v70);
  for (i = 0; i != 42; i += 6)
    fiat_p256_point_add((uint64_t *)&v71[i * 16], (uint64_t *)&v71[i * 16 + 32], (uint64_t *)&v71[i * 16 + 64], (uint64_t)&v68[i], (uint64_t)&v68[i + 2], (unint64_t *)&v70[i], 0, (unint64_t *)v65, (unint64_t *)v66, (unint64_t *)v67);
  v64 = -86;
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v63[14] = v14;
  v63[15] = v14;
  v63[12] = v14;
  v63[13] = v14;
  v63[10] = v14;
  v63[11] = v14;
  v63[8] = v14;
  v63[9] = v14;
  v63[6] = v14;
  v63[7] = v14;
  v63[4] = v14;
  v63[5] = v14;
  v63[2] = v14;
  v63[3] = v14;
  v63[0] = v14;
  v63[1] = v14;
  v15 = 256;
  ec_compute_wNAF(a1, v63, a5, 0x100uLL, 4u);
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v17 = 1;
  do
  {
    if (!v17)
      fiat_p256_point_double((uint64_t *)&v57, (uint64_t *)&v59, (uint64_t *)&v61, (unint64_t *)&v57, (unint64_t *)&v59, (unint64_t *)&v61);
    if (v15 <= 0x1F)
    {
      v18 = (8 * ((*(_QWORD *)(a3 + 8 * ((v15 + 224) >> 6)) >> (v15 - 32)) & 1)) | (4 * ((*(_QWORD *)(a3 + 8 * ((v15 + 160) >> 6)) >> (v15 - 96)) & 1)) | (2 * ((*(_QWORD *)(a3 + 8 * ((v15 + 96) >> 6)) >> (v15 + 96)) & 1)) | (*(_QWORD *)(a3 + (((v15 + 32) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v15 + 32)) & 1;
      if (v18)
      {
        fiat_p256_point_add((uint64_t *)&v57, (uint64_t *)&v59, (uint64_t *)&v61, (uint64_t)&v57, (uint64_t)&v59, (unint64_t *)&v61, 1, &fiat_p256_g_pre_comp[8 * v18 + 112], &fiat_p256_g_pre_comp[8 * v18 + 116], fiat_p256_one);
        v17 = 0;
      }
      v19 = (8 * ((*(_QWORD *)(a3 + (((v15 + 192) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v15) & 1)) | (4
                                                                                                  * ((*(_QWORD *)(a3 + (((v15 + 128) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v15) & 1)) | (2 * ((*(_QWORD *)(a3 + (((v15 + 64) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v15) & 1)) | (*(_QWORD *)(a3 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v15) & 1;
      if (v19)
      {
        fiat_p256_point_add((uint64_t *)&v57, (uint64_t *)&v59, (uint64_t *)&v61, (uint64_t)&v57, (uint64_t)&v59, (unint64_t *)&v61, 1, &fiat_p256_g_pre_comp[8 * v19 - 8], &fiat_p256_g_pre_comp[8 * v19 - 4], fiat_p256_one);
        v17 = 0;
      }
    }
    v20 = *((char *)v63 + v15);
    if (*((_BYTE *)v63 + v15))
    {
      if ((v20 & 1) == 0)
        ec_GFp_nistp256_point_mul_public_cold_1();
      if (v20 >= 0)
        v21 = *((char *)v63 + v15);
      else
        v21 = -v20;
      v22 = v21 >> 1;
      v23 = &v68[6 * v22];
      v24 = (unint64_t *)(v23 + 2);
      *(_QWORD *)&v25 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v55 = v25;
      v56 = v25;
      if (v20 < 0)
      {
        v30 = *((_QWORD *)v23 + 5);
        v31 = -(uint64_t)*v24;
        v32 = -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v16, *v24) >> 64);
        v33 = __CFADD__(v30, v32);
        v34 = v30 + v32;
        v35 = v33;
        v33 = v34 == 0;
        v36 = -v34;
        v38 = *((_QWORD *)v23 + 6);
        v37 = *((_QWORD *)v23 + 7);
        v40 = (v35 + !v33);
        v39 = v38 + v40;
        v41 = __CFADD__(v38, v40);
        v33 = v39 == 0;
        v42 = -v39;
        v43 = v41 + !v33;
        v33 = __CFADD__(v37, v43);
        v44 = v37 + v43;
        v45 = v33;
        v33 = v44 == 0;
        v46 = -v44;
        if (v45 + !v33)
          v47 = -1;
        else
          v47 = 0;
        v33 = __CFADD__(__CFADD__(v31, v47), v36);
        v48 = __CFADD__(v31, v47) + v36;
        v49 = v33 | __CFADD__(v47, v48);
        v33 = __CFADD__(v49, v42);
        v16 = v49 + v42;
        *(_QWORD *)&v55 = v31 + v47;
        *((_QWORD *)&v55 + 1) = v47 + v48;
        *(_QWORD *)&v56 = v16;
        *((_QWORD *)&v56 + 1) = v46 + v33 + (v47 & 0xFFFFFFFF00000001);
        v24 = (unint64_t *)&v55;
        if (v17)
          goto LABEL_18;
      }
      else if (v17)
      {
LABEL_18:
        v26 = v23[1];
        v57 = *v23;
        v58 = v26;
        v27 = *((_OWORD *)v24 + 1);
        v59 = *(_OWORD *)v24;
        v60 = v27;
        v28 = &v68[6 * v22];
        v29 = v28[5];
        v61 = v28[4];
        v62 = v29;
LABEL_33:
        v17 = 0;
        goto LABEL_34;
      }
      fiat_p256_point_add((uint64_t *)&v57, (uint64_t *)&v59, (uint64_t *)&v61, (uint64_t)&v57, (uint64_t)&v59, (unint64_t *)&v61, 0, (unint64_t *)v23, v24, (unint64_t *)&v70[6 * v22]);
      goto LABEL_33;
    }
LABEL_34:
    --v15;
  }
  while (v15 != -1);
  v50 = v58;
  *a2 = v57;
  a2[1] = v50;
  v51 = v60;
  *(_OWORD *)((char *)a2 + 72) = v59;
  *(_OWORD *)((char *)a2 + 88) = v51;
  result = *(double *)&v61;
  v53 = v62;
  a2[9] = v61;
  a2[10] = v53;
  return result;
}

BOOL ec_GFp_nistp256_cmp_x_coordinate(uint64_t a1, __int128 *a2, uint64_t *a3)
{
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL8 v15;
  unint64_t v16;
  uint64_t v17;
  _BOOL8 v18;
  uint64_t v19;
  uint64_t v20;
  _BOOL8 v21;
  uint64_t v22;
  _BOOL8 v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BOOL8 v28;
  uint64_t v29;
  BOOL v30;
  unint64_t v31;
  _BOOL8 v32;
  uint64_t v33;
  unint64_t v34;
  unsigned __int128 v35;
  uint64_t v36;
  uint64_t v37;
  _BOOL8 v38;
  unint64_t v39;
  _BOOL8 v40;
  _BOOL8 v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _BOOL8 v47;
  uint64_t v48;
  BOOL v49;
  unint64_t v50;
  _BOOL8 v51;
  uint64_t v52;
  unint64_t v53;
  unsigned __int128 v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unsigned __int128 v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  BOOL v72;
  BOOL v73;
  unint64_t v75;
  __int128 v76;
  BOOL v77;
  BOOL v78;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  unint64_t v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  _OWORD v89[2];
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  if (ec_GFp_simple_is_at_infinity(a1, (uint64_t)a2))
    return 0;
  v7 = a2[10];
  v89[0] = a2[9];
  v89[1] = v7;
  fiat_p256_mul((uint64_t *)v89, (unint64_t *)v89, (unint64_t *)v89);
  v8 = *((_OWORD *)a3 + 1);
  v87 = *(_OWORD *)a3;
  v88 = v8;
  fiat_p256_mul((uint64_t *)&v87, (unint64_t *)&v87, (unint64_t *)v89);
  v9 = a2[1];
  v85 = *a2;
  v10 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v11 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v12 = 0xFFFFFFFFLL * v85 + __CFADD__(-(uint64_t)v85, (_QWORD)v85) + v11;
  v13 = __CFADD__(__CFADD__(-(uint64_t)v85, (_QWORD)v85), v11) | __CFADD__(0xFFFFFFFFLL * v85, __CFADD__(-(uint64_t)v85, (_QWORD)v85)+ v11)? (((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFuLL) >> 64) + 1: ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v30 = __CFADD__(v12, *((_QWORD *)&v85 + 1));
  v14 = v12 + *((_QWORD *)&v85 + 1);
  v15 = v30;
  v16 = 0xFFFFFFFF00000001 * v14;
  v17 = (__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v14) >> 64;
  v18 = v15 + __CFADD__(-v14, v14) + v13;
  v30 = __CFADD__(v18, v17);
  v19 = v18 + v17;
  v20 = v30 - 0xFFFFFFFFLL * v85;
  v21 = __CFADD__(v30, 0xFFFFFFFF00000001 * v85);
  v30 = __CFADD__(v16, v10);
  v22 = v16 + v10;
  v23 = v30;
  v30 = __CFADD__(((unint64_t)v14 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFFLL * v14);
  v86 = v9;
  v24 = ((unint64_t)v14 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v25 = ((unint64_t)v14 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v27 = v30 + v20;
  v30 = __CFADD__(v30, v20) | __CFADD__(v25, v27);
  v26 = v25 + v27;
  v28 = v21 + v30 + v22;
  v29 = __CFADD__(v30, v22) | __CFADD__(v21, v30 + v22) ? v23 + 1 : v23;
  v30 = __CFADD__(v19, (_QWORD)v86);
  v31 = v19 + v86;
  v32 = v30;
  v33 = v30 + v26;
  v34 = (v31 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v35 = __PAIR128__(v29, __CFADD__(v30, v26)) + __PAIR128__(v24, v28);
  v36 = 0xFFFFFFFF * v31;
  v37 = (__PAIR128__(0xFFFFFFFFLL, -1) * v31) >> 64;
  v38 = v32 + __CFADD__(-(uint64_t)v31, v31) + v26;
  v39 = (__CFADD__(__CFADD__(-(uint64_t)v31, v31), v33) | __CFADD__(v37, __CFADD__(-(uint64_t)v31, v31) + v33))+ (_QWORD)v35;
  v40 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v31, v31), v33) | __CFADD__(v37, __CFADD__(-(uint64_t)v31, v31) + v33), (_QWORD)v35);
  v41 = __CFADD__(0xFFFFFFFF00000001 * v31, *((_QWORD *)&v35 + 1));
  v42 = 0xFFFFFFFF * v31;
  v43 = (v31 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v44 = (v31 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v45 = v38 + v34 + v36;
  v30 = __CFADD__(__CFADD__(v34, v36), v39) | __CFADD__(v44, (__PAIR128__(v39, v34) + (unint64_t)v42) >> 64);
  v46 = v44 + ((__PAIR128__(v39, v34) + (unint64_t)v42) >> 64);
  v47 = v40 + v30 + *((_QWORD *)&v35 + 1);
  v48 = __CFADD__(v30, *((_QWORD *)&v35 + 1)) | __CFADD__(v40, v30 + *((_QWORD *)&v35 + 1))
      ? v41 + 1
      : v41;
  v49 = __CFADD__(v45, *((_QWORD *)&v86 + 1));
  v50 = v45 + *((_QWORD *)&v86 + 1);
  v51 = v49;
  v52 = v49 + v46;
  v53 = (v50 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v54 = __PAIR128__(v48, __CFADD__(v49, v46)) + __PAIR128__(v43, v47);
  v55 = 0xFFFFFFFF00000001 * v50;
  v56 = -(uint64_t)v50;
  v57 = (__PAIR128__(0xFFFFFFFFLL, -1) * v50) >> 64;
  v58 = __CFADD__((v50 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v50)
      ? ((v50 * (unsigned __int128)0xFFFFFFFFuLL) >> 64) + 1
      : (v50 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v30 = __CFADD__(v56, v50);
  v59 = v51 + __CFADD__(v56, v50) + v46 + v57;
  v60 = v58 + (__CFADD__(v30, v52) | __CFADD__(v57, v30 + v52)) + (_QWORD)v54;
  v62 = __CFADD__(__CFADD__(v30, v52) | __CFADD__(v57, v30 + v52), (_QWORD)v54) | __CFADD__(v58, (__CFADD__(v30, v52) | __CFADD__(v57, v30 + v52)) + (_QWORD)v54);
  v61 = *((_QWORD *)&v54 + 1) + v62 + v55;
  v63 = __CFADD__(v62, v55) | __CFADD__(*((_QWORD *)&v54 + 1), v62 + v55) ? v53 + 1 : v53;
  v65 = v60 - (1 - __CFADD__(v59, 1));
  v64 = (v60 - __PAIR128__(v53, (1 - __CFADD__(v59, 1)))) >> 64;
  v66 = (unint64_t)v63
      - __PAIR128__(v57, -(uint64_t)((v61- __PAIR128__(v64, (1 - (__CFADD__(v65, 0xFFFFFFFF00000001) + v64)))) >> 64));
  v67 = __CFADD__((_QWORD)v66, 0xFFFFFFFFLL) + BYTE8(v66) == 1 ? -1 : 0;
  v68 = v67 & (v59 + 1) | *((_QWORD *)&v66 + 1) & v59;
  v69 = v67 & (v65 - 0xFFFFFFFF) | *((_QWORD *)&v66 + 1) & v60;
  v70 = v67 & (v61 - (1 - (__CFADD__(v65, 0xFFFFFFFF00000001) + v64))) | *((_QWORD *)&v66 + 1) & v61;
  v71 = v67 & (v66 + 0xFFFFFFFF) | v63 & *((_QWORD *)&v66 + 1);
  *(_QWORD *)&v85 = v68;
  *((_QWORD *)&v85 + 1) = v69;
  *(_QWORD *)&v86 = v70;
  *((_QWORD *)&v86 + 1) = v71;
  v72 = (_QWORD)v87 == v68 && *((_QWORD *)&v87 + 1) == v69;
  v73 = v72 && (_QWORD)v88 == v70;
  if (v73 && *((_QWORD *)&v88 + 1) == v71)
    return 1;
  v75 = *(int *)(a1 + 64);
  if ((_DWORD)v75 != *(_DWORD *)(a1 + 24))
    ec_GFp_nistp256_cmp_x_coordinate_cold_1();
  if (!bn_less_than_words(a3, (uint64_t *)(a1 + 232), v75))
    return 0;
  v84 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v76 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v76 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v82 = v76;
  v83 = v76;
  v80 = v76;
  v81 = v76;
  bn_add_words((unint64_t *)&v80, (const unint64_t *)a3, *(const unint64_t **)(a1 + 16), *(_DWORD *)(a1 + 24));
  v87 = v80;
  v88 = v81;
  fiat_p256_mul((uint64_t *)&v87, (unint64_t *)&v87, (unint64_t *)v89);
  v77 = (_QWORD)v87 == (_QWORD)v85 && *((_QWORD *)&v87 + 1) == *((_QWORD *)&v85 + 1);
  v78 = v77 && (_QWORD)v88 == (_QWORD)v86;
  return v78 && *((_QWORD *)&v88 + 1) == *((_QWORD *)&v86 + 1);
}

BOOL bio_fd_should_retry(int a1)
{
  _BOOL8 result;
  unsigned int v2;

  if (a1 != -1)
    return 0;
  v2 = *__error();
  result = 1;
  if (v2 > 0x39 || ((1 << v2) & 0x200003800000010) == 0)
    return v2 == 100;
  return result;
}

uint64_t BIO_set_fd(BIO *a1, int iarg, int a3)
{
  return BIO_int_ctrl(a1, 104, a3, iarg);
}

uint64_t BIO_get_fd(BIO *a1, void *parg)
{
  return BIO_ctrl(a1, 105, 0, parg);
}

BIO *__cdecl BIO_new_fp(FILE *stream, int close_flag)
{
  BIO *v4;
  BIO *v5;

  v4 = BIO_new(&methods_filep);
  v5 = v4;
  if (v4)
    BIO_ctrl(v4, 106, close_flag, stream);
  return v5;
}

BIO_METHOD *BIO_s_file(void)
{
  return (BIO_METHOD *)&methods_filep;
}

uint64_t BIO_set_fp(BIO *a1, void *parg, int a3)
{
  return BIO_ctrl(a1, 106, a3, parg);
}

uint64_t file_write(uint64_t a1, void *__ptr, unsigned int a3)
{
  uint64_t result;

  if (!*(_DWORD *)(a1 + 8))
    return 0;
  LODWORD(result) = fwrite(__ptr, (int)a3, 1uLL, *(FILE **)(a1 + 32));
  if ((int)result <= 0)
    return result;
  else
    return a3;
}

size_t file_read(uint64_t a1, void *__ptr, int a3)
{
  size_t v4;

  if (!*(_DWORD *)(a1 + 8))
    return 0;
  v4 = fread(__ptr, 1uLL, a3, *(FILE **)(a1 + 32));
  if (!v4 && ferror(*(FILE **)(a1 + 32)))
  {
    ERR_put_error(2, 0, 0, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/file.c", 150);
    ERR_put_error(17, 0, 2, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/file.c", 151);
    return 0xFFFFFFFFLL;
  }
  return v4;
}

char *file_gets(uint64_t a1, char *a2, int a3)
{
  char *result;

  if (!a3)
    return 0;
  result = fgets(a2, a3, *(FILE **)(a1 + 32));
  if (result)
    return (char *)strlen(a2);
  *a2 = 0;
  return result;
}

uint64_t file_ctrl(uint64_t a1, int a2, uint64_t a3, char *a4)
{
  uint64_t v4;
  uint64_t result;
  FILE *v7;
  char *v9;
  FILE *v10;
  int v11;
  int v12;
  char __mode[4];

  v4 = a3;
  result = 0;
  v7 = *(FILE **)(a1 + 32);
  *(_DWORD *)__mode = -1431655766;
  if (a2 <= 105)
  {
    switch(a2)
    {
      case 1:
        v4 = 0;
        goto LABEL_12;
      case 2:
        LODWORD(result) = feof(v7);
        return (int)result;
      case 3:
        goto LABEL_36;
      case 8:
        return *(int *)(a1 + 12);
      case 9:
        *(_DWORD *)(a1 + 12) = a3;
        return 1;
      case 11:
        return fflush(v7) == 0;
      default:
        return result;
    }
  }
  if (a2 > 107)
  {
    if (a2 != 108)
    {
      if (a2 == 128)
      {
LABEL_12:
        LODWORD(result) = fseek(v7, v4, 0);
        return (int)result;
      }
      else if (a2 == 133)
      {
LABEL_36:
        JUMPOUT(0x1B5E45018);
      }
      return result;
    }
    file_free(a1);
    *(_DWORD *)(a1 + 12) = v4 & 1;
    if ((v4 & 8) != 0)
    {
      if ((v4 & 2) != 0)
        v9 = "a+";
      else
        v9 = "a";
    }
    else if ((v4 & 6) == 6)
    {
      v9 = "r+";
    }
    else
    {
      if ((v4 & 4) != 0)
        v9 = "w";
      else
        v9 = "r";
      if ((v4 & 6) == 0)
      {
        v11 = 100;
        v12 = 215;
LABEL_34:
        ERR_put_error(17, 0, v11, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/file.c", v12);
        return 0;
      }
    }
    OPENSSL_strlcpy(__mode, v9, 4uLL);
    v10 = fopen(a4, __mode);
    if (v10)
    {
      *(_QWORD *)(a1 + 32) = v10;
      result = 1;
      *(_DWORD *)(a1 + 8) = 1;
      return result;
    }
    ERR_put_error(2, 0, 0, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/file.c", 221);
    ERR_add_error_data(5, "fopen('", a4, "','", __mode, "')");
    v11 = 2;
    v12 = 223;
    goto LABEL_34;
  }
  if (a2 == 106)
  {
    file_free(a1);
    *(_QWORD *)(a1 + 32) = a4;
    result = 1;
    *(_DWORD *)(a1 + 8) = 1;
    *(_DWORD *)(a1 + 12) = v4 & 1;
  }
  else
  {
    if (a4)
      *(_QWORD *)a4 = v7;
    return 1;
  }
  return result;
}

uint64_t file_free(uint64_t a1)
{
  FILE *v2;

  if (*(_DWORD *)(a1 + 12))
  {
    if (*(_DWORD *)(a1 + 8))
    {
      v2 = *(FILE **)(a1 + 32);
      if (v2)
      {
        fclose(v2);
        *(_QWORD *)(a1 + 32) = 0;
      }
    }
    *(_DWORD *)(a1 + 8) = 0;
  }
  return 1;
}

BOOL BIO_hexdump(BIO *a1, uint64_t a2, unint64_t a3, int a4)
{
  int v6;
  BOOL v7;
  unint64_t i;
  unint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  unsigned int j;
  int v14;
  int v15;
  BIO *b;
  __int128 v18;
  __int128 v19;
  int indent[2];
  unint64_t data;
  __int16 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  indent[1] = 0;
  v18 = 0u;
  v19 = 0u;
  b = a1;
  indent[0] = a4;
  v22 = -21846;
  data = 0xAAAAAAAAAAAAAAAALL;
  if (!a3)
    return 1;
  v6 = 0;
  v7 = 0;
  for (i = 0; i != a3; v7 = i >= a3)
  {
    if (!v6)
    {
      BIO_indent(b, indent[0], -1);
      LOBYTE(data) = hexbyte_hextable[DWORD2(v19) >> 28];
      BYTE1(data) = hexbyte_hextable[(*((_QWORD *)&v19 + 1) >> 24) & 0xFLL];
      BYTE2(data) = hexbyte_hextable[(*((_QWORD *)&v19 + 1) >> 20) & 0xFLL];
      BYTE3(data) = hexbyte_hextable[(*((_QWORD *)&v19 + 1) >> 16) & 0xFLL];
      BYTE4(data) = hexbyte_hextable[WORD4(v19) >> 12];
      BYTE5(data) = hexbyte_hextable[(*((_QWORD *)&v19 + 1) >> 8) & 0xFLL];
      BYTE6(data) = hexbyte_hextable[BYTE8(v19) >> 4];
      HIBYTE(data) = hexbyte_hextable[BYTE8(v19) & 0xF];
      v22 = 8224;
      if (BIO_write(b, &data, 10) < 0)
        break;
      v6 = DWORD1(v19);
    }
    v9 = *(unsigned __int8 *)(a2 + i);
    LOBYTE(data) = hexbyte_hextable[v9 >> 4];
    BYTE1(data) = hexbyte_hextable[v9 & 0xF];
    BYTE2(data) = 32;
    if (v6 == 15)
    {
      *(_WORD *)((char *)&data + 3) = 31776;
      v10 = 5;
    }
    else if (v6 == 7)
    {
      BYTE3(data) = 32;
      v10 = 4;
    }
    else
    {
      v10 = 3;
    }
    if (BIO_write(b, &data, v10) < 0)
      break;
    v11 = *(unsigned __int8 *)(a2 + i);
    if ((v11 - 127) < 0xFFFFFFA1)
      LOBYTE(v11) = 46;
    *((_BYTE *)&b + DWORD1(v19) + 8) = v11;
    v6 = DWORD1(v19) + 1;
    DWORD1(v19) = v6;
    ++*((_QWORD *)&v19 + 1);
    if (v6 == 16)
    {
      LOWORD(v19) = 2684;
      if (BIO_write(b, &v18, 18) < 0)
        break;
      v6 = 0;
      DWORD1(v19) = 0;
    }
    ++i;
  }
  if (!v7)
    return 0;
  v12 = DWORD1(v19);
  if (!DWORD1(v19))
    return 1;
  qmemcpy(&data, "    |", 5);
  if (DWORD1(v19) <= 0xF)
  {
    for (j = DWORD1(v19); j < 0x10; DWORD1(v19) = j)
    {
      v14 = j == 15 ? 5 : 3;
      v15 = j == 7 ? 4 : v14;
      if (BIO_write(b, &data, v15) < 0)
        return 0;
      j = DWORD1(v19) + 1;
    }
  }
  *((_BYTE *)&v18 + v12) = 124;
  *((_BYTE *)&v18 + (v12 + 1)) = 10;
  return (BIO_write(b, &v18, v12 + 2) & 0x80000000) == 0;
}

uint64_t HMAC_size(const EVP_MD **a1)
{
  return EVP_MD_size(*a1);
}

BOOL SSL_SESSION_to_bytes_for_ticket(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  __int128 v6;
  _BOOL8 v7;
  _OWORD v9[3];

  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v6;
  v9[2] = v6;
  v9[0] = v6;
  CBB_zero(v9);
  v7 = CBB_init((uint64_t)v9, 0x100uLL)
    && bssl::SSL_SESSION_to_bytes_full(a1, (uint64_t *)v9, 1)
    && CBB_finish((uint64_t)v9, a2, a3) != 0;
  CBB_cleanup((uint64_t)v9);
  return v7;
}

void sub_1B4FCA05C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CBB_cleanup((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BIO_METHOD *BIO_s_socket(void)
{
  return (BIO_METHOD *)&methods_sockp;
}

ssize_t sock_write(uint64_t a1, const void *a2, int a3)
{
  ssize_t v6;

  bio_clear_socket_error(a1);
  v6 = write(*(_DWORD *)(a1 + 24), a2, a3);
  BIO_clear_retry_flags(a1);
  if ((int)v6 <= 0 && bio_fd_should_retry(v6))
    BIO_set_retry_write(a1);
  return v6;
}

void *sock_read(uint64_t a1, void *a2, int a3)
{
  void *v3;

  v3 = a2;
  if (a2)
  {
    bio_clear_socket_error(a1);
    v3 = (void *)read(*(_DWORD *)(a1 + 24), v3, a3);
    BIO_clear_retry_flags(a1);
    if ((int)v3 <= 0 && bio_fd_should_retry((int)v3))
      BIO_set_retry_read(a1);
  }
  return v3;
}

uint64_t sock_ctrl(_DWORD *a1, int a2, int a3, _DWORD *a4)
{
  uint64_t result;

  if (a2 <= 10)
  {
    if (a2 == 8)
      return (int)a1[3];
    if (a2 != 9)
      return 0;
    a1[3] = a3;
    return 1;
  }
  if (a2 == 11)
    return 1;
  if (a2 != 105)
  {
    if (a2 == 104)
    {
      if (a1[3])
      {
        if (a1[2])
          close(a1[6]);
        a1[2] = 0;
        a1[4] = 0;
      }
      a1[6] = *a4;
      result = 1;
      a1[2] = 1;
      a1[3] = a3;
      return result;
    }
    return 0;
  }
  if (!a1[2])
    return -1;
  if (a4)
    *a4 = a1[6];
  return (int)a1[6];
}

uint64_t sock_free(_DWORD *a1)
{
  if (a1[3])
  {
    if (a1[2])
      close(a1[6]);
    a1[2] = 0;
    a1[4] = 0;
  }
  return 1;
}

uint64_t bn_mod_exp_base_2_consttime(BIGNUM *a1, unsigned int a2, const BIGNUM *a3, BN_CTX *a4)
{
  uint64_t result;
  int v9;

  if (BN_is_zero((uint64_t)a3))
    bn_mod_exp_base_2_consttime_cold_5();
  if (BN_is_negative((uint64_t)a3))
    bn_mod_exp_base_2_consttime_cold_4();
  if (!BN_is_odd((uint64_t)a3))
    bn_mod_exp_base_2_consttime_cold_1();
  BN_zero((uint64_t)a1);
  result = BN_num_bits(a3);
  if (!(_DWORD)result)
    bn_mod_exp_base_2_consttime_cold_2();
  if (result >= a2)
    bn_mod_exp_base_2_consttime_cold_3();
  v9 = result - 1;
  if ((_DWORD)result != 1)
  {
    result = BN_set_bit(a1, v9);
    if ((_DWORD)result)
      return bn_mod_lshift_consttime(a1, a1, a2 - v9, (uint64_t)a3, a4) != 0;
  }
  return result;
}

int RSA_padding_add_PKCS1_type_1(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  int v4;
  int v5;
  size_t v6;
  uint64_t v7;

  if (*(_QWORD *)&tlen <= 0xAuLL)
  {
    v4 = 126;
    v5 = 80;
LABEL_5:
    ERR_put_error(4, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v5);
    return 0;
  }
  v6 = *(_QWORD *)&fl;
  v7 = *(_QWORD *)&tlen;
  if ((unint64_t)(*(_QWORD *)&tlen - 11) < *(_QWORD *)&fl)
  {
    v4 = 118;
    v5 = 85;
    goto LABEL_5;
  }
  *(_WORD *)to = 256;
  if (*(_QWORD *)&tlen - 3 != *(_QWORD *)&fl)
    memset(to + 2, 255, *(_QWORD *)&tlen - 3 - *(_QWORD *)&fl);
  to[~v6 + v7] = 0;
  if (v6)
    memcpy(&to[v7 - v6], f, v6);
  return 1;
}

int RSA_padding_add_none(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  int v4;
  int v5;

  if (*(_QWORD *)&fl > *(_QWORD *)&tlen)
  {
    v4 = 114;
    v5 = 255;
LABEL_5:
    ERR_put_error(4, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v5);
    return 0;
  }
  if (*(_QWORD *)&fl < *(_QWORD *)&tlen)
  {
    v4 = 116;
    v5 = 260;
    goto LABEL_5;
  }
  if (*(_QWORD *)&fl)
    memcpy(to, f, *(size_t *)&fl);
  return 1;
}

uint64_t RSA_padding_add_PKCS1_OAEP_mgf1(_BYTE *a1, unint64_t a2, const void *a3, size_t a4, const void *a5, size_t a6, EVP_MD *md, EVP_MD *a8)
{
  EVP_MD *v9;
  EVP_MD *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  _BYTE *v26;
  unsigned __int8 *v27;
  const void *v28;
  const unsigned __int8 *v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  uint64_t v32;
  unsigned __int8 *v33;
  const unsigned __int8 *v34;
  char v35;
  __int128 v36;
  unsigned __int8 *v37;
  char v38;
  _BYTE *v39;
  const EVP_MD *v40;
  unsigned __int8 mask[16];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;

  v9 = md;
  v45 = *MEMORY[0x1E0C80C00];
  if (!md)
    v9 = (EVP_MD *)EVP_sha1();
  if (a8)
    v16 = a8;
  else
    v16 = v9;
  v17 = EVP_MD_size(v9);
  v18 = 2 * v17;
  if (2 * v17 + 2 <= a2)
  {
    v40 = v16;
    v21 = a2 - 1;
    v22 = ~v18;
    if (a2 - 1 + ~v18 < a4)
    {
      v19 = 114;
      v20 = 333;
      goto LABEL_12;
    }
    if (v21 < (v18 | 1uLL))
    {
      v19 = 126;
      v20 = 338;
      goto LABEL_12;
    }
    v25 = v17;
    v26 = &a1[v17];
    *a1 = 0;
    v27 = a1 + 1;
    v39 = v26;
    v28 = a5;
    v29 = v26 + 1;
    if (!EVP_Digest(v28, a6, v26 + 1, 0, v9, 0))
      goto LABEL_33;
    if (v21 - a4 + v22)
      bzero((void *)&v29[v25], v21 - a4 + v22);
    v29[v21 - a4 + ~v25] = 1;
    if (a4)
      memcpy(&v39[a2 - a4 - v25], a3, a4);
    if (RAND_bytes(v27, v25))
    {
      v30 = (unsigned __int8 *)OPENSSL_malloc(v21 - v25);
      v31 = v30;
      if (v30 && PKCS1_MGF1(v30, v21 - v25, v27, v25, v40))
      {
        if (v21 != v25)
        {
          if (v21 - v25 <= 1)
            v32 = 1;
          else
            v32 = v21 - v25;
          v33 = v31;
          v34 = v29;
          do
          {
            v35 = *v33++;
            *v34++ ^= v35;
            --v32;
          }
          while (v32);
        }
        *(_QWORD *)&v36 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v36 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v43 = v36;
        v44 = v36;
        *(_OWORD *)mask = v36;
        v42 = v36;
        if (PKCS1_MGF1(mask, v25, v29, v21 - v25, v40))
        {
          if (v25)
          {
            v37 = mask;
            do
            {
              v38 = *v37++;
              *v27++ ^= v38;
              --v25;
            }
            while (v25);
          }
          v23 = 1;
          goto LABEL_35;
        }
      }
    }
    else
    {
LABEL_33:
      v31 = 0;
    }
    v23 = 0;
LABEL_35:
    OPENSSL_free(v31);
    return v23;
  }
  v19 = 126;
  v20 = 327;
LABEL_12:
  ERR_put_error(4, 0, v19, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v20);
  return 0;
}

uint64_t RSA_padding_check_PKCS1_OAEP_mgf1(void *a1, unint64_t *a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, const void *a6, size_t a7, EVP_MD *md, const EVP_MD *a9)
{
  EVP_MD *v9;
  const EVP_MD *v16;
  unint64_t v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  const unsigned __int8 *v24;
  __int128 v25;
  unsigned __int8 *v26;
  unint64_t v27;
  char v28;
  unsigned __int8 *v29;
  unint64_t v30;
  char v31;
  __int128 v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v42;
  unint64_t v43;
  unint64_t *v44;
  void *v45;
  unint64_t v46;
  unsigned __int8 mda[16];
  __int128 v49;
  __int128 v50;
  __int128 v51;
  unsigned __int8 mask[16];
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;

  v9 = md;
  v56 = *MEMORY[0x1E0C80C00];
  if (!md)
    v9 = (EVP_MD *)EVP_sha1();
  if (a9)
    v16 = a9;
  else
    v16 = v9;
  v17 = EVP_MD_size(v9);
  if (2 * v17 + 2 > a5)
  {
    v18 = 0;
LABEL_8:
    v19 = 133;
    v20 = 484;
LABEL_9:
    ERR_put_error(4, 0, v19, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v20);
LABEL_27:
    OPENSSL_free(v18);
    return 0;
  }
  v21 = v17;
  v46 = a3;
  v22 = ~v17 + a5;
  v18 = (unsigned __int8 *)OPENSSL_malloc(v22);
  if (!v18)
    goto LABEL_27;
  v44 = a2;
  v45 = a1;
  v23 = (char *)(a4 + 1);
  v24 = &a4[v21 + 1];
  *(_QWORD *)&v25 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v54 = v25;
  v55 = v25;
  *(_OWORD *)mask = v25;
  v53 = v25;
  if (!PKCS1_MGF1(mask, v21, v24, v22, v16))
    goto LABEL_27;
  if (v21)
  {
    v26 = mask;
    v27 = v21;
    do
    {
      v28 = *v23++;
      *v26++ ^= v28;
      --v27;
    }
    while (v27);
  }
  if (!PKCS1_MGF1(v18, v22, mask, v21, v16))
    goto LABEL_27;
  if (v22)
  {
    v29 = v18;
    v30 = v22;
    do
    {
      v31 = *v24++;
      *v29++ ^= v31;
      --v30;
    }
    while (v30);
  }
  *(_QWORD *)&v32 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v50 = v32;
  v51 = v32;
  *(_OWORD *)mda = v32;
  v49 = v32;
  if (!EVP_Digest(a6, a7, mda, 0, v9, 0))
    goto LABEL_27;
  v33 = CRYPTO_memcmp((char *)v18, (char *)mda, v21);
  v34 = ~((v33 - 1) & ~(uint64_t)v33 & (*a4 - 1)) >> 63;
  if (v21 >= v22)
  {
    v35 = 0;
    v37 = -1;
    v38 = v44;
  }
  else
  {
    v35 = 0;
    v36 = ~(2 * v21) + a5;
    v37 = -1;
    v38 = v44;
    do
    {
      v39 = (v18[v21] ^ 1) - 1;
      v35 = ~(v37 & (v39 >> 63)) & v35 | v37 & (v39 >> 63) & v21;
      v37 &= ~(v39 >> 63);
      if (v18[v21])
        v40 = v37;
      else
        v40 = 0;
      v34 |= v40;
      ++v21;
      --v36;
    }
    while (v36);
  }
  if (v37 | v34)
    goto LABEL_8;
  v42 = v35 + 1;
  v43 = v22 - v42;
  if (v22 - v42 > v46)
  {
    v19 = 113;
    v20 = 471;
    goto LABEL_9;
  }
  if (v22 != v42)
    memcpy(v45, &v18[v42], v22 - v42);
  *v38 = v43;
  OPENSSL_free(v18);
  return 1;
}

uint64_t RSA_padding_add_PKCS1_PSS_mgf1(const RSA *a1, unsigned __int8 *a2, const void *a3, EVP_MD *md, const EVP_MD *a5, unsigned int a6)
{
  const EVP_MD *v11;
  size_t v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  __int128 v22;
  uint64_t v23;
  unsigned __int8 *v24;
  int v25;
  unsigned __int8 *v26;
  unsigned __int8 *v27;
  char v28;
  uint64_t v29;
  EVP_MD_CTX v31;

  if (a5)
    v11 = a5;
  else
    v11 = md;
  v12 = EVP_MD_size(md);
  if (BN_is_zero(a1->version))
  {
    v13 = 120;
    v14 = 612;
LABEL_38:
    ERR_put_error(4, 0, v13, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v14);
    v29 = 0;
    v21 = 0;
    goto LABEL_39;
  }
  v15 = (BN_num_bits((const BIGNUM *)a1->version) - 1) & 7;
  v16 = RSA_size(a1);
  v17 = v16;
  if (!v15)
  {
    if (!v16)
      RSA_padding_add_PKCS1_PSS_mgf1_cold_1();
    *a2++ = 0;
    v17 = v16 - 1;
  }
  if (v17 < v12 + 2)
  {
    v13 = 114;
    v14 = 625;
    goto LABEL_38;
  }
  v18 = v12;
  if (a6 != -1)
  {
    if (a6 == -2)
    {
      v18 = v17 - v12 - 2;
    }
    else
    {
      if ((a6 & 0x80000000) != 0)
      {
        v13 = 138;
        v14 = 639;
        goto LABEL_38;
      }
      v18 = a6;
    }
  }
  v19 = v17 - v12;
  if (v17 - v12 - 2 < v18)
  {
    v13 = 114;
    v14 = 646;
    goto LABEL_38;
  }
  if (v18)
  {
    v20 = (unsigned __int8 *)OPENSSL_malloc(v18);
    v21 = v20;
    if (!v20 || !RAND_bytes(v20, v18))
      goto LABEL_36;
  }
  else
  {
    v21 = 0;
  }
  *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v31.digest = v22;
  *(_OWORD *)&v31.flags = v22;
  EVP_MD_CTX_init(&v31);
  if (!EVP_DigestInit_ex(&v31, md, 0)
    || !EVP_DigestUpdate(&v31, &kPSSZeroes, 8uLL)
    || !EVP_DigestUpdate(&v31, a3, v12)
    || !EVP_DigestUpdate(&v31, v21, v18))
  {
    EVP_MD_CTX_cleanup(&v31);
LABEL_36:
    v29 = 0;
    goto LABEL_39;
  }
  v23 = v19 - 1;
  v24 = &a2[v19 - 1];
  v25 = EVP_DigestFinal_ex(&v31, v24, 0);
  EVP_MD_CTX_cleanup(&v31);
  if (!v25 || !PKCS1_MGF1(a2, v23, v24, v12, v11))
    goto LABEL_36;
  a2[v17 - (v12 + v18) - 2] ^= 1u;
  if (v18)
  {
    v26 = &a2[v17 + ~(v12 + v18)];
    v27 = v21;
    do
    {
      v28 = *v27++;
      *v26++ ^= v28;
      --v18;
    }
    while (v18);
  }
  if (v15)
    *a2 &= 0xFFu >> (8 - v15);
  a2[v17 - 1] = -68;
  v29 = 1;
LABEL_39:
  OPENSSL_free(v21);
  return v29;
}

uint64_t EVP_marshal_public_key(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t (*v3)(void);

  v2 = *(_QWORD *)(a2 + 16);
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(v2 + 32);
    if (v3)
      return v3();
  }
  ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 147);
  return 0;
}

EVP_PKEY *EVP_parse_private_key(__int128 *a1)
{
  EVP_PKEY *v1;
  EVP_PKEY *v2;
  unsigned int (*v3)(EVP_PKEY *, __int128 *, unint64_t *);
  int v4;
  int v5;
  int v7;
  unint64_t v8[3];
  __int128 v9[2];

  memset(v9, 170, sizeof(v9));
  memset(v8, 170, sizeof(v8));
  if (!CBS_get_asn1(a1, &v9[1], 536870928)
    || !CBS_get_asn1_uint64(&v9[1], v8)
    || v8[0]
    || !CBS_get_asn1(&v9[1], v9, 536870928)
    || !CBS_get_asn1(&v9[1], &v8[1], 4))
  {
    v4 = 102;
    v5 = 164;
LABEL_13:
    ERR_put_error(6, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", v5);
    return 0;
  }
  v7 = -1431655766;
  if (!parse_key_type(v9, &v7))
  {
    v4 = 128;
    v5 = 168;
    goto LABEL_13;
  }
  v1 = EVP_PKEY_new();
  v2 = v1;
  if (!v1 || !EVP_PKEY_set_type((uint64_t)v1, v7))
    goto LABEL_18;
  v3 = (unsigned int (*)(EVP_PKEY *, __int128 *, unint64_t *))*((_QWORD *)v2->pkey.ptr + 6);
  if (!v3)
  {
    ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 183);
LABEL_18:
    EVP_PKEY_free(v2);
    return 0;
  }
  if (!v3(v2, v9, &v8[1]))
    goto LABEL_18;
  return v2;
}

uint64_t EVP_marshal_private_key(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t (*v3)(void);

  v2 = *(_QWORD *)(a2 + 16);
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(v2 + 56);
    if (v3)
      return v3();
  }
  ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 199);
  return 0;
}

EVP_PKEY *__cdecl d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned __int8 **pp, uint64_t length)
{
  EVP_PKEY *v8;
  EVP_PKEY *v9;
  EC_KEY *v10;
  RSA *v11;
  DSA *v12;
  EVP_PKEY *v13;
  __int128 v15;

  if (length < 0)
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 250);
    return 0;
  }
  *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  CBS_init(&v15, (uint64_t)*pp, length);
  v8 = EVP_PKEY_new();
  if (v8)
  {
    v9 = v8;
    switch(type)
    {
      case 6:
        v11 = RSA_parse_private_key(&v15);
        if (v11 && EVP_PKEY_assign_RSA((uint64_t)v9, (uint64_t)v11))
          goto LABEL_20;
        RSA_free(v11);
        break;
      case 116:
        v12 = DSA_parse_private_key(&v15);
        if (v12 && EVP_PKEY_assign_DSA((uint64_t)v9, (uint64_t)v12))
          goto LABEL_20;
        DSA_free(v12);
        break;
      case 408:
        v10 = EC_KEY_parse_private_key(&v15, 0);
        if (v10 && EVP_PKEY_assign_EC_KEY((uint64_t)v9, (uint64_t)v10))
          goto LABEL_20;
        EC_KEY_free(v10);
        break;
      default:
        ERR_put_error(6, 0, 127, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 238);
        break;
    }
    EVP_PKEY_free(v9);
  }
  ERR_clear_error();
  CBS_init(&v15, (uint64_t)*pp, length);
  v13 = EVP_parse_private_key(&v15);
  v9 = v13;
  if (!v13)
    return v9;
  if (v13->save_type != type)
  {
    ERR_put_error(6, 0, 103, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 267);
    EVP_PKEY_free(v9);
    return 0;
  }
LABEL_20:
  if (a)
  {
    EVP_PKEY_free(*a);
    *a = v9;
  }
  *pp = (const unsigned __int8 *)CBS_data((uint64_t)&v15);
  return v9;
}

DSA *dsa_pub_decode(uint64_t a1, __int128 *a2, __int128 *a3)
{
  DSA *v6;
  int v7;
  DSA *result;
  BIGNUM *v9;

  if (CBS_len((uint64_t)a2))
  {
    v6 = DSA_parse_parameters(a2);
    if (!v6 || CBS_len((uint64_t)a2))
    {
      v7 = 81;
LABEL_10:
      ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_dsa_asn1.c", v7);
      goto LABEL_11;
    }
  }
  else
  {
    result = DSA_new();
    v6 = result;
    if (!result)
      return result;
  }
  v9 = BN_new();
  v6->q = v9;
  if (v9)
  {
    if (BN_parse_asn1_unsigned(a3, v9) && !CBS_len((uint64_t)a3))
    {
      EVP_PKEY_assign_DSA(a1, (uint64_t)v6);
      return (DSA *)1;
    }
    v7 = 93;
    goto LABEL_10;
  }
LABEL_11:
  DSA_free(v6);
  return 0;
}

uint64_t dsa_pub_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  _BOOL4 v4;
  __int128 v5;
  _OWORD v7[3];
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];

  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(v3 + 8) && *(_QWORD *)(v3 + 16) && *(_QWORD *)(v3 + 24) != 0;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[1] = v5;
  v10[2] = v5;
  v10[0] = v5;
  v9[1] = v5;
  v9[2] = v5;
  v8[2] = v5;
  v9[0] = v5;
  v8[0] = v5;
  v8[1] = v5;
  v7[1] = v5;
  v7[2] = v5;
  v7[0] = v5;
  if (CBB_add_asn1(a1, (uint64_t)v10, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v8, 6u)
    && CBB_add_bytes((uint64_t)v8, &unk_1E686DF2C, 7uLL)
    && (!v4 || DSA_marshal_parameters((uint64_t *)v9, (const BIGNUM **)v3))
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v7, 3u)
    && CBB_add_u8((uint64_t)v7, 0)
    && BN_marshal_asn1((uint64_t *)v7, *(const BIGNUM **)(v3 + 32))
    && CBB_flush(a1))
  {
    return 1;
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_dsa_asn1.c", 121);
  return 0;
}

BOOL dsa_pub_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  const BIGNUM *v3;
  const BIGNUM *v4;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = (const BIGNUM *)DSA_get0_pub_key(*(_QWORD *)(a2 + 8));
  v4 = (const BIGNUM *)DSA_get0_pub_key(v2);
  return BN_cmp(v3, v4) == 0;
}

uint64_t dsa_priv_decode(uint64_t a1, __int128 *a2, __int128 *a3)
{
  DSA *v6;
  int v7;
  BN_CTX *v8;
  BIGNUM *v10;
  BIGNUM *v11;

  v6 = DSA_parse_parameters(a2);
  if (!v6 || CBS_len((uint64_t)a2))
  {
    v7 = 135;
LABEL_4:
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_dsa_asn1.c", v7);
LABEL_5:
    v8 = 0;
LABEL_6:
    BN_CTX_free(v8);
    DSA_free(v6);
    return 0;
  }
  v10 = BN_new();
  v6->g = v10;
  if (!v10)
    goto LABEL_5;
  if (!BN_parse_asn1_unsigned(a3, v10) || CBS_len((uint64_t)a3))
  {
    v7 = 145;
    goto LABEL_4;
  }
  if (!dsa_check_key((uint64_t *)&v6->pad))
  {
    v7 = 153;
    goto LABEL_4;
  }
  v8 = BN_CTX_new();
  v11 = BN_new();
  v6->q = v11;
  if (!v8 || !v11 || !BN_mod_exp_mont_consttime(v11, v6->p, v6->g, (const BIGNUM *)v6->version, v8, 0))
    goto LABEL_6;
  BN_CTX_free(v8);
  EVP_PKEY_assign_DSA(a1, (uint64_t)v6);
  return 1;
}

uint64_t dsa_priv_encode(uint64_t *a1, uint64_t a2)
{
  const BIGNUM **v2;
  __int128 v4;
  int v6;
  int v7;
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];
  _OWORD v11[3];

  v2 = *(const BIGNUM ***)(a2 + 8);
  if (v2 && v2[5])
  {
    *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v11[1] = v4;
    v11[2] = v4;
    v11[0] = v4;
    v10[1] = v4;
    v10[2] = v4;
    v9[2] = v4;
    v10[0] = v4;
    v9[0] = v4;
    v9[1] = v4;
    v8[1] = v4;
    v8[2] = v4;
    v8[0] = v4;
    if (CBB_add_asn1(a1, (uint64_t)v11, 0x20000010u)
      && CBB_add_asn1_uint64((uint64_t *)v11, 0)
      && CBB_add_asn1((uint64_t *)v11, (uint64_t)v10, 0x20000010u)
      && CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 6u)
      && CBB_add_bytes((uint64_t)v9, &unk_1E686DF2C, 7uLL)
      && DSA_marshal_parameters((uint64_t *)v10, v2)
      && CBB_add_asn1((uint64_t *)v11, (uint64_t)v8, 4u)
      && BN_marshal_asn1((uint64_t *)v8, v2[5])
      && CBB_flush(a1))
    {
      return 1;
    }
    v6 = 105;
    v7 = 194;
  }
  else
  {
    v6 = 118;
    v7 = 179;
  }
  ERR_put_error(6, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_dsa_asn1.c", v7);
  return 0;
}

uint64_t int_dsa_size(uint64_t a1)
{
  return DSA_size(*(const DSA **)(a1 + 8));
}

uint64_t dsa_bits(uint64_t a1)
{
  const BIGNUM *v1;

  v1 = (const BIGNUM *)RSA_get0_n(*(_QWORD *)(a1 + 8));
  return BN_num_bits(v1);
}

BOOL dsa_missing_parameters(uint64_t a1)
{
  const EC_KEY *v1;

  v1 = *(const EC_KEY **)(a1 + 8);
  return !RSA_get0_n((uint64_t)v1) || !RSA_get0_e(v1) || DSA_get0_g((uint64_t)v1) == 0;
}

uint64_t dsa_copy_parameters(uint64_t a1, uint64_t a2)
{
  BIGNUM **v2;
  BIGNUM **v3;

  v2 = *(BIGNUM ***)(a1 + 8);
  v3 = *(BIGNUM ***)(a2 + 8);
  if (dup_bn_into(v2 + 1, v3[1]) && dup_bn_into(v2 + 2, v3[2]))
    return dup_bn_into(v2 + 3, v3[3]);
  else
    return 0;
}

BOOL dsa_cmp_parameters(uint64_t a1, uint64_t a2)
{
  const EC_KEY *v2;
  const EC_KEY *v3;
  const BIGNUM *v4;
  const BIGNUM *v5;
  const BIGNUM *v6;
  const BIGNUM *v7;
  const BIGNUM *v9;
  const BIGNUM *v10;

  v2 = *(const EC_KEY **)(a1 + 8);
  v3 = *(const EC_KEY **)(a2 + 8);
  v4 = (const BIGNUM *)RSA_get0_n((uint64_t)v2);
  v5 = (const BIGNUM *)RSA_get0_n((uint64_t)v3);
  if (BN_cmp(v4, v5))
    return 0;
  v6 = RSA_get0_e(v2);
  v7 = RSA_get0_e(v3);
  if (BN_cmp(v6, v7))
    return 0;
  v9 = (const BIGNUM *)DSA_get0_g((uint64_t)v2);
  v10 = (const BIGNUM *)DSA_get0_g((uint64_t)v3);
  return BN_cmp(v9, v10) == 0;
}

void int_dsa_free(uint64_t a1)
{
  DSA_free(*(DSA **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
}

uint64_t dup_bn_into(BIGNUM **a1, BIGNUM *a)
{
  uint64_t result;
  uint64_t v4;

  result = (uint64_t)BN_dup(a);
  if (result)
  {
    v4 = result;
    BN_free(*a1);
    *a1 = (BIGNUM *)v4;
    return 1;
  }
  return result;
}

const EVP_CIPHER *EVP_aes_128_cbc(void)
{
  return (const EVP_CIPHER *)&aes_128_cbc;
}

const EVP_CIPHER *EVP_aes_256_cbc(void)
{
  return (const EVP_CIPHER *)&aes_256_cbc;
}

void *EVP_aead_aes_128_gcm()
{
  return &aead_aes_128_gcm;
}

void *EVP_aead_aes_256_gcm()
{
  return &aead_aes_256_gcm;
}

uint64_t aes_init_key(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t result;
  NSObject *v6;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;

  v4 = *(_DWORD *)(*(_QWORD *)a1 + 20) & 0x3F;
  switch(v4)
  {
    case 1:
      if (!g_boringssl_log)
        goto LABEL_25;
      result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        aes_init_key_cold_3();
        goto LABEL_25;
      }
      break;
    case 2:
      if ((*(_DWORD *)(a1 + 24) - 65) < 0xFFFFFFC0)
        goto LABEL_25;
      if (a4)
        v8 = (_QWORD *)ccaes_cbc_encrypt_mode();
      else
        v8 = (_QWORD *)ccaes_cbc_decrypt_mode();
      v9 = v8;
      result = (uint64_t)malloc_type_malloc(((v8[1] + ((*v8 + 15) & 0xFFFFFFFFFFFFFFF0) + 15) & 0xFFFFFFFFFFFFFFF0) + 16, 0xD1A133F7uLL);
      if (result)
      {
        v10 = (void *)result;
        *(_QWORD *)result = v9;
        if (cccbc_init() || cccbc_set_iv())
        {
          free(v10);
          goto LABEL_25;
        }
        *(_QWORD *)(a1 + 8) = v10;
        result = 1;
      }
      break;
    case 3:
      if (!g_boringssl_log)
        goto LABEL_25;
      result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        aes_init_key_cold_4();
        goto LABEL_25;
      }
      break;
    case 4:
      if (!g_boringssl_log)
        goto LABEL_25;
      result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        aes_init_key_cold_5();
        goto LABEL_25;
      }
      break;
    case 5:
      if (!g_boringssl_log)
        goto LABEL_25;
      result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        aes_init_key_cold_2();
        goto LABEL_25;
      }
      break;
    default:
      v6 = g_boringssl_log;
      if (g_boringssl_log)
      {
        result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
          return result;
        aes_init_key_cold_1(v4, v6);
      }
LABEL_25:
      result = 0;
      break;
  }
  return result;
}

uint64_t aes_cipher(_QWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5;
  _OWORD *v6;
  int v7;

  if ((*(_BYTE *)(*a1 + 20) & 2) == 0)
    return 0;
  v5 = a1[1];
  if (!v5 || !*(_QWORD *)v5)
    return 0xFFFFFFFFLL;
  if (a4 && (!a2 || !a3))
    aes_cipher_cold_1();
  if (a4 % *(_QWORD *)(*(_QWORD *)v5 + 8))
    return 0xFFFFFFFFLL;
  v6 = (_OWORD *)((char *)a1 + 52);
  v7 = cccbc_set_iv();
  if (cccbc_update() | v7)
    return 0xFFFFFFFFLL;
  *v6 = *(_OWORD *)(v5 + ((**(_QWORD **)v5 + 15) & 0xFFFFFFFFFFFFFFF0) + 16);
  return 1;
}

void aes_cleanup(_QWORD *a1)
{
  void *v2;

  if ((*(_BYTE *)(*a1 + 20) & 2) != 0)
  {
    v2 = (void *)a1[1];
    if (v2)
    {
      cc_clear();
      free(v2);
    }
  }
  a1[1] = 0;
}

uint64_t pkey_ec_keygen(uint64_t a1, uint64_t a2)
{
  const EC_GROUP *v3;
  uint64_t v4;
  EC_KEY *v5;
  EC_KEY *v6;

  v3 = *(const EC_GROUP **)(*(_QWORD *)(a1 + 40) + 8);
  if (!v3)
  {
    v4 = *(_QWORD *)(a1 + 16);
    if (!v4)
    {
      ERR_put_error(6, 0, 124, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec.c", 218);
      return 0;
    }
    v3 = EC_KEY_get0_group(*(const EC_KEY **)(v4 + 8));
  }
  v5 = EC_KEY_new();
  v6 = v5;
  if (v5 && EC_KEY_set_group(v5, v3) && EC_KEY_generate_key(v6))
  {
    EVP_PKEY_assign_EC_KEY(a2, (uint64_t)v6);
    return 1;
  }
  EC_KEY_free(v6);
  return 0;
}

uint64_t pkey_ec_sign(uint64_t a1, unsigned __int8 *a2, unint64_t *a3, const unsigned __int8 *a4, int a5)
{
  uint64_t v6;
  EC_KEY *v7;
  unint64_t v11;
  uint64_t result;
  unsigned int siglen;

  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(EC_KEY **)(v6 + 8);
  if (!a2)
  {
    *a3 = ECDSA_size(*(const EC_KEY **)(v6 + 8));
    return 1;
  }
  v11 = *a3;
  if (v11 < ECDSA_size(*(const EC_KEY **)(v6 + 8)))
  {
    ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec.c", 125);
    return 0;
  }
  siglen = -1431655766;
  result = ECDSA_sign(0, a4, a5, a2, &siglen, v7);
  if ((_DWORD)result)
  {
    *a3 = siglen;
    return 1;
  }
  return result;
}

uint64_t pkey_ec_derive(uint64_t a1, void *a2, size_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  EC_KEY *v7;
  const EC_POINT *v8;
  unsigned int v9;
  size_t v10;
  const EC_GROUP *v12;

  v3 = *(_QWORD *)(a1 + 16);
  if (!v3 || (v4 = *(_QWORD *)(a1 + 24)) == 0)
  {
    ERR_put_error(6, 0, 117, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec.c", 146);
    return 0;
  }
  v7 = *(EC_KEY **)(v3 + 8);
  if (!a2)
  {
    v12 = EC_KEY_get0_group(*(const EC_KEY **)(v3 + 8));
    v10 = (EC_GROUP_get_degree(v12) + 7) >> 3;
    goto LABEL_9;
  }
  v8 = EC_KEY_get0_public_key(*(const EC_KEY **)(v4 + 8));
  v9 = ECDH_compute_key(a2, *a3, v8, v7, 0);
  if ((v9 & 0x80000000) != 0)
    return 0;
  v10 = v9;
LABEL_9:
  *a3 = v10;
  return 1;
}

uint64_t pkey_ec_paramgen(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  EC_KEY *v4;
  EC_KEY *v5;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(v2 + 8))
  {
    v4 = EC_KEY_new();
    v5 = v4;
    if (v4 && EC_KEY_set_group(v4, *(const EC_GROUP **)(v2 + 8)))
    {
      EVP_PKEY_assign_EC_KEY(a2, (uint64_t)v5);
      return 1;
    }
    EC_KEY_free(v5);
  }
  else
  {
    ERR_put_error(6, 0, 124, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec.c", 237);
  }
  return 0;
}

double EVP_MD_CTX_new()
{
  _OWORD *v0;
  double result;

  v0 = OPENSSL_malloc(0x20uLL);
  if (v0)
  {
    result = 0.0;
    *v0 = 0u;
    v0[1] = 0u;
  }
  return result;
}

void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx)
{
  if (ctx)
  {
    EVP_MD_CTX_cleanup(ctx);
    OPENSSL_free(ctx);
  }
}

double EVP_MD_CTX_move(uint64_t a1, _OWORD *a2)
{
  __int128 v4;
  double result;

  EVP_MD_CTX_cleanup((EVP_MD_CTX *)a1);
  v4 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v4;
  result = 0.0;
  *a2 = 0u;
  a2[1] = 0u;
  return result;
}

int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned __int8 *md, unsigned int *s)
{
  EVP_DigestFinal_ex(ctx, md, s);
  EVP_MD_CTX_cleanup(ctx);
  return 1;
}

uint64_t eckey_pub_encode(uint64_t *a1, uint64_t a2)
{
  const EC_KEY *v3;
  EC_GROUP *v4;
  EC_POINT *v5;
  __int128 v6;
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];
  _OWORD v11[3];

  v3 = *(const EC_KEY **)(a2 + 8);
  v4 = EC_KEY_get0_group(v3);
  v5 = EC_KEY_get0_public_key(v3);
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = v6;
  v11[2] = v6;
  v11[0] = v6;
  v10[1] = v6;
  v10[2] = v6;
  v9[2] = v6;
  v10[0] = v6;
  v9[0] = v6;
  v9[1] = v6;
  v8[1] = v6;
  v8[2] = v6;
  v8[0] = v6;
  if (CBB_add_asn1(a1, (uint64_t)v11, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v11, (uint64_t)v10, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 6u)
    && CBB_add_bytes((uint64_t)v9, &unk_1E686DFD4, 7uLL)
    && EC_KEY_marshal_curve_name((uint64_t *)v10, v4)
    && CBB_add_asn1((uint64_t *)v11, (uint64_t)v8, 3u)
    && CBB_add_u8((uint64_t)v8, 0)
    && EC_POINT_point2cbb((uint64_t)v8, v4, v5, POINT_CONVERSION_UNCOMPRESSED, 0)
    && CBB_flush(a1))
  {
    return 1;
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 85);
  return 0;
}

uint64_t eckey_pub_cmp(uint64_t a1, uint64_t a2)
{
  const EC_KEY *v2;
  const EC_KEY *v3;
  const EC_GROUP *v4;
  const EC_POINT *v5;
  const EC_POINT *v6;
  int v7;
  unsigned int v8;

  v2 = *(const EC_KEY **)(a1 + 8);
  v3 = *(const EC_KEY **)(a2 + 8);
  v4 = EC_KEY_get0_group(v3);
  v5 = EC_KEY_get0_public_key(v2);
  v6 = EC_KEY_get0_public_key(v3);
  v7 = EC_POINT_cmp(v4, v5, v6, 0);
  if (v7 == 1)
    v8 = 0;
  else
    v8 = -2;
  if (v7)
    return v8;
  else
    return 1;
}

uint64_t eckey_priv_decode(uint64_t a1, __int128 *a2, __int128 *a3)
{
  EC_GROUP *v6;
  EC_KEY *v8;

  v6 = EC_KEY_parse_parameters(a2);
  if (!v6 || CBS_len((uint64_t)a2))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 140);
    EC_GROUP_free(v6);
    return 0;
  }
  v8 = EC_KEY_parse_private_key(a3, v6);
  EC_GROUP_free(v6);
  if (!v8 || CBS_len((uint64_t)a3))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 148);
    EC_KEY_free(v8);
    return 0;
  }
  EVP_PKEY_assign_EC_KEY(a1, (uint64_t)v8);
  return 1;
}

uint64_t eckey_priv_encode(uint64_t *a1, uint64_t a2)
{
  const EC_KEY *v3;
  char enc_flags;
  __int128 v5;
  EC_GROUP *v6;
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];
  _OWORD v11[3];

  v3 = *(const EC_KEY **)(a2 + 8);
  enc_flags = EC_KEY_get_enc_flags(v3);
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = v5;
  v11[2] = v5;
  v11[0] = v5;
  v10[1] = v5;
  v10[2] = v5;
  v9[2] = v5;
  v10[0] = v5;
  v9[0] = v5;
  v9[1] = v5;
  v8[1] = v5;
  v8[2] = v5;
  v8[0] = v5;
  if (CBB_add_asn1(a1, (uint64_t)v11, 0x20000010u))
  {
    if (CBB_add_asn1_uint64((uint64_t *)v11, 0))
    {
      if (CBB_add_asn1((uint64_t *)v11, (uint64_t)v10, 0x20000010u))
      {
        if (CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 6u))
        {
          if (CBB_add_bytes((uint64_t)v9, &unk_1E686DFD4, 7uLL))
          {
            v6 = EC_KEY_get0_group(v3);
            if (EC_KEY_marshal_curve_name((uint64_t *)v10, v6))
            {
              if (CBB_add_asn1((uint64_t *)v11, (uint64_t)v8, 4u)
                && EC_KEY_marshal_private_key((uint64_t *)v8, (uint64_t)v3, enc_flags | 1u)
                && CBB_flush(a1))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 177);
  return 0;
}

uint64_t eckey_set1_tls_encodedpoint(uint64_t a1, const unsigned __int8 *a2, size_t a3)
{
  EC_KEY *v3;

  v3 = *(EC_KEY **)(a1 + 8);
  if (v3)
    return EC_KEY_oct2key(v3, a2, a3, 0);
  ERR_put_error(6, 0, 120, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 188);
  return 0;
}

unsigned __int8 *eckey_get1_tls_encodedpoint(uint64_t a1, unsigned __int8 **a2, uint64_t a3, uint64_t a4, uint64_t a5, BN_CTX *a6)
{
  const EC_GROUP **v6;

  v6 = *(const EC_GROUP ***)(a1 + 8);
  if (v6)
    return EC_KEY_key2buf(v6, POINT_CONVERSION_UNCOMPRESSED, a2, 0, a5, a6);
  ERR_put_error(6, 0, 120, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 199);
  return 0;
}

uint64_t eckey_opaque(uint64_t a1)
{
  return EC_KEY_is_opaque(*(_QWORD *)(a1 + 8));
}

uint64_t int_ec_size(uint64_t a1)
{
  return ECDSA_size(*(const EC_KEY **)(a1 + 8));
}

uint64_t ec_bits(uint64_t a1)
{
  const EC_GROUP *v1;
  const BIGNUM *v2;

  v1 = EC_KEY_get0_group(*(const EC_KEY **)(a1 + 8));
  if (v1)
  {
    v2 = (const BIGNUM *)EC_GROUP_get0_order((uint64_t)v1);
    return BN_num_bits(v2);
  }
  else
  {
    ERR_clear_error();
    return 0;
  }
}

BOOL ec_missing_parameters(uint64_t a1)
{
  const EC_KEY *v1;

  v1 = *(const EC_KEY **)(a1 + 8);
  return !v1 || EC_KEY_get0_group(v1) == 0;
}

uint64_t ec_copy_parameters(uint64_t a1, uint64_t a2)
{
  const EC_KEY *v3;
  const EC_GROUP *v4;
  const EC_GROUP *v5;
  EC_KEY *v6;
  int v8;
  int v9;

  v3 = *(const EC_KEY **)(a2 + 8);
  if (!v3)
  {
    v8 = 120;
    v9 = 229;
LABEL_8:
    ERR_put_error(6, 0, v8, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", v9);
    return 0;
  }
  v4 = EC_KEY_get0_group(v3);
  if (!v4)
  {
    v8 = 118;
    v9 = 234;
    goto LABEL_8;
  }
  v5 = v4;
  v6 = *(EC_KEY **)(a1 + 8);
  if (v6)
    return EC_KEY_set_group(v6, v5);
  v6 = EC_KEY_new();
  *(_QWORD *)(a1 + 8) = v6;
  if (v6)
    return EC_KEY_set_group(v6, v5);
  return 0;
}

uint64_t ec_cmp_parameters(uint64_t a1, uint64_t a2)
{
  const EC_KEY *v2;
  const EC_KEY *v3;
  BOOL v4;
  const EC_GROUP *v5;
  const EC_GROUP *v6;

  v2 = *(const EC_KEY **)(a1 + 8);
  v3 = *(const EC_KEY **)(a2 + 8);
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
    return 4294967294;
  v5 = EC_KEY_get0_group(v2);
  v6 = EC_KEY_get0_group(v3);
  if (!v5 || v6 == 0)
    return 4294967294;
  else
    return EC_GROUP_cmp(v5, v6, 0) == 0;
}

RSA *pkey_rsa_keygen(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  RSA *result;
  RSA *v5;

  v3 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(v3 + 8)
    || (result = (RSA *)BN_new(), (*(_QWORD *)(v3 + 8) = result) != 0)
    && (result = (RSA *)BN_set_word((BIGNUM *)result, 0x10001uLL), (_DWORD)result))
  {
    result = RSA_new();
    if (result)
    {
      v5 = result;
      if (RSA_generate_key_ex(result, *(_DWORD *)v3, *(BIGNUM **)(v3 + 8), 0))
      {
        EVP_PKEY_assign_RSA(a2, (uint64_t)v5);
        return (RSA *)1;
      }
      else
      {
        RSA_free(v5);
        return 0;
      }
    }
  }
  return result;
}

uint64_t pkey_rsa_sign(uint64_t a1, unsigned __int8 *a2, _QWORD *a3, const unsigned __int8 *a4, unsigned int a5)
{
  uint64_t v9;
  uint64_t v10;
  RSA *v11;
  int v12;
  uint64_t v13;
  uint64_t result;
  const EVP_MD *v15;
  int v16;
  int v17;
  unsigned int siglen;

  v9 = *(_QWORD *)(a1 + 40);
  v10 = *(_QWORD *)(a1 + 16);
  v11 = *(RSA **)(v10 + 8);
  v12 = EVP_PKEY_size((EVP_PKEY *)v10);
  v13 = v12;
  if (!a2)
    goto LABEL_10;
  if (*a3 < (unint64_t)v12)
  {
    ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa.c", 183);
    return 0;
  }
  v15 = *(const EVP_MD **)(v9 + 24);
  if (!v15)
    return RSA_sign_raw();
  siglen = -1431655766;
  v16 = *(_DWORD *)(v9 + 16);
  if (v16 == 6)
    return RSA_sign_pss_mgf1();
  if (v16 != 1)
    return 0;
  v17 = EVP_MD_type(v15);
  result = RSA_sign(v17, a4, a5, a2, &siglen, v11);
  if ((_DWORD)result)
  {
    v13 = siglen;
LABEL_10:
    *a3 = v13;
    return 1;
  }
  return result;
}

uint64_t pkey_rsa_verify_recover(uint64_t a1, unsigned __int8 *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t result;
  const EVP_MD *v16;
  int v17;
  size_t v18;
  int v19;
  BOOL v20;
  unint64_t v21;
  _DWORD v22[5];

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16);
  v12 = *(_QWORD *)(v11 + 8);
  v13 = EVP_PKEY_size((EVP_PKEY *)v11);
  v14 = v13;
  if (!a2)
  {
    *a3 = v13;
    return 1;
  }
  if (*a3 < (unint64_t)v13)
  {
    ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa.c", 255);
    return 0;
  }
  v16 = *(const EVP_MD **)(v10 + 24);
  v17 = *(_DWORD *)(v10 + 16);
  if (!v16)
    return RSA_verify_raw(v12, a3, a2, *a3, a4, a5, v17);
  if (v17 != 1)
    return 0;
  v18 = EVP_MD_size(v16);
  memset(v22, 170, sizeof(v22));
  result = setup_tbuf(v10, a1);
  if ((_DWORD)result)
  {
    v19 = EVP_MD_type(*(const EVP_MD **)(v10 + 24));
    result = RSA_add_pkcs1_prefix(&v22[3], (size_t *)&v22[1], v22, v19, &pkey_rsa_verify_recover_kDummyHash, v18);
    if ((_DWORD)result)
    {
      v21 = 0xAAAAAAAAAAAAAAAALL;
      v20 = !RSA_verify_raw(v12, &v21, *(unsigned __int8 **)(v10 + 48), v14, a4, a5, 1)
         || v21 != *(_QWORD *)&v22[1]
         || CRYPTO_memcmp(*(char **)(v10 + 48), *(char **)&v22[3], v21 - v18);
      if (v22[0])
        OPENSSL_free(*(_QWORD **)&v22[3]);
      if (v20)
        return 0;
      if (v18)
        memcpy(a2, (const void *)(*(_QWORD *)(v10 + 48) + v21 - v18), v18);
      *a3 = v18;
      return 1;
    }
  }
  return result;
}

uint64_t pkey_rsa_encrypt(uint64_t a1, uint64_t a2, uint64_t *a3, const void *a4, size_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  uint64_t result;
  int v16;

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16);
  v12 = *(_QWORD *)(v11 + 8);
  v13 = EVP_PKEY_size((EVP_PKEY *)v11);
  v14 = v13;
  if (a2)
  {
    if (*a3 >= (unint64_t)v13)
    {
      v16 = *(_DWORD *)(v10 + 16);
      if (v16 == 4)
      {
        result = setup_tbuf(v10, a1);
        if ((_DWORD)result)
        {
          result = RSA_padding_add_PKCS1_OAEP_mgf1(*(_BYTE **)(v10 + 48), v14, a4, a5, *(const void **)(v10 + 56), *(_QWORD *)(v10 + 64), *(EVP_MD **)(v10 + 24), *(EVP_MD **)(v10 + 32));
          if ((_DWORD)result)
            return RSA_encrypt(v12, a3, a2, *a3, *(_QWORD *)(v10 + 48), v14, 3);
        }
      }
      else
      {
        return RSA_encrypt(v12, a3, a2, *a3, (uint64_t)a4, a5, v16);
      }
    }
    else
    {
      ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa.c", 319);
      return 0;
    }
  }
  else
  {
    *a3 = v13;
    return 1;
  }
  return result;
}

uint64_t pkey_rsa_decrypt(uint64_t a1, void *a2, unint64_t *a3)
{
  uint64_t v6;
  int v7;
  unint64_t v8;
  uint64_t result;

  v6 = *(_QWORD *)(a1 + 40);
  v7 = EVP_PKEY_size(*(EVP_PKEY **)(a1 + 16));
  v8 = v7;
  if (a2)
  {
    if (*a3 >= v7)
    {
      if (*(_DWORD *)(v6 + 16) == 4)
      {
        result = setup_tbuf(v6, a1);
        if ((_DWORD)result)
        {
          result = RSA_decrypt();
          if ((_DWORD)result)
            return RSA_padding_check_PKCS1_OAEP_mgf1(a2, a3, v8, *(unsigned __int8 **)(v6 + 48), 0xAAAAAAAAAAAAAAAALL, *(const void **)(v6 + 56), *(_QWORD *)(v6 + 64), *(EVP_MD **)(v6 + 24), *(const EVP_MD **)(v6 + 32)) != 0;
        }
      }
      else
      {
        return RSA_decrypt();
      }
    }
    else
    {
      ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa.c", 351);
      return 0;
    }
  }
  else
  {
    *a3 = v7;
    return 1;
  }
  return result;
}

uint64_t EVP_PKEY_CTX_set_rsa_mgf1_md(uint64_t *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, 248);
}

BOOL setup_tbuf(uint64_t a1, uint64_t a2)
{
  int v4;
  _QWORD *v5;

  if (*(_QWORD *)(a1 + 48))
    return 1;
  v4 = EVP_PKEY_size(*(EVP_PKEY **)(a2 + 16));
  v5 = OPENSSL_malloc(v4);
  *(_QWORD *)(a1 + 48) = v5;
  return v5 != 0;
}

uint64_t bssl::tls13_client_handshake_int_state(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  return (4 * *((_DWORD *)this + 6)) | 0x2B291400u;
}

uint64_t bssl::close_early_data(uint64_t a1, int a2)
{
  int v2;
  uint64_t v4;
  uint64_t result;
  _BOOL8 v6;
  uint64_t (*v7)(uint64_t, _QWORD, bssl::SSLAEADContext **, _QWORD, _QWORD);
  char v8;
  bssl::SSLAEADContext *v9;
  bssl::SSLAEADContext *v10;

  v2 = *(_DWORD *)(a1 + 1600);
  if ((v2 & 0x800) == 0)
    bssl::close_early_data();
  v4 = *(_QWORD *)a1;
  *(_DWORD *)(a1 + 1600) = v2 & 0xFFFFBFFF;
  if (*(_QWORD *)(v4 + 168))
    goto LABEL_3;
  if (!a2)
  {
    v10 = (bssl::SSLAEADContext *)0xAAAAAAAAAAAAAAAALL;
    v6 = SSL_is_dtls((unsigned __int8 **)v4) != 0;
    bssl::SSLAEADContext::CreateNullCipher((bssl::SSLAEADContext *)v6, &v10);
    if (!v10
      || (v7 = *(uint64_t (**)(uint64_t, _QWORD, bssl::SSLAEADContext **, _QWORD, _QWORD))(*(_QWORD *)v4 + 144),
          v9 = v10,
          v10 = 0,
          v8 = v7(v4, 0, &v9, 0, 0),
          std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v9, 0),
          (v8 & 1) == 0))
    {
      std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v10, 0);
      return 0;
    }
    bssl::SSLAEADContext::SetVersionIfNullCipher(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 272), *(_WORD *)(v4 + 16));
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v10, 0);
    goto LABEL_3;
  }
  if (a2 != 2)
    bssl::close_early_data();
  result = bssl::tls13_set_traffic_key(v4, (const ssl_session_st *)2, 1, *(bssl **)(a1 + 1536), (const void *)(a1 + 136), *(_QWORD *)(a1 + 32));
  if ((_DWORD)result)
  {
LABEL_3:
    if (*(_DWORD *)(*(_QWORD *)(v4 + 48) + 204) != a2)
      bssl::close_early_data();
    return 1;
  }
  return result;
}

void sub_1B4FCCAF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t rsa_pub_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  __int128 v4;
  _OWORD v6[3];
  _OWORD v7[3];
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];

  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[1] = v4;
  v10[2] = v4;
  v9[2] = v4;
  v10[0] = v4;
  v9[0] = v4;
  v9[1] = v4;
  v8[1] = v4;
  v8[2] = v4;
  v7[2] = v4;
  v8[0] = v4;
  v7[0] = v4;
  v7[1] = v4;
  v6[1] = v4;
  v6[2] = v4;
  v6[0] = v4;
  if (CBB_add_asn1(a1, (uint64_t)v10, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v8, 6u)
    && CBB_add_bytes((uint64_t)v8, &unk_1E686E3AC, 9uLL)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v7, 5u)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v6, 3u)
    && CBB_add_u8((uint64_t)v6, 0)
    && RSA_marshal_public_key((uint64_t *)v6, v3)
    && CBB_flush(a1))
  {
    return 1;
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 82);
  return 0;
}

BOOL rsa_pub_cmp(uint64_t a1, uint64_t a2)
{
  const EC_KEY *v2;
  const EC_KEY *v3;
  const BIGNUM *v4;
  const BIGNUM *v5;
  const BIGNUM *v7;
  const BIGNUM *v8;

  v2 = *(const EC_KEY **)(a1 + 8);
  v3 = *(const EC_KEY **)(a2 + 8);
  v4 = (const BIGNUM *)RSA_get0_n((uint64_t)v3);
  v5 = (const BIGNUM *)RSA_get0_n((uint64_t)v2);
  if (BN_cmp(v4, v5))
    return 0;
  v7 = RSA_get0_e(v3);
  v8 = RSA_get0_e(v2);
  return BN_cmp(v7, v8) == 0;
}

uint64_t rsa_priv_decode(uint64_t a1, __int128 *a2, __int128 *a3)
{
  RSA *v7;
  _QWORD v8[2];

  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_asn1(a2, v8, 5) || CBS_len((uint64_t)v8) || CBS_len((uint64_t)a2))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 144);
  }
  else
  {
    v7 = RSA_parse_private_key(a3);
    if (v7 && !CBS_len((uint64_t)a3))
    {
      EVP_PKEY_assign_RSA(a1, (uint64_t)v7);
      return 1;
    }
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 150);
    RSA_free(v7);
  }
  return 0;
}

uint64_t rsa_priv_encode(uint64_t *a1, uint64_t a2)
{
  const BIGNUM **v3;
  __int128 v4;
  _OWORD v6[3];
  _OWORD v7[3];
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];

  v3 = *(const BIGNUM ***)(a2 + 8);
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[1] = v4;
  v10[2] = v4;
  v9[2] = v4;
  v10[0] = v4;
  v9[0] = v4;
  v9[1] = v4;
  v8[1] = v4;
  v8[2] = v4;
  v7[2] = v4;
  v8[0] = v4;
  v7[0] = v4;
  v7[1] = v4;
  v6[1] = v4;
  v6[2] = v4;
  v6[0] = v4;
  if (CBB_add_asn1(a1, (uint64_t)v10, 0x20000010u)
    && CBB_add_asn1_uint64((uint64_t *)v10, 0)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v8, 6u)
    && CBB_add_bytes((uint64_t)v8, &unk_1E686E3AC, 9uLL)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v7, 5u)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v6, 4u)
    && RSA_marshal_private_key((uint64_t *)v6, v3)
    && CBB_flush(a1))
  {
    return 1;
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 131);
  return 0;
}

uint64_t rsa_opaque()
{
  return RSA_is_opaque();
}

uint64_t int_rsa_size(uint64_t a1)
{
  return RSA_size(*(const RSA **)(a1 + 8));
}

uint64_t rsa_bits(uint64_t a1)
{
  return RSA_bits(*(_QWORD *)(a1 + 8));
}

BOOL PKCS5_PBKDF2_HMAC(const void *a1, int a2, const unsigned __int8 *a3, size_t a4, unsigned int a5, EVP_MD *md, size_t a7, char *a8)
{
  size_t v16;
  __int128 v17;
  int v18;
  unsigned int v19;
  __int128 v20;
  size_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unsigned __int8 *v30;
  _BYTE *v31;
  size_t v32;
  char v33;
  _BOOL8 v34;
  unsigned __int8 data[4];
  HMAC_CTX ctx;

  *(_QWORD *)&ctx.key[76] = *MEMORY[0x1E0C80C00];
  v16 = EVP_MD_size(md);
  ctx.o_ctx.md_data = (void *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.i_ctx.md_data = v17;
  *(_OWORD *)&ctx.o_ctx.engine = v17;
  *(_OWORD *)&ctx.md_ctx.md_data = v17;
  *(_OWORD *)&ctx.i_ctx.engine = v17;
  *(_OWORD *)&ctx.md = v17;
  *(_OWORD *)&ctx.md_ctx.engine = v17;
  HMAC_CTX_init(&ctx);
  HMAC_Init_ex(&ctx, a1, a2, md, 0);
  if (!v18)
  {
LABEL_24:
    v34 = 0;
    goto LABEL_25;
  }
  if (a7)
  {
    v19 = 1;
    *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    do
    {
      *(_DWORD *)data = bswap32(v19);
      v21 = v16 >= a7 ? a7 : v16;
      *(_OWORD *)&ctx.key[36] = v20;
      *(_OWORD *)&ctx.key[52] = v20;
      *(_OWORD *)&ctx.key[20] = v20;
      *(_OWORD *)&ctx.key[4] = v20;
      HMAC_Init_ex(&ctx, 0, 0, 0, 0);
      if (!v22)
        goto LABEL_24;
      HMAC_Update(&ctx, a3, a4);
      if (!v23)
        goto LABEL_24;
      HMAC_Update(&ctx, data, 4uLL);
      if (!v24)
        goto LABEL_24;
      HMAC_Final(&ctx, &ctx.key[4], 0);
      if (!v25)
        goto LABEL_24;
      if (v21)
        memcpy(a8, &ctx.key[4], v21);
      if (a5 >= 2)
      {
        v26 = 1;
        do
        {
          HMAC_Init_ex(&ctx, 0, 0, 0, 0);
          if (!v27)
            goto LABEL_24;
          HMAC_Update(&ctx, &ctx.key[4], v16);
          if (!v28)
            goto LABEL_24;
          HMAC_Final(&ctx, &ctx.key[4], 0);
          if (!v29)
            goto LABEL_24;
          if (v21)
          {
            v30 = &ctx.key[4];
            v31 = a8;
            v32 = v21;
            do
            {
              v33 = *v30++;
              *v31++ ^= v33;
              --v32;
            }
            while (v32);
          }
        }
        while (++v26 != a5);
      }
      a8 += v21;
      ++v19;
      a7 -= v21;
      *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    }
    while (a7);
  }
  v34 = a5 != 0;
LABEL_25:
  HMAC_CTX_cleanup(&ctx);
  return v34;
}

int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen, const unsigned __int8 *salt, int saltlen, int iter, int keylen, unsigned __int8 *out)
{
  size_t v8;
  size_t v10;
  EVP_MD *v14;

  v8 = *(_QWORD *)&keylen;
  v10 = *(_QWORD *)&saltlen;
  v14 = (EVP_MD *)EVP_sha1();
  return PKCS5_PBKDF2_HMAC(pass, passlen, salt, v10, iter, v14, v8, (char *)out);
}

BOOL bssl::tls13_add_certificate(bssl *this, bssl::SSL_HANDSHAKE *a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  return bssl::tls13_add_certificate_in_buffer(this, 0, 0, 0, a5);
}

BOOL bssl::tls13_add_certificate_in_buffer(bssl *this, bssl::SSL_HANDSHAKE *a2, _QWORD *a3, unsigned __int8 **a4, unint64_t *a5)
{
  char v7;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;
  __int128 v12;
  __int128 v13;
  uint64_t *v14;
  const bssl::SSL_HANDSHAKE *v15;
  int v16;
  __int128 v17;
  uint64_t v18;
  _BOOL8 v19;
  __int128 v20;
  char *v21;
  __int128 v22;
  const void *v23;
  size_t v24;
  const ssl_st *v25;
  int v26;
  __int128 v27;
  const void *v28;
  size_t v29;
  __int128 v30;
  const void *v31;
  size_t v32;
  uint64_t v33;
  __int128 v34;
  const void *v35;
  size_t v36;
  unint64_t i;
  char *v38;
  __int128 v39;
  const void *v40;
  size_t v41;
  int v42;
  _OWORD v44[3];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  _OWORD v54[3];
  _OWORD v55[3];
  _OWORD v56[3];

  v7 = (char)a2;
  v9 = *(_QWORD **)this;
  v10 = *(_QWORD *)(*((_QWORD *)this + 1) + 32);
  v11 = *(uint64_t **)(v10 + 152);
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v56[1] = v12;
  v56[2] = v12;
  v56[0] = v12;
  CBB_zero(v56);
  *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v55[1] = v13;
  v55[2] = v13;
  v55[0] = v13;
  v54[1] = v13;
  v54[2] = v13;
  v54[0] = v13;
  if ((*((_BYTE *)this + 1602) & 0x20) != 0)
  {
    if (!CBB_init((uint64_t)v56, 0x400uLL))
      goto LABEL_69;
    v14 = (uint64_t *)v56;
  }
  else
  {
    if (!(*(unsigned int (**)(_QWORD *, _OWORD *, _OWORD *, uint64_t))(*v9 + 88))(v9, v56, v55, 11))
      goto LABEL_69;
    v14 = (uint64_t *)v55;
  }
  if (!CBB_add_u8((uint64_t)v14, 0) || !CBB_add_u24_length_prefixed(v14, (uint64_t)v54))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 593);
    v19 = 0;
    goto LABEL_70;
  }
  v16 = *((_DWORD *)this + 400);
  if ((v16 & 0x800000) != 0 && *((_BYTE *)this + 731) == 2 && (*((_BYTE *)v9 + 180) & 1) == 0 && (v7 & 1) == 0)
  {
    *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v52 = v17;
    v53 = v17;
    v50 = v17;
    v51 = v17;
    v48 = v17;
    v49 = v17;
    if (!CBB_add_u24_length_prefixed((uint64_t *)v54, (uint64_t)&v51)
      || !CBB_add_bytes((uint64_t)&v51, *(const void **)(v9[1] + 216), *(_QWORD *)(v9[1] + 224))
      || !CBB_add_u16_length_prefixed((uint64_t *)v54, (uint64_t)&v48))
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 608);
      v19 = 0;
      goto LABEL_70;
    }
LABEL_15:
    v18 = bssl::ssl_add_message_cbb((uint64_t)v9, (uint64_t)v56);
LABEL_62:
    v19 = v18;
    goto LABEL_70;
  }
  if ((v16 & 0x400000) == 0 || *((_BYTE *)this + 730) != 2 || (v7 & 1) != 0)
  {
    if (!bssl::ssl_has_certificate(this, v15))
    {
      if (!a3)
      {
        v18 = bssl::ssl_add_message_cbb((uint64_t)v9, (uint64_t)v56);
        goto LABEL_62;
      }
      v42 = CBB_finish((uint64_t)v56, a3, a4);
      goto LABEL_58;
    }
    v21 = sk_value(*(const STACK **)(v10 + 8), 0);
    *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v52 = v22;
    v53 = v22;
    v50 = v22;
    v51 = v22;
    v48 = v22;
    v49 = v22;
    if (!CBB_add_u24_length_prefixed((uint64_t *)v54, (uint64_t)&v51)
      || (v23 = (const void *)CRYPTO_BUFFER_data((uint64_t)v21),
          v24 = CRYPTO_BUFFER_len((uint64_t)v21),
          !CBB_add_bytes((uint64_t)&v51, v23, v24))
      || !CBB_add_u16_length_prefixed((uint64_t *)v54, (uint64_t)&v48))
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 658);
      v19 = 0;
      goto LABEL_70;
    }
    v26 = *((_DWORD *)this + 400);
    if ((v26 & 4) != 0 && *(_QWORD *)(v10 + 96))
    {
      *(_QWORD *)&v27 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v46 = v27;
      v47 = v27;
      v45 = v27;
      if (!CBB_add_u16((uint64_t)&v48, 0x12u)
        || !CBB_add_u16_length_prefixed((uint64_t *)&v48, (uint64_t)&v45)
        || (v28 = (const void *)CRYPTO_BUFFER_data(*(_QWORD *)(v10 + 96)),
            v29 = CRYPTO_BUFFER_len(*(_QWORD *)(v10 + 96)),
            !CBB_add_bytes((uint64_t)&v45, v28, v29))
        || !CBB_flush((uint64_t *)&v48))
      {
        ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 671);
        goto LABEL_69;
      }
      v26 = *((_DWORD *)this + 400);
    }
    if ((v26 & 0x80) == 0)
      goto LABEL_44;
    if (!*(_QWORD *)(v10 + 104))
      goto LABEL_44;
    *(_QWORD *)&v30 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v46 = v30;
    v47 = v30;
    v44[2] = v30;
    v45 = v30;
    v44[0] = v30;
    v44[1] = v30;
    if (!CBB_add_u16((uint64_t)&v48, 5u))
      goto LABEL_68;
    if (CBB_add_u16_length_prefixed((uint64_t *)&v48, (uint64_t)&v45)
      && CBB_add_u8((uint64_t)&v45, 1u)
      && CBB_add_u24_length_prefixed((uint64_t *)&v45, (uint64_t)v44)
      && (v31 = (const void *)CRYPTO_BUFFER_data(*(_QWORD *)(v10 + 104)),
          v32 = CRYPTO_BUFFER_len(*(_QWORD *)(v10 + 104)),
          CBB_add_bytes((uint64_t)v44, v31, v32))
      && CBB_flush((uint64_t *)&v48))
    {
LABEL_44:
      if (!bssl::ssl_signing_with_dc(this, v25))
        goto LABEL_50;
      v33 = *v11;
      *(_QWORD *)&v34 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v46 = v34;
      v47 = v34;
      v45 = v34;
      if (CBB_add_u16((uint64_t)&v48, 0x22u))
      {
        if (CBB_add_u16_length_prefixed((uint64_t *)&v48, (uint64_t)&v45))
        {
          v35 = (const void *)CRYPTO_BUFFER_data(v33);
          v36 = CRYPTO_BUFFER_len(v33);
          if (CBB_add_bytes((uint64_t)&v45, v35, v36))
          {
            if (CBB_flush((uint64_t *)&v48))
            {
              *(_WORD *)(v9[6] + 220) |= 0x80u;
LABEL_50:
              for (i = 1; i < sk_num(*(const STACK **)(v10 + 8)); ++i)
              {
                v38 = sk_value(*(const STACK **)(v10 + 8), i);
                *(_QWORD *)&v39 = 0xAAAAAAAAAAAAAAAALL;
                *((_QWORD *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
                v46 = v39;
                v47 = v39;
                v45 = v39;
                if (CBB_add_u24_length_prefixed((uint64_t *)v54, (uint64_t)&v45))
                {
                  v40 = (const void *)CRYPTO_BUFFER_data((uint64_t)v38);
                  v41 = CRYPTO_BUFFER_len((uint64_t)v38);
                  if (CBB_add_bytes((uint64_t)&v45, v40, v41))
                  {
                    if (CBB_add_u16((uint64_t)v54, 0))
                      continue;
                  }
                }
                ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 712);
                goto LABEL_69;
              }
              if ((*((_BYTE *)this + 1602) & 0x20) != 0)
              {
                v18 = bssl::tls13_add_compressed_certificate(v9, (uint64_t)v56, (uint64_t)this, (uint64_t *)v55, a3, a4);
                goto LABEL_62;
              }
              if (!a3)
              {
                v18 = bssl::ssl_add_message_cbb((uint64_t)v9, (uint64_t)v56);
                goto LABEL_62;
              }
              v42 = CBB_finish((uint64_t)v56, a3, a4);
LABEL_58:
              v19 = v42 != 0;
              goto LABEL_70;
            }
          }
        }
      }
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 699);
    }
    else
    {
LABEL_68:
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 686);
    }
LABEL_69:
    v19 = 0;
    goto LABEL_70;
  }
  *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v52 = v20;
  v53 = v20;
  v50 = v20;
  v51 = v20;
  v48 = v20;
  v49 = v20;
  if (CBB_add_u24_length_prefixed((uint64_t *)v54, (uint64_t)&v51)
    && CBB_add_bytes((uint64_t)&v51, *(const void **)(v9[1] + 184), *(_QWORD *)(v9[1] + 192))
    && CBB_add_u16_length_prefixed((uint64_t *)v54, (uint64_t)&v48))
  {
    if ((*((_BYTE *)this + 1602) & 0x20) != 0)
    {
      v18 = bssl::tls13_add_compressed_certificate(v9, (uint64_t)v56, (uint64_t)this, (uint64_t *)v55, a3, a4);
      goto LABEL_62;
    }
    goto LABEL_15;
  }
  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 627);
  v19 = 0;
LABEL_70:
  CBB_cleanup((uint64_t)v56);
  return v19;
}

void sub_1B4FCD788(_Unwind_Exception *a1)
{
  uint64_t v1;

  CBB_cleanup(v1 - 128);
  _Unwind_Resume(a1);
}

uint64_t bssl::tls13_add_compressed_certificate(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  int v25;
  void *v27;
  size_t v28;
  int v29;
  char v30;
  _QWORD *v31;
  unint64_t v32;
  int v33;
  char v34;
  _OWORD v35[3];
  void *v36;
  unint64_t v37;

  v36 = 0;
  v37 = 0;
  if (!bssl::CBBFinishArray(a2, (uint64_t)&v36))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 489);
    v16 = 0;
    goto LABEL_25;
  }
  v12 = a1[15];
  v13 = *(_QWORD *)(v12 + 720);
  if (!v13)
    goto LABEL_24;
  v14 = *(_QWORD *)(v12 + 728);
  v15 = 24 * v13;
  while (*(unsigned __int16 *)(v14 + 16) != *(unsigned __int16 *)(a3 + 728))
  {
    v14 += 24;
    v15 -= 24;
    if (!v15)
      goto LABEL_24;
  }
  if (!*(_QWORD *)v14)
  {
LABEL_24:
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 502);
    v16 = 0;
    goto LABEL_25;
  }
  *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v35[1] = v17;
  v35[2] = v17;
  v35[0] = v17;
  if (!(*(unsigned int (**)(_QWORD *, uint64_t, uint64_t *, uint64_t))(*a1 + 88))(a1, a2, a4, 25)
    || !CBB_add_u16((uint64_t)a4, *(unsigned __int16 *)(a3 + 728))
    || !CBB_add_u24((uint64_t)a4, v37)
    || !CBB_add_u24_length_prefixed(a4, (uint64_t)v35))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 513);
    v16 = 0;
    goto LABEL_25;
  }
  v18 = *(_QWORD *)(a3 + 1592);
  if (!v18)
    goto LABEL_27;
  if ((*(_BYTE *)(a3 + 1602) & 0x10) != 0)
    goto LABEL_27;
  if (*(unsigned __int16 *)(v18 + 146) != *(unsigned __int16 *)(a3 + 728))
    goto LABEL_27;
  v19 = *(_QWORD *)(v18 + 160);
  if (v19 != v37)
    goto LABEL_27;
  if (v19)
  {
    v20 = (unsigned __int8 *)v36;
    v21 = *(unsigned __int8 **)(v18 + 152);
    v22 = v19 - 1;
    while (1)
    {
      v23 = v22;
      if (*v21 != *v20)
        break;
      ++v21;
      ++v20;
      --v22;
      if (!v23)
        goto LABEL_21;
    }
LABEL_27:
    if (!(*(unsigned int (**)(_QWORD *, _OWORD *, void *, unint64_t))v14)(a1, v35, v36, v37))
    {
      v25 = 529;
      goto LABEL_48;
    }
    if (v18 && (*(_BYTE *)(a3 + 1602) & 0x10) != 0)
    {
      *(_WORD *)(v18 + 146) = *(_WORD *)(a3 + 728);
      v27 = v36;
      v28 = v37;
      v29 = bssl::Array<unsigned char>::Init(v18 + 152, v37);
      v30 = v29 ^ 1;
      if (!v28)
        v30 = 1;
      if ((v30 & 1) == 0)
        memcpy(*(void **)(v18 + 152), v27, v28);
      if (!v29)
        goto LABEL_46;
      v31 = CBB_data((uint64_t)v35);
      v32 = CBB_len((uint64_t)v35);
      v33 = bssl::Array<unsigned char>::Init(v18 + 168, v32);
      v34 = v33 ^ 1;
      if (!v32)
        v34 = 1;
      if ((v34 & 1) == 0)
        memcpy(*(void **)(v18 + 168), v31, v32);
      if (!v33)
      {
LABEL_46:
        v16 = 0;
        goto LABEL_25;
      }
    }
    goto LABEL_40;
  }
LABEL_21:
  v24 = *(_QWORD *)(v18 + 176);
  if (!v24)
    goto LABEL_27;
  if (!CBB_add_bytes((uint64_t)v35, *(const void **)(v18 + 168), v24))
  {
    v25 = 524;
LABEL_48:
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", v25);
    v16 = 0;
    goto LABEL_25;
  }
LABEL_40:
  if (a5)
  {
    if (!CBB_finish(a2, a5, a6))
    {
      v25 = 550;
      goto LABEL_48;
    }
  }
  else if ((bssl::ssl_add_message_cbb((uint64_t)a1, a2) & 1) == 0)
  {
    v25 = 545;
    goto LABEL_48;
  }
  v16 = 1;
LABEL_25:
  OPENSSL_free(v36);
  return v16;
}

void sub_1B4FCDAF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t bssl::tls13_add_certificate_verify(EVP_PKEY **this, bssl::SSL_HANDSHAKE *a2)
{
  return bssl::tls13_add_certificate_verify_in_buffer(this, 0, 0, 0, 0, 0);
}

uint64_t bssl::tls13_add_certificate_verify_in_buffer(EVP_PKEY **this, bssl::SSL_HANDSHAKE *a2, unsigned __int16 *a3, unsigned __int8 **a4, unint64_t *a5, const unsigned __int8 *a6)
{
  char v10;
  EVP_PKEY *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  void *v20;
  size_t v21;
  uint64_t v22;
  ssl_st *v23;
  _OWORD v24[3];
  _OWORD v25[3];
  _OWORD v26[3];
  unsigned __int16 v27;

  v10 = (char)a2;
  v12 = *this;
  v27 = -21846;
  if ((bssl::tls1_choose_signature_algorithm((bssl *)this, (ssl_st *)&v27, a3) & 1) != 0)
  {
    *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v26[1] = v13;
    v26[2] = v13;
    v26[0] = v13;
    CBB_zero(v26);
    *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v25[1] = v14;
    v25[2] = v14;
    v25[0] = v14;
    if ((*(unsigned int (**)(EVP_PKEY *, _OWORD *, _OWORD *, uint64_t))(*(_QWORD *)&v12->type + 88))(v12, v26, v25, 15)&& CBB_add_u16((uint64_t)v25, v27))
    {
      *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v24[1] = v15;
      v24[2] = v15;
      v24[0] = v15;
      v16 = EVP_PKEY_size(this[190]);
      v22 = 0xAAAAAAAAAAAAAAAALL;
      v23 = (ssl_st *)0xAAAAAAAAAAAAAAAALL;
      if (CBB_add_u16_length_prefixed((uint64_t *)v25, (uint64_t)v24)
        && CBB_reserve((uint64_t)v24, &v23, v16))
      {
        v20 = 0;
        v21 = 0;
        if ((v10 & 1) != 0)
          v17 = 3;
        else
          v17 = (BYTE4(v12[4].pkey.dh) & 1) == 0;
        if (bssl::tls13_get_cert_verify_signature_input((uint64_t)this, (uint64_t)&v20, v17, a5, (size_t)a6))
        {
          v18 = bssl::ssl_private_key_sign((uint64_t)this, v23, (unint64_t *)&v22, v16, (evp_pkey_st *)v27, (unsigned __int8 *)v20, v21);
          if (!(_DWORD)v18)
          {
            if (a3)
            {
              if (!CBB_did_write((uint64_t)v24, v22) || !CBB_finish((uint64_t)v26, a3, a4))
              {
LABEL_25:
                v18 = 2;
                goto LABEL_19;
              }
            }
            else if (!CBB_did_write((uint64_t)v24, v22)
                   || (bssl::ssl_add_message_cbb((uint64_t)v12, (uint64_t)v26) & 1) == 0)
            {
              goto LABEL_25;
            }
            v18 = 0;
          }
        }
        else
        {
          v18 = 2;
          bssl::ssl_send_alert((bssl *)v12, (ssl_st *)2, 80);
        }
LABEL_19:
        OPENSSL_free(v20);
        goto LABEL_20;
      }
      v18 = 2;
      bssl::ssl_send_alert((bssl *)v12, (ssl_st *)2, 80);
    }
    else
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 754);
      v18 = 2;
    }
LABEL_20:
    CBB_cleanup((uint64_t)v26);
    return v18;
  }
  v18 = 2;
  bssl::ssl_send_alert((bssl *)v12, (ssl_st *)2, 40);
  return v18;
}

void sub_1B4FCDD64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  CBB_cleanup((uint64_t)&a25);
  _Unwind_Resume(a1);
}

uint64_t bssl::tls13_add_key_update(bssl *this, ssl_st *a2)
{
  unsigned __int8 v2;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  _OWORD v8[3];
  _OWORD v9[3];

  v2 = a2;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v4;
  v9[2] = v4;
  v9[0] = v4;
  CBB_zero(v9);
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v5;
  v8[2] = v5;
  v8[0] = v5;
  if ((*(unsigned int (**)(bssl *, _OWORD *, _OWORD *, uint64_t))(*(_QWORD *)this + 88))(this, v9, v8, 24)&& CBB_add_u8((uint64_t)v8, v2)&& bssl::ssl_add_message_cbb((uint64_t)this, (uint64_t)v9)&& (bssl::tls13_rotate_traffic_key((const SSL *)this, 1) & 1) != 0)
  {
    *(_WORD *)(*((_QWORD *)this + 6) + 220) |= 0x400u;
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  CBB_cleanup((uint64_t)v9);
  return v6;
}

void sub_1B4FCDE64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  CBB_cleanup((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_client_hello_init(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  uint64_t result;
  unsigned __int16 *v5[2];

  v5[0] = a3;
  v5[1] = a4;
  result = bssl::ssl_parse_client_hello_with_trailing_data(a1, v5, a2);
  if ((_DWORD)result)
    return CBS_len((uint64_t)v5) == 0;
  return result;
}

uint64_t bssl::ssl_parse_client_hello_with_trailing_data(uint64_t a1, unsigned __int16 **a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  __int128 v7;
  unint64_t v8[4];
  unint64_t v9[4];
  __int128 v10;

  *(_QWORD *)(a3 + 104) = 0;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 8) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_QWORD *)a3 = a1;
  v10 = *(_OWORD *)a2;
  memset(v9, 170, sizeof(v9));
  result = CBS_get_u16(a2, (_WORD *)(a3 + 24));
  if ((_DWORD)result)
  {
    result = CBS_get_bytes((uint64_t *)a2, &v9[2], 0x20uLL);
    if ((_DWORD)result)
    {
      result = CBS_get_u8_length_prefixed((unsigned __int8 **)a2, v9);
      if ((_DWORD)result)
      {
        if ((unint64_t)CBS_len((uint64_t)v9) > 0x20)
          return 0;
        *(_QWORD *)(a3 + 32) = CBS_data((uint64_t)&v9[2]);
        *(_QWORD *)(a3 + 40) = CBS_len((uint64_t)&v9[2]);
        *(_QWORD *)(a3 + 48) = CBS_data((uint64_t)v9);
        *(_QWORD *)(a3 + 56) = CBS_len((uint64_t)v9);
        if (!SSL_is_dtls(*(unsigned __int8 ***)a3)
          || (v8[2] = 0xAAAAAAAAAAAAAAAALL,
              v8[3] = 0xAAAAAAAAAAAAAAAALL,
              result = CBS_get_u8_length_prefixed((unsigned __int8 **)a2, &v8[2]),
              (_DWORD)result))
        {
          memset(v8, 170, sizeof(v8));
          result = CBS_get_u16_length_prefixed((unsigned __int8 **)a2, &v8[2]);
          if ((_DWORD)result)
          {
            if ((unint64_t)CBS_len((uint64_t)&v8[2]) < 2 || (CBS_len((uint64_t)&v8[2]) & 1) != 0)
              return 0;
            result = CBS_get_u8_length_prefixed((unsigned __int8 **)a2, v8);
            if ((_DWORD)result)
            {
              result = CBS_len((uint64_t)v8);
              if (result)
              {
                *(_QWORD *)(a3 + 64) = CBS_data((uint64_t)&v8[2]);
                *(_QWORD *)(a3 + 72) = CBS_len((uint64_t)&v8[2]);
                *(_QWORD *)(a3 + 80) = CBS_data((uint64_t)v8);
                *(_QWORD *)(a3 + 88) = CBS_len((uint64_t)v8);
                if (CBS_len((uint64_t)a2))
                {
                  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
                  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  if (!CBS_get_u16_length_prefixed((unsigned __int8 **)a2, (unint64_t *)&v7)
                    || !bssl::tls1_check_duplicate_extensions(&v7))
                  {
                    return 0;
                  }
                  *(_QWORD *)(a3 + 96) = CBS_data((uint64_t)&v7);
                  *(_QWORD *)(a3 + 104) = CBS_len((uint64_t)&v7);
                }
                else
                {
                  *(_QWORD *)(a3 + 96) = 0;
                  *(_QWORD *)(a3 + 104) = 0;
                }
                *(_QWORD *)(a3 + 8) = CBS_data((uint64_t)&v10);
                v6 = CBS_len((uint64_t)&v10);
                *(_QWORD *)(a3 + 16) = v6 - CBS_len((uint64_t)a2);
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ssl_client_hello_get_extension(uint64_t a1, _OWORD *a2, int a3)
{
  uint64_t result;
  __int128 v6;
  unsigned __int16 v7;
  unsigned __int8 *v8[2];

  v8[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  v8[1] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  CBS_init(v8, *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104));
  for (result = CBS_len((uint64_t)v8); result; result = CBS_len((uint64_t)v8))
  {
    v7 = -21846;
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    result = CBS_get_u16((unsigned __int16 **)v8, &v7);
    if (!(_DWORD)result)
      break;
    result = CBS_get_u16_length_prefixed(v8, (unint64_t *)&v6);
    if (!(_DWORD)result)
      break;
    if (v7 == a3)
    {
      *a2 = v6;
      return 1;
    }
  }
  return result;
}

uint64_t bssl::tls1_get_shared_group(bssl *this, const ssl_st *a2, unsigned __int16 *a3)
{
  bssl *v3;
  uint64_t v4;
  uint64_t v5;
  __int16 *v6;
  __int16 *v7;
  uint64_t v8;
  __int16 *v9;
  int v10;
  uint64_t v11;
  __int16 *v12;
  ssl_st *v14;
  unsigned __int16 *v15;

  v3 = *(bssl **)this;
  if ((*(_BYTE *)(*(_QWORD *)this + 180) & 1) == 0)
    bssl::tls1_get_shared_group();
  v4 = *((_QWORD *)this + 1);
  v5 = *(_QWORD *)(v4 + 112);
  if (v5)
  {
    v6 = *(__int16 **)(v4 + 104);
  }
  else
  {
    v6 = &bssl::kDefaultGroups;
    v5 = 4;
  }
  v7 = (__int16 *)*((_QWORD *)this + 83);
  v8 = *((_QWORD *)this + 84);
  if ((*((_BYTE *)v3 + 146) & 0x40) != 0)
  {
    v14 = (ssl_st *)a2;
    v15 = (unsigned __int16 *)&v6[v5];
    v9 = v6;
LABEL_9:
    while (!v8)
    {
LABEL_16:
      if (++v9 == (__int16 *)v15)
        return 0;
    }
    v10 = (unsigned __int16)*v9;
    v11 = 2 * v8;
    v12 = v7;
    while (v10 != (unsigned __int16)*v12
         || bssl::ssl_protocol_version(v3, a2) <= 0x303
         && ((v10 - 65073) < 2 || v10 == 16696))
    {
      ++v12;
      v11 -= 2;
      if (!v11)
        goto LABEL_16;
    }
    LOWORD(v14->version) = v10;
    return 1;
  }
  else
  {
    if (v8)
    {
      v14 = (ssl_st *)a2;
      v15 = (unsigned __int16 *)&v7[v8];
      v9 = (__int16 *)*((_QWORD *)this + 83);
      v7 = v6;
      v8 = v5;
      goto LABEL_9;
    }
    return 0;
  }
}

uint64_t bssl::tls1_set_curves(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  void *v11;
  uint64_t v12;

  v3 = a3;
  v11 = 0;
  v12 = 0;
  if (!bssl::Array<unsigned short>::Init((uint64_t)&v11, a3))
  {
LABEL_7:
    v9 = 0;
    goto LABEL_8;
  }
  if (v3)
  {
    v6 = 0;
    do
    {
      v7 = *a2++;
      if (!bssl::ssl_nid_to_group_id((bssl *)((char *)v11 + v6), (unsigned __int16 *)v7))
        goto LABEL_7;
      v6 += 2;
    }
    while (--v3);
  }
  OPENSSL_free(*(_QWORD **)a1);
  v8 = v12;
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + 8) = v8;
  v11 = 0;
  v12 = 0;
  v9 = 1;
LABEL_8:
  OPENSSL_free(v11);
  return v9;
}

void sub_1B4FCE32C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t bssl::tls1_set_curves_list(uint64_t a1, char *__s)
{
  char *v2;
  uint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  void *v14;
  uint64_t v15;

  v2 = __s;
  v4 = 0;
  v5 = __s;
  do
  {
    v6 = strchr(v5, 58);
    ++v4;
    v5 = v6 + 1;
  }
  while (v6);
  v14 = 0;
  v15 = 0;
  if (bssl::Array<unsigned short>::Init((uint64_t)&v14, v4))
  {
    v7 = 0;
    while (1)
    {
      v8 = strchr(v2, 58);
      v9 = v8;
      v10 = (const char *)(v8 ? v8 - v2 : strlen(v2));
      if ((bssl::ssl_name_to_group_id((bssl *)((char *)v14 + v7), v2, v10) & 1) == 0)
        break;
      v2 = v9 + 1;
      --v4;
      v7 += 2;
      if (!v9)
      {
        if (v4)
          __assert_rtn("tls1_set_curves_list", "extensions.cc", 410, "i == count");
        OPENSSL_free(*(_QWORD **)a1);
        v11 = v15;
        *(_QWORD *)a1 = v14;
        *(_QWORD *)(a1 + 8) = v11;
        v14 = 0;
        v15 = 0;
        v12 = 1;
        goto LABEL_13;
      }
    }
  }
  v12 = 0;
LABEL_13:
  OPENSSL_free(v14);
  return v12;
}

void sub_1B4FCE458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_negotiate_alpn(uint64_t a1, char *a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t (*v6)(_QWORD *, unint64_t *, unsigned __int8 *, uint64_t, uint64_t, _QWORD);
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t result;
  size_t v13;
  void **v14;
  const void *v15;
  char v16;
  int v17;
  int v18;
  unsigned __int8 v19;
  unint64_t v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  __int128 v23;

  v4 = *(_QWORD **)a1;
  *(_QWORD *)&v23 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if (!v4[10] || (bssl::ssl_client_hello_get_extension(a3, &v23, 16) & 1) == 0)
  {
    if (!v4[21])
      return 1;
    ERR_put_error(16, 0, 307, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1563);
    result = 0;
    v16 = 120;
LABEL_19:
    *a2 = v16;
    return result;
  }
  *(_DWORD *)(a1 + 1600) &= ~0x8000u;
  v21 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  v22 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&v23, (unint64_t *)&v21)
    || CBS_len((uint64_t)&v23)
    || (bssl::ssl_is_valid_alpn_list(v21, v22) & 1) == 0)
  {
    ERR_put_error(16, 0, 190, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1578);
    result = 0;
    v16 = 50;
    goto LABEL_19;
  }
  v20 = 0xAAAAAAAAAAAAAAAALL;
  v19 = -86;
  v6 = (uint64_t (*)(_QWORD *, unint64_t *, unsigned __int8 *, uint64_t, uint64_t, _QWORD))v4[10];
  v7 = CBS_data((uint64_t)&v21);
  v8 = CBS_len((uint64_t)&v21);
  v9 = v6(v4, &v20, &v19, v7, v8, v4[11]);
  if ((v9 & 0xFFFFFFFD) == 1)
    v10 = 2;
  else
    v10 = v9;
  if (v4[21])
    v11 = v10;
  else
    v11 = v9;
  result = 1;
  switch(v11)
  {
    case 0:
      v13 = v19;
      if (v19)
      {
        v14 = (void **)(v4[6] + 496);
        v15 = (const void *)v20;
        result = bssl::Array<unsigned char>::Init((uint64_t)v14, v19);
        if ((_DWORD)result)
        {
          memcpy(*v14, v15, v13);
          return 1;
        }
      }
      else
      {
        ERR_put_error(16, 0, 259, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1605);
        result = 0;
      }
      v16 = 80;
      goto LABEL_19;
    case 1:
    case 3:
      return result;
    case 2:
      *a2 = 120;
      v17 = 307;
      v18 = 1620;
      goto LABEL_24;
    default:
      *a2 = 80;
      v17 = 68;
      v18 = 1625;
LABEL_24:
      ERR_put_error(16, 0, v17, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v18);
      result = 0;
      break;
  }
  return result;
}

uint64_t bssl::ssl_ext_pre_shared_key_parse_serverhello(uint64_t a1, char *a2, unsigned __int16 **a3)
{
  char v5;
  uint64_t result;
  __int16 v7;

  v7 = -21846;
  if (CBS_get_u16(a3, &v7) && !CBS_len((uint64_t)a3))
  {
    if (!v7)
      return 1;
    ERR_put_error(16, 0, 195, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2051);
    v5 = 115;
  }
  else
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2044);
    v5 = 50;
  }
  result = 0;
  *a2 = v5;
  return result;
}

uint64_t bssl::ssl_ext_pre_shared_key_parse_clienthello(uint64_t a1, unint64_t *a2, _OWORD *a3, int *a4, char *a5, uint64_t a6, unsigned __int8 **a7)
{
  uint64_t v13;
  int v14;
  int v15;
  uint64_t result;
  char v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21[5];
  _OWORD v22[2];

  v13 = CBS_data((uint64_t)a7);
  if (v13 + CBS_len((uint64_t)a7) == *(_QWORD *)(a6 + 96) + *(_QWORD *)(a6 + 104))
  {
    memset(v22, 170, sizeof(v22));
    if (CBS_get_u16_length_prefixed(a7, (unint64_t *)&v22[1])
      && CBS_get_u16_length_prefixed((unsigned __int8 **)&v22[1], a2)
      && CBS_get_u32((uint64_t *)&v22[1], a4)
      && CBS_get_u16_length_prefixed(a7, (unint64_t *)v22)
      && CBS_len((uint64_t)v22)
      && !CBS_len((uint64_t)a7))
    {
      *a3 = v22[0];
      v19 = 1;
      if (CBS_len((uint64_t)&v22[1]))
      {
        while (1)
        {
          memset(v21, 170, sizeof(v21));
          if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&v22[1], (unint64_t *)&v21[1])
            || !CBS_get_u32((uint64_t *)&v22[1], v21))
          {
            break;
          }
          ++v19;
          if (!CBS_len((uint64_t)&v22[1]))
            goto LABEL_18;
        }
        v18 = 2094;
      }
      else
      {
LABEL_18:
        v20 = 0;
        if (!CBS_len((uint64_t)v22))
        {
LABEL_21:
          if (v19 == v20)
            return 1;
          v14 = 271;
          v15 = 2117;
          goto LABEL_3;
        }
        while (1)
        {
          *(_QWORD *)&v21[1] = 0xAAAAAAAAAAAAAAAALL;
          *(_QWORD *)&v21[3] = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_u8_length_prefixed((unsigned __int8 **)v22, (unint64_t *)&v21[1]))
            break;
          ++v20;
          if (!CBS_len((uint64_t)v22))
            goto LABEL_21;
        }
        v18 = 2108;
      }
    }
    else
    {
      v18 = 2080;
    }
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v18);
    result = 0;
    v17 = 50;
    goto LABEL_12;
  }
  v14 = 267;
  v15 = 2067;
LABEL_3:
  ERR_put_error(16, 0, v14, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v15);
  result = 0;
  v17 = 47;
LABEL_12:
  *a5 = v17;
  return result;
}

uint64_t bssl::ssl_ext_pre_shared_key_add_serverhello(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  __int128 v4;
  _OWORD v5[3];

  if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)a1 + 48) + 220) & 0x40) == 0)
    return 1;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v5[1] = v4;
  v5[2] = v4;
  v5[0] = v4;
  result = CBB_add_u16((uint64_t)a2, 0x29u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v5);
    if ((_DWORD)result)
    {
      result = CBB_add_u16((uint64_t)v5, 0);
      if ((_DWORD)result)
        return CBB_flush(a2) != 0;
    }
  }
  return result;
}

uint64_t bssl::ssl_ext_key_share_parse_clienthello(uint64_t a1, BOOL *a2, _QWORD *a3, _BYTE *a4, uint64_t a5)
{
  int v9;
  uint64_t result;
  int v11;
  uint64_t v12;
  __int128 v13;
  unsigned __int16 v14;
  __int128 v15;
  unsigned __int8 *v16[2];
  __int128 v17;

  *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if ((bssl::ssl_client_hello_get_extension(a5, &v17, 51) & 1) != 0)
  {
    v16[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
    v16[1] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_u16_length_prefixed((unsigned __int8 **)&v17, (unint64_t *)v16)
      && !CBS_len((uint64_t)&v17))
    {
      v11 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 1536) + 6);
      *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
      CBS_init(&v15, 0, 0);
      while (CBS_len((uint64_t)v16))
      {
        v14 = -21846;
        *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_u16((unsigned __int16 **)v16, &v14)
          || !CBS_get_u16_length_prefixed(v16, (unint64_t *)&v13)
          || !CBS_len((uint64_t)&v13))
        {
          v9 = 2447;
          goto LABEL_5;
        }
        if (v14 == v11)
        {
          if (CBS_len((uint64_t)&v15))
          {
            ERR_put_error(16, 0, 264, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2453);
            *a4 = 47;
            return 0;
          }
          v15 = v13;
        }
      }
      if (a3)
      {
        v12 = *((_QWORD *)&v15 + 1);
        *a3 = v15;
        a3[1] = v12;
      }
      *a2 = CBS_len((uint64_t)&v15) != 0;
      return 1;
    }
    else
    {
      v9 = 2433;
LABEL_5:
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v9);
      return 0;
    }
  }
  else
  {
    ERR_put_error(16, 0, 258, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2425);
    result = 0;
    *a4 = 109;
  }
  return result;
}

uint64_t bssl::ssl_ext_key_share_add_serverhello(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  __int128 v5;
  _OWORD v6[3];
  _OWORD v7[3];

  result = CBB_add_u16((uint64_t)a2, 0x33u);
  if ((_DWORD)result)
  {
    *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v7[1] = v5;
    v7[2] = v5;
    v6[2] = v5;
    v7[0] = v5;
    v6[0] = v5;
    v6[1] = v5;
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v7);
    if ((_DWORD)result)
    {
      result = CBB_add_u16((uint64_t)v7, *(unsigned __int16 *)(*(_QWORD *)(a1 + 1536) + 6));
      if ((_DWORD)result)
      {
        result = CBB_add_u16_length_prefixed((uint64_t *)v7, (uint64_t)v6);
        if ((_DWORD)result)
        {
          result = CBB_add_bytes((uint64_t)v6, *(const void **)(a1 + 632), *(_QWORD *)(a1 + 640));
          if ((_DWORD)result)
            return CBB_flush(a2) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ssl_get_local_application_settings(uint64_t a1, unsigned __int8 **a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 **v6;
  unsigned __int8 **v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v13;
  unsigned __int8 *v14;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(v4 + 144);
  if (!v5)
    return 0;
  v6 = *(unsigned __int8 ***)(v4 + 152);
  v7 = &v6[4 * v5];
  while (a4 != v6[1])
  {
LABEL_9:
    v6 += 4;
    if (v6 == v7)
      return 0;
  }
  if (a4)
  {
    v8 = *v6;
    v9 = a4 - 1;
    v10 = a3;
    do
    {
      v11 = v9;
      if (*v10 != *v8)
        goto LABEL_9;
      ++v10;
      ++v8;
      --v9;
    }
    while (v11);
  }
  v14 = v6[2];
  v13 = v6[3];
  *a2 = v14;
  a2[1] = v13;
  return 1;
}

uint64_t bssl::ssl_negotiate_alps(bssl **a1, ssl_st *a2, uint64_t a3)
{
  bssl *v3;
  int v7;
  char v8;
  char v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  unint64_t v14;
  unint64_t v15;
  void **v16;
  unsigned __int8 *v17;
  size_t v18;
  int v19;
  char v20;
  unsigned __int8 *v21;
  unint64_t v22;
  unsigned __int8 *v23[2];
  unsigned __int8 *v24;
  size_t v25;
  __int128 v26;

  v3 = *a1;
  if (*(_QWORD *)(*((_QWORD *)*a1 + 6) + 504))
  {
    *(_QWORD *)&v26 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v26 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v24 = 0;
    v25 = 0;
    if (bssl::ssl_protocol_version(v3, a2) >= 0x304
      && bssl::ssl_get_local_application_settings((uint64_t)a1, &v24, *(unsigned __int8 **)(*((_QWORD *)v3 + 6) + 496), *(unsigned __int8 **)(*((_QWORD *)v3 + 6) + 504))&& bssl::ssl_client_hello_get_extension(a3, &v26, 17513))
    {
      v23[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
      v23[1] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
      if (CBS_get_u16_length_prefixed((unsigned __int8 **)&v26, (unint64_t *)v23)
        && !CBS_len((uint64_t)&v26)
        && CBS_len((uint64_t)v23))
      {
        if (!CBS_len((uint64_t)v23))
          return 1;
        v10 = 0;
        do
        {
          v21 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
          v22 = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_u8_length_prefixed(v23, (unint64_t *)&v21) || !CBS_len((uint64_t)&v21))
          {
            v7 = 3097;
            goto LABEL_8;
          }
          v11 = *((_QWORD *)v3 + 6);
          if (v22 == *(_QWORD *)(v11 + 504))
          {
            if (v22)
            {
              v12 = *(unsigned __int8 **)(v11 + 496);
              v13 = v21;
              v14 = v22 - 1;
              while (1)
              {
                v15 = v14;
                if (*v13 != *v12)
                  break;
                ++v13;
                ++v12;
                --v14;
                if (!v15)
                  goto LABEL_20;
              }
            }
            else
            {
LABEL_20:
              v10 = 1;
            }
          }
        }
        while (CBS_len((uint64_t)v23));
        if ((v10 & 1) == 0)
          return 1;
        *((_BYTE *)a1[192] + 448) |= 0x40u;
        v16 = (void **)((char *)a1[192] + 416);
        v17 = v24;
        v18 = v25;
        v19 = bssl::Array<unsigned char>::Init((uint64_t)v16, v25);
        v20 = v19;
        if (v18)
        {
          if (v19)
            memcpy(*v16, v17, v18);
        }
        if ((v20 & 1) != 0)
          return 1;
        v8 = 80;
      }
      else
      {
        v7 = 3088;
LABEL_8:
        ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v7);
        v8 = 50;
      }
      LOBYTE(a2->version) = v8;
      return 0;
    }
  }
  return 1;
}

BOOL bssl::ssl_add_serverhello_tlsext(uint64_t a1, uint64_t *a2)
{
  bssl *v4;
  __int128 v5;
  const ssl_st *v6;
  uint64_t v7;
  uint64_t (**v8)();
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD v17[3];

  v4 = *(bssl **)a1;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[1] = v5;
  v17[2] = v5;
  v17[0] = v5;
  if (CBB_add_u16_length_prefixed(a2, (uint64_t)v17))
  {
    v7 = 0;
    v8 = &off_1E686D1C8;
    do
    {
      if (((*(_DWORD *)(a1 + 376) >> v7) & 1) != 0 && !((unsigned int (*)(uint64_t, _OWORD *))*v8)(a1, v17))
      {
        ERR_put_error(16, 0, 147, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 3999);
        ERR_add_error_dataf("extension %u", v10, v11, v12, v13, v14, v15, v16, *((_WORD *)v8 - 16));
        goto LABEL_11;
      }
      ++v7;
      v8 += 5;
    }
    while (v7 != 27);
    if (bssl::ssl_protocol_version(v4, v6) <= 0x303 && !CBB_len((uint64_t)v17))
      CBB_discard_child(a2);
    return CBB_flush(a2) != 0;
  }
  else
  {
LABEL_11:
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4014);
    return 0;
  }
}

uint64_t bssl::ssl_parse_clienthello_tlsext(uint64_t a1, uint64_t a2)
{
  bssl *v3;
  uint64_t v4;
  __int16 *v5;
  uint64_t v6;
  __int16 *v7;
  int v8;
  unint64_t *v9;
  bssl *v10;
  uint64_t v11;
  uint64_t (*v12)(bssl *, int *, _QWORD);
  int v13;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 v31;
  unint64_t v32;
  unint64_t v33;
  unsigned __int16 v34;
  int v35[2];
  unint64_t v36;

  v3 = *(bssl **)a1;
  *(_DWORD *)(a1 + 376) = 0;
  *(_QWORD *)v35 = 0xAAAAAAAAAAAAAAAALL;
  v36 = 0xAAAAAAAAAAAAAAAALL;
  CBS_init(v35, *(_QWORD *)(a2 + 96), *(_QWORD *)(a2 + 104));
  if (!CBS_len((uint64_t)v35))
  {
LABEL_10:
    v6 = 0;
    v7 = bssl::kExtensions;
    do
    {
      if (((1 << v6) & *(_DWORD *)(a1 + 376)) == 0)
      {
        v32 = 0xAAAAAAAAAAAAAAAALL;
        v33 = 0xAAAAAAAAAAAAAAAALL;
        v8 = (unsigned __int16)*v7;
        if (v8 == 65281 && bssl::ssl_client_cipher_list_contains_cipher(a2, 255))
        {
          v9 = &v32;
          CBS_init(&v32, (uint64_t)&bssl::ssl_scan_clienthello_tlsext(bssl::SSL_HANDSHAKE *,ssl_early_callback_ctx const*,int *)::kFakeRenegotiateExtension, 1);
          *(_DWORD *)(a1 + 376) |= 1 << v6;
        }
        else
        {
          v9 = 0;
        }
        LOBYTE(v34) = 50;
        if (((*((uint64_t (**)(uint64_t, unsigned __int16 *, unint64_t *))v7 + 3))(a1, &v34, v9) & 1) == 0)
        {
          ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4074);
          ERR_add_error_dataf("extension %u", v16, v17, v18, v19, v20, v21, v22, v8);
          v15 = v34;
          goto LABEL_28;
        }
      }
      ++v6;
      v7 += 20;
    }
    while (v6 != 27);
    v10 = *(bssl **)a1;
    v35[0] = 112;
    v11 = *((_QWORD *)v10 + 15);
    v12 = *(uint64_t (**)(bssl *, int *, _QWORD))(v11 + 504);
    if (!v12)
    {
      v11 = *((_QWORD *)v10 + 16);
      v12 = *(uint64_t (**)(bssl *, int *, _QWORD))(v11 + 504);
      if (!v12)
      {
LABEL_22:
        *(_DWORD *)(a1 + 1600) &= ~0x200u;
        return 1;
      }
    }
    v13 = v12(v10, v35, *(_QWORD *)(v11 + 512));
    if (v13 != 2)
    {
      if (v13 == 3)
        goto LABEL_22;
      return 1;
    }
    bssl::ssl_send_alert(v10, (ssl_st *)2, v35[0]);
    ERR_put_error(16, 0, 132, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4094);
    return 0;
  }
  while (2)
  {
    v34 = -21846;
    v32 = 0xAAAAAAAAAAAAAAAALL;
    v33 = 0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_u16((unsigned __int16 **)v35, &v34)
      && CBS_get_u16_length_prefixed((unsigned __int8 **)v35, &v32))
    {
      v4 = 0;
      v5 = bssl::kExtensions;
      while ((unsigned __int16)*v5 != v34)
      {
        ++v4;
        v5 += 20;
        if (v4 == 27)
          goto LABEL_9;
      }
      *(_DWORD *)(a1 + 376) |= 1 << v4;
      v31 = 50;
      if (!(*((unsigned int (**)(uint64_t, unsigned __int8 *, unint64_t *))v5 + 3))(a1, &v31, &v32))
      {
        v15 = v31;
        ERR_put_error(16, 0, 149, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4046);
        ERR_add_error_dataf("extension %u", v23, v24, v25, v26, v27, v28, v29, v34);
        goto LABEL_28;
      }
LABEL_9:
      if (CBS_len((uint64_t)v35))
        continue;
      goto LABEL_10;
    }
    break;
  }
  v15 = 50;
LABEL_28:
  bssl::ssl_send_alert(v3, (ssl_st *)2, v15);
  return 0;
}

uint64_t bssl::ssl_process_ticket(uint64_t *a1, SSL_SESSION **a2, _BYTE *a3, const unsigned __int8 *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  uint64_t *v13;
  const ssl_st *v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  size_t v20;
  const void *v21;
  size_t v22;
  const void *v23;
  uint64_t v24;
  char v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  void *v30;
  size_t v31;
  char v32;
  char v33;
  int v34;
  char v35;
  void *__dst;
  unint64_t v38;
  unint64_t v39;
  void *v40;
  unint64_t v41;

  v13 = (uint64_t *)*a1;
  *a3 = 0;
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](a2, 0);
  v15 = 2;
  if ((SSL_get_options(*a1) & 0x4000) == 0 && a7 <= 0x20)
  {
    v16 = bssl::ssl_protocol_version((bssl *)v13, v14);
    v17 = v16;
    __dst = 0;
    v38 = 0;
    v18 = a1[199];
    if (v16 < 0x304 || v18 == 0)
    {
      if (v16 <= 0x303 && v18 && (*((_BYTE *)a1 + 1602) & 0x10) == 0)
      {
        v20 = *(_QWORD *)(v18 + 232);
        if (v20)
        {
          v21 = *(const void **)(v18 + 224);
          if (bssl::Array<unsigned char>::Init((uint64_t)&__dst, *(_QWORD *)(v18 + 232)))
          {
            memcpy(__dst, v21, v20);
            v15 = 0;
            *a3 = *(_BYTE *)(v18 + 240);
            goto LABEL_35;
          }
LABEL_18:
          v15 = 3;
          goto LABEL_35;
        }
        if (*(_BYTE *)(v18 + 241))
          goto LABEL_20;
      }
    }
    else if ((*((_BYTE *)a1 + 1602) & 0x10) == 0)
    {
      v22 = *(_QWORD *)(v18 + 136);
      if (v22)
      {
        v23 = *(const void **)(v18 + 128);
        if (bssl::Array<unsigned char>::Init((uint64_t)&__dst, *(_QWORD *)(v18 + 136)))
        {
          memcpy(__dst, v23, v22);
          v15 = 0;
          goto LABEL_35;
        }
        goto LABEL_18;
      }
      if (*(_BYTE *)(v18 + 144))
      {
LABEL_20:
        v15 = 2;
        goto LABEL_35;
      }
    }
    v24 = v13[16];
    if (*(_QWORD *)(v24 + 800))
    {
      v40 = 0;
      v41 = 0;
      v25 = bssl::Array<unsigned char>::Init((uint64_t)&v40, a5);
      v26 = v40;
      if ((v25 & 1) != 0)
      {
        v39 = 0xAAAAAAAAAAAAAAAALL;
        v15 = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(*a1 + 128) + 800) + 16))();
        if ((_DWORD)v15)
        {
          v26 = v40;
        }
        else
        {
          if (v41 < v39)
            abort();
          v41 = v39;
          OPENSSL_free(__dst);
          v26 = 0;
          __dst = v40;
          v38 = v41;
          v40 = 0;
          v41 = 0;
        }
      }
      else
      {
        v15 = 3;
      }
      OPENSSL_free(v26);
      if (v18)
      {
LABEL_35:
        if ((*((_BYTE *)a1 + 1602) & 0x10) == 0)
          goto LABEL_36;
        if ((_DWORD)v15)
        {
          if ((_DWORD)v15 != 2)
            goto LABEL_60;
          if (v17 < 0x304)
            *(_BYTE *)(v18 + 241) = 1;
          else
            *(_BYTE *)(v18 + 144) = 1;
          goto LABEL_52;
        }
        v30 = __dst;
        v31 = v38;
        if (v17 < 0x304)
        {
          v34 = bssl::Array<unsigned char>::Init(v18 + 224, v38);
          v35 = v34 ^ 1;
          if (!v31)
            v35 = 1;
          if ((v35 & 1) == 0)
            memcpy(*(void **)(v18 + 224), v30, v31);
          if (!v34)
            goto LABEL_59;
          *(_BYTE *)(v18 + 240) = *a3;
        }
        else
        {
          v32 = bssl::Array<unsigned char>::Init(v18 + 128, v38);
          v33 = v32 ^ 1;
          if (!v31)
            v33 = 1;
          if ((v33 & 1) == 0)
            memcpy(*(void **)(v18 + 128), v30, v31);
          if ((v32 & 1) == 0)
          {
LABEL_59:
            v15 = 3;
            goto LABEL_60;
          }
        }
LABEL_37:
        v28 = (unsigned __int8 *)SSL_SESSION_from_bytes((uint64_t)__dst, v38, v13[15]);
        v29 = v28;
        v40 = v28;
        if (v28)
        {
          SHA256(a4, a5, v28 + 68);
          *((_DWORD *)v29 + 16) = 32;
          std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](a2, (SSL_SESSION *)v29);
          v15 = 0;
          goto LABEL_60;
        }
        ERR_clear_error();
LABEL_52:
        v15 = 2;
        goto LABEL_60;
      }
    }
    else if (a5 >= 0x20)
    {
      if (*(_QWORD *)(v24 + 536))
        v27 = bssl::ssl_decrypt_ticket_with_cb((uint64_t)a1, (uint64_t)&__dst, a3, a4, a5);
      else
        v27 = bssl::ssl_decrypt_ticket_with_ticket_keys((uint64_t)a1, (ssl_ctx_st *)&__dst, a4, a5);
      v15 = v27;
      if (v18)
        goto LABEL_35;
    }
    else
    {
      v15 = 2;
      if (v18)
        goto LABEL_35;
    }
LABEL_36:
    if ((_DWORD)v15)
    {
LABEL_60:
      OPENSSL_free(__dst);
      return v15;
    }
    goto LABEL_37;
  }
  return v15;
}

void sub_1B4FCF614(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)va1, 0);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_decrypt_ticket_with_cb(uint64_t a1, uint64_t a2, _BYTE *a3, const unsigned __int8 *a4, unint64_t a5)
{
  __int128 v10;
  __int128 v11;
  int v12;
  uint64_t v13;
  _OWORD v15[6];
  unint64_t v16;
  EVP_CIPHER_CTX a;

  *(_QWORD *)&a.final[16] = *MEMORY[0x1E0C80C00];
  if (a5 <= 0x1F)
    bssl::ssl_decrypt_ticket_with_cb();
  *(_QWORD *)&a.final[8] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&a.flags = v10;
  *(_OWORD *)&a.final_used = v10;
  *(_OWORD *)&a.buf[24] = v10;
  *(_OWORD *)&a.app_data = v10;
  *(_OWORD *)&a.iv[8] = v10;
  *(_OWORD *)&a.buf[8] = v10;
  *(_OWORD *)&a.encrypt = v10;
  *(_OWORD *)&a.oiv[8] = v10;
  *(_OWORD *)&a.cipher = v10;
  EVP_CIPHER_CTX_init(&a);
  v16 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v15[4] = v11;
  v15[5] = v11;
  v15[2] = v11;
  v15[3] = v11;
  v15[0] = v11;
  v15[1] = v11;
  HMAC_CTX_init((HMAC_CTX *)v15);
  v12 = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)a1 + 128) + 536))();
  if (v12 < 0)
  {
    v13 = 3;
  }
  else if (v12)
  {
    if (v12 == 2)
    {
      *a3 = 1;
    }
    else if (v12 != 1)
    {
      __assert_rtn("ssl_decrypt_ticket_with_cb", "extensions.cc", 4317, "cb_ret == 1");
    }
    v13 = bssl::decrypt_ticket_with_cipher_ctx(a2, &a, (HMAC_CTX *)v15, a4, a5);
  }
  else
  {
    v13 = 2;
  }
  HMAC_CTX_cleanup((HMAC_CTX *)v15);
  EVP_CIPHER_CTX_cleanup(&a);
  return v13;
}

void sub_1B4FCF7D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,EVP_CIPHER_CTX *a)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t bssl::ssl_decrypt_ticket_with_ticket_keys(uint64_t a1, ssl_ctx_st *a2, const unsigned __int8 *a3, unint64_t a4)
{
  uint64_t v7;
  const EVP_CIPHER *v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const EVP_MD *v14;
  int v15;
  _BOOL4 v16;
  uint64_t v17;
  pthread_rwlock_t *v19;
  HMAC_CTX ctx;
  __int128 v21;
  unint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a4 <= 0x1F)
    bssl::ssl_decrypt_ticket_with_ticket_keys();
  v7 = *(_QWORD *)(*(_QWORD *)a1 + 128);
  if (!bssl::ssl_ctx_rotate_ticket_encryption_key((bssl *)v7, a2))
    return 3;
  v8 = EVP_aes_128_cbc();
  EVP_CIPHER_iv_length(v8);
  v22 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.key[116] = v9;
  v21 = v9;
  *(_OWORD *)&ctx.key[84] = v9;
  *(_OWORD *)&ctx.key[100] = v9;
  *(_OWORD *)&ctx.key[52] = v9;
  *(_OWORD *)&ctx.key[68] = v9;
  *(_OWORD *)&ctx.key[20] = v9;
  *(_OWORD *)&ctx.key[36] = v9;
  *(_OWORD *)&ctx.key[4] = v9;
  EVP_CIPHER_CTX_init((EVP_CIPHER_CTX *)&ctx.key[4]);
  ctx.o_ctx.md_data = (void *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.i_ctx.md_data = v10;
  *(_OWORD *)&ctx.o_ctx.engine = v10;
  *(_OWORD *)&ctx.md_ctx.md_data = v10;
  *(_OWORD *)&ctx.i_ctx.engine = v10;
  *(_OWORD *)&ctx.md = v10;
  *(_OWORD *)&ctx.md_ctx.engine = v10;
  HMAC_CTX_init(&ctx);
  v19 = (pthread_rwlock_t *)0xAAAAAAAAAAAAAAAALL;
  bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_read),&(CRYPTO_MUTEX_unlock_read)>::MutexLockBase(&v19, (pthread_rwlock_t *)(v7 + 16));
  v11 = *(_QWORD *)(v7 + 520);
  if (v11)
  {
    v12 = 0;
    while (a3[v12] == *(unsigned __int8 *)(v11 + v12))
    {
      if (++v12 == 16)
      {
LABEL_12:
        v14 = EVP_sha256();
        HMAC_Init_ex(&ctx, (const void *)(v11 + 16), 16, v14, 0);
        if (v15)
          v16 = EVP_DecryptInit_ex((EVP_CIPHER_CTX *)&ctx.key[4], v8, 0, (const unsigned __int8 *)(v11 + 32), a3 + 16) != 0;
        else
          v16 = 0;
        v17 = 3;
        goto LABEL_18;
      }
    }
  }
  v11 = *(_QWORD *)(v7 + 528);
  if (v11)
  {
    v13 = 0;
    while (a3[v13] == *(unsigned __int8 *)(v11 + v13))
    {
      if (++v13 == 16)
        goto LABEL_12;
    }
  }
  v16 = 0;
  v17 = 2;
LABEL_18:
  CRYPTO_MUTEX_unlock_read(v19);
  if (v16)
    v17 = bssl::decrypt_ticket_with_cipher_ctx((uint64_t)a2, (EVP_CIPHER_CTX *)&ctx.key[4], &ctx, a3, a4);
  HMAC_CTX_cleanup(&ctx);
  EVP_CIPHER_CTX_cleanup((EVP_CIPHER_CTX *)&ctx.key[4]);
  return v17;
}

void sub_1B4FCFA08(_Unwind_Exception *a1, uint64_t a2, HMAC_CTX *ctx, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t ctxa, uint64_t ctx_8, uint64_t ctx_16, uint64_t ctx_24, uint64_t ctx_32, uint64_t ctx_40, uint64_t ctx_48, uint64_t ctx_56, uint64_t ctx_64, uint64_t ctx_72,uint64_t ctx_80,uint64_t ctx_88,uint64_t ctx_96,uint64_t ctx_104,uint64_t ctx_112)
{
  HMAC_CTX_cleanup((HMAC_CTX *)&ctxa);
  EVP_CIPHER_CTX_cleanup((EVP_CIPHER_CTX *)&ctx_112);
  _Unwind_Resume(a1);
}

uint64_t bssl::tls1_parse_peer_sigalgs(bssl **a1, ssl_st *a2)
{
  uint64_t result;

  if (bssl::ssl_protocol_version(*a1, a2) < 0x303)
    return 1;
  result = CBS_len((uint64_t)a2);
  if (result)
    return bssl::parse_u16_array((__int128 *)&a2->version, (uint64_t)(a1 + 81));
  return result;
}

uint64_t bssl::parse_u16_array(__int128 *a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  void *v9;
  unint64_t v10;
  __int128 v11;

  v11 = *a1;
  if ((CBS_len((uint64_t)&v11) & 1) != 0)
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2600);
    return 0;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v3 = CBS_len((uint64_t)&v11);
    if (bssl::Array<unsigned short>::Init((uint64_t)&v9, v3 >> 1))
    {
      if (v10)
      {
        v4 = 0;
        v5 = 0;
        while (CBS_get_u16((unsigned __int16 **)&v11, (char *)v9 + v4))
        {
          ++v5;
          v4 += 2;
          if (v5 >= v10)
            goto LABEL_7;
        }
        ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2610);
        v7 = 0;
      }
      else
      {
LABEL_7:
        if (CBS_len((uint64_t)&v11))
          __assert_rtn("parse_u16_array", "extensions.cc", 2615, "CBS_len(&copy) == 0");
        OPENSSL_free(*(_QWORD **)a2);
        v6 = v10;
        *(_QWORD *)a2 = v9;
        *(_QWORD *)(a2 + 8) = v6;
        v9 = 0;
        v10 = 0;
        v7 = 1;
      }
    }
    else
    {
      v7 = 0;
    }
    OPENSSL_free(v9);
  }
  return v7;
}

void sub_1B4FCFBFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t bssl::tls1_get_legacy_signature_algorithm(bssl *this, unsigned __int16 *a2, const evp_pkey_st *a3)
{
  int v4;
  __int16 v5;

  v4 = EVP_PKEY_id((uint64_t)a2);
  if (v4 == 6)
  {
    v5 = -255;
    goto LABEL_5;
  }
  if (v4 == 408)
  {
    v5 = 515;
LABEL_5:
    *(_WORD *)this = v5;
    return 1;
  }
  return 0;
}

uint64_t bssl::tls1_choose_signature_algorithm(bssl *this, ssl_st *a2, unsigned __int16 *a3)
{
  _QWORD *v5;
  uint64_t v6;
  const ssl_st *v7;
  int v8;
  __int16 v9;
  const bssl::SSL_HANDSHAKE *v10;
  __int16 *v11;
  uint64_t v12;
  int v13;
  unsigned __int16 *peer_verify_algorithms;
  uint64_t v15;
  uint64_t v16;
  __int16 *v17;
  uint64_t v18;
  int v19;
  uint64_t v21;
  unsigned __int16 *v22;

  v5 = *(_QWORD **)(*((_QWORD *)this + 1) + 32);
  v6 = v5[19];
  if (bssl::ssl_protocol_version(*(bssl **)this, a2) > 0x302)
  {
    if (bssl::ssl_signing_with_dc(this, v7))
    {
      v11 = (__int16 *)(v6 + 8);
      v12 = 1;
    }
    else
    {
      v12 = v5[8];
      if (v12)
      {
        v11 = (__int16 *)v5[7];
      }
      else
      {
        v11 = &bssl::kSignSignatureAlgorithms;
        v12 = 12;
      }
    }
    peer_verify_algorithms = (unsigned __int16 *)bssl::tls1_get_peer_verify_algorithms(this, v10);
    v16 = v15;
    v17 = &v11[v12];
    v18 = 2 * v15;
    while (1)
    {
      v19 = (unsigned __int16)*v11;
      if (bssl::ssl_private_key_supports_signature_algorithm(this, (evp_pkey_st *)(unsigned __int16)*v11) && v16 != 0)
        break;
LABEL_21:
      if (++v11 == v17)
      {
        v13 = 4545;
        goto LABEL_23;
      }
    }
    v21 = v18;
    v22 = peer_verify_algorithms;
    while (v19 != *v22)
    {
      ++v22;
      v21 -= 2;
      if (!v21)
        goto LABEL_21;
    }
    LOWORD(a2->version) = v19;
    return 1;
  }
  v8 = EVP_PKEY_id(*((_QWORD *)this + 190));
  if (v8 == 6)
  {
    v9 = -255;
    goto LABEL_10;
  }
  if (v8 == 408)
  {
    v9 = 515;
LABEL_10:
    LOWORD(a2->version) = v9;
    return 1;
  }
  v13 = 4517;
LABEL_23:
  ERR_put_error(16, 0, 253, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v13);
  return 0;
}

void *bssl::tls1_get_peer_verify_algorithms(bssl *this, const bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 81);
  if (!*((_QWORD *)this + 82) && bssl::ssl_protocol_version(*(bssl **)this, 0) < 0x304)
    return &bssl::tls1_get_peer_verify_algorithms(bssl::SSL_HANDSHAKE const*)::kDefaultPeerAlgorithms;
  return (void *)v2;
}

uint64_t bssl::tls1_verify_channel_id(bssl **a1, uint64_t a2)
{
  bssl *v3;
  EC_GROUP *v4;
  ECDSA_SIG *v5;
  BIGNUM *v6;
  BIGNUM *v7;
  BIGNUM *v8;
  uint64_t v9;
  EC_POINT *v10;
  uint64_t v11;
  unint64_t *v12;
  __int128 v13;
  _OWORD *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  int dgst_len[2];
  EC_POINT *v21;
  EC_KEY *eckey;
  BIGNUM *v23;
  BIGNUM *v24;
  ECDSA_SIG *v25;
  EC_GROUP *v26;
  unint64_t v27[2];
  __int128 v28;
  __int16 v29;
  unsigned __int8 dgst[16];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = *a1;
  v29 = -21846;
  v28 = *(_OWORD *)(a2 + 8);
  v27[0] = 0xAAAAAAAAAAAAAAAALL;
  v27[1] = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u16((unsigned __int16 **)&v28, &v29)
    || !CBS_get_u16_length_prefixed((unsigned __int8 **)&v28, v27)
    || CBS_len((uint64_t)&v28)
    || v29 != 30032
    || CBS_len((uint64_t)v27) != 128)
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4573);
    bssl::ssl_send_alert(v3, (ssl_st *)2, 50);
    return 0;
  }
  v4 = EC_GROUP_new_by_curve_name(415);
  v26 = v4;
  if (!v4)
  {
    ERR_put_error(16, 0, 180, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4580);
    return 0;
  }
  v5 = ECDSA_SIG_new();
  v25 = v5;
  v6 = BN_new();
  v24 = v6;
  v7 = BN_new();
  v8 = v7;
  v23 = v7;
  if (!v5 || !v6 || !v7)
  {
    v11 = 0;
    v18 = 0;
    v23 = 0;
    if (!v7)
      goto LABEL_30;
    goto LABEL_29;
  }
  v9 = CBS_data((uint64_t)v27);
  if (BN_bin2bn((const unsigned __int8 *)v9, 32, v6)
    && BN_bin2bn((const unsigned __int8 *)(v9 + 32), 32, v8)
    && BN_bin2bn((const unsigned __int8 *)(v9 + 64), 32, v5->r)
    && BN_bin2bn((const unsigned __int8 *)(v9 + 96), 32, v5->s))
  {
    eckey = EC_KEY_new();
    v10 = EC_POINT_new(v4);
    v11 = 0;
    v21 = v10;
    if (!eckey || !v10)
      goto LABEL_37;
    if (EC_POINT_set_affine_coordinates_GFp(v4, v10, v6, v8, 0))
    {
      if (EC_KEY_set_group(eckey, v4))
      {
        if (EC_KEY_set_public_key(eckey, v21))
        {
          *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v32 = v13;
          v33 = v13;
          *(_OWORD *)dgst = v13;
          v31 = v13;
          *(_QWORD *)dgst_len = 0xAAAAAAAAAAAAAAAALL;
          if ((bssl::tls1_channel_id_hash(a1, (bssl::SSL_HANDSHAKE *)dgst, (unsigned __int8 *)dgst_len, v12) & 1) != 0)
          {
            if (ECDSA_do_verify(dgst, dgst_len[0], v5, eckey))
            {
              v14 = (_OWORD *)(*((_QWORD *)v3 + 6) + 520);
              v15 = *(_OWORD *)v9;
              v16 = *(_OWORD *)(v9 + 16);
              v17 = *(_OWORD *)(v9 + 48);
              v14[2] = *(_OWORD *)(v9 + 32);
              v14[3] = v17;
              *v14 = v15;
              v14[1] = v16;
              *(_WORD *)(*((_QWORD *)v3 + 6) + 220) |= 0x200u;
              v11 = 1;
LABEL_37:
              std::unique_ptr<ec_point_st,bssl::internal::Deleter>::reset[abi:ne180100](&v21, 0);
              std::unique_ptr<ec_key_st,bssl::internal::Deleter>::reset[abi:ne180100](&eckey, 0);
              goto LABEL_28;
            }
            ERR_put_error(16, 0, 129, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4620);
            bssl::ssl_send_alert(v3, (ssl_st *)2, 51);
          }
        }
      }
    }
    v11 = 0;
    goto LABEL_37;
  }
  v11 = 0;
LABEL_28:
  v23 = 0;
LABEL_29:
  BN_free(v8);
  v18 = v11;
LABEL_30:
  v24 = 0;
  if (v6)
    BN_free(v6);
  v25 = 0;
  if (v5)
    ECDSA_SIG_free(v5);
  v26 = 0;
  EC_GROUP_free(v4);
  return v18;
}

void sub_1B4FD0158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  EC_POINT *v4;
  va_list va;
  EC_KEY *v6;
  va_list va1;
  BIGNUM *v8;
  va_list va2;
  BIGNUM *v10;
  va_list va3;
  ECDSA_SIG *v12;
  va_list va4;
  va_list va5;

  va_start(va5, a3);
  va_start(va4, a3);
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, EC_POINT *);
  va_copy(va2, va1);
  v6 = va_arg(va2, EC_KEY *);
  va_copy(va3, va2);
  v8 = va_arg(va3, BIGNUM *);
  va_copy(va4, va3);
  v10 = va_arg(va4, BIGNUM *);
  va_copy(va5, va4);
  v12 = va_arg(va5, ECDSA_SIG *);
  std::unique_ptr<ec_point_st,bssl::internal::Deleter>::reset[abi:ne180100]((EC_POINT **)va, 0);
  std::unique_ptr<ec_key_st,bssl::internal::Deleter>::reset[abi:ne180100]((EC_KEY **)va1, 0);
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100]((BIGNUM **)va2, 0);
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100]((BIGNUM **)va3, 0);
  std::unique_ptr<ecdsa_sig_st,bssl::internal::Deleter>::reset[abi:ne180100]((ECDSA_SIG **)va4, 0);
  std::unique_ptr<ec_group_st,bssl::internal::Deleter>::reset[abi:ne180100]((EC_GROUP **)va5, 0);
  _Unwind_Resume(a1);
}

uint64_t bssl::tls1_channel_id_hash(bssl **this, bssl::SSL_HANDSHAKE *a2, unsigned __int8 *a3, unint64_t *a4)
{
  bssl *v7;
  uint64_t Hash;
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  size_t len;
  _OWORD data[4];
  SHA256_CTX c;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v7 = *this;
  if (bssl::ssl_protocol_version(*this, (const ssl_st *)a2) < 0x304)
  {
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&c.data[10] = v9;
    *(_OWORD *)&c.data[14] = v9;
    *(_OWORD *)&c.data[6] = v9;
    *(_OWORD *)&c.Nl = v9;
    *(_OWORD *)&c.data[2] = v9;
    *(_OWORD *)c.h = v9;
    *(_OWORD *)&c.h[4] = v9;
    SHA256_Init(&c);
    SHA256_Update(&c, "TLS Channel ID signature", 0x19uLL);
    if (*((_QWORD *)v7 + 13))
    {
      SHA256_Update(&c, "Resumption", 0xBuLL);
      v10 = *((_QWORD *)v7 + 13);
      if (!*(_BYTE *)(v10 + 376))
      {
        ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4697);
        return 0;
      }
      SHA256_Update(&c, (const void *)(v10 + 312), *(unsigned __int8 *)(v10 + 376));
    }
    *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    data[2] = v11;
    data[3] = v11;
    data[0] = v11;
    data[1] = v11;
    len = 0xAAAAAAAAAAAAAAAALL;
    Hash = bssl::SSLTranscript::GetHash((bssl::SSLTranscript *)(this + 53), (unsigned __int8 *)data, &len);
    if ((_DWORD)Hash)
    {
      SHA256_Update(&c, data, len);
      SHA256_Final((unsigned __int8 *)a2, &c);
      *(_QWORD *)a3 = 32;
    }
  }
  else
  {
    *(_QWORD *)c.h = 0;
    *(_QWORD *)&c.h[2] = 0;
    Hash = bssl::tls13_get_cert_verify_signature_input((uint64_t)this, (uint64_t)&c, 2u, 0, 0);
    if ((Hash & 1) != 0)
    {
      SHA256(*(const unsigned __int8 **)c.h, *(size_t *)&c.h[2], (unsigned __int8 *)a2);
      *(_QWORD *)a3 = 32;
    }
    OPENSSL_free(*(_QWORD **)c.h);
  }
  return Hash;
}

void sub_1B4FD03A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

BOOL bssl::tls1_write_channel_id(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t *a4)
{
  __int128 v6;
  const EC_KEY *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  const EC_GROUP *v11;
  const EC_POINT *v12;
  uint64_t *v13;
  __int128 v14;
  _BOOL8 v15;
  _OWORD v17[3];
  uint64_t *v18;
  BIGNUM *v19;
  BIGNUM *v20;
  int dgst_len[2];
  unsigned __int8 dgst[16];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v24 = v6;
  v25 = v6;
  *(_OWORD *)dgst = v6;
  v23 = v6;
  *(_QWORD *)dgst_len = 0xAAAAAAAAAAAAAAAALL;
  if (!bssl::tls1_channel_id_hash((bssl **)a1, (bssl::SSL_HANDSHAKE *)dgst, (unsigned __int8 *)dgst_len, a4))return 0;
  v7 = (const EC_KEY *)EVP_PKEY_get0_EC_KEY(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 120));
  if (!v7)
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4639);
    return 0;
  }
  v8 = BN_new();
  v20 = v8;
  v9 = BN_new();
  v10 = v9;
  v19 = v9;
  if (v8)
  {
    if (!v9)
    {
      v15 = 0;
      v20 = 0;
LABEL_24:
      BN_free(v8);
      return v15;
    }
    v11 = EC_KEY_get0_group(v7);
    v12 = EC_KEY_get0_public_key(v7);
    if (EC_POINT_get_affine_coordinates_GFp(v11, v12, v8, v10, 0)
      && (v13 = (uint64_t *)ECDSA_do_sign(dgst, dgst_len[0], v7), (v18 = v13) != 0))
    {
      *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v17[1] = v14;
      v17[2] = v14;
      v17[0] = v14;
      v15 = CBB_add_u16((uint64_t)a2, 0x7550u)
         && CBB_add_u16_length_prefixed(a2, (uint64_t)v17)
         && BN_bn2cbb_padded((uint64_t)v17, 0x20uLL, (uint64_t)v8)
         && BN_bn2cbb_padded((uint64_t)v17, 0x20uLL, (uint64_t)v10)
         && BN_bn2cbb_padded((uint64_t)v17, 0x20uLL, *v13)
         && BN_bn2cbb_padded((uint64_t)v17, 0x20uLL, v13[1])
         && CBB_flush(a2) != 0;
      v18 = 0;
      ECDSA_SIG_free((ECDSA_SIG *)v13);
    }
    else
    {
      v15 = 0;
    }
    v19 = 0;
  }
  else
  {
    v19 = 0;
    v15 = 0;
    if (!v9)
      return v15;
  }
  BN_free(v10);
  v20 = 0;
  if (v8)
    goto LABEL_24;
  return v15;
}

void sub_1B4FD05E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, int a16, __int16 a17, char a18, char a19, int a20,__int16 a21,char a22,char a23)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t bssl::ssl_is_sct_list_valid(__int128 *a1)
{
  uint64_t result;
  unint64_t v2[2];
  unsigned __int8 *v3[2];
  __int128 v4;

  v4 = *a1;
  v3[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  v3[1] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  result = CBS_get_u16_length_prefixed((unsigned __int8 **)&v4, (unint64_t *)v3);
  if ((_DWORD)result)
  {
    if (CBS_len((uint64_t)&v4))
      return 0;
    result = CBS_len((uint64_t)v3);
    if (result)
    {
      if (!CBS_len((uint64_t)v3))
        return 1;
      while (1)
      {
        v2[0] = 0xAAAAAAAAAAAAAAAALL;
        v2[1] = 0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_u16_length_prefixed(v3, v2) || !CBS_len((uint64_t)v2))
          break;
        if (!CBS_len((uint64_t)v3))
          return 1;
      }
      return 0;
    }
  }
  return result;
}

uint64_t bssl::ext_sni_parse_clienthello()
{
  return 1;
}

uint64_t bssl::ext_sni_add_serverhello(_BYTE *a1, uint64_t a2)
{
  uint64_t result;

  if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)a1 + 48) + 220) & 0x40) != 0 || (a1[1601] & 2) == 0)
    return 1;
  result = CBB_add_u16(a2, 0);
  if ((_DWORD)result)
    return CBB_add_u16(a2, 0) != 0;
  return result;
}

uint64_t bssl::ext_ech_parse_clienthello(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  char v6;

  if (!a3)
    return 1;
  v6 = -86;
  result = CBS_get_u8(a3, &v6);
  if (!(_DWORD)result)
    return result;
  if (v6)
  {
    if (v6 != 1 || CBS_len((uint64_t)a3))
      return 0;
    *(_DWORD *)(a1 + 1600) |= 1u;
  }
  return 1;
}

uint64_t bssl::ext_ech_add_serverhello(uint64_t a1, ssl_st *a2)
{
  bssl *v4;
  __int128 v5;
  uint64_t result;
  _QWORD *v7;
  const void ***v8;
  uint64_t v9;
  _OWORD v10[3];
  _OWORD v11[3];

  v4 = *(bssl **)a1;
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) < 0x304
    || *(_DWORD *)(*((_QWORD *)v4 + 6) + 216) == 1
    || !*(_QWORD *)(a1 + 1552))
  {
    return 1;
  }
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = v5;
  v11[2] = v5;
  v10[2] = v5;
  v11[0] = v5;
  v10[0] = v5;
  v10[1] = v5;
  result = CBB_add_u16((uint64_t)a2, 0xFE0Du);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed((uint64_t *)&a2->version, (uint64_t)v11);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v11, (uint64_t)v10);
      if ((_DWORD)result)
      {
        v7 = *(_QWORD **)(a1 + 1552);
        if (*v7)
        {
          v8 = (const void ***)v7[1];
          v9 = 8 * *v7;
          while (1)
          {
            if (*((_BYTE *)*v8 + 144))
            {
              result = CBB_add_bytes((uint64_t)v10, **v8, (size_t)(*v8)[1]);
              if (!(_DWORD)result)
                break;
            }
            ++v8;
            v9 -= 8;
            if (!v9)
              return CBB_flush((uint64_t *)&a2->version) != 0;
          }
        }
        else
        {
          return CBB_flush((uint64_t *)&a2->version) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ext_ems_parse_clienthello(uint64_t a1, const ssl_st *a2, uint64_t a3)
{
  unsigned int v5;
  uint64_t result;

  v5 = bssl::ssl_protocol_version(*(bssl **)a1, a2);
  result = 1;
  if (a3 && v5 <= 0x303)
  {
    if (CBS_len(a3))
    {
      return 0;
    }
    else
    {
      *(_DWORD *)(a1 + 1600) |= 0x20000u;
      return 1;
    }
  }
  return result;
}

uint64_t bssl::ext_ems_add_serverhello(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if ((*(_BYTE *)(a1 + 1602) & 2) == 0)
    return 1;
  result = CBB_add_u16(a2, 0x17u);
  if ((_DWORD)result)
    return CBB_add_u16(a2, 0) != 0;
  return result;
}

uint64_t bssl::ext_ri_parse_clienthello(bssl **a1, ssl_st *a2, unsigned __int8 **a3)
{
  bssl *v3;
  unsigned int v6;
  uint64_t result;
  unint64_t v8[2];

  v3 = *a1;
  if ((*(_WORD *)(*((_QWORD *)*a1 + 6) + 220) & 0x20) != 0)
    bssl::ext_ri_parse_clienthello();
  v6 = bssl::ssl_protocol_version(*a1, a2);
  result = 1;
  if (a3 && v6 <= 0x303)
  {
    v8[0] = 0xAAAAAAAAAAAAAAAALL;
    v8[1] = 0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_u8_length_prefixed(a3, v8) && !CBS_len((uint64_t)a3))
    {
      if (CBS_len((uint64_t)v8))
      {
        ERR_put_error(16, 0, 202, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 888);
        result = 0;
        LOBYTE(a2->version) = 40;
      }
      else
      {
        *(_WORD *)(*((_QWORD *)v3 + 6) + 220) |= 0x100u;
        return 1;
      }
    }
    else
    {
      ERR_put_error(16, 0, 201, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 881);
      return 0;
    }
  }
  return result;
}

uint64_t bssl::ext_ri_add_serverhello(bssl **a1, const ssl_st *a2)
{
  bssl *v2;
  uint64_t result;

  v2 = *a1;
  if ((*(_WORD *)(*((_QWORD *)v2 + 6) + 220) & 0x20) != 0)
    bssl::ext_ri_add_serverhello();
  if (bssl::ssl_protocol_version(v2, a2) > 0x303)
    return 1;
  result = CBB_add_u16((uint64_t)a2, 0xFF01u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16((uint64_t)a2, 1u);
    if ((_DWORD)result)
      return CBB_add_u8((uint64_t)a2, 0) != 0;
  }
  return result;
}

uint64_t bssl::ext_supported_groups_parse_clienthello(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  uint64_t result;
  __int128 v6;

  if (!a3)
    return 1;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  result = CBS_get_u16_length_prefixed(a3, (unint64_t *)&v6);
  if ((_DWORD)result)
  {
    result = CBS_len((uint64_t)&v6);
    if (result)
    {
      if (CBS_len((uint64_t)a3))
        return 0;
      else
        return bssl::parse_u16_array(&v6, a1 + 664);
    }
  }
  return result;
}

uint64_t bssl::dont_add_serverhello()
{
  return 1;
}

uint64_t bssl::ext_ec_point_parse_clienthello(bssl **a1, ssl_st *a2, unsigned __int8 **a3)
{
  if (bssl::ssl_protocol_version(*a1, a2) <= 0x303)
    return bssl::ext_ec_point_parse_serverhello(a1, a2, a3);
  else
    return 1;
}

uint64_t bssl::ext_ec_point_add_serverhello(uint64_t a1, uint64_t *a2)
{
  if (bssl::ssl_protocol_version(*(bssl **)a1, (const ssl_st *)a2) <= 0x303
    && ((*(_DWORD *)(*(_QWORD *)(a1 + 1568) + 20) | *(_DWORD *)(*(_QWORD *)(a1 + 1568) + 24)) & 2) != 0)
  {
    return bssl::ext_ec_point_add_extension(a2);
  }
  else
  {
    return 1;
  }
}

uint64_t bssl::ignore_parse_clienthello()
{
  return 1;
}

uint64_t bssl::ext_ticket_add_serverhello(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if ((*(_BYTE *)(a1 + 1602) & 1) == 0)
    return 1;
  if ((SSL_get_options(*(_QWORD *)a1) & 0x4000) != 0)
    bssl::ext_ticket_add_serverhello();
  result = CBB_add_u16(a2, 0x23u);
  if ((_DWORD)result)
    return CBB_add_u16(a2, 0) != 0;
  return result;
}

uint64_t bssl::ext_alpn_add_serverhello(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  __int128 v4;
  uint64_t result;
  _OWORD v6[3];
  _OWORD v7[3];
  _OWORD v8[3];

  v2 = *a1;
  if (!*(_QWORD *)(*(_QWORD *)(*a1 + 48) + 504))
    return 1;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v4;
  v8[2] = v4;
  v8[0] = v4;
  v7[1] = v4;
  v7[2] = v4;
  v6[2] = v4;
  v7[0] = v4;
  v6[0] = v4;
  v6[1] = v4;
  result = CBB_add_u16((uint64_t)a2, 0x10u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v8);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        result = CBB_add_u8_length_prefixed((uint64_t *)v7, (uint64_t)v6);
        if ((_DWORD)result)
        {
          result = CBB_add_bytes((uint64_t)v6, *(const void **)(*(_QWORD *)(v2 + 48) + 496), *(_QWORD *)(*(_QWORD *)(v2 + 48) + 504));
          if ((_DWORD)result)
            return CBB_flush(a2) != 0;
        }
      }
    }
  }
  return result;
}

BOOL bssl::ext_ocsp_parse_clienthello(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  int u8;
  _BOOL8 result;
  char v6;

  if (!a3)
    return 1;
  v6 = -86;
  u8 = CBS_get_u8(a3, &v6);
  result = u8 != 0;
  if (u8)
    *(_DWORD *)(a1 + 1600) = *(_DWORD *)(a1 + 1600) & 0xFFFFFF7F | ((v6 == 1) << 7);
  return result;
}

uint64_t bssl::ext_ocsp_add_serverhello(uint64_t a1, const ssl_st *a2)
{
  bssl *v4;
  const ssl_cipher_st *v5;
  uint64_t result;

  v4 = *(bssl **)a1;
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) > 0x303
    || (*(_BYTE *)(a1 + 1600) & 0x80) == 0
    || !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) + 104)
    || (*(_WORD *)(*((_QWORD *)v4 + 6) + 220) & 0x40) != 0
    || !bssl::ssl_cipher_uses_certificate_auth(*(bssl **)(a1 + 1568), v5))
  {
    return 1;
  }
  *(_DWORD *)(a1 + 1600) |= 0x40u;
  result = CBB_add_u16((uint64_t)a2, 5u);
  if ((_DWORD)result)
    return CBB_add_u16((uint64_t)a2, 0) != 0;
  return result;
}

uint64_t bssl::ext_sigalgs_parse_clienthello(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  _OWORD *v5;
  uint64_t result;
  unint64_t v7[2];

  v5 = (_OWORD *)(a1 + 648);
  OPENSSL_free(*(_QWORD **)(a1 + 648));
  *v5 = 0u;
  if (!a3)
    return 1;
  v7[0] = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = 0xAAAAAAAAAAAAAAAALL;
  result = CBS_get_u16_length_prefixed(a3, v7);
  if ((_DWORD)result)
  {
    if (CBS_len((uint64_t)a3))
      return 0;
    else
      return bssl::tls1_parse_peer_sigalgs((bssl **)a1, (ssl_st *)v7);
  }
  return result;
}

uint64_t bssl::ext_npn_parse_clienthello(uint64_t a1, const ssl_st *a2, uint64_t a3)
{
  bssl *v5;
  unsigned int v6;
  uint64_t result;

  v5 = *(bssl **)a1;
  v6 = bssl::ssl_protocol_version(*(bssl **)a1, a2);
  result = 1;
  if (a3 && v6 <= 0x303)
  {
    if (CBS_len(a3))
    {
      return 0;
    }
    else
    {
      if ((*(_WORD *)(*((_QWORD *)v5 + 6) + 220) & 0x20) == 0
        && *(_QWORD *)(*((_QWORD *)v5 + 15) + 576)
        && !SSL_is_dtls((unsigned __int8 **)v5))
      {
        *(_DWORD *)(a1 + 1600) |= 0x8000u;
      }
      return 1;
    }
  }
  return result;
}

uint64_t bssl::ext_npn_add_serverhello(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t result;
  __int128 v6;
  _OWORD v7[3];
  unsigned int v8;
  const void *v9;

  if ((*((_BYTE *)a1 + 1601) & 0x80) == 0)
    return 1;
  v4 = *a1;
  v9 = (const void *)0xAAAAAAAAAAAAAAAALL;
  v8 = -1431655766;
  if ((*(unsigned int (**)(void))(*(_QWORD *)(v4 + 120) + 576))())
  {
    *((_DWORD *)a1 + 400) &= ~0x8000u;
    return 1;
  }
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v6;
  v7[2] = v6;
  v7[0] = v6;
  result = CBB_add_u16((uint64_t)a2, 0x3374u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v7);
    if ((_DWORD)result)
    {
      result = CBB_add_bytes((uint64_t)v7, v9, v8);
      if ((_DWORD)result)
        return CBB_flush(a2) != 0;
    }
  }
  return result;
}

uint64_t bssl::ext_sct_parse_clienthello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3)
    return 1;
  if (CBS_len(a3))
    return 0;
  *(_DWORD *)(a1 + 1600) |= 4u;
  return 1;
}

uint64_t bssl::ext_sct_add_serverhello(uint64_t a1, ssl_st *a2)
{
  bssl *v4;
  __int128 v5;
  uint64_t result;
  const void *v7;
  size_t v8;
  _OWORD v9[3];

  v4 = *(bssl **)a1;
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) > 0x303
    || (*(_WORD *)(*((_QWORD *)v4 + 6) + 220) & 0x40) != 0
    || !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) + 96))
  {
    return 1;
  }
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v5;
  v9[2] = v5;
  v9[0] = v5;
  result = CBB_add_u16((uint64_t)a2, 0x12u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed((uint64_t *)&a2->version, (uint64_t)v9);
    if ((_DWORD)result)
    {
      v7 = (const void *)CRYPTO_BUFFER_data(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) + 96));
      v8 = CRYPTO_BUFFER_len(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) + 96));
      result = CBB_add_bytes((uint64_t)v9, v7, v8);
      if ((_DWORD)result)
        return CBB_flush((uint64_t *)&a2->version) != 0;
    }
  }
  return result;
}

uint64_t bssl::ext_channel_id_parse_clienthello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3)
    return 1;
  if ((*(_WORD *)(*(_QWORD *)(a1 + 8) + 313) & 8) == 0 || SSL_is_dtls(*(unsigned __int8 ***)a1))
    return 1;
  if (!CBS_len(a3))
  {
    *(_DWORD *)(a1 + 1600) |= 0x4000000u;
    return 1;
  }
  return 0;
}

uint64_t bssl::ext_channel_id_add_serverhello(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if ((*(_BYTE *)(a1 + 1603) & 4) == 0)
    return 1;
  result = CBB_add_u16(a2, 0x7550u);
  if ((_DWORD)result)
    return CBB_add_u16(a2, 0) != 0;
  return result;
}

uint64_t bssl::ext_srtp_parse_clienthello(unsigned __int8 ***a1, uint64_t a2, unsigned __int8 **a3)
{
  unsigned __int8 **v4;
  char v5;
  const STACK *srtp_profiles;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  int u16;
  char v16;
  unsigned __int16 v17;
  unsigned __int16 *v18[2];
  unint64_t v19[4];

  if (a3)
  {
    v4 = *a1;
    if (SSL_is_dtls(*a1))
    {
      memset(v19, 170, sizeof(v19));
      if (CBS_get_u16_length_prefixed(a3, &v19[2])
        && (unint64_t)CBS_len((uint64_t)&v19[2]) >= 2
        && CBS_get_u8_length_prefixed(a3, v19)
        && !CBS_len((uint64_t)a3))
      {
        srtp_profiles = (const STACK *)SSL_get_srtp_profiles((uint64_t)v4);
        v8 = sk_num(srtp_profiles);
        if (v8)
        {
          v10 = v8;
          v11 = 0;
          while (2)
          {
            v12 = sk_value(srtp_profiles, v11);
            v18[0] = (unsigned __int16 *)0xAAAAAAAAAAAAAAAALL;
            v18[1] = (unsigned __int16 *)0xAAAAAAAAAAAAAAAALL;
            v13 = CBS_data((uint64_t)&v19[2]);
            v14 = CBS_len((uint64_t)&v19[2]);
            CBS_init(v18, v13, v14);
            while (CBS_len((uint64_t)v18))
            {
              v17 = -21846;
              u16 = CBS_get_u16(v18, &v17);
              v9 = u16 != 0;
              if (!u16)
                goto LABEL_20;
              if (*((_QWORD *)v12 + 1) == v17)
              {
                *((_QWORD *)v4[6] + 75) = v12;
LABEL_20:
                v16 = 0;
                goto LABEL_21;
              }
            }
            if (++v11 != v10)
              continue;
            break;
          }
        }
        v16 = 1;
LABEL_21:
        v5 = v16 | v9;
      }
      else
      {
        ERR_put_error(16, 0, 116, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1823);
        v5 = 0;
      }
    }
    else
    {
      v5 = 1;
    }
  }
  else
  {
    v5 = 1;
  }
  return v5 & 1;
}

uint64_t bssl::ext_srtp_add_serverhello(unsigned __int8 ***a1, uint64_t *a2)
{
  unsigned __int8 **v2;
  __int128 v4;
  uint64_t result;
  _OWORD v6[3];
  _OWORD v7[3];

  v2 = *a1;
  if (!*((_QWORD *)(*a1)[6] + 75))
    return 1;
  if (!SSL_is_dtls(*a1))
    bssl::ext_srtp_add_serverhello();
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v4;
  v7[2] = v4;
  v6[2] = v4;
  v7[0] = v4;
  v6[0] = v4;
  v6[1] = v4;
  result = CBB_add_u16((uint64_t)a2, 0xEu);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v7);
    if ((_DWORD)result)
    {
      result = CBB_add_u16_length_prefixed((uint64_t *)v7, (uint64_t)v6);
      if ((_DWORD)result)
      {
        result = CBB_add_u16((uint64_t)v6, *(unsigned __int16 *)(*((_QWORD *)v2[6] + 75) + 8));
        if ((_DWORD)result)
        {
          result = CBB_add_u8((uint64_t)v7, 0);
          if ((_DWORD)result)
            return CBB_flush(a2) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ext_psk_key_exchange_modes_parse_clienthello(uint64_t a1, _BYTE *a2, unsigned __int8 **a3)
{
  uint64_t result;
  void *v7;
  size_t v8;
  int v9;
  unint64_t v10[2];

  if (!a3)
    return 1;
  v10[0] = 0xAAAAAAAAAAAAAAAALL;
  v10[1] = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_u8_length_prefixed(a3, v10) && CBS_len((uint64_t)v10) && !CBS_len((uint64_t)a3))
  {
    v7 = (void *)CBS_data((uint64_t)v10);
    v8 = CBS_len((uint64_t)v10);
    if (v8)
      v9 = 16 * (memchr(v7, 1, v8) != 0);
    else
      v9 = 0;
    *(_DWORD *)(a1 + 1600) = *(_DWORD *)(a1 + 1600) & 0xFFFFFFEF | v9;
    return 1;
  }
  else
  {
    result = 0;
    *a2 = 50;
  }
  return result;
}

uint64_t bssl::ext_early_data_parse_clienthello(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  uint64_t result;

  if (!a3)
    return 1;
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) >= 0x304)
  {
    if (CBS_len(a3))
    {
      result = 0;
      LOBYTE(a2->version) = 50;
      return result;
    }
    *(_DWORD *)(a1 + 1600) |= 0x1000u;
  }
  return 1;
}

uint64_t bssl::ext_early_data_add_serverhello(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)a1 + 48) + 220) & 0x800) == 0)
    return 1;
  result = CBB_add_u16((uint64_t)a2, 0x2Au);
  if ((_DWORD)result)
  {
    result = CBB_add_u16((uint64_t)a2, 0);
    if ((_DWORD)result)
      return CBB_flush(a2) != 0;
  }
  return result;
}

uint64_t bssl::ext_quic_transport_params_parse_clienthello(_QWORD *a1, ssl_st *a2, uint64_t a3)
{
  return bssl::ext_quic_transport_params_parse_clienthello_impl(a1, a2, a3, 0);
}

uint64_t bssl::ext_quic_transport_params_add_serverhello(_QWORD *a1, uint64_t *a2)
{
  return bssl::ext_quic_transport_params_add_serverhello_impl(a1, a2, 0);
}

uint64_t bssl::ext_quic_transport_params_parse_clienthello_legacy(_QWORD *a1, ssl_st *a2, uint64_t a3)
{
  return bssl::ext_quic_transport_params_parse_clienthello_impl(a1, a2, a3, 1);
}

uint64_t bssl::ext_quic_transport_params_add_serverhello_legacy(_QWORD *a1, uint64_t *a2)
{
  return bssl::ext_quic_transport_params_add_serverhello_impl(a1, a2, 1);
}

uint64_t bssl::cert_compression_parse_clienthello(bssl **a1, uint64_t a2, unsigned __int8 **a3)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int16 *v13;
  const ssl_st *v15;
  uint64_t v16;
  unsigned __int16 *v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  unsigned __int16 v22;
  void *v23;
  size_t v24;
  unsigned __int16 *v25[2];

  if (!a3)
    return 1;
  v5 = *((_QWORD *)*a1 + 15);
  v6 = *(_QWORD *)(v5 + 720);
  v25[0] = (unsigned __int16 *)0xAAAAAAAAAAAAAAAALL;
  v25[1] = (unsigned __int16 *)0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_u8_length_prefixed(a3, (unint64_t *)v25)
    && !CBS_len((uint64_t)a3)
    && CBS_len((uint64_t)v25)
    && (CBS_len((uint64_t)v25) & 1) == 0)
  {
    v9 = CBS_len((uint64_t)v25);
    v23 = 0;
    v24 = 0;
    if (bssl::Array<unsigned short>::Init((uint64_t)&v23, v9 >> 1))
    {
      v10 = 0;
      v11 = v6;
      while (CBS_len((uint64_t)v25))
      {
        v22 = -21846;
        if (!CBS_get_u16(v25, &v22))
          goto LABEL_35;
        *((_WORD *)v23 + v10) = v22;
        if (v6)
        {
          v12 = 0;
          v13 = (unsigned __int16 *)(*(_QWORD *)(v5 + 728) + 16);
          while (*v13 != v22 || *((_QWORD *)v13 - 2) == 0)
          {
            ++v12;
            v13 += 12;
            if (v6 == v12)
              goto LABEL_24;
          }
          if (v12 < v11)
            v11 = v12;
        }
LABEL_24:
        ++v10;
      }
      qsort(v23, v24, 2uLL, (int (__cdecl *)(const void *, const void *))bssl::compare_uint16_t);
      if (v9 < 4)
      {
LABEL_31:
        if (v11 < v6 && bssl::ssl_protocol_version(*a1, v15) >= 0x304)
        {
          *((_DWORD *)a1 + 400) |= 0x200000u;
          *((_WORD *)a1 + 364) = *(_WORD *)(*(_QWORD *)(v5 + 728) + 24 * v11 + 16);
        }
        v7 = 1;
        goto LABEL_36;
      }
      v16 = 2;
      if (v9 >> 1 > 2)
        v16 = v9 >> 1;
      v17 = (unsigned __int16 *)((char *)v23 + 2);
      v18 = *(unsigned __int16 *)v23;
      v19 = v16 - 1;
      while (1)
      {
        v21 = *v17++;
        v20 = v21;
        if (v18 == v21)
          break;
        v18 = v20;
        if (!--v19)
          goto LABEL_31;
      }
    }
LABEL_35:
    v7 = 0;
LABEL_36:
    OPENSSL_free(v23);
    return v7;
  }
  return 0;
}

void sub_1B4FD17F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t bssl::cert_compression_add_serverhello()
{
  return 1;
}

uint64_t bssl::ext_delegated_credential_parse_clienthello(uint64_t a1, const ssl_st *a2, unsigned __int8 **a3)
{
  uint64_t result;
  __int128 v6;

  if (!a3)
    return 1;
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) < 0x304)
    return 1;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  result = CBS_get_u16_length_prefixed(a3, (unint64_t *)&v6);
  if ((_DWORD)result)
  {
    result = CBS_len((uint64_t)&v6);
    if (result)
    {
      if (CBS_len((uint64_t)a3))
      {
        return 0;
      }
      else
      {
        result = bssl::parse_u16_array(&v6, a1 + 680);
        if ((_DWORD)result)
        {
          *(_DWORD *)(a1 + 1600) |= 0x100u;
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t bssl::ext_alps_add_serverhello(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  v2 = a1[192];
  if (!v2 || (*(_BYTE *)(v2 + 448) & 0x40) == 0 || (*(_WORD *)(*(_QWORD *)(*a1 + 48) + 220) & 0x800) != 0)
    return 1;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v5;
  v7[2] = v5;
  v7[0] = v5;
  result = CBB_add_u16((uint64_t)a2, 0x4469u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v7);
    if ((_DWORD)result)
    {
      result = CBB_add_bytes((uint64_t)v7, *(const void **)(a1[192] + 416), *(_QWORD *)(a1[192] + 424));
      if ((_DWORD)result)
        return CBB_flush(a2) != 0;
    }
  }
  return result;
}

uint64_t bssl::ext_client_certificate_type_parse_clienthello(uint64_t a1, _BYTE *a2, unsigned __int8 **a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  unsigned __int8 v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD v11[2];

  if (!a3)
    return 1;
  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    return 1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(v4 + 208);
  if (!v5)
    return 1;
  v11[0] = *(_QWORD *)(v4 + 200);
  v11[1] = v5;
  v9 = 0xAAAAAAAAAAAAAAAALL;
  v10 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u8_length_prefixed(a3, &v9))
    v10 = 0;
  v8 = -86;
  while (CBS_len((uint64_t)&v9) && CBS_get_u8(&v9, &v8))
  {
    if (bssl::ssl_is_certificate_type_allowed(v11, v8))
    {
      *(_BYTE *)(a1 + 731) = v8;
      *(_DWORD *)(a1 + 1600) |= 0x800000u;
      return 1;
    }
  }
  result = 0;
  *a2 = 47;
  return result;
}

uint64_t bssl::ext_client_certificate_type_add_serverhello(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  __int128 v5;
  _OWORD v6[3];

  if ((*(_BYTE *)(a1 + 1602) & 0x80) == 0)
    return 1;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = v5;
  v6[2] = v5;
  v6[0] = v5;
  result = CBB_add_u16((uint64_t)a2, 0x13u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v6);
    if ((_DWORD)result)
    {
      result = CBB_add_u8((uint64_t)v6, *(unsigned __int8 *)(a1 + 731));
      if ((_DWORD)result)
        return CBB_flush(a2) != 0;
    }
  }
  return result;
}

uint64_t bssl::ext_server_certificate_type_parse_clienthello(uint64_t a1, _BYTE *a2, unsigned __int8 **a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  unsigned __int8 v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD v11[2];

  if (!a3)
    return 1;
  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    return 1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(v4 + 176);
  if (!v5)
    return 1;
  v11[0] = *(_QWORD *)(v4 + 168);
  v11[1] = v5;
  v9 = 0xAAAAAAAAAAAAAAAALL;
  v10 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u8_length_prefixed(a3, &v9))
    v10 = 0;
  v8 = -86;
  while (CBS_len((uint64_t)&v9) && CBS_get_u8(&v9, &v8))
  {
    if (bssl::ssl_is_certificate_type_allowed(v11, v8))
    {
      *(_BYTE *)(a1 + 730) = v8;
      *(_DWORD *)(a1 + 1600) |= 0x400000u;
      return 1;
    }
  }
  result = 0;
  *a2 = 47;
  return result;
}

uint64_t bssl::ext_server_certificate_type_add_serverhello(unsigned __int8 *a1, uint64_t *a2)
{
  __int128 v4;
  uint64_t result;
  _OWORD v6[3];

  if ((a1[1602] & 0x40) == 0 || (*(_WORD *)(*(_QWORD *)(*(_QWORD *)a1 + 48) + 220) & 0x40) != 0)
    return 1;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = v4;
  v6[2] = v4;
  v6[0] = v4;
  result = CBB_add_u16((uint64_t)a2, 0x14u);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v6);
    if ((_DWORD)result)
    {
      result = CBB_add_u8((uint64_t)v6, a1[730]);
      if ((_DWORD)result)
        return CBB_flush(a2) != 0;
    }
  }
  return result;
}

uint64_t bssl::ext_ticket_request_parse_clienthello(uint64_t a1, _BYTE *a2, _QWORD *a3)
{
  uint64_t result;
  char v7;
  char v8;

  if (!a3)
    return 1;
  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    return 1;
  v8 = -86;
  v7 = -86;
  if (CBS_get_u8(a3, &v8) && CBS_get_u8(a3, &v7))
  {
    *(_BYTE *)(a1 + 732) = v8;
    *(_BYTE *)(a1 + 733) = v7;
    return 1;
  }
  result = 0;
  *a2 = 47;
  return result;
}

uint64_t bssl::ext_ticket_request_add_serverhello(uint64_t a1, uint64_t *a2)
{
  int v2;
  int v3;
  uint64_t result;
  unsigned int v6;
  __int128 v7;
  unsigned __int8 v8;
  _OWORD v9[3];

  if (*(unsigned __int16 *)(a1 + 30) < 0x304u)
    return 1;
  v2 = *(unsigned __int8 *)(a1 + 732);
  v3 = *(unsigned __int8 *)(a1 + 733);
  if (!(v2 | v3))
    return 1;
  v6 = v3 + v2;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v7;
  v9[2] = v7;
  if (v6 >= 0xFF)
    v8 = -1;
  else
    v8 = v6;
  v9[0] = v7;
  result = CBB_add_u16((uint64_t)a2, 0x3Au);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v9);
    if ((_DWORD)result)
    {
      result = CBB_add_u8((uint64_t)v9, v8);
      if ((_DWORD)result)
        return CBB_flush(a2) != 0;
    }
  }
  return result;
}

uint64_t bssl::ext_quic_transport_params_parse_clienthello_impl(_QWORD *a1, ssl_st *a2, uint64_t a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  void **v10;
  const void *v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  char v15;

  v7 = *a1;
  v8 = *(_QWORD *)(*a1 + 168);
  if (!a3)
  {
    v14 = a1[1];
    if (v8)
    {
      if (((*(_WORD *)(v14 + 313) & 0x200) == 0) == a4)
        return 1;
      result = 0;
      v15 = 109;
    }
    else
    {
      if (!*(_QWORD *)(v14 + 248))
        return 1;
      ERR_put_error(16, 0, 305, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2736);
      result = 0;
      v15 = 80;
    }
LABEL_15:
    LOBYTE(a2->version) = v15;
    return result;
  }
  if (!v8)
  {
    if ((a4 & 1) != 0)
      return 1;
    result = 0;
    v15 = 110;
    goto LABEL_15;
  }
  if (bssl::ssl_protocol_version((bssl *)*a1, a2) != 772)
    bssl::ext_quic_transport_params_parse_clienthello_impl();
  if (((*(_WORD *)(a1[1] + 313) & 0x200) == 0) == a4)
    return 1;
  v10 = (void **)(*(_QWORD *)(v7 + 48) + 584);
  v11 = *(const void **)a3;
  v12 = *(_QWORD *)(a3 + 8);
  result = bssl::Array<unsigned char>::Init((uint64_t)v10, v12);
  if (v12 && (_DWORD)result)
  {
    memcpy(*v10, v11, v12);
    return 1;
  }
  return result;
}

uint64_t bssl::ext_quic_transport_params_add_serverhello_impl(_QWORD *a1, uint64_t *a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t result;
  _OWORD v11[3];

  v5 = *(_QWORD *)(*a1 + 168);
  if (!v5 && (a3 & 1) != 0)
    return 1;
  if (!v5)
    bssl::ext_quic_transport_params_add_serverhello_impl();
  v6 = a1[1];
  if (!*(_QWORD *)(v6 + 248))
  {
    ERR_put_error(16, 0, 305, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2789);
    return 0;
  }
  v7 = *(_WORD *)(v6 + 313) & 0x200;
  if (a3 != v7 >> 9)
    return 1;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = v8;
  v11[2] = v8;
  v11[0] = v8;
  if (v7)
    v9 = 65445;
  else
    v9 = 57;
  result = CBB_add_u16((uint64_t)a2, v9);
  if ((_DWORD)result)
  {
    result = CBB_add_u16_length_prefixed(a2, (uint64_t)v11);
    if ((_DWORD)result)
    {
      result = CBB_add_bytes((uint64_t)v11, *(const void **)(a1[1] + 240), *(_QWORD *)(a1[1] + 248));
      if ((_DWORD)result)
        return CBB_flush(a2) != 0;
    }
  }
  return result;
}

uint64_t bssl::ssl_is_certificate_type_allowed(_QWORD *a1, int a2)
{
  uint64_t result;
  unsigned __int8 v5;

  v5 = -86;
  while (1)
  {
    result = CBS_len((uint64_t)a1);
    if (!result)
      break;
    result = CBS_get_u8(a1, &v5);
    if (!(_DWORD)result)
      break;
    if (v5 == a2)
      return 1;
  }
  return result;
}

uint64_t bssl::decrypt_ticket_with_cipher_ctx(uint64_t a1, EVP_CIPHER_CTX *ctx, HMAC_CTX *a3, const unsigned __int8 *a4, unint64_t a5)
{
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  size_t v13;
  __int128 v14;
  uint64_t v15;
  unint64_t v17;
  unsigned __int8 *v18;
  int v19;
  unint64_t v20;
  int v21;
  int outl;
  unsigned __int8 *out;
  unint64_t v24;
  unsigned __int8 md[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v10 = EVP_CIPHER_CTX_iv_length(ctx);
  v11 = HMAC_size(&a3->md);
  if (a5 < v11 + v10 + 17)
    return 2;
  v12 = v11;
  v13 = a5 - v11;
  if (a5 < v11)
    abort();
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v27 = v14;
  v28 = v14;
  *(_OWORD *)md = v14;
  v26 = v14;
  HMAC_Update(a3, a4, v13);
  HMAC_Final(a3, md, 0);
  if (CRYPTO_memcmp((char *)md, (char *)&a4[a5 - v12], v12))
    return 2;
  v17 = v10 + 16;
  if (v13 < v17)
    abort();
  out = 0;
  v24 = 0;
  if (v13 - v17 <= 0x7FFFFFFE)
  {
    v19 = bssl::Array<unsigned char>::Init((uint64_t)&out, v13 - v17);
    v18 = out;
    if (v19)
    {
      v21 = -1431655766;
      outl = -1431655766;
      if (EVP_DecryptUpdate(ctx, out, &outl, &a4[v17], v13 - v17) && EVP_DecryptFinal_ex(ctx, &out[outl], &v21))
      {
        if (v24 < v21 + (uint64_t)outl)
          abort();
        v24 = v21 + (uint64_t)outl;
        OPENSSL_free(*(_QWORD **)a1);
        v18 = 0;
        v15 = 0;
        v20 = v24;
        *(_QWORD *)a1 = out;
        *(_QWORD *)(a1 + 8) = v20;
        out = 0;
        v24 = 0;
      }
      else
      {
        ERR_clear_error();
        v15 = 2;
        v18 = out;
      }
    }
    else
    {
      v15 = 3;
    }
  }
  else
  {
    v18 = 0;
    v15 = 2;
  }
  OPENSSL_free(v18);
  return v15;
}

void sub_1B4FD2198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  bssl::Array<unsigned char>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

pthread_rwlock_t **bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_read),&(CRYPTO_MUTEX_unlock_read)>::MutexLockBase(pthread_rwlock_t **a1, pthread_rwlock_t *a2)
{
  *a1 = a2;
  if (!a2)
    bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_read),&(CRYPTO_MUTEX_unlock_read)>::MutexLockBase();
  CRYPTO_MUTEX_lock_read(a2);
  return a1;
}

void std::unique_ptr<ec_key_st,bssl::internal::Deleter>::reset[abi:ne180100](EC_KEY **a1, EC_KEY *a2)
{
  EC_KEY *v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    EC_KEY_free(v3);
}

void std::unique_ptr<ec_group_st,bssl::internal::Deleter>::reset[abi:ne180100](EC_GROUP **a1, EC_GROUP *a2)
{
  EC_GROUP *v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    EC_GROUP_free(v3);
}

void std::unique_ptr<ecdsa_sig_st,bssl::internal::Deleter>::reset[abi:ne180100](ECDSA_SIG **a1, ECDSA_SIG *a2)
{
  ECDSA_SIG *v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    ECDSA_SIG_free(v3);
}

void std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100](BIGNUM **a1, BIGNUM *a2)
{
  BIGNUM *v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    BN_free(v3);
}

void std::unique_ptr<ec_point_st,bssl::internal::Deleter>::reset[abi:ne180100](EC_POINT **a1, EC_POINT *a2)
{
  EC_POINT *v3;

  v3 = *a1;
  *a1 = a2;
  if (v3)
    EC_POINT_free(v3);
}

uint64_t bssl::read_v2_client_hello(uint64_t a1, unint64_t *a2, _BYTE *a3, unint64_t a4)
{
  unint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  unint64_t v10;
  uint64_t v12;
  unint64_t v13;
  const void *v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  unint64_t v17;
  size_t v18;
  const void *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  BUF_MEM **v25;
  uint64_t v26;
  BUF_MEM *v27;
  int v28;
  int v29;
  int v30;
  _OWORD v31[3];
  _OWORD v32[3];
  _OWORD v33[3];
  _QWORD v34[2];
  uint64_t v35[4];
  unsigned __int16 v36;
  unsigned __int16 v37;
  unsigned __int16 v38;
  unsigned __int16 v39;
  char v40;
  unsigned __int16 *v41[2];
  _BYTE v42[40];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  if (a4 <= 4)
    bssl::read_v2_client_hello();
  v4 = a3[1] | ((unint64_t)(*a3 & 0x7F) << 8);
  if (v4 > 0x1000)
  {
    v5 = 200;
    v6 = 362;
LABEL_6:
    ERR_put_error(16, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", v6);
    return 4;
  }
  if (v4 <= 2)
  {
    v5 = 199;
    v6 = 369;
    goto LABEL_6;
  }
  v10 = v4 + 2;
  if (a4 < v4 + 2)
  {
    *a2 = v10;
    return 2;
  }
  v12 = *(_QWORD *)(a1 + 48);
  v13 = *(unsigned __int16 *)(v12 + 92);
  if (v13 <= 1)
    abort();
  v14 = (const void *)(*(_QWORD *)(v12 + 80) + *(unsigned __int16 *)(v12 + 88) + 2);
  v15 = (unsigned __int16 *)(v13 - 2);
  if ((unint64_t)v15 >= v4)
    v16 = (unsigned __int16 *)(a3[1] | ((unint64_t)(*a3 & 0x7F) << 8));
  else
    v16 = v15;
  v41[0] = (unsigned __int16 *)(*(_QWORD *)(v12 + 80) + *(unsigned __int16 *)(v12 + 88) + 2);
  v41[1] = v16;
  if (!bssl::SSLTranscript::Update((_QWORD **)(*(_QWORD *)(v12 + 280) + 424), v14, (size_t)v16))
    return 4;
  bssl::ssl_do_msg_callback(a1, 0, 0, (uint64_t)v14, (uint64_t)v16);
  v40 = -86;
  v39 = -21846;
  v38 = -21846;
  v37 = -21846;
  v36 = -21846;
  memset(v35, 170, sizeof(v35));
  v34[0] = 0xAAAAAAAAAAAAAAAALL;
  v34[1] = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u8(v41, &v40)
    || !CBS_get_u16(v41, &v39)
    || !CBS_get_u16(v41, &v38)
    || !CBS_get_u16(v41, &v37)
    || !CBS_get_u16(v41, &v36)
    || !CBS_get_bytes((uint64_t *)v41, &v35[2], v38)
    || !CBS_get_bytes((uint64_t *)v41, v35, v37)
    || !CBS_get_bytes((uint64_t *)v41, v34, v36)
    || CBS_len((uint64_t)v41))
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 402);
    return 4;
  }
  if (v40 != 1)
    bssl::read_v2_client_hello();
  v17 = CBS_len((uint64_t)v34);
  if (v17 >= 0x20)
    v18 = 32;
  else
    v18 = v17;
  memset(v42, 0, 32);
  v19 = (const void *)CBS_data((uint64_t)v34);
  if (v18)
    memcpy(&v42[-v18 + 32], v19, v18);
  v20 = CBS_len((uint64_t)&v35[2]);
  *(_QWORD *)&v21 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v33[2] = v21;
  v33[0] = v21;
  v33[1] = v21;
  CBB_zero(v33);
  *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v32[1] = v22;
  v32[2] = v22;
  v31[2] = v22;
  v32[0] = v22;
  v31[0] = v22;
  v31[1] = v22;
  v23 = *(_QWORD *)(a1 + 48);
  v26 = *(_QWORD *)(v23 + 224);
  v25 = (BUF_MEM **)(v23 + 224);
  v24 = v26;
  if (v26
    || (v27 = BUF_MEM_new(),
        std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v25, v27),
        (v24 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 224)) != 0))
  {
    if (BUF_MEM_reserve(v24, ((((unint64_t)v20 * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64) & 0xFFFFFFFFFFFFFFFELL)+ 43)&& CBB_init_fixed((uint64_t)v33, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 224) + 8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 224) + 16))&& CBB_add_u8((uint64_t)v33, 1u)&& CBB_add_u24_length_prefixed((uint64_t *)v33, (uint64_t)v32)&& CBB_add_u16((uint64_t)v32, v39)&& CBB_add_bytes((uint64_t)v32, v42, 0x20uLL)&& CBB_add_u8((uint64_t)v32, 0)&& CBB_add_u16_length_prefixed((uint64_t *)v32, (uint64_t)v31))
    {
      while (CBS_len((uint64_t)&v35[2]))
      {
        v30 = -1431655766;
        if (!CBS_get_u24(&v35[2], &v30))
        {
          v28 = 449;
          v29 = 137;
          goto LABEL_53;
        }
        if ((v30 & 0xFF0000) == 0 && !CBB_add_u16((uint64_t)v31, (unsigned __int16)v30))
        {
          v28 = 458;
          v29 = 68;
LABEL_53:
          ERR_put_error(16, 0, v29, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", v28);
          goto LABEL_55;
        }
      }
      if (CBB_add_u8((uint64_t)v32, 1u)
        && CBB_add_u8((uint64_t)v32, 0)
        && CBB_finish((uint64_t)v33, 0, *(_QWORD **)(*(_QWORD *)(a1 + 48) + 224)))
      {
        *a2 = v10;
        v7 = 0;
        *(_WORD *)(*(_QWORD *)(a1 + 48) + 220) |= 8u;
        goto LABEL_56;
      }
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 467);
    }
  }
LABEL_55:
  v7 = 4;
LABEL_56:
  CBB_cleanup((uint64_t)v33);
  return v7;
}

void sub_1B4FD2738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  CBB_cleanup((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_choose_tls13_cipher(unsigned __int16 *a1, unsigned __int16 *a2, unsigned int a3, uint64_t a4, int a5)
{
  int is_opaque;
  uint64_t v8;
  int v9;
  unsigned __int8 v10;
  _DWORD *cipher_by_value;
  uint64_t v12;
  bssl *protocol_id;
  unsigned int v14;
  unsigned __int16 v16;
  unsigned __int16 *v17[2];

  v17[0] = a1;
  v17[1] = a2;
  if ((CBS_len((uint64_t)v17) & 1) == 0)
  {
    is_opaque = RSA_is_opaque();
    if (CBS_len((uint64_t)v17))
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v16 = -21846;
        if (!CBS_get_u16(v17, &v16))
          return 0;
        cipher_by_value = SSL_get_cipher_by_value(v16);
        if (cipher_by_value)
        {
          v12 = (uint64_t)cipher_by_value;
          if (SSL_CIPHER_get_min_version(cipher_by_value) <= a3
            && SSL_CIPHER_get_max_version(v12) >= a3)
          {
            protocol_id = (bssl *)SSL_CIPHER_get_protocol_id(v12);
            if (bssl::ssl_tls13_cipher_meets_policy(protocol_id, a5))
            {
              if (is_opaque)
              {
                v14 = 1;
                if (!v9)
                  goto LABEL_14;
              }
              else
              {
                v14 = *(_DWORD *)(v12 + 28) == 64;
                if (!v9)
                  goto LABEL_14;
              }
              if (v14 > v10)
              {
LABEL_14:
                v9 = 1;
                v10 = v14;
                v8 = v12;
              }
            }
          }
        }
        if (!CBS_len((uint64_t)v17))
          return v8;
      }
    }
  }
  return 0;
}

uint64_t bn_abs_sub_part_words(unint64_t *a1, const unint64_t *a2, const unint64_t *a3, unsigned int a4, signed int a5, unint64_t *a6)
{
  unint64_t v12;
  int v13;

  v12 = bn_sub_part_words(a6, a2, a3, a4, a5);
  bn_sub_part_words(a1, a3, a2, a4, -a5);
  if (a5 >= 0)
    v13 = a5;
  else
    v13 = -a5;
  bn_select_words((uint64_t *)a1, -(uint64_t)v12, (uint64_t *)a1, (uint64_t *)a6, (int)(v13 + a4));
  return -(uint64_t)v12;
}

int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
  int result;

  result = bn_mul_impl(r, (BIGNUM *)a, (BIGNUM *)b, ctx);
  if (result)
  {
    bn_set_minimal_width((uint64_t)r);
    return 1;
  }
  return result;
}

uint64_t bn_mul_impl(BIGNUM *a1, BIGNUM *a2, BIGNUM *a3, BN_CTX *ctx)
{
  unint64_t top;
  int v6;
  BOOL v7;
  uint64_t v8;
  BIGNUM *v12;
  int v13;
  unint64_t v14;
  char v15;
  int v16;
  BIGNUM *v18;
  unint64_t **p_d;
  int8x8_t v22;
  int8x8_t v23;

  top = a2->top;
  v6 = a3->top;
  if ((_DWORD)top)
    v7 = v6 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    BN_CTX_start(ctx);
    if (a1 == a2 || (v12 = a1, a1 == a3))
    {
      v12 = BN_CTX_get(ctx);
      if (!v12)
        goto LABEL_45;
    }
    v12->neg = a3->neg ^ a2->neg;
    if ((_DWORD)top == 8 && v6 == 8)
    {
      if (!bn_wexpand(&v12->d, 0x10uLL))
        goto LABEL_45;
      v12->top = 16;
      bn_mul_comba8(v12->d, a2->d, a3->d);
    }
    else
    {
      v13 = v6 + top;
      if ((int)top < 16 || v6 < 16 || (top - v6 + 1) > 2)
      {
        if (!bn_wexpand(&v12->d, v13))
          goto LABEL_45;
        v12->top = v13;
        bn_mul_normal(v12->d, a2->d, top, a3->d, v6);
      }
      else
      {
        if ((int)top - v6 >= 0)
          v14 = top;
        else
          v14 = v6;
        v15 = BN_num_bits_word(v14) - 1;
        v16 = 1 << v15;
        if ((int)top < 1 << v15 && v6 < v16)
          bn_mul_impl_cold_2();
        v18 = BN_CTX_get(ctx);
        if (!v18)
          goto LABEL_45;
        p_d = &v18->d;
        if ((int)top <= v16 && v6 <= v16)
        {
          if (!bn_wexpand(&v18->d, 4 << v15) || !bn_wexpand(&v12->d, 2 << v15))
            goto LABEL_45;
          bn_mul_recursive(v12->d, a2->d, a3->d, v16, (top - v16), (v6 - v16), *p_d, v23);
        }
        else
        {
          if ((int)top < v16 || v6 < v16)
            bn_mul_impl_cold_1();
          if (!bn_wexpand(&v18->d, 8 << v15) || !bn_wexpand(&v12->d, 4 << v15))
            goto LABEL_45;
          bn_mul_part_recursive(v12->d, a2->d, (uint64_t)a3->d, v16, top - v16, v6 - v16, *p_d, v22);
        }
        v12->top = v6 + top;
      }
    }
    if (v12 == a1 || BN_copy(a1, v12))
    {
      v8 = 1;
LABEL_46:
      BN_CTX_end(ctx);
      return v8;
    }
LABEL_45:
    v8 = 0;
    goto LABEL_46;
  }
  BN_zero((uint64_t)a1);
  return 1;
}

uint64_t bn_mul_consttime(BIGNUM *a1, BIGNUM *a2, BIGNUM *a3, BN_CTX *a4)
{
  if (!a2->neg && !a3->neg)
    return bn_mul_impl(a1, a2, a3, a4);
  ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/mul.c", 528);
  return 0;
}

uint64_t bn_sqr_consttime(BIGNUM *a1, BIGNUM *a2, BN_CTX *ctx)
{
  unint64_t top;
  BIGNUM *v7;
  BIGNUM *v8;
  uint64_t v9;
  BIGNUM *v10;
  __int128 v11;
  unint64_t *d;
  unint64_t *v13;
  unint64_t *v14;
  _OWORD v16[16];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  top = a2->top;
  if ((int)top > 0)
  {
    BN_CTX_start(ctx);
    v7 = a1;
    if (a2 == a1)
      v7 = BN_CTX_get(ctx);
    v8 = BN_CTX_get(ctx);
    v9 = 0;
    if (!v7)
      goto LABEL_24;
    v10 = v8;
    if (!v8)
      goto LABEL_24;
    if (!bn_wexpand(&v7->d, 2 * top))
      goto LABEL_23;
    if ((_DWORD)top == 8)
    {
      bn_sqr_comba8(v7->d, a2->d);
      goto LABEL_20;
    }
    if ((_DWORD)top == 4)
    {
      bn_sqr_comba4(v7->d, a2->d);
      goto LABEL_20;
    }
    if (top > 0xF)
    {
      if ((top & ((_DWORD)top - 1)) == 0)
      {
        if (!bn_wexpand(&v10->d, 4 * (int)top))
          goto LABEL_23;
        bn_sqr_recursive(v7->d, a2->d, top, v10->d);
LABEL_20:
        v7->neg = 0;
        v7->top = 2 * top;
        if (v7 == a1 || BN_copy(a1, v7))
        {
          v9 = 1;
LABEL_24:
          BN_CTX_end(ctx);
          return v9;
        }
LABEL_23:
        v9 = 0;
        goto LABEL_24;
      }
      if (!bn_wexpand(&v10->d, 2 * top))
        goto LABEL_23;
      d = v7->d;
      v13 = a2->d;
      v14 = v10->d;
    }
    else
    {
      *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v16[14] = v11;
      v16[15] = v11;
      v16[12] = v11;
      v16[13] = v11;
      v16[10] = v11;
      v16[11] = v11;
      v16[8] = v11;
      v16[9] = v11;
      v16[6] = v11;
      v16[7] = v11;
      v16[4] = v11;
      v16[5] = v11;
      v16[2] = v11;
      v16[3] = v11;
      v16[0] = v11;
      v16[1] = v11;
      d = v7->d;
      v13 = a2->d;
      v14 = (unint64_t *)v16;
    }
    bn_sqr_normal(d, (uint64_t)v13, top, v14);
    goto LABEL_20;
  }
  a1->top = 0;
  a1->neg = 0;
  return 1;
}

unint64_t *bn_sqr_normal(unint64_t *rp, uint64_t a2, unint64_t a3, unint64_t *a4)
{
  unint64_t *v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t *v12;
  const unint64_t *v13;

  if (a3)
  {
    v7 = rp;
    v8 = 2 * a3;
    rp[2 * a3 - 1] = 0;
    *rp = 0;
    v9 = a3 - 1;
    if (v9)
    {
      rp[a3] = bn_mul_words(rp + 1, (const unint64_t *)(a2 + 8), v9, *(_QWORD *)a2);
      if (a3 >= 3)
      {
        v10 = a3 - 2;
        v11 = v7 + 3;
        v12 = &v7[a3 + 1];
        v13 = (const unint64_t *)(a2 + 16);
        do
        {
          *v12++ = bn_mul_add_words(v11, v13, v10, *(v13 - 1));
          v11 += 2;
          ++v13;
          --v10;
        }
        while (v10);
      }
    }
    bn_add_words(v7, v7, v7, v8);
    bn_sqr_words(a4, (const unint64_t *)a2, a3);
    return (unint64_t *)bn_add_words(v7, v7, a4, v8);
  }
  return rp;
}

unint64_t *bn_sqr_recursive(unint64_t *a1, unint64_t *a2, unint64_t a3, unint64_t *a4)
{
  unint64_t *result;
  unint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  char *v18;

  if ((a3 & (a3 - 1)) != 0)
    bn_sqr_recursive_cold_1();
  if (a3 == 8)
    return bn_sqr_comba8(a1, a2);
  if (a3 <= 0xF)
    return bn_sqr_normal(a1, (uint64_t)a2, a3, a4);
  v9 = a3 >> 1;
  v10 = bn_sub_words(&a4[a3 >> 1], a2, &a2[a3 >> 1], a3 >> 1);
  bn_sub_words(a4, &a2[a3 >> 1], a2, a3 >> 1);
  bn_select_words((uint64_t *)a4, -(uint64_t)v10, (uint64_t *)a4, (uint64_t *)&a4[a3 >> 1], a3 >> 1);
  v11 = &a4[a3];
  bn_sqr_recursive(v11, a4, a3 >> 1, &a4[2 * a3]);
  bn_sqr_recursive(a1, a2, a3 >> 1, &a4[2 * a3]);
  bn_sqr_recursive(&a1[a3], &a2[a3 >> 1], a3 >> 1, &a4[2 * a3]);
  v12 = bn_add_words(a4, a1, &a1[a3], a3);
  v13 = v12 - bn_sub_words(v11, a4, v11, a3);
  result = (unint64_t *)bn_add_words(&a1[v9], &a1[v9], v11, a3);
  v14 = (char *)result + v13;
  v15 = a3 + (a3 >> 1);
  if (v15 < 2 * a3)
  {
    v16 = a3 - v9;
    v17 = &a1[v15];
    do
    {
      v18 = &v14[*v17];
      v14 = (char *)__CFADD__(*v17, v14);
      *v17++ = (unint64_t)v18;
      --v16;
    }
    while (v16);
  }
  if (v14)
    bn_sqr_recursive_cold_2();
  return result;
}

int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)
{
  int result;

  result = bn_sqr_consttime(r, (BIGNUM *)a, ctx);
  if (result)
  {
    bn_set_minimal_width((uint64_t)r);
    return 1;
  }
  return result;
}

unint64_t bn_sub_part_words(unint64_t *a1, const unint64_t *a2, const unint64_t *a3, unsigned int num, unsigned int a5)
{
  uint64_t v9;
  unint64_t result;
  unint64_t *v11;
  const unint64_t *v12;
  uint64_t v13;
  unint64_t v14;
  const unint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  if ((num & 0x80000000) != 0)
    bn_sub_part_words_cold_1();
  v9 = num;
  result = bn_sub_words(a1, a2, a3, num);
  if (a5)
  {
    v11 = &a1[v9];
    if ((a5 & 0x80000000) != 0)
    {
      v15 = &a3[v9];
      if ((signed int)-a5 > 1)
        v16 = -a5;
      else
        v16 = 1;
      do
      {
        v17 = *v15++;
        *v11++ = -(uint64_t)(v17 + result);
        result |= v17 + result != 0;
        --v16;
      }
      while (v16);
    }
    else
    {
      v12 = &a2[v9];
      v13 = a5;
      do
      {
        v14 = *v12++;
        *v11++ = v14 - result;
        result = v14 < result;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

void bn_mul_part_recursive(_QWORD *a1, unint64_t *a2, uint64_t a3, signed int a4, unsigned int a5, unsigned int a6, unint64_t *a7, int8x8_t a8)
{
  uint8x8_t v8;
  signed int v11;
  int v15;
  unint64_t *v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  int8x8_t v21;
  uint64_t v22;
  unint64_t *v23;
  const unint64_t *v24;
  uint64_t v25;
  unint64_t *v26;
  int8x8_t v27;
  int8x8_t v28;
  int v29;
  uint64_t v30;
  int v31;
  unint64_t v33;
  const unint64_t *v34;
  unint64_t *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int v40;
  unint64_t *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t *v45;
  unint64_t *v47;
  unint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t *bp;

  a8.i32[0] = a4;
  v8 = (uint8x8_t)vcnt_s8(a8);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.i32[0] != 1)
    bn_mul_part_recursive_cold_5();
  if ((a5 & 0x80000000) != 0 || (v11 = a4 - a5, a4 <= (int)a5))
    bn_mul_part_recursive_cold_1();
  if ((a6 & 0x80000000) != 0 || (int)a6 >= a4)
    bn_mul_part_recursive_cold_2();
  if (a5 - a6 - 2 <= 0xFFFFFFFC)
    bn_mul_part_recursive_cold_3();
  v15 = 2 * a4;
  if (a4 > 7)
  {
    v49 = a4;
    v50 = a4;
    v17 = &a7[2 * a4];
    v48 = &a2[a4];
    v18 = bn_abs_sub_part_words(a7, a2, v48, a5, v11, v17);
    v47 = a7;
    v19 = &a7[a4];
    bp = v17;
    v20 = bn_abs_sub_part_words(v19, (const unint64_t *)(a3 + 8 * a4), (const unint64_t *)a3, a6, a6 - a4, v17);
    v22 = v20 ^ v18;
    if (a4 == 8)
    {
      v23 = a7;
      bn_mul_comba8(bp, a7, v19);
      v24 = a1;
      bn_mul_comba8(a1, a2, (unint64_t *)a3);
      bn_mul_normal(a1 + 16, v48, a5, (unint64_t *)(a3 + 64), a6);
      v25 = v50;
      if (v15 != a6 + a5)
        bzero(&a1[v15 + a5 + a6], 8 * (int)(v15 - (a6 + a5)));
    }
    else
    {
      v44 = v20 ^ v18;
      v45 = (unint64_t *)(a3 + 8 * a4);
      v23 = a7;
      v26 = &a7[4 * v50];
      bn_mul_recursive(bp, v47, v19, a4, 0, 0, &v47[4 * v50], v21);
      v24 = a1;
      bn_mul_recursive(a1, a2, (unint64_t *)a3, a4, 0, 0, v26, v27);
      bzero(&a1[2 * a4], 16 * a4);
      if ((a6 | a5) >= 0x10)
      {
        if ((int)a5 <= (int)a6)
          v29 = a6;
        else
          v29 = a5;
        LODWORD(v30) = a4;
        v25 = v50;
        while (1)
        {
          v31 = (int)v30 >= 0 ? v30 : (int)v30 + 1;
          v30 = (v31 >> 1);
          if ((int)v30 < v29)
            break;
          if (a5 == (_DWORD)v30 || a6 == (_DWORD)v30)
          {
            bn_mul_recursive(&a1[2 * a4], v48, v45, v30, a5 - v30, a6 - v30, v26, v28);
            goto LABEL_30;
          }
        }
        bn_mul_part_recursive(&a1[2 * a4], v48, v45, v30, a5 - v30, a6 - v30, v26);
      }
      else
      {
        bn_mul_normal(&a1[2 * a4], v48, a5, v45, a6);
        v25 = v50;
      }
LABEL_30:
      v22 = v44;
    }
    v33 = bn_add_words(v23, v24, &v24[2 * a4], 2 * a4);
    v34 = v23;
    v35 = &v23[4 * v25];
    v36 = bp;
    v37 = v33 - bn_sub_words(v35, v34, bp, 2 * a4);
    v38 = bn_add_words(v36, v34, v36, 2 * a4) + v33;
    bn_select_words((uint64_t *)v36, v22, (uint64_t *)v35, (uint64_t *)v36, 2 * a4);
    v39 = (~v22 & v38 | v22 & v37) + bn_add_words(&a1[v49], &a1[v49], bp, 2 * a4);
    v40 = 3 * a4;
    if (3 * a4 < 4 * (int)v25)
    {
      v41 = &a1[v40];
      v42 = 4 * v25 - v40;
      do
      {
        v43 = *v41 + v39;
        v39 = __CFADD__(*v41, v39);
        *v41++ = v43;
        --v42;
      }
      while (v42);
    }
    if (v39)
      bn_mul_part_recursive_cold_4();
  }
  else
  {
    bn_mul_normal(a1, a2, (int)(a5 + a4), (unint64_t *)a3, (int)(a6 + a4));
    if (v15 != a6 + a5)
      bzero(&a1[v15 + a5 + a6], (int)(v15 - (a6 + a5)));
  }
}

void bn_mul_recursive(unint64_t *a1, unint64_t *a2, unint64_t *a3, unsigned int a4, uint64_t a5, uint64_t a6, unint64_t *a7, int8x8_t a8)
{
  uint8x8_t v8;
  int v16;
  unsigned int v17;
  unint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unsigned int v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t *v35;
  unint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  int v40[2];

  a8.i32[0] = a4;
  v8 = (uint8x8_t)vcnt_s8(a8);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.i32[0] != 1)
    bn_mul_recursive_cold_4();
  if ((a5 - 1) <= 0xFFFFFFF6)
    bn_mul_recursive_cold_1();
  if ((a6 - 1) <= 0xFFFFFFF6)
    bn_mul_recursive_cold_2();
  v16 = a6 | a5;
  if (a4 != 8 || v16)
  {
    if ((int)a4 > 15)
    {
      v17 = a4 >> 1;
      v39 = a6 + (a4 >> 1);
      v18 = &a7[a4];
      v36 = &a2[a4 >> 1];
      v37 = bn_abs_sub_part_words(a7, a2, v36, a5 + (a4 >> 1), -(int)a5, v18);
      v34 = &a7[v17];
      v35 = &a3[v17];
      v38 = bn_abs_sub_part_words(v34, v35, a3, v39, a6, &a7[a4]) ^ v37;
      *(_QWORD *)v40 = a4 >> 1;
      if (v17 != 8 || v16)
      {
        v22 = &a7[2 * a4];
        bn_mul_recursive(&a7[a4], a7, v34, *(_QWORD *)v40, 0, 0, v22);
        v23 = a3;
        v21 = a4 >> 1;
        bn_mul_recursive(a1, a2, v23, *(_QWORD *)v40, 0, 0, v22);
        v19 = a4;
        v24 = a5;
        v20 = 2 * a4;
        bn_mul_recursive(&a1[a4], v36, v35, *(_QWORD *)v40, v24, a6, v22);
      }
      else
      {
        bn_mul_comba8(&a7[a4], a7, v34);
        bn_mul_comba8(a1, a2, a3);
        v19 = a4;
        bn_mul_comba8(&a1[a4], v36, v35);
        v20 = 2 * a4;
        v21 = a4 >> 1;
      }
      v25 = bn_add_words(a7, a1, &a1[v19], v19);
      v26 = &a7[v20];
      v27 = v25 - bn_sub_words(v26, a7, &a7[a4], v19);
      v28 = bn_add_words(&a7[a4], a7, &a7[a4], v19) + v25;
      bn_select_words((uint64_t *)v18, v38, (uint64_t *)v26, (uint64_t *)v18, v19);
      v29 = (~v38 & v28 | v38 & v27) + bn_add_words(&a1[v21], &a1[v21], v18, v19);
      v30 = v21 + a4;
      if ((int)(v21 + a4) < (int)v20)
      {
        v31 = &a1[v30];
        v32 = v20 - (unint64_t)v30;
        do
        {
          v33 = *v31 + v29;
          v29 = __CFADD__(*v31, v29);
          *v31++ = v33;
          --v32;
        }
        while (v32);
      }
      if (v29)
        bn_mul_recursive_cold_3();
    }
    else
    {
      bn_mul_normal(a1, a2, (int)(a5 + a4), a3, (int)(a6 + a4));
      if ((int)a6 + (int)a5 < 0)
        bzero(&a1[(int)(a5 + 2 * a4 + a6)], 8 * -(a6 + a5));
    }
  }
  else
  {
    bn_mul_comba8(a1, a2, a3);
  }
}

BIO *std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100](BIO **a1, BIO *a2)
{
  BIO *result;

  result = *a1;
  *a1 = a2;
  if (result)
    return (BIO *)BIO_free(result);
  return result;
}

boringssl_concrete_boringssl_session_state *boringssl_session_state_create_from_dispatch_data(void *a1, void *a2)
{
  int *v2;
  id v4;
  NSObject *v5;
  NSObject *v6;
  size_t size;
  size_t v8;
  boringssl_concrete_boringssl_session_state *buffer_from_dispatch_data;
  boringssl_concrete_boringssl_session_state *v10;
  size_t v11;
  size_t v12;
  SSL_SESSION *v13;
  id WeakRetained;
  void *v15;
  _BYTE *v16;
  char v17;
  id v18;
  _BYTE *v19;
  uint64_t v20;
  NSObject *v21;
  _BOOL4 v23;
  id v24;
  void *v25;
  id v26;
  void *v27;
  _BYTE *v28;
  char v29;
  id v30;
  _BYTE *v31;
  _BOOL4 v32;
  NSObject *v33;
  _BYTE v34[28];
  __int16 v35;
  id v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  v5 = a2;
  v6 = v5;
  if (!v5)
    goto LABEL_24;
  size = dispatch_data_get_size(v5);
  if (!size)
    goto LABEL_24;
  v8 = size;
  buffer_from_dispatch_data = (boringssl_concrete_boringssl_session_state *)boringssl_helper_create_buffer_from_dispatch_data(v6);
  v10 = buffer_from_dispatch_data;
  if (!buffer_from_dispatch_data)
    goto LABEL_25;
  if (LOBYTE(buffer_from_dispatch_data->super.isa) != 1)
  {
    if (v4)
    {
      WeakRetained = objc_loadWeakRetained((id *)v4 + 2);
      v2 = &OBJC_IVAR___boringssl_concrete_nw_protocol_boringssl_logging_disabled;
      if (WeakRetained)
      {
        v15 = WeakRetained;
        v16 = objc_loadWeakRetained((id *)v4 + 2);
        v17 = v16[475];

        if ((v17 & 1) != 0)
          goto LABEL_23;
      }
      v18 = objc_loadWeakRetained((id *)v4 + 2);
      if (v18)
      {
        v19 = objc_loadWeakRetained((id *)v4 + 2);
        v20 = (v19[475] & 1) == 0;

      }
      else
      {
        v20 = 1;
      }

    }
    else
    {
      v20 = 1;
    }
    if ((_DWORD)v20 && g_boringssl_log)
    {
      v21 = (id)g_boringssl_log;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        if (v4)
        {
          v20 = (uint64_t)objc_loadWeakRetained((id *)v4 + 2);
          v23 = v20 != 0;
          if (v20)
          {
            v2 = (int *)objc_loadWeakRetained((id *)v4 + 2);
            v25 = (char *)v2 + 391;
          }
          else
          {
            v25 = &unk_1B50022E3;
          }
          v24 = objc_loadWeakRetained((id *)v4 + 2);
        }
        else
        {
          v23 = 0;
          v24 = 0;
          v25 = &unk_1B50022E3;
        }
        *(_DWORD *)v34 = 136446978;
        *(_QWORD *)&v34[4] = "boringssl_session_state_create_from_dispatch_data";
        *(_WORD *)&v34[12] = 1024;
        *(_DWORD *)&v34[14] = 150;
        *(_WORD *)&v34[18] = 2082;
        *(_QWORD *)&v34[20] = v25;
        v35 = 2048;
        v36 = v24;
        _os_log_error_impl(&dword_1B4F6D000, v21, OS_LOG_TYPE_ERROR, "%{public}s(%d) %{public}s[%p] Serialized data is not of the correct content type.", v34, 0x26u);
        if (v4)

        if (v23)
        if (v4)

      }
    }
    goto LABEL_23;
  }
  if (v8 == 1
    || (v11 = BYTE1(buffer_from_dispatch_data->super.isa), v12 = v8 - 2, v12 < v11)
    || v11 >= 0x1D
    || (*(_OWORD *)v34 = xmmword_1B5017E0C,
        *(_OWORD *)&v34[12] = *(__int128 *)((char *)&xmmword_1B5017E0C + 12),
        __memcpy_chk(),
        v12 == v11))
  {
LABEL_23:
    free(v10);
    goto LABEL_24;
  }
  v13 = SSL_SESSION_from_bytes((uint64_t)&v10->super.isa + v11 + 2, v12 - v11, *((_QWORD *)v4 + 51));
  free(v10);
  if (v13)
  {
    v10 = boringssl_session_state_create((uint64_t)v13, v34);
    SSL_SESSION_free(v13);
    goto LABEL_25;
  }
  v26 = objc_loadWeakRetained((id *)v4 + 2);
  if (v26)
  {
    v27 = v26;
    v28 = objc_loadWeakRetained((id *)v4 + 2);
    v29 = v28[475];

    if ((v29 & 1) != 0)
    {
LABEL_24:
      v10 = 0;
      goto LABEL_25;
    }
  }
  v30 = objc_loadWeakRetained((id *)v4 + 2);
  if (v30)
  {
    v31 = objc_loadWeakRetained((id *)v4 + 2);
    v32 = (v31[475] & 1) == 0;

  }
  else
  {
    v32 = 1;
  }

  v10 = 0;
  if (v32 && g_boringssl_log)
  {
    v33 = (id)g_boringssl_log;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      boringssl_session_state_create_from_dispatch_data_cold_1((uint64_t)v4, v33);

    goto LABEL_24;
  }
LABEL_25:

  return v10;
}

_WORD *bssl::SSLBuffer::Clear(_WORD *this)
{
  this[4] = this[5];
  this[6] = 0;
  this[7] = this[8];
  return this;
}

int SHA1_Init(SHA_CTX *c)
{
  *(_OWORD *)&c->data[9] = 0u;
  *(_OWORD *)&c->data[13] = 0u;
  *(_OWORD *)&c->data[1] = 0u;
  *(_OWORD *)&c->data[5] = 0u;
  *(_OWORD *)&c->h0 = xmmword_1B5017430;
  *(_OWORD *)&c->h4 = 0u;
  c->h4 = -1009589776;
  return 1;
}

void SHA1_Transform(SHA_CTX *c, const unsigned __int8 *data)
{
  sha1_block_data_order((int *)c, (unsigned int *)data, 1);
}

uint64_t sha1_block_data_order(int *a1, unsigned int *a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  unint64_t v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  unint64_t v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  unint64_t v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  unint64_t v35;
  int v36;
  int v37;
  unint64_t v38;
  unsigned int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  unsigned int v46;
  int v47;
  unint64_t v48;
  int v49;
  int v50;
  unsigned int v51;
  int v52;
  int v53;
  unint64_t v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  unint64_t v62;
  unsigned int v63;
  int v64;
  int v65;
  int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  int v70;
  unint64_t v71;
  unsigned int v72;
  int v73;
  int v74;
  unsigned int v75;
  int v76;
  unint64_t v77;
  unsigned int v78;
  int v79;
  int v80;
  unsigned int v81;
  int v82;
  int v83;
  unsigned int v84;
  int v85;
  int v86;
  unint64_t v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  unsigned int v96;
  int v97;
  int v98;
  unint64_t v99;
  int v100;
  int v101;
  unsigned int v102;
  int v103;
  int v104;
  unint64_t v105;
  int v106;
  unsigned int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  unint64_t v112;
  int v113;
  unsigned int v114;
  int v115;
  int v116;
  int v117;
  unint64_t v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  unsigned int v129;
  int v130;
  int v131;
  unint64_t v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  int v139;
  int v140;
  int v141;
  unsigned int v142;
  int v143;
  unint64_t v144;
  int v145;
  int v146;
  unsigned int v147;
  int v148;
  int v149;
  unint64_t v150;
  int v151;
  unsigned int v152;
  int v153;
  int v154;
  int v155;
  unint64_t v156;
  int v157;
  unsigned int v158;
  int v159;
  int v160;
  unint64_t v161;
  int v162;
  unsigned int v163;
  int v164;
  int v165;
  int v166;
  unint64_t v167;
  int v168;
  unsigned int v169;
  int v170;
  int v171;
  unint64_t v172;
  int v173;
  unsigned int v174;
  int v175;
  int v176;
  unint64_t v177;
  int v178;
  unsigned int v179;
  int v180;
  int v181;
  int v182;
  unint64_t v183;
  int v184;
  unsigned int v185;
  int v186;
  int v187;
  unint64_t v188;
  int v189;
  unsigned int v190;
  int v191;
  int v192;
  int v193;
  unint64_t v194;
  int v195;
  unsigned int v196;
  int v197;
  int v198;
  int v199;
  unint64_t v200;
  int v201;
  unsigned int v202;
  int v203;
  int v204;
  int v205;
  unint64_t v206;
  int v207;
  unsigned int v208;
  int v209;
  int v210;
  int v211;
  unint64_t v212;
  int v213;
  unsigned int v214;
  int v215;
  int v216;
  unint64_t v217;
  int v218;
  unsigned int v219;
  int v220;
  int v221;
  int v222;
  unint64_t v223;
  int v224;
  unsigned int v225;
  int v226;
  int v227;
  int v228;
  unint64_t v229;
  int v230;
  unsigned int v231;
  int v232;
  unsigned int v233;
  int v234;
  unsigned int v235;
  int v236;
  unint64_t v237;
  int v238;
  int v239;
  int v240;
  int v241;
  unint64_t v242;
  unsigned int v243;
  int v244;
  int v245;
  unint64_t v246;
  int v247;
  unsigned int v248;
  int v249;
  unint64_t v250;
  int v251;
  int v252;
  int v253;
  int v254;
  int v255;
  int v256;
  unint64_t v257;
  int v258;
  unsigned int v259;
  int v260;
  unint64_t v261;
  int v262;
  int v263;
  int v264;
  unint64_t v265;
  unint64_t v266;
  int v267;
  unsigned int v268;
  unint64_t v269;
  int v270;
  int v271;
  int v272;
  unsigned int v273;
  int v274;
  unint64_t v275;
  int v276;
  int v277;
  int v278;
  int v279;
  unint64_t v280;
  unsigned int v281;
  int v282;
  int v283;
  unint64_t v284;
  int v285;
  unsigned int v286;
  int v287;
  unint64_t v288;
  int v289;
  int v290;
  int v291;
  int v292;
  unint64_t v293;
  int v294;
  unsigned int v295;
  int v296;
  unint64_t v297;
  int v298;
  int v299;
  int v300;
  unint64_t v301;
  unint64_t v302;
  int v303;
  unsigned int v304;
  unint64_t v305;
  int v306;
  int v307;
  int v308;
  unsigned int v309;
  int v310;
  unint64_t v311;
  int v312;
  int v313;
  int v314;
  int v315;
  unint64_t v316;
  unsigned int v317;
  int v318;
  int v319;
  unint64_t v320;
  int v321;
  unsigned int v322;
  int v323;
  unint64_t v324;
  int v325;
  int v326;
  int v327;
  int v328;
  unint64_t v329;
  int v330;
  unsigned int v331;
  int v332;
  unint64_t v333;
  int v334;
  int v335;
  int v336;
  unint64_t v337;
  unint64_t v338;
  int v339;
  int v340;
  int v341;
  unint64_t v342;
  int v343;
  int v344;
  int v345;
  int v346;
  int v347;
  unint64_t v348;
  int v349;
  int v350;
  unsigned int v351;
  int v352;
  int v353;
  unint64_t v354;
  unsigned int v355;
  int v356;
  int v357;
  int v358;
  int v359;
  unint64_t v360;
  int v361;
  unsigned int v362;
  int v363;
  int v364;
  unint64_t v365;
  int v366;
  unsigned int v367;
  int v368;
  int v369;
  unint64_t v370;
  int v371;
  unsigned int v372;
  int v373;
  int v374;
  unint64_t v375;
  int v376;
  unsigned int v377;
  int v378;
  int v379;
  int v380;
  unint64_t v381;
  int v382;
  unsigned int v383;
  int v384;
  int v385;
  int v386;
  unint64_t v387;
  int v388;
  unsigned int v389;
  int v390;
  int v391;
  int v392;
  unint64_t v393;
  int v394;
  unsigned int v395;
  int v396;
  int v397;
  int v398;
  unint64_t v399;
  int v400;
  unsigned int v401;
  int v402;
  int v403;
  int v404;
  unint64_t v405;
  int v406;
  unsigned int v407;
  int v408;
  int v409;
  int v410;
  unint64_t v411;
  int v412;
  unsigned int v413;
  int v414;
  int v415;
  int v416;
  int v417;
  unint64_t v418;
  unsigned int v419;
  int v420;
  int v421;
  int v422;
  unint64_t v423;
  int v424;
  unsigned int v425;
  int v426;
  int v427;
  int v428;
  int v429;
  int v430;
  unint64_t v431;
  unsigned int v432;
  int v433;
  int v434;
  int v435;
  unint64_t v436;
  int v437;
  unsigned int v438;
  int v439;
  int v440;
  int v441;
  int v442;
  unint64_t v443;
  unsigned int v444;
  int v445;
  int v446;
  int v447;
  unint64_t v448;
  int v449;
  unsigned int v450;
  int v451;
  uint64_t result;
  int v453;
  unint64_t v454;
  unsigned int v455;
  int v456;
  int v457;
  unint64_t v458;
  int v459;
  unsigned int v460;
  int v461;
  int v462;
  unint64_t v463;
  int v464;
  int v466;
  int v467;
  int v468;
  int v469;
  int v470;
  int v471;
  int v472;
  int v473;
  int v474;
  int v475;
  int v476;
  int v477;
  int v478;
  int v479;
  int v480;
  int v481;
  int v482;
  int v483;
  int v484;
  int v485;
  int v486;
  int v487;
  int v488;
  int v489;
  int v490;
  int v491;
  int v492;
  unsigned int v493;
  int v494;
  int v495;
  int v496;
  unsigned int v497;
  int v498;
  int v499;
  int v500;
  unsigned int v501;
  int v502;
  int v503;
  int v504;
  unsigned int v505;
  int v506;
  int v507;
  int v508;
  unsigned int v509;
  int v510;
  int v511;
  int v512;
  unsigned int v513;
  int v514;
  int v515;
  int v516;
  int v517;
  int v518;
  unsigned int *v519;
  uint64_t v520;
  int v521;
  int v522;
  int v523;

  v3 = a1[3];
  v4 = a1[4];
  v5 = a1[1];
  v6 = a1[2];
  v7 = *a1;
  do
  {
    v522 = v3;
    v523 = v5;
    v521 = v6;
    v517 = v7;
    v518 = v4;
    v519 = a2;
    v520 = a3;
    v8 = v7;
    HIDWORD(v10) = v7;
    LODWORD(v10) = v7;
    v9 = v10 >> 27;
    v11 = v3 & ~v5;
    v12 = bswap32(*a2);
    v13 = v6 & v523;
    HIDWORD(v10) = v523;
    LODWORD(v10) = v523;
    v14 = v10 >> 2;
    v501 = bswap32(a2[1]);
    v15 = v4 + 1518500249 + v9 + (v13 | v11) + v12;
    HIDWORD(v10) = v15;
    LODWORD(v10) = v15;
    v16 = v10 >> 27;
    HIDWORD(v10) = v8;
    LODWORD(v10) = v8;
    v17 = v10 >> 2;
    v18 = v522 + 1518500249 + (v8 & __ROR4__(v523, 2) | v521 & ~v8) + v501 + v16;
    HIDWORD(v10) = v18;
    LODWORD(v10) = v18;
    v19 = v10 >> 27;
    HIDWORD(v10) = v15;
    LODWORD(v10) = v15;
    v20 = v10 >> 2;
    v21 = bswap32(a2[2]);
    v505 = bswap32(a2[3]);
    v23 = __PAIR64__(v18, __ROR4__(v15, 2));
    v22 = v18 & v23;
    LODWORD(v23) = v18;
    v24 = v23 >> 2;
    v25 = v521 + 1518500249 + v21 + (v15 & __ROR4__(v8, 2) | v14 & ~v15) + v19;
    HIDWORD(v23) = v25;
    LODWORD(v23) = v25;
    v26 = v23 >> 27;
    v28 = __PAIR64__(v25, __ROR4__(v18, 2));
    v27 = v25 & v28;
    v29 = bswap32(a2[4]);
    LODWORD(v28) = v25;
    v30 = v28 >> 2;
    v31 = v14 + 1518500249 + v505 + (v22 | v17 & ~v18) + v26;
    HIDWORD(v28) = v31;
    LODWORD(v28) = v31;
    v32 = v17 + 1518500249 + v29 + (v27 | v20 & ~v25) + (v28 >> 27);
    HIDWORD(v28) = v32;
    LODWORD(v28) = v32;
    v33 = v28 >> 27;
    v35 = __PAIR64__(v31, __ROR4__(v25, 2));
    v34 = v31 & v35;
    LODWORD(v35) = v31;
    v36 = v35 >> 2;
    v38 = __PAIR64__(v32, __ROR4__(v31, 2));
    v37 = v32 & v38;
    v39 = bswap32(a2[5]);
    v40 = v34 | v24 & ~v31;
    LODWORD(v38) = v32;
    v41 = v38 >> 2;
    v42 = v20 + v39 + 1518500249 + v40 + v33;
    HIDWORD(v38) = v42;
    LODWORD(v38) = v42;
    v43 = v38 >> 27;
    v513 = bswap32(a2[6]);
    v44 = v37 | v30 & ~v32;
    HIDWORD(v38) = v42;
    LODWORD(v38) = v42;
    v45 = v38 >> 2;
    v46 = v513 + 1518500249 + v24 + v44 + v43;
    HIDWORD(v38) = v46;
    LODWORD(v38) = v46;
    v47 = v38 >> 27;
    v48 = __PAIR64__(v46, __ROR4__(v32, 2));
    v509 = bswap32(a2[7]);
    v49 = v42 & v48 | v36 & ~v42;
    LODWORD(v48) = v46;
    v50 = v48 >> 2;
    v51 = v509 + 1518500249 + v30 + v49 + v47;
    HIDWORD(v48) = v51;
    LODWORD(v48) = v51;
    v52 = v48 >> 27;
    v54 = __PAIR64__(v51, __ROR4__(v46, 2));
    v53 = v51 & v54;
    LODWORD(v54) = v51;
    v55 = v54 >> 2;
    v497 = bswap32(a2[8]);
    v56 = v497 + 1518500249 + v36 + (v46 & __ROR4__(v42, 2) | v41 & ~v46) + v52;
    v57 = bswap32(a2[13]);
    HIDWORD(v54) = v56;
    LODWORD(v54) = v56;
    v58 = v54 >> 27;
    HIDWORD(v54) = v21 ^ v12 ^ v497 ^ v57;
    LODWORD(v54) = HIDWORD(v54);
    v59 = v54 >> 31;
    v60 = HIDWORD(v54);
    v466 = HIDWORD(v54);
    v62 = __PAIR64__(v56, __ROR4__(v51, 2));
    v61 = v56 & v62;
    v63 = bswap32(a2[9]);
    LODWORD(v62) = v56;
    v64 = v62 >> 2;
    v65 = v63 + 1518500249 + v41 + (v53 | v45 & ~v51) + v58;
    HIDWORD(v62) = v65;
    LODWORD(v62) = v65;
    v66 = v62 >> 27;
    v67 = bswap32(a2[10]);
    HIDWORD(v62) = v65;
    LODWORD(v62) = v65;
    v68 = v62 >> 2;
    v69 = v67 + 1518500249 + v45 + (v61 | v50 & ~v56) + v66;
    HIDWORD(v62) = v69;
    LODWORD(v62) = v69;
    v70 = v62 >> 27;
    v71 = __PAIR64__(v69, __ROR4__(v56, 2));
    v72 = bswap32(a2[11]);
    v73 = v65 & v71 | v55 & ~v65;
    LODWORD(v71) = v69;
    v74 = v71 >> 2;
    v75 = v72 + 1518500249 + v50 + v73 + v70;
    HIDWORD(v71) = v75;
    LODWORD(v71) = v75;
    v76 = v71 >> 27;
    v77 = __PAIR64__(v75, __ROR4__(v65, 2));
    v78 = bswap32(a2[12]);
    v79 = v69 & v77 | v64 & ~v69;
    LODWORD(v77) = v75;
    v80 = v77 >> 2;
    v81 = v78 + 1518500249 + v55 + v79 + v76;
    HIDWORD(v77) = v81;
    LODWORD(v77) = v81;
    v82 = v77 >> 27;
    v83 = v75 & __ROR4__(v69, 2);
    v84 = bswap32(a2[14]);
    v85 = v68 & ~v75;
    v87 = __PAIR64__(v81, __ROR4__(v75, 2));
    v86 = v81 & v87;
    v493 = v57;
    LODWORD(v87) = v81;
    v88 = v87 >> 2;
    v89 = v57 + 1518500249 + v64 + (v83 | v85) + v82;
    v90 = v505 ^ v501 ^ v63 ^ v84;
    HIDWORD(v87) = v89;
    LODWORD(v87) = v89;
    v91 = v87 >> 27;
    HIDWORD(v87) = v90;
    LODWORD(v87) = v90;
    v92 = v87 >> 31;
    HIDWORD(v87) = v89;
    LODWORD(v87) = v89;
    v93 = v87 >> 2;
    v94 = v84 + 1518500249 + v68 + (v86 | v74 & ~v81) + v91;
    HIDWORD(v87) = v94;
    LODWORD(v87) = v94;
    v95 = v87 >> 27;
    v96 = bswap32(a2[15]);
    v97 = v29 ^ v21 ^ v67 ^ v96;
    v99 = __PAIR64__(v97, __ROR4__(v89, 2));
    v98 = v94 & v99;
    LODWORD(v99) = v97;
    v468 = v97;
    v471 = v99 >> 31;
    v100 = v89 & __ROR4__(v81, 2) | v80 & ~v89;
    HIDWORD(v99) = v94;
    LODWORD(v99) = v94;
    v101 = v99 >> 2;
    v102 = v96 + 1518500249 + v74 + v100 + v95;
    HIDWORD(v99) = v102;
    LODWORD(v99) = v102;
    v103 = v99 >> 27;
    v105 = __PAIR64__(v102, __ROR4__(v94, 2));
    v104 = v102 & v105;
    LODWORD(v105) = v102;
    v106 = v105 >> 2;
    v107 = v59 + 1518500249 + v80 + (v98 | v88 & ~v94) + v103;
    HIDWORD(v105) = v107;
    LODWORD(v105) = v107;
    v108 = v105 >> 27;
    LODWORD(v105) = v39 ^ v505 ^ v72 ^ __ROR4__(v60, 31);
    v109 = v105;
    HIDWORD(v105) = v105;
    v110 = v105 >> 31;
    v112 = __PAIR64__(v107, __ROR4__(v90, 31));
    v111 = v513 ^ v29 ^ v78 ^ v112;
    LODWORD(v112) = v107;
    v113 = v112 >> 2;
    v114 = v92 + 1518500249 + v88 + (v104 | v93 & ~v102) + v108;
    HIDWORD(v112) = v114;
    LODWORD(v112) = v114;
    v115 = v112 >> 27;
    HIDWORD(v112) = v111;
    LODWORD(v112) = v111;
    v480 = v112 >> 31;
    v116 = v509 ^ v39 ^ v57 ^ __ROR4__(v97, 31);
    v118 = __PAIR64__(v114, __ROR4__(v107, 2));
    v117 = v114 & v118;
    LODWORD(v118) = v114;
    v119 = v118 >> 2;
    HIDWORD(v118) = v116;
    LODWORD(v118) = v116;
    v477 = v118 >> 31;
    v120 = v471 + 1518500249 + v93 + (v107 & __ROR4__(v102, 2) | v101 & ~v107) + v115;
    HIDWORD(v118) = v120;
    LODWORD(v118) = v120;
    v121 = v118 >> 27;
    HIDWORD(v118) = v120;
    LODWORD(v118) = v120;
    v122 = v118 >> 2;
    v123 = v122 ^ __ROR4__(v114, 2);
    v124 = v110 + 1518500249 + v101 + (v117 | v106 & ~v114) + v121;
    HIDWORD(v118) = v124;
    LODWORD(v118) = v124;
    v125 = v118 >> 27;
    HIDWORD(v118) = v124;
    LODWORD(v118) = v124;
    v126 = v118 >> 2;
    LODWORD(v118) = v497 ^ v513 ^ v84 ^ __ROR4__(v109, 31);
    v127 = v118;
    HIDWORD(v118) = v118;
    v474 = v118 >> 31;
    v128 = v126 ^ __ROR4__(v120, 2);
    v129 = v480 + 1859775393 + v106 + (v119 ^ __ROR4__(v107, 2) ^ v120) + v125;
    HIDWORD(v118) = v129;
    LODWORD(v118) = v129;
    v130 = v118 >> 27;
    v132 = __PAIR64__(v129, __ROR4__(v111, 31));
    v131 = v63 ^ v509 ^ v96 ^ v132;
    v133 = v477 + 1859775393 + v113 + (v123 ^ v124);
    LODWORD(v132) = v129;
    v134 = v132 >> 2;
    v135 = v133 + v130;
    HIDWORD(v132) = v135;
    LODWORD(v132) = v135;
    v136 = v132 >> 27;
    v137 = v474 + 1859775393 + v119 + (v128 ^ v129);
    HIDWORD(v132) = v131;
    LODWORD(v132) = v131;
    v487 = v132 >> 31;
    v138 = v134 ^ __ROR4__(v124, 2);
    v139 = v67 ^ v497 ^ __ROR4__(v466, 31) ^ __ROR4__(v116, 31);
    v140 = v137 + v136;
    HIDWORD(v132) = v140;
    LODWORD(v132) = v140;
    v141 = v132 >> 27;
    HIDWORD(v132) = v139;
    LODWORD(v132) = v139;
    v510 = v132 >> 31;
    v142 = v487 + 1859775393 + v122 + (v138 ^ v135) + v141;
    HIDWORD(v132) = v135;
    LODWORD(v132) = v135;
    v143 = v132 >> 2;
    v144 = __PAIR64__(v142, __ROR4__(v129, 2));
    v145 = v510 + 1859775393 + v126 + (v143 ^ v144 ^ v140);
    LODWORD(v144) = v142;
    v147 = v145 + (v144 >> 27);
    LODWORD(v144) = v72 ^ v63 ^ __ROR4__(v90, 31) ^ __ROR4__(v127, 31);
    v146 = v144;
    HIDWORD(v144) = v144;
    v148 = v144 >> 31;
    HIDWORD(v144) = v140;
    LODWORD(v144) = v140;
    v149 = v144 >> 2;
    v150 = __PAIR64__(v147, __ROR4__(v135, 2));
    v151 = v148 + 1859775393 + v134 + (v149 ^ v150 ^ v142);
    LODWORD(v150) = v147;
    v152 = v151 + (v150 >> 27);
    LODWORD(v150) = v78 ^ v67 ^ __ROR4__(v468, 31) ^ __ROR4__(v131, 31);
    v153 = v150;
    HIDWORD(v150) = v150;
    v506 = v150 >> 31;
    v154 = v506 + 1859775393 + v143;
    HIDWORD(v150) = v142;
    LODWORD(v150) = v142;
    v155 = v150 >> 2;
    v156 = __PAIR64__(v152, __ROR4__(v140, 2));
    v157 = v154 + (v155 ^ v156 ^ v147);
    LODWORD(v156) = v152;
    v158 = v157 + (v156 >> 27);
    v159 = v493 ^ v72 ^ __ROR4__(v109, 31) ^ __ROR4__(v139, 31);
    HIDWORD(v156) = v159;
    LODWORD(v156) = v159;
    v502 = v156 >> 31;
    HIDWORD(v156) = v147;
    LODWORD(v156) = v147;
    v160 = v156 >> 2;
    v161 = __PAIR64__(v158, __ROR4__(v142, 2));
    v162 = v502 + 1859775393 + v149 + (v160 ^ v161 ^ v152);
    LODWORD(v161) = v158;
    v163 = v162 + (v161 >> 27);
    LODWORD(v161) = v84 ^ v78 ^ __ROR4__(v111, 31) ^ __ROR4__(v146, 31);
    v164 = v161;
    HIDWORD(v161) = v161;
    v498 = v161 >> 31;
    v165 = v498 + 1859775393 + v155;
    HIDWORD(v161) = v152;
    LODWORD(v161) = v152;
    v166 = v161 >> 2;
    v167 = __PAIR64__(v163, __ROR4__(v147, 2));
    v168 = v165 + (v166 ^ v167 ^ v158);
    LODWORD(v167) = v163;
    v169 = v168 + (v167 >> 27);
    LODWORD(v167) = v96 ^ v493 ^ __ROR4__(v116, 31) ^ __ROR4__(v153, 31);
    v170 = v167;
    HIDWORD(v167) = v167;
    v514 = v167 >> 31;
    HIDWORD(v167) = v158;
    LODWORD(v167) = v158;
    v171 = v167 >> 2;
    v172 = __PAIR64__(v169, __ROR4__(v152, 2));
    v173 = v514 + 1859775393 + v160 + (v171 ^ v172 ^ v163);
    LODWORD(v172) = v169;
    v174 = v173 + (v172 >> 27);
    LODWORD(v172) = v84 ^ __ROR4__(v466, 31) ^ __ROR4__(v127, 31) ^ __ROR4__(v159, 31);
    v175 = v172;
    HIDWORD(v172) = v172;
    v494 = v172 >> 31;
    HIDWORD(v172) = v163;
    LODWORD(v172) = v163;
    v176 = v172 >> 2;
    v177 = __PAIR64__(v174, __ROR4__(v158, 2));
    v178 = v494 + 1859775393 + v166 + (v176 ^ v177 ^ v169);
    LODWORD(v177) = v174;
    v179 = v178 + (v177 >> 27);
    LODWORD(v177) = v96 ^ __ROR4__(v90, 31) ^ __ROR4__(v131, 31) ^ __ROR4__(v164, 31);
    v180 = v177;
    HIDWORD(v177) = v177;
    v490 = v177 >> 31;
    v181 = v490 + 1859775393 + v171;
    HIDWORD(v177) = v169;
    LODWORD(v177) = v169;
    v182 = v177 >> 2;
    v183 = __PAIR64__(v179, __ROR4__(v163, 2));
    v184 = v181 + (v182 ^ v183 ^ v174);
    LODWORD(v183) = v179;
    v185 = v184 + (v183 >> 27);
    LODWORD(v183) = v471 ^ __ROR4__(v466, 31) ^ __ROR4__(v139, 31) ^ __ROR4__(v170, 31);
    v186 = v183;
    HIDWORD(v183) = v183;
    v472 = v183 >> 31;
    HIDWORD(v183) = v174;
    LODWORD(v183) = v174;
    v187 = v183 >> 2;
    v188 = __PAIR64__(v185, __ROR4__(v169, 2));
    v189 = v472 + 1859775393 + v176 + (v187 ^ v188 ^ v179);
    LODWORD(v188) = v185;
    v190 = v189 + (v188 >> 27);
    LODWORD(v188) = v110 ^ __ROR4__(v90, 31) ^ __ROR4__(v146, 31) ^ __ROR4__(v175, 31);
    v191 = v188;
    HIDWORD(v188) = v188;
    v484 = v188 >> 31;
    v192 = v484 + 1859775393 + v182;
    HIDWORD(v188) = v179;
    LODWORD(v188) = v179;
    v193 = v188 >> 2;
    v194 = __PAIR64__(v190, __ROR4__(v174, 2));
    v195 = v192 + (v193 ^ v194 ^ v185);
    LODWORD(v194) = v190;
    v196 = v195 + (v194 >> 27);
    LODWORD(v194) = v480 ^ __ROR4__(v468, 31) ^ __ROR4__(v153, 31) ^ __ROR4__(v180, 31);
    v197 = v194;
    HIDWORD(v194) = v194;
    v481 = v194 >> 31;
    v198 = v481 + 1859775393 + v187;
    HIDWORD(v194) = v185;
    LODWORD(v194) = v185;
    v199 = v194 >> 2;
    v200 = __PAIR64__(v196, __ROR4__(v179, 2));
    v201 = v198 + (v199 ^ v200 ^ v190);
    LODWORD(v200) = v196;
    v202 = v201 + (v200 >> 27);
    LODWORD(v200) = v477 ^ __ROR4__(v109, 31) ^ __ROR4__(v159, 31) ^ __ROR4__(v186, 31);
    HIDWORD(v200) = v200;
    v478 = v200 >> 31;
    v203 = v200;
    v204 = v478 + 1859775393 + v193;
    HIDWORD(v200) = v190;
    LODWORD(v200) = v190;
    v205 = v200 >> 2;
    v206 = __PAIR64__(v202, __ROR4__(v185, 2));
    v207 = v204 + (v205 ^ v206 ^ v196);
    LODWORD(v206) = v202;
    v208 = v207 + (v206 >> 27);
    LODWORD(v206) = v474 ^ __ROR4__(v111, 31) ^ __ROR4__(v164, 31) ^ __ROR4__(v191, 31);
    v209 = v206;
    HIDWORD(v206) = v206;
    v210 = v206 >> 31;
    HIDWORD(v206) = v196;
    LODWORD(v206) = v196;
    v211 = v206 >> 2;
    v212 = __PAIR64__(v208, __ROR4__(v190, 2));
    v213 = v210 + 1859775393 + v199 + (v211 ^ v212 ^ v202);
    LODWORD(v212) = v208;
    v214 = v213 + (v212 >> 27);
    LODWORD(v212) = v487 ^ __ROR4__(v116, 31) ^ __ROR4__(v170, 31) ^ __ROR4__(v197, 31);
    v215 = v212;
    HIDWORD(v212) = v212;
    v475 = v212 >> 31;
    HIDWORD(v212) = v202;
    LODWORD(v212) = v202;
    v216 = v212 >> 2;
    v217 = __PAIR64__(v214, __ROR4__(v196, 2));
    v218 = v475 + 1859775393 + v205 + (v216 ^ v217 ^ v208);
    LODWORD(v217) = v214;
    v219 = v218 + (v217 >> 27);
    v221 = v203;
    LODWORD(v217) = v510 ^ __ROR4__(v127, 31) ^ __ROR4__(v175, 31) ^ __ROR4__(v203, 31);
    v220 = v217;
    HIDWORD(v217) = v217;
    v488 = v217 >> 31;
    HIDWORD(v217) = v208;
    LODWORD(v217) = v208;
    v222 = v217 >> 2;
    v223 = __PAIR64__(v219, __ROR4__(v202, 2));
    v224 = v488 + 1859775393 + v211 + (v222 ^ v223 ^ v214);
    LODWORD(v223) = v219;
    v225 = v224 + (v223 >> 27);
    v226 = v209;
    LODWORD(v223) = v148 ^ __ROR4__(v131, 31) ^ __ROR4__(v180, 31) ^ __ROR4__(v209, 31);
    HIDWORD(v223) = v223;
    v511 = v223 >> 31;
    v227 = v223;
    HIDWORD(v223) = v214;
    LODWORD(v223) = v214;
    v228 = v223 >> 2;
    v229 = __PAIR64__(v225, __ROR4__(v208, 2));
    v230 = v511 + 1859775393 + v216 + (v228 ^ v229 ^ v219);
    LODWORD(v229) = v225;
    v231 = v230 + (v229 >> 27);
    LODWORD(v229) = v506 ^ __ROR4__(v139, 31) ^ __ROR4__(v186, 31) ^ __ROR4__(v215, 31);
    v232 = v229;
    HIDWORD(v229) = v229;
    v507 = v229 >> 31;
    HIDWORD(v229) = v231;
    LODWORD(v229) = v231;
    v233 = v507
         - 1894007588
         + v222
         + ((v225 | __ROR4__(v219, 2)) & __ROR4__(v214, 2) | v225 & __ROR4__(v219, 2))
         + (v229 >> 27);
    LODWORD(v229) = v502 ^ __ROR4__(v146, 31) ^ __ROR4__(v191, 31) ^ __ROR4__(v220, 31);
    HIDWORD(v229) = v229;
    v503 = v229 >> 31;
    v234 = v229;
    HIDWORD(v229) = v233;
    LODWORD(v229) = v233;
    v235 = v503
         - 1894007588
         + v228
         + ((v231 | __ROR4__(v225, 2)) & __ROR4__(v219, 2) | v231 & __ROR4__(v225, 2))
         + (v229 >> 27);
    v237 = __PAIR64__(v219, __ROR4__(v153, 31));
    v236 = v498 ^ v237;
    LODWORD(v237) = v219;
    v238 = v237 >> 2;
    v240 = v227;
    LODWORD(v237) = v236 ^ __ROR4__(v197, 31) ^ __ROR4__(v227, 31);
    v239 = v237;
    HIDWORD(v237) = v237;
    v499 = v237 >> 31;
    v242 = __PAIR64__(v235, __ROR4__(v159, 31));
    v241 = v514 ^ v242;
    LODWORD(v242) = v235;
    v243 = v499
         - 1894007588
         + v238
         + ((v233 | __ROR4__(v231, 2)) & __ROR4__(v225, 2) | v233 & __ROR4__(v231, 2))
         + (v242 >> 27);
    HIDWORD(v242) = v225;
    LODWORD(v242) = v225;
    v244 = v242 >> 2;
    LODWORD(v242) = v241 ^ __ROR4__(v221, 31) ^ __ROR4__(v232, 31);
    v245 = v242;
    HIDWORD(v242) = v242;
    v515 = v242 >> 31;
    v246 = __PAIR64__(v243, __ROR4__(v233, 2));
    v247 = v515 - 1894007588 + v244 + ((v235 | __ROR4__(v233, 2)) & __ROR4__(v231, 2) | v235 & v246);
    LODWORD(v246) = v243;
    v248 = v247 + (v246 >> 27);
    v250 = __PAIR64__(v231, __ROR4__(v226, 31));
    v249 = v494 ^ __ROR4__(v164, 31) ^ v250;
    v251 = v226;
    LODWORD(v250) = v231;
    v252 = v250 >> 2;
    v254 = v234;
    LODWORD(v250) = v249 ^ __ROR4__(v234, 31);
    v253 = v250;
    HIDWORD(v250) = v250;
    v495 = v250 >> 31;
    HIDWORD(v250) = v248;
    LODWORD(v250) = v248;
    v255 = v495
         - 1894007588
         + v252
         + ((v243 | __ROR4__(v235, 2)) & __ROR4__(v233, 2) | v243 & __ROR4__(v235, 2))
         + (v250 >> 27);
    v257 = __PAIR64__(v233, __ROR4__(v239, 31));
    v256 = v490 ^ __ROR4__(v170, 31) ^ __ROR4__(v215, 31) ^ v257;
    LODWORD(v257) = v233;
    v258 = v257 >> 2;
    HIDWORD(v257) = v256;
    LODWORD(v257) = v256;
    v491 = v257 >> 31;
    HIDWORD(v257) = v255;
    LODWORD(v257) = v255;
    v259 = v491
         - 1894007588
         + v258
         + ((v248 | __ROR4__(v243, 2)) & __ROR4__(v235, 2) | v248 & __ROR4__(v243, 2))
         + (v257 >> 27);
    v261 = __PAIR64__(v235, __ROR4__(v220, 31));
    v260 = v472 ^ __ROR4__(v175, 31) ^ v261;
    LODWORD(v261) = v235;
    v262 = v261 >> 2;
    v263 = v260 ^ __ROR4__(v245, 31);
    v265 = __PAIR64__(v263, __ROR4__(v243, 2));
    v264 = (v255 | __ROR4__(v248, 2)) & v265;
    LODWORD(v265) = v263;
    v469 = v265 >> 31;
    v266 = __PAIR64__(v259, __ROR4__(v248, 2));
    v267 = v469 - 1894007588 + v262 + (v264 | v255 & v266);
    LODWORD(v266) = v259;
    v268 = v267 + (v266 >> 27);
    v269 = __PAIR64__(v243, __ROR4__(v255, 2));
    v270 = (v259 | __ROR4__(v255, 2)) & __ROR4__(v248, 2) | v259 & v269;
    LODWORD(v269) = v243;
    v271 = v269 >> 2;
    LODWORD(v269) = v484 ^ __ROR4__(v180, 31) ^ __ROR4__(v240, 31) ^ __ROR4__(v253, 31);
    v272 = v269;
    HIDWORD(v269) = v269;
    v485 = v269 >> 31;
    HIDWORD(v269) = v268;
    LODWORD(v269) = v268;
    v273 = v485 - 1894007588 + v271 + v270 + (v269 >> 27);
    v275 = __PAIR64__(v248, __ROR4__(v186, 31));
    v274 = v481 ^ v275;
    LODWORD(v275) = v248;
    v276 = v275 >> 2;
    LODWORD(v275) = v274 ^ __ROR4__(v232, 31) ^ __ROR4__(v256, 31);
    v277 = v275;
    HIDWORD(v275) = v275;
    v482 = v275 >> 31;
    v278 = v482 - 1894007588 + v276 + ((v268 | __ROR4__(v259, 2)) & __ROR4__(v255, 2) | v268 & __ROR4__(v259, 2));
    v280 = __PAIR64__(v273, __ROR4__(v191, 31));
    v279 = v478 ^ v280;
    LODWORD(v280) = v273;
    v281 = v278 + (v280 >> 27);
    HIDWORD(v280) = v255;
    LODWORD(v280) = v255;
    v282 = v280 >> 2;
    LODWORD(v280) = v279 ^ __ROR4__(v234, 31) ^ __ROR4__(v263, 31);
    v283 = v280;
    HIDWORD(v280) = v280;
    v479 = v280 >> 31;
    v284 = __PAIR64__(v281, __ROR4__(v268, 2));
    v285 = v479 - 1894007588 + v282 + ((v273 | __ROR4__(v268, 2)) & __ROR4__(v259, 2) | v273 & v284);
    LODWORD(v284) = v281;
    v286 = v285 + (v284 >> 27);
    v288 = __PAIR64__(v259, __ROR4__(v239, 31));
    v287 = v210 ^ __ROR4__(v197, 31) ^ v288;
    LODWORD(v288) = v259;
    v289 = v288 >> 2;
    LODWORD(v288) = v287 ^ __ROR4__(v272, 31);
    v290 = v288;
    HIDWORD(v288) = v288;
    v473 = v288 >> 31;
    HIDWORD(v288) = v286;
    LODWORD(v288) = v286;
    v291 = v473
         - 1894007588
         + v289
         + ((v281 | __ROR4__(v273, 2)) & __ROR4__(v268, 2) | v281 & __ROR4__(v273, 2))
         + (v288 >> 27);
    v293 = __PAIR64__(v268, __ROR4__(v277, 31));
    v292 = v475 ^ __ROR4__(v221, 31) ^ __ROR4__(v245, 31) ^ v293;
    LODWORD(v293) = v268;
    v294 = v293 >> 2;
    HIDWORD(v293) = v292;
    LODWORD(v293) = v292;
    v476 = v293 >> 31;
    HIDWORD(v293) = v291;
    LODWORD(v293) = v291;
    v295 = v476
         - 1894007588
         + v294
         + ((v286 | __ROR4__(v281, 2)) & __ROR4__(v273, 2) | v286 & __ROR4__(v281, 2))
         + (v293 >> 27);
    v297 = __PAIR64__(v273, __ROR4__(v253, 31));
    v296 = v488 ^ __ROR4__(v251, 31) ^ v297;
    LODWORD(v297) = v273;
    v298 = v297 >> 2;
    v299 = v296 ^ __ROR4__(v283, 31);
    v301 = __PAIR64__(v299, __ROR4__(v281, 2));
    v300 = (v291 | __ROR4__(v286, 2)) & v301;
    LODWORD(v301) = v299;
    v489 = v301 >> 31;
    v302 = __PAIR64__(v295, __ROR4__(v286, 2));
    v303 = v489 - 1894007588 + v298 + (v300 | v291 & v302);
    LODWORD(v302) = v295;
    v304 = v303 + (v302 >> 27);
    v305 = __PAIR64__(v281, __ROR4__(v291, 2));
    v306 = (v295 | __ROR4__(v291, 2)) & __ROR4__(v286, 2) | v295 & v305;
    LODWORD(v305) = v281;
    v307 = v305 >> 2;
    LODWORD(v305) = v511 ^ __ROR4__(v215, 31) ^ __ROR4__(v256, 31) ^ __ROR4__(v290, 31);
    v308 = v305;
    HIDWORD(v305) = v305;
    v512 = v305 >> 31;
    HIDWORD(v305) = v304;
    LODWORD(v305) = v304;
    v309 = v512 - 1894007588 + v307 + v306 + (v305 >> 27);
    v311 = __PAIR64__(v286, __ROR4__(v220, 31));
    v310 = v507 ^ v311;
    LODWORD(v311) = v286;
    v312 = v311 >> 2;
    v313 = v263;
    LODWORD(v311) = v310 ^ __ROR4__(v263, 31) ^ __ROR4__(v292, 31);
    v314 = v311;
    HIDWORD(v311) = v311;
    v508 = v311 >> 31;
    v316 = __PAIR64__(v309, __ROR4__(v240, 31));
    v315 = v503 ^ v316;
    LODWORD(v316) = v309;
    v317 = v508
         - 1894007588
         + v312
         + ((v304 | __ROR4__(v295, 2)) & __ROR4__(v291, 2) | v304 & __ROR4__(v295, 2))
         + (v316 >> 27);
    HIDWORD(v316) = v291;
    LODWORD(v316) = v291;
    v318 = v316 >> 2;
    LODWORD(v316) = v315 ^ __ROR4__(v272, 31) ^ __ROR4__(v299, 31);
    v319 = v316;
    HIDWORD(v316) = v316;
    v504 = v316 >> 31;
    v320 = __PAIR64__(v317, __ROR4__(v304, 2));
    v321 = v504 - 1894007588 + v318 + ((v309 | __ROR4__(v304, 2)) & __ROR4__(v295, 2) | v309 & v320);
    LODWORD(v320) = v317;
    v322 = v321 + (v320 >> 27);
    v324 = __PAIR64__(v295, __ROR4__(v277, 31));
    v323 = v499 ^ __ROR4__(v232, 31) ^ v324;
    LODWORD(v324) = v295;
    v325 = v324 >> 2;
    LODWORD(v324) = v323 ^ __ROR4__(v308, 31);
    v326 = v324;
    HIDWORD(v324) = v324;
    v500 = v324 >> 31;
    HIDWORD(v324) = v322;
    LODWORD(v324) = v322;
    v327 = v500
         - 1894007588
         + v325
         + ((v317 | __ROR4__(v309, 2)) & __ROR4__(v304, 2) | v317 & __ROR4__(v309, 2))
         + (v324 >> 27);
    v329 = __PAIR64__(v304, __ROR4__(v314, 31));
    v328 = v515 ^ __ROR4__(v254, 31) ^ __ROR4__(v283, 31) ^ v329;
    LODWORD(v329) = v304;
    v330 = v329 >> 2;
    HIDWORD(v329) = v328;
    LODWORD(v329) = v328;
    v516 = v329 >> 31;
    HIDWORD(v329) = v327;
    LODWORD(v329) = v327;
    v331 = v516
         - 1894007588
         + v330
         + ((v322 | __ROR4__(v317, 2)) & __ROR4__(v309, 2) | v322 & __ROR4__(v317, 2))
         + (v329 >> 27);
    v333 = __PAIR64__(v309, __ROR4__(v290, 31));
    v332 = v495 ^ __ROR4__(v239, 31) ^ v333;
    LODWORD(v333) = v309;
    v334 = v333 >> 2;
    v335 = v332 ^ __ROR4__(v319, 31);
    v337 = __PAIR64__(v335, __ROR4__(v317, 2));
    v336 = (v327 | __ROR4__(v322, 2)) & v337;
    LODWORD(v337) = v335;
    v496 = v337 >> 31;
    v338 = __PAIR64__(v331, __ROR4__(v322, 2));
    v339 = v496 - 1894007588 + v334 + (v336 | v327 & v338);
    LODWORD(v338) = v331;
    v340 = v339 + (v338 >> 27);
    v341 = v491 ^ __ROR4__(v245, 31);
    v342 = __PAIR64__(v317, __ROR4__(v327, 2));
    v343 = (v331 | __ROR4__(v327, 2)) & __ROR4__(v322, 2) | v331 & v342;
    LODWORD(v342) = v317;
    v344 = v342 >> 2;
    LODWORD(v342) = v341 ^ __ROR4__(v292, 31) ^ __ROR4__(v326, 31);
    v345 = v342;
    HIDWORD(v342) = v342;
    v467 = v342 >> 31;
    v346 = v467 - 1894007588 + v344 + v343;
    v348 = __PAIR64__(v322, __ROR4__(v253, 31));
    v347 = v469 ^ v348;
    LODWORD(v348) = v322;
    v349 = v348 >> 2;
    v350 = v347 ^ __ROR4__(v299, 31) ^ __ROR4__(v328, 31);
    HIDWORD(v348) = v350;
    LODWORD(v348) = v350;
    v470 = v348 >> 31;
    HIDWORD(v348) = v340;
    LODWORD(v348) = v340;
    v351 = v346 + (v348 >> 27);
    HIDWORD(v348) = v331;
    LODWORD(v348) = v331;
    v352 = v348 >> 2;
    v354 = __PAIR64__(v351, __ROR4__(v256, 31));
    v353 = v485 ^ v354;
    LODWORD(v354) = v351;
    v355 = v470 - 899497514 + v349 + (v352 ^ __ROR4__(v327, 2) ^ v340) + (v354 >> 27);
    HIDWORD(v354) = v327;
    LODWORD(v354) = v327;
    v356 = v354 >> 2;
    v357 = v353 ^ __ROR4__(v308, 31) ^ __ROR4__(v335, 31);
    HIDWORD(v354) = v357;
    LODWORD(v354) = v357;
    v358 = v354 >> 31;
    HIDWORD(v354) = v340;
    LODWORD(v354) = v340;
    v359 = v354 >> 2;
    v360 = __PAIR64__(v355, __ROR4__(v331, 2));
    v361 = v358 - 899497514 + v356 + (v359 ^ v360 ^ v351);
    LODWORD(v360) = v355;
    v362 = v361 + (v360 >> 27);
    LODWORD(v360) = v482 ^ __ROR4__(v313, 31) ^ __ROR4__(v314, 31) ^ __ROR4__(v345, 31);
    v363 = v360;
    HIDWORD(v360) = v360;
    v492 = v360 >> 31;
    HIDWORD(v360) = v351;
    LODWORD(v360) = v351;
    v364 = v360 >> 2;
    v365 = __PAIR64__(v362, __ROR4__(v340, 2));
    v366 = v492 - 899497514 + v352 + (v364 ^ v365 ^ v355);
    LODWORD(v365) = v362;
    v367 = v366 + (v365 >> 27);
    LODWORD(v365) = v479 ^ __ROR4__(v272, 31) ^ __ROR4__(v319, 31) ^ __ROR4__(v350, 31);
    v368 = v365;
    HIDWORD(v365) = v365;
    v483 = v365 >> 31;
    HIDWORD(v365) = v355;
    LODWORD(v365) = v355;
    v369 = v365 >> 2;
    v370 = __PAIR64__(v367, __ROR4__(v351, 2));
    v371 = v483 - 899497514 + v359 + (v369 ^ v370 ^ v362);
    LODWORD(v370) = v367;
    v372 = v371 + (v370 >> 27);
    LODWORD(v370) = v473 ^ __ROR4__(v277, 31) ^ __ROR4__(v326, 31) ^ __ROR4__(v357, 31);
    v373 = v370;
    HIDWORD(v370) = v370;
    v486 = v370 >> 31;
    HIDWORD(v370) = v362;
    LODWORD(v370) = v362;
    v374 = v370 >> 2;
    v375 = __PAIR64__(v372, __ROR4__(v355, 2));
    v376 = v486 - 899497514 + v364 + (v374 ^ v375 ^ v367);
    LODWORD(v375) = v372;
    v377 = v376 + (v375 >> 27);
    LODWORD(v375) = v476 ^ __ROR4__(v283, 31) ^ __ROR4__(v328, 31) ^ __ROR4__(v363, 31);
    v378 = v375;
    HIDWORD(v375) = v375;
    v379 = v375 >> 31;
    HIDWORD(v375) = v367;
    LODWORD(v375) = v367;
    v380 = v375 >> 2;
    v381 = __PAIR64__(v377, __ROR4__(v362, 2));
    v382 = v379 - 899497514 + v369 + (v380 ^ v381 ^ v372);
    LODWORD(v381) = v377;
    v383 = v382 + (v381 >> 27);
    LODWORD(v381) = v489 ^ __ROR4__(v290, 31) ^ __ROR4__(v335, 31) ^ __ROR4__(v368, 31);
    v384 = v381;
    HIDWORD(v381) = v381;
    v385 = (v381 >> 31) - 899497514;
    HIDWORD(v381) = v372;
    LODWORD(v381) = v372;
    v386 = v381 >> 2;
    v387 = __PAIR64__(v383, __ROR4__(v367, 2));
    v388 = v385 + v374 + (v386 ^ v387 ^ v377);
    LODWORD(v387) = v383;
    v389 = v388 + (v387 >> 27);
    LODWORD(v387) = v512 ^ __ROR4__(v292, 31) ^ __ROR4__(v345, 31) ^ __ROR4__(v373, 31);
    v390 = v387;
    HIDWORD(v387) = v387;
    v391 = (v387 >> 31) - 899497514 + v380;
    HIDWORD(v387) = v377;
    LODWORD(v387) = v377;
    v392 = v387 >> 2;
    v393 = __PAIR64__(v389, __ROR4__(v372, 2));
    v394 = v391 + (v392 ^ v393 ^ v383);
    LODWORD(v393) = v389;
    v395 = v394 + (v393 >> 27);
    v396 = v508 ^ __ROR4__(v299, 31) ^ __ROR4__(v350, 31) ^ __ROR4__(v378, 31);
    HIDWORD(v393) = v396;
    LODWORD(v393) = v396;
    v397 = (v393 >> 31) - 899497514;
    HIDWORD(v393) = v383;
    LODWORD(v393) = v383;
    v398 = v393 >> 2;
    v399 = __PAIR64__(v395, __ROR4__(v377, 2));
    v400 = v397 + v386 + (v398 ^ v399 ^ v389);
    LODWORD(v399) = v395;
    v401 = v400 + (v399 >> 27);
    LODWORD(v399) = v504 ^ __ROR4__(v308, 31) ^ __ROR4__(v357, 31) ^ __ROR4__(v384, 31);
    v402 = v399;
    HIDWORD(v399) = v399;
    v403 = (v399 >> 31) - 899497514 + v392;
    HIDWORD(v399) = v389;
    LODWORD(v399) = v389;
    v404 = v399 >> 2;
    v405 = __PAIR64__(v401, __ROR4__(v383, 2));
    v406 = v403 + (v404 ^ v405 ^ v395);
    LODWORD(v405) = v401;
    v407 = v406 + (v405 >> 27);
    LODWORD(v405) = v500 ^ __ROR4__(v314, 31) ^ __ROR4__(v363, 31) ^ __ROR4__(v390, 31);
    v408 = v405;
    HIDWORD(v405) = v405;
    v409 = (v405 >> 31) - 899497514;
    HIDWORD(v405) = v395;
    LODWORD(v405) = v395;
    v410 = v405 >> 2;
    v411 = __PAIR64__(v407, __ROR4__(v389, 2));
    v412 = v409 + v398 + (v410 ^ v411 ^ v401);
    LODWORD(v411) = v407;
    v413 = v412 + (v411 >> 27);
    v414 = v516 ^ __ROR4__(v319, 31) ^ __ROR4__(v368, 31) ^ __ROR4__(v396, 31);
    HIDWORD(v411) = v414;
    LODWORD(v411) = v414;
    v415 = (v411 >> 31) - 899497514 + v404;
    HIDWORD(v411) = v401;
    LODWORD(v411) = v401;
    v416 = v411 >> 2;
    v418 = __PAIR64__(v413, __ROR4__(v326, 31));
    v417 = v496 ^ v418;
    LODWORD(v418) = v413;
    v419 = v415 + (v416 ^ __ROR4__(v395, 2) ^ v407) + (v418 >> 27);
    v420 = v417 ^ __ROR4__(v373, 31) ^ __ROR4__(v402, 31);
    HIDWORD(v418) = v420;
    LODWORD(v418) = v420;
    v421 = (v418 >> 31) - 899497514;
    HIDWORD(v418) = v407;
    LODWORD(v418) = v407;
    v422 = v418 >> 2;
    v423 = __PAIR64__(v419, __ROR4__(v401, 2));
    v424 = v421 + v410 + (v422 ^ v423 ^ v413);
    LODWORD(v423) = v419;
    v425 = v424 + (v423 >> 27);
    v426 = v467 ^ __ROR4__(v328, 31) ^ __ROR4__(v378, 31) ^ __ROR4__(v408, 31);
    HIDWORD(v423) = v426;
    LODWORD(v423) = v426;
    v427 = (v423 >> 31) - 899497514 + v416;
    HIDWORD(v423) = v413;
    LODWORD(v423) = v413;
    v428 = v423 >> 2;
    v429 = v427 + (v428 ^ __ROR4__(v407, 2) ^ v419);
    v431 = __PAIR64__(v425, __ROR4__(v335, 31));
    v430 = v470 ^ v431;
    LODWORD(v431) = v425;
    v432 = v429 + (v431 >> 27);
    v433 = v430 ^ __ROR4__(v384, 31) ^ __ROR4__(v414, 31);
    HIDWORD(v431) = v433;
    LODWORD(v431) = v433;
    v434 = (v431 >> 31) - 899497514;
    HIDWORD(v431) = v419;
    LODWORD(v431) = v419;
    v435 = v431 >> 2;
    v436 = __PAIR64__(v432, __ROR4__(v413, 2));
    v437 = v434 + v422 + (v435 ^ v436 ^ v425);
    LODWORD(v436) = v432;
    v438 = v437 + (v436 >> 27);
    v439 = v358 ^ __ROR4__(v345, 31) ^ __ROR4__(v390, 31) ^ __ROR4__(v420, 31);
    HIDWORD(v436) = v439;
    LODWORD(v436) = v439;
    v440 = (v436 >> 31) - 899497514 + v428;
    HIDWORD(v436) = v425;
    LODWORD(v436) = v425;
    v441 = v436 >> 2;
    v443 = __PAIR64__(v438, __ROR4__(v396, 31));
    v442 = v492 ^ __ROR4__(v350, 31) ^ v443;
    LODWORD(v443) = v438;
    v444 = v440 + (v441 ^ __ROR4__(v419, 2) ^ v432) + (v443 >> 27);
    v445 = v442 ^ __ROR4__(v426, 31);
    HIDWORD(v443) = v445;
    LODWORD(v443) = v445;
    v446 = (v443 >> 31) - 899497514;
    HIDWORD(v443) = v432;
    LODWORD(v443) = v432;
    v447 = v443 >> 2;
    v448 = __PAIR64__(v444, __ROR4__(v425, 2));
    v449 = v446 + v435 + (v447 ^ v448 ^ v438);
    LODWORD(v448) = v444;
    v450 = v449 + (v448 >> 27);
    LODWORD(v448) = v483 ^ __ROR4__(v357, 31) ^ __ROR4__(v402, 31) ^ __ROR4__(v433, 31);
    HIDWORD(v448) = v448;
    v451 = (v448 >> 31) - 899497514 + v441;
    HIDWORD(v448) = v438;
    LODWORD(v448) = v438;
    result = (v448 >> 2);
    v454 = __PAIR64__(v450, __ROR4__(v408, 31));
    v453 = v486 ^ __ROR4__(v363, 31) ^ v454;
    LODWORD(v454) = v450;
    v455 = v451 + (result ^ __ROR4__(v432, 2) ^ v444) + (v454 >> 27);
    LODWORD(v454) = v453 ^ __ROR4__(v439, 31);
    HIDWORD(v454) = v454;
    v456 = (v454 >> 31) - 899497514;
    HIDWORD(v454) = v444;
    LODWORD(v454) = v444;
    v457 = v454 >> 2;
    v458 = __PAIR64__(v455, __ROR4__(v438, 2));
    v459 = v456 + v447 + (v457 ^ v458 ^ v450);
    LODWORD(v458) = v455;
    v460 = v459 + (v458 >> 27);
    LODWORD(v458) = v379 ^ __ROR4__(v368, 31) ^ __ROR4__(v414, 31) ^ __ROR4__(v445, 31);
    HIDWORD(v458) = v458;
    v461 = v517 - 899497514 + (v458 >> 31) + result;
    HIDWORD(v458) = v450;
    LODWORD(v458) = v450;
    v462 = v458 >> 2;
    v463 = __PAIR64__(v460, __ROR4__(v444, 2));
    v464 = v461 + (v462 ^ v463 ^ v455);
    v5 = v460 + v523;
    LODWORD(v463) = v460;
    v7 = v464 + (v463 >> 27);
    HIDWORD(v463) = v455;
    LODWORD(v463) = v455;
    v6 = (v463 >> 2) + v521;
    v3 = v462 + v522;
    v4 = v457 + v518;
    *a1 = v7;
    a1[1] = v5;
    a1[2] = v6;
    a1[3] = v3;
    a1[4] = v457 + v518;
    a2 = v519 + 16;
    a3 = v520 - 1;
  }
  while (v520 != 1);
  return result;
}

void bssl::ssl_send_alert(bssl *this, ssl_st *a2, int a3)
{
  _QWORD *v6;

  v6 = ERR_save_state();
  bssl::ssl_send_alert_impl(this, a2, a3);
  ERR_restore_state(v6);
  if (v6)
    ERR_SAVE_STATE_free((uint64_t)v6);
}

void sub_1B4FD4F28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t boringssl_config_get_tickets_enabled()
{
  return 0;
}

uint64_t boringssl_config_get_resumption_enabled()
{
  return 1;
}

uint64_t boringssl_config_get_false_start_enabled()
{
  return 1;
}

uint64_t boringssl_config_get_tls13_external_psk_enabled()
{
  const char *v0;
  uint64_t result;

  if (boringssl_config_get_whitelisted_bundle_identifier_onceToken != -1)
    dispatch_once(&boringssl_config_get_whitelisted_bundle_identifier_onceToken, &__block_literal_global_2);
  v0 = (const char *)global_bundle_identifier;
  result = strcmp((const char *)global_bundle_identifier, "redacted_bundle_id");
  if ((_DWORD)result)
    return strcmp(v0, "no_bundle_id") != 0;
  return result;
}

uint64_t boringssl_config_restricted_mode_restrict_tls_version(uint64_t result)
{
  if (result <= 0x303)
    return 771;
  else
    return result;
}

uint64_t boringssl_config_restricted_mode_restrict_dtls_version(uint64_t result)
{
  if (result >= 0xFEFD)
    return 65277;
  else
    return result;
}

_QWORD **std::unique_ptr<bssl::`anonymous namespace'::ECKeyShare,bssl::internal::Deleter>::~unique_ptr[abi:ne180100](_QWORD **a1)
{
  _QWORD *v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    (*(void (**)(_QWORD *))*v2)(v2);
    OPENSSL_free(v2);
  }
  return a1;
}

uint64_t bssl::ssl_name_to_group_id(bssl *this, const char *a2, const char *a3)
{
  uint64_t v6;
  int *v7;

  v6 = 0;
  while (1)
  {
    {
      break;
    }
    if ((const char *)strlen((const char *)v7 + 18) == a3 && !strncmp((const char *)v7 + 18, a2, (size_t)a3))
      break;
    v6 += 8;
    if (v6 == 64)
      return 0;
  }
  return 1;
}

BOOL bssl::`anonymous namespace'::ECKeyShare::SerializePrivateKey(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  const BIGNUM *v5;
  unsigned int v6;

  v3 = *(_QWORD *)(a1 + 16);
  if (!v3)
  if (!*(_QWORD *)(a1 + 8))
  v5 = (const BIGNUM *)EC_GROUP_get0_order(v3);
  v6 = BN_num_bytes(v5);
  return BN_bn2cbb_padded(a2, v6, *(_QWORD *)(a1 + 8)) != 0;
}

BOOL bssl::`anonymous namespace'::ECKeyShare::DeserializePrivateKey(uint64_t a1, uint64_t a2)
{
  BIGNUM **v2;
  const unsigned __int8 *v4;
  int v5;
  BIGNUM *v6;

  v2 = (BIGNUM **)(a1 + 8);
  if (*(_QWORD *)(a1 + 8))
  v4 = (const unsigned __int8 *)CBS_data(a2);
  v5 = CBS_len(a2);
  v6 = BN_bin2bn(v4, v5, 0);
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100](v2, v6);
  return *v2 != 0;
}

void bssl::`anonymous namespace'::X25519KeyShare::~X25519KeyShare(bssl::_anonymous_namespace_::X25519KeyShare *this)
{
  abort();
}

BOOL bssl::`anonymous namespace'::X25519KeyShare::SerializePrivateKey(uint64_t a1, uint64_t a2)
{
  return CBB_add_bytes(a2, (const void *)(a1 + 8), 0x20uLL) != 0;
}

BOOL bssl::`anonymous namespace'::X25519KeyShare::DeserializePrivateKey(uint64_t a1, uint64_t a2)
{
  return CBS_len(a2) == 32 && CBS_copy_bytes(a2, (void *)(a1 + 8), 0x20uLL) != 0;
}

void bssl::`anonymous namespace'::CECPQ2KeyShare::~CECPQ2KeyShare(bssl::_anonymous_namespace_::CECPQ2KeyShare *this)
{
  abort();
}

uint64_t bssl::`anonymous namespace'::CECPQ2KeyShare::GroupID(bssl::_anonymous_namespace_::CECPQ2KeyShare *this)
{
  return 16696;
}

uint64_t bssl::`anonymous namespace'::CECPQ2KeyShare::Offer(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t result;
  uint64_t v6;
  _BYTE v7[1138];
  _BYTE v8[1424];
  unsigned __int8 __b[1432];
  _OWORD v10[2];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[0] = v4;
  v10[1] = v4;
  X25519_keypair(v10, (unsigned __int8 *)(a1 + 8));
  memset(__b, 170, sizeof(__b));
  memset(v8, 170, sizeof(v8));
  RAND_bytes(__b, 1432);
  result = HRSS_generate_key(v8, (unsigned __int8 *)(a1 + 40), (uint64_t)__b);
  if ((_DWORD)result)
  {
    memset(v7, 170, sizeof(v7));
    HRSS_marshal_public_key(v7, (uint64_t)v8, v6);
    result = CBB_add_bytes(a2, v10, 0x20uLL);
    if ((_DWORD)result)
      return CBB_add_bytes(a2, v7, 0x472uLL) != 0;
  }
  return result;
}

uint64_t bssl::`anonymous namespace'::CECPQ2KeyShare::Accept(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, int64x2_t *a5, uint64_t a6)
{
  _QWORD *v12;
  unsigned __int8 *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 buf[1400];
  _BYTE v19[1138];
  _BYTE __b[1424];
  _OWORD v21[2];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  OPENSSL_free(0);
  v12 = OPENSSL_malloc(0x40uLL);
  if (!v12)
    goto LABEL_10;
  v13 = (unsigned __int8 *)(a1 + 8);
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v21[0] = v14;
  v21[1] = v14;
  X25519_keypair(v21, v13);
  memset(__b, 170, sizeof(__b));
  if (a6 != 1170
    || !HRSS_parse_public_key((uint64_t)__b, (uint64_t)a5[2].i64, v15)
    || !X25519((char *)v12, (__int128 *)v13, a5))
  {
    *a4 = 50;
    ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_key_share.cc", 223);
    v16 = 0;
    goto LABEL_11;
  }
  memset(v19, 170, sizeof(v19));
  memset(buf, 170, sizeof(buf));
  RAND_bytes(buf, 1400);
  if (!HRSS_encap(v19, (unsigned __int8 *)v12 + 32, (uint64_t)__b, (uint64_t)buf)
    || !CBB_add_bytes(a2, v21, 0x20uLL)
    || !CBB_add_bytes(a2, v19, 0x472uLL))
  {
LABEL_10:
    v16 = 0;
    goto LABEL_11;
  }
  OPENSSL_free(*(_QWORD **)a3);
  *(_QWORD *)a3 = v12;
  *(_QWORD *)(a3 + 8) = 64;
  v16 = 1;
  v12 = 0;
LABEL_11:
  OPENSSL_free(v12);
  return v16;
}

void sub_1B4FD5554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t bssl::`anonymous namespace'::CECPQ2KeyShare::Finish(uint64_t a1, uint64_t a2, _BYTE *a3, int64x2_t *a4, uint64_t a5)
{
  char *v10;
  char *v11;
  uint64_t v12;

  *a3 = 80;
  OPENSSL_free(0);
  v10 = (char *)OPENSSL_malloc(0x40uLL);
  v11 = v10;
  if (!v10)
    goto LABEL_6;
  if (a5 != 1170 || !X25519(v10, (__int128 *)(a1 + 8), a4))
  {
    *a3 = 50;
    ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_key_share.cc", 255);
    v12 = 0;
    goto LABEL_8;
  }
  if (HRSS_decap((unsigned __int8 *)v11 + 32, a1 + 40, &a4[2], 0x472uLL))
  {
    OPENSSL_free(*(_QWORD **)a2);
    *(_QWORD *)a2 = v11;
    *(_QWORD *)(a2 + 8) = 64;
    v12 = 1;
    v11 = 0;
  }
  else
  {
LABEL_6:
    v12 = 0;
  }
LABEL_8:
  OPENSSL_free(v11);
  return v12;
}

void sub_1B4FD568C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  bssl::Array<unsigned char>::~Array((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void bssl::`anonymous namespace'::X25519Kyber768KeyShare::~X25519Kyber768KeyShare(bssl::_anonymous_namespace_::X25519Kyber768KeyShare *this)
{
  abort();
}

uint64_t bssl::`anonymous namespace'::X25519Kyber768KeyShare::GroupID(bssl::_anonymous_namespace_::X25519Kyber768KeyShare *this)
{
  return 65073;
}

uint64_t bssl::`anonymous namespace'::X25519Kyber768KeyShare::Offer()
{
  return 0;
}

uint64_t bssl::`anonymous namespace'::X25519Kyber768KeyShare::Accept()
{
  return 0;
}

uint64_t bssl::`anonymous namespace'::X25519Kyber768KeyShare::Finish()
{
  return 0;
}

void bssl::`anonymous namespace'::P256Kyber768KeyShare::~P256Kyber768KeyShare(bssl::_anonymous_namespace_::P256Kyber768KeyShare *this)
{
  abort();
}

uint64_t bssl::`anonymous namespace'::P256Kyber768KeyShare::GroupID(bssl::_anonymous_namespace_::P256Kyber768KeyShare *this)
{
  return 65074;
}

uint64_t bssl::`anonymous namespace'::P256Kyber768KeyShare::Offer()
{
  return 0;
}

uint64_t bssl::`anonymous namespace'::P256Kyber768KeyShare::Accept()
{
  return 0;
}

uint64_t bssl::`anonymous namespace'::P256Kyber768KeyShare::Finish()
{
  return 0;
}

uint64_t boringssl_helper_convert_trusterror_to_alertcode(int a1)
{
  if (a1 <= -67736)
  {
    if (a1 > -67820)
    {
      if ((a1 + 67819) < 2)
        return 45;
      return 46;
    }
    if (a1 != -67880 && a1 != -67843)
    {
      if (a1 == -67820)
        return 44;
      return 46;
    }
    return 42;
  }
  if (a1 <= -67613)
  {
    if (a1 == -67735 || a1 == -67655)
      return 42;
  }
  else
  {
    switch(a1)
    {
      case -67612:
        return 48;
      case -67602:
        return 42;
      case -25318:
        return 48;
    }
  }
  return 46;
}

uint64_t boringssl_helper_convert_alert_code(int a1, int a2)
{
  BOOL v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t result;

  if (a1 <= 69)
  {
    switch(a1)
    {
      case 20:
        v2 = a2 == 16388;
        v3 = -9846;
        v4 = -9820;
        break;
      case 21:
        v2 = a2 == 16388;
        v3 = -9845;
        v4 = -9821;
        break;
      case 22:
        v2 = a2 == 16388;
        v3 = -9847;
        v4 = -9822;
        break;
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
        return 4294957494;
      case 30:
        v2 = a2 == 16388;
        v3 = -9857;
        v4 = -9823;
        break;
      case 40:
        v2 = a2 == 16388;
        v3 = -9858;
        v4 = -9824;
        break;
      case 41:
      case 46:
        v2 = a2 == 16388;
        v3 = -9808;
        v4 = -9825;
        break;
      case 42:
        return 4294957488;
      case 43:
        v2 = a2 == 16388;
        v3 = -9808;
        v4 = -9826;
        break;
      case 44:
        v2 = a2 == 16388;
        v3 = -9808;
        v4 = -9827;
        break;
      case 45:
        v2 = a2 == 16388;
        v3 = -9814;
        v4 = -9828;
        break;
      case 47:
        return 4294957466;
      case 48:
        v2 = a2 == 16388;
        v3 = -9813;
        v4 = -9831;
        break;
      case 49:
        return 4294957464;
      case 50:
        v2 = a2 == 16388;
        v3 = -9859;
        v4 = -9833;
        break;
      case 51:
        v2 = a2 == 16388;
        v3 = -9845;
        v4 = -9834;
        break;
      case 60:
        v2 = a2 == 16388;
        v3 = -9802;
        v4 = -9835;
        break;
      default:
        if (!a1)
          return 4294957491;
        if (a1 != 10)
          return 4294957494;
        v2 = a2 == 16388;
        v3 = -9856;
        v4 = -9819;
        break;
    }
LABEL_39:
    if (v2)
      return v4;
    else
      return v3;
  }
  if (a1 <= 85)
  {
    switch(a1)
    {
      case 'F':
        return 4294957460;
      case 'G':
        v2 = a2 == 16388;
        v3 = -9802;
        v4 = -9837;
        break;
      case 'P':
        v2 = a2 == 16388;
        v3 = -9810;
        v4 = -9838;
        break;
      default:
        return 4294957494;
    }
    goto LABEL_39;
  }
  switch(a1)
  {
    case 'd':
      v2 = a2 == 16388;
      v3 = -9800;
      v4 = -9840;
      goto LABEL_39;
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
      return 4294957494;
    case 'n':
    case 'o':
    case 'p':
    case 'q':
      return 4294957496;
    case 'r':
      return 4294957488;
    case 's':
      return 4294957432;
    case 't':
      v2 = a2 == 16388;
      v3 = -9863;
      v4 = -9829;
      goto LABEL_39;
    default:
      if (a1 == 86)
      {
        result = 4294957436;
      }
      else
      {
        if (a1 != 90)
          return 4294957494;
        result = 4294957457;
      }
      break;
  }
  return result;
}

BOOL boringssl_helper_dispatch_data_equal(void *a1, void *a2)
{
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  _BOOL8 v6;
  size_t size;
  _QWORD v9[4];
  NSObject *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v3 = a1;
  v4 = a2;
  v5 = v4;
  v6 = v3 == v4;
  if (v3 != v4 && v3 && v4)
  {
    size = dispatch_data_get_size(v3);
    if (size == dispatch_data_get_size(v5))
    {
      v12 = 0;
      v13 = &v12;
      v14 = 0x2020000000;
      v15 = 1;
      v9[0] = MEMORY[0x1E0C809B0];
      v9[1] = 3221225472;
      v9[2] = __boringssl_helper_dispatch_data_equal_block_invoke;
      v9[3] = &unk_1E686F420;
      v10 = v5;
      v11 = &v12;
      dispatch_data_apply(v3, v9);
      v6 = *((_BYTE *)v13 + 24) != 0;

      _Block_object_dispose(&v12, 8);
    }
    else
    {
      v6 = 0;
    }
  }

  return v6;
}

uint64_t __boringssl_helper_dispatch_data_equal_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v6;
  _QWORD v8[8];

  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = __boringssl_helper_dispatch_data_equal_block_invoke_2;
  v8[3] = &unk_1E686F3F8;
  v6 = *(NSObject **)(a1 + 32);
  v8[4] = *(_QWORD *)(a1 + 40);
  v8[5] = a3;
  v8[6] = a5;
  v8[7] = a4;
  dispatch_data_apply(v6, v8);
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
}

BOOL __boringssl_helper_dispatch_data_equal_block_invoke_2(_QWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  size_t v12;

  v7 = a1[5];
  v6 = a1[6];
  if (v7 <= a3)
    v8 = a3;
  else
    v8 = a1[5];
  v9 = v6 + v7;
  if (v6 + v7 >= a5 + a3)
    v10 = a5 + a3;
  else
    v10 = v6 + v7;
  v11 = v10 > v8;
  v12 = v10 - v8;
  if (v11)
  {
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = memcmp((const void *)(a4 + v8 - a3), (const void *)(a1[7] + v8 - v7), v12) == 0;
  }
  else
  {
    if (v9 < a3)
      return 0;
    if (a5 + a3 < v7)
      return 1;
  }
  return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) != 0;
}

id boringssl_helper_create_protocol_list_from_encoded_list(uint64_t a1, size_t a2)
{
  id v2;
  xpc_object_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  char *v9;
  char *v10;
  xpc_object_t v11;
  void *v12;

  v2 = 0;
  if (a1 && a2)
  {
    v5 = xpc_array_create(0, 0);
    if (v5)
    {
      v6 = 0;
      while (1)
      {
        v7 = *(unsigned __int8 *)(a1 + v6);
        if (v6 + v7 >= a2)
          break;
        v8 = v7 + 1;
        v9 = (char *)malloc_type_malloc(v7 + 1, 0x83550F57uLL);
        if (!v9)
          break;
        v10 = v9;
        memcpy(v9, (const void *)(a1 + v6 + 1), v7);
        v10[v7] = 0;
        v11 = xpc_string_create(v10);
        if (!v11)
        {
          free(v10);
          break;
        }
        v12 = v11;
        xpc_array_append_value(v5, v11);
        free(v10);
        v6 += v8;

        if (v6 >= a2)
        {
          v2 = v5;
          goto LABEL_12;
        }
      }
    }
    v2 = 0;
LABEL_12:

  }
  return v2;
}

BOOL boringssl_helper_find_first_overlapping_protocol(void *a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v7;
  void *v8;
  _BOOL8 v9;
  _QWORD applier[4];
  id v12;
  _BYTE *v13;
  uint64_t v14;

  v7 = a2;
  v8 = v7;
  v9 = 0;
  *a4 = 0;
  if (a1 && v7 && a3)
  {
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = __boringssl_helper_find_first_overlapping_protocol_block_invoke;
    applier[3] = &unk_1E686F470;
    v12 = v7;
    v13 = a4;
    v14 = a3;
    v9 = !xpc_array_apply(a1, applier);

  }
  return v9;
}

BOOL __boringssl_helper_find_first_overlapping_protocol_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  size_t length;
  void *v6;
  _BOOL8 v7;
  _QWORD v9[6];
  __int128 v10;
  _QWORD v11[3];
  const char *string_ptr;

  v4 = a3;
  length = xpc_string_get_length(v4);
  v11[0] = 0;
  v11[1] = v11;
  v11[2] = 0x2020000000;
  string_ptr = (const char *)0xAAAAAAAAAAAAAAAALL;
  string_ptr = xpc_string_get_string_ptr(v4);
  v6 = *(void **)(a1 + 32);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = __boringssl_helper_find_first_overlapping_protocol_block_invoke_2;
  v9[3] = &unk_1E686F448;
  v9[4] = v11;
  v9[5] = length;
  v10 = *(_OWORD *)(a1 + 40);
  v7 = xpc_array_apply(v6, v9);
  _Block_object_dispose(v11, 8);

  return v7;
}

void sub_1B4FD5EB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __boringssl_helper_find_first_overlapping_protocol_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  size_t length;
  const char *string_ptr;
  uint64_t result;

  v4 = a3;
  length = xpc_string_get_length(v4);
  string_ptr = xpc_string_get_string_ptr(v4);

  if (*(_QWORD *)(a1 + 40) != length)
    return 1;
  result = strncmp(*(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), string_ptr, length);
  if ((_DWORD)result)
    return 1;
  **(_BYTE **)(a1 + 48) = length;
  **(_QWORD **)(a1 + 56) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void *boringssl_helper_create_certificate_sec_array_from_CFArray(const __CFArray *a1)
{
  void *v2;
  CFIndex v3;
  __SecCertificate *ValueAtIndex;
  sec_certificate_t v5;
  id v6;

  if (!a1)
    return 0;
  v2 = (void *)sec_array_create();
  if (v2)
  {
    if (CFArrayGetCount(a1) >= 1)
    {
      v3 = 0;
      do
      {
        ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(a1, v3);
        if (ValueAtIndex)
        {
          v5 = sec_certificate_create(ValueAtIndex);
          sec_array_append();

        }
        ++v3;
      }
      while (v3 < CFArrayGetCount(a1));
    }
    v6 = v2;
  }

  return v2;
}

uint64_t boringssl_helper_SecKeyAlgorithm_from_signature_algorithm(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v1 = MEMORY[0x1E0CD6EC8];
  v2 = MEMORY[0x1E0CD6EB8];
  v3 = MEMORY[0x1E0CD6EC0];
  v4 = MEMORY[0x1E0CD6E80];
  if (a1 != 65281)
    v4 = MEMORY[0x1E0CD6EC8];
  if (a1 != 2054)
    v3 = v4;
  if (a1 != 2053)
    v2 = v3;
  v5 = MEMORY[0x1E0CD6EA8];
  v6 = MEMORY[0x1E0CD6DF8];
  v7 = MEMORY[0x1E0CD6EB0];
  if (a1 != 2052)
    v7 = MEMORY[0x1E0CD6EC8];
  if (a1 != 1539)
    v6 = v7;
  if (a1 != 1537)
    v5 = v6;
  if (a1 <= 2052)
    v2 = v5;
  v8 = MEMORY[0x1E0CD6DF8];
  v9 = MEMORY[0x1E0CD6EA0];
  v10 = MEMORY[0x1E0CD6E00];
  if (a1 != 1283)
    v10 = MEMORY[0x1E0CD6EC8];
  if (a1 != 1281)
    v9 = v10;
  if (a1 != 1027)
    v8 = v9;
  if (a1 == 1025)
    v1 = MEMORY[0x1E0CD6E98];
  if (a1 == 515)
    v1 = MEMORY[0x1E0CD6DE0];
  if (a1 == 513)
    v1 = MEMORY[0x1E0CD6E88];
  if (a1 > 1026)
    v1 = v8;
  if (a1 > 1536)
    v1 = v2;
  return *(_QWORD *)v1;
}

uint64_t boringssl_helper_zlib_compress_data(void *a1, uint64_t a2, uLong a3, void *a4)
{
  id *v7;
  id v8;
  unsigned int (**v9)(_QWORD, _QWORD, _QWORD);
  uint64_t v10;
  id WeakRetained;
  void *v12;
  _BYTE *v13;
  char v14;
  id v15;
  _BYTE *v16;
  _BOOL4 v17;
  uInt v18;
  uLong v19;
  int v20;
  id v21;
  void *v22;
  _BYTE *v23;
  char v24;
  id v25;
  _BYTE *v26;
  _BOOL4 v27;
  NSObject *v28;
  NSObject *v29;
  z_stream v31;
  _BYTE __b[1024];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a4;
  v9 = (unsigned int (**)(_QWORD, _QWORD, _QWORD))v8;
  v10 = 0;
  if (v7 && a2 && a3 && v8)
  {
    memset(&v31, 0, sizeof(v31));
    if (deflateInit_(&v31, -1, "1.2.12", 112))
    {
      WeakRetained = objc_loadWeakRetained(v7 + 2);
      if (WeakRetained)
      {
        v12 = WeakRetained;
        v13 = objc_loadWeakRetained(v7 + 2);
        v14 = v13[475];

        if ((v14 & 1) != 0)
        {
LABEL_29:
          v10 = 0;
          goto LABEL_38;
        }
      }
      v15 = objc_loadWeakRetained(v7 + 2);
      if (v15)
      {
        v16 = objc_loadWeakRetained(v7 + 2);
        v17 = (v16[475] & 1) == 0;

      }
      else
      {
        v17 = 1;
      }

      v10 = 0;
      if (v17 && g_boringssl_log)
      {
        v28 = (id)g_boringssl_log;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          boringssl_helper_zlib_compress_data_cold_2(v7, v28);

        goto LABEL_29;
      }
    }
    else
    {
      memset(__b, 170, sizeof(__b));
      while (2)
      {
        v18 = a3 - LODWORD(v31.total_in);
        if (a3 - v31.total_in >= 0x400)
          v18 = 1024;
        v31.avail_in = v18;
        v31.next_in = (Bytef *)(a2 + v31.total_in);
        v19 = v31.total_in + 1024;
        v20 = 4 * (v31.total_in + 1024 >= a3);
        do
        {
          v31.avail_out = 1024;
          v31.next_out = __b;
          if (deflate(&v31, v20) == -2)
          {
            v21 = objc_loadWeakRetained(v7 + 2);
            if (!v21
              || (v22 = v21,
                  v23 = objc_loadWeakRetained(v7 + 2),
                  v24 = v23[475],
                  v23,
                  v22,
                  (v24 & 1) == 0))
            {
              v25 = objc_loadWeakRetained(v7 + 2);
              if (v25)
              {
                v26 = objc_loadWeakRetained(v7 + 2);
                v27 = (v26[475] & 1) == 0;

              }
              else
              {
                v27 = 1;
              }

              v10 = 0;
              if (!v27 || !g_boringssl_log)
                goto LABEL_37;
              v29 = (id)g_boringssl_log;
              if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                boringssl_helper_zlib_compress_data_cold_1(v7, v29);

            }
LABEL_36:
            v10 = 0;
            goto LABEL_37;
          }
          if (!((unsigned int (**)(_QWORD, _BYTE *, uint64_t))v9)[2](v9, __b, 1024 - v31.avail_out))
            goto LABEL_36;
        }
        while (!v31.avail_out);
        if (v19 < a3)
          continue;
        break;
      }
      v10 = 1;
LABEL_37:
      deflateEnd(&v31);
    }
  }
LABEL_38:

  return v10;
}

__CFArray *boringssl_helper_copy_identity_certificate_chain_from_identity_array(const __CFArray *a1)
{
  unsigned int Count;
  uint64_t v3;
  int v4;
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  __SecIdentity *ValueAtIndex;
  __SecIdentity *v8;
  CFTypeID v9;
  SecCertificateRef v10;
  uint64_t v11;
  CFIndex i;
  const void *v13;
  SecCertificateRef certificateRef;

  if (!a1)
    return 0;
  Count = CFArrayGetCount(a1);
  v3 = Count;
  if (!Count)
    return 0;
  v4 = Count;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v6 = (__CFArray *)g_boringssl_log;
    if (!g_boringssl_log)
      return v6;
    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      boringssl_helper_copy_identity_certificate_chain_from_identity_array_cold_1();
    return 0;
  }
  v6 = Mutable;
  ValueAtIndex = (__SecIdentity *)CFArrayGetValueAtIndex(a1, 0);
  if (!ValueAtIndex)
  {
    v6 = (__CFArray *)g_boringssl_log;
    if (!g_boringssl_log)
      return v6;
    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      boringssl_helper_copy_identity_certificate_chain_from_identity_array_cold_2();
    return 0;
  }
  v8 = ValueAtIndex;
  v9 = CFGetTypeID(ValueAtIndex);
  if (v9 != SecIdentityGetTypeID())
  {
    v6 = (__CFArray *)g_boringssl_log;
    if (!g_boringssl_log)
      return v6;
    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      boringssl_helper_copy_identity_certificate_chain_from_identity_array_cold_4();
    return 0;
  }
  certificateRef = 0;
  if (SecIdentityCopyCertificate(v8, &certificateRef) || (v10 = certificateRef) == 0)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      boringssl_helper_copy_identity_certificate_chain_from_identity_array_cold_3();
    return 0;
  }
  CFArrayAppendValue(v6, certificateRef);
  CFRelease(v10);
  if (v4 >= 2)
  {
    if (v3 <= 2)
      v11 = 2;
    else
      v11 = v3;
    for (i = 1; i != v11; ++i)
    {
      v13 = CFArrayGetValueAtIndex(a1, i);
      CFArrayAppendValue(v6, v13);
    }
  }
  return v6;
}

const __CFArray *boringssl_helper_copy_leaf_private_key_from_identity_array(const __CFArray *result)
{
  const __CFArray *v1;
  __SecIdentity *ValueAtIndex;
  __SecIdentity *v3;
  CFTypeID v4;
  SecKeyRef privateKeyRef;

  if (result)
  {
    v1 = result;
    result = (const __CFArray *)CFArrayGetCount(result);
    if (result)
    {
      ValueAtIndex = (__SecIdentity *)CFArrayGetValueAtIndex(v1, 0);
      if (ValueAtIndex)
      {
        v3 = ValueAtIndex;
        v4 = CFGetTypeID(ValueAtIndex);
        if (v4 == SecIdentityGetTypeID())
        {
          privateKeyRef = 0;
          if (!SecIdentityCopyPrivateKey(v3, &privateKeyRef))
            return privateKeyRef;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
              boringssl_helper_copy_leaf_private_key_from_identity_array_cold_2();
          }
        }
        else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        {
          boringssl_helper_copy_leaf_private_key_from_identity_array_cold_3();
        }
      }
      else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        boringssl_helper_copy_leaf_private_key_from_identity_array_cold_1();
      }
      return 0;
    }
  }
  return result;
}

uint64_t boringssl_helper_create_certificate_buffer_chain_from_certificate_chain(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  STACK *v7;

  v1 = a1;
  if (v1)
  {
    v4 = 0;
    v5 = &v4;
    v6 = 0x2020000000;
    v7 = (STACK *)0xAAAAAAAAAAAAAAAALL;
    v7 = sk_new_null();
    sec_array_apply();
    v2 = v5[3];
    _Block_object_dispose(&v4, 8);
  }
  else
  {
    v2 = 0;
  }

  return v2;
}

void sub_1B4FD675C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __boringssl_helper_create_certificate_buffer_chain_from_certificate_chain_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v4;
  NSObject *v5;
  __SecCertificate *v6;
  __SecCertificate *v7;
  const __CFData *v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  CFIndex Length;
  char *v12;

  v4 = a3;
  v5 = v4;
  if (v4)
  {
    v6 = sec_certificate_copy_ref(v4);
    if (v6)
    {
      v7 = v6;
      v8 = SecCertificateCopyData(v6);
      if (v8)
      {
        v9 = v8;
        BytePtr = CFDataGetBytePtr(v8);
        Length = CFDataGetLength(v9);
        v12 = (char *)CRYPTO_BUFFER_new(BytePtr, Length, 0);
        if (v12)
          sk_push(*(STACK **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), v12);
        CFRelease(v9);
      }
      CFRelease(v7);
    }
  }

  return 1;
}

void boringssl_helper_dump_dispatch_data(void *a1, NSObject *a2)
{
  id v3;
  id v4;
  _QWORD applier[4];
  id v6;

  v3 = a1;
  if (a2)
  {
    applier[1] = 3221225472;
    applier[2] = __boringssl_helper_dump_dispatch_data_block_invoke;
    applier[3] = &unk_1E686F4C0;
    v4 = v3;
    applier[0] = MEMORY[0x1E0C809B0];
    v6 = v3;
    dispatch_data_apply(a2, applier);

    v3 = v4;
  }

}

uint64_t __boringssl_helper_dump_dispatch_data_block_invoke(uint64_t a1, void *a2, __int128 *a3, uint64_t a4, unint64_t a5)
{
  void *v5;
  uint64_t v9;
  id WeakRetained;
  void *v11;
  _BYTE *v12;
  char v13;
  uint64_t v14;
  id v15;
  _BYTE *v16;
  _BOOL4 v17;
  NSObject *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  _BOOL4 v22;
  id v23;
  char v24;
  void *v25;
  id *v26;
  char *v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  unint64_t v35;
  unsigned int v36;
  char v37;
  char v38;
  id v39;
  void *v40;
  _BYTE *v41;
  char v42;
  id v43;
  _BYTE *v44;
  _BOOL4 v45;
  NSObject *v46;
  id v47;
  void *v48;
  id v49;
  id v51;
  char *v52;
  id v53;
  void *v54;
  _BOOL4 v55;
  void *v56;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  void *v63;
  __int16 v64;
  id v65;
  __int16 v66;
  id v67;
  __int16 v68;
  __int128 *v69;
  __int16 v70;
  _QWORD *v71;
  _QWORD v72[3];
  __int128 v73;
  _BYTE v74[31];
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v9 = *(_QWORD *)(a1 + 32);
  if (!v9)
    goto LABEL_10;
  WeakRetained = objc_loadWeakRetained((id *)(v9 + 16));
  if (!WeakRetained
    || (v11 = WeakRetained,
        v12 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16)),
        v13 = v12[475],
        v12,
        v11,
        (v13 & 1) == 0))
  {
    v14 = *(_QWORD *)(a1 + 32);
    if (!v14)
      goto LABEL_10;
    v15 = objc_loadWeakRetained((id *)(v14 + 16));
    if (v15)
    {
      v16 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 16));
      v17 = (v16[475] & 1) == 0;

    }
    else
    {
      v17 = 1;
    }

    if (v17)
    {
LABEL_10:
      if (g_boringssl_log)
      {
        v18 = (id)g_boringssl_log;
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
          goto LABEL_27;
        v19 = *(_QWORD *)(a1 + 32);
        if (v19)
        {
          v20 = (char *)objc_loadWeakRetained((id *)(v19 + 16));
          v5 = v20;
          v21 = *(_QWORD *)(a1 + 32);
          if (v20)
          {
            v22 = v21 != 0;
            if (v21)
            {
              v20 = (char *)objc_loadWeakRetained((id *)(v21 + 16));
              v21 = *(_QWORD *)(a1 + 32);
            }
            else
            {
              v20 = 0;
            }
            v25 = v20 + 391;
          }
          else
          {
            v22 = 0;
            v25 = &unk_1B50022E3;
          }
          v56 = v20;
          if (v21)
          {
            v23 = objc_loadWeakRetained((id *)(v21 + 16));
            v24 = 0;
          }
          else
          {
            v23 = 0;
            v24 = 1;
          }
        }
        else
        {
          v22 = 0;
          v23 = 0;
          v24 = 1;
          v25 = &unk_1B50022E3;
        }
        *(_DWORD *)buf = 136447490;
        v59 = "boringssl_helper_dump_dispatch_data_block_invoke";
        v60 = 1024;
        v61 = 949;
        v62 = 2082;
        v63 = v25;
        v64 = 2048;
        v65 = v23;
        v66 = 2048;
        v67 = v51;
        v68 = 2048;
        v69 = a3;
        _os_log_impl(&dword_1B4F6D000, v18, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] data region %p, offset %zu", buf, 0x3Au);
        if ((v24 & 1) != 0)
        {
          if (!v22)
            goto LABEL_25;
        }
        else
        {

          if (!v22)
          {
LABEL_25:
            if (v19)
LABEL_26:

LABEL_27:
            goto LABEL_28;
          }
        }

        if (!v19)
          goto LABEL_27;
        goto LABEL_26;
      }
    }
  }
LABEL_28:
  v26 = (id *)*(id *)(a1 + 32);
  memset(v72, 170, 17);
  if (a4 && a5)
  {
    v27 = 0;
    *(_QWORD *)&v28 = 0x2020202020202020;
    *((_QWORD *)&v28 + 1) = 0x2020202020202020;
    *(_OWORD *)&v74[15] = v28;
    v73 = v28;
    *(_OWORD *)v74 = v28;
    v75 = 0;
    do
    {
      if (a5 - (unint64_t)v27 >= 0x10)
        v29 = 16;
      else
        v29 = a5 - (_QWORD)v27;
      if (!(_DWORD)v29)
        goto LABEL_43;
      v30 = 3 * (v29 - 1);
      v31 = (char *)&v73 + 1;
      v32 = &v27[a4];
      v33 = (char *)v72;
      v34 = v29;
      do
      {
        v36 = *v32++;
        v35 = v36;
        if (v36 - 32 >= 0x5F)
          v37 = 46;
        else
          v37 = v35;
        v38 = boringssl_helper_dump_buffer_hexChars[v35 >> 4];
        *v33 = v37;
        *(v31 - 1) = v38;
        *v31 = boringssl_helper_dump_buffer_hexChars[v35 & 0xF];
        if (!v30)
          *((_BYTE *)v72 + (v29 - 1) + 1) = 0;
        v30 -= 3;
        v31 += 3;
        ++v33;
        --v34;
      }
      while (v34);
      if (v29 <= 0xF)
LABEL_43:
        memset(&v74[3 * v29 - 16], 32, (3 * (16 - v29) - 1));
      if (!v26)
        goto LABEL_53;
      v39 = objc_loadWeakRetained(v26 + 2);
      if (!v39
        || (v40 = v39,
            v41 = objc_loadWeakRetained(v26 + 2),
            v42 = v41[475],
            v41,
            v40,
            (v42 & 1) == 0))
      {
        v43 = objc_loadWeakRetained(v26 + 2);
        if (v43)
        {
          v44 = objc_loadWeakRetained(v26 + 2);
          v45 = (v44[475] & 1) == 0;

        }
        else
        {
          v45 = 1;
        }

        if (v45)
        {
LABEL_53:
          if (g_boringssl_log)
          {
            v46 = (id)g_boringssl_log;
            if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
            {
              if (v26)
              {
                v47 = objc_loadWeakRetained(v26 + 2);
                v55 = v47 != 0;
                v54 = v47;
                if (v47)
                {
                  v52 = (char *)objc_loadWeakRetained(v26 + 2);
                  v48 = v52 + 391;
                }
                else
                {
                  v48 = &unk_1B50022E3;
                }
                v53 = objc_loadWeakRetained(v26 + 2);
                v49 = v53;
              }
              else
              {
                v55 = 0;
                v49 = 0;
                v48 = &unk_1B50022E3;
              }
              *(_DWORD *)buf = 136447746;
              v59 = "boringssl_helper_dump_buffer";
              v60 = 1024;
              v61 = 938;
              v62 = 2082;
              v63 = v48;
              v64 = 2048;
              v65 = v49;
              v66 = 2048;
              v67 = v27;
              v68 = 2080;
              v69 = &v73;
              v70 = 2080;
              v71 = v72;
              _os_log_impl(&dword_1B4F6D000, v46, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] %4lu   %s   %s", buf, 0x44u);
              if (v26)

              if (v55)
              if (v26)

            }
          }
        }
      }
      v27 += v29;
    }
    while ((unint64_t)v27 < a5);
  }

  return 1;
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{

}

uint64_t __boringssl_helper_xpc_array_union_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;
  id v6;
  _QWORD v8[4];
  id v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;

  v4 = a3;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v14 = 0;
  v5 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = __boringssl_helper_xpc_array_union_block_invoke_3;
  v8[3] = &unk_1E686F510;
  v6 = v4;
  v9 = v6;
  v10 = &v11;
  xpc_array_apply(v5, v8);
  if (!*((_BYTE *)v12 + 24))
    xpc_array_append_value(*(xpc_object_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v6);

  _Block_object_dispose(&v11, 8);
  return 1;
}

void sub_1B4FD6F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __boringssl_helper_xpc_array_union_block_invoke_3(uint64_t a1, int a2, xpc_object_t object2)
{
  _BOOL4 v4;

  v4 = xpc_equal(*(xpc_object_t *)(a1 + 32), object2);
  if (v4)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  return !v4;
}

const char *boringssl_helper_get_handshake_state_description(int a1)
{
  const char *v1;

  v1 = "unknown state";
  if (a1 == 3)
    v1 = "connection established";
  if (a1 == 12288)
    return "not completed";
  else
    return v1;
}

int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
{
  int result;
  int (__cdecl *v7)(BIGNUM *, const BIGNUM *, const BIGNUM *);

  result = BN_div(0, r, m, d, ctx);
  if (result)
  {
    if (r->neg)
    {
      if (d->neg)
        v7 = BN_sub;
      else
        v7 = BN_add;
      return ((uint64_t (*)(BIGNUM *, BIGNUM *, const BIGNUM *))v7)(r, r, d);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t bn_mod_add_consttime(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, BN_CTX *ctx)
{
  const BIGNUM *v10;
  const BIGNUM *v11;
  BIGNUM *v12;
  BOOL v13;
  BOOL v14;
  unint64_t **p_d;
  unint64_t *v16;
  const unint64_t *d;
  const unint64_t *v18;
  const unint64_t *v19;
  unint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;

  BN_CTX_start(ctx);
  v10 = bn_resized_from_ctx(a2, *(int *)(a4 + 8), ctx);
  v11 = bn_resized_from_ctx(a3, *(int *)(a4 + 8), ctx);
  v12 = bn_scratch_space_from_ctx(*(int *)(a4 + 8), ctx);
  if (v10)
    v13 = v11 == 0;
  else
    v13 = 1;
  v14 = v13 || v12 == 0;
  if (v14 || (p_d = &v12->d, !bn_wexpand((_QWORD **)a1, *(int *)(a4 + 8))))
  {
    v23 = 0;
  }
  else
  {
    v16 = *(unint64_t **)a1;
    d = v10->d;
    v18 = v11->d;
    v19 = *(const unint64_t **)a4;
    v20 = *p_d;
    v21 = *(int *)(a4 + 8);
    v22 = bn_add_words(*(unint64_t **)a1, d, v18, *(_DWORD *)(a4 + 8));
    bn_reduce_once_in_place(v16, v22, v19, v20, v21);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a1 + 16) = 0;
    v23 = 1;
  }
  BN_CTX_end(ctx);
  return v23;
}

const BIGNUM *bn_resized_from_ctx(uint64_t a1, unint64_t a2, BN_CTX *ctx)
{
  const BIGNUM *v4;
  BIGNUM *v5;
  uint64_t v6;

  v4 = (const BIGNUM *)a1;
  if (*(int *)(a1 + 8) >= a2)
  {
    if (!bn_fits_in_words(a1, a2))
      bn_resized_from_ctx_cold_1();
  }
  else
  {
    v5 = bn_scratch_space_from_ctx(a2, ctx);
    if (v5 && (v6 = (uint64_t)v5, BN_copy(v5, v4)))
    {
      if (bn_resize_words(v6, a2))
        return (const BIGNUM *)v6;
      else
        return 0;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

BIGNUM *bn_scratch_space_from_ctx(unint64_t a1, BN_CTX *ctx)
{
  BIGNUM *v3;
  BIGNUM *v4;

  v3 = BN_CTX_get(ctx);
  v4 = v3;
  if (v3)
  {
    if (bn_wexpand(&v3->d, a1))
    {
      v4->neg = 0;
      v4->top = a1;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t bn_mod_sub_consttime(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, BN_CTX *ctx)
{
  const BIGNUM *v10;
  const BIGNUM *v11;
  BIGNUM *v12;
  BOOL v13;
  BOOL v14;
  unint64_t **p_d;
  uint64_t v16;

  BN_CTX_start(ctx);
  v10 = bn_resized_from_ctx(a2, *(int *)(a4 + 8), ctx);
  v11 = bn_resized_from_ctx(a3, *(int *)(a4 + 8), ctx);
  v12 = bn_scratch_space_from_ctx(*(int *)(a4 + 8), ctx);
  if (v10)
    v13 = v11 == 0;
  else
    v13 = 1;
  v14 = v13 || v12 == 0;
  if (v14 || (p_d = &v12->d, !bn_wexpand((_QWORD **)a1, *(int *)(a4 + 8))))
  {
    v16 = 0;
  }
  else
  {
    bn_mod_sub_words(*(unint64_t **)a1, v10->d, v11->d, *(const unint64_t **)a4, *p_d, *(int *)(a4 + 8));
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a1 + 16) = 0;
    v16 = 1;
  }
  BN_CTX_end(ctx);
  return v16;
}

int BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
{
  BIGNUM *v10;
  const BIGNUM *v11;
  _BOOL4 v12;

  BN_CTX_start(ctx);
  v10 = BN_CTX_get(ctx);
  if (!v10)
    goto LABEL_6;
  v11 = v10;
  if (a == b)
  {
    if (BN_sqr(v10, a, ctx))
      goto LABEL_4;
LABEL_6:
    v12 = 0;
    goto LABEL_7;
  }
  if (!BN_mul(v10, a, b, ctx))
    goto LABEL_6;
LABEL_4:
  v12 = BN_nnmod(r, v11, m, ctx) != 0;
LABEL_7:
  BN_CTX_end(ctx);
  return v12;
}

int BN_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)
{
  int result;

  result = BN_sqr(r, a, ctx);
  if (result)
    return BN_div(0, r, r, m, ctx);
  return result;
}

uint64_t bn_mod_lshift_consttime(BIGNUM *a1, const BIGNUM *a2, int a3, uint64_t a4, BN_CTX *a5)
{
  uint64_t result;
  int v10;
  int v11;
  int v12;

  result = (uint64_t)BN_copy(a1, a2);
  if (result)
  {
    if (a3 < 1)
    {
      return 1;
    }
    else
    {
      result = bn_mod_add_consttime((uint64_t)a1, (uint64_t)a1, (uint64_t)a1, a4, a5);
      if ((_DWORD)result)
      {
        v10 = 1;
        do
        {
          v11 = v10;
          if (a3 == v10)
            break;
          v12 = bn_mod_add_consttime((uint64_t)a1, (uint64_t)a1, (uint64_t)a1, a4, a5);
          v10 = v11 + 1;
        }
        while (v12);
        return v11 >= a3;
      }
    }
  }
  return result;
}

uint64_t bn_mod_lshift1_consttime(uint64_t a1, uint64_t a2, uint64_t a3, BN_CTX *ctx)
{
  return bn_mod_add_consttime(a1, a2, a2, a3, ctx);
}

uint64_t EVP_PKEY_is_opaque(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);

  v1 = *(_QWORD *)(a1 + 16);
  if (v1 && (v2 = *(uint64_t (**)(void))(v1 + 112)) != 0)
    return v2();
  else
    return 0;
}

int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
{
  char *ptr;
  uint64_t (*v5)(const EVP_PKEY *, const EVP_PKEY *);
  int result;
  uint64_t (*v7)(const EVP_PKEY *, const EVP_PKEY *);

  if (a->save_type != b->save_type)
    return -1;
  ptr = a->pkey.ptr;
  if (!ptr)
    return -2;
  v5 = (uint64_t (*)(const EVP_PKEY *, const EVP_PKEY *))*((_QWORD *)ptr + 19);
  if (v5)
  {
    result = v5(a, b);
    if (result < 1)
      return result;
    ptr = a->pkey.ptr;
  }
  v7 = (uint64_t (*)(const EVP_PKEY *, const EVP_PKEY *))*((_QWORD *)ptr + 5);
  if (v7)
    return v7(a, b);
  else
    return -2;
}

int EVP_PKEY_size(EVP_PKEY *pkey)
{
  char *ptr;
  uint64_t (*v2)(void);

  if (pkey && (ptr = pkey->pkey.ptr) != 0 && (v2 = (uint64_t (*)(void))*((_QWORD *)ptr + 15)) != 0)
    return v2();
  else
    return 0;
}

int EVP_PKEY_set1_RSA(EVP_PKEY *pkey, rsa_st *key)
{
  int result;

  result = EVP_PKEY_set_type((uint64_t)pkey, 6);
  if (result)
  {
    *(_QWORD *)&pkey->references = key;
    if (key)
    {
      RSA_up_ref(key);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t EVP_PKEY_get0_RSA(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 6)
    return *(_QWORD *)(a1 + 8);
  ERR_put_error(6, 0, 107, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp.c", 254);
  return 0;
}

uint64_t EVP_PKEY_assign_DSA(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = EVP_PKEY_set_type(a1, 116);
  if ((_DWORD)result)
  {
    *(_QWORD *)(a1 + 8) = a2;
    return a2 != 0;
  }
  return result;
}

uint64_t pkey_x25519_copy()
{
  return 1;
}

uint64_t pkey_x25519_keygen(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  uint64_t v5;

  v3 = (unsigned __int8 *)OPENSSL_malloc(0x41uLL);
  if (!v3)
    return 0;
  v4 = v3;
  if (!EVP_PKEY_set_type(a2, 948))
  {
    OPENSSL_free(v4);
    return 0;
  }
  X25519_keypair(v4, v4 + 32);
  v5 = 1;
  v4[64] = 1;
  OPENSSL_free(*(_QWORD **)(a2 + 8));
  *(_QWORD *)(a2 + 8) = v4;
  return v5;
}

uint64_t pkey_x25519_derive(uint64_t a1, char *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  int64x2_t *v7;
  BOOL v8;
  int v9;
  int v10;

  v3 = *(_QWORD *)(a1 + 16);
  if (!v3 || (v4 = *(_QWORD *)(a1 + 24)) == 0)
  {
    v9 = 117;
    v10 = 49;
    goto LABEL_10;
  }
  v6 = *(_QWORD *)(v3 + 8);
  v7 = *(int64x2_t **)(v4 + 8);
  if (v6)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (v8)
  {
    v9 = 117;
    v10 = 56;
LABEL_10:
    ERR_put_error(6, 0, v9, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_x25519.c", v10);
    return 0;
  }
  if (!*(_BYTE *)(v6 + 64))
  {
    v9 = 130;
    v10 = 61;
    goto LABEL_10;
  }
  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      v9 = 100;
      v10 = 67;
      goto LABEL_10;
    }
    if (!X25519(a2, (__int128 *)(v6 + 32), v7))
    {
      v9 = 134;
      v10 = 71;
      goto LABEL_10;
    }
  }
  *a3 = 32;
  return 1;
}

uint64_t pkey_x25519_ctrl(uint64_t a1, int a2)
{
  if (a2 == 3)
    return 1;
  ERR_put_error(6, 0, 101, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_x25519.c", 88);
  return 0;
}

double ec_GFp_mont_mul()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t i;
  int v10;
  double result;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unint64_t v17;
  char is_bit_set_words;
  char v19;
  char v20;
  char v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  _OWORD v26[13];
  uint64_t v27;
  _QWORD __b[866];

  v0 = MEMORY[0x1E0C80A78]();
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v7 = v0;
  __b[864] = *MEMORY[0x1E0C80C00];
  memset(__b, 170, 0x1B00uLL);
  ec_GFp_simple_point_set_to_infinity(v7, (uint64_t)__b);
  ec_GFp_simple_point_copy((uint64_t)&__b[27], v4);
  v8 = &__b[54];
  for (i = 2; i != 32; ++i)
  {
    if ((i & 1) != 0)
      ec_GFp_mont_add(v7, (uint64_t)v8, (uint64_t)&__b[27], (uint64_t)(v8 - 27));
    else
      ec_GFp_mont_dbl(v7, v8, &__b[27 * (i >> 1)]);
    v8 += 27;
  }
  v10 = BN_num_bits((const BIGNUM *)(v7 + 16));
  if (!v10)
    return ec_GFp_simple_point_set_to_infinity(v7, (uint64_t)v6);
  v12 = v10;
  v13 = v10 - 1;
  v14 = 1;
  v15 = v10;
  do
  {
    v16 = v13;
    if (!v14)
      ec_GFp_mont_dbl(v7, v6, v6);
    if (-858993459 * v16 <= 0x33333333)
    {
      v17 = *(int *)(v7 + 24);
      is_bit_set_words = bn_is_bit_set_words(v2, v17, v15 + 3);
      v19 = (8 * bn_is_bit_set_words(v2, v17, v15 + 2)) | (16 * is_bit_set_words);
      v20 = v19 | (4 * bn_is_bit_set_words(v2, v17, v15 + 1));
      v21 = v20 | (2 * bn_is_bit_set_words(v2, v17, v15));
      v22 = bn_is_bit_set_words(v2, v17, v16);
      v23 = 0;
      v27 = 0;
      v24 = (v21 | v22);
      v25 = __b;
      memset(v26, 0, sizeof(v26));
      do
      {
        ec_point_select(v7, (uint64_t *)v26, ((v23++ ^ v24) - 1) >> 63, v25, (uint64_t *)v26);
        v25 += 27;
      }
      while (v23 != 32);
      if (v14)
        *(_QWORD *)&result = ec_GFp_simple_point_copy((uint64_t)v6, (uint64_t)v26).n128_u64[0];
      else
        ec_GFp_mont_add(v7, (uint64_t)v6, (uint64_t)v6, (uint64_t)v26);
      v14 = 0;
    }
    v13 = v16 - 1;
    v15 = v16;
  }
  while (v16 - 1 < v12);
  if (v14)
    return ec_GFp_simple_point_set_to_infinity(v7, (uint64_t)v6);
  return result;
}

double ec_GFp_mont_mul_base()
{
  return ec_GFp_mont_mul();
}

double ec_GFp_mont_mul_batch()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t *v12;
  uint64_t v13;
  unsigned int v14;
  double result;
  char v16;
  unsigned int v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD v21[13];
  unint64_t v22;
  uint64_t __b[1379];

  v0 = MEMORY[0x1E0C80A78]();
  v19 = v2;
  v20 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v13 = v0;
  __b[1377] = *MEMORY[0x1E0C80C00];
  memset(__b, 170, 0x2B08uLL);
  ec_GFp_mont_batch_precomp(v13, (uint64_t)__b, v10);
  ec_GFp_mont_batch_precomp(v13, (uint64_t)&__b[459], v6);
  if (v4)
    ec_GFp_mont_batch_precomp(v13, (uint64_t)&__b[918], v4);
  v14 = BN_num_bits((const BIGNUM *)(v13 + 16));
  v16 = 0;
  v17 = v14;
  do
  {
    while (1)
    {
      if ((v16 & 1) != 0)
        ec_GFp_mont_dbl(v13, v12, v12);
      if (5 * (v17 / 5) != v17)
        break;
      v22 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v18 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v21[11] = v18;
      v21[12] = v18;
      v21[9] = v18;
      v21[10] = v18;
      v21[7] = v18;
      v21[8] = v18;
      v21[5] = v18;
      v21[6] = v18;
      v21[3] = v18;
      v21[4] = v18;
      v21[1] = v18;
      v21[2] = v18;
      v21[0] = v18;
      ec_GFp_mont_batch_get_window(v13, (uint64_t)v21, __b, v8, v17);
      if ((v16 & 1) != 0)
        ec_GFp_mont_add(v13, (uint64_t)v12, (uint64_t)v12, (uint64_t)v21);
      else
        ec_GFp_simple_point_copy((uint64_t)v12, (uint64_t)v21);
      ec_GFp_mont_batch_get_window(v13, (uint64_t)v21, &__b[459], v20, v17);
      ec_GFp_mont_add(v13, (uint64_t)v12, (uint64_t)v12, (uint64_t)v21);
      if (v4)
      {
        ec_GFp_mont_batch_get_window(v13, (uint64_t)v21, &__b[918], v19, v17);
        ec_GFp_mont_add(v13, (uint64_t)v12, (uint64_t)v12, (uint64_t)v21);
      }
      --v17;
      v16 = 1;
      if (v17 > v14)
        return result;
    }
    --v17;
  }
  while (v17 <= v14);
  if ((v16 & 1) == 0)
    return ec_GFp_simple_point_set_to_infinity(v13, (uint64_t)v12);
  return result;
}

uint64_t *ec_GFp_mont_batch_precomp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v6;
  unint64_t i;
  uint64_t *result;

  ec_GFp_simple_point_set_to_infinity(a1, a2);
  ec_GFp_simple_point_copy(a2 + 216, a3);
  v6 = (unint64_t *)(a2 + 432);
  for (i = 2; i != 17; ++i)
  {
    if ((i & 1) != 0)
      result = ec_GFp_mont_add(a1, (uint64_t)v6, a2 + 216, (uint64_t)(v6 - 27));
    else
      result = ec_GFp_mont_dbl(a1, v6, (unint64_t *)(a2 + 216 * (i >> 1)));
    v6 += 27;
  }
  return result;
}

uint64_t *ec_GFp_mont_batch_get_window(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned int a5)
{
  unint64_t v10;
  int is_bit_set_words;
  int v12;
  int v13;
  unsigned __int8 v14;
  uint64_t v15;
  __int128 v16;
  unint64_t *v17;
  _OWORD v19[4];
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;

  v10 = *(int *)(a1 + 24);
  is_bit_set_words = bn_is_bit_set_words(a4, v10, a5 + 4);
  v12 = (16 * bn_is_bit_set_words(a4, v10, a5 + 3)) | (32 * is_bit_set_words);
  v13 = v12 | (8 * bn_is_bit_set_words(a4, v10, a5 + 2));
  LOBYTE(v13) = v13 | (4 * bn_is_bit_set_words(a4, v10, a5 + 1));
  v14 = v13 & 0xFC | (2 * bn_is_bit_set_words(a4, v10, a5));
  if (a5)
    v14 = bn_is_bit_set_words(a4, v10, a5 - 1) | v14 & 0xFE;
  v22 = 0xAAAAAAAAAAAAAAAALL;
  v21 = 0xAAAAAAAAAAAAAAAALL;
  ec_GFp_nistp_recode_scalar_bits(&v22, &v21, v14);
  v15 = 0;
  *(_QWORD *)(a2 + 208) = 0;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  do
  {
    ec_point_select(a1, (uint64_t *)a2, (uint64_t)(((v21 ^ v15++) - 1) & ~v21) >> 63, a3, (uint64_t *)a2);
    a3 += 27;
  }
  while (v15 != 17);
  v20 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[2] = v16;
  v19[3] = v16;
  v19[0] = v16;
  v19[1] = v16;
  v17 = (unint64_t *)(a2 + 72);
  ec_felem_neg(a1, (unint64_t *)v19, v17);
  return ec_felem_select(a1, (uint64_t *)v17, -v22, (uint64_t *)v19, (uint64_t *)v17);
}

uint64_t ec_GFp_mont_init_precomp()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  unsigned int v10;
  __int128 v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  char *v18;
  uint64_t v19;
  _OWORD v21[13];
  uint64_t v22;
  _BYTE v23[6480];
  uint64_t v24;

  v0 = MEMORY[0x1E0C80A78]();
  v2 = v1;
  v3 = v0;
  v24 = *MEMORY[0x1E0C80C00];
  v4 = BN_num_bits((const BIGNUM *)(v0 + 56)) + 4;
  memset(v23, 170, sizeof(v23));
  v5 = *(_OWORD *)(v2 + 176);
  v21[10] = *(_OWORD *)(v2 + 160);
  v21[11] = v5;
  v21[12] = *(_OWORD *)(v2 + 192);
  v22 = *(_QWORD *)(v2 + 208);
  v6 = *(_OWORD *)(v2 + 112);
  v21[6] = *(_OWORD *)(v2 + 96);
  v21[7] = v6;
  v7 = *(_OWORD *)(v2 + 144);
  v21[8] = *(_OWORD *)(v2 + 128);
  v21[9] = v7;
  v8 = *(_OWORD *)(v2 + 48);
  v21[2] = *(_OWORD *)(v2 + 32);
  v21[3] = v8;
  v9 = *(_OWORD *)(v2 + 80);
  v21[4] = *(_OWORD *)(v2 + 64);
  v21[5] = v9;
  if (v4 / 5 <= 2)
    v10 = 2;
  else
    v10 = v4 / 5;
  v11 = *(_OWORD *)(v2 + 16);
  v12 = v10 - 1;
  v13 = 1;
  v21[0] = *(_OWORD *)v2;
  v21[1] = v11;
  do
  {
    v14 = 1 << v13;
    ec_GFp_mont_dbl(v3, (unint64_t *)&v21[-13] + 27 * v14 - 1, (unint64_t *)&v21[-13] + 27 * (v14 >> 1) - 1);
    v15 = v12;
    if (v4 >= 0xA)
    {
      do
      {
        ec_GFp_mont_dbl(v3, (unint64_t *)&v21[-13] + 27 * v14 - 1, (unint64_t *)&v21[-13] + 27 * v14 - 1);
        --v15;
      }
      while (v15);
    }
    v16 = 0;
    if (v14 <= 2)
      v17 = 2;
    else
      v17 = 1 << v13;
    v18 = (char *)v21 + 216 * v14;
    v19 = 216 * v17 - 216;
    do
    {
      ec_GFp_mont_add(v3, (uint64_t)&v18[v16], (uint64_t)v21 + 216 * ((1 << v13) - 1), (uint64_t)v21 + v16);
      v16 += 216;
    }
    while (v19 != v16);
    ++v13;
  }
  while (v13 != 5);
  return ec_jacobian_to_affine_batch(v3);
}

void ec_GFp_mont_mul_precomp(uint64_t a1, unint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  unsigned int v16;
  char v17;
  unsigned int v18;
  unsigned int v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  unint64_t v35;

  v16 = BN_num_bits((const BIGNUM *)(a1 + 56)) + 4;
  if (v16 >= 5)
  {
    v17 = 0;
    v18 = v16 / 5;
    v19 = v16 / 5 - 1;
    while ((v17 & 1) == 0)
    {
      v35 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v21 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v33 = v21;
      v34 = v21;
      v31 = v21;
      v32 = v21;
      v29 = v21;
      v30 = v21;
      v27 = v21;
      v28 = v21;
      v25 = v21;
      v26 = v21;
      v23 = v21;
      v24 = v21;
      v22 = v21;
      ec_GFp_mont_get_comb_window(a1, (uint64_t)&v22, a3, a4, v19);
      ec_GFp_simple_point_copy((uint64_t)a2, (uint64_t)&v22);
      if (a5)
        goto LABEL_8;
LABEL_9:
      if (a7)
      {
        ec_GFp_mont_get_comb_window(a1, (uint64_t)&v22, a7, a8, v19);
        ec_GFp_mont_add(a1, (uint64_t)a2, (uint64_t)a2, (uint64_t)&v22);
      }
      --v19;
      v17 = 1;
      if (v19 >= v18)
        return;
    }
    ec_GFp_mont_dbl(a1, a2, a2);
    v35 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v33 = v20;
    v34 = v20;
    v31 = v20;
    v32 = v20;
    v29 = v20;
    v30 = v20;
    v27 = v20;
    v28 = v20;
    v25 = v20;
    v26 = v20;
    v23 = v20;
    v24 = v20;
    v22 = v20;
    ec_GFp_mont_get_comb_window(a1, (uint64_t)&v22, a3, a4, v19);
    ec_GFp_mont_add(a1, (uint64_t)a2, (uint64_t)a2, (uint64_t)&v22);
    if (!a5)
      goto LABEL_9;
LABEL_8:
    ec_GFp_mont_get_comb_window(a1, (uint64_t)&v22, a5, a6, v19);
    ec_GFp_mont_add(a1, (uint64_t)a2, (uint64_t)a2, (uint64_t)&v22);
    goto LABEL_9;
  }
  ec_GFp_simple_point_set_to_infinity(a1, (uint64_t)a2);
}

uint64_t *ec_GFp_mont_get_comb_window(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, int a5)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;

  LODWORD(v13) = a5;
  v9 = *(int *)(a1 + 24);
  v10 = 0;
  LODWORD(v11) = 0;
  v12 = (BN_num_bits((const BIGNUM *)(a1 + 56)) + 4) / 5uLL;
  v13 = v13;
  do
  {
    v11 = (bn_is_bit_set_words(a4, v9, v13) << v10++) | v11;
    v13 += v12;
  }
  while (v10 != 5);
  *(_QWORD *)(a2 + 208) = 0;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  v14 = -31;
  *(_OWORD *)a2 = 0u;
  do
  {
    ec_felem_select(a1, (uint64_t *)a2, ((v11 ^ ((_DWORD)v14 + 32)) - 1) >> 63, a3, (uint64_t *)a2);
    ec_felem_select(a1, (uint64_t *)(a2 + 72), ((v11 ^ ((_DWORD)v14 + 32)) - 1) >> 63, a3 + 9, (uint64_t *)(a2 + 72));
    a3 += 18;
  }
  while (!__CFADD__(v14++, 1));
  return ec_felem_select(a1, (uint64_t *)(a2 + 144), (v11 - 1) >> 63, (uint64_t *)(a2 + 144), (uint64_t *)(a1 + 320));
}

const __CFArray *boringssl_identity_create_from_identity_array(const __CFArray *a1)
{
  const __CFArray *v1;
  boringssl_concrete_boringssl_identity *v2;
  const __CFArray *v3;
  __CFArray *v4;
  __CFArray *v5;
  OS_sec_array *certificate_sec_array_from_CFArray;
  OS_sec_array *certificates;
  __SecKey *private_key;

  v1 = a1;
  if (a1)
  {
    v2 = objc_alloc_init(boringssl_concrete_boringssl_identity);
    if (v2 && (v3 = boringssl_helper_copy_leaf_private_key_from_identity_array(v1), (v2->private_key = v3) != 0))
    {
      v4 = boringssl_helper_copy_identity_certificate_chain_from_identity_array(v1);
      if (v4)
      {
        v5 = v4;
        certificate_sec_array_from_CFArray = (OS_sec_array *)boringssl_helper_create_certificate_sec_array_from_CFArray(v4);
        certificates = v2->certificates;
        v2->certificates = certificate_sec_array_from_CFArray;

        CFRelease(v5);
      }
      if (v2->certificates)
      {
        v1 = v2;
      }
      else
      {
        private_key = v2->private_key;
        if (private_key)
          CFRelease(private_key);
        v1 = 0;
        v2->private_key = 0;
      }
    }
    else
    {
      v1 = 0;
    }

  }
  return v1;
}

const __CFArray *boringssl_identity_create_from_identity(void *a1)
{
  NSObject *v2;
  boringssl_concrete_boringssl_identity *v3;
  __SecIdentity *v4;
  const __CFArray *v5;
  uint64_t v6;
  OS_sec_array *certificates;
  sec_certificate_t v8;
  CFIndex v9;
  __SecCertificate *ValueAtIndex;
  sec_certificate_t v11;
  SecCertificateRef v12;
  SecKeyRef v14;
  SecCertificateRef certificateRef;

  v2 = a1;
  if (v2)
  {
    v3 = objc_alloc_init(boringssl_concrete_boringssl_identity);
    if (v3)
    {
      v4 = sec_identity_copy_ref(v2);
      certificateRef = 0;
      SecIdentityCopyCertificate(v4, &certificateRef);
      v5 = sec_identity_copy_certificates_ref(v2);
      objc_storeStrong((id *)&v3->identity, a1);
      v6 = sec_array_create();
      certificates = v3->certificates;
      v3->certificates = (OS_sec_array *)v6;

      v8 = sec_certificate_create(certificateRef);
      sec_array_append();
      if (v5 && CFArrayGetCount(v5) >= 1)
      {
        v9 = 0;
        do
        {
          ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v5, v9);
          v11 = sec_certificate_create(ValueAtIndex);
          sec_array_append();

          ++v9;
        }
        while (v9 < CFArrayGetCount(v5));
      }
      v14 = 0;
      if (SecIdentityCopyPrivateKey(v4, &v14))
      {
        if (certificateRef)
          CFRelease(certificateRef);
        certificateRef = 0;
        if (v4)
          CFRelease(v4);
        if (v5)
        {
          CFRelease(v5);
          v5 = 0;
        }
      }
      else
      {
        v12 = certificateRef;
        v3->private_key = v14;
        if (v12)
          CFRelease(v12);
        certificateRef = 0;
        if (v4)
          CFRelease(v4);
        if (v5)
          CFRelease(v5);
        v5 = v3;
      }

    }
    else
    {
      v5 = 0;
    }

  }
  else
  {
    v5 = 0;
  }

  return v5;
}

SecIdentityRef boringssl_identity_create_from_identity_without_certificates(void *a1)
{
  NSObject *v2;
  boringssl_concrete_boringssl_identity *v3;
  boringssl_concrete_boringssl_identity *v4;
  SecIdentityRef v5;
  SecKeyRef privateKeyRef;

  v2 = a1;
  if (v2)
  {
    v3 = objc_alloc_init(boringssl_concrete_boringssl_identity);
    v4 = v3;
    if (v3)
    {
      objc_storeStrong((id *)&v3->identity, a1);
      v5 = sec_identity_copy_ref(v2);
      privateKeyRef = 0;
      if (!SecIdentityCopyPrivateKey(v5, &privateKeyRef))
      {
        v4->private_key = privateKeyRef;
        if (v5)
          CFRelease(v5);
        v5 = v4;
        goto LABEL_11;
      }
      if (!v5)
      {
LABEL_11:

        goto LABEL_12;
      }
      CFRelease(v5);
    }
    v5 = 0;
    goto LABEL_11;
  }
  v5 = 0;
LABEL_12:

  return v5;
}

boringssl_concrete_boringssl_identity *boringssl_identity_create_from_external_identity(void *a1, void *a2, void *a3, void *a4)
{
  id v8;
  id v9;
  id v10;
  id v11;
  void *v12;
  boringssl_concrete_boringssl_identity *v13;
  boringssl_concrete_boringssl_identity *v14;
  uint64_t v15;
  id sign_block;
  uint64_t v17;
  id decrypt_block;
  boringssl_concrete_boringssl_identity *v19;

  v8 = a1;
  v9 = a2;
  v10 = a3;
  v11 = a4;
  v12 = v11;
  v13 = 0;
  if (v8 && v9 && v10 && v11)
  {
    v14 = objc_alloc_init(boringssl_concrete_boringssl_identity);
    v13 = v14;
    if (v14)
    {
      objc_storeStrong((id *)&v14->certificates, a1);
      v15 = MEMORY[0x1B5E45624](v9);
      sign_block = v13->sign_block;
      v13->sign_block = (id)v15;

      v17 = MEMORY[0x1B5E45624](v10);
      decrypt_block = v13->decrypt_block;
      v13->decrypt_block = (id)v17;

      objc_storeStrong((id *)&v13->queue, a4);
      v19 = v13;
    }

  }
  return v13;
}

id *boringssl_identity_copy_sec_identity(id *result)
{
  if (result)
    return (id *)result[3];
  return result;
}

id *boringssl_identity_copy_certificate_chain(id *result)
{
  if (result)
    return (id *)result[2];
  return result;
}

uint64_t boringssl_identity_private_key_sign(void *a1, uint64_t a2, unint64_t *a3, unint64_t a4, int a5, void *a6, void *a7, void *a8)
{
  id v15;
  id v16;
  id v17;
  id v18;
  void *v19;
  NSObject *v20;
  id v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  size_t size;
  _QWORD v27[5];
  id v28;
  id v29;
  id v30;
  id v31;
  __int16 v32;

  v15 = a1;
  v16 = a6;
  v17 = a7;
  v18 = a8;
  if (*((_QWORD *)v15 + 4) && *((_QWORD *)v15 + 6))
  {
    v19 = (void *)MEMORY[0x1B5E45624]();
    v20 = *((_QWORD *)v15 + 6);
    v27[0] = MEMORY[0x1E0C809B0];
    v27[1] = 3221225472;
    v27[2] = __boringssl_identity_private_key_sign_block_invoke;
    v27[3] = &unk_1E686F648;
    v32 = a5;
    v30 = v19;
    v27[4] = v16;
    v28 = v17;
    v29 = v15;
    v31 = v18;
    v21 = v19;
    boringssl_context_async((uint64_t)v28, v20, v27);

    v22 = 2;
  }
  else
  {
    v23 = boringssl_private_key_sign(*((__SecKey **)v15 + 1), a5, v16);
    v24 = v23;
    if (v23)
    {
      size = dispatch_data_get_size(v23);
      if (size < a4)
        a4 = size;
      boringssl_helper_dispatch_data_copyout(v24, a2, a4);
      v22 = 0;
      *a3 = a4;
    }
    else
    {
      v22 = 1;
    }

  }
  return v22;
}

void __boringssl_identity_private_key_sign_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[4];
  id v6;
  id v7;
  id v8;

  v2 = *(_QWORD *)(a1 + 56);
  v3 = *(unsigned __int16 *)(a1 + 72);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __boringssl_identity_private_key_sign_block_invoke_2;
  v5[3] = &unk_1E686F620;
  v4 = *(_QWORD *)(a1 + 32);
  v6 = *(id *)(a1 + 40);
  v7 = *(id *)(a1 + 48);
  v8 = *(id *)(a1 + 64);
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD *))(v2 + 16))(v2, v3, v4, v5);

}

void __boringssl_identity_private_key_sign_block_invoke_2(id *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  id v6;
  id v7;

  v3 = a2;
  v5 = a1[5];
  v7 = a1[6];
  v6 = a1[4];
  v4 = v3;
  nw_queue_context_async();

}

uint64_t __boringssl_identity_private_key_sign_block_invoke_3(uint64_t a1)
{
  objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 64), *(id *)(a1 + 40));
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 56) = 1;
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
}

uint64_t boringssl_identity_private_key_decrypt(void *a1, void *a2, size_t *a3, size_t a4, void *a5, void *a6, void *a7)
{
  id v13;
  NSObject *v14;
  id v15;
  id v16;
  void *v17;
  NSObject *v18;
  id v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  size_t size;
  size_t v24;
  _QWORD block[5];
  id v27;
  id v28;
  id v29;
  id v30;

  v13 = a1;
  v14 = a5;
  v15 = a6;
  v16 = a7;
  if (*((_QWORD *)v13 + 5) && *((_QWORD *)v13 + 6))
  {
    v17 = (void *)MEMORY[0x1B5E45624]();
    v18 = *((_QWORD *)v13 + 6);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __boringssl_identity_private_key_decrypt_block_invoke;
    block[3] = &unk_1E686F670;
    v29 = v17;
    block[4] = v14;
    v27 = v15;
    v28 = v13;
    v30 = v16;
    v19 = v17;
    boringssl_context_async((uint64_t)v27, v18, block);

    v20 = 2;
  }
  else
  {
    v21 = boringssl_private_key_decrypt(*((__SecKey **)v13 + 1), v14);
    v22 = v21;
    if (v21)
    {
      size = dispatch_data_get_size(v21);
      v24 = dispatch_data_get_size(v14) - size;
      bzero(a2, a4);
      boringssl_helper_dispatch_data_copyout(v22, (uint64_t)a2 + v24, size);
      v20 = 0;
      *a3 = a4;
    }
    else
    {
      v20 = 1;
    }

  }
  return v20;
}

void __boringssl_identity_private_key_decrypt_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v4[4];
  id v5;
  id v6;
  id v7;

  v2 = *(_QWORD *)(a1 + 56);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __boringssl_identity_private_key_decrypt_block_invoke_2;
  v4[3] = &unk_1E686F620;
  v3 = *(_QWORD *)(a1 + 32);
  v5 = *(id *)(a1 + 40);
  v6 = *(id *)(a1 + 48);
  v7 = *(id *)(a1 + 64);
  (*(void (**)(uint64_t, uint64_t, _QWORD *))(v2 + 16))(v2, v3, v4);

}

void __boringssl_identity_private_key_decrypt_block_invoke_2(id *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  id v6;
  id v7;

  v3 = a2;
  v5 = a1[5];
  v7 = a1[6];
  v6 = a1[4];
  v4 = v3;
  nw_queue_context_async();

}

uint64_t __boringssl_identity_private_key_decrypt_block_invoke_3(uint64_t a1)
{
  objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 72), *(id *)(a1 + 40));
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 56) = 1;
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
}

uint64_t boringssl_identity_private_key_complete(void *a1, uint64_t a2, size_t *a3, uint64_t a4)
{
  id v7;
  void *v8;
  void *v9;
  NSObject *v10;
  uint64_t v11;

  v7 = a1;
  v8 = v7;
  if (*((_QWORD *)v7 + 6))
  {
    v9 = (void *)*((_QWORD *)v7 + 8);
    if (v9 || (v9 = (void *)*((_QWORD *)v7 + 9)) != 0)
    {
      v10 = v9;
      boringssl_helper_dispatch_data_copyout(v10, a2, a4);
      *a3 = dispatch_data_get_size(v10);

      v11 = 0;
    }
    else if (*((_BYTE *)v7 + 56))
    {
      v11 = 1;
    }
    else
    {
      v11 = 2;
    }
  }
  else
  {
    v11 = 1;
  }

  return v11;
}

BOOL BN_abs_is_word(unsigned int *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = a1[2];
  if ((_DWORD)v2)
  {
    a2 ^= **(_QWORD **)a1;
    if ((int)v2 >= 2)
    {
      v3 = (uint64_t *)(*(_QWORD *)a1 + 8);
      v4 = v2 - 1;
      do
      {
        v5 = *v3++;
        a2 |= v5;
        --v4;
      }
      while (v4);
    }
  }
  return a2 == 0;
}

BOOL BN_is_one(unsigned int *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;

  if (a1[4])
    return 0;
  v2 = a1[2];
  if ((_DWORD)v2)
  {
    v3 = **(_QWORD **)a1 ^ 1;
    if ((int)v2 >= 2)
    {
      v4 = v2 - 1;
      v5 = (uint64_t *)(*(_QWORD *)a1 + 8);
      do
      {
        v6 = *v5++;
        v3 |= v6;
        --v4;
      }
      while (v4);
    }
  }
  else
  {
    v3 = 1;
  }
  return v3 == 0;
}

BOOL BN_is_word(unsigned int *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;

  v2 = a1[2];
  v3 = a2;
  if ((_DWORD)v2)
  {
    v3 = **(_QWORD **)a1 ^ a2;
    if ((int)v2 >= 2)
    {
      v4 = v2 - 1;
      v5 = (uint64_t *)(*(_QWORD *)a1 + 8);
      do
      {
        v6 = *v5++;
        v3 |= v6;
        --v4;
      }
      while (v4);
    }
  }
  if (v3)
    return 0;
  if (a2)
    return a1[4] == 0;
  return 1;
}

BOOL BN_equal_consttime(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v2 = *(int *)(a1 + 8);
  v3 = *(int *)(a2 + 8);
  if ((int)v2 >= (int)v3)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    v5 = (uint64_t *)(*(_QWORD *)a2 + 8 * v2);
    v6 = v3 - v2;
    do
    {
      v7 = *v5++;
      v4 |= v7;
      --v6;
    }
    while (v6);
  }
  if ((int)v3 < (int)v2)
  {
    v8 = (uint64_t *)(*(_QWORD *)a1 + 8 * v3);
    v9 = v2 - v3;
    do
    {
      v10 = *v8++;
      v4 |= v10;
      --v9;
    }
    while (v9);
  }
  if ((int)v2 >= (int)v3)
    v2 = v3;
  else
    v2 = v2;
  if ((int)v2 >= 1)
  {
    v11 = *(uint64_t **)a1;
    v12 = *(uint64_t **)a2;
    do
    {
      v14 = *v11++;
      v13 = v14;
      v15 = *v12++;
      v4 |= v15 ^ v13;
      --v2;
    }
    while (v2);
  }
  return (v4 | *(_DWORD *)(a2 + 16) ^ *(_DWORD *)(a1 + 16)) == 0;
}

