uint64_t tcp_cc_delay_ack(uint64_t a1, uint64_t a2)
{
  int v3;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;

  v3 = *(_DWORD *)(sysctls + 36);
  if ((v3 - 1) >= 2)
  {
    if (v3 == 3)
    {
      if (*(_DWORD *)(sysctls + 288))
      {
        v5 = tcp_sbspace(a1);
        v6 = 0xFFFF << *(_BYTE *)(a1 + 261);
        if (v5 < v6)
          v6 = v5;
        if ((*(_BYTE *)(a1 + 90) & 4) != 0
          || *(_WORD *)(a1 + 308)
          || *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 488) <= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)
                                                                                         + 496)
          || v6 > *(_DWORD *)(a1 + 132))
        {
          return 0;
        }
        v7 = *(_DWORD *)(a1 + 120) - *(_DWORD *)(a1 + 284);
        v8 = *(_DWORD *)(a1 + 196);
        if (v7 <= v8)
        {
          if (v7 >= v6 >> 2)
            return 0;
        }
        else if (v7 >= v6 >> 2 || v6 <= *(_DWORD *)(sysctls + 236) + (*(int *)(sysctls + 236) >> 1))
        {
          return 0;
        }
        if (v7 < v8 << 8)
        {
          ++*(_DWORD *)(a1 + 728);
          return 1;
        }
      }
      else
      {
        v9 = *(_DWORD *)(a1 + 88);
        if ((v9 & 0x40000) == 0 && (*(_BYTE *)(a2 + 13) & 8) == 0)
        {
          v10 = *(unsigned __int16 *)(a1 + 304);
          if (v10 == 1 || v9 < 0 && *(_DWORD *)(sysctls + 52) > v10)
            return 1;
        }
      }
    }
  }
  else if ((*(_BYTE *)(a1 + 90) & 4) == 0 && (*(_BYTE *)(a2 + 13) & 8) == 0 && *(_WORD *)(a1 + 304) == 1)
  {
    return 1;
  }
  return 0;
}

uint64_t tcp_sbspace(uint64_t a1)
{
  _DWORD *v2;
  _DWORD *v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v10;
  uint64_t result;
  int v12;
  unsigned int v13;

  v2 = *(_DWORD **)(*(_QWORD *)(a1 + 80) + 224);
  v3 = v2 + 122;
  v4 = *(_DWORD *)(a1 + 196);
  v5 = v2[123];
  if (*(_DWORD *)(sysctls + 40) != 1
    && (v2[92] & 0x4000) == 0
    && *(_DWORD *)(sysctls + 68) == 1
    && !(*(_DWORD *)(a1 + 88) & 0x80000 | v2[92] & 0x40))
  {
    v6 = 16 * v4;
    if (v5 - *v3 < 16 * v4)
    {
      v7 = *(_DWORD *)(sysctls + 72);
      if (v5 < v7)
      {
        v8 = v2[135];
        if (v8 && v5 <= v8 + v6)
        {
          if (v5 + v6 >= v7)
            v10 = *(_DWORD *)(sysctls + 72);
          else
            v10 = v5 + v6;
          sbreserve((uint64_t)(v2 + 122), v10);
          v5 = v2[123];
          v4 = *(_DWORD *)(a1 + 196);
        }
      }
    }
  }
  result = (v5 - *v3) & ~((int)(v5 - *v3) >> 31);
  if ((int)result >= v4 && (*(_BYTE *)(a1 + 90) & 8) != 0)
  {
    v12 = *(_DWORD *)(sysctls + 48);
    if ((int)result >= v12)
      v13 = *(_DWORD *)(sysctls + 48);
    else
      v13 = (v5 - *v3) & ~((int)(v5 - *v3) >> 31);
    if (v12 <= 0)
      return result;
    else
      return v13;
  }
  return result;
}

uint64_t __nw_protocol_tcp_initialize_globals_block_invoke()
{
  uint64_t result;

  tcp_input_batch_size = networkd_settings_get_int64_with_default();
  tcp_batch_ack_max = networkd_settings_get_int64_with_default();
  tcp_perf_measurement = networkd_settings_get_BOOL();
  g_use_slab_allocator = networkd_settings_get_int64_with_default() == 0;
  result = networkd_settings_get_int64_with_default();
  tcp_timerlist_max_offset = result;
  return result;
}

int *nw_protocol_tcp_identifier()
{
  if (nw_protocol_tcp_identifier_onceToken != -1)
    dispatch_once(&nw_protocol_tcp_identifier_onceToken, &__block_literal_global);
  return &nw_protocol_tcp_identifier_identifier;
}

void nw_tcp_init_globals(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  _QWORD *v6;
  NSObject *v7;
  void *v8;
  NSObject *v9;
  void *v10;

  v4 = malloc_type_calloc(1uLL, 0x48uLL, 0xEAFB8F1AuLL);
  if (!v4)
  {
    v7 = __nwlog_obj();
    os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    v8 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
      goto LABEL_8;
    free(v8);
  }
  *(_QWORD *)(a1 + 72) = v4;
  sysctls = nw_path_get_sysctls_region();
  tcp_init(a1);
  xmmword_253CF8870 = 0u;
  unk_253CF8880 = 0u;
  xmmword_253CF8850 = 0u;
  unk_253CF8860 = 0u;
  xmmword_253CF8830 = 0u;
  unk_253CF8840 = 0u;
  tcp_cc_algo_none = 0u;
  unk_253CF8820 = 0u;
  tcp_cc_algo_list[0] = (uint64_t)&tcp_cc_algo_none;
  *(_QWORD *)algn_253CF88F8 = tcp_cc_newreno;
  qword_253CF8900 = (uint64_t)tcp_cc_ledbat;
  unk_253CF8908 = tcp_cc_cubic;
  qword_253CF8910 = (uint64_t)tcp_cc_prague;
  v5 = malloc_type_calloc(0x64uLL, 8uLL, 0xEAFB8F1AuLL);
  if (v5)
  {
LABEL_3:
    *(_QWORD *)(a1 + 32) = v5;
    *(_DWORD *)(a1 + 312) = arc4random();
    nw_protocol_tcp_timer_init(a1, a2, 1);
    nw_protocol_tcp_timer_init(a1, a2, 0);
    *(_QWORD *)(a1 + 144) = 0;
    v6 = (_QWORD *)(a1 + 144);
    v6[1] = v6;
    v6[2] = 0;
    v6[3] = v6 + 2;
    v6[4] = 0;
    v6[5] = v6 + 4;
    v6[6] = 0;
    v6[7] = v6 + 6;
    v6[8] = 0;
    v6[9] = v6 + 8;
    v6[10] = 0;
    v6[11] = v6 + 10;
    return;
  }
  v9 = __nwlog_obj();
  os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
  v10 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort())
  {
    free(v10);
    goto LABEL_3;
  }
LABEL_8:
  __break(1u);
}

void nw_protocol_tcp_timer_init(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t source;
  void *v6;
  NSObject *v7;
  uint8_t buf[4];
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (a3)
    v4 = 88;
  else
    v4 = 96;
  source = nw_queue_context_create_source();
  *(_QWORD *)(a1 + v4) = source;
  if (source)
  {
    if ((networkd_settings_get_BOOL() & 1) == 0)
      nw_queue_source_set_qos_class_fallback();
    nw_queue_activate_source();
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v9 = "nw_protocol_tcp_timer_init";
    v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v9 = "nw_protocol_tcp_timer_init";
        _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_ERROR, "%{public}s nw_queue_context_create_source failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v6)
      free(v6);
  }
}

void tcp_init(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  NSObject *v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  void *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  uint8_t buf[4];
  const char *v21;
  int __buf;
  const char *v23;
  __int16 v24;
  _QWORD *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a1 + 328) & 0x40) != 0)
    return;
  *(_BYTE *)(a1 + 328) |= 0x40u;
  v2 = sysctls;
  v3 = *(_DWORD *)(sysctls + 240);
  *(_QWORD *)(a1 + 240) = v3 / 0xF4240uLL;
  *(_DWORD *)(a1 + 248) = v3 % 0xF4240;
  *(_DWORD *)(a1 + 316) = *(_DWORD *)(v2 + 244);
  arc4random_buf(&__buf, 0x10uLL);
  if (CCCryptorCreate(0, 0, 2u, &__buf, 0x10uLL, 0, (CCCryptorRef *)(a1 + 80)))
  {
    v4 = __nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v21 = "aes_encrypt_key128";
      _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_ERROR, "%{public}s CCCryptorCreate", buf, 0xCu);
    }
  }
  v5 = *(_QWORD **)(a1 + 72);
  v5[3] = tcp_itimer;
  v5[4] = a1 + 104;
  v5[2] = tcp_gc;
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 324) = 128;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 120) = a1 + 112;
  v6 = (_QWORD *)(a1 + 112);
  do
  {
    v6 = (_QWORD *)*v6;
    if (!v6)
    {
      *v5 = 0;
      v5[1] = a1 + 112;
      *(_QWORD *)(a1 + 112) = v5;
      *(_QWORD *)(a1 + 120) = v5;
      goto LABEL_18;
    }
  }
  while (v6 != v5);
  __nwlog_obj();
  __buf = 136446466;
  v23 = "in_pcbinfo_attach";
  v24 = 2048;
  v25 = v5;
  v7 = (void *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  if (__nwlog_fault())
  {
    if (buf[0] == 17)
    {
      v8 = __nwlog_obj();
      v9 = buf[0];
      if (!os_log_type_enabled(v8, (os_log_type_t)buf[0]))
        goto LABEL_16;
      __buf = 136446466;
      v23 = "in_pcbinfo_attach";
      v24 = 2048;
      v25 = v5;
      v10 = "%{public}s ipi %p already in the list";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = buf[0];
      if (!os_log_type_enabled(v8, (os_log_type_t)buf[0]))
        goto LABEL_16;
      __buf = 136446466;
      v23 = "in_pcbinfo_attach";
      v24 = 2048;
      v25 = v5;
      v10 = "%{public}s ipi %p already in the list, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v8, v9, v10, (uint8_t *)&__buf, 0x16u);
  }
LABEL_16:
  if (v7)
    free(v7);
LABEL_18:
  v11 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
  if (v11)
    *v11 = 32;
  *(_QWORD *)(a1 + 40) = v11;
  v12 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
  if (v12)
  {
    *v12 = 48;
    *(_QWORD *)(a1 + 48) = v12;
    v13 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
    if (v13)
      *v13 = 24;
    *(_QWORD *)(a1 + 56) = v13;
    v14 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
    if (v14)
      *v14 = 88;
    *(_QWORD *)(a1 + 128) = 0;
    v15 = a1 + 128;
    *(_QWORD *)(v15 - 64) = v14;
    *(_QWORD *)(v15 + 8) = v15;
    *(_OWORD *)(v15 + 128) = 0u;
    *(_OWORD *)(v15 + 144) = 0u;
    *(_OWORD *)(v15 + 160) = 0u;
    *(_QWORD *)(v15 + 176) = 0;
    return;
  }
  *(_QWORD *)(a1 + 48) = 0;
  __nwlog_obj();
  __buf = 136446210;
  v23 = "tcp_init";
  v16 = (void *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  if (__nwlog_fault())
  {
    if (buf[0] == 17)
    {
      v17 = __nwlog_obj();
      v18 = buf[0];
      if (!os_log_type_enabled(v17, (os_log_type_t)buf[0]))
        goto LABEL_33;
      __buf = 136446210;
      v23 = "tcp_init";
      v19 = "%{public}s failed allocating tcp_reass_zone";
    }
    else
    {
      v17 = __nwlog_obj();
      v18 = buf[0];
      if (!os_log_type_enabled(v17, (os_log_type_t)buf[0]))
        goto LABEL_33;
      __buf = 136446210;
      v23 = "tcp_init";
      v19 = "%{public}s failed allocating tcp_reass_zone, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v17, v18, v19, (uint8_t *)&__buf, 0xCu);
  }
LABEL_33:
  if (v16)
    free(v16);
}

uint64_t __nw_protocol_tcp_wake_send_block_invoke(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  NSObject *v7;
  _DWORD *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  NSObject *v15;
  const char *v16;
  int v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 40);
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 5224) == 2)
  {
    v3 = *(_DWORD *)(v2 + 384);
    v4 = *(_DWORD *)(v2 + 388) - v3;
    v5 = *(_DWORD *)(v2 + 484);
    v6 = v5 - v3;
    if (v6 >= v4)
      v6 = v4;
    if (v5)
      v4 = v6;
    if ((v4 & ~(v4 >> 31)) >= *(_DWORD *)(v2 + 392))
    {
      nw_protocol_get_input_handler();
      nw_protocol_output_available_quiet();
    }
    else if ((*(_BYTE *)(v2 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v7 = __nwlog_tcp_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          v8 = *(_DWORD **)(a1 + 40);
          v9 = v8[98];
          v10 = v8[96];
          v11 = v8[97] - v10;
          v12 = v8[121];
          v13 = v12 - v10;
          if (v13 >= v11)
            v13 = v11;
          if (v12)
            v14 = v13;
          else
            v14 = v11;
          v18 = 136446978;
          v19 = "nw_protocol_tcp_wake_send_block_invoke";
          v20 = 2082;
          v21 = (const char *)(v2 + 604);
          v22 = 1024;
          v23 = v9;
          v24 = 1024;
          v25 = v14 & ~(v14 >> 31);
          _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Ignoring wake low_water %u sbpace %u", (uint8_t *)&v18, 0x22u);
        }
      }
    }
  }
  else if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v15 = __nwlog_tcp_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        v16 = "";
        if (v2)
          v16 = (const char *)(v2 + 604);
        v18 = 136446466;
        v19 = "nw_protocol_tcp_wake_send_block_invoke";
        v20 = 2082;
        v21 = v16;
        _os_log_impl(&dword_209FB3000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v18, 0x16u);
      }
    }
  }
  return nw_protocol_release();
}

uint64_t tcp_log_packet(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  int v4;

  result = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
  if (result && (*(_BYTE *)(result + 828) & 6) == 0)
  {
    v3 = nw_tcp_access_globals(result);
    if (*(_DWORD *)(a1 + 1776))
      nw_log_ms_to_delta();
    v4 = *(_DWORD *)(v3 + 316);
    if (!v4)
      v4 = -1;
    *(_DWORD *)(a1 + 1776) = v4;
    return nw_log_ring_append();
  }
  return result;
}

uint64_t nw_protocol_tcp_create()
{
  uint64_t v0;
  uint64_t v1;
  void *v3;
  NSObject *v4;
  __int128 buf;
  uint64_t (*v6)(uint64_t, int, int, int, int);
  uint64_t (*v7)(uint64_t, int);
  uint64_t (*v8)(uint64_t, int);
  uint64_t (*v9)(os_unfair_lock_s *);
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (nw_protocol_tcp_identifier_onceToken != -1)
    dispatch_once(&nw_protocol_tcp_identifier_onceToken, &__block_literal_global);
  if (nw_protocol_tcp_callbacks_onceToken != -1)
    dispatch_once(&nw_protocol_tcp_callbacks_onceToken, &__block_literal_global_9);
  v0 = nw_protocol_new();
  if (v0)
  {
    v1 = v0;
    if (nw_protocol_tcp_initialize_globals_onceToken != -1)
      dispatch_once(&nw_protocol_tcp_initialize_globals_onceToken, &__block_literal_global_32);
    *(_DWORD *)(v1 + 5264) = 0;
    MEMORY[0x20BD1E818](v1 + 5184);
    *(_QWORD *)(v1 + 5232) = nw_tcp_create_metadata();
    *(_QWORD *)&buf = nw_protocol_tcp_get_receive_buffer_size;
    *((_QWORD *)&buf + 1) = nw_protocol_tcp_get_send_buffer_size;
    v6 = nw_protocol_tcp_reset_keepalives;
    v7 = nw_protocol_tcp_set_no_delay;
    v8 = nw_protocol_tcp_set_no_push;
    v9 = nw_protocol_tcp_set_no_wake_from_sleep;
    nw_tcp_set_callbacks();
    return nw_protocol_upcast();
  }
  else
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(_QWORD *)((char *)&buf + 4) = "__nw_protocol_tcp_create";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = "__nw_protocol_tcp_create";
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_ERROR, "%{public}s nw_protocol_tcp_obj_alloc failed, backtrace limit exceeded", (uint8_t *)&buf, 0xCu);
      }
    }
    if (v3)
      free(v3);
    return 0;
  }
}

uint64_t __tcp_input_get_aggregate_frames_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  void *v10;
  uint64_t result;
  void *v12;
  NSObject *v13;
  NSObject *v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  const void *v22;
  uint64_t v23;
  unsigned int v24;
  void *v25;
  uint64_t v26;
  unsigned int v27;
  _DWORD *v28;
  uint64_t v29;
  NSObject *v30;
  const char *v31;
  int v32;
  uint64_t v33;
  _QWORD *v34;
  void (*v35)(uint64_t, uint64_t, uint64_t);
  uint64_t v36;
  NSObject *v37;
  void *v38;
  void *v39;
  NSObject *v40;
  void *v41;
  NSObject *v42;
  void *v43;
  NSObject *v44;
  void *v45;
  NSObject *v46;
  unsigned int v47;
  int v48;
  NSObject *v49;
  int v50;
  uint64_t v51;
  unsigned int v52;
  void *v53;
  NSObject *v54;
  void *v55;
  NSObject *v56;
  uint8_t buf[4];
  const char *v58;
  __int16 v59;
  _BYTE v60[10];
  _BYTE v61[6];
  const void *v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    v9 = __nwlog_obj();
    os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v58 = "tcp_input_get_aggregate_frames_block_invoke";
    v10 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort();
    if ((_DWORD)result)
      goto LABEL_95;
    free(v10);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v58 = "__nw_frame_unclaimed_bytes";
    v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "__nw_frame_unclaimed_bytes";
        _os_log_impl(&dword_209FB3000, v13, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v12)
      free(v12);
    goto LABEL_17;
  }
  if (!*(_QWORD *)(a2 + 112)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && *MEMORY[0x24BDE08C0]
    && !((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(a2, *(_QWORD *)(a2 + 88)))
  {
LABEL_17:
    v6 = 0;
    goto LABEL_18;
  }
  v5 = *(_DWORD *)(a2 + 52);
  v4 = *(unsigned int *)(a2 + 56);
  if (v5)
  {
    v6 = v5 - (v4 + *(_DWORD *)(a2 + 60));
    v7 = *(_QWORD *)(a2 + 112);
    if (!v7)
    {
LABEL_18:
      v14 = __nwlog_obj();
      os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v58 = "tcp_input_get_aggregate_frames_block_invoke";
      v15 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort();
      if (!(_DWORD)result)
      {
        free(v15);
        v8 = 0;
        goto LABEL_20;
      }
LABEL_95:
      __break(1u);
      return result;
    }
  }
  else
  {
    v6 = 0;
    v7 = *(_QWORD *)(a2 + 112);
    if (!v7)
      goto LABEL_18;
  }
  v8 = v7 + v4;
LABEL_20:
  *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
  v16 = (_QWORD *)a1[7];
  v17 = v16[65];
  if (!v17)
    goto LABEL_77;
  v18 = 0;
  while (1)
  {
    if (*(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) >= v6)
    {
LABEL_74:
      if ((v18 & 1) == 0)
        goto LABEL_77;
      goto LABEL_75;
    }
    v19 = *(_DWORD *)(v17 + 52);
    v20 = v19 ? v19 - (*(_DWORD *)(v17 + 56) + *(_DWORD *)(v17 + 60)) : 0;
    if (*(_QWORD *)(*v16 + 240))
    {
      v21 = *(_QWORD *)(v17 + 112);
      if (v21
        && ((*(_WORD *)(v17 + 204) & 0x100) == 0
         || !*MEMORY[0x24BDE08C0]
         || ((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v17, *(_QWORD *)(v17 + 88))
         && (v21 = *(_QWORD *)(v17 + 112)) != 0))
      {
        v22 = (const void *)(v21 + *(unsigned int *)(v17 + 56));
      }
      else
      {
        v22 = 0;
        if ((*(_WORD *)(v17 + 204) & 0x100) != 0)
        {
          if (*MEMORY[0x24BDE08C0])
          {
            v22 = 0;
            if ((((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v17, *(_QWORD *)(v17 + 88)) & 1) == 0)
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1[7] + 240) + 1056) = 0;
          }
        }
      }
    }
    else
    {
      v22 = 0;
    }
    v18 |= (unsigned __int16)(*(_WORD *)(v17 + 204) & 0x4000) >> 14;
    if (v20)
    {
      if (v22)
        break;
    }
    v29 = a1[7];
    if (!v29 || (*(_BYTE *)(v29 + 828) & 2) == 0)
    {
      v30 = __nwlog_tcp_log();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
      {
        v31 = (const char *)(v29 + 604);
        *(_DWORD *)buf = 136446978;
        if (!v29)
          v31 = "";
        v58 = "tcp_input_get_aggregate_frames_block_invoke";
        v59 = 2082;
        *(_QWORD *)v60 = v31;
        *(_WORD *)&v60[8] = 1024;
        *(_DWORD *)v61 = v20;
        *(_WORD *)&v61[4] = 2048;
        v62 = v22;
        _os_log_impl(&dword_209FB3000, v30, OS_LOG_TYPE_INFO, "%{public}s %{public}s skipping empty input frame (length %u bytes %p)", buf, 0x26u);
      }
    }
    v26 = a1[7];
    if (*(_DWORD *)(v26 + 552) < v20)
    {
      v40 = __nwlog_obj();
      os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v58 = "tcp_input_get_aggregate_frames_block_invoke";
      v41 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort();
      if ((_DWORD)result)
        goto LABEL_95;
      free(v41);
      v26 = a1[7];
    }
    v27 = *(_DWORD *)(v26 + 488);
    if (v27 < v20)
    {
      v42 = __nwlog_obj();
      os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v58 = "tcp_input_get_aggregate_frames_block_invoke";
      v43 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort();
      if ((_DWORD)result)
        goto LABEL_95;
      free(v43);
      v26 = a1[7];
      v27 = *(_DWORD *)(v26 + 488);
    }
    v28 = (_DWORD *)(v26 + 488);
    *(_DWORD *)(v26 + 552) -= v20;
LABEL_48:
    *v28 = v27 - v20;
    v32 = *(_DWORD *)(v26 + 548);
    if (!v32)
    {
      v37 = __nwlog_obj();
      os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v58 = "tcp_input_get_aggregate_frames_block_invoke";
      v38 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort();
      if ((_DWORD)result)
        goto LABEL_95;
      free(v38);
      v26 = a1[7];
      v32 = *(_DWORD *)(v26 + 548);
    }
    *(_DWORD *)(v26 + 548) = v32 - 1;
    v33 = *(_QWORD *)(v17 + 32);
    v34 = *(_QWORD **)(v17 + 40);
    if (v33)
    {
      *(_QWORD *)(v33 + 40) = v34;
      v34 = *(_QWORD **)(v17 + 40);
    }
    else
    {
      *(_QWORD *)(v26 + 528) = v34;
    }
    *v34 = v33;
    v35 = *(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 80);
    *(_QWORD *)(v17 + 32) = 0;
    *(_QWORD *)(v17 + 40) = 0;
    if (v35)
    {
      v36 = *(_QWORD *)(v17 + 88);
      *(_QWORD *)(v17 + 80) = 0;
      *(_QWORD *)(v17 + 88) = 0;
      v35(v17, 1, v36);
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v58 = "__nw_frame_finalize";
      v39 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v46 = __nwlog_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v58 = "__nw_frame_finalize";
          _os_log_impl(&dword_209FB3000, v46, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v39)
        free(v39);
    }
    v16 = (_QWORD *)a1[7];
    v17 = v16[65];
    if (!v17)
      goto LABEL_74;
  }
  v23 = *(unsigned int *)(*(_QWORD *)(a1[4] + 8) + 24);
  v24 = v6 - v23;
  v25 = (void *)(v8 + v23);
  if (v6 - v23 >= v20)
  {
    memcpy(v25, v22, v20);
    *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) += v20;
    *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24) += v20;
    v26 = a1[7];
    v27 = *(_DWORD *)(v26 + 552);
    if (v27 < v20)
    {
      v44 = __nwlog_obj();
      os_log_type_enabled(v44, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v58 = "tcp_input_get_aggregate_frames_block_invoke";
      v45 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort();
      if ((_DWORD)result)
        goto LABEL_95;
      free(v45);
      v26 = a1[7];
      v27 = *(_DWORD *)(v26 + 552);
    }
    v28 = (_DWORD *)(v26 + 552);
    goto LABEL_48;
  }
  memcpy(v25, v22, v6 - v23);
  if ((*(_WORD *)(v17 + 204) & 0x80) != 0)
    *(_WORD *)(v17 + 196) -= v24;
  v47 = *(_DWORD *)(v17 + 56) + v24;
  v48 = *(_DWORD *)(v17 + 60);
  if (v47 <= *(_DWORD *)(v17 + 52) - v48)
  {
    *(_DWORD *)(v17 + 56) = v47;
  }
  else
  {
    v49 = __nwlog_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      v50 = *(_DWORD *)(v17 + 52);
      *(_DWORD *)buf = 136446978;
      v58 = "__nw_frame_claim_internal";
      v59 = 1024;
      *(_DWORD *)v60 = v47;
      *(_WORD *)&v60[4] = 1024;
      *(_DWORD *)&v60[6] = v50;
      *(_WORD *)v61 = 1024;
      *(_DWORD *)&v61[2] = v48;
      _os_log_impl(&dword_209FB3000, v49, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
    }
  }
  *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) += v24;
  *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24) += v24;
  v51 = a1[7];
  v52 = *(_DWORD *)(v51 + 552);
  if (v52 < v24)
  {
    v54 = __nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v58 = "tcp_input_get_aggregate_frames_block_invoke";
    v55 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort();
    if ((_DWORD)result)
      goto LABEL_95;
    free(v55);
    v51 = a1[7];
    v52 = *(_DWORD *)(v51 + 552);
  }
  *(_DWORD *)(v51 + 552) = v52 - v24;
  if ((v18 & 1) == 0)
    goto LABEL_77;
LABEL_75:
  if (a2)
  {
    *(_WORD *)(a2 + 204) |= 0x4000u;
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v58 = "__nw_frame_set_is_wake_packet";
    v53 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v56 = __nwlog_obj();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "__nw_frame_set_is_wake_packet";
        _os_log_impl(&dword_209FB3000, v56, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v53)
      free(v53);
  }
LABEL_77:
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
  return 1;
}

BOOL tcp_input_get_aggregate_frames(uint64_t a1, unsigned int a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  unsigned int v7;
  _BOOL8 v8;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  _QWORD v14[3];
  int v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  int v19;

  v16 = 0;
  v17 = &v16;
  v19 = 0;
  v18 = 0x2000000000;
  v14[0] = 0;
  v14[1] = v14;
  v15 = 0;
  v14[2] = 0x2000000000;
  v10 = 0;
  v11 = &v10;
  v13 = 0;
  v12 = 0x2000000000;
  v7 = *(_DWORD *)(a1 + 552);
  if (v7 && *(_QWORD *)(a1 + 520))
  {
    if (v7 < a2)
      a2 = *(_DWORD *)(a1 + 552);
    if (nw_protocol_tcp_get_frames(a1, a2, a5, -1, 0, 0))
      nw_frame_array_foreach();
  }
  if (a3)
    *a3 = *((_DWORD *)v17 + 6);
  if (a4)
    *a4 = *((_DWORD *)v11 + 6);
  v8 = *((_DWORD *)v17 + 6) != 0;
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(&v16, 8);
  return v8;
}

uint64_t nw_protocol_tcp_get_frames(uint64_t a1, signed int a2, uint64_t a3, int a4, int *a5, char a6)
{
  int *v6;
  unsigned int v7;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  unsigned int v17;
  _QWORD *v18;
  uint64_t *v19;
  unsigned int v20;
  unsigned int frame_count;
  unsigned int v22;
  uint64_t v23;
  int v24;
  uint64_t result;
  uint64_t external;
  _BYTE *v27;
  uint64_t *v28;
  uint64_t *v29;
  _QWORD *v30;
  int v31;
  _QWORD *v32;
  unsigned int v33;
  _QWORD *v34;
  void *v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  _QWORD *v39;
  unsigned int v40;
  void *v41;
  NSObject *v42;
  os_log_type_t v43;
  const char *v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  uint64_t *v51;
  _QWORD *v52;
  uint64_t v53;
  int v54;
  uint64_t *v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  _BYTE *v64;
  uint64_t *v65;
  uint64_t *v66;
  uint64_t v67;
  int v68;
  unsigned int v69;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  _QWORD *v73;
  _QWORD *v74;
  void *v75;
  __int16 v76;
  int v77;
  int v78;
  int v79;
  unsigned int v80;
  int v81;
  NSObject *v82;
  int v83;
  size_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unsigned int v88;
  BOOL v89;
  unsigned int v90;
  uint64_t v91;
  void *v92;
  uint64_t v93;
  NSObject *v94;
  os_log_type_t v95;
  const char *v96;
  void *v97;
  _BOOL4 v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  NSObject *v105;
  int v106;
  NSObject *v107;
  void *v108;
  NSObject *v109;
  uint64_t v110;
  NSObject *v111;
  uint64_t *v112;
  _QWORD *v113;
  uint64_t v114;
  void *v115;
  NSObject *v116;
  os_log_type_t v117;
  const char *v118;
  void *backtrace_string;
  NSObject *v120;
  _BOOL4 v121;
  NSObject *v122;
  os_log_type_t v123;
  unsigned int v124;
  int malloc_frame;
  char v126;
  uint64_t *v127;
  _QWORD *v128;
  uint64_t v129;
  int v130;
  NSObject *v131;
  uint64_t v132;
  uint64_t v133;
  char v134;
  unsigned int v135;
  void *v136;
  NSObject *v137;
  os_log_type_t v138;
  const char *v139;
  NSObject *v140;
  void *v141;
  unsigned int v142;
  void *v143;
  NSObject *v144;
  os_log_type_t v145;
  const char *v146;
  void *v147;
  NSObject *v148;
  os_log_type_t v149;
  _BOOL4 v150;
  void *v151;
  _BOOL4 v152;
  void *v153;
  NSObject *v154;
  os_log_type_t v155;
  _BOOL4 v156;
  void *v157;
  _BOOL4 v158;
  NSObject *v159;
  os_log_type_t v160;
  NSObject *v161;
  void *v162;
  NSObject *v163;
  os_log_type_t v164;
  NSObject *v165;
  void *v166;
  NSObject *log;
  NSObject *v168;
  NSObject *v169;
  unsigned int v170;
  uint64_t v171;
  uint64_t v172;
  os_log_type_t type[4];
  unsigned int v177;
  uint64_t v178;
  uint64_t *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  char v183;
  __int128 buf;
  uint64_t (*v185)(uint64_t, uint64_t);
  void *v186;
  uint64_t *v187;
  uint64_t v188;
  _QWORD *v189;
  uint8_t v190[4];
  const char *v191;
  __int16 v192;
  _BYTE v193[10];
  uint64_t v194;
  __int16 v195;
  uint64_t v196;
  __int16 v197;
  void *v198;
  uint64_t v199;

  v6 = a5;
  v7 = a4;
  v10 = a1;
  v199 = *MEMORY[0x24BDAC8D0];
  if ((a6 & 1) == 0)
  {
    if (!g_use_slab_allocator)
      return nw_protocol_tcp_get_malloc_frame(a1, a2, a3, a4, a5);
    v178 = 0;
    v179 = &v178;
    v180 = 0x2800000000;
    v181 = 0;
    v182 = 0;
    v177 = 0;
    if (a3)
    {
      if (a4)
      {
        if (a2 < 1)
          goto LABEL_248;
        if (a5)
          *a5 = 0;
        if (a1)
        {
          v17 = a2;
          if (*(_QWORD *)(a1 + 40))
          {
LABEL_17:
            v18 = (_QWORD *)nw_tcp_access_globals(v10);
            v19 = v179;
            v179[3] = 0;
            v19[4] = (uint64_t)(v19 + 3);
            v20 = nw_context_2k_buffer_length();
            frame_count = nw_protocol_tcp_get_frame_count(v17, v20, (int *)&v177);
            if (frame_count > v7 || (v22 = frame_count, frame_count - 3 < 0xFFFFFFFE))
            {
              v40 = nw_context_8k_buffer_length();
              if (nw_protocol_tcp_get_frame_count(v17, v40, (int *)&v177) == 1)
              {
                v23 = nw_context_8k_buffer_manager();
                v22 = 1;
                v24 = nw_context_8k_buffer_length();
              }
              else
              {
                v45 = nw_context_16k_buffer_length();
                v46 = nw_protocol_tcp_get_frame_count(v17, v45, (int *)&v177);
                if (v46 > v7 || (v22 = v46, v46 - 3 < 0xFFFFFFFE))
                {
                  v47 = nw_context_64k_buffer_length();
                  if (nw_protocol_tcp_get_frame_count(v17, v47, (int *)&v177) == 1)
                  {
                    v23 = nw_context_64k_buffer_manager();
                    v22 = 1;
                    v24 = nw_context_64k_buffer_length();
                  }
                  else
                  {
                    v48 = nw_context_128k_buffer_length();
                    v22 = nw_protocol_tcp_get_frame_count(v17, v48, (int *)&v177);
                    v23 = nw_context_128k_buffer_manager();
                    v24 = nw_context_128k_buffer_length();
                  }
                }
                else
                {
                  v23 = nw_context_16k_buffer_manager();
                  v24 = nw_context_16k_buffer_length();
                }
              }
            }
            else
            {
              v23 = nw_context_2k_buffer_manager();
              v24 = nw_context_2k_buffer_length();
            }
            v49 = v24;
            if (v23)
            {
              if (v22 > v7)
              {
                *(_DWORD *)type = 0;
                v50 = a2;
                if (nw_protocol_tcp_get_malloc_frame(v10, a2, (uint64_t)(v179 + 3), 1, type))
                {
                  v51 = v179;
                  v52 = v179 + 3;
                  v53 = v179[3];
                  if (v53)
                  {
                    **(_QWORD **)(a3 + 8) = v53;
                    *(_QWORD *)(v51[3] + 40) = *(_QWORD *)(a3 + 8);
                    *(_QWORD *)(a3 + 8) = v51[4];
                    v51[3] = 0;
                    v51[4] = (uint64_t)v52;
                  }
                  if (v6)
                    *v6 = *(_DWORD *)type;
                  goto LABEL_171;
                }
                v109 = __nwlog_obj();
                if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v190 = 136446722;
                  v191 = "nw_protocol_tcp_get_slab_frame";
                  v192 = 1024;
                  *(_DWORD *)v193 = v22;
                  *(_WORD *)&v193[4] = 1024;
                  *(_DWORD *)&v193[6] = v7;
                  _os_log_impl(&dword_209FB3000, v109, OS_LOG_TYPE_ERROR, "%{public}s requested frame count %u larger than max frame count %u", v190, 0x18u);
                }
                _Block_object_dispose(&v178, 8);
                v110 = a3;
                return nw_protocol_tcp_get_malloc_frame(v10, v50, v110, v7, v6);
              }
              v171 = v10;
              v170 = v7;
              v54 = 0;
              while (1)
              {
                v57 = nw_mem_buffer_allocate();
                if (!v57)
                {
                  v10 = v171;
                  if (__nwlog_is_datapath_logging_enabled())
                  {
                    v111 = __nwlog_obj();
                    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)v190 = 136446466;
                      v191 = "nw_protocol_tcp_get_slab_frame";
                      v192 = 1024;
                      *(_DWORD *)v193 = v49;
                      _os_log_impl(&dword_209FB3000, v111, OS_LOG_TYPE_DEBUG, "%{public}s failed to allocate slab buffer of size %u", v190, 0x12u);
                    }
                  }
LABEL_165:
                  v50 = a2;
                  v124 = a2 - v54;
                  if (a2 == v54)
                  {
                    v161 = __nwlog_obj();
                    os_log_type_enabled(v161, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)v190 = 136446210;
                    v191 = "nw_protocol_tcp_get_slab_frame";
                    v162 = (void *)_os_log_send_and_compose_impl();
                    result = __nwlog_abort();
                    if ((_DWORD)result)
                      goto LABEL_275;
                    free(v162);
                    v6 = a5;
                    v50 = a2;
                    v10 = v171;
                  }
                  *(_DWORD *)type = 0;
                  malloc_frame = nw_protocol_tcp_get_malloc_frame(v10, v124, (uint64_t)(v179 + 3), 1, type);
                  v126 = malloc_frame;
                  v7 = v170;
                  if (malloc_frame)
                  {
                    v127 = v179;
                    v128 = v179 + 3;
                    v129 = v179[3];
                    v110 = a3;
                    if (v129)
                    {
                      **(_QWORD **)(a3 + 8) = v129;
                      *(_QWORD *)(v127[3] + 40) = *(_QWORD *)(a3 + 8);
                      *(_QWORD *)(a3 + 8) = v127[4];
                      v127[3] = 0;
                      v127[4] = (uint64_t)v128;
                    }
                    if (v6)
                    {
                      v130 = *v6 + *(_DWORD *)type;
                      goto LABEL_180;
                    }
LABEL_171:
                    _Block_object_dispose(&v178, 8);
                    return 1;
                  }
                  v131 = __nwlog_obj();
                  if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v190 = 136446466;
                    v191 = "nw_protocol_tcp_get_slab_frame";
                    v192 = 1024;
                    *(_DWORD *)v193 = v124;
                    _os_log_impl(&dword_209FB3000, v131, OS_LOG_TYPE_ERROR, "%{public}s tcp get malloc failed for %u bytes", v190, 0x12u);
                  }
                  *(_QWORD *)&buf = MEMORY[0x24BDAC760];
                  *((_QWORD *)&buf + 1) = 0x40000000;
                  v185 = __nw_protocol_tcp_get_slab_frame_block_invoke;
                  v186 = &unk_24C2B28C0;
                  v187 = &v178;
                  v188 = v23;
                  v189 = v18;
                  v132 = v179[3];
                  do
                  {
                    if (!v132)
                      break;
                    v133 = *(_QWORD *)(v132 + 32);
                    v134 = ((uint64_t (*)(__int128 *))v185)(&buf);
                    v132 = v133;
                  }
                  while ((v134 & 1) != 0);
                  v110 = a3;
                  v50 = a2;
                  if (v179[3])
                  {
                    v165 = __nwlog_obj();
                    os_log_type_enabled(v165, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)v190 = 136446210;
                    v191 = "nw_protocol_tcp_get_slab_frame";
                    v166 = (void *)_os_log_send_and_compose_impl();
                    result = __nwlog_abort();
                    if ((_DWORD)result)
                      goto LABEL_275;
                    free(v166);
                    v6 = a5;
                    v110 = a3;
                    v50 = a2;
                    v7 = v170;
                    v10 = v171;
                    if (a5)
                      goto LABEL_179;
                  }
                  else if (v6)
                  {
LABEL_179:
                    v130 = 0;
LABEL_180:
                    *v6 = v130;
                  }
                  _Block_object_dispose(&v178, 8);
                  if ((v126 & 1) == 0)
                    return nw_protocol_tcp_get_malloc_frame(v10, v50, v110, v7, v6);
                  return 1;
                }
                v58 = v57;
                v59 = v18[26];
                if (v59)
                {
                  v61 = *(_QWORD *)(v59 + 16);
                  v62 = *(_QWORD **)(v59 + 24);
                  v60 = (_QWORD *)(v59 + 16);
                  if (v61)
                  {
                    *(_QWORD *)(v61 + 24) = v62;
                    v62 = *(_QWORD **)(v59 + 24);
                  }
                  else
                  {
                    v18[27] = v62;
                  }
                  *v62 = v61;
                  *v60 = 0;
                  *(_QWORD *)(v59 + 24) = 0;
                  v66 = (uint64_t *)v18[29];
                  *(_QWORD *)(v59 + 24) = v66;
                  *v66 = v59;
                  v18[29] = v60;
                  v67 = v18[3];
                  if (v67 <= 0)
                  {
                    v107 = __nwlog_obj();
                    os_log_type_enabled(v107, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)v190 = 136446210;
                    v191 = "nw_protocol_tcp_get_slab_frame";
                    v108 = (void *)_os_log_send_and_compose_impl();
                    result = __nwlog_abort();
                    if ((_DWORD)result)
                      goto LABEL_275;
                    free(v108);
                    v67 = v18[3];
                  }
                  v18[3] = v67 - 1;
                  v68 = *(unsigned __int16 *)(v59 + 204);
                  *(_QWORD *)(v59 + 80) = nw_frame_tcp_finalize;
                  *(_QWORD *)(v59 + 88) = v18;
                  *(_QWORD *)(v59 + 112) = v58;
                  *(_QWORD *)(v59 + 104) = 0;
                  *(_WORD *)(v59 + 196) = 0;
                  *(_DWORD *)(v59 + 48) = v49;
                  *(_DWORD *)(v59 + 52) = v49;
                  *(_QWORD *)(v59 + 56) = 0;
                  *(_DWORD *)(v59 + 192) = 0;
                  *(_BYTE *)(v59 + 200) = 0;
                  v69 = v68 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v59 + 206) << 16);
                  *(_WORD *)(v59 + 204) = v69;
                  *(_BYTE *)(v59 + 206) = BYTE2(v69);
                  v70 = *(_QWORD **)(v59 + 64);
                  if (v70)
                  {
                    do
                    {
                      v71 = (_QWORD *)*v70;
                      v72 = (void *)v70[6];
                      v73 = (_QWORD *)*v70;
                      if (v72)
                      {
                        nw_release(v72);
                        v70[6] = 0;
                        v73 = (_QWORD *)*v70;
                      }
                      v74 = (_QWORD *)v70[1];
                      if (v73)
                      {
                        v73[1] = v74;
                        v74 = (_QWORD *)v70[1];
                      }
                      else
                      {
                        *(_QWORD *)(v59 + 72) = v74;
                      }
                      *v74 = v73;
                      if (v70 != (_QWORD *)(v59 + 120))
                        free(v70);
                      v70 = v71;
                    }
                    while (v71);
                  }
                  *(_QWORD *)(v59 + 64) = 0;
                  *(_QWORD *)(v59 + 72) = v59 + 64;
                  v75 = *(void **)(v59 + 168);
                  if (v75)
                    nw_release(v75);
                  v76 = *(_WORD *)(v59 + 204);
                  *(_QWORD *)(v59 + 184) = 0;
                  *(_OWORD *)(v59 + 168) = 0u;
                  *(_OWORD *)(v59 + 152) = 0u;
                  *(_OWORD *)(v59 + 136) = 0u;
                  *(_OWORD *)(v59 + 120) = 0u;
                  *(_WORD *)(v59 + 204) = v76 & 0x213F;
                  *(_BYTE *)(v59 + 203) = 0;
                  *(_WORD *)(v59 + 198) = 0;
                  *(_QWORD *)(v59 + 104) = v23;
                  v6 = a5;
                }
                else
                {
                  v63 = nw_frame_create();
                  if (!v63)
                  {
                    __nwlog_obj();
                    *(_DWORD *)v190 = 136446210;
                    v191 = "nw_protocol_tcp_get_slab_frame";
                    v115 = (void *)_os_log_send_and_compose_impl();
                    type[0] = OS_LOG_TYPE_ERROR;
                    v183 = 0;
                    if (!__nwlog_fault())
                      goto LABEL_162;
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      v116 = __nwlog_obj();
                      v117 = type[0];
                      if (os_log_type_enabled(v116, type[0]))
                      {
                        *(_DWORD *)v190 = 136446210;
                        v191 = "nw_protocol_tcp_get_slab_frame";
                        v118 = "%{public}s nw_frame_create failed";
                        goto LABEL_160;
                      }
                      goto LABEL_162;
                    }
                    if (v183)
                    {
                      backtrace_string = (void *)__nw_create_backtrace_string();
                      v120 = __nwlog_obj();
                      v121 = os_log_type_enabled(v120, type[0]);
                      if (backtrace_string)
                      {
                        if (v121)
                        {
                          *(_DWORD *)v190 = 136446466;
                          v191 = "nw_protocol_tcp_get_slab_frame";
                          v192 = 2082;
                          *(_QWORD *)v193 = backtrace_string;
                          _os_log_impl(&dword_209FB3000, v120, type[0], "%{public}s nw_frame_create failed, dumping backtrace:%{public}s", v190, 0x16u);
                        }
                        free(backtrace_string);
                        goto LABEL_162;
                      }
                      if (!v121)
                      {
LABEL_162:
                        if (v115)
                          free(v115);
                        nw_mem_buffer_free();
                        v10 = v171;
                        goto LABEL_165;
                      }
                      *(_DWORD *)v190 = 136446210;
                      v191 = "nw_protocol_tcp_get_slab_frame";
                      v118 = "%{public}s nw_frame_create failed, no backtrace";
                      v122 = v120;
                      v123 = type[0];
                    }
                    else
                    {
                      v116 = __nwlog_obj();
                      v117 = type[0];
                      if (!os_log_type_enabled(v116, type[0]))
                        goto LABEL_162;
                      *(_DWORD *)v190 = 136446210;
                      v191 = "nw_protocol_tcp_get_slab_frame";
                      v118 = "%{public}s nw_frame_create failed, backtrace limit exceeded";
LABEL_160:
                      v122 = v116;
                      v123 = v117;
                    }
                    _os_log_impl(&dword_209FB3000, v122, v123, v118, v190, 0xCu);
                    goto LABEL_162;
                  }
                  v59 = v63;
                  v64 = (*(_WORD *)(v63 + 204) & 4) != 0 ? (_BYTE *)(v63 + 208) : 0;
                  *v64 |= 1u;
                  *(_QWORD *)(v63 + 104) = v23;
                  *(_QWORD *)(v63 + 16) = 0;
                  v65 = (uint64_t *)v18[29];
                  *(_QWORD *)(v63 + 24) = v65;
                  *v65 = v63;
                  v18[29] = v63 + 16;
                }
                v77 = v49;
                if (v22 == 1)
                {
                  v78 = v177;
                  v77 = v49;
                  if (v177)
                    break;
                }
LABEL_133:
                if (v6)
                  ++*v6;
                v54 += v77;
                *(_QWORD *)(v59 + 32) = 0;
                v55 = v179;
                v56 = (uint64_t *)v179[4];
                *(_QWORD *)(v59 + 40) = v56;
                *v56 = v59;
                v55[4] = v59 + 32;
                if (!--v22)
                {
                  v112 = v179;
                  v113 = v179 + 3;
                  v114 = v179[3];
                  if (v114)
                  {
                    **(_QWORD **)(a3 + 8) = v114;
                    *(_QWORD *)(v112[3] + 40) = *(_QWORD *)(a3 + 8);
                    *(_QWORD *)(a3 + 8) = v112[4];
                    v112[3] = 0;
                    v112[4] = (uint64_t)v113;
                  }
                  goto LABEL_171;
                }
              }
              if ((*(_WORD *)(v59 + 204) & 0x80) != 0)
                *(_WORD *)(v59 + 196) -= v177;
              v79 = *(_DWORD *)(v59 + 52);
              v80 = *(_DWORD *)(v59 + 56) + v78;
              v81 = *(_DWORD *)(v59 + 60);
              if (v80 <= v79 - v81)
              {
                *(_DWORD *)(v59 + 56) = v80;
                v6 = a5;
                if (!v79)
                {
LABEL_126:
                  v102 = v177;
                  if ((*(_WORD *)(v59 + 204) & 0x80) != 0)
                    *(_WORD *)(v59 + 196) += v177;
                  v103 = *(_DWORD *)(v59 + 56);
                  v89 = v103 >= v102;
                  v104 = v103 - v102;
                  if (v89)
                  {
                    *(_DWORD *)(v59 + 56) = v104;
                  }
                  else
                  {
                    v105 = __nwlog_obj();
                    if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
                    {
                      v106 = *(_DWORD *)(v59 + 56);
                      *(_DWORD *)v190 = 136446722;
                      v191 = "__nw_frame_unclaim_internal";
                      v192 = 1024;
                      *(_DWORD *)v193 = v102;
                      *(_WORD *)&v193[4] = 1024;
                      *(_DWORD *)&v193[6] = v106;
                      _os_log_impl(&dword_209FB3000, v105, OS_LOG_TYPE_ERROR, "%{public}s Frame cannot unclaim %u start bytes (has %u left)", v190, 0x18u);
                    }
                  }
                  v77 = v177;
                  goto LABEL_133;
                }
              }
              else
              {
                v82 = __nwlog_obj();
                if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
                {
                  v83 = *(_DWORD *)(v59 + 52);
                  *(_DWORD *)v190 = 136446978;
                  v191 = "__nw_frame_claim_internal";
                  v192 = 1024;
                  *(_DWORD *)v193 = v80;
                  *(_WORD *)&v193[4] = 1024;
                  *(_DWORD *)&v193[6] = v83;
                  LOWORD(v194) = 1024;
                  *(_DWORD *)((char *)&v194 + 2) = v81;
                  _os_log_impl(&dword_209FB3000, v82, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", v190, 0x1Eu);
                }
                v79 = *(_DWORD *)(v59 + 52);
                v6 = a5;
                if (!v79)
                  goto LABEL_126;
              }
              v85 = *(unsigned int *)(v59 + 56);
              v84 = *(unsigned int *)(v59 + 60);
              v86 = (v79 - (v84 + v85));
              if (v79 == (_DWORD)v84 + (_DWORD)v85)
                goto LABEL_126;
              if ((_DWORD)v84)
              {
                v87 = *(_QWORD *)(v59 + 112);
                if (v87)
                {
                  memmove((void *)(v87 + v85), (const void *)(v87 + v85 + v86), v84);
                  v79 = *(_DWORD *)(v59 + 52);
                }
              }
              *(_DWORD *)(v59 + 52) = v79 - v86;
              if ((*(_WORD *)(v59 + 204) & 0x80) == 0)
                goto LABEL_126;
              v88 = *(unsigned __int16 *)(v59 + 196);
              v89 = v88 >= v86;
              v90 = v88 - v86;
              *(_WORD *)(v59 + 196) = v90;
              if (v89 && v90 < 0x10000)
                goto LABEL_126;
              __nwlog_obj();
              v91 = *(unsigned __int16 *)(v59 + 196);
              *(_DWORD *)v190 = 136446978;
              v191 = "__nw_frame_collapse";
              v192 = 2082;
              *(_QWORD *)v193 = "frame->aggregate_buffer_length";
              *(_WORD *)&v193[8] = 2048;
              v194 = v86;
              v195 = 2048;
              v196 = v91;
              v92 = (void *)_os_log_send_and_compose_impl();
              type[0] = OS_LOG_TYPE_ERROR;
              v183 = 0;
              if (__nwlog_fault())
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  v168 = __nwlog_obj();
                  if (os_log_type_enabled(v168, type[0]))
                  {
                    v93 = *(unsigned __int16 *)(v59 + 196);
                    *(_DWORD *)v190 = 136446978;
                    v191 = "__nw_frame_collapse";
                    v192 = 2082;
                    *(_QWORD *)v193 = "frame->aggregate_buffer_length";
                    *(_WORD *)&v193[8] = 2048;
                    v194 = v86;
                    v195 = 2048;
                    v196 = v93;
                    v94 = v168;
                    v95 = type[0];
                    v96 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_122:
                    _os_log_impl(&dword_209FB3000, v94, v95, v96, v190, 0x2Au);
                  }
                }
                else if (v183)
                {
                  v97 = (void *)__nw_create_backtrace_string();
                  log = __nwlog_obj();
                  v98 = os_log_type_enabled(log, type[0]);
                  if (v97)
                  {
                    if (v98)
                    {
                      v99 = *(unsigned __int16 *)(v59 + 196);
                      *(_DWORD *)v190 = 136447234;
                      v191 = "__nw_frame_collapse";
                      v192 = 2082;
                      *(_QWORD *)v193 = "frame->aggregate_buffer_length";
                      *(_WORD *)&v193[8] = 2048;
                      v194 = v86;
                      v195 = 2048;
                      v196 = v99;
                      v197 = 2082;
                      v198 = v97;
                      _os_log_impl(&dword_209FB3000, log, type[0], "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", v190, 0x34u);
                    }
                    free(v97);
                    goto LABEL_123;
                  }
                  if (v98)
                  {
                    v101 = *(unsigned __int16 *)(v59 + 196);
                    *(_DWORD *)v190 = 136446978;
                    v191 = "__nw_frame_collapse";
                    v192 = 2082;
                    *(_QWORD *)v193 = "frame->aggregate_buffer_length";
                    *(_WORD *)&v193[8] = 2048;
                    v194 = v86;
                    v195 = 2048;
                    v196 = v101;
                    v94 = log;
                    v95 = type[0];
                    v96 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                    goto LABEL_122;
                  }
                }
                else
                {
                  v169 = __nwlog_obj();
                  if (os_log_type_enabled(v169, type[0]))
                  {
                    v100 = *(unsigned __int16 *)(v59 + 196);
                    *(_DWORD *)v190 = 136446978;
                    v191 = "__nw_frame_collapse";
                    v192 = 2082;
                    *(_QWORD *)v193 = "frame->aggregate_buffer_length";
                    *(_WORD *)&v193[8] = 2048;
                    v194 = v86;
                    v195 = 2048;
                    v196 = v100;
                    v94 = v169;
                    v95 = type[0];
                    v96 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                    goto LABEL_122;
                  }
                }
              }
LABEL_123:
              if (v92)
                free(v92);
              *(_WORD *)(v59 + 196) = 0;
              goto LABEL_126;
            }
LABEL_248:
            _Block_object_dispose(&v178, 8);
            v110 = a3;
            v50 = a2;
            return nw_protocol_tcp_get_malloc_frame(v10, v50, v110, v7, v6);
          }
          v142 = a4;
          __nwlog_obj();
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_tcp_access_context";
          v143 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v183 = 0;
          if (__nwlog_fault())
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v144 = __nwlog_obj();
              v145 = type[0];
              if (!os_log_type_enabled(v144, type[0]))
                goto LABEL_264;
              *(_DWORD *)v190 = 136446210;
              v191 = "nw_tcp_access_context";
              v146 = "%{public}s called with null tcp";
              goto LABEL_262;
            }
            if (!v183)
            {
              v144 = __nwlog_obj();
              v145 = type[0];
              if (!os_log_type_enabled(v144, type[0]))
                goto LABEL_264;
              *(_DWORD *)v190 = 136446210;
              v191 = "nw_tcp_access_context";
              v146 = "%{public}s called with null tcp, backtrace limit exceeded";
              goto LABEL_262;
            }
            v157 = (void *)__nw_create_backtrace_string();
            v154 = __nwlog_obj();
            v155 = type[0];
            v158 = os_log_type_enabled(v154, type[0]);
            if (v157)
            {
              if (v158)
              {
                *(_DWORD *)v190 = 136446466;
                v191 = "nw_tcp_access_context";
                v192 = 2082;
                *(_QWORD *)v193 = v157;
                _os_log_impl(&dword_209FB3000, v154, type[0], "%{public}s called with null tcp, dumping backtrace:%{public}s", v190, 0x16u);
              }
              free(v157);
              if (!v143)
                goto LABEL_266;
              goto LABEL_265;
            }
            if (v158)
            {
              *(_DWORD *)v190 = 136446210;
              v191 = "nw_tcp_access_context";
              v146 = "%{public}s called with null tcp, no backtrace";
              goto LABEL_274;
            }
          }
        }
        else
        {
          v142 = a4;
          __nwlog_obj();
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_tcp_access_context";
          v143 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v183 = 0;
          if (!__nwlog_fault())
            goto LABEL_264;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v144 = __nwlog_obj();
            v145 = type[0];
            if (!os_log_type_enabled(v144, type[0]))
              goto LABEL_264;
            *(_DWORD *)v190 = 136446210;
            v191 = "nw_tcp_access_context";
            v146 = "%{public}s called with null so";
LABEL_262:
            v163 = v144;
            v164 = v145;
LABEL_263:
            _os_log_impl(&dword_209FB3000, v163, v164, v146, v190, 0xCu);
            goto LABEL_264;
          }
          if (!v183)
          {
            v144 = __nwlog_obj();
            v145 = type[0];
            if (!os_log_type_enabled(v144, type[0]))
              goto LABEL_264;
            *(_DWORD *)v190 = 136446210;
            v191 = "nw_tcp_access_context";
            v146 = "%{public}s called with null so, backtrace limit exceeded";
            goto LABEL_262;
          }
          v153 = (void *)__nw_create_backtrace_string();
          v154 = __nwlog_obj();
          v155 = type[0];
          v156 = os_log_type_enabled(v154, type[0]);
          if (v153)
          {
            if (v156)
            {
              *(_DWORD *)v190 = 136446466;
              v191 = "nw_tcp_access_context";
              v192 = 2082;
              *(_QWORD *)v193 = v153;
              _os_log_impl(&dword_209FB3000, v154, type[0], "%{public}s called with null so, dumping backtrace:%{public}s", v190, 0x16u);
            }
            free(v153);
          }
          else if (v156)
          {
            *(_DWORD *)v190 = 136446210;
            v191 = "nw_tcp_access_context";
            v146 = "%{public}s called with null so, no backtrace";
LABEL_274:
            v163 = v154;
            v164 = v155;
            goto LABEL_263;
          }
        }
LABEL_264:
        if (!v143)
        {
LABEL_266:
          v6 = a5;
          v17 = a2;
          v7 = v142;
          goto LABEL_17;
        }
LABEL_265:
        free(v143);
        goto LABEL_266;
      }
      v172 = a1;
      v135 = 0;
      __nwlog_obj();
      *(_DWORD *)v190 = 136446210;
      v191 = "nw_protocol_tcp_get_slab_frame";
      v136 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v183 = 0;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v137 = __nwlog_obj();
          v138 = type[0];
          if (!os_log_type_enabled(v137, type[0]))
            goto LABEL_245;
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null (max_frame_count > 0)";
          goto LABEL_243;
        }
        if (!v183)
        {
          v137 = __nwlog_obj();
          v138 = type[0];
          v6 = a5;
          if (!os_log_type_enabled(v137, type[0]))
            goto LABEL_245;
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null (max_frame_count > 0), backtrace limit exceeded";
          goto LABEL_243;
        }
        v151 = (void *)__nw_create_backtrace_string();
        v148 = __nwlog_obj();
        v149 = type[0];
        v152 = os_log_type_enabled(v148, type[0]);
        if (v151)
        {
          if (v152)
          {
            *(_DWORD *)v190 = 136446466;
            v191 = "nw_protocol_tcp_get_slab_frame";
            v192 = 2082;
            *(_QWORD *)v193 = v151;
            _os_log_impl(&dword_209FB3000, v148, type[0], "%{public}s called with null (max_frame_count > 0), dumping backtrace:%{public}s", v190, 0x16u);
          }
          free(v151);
          v6 = a5;
          if (!v136)
            goto LABEL_247;
          goto LABEL_246;
        }
        v6 = a5;
        if (v152)
        {
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null (max_frame_count > 0), no backtrace";
          goto LABEL_257;
        }
      }
    }
    else
    {
      v172 = a1;
      v135 = a4;
      __nwlog_obj();
      *(_DWORD *)v190 = 136446210;
      v191 = "nw_protocol_tcp_get_slab_frame";
      v136 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v183 = 0;
      if (!__nwlog_fault())
        goto LABEL_245;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v137 = __nwlog_obj();
        v138 = type[0];
        if (!os_log_type_enabled(v137, type[0]))
          goto LABEL_245;
        *(_DWORD *)v190 = 136446210;
        v191 = "nw_protocol_tcp_get_slab_frame";
        v139 = "%{public}s called with null ret_frame_array";
LABEL_243:
        v159 = v137;
        v160 = v138;
LABEL_244:
        _os_log_impl(&dword_209FB3000, v159, v160, v139, v190, 0xCu);
        goto LABEL_245;
      }
      if (!v183)
      {
        v137 = __nwlog_obj();
        v138 = type[0];
        v6 = a5;
        if (!os_log_type_enabled(v137, type[0]))
          goto LABEL_245;
        *(_DWORD *)v190 = 136446210;
        v191 = "nw_protocol_tcp_get_slab_frame";
        v139 = "%{public}s called with null ret_frame_array, backtrace limit exceeded";
        goto LABEL_243;
      }
      v147 = (void *)__nw_create_backtrace_string();
      v148 = __nwlog_obj();
      v149 = type[0];
      v150 = os_log_type_enabled(v148, type[0]);
      if (v147)
      {
        if (v150)
        {
          *(_DWORD *)v190 = 136446466;
          v191 = "nw_protocol_tcp_get_slab_frame";
          v192 = 2082;
          *(_QWORD *)v193 = v147;
          _os_log_impl(&dword_209FB3000, v148, type[0], "%{public}s called with null ret_frame_array, dumping backtrace:%{public}s", v190, 0x16u);
        }
        free(v147);
        v6 = a5;
      }
      else
      {
        v6 = a5;
        if (v150)
        {
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null ret_frame_array, no backtrace";
LABEL_257:
          v159 = v148;
          v160 = v149;
          goto LABEL_244;
        }
      }
    }
LABEL_245:
    if (!v136)
    {
LABEL_247:
      v7 = v135;
      v10 = v172;
      goto LABEL_248;
    }
LABEL_246:
    free(v136);
    goto LABEL_247;
  }
  if (!a3)
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    v41 = (void *)_os_log_send_and_compose_impl();
    v190[0] = 16;
    LOBYTE(v178) = 0;
    if (!__nwlog_fault())
      goto LABEL_150;
    if (v190[0] == 17)
    {
      v42 = __nwlog_obj();
      v43 = v190[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v190[0]))
        goto LABEL_150;
      LODWORD(buf) = 136446210;
      *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      v44 = "%{public}s called with null ret_frame_array";
    }
    else
    {
      v42 = __nwlog_obj();
      v43 = v190[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v190[0]))
        goto LABEL_150;
      LODWORD(buf) = 136446210;
      *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      v44 = "%{public}s called with null ret_frame_array, backtrace limit exceeded";
    }
    goto LABEL_149;
  }
  if (!a4)
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    v41 = (void *)_os_log_send_and_compose_impl();
    v190[0] = 16;
    LOBYTE(v178) = 0;
    if (!__nwlog_fault())
      goto LABEL_150;
    if (v190[0] == 17)
    {
      v42 = __nwlog_obj();
      v43 = v190[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v190[0]))
        goto LABEL_150;
      LODWORD(buf) = 136446210;
      *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      v44 = "%{public}s called with null (max_frame_count > 0)";
    }
    else
    {
      v42 = __nwlog_obj();
      v43 = v190[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v190[0]))
        goto LABEL_150;
      LODWORD(buf) = 136446210;
      *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      v44 = "%{public}s called with null (max_frame_count > 0), backtrace limit exceeded";
    }
    goto LABEL_149;
  }
  v11 = (_QWORD *)nw_tcp_access_globals(a1);
  v12 = v11;
  if (v6)
    *v6 = 0;
  v13 = v11[22];
  if (!v13)
  {
    external = nw_frame_create_external();
    if (external)
    {
      if ((*(_WORD *)(external + 204) & 4) != 0)
        v27 = (_BYTE *)(external + 208);
      else
        v27 = 0;
      *v27 |= 2u;
      *(_QWORD *)(external + 16) = 0;
      v28 = (uint64_t *)v12[25];
      *(_QWORD *)(external + 24) = v28;
      *v28 = external;
      v12[25] = external + 16;
      *(_QWORD *)(external + 32) = 0;
      v29 = *(uint64_t **)(a3 + 8);
      *(_QWORD *)(external + 40) = v29;
      *v29 = external;
      *(_QWORD *)(a3 + 8) = external + 32;
      result = 1;
      if (v6)
        *v6 = 1;
      return result;
    }
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    v41 = (void *)_os_log_send_and_compose_impl();
    v190[0] = 16;
    LOBYTE(v178) = 0;
    if (!__nwlog_fault())
      goto LABEL_150;
    if (v190[0] == 17)
    {
      v42 = __nwlog_obj();
      v43 = v190[0];
      if (os_log_type_enabled(v42, (os_log_type_t)v190[0]))
      {
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
        v44 = "%{public}s nw_frame_create_external failed";
LABEL_149:
        _os_log_impl(&dword_209FB3000, v42, v43, v44, (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      v42 = __nwlog_obj();
      v43 = v190[0];
      if (os_log_type_enabled(v42, (os_log_type_t)v190[0]))
      {
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
        v44 = "%{public}s nw_frame_create_external failed, backtrace limit exceeded";
        goto LABEL_149;
      }
    }
LABEL_150:
    if (v41)
      free(v41);
    return 0;
  }
  v15 = *(_QWORD *)(v13 + 16);
  v16 = *(_QWORD **)(v13 + 24);
  v14 = (_QWORD *)(v13 + 16);
  if (v15)
  {
    *(_QWORD *)(v15 + 24) = v16;
    v16 = *(_QWORD **)(v13 + 24);
  }
  else
  {
    v11[23] = v16;
  }
  *v16 = v15;
  *v14 = 0;
  *(_QWORD *)(v13 + 24) = 0;
  v30 = (_QWORD *)v11[25];
  *(_QWORD *)(v13 + 24) = v30;
  *v30 = v13;
  v11[25] = v14;
  --v11[2];
  LODWORD(v30) = *(unsigned __int16 *)(v13 + 204);
  v31 = v30 | (*(unsigned __int8 *)(v13 + 206) << 16);
  if ((v30 & 2) == 0)
  {
    v140 = __nwlog_obj();
    os_log_type_enabled(v140, OS_LOG_TYPE_ERROR);
    LODWORD(buf) = 136446210;
    *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    v141 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort();
    if ((_DWORD)result)
    {
LABEL_275:
      __break(1u);
      return result;
    }
    free(v141);
    v31 = *(unsigned __int16 *)(v13 + 204) | (*(unsigned __int8 *)(v13 + 206) << 16);
  }
  v32 = *(_QWORD **)(v13 + 64);
  *(_QWORD *)(v13 + 80) = nw_frame_tcp_finalize;
  *(_QWORD *)(v13 + 88) = v12;
  *(_QWORD *)(v13 + 104) = 0;
  *(_QWORD *)(v13 + 112) = 0;
  *(_WORD *)(v13 + 196) = 0;
  *(_DWORD *)(v13 + 48) = a2;
  *(_DWORD *)(v13 + 52) = a2;
  *(_QWORD *)(v13 + 56) = 0;
  *(_DWORD *)(v13 + 192) = 0;
  *(_BYTE *)(v13 + 200) = 0;
  v33 = v31 & 0xFFFFFFC7;
  *(_WORD *)(v13 + 204) = v33;
  *(_BYTE *)(v13 + 206) = BYTE2(v33);
  if (v32)
  {
    do
    {
      v34 = (_QWORD *)*v32;
      v35 = (void *)v32[6];
      v36 = (_QWORD *)*v32;
      if (v35)
      {
        nw_release(v35);
        v32[6] = 0;
        v36 = (_QWORD *)*v32;
      }
      v37 = (_QWORD *)v32[1];
      if (v36)
      {
        v36[1] = v37;
        v37 = (_QWORD *)v32[1];
      }
      else
      {
        *(_QWORD *)(v13 + 72) = v37;
      }
      *v37 = v36;
      if (v32 != (_QWORD *)(v13 + 120))
        free(v32);
      v32 = v34;
    }
    while (v34);
  }
  *(_QWORD *)(v13 + 64) = 0;
  *(_QWORD *)(v13 + 72) = v13 + 64;
  v38 = *(void **)(v13 + 168);
  if (v38)
    nw_release(v38);
  *(_QWORD *)(v13 + 184) = 0;
  *(_OWORD *)(v13 + 168) = 0u;
  *(_OWORD *)(v13 + 152) = 0u;
  *(_OWORD *)(v13 + 136) = 0u;
  *(_OWORD *)(v13 + 120) = 0u;
  *(_WORD *)(v13 + 204) &= 0x213Fu;
  *(_BYTE *)(v13 + 203) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 198) = 0;
  v39 = *(_QWORD **)(a3 + 8);
  *(_QWORD *)(v13 + 40) = v39;
  *v39 = v13;
  *(_QWORD *)(a3 + 8) = v13 + 32;
  result = 1;
  if (a5)
    *a5 = 1;
  return result;
}

double calculate_tcp_clock(uint64_t a1)
{
  _OWORD *v2;
  uint64_t v3;
  int v4;
  double result;
  unsigned int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  __int128 v19;

  v2 = (_OWORD *)(a1 + 240);
  v3 = *(_QWORD *)(a1 + 240);
  v4 = *(_DWORD *)(a1 + 248);
  v19 = 0uLL;
  microuptime((uint64_t)&v19);
  v6 = v4 + 1000;
  if (v4 >= -1000)
  {
    if (v6 <= 0xF423F)
      goto LABEL_6;
    v7 = -1000000;
    v8 = 1;
  }
  else
  {
    v7 = 1000000;
    v8 = -1;
  }
  v3 += v8;
  v6 += v7;
LABEL_6:
  v9 = v19;
  v10 = (uint64_t)v19 <= v3;
  if ((_QWORD)v19 == v3)
    v10 = SDWORD2(v19) <= (int)v6;
  if (!v10)
  {
    *(_QWORD *)a1 = v19;
    v11 = *(_QWORD *)(a1 + 240);
    v12 = v11 < v9;
    if (v11 == v9)
      v12 = *(_DWORD *)(a1 + 248) < SDWORD2(v19);
    if (v12)
    {
      microuptime((uint64_t)&v19);
      v13 = v19 - *(_QWORD *)(a1 + 240);
      v14 = DWORD2(v19) - *(_DWORD *)(a1 + 248);
      if (v14 < 0)
      {
        v15 = 1000000;
        v16 = -1;
      }
      else
      {
        if (v14 <= 0xF423F)
        {
LABEL_18:
          v17 = v14 / 1000 + 1000 * v13;
          v18 = v14 % 1000 + *(_DWORD *)(a1 + 320);
          if (v18 >= 0x3E8)
            v17 += v18 / 0x3E8;
          if (v17)
          {
            result = *(double *)&v19;
            *v2 = v19;
            *(_DWORD *)(a1 + 320) = v18 % 0x3E8;
            *(_DWORD *)(a1 + 316) += v17;
          }
          return result;
        }
        v15 = -1000000;
        v16 = 1;
      }
      LODWORD(v13) = v16 + v13;
      v14 += v15;
      goto LABEL_18;
    }
  }
  return result;
}

void microuptime(uint64_t a1)
{
  kern_return_t v2;
  kern_return_t v3;
  NSObject *v4;
  uint64_t v5;
  mach_timebase_info info;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  kern_return_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  info = 0;
  v2 = mach_timebase_info(&info);
  if (v2)
  {
    v3 = v2;
    v4 = __nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v8 = "microuptime";
      v9 = 1024;
      v10 = v3;
      _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_ERROR, "%{public}s mach_timebase_info returned %u", buf, 0x12u);
    }
  }
  else
  {
    v5 = mach_absolute_time() * info.numer / info.denom;
    *(_QWORD *)a1 = v5 / 0x3B9ACA00;
    *(_DWORD *)(a1 + 8) = v5 % 0x3B9ACA00 / 0x3E8;
  }
}

uint64_t nw_protocol_tcp_get_frame_count(unsigned int a1, unsigned int a2, int *a3)
{
  uint64_t result;
  void *v5;
  NSObject *v6;
  uint8_t buf[4];
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    result = (a1 + a2 - 1) / a2;
    if (a3)
      *a3 = a1 % a2;
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v8 = "nw_protocol_tcp_get_frame_count";
    v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v8 = "nw_protocol_tcp_get_frame_count";
        _os_log_impl(&dword_209FB3000, v6, OS_LOG_TYPE_ERROR, "%{public}s called with null (buffer_size > 0), backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v5)
      free(v5);
    return 0;
  }
  return result;
}

void nw_protocol_tcp_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int v4;
  void *v5;
  NSObject *v6;
  const char *v7;
  uint8_t buf[4];
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (nw_protocol_downcast())
    {
      if (a3)
      {
        v4 = a3[1] & 0xFFFFFFF8 | 4;
        *a3 = -1;
        a3[1] = v4;
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v9 = "nw_protocol_tcp_get_message_properties";
    v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v9 = "nw_protocol_tcp_get_message_properties";
        v7 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_14;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v9 = "nw_protocol_tcp_get_message_properties";
    v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v9 = "nw_protocol_tcp_get_message_properties";
        v7 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_14:
        _os_log_impl(&dword_209FB3000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
      }
    }
  }
  if (v5)
    free(v5);
}

BOOL nw_protocol_tcp_finalize_output_frames(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  _BOOL8 v9;
  void *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  _QWORD v15[2];
  uint64_t (*v16)(_QWORD *);
  void *v17;
  os_log_type_t *v18;
  __int128 *p_buf;
  uint64_t v20;
  os_log_type_t type[8];
  os_log_type_t *v22;
  uint64_t v23;
  char v24;
  char v25;
  __int128 buf;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v4 = nw_protocol_downcast();
    if (v4)
    {
      v5 = v4;
      *(_QWORD *)&buf = 0;
      *((_QWORD *)&buf + 1) = &buf;
      v27 = 0x2000000000;
      v28 = v4;
      *(_QWORD *)type = 0;
      v22 = type;
      v23 = 0x2000000000;
      v24 = 1;
      v15[0] = MEMORY[0x24BDAC760];
      v15[1] = 0x40000000;
      v16 = (uint64_t (*)(_QWORD *))__nw_protocol_tcp_finalize_output_frames_block_invoke;
      v17 = &unk_24C2B2B08;
      v18 = type;
      p_buf = &buf;
      v20 = a1;
      v6 = *a2;
      do
      {
        if (!v6)
          break;
        v7 = *(_QWORD *)(v6 + 32);
        v8 = v16(v15);
        v6 = v7;
      }
      while ((v8 & 1) != 0);
      nw_protocol_tcp_update_metadata(a1);
      *(_DWORD *)(v5 + 5308) &= ~0x20u;
      v9 = *((_BYTE *)v22 + 24) != 0;
      _Block_object_dispose(type, 8);
      _Block_object_dispose(&buf, 8);
      return v9;
    }
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
    v11 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          v14 = "%{public}s called with null tcp";
          goto LABEL_22;
        }
      }
      else
      {
        v12 = __nwlog_obj();
        v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          v14 = "%{public}s called with null tcp, backtrace limit exceeded";
          goto LABEL_22;
        }
      }
    }
  }
  else
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
    v11 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          v14 = "%{public}s called with null protocol";
LABEL_22:
          _os_log_impl(&dword_209FB3000, v12, v13, v14, (uint8_t *)&buf, 0xCu);
        }
      }
      else
      {
        v12 = __nwlog_obj();
        v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(_QWORD *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          v14 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_22;
        }
      }
    }
  }
  if (v11)
    free(v11);
  return 0;
}

uint64_t __nw_protocol_tcp_finalize_output_frames_block_invoke(_QWORD *a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  BOOL v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  uint64_t v15;
  void *v16;
  NSObject *v17;
  NSObject *v18;
  const char *v19;
  uint64_t v20;
  void (*v21)(uint64_t, uint64_t, uint64_t);
  uint64_t v22;
  void *v24;
  NSObject *v25;
  const char *v26;
  NSObject *v27;
  const char *v28;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  unsigned int v34;
  __int16 v35;
  unsigned int v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v30 = "__nw_frame_unclaimed_length";
    v16 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v17 = __nwlog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "__nw_frame_unclaimed_length";
        _os_log_impl(&dword_209FB3000, v17, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v16)
      free(v16);
    goto LABEL_36;
  }
  v4 = *(_DWORD *)(a2 + 52);
  if (!v4)
  {
LABEL_36:
    v5 = 0;
    goto LABEL_37;
  }
  v5 = v4 - (*(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60));
  if (*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
    v6 = v4 == *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
  else
    v6 = 1;
  if (!v6)
  {
    v7 = *(char *)(a2 + 186);
    v8 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
    v9 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 40)
                                                                             + 72))(v8, 0, a2, 0, 0);
    v10 = v9;
    if ((*(_DWORD *)(v8 + 368) & 0x30) != 0)
      *(_DWORD *)(v8 + 368) &= *(_DWORD *)(v8 + 368) & 0x10 ^ 0xFFFFFFDF;
    if (v9 > 0x23 || ((1 << v9) & 0x800000011) == 0)
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
      if (!v12 || (*(_BYTE *)(v12 + 828) & 2) == 0)
      {
        v13 = __nwlog_tcp_log();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          v14 = (const char *)(v12 + 604);
          v30 = "nw_protocol_tcp_finalize_output_frames_block_invoke";
          v31 = 2082;
          *(_DWORD *)buf = 136446978;
          if (!v12)
            v14 = "";
          v32 = v14;
          v33 = 1024;
          v34 = v10;
          v35 = 1024;
          v36 = v5;
          _os_log_impl(&dword_209FB3000, v13, OS_LOG_TYPE_ERROR, "%{public}s %{public}s tcp_finalize_send error %d for frame of length %u", buf, 0x22u);
        }
      }
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) + 378) = v10;
      user_north_signal_error(*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24));
      *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
    }
    if (*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) && v7 < 0)
    {
      v15 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
      if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v18 = __nwlog_tcp_log();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            v19 = "";
            if (v15)
              v19 = (const char *)(v15 + 604);
            *(_DWORD *)buf = 136446466;
            v30 = "nw_protocol_tcp_finalize_output_frames_block_invoke";
            v31 = 2082;
            v32 = v19;
            _os_log_impl(&dword_209FB3000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s frame marks connection complete, marking output finished", buf, 0x16u);
          }
        }
      }
      nw_protocol_tcp_output_finished(a1[6]);
    }
    return 1;
  }
LABEL_37:
  v20 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  if (!v20 || (*(_BYTE *)(v20 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v25 = __nwlog_tcp_log();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        v26 = (const char *)(v20 + 604);
        v30 = "nw_protocol_tcp_finalize_output_frames_block_invoke";
        *(_DWORD *)buf = 136446722;
        if (!v20)
          v26 = "";
        v31 = 2082;
        v32 = v26;
        v33 = 1024;
        v34 = v5;
        _os_log_impl(&dword_209FB3000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s dropping frame of length %u", buf, 0x1Cu);
      }
    }
  }
  if (a2)
  {
    v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 80);
    if (v21)
    {
      v22 = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a2 + 80) = 0;
      *(_QWORD *)(a2 + 88) = 0;
      v21(a2, 1, v22);
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v30 = "__nw_frame_finalize";
    v24 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_57;
    v27 = __nwlog_obj();
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      goto LABEL_57;
    *(_DWORD *)buf = 136446210;
    v30 = "__nw_frame_finalize";
    v28 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
    goto LABEL_56;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v30 = "__nw_frame_finalize";
  v24 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v27 = __nwlog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "__nw_frame_finalize";
      v28 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_56:
      _os_log_impl(&dword_209FB3000, v27, OS_LOG_TYPE_ERROR, v28, buf, 0xCu);
    }
  }
LABEL_57:
  if (v24)
    free(v24);
  return 1;
}

uint64_t tcp_usr_send(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t, uint64_t);
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  _BOOL4 v14;
  int *v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(uint64_t);
  __int16 v22;
  uint64_t v23;
  void *v24;
  NSObject *v25;
  void *v26;
  NSObject *v27;
  void *v28;
  NSObject *v29;
  _BYTE buf[22];
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)a1;
  if (!*(_QWORD *)a1 || *(_DWORD *)(v5 + 232) == 3)
  {
    if (a3)
    {
      v7 = (_QWORD *)(a3 + 80);
      v6 = *(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 80);
      if (v6)
      {
        v8 = *(_QWORD *)(a3 + 88);
        *v7 = 0;
        *(_QWORD *)(a3 + 88) = 0;
        v6(a3, 1, v8);
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v26 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v29 = __nwlog_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            _os_log_impl(&dword_209FB3000, v29, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
          }
        }
        if (v26)
          free(v26);
      }
    }
    if (v5)
      return 41;
    else
      return 54;
  }
  if (a4)
    v14 = *(unsigned __int8 *)(a4 + 1) == 30;
  else
    v14 = 0;
  v15 = *(int **)(v5 + 240);
  v16 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v16);
  if ((*(_BYTE *)(a1 + 367) & 1) == 0 || (*(_BYTE *)(a1 + 433) & 0x10) != 0)
  {
    if ((a2 & 1) != 0)
      goto LABEL_16;
    goto LABEL_17;
  }
  v27 = __nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "tcp_usr_send";
  v28 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v28);
    if ((a2 & 1) != 0)
    {
LABEL_16:
      if ((*(_BYTE *)(a1 + 368) & 0x20) == 0)
        goto LABEL_36;
    }
LABEL_17:
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)(a3 + 40) = buf;
    *(_QWORD *)buf = a3;
    *(_QWORD *)&buf[8] = a3 + 32;
    v17 = *(_DWORD *)(a3 + 52);
    if (v17)
      v18 = v17 - (*(_DWORD *)(a3 + 56) + *(_DWORD *)(a3 + 60));
    else
      v18 = 0;
    sbappendstream((int *)(a1 + 384), (uint64_t *)buf, v18, 0);
    if (a4 && v15[3] <= 1)
    {
      if (v14)
      {
        v9 = tcp6_connect((uint64_t)v15, a4);
        if ((_DWORD)v9)
          return v9;
      }
      else
      {
        v9 = tcp_connect((uint64_t)v15, a4);
        if ((_DWORD)v9)
          return v9;
      }
      v15[35] = 4096;
      v15[63] = 4096;
      tcp_mss((uint64_t)v15, -1, 0);
    }
    if ((a2 & 2) != 0)
    {
      *(_WORD *)(a1 + 376) |= 0x10u;
      v20 = *(_QWORD *)(a1 + 32);
      if (v20)
      {
        v21 = *(void (**)(uint64_t))(v20 + 16);
        if (v21)
          v21(a1);
      }
      v15 = (int *)tcp_usrclosed((uint64_t)v15, v19);
    }
    if (v15)
    {
      if ((a2 & 4) != 0)
      {
        v15[22] |= 0x10000u;
        v9 = tcp_output((uint64_t)v15);
        v15[22] &= ~0x10000u;
        v22 = *(_WORD *)(a1 + 376);
        if ((v22 & 4) != 0)
          goto LABEL_39;
      }
      else
      {
        v9 = tcp_output((uint64_t)v15);
        v22 = *(_WORD *)(a1 + 376);
        if ((v22 & 4) != 0)
          goto LABEL_39;
      }
      return v9;
    }
LABEL_36:
    v9 = 0;
    v22 = *(_WORD *)(a1 + 376);
    if ((v22 & 4) != 0)
    {
LABEL_39:
      if ((v22 & 0x100) != 0)
      {
        return 35;
      }
      else if ((*(_BYTE *)(a1 + 828) & 2) == 0)
      {
        __nwlog_tcp_log();
        v23 = a1 + 604;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_usr_send";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 604;
        v24 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v25 = __nwlog_tcp_log();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "tcp_usr_send";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v23;
            _os_log_impl(&dword_209FB3000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s NBIO not set, backtrace limit exceeded", buf, 0x16u);
          }
        }
        if (v24)
          free(v24);
      }
    }
    return v9;
  }
  __break(1u);
  return result;
}

void sbdrop(int *a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  os_log_type_t v8;
  NSObject *v9;
  const char *v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t all_stats;
  uint64_t v19;
  _QWORD *v20;
  void (*v21)(uint64_t, uint64_t, uint64_t);
  uint64_t v22;
  void *v23;
  uint64_t v24;
  NSObject *v25;
  const char *v26;
  int v27;
  int v28;
  NSObject *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *log;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  _BYTE v38[10];
  _BYTE v39[6];
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)a1 + 4))
  {
    v4 = *((_QWORD *)a1 + 9);
    if (tcp_perf_measurement)
    {
      if (!v4 || (*(_BYTE *)(v4 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v5 = __nwlog_tcp_log();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
          {
            v6 = "";
            if (v4)
              v6 = (const char *)(v4 + 604);
            *(_DWORD *)buf = 136446466;
            v36 = "sbdrop";
            v37 = 2082;
            *(_QWORD *)v38 = v6;
            v7 = v5;
            v8 = OS_LOG_TYPE_DEBUG;
LABEL_16:
            _os_log_impl(&dword_209FB3000, v7, v8, "%{public}s %{public}s sb_mb_aggregate not empty", buf, 0x16u);
          }
        }
      }
    }
    else if (!v4 || (*(_BYTE *)(v4 + 828) & 2) == 0)
    {
      v9 = __nwlog_tcp_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        v10 = "";
        if (v4)
          v10 = (const char *)(v4 + 604);
        *(_DWORD *)buf = 136446466;
        v36 = "sbdrop";
        v37 = 2082;
        *(_QWORD *)v38 = v10;
        v7 = v9;
        v8 = OS_LOG_TYPE_INFO;
        goto LABEL_16;
      }
    }
  }
  if ((a2 & 0x80000000) == 0)
  {
    while (1)
    {
      v11 = *((_QWORD *)a1 + 2);
      if (!v11)
        break;
      v12 = *(_DWORD *)(v11 + 52);
      if (v12)
      {
        v13 = *(_DWORD *)(v11 + 56);
        v14 = *(_DWORD *)(v11 + 60);
        if (v12 - (v13 + v14) > a2)
        {
          if ((*(_WORD *)(v11 + 204) & 0x80) != 0)
            *(_WORD *)(v11 + 196) -= a2;
          v28 = v13 + a2;
          if (v13 + a2 <= (v12 - v14))
          {
            *(_DWORD *)(v11 + 56) = v28;
          }
          else
          {
            v29 = __nwlog_obj();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              v30 = *(_DWORD *)(v11 + 52);
              *(_DWORD *)buf = 136446978;
              v36 = "__nw_frame_claim_internal";
              v37 = 1024;
              *(_DWORD *)v38 = v28;
              *(_WORD *)&v38[4] = 1024;
              *(_DWORD *)&v38[6] = v30;
              *(_WORD *)v39 = 1024;
              *(_DWORD *)&v39[2] = v14;
              _os_log_impl(&dword_209FB3000, v29, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
            }
          }
          *a1 -= a2;
          goto LABEL_58;
        }
        v15 = v13 - v12 + v14;
      }
      else
      {
        v15 = 0;
      }
      *a1 += v15;
      v16 = *(_QWORD *)(*((_QWORD *)a1 + 9) + 24);
      if ((a1[12] & 4) != 0)
      {
        if (v16)
        {
          all_stats = nw_protocol_tcp_get_all_stats();
          if (all_stats)
            *(_DWORD *)(all_stats + 92) = *a1;
        }
      }
      else if (v16)
      {
        v17 = nw_protocol_tcp_get_all_stats();
        if (v17)
          *(_DWORD *)(v17 + 104) = *a1;
      }
      v19 = *(_QWORD *)(v11 + 32);
      v20 = *(_QWORD **)(v11 + 40);
      if (v19)
      {
        *(_QWORD *)(v19 + 40) = v20;
        v20 = *(_QWORD **)(v11 + 40);
      }
      else
      {
        *((_QWORD *)a1 + 3) = v20;
      }
      a2 += v15;
      *v20 = v19;
      v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 80);
      *(_QWORD *)(v11 + 32) = 0;
      *(_QWORD *)(v11 + 40) = 0;
      if (v21)
      {
        v22 = *(_QWORD *)(v11 + 88);
        *(_QWORD *)(v11 + 80) = 0;
        *(_QWORD *)(v11 + 88) = 0;
        v21(v11, 1, v22);
        if (a2 < 0)
          goto LABEL_58;
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v36 = "__nw_frame_finalize";
        v23 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          log = __nwlog_obj();
          if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v36 = "__nw_frame_finalize";
            _os_log_impl(&dword_209FB3000, log, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
          }
        }
        if (v23)
          free(v23);
        if (a2 < 0)
          goto LABEL_58;
      }
    }
    if (*a1)
    {
      v24 = *((_QWORD *)a1 + 9);
      if (!v24 || (*(_BYTE *)(v24 + 828) & 2) == 0)
      {
        v25 = __nwlog_tcp_log();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          v26 = (const char *)(v24 + 604);
          v27 = *a1;
          v36 = "sbdrop";
          *(_DWORD *)buf = 136446978;
          if (!v24)
            v26 = "";
          v37 = 2082;
          *(_QWORD *)v38 = v26;
          *(_WORD *)&v38[8] = 1024;
          *(_DWORD *)v39 = a2;
          *(_WORD *)&v39[4] = 1024;
          v40 = v27;
          _os_log_impl(&dword_209FB3000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s sbdrop - count not zero: len %d sb_cc %u", buf, 0x22u);
        }
      }
      *a1 = 0;
    }
  }
LABEL_58:
  v31 = *(_QWORD *)(*((_QWORD *)a1 + 9) + 24);
  if ((a1[12] & 4) != 0)
  {
    if (v31)
    {
      v33 = nw_protocol_tcp_get_all_stats();
      if (v33)
        *(_DWORD *)(v33 + 92) = *a1;
    }
  }
  else
  {
    if (v31)
    {
      v32 = nw_protocol_tcp_get_all_stats();
      if (v32)
        *(_DWORD *)(v32 + 104) = *a1;
    }
    nw_protocol_tcp_update_metadata(*(_QWORD *)(*((_QWORD *)a1 + 9) + 24));
  }
}

void nw_frame_tcp_finalize(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  NSObject *v5;
  void *v6;
  NSObject *v7;
  void *v8;
  unsigned int v9;
  int v10;
  NSObject *v11;
  void *v12;
  unsigned int v13;
  unsigned int v14;
  void *v15;
  int v16;
  unsigned int v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t *v36;
  void *v37;
  __int16 v38;
  _QWORD *v39;
  uint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  void *v47;
  NSObject *v48;
  os_log_type_t v49;
  const char *v50;
  NSObject *v51;
  void *v52;
  int v53;
  NSObject *v54;
  void *v55;
  NSObject *v56;
  void *v57;
  _QWORD v58[2];
  uint64_t (*v59)(uint64_t, uint64_t);
  void *v60;
  uint64_t *v61;
  _QWORD *v62;
  char v63;
  char v64;
  char v65;
  char v66;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v69;
  __int16 v70;
  _BYTE v71[10];
  __int16 v72;
  int v73;
  uint64_t v74;

  v74 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 4) == 0)
    {
      v5 = __nwlog_obj();
      os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446466;
      v69 = "nw_frame_tcp_finalize";
      v70 = 2048;
      *(_QWORD *)v71 = 0;
      v6 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
        goto LABEL_86;
      free(v6);
    }
    if (!a3)
    {
      v7 = __nwlog_obj();
      os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446466;
      v69 = "nw_frame_tcp_finalize";
      v70 = 2048;
      *(_QWORD *)v71 = 0;
      v8 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
        goto LABEL_86;
      free(v8);
    }
    v9 = *(unsigned __int8 *)(a1 + 208);
    v10 = v9 & 1;
    if ((~v9 & 6) == 0 || (v9 & 5) == 5 || (v9 & 3) == 3)
    {
      v11 = __nwlog_obj();
      os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446978;
      v69 = "nw_frame_tcp_finalize";
      v70 = 1024;
      *(_DWORD *)v71 = v9 & 1;
      *(_WORD *)&v71[4] = 1024;
      *(_DWORD *)&v71[6] = (v9 >> 1) & 1;
      v72 = 1024;
      v73 = (v9 >> 2) & 1;
      v12 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
        goto LABEL_86;
      free(v12);
    }
    v13 = v9 & 4;
    v14 = v9 & 2;
    if (v14)
    {
      if ((*(_WORD *)(a1 + 204) & 2) != 0)
      {
        v33 = *(void **)(a1 + 96);
        if (v33)
        {
          nw_release(v33);
          *(_QWORD *)(a1 + 96) = 0;
        }
        *(_DWORD *)(a1 + 52) = 0;
        *(_DWORD *)(a1 + 56) = 0;
        *(_WORD *)(a1 + 196) = 0;
      }
      else
      {
        v23 = __nwlog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v69 = "__nw_frame_set_external_data";
          _os_log_impl(&dword_209FB3000, v23, OS_LOG_TYPE_ERROR, "%{public}s Frame does not use external data", buf, 0xCu);
        }
      }
      v34 = a3 + 22;
      v35 = a3 + 24;
      v36 = a3 + 2;
      goto LABEL_61;
    }
    if (!v10)
    {
      if (!v13)
      {
LABEL_56:
        v34 = a3 + 18;
        v35 = a3 + 20;
        v36 = a3 + 1;
LABEL_61:
        v40 = *(_QWORD *)(a1 + 16);
        v41 = *(_QWORD **)(a1 + 24);
        v39 = (_QWORD *)(a1 + 16);
        if (v40)
        {
          *(_QWORD *)(v40 + 24) = v41;
          v41 = *(_QWORD **)(a1 + 24);
        }
        else
        {
          v35[1] = v41;
        }
        *v41 = v40;
        *v39 = 0;
        *(_QWORD *)(a1 + 24) = 0;
        v42 = (_QWORD *)v34[1];
        *(_QWORD *)(a1 + 24) = v42;
        *v42 = a1;
        v34[1] = v39;
        v43 = *v36;
        if ((*v36 & 0x8000000000000000) == 0)
        {
LABEL_65:
          *v36 = v43 + 1;
          if (v43 >= 100)
          {
            v58[0] = MEMORY[0x24BDAC760];
            v58[1] = 0x40000000;
            v59 = __nw_frame_tcp_finalize_block_invoke;
            v60 = &__block_descriptor_tmp_2;
            v61 = v36;
            v62 = v34;
            v63 = v14 >> 1;
            v64 = v13 >> 2;
            v65 = v10;
            v44 = *v34;
            do
            {
              if (!v44)
                break;
              v45 = *(_QWORD *)(v44 + 16);
              v46 = ((uint64_t (*)(_QWORD *))v59)(v58);
              v44 = v45;
            }
            while ((v46 & 1) != 0);
          }
          return;
        }
        v51 = __nwlog_obj();
        os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v69 = "nw_frame_tcp_finalize";
        v52 = (void *)_os_log_send_and_compose_impl();
        if (!__nwlog_abort())
        {
          free(v52);
          v43 = *v36;
          goto LABEL_65;
        }
LABEL_86:
        __break(1u);
      }
      if ((*(_WORD *)(a1 + 204) & 0x100) == 0
        || !*MEMORY[0x24BDE08C0]
        || ((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(a1, *(_QWORD *)(a1 + 88)))
      {
        v15 = *(void **)(a1 + 112);
        if (v15)
          free(v15);
      }
      v16 = *(unsigned __int16 *)(a1 + 204);
      *(_WORD *)(a1 + 196) = 0;
      *(_DWORD *)(a1 + 192) = 0;
      *(_BYTE *)(a1 + 200) = 0;
      *(_QWORD *)(a1 + 56) = 0;
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 80) = 0;
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 104) = 0;
      v17 = v16 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a1 + 206) << 16);
      *(_WORD *)(a1 + 204) = v17;
      *(_BYTE *)(a1 + 206) = BYTE2(v17);
      v18 = *(_QWORD **)(a1 + 64);
      if (v18)
      {
        do
        {
          v19 = (_QWORD *)*v18;
          v20 = (void *)v18[6];
          v21 = (_QWORD *)*v18;
          if (v20)
          {
            nw_release(v20);
            v18[6] = 0;
            v21 = (_QWORD *)*v18;
          }
          v22 = (_QWORD *)v18[1];
          if (v21)
          {
            v21[1] = v22;
            v22 = (_QWORD *)v18[1];
          }
          else
          {
            *(_QWORD *)(a1 + 72) = v22;
          }
          *v22 = v21;
          if (v18 != (_QWORD *)(a1 + 120))
            free(v18);
          v18 = v19;
        }
        while (v19);
      }
      *(_QWORD *)(a1 + 64) = 0;
      *(_QWORD *)(a1 + 72) = a1 + 64;
      v37 = *(void **)(a1 + 168);
      if (!v37)
        goto LABEL_55;
      goto LABEL_54;
    }
    v24 = *(_QWORD *)(a1 + 104);
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0
      && *MEMORY[0x24BDE08C0]
      && !((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(a1, *(_QWORD *)(a1 + 88)))
    {
      if (!v24)
        goto LABEL_60;
    }
    else
    {
      v25 = *(_QWORD *)(a1 + 112);
      if (!v24)
      {
        if (v25)
        {
          v56 = __nwlog_obj();
          os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          v69 = "nw_frame_tcp_finalize";
          v57 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_abort())
            goto LABEL_86;
          free(v57);
        }
        goto LABEL_60;
      }
      if (v25)
      {
LABEL_39:
        nw_mem_buffer_free();
        v26 = *(unsigned __int16 *)(a1 + 204);
        *(_WORD *)(a1 + 196) = 0;
        *(_DWORD *)(a1 + 192) = 0;
        *(_BYTE *)(a1 + 200) = 0;
        *(_QWORD *)(a1 + 56) = 0;
        *(_QWORD *)(a1 + 48) = 0;
        *(_QWORD *)(a1 + 88) = 0;
        *(_QWORD *)(a1 + 80) = 0;
        *(_QWORD *)(a1 + 104) = 0;
        *(_QWORD *)(a1 + 112) = 0;
        v27 = v26 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a1 + 206) << 16);
        *(_WORD *)(a1 + 204) = v27;
        *(_BYTE *)(a1 + 206) = BYTE2(v27);
        v28 = *(_QWORD **)(a1 + 64);
        if (v28)
        {
          do
          {
            v29 = (_QWORD *)*v28;
            v30 = (void *)v28[6];
            v31 = (_QWORD *)*v28;
            if (v30)
            {
              nw_release(v30);
              v28[6] = 0;
              v31 = (_QWORD *)*v28;
            }
            v32 = (_QWORD *)v28[1];
            if (v31)
            {
              v31[1] = v32;
              v32 = (_QWORD *)v28[1];
            }
            else
            {
              *(_QWORD *)(a1 + 72) = v32;
            }
            *v32 = v31;
            if (v28 != (_QWORD *)(a1 + 120))
              free(v28);
            v28 = v29;
          }
          while (v29);
        }
        *(_QWORD *)(a1 + 64) = 0;
        *(_QWORD *)(a1 + 72) = a1 + 64;
        v37 = *(void **)(a1 + 168);
        if (!v37)
        {
LABEL_55:
          v38 = *(_WORD *)(a1 + 204);
          *(_QWORD *)(a1 + 184) = 0;
          *(_OWORD *)(a1 + 168) = 0u;
          *(_OWORD *)(a1 + 152) = 0u;
          *(_OWORD *)(a1 + 136) = 0u;
          *(_OWORD *)(a1 + 120) = 0u;
          *(_WORD *)(a1 + 204) = v38 & 0x213F;
          *(_BYTE *)(a1 + 203) = 0;
          *(_WORD *)(a1 + 198) = 0;
          if (!v10)
            goto LABEL_56;
LABEL_60:
          v34 = a3 + 26;
          v35 = a3 + 28;
          v36 = a3 + 3;
          goto LABEL_61;
        }
LABEL_54:
        nw_release(v37);
        goto LABEL_55;
      }
    }
    v53 = v10;
    v54 = __nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v69 = "nw_frame_tcp_finalize";
    v55 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
      goto LABEL_86;
    free(v55);
    v10 = v53;
    goto LABEL_39;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v69 = "nw_frame_tcp_finalize";
  v47 = (void *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v66 = 0;
  if (__nwlog_fault())
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (!os_log_type_enabled(v48, type))
        goto LABEL_82;
      *(_DWORD *)buf = 136446210;
      v69 = "nw_frame_tcp_finalize";
      v50 = "%{public}s called with null frame";
    }
    else
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (!os_log_type_enabled(v48, type))
        goto LABEL_82;
      *(_DWORD *)buf = 136446210;
      v69 = "nw_frame_tcp_finalize";
      v50 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v48, v49, v50, buf, 0xCu);
  }
LABEL_82:
  if (v47)
    free(v47);
}

void tcp_xmit_timer(uint64_t a1, unsigned int a2, int a3, int a4)
{
  unsigned int v7;
  uint64_t v8;
  NSObject *v9;
  const char *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  signed int v24;
  int v25;
  unsigned int v26;
  signed int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t all_stats;
  uint64_t v35;
  uint64_t v36;
  int v37;
  unint64_t v38;
  int v39;
  unsigned int v40;
  int v41;
  const char *v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  unsigned int v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  if (a2 <= 1)
    v7 = 1;
  else
    v7 = a2;
  if ((int)v7 >= 60001)
  {
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
    if (!v8 || (*(_BYTE *)(v8 + 828) & 2) == 0)
    {
      v9 = __nwlog_tcp_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        v10 = (const char *)(v8 + 604);
        v42 = "tcp_xmit_timer";
        v41 = 136446722;
        if (!v8)
          v10 = "";
        v43 = 2082;
        v44 = v10;
        v45 = 1024;
        v46 = v7;
        _os_log_impl(&dword_209FB3000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}s rtt is %d - maxing it at 4 x MSL\n", (uint8_t *)&v41, 0x1Cu);
      }
    }
    v7 = 60000;
  }
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 448);
  if (!v11 || (*(_BYTE *)(v11 + 1054) & 0x10) == 0 || *(_DWORD *)(a1 + 112) + 1 != a4)
  {
    v12 = *(_DWORD *)(a1 + 740);
    if ((v12 & 0x40) == 0)
    {
      v13 = *(_QWORD *)(a1 + 1056);
      if (v13)
        ++*(_QWORD *)(v13 + 464);
      v14 = *(_DWORD *)(a1 + 240) + 1;
      *(_DWORD *)(a1 + 236) = v7;
      *(_DWORD *)(a1 + 240) = v14;
      update_base_rtt(a1, v7);
      v15 = *(_DWORD *)(a1 + 200);
      if (v15)
      {
        v16 = 4 * v7 - (v15 >> 3);
        v17 = v16 + v15;
        if (v17 <= 1)
          v17 = 1;
        *(_DWORD *)(a1 + 200) = v17;
        if (v16 < 0)
          v16 = -v16;
        v18 = *(_DWORD *)(a1 + 208) + v16 - (*(int *)(a1 + 208) >> 2);
        if (v18 <= 1)
          v19 = 1;
        else
          v19 = v18;
        *(_DWORD *)(a1 + 208) = v19;
        v20 = *(_DWORD *)(a1 + 232);
        v21 = v19 + v17;
        if (!v20 || v20 > v21)
          *(_DWORD *)(a1 + 232) = v21;
      }
      else
      {
        *(_DWORD *)(a1 + 200) = 32 * v7;
        *(_DWORD *)(a1 + 208) = 8 * v7;
        *(_DWORD *)(a1 + 232) = 40 * v7;
        if (!*(_DWORD *)(a1 + 1968))
          *(_DWORD *)(a1 + 1968) = 32 * v7;
      }
      if ((*(_DWORD *)(a1 + 1872) & 0xFFFFFFFE) == 2)
      {
        v29 = *(_DWORD *)(a1 + 204);
        if (v29)
        {
          v30 = 4 * v7 - (v29 >> 3);
          v31 = v30 + v29;
          if (v31 <= 1)
            v31 = 1;
          *(_DWORD *)(a1 + 204) = v31;
          if (v30 >= 0)
            v32 = v30;
          else
            v32 = -v30;
          v33 = *(_DWORD *)(a1 + 212) + v32 - (*(int *)(a1 + 212) >> 2);
          if (v33 <= 1)
            v33 = 1;
        }
        else
        {
          *(_DWORD *)(a1 + 204) = 32 * v7;
          v33 = 8 * v7;
        }
        *(_DWORD *)(a1 + 212) = v33;
      }
      goto LABEL_59;
    }
    if (a4 - *(_DWORD *)(a1 + 92) >= 1 && a4 - *(_DWORD *)(a1 + 96) <= 0 && (!a3 || a3 - *(_DWORD *)(a1 + 532) >= 0))
    {
      *(_DWORD *)(a1 + 740) = v12 & 0xFFFFFFBF;
      *(_DWORD *)(a1 + 532) = 0;
      v22 = *(int *)(a1 + 516);
      if (v22 <= v7)
        LODWORD(v22) = v7;
      v23 = 32 * v22;
      *(_DWORD *)(a1 + 200) = v23;
      v24 = *(_DWORD *)(a1 + 524);
      if (v24 <= (int)(v7 >> 1))
        v24 = v7 >> 1;
      v25 = 16 * v24;
      *(_DWORD *)(a1 + 208) = v25;
      if ((*(_DWORD *)(a1 + 1872) & 0xFFFFFFFE) == 2)
      {
        if (*(int *)(a1 + 520) <= (uint64_t)v7)
          v26 = v7;
        else
          v26 = *(_DWORD *)(a1 + 520);
        *(_DWORD *)(a1 + 204) = 32 * v26;
        v27 = *(_DWORD *)(a1 + 528);
        if (v27 <= (int)(v7 >> 1))
          v27 = v7 >> 1;
        *(_DWORD *)(a1 + 212) = 16 * v27;
      }
      v28 = v23 + v25;
      if (*(_DWORD *)(a1 + 232) > v28)
        *(_DWORD *)(a1 + 232) = v28;
LABEL_59:
      if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 24))
      {
        all_stats = nw_protocol_tcp_get_all_stats();
        if (all_stats)
          *(_DWORD *)(all_stats + 68) = *(_DWORD *)(a1 + 232);
      }
      if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 24))
      {
        v35 = nw_protocol_tcp_get_all_stats();
        if (v35)
          *(_DWORD *)(v35 + 72) = *(_DWORD *)(a1 + 200);
      }
      if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 24))
      {
        v36 = nw_protocol_tcp_get_all_stats();
        if (v36)
          *(_DWORD *)(v36 + 76) = *(_DWORD *)(a1 + 208);
      }
      if (*(int *)(a1 + 12) < 4)
        v37 = 0;
      else
        v37 = *(_DWORD *)(sysctls + 176);
      v38 = *(unsigned int *)(a1 + 228);
      v39 = (*(_DWORD *)(a1 + 208) + (*(int *)(a1 + 200) >> 3)) >> 2;
      if ((uint64_t)v38 > v39)
        v39 = *(_DWORD *)(a1 + 228);
      v40 = v39 + v37;
      *(_DWORD *)(a1 + 192) = v40;
      if ((unint64_t)v7 + 2 >= v38)
        LODWORD(v38) = v7 + 2;
      if (v40 >= v38)
      {
        if (v40 < 0xFA01)
        {
LABEL_79:
          *(_DWORD *)(a1 + 256) = 0;
          return;
        }
        LODWORD(v38) = 64000;
      }
      *(_DWORD *)(a1 + 192) = v38;
      goto LABEL_79;
    }
  }
}

uint64_t sbappendstream(int *a1, uint64_t *a2, int a3, char a4)
{
  int v6;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  void (*v12)(uint64_t, uint64_t, uint64_t);
  uint64_t v13;
  uint64_t v14;
  uint64_t all_stats;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  const char *v23;
  int v24;
  int v25;
  const char *v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  NSObject *v31;
  const char *v32;
  int v33;
  int v34;
  NSObject *v35;
  void *v36;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  _BYTE v40[10];
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  if (!a2)
    return 0;
  v6 = a1[12];
  if ((v6 & 0x80) != 0)
  {
    result = *a2;
    if (*a2)
    {
      do
      {
        v12 = *(void (**)(uint64_t, uint64_t, uint64_t))(result + 80);
        v13 = *(_QWORD *)(result + 32);
        if (v12)
        {
          v14 = *(_QWORD *)(result + 88);
          *(_QWORD *)(result + 80) = 0;
          *(_QWORD *)(result + 88) = 0;
          v12(result, 1, v14);
        }
        else
        {
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v38 = "__nw_frame_finalize";
          v36 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            v35 = __nwlog_obj();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v38 = "__nw_frame_finalize";
              _os_log_impl(&dword_209FB3000, v35, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v36)
            free(v36);
        }
        result = v13;
      }
      while (v13);
    }
    return result;
  }
  *a1 += a3;
  v9 = *(_QWORD *)(*((_QWORD *)a1 + 9) + 24);
  if ((v6 & 4) != 0)
  {
    if (v9)
    {
      all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats)
        *(_DWORD *)(all_stats + 92) = *a1;
    }
  }
  else if (v9)
  {
    v10 = nw_protocol_tcp_get_all_stats();
    if (v10)
      *(_DWORD *)(v10 + 104) = *a1;
  }
  if ((a4 & 2) != 0)
  {
    if (*a2)
    {
      v16 = 0;
      v17 = 0;
      v18 = *a2;
      do
      {
        v19 = *(_DWORD *)(v18 + 52);
        if (v19)
          v19 -= *(_DWORD *)(v18 + 56) + *(_DWORD *)(v18 + 60);
        v16 += v19;
        ++v17;
        v18 = *(_QWORD *)(v18 + 32);
      }
      while (v18);
      **((_QWORD **)a1 + 5) = *a2;
      *(_QWORD *)(*a2 + 40) = *((_QWORD *)a1 + 5);
      *((_QWORD *)a1 + 5) = a2[1];
      *a2 = 0;
      a2[1] = (uint64_t)a2;
      if (v16 == a3)
        goto LABEL_30;
    }
    else
    {
      v16 = 0;
      v17 = 0;
      if (!a3)
      {
LABEL_30:
        v20 = a1[16] + a3;
        a1[15] += v17;
        a1[16] = v20;
        v21 = *((_QWORD *)a1 + 9);
        if (v21 && (*(_BYTE *)(v21 + 828) & 2) != 0)
          return 1;
        if (!__nwlog_is_datapath_logging_enabled())
          return 1;
        v22 = __nwlog_tcp_log();
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
          return 1;
        v23 = (const char *)(v21 + 604);
        v24 = a1[16];
        v25 = *a1;
        if (!v21)
          v23 = "";
        *(_DWORD *)buf = 136447490;
        v38 = "sbcompress";
        v39 = 2082;
        *(_QWORD *)v40 = v23;
        *(_WORD *)&v40[8] = 1024;
        v41 = v17;
        v42 = 1024;
        v43 = a3;
        v44 = 1024;
        v45 = v24;
        v46 = 1024;
        v47 = v25;
        v26 = "%{public}s %{public}s append to aggregate frame count %u length %u sb_agg_bytes %u sb_cc %u";
        goto LABEL_58;
      }
    }
    v31 = __nwlog_obj();
    result = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
      goto LABEL_53;
    return result;
  }
  if (*((_QWORD *)a1 + 4)
    && tcp_input_aggregate_end(*(_QWORD *)(**((_QWORD **)a1 + 9) + 224), *(_QWORD *)(**((_QWORD **)a1 + 9) + 240)))
  {
    return 0;
  }
  if (*a2)
  {
    v16 = 0;
    v27 = 0;
    v28 = *a2;
    do
    {
      v29 = *(_DWORD *)(v28 + 52);
      if (v29)
        v29 -= *(_DWORD *)(v28 + 56) + *(_DWORD *)(v28 + 60);
      v16 += v29;
      ++v27;
      v28 = *(_QWORD *)(v28 + 32);
    }
    while (v28);
    **((_QWORD **)a1 + 3) = *a2;
    *(_QWORD *)(*a2 + 40) = *((_QWORD *)a1 + 3);
    *((_QWORD *)a1 + 3) = a2[1];
    *a2 = 0;
    a2[1] = (uint64_t)a2;
    if (v16 == a3)
      goto LABEL_43;
  }
  else
  {
    v16 = 0;
    v27 = 0;
    if (!a3)
    {
LABEL_43:
      v30 = *((_QWORD *)a1 + 9);
      if (v30 && (*(_BYTE *)(v30 + 828) & 2) != 0)
        return 1;
      if (!__nwlog_is_datapath_logging_enabled())
        return 1;
      v22 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        return 1;
      v32 = (const char *)(v30 + 604);
      v33 = a1[16];
      v34 = *a1;
      if (!v30)
        v32 = "";
      *(_DWORD *)buf = 136447490;
      v38 = "sbcompress";
      v39 = 2082;
      *(_QWORD *)v40 = v32;
      *(_WORD *)&v40[8] = 1024;
      v41 = v27;
      v42 = 1024;
      v43 = a3;
      v44 = 1024;
      v45 = v33;
      v46 = 1024;
      v47 = v34;
      v26 = "%{public}s %{public}s append frame count %u length %u sb_agg_bytes %u sb_cc %u";
LABEL_58:
      _os_log_impl(&dword_209FB3000, v22, OS_LOG_TYPE_DEBUG, v26, buf, 0x2Eu);
      return 1;
    }
  }
  v31 = __nwlog_obj();
  result = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
LABEL_53:
    *(_DWORD *)buf = 136446722;
    v38 = "sbcompress";
    v39 = 1024;
    *(_DWORD *)v40 = a3;
    *(_WORD *)&v40[4] = 1024;
    *(_DWORD *)&v40[6] = v16;
    _os_log_impl(&dword_209FB3000, v31, OS_LOG_TYPE_ERROR, "%{public}s len_added %u != len_to_add %u", buf, 0x18u);
    return 0;
  }
  return result;
}

uint64_t nw_protocol_tcp_get_all_stats()
{
  uint64_t v0;
  void *v2;
  NSObject *v3;
  uint8_t buf[4];
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v0 = nw_protocol_downcast();
  if (v0)
  {
    if (*(_QWORD *)(v0 + 5216))
      return nw_path_flow_registration_get_stats_area();
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v5 = "nw_protocol_tcp_get_all_stats";
    v2 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v3 = __nwlog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v5 = "nw_protocol_tcp_get_all_stats";
        _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_ERROR, "%{public}s called with null tcp, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v2)
      free(v2);
  }
  return 0;
}

uint64_t tcp_compute_rcv_rtt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  NSObject *v16;
  void *v17;

  if (!a2 || !a3)
  {
    v16 = __nwlog_obj();
    os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    v17 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort();
    if ((_DWORD)result)
    {
      __break(1u);
      return result;
    }
    free(v17);
  }
  result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  if ((*(_BYTE *)a2 & 1) != 0)
  {
    v11 = *(_DWORD *)(a2 + 8);
    if (v11 && (v12 = *(_DWORD *)(result + 316), v12 - v11 >= 0))
    {
      if (v12 == v11)
        v10 = 1;
      else
        v10 = v12 - v11;
    }
    else
    {
      v10 = 0;
    }
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 1972);
    if (v6)
    {
      v7 = *(_DWORD *)(a1 + 120);
      if (v7 - *(_DWORD *)(a1 + 1976) < 0)
        return result;
      v8 = *(_DWORD *)(result + 316);
      v9 = v8 - v6;
      if (v9)
        v10 = v9;
      else
        v10 = 1;
    }
    else
    {
      v8 = *(_DWORD *)(result + 316);
      v7 = *(_DWORD *)(a1 + 120);
      v10 = 100;
    }
    *(_DWORD *)(a1 + 1972) = v8;
    *(_DWORD *)(a1 + 1976) = *(_DWORD *)(a1 + 128) + v7;
  }
  v13 = *(_DWORD *)(a1 + 1968);
  v14 = v13 + 4 * v10 - (v13 >> 3);
  if (v14 <= 1)
    v14 = 1;
  if (v13)
    v15 = v14;
  else
    v15 = 32 * v10;
  *(_DWORD *)(a1 + 1968) = v15;
  *(_DWORD *)(a1 + 236) = v10;
  return update_base_rtt(a1, v10);
}

uint64_t update_base_rtt(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned int *v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;

  result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 496);
  if (v5)
  {
    v6 = *(unsigned int **)(v5 + 1488);
    if (v6)
    {
      if (v6[11])
      {
        v7 = *(_DWORD *)(a1 + 740);
        if ((v7 & 0x100) != 0
          && *(_DWORD *)(result + 316) - *(_DWORD *)(a1 + 1040) >= 5000
          && *(_DWORD *)(a1 + 236) <= *(_DWORD *)(sysctls + 4) + v6[10])
        {
          *(_DWORD *)(a1 + 740) = v7 & 0xFFFFFEFF;
          *(_DWORD *)(a1 + 1040) = 0;
        }
        v8 = (*(_DWORD *)(a1 + 1912) + 1) & 3;
        *(_DWORD *)(a1 + 1912) = v8;
        *(_DWORD *)(a1 + 1892 + 4 * v8) = a2;
        v9 = *(_DWORD *)(a1 + 1892);
        if (*(_DWORD *)(a1 + 1896) - 1 < (v9 - 1))
          v9 = *(_DWORD *)(a1 + 1896);
        if (*(_DWORD *)(a1 + 1900) - 1 < (v9 - 1))
          v9 = *(_DWORD *)(a1 + 1900);
        if (*(_DWORD *)(a1 + 1904) - 1 < (v9 - 1))
          v9 = *(_DWORD *)(a1 + 1904);
        *(_DWORD *)(a1 + 1908) = v9;
        v10 = *(_DWORD *)(result + 316) - v6[11];
        if (v10 < 60000)
        {
          v24 = v6[*((unsigned __int8 *)v6 + 72)];
          if (v24 >= a2)
            v24 = a2;
          v6[*((unsigned __int8 *)v6 + 72)] = v24;
          v25 = v6[10];
          if (v25)
          {
            if (v25 >= a2)
              v25 = a2;
            v6[10] = v25;
          }
          else
          {
            v6[10] = a2;
          }
        }
        else
        {
          v11 = v10 / 0xEA60u;
          if (v10 >= 0xA1220)
            v11 = 11;
          v12 = *((unsigned __int8 *)v6 + 72);
          LODWORD(v13) = v12 + 1;
          if (v11 >= 2)
          {
            if (v11 == 2)
              goto LABEL_22;
            v14 = (v11 - 1) & 0xFFFFFFFE;
            v15 = v12 + 2;
            v16 = v12 + 1;
            v17 = v14;
            do
            {
              v6[v16 % 0xA] = 0;
              v6[v15 % 0xA] = 0;
              v16 += 2;
              v15 += 2;
              v17 -= 2;
            }
            while (v17);
            LODWORD(v13) = v13 + v14;
            if (v11 - 1 != v14)
            {
LABEL_22:
              v18 = v11 + v12;
              v19 = (int *)&v6[v13];
              v13 = v13;
              do
              {
                v19[-10 * (v13 / 0xA)] = 0;
                ++v13;
                ++v19;
              }
              while (v13 < v18);
            }
          }
          v20 = v13 % 0xA;
          *((_BYTE *)v6 + 72) = v20;
          v6[v20] = a2;
          v21 = *(_DWORD *)(result + 316);
          v22 = *v6;
          result = v6[8];
          if (v6[1] - 1 < *v6 - 1)
            v22 = v6[1];
          if (v6[2] - 1 < v22 - 1)
            v22 = v6[2];
          if (v6[3] - 1 < v22 - 1)
            v22 = v6[3];
          if (v6[4] - 1 < v22 - 1)
            v22 = v6[4];
          if (v6[5] - 1 < v22 - 1)
            v22 = v6[5];
          if (v6[6] - 1 < v22 - 1)
            v22 = v6[6];
          if (v6[7] - 1 < v22 - 1)
            v22 = v6[7];
          if ((int)result - 1 < v22 - 1)
            v22 = v6[8];
          if (v6[9] - 1 < v22 - 1)
            v22 = v6[9];
          v6[10] = v22;
          v6[11] = v21;
        }
      }
      else
      {
        v23 = *(_DWORD *)(result + 316);
        *((_BYTE *)v6 + 72) = 0;
        *v6 = a2;
        v6[10] = a2;
        v6[11] = v23;
        *(_DWORD *)(a1 + 1912) = 0;
        *(_DWORD *)(a1 + 1892) = a2;
        *(_DWORD *)(a1 + 1908) = a2;
      }
    }
  }
  return result;
}

uint64_t tcp_set_traffic_class(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v5;

  (*(void (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) == 0 && (*(_BYTE *)(a1 + 365) & 0x20) == 0)
  {
    v5 = 22;
    goto LABEL_23;
  }
  if (a2 > 9999)
  {
LABEL_22:
    v5 = 0;
    goto LABEL_23;
  }
  v5 = 22;
  if (a2 > 499)
  {
    if (a2 <= 699)
    {
      if (a2 != 500 && a2 != 600)
        goto LABEL_23;
    }
    else if (a2 != 700 && a2 != 900 && a2 != 800)
    {
      goto LABEL_23;
    }
LABEL_21:
    *(_DWORD *)(a1 + 600) = a2;
    set_tcp_stream_priority(a1);
    goto LABEL_22;
  }
  if (a2 > 199)
  {
    if (a2 != 200 && a2 != 300 && a2 != 400)
      goto LABEL_23;
    goto LABEL_21;
  }
  if (!a2 || a2 == 100)
    goto LABEL_21;
LABEL_23:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v2);
  return v5;
}

void tcp_output_batch_acks_end(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  int v6;
  int v7;
  int v8;
  BOOL v9;
  const char *v10;
  int v11;
  int v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 240);
  v3 = *(_QWORD *)(a1 + 224);
  if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v4 = __nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        v5 = (const char *)(v3 + 604);
        v6 = *(_DWORD *)(v2 + 740);
        v7 = *(_DWORD *)(v2 + 648);
        if (!v3)
          v5 = "";
        v8 = *(_DWORD *)(v2 + 300);
        v13 = "tcp_output_batch_acks_end";
        v9 = (v6 & 0x2000000) == 0;
        v10 = "off";
        v12 = 136447234;
        if (!v9)
          v10 = "on";
        v14 = 2082;
        v15 = v5;
        v16 = 2082;
        v17 = v10;
        v18 = 1024;
        v19 = v7;
        v20 = 1024;
        v21 = v8;
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s %{public}s t_pktlist_sentlen %d t_lastchain %d", (uint8_t *)&v12, 0x2Cu);
      }
    }
  }
  *(_DWORD *)(v2 + 740) &= ~0x2000000u;
  if (*(_BYTE *)(a1 + 2238))
    goto LABEL_17;
  if (*(_QWORD *)(v2 + 632))
    goto LABEL_14;
  while (*(_QWORD *)(v2 + 656))
  {
LABEL_14:
    tcp_ip_output_send(v3, v2, (_QWORD *)(v2 + 632), *(_DWORD *)(v2 + 300), 0);
    *(_QWORD *)(v2 + 632) = 0;
    *(_QWORD *)(v2 + 640) = v2 + 632;
    *(_DWORD *)(v2 + 648) = 0;
    *(_DWORD *)(v2 + 300) = 0;
    if (*(_BYTE *)(a1 + 2238))
      goto LABEL_17;
  }
  v11 = *(_DWORD *)(v2 + 88);
  if ((v11 & 0x8000000) != 0)
  {
    *(_DWORD *)(v2 + 88) = v11 & 0xF7FFFFFF;
    tcp_close(v2);
  }
  else
  {
LABEL_17:
    tcp_check_timer_state(v2);
  }
}

uint64_t tcp_ip_output_send(uint64_t a1, uint64_t a2, _QWORD *a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  _QWORD *v20;
  _BYTE *v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  void (*v25)(_QWORD *, _QWORD, uint64_t);
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  _BOOL4 v31;
  os_log_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  const char *v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  void (*v41)(_QWORD *, _QWORD, uint64_t);
  uint64_t v42;
  NSObject *v43;
  os_log_type_t v44;
  const char *v45;
  uint64_t result;
  uint64_t v47;
  uint64_t v48;
  char v49;
  NSObject *v50;
  void *v51;
  os_log_type_t type;
  os_log_type_t log;
  NSObject *loga;
  os_log_type_t logb;
  NSObject *v56;
  os_log_t backtrace_string;
  NSObject *v58;
  void *v59;
  NSObject *v60;
  NSObject *v61;
  void *v62;
  int v63;
  _QWORD v64[2];
  uint64_t (*v65)(uint64_t, uint64_t);
  void *v66;
  uint64_t v67;
  uint64_t v68;
  char v69;
  os_log_type_t v70;
  _BYTE buf[24];
  uint64_t v72;
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(a2 + 80);
  v11 = *(_QWORD *)(v10 + 496);
  v63 = *(_DWORD *)(v10 + 2228);
  if ((*(_BYTE *)(a2 + 743) & 2) == 0
    || a4 != 1
    || *(_DWORD *)(a2 + 648)
    || *(_DWORD *)(a2 + 672) + 1 >= tcp_batch_ack_max)
  {
    goto LABEL_2;
  }
  v14 = (_QWORD *)*a3;
  if (!*a3)
    goto LABEL_84;
  v15 = v14[14];
  v16 = (_QWORD *)MEMORY[0x24BDE08C0];
  if (!v15
    || (*((_WORD *)v14 + 102) & 0x100) != 0
    && *MEMORY[0x24BDE08C0]
    && (!((unsigned int (*)(_QWORD, _QWORD))*MEMORY[0x24BDE08C0])(*a3, v14[11]) || (v15 = v14[14]) == 0))
  {
    if ((*((_WORD *)v14 + 102) & 0x100) != 0
      && *v16
      && (((uint64_t (*)(_QWORD *, _QWORD))*v16)(v14, v14[11]) & 1) == 0)
    {
      *(_QWORD *)(a2 + 1056) = 0;
    }
LABEL_84:
    if (!a1 || (*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      v36 = __nwlog_tcp_log();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
      {
        v37 = (const char *)(a1 + 604);
        if (!a1)
          v37 = "";
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_ip_output_send";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v37;
        _os_log_impl(&dword_209FB3000, v36, OS_LOG_TYPE_INFO, "%{public}s %{public}s failed to get tcp buffer in tcp-ip output", buf, 0x16u);
      }
    }
    v38 = (_QWORD *)*a3;
    if (!*a3)
      return 6;
    while (1)
    {
      v39 = v38[4];
      v40 = (_QWORD *)v38[5];
      if (v39)
      {
        *(_QWORD *)(v39 + 40) = v40;
        v40 = (_QWORD *)v38[5];
      }
      else
      {
        a3[1] = v40;
      }
      *v40 = v39;
      v41 = (void (*)(_QWORD *, _QWORD, uint64_t))v38[10];
      v38[4] = 0;
      v38[5] = 0;
      if (!v41)
        break;
      v42 = v38[11];
      v38[10] = 0;
      v38[11] = 0;
      v41(v38, 0, v42);
LABEL_96:
      v38 = (_QWORD *)*a3;
      if (!*a3)
        return 6;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_frame_finalize";
    v70 = OS_LOG_TYPE_ERROR;
    v69 = 0;
    v62 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      if (v70 == OS_LOG_TYPE_FAULT)
      {
        v60 = __nwlog_obj();
        if (!os_log_type_enabled(v60, v70))
          goto LABEL_105;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v43 = v60;
        v44 = v70;
        v45 = "%{public}s called with null frame->finalizer";
      }
      else
      {
        v61 = __nwlog_obj();
        if (!os_log_type_enabled(v61, v70))
          goto LABEL_105;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v43 = v61;
        v44 = v70;
        v45 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }
      _os_log_impl(&dword_209FB3000, v43, v44, v45, buf, 0xCu);
    }
LABEL_105:
    if (v62)
      free(v62);
    goto LABEL_96;
  }
  if ((*(_BYTE *)(v15 + *((unsigned int *)v14 + 14) + 13) & 7) == 0)
  {
    if (*a3)
    {
      **(_QWORD **)(a2 + 664) = *a3;
      *(_QWORD *)(*a3 + 40) = *(_QWORD *)(a2 + 664);
      *(_QWORD *)(a2 + 664) = a3[1];
      *a3 = 0;
      a3[1] = a3;
    }
    v17 = 0;
    ++*(_DWORD *)(a2 + 672);
    return v17;
  }
LABEL_2:
  v12 = *(_QWORD *)(a2 + 656);
  if (v12)
  {
    if (*a3)
    {
      **(_QWORD **)(a2 + 664) = *a3;
      *(_QWORD *)(*a3 + 40) = *(_QWORD *)(a2 + 664);
      *(_QWORD *)(a2 + 664) = a3[1];
      *a3 = 0;
      a3[1] = a3;
      v12 = *(_QWORD *)(a2 + 656);
      v13 = a3;
      if (!v12)
        goto LABEL_21;
    }
    else
    {
      v13 = (_QWORD *)a3[1];
    }
    *v13 = v12;
    *(_QWORD *)(*(_QWORD *)(a2 + 656) + 40) = a3[1];
    a3[1] = *(_QWORD *)(a2 + 664);
    *(_QWORD *)(a2 + 656) = 0;
    *(_QWORD *)(a2 + 664) = a2 + 656;
LABEL_21:
    *(_DWORD *)(a2 + 672) = 0;
  }
  ++*(_BYTE *)(v10 + 2238);
  if (*(_DWORD *)(sysctls + 104) && !*(_DWORD *)(a1 + 592))
  {
    v18 = 1;
    if (!a5 && *(_DWORD *)(a2 + 12) == 4 && (*(_BYTE *)(a2 + 90) & 0x20) == 0 && (*(_BYTE *)(a1 + 367) & 1) == 0)
    {
      (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 0, v5);
      v18 = 0;
    }
  }
  else
  {
    v18 = 1;
  }
  v19 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 32);
  if (__nwlog_is_datapath_logging_enabled())
  {
    v64[0] = MEMORY[0x24BDAC760];
    v64[1] = 0x40000000;
    v65 = __tcp_ip_output_send_block_invoke;
    v66 = &__block_descriptor_tmp_485;
    v67 = a2;
    v68 = a1;
    v47 = *a3;
    do
    {
      if (!v47)
        break;
      v48 = *(_QWORD *)(v47 + 32);
      v49 = ((uint64_t (*)(_QWORD *))v65)(v64);
      v47 = v48;
    }
    while ((v49 & 1) != 0);
  }
  v20 = (_QWORD *)MEMORY[0x24BDE08B8];
  if (*MEMORY[0x24BDE08B8] != -1)
    dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_486);
  v21 = (_BYTE *)MEMORY[0x24BDE08B0];
  if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v72 = 0;
    nw_frame_array_foreach();
    if (*v20 == -1)
    {
      if (*v21)
        goto LABEL_118;
    }
    else
    {
      dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_486);
      if (*v21)
      {
LABEL_118:
        if (kdebug_is_enabled())
        {
          nw_frame_array_unclaimed_length();
          kdebug_trace();
        }
      }
    }
    _Block_object_dispose(buf, 8);
  }
  if (((*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)(v19 + 24) + 96))(v19, a3) & 1) == 0)
  {
    v22 = (_QWORD *)*a3;
    if (!*a3)
      goto LABEL_57;
    while (1)
    {
      v23 = v22[4];
      v24 = (_QWORD *)v22[5];
      if (v23)
      {
        *(_QWORD *)(v23 + 40) = v24;
        v24 = (_QWORD *)v22[5];
      }
      else
      {
        a3[1] = v24;
      }
      *v24 = v23;
      v25 = (void (*)(_QWORD *, _QWORD, uint64_t))v22[10];
      v22[4] = 0;
      v22[5] = 0;
      if (!v25)
        break;
      v26 = v22[11];
      v22[10] = 0;
      v22[11] = 0;
      v25(v22, 0, v26);
LABEL_39:
      v22 = (_QWORD *)*a3;
      if (!*a3)
        goto LABEL_57;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_frame_finalize";
    v27 = _os_log_send_and_compose_impl();
    v70 = OS_LOG_TYPE_ERROR;
    v69 = 0;
    v59 = (void *)v27;
    if (__nwlog_fault())
    {
      if (v70 == OS_LOG_TYPE_FAULT)
      {
        v56 = __nwlog_obj();
        log = v70;
        if (!os_log_type_enabled(v56, v70))
          goto LABEL_55;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v28 = v56;
        v29 = log;
        v30 = "%{public}s called with null frame->finalizer";
        goto LABEL_54;
      }
      if (!v69)
      {
        v58 = __nwlog_obj();
        logb = v70;
        if (!os_log_type_enabled(v58, v70))
          goto LABEL_55;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v28 = v58;
        v29 = logb;
        v30 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        goto LABEL_54;
      }
      backtrace_string = (os_log_t)__nw_create_backtrace_string();
      loga = __nwlog_obj();
      type = v70;
      v31 = os_log_type_enabled(loga, v70);
      v32 = backtrace_string;
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_209FB3000, loga, type, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          v32 = backtrace_string;
        }
        free(v32);
        goto LABEL_55;
      }
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v28 = loga;
        v29 = type;
        v30 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_54:
        _os_log_impl(&dword_209FB3000, v28, v29, v30, buf, 0xCu);
      }
    }
LABEL_55:
    if (v59)
      free(v59);
    goto LABEL_39;
  }
  if (*(_DWORD *)(a2 + 12) == 2)
    ++*(_BYTE *)(a2 + 1868);
LABEL_57:
  if ((v18 & 1) == 0)
    (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 0, v5);
  if ((*(_BYTE *)(v10 + 2231) & 0x10) != 0)
  {
    if ((v63 & 0x10000000) != 0)
    {
      v17 = 0;
      goto LABEL_66;
    }
LABEL_64:
    v17 = 55;
    goto LABEL_66;
  }
  v17 = 0;
  if ((*(_BYTE *)(*(_QWORD *)(v10 + 224) + 366) & 2) != 0 && (v63 & 0x10000000) == 0)
    goto LABEL_64;
LABEL_66:
  v33 = *(unsigned __int8 *)(v10 + 2238);
  *(_BYTE *)(v10 + 2238) = v33 - 1;
  if (v33)
  {
    if (v11)
    {
LABEL_68:
      v34 = *(_QWORD *)(v11 + 216);
      if (v34 != *(_QWORD *)(v10 + 448) && *(_DWORD *)(a1 + 384))
      {
        os_unfair_lock_lock((os_unfair_lock_t)(a2 + 1864));
        *(_QWORD *)(v10 + 448) = v34;
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 1864));
      }
    }
LABEL_71:
    if (*(int *)(a2 + 12) <= 3 && !*(_WORD *)(a2 + 226))
    {
      v35 = *(_QWORD *)(*(_QWORD *)(a2 + 80) + 496);
      if (v35)
      {
        tcp_getrt_rtt(a2, *(_QWORD *)(v35 + 1488));
        *(_DWORD *)(a2 + 28) = *(_DWORD *)(a2 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 224)) + 316)
                             - *(_DWORD *)(a2 + 64);
      }
    }
    return v17;
  }
  v50 = __nwlog_obj();
  os_log_type_enabled(v50, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "tcp_ip_output_send";
  v51 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v51);
    if (v11)
      goto LABEL_68;
    goto LABEL_71;
  }
  __break(1u);
  return result;
}

uint64_t nw_protocol_tcp_get_input_frames(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, _QWORD **a6)
{
  uint64_t v6;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  NSObject *v15;
  const char *v16;
  uint64_t v17;
  NSObject *v18;
  void *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  unsigned int *v23;
  uint64_t (*v24)(uint64_t);
  int v25;
  int *v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t isa;
  uint64_t *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  BOOL v35;
  unsigned int v36;
  unsigned int v37;
  _QWORD *v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  int v47;
  unsigned int v48;
  uint64_t v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  _QWORD *v53;
  void (*v54)(uint64_t, uint64_t, uint64_t);
  uint64_t v55;
  uint64_t v56;
  NSObject *v57;
  os_log_type_t v58;
  const char *v59;
  void *v60;
  _BOOL4 v61;
  uint64_t all_stats;
  unsigned int *v63;
  NSObject *v64;
  BOOL v65;
  int v66;
  uint64_t v67;
  void *v68;
  NSObject *v69;
  os_log_type_t v70;
  const char *v71;
  void *backtrace_string;
  _BOOL4 v73;
  NSObject *v74;
  os_log_type_t v75;
  uint32_t v76;
  uint64_t result;
  unsigned int v78;
  unsigned int v79;
  signed int v80;
  _QWORD *v81;
  uint64_t v82;
  _QWORD *v83;
  uint64_t *v84;
  uint64_t v85;
  uint64_t v86;
  char v87;
  NSObject *v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  _BOOL4 v92;
  int v93;
  uint64_t *v94;
  NSObject *v95;
  os_log_type_t v96;
  uint64_t v97;
  unsigned int v98;
  int v99;
  int v100;
  NSObject *v101;
  int v102;
  NSObject *v103;
  NSObject *v104;
  _QWORD *v105;
  NSObject *v106;
  void *v107;
  void *v108;
  NSObject *v109;
  os_log_type_t v110;
  const char *v111;
  void *v112;
  _BOOL4 v113;
  NSObject *v114;
  NSObject *log;
  NSObject *loga;
  NSObject *logb;
  void *v118;
  uint64_t v119;
  int v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  unsigned int *v124;
  os_log_t v125;
  os_log_t v126;
  NSObject *v127;
  NSObject *v128;
  int v129;
  os_log_t v130;
  os_log_t v131;
  unsigned int v132;
  NSObject *v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  _QWORD v139[2];
  uint64_t (*v140)(uint64_t, uint64_t);
  void *v141;
  uint64_t v142;
  BOOL v143;
  _QWORD v144[3];
  char v145;
  _BYTE buf[24];
  _BYTE v147[6];
  _BYTE v148[10];
  __int16 v149;
  int v150;
  __int16 v151;
  unsigned int v152;
  __int16 v153;
  unsigned int v154;
  uint64_t v155;

  v155 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
    v68 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (!__nwlog_fault())
      goto LABEL_143;
    if (BYTE4(v144[0]) == 17)
    {
      v95 = __nwlog_obj();
      v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0])))
        goto LABEL_143;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
      v71 = "%{public}s called with null protocol";
    }
    else
    {
      v95 = __nwlog_obj();
      v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0])))
        goto LABEL_143;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
      v71 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_234;
  }
  v12 = nw_protocol_downcast();
  if (!v12)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
    v68 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (!__nwlog_fault())
      goto LABEL_143;
    if (BYTE4(v144[0]) == 17)
    {
      v95 = __nwlog_obj();
      v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0])))
        goto LABEL_143;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
      v71 = "%{public}s called with null tcp";
    }
    else
    {
      v95 = __nwlog_obj();
      v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0])))
        goto LABEL_143;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
      v71 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
LABEL_234:
    v74 = v95;
    v75 = v96;
    v76 = 12;
    goto LABEL_142;
  }
  v13 = v12;
  v14 = *(_DWORD *)(v12 + 5224);
  if (v14 <= 1)
  {
    if ((*(_BYTE *)(v12 + 828) & 2) != 0)
      return 0;
    if (!__nwlog_is_datapath_logging_enabled())
      return 0;
    v15 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      return 0;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v13 + 604;
    v16 = "%{public}s %{public}s skipping";
    goto LABEL_8;
  }
  if (v14 != 2)
  {
    if (!*(_DWORD *)(v12 + 488))
    {
      if ((*(_BYTE *)(v12 + 828) & 2) != 0)
        return 0;
      if (!__nwlog_is_datapath_logging_enabled())
        return 0;
      v15 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        return 0;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v13 + 604;
      v16 = "%{public}s %{public}s past connected state, skipping";
LABEL_8:
      _os_log_impl(&dword_209FB3000, v15, OS_LOG_TYPE_DEBUG, v16, buf, 0x16u);
      return 0;
    }
    if ((*(_BYTE *)(v12 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v103 = __nwlog_tcp_log();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v13 + 604;
          _os_log_impl(&dword_209FB3000, v103, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s allowing read past connected state", buf, 0x16u);
        }
      }
    }
  }
  if (*(_DWORD *)(v13 + 492) < a3)
  {
    if ((*(_BYTE *)(v13 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v101 = __nwlog_tcp_log();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
        {
          v102 = *(_DWORD *)(v13 + 492);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v13 + 604;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)v147 = a3;
          *(_WORD *)&v147[4] = 1024;
          *(_DWORD *)v148 = v102;
          _os_log_impl(&dword_209FB3000, v101, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s capping minimum_bytes %u to sb_hiwat %u", buf, 0x22u);
        }
      }
    }
    a3 = *(_DWORD *)(v13 + 492);
  }
  v17 = *(_QWORD *)(v13 + 8);
  v18 = *(NSObject **)(*(_QWORD *)v13 + 240);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 16))(v13, 1, v6);
  if (*(_DWORD *)(v13 + 360) == 1)
  {
    if ((*(_BYTE *)(v13 + 828) & 2) != 0)
      goto LABEL_126;
    __nwlog_tcp_log();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "tcp_get_northbound_frames";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v13 + 604;
    v19 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (!__nwlog_fault())
      goto LABEL_54;
    if (BYTE4(v144[0]) == 17)
    {
      v20 = __nwlog_tcp_log();
      v21 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v20, BYTE4(v144[0])))
        goto LABEL_54;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "tcp_get_northbound_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v13 + 604;
      v22 = "%{public}s %{public}s no other reference on socket";
    }
    else
    {
      v20 = __nwlog_tcp_log();
      v21 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v20, BYTE4(v144[0])))
        goto LABEL_54;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "tcp_get_northbound_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v13 + 604;
      v22 = "%{public}s %{public}s no other reference on socket, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v20, v21, v22, buf, 0x16u);
LABEL_54:
    if (v19)
      free(v19);
    goto LABEL_126;
  }
  v23 = (unsigned int *)(v13 + 488);
  if ((*(_BYTE *)(v13 + 364) & 8) != 0)
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 57;
    if ((*(_BYTE *)(v13 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v104 = __nwlog_tcp_log();
        if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "tcp_get_northbound_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v13 + 604;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)v147 = 57;
          _os_log_impl(&dword_209FB3000, v104, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s defunct socket error (%d)", buf, 0x1Cu);
        }
      }
    }
    if (*(__int16 *)(v13 + 376) < 0)
      sb_empty_assert((int *)(v13 + 488), (uint64_t)"tcp_get_northbound_frames");
    goto LABEL_125;
  }
  if ((*(_BYTE *)(v13 + 368) & 0x20) != 0)
  {
    v24 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v17 + 40) + 88);
    if (v24)
    {
      v25 = v24(v13);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = v25;
      if (v25)
      {
LABEL_125:
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v13 + 8) + 24))(v13, 1, v6);
        goto LABEL_126;
      }
    }
  }
  if ((~*(unsigned __int16 *)(v13 + 376) & 0x21) == 0 && (*(_BYTE *)(v13 + 367) & 1) == 0)
  {
    v26 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    v27 = 45;
LABEL_124:
    *v26 = v27;
    goto LABEL_125;
  }
  v28 = *v23;
  if (*v23 < a3 && v28 < *(_DWORD *)(v13 + 496))
    goto LABEL_123;
  v29 = v28 >= a4 ? a4 : *v23;
  if (!v29)
    goto LABEL_123;
  v130 = v18;
  isa = *(_QWORD *)(v13 + 504);
  v138 = v29;
  if (!isa)
  {
    v129 = a5;
    goto LABEL_58;
  }
  v31 = (uint64_t *)(v13 + 504);
  if (*(_DWORD *)(v13 + 824) != -1)
  {
    v129 = a5;
    v32 = *(_DWORD *)(v13 + 552);
    v33 = v28 - v32;
    if (v28 > v32 && v33 <= v29)
    {
      *a6[1] = isa;
      *(_QWORD *)(*(_QWORD *)(v13 + 504) + 40) = a6[1];
      a6[1] = *(_QWORD **)(v13 + 512);
      *(_QWORD *)(v13 + 504) = 0;
      *(_QWORD *)(v13 + 512) = v31;
      goto LABEL_50;
    }
    v124 = (unsigned int *)(v13 + 488);
    v33 = 0;
    v34 = 0;
    v78 = v29;
    while (1)
    {
      v79 = *(_DWORD *)(isa + 52);
      if (v79)
        v79 -= *(_DWORD *)(isa + 56) + *(_DWORD *)(isa + 60);
      v80 = v78 - v79;
      if (v78 < v79)
        break;
      v82 = *(_QWORD *)(isa + 32);
      v83 = *(_QWORD **)(isa + 40);
      v81 = (_QWORD *)(isa + 32);
      if (v82)
      {
        *(_QWORD *)(v82 + 40) = v83;
        v83 = *(_QWORD **)(isa + 40);
      }
      else
      {
        *(_QWORD *)(v13 + 512) = v83;
      }
      v33 += v79;
      *v83 = v82;
      *v81 = 0;
      *(_QWORD *)(isa + 40) = 0;
      v84 = a6[1];
      *(_QWORD *)(isa + 40) = v84;
      *v84 = isa;
      a6[1] = v81;
      v34 = (v34 + 1);
      isa = *v31;
      if (*v31)
      {
        v78 = v80;
        if (v80)
          continue;
      }
      goto LABEL_167;
    }
    v80 = v78;
LABEL_167:
    if (!isa || !v80)
    {
      v23 = (unsigned int *)(v13 + 488);
      goto LABEL_59;
    }
    v126 = (os_log_t)(v13 + 504);
    v136 = v33;
    v89 = nw_protocol_tcp_copy_frame(v13, isa, v80);
    if (v89)
    {
      v90 = v89;
      if ((*(_WORD *)(isa + 204) & 0x80) != 0)
        *(_WORD *)(isa + 196) -= v80;
      v91 = *(_DWORD *)(isa + 56) + v80;
      if (v91 <= *(_DWORD *)(isa + 52) - *(_DWORD *)(isa + 60))
      {
        *(_DWORD *)(isa + 56) = v91;
      }
      else
      {
        v120 = *(_DWORD *)(isa + 56) + v80;
        v123 = *(_DWORD *)(isa + 60);
        v131 = (os_log_t)v89;
        v127 = __nwlog_obj();
        v92 = os_log_type_enabled(v127, OS_LOG_TYPE_ERROR);
        v90 = (uint64_t)v131;
        if (v92)
        {
          v93 = *(_DWORD *)(isa + 52);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v120;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v93;
          *(_WORD *)v147 = 1024;
          *(_DWORD *)&v147[2] = v123;
          _os_log_impl(&dword_209FB3000, v127, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
          v90 = (uint64_t)v131;
        }
      }
      *(_QWORD *)(v90 + 32) = 0;
      v33 = v136 + v80;
      v94 = a6[1];
      *(_QWORD *)(v90 + 40) = v94;
      *v94 = v90;
      a6[1] = (_QWORD *)(v90 + 32);
      v34 = (v34 + 1);
LABEL_187:
      v23 = v124;
      v29 = v138;
      goto LABEL_59;
    }
    if (v126->isa)
    {
      *a6[1] = v126->isa;
      *(_QWORD *)(*(_QWORD *)(v13 + 504) + 40) = a6[1];
      a6[1] = *(_QWORD **)(v13 + 512);
      *(_QWORD *)(v13 + 504) = 0;
      *(_QWORD *)(v13 + 512) = v126;
    }
    if (*a6)
    {
      **(_QWORD **)(v13 + 512) = *a6;
      (*a6)[5] = *(_QWORD *)(v13 + 512);
      *(_QWORD *)(v13 + 512) = a6[1];
      *a6 = 0;
      a6[1] = a6;
    }
    if ((*(_WORD *)(isa + 204) & 0x100) != 0
      && *MEMORY[0x24BDE08C0]
      && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(isa, *(_QWORD *)(isa + 88)) & 1) == 0)
    {
      v130[132].isa = 0;
    }
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 55;
LABEL_126:
    v66 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v66 == 35)
    {
      nw_protocol_tcp_set_receive_low_water_mark(a1, a3);
      return 0;
    }
    __nwlog_obj();
    v67 = v13 + 604;
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v13 + 604;
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)v147 = v66;
    v68 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (__nwlog_fault())
    {
      if (BYTE4(v144[0]) == 17)
      {
        v69 = __nwlog_obj();
        v70 = BYTE4(v144[0]);
        if (!os_log_type_enabled(v69, BYTE4(v144[0])))
          goto LABEL_143;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v67;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v147 = v66;
        v71 = "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d";
        goto LABEL_141;
      }
      if (!LOBYTE(v144[0]))
      {
        v69 = __nwlog_obj();
        v70 = BYTE4(v144[0]);
        if (!os_log_type_enabled(v69, BYTE4(v144[0])))
          goto LABEL_143;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v67;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v147 = v66;
        v71 = "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_141;
      }
      backtrace_string = (void *)__nw_create_backtrace_string();
      v69 = __nwlog_obj();
      v70 = BYTE4(v144[0]);
      v73 = os_log_type_enabled(v69, BYTE4(v144[0]));
      if (backtrace_string)
      {
        if (v73)
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v67;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)v147 = v66;
          *(_WORD *)&v147[4] = 2082;
          *(_QWORD *)v148 = backtrace_string;
          _os_log_impl(&dword_209FB3000, v69, v70, "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
        }
        free(backtrace_string);
        goto LABEL_143;
      }
      if (v73)
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v67;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v147 = v66;
        v71 = "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d, no backtrace";
LABEL_141:
        v74 = v69;
        v75 = v70;
        v76 = 28;
LABEL_142:
        _os_log_impl(&dword_209FB3000, v74, v75, v71, buf, v76);
      }
    }
LABEL_143:
    if (v68)
      free(v68);
    return 0;
  }
  v125 = (os_log_t)(v13 + 504);
  *(_QWORD *)((char *)v144 + 4) = 0;
  *(_QWORD *)((char *)&v144[1] + 4) = (char *)v144 + 4;
  if (!nw_protocol_tcp_get_frames(v13, v29, (uint64_t)v144 + 4, 1, 0, 0))
  {
    v26 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    v27 = 12;
    goto LABEL_124;
  }
  v39 = *(_QWORD *)((char *)v144 + 4);
  v129 = a5;
  if (!*(_QWORD *)((char *)v144 + 4))
  {
    v124 = (unsigned int *)(v13 + 488);
    v106 = __nwlog_obj();
    os_log_type_enabled(v106, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "tcp_get_northbound_frames";
    v107 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort();
    if ((_DWORD)result)
    {
      __break(1u);
      return result;
    }
    free(v107);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_frame_unclaimed_bytes";
    v108 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(v144[0]) = 16;
    v145 = 0;
    if (!__nwlog_fault())
      goto LABEL_255;
    if (LOBYTE(v144[0]) == 17)
    {
      v109 = __nwlog_obj();
      v110 = v144[0];
      if (os_log_type_enabled(v109, v144[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_unclaimed_bytes";
        v111 = "%{public}s called with null frame";
LABEL_253:
        v114 = v109;
LABEL_254:
        _os_log_impl(&dword_209FB3000, v114, v110, v111, buf, 0xCu);
      }
    }
    else if (v145)
    {
      v112 = (void *)__nw_create_backtrace_string();
      v110 = v144[0];
      v133 = __nwlog_obj();
      v113 = os_log_type_enabled(v133, v144[0]);
      if (v112)
      {
        if (v113)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "__nw_frame_unclaimed_bytes";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v112;
          _os_log_impl(&dword_209FB3000, v133, v144[0], "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v112);
        goto LABEL_255;
      }
      if (v113)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_unclaimed_bytes";
        v111 = "%{public}s called with null frame, no backtrace";
        v114 = v133;
        goto LABEL_254;
      }
    }
    else
    {
      v109 = __nwlog_obj();
      v110 = v144[0];
      if (os_log_type_enabled(v109, v144[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_unclaimed_bytes";
        v111 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_253;
      }
    }
LABEL_255:
    if (v108)
      free(v108);
    v34 = 0;
    v33 = 0;
    goto LABEL_187;
  }
  v29 = v138;
  if (!*(_QWORD *)(*(_QWORD *)((char *)v144 + 4) + 112))
    goto LABEL_58;
  if ((*(_WORD *)(*(_QWORD *)((char *)v144 + 4) + 204) & 0x100) != 0)
  {
    if (*MEMORY[0x24BDE08C0])
    {
      v121 = *(_QWORD *)((char *)v144 + 4);
      v40 = ((uint64_t (*)(_QWORD, _QWORD))*MEMORY[0x24BDE08C0])(*(_QWORD *)((char *)v144 + 4), *(_QWORD *)(*(_QWORD *)((char *)v144 + 4) + 88));
      v39 = v121;
      v29 = v138;
      if (!v40)
        goto LABEL_58;
    }
  }
  v41 = *(_DWORD *)(v39 + 52);
  if (!v41)
  {
    v33 = 0;
    v34 = 0;
    if (*(_QWORD *)(v39 + 112))
      goto LABEL_240;
    goto LABEL_59;
  }
  v42 = *(_QWORD *)(v39 + 112);
  if (!v42)
  {
LABEL_58:
    v34 = 0;
    v33 = 0;
    goto LABEL_59;
  }
  v122 = v39;
  v43 = *(unsigned int *)(v39 + 56);
  v44 = v41 - (v43 + *(_DWORD *)(v39 + 60));
  if (!v44 || !v130)
  {
    v33 = 0;
    v23 = (unsigned int *)(v13 + 488);
    goto LABEL_239;
  }
  v33 = 0;
  v119 = v42 + v43;
  while (1)
  {
    v134 = v33;
    if (!*(_QWORD *)(isa + 112))
      break;
    if ((*(_WORD *)(isa + 204) & 0x100) != 0)
    {
      if (*MEMORY[0x24BDE08C0])
      {
        v45 = ((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(isa, *(_QWORD *)(isa + 88));
        v29 = v138;
        if (!v45)
          break;
      }
    }
    v47 = *(_DWORD *)(isa + 52);
    v46 = *(unsigned int *)(isa + 56);
    v48 = v47 ? v47 - (v46 + *(_DWORD *)(isa + 60)) : 0;
    v49 = *(_QWORD *)(isa + 112);
    if (!v49)
      break;
    v50 = v44 - v48;
    if (v44 < v48)
      goto LABEL_206;
    v51 = v48;
    memcpy((void *)(v119 + v134), (const void *)(v49 + v46), v48);
    v52 = *(_QWORD *)(isa + 32);
    v53 = *(_QWORD **)(isa + 40);
    if (v52)
    {
      *(_QWORD *)(v52 + 40) = v53;
      v53 = *(_QWORD **)(isa + 40);
    }
    else
    {
      *(_QWORD *)(v13 + 512) = v53;
    }
    *v53 = v52;
    v54 = *(void (**)(uint64_t, uint64_t, uint64_t))(isa + 80);
    *(_QWORD *)(isa + 32) = 0;
    *(_QWORD *)(isa + 40) = 0;
    if (!v54)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_finalize";
      v56 = _os_log_send_and_compose_impl();
      LOBYTE(v144[0]) = 16;
      v145 = 0;
      v118 = (void *)v56;
      if (!__nwlog_fault())
        goto LABEL_107;
      if (LOBYTE(v144[0]) == 17)
      {
        log = __nwlog_obj();
        if (os_log_type_enabled(log, v144[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v57 = log;
          v58 = v144[0];
          v59 = "%{public}s called with null frame->finalizer";
          goto LABEL_106;
        }
        goto LABEL_107;
      }
      if (v145)
      {
        v60 = (void *)__nw_create_backtrace_string();
        loga = __nwlog_obj();
        v61 = os_log_type_enabled(loga, v144[0]);
        if (v60)
        {
          if (v61)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v60;
            _os_log_impl(&dword_209FB3000, loga, v144[0], "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v60);
          goto LABEL_107;
        }
        if (!v61)
        {
LABEL_107:
          if (v118)
            free(v118);
          goto LABEL_90;
        }
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v57 = loga;
        v58 = v144[0];
        v59 = "%{public}s called with null frame->finalizer, no backtrace";
      }
      else
      {
        logb = __nwlog_obj();
        if (!os_log_type_enabled(logb, v144[0]))
          goto LABEL_107;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v57 = logb;
        v58 = v144[0];
        v59 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }
LABEL_106:
      _os_log_impl(&dword_209FB3000, v57, v58, v59, buf, 0xCu);
      goto LABEL_107;
    }
    v55 = *(_QWORD *)(isa + 88);
    *(_QWORD *)(isa + 80) = 0;
    *(_QWORD *)(isa + 88) = 0;
    v54(isa, 1, v55);
LABEL_90:
    v33 = v51 + v134;
    isa = (uint64_t)v125->isa;
    v29 = v138;
    if (v125->isa)
    {
      v44 = v50;
      if (v50)
        continue;
    }
    goto LABEL_208;
  }
  if ((*(_WORD *)(isa + 204) & 0x100) == 0)
  {
LABEL_206:
    v50 = v44;
    goto LABEL_207;
  }
  if (*MEMORY[0x24BDE08C0]
    && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(isa, *(_QWORD *)(isa + 88)) & 1) == 0)
  {
    v130[132].isa = 0;
  }
  v50 = v44;
  v29 = v138;
LABEL_207:
  v33 = v134;
LABEL_208:
  if (isa && v50)
  {
    v137 = v33;
    v97 = *(_QWORD *)(isa + 112);
    if (v97
      && ((*(_WORD *)(isa + 204) & 0x100) == 0
       || !*MEMORY[0x24BDE08C0]
       || ((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(isa, *(_QWORD *)(isa + 88))
       && (v97 = *(_QWORD *)(isa + 112)) != 0))
    {
      memcpy((void *)(v119 + v137), (const void *)(v97 + *(unsigned int *)(isa + 56)), v50);
      if ((*(_WORD *)(isa + 204) & 0x80) != 0)
        *(_WORD *)(isa + 196) -= v50;
      v132 = v50;
      v98 = *(_DWORD *)(isa + 56) + v50;
      v99 = *(_DWORD *)(isa + 60);
      if (v98 <= *(_DWORD *)(isa + 52) - v99)
      {
        *(_DWORD *)(isa + 56) = v98;
      }
      else
      {
        v128 = __nwlog_obj();
        if (os_log_type_enabled(v128, OS_LOG_TYPE_ERROR))
        {
          v100 = *(_DWORD *)(isa + 52);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v98;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v100;
          *(_WORD *)v147 = 1024;
          *(_DWORD *)&v147[2] = v99;
          _os_log_impl(&dword_209FB3000, v128, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
        }
      }
      v33 = v137 + v132;
      v23 = (unsigned int *)(v13 + 488);
      v29 = v138;
    }
    else
    {
      if ((*(_WORD *)(isa + 204) & 0x100) != 0
        && *MEMORY[0x24BDE08C0]
        && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(isa, *(_QWORD *)(isa + 88)) & 1) == 0)
      {
        v130[132].isa = 0;
      }
      v23 = (unsigned int *)(v13 + 488);
      v29 = v138;
      v33 = v137;
    }
  }
  else
  {
    v23 = (unsigned int *)(v13 + 488);
  }
LABEL_239:
  v39 = v122;
LABEL_240:
  *(_QWORD *)(v39 + 32) = 0;
  v105 = a6[1];
  *(_QWORD *)(v39 + 40) = v105;
  *v105 = v39;
  a6[1] = (_QWORD *)(v39 + 32);
LABEL_50:
  v34 = 1;
LABEL_59:
  v35 = v29 >= v33;
  v36 = v29 - v33;
  if (v36 != 0 && v35)
  {
    v37 = v33;
    v144[0] = 0;
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    if (tcp_input_get_aggregate_frames(v13, v36, (_DWORD *)v144 + 1, v144, (uint64_t)buf))
    {
      if (*(_QWORD *)buf)
      {
        *a6[1] = *(_QWORD *)buf;
        v38 = *(_QWORD **)&buf[8];
        *(_QWORD *)(*(_QWORD *)buf + 40) = a6[1];
        a6[1] = v38;
      }
      v33 = HIDWORD(v144[0]) + v37;
      v34 = (LODWORD(v144[0]) + v34);
    }
    else
    {
      v33 = v37;
    }
  }
  if (!v33)
  {
LABEL_123:
    v26 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    v27 = 35;
    goto LABEL_124;
  }
  v135 = v33;
  *(_DWORD *)(v13 + 488) -= v33;
  if (*(_QWORD *)(v13 + 24))
  {
    all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats)
      *(_DWORD *)(all_stats + 92) = *v23;
  }
  v63 = v23;
  if (*(_QWORD *)v13)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(v17 + 40) + 56))(v13, 0);
  if (v138 != v135)
  {
    v64 = __nwlog_obj();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "tcp_get_northbound_frames";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v138;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v135;
      _os_log_impl(&dword_209FB3000, v64, OS_LOG_TYPE_ERROR, "%{public}s Failed to copy expected bytes, total_space %u != adj_space %u", buf, 0x18u);
    }
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v13 + 8) + 24))(v13, 1, v6);
  if ((v138 & 0x80000000) != 0)
    goto LABEL_126;
  if (*(_QWORD *)(v13 + 5232))
  {
    nw_protocol_tcp_update_metadata(a1);
    v65 = (*(_WORD *)(v13 + 376) & 0x20) != 0 && *v63 == 0;
    v139[0] = MEMORY[0x24BDAC760];
    v139[1] = 0x40000000;
    v140 = __nw_protocol_tcp_get_input_frames_block_invoke;
    v141 = &__block_descriptor_tmp_25;
    v142 = v13;
    v143 = v65;
    v85 = (uint64_t)*a6;
    do
    {
      if (!v85)
        break;
      v86 = *(_QWORD *)(v85 + 32);
      v87 = ((uint64_t (*)(_QWORD *))v140)(v139);
      v85 = v86;
    }
    while ((v87 & 1) != 0);
  }
  nw_protocol_tcp_set_receive_low_water_mark(a1, 1);
  if ((*(_BYTE *)(v13 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v88 = __nwlog_tcp_log();
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136448002;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v13 + 604;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v147 = a3;
        *(_WORD *)&v147[4] = 1024;
        *(_DWORD *)v148 = a4;
        *(_WORD *)&v148[4] = 1024;
        *(_DWORD *)&v148[6] = v129;
        v149 = 1024;
        v150 = v34;
        v151 = 1024;
        v152 = v135;
        v153 = 1024;
        v154 = v138;
        _os_log_impl(&dword_209FB3000, v88, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Asked for min %u max %u bytes, max %u frames and got %d frames %u bytes, ret %u", buf, 0x3Au);
      }
    }
  }
  return v34;
}

uint64_t tcp_lock(uint64_t *a1, int a2)
{
  int v3;
  uint64_t result;
  uint64_t v5;
  int v6;
  void *v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t *v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  __int16 v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v3 = *((_DWORD *)a1 + 90);
  if (v3 < 0)
  {
    if ((*((_BYTE *)a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      v5 = *a1;
      v6 = *((_DWORD *)a1 + 90);
      *(_DWORD *)buf = 136447490;
      v12 = "tcp_lock";
      v13 = 2082;
      v14 = (uint64_t)a1 + 604;
      v15 = 2048;
      v16 = a1;
      v17 = 2048;
      v18 = v5;
      v19 = 1024;
      v20 = v6;
      v21 = 2080;
      v22 = "";
      v7 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v8 = __nwlog_tcp_log();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          v9 = *a1;
          v10 = *((_DWORD *)a1 + 90);
          *(_DWORD *)buf = 136447490;
          v12 = "tcp_lock";
          v13 = 2082;
          v14 = (uint64_t)a1 + 604;
          v15 = 2048;
          v16 = a1;
          v17 = 2048;
          v18 = v9;
          v19 = 1024;
          v20 = v10;
          v21 = 2080;
          v22 = "";
          _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_ERROR, "%{public}s %{public}s tcp_lock: so=%p so_pcb=%p ref=%x lrh= %s, backtrace limit exceeded", buf, 0x3Au);
        }
      }
      if (v7)
        free(v7);
    }
    return 22;
  }
  else
  {
    result = 0;
    if (a2)
      *((_DWORD *)a1 + 90) = v3 + 1;
  }
  return result;
}

uint64_t tcp_unlock(uint64_t a1, int a2)
{
  int v3;
  int v5;
  void *v6;
  int v7;
  NSObject *v8;
  int v9;
  const char *v10;
  int v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 360);
  if (a2)
    *(_DWORD *)(a1 + 360) = --v3;
  if (v3 < 0)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      v5 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      v13 = "tcp_unlock";
      v14 = 2082;
      v15 = a1 + 604;
      v16 = 2048;
      v17 = a1;
      v18 = 1024;
      v19 = v5;
      v20 = 2080;
      v21 = "";
      v6 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_fault())
        goto LABEL_17;
      v8 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        goto LABEL_17;
      v9 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      v13 = "tcp_unlock";
      v14 = 2082;
      v15 = a1 + 604;
      v16 = 2048;
      v17 = a1;
      v18 = 1024;
      v19 = v9;
      v20 = 2080;
      v21 = "";
      v10 = "%{public}s %{public}s tcp_unlock: so=%p usecount=%x lrh= %s, backtrace limit exceeded";
      goto LABEL_16;
    }
  }
  else
  {
    if (*(_QWORD *)a1)
      return 0;
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      v7 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      v13 = "tcp_unlock";
      v14 = 2082;
      v15 = a1 + 604;
      v16 = 2048;
      v17 = a1;
      v18 = 1024;
      v19 = v7;
      v20 = 2080;
      v21 = "";
      v6 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_fault())
        goto LABEL_17;
      v8 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        goto LABEL_17;
      v11 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      v13 = "tcp_unlock";
      v14 = 2082;
      v15 = a1 + 604;
      v16 = 2048;
      v17 = a1;
      v18 = 1024;
      v19 = v11;
      v20 = 2080;
      v21 = "";
      v10 = "%{public}s %{public}s tcp_unlock: so=%p NO PCB usecount=%x lrh= %s, backtrace limit exceeded";
LABEL_16:
      _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_ERROR, v10, buf, 0x30u);
LABEL_17:
      if (v6)
        free(v6);
    }
  }
  return 22;
}

void nw_protocol_tcp_set_receive_low_water_mark(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  signed int v6;
  NSObject *v7;
  int v8;
  int v9;
  const char *v10;
  NSObject *v11;
  os_log_type_t v12;
  uint32_t v13;
  NSObject *v14;
  void *v15;
  NSObject *v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  _BYTE v20[10];
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v4 = nw_protocol_downcast();
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_tcp_set_receive_low_water_mark";
    v15 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v16 = __nwlog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_tcp_set_receive_low_water_mark";
        _os_log_impl(&dword_209FB3000, v16, OS_LOG_TYPE_ERROR, "%{public}s called with null tcp, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v15)
      free(v15);
    return;
  }
  v5 = v4;
  if (a2 <= 1)
    a2 = 1;
  if (*(_DWORD *)(v4 + 496) == a2)
    return;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 8) + 16))(v4, 1, v2);
  if ((~*(unsigned __int16 *)(v5 + 376) & 0x30) != 0)
  {
    if (a2 > 0)
      goto LABEL_8;
LABEL_19:
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 + 8) + 24))(v5, 1, v2);
    v14 = __nwlog_obj();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446722;
    v18 = "nw_protocol_tcp_set_receive_low_water_mark";
    v19 = 1024;
    *(_DWORD *)v20 = a2;
    *(_WORD *)&v20[4] = 1024;
    *(_DWORD *)&v20[6] = 22;
    v10 = "%{public}s setsockopt SO_RCVLOWAT %u failed %{darwin.errno}d";
    v11 = v14;
    v12 = OS_LOG_TYPE_ERROR;
    v13 = 24;
    goto LABEL_21;
  }
  if ((*(_BYTE *)(v5 + 365) & 0x20) == 0 || a2 < 1)
    goto LABEL_19;
LABEL_8:
  v6 = *(_DWORD *)(v5 + 492) / 3u;
  if (a2 <= *(_DWORD *)(v5 + 492) / 3)
    v6 = a2;
  if (v6 >= 0x4000)
    v6 = 0x4000;
  if (v6 <= 1)
    v6 = 1;
  *(_DWORD *)(v5 + 496) = v6;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 + 8) + 24))(v5, 1, v2);
  if ((*(_BYTE *)(v5 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v8 = *(_DWORD *)(v5 + 496);
        v9 = *(_DWORD *)(v5 + 488);
        *(_DWORD *)buf = 136446978;
        v18 = "nw_protocol_tcp_set_receive_low_water_mark";
        v19 = 2082;
        *(_QWORD *)v20 = v5 + 604;
        *(_WORD *)&v20[8] = 1024;
        v21 = v8;
        v22 = 1024;
        v23 = v9;
        v10 = "%{public}s %{public}s so_rcv.sb_lowat %u sb_cc %u";
        v11 = v7;
        v12 = OS_LOG_TYPE_DEBUG;
        v13 = 34;
LABEL_21:
        _os_log_impl(&dword_209FB3000, v11, v12, v10, buf, v13);
      }
    }
  }
}

uint64_t __nw_protocol_tcp_get_input_frames_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  _BOOL4 v4;
  unsigned int dscp_value;
  nw_service_class_t service_class;
  int v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  char v14;
  void *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  const unsigned __int8 *v19;
  char v20;
  char v21;
  nw_protocol_definition_t v22;
  NSObject *v23;
  nw_protocol_definition_t v24;
  void *v25;
  _QWORD *v26;
  char v27;
  uint64_t v28;
  _QWORD *v29;
  NSObject *v30;
  os_log_type_t v31;
  uint32_t v32;
  uint64_t result;
  NSObject *v34;
  os_log_type_t v35;
  void *v36;
  NSObject *v37;
  os_log_type_t v38;
  const char *v39;
  NSObject *v40;
  void *v41;
  os_log_type_t type[16];
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 5232);
  if (*(_BYTE *)(a1 + 40))
  {
    v4 = *(_QWORD *)(a2 + 32) == 0;
    if (v3)
      goto LABEL_3;
LABEL_10:
    v8 = a2 + 204;
    if ((*(_WORD *)(a2 + 204) & 8) != 0)
      return 1;
    goto LABEL_15;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v44 = "__nw_frame_set_metadata";
    v15 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v34 = __nwlog_obj();
        v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v44 = "__nw_frame_set_metadata";
          v18 = "%{public}s called with null frame";
LABEL_77:
          v30 = v34;
          v31 = v35;
          v32 = 12;
LABEL_59:
          _os_log_impl(&dword_209FB3000, v30, v31, v18, buf, v32);
        }
      }
      else
      {
        v34 = __nwlog_obj();
        v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v44 = "__nw_frame_set_metadata";
          v18 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_77;
        }
      }
    }
LABEL_60:
    if (v15)
      free(v15);
    return 1;
  }
  v4 = 0;
  if (!v3)
    goto LABEL_10;
LABEL_3:
  if (nw_protocol_metadata_is_ip(*(nw_protocol_metadata_t *)(*(_QWORD *)(a1 + 32) + 5232)))
  {
    *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0xFC | nw_ip_metadata_get_ecn_flag(v3) & 3;
    dscp_value = nw_ip_metadata_get_dscp_value();
    if (dscp_value < 0x40)
    {
      *(_BYTE *)(a2 + 184) = dscp_value;
LABEL_6:
      service_class = nw_ip_metadata_get_service_class(v3);
      if (service_class > nw_service_class_signaling)
        v7 = 0;
      else
        v7 = dword_20A010AC8[service_class];
      *(_DWORD *)(a2 + 176) = v7;
      *(_DWORD *)(a2 + 180) = nw_ip_metadata_get_fragmentation_value();
      goto LABEL_14;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v44 = "__nw_frame_set_dscp_value";
    v36 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v37 = __nwlog_obj();
        v38 = type[0];
        if (!os_log_type_enabled(v37, type[0]))
          goto LABEL_81;
        *(_DWORD *)buf = 136446210;
        v44 = "__nw_frame_set_dscp_value";
        v39 = "%{public}s called with null (dscp_value <= _MAX_DSCP)";
      }
      else
      {
        v37 = __nwlog_obj();
        v38 = type[0];
        if (!os_log_type_enabled(v37, type[0]))
          goto LABEL_81;
        *(_DWORD *)buf = 136446210;
        v44 = "__nw_frame_set_dscp_value";
        v39 = "%{public}s called with null (dscp_value <= _MAX_DSCP), backtrace limit exceeded";
      }
      _os_log_impl(&dword_209FB3000, v37, v38, v39, buf, 0xCu);
    }
LABEL_81:
    if (v36)
      free(v36);
    goto LABEL_6;
  }
LABEL_14:
  v8 = a2 + 204;
  if ((*(_WORD *)(a2 + 204) & 8) == 0)
  {
LABEL_15:
    v9 = *(void **)(a2 + 168);
    if (v9)
    {
      nw_release(v9);
      *(_QWORD *)(a2 + 168) = 0;
    }
    v10 = a2 + 120;
    if (v3)
    {
      *(_QWORD *)(a2 + 168) = nw_retain(v3);
      v11 = *(unsigned __int16 *)(a2 + 204);
      v12 = v11 | (*(unsigned __int8 *)(a2 + 206) << 16);
      if ((v11 & 0x20) == 0)
      {
        nw_protocol_metadata_copy_identifier();
        v12 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
      }
      *(_BYTE *)(v8 + 2) = BYTE2(v12);
      *(_WORD *)v8 = v12 | 8;
    }
    v13 = *(_QWORD *)(a2 + 64);
    if (v4)
      v14 = 64;
    else
      v14 = 0;
    *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0xBF | v14;
    if (!v13)
    {
      *(_QWORD *)(a2 + 64) = v10;
      *(_QWORD *)(a2 + 72) = v10;
      *(_QWORD *)(a2 + 120) = 0;
      *(_QWORD *)(a2 + 128) = a2 + 64;
      return 1;
    }
    if (v13 == v10)
      return 1;
    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    v44 = "__nw_frame_set_metadata";
    v45 = 2048;
    v46 = v13;
    v47 = 2048;
    v48 = a2 + 120;
    v15 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_60;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type[0];
      if (!os_log_type_enabled(v16, type[0]))
        goto LABEL_60;
      *(_DWORD *)buf = 136446722;
      v44 = "__nw_frame_set_metadata";
      v45 = 2048;
      v46 = v13;
      v47 = 2048;
      v48 = v10;
      v18 = "%{public}s Existing metadata %p doesn't match expected %p";
    }
    else
    {
      v16 = __nwlog_obj();
      v17 = type[0];
      if (!os_log_type_enabled(v16, type[0]))
        goto LABEL_60;
      *(_DWORD *)buf = 136446722;
      v44 = "__nw_frame_set_metadata";
      v45 = 2048;
      v46 = v13;
      v47 = 2048;
      v48 = v10;
      v18 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
    }
    v30 = v16;
    v31 = v17;
    v32 = 32;
    goto LABEL_59;
  }
  memset(type, 0, sizeof(type));
  nw_protocol_metadata_copy_identifier();
  v19 = *(const unsigned __int8 **)(a2 + 64);
  if (!v19)
    goto LABEL_47;
  v20 = 0;
  if (v4)
    v21 = 64;
  else
    v21 = 0;
  do
  {
    v22 = nw_protocol_metadata_copy_definition(v3);
    v23 = *((_QWORD *)v19 + 6);
    if (!v23)
      goto LABEL_40;
    v24 = nw_protocol_metadata_copy_definition(v23);
    if (!MEMORY[0x20BD1E41C](v22, v24) || uuid_compare((const unsigned __int8 *)type, v19 + 16))
    {
      if (!v24)
        goto LABEL_40;
LABEL_39:
      nw_release(v24);
      goto LABEL_40;
    }
    nw_retain(v3);
    v25 = (void *)*((_QWORD *)v19 + 6);
    if (v25)
      nw_release(v25);
    *((_QWORD *)v19 + 6) = v3;
    *((_BYTE *)v19 + 66) = v19[66] & 0xBF | v21;
    v20 = 1;
    if (v24)
      goto LABEL_39;
LABEL_40:
    if (v22)
      nw_release(v22);
    v19 = *(const unsigned __int8 **)v19;
  }
  while (v19);
  if ((v20 & 1) != 0)
    return 1;
LABEL_47:
  v26 = malloc_type_calloc(1uLL, 0x48uLL, 0xEAFB8F1AuLL);
  if (v26)
    goto LABEL_48;
  v40 = __nwlog_obj();
  os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v44 = "strict_calloc";
  v45 = 2048;
  v46 = 1;
  v47 = 2048;
  v48 = 72;
  v41 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if ((_DWORD)result)
  {
    __break(1u);
  }
  else
  {
    free(v41);
LABEL_48:
    v26[6] = nw_retain(v3);
    *((_OWORD *)v26 + 1) = *(_OWORD *)type;
    if (v4)
      v27 = 64;
    else
      v27 = 0;
    *((_BYTE *)v26 + 66) = *((_BYTE *)v26 + 66) & 0xBF | v27;
    v28 = *(_QWORD *)(a2 + 64);
    *v26 = v28;
    if (v28)
      v29 = (_QWORD *)(v28 + 8);
    else
      v29 = (_QWORD *)(a2 + 72);
    *v29 = v26;
    *(_QWORD *)(a2 + 64) = v26;
    v26[1] = a2 + 64;
    return 1;
  }
  return result;
}

uint64_t tcp_usr_rcvd(uint64_t *a1)
{
  uint64_t v1;
  int *v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t all_stats;
  unsigned int v15;

  v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3)
    return 22;
  v4 = *(int **)(v1 + 240);
  v5 = nw_tcp_access_globals(*(_QWORD *)(v1 + 224));
  calculate_tcp_clock(v5);
  if (v4)
  {
    if (*(_DWORD *)(sysctls + 68) == 1)
    {
      v6 = *((_DWORD *)a1 + 135);
      if (v6)
      {
        v7 = *((_DWORD *)a1 + 123);
        v8 = v7 - v6;
        if (v7 > v6)
        {
          v9 = v6 >> 4;
          if (v4[31] - v4[30] > v9)
            v9 = v4[31] - v4[30];
          if (!v9)
            v9 = 8 * v4[49];
          v10 = v7 - v9 - *((_DWORD *)a1 + 122);
          if (v10 < v8)
            v8 = v10;
          if (v8 >= 1)
          {
            v11 = v7 - v8;
            if (v11 <= 0x71C71C)
            {
              *((_DWORD *)a1 + 123) = v11;
              v12 = *(_QWORD *)(a1[70] + 24);
              if ((a1[67] & 4) != 0)
              {
                if (v12)
                {
                  all_stats = nw_protocol_tcp_get_all_stats();
                  if (all_stats)
                    *(_DWORD *)(all_stats + 88) = *((_DWORD *)a1 + 123);
                }
              }
              else if (v12)
              {
                v13 = nw_protocol_tcp_get_all_stats();
                if (v13)
                  *(_DWORD *)(v13 + 100) = *((_DWORD *)a1 + 123);
              }
              v15 = *((_DWORD *)a1 + 123);
              if (*((_DWORD *)a1 + 124) > v15)
                *((_DWORD *)a1 + 124) = v15;
            }
          }
        }
      }
    }
    if (v4[3] >= 4)
      tcp_output((uint64_t)v4);
  }
  return 0;
}

uint64_t tcp_getrt_rtt(uint64_t result, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;

  if (!a2)
    return result;
  v2 = *(_DWORD *)(a2 + 64);
  if (!v2 || *(_DWORD *)(result + 1872) == 1)
    return result;
  if ((*(_DWORD *)(result + 88) & 0x20000) != 0)
    v3 = *(_DWORD *)(sysctls + 172);
  else
    v3 = 30;
  *(_DWORD *)(result + 228) = v3;
  v4 = v2 / 0x1F;
  *(_DWORD *)(result + 200) = v2 / 0x1F;
  v5 = *(_QWORD *)(result + 1056);
  if (!v5)
  {
    v8 = *(_DWORD *)(a2 + 68);
    if (v8)
    {
      v7 = v8 / 0x3E;
      *(_DWORD *)(result + 208) = v8 / 0x3E;
      goto LABEL_13;
    }
LABEL_12:
    v7 = v2 / 0x3E;
    *(_DWORD *)(result + 208) = v7;
    goto LABEL_13;
  }
  ++*(_QWORD *)(v5 + 1280);
  v6 = *(_DWORD *)(a2 + 68);
  if (!v6)
    goto LABEL_12;
  v7 = v6 / 0x3E;
  *(_DWORD *)(result + 208) = v6 / 0x3E;
  ++*(_QWORD *)(v5 + 1288);
LABEL_13:
  if (*(int *)(result + 12) < 4)
    v9 = 0;
  else
    v9 = *(_DWORD *)(sysctls + 176);
  v10 = (v7 + (v4 >> 3)) >> 2;
  if (v3 > v10)
    v10 = v3;
  v11 = v10 + v9;
  *(_DWORD *)(result + 192) = v11;
  if (v11 >= v3)
  {
    if (v11 < 0xFA01)
      return result;
    v3 = 64000;
  }
  *(_DWORD *)(result + 192) = v3;
  return result;
}

void nw_protocol_tcp_input_available(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  dispatch_once_t *v3;
  unsigned int input_frames;
  unsigned int v5;
  uint64_t *v6;
  char v7;
  dispatch_once_t *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  char v15;
  char v16;
  char v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  NSObject *v21;
  _QWORD *i;
  void (*v23)(_QWORD *, _QWORD, uint64_t);
  _QWORD *v24;
  uint64_t v25;
  void *v26;
  NSObject *v27;
  os_log_type_t v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  void *backtrace_string;
  NSObject *v33;
  os_log_type_t v34;
  _BOOL4 v35;
  NSObject *v36;
  os_log_type_t v37;
  uint64_t v38;
  void (*v39)(uint64_t);
  uint64_t v40;
  uint64_t v41;
  NSObject *v42;
  NSObject *v43;
  uint64_t v44;
  NSObject *v45;
  NSObject *v46;
  const char *v47;
  const char *v48;
  char *v49;
  int v50;
  NSObject *v51;
  NSObject *v52;
  const char *v53;
  NSObject *v54;
  os_log_type_t v55;
  uint32_t v56;
  NSObject *v57;
  void *v58;
  NSObject *v59;
  os_log_type_t v60;
  const char *v61;
  NSObject *log;
  uint64_t v63;
  int *v64;
  os_log_type_t type[8];
  os_log_type_t *v66;
  BOOL v67;
  __int16 v68;
  _BYTE buf[22];
  __int16 v70;
  _BYTE v71[10];
  char *v72;
  __int16 v73;
  int v74;
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_input_available";
    v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    HIBYTE(v68) = 0;
    if (!__nwlog_fault())
      goto LABEL_128;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v59 = __nwlog_obj();
      v60 = type[0];
      if (!os_log_type_enabled(v59, type[0]))
        goto LABEL_128;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_input_available";
      v61 = "%{public}s called with null protocol";
    }
    else
    {
      v59 = __nwlog_obj();
      v60 = type[0];
      if (!os_log_type_enabled(v59, type[0]))
        goto LABEL_128;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_input_available";
      v61 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_127;
  }
  v1 = nw_protocol_downcast();
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_input_available";
    v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    HIBYTE(v68) = 0;
    if (!__nwlog_fault())
      goto LABEL_128;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v59 = __nwlog_obj();
      v60 = type[0];
      if (!os_log_type_enabled(v59, type[0]))
        goto LABEL_128;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_input_available";
      v61 = "%{public}s called with null tcp";
    }
    else
    {
      v59 = __nwlog_obj();
      v60 = type[0];
      if (!os_log_type_enabled(v59, type[0]))
        goto LABEL_128;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_input_available";
      v61 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
LABEL_127:
    _os_log_impl(&dword_209FB3000, v59, v60, v61, buf, 0xCu);
LABEL_128:
    if (v58)
      free(v58);
    return;
  }
  v2 = v1;
  if (*(_DWORD *)(v1 + 5224))
  {
    v3 = (dispatch_once_t *)MEMORY[0x24BDE08B8];
    if (*MEMORY[0x24BDE08B8] != -1)
      dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_16);
    if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
      kdebug_trace();
    v64 = (int *)(v2 + 488);
    v63 = v2 + 604;
    *(_QWORD *)type = 0;
    v66 = type;
    while (1)
    {
LABEL_11:
      nw_protocol_get_output_handler();
      input_frames = nw_protocol_get_input_frames();
      if (!input_frames)
        return;
      v5 = input_frames;
      if (*v3 != -1)
        dispatch_once(v3, &__block_literal_global_16);
      if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
      {
        nw_frame_array_unclaimed_length();
        kdebug_trace();
      }
      if (v5 > tcp_input_batch_size)
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0)
        {
          v57 = __nwlog_tcp_log();
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_input_available";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v63;
            v70 = 1024;
            *(_DWORD *)v71 = tcp_input_batch_size;
            *(_WORD *)&v71[4] = 1024;
            *(_DWORD *)&v71[6] = v5;
            v53 = "%{public}s %{public}s we asked for maximum %u frames, but got %u";
            v54 = v57;
            v55 = OS_LOG_TYPE_ERROR;
            v56 = 34;
LABEL_111:
            _os_log_impl(&dword_209FB3000, v54, v55, v53, buf, v56);
          }
        }
        return;
      }
      if ((*(_BYTE *)(v2 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v45 = __nwlog_tcp_log();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_input_available";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v2 + 604;
            v70 = 1024;
            *(_DWORD *)v71 = v5;
            _os_log_impl(&dword_209FB3000, v45, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s input available and we got %d frames", buf, 0x1Cu);
          }
        }
      }
      v6 = *(uint64_t **)v2;
      if (!*(_QWORD *)v2)
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            v21 = __nwlog_tcp_log();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "tcp_input_available";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v2 + 604;
              _os_log_impl(&dword_209FB3000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s inp == NULL || so->so_pcb == NULL", buf, 0x16u);
            }
          }
        }
LABEL_51:
        for (i = *(_QWORD **)type; ; i = v24)
        {
LABEL_52:
          if (!i)
            goto LABEL_11;
          v23 = (void (*)(_QWORD *, _QWORD, uint64_t))i[10];
          v24 = (_QWORD *)i[4];
          if (!v23)
            break;
          v25 = i[11];
          i[10] = 0;
          i[11] = 0;
          v23(i, 0, v25);
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v26 = (void *)_os_log_send_and_compose_impl();
        v68 = 4096;
        if (!__nwlog_fault())
          goto LABEL_69;
        if (HIBYTE(v68) == 17)
        {
          v27 = __nwlog_obj();
          v28 = HIBYTE(v68);
          if (os_log_type_enabled(v27, HIBYTE(v68)))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v29 = v27;
            v30 = v28;
            v31 = "%{public}s called with null frame->finalizer";
            goto LABEL_68;
          }
          goto LABEL_69;
        }
        if ((_BYTE)v68)
        {
          backtrace_string = (void *)__nw_create_backtrace_string();
          v33 = __nwlog_obj();
          v34 = HIBYTE(v68);
          log = v33;
          v35 = os_log_type_enabled(v33, HIBYTE(v68));
          if (backtrace_string)
          {
            if (v35)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "__nw_frame_finalize";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_209FB3000, log, v34, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(backtrace_string);
            goto LABEL_69;
          }
          if (!v35)
          {
LABEL_69:
            if (v26)
              free(v26);
            i = v24;
            goto LABEL_52;
          }
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v29 = log;
          v30 = v34;
          v31 = "%{public}s called with null frame->finalizer, no backtrace";
        }
        else
        {
          v36 = __nwlog_obj();
          v37 = HIBYTE(v68);
          if (!os_log_type_enabled(v36, HIBYTE(v68)))
            goto LABEL_69;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v29 = v36;
          v30 = v37;
          v31 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        }
LABEL_68:
        _os_log_impl(&dword_209FB3000, v29, v30, v31, buf, 0xCu);
        goto LABEL_69;
      }
      v7 = *(_BYTE *)(v2 + 828);
      if ((*(_BYTE *)(v2 + 364) & 8) != 0)
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            v51 = __nwlog_tcp_log();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "tcp_input_available";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v2 + 604;
              v70 = 1024;
              *(_DWORD *)v71 = 57;
              _os_log_impl(&dword_209FB3000, v51, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s defunct socket error (%d)", buf, 0x1Cu);
            }
          }
        }
        if (*(__int16 *)(v2 + 376) < 0)
          sb_empty_assert(v64, (uint64_t)"tcp_input_available");
        goto LABEL_51;
      }
      v8 = v3;
      if ((*(_BYTE *)(v2 + 828) & 1) == 0)
      {
        v9 = nw_tcp_access_globals(v2);
        ++*(_DWORD *)(v9 + 288);
        v10 = v6[28];
        if (*(_QWORD *)(v10 + 520))
        {
          if ((*(_BYTE *)(v10 + 828) & 2) == 0)
          {
            v11 = __nwlog_tcp_log();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "tcp_input_aggregate_begin";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v10 + 604;
              _os_log_impl(&dword_209FB3000, v11, OS_LOG_TYPE_ERROR, "%{public}s %{public}s tcp_input_aggregate_begin sb_mb_aggregate not empty", buf, 0x16u);
            }
          }
        }
      }
      v12 = v6[30];
      if (*(_DWORD *)(v12 + 12) == 4 && *(int *)(sysctls + 100) >= 1)
        *(_DWORD *)(v12 + 740) |= 0x2000000u;
      *(_QWORD *)(v12 + 656) = 0;
      *(_QWORD *)(v12 + 664) = v12 + 656;
      *(_DWORD *)(v12 + 672) = 0;
      v13 = v6[28];
      if (!v13 || (*(_BYTE *)(v13 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v46 = __nwlog_tcp_log();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          {
            v47 = (const char *)(v13 + 604);
            if (!v13)
              v47 = "";
            v48 = "on";
            if ((*(_DWORD *)(v12 + 740) & 0x2000000) == 0)
              v48 = "off";
            v49 = tcpstates[*(int *)(v12 + 12)];
            v50 = *(_DWORD *)(sysctls + 100);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "tcp_output_batch_acks_begin";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v47;
            v70 = 2082;
            *(_QWORD *)v71 = v48;
            *(_WORD *)&v71[8] = 2082;
            v72 = v49;
            v73 = 1024;
            v74 = v50;
            _os_log_impl(&dword_209FB3000, v46, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s %{public}s t_state %{public}s tcp_packet_chaining %d", buf, 0x30u);
          }
        }
      }
      v14 = *(_QWORD **)type;
      if (!*(_QWORD *)type)
      {
        tcp_output_batch_acks_end((uint64_t)v6);
        goto LABEL_92;
      }
      v15 = 0;
      v16 = 0;
      v17 = 0;
      do
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        do
        {
          v18 = v14[4];
          v19 = (_QWORD *)v14[5];
          if (v18)
          {
            *(_QWORD *)(v18 + 40) = v19;
            v19 = (_QWORD *)v14[5];
          }
          else
          {
            v66 = (os_log_type_t *)v14[5];
          }
          *v19 = v18;
          v20 = *(_QWORD **)&buf[8];
          v14[4] = 0;
          v14[5] = v20;
          *v20 = v14;
          *(_QWORD *)&buf[8] = v14 + 4;
          v14 = *(_QWORD **)type;
        }
        while (*(_QWORD *)type && (*(_WORD *)(*(_QWORD *)type + 204) & 0x40) != 0);
        v68 = 0;
        v67 = 0;
        tcp_input((uint64_t *)buf, v6[56], (uint64_t)v6, (_BYTE *)&v68 + 1, &v68, &v67);
        v16 |= (_BYTE)v68 != 0;
        v17 |= HIBYTE(v68) != 0;
        v15 |= v67;
        v14 = *(_QWORD **)type;
      }
      while (*(_QWORD *)type);
      tcp_output_batch_acks_end((uint64_t)v6);
      if ((v16 & 1) != 0)
      {
        v38 = *(_QWORD *)(v2 + 32);
        if (v38)
        {
          v39 = *(void (**)(uint64_t))(v38 + 48);
          if (v39)
            v39(v2);
        }
      }
      if ((v15 & 1) == 0)
        goto LABEL_91;
      if ((*(_DWORD *)(v2 + 552) && (v40 = v2 + 528, *(_QWORD *)(v2 + 520))
         || *v64 && (v40 = v2 + 512, *(_QWORD *)(v2 + 504)))
        && (v41 = **(_QWORD **)(*(_QWORD *)v40 + 8)) != 0)
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0)
        {
          v42 = __nwlog_tcp_log();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "tcp_input_carry_wake_packet";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v2 + 604;
            _os_log_impl(&dword_209FB3000, v42, OS_LOG_TYPE_INFO, "%{public}s %{public}s found data to carry wake packet", buf, 0x16u);
          }
        }
        *(_WORD *)(v41 + 204) |= 0x4000u;
        if ((v17 & 1) != 0)
          goto LABEL_10;
LABEL_92:
        v3 = v8;
        if ((v7 & 1) == 0)
        {
          v44 = nw_tcp_access_globals(v2);
          tcp_coalesce_timer_updates_end(v44);
          tcp_input_aggregate_end(v6[28], v6[30]);
        }
      }
      else
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0)
        {
          v43 = __nwlog_tcp_log();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "tcp_input_carry_wake_packet";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v2 + 604;
            _os_log_impl(&dword_209FB3000, v43, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s no data to carry wake packet", buf, 0x16u);
          }
        }
LABEL_91:
        if ((v17 & 1) == 0)
          goto LABEL_92;
LABEL_10:
        *(_BYTE *)(v2 + 828) |= 1u;
        v3 = v8;
      }
    }
  }
  if ((*(_BYTE *)(v1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v52 = __nwlog_tcp_log();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v2 + 604;
        v53 = "%{public}s %{public}s skipping";
        v54 = v52;
        v55 = OS_LOG_TYPE_DEBUG;
        v56 = 22;
        goto LABEL_111;
      }
    }
  }
}

void set_frame_service_class(uint64_t a1, uint64_t a2, int a3, char a4, int *a5)
{
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  void *v21;
  NSObject *v22;
  void *v23;
  uint64_t v24;

  v9 = *(_QWORD *)a2;
  if ((a3 + 1) >= 2)
  {
    v11 = 524432;
    if (a3 <= 499)
    {
      if (a3 > 299)
      {
        if (a3 == 300)
        {
          v10 = 1572880;
          goto LABEL_3;
        }
        if (a3 == 400)
        {
          v10 = 2097184;
          goto LABEL_3;
        }
      }
      else
      {
        if (a3 == 100)
          goto LABEL_11;
        if (a3 == 200)
        {
LABEL_9:
          v11 = 1048704;
          goto LABEL_11;
        }
      }
    }
    else if (a3 <= 699)
    {
      if (a3 == 500)
      {
        v10 = 2621728;
        goto LABEL_3;
      }
      if (a3 == 600)
      {
        v10 = 3146000;
        goto LABEL_3;
      }
    }
    else
    {
      switch(a3)
      {
        case 700:
          v10 = 3670272;
          goto LABEL_3;
        case 800:
          v10 = 4194688;
          goto LABEL_3;
        case 900:
          v10 = 4718992;
          goto LABEL_3;
      }
    }
    v24 = *(_QWORD *)a2;
    v22 = __nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    v23 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
      goto LABEL_55;
    free(v23);
    v10 = 0;
    v9 = v24;
    goto LABEL_3;
  }
  v10 = 0;
LABEL_3:
  if ((*(_BYTE *)(a2 + 369) & 0x20) != 0)
    goto LABEL_9;
  if (v10 && v10 != 2097184 && v10 != 1572880 || !*(_QWORD *)(v9 + 448))
  {
    v11 = v10;
    goto LABEL_11;
  }
  v11 = v10;
  if (so_throttle_best_effort(a2))
    goto LABEL_9;
LABEL_11:
  if ((*(_BYTE *)(a2 + 369) & 0x20) != 0 || (v12 = *(_DWORD *)(a2 + 600), v12 == 200) || v12 == 100)
  {
    *(_BYTE *)(a1 + 186) |= 0x10u;
    v12 = *(_DWORD *)(a2 + 600);
  }
  if ((v12 - 801) >= 0xFFFFFED3)
    *(_BYTE *)(a1 + 186) |= 0x20u;
  if ((a4 & 6) != 0)
    v13 = 4718992;
  else
    v13 = v11;
  if (v11 == 1048704)
    v14 = 1048704;
  else
    v14 = v13;
  if (v11 == 524432)
    v15 = 524432;
  else
    v15 = v14;
  set_tcp_stream_priority(a2);
  v16 = (unsigned __int16)v15 >> 7;
  if (v16 < 4)
    goto LABEL_27;
  v20 = __nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  v21 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort())
  {
LABEL_55:
    __break(1u);
    return;
  }
  free(v21);
LABEL_27:
  v17 = a2 + 32 * v16;
  ++*(_QWORD *)(v17 + 712);
  v18 = *(_DWORD *)(a1 + 52);
  if (v18)
    v19 = (v18 - (*(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60)));
  else
    v19 = 0;
  *(_QWORD *)(v17 + 720) += v19;
  *a5 = v15;
}

void set_tcp_stream_priority(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  unint64_t *v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  int v10;
  int v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  int v20;
  const char *v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(*(_QWORD *)a1 + 232) != 3)
  {
    v2 = *(_QWORD *)(*(_QWORD *)a1 + 240);
    v3 = *(unsigned __int8 *)(v2 + 264);
    v4 = *(_DWORD *)(a1 + 368);
    v5 = (unint64_t *)nw_tcp_access_globals(a1);
    v6 = *v5;
    if (so_throttle_best_effort(a1)
      || ((v10 = *(_DWORD *)(a1 + 368), (v10 & 0x2000) != 0) || (v11 = *(_DWORD *)(a1 + 600), v11 == 200) || v11 == 100)
      && ((v12 = *(_QWORD *)(v2 + 1064)) != 0 ? (v13 = v6 >= 3) : (v13 = 0), v13 && *(_QWORD *)(v12 + 8) > *v5 - 2)
      || *(_DWORD *)(a1 + 600) == 100)
    {
      if (v3 != 2)
        tcp_set_new_cc(a1, 2);
      v7 = *(_DWORD *)(a1 + 368);
      if ((v7 & 0x4000) == 0)
      {
        *(_DWORD *)(a1 + 368) = v7 | 0x4000;
        if (*(_DWORD *)(sysctls + 308) == 1)
        {
          v8 = *(_QWORD *)(*(_QWORD *)a1 + 240);
          if ((~*(_DWORD *)(v8 + 88) & 0x180) == 0 && off_253CF86B8 != 0)
            off_253CF86B8(v8);
        }
      }
    }
    else
    {
      if ((v10 & 0x4000) != 0)
        *(_DWORD *)(a1 + 368) = v10 & 0xFFFFBFFF;
      if (v3 == 2)
      {
        if (*(_DWORD *)(sysctls + 20))
        {
          v14 = a1;
          v15 = 1;
        }
        else if (*(_DWORD *)(sysctls + 304))
        {
          v14 = a1;
          v15 = 2;
        }
        else
        {
          v16 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 240) + 740);
          if ((v16 & 0x10000000) == 0 && ((v16 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 336) == 1 || tcp_do_l4s == 1))
          {
            v14 = a1;
            v15 = 4;
          }
          else
          {
            v14 = a1;
            v15 = 3;
          }
        }
        tcp_set_new_cc(v14, v15);
      }
    }
    v17 = v4 & 0x4000;
    if ((v3 != *(unsigned __int8 *)(v2 + 264) || v17 != (*(_DWORD *)(a1 + 368) & 0x4000))
      && (*(_BYTE *)(a1 + 828) & 2) == 0
      && __nwlog_is_datapath_logging_enabled())
    {
      v18 = __nwlog_tcp_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        v19 = tcp_cc_algo_list[*(unsigned __int8 *)(v2 + 264)];
        v20 = 136446978;
        v21 = "set_tcp_stream_priority";
        v22 = 2082;
        v23 = a1 + 604;
        v24 = 2082;
        v25 = v19;
        v26 = 1024;
        v27 = v17;
        _os_log_impl(&dword_209FB3000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s cc_algo %{public}s recvbg %d", (uint8_t *)&v20, 0x26u);
      }
    }
  }
}

BOOL so_throttle_best_effort(uint64_t a1)
{
  int v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  BOOL v7;
  _BOOL8 v8;
  NSObject *v9;
  const char *v10;
  int v12;
  const char *v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a1 + 600);
  if (v2 && v2 != 400 && v2 != 300)
    return 0;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 240);
  v4 = (unint64_t *)nw_tcp_access_globals(a1);
  v8 = *(_DWORD *)(sysctls + 340) == 1
    && ((v5 = *v4, (v6 = *(_QWORD *)(v3 + 1064)) != 0) ? (v7 = v5 >= 3) : (v7 = 0), v7)
    && *(_QWORD *)(v6 + 16) > v5 - 2;
  if (so_throttle_best_effort_old_result != v8 && (*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    v9 = __nwlog_tcp_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v10 = "off";
      v13 = "so_throttle_best_effort";
      v12 = 136446722;
      if (v8)
        v10 = "on";
      v14 = 2082;
      v15 = a1 + 604;
      v16 = 2080;
      v17 = v10;
      _os_log_impl(&dword_209FB3000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}s throttling is now %s", (uint8_t *)&v12, 0x20u);
    }
  }
  so_throttle_best_effort_old_result = v8;
  return v8;
}

void tcp_check_timer_state(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  char v17;
  unsigned int v18;
  void *v19;
  NSObject *v20;
  void *v21;
  NSObject *v22;
  BOOL v23;
  int v24;
  int v25;
  BOOL v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 8) + 32))();
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 80) + 2232) & 1) != 0)
    return;
  tcp_set_lotimer_index(a1);
  v2 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  v3 = a1 + 48;
  v4 = *(_QWORD *)(a1 + 80);
  if (*(_DWORD *)(v4 + 232) == 3)
  {
    if ((*(_BYTE *)(a1 + 91) & 0x40) == 0)
      return;
    goto LABEL_6;
  }
  if (*(_WORD *)(a1 + 72) == 8)
  {
LABEL_6:
    v5 = nw_tcp_access_globals(*(_QWORD *)(v4 + 224));
    (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 8) + 32))();
    v6 = *(_DWORD *)(a1 + 88);
    if ((v6 & 0x40000000) != 0)
    {
      v7 = *(_QWORD *)(v5 + 264);
      v8 = *(_QWORD *)v3;
      if (v7)
        v9 = v7 == v3;
      else
        v9 = 0;
      if (v9)
        *(_QWORD *)(v5 + 264) = v8;
      if (v8)
        *(_QWORD *)(v8 + 8) = *(_QWORD *)(a1 + 56);
      **(_QWORD **)(a1 + 56) = v8;
      *(_DWORD *)(a1 + 88) = v6 & 0xBFFFFFFF;
      --*(_DWORD *)(v5 + 280);
      *(_QWORD *)v3 = 0;
      *(_QWORD *)(a1 + 56) = 0;
    }
    return;
  }
  v10 = v2;
  v11 = *(unsigned __int16 *)(a1 + 74);
  v12 = *(_DWORD *)(a1 + 68);
  if (v12 - *(_DWORD *)(v2 + 316) <= 1)
    v13 = 1;
  else
    v13 = v12 - *(_DWORD *)(v2 + 316);
  v14 = *(_DWORD *)(a1 + 88);
  if ((v14 & 0x40000000) != 0)
  {
    v17 = *(_BYTE *)(v2 + 310);
  }
  else
  {
    v15 = *(_QWORD *)(v2 + 256);
    *(_QWORD *)v3 = v15;
    if (v15)
      *(_QWORD *)(v15 + 8) = v3;
    *(_QWORD *)(v2 + 256) = v3;
    *(_QWORD *)(a1 + 56) = v2 + 256;
    *(_DWORD *)(a1 + 88) = v14 | 0x40000000;
    v16 = *(_DWORD *)(v2 + 280) + 1;
    *(_DWORD *)(v2 + 280) = v16;
    if (v16 > *(_DWORD *)(v2 + 284))
      *(_DWORD *)(v2 + 284) = v16;
    v17 = *(_BYTE *)(v2 + 310);
    if ((v17 & 2) == 0)
      goto LABEL_52;
  }
  if ((v17 & 3) == 2)
  {
    v18 = *(_DWORD *)(v2 + 272) - v12;
    if ((int)v18 < 1)
      return;
    if ((v11 & 1) != 0)
    {
      if (v18 < 0xB)
        return;
    }
    else if ((v11 & 2) != 0)
    {
      if (v18 < 0x65)
        return;
    }
    else if (v18 < 0x1F5)
    {
      return;
    }
  }
  if (*(_QWORD *)v3 && *(_QWORD *)(*(_QWORD *)v3 + 8) != v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v28 = "tcp_sched_timers";
    v29 = 2048;
    v30 = a1 + 48;
    v19 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v20 = __nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v28 = "tcp_sched_timers";
        v29 = 2048;
        v30 = a1 + 48;
        _os_log_impl(&dword_209FB3000, v20, OS_LOG_TYPE_ERROR, "%{public}s Bad link elm %p next->prev != elm, backtrace limit exceeded", buf, 0x16u);
      }
    }
    if (v19)
      free(v19);
  }
  if (**(_QWORD **)(a1 + 56) != v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v28 = "tcp_sched_timers";
    v29 = 2048;
    v30 = a1 + 48;
    v21 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v22 = __nwlog_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v28 = "tcp_sched_timers";
        v29 = 2048;
        v30 = v3;
        _os_log_impl(&dword_209FB3000, v22, OS_LOG_TYPE_ERROR, "%{public}s Bad link elm %p prev->next != elm, backtrace limit exceeded", buf, 0x16u);
      }
    }
    if (v21)
      free(v21);
  }
  if ((*(_BYTE *)(v10 + 310) & 1) == 0)
  {
    if ((*(_BYTE *)(v10 + 310) & 2) != 0 && (int)(*(_DWORD *)(v10 + 272) - *(_DWORD *)(v10 + 316) - v13) < 1)
      return;
LABEL_52:
    if ((v11 & 1) != 0)
    {
      *(_DWORD *)(v10 + 292) = 1;
      *(_DWORD *)(v10 + 304) = 0;
      v23 = v13 >= 0xA;
      v24 = 10;
    }
    else
    {
      if ((v11 & 2) == 0)
      {
LABEL_67:
        tcp_sched_timerlist(v10, v13);
        return;
      }
      if (*(_DWORD *)(v10 + 292) >= 3u)
        *(_DWORD *)(v10 + 292) = 2;
      *(_DWORD *)(v10 + 304) = 0;
      v23 = v13 >= 0x64;
      v24 = 100;
    }
    if (v23)
      v13 = v24;
    goto LABEL_67;
  }
  *(_DWORD *)(v10 + 296) |= v11;
  v25 = *(_DWORD *)(v10 + 300);
  if (v25)
    v26 = (int)v13 < v25;
  else
    v26 = 1;
  if (v26)
    *(_DWORD *)(v10 + 300) = v13;
}

uint64_t nw_tcp_access_globals(uint64_t a1)
{
  uint64_t v1;
  void *v3;
  NSObject *v4;
  const char *v5;
  uint8_t buf[4];
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 40);
    if (v1)
      return *(_QWORD *)(v1 + 5240);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v7 = "nw_tcp_access_globals";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v7 = "nw_tcp_access_globals";
        v5 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_12;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v7 = "nw_tcp_access_globals";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v7 = "nw_tcp_access_globals";
        v5 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_12:
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_ERROR, v5, buf, 0xCu);
      }
    }
  }
  if (v3)
    free(v3);
  return 0;
}

uint64_t tcp_getlock(uint64_t a1)
{
  void *v3;
  int v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  NSObject *v9;
  int v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  _BYTE v18[14];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)a1)
  {
    if ((*(_DWORD *)(a1 + 360) & 0x80000000) == 0)
      return *(_QWORD *)a1 + 24;
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      v4 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      v12 = "tcp_getlock";
      v13 = 2082;
      v14 = a1 + 604;
      v15 = 2048;
      v16 = a1;
      v17 = 1024;
      *(_DWORD *)v18 = v4;
      *(_WORD *)&v18[4] = 2082;
      *(_QWORD *)&v18[6] = "";
      v3 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_fault())
        goto LABEL_15;
      v9 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        goto LABEL_15;
      v10 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      v12 = "tcp_getlock";
      v13 = 2082;
      v14 = a1 + 604;
      v15 = 2048;
      v16 = a1;
      v17 = 1024;
      *(_DWORD *)v18 = v10;
      *(_WORD *)&v18[4] = 2082;
      *(_QWORD *)&v18[6] = "";
      v6 = "%{public}s %{public}s tcp_getlock: so=%p usecount=%x lrh= %{public}s, backtrace limit exceeded";
      v7 = v9;
      v8 = 48;
LABEL_14:
      _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
LABEL_15:
      if (v3)
        free(v3);
    }
  }
  else if ((*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    *(_DWORD *)buf = 136446978;
    v12 = "tcp_getlock";
    v13 = 2082;
    v14 = a1 + 604;
    v15 = 2048;
    v16 = a1;
    v17 = 2082;
    *(_QWORD *)v18 = "";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_15;
    v5 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    *(_DWORD *)buf = 136446978;
    v12 = "tcp_getlock";
    v13 = 2082;
    v14 = a1 + 604;
    v15 = 2048;
    v16 = a1;
    v17 = 2082;
    *(_QWORD *)v18 = "";
    v6 = "%{public}s %{public}s tcp_getlock: so=%p NULL so_pcb %{public}s, backtrace limit exceeded";
    v7 = v5;
    v8 = 42;
    goto LABEL_14;
  }
  return 0;
}

void tcp_set_lotimer_index(uint64_t a1)
{
  int v2;
  int v3;
  int v4;
  unsigned int v5;
  _BOOL4 v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  __int16 v23;
  unsigned int v25;
  uint64_t v26;
  NSObject *v27;
  void *v28;

  v2 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 20);
  v4 = *(_DWORD *)(a1 + 24);
  v5 = *(_DWORD *)(a1 + 28);
  v6 = (v4 | v2) != 0;
  if (v3)
    v6 = 1;
  if (v3 - 1 >= (v2 - 1))
  {
    v7 = 8 * (v2 == 0);
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 20);
    v7 = 1;
  }
  if (v4 - 1 < (v2 - 1))
  {
    v2 = *(_DWORD *)(a1 + 24);
    v7 = 2;
  }
  v8 = v6 | 2;
  if (v2 - 1 >= v5)
    v9 = *(_DWORD *)(a1 + 28);
  else
    v9 = v2;
  if (v2 - 1 >= v5)
    v10 = 3;
  else
    v10 = v7;
  if (v5)
    v2 = v9;
  else
    v8 = v6;
  if (v5)
    v7 = v10;
  v11 = *(_DWORD *)(a1 + 32);
  v12 = *(_DWORD *)(a1 + 36);
  if (v2 - 1 >= v11)
    v13 = *(_DWORD *)(a1 + 32);
  else
    v13 = v2;
  if (v2 - 1 >= v11)
    v14 = 4;
  else
    v14 = v7;
  if (v11)
  {
    v2 = v13;
    v8 |= 2u;
    v7 = v14;
  }
  if (v2 - 1 >= v12)
    v15 = *(_DWORD *)(a1 + 36);
  else
    v15 = v2;
  if (v2 - 1 >= v12)
    v16 = 5;
  else
    v16 = v7;
  if (v12)
  {
    v2 = v15;
    v8 |= 4u;
    v17 = v16;
  }
  else
  {
    v17 = v7;
  }
  v19 = *(_DWORD *)(a1 + 40);
  v18 = *(_DWORD *)(a1 + 44);
  if (v2 - 1 >= v19)
    v20 = *(_DWORD *)(a1 + 40);
  else
    v20 = v2;
  if (v2 - 1 >= v19)
    v21 = 6;
  else
    v21 = v17;
  if (v19)
    v8 |= 4u;
  else
    v20 = v2;
  if (v19)
    v22 = v21;
  else
    v22 = v17;
  if (v18)
  {
    v23 = v8 | 4;
    if (v20 - 1 >= v18)
      v22 = 7;
    *(_WORD *)(a1 + 72) = v22;
    *(_WORD *)(a1 + 74) = v23;
    if (v22 == 8)
      return;
    goto LABEL_58;
  }
  *(_WORD *)(a1 + 72) = v22;
  *(_WORD *)(a1 + 74) = v8;
  if (v22 == 8 || v8 != 0)
  {
    if (v22 == 8)
      return;
    goto LABEL_58;
  }
  v27 = __nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  v28 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort())
  {
    __break(1u);
    return;
  }
  free(v28);
  v22 = *(unsigned __int16 *)(a1 + 72);
  if (v22 != 8)
  {
LABEL_58:
    v25 = *(_DWORD *)(a1 + 4 * v22 + 16) + *(_DWORD *)(a1 + 64);
    if (v25 != *(_DWORD *)(a1 + 68))
    {
      if (v25 <= 1)
        v25 = 1;
      *(_DWORD *)(a1 + 68) = v25;
      v26 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
      if (*(_DWORD *)(v26 + 288))
        *(_BYTE *)(v26 + 310) |= 4u;
    }
  }
}

_QWORD *tcp_input(uint64_t *a1, uint64_t a2, uint64_t a3, _BYTE *a4, _BYTE *a5, BOOL *a6)
{
  uint64_t v6;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  _BOOL4 v18;
  BOOL *v19;
  void *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  _QWORD *v30;
  int v31;
  int v32;
  uint64_t v33;
  _BOOL4 v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  BOOL *v43;
  uint64_t *v44;
  NSObject *v45;
  const char *v46;
  const char *v47;
  NSObject *v48;
  os_log_type_t v49;
  int v50;
  uint64_t v51;
  NSObject *v52;
  const char *v53;
  uint32_t v54;
  int v55;
  _QWORD *result;
  void (*v57)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  os_log_type_t v62;
  const char *v63;
  _BOOL4 v64;
  unint64_t v65;
  BOOL v66;
  uint64_t v67;
  NSObject *v68;
  const char *v69;
  uint64_t v70;
  char v71;
  uint64_t v72;
  int v73;
  const char *v74;
  char v75;
  int v76;
  int v77;
  NSObject *v78;
  NSObject *v79;
  int v80;
  _QWORD *v81;
  unsigned int v82;
  int v83;
  void *v84;
  NSObject *v85;
  NSObject *v86;
  os_log_type_t v87;
  const char *v88;
  NSObject *v89;
  void *v90;
  NSObject *v91;
  os_log_type_t v92;
  const char *v93;
  NSObject *v94;
  int v95;
  uint64_t v96;
  int v97;
  void *v98;
  NSObject *v99;
  os_log_type_t v100;
  int v101;
  const char *v102;
  const char *v103;
  void *v104;
  NSObject *v105;
  os_log_type_t v106;
  const char *v107;
  int v108;
  uint64_t v109;
  NSObject *v110;
  uint64_t v111;
  NSObject *v112;
  const char *v113;
  void *v114;
  NSObject *v115;
  os_log_type_t v116;
  const char *v117;
  NSObject *v118;
  const char *v119;
  unint64_t v120;
  unsigned int v121;
  uint64_t v122;
  uint64_t v123;
  unsigned __int8 *v124;
  int v125;
  uint64_t v126;
  uint64_t v127;
  NSObject *v128;
  const char *v129;
  unsigned __int8 *v130;
  uint64_t v131;
  int v132;
  unsigned int v133;
  uint64_t v134;
  uint64_t v135;
  unsigned int v136;
  char v137;
  uint64_t all_stats;
  uint64_t v139;
  int v140;
  int v141;
  void (*v142)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v143;
  uint64_t v144;
  uint64_t v145;
  NSObject *v146;
  os_log_type_t v147;
  const char *v148;
  _BOOL4 v149;
  uint64_t v150;
  int v151;
  _BOOL4 v152;
  int v153;
  unsigned int v154;
  int v155;
  int v156;
  int v157;
  void (*v158)(uint64_t, _QWORD);
  unsigned int v159;
  unsigned int v160;
  uint64_t v161;
  int v162;
  int v163;
  uint64_t v164;
  int v165;
  int v166;
  int v167;
  int v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  int v172;
  NSObject *v173;
  const char *v174;
  int v175;
  int v176;
  int v177;
  int v178;
  uint64_t v179;
  unsigned int v180;
  uint64_t v181;
  uint64_t v182;
  unsigned int v183;
  int v184;
  int v185;
  unsigned int v186;
  int v187;
  int v188;
  int v189;
  char v190;
  int v191;
  uint64_t v192;
  _QWORD *v193;
  int v194;
  uint64_t v195;
  _QWORD *v196;
  uint64_t v197;
  unsigned int v198;
  __int16 v199;
  int v200;
  void *v201;
  NSObject *v202;
  os_log_type_t v203;
  int v204;
  const char *v205;
  NSObject *v206;
  const char *v207;
  NSObject *v208;
  const char *v209;
  unsigned int v210;
  unsigned int v211;
  unsigned int v212;
  NSObject *v213;
  os_log_type_t v214;
  NSObject *v215;
  const char *v216;
  unsigned int v217;
  unsigned int v218;
  unsigned int v219;
  unsigned int v220;
  int64x2_t v221;
  int v222;
  unsigned int v223;
  uint64_t v224;
  NSObject *v225;
  const char *v226;
  int v227;
  unsigned int v228;
  int v229;
  uint64_t v230;
  int v231;
  uint64_t v232;
  int v233;
  int v234;
  uint64_t v235;
  int v236;
  int v237;
  uint64_t v238;
  int v239;
  int v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  int v244;
  int v245;
  uint64_t v246;
  int v247;
  uint64_t v248;
  int64x2_t *v249;
  uint64_t v250;
  int v251;
  __int32 v252;
  unsigned int v253;
  int v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  __int16 v258;
  NSObject *v259;
  char *v260;
  const char *v261;
  NSObject *v262;
  os_log_type_t v263;
  unint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  _QWORD *v268;
  int v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  int v273;
  int v274;
  uint64_t v275;
  int v276;
  uint64_t v277;
  void (*v278)(uint64_t);
  uint64_t v279;
  uint64_t v280;
  _QWORD *v281;
  uint64_t v282;
  int v283;
  uint64_t v284;
  int v285;
  _QWORD *v286;
  uint64_t v287;
  int v288;
  _BOOL4 v289;
  int v290;
  int v291;
  int v292;
  int v293;
  _QWORD *v294;
  uint64_t v295;
  uint64_t v296;
  int v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t *v300;
  unsigned int v301;
  int v302;
  int v303;
  void *v304;
  NSObject *v305;
  os_log_type_t v306;
  int v307;
  const char *v308;
  uint64_t v309;
  int v310;
  int v311;
  uint64_t v312;
  int v313;
  unsigned int v314;
  int v315;
  int v316;
  int v319;
  uint64_t v320;
  int64x2_t v321;
  int v322;
  uint64_t v323;
  uint64_t v324;
  int v325;
  int v326;
  char v327;
  uint64_t v328;
  int v329;
  unsigned int v330;
  unsigned int v331;
  unsigned int v332;
  int v333;
  uint64_t v334;
  uint64_t v335;
  int v336;
  int v337;
  unsigned int v338;
  uint64_t v339;
  int v340;
  char v341;
  uint64_t (*v342)(uint64_t, __int128 *);
  int v343;
  int v344;
  uint64_t v345;
  uint64_t v346;
  int v347;
  int v348;
  uint64_t v349;
  uint64_t v350;
  __int16 v351;
  NSObject *v352;
  char *v353;
  const char *v354;
  NSObject *v355;
  char *v356;
  const char *v357;
  uint64_t v358;
  void *v359;
  _BOOL4 v360;
  int v361;
  int v362;
  int v363;
  int v364;
  uint64_t v365;
  uint64_t v366;
  int v367;
  BOOL v368;
  _QWORD *v370;
  uint64_t v371;
  uint64_t v372;
  char v373;
  int v374;
  int v375;
  unsigned int v376;
  _QWORD *v377;
  unsigned int v378;
  uint64_t *v379;
  int v380;
  int v381;
  uint64_t v382;
  void *v383;
  NSObject *v384;
  os_log_type_t v385;
  int v386;
  const char *v387;
  void *v388;
  _BOOL4 v389;
  int v390;
  int v391;
  NSObject *v392;
  unsigned int v393;
  uint64_t v394;
  int v395;
  unsigned int v396;
  int v397;
  unsigned int v398;
  unsigned int v399;
  int v400;
  NSObject *v401;
  _BOOL4 v402;
  int v403;
  NSObject *v405;
  _BOOL4 v406;
  uint64_t v407;
  uint64_t v408;
  _BOOL4 v409;
  int v410;
  int v411;
  uint64_t v412;
  int v413;
  int v414;
  uint64_t v415;
  uint64_t v416;
  int v417;
  uint64_t v418;
  int v419;
  unsigned int v420;
  int v421;
  const char *v422;
  int v423;
  int v424;
  int v425;
  void *v426;
  NSObject *v427;
  os_log_type_t v428;
  int v429;
  int v430;
  int v431;
  const char *v432;
  void *v433;
  _BOOL4 v434;
  int v435;
  int v436;
  int v437;
  int v438;
  int v439;
  int v440;
  void (*v441)(uint64_t, __int128 *);
  int v442;
  uint64_t v443;
  int v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  int v449;
  int v450;
  int v451;
  int v452;
  int v453;
  int v454;
  uint64_t v455;
  int v456;
  unsigned int v457;
  void (**v458)(uint64_t);
  void (*v459)(uint64_t);
  int v460;
  uint64_t v461;
  uint64_t v462;
  int v463;
  uint64_t v464;
  char v465;
  int v466;
  uint64_t v467;
  void (*v468)(uint64_t);
  int v469;
  uint64_t v470;
  char v471;
  char v472;
  uint64_t *v473;
  int v474;
  unsigned __int16 v475;
  int v476;
  int v477;
  int v478;
  int v479;
  int v480;
  int v481;
  unsigned int v482;
  unsigned int v483;
  int v484;
  BOOL v485;
  char v486;
  int v487;
  int v488;
  int v489;
  uint64_t v490;
  unsigned int v491;
  int v492;
  void *v493;
  NSObject *v494;
  os_log_type_t v495;
  int v496;
  const char *v497;
  int v498;
  uint64_t v499;
  int v500;
  unsigned int v501;
  uint64_t v502;
  int v503;
  unsigned int v504;
  unsigned int v505;
  int v506;
  BOOL v507;
  int v509;
  NSObject *v510;
  uint64_t v511;
  unsigned int v512;
  uint64_t v513;
  int v514;
  unsigned int v515;
  int v516;
  unsigned int v517;
  unsigned int v518;
  int v519;
  NSObject *v520;
  _BOOL4 v521;
  int v522;
  NSObject *v524;
  _BOOL4 v525;
  int v526;
  int v527;
  int v528;
  uint64_t v529;
  uint64_t v530;
  void (*v531)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v532;
  uint64_t v533;
  uint64_t v534;
  NSObject *v535;
  os_log_type_t v536;
  const char *v537;
  _BOOL4 v538;
  char v539;
  int is_ack_ratelimited;
  uint64_t v541;
  char v542;
  int v543;
  uint64_t v544;
  uint64_t v545;
  int v546;
  int v547;
  uint64_t v548;
  int v549;
  char v550;
  int v551;
  int v552;
  int v553;
  int v554;
  int v555;
  uint64_t v556;
  int v557;
  int v558;
  unsigned int v559;
  void (*v560)(uint64_t, __int128 *);
  unsigned int v561;
  int v562;
  uint64_t v563;
  uint64_t v564;
  int v565;
  int v566;
  uint64_t v567;
  int v568;
  int v569;
  int v570;
  uint64_t v571;
  uint64_t v572;
  int v573;
  void *v574;
  NSObject *v575;
  os_log_type_t v576;
  const char *v577;
  void *v578;
  NSObject *v579;
  _BOOL4 v580;
  int v581;
  BOOL v582;
  unsigned int v584;
  unsigned int v585;
  BOOL v586;
  int v587;
  int v588;
  int v589;
  int v590;
  NSObject *v591;
  const char *v592;
  int v593;
  unsigned int v594;
  int v595;
  int v596;
  NSObject *v597;
  os_log_type_t v598;
  uint64_t v599;
  unsigned int v600;
  int v601;
  int v602;
  int v603;
  unsigned int v604;
  unsigned int v605;
  int v606;
  NSObject *v607;
  int v608;
  NSObject *v609;
  unsigned int (*v610)(uint64_t, __int128 *);
  int v611;
  int v612;
  uint64_t v613;
  uint64_t v614;
  char v615;
  _QWORD *v616;
  unsigned int v617;
  char v618;
  void (*v619)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v620;
  uint64_t v621;
  uint64_t v622;
  NSObject *v623;
  os_log_type_t v624;
  const char *v625;
  _BOOL4 v626;
  int v627;
  uint64_t v628;
  void (*v629)(uint64_t);
  uint64_t v630;
  uint64_t v631;
  uint64_t v632;
  uint64_t v633;
  uint64_t v634;
  uint64_t v635;
  int v636;
  uint64_t v637;
  void (*v638)(uint64_t);
  int v639;
  uint64_t v640;
  uint64_t v641;
  NSObject *v642;
  const char *v643;
  int v644;
  NSObject *v645;
  char *v646;
  const char *v647;
  int v648;
  int v649;
  BOOL v650;
  _BOOL4 v651;
  int v652;
  uint64_t v653;
  void *v654;
  NSObject *v655;
  _BOOL4 v656;
  int v657;
  uint64_t *v658;
  void *v659;
  NSObject *v660;
  os_log_type_t v661;
  const char *v662;
  NSObject *v663;
  const char *v664;
  uint64_t v665;
  void (*v666)(unint64_t);
  uint64_t v667;
  int v668;
  BOOL v670;
  int v671;
  void *v672;
  _BOOL4 v673;
  int v674;
  int v675;
  char v676;
  unsigned int v677;
  int v678;
  uint64_t v679;
  int v680;
  NSObject *v681;
  uint64_t v682;
  unsigned int v683;
  int v684;
  int v685;
  int v686;
  unsigned int v687;
  unsigned int v688;
  int v689;
  NSObject *v690;
  int v691;
  NSObject *v692;
  int v693;
  unsigned int v694;
  unsigned int (*v695)(uint64_t, __int128 *);
  int v696;
  void (*v697)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v698;
  uint64_t v699;
  uint64_t v700;
  NSObject *v701;
  os_log_type_t v702;
  const char *v703;
  _BOOL4 v704;
  void *v705;
  NSObject *v706;
  os_log_type_t v707;
  const char *v708;
  uint64_t v709;
  int v710;
  void *v711;
  NSObject *v712;
  _BOOL4 v713;
  NSObject *v714;
  char *v715;
  const char *v716;
  void *v717;
  NSObject *v718;
  _BOOL4 v719;
  NSObject *v720;
  os_log_type_t v721;
  NSObject *v722;
  char *v723;
  const char *v724;
  NSObject *v725;
  const char *v726;
  NSObject *v727;
  char *v728;
  const char *v729;
  NSObject *v730;
  char *v731;
  const char *v732;
  NSObject *v733;
  os_log_type_t v734;
  unsigned int v735;
  unsigned int v736;
  _BOOL4 v737;
  void (*v738)(uint64_t, __int128 *);
  int v739;
  int v740;
  int v741;
  unsigned int v742;
  void (**v743)(uint64_t);
  void (*v744)(uint64_t);
  void (*v745)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v746;
  uint64_t v747;
  uint64_t v748;
  NSObject *v749;
  os_log_type_t v750;
  const char *v751;
  _BOOL4 v752;
  NSObject *v753;
  os_log_type_t v754;
  NSObject *v755;
  char *v756;
  const char *v757;
  NSObject *v758;
  char *v759;
  const char *v760;
  NSObject *v761;
  char *v762;
  const char *v763;
  NSObject *v764;
  char *v765;
  const char *v766;
  NSObject *v767;
  char *v768;
  const char *v769;
  void *v770;
  NSObject *v771;
  os_log_type_t v772;
  const char *v773;
  NSObject *v774;
  const char *v775;
  NSObject *v776;
  void *v777;
  void *v778;
  NSObject *v779;
  _BOOL4 v780;
  NSObject *v781;
  void *v782;
  NSObject *v783;
  char *v784;
  const char *v785;
  NSObject *v786;
  char *v787;
  const char *v788;
  NSObject *v789;
  os_log_type_t v790;
  void *v791;
  NSObject *v792;
  os_log_type_t v793;
  const char *v794;
  NSObject *v795;
  const char *v796;
  NSObject *v797;
  void *v798;
  void *v799;
  NSObject *v800;
  _BOOL4 v801;
  NSObject *v802;
  const char *v803;
  NSObject *v804;
  os_log_type_t v805;
  NSObject *v806;
  const char *v807;
  uint64_t v808;
  NSObject *v809;
  const char *v810;
  NSObject *v811;
  const char *v812;
  NSObject *v813;
  NSObject *v814;
  uint64_t v815;
  uint64_t v816;
  _BOOL4 v817;
  _BOOL4 v818;
  int v819;
  int v820;
  unsigned int v821;
  unsigned int v822;
  int v823;
  int v824;
  unsigned int v825;
  int v826;
  _BYTE *v827;
  _BYTE *v828;
  uint64_t v829;
  uint64_t v830;
  int v831;
  int v832;
  int v833;
  int v834;
  int v835;
  int v836;
  uint64_t v837;
  uint64_t v838;
  uint64_t v839;
  unsigned int v840;
  int v841;
  NSObject *v842;
  int v843;
  const char *v844;
  int v845;
  unsigned int v846;
  int v847;
  unint64_t v848;
  int v849;
  _BYTE *v850;
  os_log_type_t v851;
  os_log_type_t v852;
  unsigned int log;
  os_log_type_t loga;
  NSObject *logb;
  os_log_type_t logc;
  NSObject *logd;
  NSObject *loge;
  os_log_type_t logf;
  NSObject *logg;
  os_log_type_t logh;
  NSObject *logi;
  NSObject *logj;
  NSObject *v864;
  void *v865;
  NSObject *v866;
  NSObject *v867;
  void *v868;
  NSObject *v869;
  NSObject *v870;
  void *v871;
  NSObject *v872;
  NSObject *v873;
  void *v874;
  NSObject *v875;
  NSObject *v876;
  void *v877;
  NSObject *v878;
  NSObject *v879;
  void *backtrace_string;
  NSObject *v881;
  void *v882;
  unsigned int v883;
  void *v884;
  int v885;
  unsigned int v886;
  char updated;
  void *v888;
  void *v889;
  void *v890;
  void *v891;
  BOOL *v892;
  os_log_type_t type[4];
  int v895;
  _OWORD v896[3];
  uint64_t v897;
  uint64_t v898;
  int v899;
  char v900;
  uint8_t buf[4];
  const char *v902;
  __int16 v903;
  _BYTE v904[10];
  _BYTE v905[10];
  __int16 v906;
  _BYTE v907[10];
  __int16 v908;
  unsigned int v909;
  __int16 v910;
  unsigned int v911;
  __int16 v912;
  unsigned int v913;
  __int16 v914;
  int v915;
  __int16 v916;
  int v917;
  __int16 v918;
  int v919;
  __int16 v920;
  void *v921;
  __int128 v922;
  unsigned __int16 v923;
  int v924;
  int8x8_t v925;
  char v926;
  uint64_t v927;

  v927 = *MEMORY[0x24BDAC8D0];
  v12 = nw_frame_array_first();
  v13 = v12;
  v899 = 0;
  v14 = *(_QWORD *)(a3 + 240);
  v15 = *(_QWORD *)(a3 + 224);
  v898 = 0;
  v897 = 0;
  memset(v896, 0, sizeof(v896));
  if (!v12)
  {
    v827 = a5;
    v838 = v14;
    v19 = a6;
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v902 = "__nw_frame_get_ecn_flag";
    v20 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(v922) = 16;
    LOBYTE(v895) = 0;
    if (!__nwlog_fault())
      goto LABEL_20;
    if (v922 == 17)
    {
      v21 = __nwlog_obj();
      v22 = v922;
      if (!os_log_type_enabled(v21, (os_log_type_t)v922))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v902 = "__nw_frame_get_ecn_flag";
      v23 = "%{public}s called with null frame";
    }
    else
    {
      v21 = __nwlog_obj();
      v22 = v922;
      if (!os_log_type_enabled(v21, (os_log_type_t)v922))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v902 = "__nw_frame_get_ecn_flag";
      v23 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v21, v22, v23, buf, 0xCu);
LABEL_20:
    if (v20)
      free(v20);
    log = 0;
    v14 = v838;
    a5 = v827;
    v892 = v19;
    if (a2)
      goto LABEL_3;
LABEL_23:
    v17 = 0;
    v16 = 0;
    v18 = 0;
    goto LABEL_24;
  }
  log = *(_BYTE *)(v12 + 186) & 3;
  v892 = a6;
  if (!a2)
    goto LABEL_23;
LABEL_3:
  if (*(unsigned __int8 *)(a2 + 1076) == 255 || *(_DWORD *)(a2 + 1024) == 255)
  {
    v16 = 1;
    goto LABEL_6;
  }
  if (*(_DWORD *)(a2 + 1068) == 3)
  {
    v16 = 0;
    v18 = 0;
    v17 = 1;
  }
  else
  {
    v16 = 0;
    if (*(_DWORD *)(a2 + 1032) != 3)
    {
LABEL_6:
      v17 = 0;
      v18 = *(_DWORD *)(a2 + 1064) == 2 || *(_DWORD *)(a2 + 1028) == 2;
      goto LABEL_24;
    }
    v17 = 1;
    v18 = 0;
  }
LABEL_24:
  v895 = 0;
  if (a5)
    *a5 = 0;
  v24 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v14 + 80) + 224));
  v25 = v24;
  v26 = (unsigned int *)(a3 + 456);
  while (1)
  {
    v27 = *v26;
    if ((unsigned __int16)*v26 == 0xFFFF)
      break;
    while (1)
    {
      v28 = __ldxr(v26);
      if (v28 != v27)
        break;
      if (!__stxr(v27 + 1, v26))
        goto LABEL_32;
    }
    __clrex();
  }
LABEL_32:
  if (!v13 || !v14)
    goto LABEL_45;
  v850 = a4;
  v29 = *(_QWORD *)(v13 + 112);
  v30 = (_QWORD *)MEMORY[0x24BDE08C0];
  if (!v29)
  {
LABEL_41:
    if ((*(_WORD *)(v13 + 204) & 0x100) != 0
      && *v30
      && (((uint64_t (*)(uint64_t, _QWORD))*v30)(v13, *(_QWORD *)(v13 + 88)) & 1) == 0)
    {
      *(_QWORD *)(v14 + 1056) = 0;
    }
LABEL_45:
    v42 = *(_QWORD *)(v14 + 1056);
    if (v42)
    {
      ++*(_QWORD *)(v42 + 152);
      ++*(_QWORD *)(v42 + 232);
    }
    in_pcb_checkstate(a3, 2, 1);
    v43 = v892;
    v44 = a1;
    if (v15 && (*(_BYTE *)(v15 + 828) & 2) != 0)
      goto LABEL_65;
    v45 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
      goto LABEL_65;
    v46 = "";
    if (v15)
      v46 = (const char *)(v15 + 604);
    *(_DWORD *)buf = 136446466;
    v902 = "tcp_input";
    v903 = 2082;
    *(_QWORD *)v904 = v46;
    v47 = "%{public}s %{public}s failed to get tcp header";
    v48 = v45;
    v49 = OS_LOG_TYPE_INFO;
LABEL_63:
    v54 = 22;
LABEL_64:
    _os_log_impl(&dword_209FB3000, v48, v49, v47, buf, v54);
LABEL_65:
    v55 = 0;
    goto LABEL_66;
  }
  if ((*(_WORD *)(v13 + 204) & 0x100) != 0 && *MEMORY[0x24BDE08C0])
  {
    v31 = v17;
    v32 = v16;
    v33 = a3;
    v34 = v18;
    v35 = v15;
    v36 = v24;
    v37 = ((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v13, *(_QWORD *)(v13 + 88));
    v25 = v36;
    v15 = v35;
    v18 = v34;
    a3 = v33;
    v16 = v32;
    v17 = v31;
    v30 = (_QWORD *)MEMORY[0x24BDE08C0];
    if (v37)
    {
      v38 = *(_QWORD *)(v13 + 112);
      if (v38)
      {
        v39 = *(unsigned int *)(v13 + 56);
        v40 = v38 + v39;
        v41 = *(_DWORD *)(v13 + 52);
        if (!v41)
          goto LABEL_55;
        goto LABEL_54;
      }
    }
    goto LABEL_41;
  }
  v39 = *(unsigned int *)(v13 + 56);
  v40 = v29 + v39;
  v41 = *(_DWORD *)(v13 + 52);
  if (!v41)
  {
LABEL_55:
    v51 = *(_QWORD *)(v14 + 1056);
    if (v51)
    {
      ++*(_QWORD *)(v51 + 152);
      ++*(_QWORD *)(v51 + 368);
    }
    in_pcb_checkstate(a3, 2, 1);
    v43 = v892;
    v44 = a1;
    if (v15 && (*(_BYTE *)(v15 + 828) & 2) != 0)
      goto LABEL_65;
    v52 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      goto LABEL_65;
    v53 = "";
    if (v15)
      v53 = (const char *)(v15 + 604);
    *(_DWORD *)buf = 136446466;
    v902 = "tcp_input";
    v903 = 2082;
    *(_QWORD *)v904 = v53;
    v47 = "%{public}s %{public}s buffer smaller than tcp header";
    v48 = v52;
    v49 = OS_LOG_TYPE_ERROR;
    goto LABEL_63;
  }
LABEL_54:
  v50 = v41 - (v39 + *(_DWORD *)(v13 + 60));
  if (v50 <= 19)
    goto LABEL_55;
  v65 = ((unint64_t)*(unsigned __int8 *)(v40 + 12) >> 2) & 0x3C;
  v66 = v65 >= 0x14 && v50 >= v65;
  v848 = ((unint64_t)*(unsigned __int8 *)(v40 + 12) >> 2) & 0x3C;
  if (!v66)
  {
    v67 = *(_QWORD *)(v14 + 1056);
    if (v67)
    {
      ++*(_QWORD *)(v67 + 152);
      ++*(_QWORD *)(v67 + 360);
    }
    in_pcb_checkstate(a3, 2, 1);
    v43 = v892;
    v44 = a1;
    if (v15 && (*(_BYTE *)(v15 + 828) & 2) != 0)
      goto LABEL_65;
    v68 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      goto LABEL_65;
    v69 = (const char *)(v15 + 604);
    v902 = "tcp_input";
    *(_DWORD *)buf = 136446722;
    if (!v15)
      v69 = "";
    v903 = 2082;
    *(_QWORD *)v904 = v69;
    *(_WORD *)&v904[8] = 1024;
    *(_DWORD *)v905 = v848;
    v47 = "%{public}s %{public}s offset does not make any sense: %u";
    v48 = v68;
    v49 = OS_LOG_TYPE_ERROR;
    v54 = 28;
    goto LABEL_64;
  }
  v831 = v65 - 20;
  v826 = v17;
  v837 = v25;
  v830 = v40;
  __memcpy_chk();
  if ((*(_WORD *)(v13 + 204) & 0x100) != 0
    && *v30
    && (((uint64_t (*)(uint64_t, _QWORD))*v30)(v13, *(_QWORD *)(v13 + 88)) & 1) == 0)
  {
    v44 = a1;
    v111 = *(_QWORD *)(v14 + 1056);
    if (v111)
      ++*(_QWORD *)(v111 + 152);
    in_pcb_checkstate(a3, 2, 1);
    if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
    {
      v112 = __nwlog_tcp_log();
      if (os_log_type_enabled(v112, OS_LOG_TYPE_INFO))
      {
        v113 = "";
        if (v15)
          v113 = (const char *)(v15 + 604);
        *(_DWORD *)buf = 136446466;
        v902 = "tcp_input";
        v903 = 2082;
        *(_QWORD *)v904 = v113;
        _os_log_impl(&dword_209FB3000, v112, OS_LOG_TYPE_INFO, "%{public}s %{public}s buffer no longer valid", buf, 0x16u);
      }
    }
    v55 = 0;
    *(_QWORD *)(v14 + 1056) = 0;
    v43 = v892;
    goto LABEL_66;
  }
  v70 = *a1;
  v839 = v14;
  v828 = a5;
  v829 = a2;
  if (!*a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v902 = "__nw_frame_is_single_ip_aggregate";
    v114 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v900 = 0;
    if (!__nwlog_fault())
      goto LABEL_225;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v115 = __nwlog_obj();
      v116 = type[0];
      if (!os_log_type_enabled(v115, type[0]))
        goto LABEL_225;
      *(_DWORD *)buf = 136446210;
      v902 = "__nw_frame_is_single_ip_aggregate";
      v117 = "%{public}s called with null frame";
    }
    else
    {
      v115 = __nwlog_obj();
      v116 = type[0];
      if (!os_log_type_enabled(v115, type[0]))
        goto LABEL_225;
      *(_DWORD *)buf = 136446210;
      v902 = "__nw_frame_is_single_ip_aggregate";
      v117 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v115, v116, v117, buf, 0xCu);
LABEL_225:
    if (v114)
      free(v114);
    v849 = 0;
    v73 = 0;
    v72 = 0;
LABEL_228:
    if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v206 = __nwlog_tcp_log();
        if (os_log_type_enabled(v206, OS_LOG_TYPE_DEBUG))
        {
          v902 = "tcp_compute_segment_length";
          v903 = 2082;
          v207 = "";
          *(_DWORD *)buf = 136447234;
          if (v15)
            v207 = (const char *)(v15 + 604);
          *(_QWORD *)v904 = v207;
          *(_WORD *)&v904[8] = 1024;
          *(_DWORD *)v905 = v848;
          *(_WORD *)&v905[4] = 1024;
          *(_DWORD *)&v905[6] = v72;
          v906 = 1024;
          *(_DWORD *)v907 = v73;
          _os_log_impl(&dword_209FB3000, v206, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s TCP hlen %d segment length %d on %d buffers", buf, 0x28u);
        }
      }
    }
    v899 = v72;
    goto LABEL_232;
  }
  v71 = *(_WORD *)(v70 + 204);
  if ((*(_WORD *)(v70 + 204) & 0x80) != 0)
  {
    v72 = *(unsigned __int16 *)(v70 + 196);
    v899 = *(unsigned __int16 *)(v70 + 196);
    if ((v71 & 0x40) == 0)
    {
      v73 = *(unsigned __int8 *)(v70 + 200);
      if (*(_BYTE *)(v70 + 200))
      {
LABEL_183:
        if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
        {
          v43 = v892;
          if (!__nwlog_is_datapath_logging_enabled())
          {
            v849 = 0;
            goto LABEL_233;
          }
          v118 = __nwlog_tcp_log();
          if (os_log_type_enabled(v118, OS_LOG_TYPE_DEBUG))
          {
            v902 = "tcp_compute_segment_length";
            v903 = 2082;
            v119 = "";
            *(_DWORD *)buf = 136447234;
            if (v15)
              v119 = (const char *)(v15 + 604);
            *(_QWORD *)v904 = v119;
            *(_WORD *)&v904[8] = 1024;
            *(_DWORD *)v905 = v848;
            *(_WORD *)&v905[4] = 1024;
            *(_DWORD *)&v905[6] = v72;
            v906 = 1024;
            *(_DWORD *)v907 = v73;
            _os_log_impl(&dword_209FB3000, v118, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s TCP hlen %d segment length %d on %d buffers", buf, 0x28u);
          }
        }
        v849 = 0;
LABEL_232:
        v43 = v892;
LABEL_233:
        v120 = 0x253CF8000uLL;
        if (*(_DWORD *)(sysctls + 288))
          v121 = v73;
        else
          v121 = 1;
        v122 = v839;
        v123 = *(_QWORD *)(v839 + 1056);
        if (v123)
          *(_QWORD *)(v123 + 152) += v121;
        if (v15 && (*(_BYTE *)(v15 + 828) & 2) != 0)
        {
          if ((tcp_validate_cksum(v13, v72, v839) & 1) != 0)
            goto LABEL_242;
        }
        else
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            v173 = __nwlog_tcp_log();
            if (os_log_type_enabled(v173, OS_LOG_TYPE_DEBUG))
            {
              v174 = (const char *)(v15 + 604);
              if (!v15)
                v174 = "";
              v175 = *(_DWORD *)(v839 + 12);
              v176 = *(_DWORD *)(v839 + 120);
              v177 = *(_DWORD *)(v839 + 92);
              *(_DWORD *)buf = 136449026;
              v902 = "tcp_input";
              v903 = 2082;
              *(_QWORD *)v904 = v174;
              *(_WORD *)&v904[8] = 1024;
              *(_DWORD *)v905 = bswap32((unsigned __int16)v922) >> 16;
              *(_WORD *)&v905[4] = 1024;
              *(_DWORD *)&v905[6] = bswap32(WORD1(v922)) >> 16;
              v906 = 1024;
              *(_DWORD *)v907 = v72;
              *(_WORD *)&v907[4] = 1024;
              *(_DWORD *)&v907[6] = BYTE13(v922);
              v908 = 1024;
              v909 = bswap32(DWORD1(v922));
              v910 = 1024;
              v911 = bswap32(DWORD2(v922));
              v912 = 1024;
              v913 = bswap32(HIWORD(v922)) >> 16;
              v914 = 1024;
              v915 = v175;
              v916 = 1024;
              v917 = v176;
              v918 = 1024;
              v919 = v177;
              _os_log_impl(&dword_209FB3000, v173, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s processing an input-frame, %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u", buf, 0x52u);
              LODWORD(v72) = v899;
            }
            v43 = v892;
          }
          if ((validate_tcp_cksum() & 1) != 0)
          {
LABEL_242:
            v845 = v72 - v848;
            v899 = v72 - v848;
            if (v848 < 0x15)
            {
              v125 = 0;
              v124 = 0;
              v126 = v837;
            }
            else
            {
              v124 = (unsigned __int8 *)&v924;
              v125 = v831;
              v126 = v837;
              if ((v831 == 12 || v848 >= 0x21 && !v926) && v924 == 168296705 && (BYTE13(v922) & 2) == 0)
              {
                v125 = 0;
                v124 = 0;
                LODWORD(v896[0]) |= 1u;
                *(int8x8_t *)((char *)v896 + 4) = vrev32_s8(v925);
              }
            }
            v883 = BYTE13(v922);
            if ((~BYTE13(v922) & 3) == 0)
              goto LABEL_262;
            v130 = v124;
            v832 = v125;
            calculate_tcp_clock(v126);
            if (v829)
              v840 = *(unsigned __int16 *)(v829 + 1072);
            else
              v840 = 0;
            v825 = v121;
            if ((BYTE13(v922) & 0x24) != 0)
            {
              if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
              {
                v208 = __nwlog_tcp_log();
                if (os_log_type_enabled(v208, OS_LOG_TYPE_ERROR))
                {
                  v209 = (const char *)(v15 + 604);
                  if (!v15)
                    v209 = "";
                  v210 = *(_DWORD *)(v839 + 12);
                  v211 = *(_DWORD *)(v839 + 120);
                  v212 = *(_DWORD *)(v839 + 92);
                  *(_DWORD *)buf = 136448258;
                  v902 = "tcp_input";
                  v903 = 2082;
                  *(_QWORD *)v904 = v209;
                  *(_WORD *)&v904[8] = 1024;
                  *(_DWORD *)v905 = BYTE13(v922);
                  *(_WORD *)&v905[4] = 1024;
                  *(_DWORD *)&v905[6] = bswap32(DWORD1(v922));
                  v906 = 1024;
                  *(_DWORD *)v907 = bswap32(DWORD2(v922));
                  *(_WORD *)&v907[4] = 1024;
                  *(_DWORD *)&v907[6] = bswap32(HIWORD(v922)) >> 16;
                  v908 = 1024;
                  v909 = v210;
                  v910 = 1024;
                  v911 = v211;
                  v912 = 1024;
                  v913 = v212;
                  v213 = v208;
                  v214 = OS_LOG_TYPE_ERROR;
                  goto LABEL_549;
                }
              }
            }
            else if ((BYTE13(v922) & 3) != 0 && (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0))
            {
              v215 = __nwlog_tcp_log();
              if (os_log_type_enabled(v215, OS_LOG_TYPE_DEFAULT))
              {
                v216 = (const char *)(v15 + 604);
                if (!v15)
                  v216 = "";
                v217 = *(_DWORD *)(v839 + 12);
                v218 = *(_DWORD *)(v839 + 120);
                v219 = *(_DWORD *)(v839 + 92);
                *(_DWORD *)buf = 136448258;
                v902 = "tcp_input";
                v903 = 2082;
                *(_QWORD *)v904 = v216;
                *(_WORD *)&v904[8] = 1024;
                *(_DWORD *)v905 = BYTE13(v922);
                *(_WORD *)&v905[4] = 1024;
                *(_DWORD *)&v905[6] = bswap32(DWORD1(v922));
                v906 = 1024;
                *(_DWORD *)v907 = bswap32(DWORD2(v922));
                *(_WORD *)&v907[4] = 1024;
                *(_DWORD *)&v907[6] = bswap32(HIWORD(v922)) >> 16;
                v908 = 1024;
                v909 = v217;
                v910 = 1024;
                v911 = v218;
                v912 = 1024;
                v913 = v219;
                v213 = v215;
                v214 = OS_LOG_TYPE_DEFAULT;
LABEL_549:
                _os_log_impl(&dword_209FB3000, v213, v214, "%{public}s %{public}s flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u", buf, 0x40u);
              }
            }
            tcp_log_packet(v839);
            if ((*(_WORD *)(v13 + 204) & 0x100) != 0
              && *MEMORY[0x24BDE08C0]
              && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v13, *(_QWORD *)(v13 + 88)) & 1) == 0)
            {
              if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
              {
                v806 = __nwlog_tcp_log();
                if (os_log_type_enabled(v806, OS_LOG_TYPE_INFO))
                {
                  v807 = "";
                  if (v15)
                    v807 = (const char *)(v15 + 604);
                  *(_DWORD *)buf = 136446466;
                  v902 = "tcp_input";
                  v903 = 2082;
                  *(_QWORD *)v904 = v807;
                  _os_log_impl(&dword_209FB3000, v806, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping tcp input frame since frame is no longer valid", buf, 0x16u);
                }
              }
              *(_QWORD *)(v839 + 1056) = 0;
              in_pcb_checkstate(a3, 2, 1);
              v44 = a1;
              v43 = v892;
              v55 = v849;
              goto LABEL_66;
            }
            *(int8x8_t *)((char *)&v922 + 4) = vrev32_s8(*(int8x8_t *)((char *)&v922 + 4));
            HIWORD(v922) = bswap32(HIWORD(v922)) >> 16;
            v923 = bswap32(v923) >> 16;
            if (&v922 != (__int128 *)v830)
            {
              *(int8x8_t *)(v830 + 4) = vrev32_s8(*(int8x8_t *)(v830 + 4));
              *(_WORD *)(v830 + 14) = bswap32(*(unsigned __int16 *)(v830 + 14)) >> 16;
              *(_WORD *)(v830 + 18) = bswap32(*(unsigned __int16 *)(v830 + 18)) >> 16;
            }
            LODWORD(v131) = v883;
            if ((*(_BYTE *)(a3 + 2229) & 0x40) != 0)
              v840 = *(unsigned __int16 *)(*(_QWORD *)(a3 + 440) + 1072);
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 8) + 16))(v15, 1, v6);
            if (in_pcb_checkstate(a3, 2, 1) == 0xFFFF)
            {
              v132 = 0;
              v44 = a1;
LABEL_277:
              v43 = v892;
              goto LABEL_278;
            }
            if ((v896[0] & 1) != 0)
              DWORD2(v896[0]) -= *(_DWORD *)(v839 + 1888);
            if ((v883 & 0x17) == 0 || !*(_DWORD *)(v839 + 12))
            {
              v44 = a1;
              v55 = v849;
              v43 = v892;
LABEL_1334:
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 8) + 24))(v15, 1, v6);
              goto LABEL_66;
            }
            if (*(_QWORD *)(v15 + 24))
            {
              all_stats = nw_protocol_tcp_get_all_stats();
              if (all_stats)
                ++*(_QWORD *)(all_stats + 16);
              if (*(_QWORD *)(v15 + 24))
              {
                v139 = nw_protocol_tcp_get_all_stats();
                if (v139)
                  *(_QWORD *)(v139 + 24) += v845;
              }
            }
            LODWORD(v898) = DWORD2(v922);
            v140 = HIWORD(v922);
            if ((v883 & 2) == 0)
              v140 = HIWORD(v922) << *(_BYTE *)(v839 + 260);
            v822 = v140;
            v141 = *(_DWORD *)(v15 + 372);
            if ((v141 & 2) != 0)
            {
              *(_DWORD *)(v15 + 372) = v141 & 0xFFFFFFFD;
              if ((*(_BYTE *)(v15 + 828) & 2) == 0)
              {
                if (__nwlog_is_datapath_logging_enabled())
                {
                  v591 = __nwlog_tcp_log();
                  if (os_log_type_enabled(v591, OS_LOG_TYPE_DEBUG))
                  {
                    v592 = "";
                    v902 = "tcp_input";
                    v593 = *(_DWORD *)(v839 + 12);
                    *(_DWORD *)buf = 136446722;
                    if (v15)
                      v592 = (const char *)(v15 + 604);
                    v903 = 2082;
                    *(_QWORD *)v904 = v592;
                    *(_WORD *)&v904[8] = 1024;
                    *(_DWORD *)v905 = v593;
                    _os_log_impl(&dword_209FB3000, v591, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{network:tcp_state}d", buf, 0x1Cu);
                  }
                }
              }
              if (*(_QWORD *)(v15 + 24))
              {
                v150 = nw_protocol_tcp_get_all_stats();
                if (v150)
                  *(_DWORD *)(v150 + 136) = 1;
              }
              v122 = v839;
              tcp_set_max_rwinscale(v839, v15);
              v824 = 1;
              LODWORD(v131) = v883;
            }
            else
            {
              v824 = 0;
            }
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(v15 + 8) + 32))(v15, 0);
            v151 = v848;
            if (*(_DWORD *)(v122 + 12) == 4 && v845 >= 1)
            {
              if ((*(_BYTE *)(v122 + 740) & 2) != 0)
                *(_WORD *)(v122 + 344) += v825;
              v152 = tcp_stretch_ack_enable(v122, v131);
              v153 = *(_DWORD *)(v122 + 88);
              if (v152)
              {
                v154 = v153 | 0x80000000;
                *(_DWORD *)(v122 + 740) &= ~2u;
                *(_WORD *)(v122 + 344) = 0;
              }
              else
              {
                v154 = v153 & 0x7FFFFFFF;
              }
              *(_DWORD *)(v122 + 88) = v154;
              v155 = *(_DWORD *)(v837 + 316);
              v151 = v848;
              if (*(_DWORD *)(v122 + 324) - v155 - 50 < 1)
              {
                *(_DWORD *)(v122 + 324) = v155 + 100;
                *(_DWORD *)(v122 + 328) = v72 + *(_DWORD *)(v122 + 332);
                *(_DWORD *)(v122 + 332) = v72;
              }
              else
              {
                *(int32x2_t *)(v122 + 328) = vadd_s32(*(int32x2_t *)(v122 + 328), vdup_n_s32(v72));
              }
            }
            v156 = *(_DWORD *)(v122 + 740);
            if ((v156 & 0x10000000) == 0
              && ((v156 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 336) == 1 || tcp_do_l4s == 1)
              && ((v156 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1)
              && (~*(_DWORD *)(v122 + 348) & 0x300000) == 0)
            {
              *(_BYTE *)(v122 + 428) &= ~1u;
            }
            if (*(_DWORD *)(v122 + 12) == 4)
            {
              v157 = *(_DWORD *)(v122 + 92);
              if (DWORD2(v922) != v157)
              {
                v158 = *(void (**)(uint64_t, _QWORD))(tcp_cc_algo_list[*(unsigned __int8 *)(v122 + 264)] + 112);
                if (v158)
                {
                  v158(v122, (DWORD2(v922) - v157));
                  v151 = v848;
                }
                if ((*(_BYTE *)(v122 + 348) & 4) != 0)
                {
                  v159 = *(_DWORD *)(v122 + 196);
                  v160 = (DWORD2(v922) - *(_DWORD *)(v122 + 92) + (v159 >> 1)) / v159;
                  if (v159 > v160 * v159)
                    v161 = 1;
                  else
                    v161 = v160;
                  *(_QWORD *)(v122 + 376) += v161;
                }
              }
            }
            v162 = *(_DWORD *)(v122 + 740);
            if ((v162 & 0x10000000) != 0)
            {
              if ((v131 & 0x80) == 0)
                goto LABEL_360;
            }
            else if ((v131 & 0x80) == 0
                   || (v162 & 0x8000000) != 0
                   || *(_DWORD *)(sysctls + 320) == 1
                   || tcp_do_acc_ecn == 1)
            {
LABEL_360:
              if ((SBYTE13(v922) & 0x80u) == 0)
                v163 = (BYTE13(v922) & 0x40) != 0;
              else
                v163 = (BYTE13(v922) >> 6) | 2;
              v821 = v163 & 0xFFFFFFFB | (4 * (BYTE12(v922) & 1));
              v164 = v837;
              if ((v162 & 0x10000000) != 0
                || (v162 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
                || (~*(_DWORD *)(v122 + 348) & 0x300000) != 0
                || *(_DWORD *)(v122 + 12) != 4)
              {
                if (log == 3)
                {
                  v166 = *(_DWORD *)(v122 + 12);
                  if (v166 != 4)
                    goto LABEL_415;
                  v167 = *(_DWORD *)(v122 + 348);
                  if ((~v167 & 3) == 0 && v845 >= 1)
                  {
                    v168 = *(_DWORD *)(v122 + 284);
                    if (DWORD1(v922) - v168 >= 0 && DWORD1(v922) - (v168 + *(_DWORD *)(v122 + 128)) < 0)
                    {
                      ++*(_DWORD *)(v122 + 352);
                      v169 = *(_QWORD *)(v122 + 1056);
                      if (v169)
                        ++*(_QWORD *)(v169 + 856);
                      v170 = *(_QWORD *)(a3 + 448);
                      if (v170)
                      {
                        v171 = 568;
                        if ((*(_BYTE *)(a3 + 2236) & 2) == 0)
                          v171 = 184;
                        ++*(_QWORD *)(v170 + v171);
                      }
                      *(_DWORD *)(v122 + 348) = v167 | 0x50;
                      v164 = v837;
                      LOBYTE(v131) = v883;
                    }
                  }
                }
LABEL_399:
                v166 = *(_DWORD *)(v122 + 12);
                if (v166 == 4)
                {
                  v178 = *(_DWORD *)(v122 + 348);
                  if ((v178 & 1) == 0)
                  {
                    if (log == 3)
                    {
LABEL_410:
                      v823 = 1;
                      if ((~v178 & 3) == 0 || (v178 & 0x2000) != 0)
                        goto LABEL_419;
                      v179 = *(_QWORD *)(v122 + 1056);
                      if (v179)
                        ++*(_QWORD *)(v179 + 944);
                      tcp_heuristic_ecn_aggressive(v122);
                      *(_DWORD *)(v122 + 348) |= 0x2000u;
                      v166 = *(_DWORD *)(v122 + 12);
                      v823 = 1;
                      v164 = v837;
LABEL_417:
                      if (v166 != 4)
                        goto LABEL_432;
                      v178 = *(_DWORD *)(v122 + 348);
LABEL_419:
                      if (v823 && (v178 & 0x2003) == 3)
                      {
                        v180 = *(unsigned __int8 *)(v122 + 733);
                        if (**(_QWORD **)(a3 + 248) > 9uLL)
                        {
                          if (v180 >= 8)
                          {
                            v181 = *(_QWORD *)(v122 + 1056);
                            if (v181)
                              ++*(_QWORD *)(v181 + 944);
                            tcp_heuristic_ecn_aggressive(v122);
                            *(_DWORD *)(v122 + 348) |= 0x2000u;
                            v182 = *(_QWORD *)(a3 + 448);
                            if (v182)
                            {
                              if ((*(_BYTE *)(a3 + 2236) & 2) != 0)
                                ++*(_QWORD *)(v182 + 640);
                              else
                                ++*(_QWORD *)(v182 + 256);
                              v823 = 1;
                              v164 = v837;
                              LOBYTE(v131) = v883;
                            }
                            else
                            {
                              v823 = 1;
                              v164 = v837;
                              LOBYTE(v131) = v883;
                            }
                            goto LABEL_431;
                          }
                          *(_DWORD *)(v122 + 348) = v178 | 0x2000;
                        }
                        else
                        {
                          *(_BYTE *)(v122 + 733) = v180 + 1;
                        }
                        v823 = 1;
                      }
LABEL_431:
                      v166 = *(_DWORD *)(v122 + 12);
LABEL_432:
                      *(_DWORD *)(v122 + 160) = *(_DWORD *)(v164 + 316);
                      if (v166 >= 4)
                      {
                        tcp_keepalive_reset(v122);
                        v166 = *(_DWORD *)(v122 + 12);
                      }
                      if (v166 != 1 && v130)
                      {
                        tcp_dooptions(v122, v130, v832, (uint64_t)&v922, (uint64_t)v896);
                        v166 = *(_DWORD *)(v122 + 12);
                      }
                      if ((v131 & 2) != 0 && v166 == 2)
                      {
                        if ((v131 & 0x10) != 0
                          && (DWORD2(v922) - *(_DWORD *)(v122 + 112) < 1 || DWORD2(v922) - *(_DWORD *)(v122 + 96) > 0))
                        {
LABEL_460:
                          *(_DWORD *)(v122 + 744) = 0;
                          goto LABEL_461;
                        }
                        tcp_finalize_options(v122, (int *)v896, v840);
                        v166 = *(_DWORD *)(v122 + 12);
                      }
                      if ((v131 & 0x7F) != 0x10
                        || v166 != 4
                        || (*(_BYTE *)(v122 + 89) & 8) != 0
                        || (v896[0] & 1) != 0 && DWORD1(v896[0]) - *(_DWORD *)(v122 + 276) < 0
                        || DWORD1(v922) != *(_DWORD *)(v122 + 120)
                        || *(_QWORD *)v122)
                      {
                        goto LABEL_460;
                      }
                      v183 = *(unsigned __int16 *)(v122 + 752);
                      if (v183 <= 0x28)
                        *(_WORD *)(v122 + 752) = v183 + v825;
                      v184 = *(unsigned __int16 *)(v122 + 748);
                      if (*(_WORD *)(v122 + 748) && v845 <= v184)
                      {
                        if (v845 != v184)
                        {
LABEL_455:
                          if (v845 < v184)
                          {
                            v186 = (*(_BYTE *)(v122 + 750) + v825);
                            *(_BYTE *)(v122 + 750) += v825;
                            if (v186 < 0x15)
                            {
                              *(_DWORD *)(v122 + 744) = 0;
                            }
                            else
                            {
                              *(_WORD *)(v122 + 748) = v845;
                              *(_DWORD *)(v122 + 744) = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v122 + 80) + 224))
                                                                  + 316);
                              *(_BYTE *)(v122 + 750) = 0;
                            }
                            goto LABEL_461;
                          }
                          v192 = v122;
                          goto LABEL_529;
                        }
                        v185 = *(_DWORD *)(v122 + 744);
                        if (v185)
                        {
                          compute_iaj_meat(v122, *(_DWORD *)(v837 + 316) - v185);
                          v184 = *(unsigned __int16 *)(v122 + 748);
                          goto LABEL_455;
                        }
                      }
                      v192 = v122;
LABEL_529:
                      update_iaj_state(v192, v845);
LABEL_461:
                      if (*(_DWORD *)(v122 + 12) != 4)
                        goto LABEL_552;
                      if ((v883 & 0xFFFFFFF7) != 0x10)
                        goto LABEL_552;
                      if ((*(_WORD *)(v15 + 376) & 0x20) != 0)
                        goto LABEL_552;
                      v187 = *(_DWORD *)(v122 + 88);
                      if ((v187 & 0x800) != 0 || (v896[0] & 1) != 0 && DWORD1(v896[0]) - *(_DWORD *)(v122 + 276) < 0)
                        goto LABEL_552;
                      if (DWORD1(v922) != *(_DWORD *)(v122 + 120))
                        goto LABEL_552;
                      if (!v822)
                        goto LABEL_552;
                      if (v822 != *(_DWORD *)(v122 + 140))
                        goto LABEL_552;
                      v188 = *(_DWORD *)(v122 + 100);
                      if (v188 != *(_DWORD *)(v122 + 96))
                        goto LABEL_552;
                      if ((v896[0] & 1) != 0 && DWORD1(v922) - *(_DWORD *)(v839 + 284) <= 0)
                      {
                        *(_DWORD *)(v839 + 280) = *(_DWORD *)(v837 + 316);
                        *(_DWORD *)(v839 + 276) = DWORD1(v896[0]);
                      }
                      v189 = *(_DWORD *)(v839 + 740);
                      if ((v189 & 0x10000000) == 0
                        && ((v189 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
                      {
                        v190 = v823 ^ 1;
                        if ((~*(_DWORD *)(v839 + 348) & 0x300000) != 0)
                          v190 = 1;
                        if ((v190 & 1) == 0)
                          *(_WORD *)(v839 + 306) += v825;
                      }
                      v191 = *(_DWORD *)(v839 + 92);
                      if ((_DWORD)v72 == (_DWORD)v848)
                      {
                        v122 = v839;
                        if (DWORD2(v922) - v188 <= 0
                          && DWORD2(v922) - v191 >= 1
                          && (v187 & 0x200000) == 0
                          && *(_DWORD *)(v839 + 144) >= *(_DWORD *)(v839 + 148))
                        {
                          if ((v189 & 0x20) != 0)
                          {
                            v122 = v839;
                            if (!HIBYTE(v896[0]) && !*(_QWORD *)(v839 + 544))
                              goto LABEL_1456;
                          }
                          else
                          {
                            v122 = v839;
                            if (*(_DWORD *)(v839 + 8) < (int)*(unsigned __int8 *)(v839 + 310))
                            {
LABEL_1456:
                              v567 = *(_QWORD *)(v122 + 1056);
                              if (v567)
                                ++*(_QWORD *)(v567 + 544);
                              tcp_bad_rexmt_check(v839, (uint64_t)&v922, (uint64_t)v896);
                              tcp_compute_rtt(v839, (uint64_t)v896, (uint64_t)&v922);
                              v568 = DWORD2(v922);
                              v569 = *(_DWORD *)(v839 + 92);
                              v570 = DWORD2(v922) - v569;
                              if (DWORD2(v922) - v569 >= 0)
                              {
LABEL_1459:
                                v571 = *(_QWORD *)(v839 + 1056);
                                if (v571)
                                {
                                  v572 = *(_QWORD *)(v571 + 168) + v570;
                                  ++*(_QWORD *)(v571 + 160);
                                  *(_QWORD *)(v571 + 168) = v572;
                                }
                                v573 = *(_DWORD *)(v839 + 740);
                                if ((v573 & 0x10000000) != 0
                                  || (v573 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
                                  || (~*(_DWORD *)(v839 + 348) & 0x300004) != 0)
                                {
                                  goto LABEL_1935;
                                }
                                if ((v573 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 336) == 1 || tcp_do_l4s == 1)
                                {
LABEL_1924:
                                  v735 = *(_DWORD *)(v839 + 196);
                                  if (v570 / v735 * v735 == v570)
                                    v736 = v570 / v735;
                                  else
                                    v736 = v570 / v735 + 1;
                                  *(_DWORD *)(v839 + 296) += v736;
                                  if (v568 == v569)
                                  {
                                    v737 = 0;
                                    if ((v896[0] & 1) != 0 && DWORD2(v896[0]))
                                      v737 = DWORD2(v896[0]) - *(_DWORD *)(v839 + 400) > 0;
                                  }
                                  else
                                  {
                                    v737 = 0;
                                  }
                                  if (v570 > 0 || v737)
                                    tcp_process_accecn(v839, (uint64_t)v896, (uint64_t)&v922, v736, v821);
LABEL_1935:
                                  if ((*(_DWORD *)(v839 + 740) & 0x20400020) == 0x20000020)
                                  {
                                    tcp_segs_doack(v839, DWORD2(v922), v896[0], SDWORD2(v896[0]));
                                    if (*(_DWORD *)(v839 + 560) - DWORD2(v922) < 0)
                                      *(_DWORD *)(v839 + 560) = DWORD2(v922);
                                  }
                                  v738 = *(void (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v839 + 264)]
                                                                                    + 48);
                                  if (v738)
                                    v738(v839, &v922);
                                  sbdrop((int *)(v15 + 384), v570);
                                  tcp_sbsnd_trim(v15 + 384);
                                  v739 = *(_DWORD *)(v839 + 152);
                                  v740 = DWORD2(v922);
                                  if (*(_DWORD *)(v839 + 92) - v739 >= 1 && DWORD2(v922) - v739 <= 0)
                                    *(_DWORD *)(v839 + 152) = DWORD2(v922) - 1;
                                  tcp_update_snd_una(v839, v740);
                                  *(_WORD *)(v839 + 226) = 0;
                                  *(_DWORD *)(v839 + 248) = 0;
                                  *(_DWORD *)(v839 + 108) = DWORD2(v922);
                                  if (*(int *)(v839 + 8) >= 1)
                                  {
                                    *(_DWORD *)(v839 + 8) = 0;
                                    *(_BYTE *)(v839 + 310) = 3;
                                  }
                                  *(_DWORD *)(v839 + 628) = 0;
                                  if (*(_DWORD *)(v839 + 92) == *(_DWORD *)(v839 + 96))
                                  {
                                    *(_DWORD *)(v839 + 16) = 0;
                                    *(_QWORD *)(v839 + 24) = 0;
                                    *(_BYTE *)(v839 + 2069) &= ~0x80u;
                                  }
                                  else if (!*(_DWORD *)(v839 + 36))
                                  {
                                    *(_DWORD *)(v839 + 28) = *(_DWORD *)(v839 + 192)
                                                           + *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v839 + 80) + 224))
                                                                       + 316)
                                                           - *(_DWORD *)(v839 + 64);
                                  }
                                  if (*(_QWORD *)(v839 + 952))
                                  {
                                    v741 = *(_DWORD *)(v839 + 960);
                                    if (v741 - *(_DWORD *)(v839 + 96) > 0)
                                      goto LABEL_1951;
                                    v742 = *(_DWORD *)(v839 + 140);
                                    if (v742 >= *(_DWORD *)(sysctls + 120))
                                      v742 = *(_DWORD *)(sysctls + 120);
                                    if ((int)(v741 - *(_DWORD *)(v839 + 92) + v742) < 0)
LABEL_1951:
                                      tcp_rxtseg_clean(v839);
                                  }
                                  if ((*(_BYTE *)(v839 + 740) & 8) != 0 && *(_QWORD *)(v839 + 768))
                                    tcp_bwmeas_check(v839);
                                  v743 = *(void (***)(uint64_t))(v15 + 32);
                                  if (v743)
                                  {
                                    v744 = *v743;
                                    if (v744)
                                      v744(v15);
                                  }
                                  if (!*(_DWORD *)(v15 + 384) && (*(_BYTE *)(v839 + 88) & 1) == 0
                                    || !tcp_output(v839)
                                    || (*(_WORD *)(v13 + 204) & 0x100) == 0
                                    || !*MEMORY[0x24BDE08C0]
                                    || (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v13, *(_QWORD *)(v13 + 88)) & 1) != 0)
                                  {
                                    tcp_tfo_rcv_ack(v839, (uint64_t)&v922);
                                    tcp_check_timer_state(v839);
                                    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v15 + 8) + 24))(v15, 1);
                                    result = (_QWORD *)*a1;
                                    if (!*a1)
                                      return result;
                                    while (1)
                                    {
                                      v745 = (void (*)(_QWORD *, uint64_t, uint64_t))result[10];
                                      v746 = (_QWORD *)result[4];
                                      if (!v745)
                                        break;
                                      v747 = result[11];
                                      result[10] = 0;
                                      result[11] = 0;
                                      v745(result, 1, v747);
LABEL_1970:
                                      result = v746;
                                      if (!v746)
                                        return result;
                                    }
                                    __nwlog_obj();
                                    *(_DWORD *)buf = 136446210;
                                    v902 = "__nw_frame_finalize";
                                    v748 = _os_log_send_and_compose_impl();
                                    type[0] = OS_LOG_TYPE_ERROR;
                                    v900 = 0;
                                    v891 = (void *)v748;
                                    if (__nwlog_fault())
                                    {
                                      if (type[0] == OS_LOG_TYPE_FAULT)
                                      {
                                        v879 = __nwlog_obj();
                                        if (!os_log_type_enabled(v879, type[0]))
                                          goto LABEL_1986;
                                        *(_DWORD *)buf = 136446210;
                                        v902 = "__nw_frame_finalize";
                                        v749 = v879;
                                        v750 = type[0];
                                        v751 = "%{public}s called with null frame->finalizer";
                                        goto LABEL_1985;
                                      }
                                      if (!v900)
                                      {
                                        v881 = __nwlog_obj();
                                        if (!os_log_type_enabled(v881, type[0]))
                                          goto LABEL_1986;
                                        *(_DWORD *)buf = 136446210;
                                        v902 = "__nw_frame_finalize";
                                        v749 = v881;
                                        v750 = type[0];
                                        v751 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                                        goto LABEL_1985;
                                      }
                                      backtrace_string = (void *)__nw_create_backtrace_string();
                                      logj = __nwlog_obj();
                                      v752 = os_log_type_enabled(logj, type[0]);
                                      if (backtrace_string)
                                      {
                                        if (v752)
                                        {
                                          *(_DWORD *)buf = 136446466;
                                          v902 = "__nw_frame_finalize";
                                          v903 = 2082;
                                          *(_QWORD *)v904 = backtrace_string;
                                          _os_log_impl(&dword_209FB3000, logj, type[0], "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                                        }
                                        free(backtrace_string);
                                        goto LABEL_1986;
                                      }
                                      if (v752)
                                      {
                                        *(_DWORD *)buf = 136446210;
                                        v902 = "__nw_frame_finalize";
                                        v749 = logj;
                                        v750 = type[0];
                                        v751 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1985:
                                        _os_log_impl(&dword_209FB3000, v749, v750, v751, buf, 0xCu);
                                      }
                                    }
LABEL_1986:
                                    if (v891)
                                      free(v891);
                                    goto LABEL_1970;
                                  }
                                  if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                  {
                                    v802 = __nwlog_tcp_log();
                                    if (os_log_type_enabled(v802, OS_LOG_TYPE_INFO))
                                    {
                                      v803 = "";
                                      if (v15)
                                        v803 = (const char *)(v15 + 604);
                                      *(_DWORD *)buf = 136446466;
                                      v902 = "tcp_input";
                                      v903 = 2082;
                                      *(_QWORD *)v904 = v803;
                                      _os_log_impl(&dword_209FB3000, v802, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping input packet since frame is no longer valid", buf, 0x16u);
                                    }
                                  }
                                  *(_QWORD *)(v839 + 1056) = 0;
                                  v44 = a1;
                                  v43 = v892;
                                  v55 = v849;
LABEL_1293:
                                  v132 = v824;
                                  goto LABEL_1332;
                                }
                                __nwlog_obj();
                                *(_DWORD *)buf = 136446210;
                                v902 = "tcp_input";
                                v574 = (void *)_os_log_send_and_compose_impl();
                                type[0] = OS_LOG_TYPE_ERROR;
                                v900 = 0;
                                if (__nwlog_fault())
                                {
                                  if (type[0] == OS_LOG_TYPE_FAULT)
                                  {
                                    v575 = __nwlog_obj();
                                    v576 = type[0];
                                    if (!os_log_type_enabled(v575, type[0]))
                                      goto LABEL_1922;
                                    *(_DWORD *)buf = 136446210;
                                    v902 = "tcp_input";
                                    v577 = "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not";
LABEL_1920:
                                    v733 = v575;
                                    v734 = v576;
LABEL_1921:
                                    _os_log_impl(&dword_209FB3000, v733, v734, v577, buf, 0xCu);
                                    goto LABEL_1922;
                                  }
                                  if (!v900)
                                  {
                                    v575 = __nwlog_obj();
                                    v576 = type[0];
                                    if (!os_log_type_enabled(v575, type[0]))
                                      goto LABEL_1922;
                                    *(_DWORD *)buf = 136446210;
                                    v902 = "tcp_input";
                                    v577 = "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not, backtrace limit exceeded";
                                    goto LABEL_1920;
                                  }
                                  v711 = (void *)__nw_create_backtrace_string();
                                  v712 = __nwlog_obj();
                                  v713 = os_log_type_enabled(v712, type[0]);
                                  if (v711)
                                  {
                                    if (v713)
                                    {
                                      *(_DWORD *)buf = 136446466;
                                      v902 = "tcp_input";
                                      v903 = 2082;
                                      *(_QWORD *)v904 = v711;
                                      _os_log_impl(&dword_209FB3000, v712, type[0], "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not, dumping backtrace:%{public}s", buf, 0x16u);
                                    }
                                    free(v711);
                                    goto LABEL_1922;
                                  }
                                  if (v713)
                                  {
                                    *(_DWORD *)buf = 136446210;
                                    v902 = "tcp_input";
                                    v577 = "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not, no backtrace";
                                    v733 = v712;
                                    v734 = type[0];
                                    goto LABEL_1921;
                                  }
                                }
LABEL_1922:
                                if (v574)
                                  free(v574);
                                goto LABEL_1924;
                              }
                              v797 = __nwlog_obj();
                              os_log_type_enabled(v797, OS_LOG_TYPE_ERROR);
                              *(_DWORD *)buf = 136446210;
                              v902 = "tcp_input";
                              v798 = (void *)_os_log_send_and_compose_impl();
                              if (!__nwlog_abort())
                              {
                                free(v798);
                                v568 = DWORD2(v922);
                                v569 = *(_DWORD *)(v839 + 92);
                                v570 = DWORD2(v922) - v569;
                                goto LABEL_1459;
                              }
                              goto LABEL_2097;
                            }
                          }
                        }
LABEL_552:
                        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(v15 + 8) + 32))(v15, 0);
                        v220 = tcp_sbspace(v122);
                        if ((v220 & 0x80000000) == 0)
                        {
                          v44 = a1;
                          if ((*(_BYTE *)(v122 + 90) & 8) != 0)
                          {
                            v222 = *(_DWORD *)(sysctls + 48);
                            v223 = v220 >= v222 ? *(_DWORD *)(sysctls + 48) : v220;
                            if (v222 > 0)
                              v220 = v223;
                          }
LABEL_567:
                          v227 = *(_DWORD *)(v122 + 120);
                          if ((int)v220 <= *(_DWORD *)(v122 + 124) - v227)
                            v228 = *(_DWORD *)(v122 + 124) - v227;
                          else
                            v228 = v220;
                          *(_DWORD *)(v122 + 128) = v228;
                          v229 = *(_DWORD *)(v122 + 12);
                          LODWORD(v131) = v883;
                          switch(v229)
                          {
                            case 1:
                              tcp_dooptions(v122, v130, v832, (uint64_t)&v922, (uint64_t)v896);
                              tcp_finalize_options(v122, (int *)v896, v840);
                              if ((*(_BYTE *)(v122 + 742) & 0x40) != 0)
                                v841 = tcp_tfo_syn(v122, (uint64_t)v896);
                              else
                                v841 = 0;
                              v244 = tcp_new_isn(v122);
                              v245 = DWORD1(v922);
                              *(_DWORD *)(v122 + 112) = v244;
                              *(_DWORD *)(v122 + 116) = v245;
                              *(_DWORD *)(v122 + 152) = v244;
                              *(_DWORD *)(v122 + 96) = v244;
                              *(_DWORD *)(v122 + 100) = v244;
                              *(_DWORD *)(v122 + 92) = v244;
                              if (*(_QWORD *)(v15 + 24))
                              {
                                v246 = nw_protocol_tcp_get_all_stats();
                                v244 = *(_DWORD *)(v122 + 92);
                                if (v246)
                                {
                                  *(_DWORD *)(v246 + 108) = *(_DWORD *)(v122 + 96) - v244;
                                  v244 = *(_DWORD *)(v122 + 92);
                                }
                              }
                              v247 = *(_DWORD *)(v122 + 116) + 1;
                              *(_DWORD *)(v122 + 1916) = v247;
                              *(_DWORD *)(v122 + 120) = v247;
                              *(_DWORD *)(v122 + 124) = v247;
                              *(_DWORD *)(v122 + 152) = v244;
                              *(_DWORD *)(v122 + 140) = v822;
                              *(_DWORD *)(v122 + 252) = v822;
                              if (*(_QWORD *)(v15 + 24))
                              {
                                v248 = nw_protocol_tcp_get_all_stats();
                                if (v248)
                                  *(_DWORD *)(v248 + 112) = *(_DWORD *)(v122 + 140);
                              }
                              *(_DWORD *)(v122 + 88) |= 1u;
                              *(_DWORD *)(v122 + 304) = 0;
                              v249 = (int64x2_t *)v122;
                              *(_DWORD *)(v122 + 12) = 3;
                              if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                              {
                                if (__nwlog_is_datapath_logging_enabled())
                                {
                                  v645 = __nwlog_tcp_log();
                                  if (os_log_type_enabled(v645, OS_LOG_TYPE_DEBUG))
                                  {
                                    v646 = tcpstates[v249->i32[3]];
                                    v902 = "tcp_input";
                                    v647 = "";
                                    *(_DWORD *)buf = 136446722;
                                    if (v15)
                                      v647 = (const char *)(v15 + 604);
                                    v903 = 2082;
                                    *(_QWORD *)v904 = v647;
                                    *(_WORD *)&v904[8] = 2082;
                                    *(_QWORD *)v905 = v646;
                                    _os_log_impl(&dword_209FB3000, v645, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                  }
                                }
                              }
                              if (*(_QWORD *)(v15 + 24))
                              {
                                v250 = nw_protocol_tcp_get_all_stats();
                                if (v250)
                                  *(_DWORD *)(v250 + 136) = 3;
                              }
                              v243 = (uint64_t)v249;
                              v251 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(v249[5].i64[0] + 224)) + 316);
                              v252 = v249[42].i32[2];
                              if (!v252)
                                v252 = *(_DWORD *)(sysctls + 188);
                              v249[2].i32[2] = v252 + v251 - v249[4].i32[0];
                              v253 = v883;
                              if (!*(_DWORD *)(a3 + 460))
                              {
                                v254 = inp_calc_flowhash_flow_hash++;
                                *(_DWORD *)(a3 + 460) = v254;
                              }
                              *(_DWORD *)(v15 + 364) &= ~0x40000u;
                              v255 = v249[66].i64[0];
                              if (v255)
                                ++*(_QWORD *)(v255 + 384);
                              v221 = tcp_input_process_accecn_syn(v249, ((unsigned __int16)v883 | (unsigned __int16)(BYTE12(v922) << 8)) & 0x1C0, log);
                              v824 = 0;
                              v256 = v830;
                              goto LABEL_938;
                            case 2:
                              if ((v883 & 0x10) != 0)
                              {
                                if (DWORD2(v922) - *(_DWORD *)(v122 + 112) < 1
                                  || DWORD2(v922) - *(_DWORD *)(v122 + 96) > 0)
                                {
                                  goto LABEL_645;
                                }
                                if ((v883 & 4) != 0)
                                {
                                  if ((*(_DWORD *)(v122 + 740) & 0x1400000) == 0x400000)
                                    tcp_heuristic_tfo_rst(v122);
                                  v322 = *(_DWORD *)(v122 + 348);
                                  if ((v322 & 0x8001) == 1 || (v322 & 0x108000) == 0x100000)
                                    tcp_heuristic_ecn_synrst(v122);
                                  tcp_drop(v122, 61);
                                  v43 = v892;
                                  goto LABEL_1292;
                                }
                                v43 = v892;
                                LOBYTE(v131) = v883;
                                if ((v883 & 2) == 0)
                                  goto LABEL_1292;
                              }
                              else if ((v883 & 6) != 2)
                              {
LABEL_619:
                                v55 = v849;
                                v132 = v824;
                                goto LABEL_620;
                              }
                              v237 = HIWORD(v922);
                              *(_DWORD *)(v122 + 140) = HIWORD(v922);
                              *(_DWORD *)(v122 + 252) = v237;
                              if (*(_QWORD *)(v15 + 24))
                              {
                                v238 = nw_protocol_tcp_get_all_stats();
                                if (v238)
                                  *(_DWORD *)(v238 + 112) = *(_DWORD *)(v122 + 140);
                              }
                              v820 = v16;
                              v239 = DWORD1(v922);
                              v240 = DWORD1(v922) + 1;
                              *(_DWORD *)(v122 + 1916) = DWORD1(v922) + 1;
                              *(_DWORD *)(v122 + 116) = v239;
                              *(_DWORD *)(v122 + 120) = v240;
                              *(_DWORD *)(v122 + 124) = v240;
                              if ((v131 & 0x10) == 0)
                              {
                                *(_DWORD *)(v122 + 88) |= 1u;
                                *(_DWORD *)(v122 + 28) = 0;
                                v241 = v122;
                                *(_DWORD *)(v122 + 12) = 3;
                                if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                {
                                  if (__nwlog_is_datapath_logging_enabled())
                                  {
                                    v714 = __nwlog_tcp_log();
                                    if (os_log_type_enabled(v714, OS_LOG_TYPE_DEBUG))
                                    {
                                      v715 = tcpstates[*(int *)(v241 + 12)];
                                      v902 = "tcp_input";
                                      v716 = "";
                                      *(_DWORD *)buf = 136446722;
                                      if (v15)
                                        v716 = (const char *)(v15 + 604);
                                      v903 = 2082;
                                      *(_QWORD *)v904 = v716;
                                      *(_WORD *)&v904[8] = 2082;
                                      *(_QWORD *)v905 = v715;
                                      _os_log_impl(&dword_209FB3000, v714, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                    }
                                  }
                                }
                                if (*(_QWORD *)(v15 + 24))
                                {
                                  v242 = nw_protocol_tcp_get_all_stats();
                                  if (v242)
                                    *(_DWORD *)(v242 + 136) = 3;
                                }
                                v841 = 0;
                                v243 = v241;
                                *(_DWORD *)(v241 + 740) &= ~0x400000u;
                                goto LABEL_937;
                              }
                              v267 = v122;
                              v268 = *(_QWORD **)(v122 + 1056);
                              if (v268)
                                ++v268[51];
                              if ((v131 & 0xC0) == 0x40)
                              {
                                v269 = *(_DWORD *)(v122 + 348);
                                *(_DWORD *)(v122 + 348) = v269 | 2;
                                if ((v269 & 1) != 0)
                                {
                                  v270 = *(_QWORD *)(v122 + 80);
                                  buf[0] = 1;
                                  (*(void (**)(_QWORD, uint8_t *))(*(_QWORD *)(v270 + 2136) + 24))(*(_QWORD *)(v270 + 224), buf);
                                  v271 = *(_QWORD *)(v122 + 1056);
                                  if (v271)
                                    ++*(_QWORD *)(v271 + 776);
                                }
                                v272 = v122;
                                v273 = *(_DWORD *)(v122 + 348);
                                if ((v273 & 0x100000) != 0)
                                {
                                  *(_DWORD *)(v122 + 348) = v273 & 0xFFEFFFFA | 5;
                                  if (*(_DWORD *)(v122 + 360) == 2)
                                  {
                                    v274 = 3;
LABEL_800:
                                    *(_DWORD *)(v272 + 360) = v274;
                                  }
                                }
                              }
                              else
                              {
                                v310 = *(_DWORD *)(v122 + 740);
                                if ((v310 & 0x10000000) == 0
                                  && ((v311 = ((unsigned __int16)v883 | (unsigned __int16)(BYTE12(v922) << 8)) & 0x1C0,
                                       v312 = sysctls,
                                       *(_DWORD *)(sysctls + 320) == 1)
                                   || tcp_do_acc_ecn == 1
                                   || (v310 & 0x8000000) != 0)
                                  && (((unsigned __int16)v883 | (unsigned __int16)(BYTE12(v922) << 8)) & 0x1C0) != 0
                                  && v311 != 448)
                                {
                                  *(_DWORD *)(v122 + 420) = 5;
                                  *(_QWORD *)(v122 + 456) = 1;
                                  *(_OWORD *)(v122 + 464) = xmmword_20A010BA0;
                                  v313 = *(_DWORD *)(v122 + 348);
                                  v314 = v313 | 0x400000;
                                  *(_DWORD *)(v122 + 348) = v313 | 0x400000;
                                  switch((v311 - 128) >> 6)
                                  {
                                    case 0u:
                                      v315 = v310 & 0x8000000;
                                      v316 = *(_DWORD *)(v312 + 336);
                                      if (tcp_do_l4s != 1 && v316 != 1 && v315 == 0)
                                        v319 = 0x200000;
                                      else
                                        v319 = 2097156;
                                      v314 |= v319;
                                      *(_DWORD *)(v122 + 348) = v314;
                                      *(_DWORD *)(v122 + 360) = 7;
                                      if (v268)
                                        ++v268[102];
                                      break;
                                    case 1u:
                                      v314 = v313 & 0xFF9FFFFB | 0x600000;
                                      *(_DWORD *)(v122 + 348) = v314;
                                      *(_DWORD *)(v122 + 360) = 8;
                                      if (v268)
                                        ++v268[103];
                                      break;
                                    case 2u:
                                      v314 = v313 & 0xFF9FFFFB | 0x600000;
                                      *(_DWORD *)(v122 + 348) = v314;
                                      *(_DWORD *)(v122 + 360) = 8;
                                      if (v268)
                                        ++v268[104];
                                      break;
                                    case 4u:
                                      *(_DWORD *)(v122 + 360) = 8;
                                      v314 = v313 & 0xFF9FFFFB | 0x600000;
                                      *(_DWORD *)(v122 + 348) = v314;
                                      *(_DWORD *)(v122 + 144) = 2 * *(_DWORD *)(v122 + 196);
                                      if (v268)
                                        ++v268[105];
                                      break;
                                    default:
                                      break;
                                  }
                                  if ((~v314 & 3) == 0)
                                  {
                                    v563 = *(_QWORD *)(v122 + 80);
                                    buf[0] = 1;
                                    (*(void (**)(_QWORD, uint8_t *))(*(_QWORD *)(v563 + 2136) + 24))(*(_QWORD *)(v563 + 224), buf);
                                    v564 = *(_QWORD *)(v122 + 1056);
                                    if (v564)
                                      ++*(_QWORD *)(v564 + 776);
                                  }
                                  v272 = v122;
                                  *(_DWORD *)(v122 + 416) = 5;
                                  *(int64x2_t *)(v122 + 432) = vdupq_n_s64(1uLL);
                                  *(_QWORD *)(v122 + 448) = 0;
                                  tcp_input_ip_ecn(v122, a3, v899, v825, log);
                                  *(_DWORD *)(v122 + 348) |= dword_20A010BC0[log];
                                  if ((v896[0] & 1) != 0)
                                  {
                                    if (DWORD2(v896[0]))
                                    {
                                      v565 = *(_DWORD *)(v122 + 400);
                                      if (!v565 || ((DWORD2(v896[0]) - v565) & 0x80000000) == 0)
                                        *(_DWORD *)(v122 + 400) = DWORD2(v896[0]);
                                    }
                                  }
                                }
                                else
                                {
                                  if ((*(_DWORD *)(v122 + 348) & 0x100001) != 0 && !*(_WORD *)(v122 + 226))
                                  {
                                    v323 = *(_QWORD *)(v122 + 80);
                                    buf[0] = 1;
                                    (*(void (**)(_QWORD, uint8_t *))(*(_QWORD *)(v323 + 2136) + 24))(*(_QWORD *)(v323 + 224), buf);
                                    v324 = *(_QWORD *)(v122 + 1056);
                                    if (v324)
                                      ++*(_QWORD *)(v324 + 784);
                                  }
                                  v325 = *(_DWORD *)(v122 + 348);
                                  if ((v325 & 0x100001) != 0 && *(_WORD *)(v122 + 226))
                                  {
                                    tcp_heuristic_ecn_loss(v122);
                                    v325 = *(_DWORD *)(v122 + 348);
                                  }
                                  *(_DWORD *)(v122 + 348) = v325 & 0xFFFFFFFB;
                                  if ((v325 & 0x100) != 0
                                    && *(unsigned __int16 *)(v122 + 226) <= 2u
                                    && *(_DWORD *)(v122 + 360) == 2)
                                  {
                                    *(_DWORD *)(v122 + 360) = 5;
                                  }
                                  v272 = v122;
                                  if (*(_DWORD *)(v122 + 360) == 2)
                                  {
                                    v274 = 4;
                                    goto LABEL_800;
                                  }
                                }
                              }
                              v326 = *(_DWORD *)(v272 + 88);
                              if ((~v326 & 0x60) != 0)
                              {
                                v327 = *(_BYTE *)(v272 + 261);
                              }
                              else
                              {
                                *(_BYTE *)(v272 + 260) = *(_BYTE *)(v272 + 263);
                                v327 = *(_BYTE *)(v272 + 262);
                                *(_BYTE *)(v272 + 261) = v327;
                              }
                              v328 = 0xFFFFLL << v327;
                              v329 = 0xFFFF << v327;
                              if (v328 <= *(unsigned int *)(v272 + 128))
                                v330 = v329;
                              else
                                v330 = *(_DWORD *)(v272 + 128);
                              if (*(_DWORD *)(sysctls + 308) == 1
                                && (v326 & 0x180) == 0x180
                                && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v15 + 369) & 0x40) != 0))
                              {
                                if (off_253CF86A8)
                                {
                                  v331 = off_253CF86A8(v122);
                                  v332 = v330 >= v331 ? v331 : v330;
                                  if (v331)
                                    v330 = v332;
                                }
                              }
                              *(_DWORD *)(v122 + 124) += v330;
                              v333 = *(_DWORD *)(v122 + 92) + 1;
                              *(_DWORD *)(v122 + 92) = v333;
                              if (*(_QWORD *)(v15 + 24))
                              {
                                v334 = nw_protocol_tcp_get_all_stats();
                                v333 = *(_DWORD *)(v122 + 92);
                                if (v334)
                                {
                                  *(_DWORD *)(v334 + 108) = *(_DWORD *)(v122 + 96) - v333;
                                  v333 = *(_DWORD *)(v122 + 92);
                                }
                              }
                              v335 = v122;
                              v336 = *(_DWORD *)(v122 + 100);
                              if (v336 - v333 < 0)
                              {
                                *(_DWORD *)(v122 + 100) = v333;
                                v336 = v333;
                              }
                              v337 = DWORD2(v922);
                              if (v336 - DWORD2(v922) >= 1)
                              {
                                if ((*(_BYTE *)(v122 + 743) & 1) == 0 && (*(_WORD *)(v122 + 990) & 0x40) != 0)
                                {
                                  v338 = *(_DWORD *)(v122 + 96);
                                  if (v338 == DWORD2(v922) + 1 && v338 > v333 + 1)
                                  {
                                    tcp_heuristic_tfo_middlebox(v122);
                                    *(_WORD *)(v15 + 378) = 96;
                                    user_north_signal_error(v15);
                                    *(_WORD *)(v122 + 990) |= 0x4000u;
                                    v337 = DWORD2(v922);
                                  }
                                }
                                v335 = v122;
                                *(_DWORD *)(v122 + 96) = v337;
                                *(_DWORD *)(v122 + 100) = v337;
                              }
                              if (*(_QWORD *)(v15 + 24))
                              {
                                v339 = nw_protocol_tcp_get_all_stats();
                                if (v339)
                                  *(_DWORD *)(v339 + 108) = *(_DWORD *)(v335 + 96) - *(_DWORD *)(v335 + 92);
                              }
                              *(_WORD *)(v335 + 304) += v825;
                              v340 = *(_DWORD *)(v335 + 740);
                              if ((v340 & 0x10000000) == 0
                                && ((v340 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
                              {
                                v341 = v823 ^ 1;
                                if ((~*(_DWORD *)(v335 + 348) & 0x300000) != 0)
                                  v341 = 1;
                                if ((v341 & 1) == 0)
                                  *(_WORD *)(v335 + 306) += v825;
                              }
                              v342 = *(uint64_t (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v335 + 264)]
                                                                                   + 96);
                              if (v342)
                              {
                                v343 = v342(v335, &v922);
                                v344 = *(_DWORD *)(v335 + 88);
                                if (v343 && v899)
                                {
                                  v345 = v122;
                                  if ((v344 & 2) == 0)
                                  {
                                    *(_DWORD *)(v122 + 88) = v344 | 2;
                                    *(_DWORD *)(v122 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v122 + 80) + 224))
                                                                       + 316)
                                                           - *(_DWORD *)(v122 + 64)
                                                           + 100;
                                  }
LABEL_847:
                                  *(_DWORD *)(v345 + 168) = *(_DWORD *)(v837 + 316);
                                  tcp_sbrcv_tstmp_check(v345);
                                  if ((*(_BYTE *)(v345 + 89) & 8) != 0)
                                  {
                                    *(_DWORD *)(v345 + 12) = 6;
                                    if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                    {
                                      if (__nwlog_is_datapath_logging_enabled())
                                      {
                                        v730 = __nwlog_tcp_log();
                                        if (os_log_type_enabled(v730, OS_LOG_TYPE_DEBUG))
                                        {
                                          v731 = tcpstates[*(int *)(v267 + 12)];
                                          v902 = "tcp_input";
                                          v732 = "";
                                          *(_DWORD *)buf = 136446722;
                                          if (v15)
                                            v732 = (const char *)(v15 + 604);
                                          v903 = 2082;
                                          *(_QWORD *)v904 = v732;
                                          *(_WORD *)&v904[8] = 2082;
                                          *(_QWORD *)v905 = v731;
                                          _os_log_impl(&dword_209FB3000, v730, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                        }
                                      }
                                    }
                                    if (*(_QWORD *)(v15 + 24))
                                    {
                                      v350 = nw_protocol_tcp_get_all_stats();
                                      if (v350)
                                        *(_DWORD *)(v350 + 136) = 6;
                                    }
                                    *(_DWORD *)(v267 + 88) &= ~0x800u;
                                    v883 &= ~2u;
                                  }
                                  else
                                  {
                                    *(_DWORD *)(v345 + 12) = 4;
                                    if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                    {
                                      if (__nwlog_is_datapath_logging_enabled())
                                      {
                                        v727 = __nwlog_tcp_log();
                                        if (os_log_type_enabled(v727, OS_LOG_TYPE_DEBUG))
                                        {
                                          v728 = tcpstates[*(int *)(v267 + 12)];
                                          v902 = "tcp_input";
                                          v729 = "";
                                          *(_DWORD *)buf = 136446722;
                                          if (v15)
                                            v729 = (const char *)(v15 + 604);
                                          v903 = 2082;
                                          *(_QWORD *)v904 = v729;
                                          *(_WORD *)&v904[8] = 2082;
                                          *(_QWORD *)v905 = v728;
                                          _os_log_impl(&dword_209FB3000, v727, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                        }
                                      }
                                    }
                                    if (*(_QWORD *)(v15 + 24))
                                    {
                                      v346 = nw_protocol_tcp_get_all_stats();
                                      if (v346)
                                        *(_DWORD *)(v346 + 136) = 4;
                                    }
                                    v347 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v267 + 80) + 224))
                                                     + 316);
                                    v348 = *(_DWORD *)(v267 + 676);
                                    if (!v348
                                      || (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v267 + 80) + 224) + 372) & 8) == 0)
                                    {
                                      v348 = *(_DWORD *)(sysctls + 192);
                                    }
                                    *(_DWORD *)(v267 + 40) = v348 + v347 - *(_DWORD *)(v267 + 64);
                                    if (*(_QWORD *)(v15 + 24))
                                    {
                                      v349 = nw_protocol_tcp_get_all_stats();
                                      if (v349)
                                        ++*(_DWORD *)(v349 + 64);
                                    }
                                  }
                                  v243 = v267;
                                  *(_WORD *)(v267 + 308) = 16;
                                  if ((*(_BYTE *)(v267 + 988) & 0xC) != 0 || (*(_WORD *)(v267 + 990) & 0x40) != 0)
                                  {
                                    tcp_tfo_synack(v267, (uint64_t)v896);
                                    v351 = *(_WORD *)(v267 + 990);
                                    if ((v351 & 0x40) == 0 || *(_DWORD *)(v267 + 92) - DWORD2(v922) >= 0)
                                    {
                                      v841 = 1;
                                      v243 = v267;
                                      goto LABEL_937;
                                    }
                                    *(_WORD *)(v267 + 990) = v351 | 0x80;
                                    v372 = *(_QWORD *)(v267 + 1056);
                                    if (v372)
                                      ++*(_QWORD *)(v372 + 1128);
                                    v243 = v267;
                                    tcp_tfo_rcv_probe(v267, v899);
                                  }
                                  v841 = 1;
LABEL_937:
                                  v16 = v820;
                                  v256 = v830;
                                  v253 = v883;
LABEL_938:
                                  if ((*(_WORD *)(v13 + 204) & 0x100) == 0
                                    || !*MEMORY[0x24BDE08C0]
                                    || (v373 = ((uint64_t (*)(uint64_t, _QWORD, __n128))*MEMORY[0x24BDE08C0])(v13, *(_QWORD *)(v13 + 88), (__n128)v221), v256 = v830, (v373 & 1) != 0))
                                  {
                                    v886 = v253;
                                    ++DWORD1(v922);
                                    if (&v922 != (__int128 *)v256)
                                      ++*(_DWORD *)(v256 + 4);
                                    v374 = v899;
                                    v375 = *(_DWORD *)(v243 + 128);
                                    v376 = v899 - v375;
                                    v819 = v16;
                                    if (v899 <= v375)
                                    {
LABEL_990:
                                      v409 = 0;
                                      v410 = 0;
                                      v847 = 0;
                                      v411 = DWORD1(v922);
                                      v412 = v839;
                                      *(_DWORD *)(v839 + 104) = DWORD1(v922) - 1;
                                      *(_DWORD *)(v839 + 136) = v411;
                                      v413 = v886;
                                      if ((v886 & 0x10) == 0)
                                        goto LABEL_1114;
LABEL_991:
                                      v883 = v413;
                                      v414 = DWORD2(v922) - *(_DWORD *)(v412 + 92);
                                      if (v414 >= 0)
                                      {
                                        v120 = v412;
                                        v415 = *(_QWORD *)(v412 + 1056);
                                        if (v415)
                                        {
                                          v416 = *(_QWORD *)(v415 + 168) + v414;
                                          ++*(_QWORD *)(v415 + 160);
                                          *(_QWORD *)(v415 + 168) = v416;
                                        }
                                        tcp_bad_rexmt_check(v412, (uint64_t)&v922, (uint64_t)v896);
                                        tcp_compute_rtt(v412, (uint64_t)v896, (uint64_t)&v922);
                                        v417 = 0;
                                        *(_WORD *)(v412 + 226) = 0;
                                        *(_DWORD *)(v412 + 248) = 0;
                                        if (*(int *)(v412 + 12) >= 4)
                                          v417 = *(_DWORD *)(sysctls + 176);
                                        v418 = *(unsigned int *)(v412 + 228);
                                        v419 = (*(_DWORD *)(v412 + 208) + (*(int *)(v412 + 200) >> 3)) >> 2;
                                        if (v418 > v419)
                                          v419 = *(_DWORD *)(v412 + 228);
                                        v420 = v419 + v417;
                                        *(_DWORD *)(v412 + 192) = v420;
                                        if (v420 >= v418)
                                        {
                                          if (v420 < 0xFA01)
                                            goto LABEL_1002;
                                          LODWORD(v418) = 64000;
                                        }
                                        *(_DWORD *)(v412 + 192) = v418;
LABEL_1002:
                                        if (DWORD2(v922) == *(_DWORD *)(v412 + 96))
                                        {
                                          *(_DWORD *)(v412 + 16) = 0;
                                          *(_QWORD *)(v412 + 24) = 0;
                                          *(_BYTE *)(v412 + 2069) &= ~0x80u;
                                          v847 = 1;
                                        }
                                        else
                                        {
                                          v847 = 0;
                                          if (!*(_DWORD *)(v412 + 36))
                                            *(_DWORD *)(v412 + 28) = *(_DWORD *)(v412 + 192)
                                                                   + *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v412 + 80) + 224))
                                                                               + 316)
                                                                   - *(_DWORD *)(v412 + 64);
                                        }
                                        if (!v414)
                                        {
LABEL_1111:
                                          v410 = 0;
                                          goto LABEL_1112;
                                        }
                                        if ((*(_DWORD *)(v412 + 740) & 0x20400020) == 0x20000020)
                                        {
                                          tcp_segs_doack(v412, DWORD2(v922), v896[0], SDWORD2(v896[0]));
                                          v438 = *(_DWORD *)(v412 + 560);
                                          v439 = v898;
                                          if (v438 - (int)v898 < 0)
                                          {
                                            *(_DWORD *)(v412 + 560) = v898;
                                            v438 = v439;
                                          }
                                          if (v438 - DWORD2(v922) < 0)
                                            *(_DWORD *)(v412 + 560) = DWORD2(v922);
                                        }
                                        if ((*(_WORD *)(v412 + 990) & 0x40) != 0
                                          && (*(_BYTE *)(v412 + 988) & 0x20) == 0
                                          && (BYTE13(v922) & 2) == 0)
                                        {
                                          *(_BYTE *)(v412 + 988) |= 0x20u;
                                        }
                                        v440 = *(_DWORD *)(v412 + 348);
                                        if ((v440 & 4) != 0)
                                        {
                                          v444 = *(_DWORD *)(v412 + 740);
                                          if ((v444 & 0x10000000) == 0
                                            && ((v444 & 0x8000000) != 0
                                             || *(_DWORD *)(sysctls + 320) == 1
                                             || tcp_do_acc_ecn == 1)
                                            && (v413 & 2) == 0
                                            && (v440 & 0x300000) == 0x300000)
                                          {
                                            v479 = 0;
                                            v480 = DWORD2(v922);
                                            v481 = *(_DWORD *)(v412 + 112) + 1;
                                            if (DWORD2(v922) == v481)
                                              v414 = 0;
                                            v482 = *(_DWORD *)(v412 + 196);
                                            if (v414 / v482 * v482 == v414)
                                              v483 = v414 / v482;
                                            else
                                              v483 = v414 / v482 + 1;
                                            *(_DWORD *)(v412 + 296) += v483;
                                            if (v480 == v481 && !HIDWORD(v898))
                                            {
                                              v479 = 0;
                                              if ((v896[0] & 1) != 0)
                                              {
                                                if (DWORD2(v896[0]))
                                                {
                                                  v484 = *(_DWORD *)(v412 + 400);
                                                  if (v484)
                                                    v485 = DWORD2(v896[0]) - v484 <= 0;
                                                  else
                                                    v485 = 0;
                                                  v479 = !v485;
                                                }
                                              }
                                            }
                                            if (v414 || HIDWORD(v898) || v479)
                                              tcp_process_accecn(v412, (uint64_t)v896, (uint64_t)&v922, v483, v821);
                                            else
                                              v414 = 0;
                                          }
                                          else if ((v413 & 0x40) != 0
                                                 && (*(_DWORD *)(v412 + 348) & 3) == 3
                                                 && (*(_BYTE *)(v412 + 90) & 0x20) == 0)
                                          {
                                            tcp_enter_fast_recovery(v412);
                                            *(_DWORD *)(v412 + 348) |= 0xA8u;
                                            v445 = *(_QWORD *)(a3 + 448);
                                            if (v445)
                                            {
                                              v446 = 576;
                                              if ((*(_BYTE *)(a3 + 2236) & 2) == 0)
                                                v446 = 192;
                                              ++*(_QWORD *)(v445 + v446);
                                            }
                                            v447 = *(_QWORD *)(v412 + 1056);
                                            if (v447)
                                              ++*(_QWORD *)(v447 + 864);
                                            ++*(_QWORD *)(v412 + 384);
                                          }
                                        }
                                        if (!(*(_DWORD *)(v412 + 88) & 0x200000 | v409))
                                        {
                                          v441 = *(void (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v412 + 264)]
                                                                                            + 56);
                                          if (v441)
                                            v441(v412, &v922);
                                        }
                                        v442 = *(_DWORD *)(v15 + 384);
                                        if (v414 <= v442)
                                        {
                                          sbdrop((int *)(v15 + 384), v414);
                                          tcp_sbsnd_trim(v15 + 384);
                                          v122 = v120;
                                          *(_DWORD *)(v120 + 140) -= v414;
                                          if (*(_QWORD *)(v15 + 24))
                                          {
                                            v448 = nw_protocol_tcp_get_all_stats();
                                            if (v448)
                                              *(_DWORD *)(v448 + 112) = *(_DWORD *)(v120 + 140);
                                          }
                                        }
                                        else
                                        {
                                          *(_DWORD *)(v120 + 140) -= v442;
                                          if (*(_QWORD *)(v15 + 24))
                                          {
                                            v443 = nw_protocol_tcp_get_all_stats();
                                            if (v443)
                                              *(_DWORD *)(v443 + 112) = *(_DWORD *)(v120 + 140);
                                          }
                                          sbdrop((int *)(v15 + 384), *(_DWORD *)(v15 + 384));
                                          v122 = v120;
                                        }
                                        v449 = *(_DWORD *)(v122 + 88);
                                        v450 = *(_DWORD *)(v122 + 152);
                                        if ((v449 & 0x200000) != 0)
                                        {
                                          v451 = DWORD2(v922);
                                          if (DWORD2(v922) - v450 < 0)
                                            goto LABEL_1066;
                                          *(_DWORD *)(v122 + 88) = v449 & 0xFFDFFFFF;
                                          *(_DWORD *)(v122 + 8) = 0;
                                          *(_BYTE *)(v122 + 310) = 3;
                                          *(_DWORD *)(v122 + 288) = 0;
                                          *(_DWORD *)(v122 + 348) &= ~0x20u;
                                          *(_DWORD *)(v122 + 16) = 0;
                                          v452 = *(_DWORD *)(v122 + 740);
                                          *(_DWORD *)(v122 + 740) = v452 & 0xFFF7FFFF;
                                          *(_DWORD *)(v122 + 984) = 0;
                                          *(_DWORD *)(v122 + 628) = 0;
                                          if ((v452 & 0x20400020) == 0x20000020
                                            && (*(_BYTE *)(v120 + 2069) & 0x1F) != 0)
                                          {
                                            v122 = v120;
                                            *(_BYTE *)(v120 + 2069) = *(_BYTE *)(v120 + 2069) & 0xE0 | (*(_BYTE *)(v120 + 2069) - 1) & 0x1F;
                                            goto LABEL_1066;
                                          }
                                        }
                                        else
                                        {
                                          v451 = DWORD2(v922);
                                          if (*(_DWORD *)(v122 + 92) - v450 >= 1 && DWORD2(v922) - v450 <= 0)
                                          {
                                            v122 = v120;
                                            *(_DWORD *)(v120 + 152) = DWORD2(v922) - 1;
                                            goto LABEL_1066;
                                          }
                                        }
                                        v122 = v120;
LABEL_1066:
                                        tcp_update_snd_una(v122, v451);
                                        v453 = *(_DWORD *)(v122 + 740);
                                        v454 = *(_DWORD *)(v122 + 92);
                                        if ((v453 & 0x20) != 0 && v454 - *(_DWORD *)(v122 + 152) >= 1)
                                          *(_DWORD *)(v122 + 152) = v454;
                                        if (*(_DWORD *)(v122 + 100) - v454 < 0)
                                          *(_DWORD *)(v122 + 100) = v454;
                                        if ((v453 & 0x20400020) == 0x20000020
                                          && tcp_rack_detect_loss_and_arm_timer(v122, 0))
                                        {
                                          if ((*(_BYTE *)(v122 + 90) & 0x20) == 0)
                                          {
                                            tcp_enter_fast_recovery(v120);
                                            v455 = *(_QWORD *)(v120 + 1056);
                                            if (v455)
                                              ++*(_QWORD *)(v455 + 624);
                                            ++*(_DWORD *)(v120 + 1008);
                                          }
                                          v122 = v120;
                                          tcp_output(v120);
                                        }
                                        if (*(_QWORD *)(v122 + 952))
                                        {
                                          v456 = *(_DWORD *)(v122 + 960);
                                          if (v456 - *(_DWORD *)(v122 + 96) > 0)
                                            goto LABEL_1080;
                                          v457 = *(_DWORD *)(v122 + 140);
                                          if (v457 >= *(_DWORD *)(sysctls + 120))
                                            v457 = *(_DWORD *)(sysctls + 120);
                                          if ((int)(v456 - *(_DWORD *)(v122 + 92) + v457) < 0)
LABEL_1080:
                                            tcp_rxtseg_clean(v122);
                                        }
                                        if ((*(_BYTE *)(v122 + 740) & 8) != 0 && *(_QWORD *)(v122 + 768))
                                          tcp_bwmeas_check(v122);
                                        v458 = *(void (***)(uint64_t))(v15 + 32);
                                        if (v458)
                                        {
                                          v459 = *v458;
                                          if (v459)
                                            v459(v15);
                                        }
                                        v410 = 0;
                                        v460 = *(_DWORD *)(v122 + 12);
                                        switch(v460)
                                        {
                                          case 6:
                                            if (v414 <= v442)
                                              goto LABEL_1111;
                                            *(_DWORD *)(v120 + 12) = 9;
                                            if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                            {
                                              if (__nwlog_is_datapath_logging_enabled())
                                              {
                                                v764 = __nwlog_tcp_log();
                                                if (os_log_type_enabled(v764, OS_LOG_TYPE_DEBUG))
                                                {
                                                  v765 = tcpstates[*(int *)(v120 + 12)];
                                                  v902 = "tcp_input";
                                                  v766 = "";
                                                  *(_DWORD *)buf = 136446722;
                                                  if (v15)
                                                    v766 = (const char *)(v15 + 604);
                                                  v903 = 2082;
                                                  *(_QWORD *)v904 = v766;
                                                  *(_WORD *)&v904[8] = 2082;
                                                  *(_QWORD *)v905 = v765;
                                                  _os_log_impl(&dword_209FB3000, v764, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                }
                                              }
                                            }
                                            if (*(_QWORD *)(v15 + 24))
                                            {
                                              v461 = nw_protocol_tcp_get_all_stats();
                                              if (v461)
                                                *(_DWORD *)(v461 + 136) = 9;
                                            }
                                            if ((*(_WORD *)(v15 + 376) & 0x20) != 0)
                                            {
                                              tcp_set_finwait_timeout(v120);
                                              v841 = 0;
LABEL_1214:
                                              v410 = 1;
                                            }
                                            else
                                            {
                                              v410 = 0;
                                            }
                                            v460 = *(_DWORD *)(v120 + 12);
LABEL_1216:
                                            if (v460 != 4)
                                              goto LABEL_1112;
                                            if ((*(_DWORD *)(v120 + 740) & 0x20) == 0)
                                              goto LABEL_1112;
                                            if (!HIDWORD(v898))
                                              goto LABEL_1112;
                                            if (!HIBYTE(v896[0]))
                                              goto LABEL_1112;
                                            if (*(_DWORD *)(v120 + 8))
                                              goto LABEL_1112;
                                            if (DWORD2(v922) - *(_DWORD *)(v120 + 92) > 0)
                                              goto LABEL_1112;
                                            v835 = v899;
                                            if (v899 | *(_DWORD *)(v120 + 740) & 0x2000)
                                              goto LABEL_1112;
                                            v499 = *(_QWORD *)(v120 + 1056);
                                            if (v499)
                                              ++*(_QWORD *)(v499 + 704);
                                            v412 = v120;
                                            break;
                                          case 7:
                                            if (v414 <= v442)
                                              goto LABEL_1111;
                                            *(_DWORD *)(v120 + 12) = 10;
                                            if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                            {
                                              if (__nwlog_is_datapath_logging_enabled())
                                              {
                                                v767 = __nwlog_tcp_log();
                                                if (os_log_type_enabled(v767, OS_LOG_TYPE_DEBUG))
                                                {
                                                  v768 = tcpstates[*(int *)(v120 + 12)];
                                                  v902 = "tcp_input";
                                                  v769 = "";
                                                  *(_DWORD *)buf = 136446722;
                                                  if (v15)
                                                    v769 = (const char *)(v15 + 604);
                                                  v903 = 2082;
                                                  *(_QWORD *)v904 = v769;
                                                  *(_WORD *)&v904[8] = 2082;
                                                  *(_QWORD *)v905 = v768;
                                                  _os_log_impl(&dword_209FB3000, v767, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                }
                                              }
                                            }
                                            if (*(_QWORD *)(v15 + 24))
                                            {
                                              v462 = nw_protocol_tcp_get_all_stats();
                                              if (v462)
                                                *(_DWORD *)(v462 + 136) = 10;
                                            }
                                            tcp_canceltimers(v120);
                                            if ((*(_BYTE *)(v120 + 741) & 8) != 0)
                                            {
                                              v841 = 0;
                                              *(_DWORD *)(v120 + 88) |= 0x8000000u;
                                            }
                                            else
                                            {
                                              add_to_time_wait(v120, 2 * *(_DWORD *)(sysctls + 204));
                                              v841 = 0;
                                            }
                                            goto LABEL_1214;
                                          case 8:
                                            if (v414 <= v442)
                                              goto LABEL_1111;
                                            if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                            {
                                              if (__nwlog_is_datapath_logging_enabled())
                                              {
                                                v761 = __nwlog_tcp_log();
                                                if (os_log_type_enabled(v761, OS_LOG_TYPE_DEBUG))
                                                {
                                                  v762 = tcpstates[*(int *)(v120 + 12)];
                                                  v902 = "tcp_input";
                                                  v763 = "";
                                                  *(_DWORD *)buf = 136446722;
                                                  if (v15)
                                                    v763 = (const char *)(v15 + 604);
                                                  v903 = 2082;
                                                  *(_QWORD *)v904 = v763;
                                                  *(_WORD *)&v904[8] = 2082;
                                                  *(_QWORD *)v905 = v762;
                                                  _os_log_impl(&dword_209FB3000, v761, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s ourfinisacked t_state %{public}s", buf, 0x20u);
                                                }
                                              }
                                            }
                                            tcp_close(v120);
                                            goto LABEL_1291;
                                          case 10:
                                            add_to_time_wait(v122, 2 * *(_DWORD *)(sysctls + 204));
                                            v44 = a1;
                                            v43 = v892;
                                            goto LABEL_1170;
                                          default:
                                            goto LABEL_1216;
                                        }
                                        goto LABEL_1226;
                                      }
                                      v421 = v374;
                                      if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                      {
                                        __nwlog_tcp_log();
                                        if (v15)
                                          v422 = (const char *)(v15 + 604);
                                        else
                                          v422 = "";
                                        v423 = *(_DWORD *)(v412 + 12);
                                        v424 = *(_DWORD *)(v412 + 120);
                                        v425 = *(_DWORD *)(v412 + 92);
                                        *(_DWORD *)buf = 136449026;
                                        v902 = "tcp_input";
                                        v903 = 2082;
                                        *(_QWORD *)v904 = v422;
                                        *(_WORD *)&v904[8] = 1024;
                                        *(_DWORD *)v905 = bswap32((unsigned __int16)v922) >> 16;
                                        *(_WORD *)&v905[4] = 1024;
                                        *(_DWORD *)&v905[6] = bswap32(WORD1(v922)) >> 16;
                                        v906 = 1024;
                                        *(_DWORD *)v907 = v421;
                                        *(_WORD *)&v907[4] = 1024;
                                        *(_DWORD *)&v907[6] = BYTE13(v922);
                                        v908 = 1024;
                                        v909 = bswap32(DWORD1(v922));
                                        v910 = 1024;
                                        v911 = bswap32(DWORD2(v922));
                                        v912 = 1024;
                                        v913 = bswap32(HIWORD(v922)) >> 16;
                                        v914 = 1024;
                                        v915 = v423;
                                        v916 = 1024;
                                        v917 = v424;
                                        v918 = 1024;
                                        v919 = v425;
                                        v426 = (void *)_os_log_send_and_compose_impl();
                                        type[0] = OS_LOG_TYPE_ERROR;
                                        v900 = 0;
                                        v44 = a1;
                                        if (__nwlog_fault())
                                        {
                                          if (type[0] == OS_LOG_TYPE_FAULT)
                                          {
                                            v427 = __nwlog_tcp_log();
                                            v428 = type[0];
                                            if (!os_log_type_enabled(v427, type[0]))
                                              goto LABEL_1200;
                                            v429 = *(_DWORD *)(v412 + 12);
                                            v430 = *(_DWORD *)(v412 + 120);
                                            v431 = *(_DWORD *)(v412 + 92);
                                            *(_DWORD *)buf = 136449026;
                                            v902 = "tcp_input";
                                            v903 = 2082;
                                            *(_QWORD *)v904 = v422;
                                            *(_WORD *)&v904[8] = 1024;
                                            *(_DWORD *)v905 = bswap32((unsigned __int16)v922) >> 16;
                                            *(_WORD *)&v905[4] = 1024;
                                            *(_DWORD *)&v905[6] = bswap32(WORD1(v922)) >> 16;
                                            v906 = 1024;
                                            *(_DWORD *)v907 = v899;
                                            *(_WORD *)&v907[4] = 1024;
                                            *(_DWORD *)&v907[6] = BYTE13(v922);
                                            v908 = 1024;
                                            v909 = bswap32(DWORD1(v922));
                                            v910 = 1024;
                                            v911 = bswap32(DWORD2(v922));
                                            v912 = 1024;
                                            v913 = bswap32(HIWORD(v922)) >> 16;
                                            v914 = 1024;
                                            v915 = v429;
                                            v916 = 1024;
                                            v917 = v430;
                                            v918 = 1024;
                                            v919 = v431;
                                            v432 = "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, tp->"
                                                   "snd_una) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack=%u, w"
                                                   "in=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u";
                                            goto LABEL_1199;
                                          }
                                          if (!v900)
                                          {
                                            v427 = __nwlog_tcp_log();
                                            v428 = type[0];
                                            if (!os_log_type_enabled(v427, type[0]))
                                              goto LABEL_1200;
                                            v476 = *(_DWORD *)(v412 + 12);
                                            v477 = *(_DWORD *)(v412 + 120);
                                            v478 = *(_DWORD *)(v412 + 92);
                                            *(_DWORD *)buf = 136449026;
                                            v902 = "tcp_input";
                                            v903 = 2082;
                                            *(_QWORD *)v904 = v422;
                                            *(_WORD *)&v904[8] = 1024;
                                            *(_DWORD *)v905 = bswap32((unsigned __int16)v922) >> 16;
                                            *(_WORD *)&v905[4] = 1024;
                                            *(_DWORD *)&v905[6] = bswap32(WORD1(v922)) >> 16;
                                            v906 = 1024;
                                            *(_DWORD *)v907 = v899;
                                            *(_WORD *)&v907[4] = 1024;
                                            *(_DWORD *)&v907[6] = BYTE13(v922);
                                            v908 = 1024;
                                            v909 = bswap32(DWORD1(v922));
                                            v910 = 1024;
                                            v911 = bswap32(DWORD2(v922));
                                            v912 = 1024;
                                            v913 = bswap32(HIWORD(v922)) >> 16;
                                            v914 = 1024;
                                            v915 = v476;
                                            v916 = 1024;
                                            v917 = v477;
                                            v918 = 1024;
                                            v919 = v478;
                                            v432 = "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, tp->"
                                                   "snd_una) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack=%u, w"
                                                   "in=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u, backtrace limit exceeded";
                                            goto LABEL_1199;
                                          }
                                          v433 = (void *)__nw_create_backtrace_string();
                                          v427 = __nwlog_tcp_log();
                                          v428 = type[0];
                                          v434 = os_log_type_enabled(v427, type[0]);
                                          if (v433)
                                          {
                                            if (v434)
                                            {
                                              v435 = *(_DWORD *)(v412 + 12);
                                              v436 = *(_DWORD *)(v412 + 120);
                                              v437 = *(_DWORD *)(v412 + 92);
                                              *(_DWORD *)buf = 136449282;
                                              v902 = "tcp_input";
                                              v903 = 2082;
                                              *(_QWORD *)v904 = v422;
                                              *(_WORD *)&v904[8] = 1024;
                                              *(_DWORD *)v905 = bswap32((unsigned __int16)v922) >> 16;
                                              *(_WORD *)&v905[4] = 1024;
                                              *(_DWORD *)&v905[6] = bswap32(WORD1(v922)) >> 16;
                                              v906 = 1024;
                                              *(_DWORD *)v907 = v899;
                                              *(_WORD *)&v907[4] = 1024;
                                              *(_DWORD *)&v907[6] = BYTE13(v922);
                                              v908 = 1024;
                                              v909 = bswap32(DWORD1(v922));
                                              v910 = 1024;
                                              v911 = bswap32(DWORD2(v922));
                                              v912 = 1024;
                                              v913 = bswap32(HIWORD(v922)) >> 16;
                                              v914 = 1024;
                                              v915 = v435;
                                              v916 = 1024;
                                              v917 = v436;
                                              v918 = 1024;
                                              v919 = v437;
                                              v920 = 2082;
                                              v921 = v433;
                                              _os_log_impl(&dword_209FB3000, v427, type[0], "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, tp->snd_una) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u, dumping backtrace:%{public}s", buf, 0x5Cu);
                                            }
                                            free(v433);
                                            goto LABEL_1200;
                                          }
                                          if (v434)
                                          {
                                            v487 = *(_DWORD *)(v412 + 12);
                                            v488 = *(_DWORD *)(v412 + 120);
                                            v489 = *(_DWORD *)(v412 + 92);
                                            *(_DWORD *)buf = 136449026;
                                            v902 = "tcp_input";
                                            v903 = 2082;
                                            *(_QWORD *)v904 = v422;
                                            *(_WORD *)&v904[8] = 1024;
                                            *(_DWORD *)v905 = bswap32((unsigned __int16)v922) >> 16;
                                            *(_WORD *)&v905[4] = 1024;
                                            *(_DWORD *)&v905[6] = bswap32(WORD1(v922)) >> 16;
                                            v906 = 1024;
                                            *(_DWORD *)v907 = v899;
                                            *(_WORD *)&v907[4] = 1024;
                                            *(_DWORD *)&v907[6] = BYTE13(v922);
                                            v908 = 1024;
                                            v909 = bswap32(DWORD1(v922));
                                            v910 = 1024;
                                            v911 = bswap32(DWORD2(v922));
                                            v912 = 1024;
                                            v913 = bswap32(HIWORD(v922)) >> 16;
                                            v914 = 1024;
                                            v915 = v487;
                                            v916 = 1024;
                                            v917 = v488;
                                            v918 = 1024;
                                            v919 = v489;
                                            v432 = "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, tp->"
                                                   "snd_una) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack=%u, w"
                                                   "in=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u, no backtrace";
LABEL_1199:
                                            _os_log_impl(&dword_209FB3000, v427, v428, v432, buf, 0x52u);
                                          }
                                        }
LABEL_1200:
                                        if (v426)
                                          free(v426);
LABEL_1202:
                                        v43 = v892;
                                        goto LABEL_1292;
                                      }
LABEL_1291:
                                      v44 = a1;
                                      v43 = v892;
                                      goto LABEL_1292;
                                    }
                                    v377 = (_QWORD *)*v44;
                                    v846 = v899 - v375;
                                    if (*v44)
                                    {
                                      if ((*((_WORD *)v377 + 102) & 0x80) != 0)
                                      {
                                        v378 = *((unsigned __int16 *)v377 + 98);
                                        if (v376 > v378)
                                        {
                                          v833 = v899;
                                          v379 = v44;
                                          v380 = v899 - v375;
                                          __nwlog_obj();
                                          v381 = *((unsigned __int16 *)v377 + 98);
                                          *(_DWORD *)buf = 136446722;
                                          v902 = "__nw_frame_array_claim";
                                          v903 = 1024;
                                          *(_DWORD *)v904 = v381;
                                          *(_WORD *)&v904[4] = 1024;
                                          *(_DWORD *)&v904[6] = v380;
                                          v382 = _os_log_send_and_compose_impl();
                                          type[0] = OS_LOG_TYPE_ERROR;
                                          v900 = 0;
                                          v383 = (void *)v382;
                                          if (__nwlog_fault())
                                          {
                                            if (type[0] == OS_LOG_TYPE_FAULT)
                                            {
                                              v384 = __nwlog_obj();
                                              v385 = type[0];
                                              if (os_log_type_enabled(v384, type[0]))
                                              {
                                                v386 = *((unsigned __int16 *)v377 + 98);
                                                *(_DWORD *)buf = 136446722;
                                                v902 = "__nw_frame_array_claim";
                                                v903 = 1024;
                                                *(_DWORD *)v904 = v386;
                                                *(_WORD *)&v904[4] = 1024;
                                                *(_DWORD *)&v904[6] = v846;
                                                v387 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_961:
                                                v392 = v384;
LABEL_962:
                                                _os_log_impl(&dword_209FB3000, v392, v385, v387, buf, 0x18u);
                                              }
                                            }
                                            else if (v900)
                                            {
                                              v388 = (void *)__nw_create_backtrace_string();
                                              v385 = type[0];
                                              v813 = __nwlog_obj();
                                              v389 = os_log_type_enabled(v813, type[0]);
                                              if (v388)
                                              {
                                                if (v389)
                                                {
                                                  v390 = *((unsigned __int16 *)v377 + 98);
                                                  *(_DWORD *)buf = 136446978;
                                                  v902 = "__nw_frame_array_claim";
                                                  v903 = 1024;
                                                  *(_DWORD *)v904 = v390;
                                                  *(_WORD *)&v904[4] = 1024;
                                                  *(_DWORD *)&v904[6] = v846;
                                                  *(_WORD *)v905 = 2082;
                                                  *(_QWORD *)&v905[2] = v388;
                                                  _os_log_impl(&dword_209FB3000, v813, type[0], "%{public}s Aggregate buffer length: %u sum: %u, dumping backtrace:%{public}s", buf, 0x22u);
                                                }
                                                free(v388);
                                                goto LABEL_963;
                                              }
                                              if (v389)
                                              {
                                                v498 = *((unsigned __int16 *)v377 + 98);
                                                *(_DWORD *)buf = 136446722;
                                                v902 = "__nw_frame_array_claim";
                                                v903 = 1024;
                                                *(_DWORD *)v904 = v498;
                                                *(_WORD *)&v904[4] = 1024;
                                                *(_DWORD *)&v904[6] = v846;
                                                v387 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                                                v392 = v813;
                                                goto LABEL_962;
                                              }
                                            }
                                            else
                                            {
                                              v384 = __nwlog_obj();
                                              v385 = type[0];
                                              if (os_log_type_enabled(v384, type[0]))
                                              {
                                                v391 = *((unsigned __int16 *)v377 + 98);
                                                *(_DWORD *)buf = 136446722;
                                                v902 = "__nw_frame_array_claim";
                                                v903 = 1024;
                                                *(_DWORD *)v904 = v391;
                                                *(_WORD *)&v904[4] = 1024;
                                                *(_DWORD *)&v904[6] = v846;
                                                v387 = "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded";
                                                goto LABEL_961;
                                              }
                                            }
                                          }
LABEL_963:
                                          if (v383)
                                            free(v383);
                                          *((_WORD *)v377 + 98) = 0;
                                          v44 = v379;
                                          v120 = 0x253CF8000;
                                          v374 = v833;
                                          v376 = v846;
                                          goto LABEL_966;
                                        }
                                        *((_WORD *)v377 + 98) = v378 - v376;
                                      }
LABEL_952:
                                      if (v374 == v375)
                                      {
LABEL_988:
                                        v374 = *(_DWORD *)(v839 + 128);
                                        v899 = v374;
                                        v886 &= ~1u;
                                        v407 = *(_QWORD *)(v839 + 1056);
                                        if (v407)
                                        {
                                          v408 = *(_QWORD *)(v407 + 280) + (int)v376;
                                          ++*(_QWORD *)(v407 + 272);
                                          *(_QWORD *)(v407 + 280) = v408;
                                        }
                                        goto LABEL_990;
                                      }
LABEL_966:
                                      v393 = 0;
                                      v394 = **(_QWORD **)(v44[1] + 8);
                                      if (!v394 || v374 == v375)
                                      {
LABEL_985:
                                        if (v393 != v376)
                                        {
                                          v405 = __nwlog_obj();
                                          v406 = os_log_type_enabled(v405, OS_LOG_TYPE_ERROR);
                                          v376 = v846;
                                          if (v406)
                                          {
                                            *(_DWORD *)buf = 136446722;
                                            v902 = "__nw_frame_array_claim";
                                            v903 = 1024;
                                            *(_DWORD *)v904 = v393;
                                            *(_WORD *)&v904[4] = 1024;
                                            *(_DWORD *)&v904[6] = v846;
                                            _os_log_impl(&dword_209FB3000, v405, OS_LOG_TYPE_ERROR, "%{public}s end_offset %u != end_bytes %u", buf, 0x18u);
                                            v376 = v846;
                                          }
                                        }
                                      }
                                      else
                                      {
                                        v393 = 0;
                                        while (1)
                                        {
                                          v395 = *(_DWORD *)(v394 + 52);
                                          v396 = *(_DWORD *)(v394 + 56);
                                          v397 = *(_DWORD *)(v394 + 60);
                                          v398 = v395 - (v396 + v397);
                                          if (v398 >= v376 - v393)
                                            v398 = v376 - v393;
                                          v399 = v395 ? v398 : 0;
                                          v400 = v397 + v399;
                                          if (v396 <= v395 - (v397 + v399))
                                          {
                                            *(_DWORD *)(v394 + 60) = v400;
                                          }
                                          else
                                          {
                                            v401 = __nwlog_obj();
                                            v402 = os_log_type_enabled(v401, OS_LOG_TYPE_ERROR);
                                            v376 = v846;
                                            if (v402)
                                            {
                                              v403 = *(_DWORD *)(v394 + 52);
                                              *(_DWORD *)buf = 136446978;
                                              v902 = "__nw_frame_claim_internal";
                                              v903 = 1024;
                                              *(_DWORD *)v904 = v396;
                                              *(_WORD *)&v904[4] = 1024;
                                              *(_DWORD *)&v904[6] = v403;
                                              *(_WORD *)v905 = 1024;
                                              *(_DWORD *)&v905[2] = v400;
                                              _os_log_impl(&dword_209FB3000, v401, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
                                              v376 = v846;
                                            }
                                          }
                                          v393 += v399;
                                          v120 = 0x253CF8000;
                                          if (v393 == v376)
                                            break;
                                          if (*(_OWORD *)(v394 + 32) != 0)
                                          {
                                            v394 = **(_QWORD **)(*(_QWORD *)(v394 + 40) + 8);
                                            if (v394 && v393 < v376)
                                              continue;
                                          }
                                          goto LABEL_985;
                                        }
                                      }
                                      goto LABEL_988;
                                    }
                                    v836 = v899;
                                    v658 = v44;
                                    __nwlog_obj();
                                    *(_DWORD *)buf = 136446210;
                                    v902 = "__nw_frame_is_single_ip_aggregate";
                                    v659 = (void *)_os_log_send_and_compose_impl();
                                    type[0] = OS_LOG_TYPE_ERROR;
                                    v900 = 0;
                                    if (__nwlog_fault())
                                    {
                                      if (type[0] == OS_LOG_TYPE_FAULT)
                                      {
                                        v660 = __nwlog_obj();
                                        v661 = type[0];
                                        if (os_log_type_enabled(v660, type[0]))
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          v902 = "__nw_frame_is_single_ip_aggregate";
                                          v662 = "%{public}s called with null frame";
LABEL_1881:
                                          v720 = v660;
                                          v721 = v661;
LABEL_1882:
                                          _os_log_impl(&dword_209FB3000, v720, v721, v662, buf, 0xCu);
                                        }
                                      }
                                      else if (v900)
                                      {
                                        v672 = (void *)__nw_create_backtrace_string();
                                        v814 = __nwlog_obj();
                                        v673 = os_log_type_enabled(v814, type[0]);
                                        if (v672)
                                        {
                                          if (v673)
                                          {
                                            *(_DWORD *)buf = 136446466;
                                            v902 = "__nw_frame_is_single_ip_aggregate";
                                            v903 = 2082;
                                            *(_QWORD *)v904 = v672;
                                            _os_log_impl(&dword_209FB3000, v814, type[0], "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                                          }
                                          free(v672);
                                          goto LABEL_1883;
                                        }
                                        if (v673)
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          v902 = "__nw_frame_is_single_ip_aggregate";
                                          v662 = "%{public}s called with null frame, no backtrace";
                                          v720 = v814;
                                          v721 = type[0];
                                          goto LABEL_1882;
                                        }
                                      }
                                      else
                                      {
                                        v660 = __nwlog_obj();
                                        v661 = type[0];
                                        if (os_log_type_enabled(v660, type[0]))
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          v902 = "__nw_frame_is_single_ip_aggregate";
                                          v662 = "%{public}s called with null frame, backtrace limit exceeded";
                                          goto LABEL_1881;
                                        }
                                      }
                                    }
LABEL_1883:
                                    if (v659)
                                      free(v659);
                                    v44 = v658;
                                    v374 = v836;
                                    v376 = v846;
                                    goto LABEL_952;
                                  }
                                  v640 = v243;
                                  v641 = v15;
                                  if ((*(_BYTE *)(v15 + 828) & 2) != 0)
                                    goto LABEL_1685;
                                  v642 = __nwlog_tcp_log();
                                  if (!os_log_type_enabled(v642, OS_LOG_TYPE_INFO))
                                    goto LABEL_1685;
                                  v643 = "";
                                  if (v15)
                                    v643 = (const char *)(v15 + 604);
                                  goto LABEL_1684;
                                }
                              }
                              else
                              {
                                v344 = *(_DWORD *)(v335 + 88);
                              }
                              v345 = v122;
                              *(_DWORD *)(v122 + 88) = v344 | 1;
                              goto LABEL_847;
                            case 3:
                              if ((v883 & 0x10) != 0
                                && (DWORD2(v922) - *(_DWORD *)(v122 + 92) < 1
                                 || DWORD2(v922) - *(_DWORD *)(v122 + 96) > 0))
                              {
                                goto LABEL_645;
                              }
                              if ((v883 & 2) != 0 && *(_DWORD *)(v122 + 116) == DWORD1(v922) && (v896[0] & 0x20) == 0)
                                *(_DWORD *)(v122 + 88) &= ~0x40u;
LABEL_584:
                              if ((v883 & 4) == 0)
                              {
                                if ((v896[0] & 1) == 0
                                  || (v231 = *(_DWORD *)(v122 + 276)) == 0
                                  || DWORD1(v896[0]) - v231 >= 0)
                                {
LABEL_590:
                                  v232 = v830;
                                  if (v229 == 3 && DWORD1(v922) - *(_DWORD *)(v122 + 116) < 0)
                                  {
LABEL_645:
                                    v132 = v824;
                                    goto LABEL_277;
                                  }
                                  if ((*(_WORD *)(v13 + 204) & 0x100) != 0 && *MEMORY[0x24BDE08C0])
                                  {
                                    if (!((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v13, *(_QWORD *)(v13 + 88)))
                                    {
                                      v640 = v122;
                                      v641 = v15;
                                      if ((*(_BYTE *)(v15 + 828) & 2) != 0)
                                        goto LABEL_1685;
                                      v642 = __nwlog_tcp_log();
                                      if (!os_log_type_enabled(v642, OS_LOG_TYPE_INFO))
                                        goto LABEL_1685;
                                      v643 = "";
                                      if (v15)
                                        v643 = (const char *)(v15 + 604);
LABEL_1684:
                                      *(_DWORD *)buf = 136446466;
                                      v902 = "tcp_input";
                                      v903 = 2082;
                                      *(_QWORD *)v904 = v643;
                                      _os_log_impl(&dword_209FB3000, v642, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping tcp input frame since frame is no longer valid", buf, 0x16u);
LABEL_1685:
                                      *(_QWORD *)(v640 + 1056) = 0;
                                      goto LABEL_1686;
                                    }
                                    v227 = *(_DWORD *)(v122 + 120);
                                    v232 = v830;
                                  }
                                  v233 = v227 - DWORD1(v922);
                                  v234 = v848;
                                  v819 = v16;
                                  if (v227 - DWORD1(v922) <= 0)
                                  {
                                    v264 = v899;
                                    v131 = v883;
                                    v43 = v892;
LABEL_727:
                                    if ((_DWORD)v264)
                                    {
                                      v288 = *(_DWORD *)(v15 + 364);
                                      v289 = (v288 & 0x1000000) == 0
                                          && (*(_WORD *)(v15 + 376) & 1) != 0
                                          && *(_DWORD *)(v122 + 12) > 5;
                                      if ((v288 & 8) != 0 && *(int *)(v122 + 12) > 6)
                                        v289 = 1;
                                      if (*(_WORD *)(v15 + 376) & 0x20 | v289)
                                      {
                                        v298 = *(_QWORD *)(v122 + 1056);
                                        if (v298)
                                          ++*(_QWORD *)(v298 + 304);
                                        tcp_close(v122);
                                        v132 = v824;
                                        goto LABEL_278;
                                      }
                                    }
                                    v290 = DWORD1(v922);
                                    v291 = *(_DWORD *)(v122 + 120);
                                    v292 = *(_DWORD *)(v122 + 128);
                                    v293 = DWORD1(v922) + v264 - (v291 + v292);
                                    LODWORD(v848) = v234;
                                    v817 = v18;
                                    v815 = a3;
                                    if (v293 < 1)
                                      goto LABEL_1273;
                                    v294 = *(_QWORD **)(v122 + 1056);
                                    v885 = DWORD1(v922) + v264 - (v291 + v292);
                                    v295 = v131;
                                    if (v294)
                                    {
                                      v296 = v294[35];
                                      ++v294[34];
                                      if ((int)v264 > v293)
                                      {
                                        v297 = v264;
                                        v294[35] = v296 + v293;
                                        goto LABEL_750;
                                      }
                                      v294[35] = v296 + (int)v264;
                                      if (v290 == v291 && !v292)
                                      {
                                        v297 = v264;
                                        *(_DWORD *)(v839 + 88) |= 1u;
                                        ++v294[36];
LABEL_750:
                                        v299 = *v44;
                                        if (*v44)
                                        {
                                          if ((*(_WORD *)(v299 + 204) & 0x80) != 0)
                                          {
                                            v300 = v44;
                                            v301 = *(unsigned __int16 *)(v299 + 196);
                                            v302 = v293;
                                            if (v293 > v301)
                                            {
                                              __nwlog_obj();
                                              v303 = *(unsigned __int16 *)(v299 + 196);
                                              *(_DWORD *)buf = 136446722;
                                              v902 = "__nw_frame_array_claim";
                                              v903 = 1024;
                                              *(_DWORD *)v904 = v303;
                                              *(_WORD *)&v904[4] = 1024;
                                              *(_DWORD *)&v904[6] = v302;
                                              v304 = (void *)_os_log_send_and_compose_impl();
                                              type[0] = OS_LOG_TYPE_ERROR;
                                              v900 = 0;
                                              if (__nwlog_fault())
                                              {
                                                if (type[0] == OS_LOG_TYPE_FAULT)
                                                {
                                                  v305 = __nwlog_obj();
                                                  v306 = type[0];
                                                  if (os_log_type_enabled(v305, type[0]))
                                                  {
                                                    v307 = *(unsigned __int16 *)(v299 + 196);
                                                    *(_DWORD *)buf = 136446722;
                                                    v902 = "__nw_frame_array_claim";
                                                    v903 = 1024;
                                                    *(_DWORD *)v904 = v307;
                                                    *(_WORD *)&v904[4] = 1024;
                                                    *(_DWORD *)&v904[6] = v885;
                                                    v308 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_1243:
                                                    v510 = v305;
LABEL_1244:
                                                    _os_log_impl(&dword_209FB3000, v510, v306, v308, buf, 0x18u);
                                                  }
                                                }
                                                else if (v900)
                                                {
                                                  v359 = (void *)__nw_create_backtrace_string();
                                                  v306 = type[0];
                                                  v842 = __nwlog_obj();
                                                  v360 = os_log_type_enabled(v842, type[0]);
                                                  if (v359)
                                                  {
                                                    if (v360)
                                                    {
                                                      v361 = *(unsigned __int16 *)(v299 + 196);
                                                      *(_DWORD *)buf = 136446978;
                                                      v902 = "__nw_frame_array_claim";
                                                      v903 = 1024;
                                                      *(_DWORD *)v904 = v361;
                                                      *(_WORD *)&v904[4] = 1024;
                                                      *(_DWORD *)&v904[6] = v885;
                                                      *(_WORD *)v905 = 2082;
                                                      *(_QWORD *)&v905[2] = v359;
                                                      _os_log_impl(&dword_209FB3000, v842, type[0], "%{public}s Aggregate buffer length: %u sum: %u, dumping backtrace:%{public}s", buf, 0x22u);
                                                    }
                                                    free(v359);
                                                    goto LABEL_1245;
                                                  }
                                                  if (v360)
                                                  {
                                                    v555 = *(unsigned __int16 *)(v299 + 196);
                                                    *(_DWORD *)buf = 136446722;
                                                    v902 = "__nw_frame_array_claim";
                                                    v903 = 1024;
                                                    *(_DWORD *)v904 = v555;
                                                    *(_WORD *)&v904[4] = 1024;
                                                    *(_DWORD *)&v904[6] = v885;
                                                    v308 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                                                    v510 = v842;
                                                    goto LABEL_1244;
                                                  }
                                                }
                                                else
                                                {
                                                  v305 = __nwlog_obj();
                                                  v306 = type[0];
                                                  if (os_log_type_enabled(v305, type[0]))
                                                  {
                                                    v509 = *(unsigned __int16 *)(v299 + 196);
                                                    *(_DWORD *)buf = 136446722;
                                                    v902 = "__nw_frame_array_claim";
                                                    v903 = 1024;
                                                    *(_DWORD *)v904 = v509;
                                                    *(_WORD *)&v904[4] = 1024;
                                                    *(_DWORD *)&v904[6] = v885;
                                                    v308 = "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded";
                                                    goto LABEL_1243;
                                                  }
                                                }
                                              }
LABEL_1245:
                                              if (v304)
                                                free(v304);
                                              *(_WORD *)(v299 + 196) = 0;
LABEL_1248:
                                              v44 = v300;
                                              v293 = v885;
                                              goto LABEL_1249;
                                            }
                                            *(_WORD *)(v299 + 196) = v301 - v293;
                                          }
LABEL_1249:
                                          v511 = **(_QWORD **)(v44[1] + 8);
                                          if (v511)
                                          {
                                            v512 = 0;
                                            v131 = v295;
                                            while (1)
                                            {
                                              v513 = v131;
                                              v514 = *(_DWORD *)(v511 + 52);
                                              v515 = *(_DWORD *)(v511 + 56);
                                              v516 = *(_DWORD *)(v511 + 60);
                                              v517 = v514 - (v515 + v516);
                                              if (v517 >= v293 - v512)
                                                v517 = v293 - v512;
                                              v518 = v514 ? v517 : 0;
                                              v519 = v516 + v518;
                                              if (v515 <= v514 - (v516 + v518))
                                              {
                                                *(_DWORD *)(v511 + 60) = v519;
                                              }
                                              else
                                              {
                                                v520 = __nwlog_obj();
                                                v521 = os_log_type_enabled(v520, OS_LOG_TYPE_ERROR);
                                                v293 = v885;
                                                if (v521)
                                                {
                                                  v522 = *(_DWORD *)(v511 + 52);
                                                  *(_DWORD *)buf = 136446978;
                                                  v902 = "__nw_frame_claim_internal";
                                                  v903 = 1024;
                                                  *(_DWORD *)v904 = v515;
                                                  *(_WORD *)&v904[4] = 1024;
                                                  *(_DWORD *)&v904[6] = v522;
                                                  *(_WORD *)v905 = 1024;
                                                  *(_DWORD *)&v905[2] = v519;
                                                  _os_log_impl(&dword_209FB3000, v520, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
                                                  v293 = v885;
                                                }
                                              }
                                              v512 += v518;
                                              v131 = v513;
                                              if (v512 == v293)
                                                break;
                                              if (*(_OWORD *)(v511 + 32) != 0)
                                              {
                                                v511 = **(_QWORD **)(*(_QWORD *)(v511 + 40) + 8);
                                                if (v511 && v512 < v293)
                                                  continue;
                                              }
                                              goto LABEL_1269;
                                            }
                                          }
                                          else
                                          {
                                            v512 = 0;
                                            LODWORD(v131) = v295;
LABEL_1269:
                                            if (v512 != v293)
                                            {
                                              v524 = __nwlog_obj();
                                              v525 = os_log_type_enabled(v524, OS_LOG_TYPE_ERROR);
                                              v293 = v885;
                                              if (v525)
                                              {
                                                *(_DWORD *)buf = 136446722;
                                                v902 = "__nw_frame_array_claim";
                                                v903 = 1024;
                                                *(_DWORD *)v904 = v512;
                                                *(_WORD *)&v904[4] = 1024;
                                                *(_DWORD *)&v904[6] = v885;
                                                _os_log_impl(&dword_209FB3000, v524, OS_LOG_TYPE_ERROR, "%{public}s end_offset %u != end_bytes %u", buf, 0x18u);
                                                v293 = v885;
                                              }
                                            }
                                          }
                                          v264 = (v297 - v293);
                                          v899 = v297 - v293;
                                          LODWORD(v131) = v131 & 0xFFFFFFF6;
                                          v122 = v839;
LABEL_1273:
                                          if ((v896[0] & 1) != 0)
                                          {
                                            v526 = *(_DWORD *)(v122 + 284);
                                            if (DWORD1(v922) - v526 <= 0
                                              && v526 - ((v131 & 3) != 0) - (DWORD1(v922) + (int)v264) <= 0)
                                            {
                                              *(_DWORD *)(v122 + 280) = *(_DWORD *)(v837 + 316);
                                              *(_DWORD *)(v122 + 276) = DWORD1(v896[0]);
                                            }
                                          }
                                          if ((v131 & 2) == 0)
                                          {
                                            v120 = v264;
                                            v527 = *(_DWORD *)(v122 + 12);
                                            if ((v131 & 0x10) == 0)
                                              goto LABEL_1279;
                                            goto LABEL_1286;
                                          }
                                          if ((int)v264 >= 1
                                            && DWORD1(v922) == *(_DWORD *)(v122 + 116)
                                            && !(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v122 + 80) + 248) + 8) >> 31))
                                          {
                                            v120 = v264;
                                            ++DWORD1(v922);
                                            LODWORD(v131) = v131 & 0xFFFFFFFD;
                                            v527 = *(_DWORD *)(v122 + 12);
                                            if ((v131 & 0x10) == 0)
                                            {
LABEL_1279:
                                              if (v527 == 3)
                                              {
                                                v412 = v122;
                                                if ((*(_BYTE *)(v122 + 742) & 0x40) != 0)
                                                {
                                                  *(_DWORD *)(v122 + 100) = *(_DWORD *)(v122 + 92);
                                                  v847 = (BYTE13(v922) >> 1) & 1;
                                                }
                                                else
                                                {
                                                  v847 = 0;
                                                }
                                                LOBYTE(v413) = v131;
                                                tcp_input_process_accecn_syn((int64x2_t *)v122, ((unsigned __int16)v131 | (unsigned __int16)(BYTE12(v922) << 8)) & 0x1C0, log);
                                                v410 = 0;
                                                v841 = 0;
                                                v18 = v817;
                                                a3 = v815;
                                                v120 = 0x253CF8000;
                                                goto LABEL_1114;
                                              }
                                              v44 = a1;
                                              v43 = v892;
                                              v132 = v824;
                                              if ((*(_BYTE *)(v122 + 88) & 1) != 0)
                                                goto LABEL_1298;
LABEL_1331:
                                              v55 = v849;
LABEL_1332:
                                              if (v132)
                                                soabort(v15);
                                              goto LABEL_1334;
                                            }
LABEL_1286:
                                            v528 = v131;
                                            v412 = v122;
                                            v841 = 0;
                                            if ((v527 - 4) < 7)
                                              goto LABEL_1287;
                                            if (v527 != 3)
                                            {
                                              v410 = 0;
                                              v847 = 0;
                                              goto LABEL_1392;
                                            }
                                            v541 = *(_QWORD *)(v122 + 1056);
                                            if (v541)
                                              ++*(_QWORD *)(v541 + 408);
                                            if ((~*(_DWORD *)(v122 + 88) & 0x60) == 0)
                                            {
                                              v542 = *(_BYTE *)(v122 + 263);
                                              *(_BYTE *)(v122 + 260) = v542;
                                              *(_BYTE *)(v122 + 261) = *(_BYTE *)(v122 + 262);
                                              v543 = HIWORD(v922) << v542;
                                              *(_DWORD *)(v122 + 140) = v543;
                                              v822 = v543;
                                              *(_DWORD *)(v122 + 252) = v543;
                                              if (*(_QWORD *)(v15 + 24))
                                              {
                                                v544 = nw_protocol_tcp_get_all_stats();
                                                v822 = *(_DWORD *)(v122 + 140);
                                                if (v544)
                                                {
                                                  *(_DWORD *)(v544 + 112) = v822;
                                                  v822 = *(_DWORD *)(v122 + 140);
                                                }
                                              }
                                            }
                                            *(_DWORD *)(v122 + 168) = *(_DWORD *)(v837 + 316);
                                            tcp_sbrcv_tstmp_check(v122);
                                            if ((*(_BYTE *)(v122 + 89) & 8) != 0)
                                            {
                                              *(_DWORD *)(v122 + 12) = 6;
                                              if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                              {
                                                if (__nwlog_is_datapath_logging_enabled())
                                                {
                                                  v786 = __nwlog_tcp_log();
                                                  if (os_log_type_enabled(v786, OS_LOG_TYPE_DEBUG))
                                                  {
                                                    v787 = tcpstates[*(int *)(v412 + 12)];
                                                    v902 = "tcp_input";
                                                    v788 = "";
                                                    *(_DWORD *)buf = 136446722;
                                                    if (v15)
                                                      v788 = (const char *)(v15 + 604);
                                                    v903 = 2082;
                                                    *(_QWORD *)v904 = v788;
                                                    *(_WORD *)&v904[8] = 2082;
                                                    *(_QWORD *)v905 = v787;
                                                    _os_log_impl(&dword_209FB3000, v786, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                  }
                                                }
                                              }
                                              if (*(_QWORD *)(v15 + 24))
                                              {
                                                v556 = nw_protocol_tcp_get_all_stats();
                                                if (v556)
                                                  *(_DWORD *)(v556 + 136) = 6;
                                              }
                                              *(_DWORD *)(v412 + 88) &= ~0x800u;
                                            }
                                            else
                                            {
                                              *(_DWORD *)(v122 + 12) = 4;
                                              if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                              {
                                                if (__nwlog_is_datapath_logging_enabled())
                                                {
                                                  v783 = __nwlog_tcp_log();
                                                  if (os_log_type_enabled(v783, OS_LOG_TYPE_DEBUG))
                                                  {
                                                    v784 = tcpstates[*(int *)(v412 + 12)];
                                                    v902 = "tcp_input";
                                                    v785 = "";
                                                    *(_DWORD *)buf = 136446722;
                                                    if (v15)
                                                      v785 = (const char *)(v15 + 604);
                                                    v903 = 2082;
                                                    *(_QWORD *)v904 = v785;
                                                    *(_WORD *)&v904[8] = 2082;
                                                    *(_QWORD *)v905 = v784;
                                                    _os_log_impl(&dword_209FB3000, v783, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                  }
                                                }
                                              }
                                              if (*(_QWORD *)(v15 + 24))
                                              {
                                                v545 = nw_protocol_tcp_get_all_stats();
                                                if (v545)
                                                  *(_DWORD *)(v545 + 136) = 4;
                                              }
                                              v546 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v412 + 80)
                                                                                                 + 224))
                                                               + 316);
                                              v547 = *(_DWORD *)(v412 + 676);
                                              if (!v547
                                                || (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v412 + 80) + 224) + 372) & 8) == 0)
                                              {
                                                v547 = *(_DWORD *)(sysctls + 192);
                                              }
                                              *(_DWORD *)(v412 + 40) = v547 + v546 - *(_DWORD *)(v412 + 64);
                                              if (*(_QWORD *)(v15 + 24))
                                              {
                                                v548 = nw_protocol_tcp_get_all_stats();
                                                if (v548)
                                                  ++*(_DWORD *)(v548 + 64);
                                              }
                                            }
                                            *(_WORD *)(v412 + 308) = 16;
                                            if (*(_QWORD *)v412)
                                            {
                                              v776 = __nwlog_obj();
                                              os_log_type_enabled(v776, OS_LOG_TYPE_ERROR);
                                              *(_DWORD *)buf = 136446210;
                                              v902 = "tcp_input";
                                              v777 = (void *)_os_log_send_and_compose_impl();
                                              if (__nwlog_abort())
                                                goto LABEL_2097;
                                              free(v777);
                                            }
                                            *(_DWORD *)(v412 + 104) = DWORD1(v922) - 1;
                                            v557 = *(_DWORD *)(v412 + 740);
                                            if ((v557 & 0x10000000) == 0
                                              && ((v557 & 0x8000000) != 0
                                               || *(_DWORD *)(sysctls + 320) == 1
                                               || tcp_do_acc_ecn == 1)
                                              && (v528 & 0x12) == 0x10)
                                            {
                                              v558 = *(_DWORD *)(v412 + 348);
                                              if ((v558 & 0x300000) == 0x300000)
                                              {
                                                if ((_DWORD)v120 || HIBYTE(v896[0]))
                                                {
                                                  if (!HIBYTE(v896[0]))
                                                  {
                                                    *(_DWORD *)(v412 + 420) = 5;
                                                    if (*(_DWORD *)(v412 + 364) == 5)
                                                      *(_DWORD *)(v412 + 364) = 8;
                                                  }
                                                }
                                                else
                                                {
                                                  switch(((v528 | (BYTE12(v922) << 8)) >> 6) & 7)
                                                  {
                                                    case 0u:
                                                      *(_DWORD *)(v412 + 348) = v558 & 0xFFDFFFF1;
                                                      if ((v558 & 0x200) != 0
                                                        && *(unsigned __int16 *)(v412 + 226) <= 2u
                                                        && (*(_DWORD *)(v412 + 364) & 0xFFFFFFFE) == 4)
                                                      {
                                                        *(_DWORD *)(v412 + 364) = 6;
                                                      }
                                                      if (*(_DWORD *)(v412 + 364) == 5)
                                                      {
                                                        v674 = 7;
                                                        goto LABEL_1762;
                                                      }
                                                      break;
                                                    case 2u:
                                                      *(_DWORD *)(v412 + 420) = 5;
                                                      if (*(_DWORD *)(v412 + 364) == 5)
                                                      {
                                                        v674 = 8;
                                                        goto LABEL_1762;
                                                      }
                                                      break;
                                                    case 3u:
                                                    case 4u:
                                                      *(_DWORD *)(v412 + 420) = 5;
                                                      goto LABEL_1758;
                                                    case 6u:
                                                      *(_DWORD *)(v412 + 420) = 6;
                                                      *(_DWORD *)(v412 + 144) = 2 * *(_DWORD *)(v412 + 196);
LABEL_1758:
                                                      if (*(_DWORD *)(v412 + 364) == 5)
                                                      {
                                                        v674 = 9;
LABEL_1762:
                                                        *(_DWORD *)(v412 + 364) = v674;
                                                      }
                                                      break;
                                                    default:
                                                      *(_DWORD *)(v412 + 420) = 5;
                                                      break;
                                                  }
                                                  if ((v896[0] & 1) != 0)
                                                  {
                                                    if (DWORD2(v896[0]))
                                                    {
                                                      v675 = *(_DWORD *)(v412 + 400);
                                                      if (!v675 || ((DWORD2(v896[0]) - v675) & 0x80000000) == 0)
                                                        *(_DWORD *)(v412 + 400) = DWORD2(v896[0]);
                                                    }
                                                  }
                                                }
                                                tcp_input_ip_ecn(v412, v815, v120, v825, log);
                                              }
                                            }
                                            v676 = *(_BYTE *)(v412 + 988);
                                            if ((v676 & 2) == 0)
                                            {
                                              v841 = 1;
                                              goto LABEL_1774;
                                            }
                                            do
                                              v677 = __ldxr((unsigned int *)&tcp_tfo_halfcnt);
                                            while (__stxr(v677 - 1, (unsigned int *)&tcp_tfo_halfcnt));
                                            if ((tcp_tfo_halfcnt & 0x80000000) == 0)
                                            {
LABEL_1773:
                                              v841 = 0;
                                              *(_BYTE *)(v412 + 988) = v676 & 0xFD;
LABEL_1774:
                                              if (*(_DWORD *)(v15 + 384))
                                              {
                                                v678 = *(_DWORD *)(v412 + 92) + 1;
                                                *(_DWORD *)(v412 + 92) = v678;
                                                if (*(_QWORD *)(v15 + 24))
                                                {
                                                  v679 = nw_protocol_tcp_get_all_stats();
                                                  v678 = *(_DWORD *)(v412 + 92);
                                                  if (v679)
                                                  {
                                                    *(_DWORD *)(v679 + 108) = *(_DWORD *)(v412 + 96) - v678;
                                                    v678 = *(_DWORD *)(v412 + 92);
                                                  }
                                                }
                                                if (*(_DWORD *)(v412 + 100) - v678 < 0)
                                                  *(_DWORD *)(v412 + 100) = v678;
                                                if ((*(_BYTE *)(v412 + 740) & 0x20) != 0
                                                  && (HIBYTE(v896[0]) || *(_QWORD *)(v412 + 544)))
                                                {
                                                  tcp_sack_doack(v412, (uint64_t)v896, SDWORD2(v922), (_DWORD *)&v898 + 1, &v898);
                                                }
                                                goto LABEL_1784;
                                              }
LABEL_1287:
                                              if (DWORD2(v922) - *(_DWORD *)(v412 + 96) >= 1)
                                              {
                                                v529 = *(_QWORD *)(v412 + 1056);
                                                if (v529)
                                                  ++*(_QWORD *)(v529 + 184);
LABEL_1330:
                                                v122 = v412;
                                                is_ack_ratelimited = tcp_is_ack_ratelimited(v412);
                                                v43 = v892;
                                                v132 = v824;
                                                LODWORD(v131) = v528;
                                                v44 = a1;
                                                if (!is_ack_ratelimited)
                                                  goto LABEL_1298;
                                                goto LABEL_1331;
                                              }
                                              if (DWORD2(v922) - *(_DWORD *)(v412 + 92) + *(_DWORD *)(v412 + 252) < 0)
                                                goto LABEL_1330;
                                              v539 = 1;
                                              if ((*(_BYTE *)(v412 + 740) & 0x20) != 0)
                                              {
                                                if (HIBYTE(v896[0]))
                                                {
                                                  if (tcp_sack_process_dsack(v412, (uint64_t)v896, (uint64_t)&v922, &v895))
                                                  {
                                                    v539 = 0;
                                                    if (DWORD2(v922) - *(_DWORD *)(v412 + 92) <= 0 && !HIBYTE(v896[0]))
                                                    {
                                                      tcp_bad_rexmt_check(v412, (uint64_t)&v922, (uint64_t)v896);
                                                      goto LABEL_1291;
                                                    }
                                                  }
                                                }
                                              }
                                              v549 = *(_DWORD *)(v412 + 740);
                                              if ((v549 & 0x20) != 0 && (HIBYTE(v896[0]) || *(_QWORD *)(v412 + 544)))
                                              {
                                                tcp_sack_doack(v412, (uint64_t)v896, SDWORD2(v922), (_DWORD *)&v898 + 1, &v898);
                                                v549 = *(_DWORD *)(v412 + 740);
                                              }
                                              if ((v549 & 0x20400020) == 0x20000020)
                                              {
                                                if (v895)
                                                  v550 = 1;
                                                else
                                                  v550 = v539;
                                                if ((v550 & 1) == 0)
                                                  *(_BYTE *)(v412 + 2069) |= 0x40u;
                                                tcp_rack_update_reordering_window(v412, SDWORD2(v922));
                                              }
                                              tcp_tfo_rcv_ack(v412, (uint64_t)&v922);
                                              if (DWORD2(v922) - *(_DWORD *)(v412 + 92) > 0)
                                              {
                                                v551 = *(_DWORD *)(v412 + 88);
                                                if ((v551 & 0x200000) != 0)
                                                {
                                                  if (DWORD2(v922) - *(_DWORD *)(v412 + 152) >= 0)
                                                  {
                                                    v409 = *(_DWORD *)(sysctls + 276) != 0;
                                                    *(_DWORD *)(v412 + 88) = v551 & 0xFFDFFFFF;
                                                    *(_DWORD *)(v412 + 8) = 0;
                                                    *(_BYTE *)(v412 + 310) = 3;
                                                    *(_DWORD *)(v412 + 288) = 0;
                                                    *(_DWORD *)(v412 + 348) &= ~0x20u;
                                                    *(_DWORD *)(v412 + 16) = 0;
                                                    v559 = *(_DWORD *)(v412 + 740) & 0xFFF7FFFF;
                                                    *(_DWORD *)(v412 + 740) = v559;
                                                    *(_DWORD *)(v412 + 984) = 0;
                                                    *(_DWORD *)(v412 + 628) = 0;
                                                    v560 = *(void (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v412 + 264)] + 72);
                                                    if (v560)
                                                    {
                                                      v560(v412, &v922);
                                                      v559 = *(_DWORD *)(v412 + 740);
                                                    }
                                                    if ((v559 & 0x20400020) == 0x20000020
                                                      && (*(_BYTE *)(v412 + 2069) & 0x1F) != 0)
                                                    {
                                                      *(_BYTE *)(v412 + 2069) = *(_BYTE *)(v412 + 2069) & 0xE0 | (*(_BYTE *)(v412 + 2069) - 1) & 0x1F;
                                                    }
                                                    *(_DWORD *)(v412 + 972) = 0;
                                                    *(_QWORD *)(v412 + 964) = 0;
                                                    *(_BYTE *)(v412 + 751) = 0;
                                                    *(_QWORD *)(v412 + 980) = 0;
                                                    goto LABEL_1785;
                                                  }
                                                  if ((*(_BYTE *)(v412 + 348) & 0x20) == 0)
                                                  {
                                                    v566 = *(_DWORD *)(v412 + 740);
                                                    if ((v566 & 0x20400020) != 0x20000020)
                                                    {
                                                      if ((v566 & 0x20) != 0)
                                                        tcp_sack_partialack(v412, (uint64_t)&v922);
                                                      else
                                                        tcp_newreno_partial_ack((_DWORD *)v412, (uint64_t)&v922);
                                                    }
                                                  }
                                                }
                                                else
                                                {
                                                  v552 = *(_DWORD *)(v412 + 740);
                                                  if ((~v552 & 0x6000) != 0)
                                                  {
                                                    v409 = 0;
                                                    *(_DWORD *)(v412 + 8) = 0;
                                                    *(_BYTE *)(v412 + 310) = 3;
                                                    goto LABEL_1785;
                                                  }
                                                  if (DWORD2(v922) - *(_DWORD *)(v412 + 152) >= 0
                                                    || !*(_QWORD *)(v412 + 544))
                                                  {
                                                    v409 = 0;
                                                    *(_DWORD *)(v412 + 88) = v551 & 0xFFDFFFFF;
                                                    *(_BYTE *)(v412 + 310) = 3;
                                                    *(_DWORD *)(v412 + 348) &= ~0x20u;
                                                    *(_DWORD *)(v412 + 8) = 0;
                                                    *(_DWORD *)(v412 + 288) = 0;
                                                    *(_QWORD *)(v412 + 16) = 0;
                                                    *(_DWORD *)(v412 + 740) = v552 & 0xFFF7BFFF;
                                                    *(_DWORD *)(v412 + 984) = 0;
                                                    *(_DWORD *)(v412 + 628) = 0;
LABEL_1785:
                                                    v18 = v817;
                                                    a3 = v815;
                                                    v413 = v528;
                                                    v374 = v120;
                                                    goto LABEL_991;
                                                  }
                                                }
LABEL_1784:
                                                v409 = 0;
                                                goto LABEL_1785;
                                              }
                                              v553 = *(_DWORD *)(v412 + 740);
                                              if ((~v553 & 0x20000020) == 0
                                                && (v553 & 0x400000) == 0
                                                && HIDWORD(v898)
                                                && *(_DWORD *)(v412 + 560) - (int)v898 < 0)
                                              {
                                                *(_DWORD *)(v412 + 560) = v898;
                                              }
                                              if ((v553 & 0x10000000) == 0
                                                && ((v553 & 0x8000000) != 0
                                                 || *(_DWORD *)(sysctls + 320) == 1
                                                 || tcp_do_acc_ecn == 1))
                                              {
                                                v554 = *(_DWORD *)(v412 + 348);
                                                if ((~v554 & 0x300000) == 0 && (v554 & 4) != 0 && !HIDWORD(v898))
                                                {
                                                  ++*(_DWORD *)(v412 + 296);
                                                  if ((v896[0] & 1) != 0
                                                    && DWORD2(v896[0])
                                                    && DWORD2(v896[0]) - *(_DWORD *)(v412 + 400) >= 1)
                                                  {
                                                    tcp_process_accecn(v412, (uint64_t)v896, (uint64_t)&v922, 1u, v821);
                                                  }
                                                }
                                              }
                                              if ((_DWORD)v120)
                                              {
                                                v410 = 0;
                                                v847 = 0;
                                              }
                                              else
                                              {
                                                if (v822 == *(_DWORD *)(v412 + 140)
                                                  || (v410 = 0, HIBYTE(v896[0])) && HIDWORD(v898))
                                                {
                                                  if ((v528 & 1) != 0)
                                                  {
                                                    v835 = 0;
                                                    v410 = 0;
                                                    v847 = 0;
                                                    v18 = v817;
                                                    a3 = v815;
                                                    v120 = 0x253CF8000;
                                                    LOBYTE(v413) = v528;
                                                    if (*(int *)(v412 + 12) < 10)
                                                    {
LABEL_1114:
                                                      v463 = v899;
                                                      updated = tcp_update_window(v412, v413, (uint64_t)&v922, v822, v899);
                                                      v464 = v412;
                                                      v465 = v413;
                                                      if ((v413 & 0x20) == 0 || !v923 || *(int *)(v464 + 12) > 9)
                                                      {
                                                        v466 = *(_DWORD *)(v464 + 120);
                                                        if (v466 - *(_DWORD *)(v464 + 136) >= 1)
                                                          *(_DWORD *)(v464 + 136) = v466;
                                                        v43 = v892;
LABEL_1126:
                                                        if (v841)
                                                        {
                                                          soisconnected(v15);
                                                          if (v828)
                                                            *v828 = 1;
                                                        }
                                                        else if (v410)
                                                        {
                                                          *(_WORD *)(v15 + 376) = *(_WORD *)(v15 + 376) & 0xDFC1 | 0x2030;
                                                          v467 = *(_QWORD *)(v15 + 32);
                                                          if (v467)
                                                          {
                                                            v468 = *(void (**)(uint64_t))(v467 + 56);
                                                            if (v468)
                                                              v468(v15);
                                                          }
                                                        }
                                                        if (*(_DWORD *)(a3 + 232) == 3)
                                                        {
                                                          v44 = a1;
LABEL_1292:
                                                          v55 = v849;
                                                          goto LABEL_1293;
                                                        }
                                                        if (!(v463 | v465 & 1)
                                                          || (v469 = *(_DWORD *)(v464 + 12), v469 > 9)
                                                          || (v818 = v18, v469 <= 3)
                                                          && (v469 != 3 || (*(_BYTE *)(v464 + 988) & 2) == 0))
                                                        {
                                                          v472 = 0;
                                                          v473 = a1;
                                                          v474 = *(_DWORD *)(v464 + 740);
                                                          if ((v474 & 0x10000000) != 0)
                                                            goto LABEL_1595;
LABEL_1157:
                                                          if (((v474 & 0x8000000) != 0
                                                             || *(_DWORD *)(*(_QWORD *)(v120 + 2352) + 320) == 1
                                                             || tcp_do_acc_ecn == 1)
                                                            && (~*(_DWORD *)(v464 + 348) & 0x300000) == 0
                                                            && (*(_DWORD *)(v464 + 12) - 4) <= 5)
                                                          {
                                                            v475 = *(_WORD *)(v464 + 306);
                                                            if (v823
                                                              && (v475 += v825,
                                                                  *(_WORD *)(v464 + 306) = v475,
                                                                  *(_DWORD *)(v464 + 408) != 3)
                                                              || v475 >= 2u
                                                              && (v475 != 2
                                                               || *(_DWORD *)(v464 + 284) != *(_DWORD *)(v464 + 120)))
                                                            {
                                                              *(_DWORD *)(v464 + 88) |= 1u;
                                                            }
                                                            *(_DWORD *)(v464 + 408) = log;
                                                          }
LABEL_1595:
                                                          if ((v472 & 1) != 0)
                                                          {
                                                            v627 = *(_DWORD *)(v464 + 12);
                                                            if (v627 <= 9)
                                                            {
                                                              *(_WORD *)(v15 + 376) |= 0x20u;
                                                              v628 = *(_QWORD *)(v15 + 32);
                                                              if (v628)
                                                              {
                                                                v629 = *(void (**)(uint64_t))(v628 + 40);
                                                                if (v629)
                                                                {
                                                                  v629(v15);
                                                                  v627 = *(_DWORD *)(v464 + 12);
                                                                }
                                                              }
                                                              *(_WORD *)(v464 + 304) += v825;
                                                              *(_DWORD *)(v464 + 88) |= 1u;
                                                              ++*(_DWORD *)(v464 + 120);
                                                            }
                                                            switch(v627)
                                                            {
                                                              case 3:
                                                                *(_DWORD *)(v464 + 168) = *(_DWORD *)(v837 + 316);
                                                                goto LABEL_1629;
                                                              case 4:
LABEL_1629:
                                                                v630 = v464;
                                                                *(_DWORD *)(v464 + 12) = 5;
                                                                if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                                {
                                                                  if (__nwlog_is_datapath_logging_enabled())
                                                                  {
                                                                    v722 = __nwlog_tcp_log();
                                                                    if (os_log_type_enabled(v722, OS_LOG_TYPE_DEBUG))
                                                                    {
                                                                      v723 = tcpstates[*(int *)(v630 + 12)];
                                                                      v902 = "tcp_input";
                                                                      v724 = "";
                                                                      *(_DWORD *)buf = 136446722;
                                                                      if (v15)
                                                                        v724 = (const char *)(v15 + 604);
                                                                      v903 = 2082;
                                                                      *(_QWORD *)v904 = v724;
                                                                      *(_WORD *)&v904[8] = 2082;
                                                                      *(_QWORD *)v905 = v723;
                                                                      _os_log_impl(&dword_209FB3000, v722, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                                    }
                                                                  }
                                                                }
                                                                v464 = v630;
                                                                if (*(_QWORD *)(v15 + 24))
                                                                {
                                                                  v631 = nw_protocol_tcp_get_all_stats();
                                                                  if (v631)
                                                                    *(_DWORD *)(v631 + 136) = 5;
                                                                }
                                                                break;
                                                              case 6:
                                                                v632 = v464;
                                                                *(_DWORD *)(v464 + 12) = 7;
                                                                if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                                {
                                                                  if (__nwlog_is_datapath_logging_enabled())
                                                                  {
                                                                    v755 = __nwlog_tcp_log();
                                                                    if (os_log_type_enabled(v755, OS_LOG_TYPE_DEBUG))
                                                                    {
                                                                      v756 = tcpstates[*(int *)(v632 + 12)];
                                                                      v902 = "tcp_input";
                                                                      v757 = "";
                                                                      *(_DWORD *)buf = 136446722;
                                                                      if (v15)
                                                                        v757 = (const char *)(v15 + 604);
                                                                      v903 = 2082;
                                                                      *(_QWORD *)v904 = v757;
                                                                      *(_WORD *)&v904[8] = 2082;
                                                                      *(_QWORD *)v905 = v756;
                                                                      _os_log_impl(&dword_209FB3000, v755, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                                    }
                                                                  }
                                                                }
                                                                v464 = v632;
                                                                if (*(_QWORD *)(v15 + 24))
                                                                {
                                                                  v633 = nw_protocol_tcp_get_all_stats();
                                                                  if (v633)
                                                                    *(_DWORD *)(v633 + 136) = 7;
                                                                }
                                                                break;
                                                              case 9:
                                                                v634 = v464;
                                                                *(_DWORD *)(v464 + 12) = 10;
                                                                if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                                {
                                                                  if (__nwlog_is_datapath_logging_enabled())
                                                                  {
                                                                    v758 = __nwlog_tcp_log();
                                                                    if (os_log_type_enabled(v758, OS_LOG_TYPE_DEBUG))
                                                                    {
                                                                      v759 = tcpstates[*(int *)(v634 + 12)];
                                                                      v902 = "tcp_input";
                                                                      v760 = "";
                                                                      *(_DWORD *)buf = 136446722;
                                                                      if (v15)
                                                                        v760 = (const char *)(v15 + 604);
                                                                      v903 = 2082;
                                                                      *(_QWORD *)v904 = v760;
                                                                      *(_WORD *)&v904[8] = 2082;
                                                                      *(_QWORD *)v905 = v759;
                                                                      _os_log_impl(&dword_209FB3000, v758, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                                    }
                                                                  }
                                                                }
                                                                if (*(_QWORD *)(v15 + 24))
                                                                {
                                                                  v635 = nw_protocol_tcp_get_all_stats();
                                                                  if (v635)
                                                                    *(_DWORD *)(v635 + 136) = 10;
                                                                }
                                                                tcp_canceltimers(v634);
                                                                v636 = *(_DWORD *)(v634 + 88);
                                                                *(_DWORD *)(v634 + 88) = v636 | 1;
                                                                if ((*(_BYTE *)(v634 + 741) & 8) != 0)
                                                                  *(_DWORD *)(v634 + 88) = v636 | 0x8000001;
                                                                else
                                                                  add_to_time_wait(v634, 2 * *(_DWORD *)(*(_QWORD *)(v120 + 2352) + 204));
                                                                *(_WORD *)(v15 + 376) = *(_WORD *)(v15 + 376) & 0xDFC1 | 0x2030;
                                                                v637 = *(_QWORD *)(v15 + 32);
                                                                v464 = v634;
                                                                if (v637)
                                                                {
                                                                  v638 = *(void (**)(uint64_t))(v637 + 56);
                                                                  if (v638)
                                                                    v638(v15);
                                                                }
                                                                break;
                                                              case 10:
                                                                add_to_time_wait(v464, 2 * *(_DWORD *)(*(_QWORD *)(v120 + 2352) + 204));
                                                                break;
                                                              default:
                                                                break;
                                                            }
                                                          }
                                                          v618 = updated;
                                                          if (v847)
                                                            v618 = 1;
                                                          if ((v618 & 1) != 0 || (*(_BYTE *)(v464 + 88) & 1) != 0)
                                                            tcp_output(v464);
                                                          tcp_check_timer_state(v464);
                                                          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 8) + 24))(v15, 1, v6);
                                                          *v892 = v849 != 0;
                                                          result = (_QWORD *)*v473;
                                                          if (!*v473)
                                                            return result;
                                                          while (1)
                                                          {
                                                            v619 = (void (*)(_QWORD *, uint64_t, uint64_t))result[10];
                                                            v620 = (_QWORD *)result[4];
                                                            if (!v619)
                                                              break;
                                                            v621 = result[11];
                                                            result[10] = 0;
                                                            result[11] = 0;
                                                            v619(result, 1, v621);
LABEL_1604:
                                                            result = v620;
                                                            if (!v620)
                                                              return result;
                                                          }
                                                          __nwlog_obj();
                                                          *(_DWORD *)buf = 136446210;
                                                          v902 = "__nw_frame_finalize";
                                                          v622 = _os_log_send_and_compose_impl();
                                                          type[0] = OS_LOG_TYPE_ERROR;
                                                          v900 = 0;
                                                          v889 = (void *)v622;
                                                          if (__nwlog_fault())
                                                          {
                                                            if (type[0] == OS_LOG_TYPE_FAULT)
                                                            {
                                                              v873 = __nwlog_obj();
                                                              logf = type[0];
                                                              if (!os_log_type_enabled(v873, type[0]))
                                                                goto LABEL_1620;
                                                              *(_DWORD *)buf = 136446210;
                                                              v902 = "__nw_frame_finalize";
                                                              v623 = v873;
                                                              v624 = logf;
                                                              v625 = "%{public}s called with null frame->finalizer";
                                                              goto LABEL_1619;
                                                            }
                                                            if (!v900)
                                                            {
                                                              v875 = __nwlog_obj();
                                                              logh = type[0];
                                                              if (!os_log_type_enabled(v875, type[0]))
                                                                goto LABEL_1620;
                                                              *(_DWORD *)buf = 136446210;
                                                              v902 = "__nw_frame_finalize";
                                                              v623 = v875;
                                                              v624 = logh;
                                                              v625 = "%{public}s called with null frame->finalizer, backt"
                                                                     "race limit exceeded";
                                                              goto LABEL_1619;
                                                            }
                                                            v874 = (void *)__nw_create_backtrace_string();
                                                            logg = __nwlog_obj();
                                                            v852 = type[0];
                                                            v626 = os_log_type_enabled(logg, type[0]);
                                                            if (v874)
                                                            {
                                                              if (v626)
                                                              {
                                                                *(_DWORD *)buf = 136446466;
                                                                v902 = "__nw_frame_finalize";
                                                                v903 = 2082;
                                                                *(_QWORD *)v904 = v874;
                                                                _os_log_impl(&dword_209FB3000, logg, v852, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                                                              }
                                                              free(v874);
                                                              goto LABEL_1620;
                                                            }
                                                            if (v626)
                                                            {
                                                              *(_DWORD *)buf = 136446210;
                                                              v902 = "__nw_frame_finalize";
                                                              v623 = logg;
                                                              v624 = v852;
                                                              v625 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1619:
                                                              _os_log_impl(&dword_209FB3000, v623, v624, v625, buf, 0xCu);
                                                            }
                                                          }
LABEL_1620:
                                                          if (v889)
                                                            free(v889);
                                                          goto LABEL_1604;
                                                        }
                                                        v843 = DWORD1(v922) + v463;
                                                        v834 = DWORD1(v922);
                                                        if (DWORD1(v922) != *(_DWORD *)(v464 + 120) || *(_QWORD *)v464)
                                                        {
                                                          *(_DWORD *)type = 0;
                                                          if (*(_DWORD *)(v464 + 1916) - v843 < 0)
                                                          {
                                                            *(_DWORD *)(v464 + 1916) = v843;
                                                            if ((v896[0] & 1) != 0)
                                                              *(_DWORD *)(v464 + 1920) = DWORD1(v896[0]);
                                                          }
                                                          tcp_compute_rcv_rtt(v464, (uint64_t)v896, (uint64_t)&v922);
                                                          v470 = sysctls;
                                                          if (*(_DWORD *)(sysctls + 260))
                                                          {
                                                            tcp_sbrcv_grow(v839, v15 + 488, (uint64_t)v896, v463);
                                                            v470 = sysctls;
                                                          }
                                                          if (*(_DWORD *)(v470 + 308) == 1
                                                            && (~*(_DWORD *)(v839 + 88) & 0x180) == 0
                                                            && (*(_DWORD *)(v470 + 40) == 1
                                                             || (*(_BYTE *)(v15 + 369) & 0x40) != 0)
                                                            && off_253CF86A0)
                                                          {
                                                            off_253CF86A0(v839, (uint64_t)&v922, (uint64_t)v896, v463);
                                                          }
                                                          v471 = tcp_reass(v839, &v899, a1, v829, v848, v850, type);
                                                          if (*(_DWORD *)type)
                                                          {
                                                            if ((*(_WORD *)(v13 + 204) & 0x100) != 0
                                                              && *MEMORY[0x24BDE08C0]
                                                              && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v13, *(_QWORD *)(v13 + 88)) & 1) == 0)
                                                            {
                                                              if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                              {
                                                                v725 = __nwlog_tcp_log();
                                                                if (os_log_type_enabled(v725, OS_LOG_TYPE_INFO))
                                                                {
                                                                  v726 = "";
                                                                  if (v15)
                                                                    v726 = (const char *)(v15 + 604);
                                                                  *(_DWORD *)buf = 136446466;
                                                                  v902 = "tcp_input";
                                                                  v903 = 2082;
                                                                  *(_QWORD *)v904 = v726;
                                                                  _os_log_impl(&dword_209FB3000, v725, OS_LOG_TYPE_INFO, "%{public}s %{public}s frame no longer valid", buf, 0x16u);
                                                                }
                                                              }
                                                              *(_QWORD *)(v839 + 1056) = 0;
                                                            }
                                                            v55 = 0;
                                                            v44 = a1;
                                                            v43 = v892;
                                                            goto LABEL_1293;
                                                          }
                                                          v472 = v471;
                                                          *(_DWORD *)(v839 + 88) |= 1u;
                                                          v463 = v899;
                                                          if (v899 > 0)
                                                          {
                                                            v849 = 0;
                                                            goto LABEL_1589;
                                                          }
                                                          v849 = 0;
                                                          v486 = BYTE13(v922);
LABEL_1195:
                                                          if ((v486 & 1) == 0)
                                                          {
                                                            v464 = v839;
                                                            tcp_adaptive_rwtimo_check(v839, v463);
                                                            goto LABEL_1594;
                                                          }
LABEL_1589:
                                                          if ((*(_BYTE *)(v839 + 740) & 0x20) != 0)
                                                            tcp_update_sack_list((_DWORD *)v839, v834, v843 + (BYTE13(v922) & 1));
                                                          v464 = v839;
                                                          tcp_adaptive_rwtimo_check(v839, v463);
                                                          if (v463 >= 1 && *(_BYTE *)(v839 + 993))
                                                            *(_BYTE *)(v839 + 993) = 0;
LABEL_1594:
                                                          v473 = a1;
                                                          v120 = 0x253CF8000uLL;
                                                          v474 = *(_DWORD *)(v464 + 740);
                                                          if ((v474 & 0x10000000) != 0)
                                                            goto LABEL_1595;
                                                          goto LABEL_1157;
                                                        }
                                                        v490 = *a1;
                                                        if (*a1)
                                                        {
                                                          if ((*(_WORD *)(v490 + 204) & 0x80) != 0)
                                                          {
                                                            v491 = *(unsigned __int16 *)(v490 + 196);
                                                            if (v848 > v491)
                                                            {
                                                              __nwlog_obj();
                                                              v492 = *(unsigned __int16 *)(v490 + 196);
                                                              *(_DWORD *)buf = 136446722;
                                                              v902 = "__nw_frame_array_claim";
                                                              v903 = 1024;
                                                              *(_DWORD *)v904 = v492;
                                                              *(_WORD *)&v904[4] = 1024;
                                                              *(_DWORD *)&v904[6] = v848;
                                                              v493 = (void *)_os_log_send_and_compose_impl();
                                                              type[0] = OS_LOG_TYPE_ERROR;
                                                              v900 = 0;
                                                              if (__nwlog_fault())
                                                              {
                                                                if (type[0] == OS_LOG_TYPE_FAULT)
                                                                {
                                                                  v494 = __nwlog_obj();
                                                                  v495 = type[0];
                                                                  if (os_log_type_enabled(v494, type[0]))
                                                                  {
                                                                    v496 = *(unsigned __int16 *)(v490 + 196);
                                                                    *(_DWORD *)buf = 136446722;
                                                                    v902 = "__nw_frame_array_claim";
                                                                    v903 = 1024;
                                                                    *(_DWORD *)v904 = v496;
                                                                    *(_WORD *)&v904[4] = 1024;
                                                                    *(_DWORD *)&v904[6] = v848;
                                                                    v497 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_1533:
                                                                    v597 = v494;
                                                                    v598 = v495;
LABEL_1534:
                                                                    _os_log_impl(&dword_209FB3000, v597, v598, v497, buf, 0x18u);
                                                                  }
                                                                }
                                                                else if (v900)
                                                                {
                                                                  v578 = (void *)__nw_create_backtrace_string();
                                                                  v579 = __nwlog_obj();
                                                                  v580 = os_log_type_enabled(v579, type[0]);
                                                                  if (v578)
                                                                  {
                                                                    if (v580)
                                                                    {
                                                                      v581 = *(unsigned __int16 *)(v490 + 196);
                                                                      *(_DWORD *)buf = 136446978;
                                                                      v902 = "__nw_frame_array_claim";
                                                                      v903 = 1024;
                                                                      *(_DWORD *)v904 = v581;
                                                                      *(_WORD *)&v904[4] = 1024;
                                                                      *(_DWORD *)&v904[6] = v848;
                                                                      *(_WORD *)v905 = 2082;
                                                                      *(_QWORD *)&v905[2] = v578;
                                                                      _os_log_impl(&dword_209FB3000, v579, type[0], "%{public}s Aggregate buffer length: %u sum: %u, dumping backtrace:%{public}s", buf, 0x22u);
                                                                    }
                                                                    free(v578);
                                                                    goto LABEL_1535;
                                                                  }
                                                                  if (v580)
                                                                  {
                                                                    v644 = *(unsigned __int16 *)(v490 + 196);
                                                                    *(_DWORD *)buf = 136446722;
                                                                    v902 = "__nw_frame_array_claim";
                                                                    v903 = 1024;
                                                                    *(_DWORD *)v904 = v644;
                                                                    *(_WORD *)&v904[4] = 1024;
                                                                    *(_DWORD *)&v904[6] = v848;
                                                                    v497 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                                                                    v597 = v579;
                                                                    v598 = type[0];
                                                                    goto LABEL_1534;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  v494 = __nwlog_obj();
                                                                  v495 = type[0];
                                                                  if (os_log_type_enabled(v494, type[0]))
                                                                  {
                                                                    v596 = *(unsigned __int16 *)(v490 + 196);
                                                                    *(_DWORD *)buf = 136446722;
                                                                    v902 = "__nw_frame_array_claim";
                                                                    v903 = 1024;
                                                                    *(_DWORD *)v904 = v596;
                                                                    *(_WORD *)&v904[4] = 1024;
                                                                    *(_DWORD *)&v904[6] = v848;
                                                                    v497 = "%{public}s Aggregate buffer length: %u sum: %"
                                                                           "u, backtrace limit exceeded";
                                                                    goto LABEL_1533;
                                                                  }
                                                                }
                                                              }
LABEL_1535:
                                                              if (v493)
                                                                free(v493);
                                                              *(_WORD *)(v490 + 196) = 0;
LABEL_1538:
                                                              v599 = *a1;
                                                              if (*a1)
                                                              {
                                                                v600 = 0;
                                                                while (1)
                                                                {
                                                                  v601 = *(_DWORD *)(v599 + 52);
                                                                  v602 = *(_DWORD *)(v599 + 56);
                                                                  v603 = *(_DWORD *)(v599 + 60);
                                                                  v604 = v601 - (v602 + v603);
                                                                  if (v604 >= v848 - v600)
                                                                    v604 = v848 - v600;
                                                                  v605 = v601 ? v604 : 0;
                                                                  v606 = v602 + v605;
                                                                  if (v602 + v605 <= v601 - v603)
                                                                  {
                                                                    *(_DWORD *)(v599 + 56) = v606;
                                                                    *(_DWORD *)(v599 + 60) = v603;
                                                                  }
                                                                  else
                                                                  {
                                                                    v607 = __nwlog_obj();
                                                                    if (os_log_type_enabled(v607, OS_LOG_TYPE_ERROR))
                                                                    {
                                                                      v608 = *(_DWORD *)(v599 + 52);
                                                                      *(_DWORD *)buf = 136446978;
                                                                      v902 = "__nw_frame_claim_internal";
                                                                      v903 = 1024;
                                                                      *(_DWORD *)v904 = v606;
                                                                      *(_WORD *)&v904[4] = 1024;
                                                                      *(_DWORD *)&v904[6] = v608;
                                                                      *(_WORD *)v905 = 1024;
                                                                      *(_DWORD *)&v905[2] = v603;
                                                                      _os_log_impl(&dword_209FB3000, v607, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
                                                                    }
                                                                  }
                                                                  v600 += v605;
                                                                  if (v600 == (_DWORD)v848)
                                                                    break;
                                                                  if (v600 < v848)
                                                                  {
                                                                    v599 = *(_QWORD *)(v599 + 32);
                                                                    if (v599)
                                                                      continue;
                                                                  }
                                                                  goto LABEL_1554;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                v600 = 0;
LABEL_1554:
                                                                if (v600 != (_DWORD)v848)
                                                                {
                                                                  v609 = __nwlog_obj();
                                                                  if (os_log_type_enabled(v609, OS_LOG_TYPE_ERROR))
                                                                  {
                                                                    *(_DWORD *)buf = 136446722;
                                                                    v902 = "__nw_frame_array_claim";
                                                                    v903 = 1024;
                                                                    *(_DWORD *)v904 = v600;
                                                                    *(_WORD *)&v904[4] = 1024;
                                                                    *(_DWORD *)&v904[6] = v848;
                                                                    _os_log_impl(&dword_209FB3000, v609, OS_LOG_TYPE_ERROR, "%{public}s start_offset %u != start_bytes %u", buf, 0x18u);
                                                                  }
                                                                }
                                                              }
LABEL_1557:
                                                              if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                              {
                                                                if (__nwlog_is_datapath_logging_enabled())
                                                                {
                                                                  v774 = __nwlog_tcp_log();
                                                                  if (os_log_type_enabled(v774, OS_LOG_TYPE_DEBUG))
                                                                  {
                                                                    v775 = (const char *)(v15 + 604);
                                                                    v902 = "tcp_input";
                                                                    *(_DWORD *)buf = 136446722;
                                                                    if (!v15)
                                                                      v775 = "";
                                                                    v903 = 2082;
                                                                    *(_QWORD *)v904 = v775;
                                                                    *(_WORD *)&v904[8] = 1024;
                                                                    *(_DWORD *)v905 = v463;
                                                                    _os_log_impl(&dword_209FB3000, v774, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s queueing frame of length %u - slowpath", buf, 0x1Cu);
                                                                  }
                                                                }
                                                              }
                                                              *(_WORD *)(v839 + 304) += v825;
                                                              tcp_compute_rcv_rtt(v839, (uint64_t)v896, (uint64_t)&v922);
                                                              v610 = *(unsigned int (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v839 + 264)] + 96);
                                                              if (v610
                                                                && v610(v839, &v922)
                                                                && (v611 = *(_DWORD *)(v839 + 88), (v611 & 1) == 0))
                                                              {
                                                                if ((v611 & 2) == 0)
                                                                {
                                                                  *(_DWORD *)(v839 + 88) = v611 | 2;
                                                                  *(_DWORD *)(v839 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v839 + 80) + 224)) + 316)
                                                                                         - *(_DWORD *)(v839 + 64)
                                                                                         + 100;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                *(_DWORD *)(v839 + 88) |= 1u;
                                                              }
                                                              v612 = *(_DWORD *)(v839 + 120) + v463;
                                                              *(_DWORD *)(v839 + 120) = v612;
                                                              if (*(_DWORD *)(v839 + 1916) - v612 < 0)
                                                              {
                                                                *(_DWORD *)(v839 + 1916) = v612;
                                                                if ((v896[0] & 1) != 0)
                                                                  *(_DWORD *)(v839 + 1920) = DWORD1(v896[0]);
                                                              }
                                                              v613 = *(_QWORD *)(v839 + 1056);
                                                              if (v613)
                                                              {
                                                                v614 = *(_QWORD *)(v613 + 200) + v463;
                                                                ++*(_QWORD *)(v613 + 192);
                                                                *(_QWORD *)(v613 + 200) = v614;
                                                              }
                                                              v615 = BYTE13(v922);
                                                              v616 = *(_QWORD **)(a3 + 248);
                                                              ++*v616;
                                                              if (v819)
                                                              {
                                                                ++**(_QWORD **)(a3 + 256);
                                                                if (!v826)
                                                                  goto LABEL_1573;
                                                              }
                                                              else if (!v826)
                                                              {
LABEL_1573:
                                                                if (!v818)
                                                                  goto LABEL_1575;
                                                                goto LABEL_1574;
                                                              }
                                                              ++**(_QWORD **)(a3 + 264);
                                                              if (!v818)
                                                              {
LABEL_1575:
                                                                v616[1] += v463;
                                                                if (v819)
                                                                {
                                                                  *(_QWORD *)(*(_QWORD *)(a3 + 256) + 8) += v463;
                                                                  if (!v826)
                                                                    goto LABEL_1577;
                                                                }
                                                                else if (!v826)
                                                                {
LABEL_1577:
                                                                  if (!v818)
                                                                    goto LABEL_1579;
                                                                  goto LABEL_1578;
                                                                }
                                                                *(_QWORD *)(*(_QWORD *)(a3 + 264) + 8) += v463;
                                                                if (!v818)
                                                                {
LABEL_1579:
                                                                  v472 = v615 & 1;
                                                                  tcp_sbrcv_grow(v839, v15 + 488, (uint64_t)v896, v463);
                                                                  if (*(_DWORD *)(sysctls + 308) == 1
                                                                    && (~*(_DWORD *)(v839 + 88) & 0x180) == 0
                                                                    && (*(_DWORD *)(sysctls + 40) == 1
                                                                     || (*(_BYTE *)(v15 + 369) & 0x40) != 0)
                                                                    && off_253CF86A0)
                                                                  {
                                                                    off_253CF86A0(v839, (uint64_t)&v922, (uint64_t)v896, v463);
                                                                  }
                                                                  v486 = BYTE13(v922);
                                                                  *(_DWORD *)(v839 + 740) = *(_DWORD *)(v839 + 740) & 0xFFFFFFEF | (16 * ((BYTE13(v922) >> 3) & 1));
                                                                  if (v463 >= 1)
                                                                  {
                                                                    v617 = tcp_input_sbappendstream(v15, a1, v463, 2);
                                                                    v849 = 0;
                                                                    if (v850 && v617)
                                                                    {
                                                                      v849 = 0;
                                                                      *v850 = 1;
                                                                    }
                                                                    goto LABEL_1589;
                                                                  }
                                                                  goto LABEL_1195;
                                                                }
LABEL_1578:
                                                                *(_QWORD *)(*(_QWORD *)(a3 + 272) + 8) += v463;
                                                                goto LABEL_1579;
                                                              }
LABEL_1574:
                                                              ++**(_QWORD **)(a3 + 272);
                                                              goto LABEL_1575;
                                                            }
                                                            *(_WORD *)(v490 + 196) = v491 - v848;
                                                          }
LABEL_1422:
                                                          if (!(_DWORD)v848)
                                                            goto LABEL_1557;
                                                          goto LABEL_1538;
                                                        }
                                                        __nwlog_obj();
                                                        *(_DWORD *)buf = 136446210;
                                                        v902 = "__nw_frame_is_single_ip_aggregate";
                                                        v770 = (void *)_os_log_send_and_compose_impl();
                                                        type[0] = OS_LOG_TYPE_ERROR;
                                                        v900 = 0;
                                                        if (__nwlog_fault())
                                                        {
                                                          if (type[0] == OS_LOG_TYPE_FAULT)
                                                          {
                                                            v771 = __nwlog_obj();
                                                            v772 = type[0];
                                                            if (!os_log_type_enabled(v771, type[0]))
                                                              goto LABEL_2048;
                                                            *(_DWORD *)buf = 136446210;
                                                            v902 = "__nw_frame_is_single_ip_aggregate";
                                                            v773 = "%{public}s called with null frame";
LABEL_2046:
                                                            v789 = v771;
                                                            v790 = v772;
LABEL_2047:
                                                            _os_log_impl(&dword_209FB3000, v789, v790, v773, buf, 0xCu);
                                                            goto LABEL_2048;
                                                          }
                                                          if (!v900)
                                                          {
                                                            v771 = __nwlog_obj();
                                                            v772 = type[0];
                                                            if (!os_log_type_enabled(v771, type[0]))
                                                              goto LABEL_2048;
                                                            *(_DWORD *)buf = 136446210;
                                                            v902 = "__nw_frame_is_single_ip_aggregate";
                                                            v773 = "%{public}s called with null frame, backtrace limit exceeded";
                                                            goto LABEL_2046;
                                                          }
                                                          v778 = (void *)__nw_create_backtrace_string();
                                                          v779 = __nwlog_obj();
                                                          v780 = os_log_type_enabled(v779, type[0]);
                                                          if (v778)
                                                          {
                                                            if (v780)
                                                            {
                                                              *(_DWORD *)buf = 136446466;
                                                              v902 = "__nw_frame_is_single_ip_aggregate";
                                                              v903 = 2082;
                                                              *(_QWORD *)v904 = v778;
                                                              _os_log_impl(&dword_209FB3000, v779, type[0], "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                                                            }
                                                            free(v778);
                                                            goto LABEL_2048;
                                                          }
                                                          if (v780)
                                                          {
                                                            *(_DWORD *)buf = 136446210;
                                                            v902 = "__nw_frame_is_single_ip_aggregate";
                                                            v773 = "%{public}s called with null frame, no backtrace";
                                                            v789 = v779;
                                                            v790 = type[0];
                                                            goto LABEL_2047;
                                                          }
                                                        }
LABEL_2048:
                                                        if (v770)
                                                          free(v770);
                                                        goto LABEL_1422;
                                                      }
                                                      if ((*(_WORD *)(v13 + 204) & 0x100) == 0
                                                        || !*MEMORY[0x24BDE08C0]
                                                        || (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v13, *(_QWORD *)(v13 + 88)) & 1) != 0)
                                                      {
                                                        v923 = 0;
                                                        v43 = v892;
                                                        if (&v922 != (__int128 *)v830)
                                                          *(_WORD *)(v830 + 18) = 0;
                                                        v465 &= ~0x20u;
                                                        goto LABEL_1126;
                                                      }
                                                      v808 = v464;
                                                      v641 = v15;
                                                      if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                      {
                                                        v809 = __nwlog_tcp_log();
                                                        if (os_log_type_enabled(v809, OS_LOG_TYPE_INFO))
                                                        {
                                                          v810 = "";
                                                          if (v15)
                                                            v810 = (const char *)(v15 + 604);
                                                          *(_DWORD *)buf = 136446466;
                                                          v902 = "tcp_input";
                                                          v903 = 2082;
                                                          *(_QWORD *)v904 = v810;
                                                          _os_log_impl(&dword_209FB3000, v809, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping tcp input frame since frame is no longer valid", buf, 0x16u);
                                                        }
                                                      }
                                                      *(_QWORD *)(v808 + 1056) = 0;
                                                      v44 = a1;
LABEL_1686:
                                                      v43 = v892;
                                                      v55 = v849;
                                                      v15 = v641;
                                                      goto LABEL_1293;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    v835 = 0;
                                                    v410 = 0;
                                                    v847 = 0;
                                                    v18 = v817;
                                                    a3 = v815;
                                                    LOBYTE(v413) = v528;
                                                  }
LABEL_1226:
                                                  LOBYTE(v883) = v413;
                                                  v120 = v412;
                                                  v500 = *(_DWORD *)(v412 + 348);
                                                  if ((v500 & 0x20) != 0)
                                                  {
                                                    v500 &= ~0x20u;
                                                    *(_DWORD *)(v412 + 348) = v500;
                                                  }
                                                  v501 = *(_DWORD *)(v412 + 8);
                                                  v502 = *(_QWORD *)(v120 + 1056);
                                                  if (v502)
                                                    ++*(_QWORD *)(v502 + 176);
                                                  v503 = *(_DWORD *)(v120 + 740);
                                                  if ((v503 & 0x20) != 0)
                                                  {
                                                    v505 = HIDWORD(v898);
                                                    v561 = *(_DWORD *)(v120 + 196);
                                                    if (v561 <= HIDWORD(v898))
                                                      v562 = HIDWORD(v898) / v561;
                                                    else
                                                      v562 = 1;
                                                    v504 = v501 + v562;
                                                  }
                                                  else
                                                  {
                                                    v504 = v501 + 1;
                                                    v505 = HIDWORD(v898);
                                                  }
                                                  *(_DWORD *)(v120 + 8) = v504;
                                                  *(_DWORD *)(v120 + 628) += v505;
                                                  if (v505 && (v503 & 0x10000000) == 0)
                                                  {
                                                    v582 = (v503 & 0x8000000) == 0;
                                                    if (*(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1)
                                                      v582 = 0;
                                                    if ((~v500 & 0x300004) == 0 && !v582 && *(_DWORD *)(v120 + 12) == 4)
                                                    {
                                                      v584 = *(_DWORD *)(v120 + 196);
                                                      if (v505 / v584 * v584 == v505)
                                                        v585 = v505 / v584;
                                                      else
                                                        v585 = v505 / v584 + 1;
                                                      *(_DWORD *)(v120 + 296) += v585;
                                                      tcp_process_accecn(v120, (uint64_t)v896, (uint64_t)&v922, v585, v821);
                                                    }
                                                  }
                                                  if (*(_WORD *)(v120 + 268)
                                                    && *(_DWORD *)(v837 + 316) - *(_DWORD *)(v120 + 272) - 60000 >= 0)
                                                  {
                                                    *(_WORD *)(v120 + 268) = 0;
                                                  }
                                                  if ((*(_BYTE *)(v120 + 90) & 0x20) == 0)
                                                    tcp_early_rexmt_check(v120);
                                                  v586 = (*(_DWORD *)(v120 + 740) & 0x20400020) == 0x20000020
                                                      && tcp_rack_detect_loss_and_arm_timer(v120, *(_DWORD *)(v120 + 8));
                                                  if (!*(_DWORD *)(v120 + 28)
                                                    || (v587 = *(_DWORD *)(v120 + 92), DWORD2(v922) != v587) && !v505)
                                                  {
                                                    v412 = v120;
                                                    *(_DWORD *)(v120 + 8) = 0;
                                                    *(_BYTE *)(v120 + 310) = 3;
                                                    goto LABEL_1113;
                                                  }
                                                  v588 = *(_DWORD *)(v120 + 740);
                                                  if ((v588 & 0x20400020) != 0x20000020
                                                    && (v594 = *(unsigned __int8 *)(v120 + 310),
                                                        *(_DWORD *)(v120 + 8) > (signed int)v594)
                                                    && v501 >= v594
                                                    || (v589 = *(_DWORD *)(v120 + 88), (v589 & 0x200000) != 0))
                                                  {
                                                    if ((v588 & 0x20) == 0)
                                                      goto LABEL_1523;
                                                    v639 = *(_DWORD *)(v120 + 88);
                                                    if ((~v588 & 0x6000) == 0 && (v639 & 0x200000) == 0)
                                                      goto LABEL_1112;
                                                    if ((v639 & 0x200000) != 0)
                                                    {
                                                      v595 = *(_DWORD *)(v120 + 148);
                                                      if (*(_DWORD *)(v120 + 100)
                                                         - *(_DWORD *)(v120 + 560)
                                                         + *(_DWORD *)(v120 + 624) >= v595)
                                                        goto LABEL_1525;
                                                      if (*(_DWORD *)(v120 + 144) + *(_DWORD *)(v120 + 196) < v595)
                                                        v595 = *(_DWORD *)(v120 + 144) + *(_DWORD *)(v120 + 196);
                                                    }
                                                    else
                                                    {
LABEL_1523:
                                                      v595 = *(_DWORD *)(v120 + 144) + *(_DWORD *)(v120 + 196);
                                                    }
                                                    *(_DWORD *)(v120 + 144) = v595;
                                                    goto LABEL_1525;
                                                  }
                                                  if (!v586)
                                                  {
                                                    v648 = *(_DWORD *)(v120 + 8);
                                                    if ((v588 & 0x20400020) == 0x20000020
                                                      || v648 < *(unsigned __int8 *)(v120 + 310))
                                                    {
                                                      if (v648 >= 1)
                                                      {
                                                        v649 = ~v588 & 0x6000;
                                                        v650 = (v588 & 0x20) != 0 && v505 == 0;
                                                        v651 = !v650;
                                                        if (v649
                                                          && v648 < *(unsigned __int8 *)(v120 + 310)
                                                          && v651
                                                          && v587 - *(_DWORD *)(v120 + 96) + *(_DWORD *)(v15 + 384))
                                                        {
                                                          v652 = *(_DWORD *)(v120 + 196) * v648;
                                                          *(_DWORD *)(v120 + 144) += v652;
                                                          v653 = *(_QWORD *)(v120 + 1056);
                                                          if (v653)
                                                            ++*(_QWORD *)(v653 + 688);
                                                          if (tcp_output(v120)
                                                            && (*(_WORD *)(v13 + 204) & 0x100) != 0
                                                            && *MEMORY[0x24BDE08C0]
                                                            && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v13, *(_QWORD *)(v13 + 88)) & 1) == 0)
                                                          {
                                                            goto LABEL_2098;
                                                          }
                                                          v412 = v120;
                                                          *(_DWORD *)(v120 + 144) -= v652;
                                                          goto LABEL_1113;
                                                        }
                                                      }
                                                      goto LABEL_1112;
                                                    }
                                                  }
                                                  v590 = *(_DWORD *)(v120 + 100);
                                                  if ((v588 & 0x20) == 0)
                                                  {
                                                    if (DWORD2(v922) - *(_DWORD *)(v120 + 152) <= 0)
                                                    {
                                                      v412 = v120;
                                                      *(_DWORD *)(v120 + 8) = 0;
                                                      goto LABEL_1113;
                                                    }
LABEL_1724:
                                                    *(_DWORD *)(v120 + 152) = *(_DWORD *)(v120 + 96)
                                                                            + (v589 << 27 >> 31);
                                                    *(_DWORD *)(v120 + 16) = 0;
                                                    *(_DWORD *)(v120 + 172) = 0;
                                                    if ((v588 & 0x6020) == 0x2020
                                                      && *(_WORD *)(v120 + 536)
                                                      && (*(_DWORD *)(v120 + 12) | 2) == 6)
                                                    {
                                                      *(_DWORD *)(v120 + 20) = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v120 + 80) + 224))
                                                                                         + 316)
                                                                             + *(unsigned __int16 *)(v120 + 536)
                                                                             - *(_DWORD *)(v120 + 64);
                                                      *(_DWORD *)(v120 + 740) |= 0x4000u;
                                                      v665 = *(_QWORD *)(v120 + 1056);
                                                      if (v665)
                                                        ++*(_QWORD *)(v665 + 984);
                                                      goto LABEL_1112;
                                                    }
                                                    tcp_rexmt_save_state(v120);
                                                    v666 = *(void (**)(unint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v120 + 264)] + 64);
                                                    if (v666)
                                                      v666(v120);
                                                    *(_DWORD *)(v120 + 88) |= 0x200000u;
                                                    v667 = *(_QWORD *)(v120 + 80);
                                                    if ((*(_BYTE *)(v667 + 2231) & 0x40) != 0)
                                                      inp_reset_fc_state(v667);
                                                    if (*(_QWORD *)(v120 + 952))
                                                      tcp_rxtseg_clean(v120);
                                                    *(_DWORD *)(v120 + 28) = 0;
                                                    v668 = *(_DWORD *)(v120 + 740);
                                                    if ((v668 & 0x10000000) != 0)
                                                    {
                                                      v671 = *(_DWORD *)(v120 + 348);
                                                    }
                                                    else
                                                    {
                                                      v670 = tcp_do_acc_ecn != 1
                                                          && *(_DWORD *)(sysctls + 320) != 1
                                                          && (v668 & 0x8000000) == 0;
                                                      v671 = *(_DWORD *)(v120 + 348);
                                                      if (!v670 && (v671 & 0x300000) == 0x300000)
                                                      {
LABEL_1854:
                                                        if ((v668 & 0x20) == 0)
                                                        {
                                                          *(_DWORD *)(v120 + 100) = DWORD2(v922);
                                                          *(_DWORD *)(v120 + 144) = *(_DWORD *)(v120 + 196);
                                                          *(_DWORD *)(v120 + 740) = v668 & 0xFFEFFFFF;
                                                          if (v822 > *(_DWORD *)(v120 + 140))
                                                            tcp_update_window(v120, v413, (uint64_t)&v922, v822, v835);
                                                          tcp_output(v120);
                                                          if ((*(_BYTE *)(v120 + 742) & 0x10) != 0)
                                                            tcp_cc_adjust_nonvalidated_cwnd(v120);
                                                          else
                                                            *(_DWORD *)(v120 + 144) = *(_DWORD *)(v120 + 148)
                                                                                    + *(_DWORD *)(v120 + 8)
                                                                                    * *(_DWORD *)(v120 + 196);
                                                          if (v590 - *(_DWORD *)(v120 + 100) >= 1)
                                                            *(_DWORD *)(v120 + 100) = v590;
                                                          goto LABEL_1291;
                                                        }
                                                        v709 = *(_QWORD *)(v120 + 1056);
                                                        if ((v668 & 0x20400000) == 0x20000000)
                                                        {
                                                          if (v709)
                                                            ++*(_QWORD *)(v709 + 624);
                                                          ++*(_DWORD *)(v120 + 1008);
                                                        }
                                                        else
                                                        {
                                                          if (v709)
                                                            ++*(_QWORD *)(v709 + 568);
                                                          ++*(_DWORD *)(v120 + 1004);
                                                        }
                                                        *(_DWORD *)(v120 + 144) = *(_DWORD *)(v120 + 148);
                                                        *(_DWORD *)(v120 + 740) = v668 & 0xFFEFFFFF;
LABEL_1525:
                                                        if (v822 > *(_DWORD *)(v120 + 140))
                                                          tcp_update_window(v120, v413, (uint64_t)&v922, v822, v835);
                                                        tcp_output(v120);
                                                        goto LABEL_1291;
                                                      }
                                                    }
                                                    if ((~v671 & 3) == 0)
                                                      *(_DWORD *)(v120 + 348) = v671 | 8;
                                                    goto LABEL_1854;
                                                  }
                                                  if ((v588 & 0x4000) == 0)
                                                    goto LABEL_1724;
LABEL_1112:
                                                  v412 = v120;
LABEL_1113:
                                                  v120 = 0x253CF8000uLL;
                                                  LOBYTE(v413) = v883;
                                                  goto LABEL_1114;
                                                }
                                                v847 = 0;
                                              }
LABEL_1392:
                                              v18 = v817;
                                              a3 = v815;
                                              v120 = 0x253CF8000;
                                              LOBYTE(v413) = v528;
                                              goto LABEL_1114;
                                            }
                                            v781 = __nwlog_obj();
                                            os_log_type_enabled(v781, OS_LOG_TYPE_ERROR);
                                            *(_DWORD *)buf = 136446210;
                                            v902 = "tcp_input";
                                            v782 = (void *)_os_log_send_and_compose_impl();
                                            if (!__nwlog_abort())
                                            {
                                              free(v782);
                                              v676 = *(_BYTE *)(v412 + 988);
                                              goto LABEL_1773;
                                            }
LABEL_2097:
                                            __break(1u);
LABEL_2098:
                                            if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                            {
                                              v811 = __nwlog_tcp_log();
                                              if (os_log_type_enabled(v811, OS_LOG_TYPE_INFO))
                                              {
                                                v812 = "";
                                                if (v15)
                                                  v812 = (const char *)(v15 + 604);
                                                *(_DWORD *)buf = 136446466;
                                                v902 = "tcp_input";
                                                v903 = 2082;
                                                *(_QWORD *)v904 = v812;
                                                _os_log_impl(&dword_209FB3000, v811, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping input packet since frame is no longer valid", buf, 0x16u);
                                              }
                                            }
                                            *(_QWORD *)(v120 + 1056) = 0;
                                            goto LABEL_1291;
                                          }
                                          if (tcp_is_ack_ratelimited(v122))
                                            goto LABEL_1291;
                                          v530 = *(_QWORD *)(v122 + 1056);
                                          if (v530)
                                            ++*(_QWORD *)(v530 + 104);
                                          v44 = a1;
                                          v43 = v892;
                                          v132 = v824;
LABEL_1298:
                                          if (*(_DWORD *)(v122 + 12) != 3
                                            || (v131 & 0x10) == 0
                                            || *(_DWORD *)(v122 + 92) - DWORD2(v922) <= 0
                                            && DWORD2(v922) - *(_DWORD *)(v122 + 96) <= 0)
                                          {
                                            *(_DWORD *)(v122 + 88) |= 1u;
                                            tcp_output(v122);
                                            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 8)
                                                                                              + 24))(v15, 1, v6);
                                            *v43 = v849 != 0;
                                            result = (_QWORD *)*v44;
                                            if (!*v44)
                                              return result;
                                            while (1)
                                            {
                                              v531 = (void (*)(_QWORD *, uint64_t, uint64_t))result[10];
                                              v532 = (_QWORD *)result[4];
                                              if (!v531)
                                                break;
                                              v533 = result[11];
                                              result[10] = 0;
                                              result[11] = 0;
                                              v531(result, 1, v533);
LABEL_1305:
                                              result = v532;
                                              if (!v532)
                                                return result;
                                            }
                                            __nwlog_obj();
                                            *(_DWORD *)buf = 136446210;
                                            v902 = "__nw_frame_finalize";
                                            v534 = _os_log_send_and_compose_impl();
                                            type[0] = OS_LOG_TYPE_ERROR;
                                            v900 = 0;
                                            v888 = (void *)v534;
                                            if (__nwlog_fault())
                                            {
                                              if (type[0] == OS_LOG_TYPE_FAULT)
                                              {
                                                v870 = __nwlog_obj();
                                                if (!os_log_type_enabled(v870, type[0]))
                                                  goto LABEL_1321;
                                                *(_DWORD *)buf = 136446210;
                                                v902 = "__nw_frame_finalize";
                                                v535 = v870;
                                                v536 = type[0];
                                                v537 = "%{public}s called with null frame->finalizer";
                                                goto LABEL_1320;
                                              }
                                              if (!v900)
                                              {
                                                v872 = __nwlog_obj();
                                                if (!os_log_type_enabled(v872, type[0]))
                                                  goto LABEL_1321;
                                                *(_DWORD *)buf = 136446210;
                                                v902 = "__nw_frame_finalize";
                                                v535 = v872;
                                                v536 = type[0];
                                                v537 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                                                goto LABEL_1320;
                                              }
                                              v871 = (void *)__nw_create_backtrace_string();
                                              loge = __nwlog_obj();
                                              v538 = os_log_type_enabled(loge, type[0]);
                                              if (v871)
                                              {
                                                if (v538)
                                                {
                                                  *(_DWORD *)buf = 136446466;
                                                  v902 = "__nw_frame_finalize";
                                                  v903 = 2082;
                                                  *(_QWORD *)v904 = v871;
                                                  _os_log_impl(&dword_209FB3000, loge, type[0], "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                                                }
                                                free(v871);
                                                goto LABEL_1321;
                                              }
                                              if (v538)
                                              {
                                                *(_DWORD *)buf = 136446210;
                                                v902 = "__nw_frame_finalize";
                                                v535 = loge;
                                                v536 = type[0];
                                                v537 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1320:
                                                _os_log_impl(&dword_209FB3000, v535, v536, v537, buf, 0xCu);
                                              }
                                            }
LABEL_1321:
                                            if (v888)
                                              free(v888);
                                            goto LABEL_1305;
                                          }
LABEL_278:
                                          if ((v131 & 4) == 0)
                                          {
                                            if ((v131 & 0x10) != 0)
                                            {
                                              v136 = DWORD2(v922);
                                              v134 = v122;
                                              v135 = v13;
                                              v133 = 0;
                                              v137 = 4;
                                            }
                                            else
                                            {
                                              v133 = v899 + ((v131 >> 1) & 1) + DWORD1(v922);
                                              v134 = v122;
                                              v135 = v13;
                                              v136 = 0;
                                              v137 = 20;
                                            }
                                            tcp_respond(v134, &v922, v135, v133, v136, v137, 0);
                                            if (v132)
                                              soabort(v15);
                                            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 8)
                                                                                              + 24))(v15, 1, v6);
                                            *v43 = v849 != 0;
                                            result = (_QWORD *)*v44;
                                            if (!*v44)
                                              return result;
                                            while (1)
                                            {
                                              v142 = (void (*)(_QWORD *, uint64_t, uint64_t))result[10];
                                              v143 = (_QWORD *)result[4];
                                              if (!v142)
                                                break;
                                              v144 = result[11];
                                              result[10] = 0;
                                              result[11] = 0;
                                              v142(result, 1, v144);
LABEL_302:
                                              result = v143;
                                              if (!v143)
                                                return result;
                                            }
                                            __nwlog_obj();
                                            *(_DWORD *)buf = 136446210;
                                            v902 = "__nw_frame_finalize";
                                            v145 = _os_log_send_and_compose_impl();
                                            type[0] = OS_LOG_TYPE_ERROR;
                                            v900 = 0;
                                            v884 = (void *)v145;
                                            if (__nwlog_fault())
                                            {
                                              if (type[0] == OS_LOG_TYPE_FAULT)
                                              {
                                                v867 = __nwlog_obj();
                                                if (!os_log_type_enabled(v867, type[0]))
                                                  goto LABEL_318;
                                                *(_DWORD *)buf = 136446210;
                                                v902 = "__nw_frame_finalize";
                                                v146 = v867;
                                                v147 = type[0];
                                                v148 = "%{public}s called with null frame->finalizer";
                                                goto LABEL_317;
                                              }
                                              if (!v900)
                                              {
                                                v869 = __nwlog_obj();
                                                if (!os_log_type_enabled(v869, type[0]))
                                                  goto LABEL_318;
                                                *(_DWORD *)buf = 136446210;
                                                v902 = "__nw_frame_finalize";
                                                v146 = v869;
                                                v147 = type[0];
                                                v148 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                                                goto LABEL_317;
                                              }
                                              v868 = (void *)__nw_create_backtrace_string();
                                              logd = __nwlog_obj();
                                              v149 = os_log_type_enabled(logd, type[0]);
                                              if (v868)
                                              {
                                                if (v149)
                                                {
                                                  *(_DWORD *)buf = 136446466;
                                                  v902 = "__nw_frame_finalize";
                                                  v903 = 2082;
                                                  *(_QWORD *)v904 = v868;
                                                  _os_log_impl(&dword_209FB3000, logd, type[0], "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                                                }
                                                free(v868);
                                                goto LABEL_318;
                                              }
                                              if (v149)
                                              {
                                                *(_DWORD *)buf = 136446210;
                                                v902 = "__nw_frame_finalize";
                                                v146 = logd;
                                                v147 = type[0];
                                                v148 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_317:
                                                _os_log_impl(&dword_209FB3000, v146, v147, v148, buf, 0xCu);
                                              }
                                            }
LABEL_318:
                                            if (v884)
                                              free(v884);
                                            goto LABEL_302;
                                          }
                                          goto LABEL_1331;
                                        }
                                        v300 = v44;
                                        __nwlog_obj();
                                        *(_DWORD *)buf = 136446210;
                                        v902 = "__nw_frame_is_single_ip_aggregate";
                                        v705 = (void *)_os_log_send_and_compose_impl();
                                        type[0] = OS_LOG_TYPE_ERROR;
                                        v900 = 0;
                                        if (__nwlog_fault())
                                        {
                                          if (type[0] == OS_LOG_TYPE_FAULT)
                                          {
                                            v706 = __nwlog_obj();
                                            v707 = type[0];
                                            if (!os_log_type_enabled(v706, type[0]))
                                              goto LABEL_1993;
                                            *(_DWORD *)buf = 136446210;
                                            v902 = "__nw_frame_is_single_ip_aggregate";
                                            v708 = "%{public}s called with null frame";
LABEL_1991:
                                            v753 = v706;
                                            v754 = v707;
LABEL_1992:
                                            _os_log_impl(&dword_209FB3000, v753, v754, v708, buf, 0xCu);
                                            goto LABEL_1993;
                                          }
                                          if (!v900)
                                          {
                                            v706 = __nwlog_obj();
                                            v707 = type[0];
                                            if (!os_log_type_enabled(v706, type[0]))
                                              goto LABEL_1993;
                                            *(_DWORD *)buf = 136446210;
                                            v902 = "__nw_frame_is_single_ip_aggregate";
                                            v708 = "%{public}s called with null frame, backtrace limit exceeded";
                                            goto LABEL_1991;
                                          }
                                          v717 = (void *)__nw_create_backtrace_string();
                                          v718 = __nwlog_obj();
                                          v719 = os_log_type_enabled(v718, type[0]);
                                          if (v717)
                                          {
                                            if (v719)
                                            {
                                              *(_DWORD *)buf = 136446466;
                                              v902 = "__nw_frame_is_single_ip_aggregate";
                                              v903 = 2082;
                                              *(_QWORD *)v904 = v717;
                                              _os_log_impl(&dword_209FB3000, v718, type[0], "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                                            }
                                            free(v717);
                                            goto LABEL_1993;
                                          }
                                          if (v719)
                                          {
                                            *(_DWORD *)buf = 136446210;
                                            v902 = "__nw_frame_is_single_ip_aggregate";
                                            v708 = "%{public}s called with null frame, no backtrace";
                                            v753 = v718;
                                            v754 = type[0];
                                            goto LABEL_1992;
                                          }
                                        }
LABEL_1993:
                                        if (v705)
                                          free(v705);
                                        goto LABEL_1248;
                                      }
                                    }
                                    else
                                    {
                                      v297 = v264;
                                      if ((int)v264 > v293)
                                        goto LABEL_750;
                                      if (DWORD1(v922) == v291 && !v292)
                                      {
                                        *(_DWORD *)(v839 + 88) |= 1u;
                                        goto LABEL_750;
                                      }
                                    }
                                    v43 = v892;
                                    v122 = v839;
                                    v132 = v824;
                                    goto LABEL_1298;
                                  }
                                  v235 = v883;
                                  if ((v883 & 2) == 0)
                                  {
LABEL_679:
                                    v275 = v122;
                                    v276 = v899;
                                    if (v233 <= v899 && ((v235 & 1) != 0 || v233 != v899))
                                    {
                                      v284 = *(_QWORD *)(v275 + 1056);
                                      if (!v284)
                                      {
                                        v282 = v235;
                                        v43 = v892;
                                        v283 = v826;
LABEL_695:
                                        if (v233 >= 2)
                                        {
                                          v285 = DWORD1(v922);
                                          *(_DWORD *)(v275 + 940) = DWORD1(v922);
                                          *(_DWORD *)(v275 + 944) = v285 + v233;
                                          *(_DWORD *)(v275 + 88) |= 1u;
                                        }
                                        v286 = *(_QWORD **)(a3 + 248);
                                        ++*v286;
                                        if (v819)
                                        {
                                          ++**(_QWORD **)(a3 + 256);
                                          if (!v283)
                                            goto LABEL_699;
                                        }
                                        else if (!v283)
                                        {
LABEL_699:
                                          if (!v18)
                                            goto LABEL_701;
                                          goto LABEL_700;
                                        }
                                        ++**(_QWORD **)(a3 + 264);
                                        if (!v18)
                                        {
LABEL_701:
                                          v286[1] += v233;
                                          if (v819)
                                          {
                                            *(_QWORD *)(*(_QWORD *)(a3 + 256) + 8) += v233;
                                            if (!v283)
                                              goto LABEL_703;
                                          }
                                          else if (!v283)
                                          {
LABEL_703:
                                            if (!v18)
                                            {
LABEL_705:
                                              *(_DWORD *)(v275 + 704) += v233;
                                              if (*(_QWORD *)(v15 + 24))
                                              {
                                                v287 = nw_protocol_tcp_get_all_stats();
                                                if (v287)
                                                  *(_DWORD *)(v287 + 48) += v233;
                                              }
                                              if ((*(_WORD *)(v13 + 204) & 0x100) != 0
                                                && *MEMORY[0x24BDE08C0]
                                                && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v13, *(_QWORD *)(v13 + 88)) & 1) == 0)
                                              {
                                                v44 = a1;
                                                v641 = v15;
                                                if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                                {
                                                  v663 = __nwlog_tcp_log();
                                                  if (os_log_type_enabled(v663, OS_LOG_TYPE_INFO))
                                                  {
                                                    v664 = "";
                                                    if (v15)
                                                      v664 = (const char *)(v15 + 604);
                                                    *(_DWORD *)buf = 136446466;
                                                    v902 = "tcp_input";
                                                    v903 = 2082;
                                                    *(_QWORD *)v904 = v664;
                                                    _os_log_impl(&dword_209FB3000, v663, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping tcp input frame since frame is no longer valid", buf, 0x16u);
                                                  }
                                                }
                                                *(_QWORD *)(v275 + 1056) = 0;
                                                goto LABEL_1686;
                                              }
                                              v234 = v233 + v848;
                                              DWORD1(v922) += v233;
                                              if (&v922 == (__int128 *)v830)
                                              {
                                                v264 = (v276 - v233);
                                                v899 = v276 - v233;
                                                if (v233 < v923)
                                                {
                                                  v923 -= v233;
                                                  goto LABEL_722;
                                                }
                                                v131 = v282 & 0xFFFFFFDF;
                                                v923 = 0;
                                              }
                                              else
                                              {
                                                *(_DWORD *)(v830 + 4) += v233;
                                                v264 = (v276 - v233);
                                                v899 = v276 - v233;
                                                if (v233 < v923)
                                                {
                                                  v923 -= v233;
                                                  *(_WORD *)(v830 + 18) -= v233;
LABEL_722:
                                                  v122 = v275;
                                                  v131 = v282;
LABEL_726:
                                                  v44 = a1;
                                                  goto LABEL_727;
                                                }
                                                v131 = v282 & 0xFFFFFFDF;
                                                v923 = 0;
                                                *(_WORD *)(v830 + 18) = 0;
                                              }
                                              v122 = v275;
                                              goto LABEL_726;
                                            }
LABEL_704:
                                            *(_QWORD *)(*(_QWORD *)(a3 + 272) + 8) += v233;
                                            goto LABEL_705;
                                          }
                                          *(_QWORD *)(*(_QWORD *)(a3 + 264) + 8) += v233;
                                          if (!v18)
                                            goto LABEL_705;
                                          goto LABEL_704;
                                        }
LABEL_700:
                                        ++**(_QWORD **)(a3 + 272);
                                        goto LABEL_701;
                                      }
                                      ++*(_QWORD *)(v284 + 240);
                                      v280 = v233;
                                      v281 = (_QWORD *)(v284 + 248);
                                      v43 = v892;
LABEL_694:
                                      v283 = v826;
                                      *v281 += v280;
                                      v282 = v235;
                                      goto LABEL_695;
                                    }
                                    if ((v883 & 2) != 0)
                                    {
                                      if (tcp_is_ack_ratelimited(v275))
                                      {
LABEL_685:
                                        v235 = v235 & 0xFFFFFFFE;
                                        v43 = v892;
                                        if (v233 == 1)
                                        {
                                          v277 = *(_QWORD *)(v15 + 32);
                                          if (v277)
                                          {
                                            v278 = *(void (**)(uint64_t))(v277 + 88);
                                            if (v278)
                                              v278(v15);
                                          }
                                        }
                                        v279 = *(_QWORD *)(v275 + 1056);
                                        if (!v279)
                                        {
                                          v282 = v235;
                                          v233 = v276;
                                          v283 = v826;
                                          goto LABEL_695;
                                        }
                                        v280 = v276;
                                        ++*(_QWORD *)(v279 + 208);
                                        v281 = (_QWORD *)(v279 + 216);
                                        v233 = v276;
                                        goto LABEL_694;
                                      }
                                      v309 = *(_QWORD *)(v275 + 1056);
                                      if (v309)
                                        ++*(_QWORD *)(v309 + 104);
                                    }
                                    *(_DWORD *)(v275 + 88) |= 1u;
                                    goto LABEL_685;
                                  }
                                  v235 = v883 & 0xFFFFFFFD;
                                  ++DWORD1(v922);
                                  if (&v922 == (__int128 *)v232)
                                  {
                                    if (v923 > 1u)
                                    {
                                      --v923;
                                      goto LABEL_678;
                                    }
                                  }
                                  else
                                  {
                                    ++*(_DWORD *)(v232 + 4);
                                    if (v923 > 1u)
                                    {
                                      --v923;
                                      --*(_WORD *)(v232 + 18);
LABEL_678:
                                      --v233;
                                      goto LABEL_679;
                                    }
                                  }
                                  v235 = v883 & 0xDDDDDDDD;
                                  goto LABEL_678;
                                }
                                if (*(_DWORD *)(v837 + 316) - *(_DWORD *)(v122 + 280) >= 2073600001)
                                {
                                  *(_DWORD *)(v122 + 276) = 0;
                                  LODWORD(v131) = v883;
                                  goto LABEL_590;
                                }
                                v320 = *(_QWORD *)(v122 + 1056);
                                if (v320)
                                {
                                  ++*(_QWORD *)(v320 + 208);
                                  ++*(_DWORD *)(v122 + 1000);
                                  v321 = vdupq_n_s64(1uLL);
                                  v321.i64[0] = v845;
                                  *(int64x2_t *)(v320 + 216) = vaddq_s64(*(int64x2_t *)(v320 + 216), v321);
                                }
                                else
                                {
                                  ++*(_DWORD *)(v122 + 1000);
                                }
                                v364 = *(_DWORD *)(v122 + 348);
                                if ((~v364 & 3) == 0)
                                  goto LABEL_2106;
                                v367 = *(_DWORD *)(v122 + 740);
                                if ((v367 & 0x10000000) == 0)
                                {
                                  v368 = (v367 & 0x8000000) == 0;
                                  if (*(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1)
                                    v368 = 0;
                                  if ((~v364 & 0x300000) == 0 && !v368)
                                  {
LABEL_2106:
                                    if (!(*(_QWORD *)(*(_QWORD *)(a3 + 248) + 8) >> 31))
                                    {
                                      v365 = *(_QWORD *)(a3 + 448);
                                      if (v365)
                                      {
                                        v366 = 632;
                                        if ((*(_BYTE *)(a3 + 2236) & 2) == 0)
                                          v366 = 248;
                                        ++*(_QWORD *)(v365 + v366);
                                      }
                                      if (v320)
                                        ++*(_QWORD *)(v320 + 936);
                                      tcp_heuristic_ecn_aggressive(v122);
                                    }
                                  }
                                }
                                v370 = *(_QWORD **)(a3 + 248);
                                ++*v370;
                                if (v16)
                                {
                                  ++**(_QWORD **)(a3 + 256);
                                  if (!v826)
                                    goto LABEL_915;
                                }
                                else if (!v826)
                                {
LABEL_915:
                                  if (!v18)
                                    goto LABEL_917;
                                  goto LABEL_916;
                                }
                                ++**(_QWORD **)(a3 + 264);
                                if (!v18)
                                {
LABEL_917:
                                  v131 = v899;
                                  v370[1] += v899;
                                  if (v16)
                                  {
                                    *(_QWORD *)(*(_QWORD *)(a3 + 256) + 8) += v131;
                                    if (!v826)
                                      goto LABEL_919;
                                  }
                                  else if (!v826)
                                  {
LABEL_919:
                                    if (!v18)
                                    {
LABEL_921:
                                      *(_DWORD *)(v122 + 704) += v131;
                                      if (*(_QWORD *)(v15 + 24))
                                      {
                                        v371 = nw_protocol_tcp_get_all_stats();
                                        if (v371)
                                          *(_DWORD *)(v371 + 48) += v131;
                                      }
                                      v485 = (int)v131 <= 0;
                                      v43 = v892;
                                      v132 = v824;
                                      LODWORD(v131) = v883;
                                      if (!v485)
                                        goto LABEL_1298;
                                      goto LABEL_1331;
                                    }
LABEL_920:
                                    *(_QWORD *)(*(_QWORD *)(a3 + 272) + 8) += v131;
                                    goto LABEL_921;
                                  }
                                  *(_QWORD *)(*(_QWORD *)(a3 + 264) + 8) += v131;
                                  if (!v18)
                                    goto LABEL_921;
                                  goto LABEL_920;
                                }
LABEL_916:
                                ++**(_QWORD **)(a3 + 272);
                                goto LABEL_917;
                              }
                              v236 = *(_DWORD *)(v122 + 284);
                              v132 = v824;
                              if ((DWORD1(v922) - v236 < 0 || (int)(DWORD1(v922) - v236 - v228) >= 0)
                                && (v228 || DWORD1(v922) != v236 && v236 - 1 != DWORD1(v922)))
                              {
                                v55 = v849;
LABEL_620:
                                v43 = v892;
                                goto LABEL_1332;
                              }
                              if (DWORD1(v922) != v236)
                              {
                                v265 = *(_QWORD *)(v122 + 1056);
                                if (v265)
                                  ++*(_QWORD *)(v265 + 312);
                                if (tcp_is_ack_ratelimited(v122))
                                  goto LABEL_1202;
                                v266 = *(_QWORD *)(v122 + 1056);
                                if (v266)
                                  ++*(_QWORD *)(v266 + 112);
                                v43 = v892;
LABEL_1170:
                                v132 = v824;
                                LODWORD(v131) = v883;
                                goto LABEL_1298;
                              }
                              break;
                            case 4:
                              if ((v883 & 2) == 0 || v845 > 0)
                                goto LABEL_584;
                              if (tcp_is_ack_ratelimited(v122))
                                goto LABEL_619;
                              v230 = *(_QWORD *)(v122 + 1056);
                              if (v230)
                                ++*(_QWORD *)(v230 + 104);
                              v132 = v824;
                              v43 = v892;
                              goto LABEL_1298;
                            default:
                              goto LABEL_584;
                          }
                          v257 = v122;
                          v258 = 61;
                          switch(v229)
                          {
                            case 3:
                              goto LABEL_649;
                            case 4:
                              v362 = *(_DWORD *)(v122 + 348);
                              if ((~v362 & 3) == 0)
                                goto LABEL_892;
                              v506 = *(_DWORD *)(v122 + 740);
                              if ((v506 & 0x10000000) == 0)
                              {
                                v507 = (v506 & 0x8000000) == 0;
                                if (*(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1)
                                  v507 = 0;
                                if ((~v362 & 0x300000) == 0 && !v507)
                                {
LABEL_892:
                                  v363 = *(_DWORD *)(v122 + 92);
                                  if (v363 == *(_DWORD *)(v122 + 112) + 1 && *(_DWORD *)(v122 + 96) - v363 >= 1)
                                    tcp_heuristic_ecn_droprst(v122);
                                }
                              }
                              goto LABEL_648;
                            case 5:
                            case 6:
                            case 9:
LABEL_648:
                              v258 = 54;
LABEL_649:
                              *(_WORD *)(v15 + 378) = v258;
                              if (tcp_perf_measurement)
                              {
                                if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                {
                                  if (__nwlog_is_datapath_logging_enabled())
                                  {
                                    v259 = __nwlog_tcp_log();
                                    if (os_log_type_enabled(v259, OS_LOG_TYPE_DEBUG))
                                    {
                                      v260 = tcpstates[*(int *)(v257 + 12)];
                                      v902 = "tcp_input";
                                      v261 = "";
                                      *(_DWORD *)buf = 136446722;
                                      if (v15)
                                        v261 = (const char *)(v15 + 604);
                                      v903 = 2082;
                                      *(_QWORD *)v904 = v261;
                                      *(_WORD *)&v904[8] = 2082;
                                      *(_QWORD *)v905 = v260;
                                      v262 = v259;
                                      v263 = OS_LOG_TYPE_DEBUG;
LABEL_882:
                                      _os_log_impl(&dword_209FB3000, v262, v263, "%{public}s %{public}s ECONNRESET t_state %{public}s", buf, 0x20u);
                                    }
                                  }
                                }
                              }
                              else if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                              {
                                v355 = __nwlog_tcp_log();
                                if (os_log_type_enabled(v355, OS_LOG_TYPE_INFO))
                                {
                                  v356 = tcpstates[*(int *)(v257 + 12)];
                                  v902 = "tcp_input";
                                  v357 = "";
                                  *(_DWORD *)buf = 136446722;
                                  if (v15)
                                    v357 = (const char *)(v15 + 604);
                                  v903 = 2082;
                                  *(_QWORD *)v904 = v357;
                                  *(_WORD *)&v904[8] = 2082;
                                  *(_QWORD *)v905 = v356;
                                  v262 = v355;
                                  v263 = OS_LOG_TYPE_INFO;
                                  goto LABEL_882;
                                }
                              }
                              user_north_signal_error(v15);
                              v358 = *(_QWORD *)(v257 + 1056);
                              if (v358)
                                ++*(_QWORD *)(v358 + 424);
LABEL_885:
                              tcp_close(v257);
                              v43 = v892;
                              goto LABEL_1292;
                            case 7:
                            case 8:
                              if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                              {
                                if (__nwlog_is_datapath_logging_enabled())
                                {
                                  v352 = __nwlog_tcp_log();
                                  if (os_log_type_enabled(v352, OS_LOG_TYPE_DEBUG))
                                  {
                                    v353 = tcpstates[*(int *)(v257 + 12)];
                                    v902 = "tcp_input";
                                    v354 = "";
                                    *(_DWORD *)buf = 136446722;
                                    if (v15)
                                      v354 = (const char *)(v15 + 604);
                                    v903 = 2082;
                                    *(_QWORD *)v904 = v354;
                                    *(_WORD *)&v904[8] = 2082;
                                    *(_QWORD *)v905 = v353;
                                    _os_log_impl(&dword_209FB3000, v352, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s t_state %{public}s", buf, 0x20u);
                                  }
                                }
                              }
                              goto LABEL_885;
                            default:
                              goto LABEL_1202;
                          }
                        }
                        v224 = v122;
                        v44 = a1;
                        if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                        {
                          v225 = __nwlog_tcp_log();
                          v220 = os_log_type_enabled(v225, OS_LOG_TYPE_ERROR);
                          if (!v220)
                          {
LABEL_566:
                            v122 = v224;
                            goto LABEL_567;
                          }
                          v226 = (const char *)(v15 + 604);
                          v902 = "tcp_input";
                          *(_DWORD *)buf = 136446722;
                          if (!v15)
                            v226 = "";
                          v903 = 2082;
                          *(_QWORD *)v904 = v226;
                          *(_WORD *)&v904[8] = 1024;
                          *(_DWORD *)v905 = 0;
                          _os_log_impl(&dword_209FB3000, v225, OS_LOG_TYPE_ERROR, "%{public}s %{public}s win is smaller than 0: %d", buf, 0x1Cu);
                        }
                        v220 = 0;
                        goto LABEL_566;
                      }
                      v122 = v839;
                      if (DWORD2(v922) != v191 || *(_QWORD *)v839 || v845 > (int)tcp_sbspace(v839))
                        goto LABEL_552;
                      if ((*(_BYTE *)(v839 + 740) & 0x20) != 0 && *(_DWORD *)(v839 + 564))
                      {
                        *(_DWORD *)(v839 + 612) = 0;
                        *(_OWORD *)(v839 + 580) = 0u;
                        *(_OWORD *)(v839 + 596) = 0u;
                        *(_OWORD *)(v839 + 564) = 0u;
                      }
                      v193 = *(_QWORD **)(v839 + 1056);
                      if (v193)
                        ++v193[69];
                      v194 = *(_DWORD *)(v839 + 120) + v845;
                      *(_DWORD *)(v839 + 120) = v194;
                      if (*(_DWORD *)(v839 + 1916) - v194 < 0)
                      {
                        *(_DWORD *)(v839 + 1916) = v194;
                        if ((v896[0] & 1) != 0)
                          *(_DWORD *)(v839 + 1920) = DWORD1(v896[0]);
                      }
                      *(_DWORD *)(v839 + 104) = DWORD1(v922);
                      *(_DWORD *)(v839 + 136) = v194;
                      if (v193)
                      {
                        v195 = v193[25] + v845;
                        v193[24] += v825;
                        v193[25] = v195;
                      }
                      v196 = *(_QWORD **)(a3 + 248);
                      ++*v196;
                      if (v16)
                      {
                        ++**(_QWORD **)(a3 + 256);
                        if (!v826)
                          goto LABEL_509;
                      }
                      else if (!v826)
                      {
LABEL_509:
                        if (!v18)
                          goto LABEL_511;
                        goto LABEL_510;
                      }
                      ++**(_QWORD **)(a3 + 264);
                      if (!v18)
                      {
LABEL_511:
                        v196[1] += v845;
                        if (v16)
                        {
                          *(_QWORD *)(*(_QWORD *)(a3 + 256) + 8) += v845;
                          if (!v826)
                            goto LABEL_513;
                        }
                        else if (!v826)
                        {
LABEL_513:
                          if (!v18)
                            goto LABEL_515;
                          goto LABEL_514;
                        }
                        *(_QWORD *)(*(_QWORD *)(a3 + 264) + 8) += v845;
                        if (!v18)
                        {
LABEL_515:
                          tcp_compute_rcv_rtt(v839, (uint64_t)v896, (uint64_t)&v922);
                          tcp_sbrcv_grow(v839, v15 + 488, (uint64_t)v896, v845);
                          if (*(_DWORD *)(sysctls + 308) == 1
                            && (~*(_DWORD *)(v839 + 88) & 0x180) == 0
                            && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v15 + 369) & 0x40) != 0)
                            && off_253CF86A0)
                          {
                            off_253CF86A0(v839, (uint64_t)&v922, (uint64_t)v896, v845);
                          }
                          v197 = *a1;
                          if (*a1)
                          {
                            if ((*(_WORD *)(v197 + 204) & 0x80) == 0)
                              goto LABEL_1793;
                            v198 = *(unsigned __int16 *)(v197 + 196);
                            v66 = v198 >= v848;
                            v199 = v198 - v848;
                            if (v66)
                            {
                              *(_WORD *)(v197 + 196) = v199;
                              goto LABEL_1793;
                            }
                            __nwlog_obj();
                            v200 = *(unsigned __int16 *)(v197 + 196);
                            *(_DWORD *)buf = 136446722;
                            v902 = "__nw_frame_array_claim";
                            v903 = 1024;
                            *(_DWORD *)v904 = v200;
                            *(_WORD *)&v904[4] = 1024;
                            *(_DWORD *)&v904[6] = v848;
                            v201 = (void *)_os_log_send_and_compose_impl();
                            type[0] = OS_LOG_TYPE_ERROR;
                            v900 = 0;
                            if (!__nwlog_fault())
                              goto LABEL_1790;
                            if (type[0] == OS_LOG_TYPE_FAULT)
                            {
                              v202 = __nwlog_obj();
                              v203 = type[0];
                              if (os_log_type_enabled(v202, type[0]))
                              {
                                v204 = *(unsigned __int16 *)(v197 + 196);
                                *(_DWORD *)buf = 136446722;
                                v902 = "__nw_frame_array_claim";
                                v903 = 1024;
                                *(_DWORD *)v904 = v204;
                                *(_WORD *)&v904[4] = 1024;
                                *(_DWORD *)&v904[6] = v848;
                                v205 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_1788:
                                v681 = v202;
LABEL_1789:
                                _os_log_impl(&dword_209FB3000, v681, v203, v205, buf, 0x18u);
                              }
                            }
                            else if (v900)
                            {
                              v654 = (void *)__nw_create_backtrace_string();
                              v655 = __nwlog_obj();
                              v203 = type[0];
                              v656 = os_log_type_enabled(v655, type[0]);
                              if (v654)
                              {
                                if (v656)
                                {
                                  v657 = *(unsigned __int16 *)(v197 + 196);
                                  *(_DWORD *)buf = 136446978;
                                  v902 = "__nw_frame_array_claim";
                                  v903 = 1024;
                                  *(_DWORD *)v904 = v657;
                                  *(_WORD *)&v904[4] = 1024;
                                  *(_DWORD *)&v904[6] = v848;
                                  *(_WORD *)v905 = 2082;
                                  *(_QWORD *)&v905[2] = v654;
                                  _os_log_impl(&dword_209FB3000, v655, type[0], "%{public}s Aggregate buffer length: %u sum: %u, dumping backtrace:%{public}s", buf, 0x22u);
                                }
                                free(v654);
                                goto LABEL_1790;
                              }
                              if (v656)
                              {
                                v710 = *(unsigned __int16 *)(v197 + 196);
                                *(_DWORD *)buf = 136446722;
                                v902 = "__nw_frame_array_claim";
                                v903 = 1024;
                                *(_DWORD *)v904 = v710;
                                *(_WORD *)&v904[4] = 1024;
                                *(_DWORD *)&v904[6] = v848;
                                v205 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                                v681 = v655;
                                goto LABEL_1789;
                              }
                            }
                            else
                            {
                              v202 = __nwlog_obj();
                              v203 = type[0];
                              if (os_log_type_enabled(v202, type[0]))
                              {
                                v680 = *(unsigned __int16 *)(v197 + 196);
                                *(_DWORD *)buf = 136446722;
                                v902 = "__nw_frame_array_claim";
                                v903 = 1024;
                                *(_DWORD *)v904 = v680;
                                *(_WORD *)&v904[4] = 1024;
                                *(_DWORD *)&v904[6] = v848;
                                v205 = "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded";
                                goto LABEL_1788;
                              }
                            }
LABEL_1790:
                            if (v201)
                              free(v201);
                            *(_WORD *)(v197 + 196) = 0;
                            goto LABEL_1793;
                          }
                          __nwlog_obj();
                          *(_DWORD *)buf = 136446210;
                          v902 = "__nw_frame_is_single_ip_aggregate";
                          v791 = (void *)_os_log_send_and_compose_impl();
                          type[0] = OS_LOG_TYPE_ERROR;
                          v900 = 0;
                          if (__nwlog_fault())
                          {
                            if (type[0] == OS_LOG_TYPE_FAULT)
                            {
                              v792 = __nwlog_obj();
                              v793 = type[0];
                              if (!os_log_type_enabled(v792, type[0]))
                                goto LABEL_2077;
                              *(_DWORD *)buf = 136446210;
                              v902 = "__nw_frame_is_single_ip_aggregate";
                              v794 = "%{public}s called with null frame";
LABEL_2075:
                              v804 = v792;
                              v805 = v793;
LABEL_2076:
                              _os_log_impl(&dword_209FB3000, v804, v805, v794, buf, 0xCu);
                              goto LABEL_2077;
                            }
                            if (!v900)
                            {
                              v792 = __nwlog_obj();
                              v793 = type[0];
                              if (!os_log_type_enabled(v792, type[0]))
                                goto LABEL_2077;
                              *(_DWORD *)buf = 136446210;
                              v902 = "__nw_frame_is_single_ip_aggregate";
                              v794 = "%{public}s called with null frame, backtrace limit exceeded";
                              goto LABEL_2075;
                            }
                            v799 = (void *)__nw_create_backtrace_string();
                            v800 = __nwlog_obj();
                            v801 = os_log_type_enabled(v800, type[0]);
                            if (v799)
                            {
                              if (v801)
                              {
                                *(_DWORD *)buf = 136446466;
                                v902 = "__nw_frame_is_single_ip_aggregate";
                                v903 = 2082;
                                *(_QWORD *)v904 = v799;
                                _os_log_impl(&dword_209FB3000, v800, type[0], "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                              }
                              free(v799);
                              goto LABEL_2077;
                            }
                            if (v801)
                            {
                              *(_DWORD *)buf = 136446210;
                              v902 = "__nw_frame_is_single_ip_aggregate";
                              v794 = "%{public}s called with null frame, no backtrace";
                              v804 = v800;
                              v805 = type[0];
                              goto LABEL_2076;
                            }
                          }
LABEL_2077:
                          if (v791)
                            free(v791);
LABEL_1793:
                          v682 = *a1;
                          if (*a1)
                          {
                            v683 = 0;
                            while (1)
                            {
                              v684 = *(_DWORD *)(v682 + 52);
                              v685 = *(_DWORD *)(v682 + 56);
                              v686 = *(_DWORD *)(v682 + 60);
                              v687 = v684 - (v685 + v686);
                              if (v687 >= v848 - v683)
                                v687 = v848 - v683;
                              v688 = v684 ? v687 : 0;
                              v689 = v685 + v688;
                              if (v685 + v688 <= v684 - v686)
                              {
                                *(_DWORD *)(v682 + 56) = v689;
                              }
                              else
                              {
                                v690 = __nwlog_obj();
                                if (os_log_type_enabled(v690, OS_LOG_TYPE_ERROR))
                                {
                                  v691 = *(_DWORD *)(v682 + 52);
                                  *(_DWORD *)buf = 136446978;
                                  v902 = "__nw_frame_claim_internal";
                                  v903 = 1024;
                                  *(_DWORD *)v904 = v689;
                                  *(_WORD *)&v904[4] = 1024;
                                  *(_DWORD *)&v904[6] = v691;
                                  *(_WORD *)v905 = 1024;
                                  *(_DWORD *)&v905[2] = v686;
                                  _os_log_impl(&dword_209FB3000, v690, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
                                }
                              }
                              v683 += v688;
                              if (v683 == (_DWORD)v848)
                                break;
                              if (v683 < v848)
                              {
                                v682 = *(_QWORD *)(v682 + 32);
                                if (v682)
                                  continue;
                              }
                              goto LABEL_1809;
                            }
                          }
                          else
                          {
                            v683 = 0;
LABEL_1809:
                            if (v683 != (_DWORD)v848)
                            {
                              v692 = __nwlog_obj();
                              if (os_log_type_enabled(v692, OS_LOG_TYPE_ERROR))
                              {
                                *(_DWORD *)buf = 136446722;
                                v902 = "__nw_frame_array_claim";
                                v903 = 1024;
                                *(_DWORD *)v904 = v683;
                                *(_WORD *)&v904[4] = 1024;
                                *(_DWORD *)&v904[6] = v848;
                                _os_log_impl(&dword_209FB3000, v692, OS_LOG_TYPE_ERROR, "%{public}s start_offset %u != start_bytes %u", buf, 0x18u);
                              }
                            }
                          }
                          if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                          {
                            if (__nwlog_is_datapath_logging_enabled())
                            {
                              v795 = __nwlog_tcp_log();
                              if (os_log_type_enabled(v795, OS_LOG_TYPE_DEBUG))
                              {
                                v796 = "";
                                v902 = "tcp_input";
                                *(_DWORD *)buf = 136446722;
                                if (v15)
                                  v796 = (const char *)(v15 + 604);
                                v903 = 2082;
                                *(_QWORD *)v904 = v796;
                                *(_WORD *)&v904[8] = 1024;
                                *(_DWORD *)v905 = v899;
                                _os_log_impl(&dword_209FB3000, v795, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s queueing frame of length %u - fastpath", buf, 0x1Cu);
                              }
                            }
                          }
                          *(_DWORD *)(v839 + 740) = *(_DWORD *)(v839 + 740) & 0xFFFFFFEF | (16
                                                                                          * ((BYTE13(v922) >> 3) & 1));
                          v693 = v899;
                          v694 = tcp_input_sbappendstream(v15, a1, v899, 2);
                          if (v850 && v694)
                            *v850 = 1;
                          *(_WORD *)(v839 + 304) += v825;
                          v695 = *(unsigned int (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v839 + 264)]
                                                                                    + 96);
                          if (v695 && v695(v839, &v922))
                          {
                            v696 = *(_DWORD *)(v839 + 88);
                            if ((v696 & 2) == 0)
                            {
                              *(_DWORD *)(v839 + 88) = v696 | 2;
                              *(_DWORD *)(v839 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v839 + 80) + 224))
                                                                 + 316)
                                                     - *(_DWORD *)(v839 + 64)
                                                     + 100;
                            }
                          }
                          else
                          {
                            *(_DWORD *)(v839 + 88) |= 1u;
                            tcp_output(v839);
                          }
                          tcp_adaptive_rwtimo_check(v839, v693);
                          if (v693 >= 1 && *(_BYTE *)(v839 + 993))
                            *(_BYTE *)(v839 + 993) = 0;
                          tcp_check_timer_state(v839);
                          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v15 + 8) + 24))(v15, 1);
                          *v892 = 0;
                          result = (_QWORD *)*a1;
                          if (!*a1)
                            return result;
                          while (1)
                          {
                            v697 = (void (*)(_QWORD *, uint64_t, uint64_t))result[10];
                            v698 = (_QWORD *)result[4];
                            if (!v697)
                              break;
                            v699 = result[11];
                            result[10] = 0;
                            result[11] = 0;
                            v697(result, 1, v699);
LABEL_1829:
                            result = v698;
                            if (!v698)
                              return result;
                          }
                          __nwlog_obj();
                          *(_DWORD *)buf = 136446210;
                          v902 = "__nw_frame_finalize";
                          v700 = _os_log_send_and_compose_impl();
                          type[0] = OS_LOG_TYPE_ERROR;
                          v900 = 0;
                          v890 = (void *)v700;
                          if (__nwlog_fault())
                          {
                            if (type[0] == OS_LOG_TYPE_FAULT)
                            {
                              v876 = __nwlog_obj();
                              if (!os_log_type_enabled(v876, type[0]))
                                goto LABEL_1845;
                              *(_DWORD *)buf = 136446210;
                              v902 = "__nw_frame_finalize";
                              v701 = v876;
                              v702 = type[0];
                              v703 = "%{public}s called with null frame->finalizer";
                              goto LABEL_1844;
                            }
                            if (!v900)
                            {
                              v878 = __nwlog_obj();
                              if (!os_log_type_enabled(v878, type[0]))
                                goto LABEL_1845;
                              *(_DWORD *)buf = 136446210;
                              v902 = "__nw_frame_finalize";
                              v701 = v878;
                              v702 = type[0];
                              v703 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                              goto LABEL_1844;
                            }
                            v877 = (void *)__nw_create_backtrace_string();
                            logi = __nwlog_obj();
                            v704 = os_log_type_enabled(logi, type[0]);
                            if (v877)
                            {
                              if (v704)
                              {
                                *(_DWORD *)buf = 136446466;
                                v902 = "__nw_frame_finalize";
                                v903 = 2082;
                                *(_QWORD *)v904 = v877;
                                _os_log_impl(&dword_209FB3000, logi, type[0], "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                              }
                              free(v877);
                              goto LABEL_1845;
                            }
                            if (v704)
                            {
                              *(_DWORD *)buf = 136446210;
                              v902 = "__nw_frame_finalize";
                              v701 = logi;
                              v702 = type[0];
                              v703 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1844:
                              _os_log_impl(&dword_209FB3000, v701, v702, v703, buf, 0xCu);
                            }
                          }
LABEL_1845:
                          if (v890)
                            free(v890);
                          goto LABEL_1829;
                        }
LABEL_514:
                        *(_QWORD *)(*(_QWORD *)(a3 + 272) + 8) += v845;
                        goto LABEL_515;
                      }
LABEL_510:
                      ++**(_QWORD **)(a3 + 272);
                      goto LABEL_511;
                    }
LABEL_405:
                    v823 = 0;
                    goto LABEL_431;
                  }
                  if (log != 3 && ((char)v131 & 0x80000000) == 0)
                    goto LABEL_405;
                  tcp_reset_stretch_ack(v122);
                  v164 = v837;
                  *(_WORD *)(v122 + 308) = 16;
                  *(_DWORD *)(v122 + 744) = 0;
                  v166 = *(_DWORD *)(v122 + 12);
                }
                if (log != 3)
                {
                  v823 = 0;
                  goto LABEL_417;
                }
                if (v166 == 4)
                {
                  v178 = *(_DWORD *)(v122 + 348);
                  goto LABEL_410;
                }
LABEL_415:
                v823 = 1;
                goto LABEL_432;
              }
              if ((_DWORD)v72 == v151)
                goto LABEL_370;
              v165 = DWORD1(v922);
              if (v845 < 1 || (v172 = *(_DWORD *)(v122 + 284), DWORD1(v922) - v172 < 0))
              {
                v164 = v837;
                LOBYTE(v131) = v883;
                goto LABEL_396;
              }
              v164 = v837;
              LOBYTE(v131) = v883;
              if (DWORD1(v922) - (v172 + *(_DWORD *)(v122 + 128)) < 0)
              {
LABEL_370:
                tcp_input_ip_ecn(v122, a3, v845, v825, log);
                v164 = v837;
                v165 = DWORD1(v922);
              }
LABEL_396:
              if (v165 == *(_DWORD *)(v122 + 112) + 1 && !v821)
                *(_DWORD *)(v122 + 360) = 6;
              goto LABEL_399;
            }
            *(_DWORD *)(v122 + 348) &= ~0x10u;
            ++*(_DWORD *)(v122 + 356);
            goto LABEL_360;
          }
          if ((*(_WORD *)(v13 + 204) & 0x100) != 0
            && *MEMORY[0x24BDE08C0]
            && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v13, *(_QWORD *)(v13 + 88)) & 1) == 0)
          {
            *(_QWORD *)(v839 + 1056) = 0;
            if (!v15)
              goto LABEL_256;
          }
          else
          {
            v127 = *(_QWORD *)(v839 + 1056);
            if (v127)
              ++*(_QWORD *)(v127 + 320);
            if (!v15)
              goto LABEL_256;
          }
        }
        if ((*(_BYTE *)(v15 + 828) & 2) != 0)
        {
LABEL_262:
          in_pcb_checkstate(a3, 2, 1);
          v44 = a1;
          v55 = v849;
          goto LABEL_66;
        }
LABEL_256:
        v128 = __nwlog_tcp_log();
        if (os_log_type_enabled(v128, OS_LOG_TYPE_INFO))
        {
          v129 = "";
          if (v15)
            v129 = (const char *)(v15 + 604);
          *(_DWORD *)buf = 136446466;
          v902 = "tcp_input";
          v903 = 2082;
          *(_QWORD *)v904 = v129;
          _os_log_impl(&dword_209FB3000, v128, OS_LOG_TYPE_INFO, "%{public}s %{public}s invalid checksum", buf, 0x16u);
        }
        goto LABEL_262;
      }
LABEL_168:
      if (v15 && (*(_BYTE *)(v15 + 828) & 2) != 0)
      {
        v849 = 0;
        v73 = 1;
        goto LABEL_232;
      }
      __nwlog_tcp_log();
      if (v15)
        v103 = (const char *)(v15 + 604);
      else
        v103 = "";
      *(_DWORD *)buf = 136446466;
      v902 = "tcp_compute_segment_length";
      v903 = 2082;
      *(_QWORD *)v904 = v103;
      v104 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v900 = 0;
      if (!__nwlog_fault())
        goto LABEL_180;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v105 = __nwlog_tcp_log();
        v106 = type[0];
        if (os_log_type_enabled(v105, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          v902 = "tcp_compute_segment_length";
          v903 = 2082;
          *(_QWORD *)v904 = v103;
          v107 = "%{public}s %{public}s Segment count is 0 for single-IP frame";
LABEL_179:
          _os_log_impl(&dword_209FB3000, v105, v106, v107, buf, 0x16u);
        }
      }
      else
      {
        v105 = __nwlog_tcp_log();
        v106 = type[0];
        if (os_log_type_enabled(v105, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          v902 = "tcp_compute_segment_length";
          v903 = 2082;
          *(_QWORD *)v904 = v103;
          v107 = "%{public}s %{public}s Segment count is 0 for single-IP frame, backtrace limit exceeded";
          goto LABEL_179;
        }
      }
LABEL_180:
      if (v104)
        free(v104);
      v73 = 1;
      goto LABEL_183;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v902 = "__nw_frame_get_segment_count";
    v90 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v900 = 0;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v91 = __nwlog_obj();
        v92 = type[0];
        if (!os_log_type_enabled(v91, type[0]))
          goto LABEL_166;
        *(_DWORD *)buf = 136446210;
        v902 = "__nw_frame_get_segment_count";
        v93 = "%{public}s Attempt to get segment-count on a chain-member";
      }
      else
      {
        v91 = __nwlog_obj();
        v92 = type[0];
        if (!os_log_type_enabled(v91, type[0]))
          goto LABEL_166;
        *(_DWORD *)buf = 136446210;
        v902 = "__nw_frame_get_segment_count";
        v93 = "%{public}s Attempt to get segment-count on a chain-member, backtrace limit exceeded";
      }
      _os_log_impl(&dword_209FB3000, v91, v92, v93, buf, 0xCu);
    }
LABEL_166:
    if (v90)
      free(v90);
    goto LABEL_168;
  }
  v849 = 0;
  LODWORD(v72) = 0;
  v73 = 0;
  v74 = (const char *)(v15 + 604);
  if (!v15)
    v74 = "";
  v844 = v74;
  v75 = 1;
  while (1)
  {
    if ((*(_WORD *)(v70 + 204) & 0x4000) == 0)
    {
      if ((v75 & 1) == 0)
        goto LABEL_124;
LABEL_128:
      v76 = *(_DWORD *)(v70 + 52);
      if (!v76)
        goto LABEL_129;
      goto LABEL_108;
    }
    if ((v75 & 1) == 0)
      break;
    if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
    {
      v78 = __nwlog_tcp_log();
      v849 = 1;
      if (os_log_type_enabled(v78, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        v902 = "tcp_compute_segment_length";
        v903 = 2082;
        *(_QWORD *)v904 = v844;
        v849 = 1;
        _os_log_impl(&dword_209FB3000, v78, OS_LOG_TYPE_INFO, "%{public}s %{public}s first frame is wake packet", buf, 0x16u);
        v76 = *(_DWORD *)(v70 + 52);
        if (!v76)
          goto LABEL_129;
        goto LABEL_108;
      }
      goto LABEL_128;
    }
    v849 = 1;
    v76 = *(_DWORD *)(v70 + 52);
    if (!v76)
    {
LABEL_129:
      v77 = 0;
      goto LABEL_109;
    }
LABEL_108:
    v77 = v76 - (*(_DWORD *)(v70 + 56) + *(_DWORD *)(v70 + 60));
LABEL_109:
    v75 = 0;
    v72 = (v77 + v72);
    v70 = *(_QWORD *)(v70 + 32);
    ++v73;
    if (!v70)
      goto LABEL_228;
  }
  if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
  {
    v79 = __nwlog_tcp_log();
    if (os_log_type_enabled(v79, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v902 = "tcp_compute_segment_length";
      v903 = 2082;
      *(_QWORD *)v904 = v844;
      _os_log_impl(&dword_209FB3000, v79, OS_LOG_TYPE_INFO, "%{public}s %{public}s frame is wake packet", buf, 0x16u);
    }
  }
  v80 = *(_WORD *)(v70 + 204) & 0xBFFF | (*(unsigned __int8 *)(v70 + 206) << 16);
  *(_WORD *)(v70 + 204) &= ~0x4000u;
  *(_BYTE *)(v70 + 206) = BYTE2(v80);
  if (*a1)
  {
    *(_WORD *)(*a1 + 204) |= 0x4000u;
    v849 = 1;
    goto LABEL_124;
  }
  v816 = v13;
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v902 = "__nw_frame_set_is_wake_packet";
  v84 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v900 = 0;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v85 = __nwlog_obj();
      if (os_log_type_enabled(v85, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v902 = "__nw_frame_set_is_wake_packet";
        v86 = v85;
        v87 = type[0];
        v88 = "%{public}s called with null frame";
        goto LABEL_138;
      }
    }
    else
    {
      v89 = __nwlog_obj();
      if (os_log_type_enabled(v89, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v902 = "__nw_frame_set_is_wake_packet";
        v86 = v89;
        v87 = type[0];
        v88 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_138:
        _os_log_impl(&dword_209FB3000, v86, v87, v88, buf, 0xCu);
      }
    }
  }
  if (v84)
    free(v84);
  v849 = 1;
  v13 = v816;
  v30 = (_QWORD *)MEMORY[0x24BDE08C0];
LABEL_124:
  v81 = v30;
  if ((*(_WORD *)(v70 + 204) & 0x80) != 0)
    *(_WORD *)(v70 + 196) -= v848;
  v82 = *(_DWORD *)(v70 + 56) + v848;
  v83 = *(_DWORD *)(v70 + 60);
  if (v82 <= *(_DWORD *)(v70 + 52) - v83)
  {
    *(_DWORD *)(v70 + 56) = v82;
    v30 = v81;
    goto LABEL_128;
  }
  v94 = __nwlog_obj();
  if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
  {
    v95 = *(_DWORD *)(v70 + 52);
    *(_DWORD *)buf = 136446978;
    v902 = "__nw_frame_claim_internal";
    v903 = 1024;
    *(_DWORD *)v904 = v82;
    *(_WORD *)&v904[4] = 1024;
    *(_DWORD *)&v904[6] = v95;
    *(_WORD *)v905 = 1024;
    *(_DWORD *)&v905[2] = v83;
    _os_log_impl(&dword_209FB3000, v94, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
  }
  v44 = a1;
  v96 = v839;
  if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    v97 = *(_DWORD *)(v70 + 52);
    if (v97)
      v97 -= *(_DWORD *)(v70 + 56) + *(_DWORD *)(v70 + 60);
    *(_DWORD *)buf = 136446978;
    v902 = "tcp_compute_segment_length";
    v903 = 2082;
    *(_QWORD *)v904 = v844;
    *(_WORD *)&v904[8] = 1024;
    *(_DWORD *)v905 = v97;
    *(_WORD *)&v905[4] = 1024;
    *(_DWORD *)&v905[6] = v848;
    v98 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v900 = 0;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v99 = __nwlog_tcp_log();
        v100 = type[0];
        if (os_log_type_enabled(v99, type[0]))
        {
          v101 = *(_DWORD *)(v70 + 52);
          if (v101)
            v101 -= *(_DWORD *)(v70 + 56) + *(_DWORD *)(v70 + 60);
          *(_DWORD *)buf = 136446978;
          v902 = "tcp_compute_segment_length";
          v903 = 2082;
          *(_QWORD *)v904 = v844;
          *(_WORD *)&v904[8] = 1024;
          *(_DWORD *)v905 = v101;
          *(_WORD *)&v905[4] = 1024;
          *(_DWORD *)&v905[6] = v848;
          v102 = "%{public}s %{public}s chained frame len %u is smaller than TCP header size %u";
          goto LABEL_191;
        }
      }
      else
      {
        v99 = __nwlog_tcp_log();
        v100 = type[0];
        if (os_log_type_enabled(v99, type[0]))
        {
          v108 = *(_DWORD *)(v70 + 52);
          if (v108)
            v108 -= *(_DWORD *)(v70 + 56) + *(_DWORD *)(v70 + 60);
          *(_DWORD *)buf = 136446978;
          v902 = "tcp_compute_segment_length";
          v903 = 2082;
          *(_QWORD *)v904 = v844;
          *(_WORD *)&v904[8] = 1024;
          *(_DWORD *)v905 = v108;
          *(_WORD *)&v905[4] = 1024;
          *(_DWORD *)&v905[6] = v848;
          v102 = "%{public}s %{public}s chained frame len %u is smaller than TCP header size %u, backtrace limit exceeded";
LABEL_191:
          _os_log_impl(&dword_209FB3000, v99, v100, v102, buf, 0x22u);
        }
      }
    }
    if (v98)
      free(v98);
    v96 = v839;
  }
  v109 = *(_QWORD *)(v96 + 1056);
  if (v109)
    ++*(_QWORD *)(v109 + 152);
  v43 = v892;
  if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
  {
    v110 = __nwlog_tcp_log();
    if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v902 = "tcp_input";
      v903 = 2082;
      *(_QWORD *)v904 = v844;
      _os_log_impl(&dword_209FB3000, v110, OS_LOG_TYPE_ERROR, "%{public}s %{public}s invalid frame list", buf, 0x16u);
    }
  }
  in_pcb_checkstate(a3, 2, 1);
  v55 = v849;
LABEL_66:
  *v43 = v55 != 0;
  result = (_QWORD *)*v44;
  if (*v44)
  {
    while (2)
    {
      v57 = (void (*)(_QWORD *, uint64_t, uint64_t))result[10];
      v58 = (_QWORD *)result[4];
      if (v57)
      {
        v59 = result[11];
        result[10] = 0;
        result[11] = 0;
        v57(result, 1, v59);
        goto LABEL_69;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v902 = "__nw_frame_finalize";
      v60 = _os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v900 = 0;
      v882 = (void *)v60;
      if (!__nwlog_fault())
        goto LABEL_85;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v864 = __nwlog_obj();
        loga = type[0];
        if (os_log_type_enabled(v864, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v902 = "__nw_frame_finalize";
          v61 = v864;
          v62 = loga;
          v63 = "%{public}s called with null frame->finalizer";
          break;
        }
        goto LABEL_85;
      }
      if (v900)
      {
        v865 = (void *)__nw_create_backtrace_string();
        logb = __nwlog_obj();
        v851 = type[0];
        v64 = os_log_type_enabled(logb, type[0]);
        if (v865)
        {
          if (v64)
          {
            *(_DWORD *)buf = 136446466;
            v902 = "__nw_frame_finalize";
            v903 = 2082;
            *(_QWORD *)v904 = v865;
            _os_log_impl(&dword_209FB3000, logb, v851, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v865);
          goto LABEL_85;
        }
        if (!v64)
        {
LABEL_85:
          if (v882)
            free(v882);
LABEL_69:
          result = v58;
          if (!v58)
            return result;
          continue;
        }
        *(_DWORD *)buf = 136446210;
        v902 = "__nw_frame_finalize";
        v61 = logb;
        v62 = v851;
        v63 = "%{public}s called with null frame->finalizer, no backtrace";
      }
      else
      {
        v866 = __nwlog_obj();
        logc = type[0];
        if (!os_log_type_enabled(v866, type[0]))
          goto LABEL_85;
        *(_DWORD *)buf = 136446210;
        v902 = "__nw_frame_finalize";
        v61 = v866;
        v62 = logc;
        v63 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }
      break;
    }
    _os_log_impl(&dword_209FB3000, v61, v62, v63, buf, 0xCu);
    goto LABEL_85;
  }
  return result;
}

uint64_t tcp_keepalive_reset(uint64_t a1)
{
  uint64_t result;
  int v3;

  result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  v3 = *(_DWORD *)(a1 + 676);
  if (!v3 || (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 372) & 8) == 0)
    v3 = *(_DWORD *)(sysctls + 192);
  *(_DWORD *)(a1 + 40) = v3 + *(_DWORD *)(result + 316) - *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 740) &= ~0x80u;
  *(_BYTE *)(a1 + 311) = 0;
  return result;
}

uint64_t tcp_sbrcv_grow(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  char v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  char v29;
  unsigned int v30;
  int v31;

  v8 = *(_QWORD *)(a2 + 72);
  result = nw_tcp_access_globals(v8);
  v10 = result;
  if (*(_DWORD *)(sysctls + 68))
  {
    if ((*(_BYTE *)(a2 + 49) & 4) != 0)
    {
      v11 = *(_DWORD *)(a2 + 4);
      v12 = *(_DWORD *)(sysctls + 72);
      if (v11 < v12
        && (*(_BYTE *)(a1 + 741) & 1) == 0
        && (*(_BYTE *)(v8 + 368) & 0x40) == 0
        && (*(_DWORD *)(sysctls + 260) || !*(_QWORD *)a1))
      {
        if ((~*(_DWORD *)(a1 + 88) & 0x180) != 0)
        {
          v25 = *(_DWORD *)(result + 316);
          v26 = *(_DWORD *)(a1 + 180) + (*(_DWORD *)(a1 + 1968) >> 5);
          v27 = *(_DWORD *)(a1 + 184) + a4;
          *(_DWORD *)(a1 + 184) = v27;
          if (v25 - v26 < 0)
            return result;
          v28 = *(_DWORD *)(a1 + 188);
          if (v27 > v28)
          {
            v29 = v27 <= v28 + (v28 >> 1) ? 1 : 2;
            v30 = v27 << v29;
            v31 = (v27 << v29) - v11;
            if (v31 >= 1)
            {
              result = tcp_sbrcv_reserve(a1, a2, v11 + v31 / *(_DWORD *)(a1 + 196) * *(_DWORD *)(a1 + 196), v30, v12);
              *(_DWORD *)(a1 + 188) = *(_DWORD *)(a1 + 184);
            }
          }
        }
        else
        {
          v13 = *(_DWORD *)(a3 + 8);
          if (v13)
          {
            v14 = *(_DWORD *)(a1 + 180);
            v15 = *(_DWORD *)(a1 + 184) + a4;
            *(_DWORD *)(a1 + 184) = v15;
            if (v13 - v14 < 0)
              return result;
            v16 = *(_DWORD *)(a1 + 188);
            if (v15 > v16)
            {
              v17 = v15 <= v16 + (v16 >> 1) ? 1 : 2;
              v18 = v15 << v17;
              v19 = (v15 << v17) - v11;
              *(_DWORD *)(a1 + 188) = v15;
              if (v19 >= 1)
                result = tcp_sbrcv_reserve(a1, a2, v11 + v19 / *(_DWORD *)(a1 + 196) * *(_DWORD *)(a1 + 196), v18, v12);
            }
            v20 = *(_QWORD *)(a1 + 768);
            if (v20)
            {
              v21 = *(_DWORD *)(a1 + 184);
              if (v21)
              {
                v22 = *(_DWORD *)(v10 + 316) - *(_DWORD *)(a1 + 180);
                if (v22 >= 1)
                {
                  v23 = *(_DWORD *)(v20 + 36);
                  v24 = v21 / v22;
                  if (v23)
                  {
                    if (v23 > v24)
                      v24 = *(_DWORD *)(v20 + 36);
                  }
                  *(_DWORD *)(v20 + 36) = v24;
                }
              }
            }
          }
        }
      }
    }
  }
  *(_QWORD *)(a1 + 180) = *(unsigned int *)(v10 + 316);
  return result;
}

BOOL tcp_stretch_ack_enable(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;

  v4 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  v5 = sysctls;
  if (*(_DWORD *)(a1 + 328) >= (*(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 52)))
  {
    v7 = *(_DWORD *)(a1 + 324);
    v6 = *(_DWORD *)(v4 + 316);
    if (v7 - v6 >= 0)
    {
      v8 = *(_DWORD *)(a1 + 88) | 0x2000000;
      goto LABEL_6;
    }
  }
  else
  {
    v6 = *(_DWORD *)(v4 + 316);
    v7 = *(_DWORD *)(a1 + 324);
  }
  v8 = *(_DWORD *)(a1 + 88) & 0xFDFFFFFF;
LABEL_6:
  *(_DWORD *)(a1 + 88) = v8;
  if (v6 - v7 - 200 >= 1)
  {
    v8 &= ~0x2000000u;
    *(_DWORD *)(a1 + 88) = v8;
  }
  if ((a2 & 0xFFFFFFEF) != 0)
  {
    v8 &= ~0x2000000u;
    *(_DWORD *)(a1 + 88) = v8;
  }
  v9 = *(_DWORD *)(a1 + 740);
  if ((v9 & 0x10000) != 0)
  {
    v10 = *(_DWORD *)(a1 + 340);
    if (v10 < 0x7D0)
    {
      *(_DWORD *)(a1 + 340) = v10 + 1;
    }
    else
    {
      v9 &= ~0x10000u;
      *(_DWORD *)(a1 + 740) = v9;
      *(_QWORD *)(a1 + 336) = 0;
    }
  }
  return (v9 & 0x10200) == 0
      && (v8 & 0x2000000) != 0
      && ((v9 & 2) == 0 || *(_DWORD *)(v5 + 76) <= (int)*(unsigned __int16 *)(a1 + 344));
}

uint64_t tcp_adaptive_rwtimo_check(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result;
  v3 = *(_QWORD *)(result + 80);
  if (*(_BYTE *)(result + 265))
  {
    if (a2 < 1)
      return result;
  }
  else
  {
    v4 = *(_QWORD *)(v3 + 448);
    if (!v4 || a2 < 1 || (*(_DWORD *)(v4 + 1052) & 8) == 0)
      return result;
  }
  if (*(_DWORD *)(result + 12) == 4)
  {
    result = nw_tcp_access_globals(*(_QWORD *)(v3 + 224));
    v5 = *(unsigned int *)(v2 + 228);
    if (v5 <= (*(_DWORD *)(v2 + 208) + (*(int *)(v2 + 200) >> 3)) >> 2)
      LODWORD(v5) = (*(_DWORD *)(v2 + 208) + (*(int *)(v2 + 200) >> 3)) >> 2;
    *(_DWORD *)(v2 + 40) = *(_DWORD *)(result + 316) - *(_DWORD *)(v2 + 64) + 2 * v5;
    *(_DWORD *)(v2 + 740) |= 0x80u;
    *(_BYTE *)(v2 + 311) = 0;
  }
  return result;
}

_QWORD *tcp_input_sbappendstream(uint64_t a1, uint64_t *a2, signed int a3, char a4)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  const char *v12;
  uint64_t v13;
  int v14;
  int v15;
  void *v16;
  NSObject *v17;
  os_log_type_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  const char *v25;
  uint64_t v26;
  _QWORD *v27;
  os_log_type_t *v28;
  _QWORD *result;
  void (*v30)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *v34;
  os_log_type_t v35;
  const char *v36;
  _BOOL4 v37;
  void *v38;
  uint64_t v39;
  NSObject *v40;
  void *v41;
  NSObject *v42;
  os_log_type_t v43;
  const char *v44;
  char *backtrace_string;
  _BOOL4 v46;
  os_log_type_t v47;
  os_log_type_t log;
  NSObject *loga;
  os_log_type_t logb;
  NSObject *v51;
  void *v52;
  NSObject *v53;
  void *v54;
  os_log_type_t type[8];
  os_log_type_t *v56;
  char v57;
  os_log_type_t v58;
  uint8_t buf[4];
  const char *v60;
  __int16 v61;
  const char *v62;
  __int16 v63;
  signed int v64;
  __int16 v65;
  int v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v8 = *a2;
  if (*a2)
  {
    v9 = 0;
    v10 = *a2;
    do
    {
      v11 = *(_DWORD *)(v10 + 52);
      if (v11)
        v11 -= *(_DWORD *)(v10 + 56) + *(_DWORD *)(v10 + 60);
      v9 += v11;
      v10 = *(_QWORD *)(v10 + 32);
    }
    while (v10);
  }
  else
  {
    v9 = 0;
  }
  if (v9 != a3 && (!a1 || (*(_BYTE *)(a1 + 828) & 2) == 0))
  {
    __nwlog_tcp_log();
    if (a1)
      v12 = (const char *)(a1 + 604);
    else
      v12 = "";
    v13 = *a2;
    if (*a2)
    {
      v14 = 0;
      do
      {
        v15 = *(_DWORD *)(v13 + 52);
        if (v15)
          v15 -= *(_DWORD *)(v13 + 56) + *(_DWORD *)(v13 + 60);
        v14 += v15;
        v13 = *(_QWORD *)(v13 + 32);
      }
      while (v13);
    }
    else
    {
      v14 = 0;
    }
    *(_DWORD *)buf = 136446978;
    v60 = "tcp_input_sbappendstream";
    v61 = 2082;
    v62 = v12;
    v63 = 1024;
    v64 = a3;
    v65 = 1024;
    v66 = v14;
    v16 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v58 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault())
      goto LABEL_38;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_tcp_log();
      v18 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        v19 = *a2;
        if (*a2)
        {
          v20 = 0;
          do
          {
            v21 = *(_DWORD *)(v19 + 52);
            if (v21)
              v21 -= *(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60);
            v20 += v21;
            v19 = *(_QWORD *)(v19 + 32);
          }
          while (v19);
        }
        else
        {
          v20 = 0;
        }
        *(_DWORD *)buf = 136446978;
        v60 = "tcp_input_sbappendstream";
        v61 = 2082;
        v62 = v12;
        v63 = 1024;
        v64 = a3;
        v65 = 1024;
        v66 = v20;
        v25 = "%{public}s %{public}s tlen %d != __nw_frame_array_unclaimed_length() %u";
LABEL_37:
        _os_log_impl(&dword_209FB3000, v17, v18, v25, buf, 0x22u);
      }
    }
    else
    {
      v17 = __nwlog_tcp_log();
      v18 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        v22 = *a2;
        if (*a2)
        {
          v23 = 0;
          do
          {
            v24 = *(_DWORD *)(v22 + 52);
            if (v24)
              v24 -= *(_DWORD *)(v22 + 56) + *(_DWORD *)(v22 + 60);
            v23 += v24;
            v22 = *(_QWORD *)(v22 + 32);
          }
          while (v22);
        }
        else
        {
          v23 = 0;
        }
        *(_DWORD *)buf = 136446978;
        v60 = "tcp_input_sbappendstream";
        v61 = 2082;
        v62 = v12;
        v63 = 1024;
        v64 = a3;
        v65 = 1024;
        v66 = v23;
        v25 = "%{public}s %{public}s tlen %d != __nw_frame_array_unclaimed_length() %u, backtrace limit exceeded";
        goto LABEL_37;
      }
    }
LABEL_38:
    if (v16)
      free(v16);
    v8 = *a2;
  }
  *(_QWORD *)type = 0;
  v56 = type;
  if ((a4 & 2) != 0 && !*(_DWORD *)(a1 + 824))
  {
    v26 = nw_protocol_tcp_copy_frame(a1, v8, a3);
    if (v26)
    {
      a4 &= ~2u;
      *(_QWORD *)(v26 + 32) = 0;
      v27 = v56;
      *(_QWORD *)(v26 + 40) = v56;
      *v27 = v26;
      v56 = (os_log_type_t *)(v26 + 32);
      goto LABEL_47;
    }
    v39 = *(_QWORD *)(*(_QWORD *)a1 + 240);
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      v40 = __nwlog_tcp_log();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v60 = "tcp_input_sbappendstream";
        v61 = 2082;
        v62 = (const char *)(a1 + 604);
        _os_log_impl(&dword_209FB3000, v40, OS_LOG_TYPE_ERROR, "%{public}s %{public}s nw_protocol_tcp_copy_frame failed", buf, 0x16u);
      }
    }
    if (v8)
    {
      if ((*(_WORD *)(v8 + 204) & 0x100) == 0
        || !*MEMORY[0x24BDE08C0]
        || (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v8, *(_QWORD *)(v8 + 88)) & 1) != 0)
      {
        goto LABEL_79;
      }
      goto LABEL_78;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v60 = "__nw_frame_check_validity";
    v41 = (void *)_os_log_send_and_compose_impl();
    v58 = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (__nwlog_fault())
    {
      if (v58 == OS_LOG_TYPE_FAULT)
      {
        v42 = __nwlog_obj();
        v43 = v58;
        if (!os_log_type_enabled(v42, v58))
          goto LABEL_94;
        *(_DWORD *)buf = 136446210;
        v60 = "__nw_frame_check_validity";
        v44 = "%{public}s called with null frame";
        goto LABEL_93;
      }
      if (!v57)
      {
        v42 = __nwlog_obj();
        v43 = v58;
        if (!os_log_type_enabled(v42, v58))
          goto LABEL_94;
        *(_DWORD *)buf = 136446210;
        v60 = "__nw_frame_check_validity";
        v44 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_93;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v42 = __nwlog_obj();
      v43 = v58;
      v46 = os_log_type_enabled(v42, v58);
      if (backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          v60 = "__nw_frame_check_validity";
          v61 = 2082;
          v62 = backtrace_string;
          _os_log_impl(&dword_209FB3000, v42, v43, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_94;
      }
      if (v46)
      {
        *(_DWORD *)buf = 136446210;
        v60 = "__nw_frame_check_validity";
        v44 = "%{public}s called with null frame, no backtrace";
LABEL_93:
        _os_log_impl(&dword_209FB3000, v42, v43, v44, buf, 0xCu);
      }
    }
LABEL_94:
    if (v41)
      free(v41);
LABEL_78:
    *(_QWORD *)(v39 + 1056) = 0;
LABEL_79:
    tcp_drop(v39, 53);
    return 0;
  }
  if (v8)
  {
    *(_QWORD *)(v8 + 40) = type;
    v28 = (os_log_type_t *)a2[1];
    *(_QWORD *)type = v8;
    v56 = v28;
    *a2 = 0;
    a2[1] = (uint64_t)a2;
  }
LABEL_47:
  if (a3 > 0)
    return (_QWORD *)sbappendstream((int *)(a1 + 488), (uint64_t *)type, a3, a4);
  result = *(_QWORD **)type;
  if (*(_QWORD *)type)
  {
    while (1)
    {
      v30 = (void (*)(_QWORD *, uint64_t, uint64_t))result[10];
      v31 = (_QWORD *)result[4];
      if (!v30)
        break;
      v32 = result[11];
      result[10] = 0;
      result[11] = 0;
      v30(result, 1, v32);
LABEL_53:
      result = v31;
      if (!v31)
        return result;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v60 = "__nw_frame_finalize";
    v33 = _os_log_send_and_compose_impl();
    v58 = OS_LOG_TYPE_ERROR;
    v57 = 0;
    v54 = (void *)v33;
    if (__nwlog_fault())
    {
      if (v58 == OS_LOG_TYPE_FAULT)
      {
        v51 = __nwlog_obj();
        log = v58;
        if (!os_log_type_enabled(v51, v58))
          goto LABEL_69;
        *(_DWORD *)buf = 136446210;
        v60 = "__nw_frame_finalize";
        v34 = v51;
        v35 = log;
        v36 = "%{public}s called with null frame->finalizer";
        goto LABEL_68;
      }
      if (!v57)
      {
        v53 = __nwlog_obj();
        logb = v58;
        if (!os_log_type_enabled(v53, v58))
          goto LABEL_69;
        *(_DWORD *)buf = 136446210;
        v60 = "__nw_frame_finalize";
        v34 = v53;
        v35 = logb;
        v36 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        goto LABEL_68;
      }
      v52 = (void *)__nw_create_backtrace_string();
      loga = __nwlog_obj();
      v47 = v58;
      v37 = os_log_type_enabled(loga, v58);
      v38 = v52;
      if (v52)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          v60 = "__nw_frame_finalize";
          v61 = 2082;
          v62 = (const char *)v52;
          _os_log_impl(&dword_209FB3000, loga, v47, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          v38 = v52;
        }
        free(v38);
        goto LABEL_69;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        v60 = "__nw_frame_finalize";
        v34 = loga;
        v35 = v47;
        v36 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_68:
        _os_log_impl(&dword_209FB3000, v34, v35, v36, buf, 0xCu);
      }
    }
LABEL_69:
    if (v54)
      free(v54);
    goto LABEL_53;
  }
  return result;
}

uint64_t tcp_update_window(uint64_t a1, char a2, uint64_t a3, unsigned int a4, int a5)
{
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t all_stats;

  if ((a2 & 0x10) == 0)
    return 0;
  v8 = *(_DWORD *)(a1 + 104);
  v9 = *(_DWORD *)(a3 + 4);
  if (v8 - v9 >= 0)
  {
    if (v8 != v9)
      return 0;
    v10 = *(_DWORD *)(a1 + 108);
    v11 = *(_DWORD *)(a3 + 8);
    if (v10 - v11 >= 0 && (v10 != v11 || *(_DWORD *)(a1 + 140) >= a4))
      return 0;
  }
  if (!a5 && *(_DWORD *)(a1 + 108) == *(_DWORD *)(a3 + 8) && *(_DWORD *)(a1 + 140) < a4)
  {
    v12 = *(_QWORD *)(a1 + 1056);
    if (v12)
      ++*(_QWORD *)(v12 + 296);
  }
  *(_DWORD *)(a1 + 140) = a4;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 24))
  {
    all_stats = nw_protocol_tcp_get_all_stats();
    a4 = *(_DWORD *)(a1 + 140);
    if (all_stats)
    {
      *(_DWORD *)(all_stats + 112) = a4;
      a4 = *(_DWORD *)(a1 + 140);
    }
  }
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a3 + 4);
  if (a4 > *(_DWORD *)(a1 + 252))
    *(_DWORD *)(a1 + 252) = a4;
  return 1;
}

void tcp_bad_rexmt_check(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  int v12;
  int v13;
  int v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  int v21;
  void (*v22)(uint64_t);
  uint64_t v23;
  int v24;
  int v25;

  if (*(_WORD *)(a1 + 226) && tcp_detect_bad_rexmt(a1, a2, a3, *(_DWORD *)(a1 + 248)))
  {
    v6 = *(_QWORD *)(a1 + 1056);
    if (v6)
      ++*(_QWORD *)(v6 + 1312);
    tcp_bad_rexmt_restore_state(a1, a2);
  }
  else if ((*(_BYTE *)(a1 + 741) & 0x10) != 0
         && (v7 = *(_DWORD *)(a1 + 928)) != 0
         && *(_DWORD *)(a2 + 8) - v7 >= 0
         && !tcp_detect_bad_rexmt(a1, a2, a3, *(_DWORD *)(a1 + 936)))
  {
    v20 = *(_QWORD *)(a1 + 1056);
    if (v20)
      ++*(_QWORD *)(v20 + 752);
    v21 = *(_DWORD *)(a1 + 88);
    if ((v21 & 0x200000) == 0)
    {
      v22 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 64);
      if (v22)
      {
        v22(a1);
        v21 = *(_DWORD *)(a1 + 88);
      }
      *(_DWORD *)(a1 + 88) = v21 | 0x200000;
      v23 = *(_QWORD *)(a1 + 80);
      if ((*(_BYTE *)(v23 + 2231) & 0x40) != 0)
        inp_reset_fc_state(v23);
      if (*(_QWORD *)(a1 + 952))
        tcp_rxtseg_clean(a1);
      v24 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 96) + (v24 << 27 >> 31);
      v25 = *(_DWORD *)(a1 + 740);
      *(_DWORD *)(a1 + 28) = 0;
      *(_DWORD *)(a1 + 172) = 0;
      *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 148);
      *(_DWORD *)(a1 + 88) = v24 & 0xFFDFFFFF;
      *(_DWORD *)(a1 + 8) = 0;
      *(_BYTE *)(a1 + 310) = 3;
      *(_DWORD *)(a1 + 288) = 0;
      *(_DWORD *)(a1 + 348) &= ~0x20u;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 740) = v25 & 0xFFE7FFFF;
      *(_DWORD *)(a1 + 984) = 0;
      *(_DWORD *)(a1 + 628) = 0;
    }
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 952);
    if (v8 && *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 152) >= 0)
    {
      v9 = (_QWORD *)(a1 + 952);
      while ((*(_WORD *)(v8 + 10) & 1) != 0)
      {
        v8 = *(_QWORD *)(v8 + 16);
        if (!v8)
        {
          v10 = *(_QWORD *)(a1 + 1056);
          if (v10)
            ++*(_QWORD *)(v10 + 1032);
          tcp_bad_rexmt_restore_state(a1, a2);
          v11 = *(_QWORD **)(a1 + 952);
          if (v11)
          {
            do
            {
              v17 = (_QWORD *)*v9;
              v18 = (_QWORD *)(a1 + 952);
              if ((_QWORD *)*v9 != v11)
              {
                do
                {
                  v19 = v17;
                  v17 = (_QWORD *)v17[2];
                }
                while (v17 != v11);
                v18 = v19 + 2;
              }
              v16 = (_QWORD *)v11[2];
              *v18 = v16;
              nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
              free(v11);
              v11 = v16;
            }
            while (v16);
          }
          *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
          break;
        }
      }
    }
  }
  *(_DWORD *)(a1 + 740) &= ~0x1000u;
  *(_DWORD *)(a1 + 928) = 0;
  *(_DWORD *)(a1 + 936) = 0;
  if (*(_WORD *)(a1 + 226))
  {
    v12 = *(_DWORD *)(a1 + 88);
    if ((v12 & 0x20000000) != 0)
    {
      v13 = *(_DWORD *)(a1 + 700);
      if ((~v12 & 0x180) == 0 && v13 != 0 && (*(_BYTE *)a3 & 1) != 0)
      {
        v15 = *(_DWORD *)(a3 + 8);
        if (v15)
        {
          if (v15 - v13 < 0)
            tcp_pmtud_revert_segment_size(a1);
        }
      }
    }
  }
  if (*(_DWORD *)(a1 + 700))
    *(_DWORD *)(a1 + 700) = 0;
  *(_WORD *)(a1 + 696) = 0;
}

void tcp_compute_rtt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  int v8;
  signed int v9;
  signed int v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  void *v21;

  if (!a2 || !a3)
  {
    v20 = __nwlog_obj();
    os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    v21 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v21);
  }
  v6 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  v7 = *(_DWORD *)(a1 + 172);
  if (v7)
  {
    v8 = *(_DWORD *)(a3 + 8);
    if (v8 - *(_DWORD *)(a1 + 176) >= 1)
    {
      v9 = *(_DWORD *)(v6 + 316) - v7;
      if (v9)
        v10 = v9;
      else
        v10 = 1;
      v11 = v8 - *(_DWORD *)(a1 + 976);
      if (v11 < 1)
        goto LABEL_23;
      v12 = *(unsigned __int8 *)(a1 + 751);
      *(_DWORD *)(a1 + 964 + 4 * v12) = v11;
      *(_BYTE *)(a1 + 751) = (v12 + 1) % 3u;
      v13 = *(_DWORD *)(a1 + 964);
      if (v13 <= *(_DWORD *)(a1 + 968))
        v13 = *(_DWORD *)(a1 + 968);
      if (*(_DWORD *)(a1 + 972) > v13)
        v13 = *(_DWORD *)(a1 + 972);
      if (*(_DWORD *)(sysctls + 304))
      {
        v14 = *(_DWORD *)(sysctls + 16);
      }
      else
      {
        if (!*(_DWORD *)(sysctls + 276))
        {
          v15 = 4380;
          goto LABEL_20;
        }
        v14 = 10;
      }
      v15 = *(_DWORD *)(a1 + 196) * v14;
LABEL_20:
      if (v13 <= v15)
        v13 = 0;
      *(_DWORD *)(a1 + 980) = v13;
LABEL_23:
      *(_DWORD *)(a1 + 172) = 0;
      if ((*(_BYTE *)a2 & 1) == 0)
        goto LABEL_27;
      goto LABEL_24;
    }
  }
  v10 = 0;
  if ((*(_BYTE *)a2 & 1) == 0)
    goto LABEL_27;
LABEL_24:
  v16 = *(_DWORD *)(a2 + 8);
  if (v16)
  {
    v17 = *(_DWORD *)(v6 + 316) - v16;
    if (v17 >= 0)
    {
      v18 = *(_DWORD *)(a3 + 8);
      v19 = a1;
      v10 = v17;
      goto LABEL_29;
    }
  }
LABEL_27:
  if (v10 < 1)
    return;
  v18 = *(_DWORD *)(a3 + 8);
  v19 = a1;
  v16 = 0;
LABEL_29:
  tcp_xmit_timer(v19, v10, v16, v18);
}

uint64_t update_iaj_state(uint64_t result, unsigned int a2)
{
  BOOL v2;
  uint64_t v3;

  if (*(_WORD *)(result + 748))
    v2 = *(unsigned __int16 *)(result + 748) > a2;
  else
    v2 = 0;
  if (!v2)
  {
    v3 = result;
    *(_WORD *)(result + 748) = a2;
    result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(result + 80) + 224));
    *(_DWORD *)(v3 + 744) = *(_DWORD *)(result + 316);
    *(_BYTE *)(v3 + 750) = 0;
  }
  return result;
}

uint64_t tcp_tfo_rcv_ack(uint64_t result, uint64_t a2)
{
  _DWORD *v2;
  int v3;
  uint64_t v4;

  if (*(_BYTE *)(result + 993) == 1)
  {
    v2 = (_DWORD *)result;
    if (*(_BYTE *)(result + 992))
    {
      v3 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(result + 120);
      if (v3)
      {
        if (v3 >= 1)
        {
          *(_BYTE *)(result + 993) = 2;
          result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(result + 80) + 224));
          v4 = v2[57];
          if (v4 <= (v2[52] + ((int)v2[50] >> 3)) >> 2)
            LODWORD(v4) = (v2[52] + ((int)v2[50] >> 3)) >> 2;
          v2[10] = *(_DWORD *)(result + 316) - v2[16] + v4;
        }
      }
      else
      {
        *(_BYTE *)(result + 993) = 0;
      }
    }
  }
  return result;
}

uint64_t tcp_update_snd_una(uint64_t a1, int a2)
{
  uint64_t result;

  *(_DWORD *)(a1 + 92) = a2;
  result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 24);
  if (result)
  {
    result = nw_protocol_tcp_get_all_stats();
    if (result)
      *(_DWORD *)(result + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
  }
  return result;
}

uint64_t tcp_bwmeas_check(uint64_t result)
{
  _DWORD *v1;
  int v2;
  uint64_t v3;
  _DWORD *v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;

  v1 = *(_DWORD **)(result + 768);
  v2 = *(_DWORD *)(result + 92) - *v1;
  if (v2 >= 1)
  {
    v3 = result;
    if ((*(_BYTE *)(result + 740) & 4) != 0 && v2 >= v1[2])
    {
      result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(result + 80) + 224));
      v4 = *(_DWORD **)(v3 + 768);
      v5 = *(_DWORD *)(result + 316) - v4[1];
      if (v5 && v5 <= v2)
      {
        v6 = v2 / v5;
        v7 = v4[7];
        v8 = v4[8];
        if (v7)
          v6 = (v6 - v7 + 8 * v7) >> 3;
        if (v6 <= v8)
          v9 = v4[8];
        else
          v9 = v6;
        if (!v8)
          v9 = v6;
        v4[7] = v6;
        v4[8] = v9;
      }
      *(_DWORD *)(v3 + 740) &= ~4u;
    }
  }
  return result;
}

uint64_t tcp_sbsnd_trim(uint64_t result)
{
  _DWORD *v1;
  int v2;
  unsigned int v3;
  unsigned int v4;

  v1 = (_DWORD *)result;
  v2 = *(_DWORD *)(result + 48);
  if ((~v2 & 0xC00) == 0)
  {
    v3 = *(_DWORD *)(result + 52);
    if (v3)
    {
      if (*(_DWORD *)(result + 4) > v3)
      {
        if (*(_DWORD *)result > v3)
          v3 = *(_DWORD *)result;
        if (v3 <= 0x71C71C)
        {
          *(_DWORD *)(result + 4) = v3;
          result = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
          if ((v2 & 4) != 0)
          {
            if (result)
            {
              result = nw_protocol_tcp_get_all_stats();
              if (result)
                *(_DWORD *)(result + 88) = v1[1];
            }
          }
          else if (result)
          {
            result = nw_protocol_tcp_get_all_stats();
            if (result)
              *(_DWORD *)(result + 100) = v1[1];
          }
          v4 = v1[1];
          if (v1[2] > v4)
            v1[2] = v4;
        }
      }
    }
  }
  if (v1[1] <= v1[13])
    v1[12] &= ~0x800u;
  return result;
}

void tcp_cubic_ack_rcvd(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  int v11;

  v2 = *(_DWORD *)(a1 + 980);
  if (v2)
  {
    v3 = *(_DWORD *)(a1 + 144);
    if (v2 < v3 >> 1)
    {
      v4 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
      if (!v4 || *(_DWORD *)(v4 + 384) <= v3)
      {
        *(_DWORD *)(a1 + 740) |= 0x100000u;
        return;
      }
    }
    *(_DWORD *)(a1 + 740) &= ~0x100000u;
  }
  else
  {
    *(_DWORD *)(a1 + 740) &= ~0x100000u;
    v3 = *(_DWORD *)(a1 + 144);
  }
  if (v3 >= *(_DWORD *)(a1 + 148))
  {
    tcp_cubic_congestion_avd(a1, a2);
  }
  else
  {
    v5 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
    if (*(_DWORD *)(sysctls + 276))
    {
      if (*(_DWORD *)(sysctls + 304))
        v6 = *(_DWORD *)(sysctls + 16);
      else
        v6 = 10;
      v7 = *(_DWORD *)(a1 + 196) * v6;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 196) << (*(_DWORD *)(a1 + 100) == *(_DWORD *)(a1 + 96));
    }
    if (v5 >= v7)
      v5 = v7;
    v8 = v5 + v3;
    v9 = *(_BYTE *)(a1 + 260);
    v10 = 0xFFFFLL << v9;
    v11 = 0xFFFF << v9;
    if (v10 <= v8)
      LODWORD(v8) = v11;
    *(_DWORD *)(a1 + 144) = v8;
  }
}

_DWORD *tcp_update_sack_list(_DWORD *result, int a2, int a3)
{
  _DWORD *v3;
  uint64_t v4;
  int v5;
  _QWORD *v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  _QWORD __src[7];

  v3 = result;
  __src[6] = *MEMORY[0x24BDAC8D0];
  v4 = result[141];
  if ((int)v4 < 1)
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    v6 = result + 142;
    do
    {
      v7 = *v6;
      v8 = HIDWORD(*v6);
      if (v7 - v8 < 0 && v7 - result[30] >= 1)
      {
        if (a2 - v8 > 0 || a3 - v7 < 0)
        {
          __src[v5++] = *v6;
        }
        else
        {
          if (a2 - v7 > 0)
            a2 = *v6;
          if (a3 - v8 < 0)
            a3 = HIDWORD(*v6);
        }
      }
      ++v6;
      --v4;
    }
    while (v4);
  }
  if (a2 - result[30] < 1)
  {
    v9 = 0;
    if (v5 < 1)
      goto LABEL_18;
    goto LABEL_17;
  }
  result[142] = a2;
  result[143] = a3;
  v5 -= v5 > 5;
  v9 = 1;
  if (v5 >= 1)
LABEL_17:
    result = memcpy(&result[2 * v9 + 142], __src, 8 * v5);
LABEL_18:
  v10 = v5 + v9;
  v3[141] = v5 + v9;
  v11 = v3[22];
  if (v11 < 0 && v10 >= 1)
  {
    v3[22] = v11 & 0x7DFFFFFF;
    *((_QWORD *)v3 + 41) = 0;
    result = (_DWORD *)nw_tcp_access_globals(*(_QWORD *)(*((_QWORD *)v3 + 10) + 224));
    v3[81] = result[79] + 100;
    v3[185] |= 2u;
    *((_WORD *)v3 + 172) = 0;
    v10 = v3[141];
  }
  if (v10 >= 1)
  {
    *((_WORD *)v3 + 154) = 16;
    if (*((_WORD *)v3 + 377))
    {
      *((_WORD *)v3 + 377) = 0;
      v3[186] = 0;
    }
  }
  return result;
}

uint64_t tcp_dooptions(uint64_t result, unsigned __int8 *a2, int a3, uint64_t a4, uint64_t a5)
{
  unsigned int v5;
  BOOL v6;
  int v7;
  BOOL v8;
  unsigned int v9;
  char v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  unsigned int v16;

  if (a3 >= 1)
  {
    do
    {
      v7 = *a2;
      if (v7 == 1)
      {
        v5 = 1;
      }
      else
      {
        if (*a2)
          v8 = a3 >= 2;
        else
          v8 = 0;
        if (!v8)
          return result;
        v5 = a2[1];
        v9 = v5 - 2;
        if (v5 < 2 || a3 < v5)
          return result;
        switch(*a2)
        {
          case 2u:
            if (v5 == 4)
            {
              if ((*(_BYTE *)(a4 + 13) & 2) != 0)
              {
                *(_WORD *)(a5 + 12) = bswap32(*((unsigned __int16 *)a2 + 1)) >> 16;
                *(_DWORD *)a5 |= 0x10u;
              }
              v5 = 4;
            }
            break;
          case 3u:
            if (v5 == 3)
            {
              if ((*(_BYTE *)(a4 + 13) & 2) != 0)
              {
                *(_DWORD *)a5 |= 0x20u;
                v16 = a2[2];
                if (v16 >= 0xE)
                  LOBYTE(v16) = 14;
                *(_BYTE *)(a5 + 14) = v16;
                v5 = 3;
              }
              else
              {
                v5 = 3;
              }
            }
            break;
          case 4u:
            if (v5 == 2)
            {
              if ((*(_BYTE *)(a4 + 13) & 2) == 0)
                goto LABEL_48;
              v12 = *(_DWORD *)a5 | 0x100;
              goto LABEL_44;
            }
            break;
          case 5u:
            if (v5 >= 3 && (v9 & 7) == 0)
            {
              *(_BYTE *)(a5 + 15) = v9 >> 3;
              *(_QWORD *)(a5 + 16) = a2 + 2;
              v13 = *(_QWORD *)(result + 1056);
              if (v13)
                ++*(_QWORD *)(v13 + 592);
            }
            break;
          case 6u:
          case 7u:
          case 9u:
          case 0xAu:
          case 0xBu:
          case 0xCu:
          case 0xDu:
          case 0xEu:
          case 0xFu:
          case 0x10u:
          case 0x11u:
          case 0x12u:
          case 0x13u:
          case 0x14u:
          case 0x15u:
          case 0x16u:
          case 0x17u:
          case 0x18u:
          case 0x19u:
          case 0x1Au:
          case 0x1Bu:
          case 0x1Cu:
          case 0x1Du:
          case 0x1Eu:
          case 0x1Fu:
          case 0x20u:
          case 0x21u:
            break;
          case 8u:
            if (v5 == 10)
            {
              *(_DWORD *)a5 |= 1u;
              *(_DWORD *)(a5 + 4) = bswap32(*(_DWORD *)(a2 + 2));
              v14 = *(_DWORD *)(a2 + 6);
              *(_DWORD *)(a5 + 8) = v14;
              *(_DWORD *)(a5 + 8) = bswap32(v14) - *(_DWORD *)(result + 1888);
              v15 = *(_DWORD *)(result + 88);
              if ((v15 & 0x80) == 0)
                *(_DWORD *)(result + 88) = v15 | 0x80;
              v5 = 10;
            }
            break;
          case 0x22u:
            if (v5 == 2)
            {
              if (*(_DWORD *)(result + 12) == 1)
              {
                v12 = *(_DWORD *)a5 | 0x800;
LABEL_44:
                *(_DWORD *)a5 = v12;
                v5 = 2;
              }
              else
              {
LABEL_48:
                v5 = 2;
              }
            }
            else if ((v5 - 19) >= 0xF3u && (*(_DWORD *)(result + 12) - 1) <= 1)
            {
              *(_DWORD *)a5 |= 0x400u;
              *(_QWORD *)(a5 + 24) = a2 + 1;
            }
            break;
          default:
            if ((v7 == 172 || v7 == 174) && v5 >= 5)
            {
              v11 = (v5 - 2) / 3u;
              if ((-3 * v11) == (2 - v5))
              {
                *(_BYTE *)(a5 + 32) = v11;
                *(_QWORD *)(a5 + 40) = a2 + 2;
                *(_BYTE *)(a5 + 48) = v7 == 174;
              }
            }
            break;
        }
      }
      a2 += v5;
      v6 = __OFSUB__(a3, v5);
      a3 -= v5;
    }
    while (!((a3 < 0) ^ v6 | (a3 == 0)));
  }
  return result;
}

uint64_t tcp_sbrcv_tstmp_check(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  unsigned int v4;
  char v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  unsigned int v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  int v14;

  if ((~*(_DWORD *)(result + 88) & 0x180) != 0)
  {
    v1 = result;
    v2 = *(_QWORD *)(*(_QWORD *)(result + 80) + 224);
    v3 = *(_DWORD *)(v2 + 536);
    if ((v3 & 0x400) != 0)
    {
      v4 = 2 * *(_DWORD *)(sysctls + 236);
      v5 = *(_BYTE *)(result + 261);
      v6 = 0xFFFFLL << v5;
      v7 = 0xFFFF << v5;
      v8 = v6 <= v4 ? v7 : 2 * *(_DWORD *)(sysctls + 236);
      if (v8 > *(_DWORD *)(v2 + 492) && v8 <= 0x71C71C)
      {
        *(_DWORD *)(v2 + 492) = v8;
        result = *(_QWORD *)(*(_QWORD *)(v2 + 560) + 24);
        if ((v3 & 4) != 0)
        {
          if (result)
          {
            result = nw_protocol_tcp_get_all_stats();
            if (result)
              *(_DWORD *)(result + 88) = *(_DWORD *)(v2 + 492);
          }
        }
        else if (result)
        {
          result = nw_protocol_tcp_get_all_stats();
          if (result)
            *(_DWORD *)(result + 100) = *(_DWORD *)(v2 + 492);
        }
        v10 = *(_DWORD *)(v2 + 492);
        if (*(_DWORD *)(v2 + 496) > v10)
          *(_DWORD *)(v2 + 496) = v10;
        LODWORD(v11) = *(_DWORD *)(v2 + 540);
        if (v11 <= v8)
          LODWORD(v11) = v8;
        if (v11 >= v4)
          v11 = v4;
        else
          v11 = v11;
        v12 = *(_BYTE *)(v1 + 261);
        v13 = 0xFFFFLL << v12;
        v14 = 0xFFFF << v12;
        if (v13 <= v11)
          LODWORD(v11) = v14;
        *(_DWORD *)(v2 + 540) = v11;
      }
    }
  }
  return result;
}

void tcp_finalize_options(uint64_t a1, int *a2, uint64_t a3)
{
  int v6;
  int v7;
  int v8;

  v6 = *a2;
  if ((*a2 & 1) != 0)
  {
    *(_DWORD *)(a1 + 88) |= 0x100u;
    *(_DWORD *)(a1 + 276) = a2[1];
    *(_DWORD *)(a1 + 280) = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316);
    v6 = *a2;
    if ((*a2 & 0x10) == 0)
    {
LABEL_3:
      v7 = *(_DWORD *)(a1 + 740);
      if ((v7 & 0x20) == 0)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else if ((v6 & 0x10) == 0)
  {
    goto LABEL_3;
  }
  tcp_mss(a1, *((unsigned __int16 *)a2 + 6), a3);
  v6 = *a2;
  v7 = *(_DWORD *)(a1 + 740);
  if ((v7 & 0x20) == 0)
  {
LABEL_4:
    if ((v6 & 0x20) == 0)
      return;
    goto LABEL_12;
  }
LABEL_8:
  if ((v6 & 0x100) != 0)
  {
    *(_DWORD *)(a1 + 88) |= 0x200u;
    if ((v6 & 0x20) == 0)
      return;
  }
  else
  {
    *(_DWORD *)(a1 + 740) = v7 & 0xFFFFFFDF;
    if ((v6 & 0x20) == 0)
      return;
  }
LABEL_12:
  v8 = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 88) = v8 | 0x40;
  *(_BYTE *)(a1 + 263) = *((_BYTE *)a2 + 14);
  if (*(_BYTE *)(a1 + 262))
    *(_DWORD *)(a1 + 88) = v8 | 0x60;
}

uint64_t soisconnected(uint64_t result)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  __int16 v4;
  __int16 v5;
  int v6;
  BOOL v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t);
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t);
  uint64_t (*v15)(uint64_t);
  uint64_t v16;

  v2 = (_QWORD *)result;
  v3 = *(_QWORD *)(result + 296);
  v4 = *(_WORD *)(result + 376);
  v5 = v4 & 0xFBF1 | 2;
  *(_WORD *)(result + 376) = v5;
  *(_DWORD *)(result + 484) = 0;
  *(_DWORD *)(result + 588) = 0;
  v6 = v4 & 0x800;
  if (v3)
    v7 = v6 == 0;
  else
    v7 = 1;
  if (v7)
  {
    v8 = *(_QWORD *)(result + 32);
    if (v8)
    {
      v9 = *(uint64_t (**)(uint64_t))(v8 + 24);
      if (!v9 || (result = v9(result), (v8 = v2[4]) != 0))
      {
        if (*(_QWORD *)v8)
          return (*(uint64_t (**)(_QWORD *))v8)(v2);
      }
    }
  }
  else
  {
    *(_WORD *)(result + 376) = v5 & 0xE3F3 | 0x1000;
    if (*(_QWORD *)(*(_QWORD *)(v3 + 8) + 32))
    {
      (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(result + 8) + 24))(result, 0, v1);
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v3 + 8) + 16))(v3, 1, v1);
    }
    v10 = v2[42];
    v11 = (_QWORD *)v2[43];
    if (v10)
    {
      *(_QWORD *)(v10 + 344) = v11;
      v11 = (_QWORD *)v2[43];
    }
    else
    {
      *(_QWORD *)(v3 + 312) = v11;
    }
    *v11 = v10;
    --*(_WORD *)(v3 + 356);
    v12 = *(_QWORD **)(v3 + 328);
    v2[42] = 0;
    v2[43] = v12;
    *v12 = v2;
    *(_QWORD *)(v3 + 328) = v2 + 42;
    v13 = *(_QWORD *)(v3 + 32);
    if (v13)
    {
      v14 = *(uint64_t (**)(uint64_t))(v13 + 24);
      if (!v14 || (result = v14(v3), (v13 = *(_QWORD *)(v3 + 32)) != 0))
      {
        v15 = *(uint64_t (**)(uint64_t))(v13 + 48);
        if (v15)
          result = v15(v3);
      }
    }
    v16 = *(_QWORD *)(v3 + 8);
    if (*(_QWORD *)(v16 + 32))
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 24))(v3, 1, v1);
      return (*(uint64_t (**)(_QWORD *, _QWORD, uint64_t))(v2[1] + 16))(v2, 0, v1);
    }
  }
  return result;
}

void nw_protocol_tcp_wake_connected(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  _BYTE v8[22];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) < 2u)
  {
    *(_DWORD *)(v2 + 5224) = 2;
    if (*MEMORY[0x24BDE08B8] != -1)
      dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_16);
    if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
      kdebug_trace();
    *(_QWORD *)v8 = 0;
    *(_QWORD *)&v8[8] = 0;
    microuptime((uint64_t)v8);
    v4 = *(_QWORD *)v8 - *(_QWORD *)(v2 + 5248);
    v5 = *(_DWORD *)&v8[8] - *(_DWORD *)(v2 + 5256);
    if (v5 < 0)
    {
      v7 = -1;
      v6 = 1000000;
    }
    else
    {
      if (v5 <= 0xF423F)
      {
LABEL_16:
        *(_DWORD *)(v2 + 5296) = v5 + 1000000 * v4;
        nw_protocol_upcast();
        nw_protocol_get_input_handler();
        nw_protocol_connected_quiet();
        return;
      }
      v6 = -1000000;
      v7 = 1;
    }
    LODWORD(v4) = v7 + v4;
    v5 += v6;
    goto LABEL_16;
  }
  if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    v3 = __nwlog_tcp_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v8 = 136446466;
      *(_QWORD *)&v8[4] = "nw_protocol_tcp_wake_connected";
      *(_WORD *)&v8[12] = 2082;
      *(_QWORD *)&v8[14] = a1 + 604;
      _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", v8, 0x16u);
    }
  }
}

uint64_t compute_iaj_meat(uint64_t result, unsigned int a2)
{
  int v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  char v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;

  v2 = *(_DWORD *)(result + 756);
  v3 = *(_DWORD *)(result + 760);
  v4 = v3 + v2;
  if ((v3 + v2) <= *(_DWORD *)(sysctls + 64))
    v4 = *(_DWORD *)(sysctls + 64);
  if (*(unsigned __int16 *)(result + 752) >= 0x29u)
  {
    v5 = *(unsigned __int16 *)(result + 754);
    v6 = a2 - v4 + v5;
    v7 = v5 >= 2;
    v8 = v5 - 2;
    if (!v7)
      v8 = 0;
    if (a2 <= v4)
      v9 = v8;
    else
      v9 = v6;
    v10 = *(_DWORD *)(sysctls + 112) + 100;
    if (v9 < v10)
      LOWORD(v10) = v9;
    *(_WORD *)(result + 754) = v10;
  }
  *(_DWORD *)(result + 756) = (a2 - v2 + 16 * v2 + 8) >> 4;
  v11 = (a2 - v2) * (a2 - v2) - v3 * v3 + 16 * v3 * v3 + 8;
  v12 = v11 >> 4;
  if (v11 >= 0x650)
  {
    v13 = 0;
    v14 = 15;
    v15 = 0x8000;
    do
    {
      v16 = (v15 + 2 * v13) << v14;
      if (v12 >= v16)
      {
        v17 = v15;
      }
      else
      {
        v16 = 0;
        v17 = 0;
      }
      v13 += v17;
      if (v15 < 2)
        break;
      --v14;
      v15 >>= 1;
      v12 -= v16;
    }
    while (v12);
    *(_DWORD *)(result + 760) = v13;
  }
  else if (v12 > 1)
  {
    if (v11 >= 0x40)
    {
      if (v12 == 4)
      {
        *(_DWORD *)(result + 760) = 2;
      }
      else if (v11 >= 0x90)
      {
        if (v12 == 9 || v11 < 0x100)
        {
          *(_DWORD *)(result + 760) = 3;
        }
        else if (v12 == 16 || v11 < 0x190)
        {
          *(_DWORD *)(result + 760) = 4;
        }
        else if (v12 == 25 || v11 < 0x240)
        {
          *(_DWORD *)(result + 760) = 5;
        }
        else if (v12 == 36 || v11 < 0x310)
        {
          *(_DWORD *)(result + 760) = 6;
        }
        else if (v12 == 49 || v11 < 0x400)
        {
          *(_DWORD *)(result + 760) = 7;
        }
        else if (v12 == 64 || v11 < 0x510)
        {
          *(_DWORD *)(result + 760) = 8;
        }
        else if (v12 == 81 || v11 < 0x640)
        {
          *(_DWORD *)(result + 760) = 9;
        }
        else
        {
          *(_DWORD *)(result + 760) = 10;
        }
      }
      else
      {
        *(_DWORD *)(result + 760) = 2;
      }
    }
    else
    {
      *(_DWORD *)(result + 760) = 1;
    }
  }
  else
  {
    *(_DWORD *)(result + 760) = v12;
  }
  return result;
}

void nw_proto_tcp_ecn_update_cache(uint64_t a1, _BYTE *a2)
{
  uint64_t v2;
  void *v3;
  NSObject *v4;
  const char *v5;
  uint8_t buf[4];
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      v2 = *(_QWORD *)(a1 + 40);
      if (v2)
      {
        *(_DWORD *)(v2 + 5308) = *(_DWORD *)(v2 + 5308) & 0xFFFDFFFF | ((*a2 & 1) << 17);
        if (*(_QWORD *)(v2 + 5208))
        {
          if (*(_QWORD *)(v2 + 5216))
            nw_path_flow_registration_set_ecn_cache();
        }
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v7 = "nw_proto_tcp_ecn_update_cache";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v7 = "nw_proto_tcp_ecn_update_cache";
        v5 = "%{public}s called with null ecn_cache_buffer, backtrace limit exceeded";
        goto LABEL_15;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v7 = "nw_proto_tcp_ecn_update_cache";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v7 = "nw_proto_tcp_ecn_update_cache";
        v5 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_15:
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_ERROR, v5, buf, 0xCu);
      }
    }
  }
  if (v3)
    free(v3);
}

void tcp_set_new_cc(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  void (*v6)(_QWORD);
  uint64_t all_stats;
  uint64_t v8;
  void (*v9)(uint64_t);
  NSObject *v10;
  uint64_t v11;
  int v12;
  const char *v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(*(_QWORD *)a1 + 240);
  v3 = *(unsigned __int8 *)(v2 + 264);
  if ((_DWORD)v3 != a2)
  {
    v6 = *(void (**)(_QWORD))(tcp_cc_algo_list[v3] + 32);
    if (v6)
      v6(*(_QWORD *)(*(_QWORD *)a1 + 240));
    *(_BYTE *)(v2 + 264) = a2;
    if (*(_QWORD *)(a1 + 24))
    {
      all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats)
        *(_DWORD *)(all_stats + 132) = a2;
    }
    v8 = *(unsigned __int8 *)(v2 + 264);
    if ((v8 - 2) <= 2 && !*(_QWORD *)(v2 + 840))
    {
      *(_QWORD *)(v2 + 840) = v2 + 848;
      *(_OWORD *)(v2 + 848) = 0u;
      *(_OWORD *)(v2 + 864) = 0u;
      *(_OWORD *)(v2 + 880) = 0u;
      *(_OWORD *)(v2 + 896) = 0u;
      *(_OWORD *)(v2 + 912) = 0u;
    }
    v9 = *(void (**)(uint64_t))(tcp_cc_algo_list[v8] + 120);
    if (v9)
      v9(v2);
    if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
    {
      v10 = __nwlog_tcp_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v11 = tcp_cc_algo_list[*(unsigned __int8 *)(v2 + 264)];
        v12 = 136446722;
        v13 = "tcp_set_new_cc";
        v14 = 2082;
        v15 = a1 + 604;
        v16 = 2082;
        v17 = v11;
        _os_log_impl(&dword_209FB3000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s cc_algo %{public}s", (uint8_t *)&v12, 0x20u);
      }
    }
  }
}

uint64_t tcp_sbrcv_reserve(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v5;
  char v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  char v18;
  uint64_t v19;
  int v20;

  if (a3 >= a5)
    v5 = a5;
  else
    v5 = a3;
  v6 = *(_BYTE *)(result + 261);
  v7 = 0xFFFFLL << v6;
  v8 = 0xFFFF << v6;
  if (v7 <= v5)
    v9 = v8;
  else
    v9 = v5;
  if (v9 > *(_DWORD *)(a2 + 4) && v9 <= 0x71C71C)
  {
    v14 = result;
    *(_DWORD *)(a2 + 4) = v9;
    result = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
    if ((*(_BYTE *)(a2 + 48) & 4) != 0)
    {
      if (result)
      {
        result = nw_protocol_tcp_get_all_stats();
        if (result)
          *(_DWORD *)(result + 88) = *(_DWORD *)(a2 + 4);
      }
    }
    else if (result)
    {
      result = nw_protocol_tcp_get_all_stats();
      if (result)
        *(_DWORD *)(result + 100) = *(_DWORD *)(a2 + 4);
    }
    v15 = *(_DWORD *)(a2 + 4);
    if (*(_DWORD *)(a2 + 8) > v15)
      *(_DWORD *)(a2 + 8) = v15;
    LODWORD(v16) = *(_DWORD *)(a2 + 52);
    if (a4)
      v17 = a4;
    else
      v17 = v9;
    if (v16 <= v17)
      LODWORD(v16) = v17;
    if (v16 >= a5)
      v16 = a5;
    else
      v16 = v16;
    v18 = *(_BYTE *)(v14 + 261);
    v19 = 0xFFFFLL << v18;
    v20 = 0xFFFF << v18;
    if (v19 <= v16)
      LODWORD(v16) = v20;
    *(_DWORD *)(a2 + 52) = v16;
  }
  return result;
}

_DWORD *tcp_ledbat_ack_rcvd(_DWORD *result, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  unsigned int v8;

  v2 = *(_DWORD *)(a2 + 8) - result[23];
  if (*(_DWORD *)(sysctls + 300))
    return (_DWORD *)ledbat_pp_ack_rcvd((uint64_t)result, v2);
  v3 = result[36];
  v4 = result[49];
  v5 = result[72] + v2;
  result[72] = v5;
  if (v3 >= result[184])
  {
    if (v5 >= v3)
      v2 = v4;
    else
      v2 = 0;
    v7 = v5 >= v3;
    v8 = v5 - v3;
    if (!v7)
      goto LABEL_14;
  }
  else
  {
    v6 = v4 << (result[25] == result[24]);
    if (v2 >= v6)
      v2 = v6;
    v7 = v5 >= v3;
    v8 = v5 - v3;
    if (!v7)
      goto LABEL_14;
  }
  result[72] = v8;
LABEL_14:
  if (v2)
    return (_DWORD *)update_cwnd((uint64_t)result, v2, 1);
  return result;
}

uint64_t ledbat_pp_ack_rcvd(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  int v11;
  uint64_t result;
  _DWORD *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  BOOL v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  unsigned int v24;
  BOOL v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;
  BOOL v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  double v40;
  double v41;
  double v42;
  unsigned int v43;
  int v44;
  int v45;

  v4 = *(_QWORD *)(a1 + 80);
  v5 = *(_QWORD *)(v4 + 496);
  if (v5 && (v6 = *(_QWORD *)(v5 + 1488)) != 0)
    v7 = *(_DWORD *)(v6 + 40);
  else
    v7 = 0;
  v8 = 1908;
  if (!*(_DWORD *)(sysctls + 312))
    v8 = 236;
  v9 = *(_DWORD *)(a1 + v8);
  v10 = 3 * *(_DWORD *)(sysctls + 4);
  if (v10 >= 0)
    v11 = 3 * *(_DWORD *)(sysctls + 4);
  else
    v11 = v10 + 3;
  result = nw_tcp_access_globals(*(_QWORD *)(v4 + 224));
  v13 = *(_DWORD **)(a1 + 840);
  v14 = v13[1];
  if (!v14)
    goto LABEL_20;
  v15 = *(_DWORD *)(result + 316);
  if (v15 < v14)
  {
    v14 = 1;
    goto LABEL_20;
  }
  if (!v13[2])
  {
    v13[2] = v15;
    ++**(_DWORD **)(a1 + 840);
    v15 = *(_DWORD *)(result + 316);
    v13 = *(_DWORD **)(a1 + 840);
    v14 = v13[1];
  }
  if (v15 >= v14 + 2 * (*(int *)(a1 + 200) >> 5))
  {
LABEL_20:
    if (v9)
      v18 = v7 == 0;
    else
      v18 = 1;
    if (v18)
    {
      if (10 * *(_DWORD *)(a1 + 196) >= a2)
        v19 = a2;
      else
        v19 = 10 * *(_DWORD *)(a1 + 196);
      return update_cwnd(a1, v19, 1);
    }
    v20 = *(_DWORD *)(a1 + 144);
    v21 = *(_DWORD *)(a1 + 736);
    if (v20 < v21)
    {
      v22 = v11 >> 2;
      if (*v13)
      {
        v23 = *(_DWORD *)(sysctls + 4);
        v24 = v22 + v7;
        v25 = v9 > v23 + v7 && v9 > v24;
        if (!v25)
          goto LABEL_56;
      }
      else if (v9 <= v22 + v7)
      {
        v23 = *(_DWORD *)(sysctls + 4);
LABEL_56:
        v39 = *(_DWORD *)(a1 + 288) + a2;
        *(_DWORD *)(a1 + 288) = v39;
        v40 = (double)(2 * v23) / (double)v7;
        v41 = trunc(v40);
        v25 = v40 <= v41;
        v42 = 0.0;
        if (!v25)
          v42 = 1.0;
        v43 = (v42 + v41);
        if (v43 >= 0x10)
          v43 = 16;
        v44 = *(_DWORD *)(a1 + 196);
        if (v39 >= v44 * v43)
        {
          if (v39 / v43 >= 10 * v44)
            v45 = 10 * v44;
          else
            v45 = v39 / v43;
          *(_DWORD *)(a1 + 288) = 0;
          result = update_cwnd(a1, v45, 1);
          v13 = *(_DWORD **)(a1 + 840);
        }
        if (v13[1])
          v13[1] = 0;
        return result;
      }
    }
    v26 = *(_DWORD *)(result + 316);
    if (v14)
    {
LABEL_45:
      v28 = sysctls;
      if (*(_DWORD *)(sysctls + 4) + v7 < v9)
      {
        *(_DWORD *)(*(_QWORD *)(a1 + 840) + 12) += a2;
        v29 = *(_QWORD *)(a1 + 840);
        v30 = *(_DWORD *)(v29 + 12);
        v31 = *(_DWORD *)(a1 + 144);
        v32 = v30 >= v31;
        v33 = v30 - v31;
        if (v32)
        {
          v34 = v9 - v7;
          if (v9 < v7)
            v34 = 0;
          v35 = (fmin((double)v34 / (double)*(int *)(v28 + 4) + -1.0, 0.5) * (double)v31);
          *(_DWORD *)(v29 + 12) = v33;
          result = update_cwnd(a1, v35, 0);
          v36 = *(_QWORD *)(a1 + 840);
          if (*(_DWORD *)(v36 + 4))
            *(_DWORD *)(v36 + 4) = v26 + 30000;
        }
        return result;
      }
      v37 = *(_DWORD *)(a1 + 288) + a2;
      *(_DWORD *)(a1 + 288) = v37;
      v32 = v37 >= v20;
      v38 = v37 - v20;
      if (!v32)
        return result;
      v19 = *(_DWORD *)(a1 + 196);
      *(_DWORD *)(a1 + 288) = v38;
      return update_cwnd(a1, v19, 1);
    }
    if (*v13)
    {
      v27 = (v26 - v13[2]) << (v20 < v21);
      v13[1] = 9 * v27 + v26;
      if (v27)
        goto LABEL_43;
    }
    else
    {
      v13[1] = v26;
    }
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 4) += 2 * (*(int *)(a1 + 200) >> 5);
LABEL_43:
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 8) = 0;
    v20 = *(_DWORD *)(a1 + 144);
    if (*(_DWORD *)(a1 + 736) > v20)
      *(_DWORD *)(a1 + 736) = v20;
    goto LABEL_45;
  }
  v16 = *(_DWORD *)(a1 + 144);
  v17 = *(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 16);
  if (v16 > v17)
  {
    if (*(_DWORD *)(a1 + 736) < v16)
      *(_DWORD *)(a1 + 736) = v16;
    *(_DWORD *)(a1 + 144) = v17;
    *(_DWORD *)(a1 + 288) = 0;
  }
  return result;
}

void tcp_respond(uint64_t a1, __int128 *a2, uint64_t a3, unsigned int a4, unsigned int a5, char a6, uint64_t a7)
{
  char v8;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  const char *v25;
  __int128 v26;
  int v27;
  unsigned int v28;
  int v29;
  NSObject *v30;
  _BOOL4 v31;
  _QWORD *v32;
  unsigned int *v33;
  size_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  BOOL v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  NSObject *v43;
  uint64_t v44;
  const char *v45;
  void *backtrace_string;
  _BOOL4 v47;
  uint64_t v48;
  uint64_t v49;
  NSObject *v50;
  os_log_type_t v51;
  NSObject *v52;
  unsigned int v53;
  unint64_t v54;
  uint64_t v55;
  __int16 v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  NSObject *v63;
  char *v64;
  uint64_t v65;
  int v66;
  int v67;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int16 *v73;
  NSObject *v74;
  unsigned int v75;
  unsigned int v76;
  int v77;
  unsigned int v78;
  unsigned int v79;
  int v80;
  const char *v81;
  os_log_type_t v82;
  os_log_type_t log;
  NSObject *loga;
  void *v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int *v88;
  uint64_t v89;
  unsigned int v90;
  int v91;
  int v92;
  char v93;
  int v94;
  int v96;
  int v97;
  _QWORD v98[2];
  char v99;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v102;
  __int16 v103;
  _BYTE v104[10];
  _BYTE v105[10];
  uint64_t v106;
  _BYTE v107[10];
  __int16 v108;
  unsigned int v109;
  __int16 v110;
  int v111;
  __int16 v112;
  int v113;
  __int16 v114;
  int v115;
  __int16 v116;
  const char *v117;
  uint64_t v118;

  v8 = a6;
  v118 = *MEMORY[0x24BDAC8D0];
  v13 = *(_QWORD *)(a1 + 80);
  v14 = *(_QWORD *)(v13 + 224);
  v15 = *(_QWORD *)(v14 + 24);
  v16 = *(_QWORD *)(v15 + 32);
  v93 = *(_BYTE *)(v13 + 2236);
  if ((a6 & 4) != 0)
  {
    v18 = 0;
  }
  else
  {
    v17 = tcp_sbspace(a1);
    if (v17 >= 0xFFFF << *(_BYTE *)(a1 + 261))
      v18 = 0xFFFF << *(_BYTE *)(a1 + 261);
    else
      v18 = v17;
    v15 = *(_QWORD *)(v14 + 24);
  }
  v98[0] = 0;
  v98[1] = v98;
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)(v16 + 24)
                                                                                             + 88))(v16, v15, 20, 20, 1, v98))
  {
    v91 = v18;
    v19 = v98[0];
    if (v98[0])
    {
      v89 = a7;
      v20 = *(_QWORD *)(v98[0] + 112);
      v21 = (_QWORD *)MEMORY[0x24BDE08C0];
      if (v20)
      {
        v86 = a5;
        v87 = a4;
        if ((*(_WORD *)(v98[0] + 204) & 0x100) == 0 || !*MEMORY[0x24BDE08C0])
        {
          v88 = (unsigned int *)(v98[0] + 56);
          v23 = v20 + *(unsigned int *)(v98[0] + 56);
LABEL_24:
          v26 = *a2;
          *(_DWORD *)(v23 + 16) = *((_DWORD *)a2 + 4);
          *(_OWORD *)v23 = v26;
          if ((*(_WORD *)(v19 + 204) & 0x80) != 0)
            *(_WORD *)(v19 + 196) -= 20;
          v27 = *(_DWORD *)(v19 + 52);
          v28 = *(_DWORD *)(v19 + 56) + 20;
          v29 = *(_DWORD *)(v19 + 60);
          if (v28 <= v27 - v29)
          {
            *v88 = v28;
            v33 = v88;
            v32 = (_QWORD *)MEMORY[0x24BDE08C0];
            if (!v27)
              goto LABEL_56;
          }
          else
          {
            v30 = __nwlog_obj();
            v31 = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
            v27 = *(_DWORD *)(v19 + 52);
            if (v31)
            {
              *(_DWORD *)buf = 136446978;
              v102 = "__nw_frame_claim_internal";
              v103 = 1024;
              *(_DWORD *)v104 = v28;
              *(_WORD *)&v104[4] = 1024;
              *(_DWORD *)&v104[6] = v27;
              *(_WORD *)v105 = 1024;
              *(_DWORD *)&v105[2] = v29;
              _os_log_impl(&dword_209FB3000, v30, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
              v27 = *(_DWORD *)(v19 + 52);
            }
            v32 = (_QWORD *)MEMORY[0x24BDE08C0];
            v33 = v88;
            if (!v27)
            {
LABEL_56:
              if ((*(_WORD *)(v19 + 204) & 0x80) != 0)
                *(_WORD *)(v19 + 196) += 20;
              if (*v33 > 0x13)
              {
                *v33 -= 20;
              }
              else
              {
                v52 = __nwlog_obj();
                if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
                {
                  v53 = *v33;
                  *(_DWORD *)buf = 136446722;
                  v102 = "__nw_frame_unclaim_internal";
                  v103 = 1024;
                  *(_DWORD *)v104 = 20;
                  *(_WORD *)&v104[4] = 1024;
                  *(_DWORD *)&v104[6] = v53;
                  _os_log_impl(&dword_209FB3000, v52, OS_LOG_TYPE_ERROR, "%{public}s Frame cannot unclaim %u start bytes (has %u left)", buf, 0x18u);
                }
              }
              if (a3)
              {
                HIDWORD(v54) = *(_DWORD *)v23;
                LODWORD(v54) = *(_DWORD *)v23;
                *(_DWORD *)v23 = v54 >> 16;
                v55 = v89;
                if (!v89)
                  goto LABEL_68;
              }
              else
              {
                v8 = 16;
                v55 = v89;
                if (!v89)
                  goto LABEL_68;
              }
              if ((*(_BYTE *)(v55 + 4) & 0x10) != 0)
                *(_WORD *)(v19 + 204) |= 0x8000u;
LABEL_68:
              *(_DWORD *)(v23 + 4) = bswap32(v86);
              *(_DWORD *)(v23 + 8) = bswap32(v87);
              *(_BYTE *)(v23 + 12) = 80;
              *(_BYTE *)(v23 + 13) = v8;
              *(_WORD *)(v23 + 14) = bswap32(v91 >> *(_BYTE *)(a1 + 261)) >> 16;
              *(_WORD *)(v23 + 18) = 0;
              if ((v93 & 2) != 0)
                v56 = in6_pseudo();
              else
                v56 = in_pseudo();
              *(_WORD *)(v23 + 16) = v56;
              v57 = in_finalize_cksum();
              if (v57
                && (*(_WORD *)(v19 + 204) & 0x100) != 0
                && *v32
                && (((uint64_t (*)(uint64_t, _QWORD))*v32)(v19, *(_QWORD *)(v19 + 88)) & 1) == 0)
              {
                *(_QWORD *)(a1 + 1056) = 0;
                v57 = 6;
                if ((*(_BYTE *)(v14 + 828) & 2) == 0)
                {
LABEL_84:
                  v63 = __nwlog_tcp_log();
                  if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
                  {
                    v64 = strerror(v57);
                    *(_DWORD *)buf = 136446722;
                    v102 = "tcp_respond";
                    v103 = 2082;
                    *(_QWORD *)v104 = v14 + 604;
                    *(_WORD *)&v104[8] = 2080;
                    *(_QWORD *)v105 = v64;
                    _os_log_impl(&dword_209FB3000, v63, OS_LOG_TYPE_INFO, "%{public}s %{public}s failed to finalize checksum, %s", buf, 0x20u);
                  }
                }
LABEL_94:
                (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)(v16 + 24) + 96))(v16, v98);
                return;
              }
              v58 = *(_DWORD *)(v19 + 52);
              if (v58)
              {
                v59 = (v58 - (*(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60)));
                v60 = *(_QWORD *)(a1 + 1056);
                if (!v60)
                  goto LABEL_82;
              }
              else
              {
                v59 = 0;
                v60 = *(_QWORD *)(a1 + 1056);
                if (!v60)
                  goto LABEL_82;
              }
              v61 = 144;
              v62 = 136;
              if ((v93 & 2) == 0)
                v62 = 120;
              ++*(_QWORD *)(v60 + v62);
              if ((v93 & 2) == 0)
                v61 = 128;
              *(_QWORD *)(v60 + v61) += v59;
LABEL_82:
              if (v57)
              {
                if ((*(_BYTE *)(v14 + 828) & 2) == 0)
                  goto LABEL_84;
                goto LABEL_94;
              }
              v65 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
              v66 = *(_DWORD *)(v65 + 600);
              v97 = 0;
              set_frame_service_class(v19, v65, v66, (v93 & 2) >> 1, &v97);
              v67 = v97;
              *(_DWORD *)(v19 + 176) = v97;
              if (!__nwlog_is_datapath_logging_enabled())
              {
LABEL_89:
                if (*MEMORY[0x24BDE08B8] != -1)
                  dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_83);
                if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
                {
                  nw_frame_array_unclaimed_length();
                  kdebug_trace();
                }
                goto LABEL_94;
              }
              v69 = *(_DWORD *)(v19 + 52);
              if (v69)
                v70 = v69 - (*(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60));
              else
                v70 = 0;
              v71 = *(_QWORD *)(v19 + 112);
              if (v71)
              {
                if ((*(_WORD *)(v19 + 204) & 0x100) == 0 || !*MEMORY[0x24BDE08C0])
                {
                  v72 = *v88;
                  goto LABEL_115;
                }
                if (((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v19, *(_QWORD *)(v19 + 88)))
                {
                  v71 = *(_QWORD *)(v19 + 112);
                  if (v71)
                  {
                    v72 = *(unsigned int *)(v19 + 56);
LABEL_115:
                    v73 = (unsigned __int16 *)(v71 + v72);
                    if ((*(_BYTE *)(v14 + 828) & 2) == 0)
                    {
                      if (__nwlog_is_datapath_logging_enabled())
                      {
                        v74 = __nwlog_tcp_log();
                        if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
                        {
                          v75 = bswap32(*v73) >> 16;
                          v76 = bswap32(v73[1]) >> 16;
                          v77 = *((unsigned __int8 *)v73 + 13);
                          v78 = *((_DWORD *)v73 + 2);
                          v79 = bswap32(*((_DWORD *)v73 + 1));
                          v90 = bswap32(v78);
                          v92 = v77;
                          v94 = *(_DWORD *)(a1 + 120);
                          v96 = *(_DWORD *)(a1 + 92);
                          v80 = *(_DWORD *)(a1 + 12);
                          v81 = packet_service_class_to_str(v67);
                          *(_DWORD *)buf = 136449026;
                          v102 = "tcp_respond";
                          v103 = 2082;
                          *(_QWORD *)v104 = v14 + 604;
                          *(_WORD *)&v104[8] = 1024;
                          *(_DWORD *)v105 = v75;
                          *(_WORD *)&v105[4] = 1024;
                          *(_DWORD *)&v105[6] = v76;
                          LOWORD(v106) = 1024;
                          *(_DWORD *)((char *)&v106 + 2) = v70;
                          HIWORD(v106) = 1024;
                          *(_DWORD *)v107 = v92;
                          *(_WORD *)&v107[4] = 1024;
                          *(_DWORD *)&v107[6] = v79;
                          v108 = 1024;
                          v109 = v90;
                          v110 = 1024;
                          v111 = v94;
                          v112 = 1024;
                          v113 = v96;
                          v114 = 1024;
                          v115 = v80;
                          v116 = 2082;
                          v117 = v81;
                          _os_log_impl(&dword_209FB3000, v74, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s sending frame, %u:%u tlen %u, flags %#x, seq %u, ack %u, rcv_nxt %u snd_una %u state %u svc %{public}s", buf, 0x56u);
                        }
                      }
                    }
                    goto LABEL_89;
                  }
                }
              }
              if ((*(_WORD *)(v19 + 204) & 0x100) != 0
                && *MEMORY[0x24BDE08C0]
                && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v19, *(_QWORD *)(v19 + 88)) & 1) == 0)
              {
                *(_QWORD *)(a1 + 1056) = 0;
              }
              goto LABEL_89;
            }
          }
          v35 = *(unsigned int *)(v19 + 56);
          v34 = *(unsigned int *)(v19 + 60);
          v36 = (v27 - (v34 + v35));
          if (v27 == (_DWORD)v34 + (_DWORD)v35)
            goto LABEL_56;
          if ((_DWORD)v34)
          {
            v37 = *(_QWORD *)(v19 + 112);
            if (v37)
            {
              memmove((void *)(v37 + v35), (const void *)(v37 + v35 + v36), v34);
              v27 = *(_DWORD *)(v19 + 52);
            }
          }
          *(_DWORD *)(v19 + 52) = v27 - v36;
          if ((*(_WORD *)(v19 + 204) & 0x80) == 0)
            goto LABEL_56;
          v38 = *(unsigned __int16 *)(v19 + 196);
          v39 = v38 >= v36;
          v40 = v38 - v36;
          *(_WORD *)(v19 + 196) = v40;
          if (v39 && v40 < 0x10000)
            goto LABEL_56;
          __nwlog_obj();
          v41 = *(unsigned __int16 *)(v19 + 196);
          *(_DWORD *)buf = 136446978;
          v102 = "__nw_frame_collapse";
          v103 = 2082;
          *(_QWORD *)v104 = "frame->aggregate_buffer_length";
          *(_WORD *)&v104[8] = 2048;
          *(_QWORD *)v105 = v36;
          *(_WORD *)&v105[8] = 2048;
          v106 = v41;
          v42 = _os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v99 = 0;
          v85 = (void *)v42;
          if (__nwlog_fault())
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v43 = __nwlog_obj();
              log = type;
              if (os_log_type_enabled(v43, type))
              {
                v44 = *(unsigned __int16 *)(v19 + 196);
                *(_DWORD *)buf = 136446978;
                v102 = "__nw_frame_collapse";
                v103 = 2082;
                *(_QWORD *)v104 = "frame->aggregate_buffer_length";
                *(_WORD *)&v104[8] = 2048;
                *(_QWORD *)v105 = v36;
                *(_WORD *)&v105[8] = 2048;
                v106 = v44;
                v45 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_51:
                v50 = v43;
                v51 = log;
LABEL_52:
                _os_log_impl(&dword_209FB3000, v50, v51, v45, buf, 0x2Au);
              }
            }
            else if (v99)
            {
              backtrace_string = (void *)__nw_create_backtrace_string();
              loga = __nwlog_obj();
              v82 = type;
              v47 = os_log_type_enabled(loga, type);
              if (backtrace_string)
              {
                if (v47)
                {
                  v48 = *(unsigned __int16 *)(v19 + 196);
                  *(_DWORD *)buf = 136447234;
                  v102 = "__nw_frame_collapse";
                  v103 = 2082;
                  *(_QWORD *)v104 = "frame->aggregate_buffer_length";
                  *(_WORD *)&v104[8] = 2048;
                  *(_QWORD *)v105 = v36;
                  *(_WORD *)&v105[8] = 2048;
                  v106 = v48;
                  *(_WORD *)v107 = 2082;
                  *(_QWORD *)&v107[2] = backtrace_string;
                  _os_log_impl(&dword_209FB3000, loga, v82, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(backtrace_string);
                goto LABEL_53;
              }
              if (v47)
              {
                v68 = *(unsigned __int16 *)(v19 + 196);
                *(_DWORD *)buf = 136446978;
                v102 = "__nw_frame_collapse";
                v103 = 2082;
                *(_QWORD *)v104 = "frame->aggregate_buffer_length";
                *(_WORD *)&v104[8] = 2048;
                *(_QWORD *)v105 = v36;
                *(_WORD *)&v105[8] = 2048;
                v106 = v68;
                v45 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                v50 = loga;
                v51 = v82;
                goto LABEL_52;
              }
            }
            else
            {
              v43 = __nwlog_obj();
              log = type;
              if (os_log_type_enabled(v43, type))
              {
                v49 = *(unsigned __int16 *)(v19 + 196);
                *(_DWORD *)buf = 136446978;
                v102 = "__nw_frame_collapse";
                v103 = 2082;
                *(_QWORD *)v104 = "frame->aggregate_buffer_length";
                *(_WORD *)&v104[8] = 2048;
                *(_QWORD *)v105 = v36;
                *(_WORD *)&v105[8] = 2048;
                v106 = v49;
                v45 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                goto LABEL_51;
              }
            }
          }
LABEL_53:
          if (v85)
            free(v85);
          *(_WORD *)(v19 + 196) = 0;
          v33 = v88;
          goto LABEL_56;
        }
        if (((unsigned int (*)(_QWORD, _QWORD))*MEMORY[0x24BDE08C0])(v98[0], *(_QWORD *)(v98[0] + 88)))
        {
          v88 = (unsigned int *)(v19 + 56);
          v22 = *(_QWORD *)(v19 + 112);
          if (v22)
          {
            v23 = v22 + *(unsigned int *)(v19 + 56);
            goto LABEL_24;
          }
        }
      }
      if ((*(_WORD *)(v19 + 204) & 0x100) != 0
        && *v21
        && (((uint64_t (*)(uint64_t, _QWORD))*v21)(v19, *(_QWORD *)(v19 + 88)) & 1) == 0)
      {
        *(_QWORD *)(a1 + 1056) = 0;
      }
    }
    if ((*(_BYTE *)(v14 + 828) & 2) == 0)
    {
      v24 = __nwlog_tcp_log();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        v102 = "tcp_respond";
        v103 = 2082;
        *(_QWORD *)v104 = v14 + 604;
        v25 = "%{public}s %{public}s output frame is no longer valid";
LABEL_22:
        _os_log_impl(&dword_209FB3000, v24, OS_LOG_TYPE_INFO, v25, buf, 0x16u);
      }
    }
  }
  else if ((*(_BYTE *)(v14 + 828) & 2) == 0)
  {
    v24 = __nwlog_tcp_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v102 = "tcp_respond";
      v103 = 2082;
      *(_QWORD *)v104 = v14 + 604;
      v25 = "%{public}s %{public}s failed to get output frames";
      goto LABEL_22;
    }
  }
}

uint64_t tcp_ledbat_delay_ack(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(sysctls + 288) == 1)
    return tcp_cc_delay_ack(a1, a2);
  return (*(_BYTE *)(a1 + 90) & 4) == 0 && (*(_BYTE *)(a2 + 13) & 8) == 0 && *(_WORD *)(a1 + 304) == 1;
}

uint64_t update_cwnd(uint64_t result, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  _DWORD *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  char v13;
  uint64_t v14;
  unsigned int v15;
  NSObject *v16;
  void *v17;
  uint64_t v18;
  int v19;

  v3 = *(_QWORD *)(*(_QWORD *)(result + 80) + 496);
  if (v3 && (v4 = *(_QWORD *)(v3 + 1488)) != 0)
    v5 = *(_DWORD *)(v4 + 40);
  else
    v5 = 0;
  v6 = (_DWORD *)sysctls;
  v7 = 1908;
  if (!*(_DWORD *)(sysctls + 312))
    v7 = 236;
  if (v5 && (v8 = *(_DWORD *)(result + v7)) != 0)
  {
    if (v8 <= *(_DWORD *)(sysctls + 4) + v5)
    {
      v11 = *(_DWORD *)(result + 144);
      if (*(_DWORD *)(result + 736) < v11)
        *(_DWORD *)(result + 736) = v11;
      v10 = (v11 + a2 + (*(_DWORD *)(result + 196) >> 1)) / *(_DWORD *)(result + 196) * *(_DWORD *)(result + 196);
    }
    else
    {
      if (*(_DWORD *)(sysctls + 300))
      {
        if (a3)
        {
          v19 = a2;
          v18 = result;
          v16 = __nwlog_obj();
          os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
          v17 = (void *)_os_log_send_and_compose_impl();
          result = __nwlog_abort();
          if ((_DWORD)result)
          {
            __break(1u);
            return result;
          }
          free(v17);
          v6 = (_DWORD *)sysctls;
          result = v18;
          a2 = v19;
        }
        v9 = *(_DWORD *)(result + 144) - a2;
      }
      else
      {
        v9 = *(_DWORD *)(result + 144) - (*(_DWORD *)(result + 144) >> 3);
      }
      v12 = *(_DWORD *)(result + 196);
      if (v9 <= v12 * v6[4])
        v9 = v12 * v6[4];
      v10 = (v9 + (v12 >> 1)) / v12 * v12;
      if (*(_DWORD *)(result + 736) > v10)
        *(_DWORD *)(result + 736) = v10;
    }
  }
  else
  {
    v10 = *(_DWORD *)(result + 144) + a2;
  }
  if (v6[75])
  {
    v13 = *(_BYTE *)(result + 260);
    v14 = 0xFFFFLL << v13;
    v15 = 0xFFFF << v13;
    if (v14 > v10)
      v15 = v10;
  }
  else
  {
    v15 = ((*(_DWORD *)(result + 96) - *(_DWORD *)(result + 92)) << v6[3]) + *(_DWORD *)(result + 196) * v6[2];
    if (v10 < v15)
      v15 = v10;
  }
  *(_DWORD *)(result + 144) = v15;
  return result;
}

BOOL tcp_detect_bad_rexmt(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  int v5;
  BOOL v6;
  int v7;

  v5 = *(_DWORD *)(a1 + 740);
  if ((v5 & 0x10000000) == 0)
  {
    if ((v5 & 0x8000000) != 0 || (*(_DWORD *)(sysctls + 320) != 1 ? (v6 = tcp_do_acc_ecn == 1) : (v6 = 1), v6))
    {
      if ((~*(_DWORD *)(a1 + 348) & 0x300000) == 0 && *(_DWORD *)(a1 + 424))
        return 0;
    }
  }
  if ((~*(_DWORD *)(a1 + 348) & 3) == 0 && (*(_BYTE *)(a2 + 13) & 0x40) != 0)
    return 0;
  if ((~*(_DWORD *)(a1 + 88) & 0x180) == 0)
  {
    if (!a4)
      return 0;
    if ((*(_BYTE *)a3 & 1) == 0)
      return 0;
    v7 = *(_DWORD *)(a3 + 8);
    return v7 && v7 - a4 < 0;
  }
  if (*(_WORD *)(a1 + 226) == 1)
  {
    if (!a4)
      return 0;
  }
  else if (!a4 || (v5 & 0x1000) == 0)
  {
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 200);
  return *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316) - a4 < v4 >> 6;
}

uint64_t tcp_set_finwait_timeout(uint64_t a1)
{
  unsigned int v2;
  int v3;
  int v4;
  uint64_t result;
  int v6;
  int v7;
  int v8;

  v2 = *(_DWORD *)(sysctls + 316);
  if (!v2)
    goto LABEL_6;
  v3 = *(_DWORD *)(a1 + 688);
  if (v3)
  {
    v4 = *(_DWORD *)(a1 + 684);
    if (v4)
      goto LABEL_4;
  }
  else
  {
    v3 = *(_DWORD *)(sysctls + 200);
    v4 = *(_DWORD *)(a1 + 684);
    if (v4)
      goto LABEL_4;
  }
  v4 = *(_DWORD *)(sysctls + 196);
LABEL_4:
  if (v2 < v4 * v3)
  {
    result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
    v6 = *(_DWORD *)(sysctls + 316) + *(_DWORD *)(result + 316);
    goto LABEL_11;
  }
LABEL_6:
  result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  v7 = *(_DWORD *)(a1 + 688);
  if (!v7)
    v7 = *(_DWORD *)(sysctls + 200);
  v8 = *(_DWORD *)(a1 + 684);
  if (!v8)
    v8 = *(_DWORD *)(sysctls + 196);
  v6 = *(_DWORD *)(result + 316) + v8 * v7;
LABEL_11:
  *(_DWORD *)(a1 + 44) = v6 - *(_DWORD *)(a1 + 64);
  return result;
}

uint64_t tcp_sack_process_dsack(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  BOOL v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int *v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t i;

  v4 = *(unsigned int **)(a2 + 16);
  v5 = bswap32(*v4);
  v6 = *(unsigned __int8 *)(a2 + 15);
  if (v6 < 2)
  {
    v7 = 0;
    v8 = 0;
  }
  else
  {
    v7 = bswap32(v4[2]);
    v8 = bswap32(v4[3]);
  }
  v9 = bswap32(v4[1]);
  v10 = *(_DWORD *)(a3 + 8);
  if (((v5 - v10) & 0x80000000) != 0 && (int)(v9 - v10) <= 0)
  {
    v11 = *(_DWORD *)(a1 + 96);
    if ((int)(v5 - v11) > 0)
      goto LABEL_46;
    v12 = *(_DWORD *)(a1 + 140);
    if (v12 >= *(_DWORD *)(sysctls + 120))
      v12 = *(_DWORD *)(sysctls + 120);
    v13 = v12 - v10;
    if (((v13 + v5) & 0x80000000) != 0 || (int)(v9 - v11) > 0 || ((v13 + v9) & 0x80000000) != 0)
      goto LABEL_46;
    goto LABEL_25;
  }
  v14 = 0;
  v15 = v6 >= 2 && (int)(v7 - v5) <= 0;
  if (v15 && ((v8 - v9) & 0x80000000) == 0)
  {
    if ((int)(v8 - v7) < 1
      || (int)(v7 - v10) < 1
      || (v16 = *(_DWORD *)(a1 + 92), (int)(v7 - v16) < 1)
      || (v17 = *(_DWORD *)(a1 + 96), ((v7 - v17) & 0x80000000) == 0)
      || (int)(v8 - v16) < 1
      || (int)(v8 - v17) >= 1)
    {
LABEL_46:
      *(_BYTE *)(a2 + 15) = v6 - 1;
      *(_QWORD *)(a2 + 16) = v4 + 2;
      v24 = *(_QWORD *)(a1 + 1056);
      if (v24)
        ++*(_QWORD *)(v24 + 1048);
      return 1;
    }
LABEL_25:
    *(_BYTE *)(a2 + 15) = v6 - 1;
    *(_QWORD *)(a2 + 16) = v4 + 2;
    v18 = *(_QWORD *)(a1 + 1056);
    if (v18)
      ++*(_QWORD *)(v18 + 1016);
    ++*(_DWORD *)(a1 + 1024);
    v19 = *(_DWORD *)(a1 + 932);
    if (v19 && v19 == v9)
    {
      *a4 = 1;
      *(_DWORD *)(a1 + 932) = 0;
    }
    v20 = *(_DWORD *)(a1 + 740);
    if ((v20 & 0x20400020) == 0x20000020 && !*a4)
    {
      for (i = *(_QWORD *)(a1 + 1984); i; i = *(_QWORD *)(i + 16))
      {
        if ((*(_BYTE *)(i + 12) & 8) != 0 && (int)(v5 - *(_DWORD *)i) <= 0 && (int)(v9 - *(_DWORD *)(i + 4)) >= 0)
          ++*(_DWORD *)(a1 + 1016);
      }
    }
    if ((*(_WORD *)(a1 + 226) == 1 && v5 == *(_DWORD *)(a1 + 92) || (v20 & 0x1000) != 0 && v9 == *(_DWORD *)(a1 + 928))
      && !*(_QWORD *)(a1 + 544)
      && *(_DWORD *)(a3 + 8) - *(_DWORD *)(a1 + 92) >= 1)
    {
      if (v18)
        ++*(_QWORD *)(v18 + 1040);
    }
    else
    {
      v21 = *(int **)(a1 + 952);
      if (v21)
      {
        v22 = v9 - 1;
        do
        {
          v23 = *v21;
          if ((int)(*v21 - v5) >= 0 && (int)(v21[1] - v22) <= 0 && *((_WORD *)v21 + 4) == 1)
            *((_WORD *)v21 + 5) |= 1u;
          if ((int)(v23 - v22) >= 0)
            break;
          v21 = (int *)*((_QWORD *)v21 + 2);
        }
        while (v21);
      }
    }
    return 1;
  }
  return v14;
}

uint64_t tcp_early_rexmt_check(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;

  v1 = result;
  v2 = *(_QWORD *)(*(_QWORD *)(result + 80) + 224);
  v3 = *(_DWORD *)(result + 740);
  if ((v3 & 0x20) == 0 && *(unsigned __int16 *)(result + 268) > 9u)
    goto LABEL_33;
  v5 = *(_DWORD *)(result + 92);
  v4 = *(_DWORD *)(result + 96);
  result = (v4 - v5);
  if ((int)result < 1)
    goto LABEL_33;
  if (*(_DWORD *)(v1 + 8) == 1)
  {
    if ((v3 & 0x20400020) != 0x20000020 && ((v3 & 0x20) == 0 || !*(_QWORD *)(v1 + 544)))
      goto LABEL_12;
  }
  else if ((v3 & 0x20) == 0 || !*(_QWORD *)(v1 + 544))
  {
    goto LABEL_33;
  }
  result = tcp_flight_size((_DWORD *)v1);
  v5 = *(_DWORD *)(v1 + 92);
  v4 = *(_DWORD *)(v1 + 96);
LABEL_12:
  v6 = *(_DWORD *)(v1 + 140);
  if (*(_DWORD *)(v2 + 384) < v6)
    v6 = *(_DWORD *)(v2 + 384);
  v7 = *(_DWORD *)(v1 + 196);
  if (result < 4 * v7 && (int)(v5 - v4 + v6) <= 0)
  {
    v8 = result / v7;
    if (result / v7 * v7 < result)
      ++v8;
    if (v8 <= 3)
    {
      v9 = v8 - 1;
      if (v9 <= 1)
        LOBYTE(v9) = 1;
      if (v9 >= 3u)
        LOBYTE(v9) = 3;
      if (*(int *)(v1 + 8) >= (uint64_t)v9)
        LOBYTE(v9) = *(_DWORD *)(v1 + 8);
      *(_BYTE *)(v1 + 310) = v9;
      if (!*(_WORD *)(v1 + 268))
      {
        result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v1 + 80) + 224));
        *(_DWORD *)(v1 + 272) = *(_DWORD *)(result + 316);
      }
      v10 = *(_QWORD *)(v1 + 1056);
      if ((*(_BYTE *)(v1 + 741) & 0x10) != 0)
      {
        if (v10)
          ++*(_QWORD *)(v10 + 744);
      }
      else
      {
        if (v10)
          ++*(_QWORD *)(v10 + 696);
        ++*(_WORD *)(v1 + 268);
      }
    }
  }
LABEL_33:
  *(_DWORD *)(v1 + 740) &= ~0x1000u;
  *(_DWORD *)(v1 + 928) = 0;
  *(_DWORD *)(v1 + 936) = 0;
  return result;
}

void add_to_time_wait(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  void *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t *v18;
  uint64_t *v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned int *v25;
  unsigned int v26;
  NSObject *v27;
  const char *v28;
  int v29;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 72);
  v5 = *(uint64_t **)(a1 + 80);
  v6 = v5[28];
  if ((*(_BYTE *)(v6 + 374) & 1) != 0)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v31 = "socket_post_kev_msg_closed";
    v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "socket_post_kev_msg_closed";
        _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_ERROR, "%{public}s currently not supported, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v7)
      free(v7);
    v5 = *(uint64_t **)(a1 + 80);
    v6 = v5[28];
  }
  v9 = nw_tcp_access_globals(v6);
  v10 = v9;
  v11 = *((_DWORD *)v5 + 558);
  if ((v11 & 1) != 0)
  {
    v13 = *(_QWORD *)(a1 + 824);
    v14 = *(_QWORD **)(a1 + 832);
    if (v13)
    {
      *(_QWORD *)(v13 + 832) = v14;
      v14 = *(_QWORD **)(a1 + 832);
    }
    else
    {
      *(_QWORD *)(v9 + 136) = v14;
    }
  }
  else
  {
    ++*(_DWORD *)(*(_QWORD *)(v9 + 72) + 64);
    v12 = *(_QWORD *)(a1 + 1056);
    if (v12)
      ++*(_QWORD *)(v12 + 1696);
    *((_DWORD *)v5 + 558) = v11 | 1;
    v13 = *v5;
    if (*v5)
      *(_QWORD *)(v13 + 8) = v5[1];
    v14 = (_QWORD *)v5[1];
  }
  *v14 = v13;
  v15 = *(_DWORD *)(v9 + 316) + a2;
  if ((*(_BYTE *)(a1 + 91) & 0x40) != 0)
  {
    v16 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 8) + 32))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224), 0);
    v17 = *(_DWORD *)(a1 + 88);
    if ((v17 & 0x40000000) != 0)
    {
      v18 = *(uint64_t **)(v16 + 264);
      v19 = (uint64_t *)(a1 + 48);
      if (v18)
        v20 = v18 == v19;
      else
        v20 = 0;
      if (v20)
        *(_QWORD *)(v16 + 264) = *v18;
      v21 = *v19;
      if (*v19)
        *(_QWORD *)(v21 + 8) = *(_QWORD *)(a1 + 56);
      **(_QWORD **)(a1 + 56) = v21;
      *(_DWORD *)(a1 + 88) = v17 & 0xBFFFFFFF;
      --*(_DWORD *)(v16 + 280);
      *v19 = 0;
      *(_QWORD *)(a1 + 56) = 0;
    }
  }
  *(_DWORD *)(a1 + 44) = v15;
  v22 = v5[28];
  if (!v22 || (*(_BYTE *)(v22 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v27 = __nwlog_tcp_log();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        v28 = (const char *)(v22 + 604);
        v29 = *(_DWORD *)(v5[28] + 360);
        if (!v22)
          v28 = "";
        *(_DWORD *)buf = 136446978;
        v31 = "add_to_time_wait_locked";
        v32 = 2082;
        v33 = v28;
        v34 = 1024;
        v35 = v29;
        v36 = 1024;
        v37 = a2;
        _os_log_impl(&dword_209FB3000, v27, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s so_usecount %u added to TIME_WAIT delay %u", buf, 0x22u);
      }
    }
  }
  *(_QWORD *)(a1 + 824) = 0;
  v23 = *(_QWORD **)(v10 + 136);
  *(_QWORD *)(a1 + 832) = v23;
  *v23 = a1;
  *(_QWORD *)(v10 + 136) = a1 + 824;
  v24 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  *(_BYTE *)(v24 + 328) |= 2u;
  v25 = (unsigned int *)(v4 + 40);
  do
    v26 = __ldaxr(v25);
  while (__stlxr(v26 + 1, v25));
  if ((*(_BYTE *)(v24 + 328) & 1) == 0 && (*(_BYTE *)(v24 + 328) & 6) != 0)
  {
    *(_BYTE *)(v24 + 328) = *(_BYTE *)(v24 + 328) & 0xF6 | 1;
    nw_protocol_timer_run_inner(v24, 1000000000);
  }
}

uint64_t tcp_rledbat_data_rcvd(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  uint64_t result;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  BOOL v22;
  unsigned int v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  unsigned int v33;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  unsigned int v45;
  BOOL v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  double v57;
  double v58;
  double v59;
  unsigned int v60;
  double v61;
  double v62;
  double v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  char v67;
  uint64_t v68;
  int v69;

  v8 = *(_QWORD *)(a1 + 80);
  v9 = *(_QWORD *)(v8 + 496);
  if (v9 && (v10 = *(_QWORD *)(v9 + 1488)) != 0)
    v11 = *(_DWORD *)(v10 + 40);
  else
    v11 = 0;
  v12 = 1908;
  if (!*(_DWORD *)(sysctls + 312))
    v12 = 236;
  v13 = *(_DWORD *)(a1 + v12);
  v14 = *(_DWORD *)(a1 + 1968) >> 5;
  v15 = 3 * *(_DWORD *)(sysctls + 4);
  if (v15 >= 0)
    v16 = 3 * *(_DWORD *)(sysctls + 4);
  else
    v16 = v15 + 3;
  *(_DWORD *)(a1 + 1956) += a4;
  result = nw_tcp_access_globals(*(_QWORD *)(v8 + 224));
  v18 = *(_DWORD *)(a1 + 1928);
  if (v18)
  {
    v19 = *(_DWORD *)(result + 316);
    if (v19 >= v18)
    {
      if (!*(_DWORD *)(a1 + 1932))
      {
        *(_DWORD *)(a1 + 1932) = v19;
        ++*(_DWORD *)(a1 + 1924);
      }
      if (v19 < v18 + 2 * v14)
      {
        v20 = *(_DWORD *)(a1 + 1948);
        v21 = *(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 16);
        if (v20 > v21)
        {
          if (*(_DWORD *)(a1 + 1952) < v20)
            *(_DWORD *)(a1 + 1952) = v20;
          *(_DWORD *)(a1 + 1948) = v21;
          *(_DWORD *)(a1 + 1940) = 0;
        }
        return result;
      }
    }
  }
  if ((int)(*(_DWORD *)(a2 + 4) + a4 - *(_DWORD *)(a1 + 1916)) < 0 && *(_DWORD *)(a3 + 4) - *(_DWORD *)(a1 + 1920) >= 0)
  {
    v35 = *(_DWORD *)(result + 316);
    if (v35 >= *(_DWORD *)(a1 + 1936))
    {
      v36 = *(_DWORD *)(a1 + 196);
      v37 = ((v36 >> 1) + (*(_DWORD *)(a1 + 1948) >> 1)) / v36 * v36;
      v38 = 2 * v36;
      if (v37 <= v38)
        v37 = v38;
      *(_DWORD *)(a1 + 1952) = v37;
      *(_DWORD *)(a1 + 1948) = v37;
      *(_QWORD *)(a1 + 1940) = 0;
      *(_DWORD *)(a1 + 1936) = v35 + 2 * v14;
      if (v18)
      {
        v39 = v35 + 60000;
LABEL_66:
        *(_DWORD *)(a1 + 1928) = v39;
        return result;
      }
    }
    return result;
  }
  if (v13)
    v22 = v11 == 0;
  else
    v22 = 1;
  if (v22)
  {
    v23 = 10 * *(_DWORD *)(a1 + 196);
    if (v23 >= a4)
      v23 = a4;
    v24 = v23 + *(_DWORD *)(a1 + 1948);
LABEL_28:
    v25 = *(_BYTE *)(a1 + 261);
    v26 = 0xFFFFLL << v25;
    v27 = 0xFFFF << v25;
    if (v26 <= v24)
      LODWORD(v24) = v27;
    *(_DWORD *)(a1 + 1948) = v24;
    return result;
  }
  v28 = *(_DWORD *)(a1 + 1948);
  v29 = *(_DWORD *)(a1 + 1952);
  if (v28 < v29)
  {
    v30 = v16 >> 2;
    if (*(_DWORD *)(a1 + 1924))
    {
      v31 = *(_DWORD *)(sysctls + 4);
      v32 = 2 * v31;
      v33 = v30 + v11;
      if (v13 <= 2 * v31 + v11 || v13 <= v33)
        goto LABEL_72;
    }
    else if (v13 <= v30 + v11)
    {
      v31 = *(_DWORD *)(sysctls + 4);
      v32 = 2 * v31;
LABEL_72:
      v56 = *(_DWORD *)(a1 + 1940) + a4;
      *(_DWORD *)(a1 + 1940) = v56;
      v57 = (double)v32 / (double)v11;
      v58 = trunc(v57);
      if (v57 <= v58)
        v59 = 0.0;
      else
        v59 = 1.0;
      if ((v59 + v58) <= 0x10)
      {
        v61 = (double)(2 * v31) / (double)v11;
        v62 = trunc(v61);
        if (v61 <= v62)
          v63 = 0.0;
        else
          v63 = 1.0;
        v60 = (v63 + v62);
      }
      else
      {
        v60 = 16;
      }
      v64 = *(_DWORD *)(a1 + 196);
      if (v56 >= v64 * v60)
      {
        v65 = v56 / v60;
        if (v65 >= 10 * v64)
          v65 = 10 * v64;
        *(_DWORD *)(a1 + 1940) = 0;
        v66 = (v28 + v65 + (v64 >> 1)) / v64 * v64;
        v67 = *(_BYTE *)(a1 + 261);
        v68 = 0xFFFFLL << v67;
        v69 = 0xFFFF << v67;
        if (v68 <= v66)
          LODWORD(v66) = v69;
        *(_DWORD *)(a1 + 1948) = v66;
      }
      if (v18)
        *(_DWORD *)(a1 + 1928) = 0;
      return result;
    }
  }
  v40 = *(_DWORD *)(result + 316);
  if (!v18)
  {
    v41 = v28 >= v29 ? 60000 : 120000;
    v42 = *(_DWORD *)(a1 + 1924) ? v41 : 60000;
    v18 = v42 + v40;
    *(_QWORD *)(a1 + 1928) = v18;
    if (v28 < v29)
    {
      *(_DWORD *)(a1 + 1952) = v28;
      v29 = v28;
    }
  }
  v43 = sysctls;
  v44 = *(_DWORD *)(sysctls + 4);
  if (v44 + v11 >= v13)
  {
    v53 = *(_DWORD *)(a1 + 1940) + a4;
    *(_DWORD *)(a1 + 1940) = v53;
    v54 = v53 - v28;
    if (v53 < v28)
      return result;
    v55 = *(_DWORD *)(a1 + 196);
    *(_DWORD *)(a1 + 1940) = v54;
    if (v29 < v28)
      *(_DWORD *)(a1 + 1952) = v28;
    v24 = (v55 + v28 + (v55 >> 1)) / v55 * v55;
    goto LABEL_28;
  }
  if (*(_DWORD *)(a1 + 1936) <= v40)
  {
    v45 = *(_DWORD *)(a1 + 1944) + a4;
    *(_DWORD *)(a1 + 1944) = v45;
    v46 = v45 >= v28;
    v47 = v45 - v28;
    if (v46)
    {
      v48 = v13 - v11;
      if (v13 < v11)
        v48 = 0;
      *(_DWORD *)(a1 + 1944) = v47;
      v49 = v28 - (fmin((double)v48 / (double)v44 + -1.0, 0.5) * (double)v28);
      v50 = *(_DWORD *)(a1 + 196);
      v51 = v50 * *(_DWORD *)(v43 + 16);
      if (v49 <= v51)
        v49 = v51;
      v52 = (v49 + (v50 >> 1)) / v50 * v50;
      *(_DWORD *)(a1 + 1948) = v52;
      if (v29 > v52)
        *(_DWORD *)(a1 + 1952) = v52;
      if (v18)
      {
        v39 = v40 + 60000;
        goto LABEL_66;
      }
    }
  }
  return result;
}

uint64_t tcp_ledbat_switch_cc(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  **(_DWORD **)(result + 840) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 4) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 8) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 12) = 0;
  v1 = *(_DWORD *)(result + 736);
  v2 = *(_DWORD *)(result + 148);
  if (v1 - 1 >= v2)
  {
    *(_DWORD *)(result + 736) = v2;
    v1 = v2;
  }
  v3 = *(_DWORD *)(result + 140);
  v4 = *(_DWORD *)(result + 144);
  if (v3 >= v4)
    v3 = *(_DWORD *)(result + 144);
  if (v4 <= v1)
    v3 >>= 1;
  v5 = *(_DWORD *)(result + 196);
  v6 = v3 / v5;
  if (v6 <= *(_DWORD *)(sysctls + 16))
    v6 = *(_DWORD *)(sysctls + 16);
  *(_DWORD *)(result + 144) = v6 * v5;
  *(_DWORD *)(result + 288) = 0;
  do
    v7 = __ldaxr(dword_253CF86D0);
  while (__stlxr(v7 + 1, dword_253CF86D0));
  return result;
}

void tcp_cubic_congestion_avd(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int *v15;
  float v16;
  unsigned int *v17;
  unsigned int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  float v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  float v32;
  float v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int v36;
  _DWORD *v37;
  unsigned int v38;
  unsigned int v39;
  BOOL v40;
  unsigned int v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t v44;
  unsigned int v45;
  float v46;
  unsigned int v47;
  unsigned int v48;
  unint64_t v49;
  unint64_t v50;
  int v51;
  unint64_t v52;
  unint64_t v53;
  char v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  unsigned int v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  char v62;
  uint64_t v63;
  int v64;
  int v65;
  NSObject *v66;
  void *v67;

  v4 = *(_QWORD *)(a1 + 80);
  v5 = *(_QWORD *)(v4 + 224);
  v6 = *(_DWORD *)(a1 + 980);
  if (v6)
  {
    v7 = *(_DWORD *)(a1 + 144);
    if (v6 < v7 >> 1 && (!v5 || *(_DWORD *)(v5 + 384) <= v7))
    {
      *(_DWORD *)(a1 + 740) |= 0x100000u;
      return;
    }
  }
  *(_DWORD *)(a1 + 740) &= ~0x100000u;
  *(_DWORD *)(a1 + 288) += *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
  v8 = *(_QWORD *)(v4 + 496);
  if (v8 && (v9 = *(_QWORD *)(v8 + 1488)) != 0)
    v10 = *(_DWORD *)(v9 + 40);
  else
    v10 = 0;
  v11 = nw_tcp_access_globals(v5);
  v12 = v11;
  v13 = *(_DWORD *)(a1 + 144);
  if (v13 >= *(_DWORD *)(a1 + 140))
    v13 = *(_DWORD *)(a1 + 140);
  v14 = *(_QWORD *)(a1 + 840);
  if (!*(_DWORD *)v14)
  {
    *(_DWORD *)v14 = *(_DWORD *)(a1 + 148);
    v14 = *(_QWORD *)(a1 + 840);
  }
  if (!*(_DWORD *)(v14 + 4))
  {
    *(_DWORD *)(v14 + 4) = *(_DWORD *)(v11 + 316);
    v15 = *(unsigned int **)(a1 + 840);
    if (!v15[1])
    {
      v15[1] = 1;
      v15 = *(unsigned int **)(a1 + 840);
    }
    if (*v15 <= v13)
    {
      v15[7] = 0;
      v17 = *(unsigned int **)(a1 + 840);
    }
    else
    {
      if (*(_DWORD *)(sysctls + 276))
        v16 = (float)((float)((float)*v15 - (float)v13) * 2.5) / (float)*(unsigned int *)(a1 + 196);
      else
        v16 = (float)((*v15 - v13) / *(_DWORD *)(a1 + 196)) * 2.5;
      *((float *)v15 + 7) = cbrtf(v16) * 1000.0;
      v17 = *(unsigned int **)(a1 + 840);
      v13 = *v17;
    }
    v17[2] = v13;
    v14 = *(_QWORD *)(a1 + 840);
  }
  v18 = *(_DWORD *)(v14 + 8);
  if (!v18)
  {
    v66 = __nwlog_obj();
    os_log_type_enabled(v66, OS_LOG_TYPE_ERROR);
    v67 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v67);
    v14 = *(_QWORD *)(a1 + 840);
    v18 = *(_DWORD *)(v14 + 8);
  }
  v19 = *(_DWORD *)(v12 + 316);
  v20 = *(_DWORD *)(v14 + 4);
  v21 = sysctls;
  v22 = *(int *)(sysctls + 32);
  if (v22 <= v10)
    v23 = v10;
  else
    v23 = *(_DWORD *)(sysctls + 32);
  if ((_DWORD)v22)
    v24 = v23;
  else
    v24 = v10;
  v25 = *(float *)(v14 + 28);
  v26 = *(_DWORD *)(a1 + 196);
  if (*(_DWORD *)(v14 + 12))
  {
    *(_DWORD *)(v14 + 16) += *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
    v27 = *(_QWORD *)(a1 + 840);
    v30 = *(_DWORD *)(v27 + 16);
    v28 = (unsigned int *)(v27 + 16);
    v29 = v30;
    if (*(_DWORD *)(v21 + 276))
    {
      v31 = *(_DWORD *)(a1 + 144);
      if (v29 >= v31)
      {
        v32 = 3.0 - (float)(*(float *)&tcp_cubic_beta * 3.0);
        v33 = 1.0 / (float)(*(float *)&tcp_cubic_beta + 1.0);
        do
        {
          *v28 = v29 - v31;
          v37 = *(_DWORD **)(a1 + 840);
          if (*(_DWORD *)(a1 + 144) < *v37 && *(_DWORD *)(v21 + 280))
            v34 = (float)((float)(v32 * (float)*(unsigned int *)(a1 + 196)) * v33);
          else
            v34 = *(_DWORD *)(a1 + 196);
          v37[3] += v34;
          v35 = *(_QWORD *)(a1 + 840);
          v36 = *(_DWORD *)(v35 + 16);
          v28 = (unsigned int *)(v35 + 16);
          v29 = v36;
          v31 = *(_DWORD *)(a1 + 144);
        }
        while (v36 >= v31);
      }
    }
    else
    {
      v39 = *(_DWORD *)(*(_QWORD *)(a1 + 840) + 12);
      v40 = v29 >= v39;
      v41 = v29 - v39;
      if (v40)
      {
        *v28 = v41;
        *(_DWORD *)(*(_QWORD *)(a1 + 840) + 12) += *(_DWORD *)(a1 + 196);
      }
    }
  }
  else
  {
    v38 = *(_DWORD *)(a1 + 144);
    if (v38 >= *(_DWORD *)(a1 + 140))
      v38 = *(_DWORD *)(a1 + 140);
    *(_DWORD *)(v14 + 12) = v38;
    if (*(_DWORD *)(v21 + 276))
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 16) = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
    else
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 16) = 0;
  }
  v42 = *(_QWORD *)(a1 + 840);
  v43 = *(_DWORD *)(v42 + 12);
  v44 = *(unsigned int *)(a1 + 144);
  if (v44 < v43
    && !*(_DWORD *)(v21 + 276)
    && (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 600) - 801) <= 0xFFFFFED2
    && *(_DWORD *)(v42 + 24) > (2 * *(_DWORD *)(a1 + 196)))
  {
    v45 = *(_DWORD *)(a1 + 288);
    if (v45 < v44)
      return;
    *(_DWORD *)(a1 + 288) = v45 - v44;
LABEL_59:
    v54 = *(_BYTE *)(a1 + 260);
    v55 = 0xFFFFLL << v54;
    v56 = 0xFFFF << v54;
    if (v55 > v43)
      v56 = v43;
LABEL_72:
    *(_DWORD *)(a1 + 144) = v56;
    return;
  }
  v46 = (float)((float)(v24 + v19 - v20) - v25) * 0.001;
  v47 = (float)((float)v18 + (float)((float)((float)(v46 * v46) * (float)((float)v26 * 0.4)) * v46));
  if (v47 <= v44)
  {
    v51 = *(_DWORD *)(v21 + 276);
    v52 = 0xFFFFFFFFLL;
  }
  else
  {
    v48 = *(_DWORD *)(a1 + 196);
    v49 = v48 * (unint64_t)v44;
    v50 = v47 - v44;
    v51 = *(_DWORD *)(v21 + 276);
    v52 = v49 / v50;
    if (!v51 && v49 >= v50)
    {
      v53 = *(unsigned int *)(a1 + 288);
      if (v52 > v53)
        return;
      *(_DWORD *)(a1 + 288) = v53 - v52;
      v43 = v48 + v44;
      goto LABEL_59;
    }
  }
  if (v51)
  {
    v57 = *(unsigned int *)(a1 + 196);
    v58 = (v43 + (v57 >> 1)) / v57 * v57;
    if (v58 > v44)
    {
      v59 = v57 * (unint64_t)v44 / (v58 - v44);
      if (v59 < v52)
        v52 = v59;
    }
    if (v52)
    {
      v60 = *(unsigned int *)(a1 + 288);
      if (v52 <= v60)
      {
        *(_DWORD *)(a1 + 288) = v60 - v52;
        v61 = v57 + v44;
        v62 = *(_BYTE *)(a1 + 260);
        v63 = 0xFFFFLL << v62;
        v64 = v57 + v44;
        v65 = 0xFFFF << v62;
        if (v61 >= v63)
          v56 = v65;
        else
          v56 = v64;
        goto LABEL_72;
      }
    }
  }
}

uint64_t tcp_rexmt_save_state(uint64_t result)
{
  int v1;
  unsigned int v2;
  int v3;
  uint64_t v4;
  unsigned int v5;

  v1 = *(_DWORD *)(result + 88);
  if ((~v1 & 0x180) != 0)
  {
    v4 = *(_QWORD *)(result + 144);
    *(_DWORD *)(result + 512) = *(_DWORD *)(result + 152);
    *(_QWORD *)(result + 504) = v4;
    if ((v1 & 0x200000) != 0)
      v5 = v1 | 0x400000;
    else
      v5 = v1 & 0xFFBFFFFF;
    *(_DWORD *)(result + 88) = v5;
  }
  else
  {
    v2 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    v3 = *(_DWORD *)(result + 152);
    if (v2 <= *(_DWORD *)(result + 148))
      v2 = *(_DWORD *)(result + 148);
    *(_DWORD *)(result + 508) = v2;
    *(_DWORD *)(result + 512) = v3;
  }
  *(_DWORD *)(result + 516) = (*(int *)(result + 200) >> 5) + 2;
  *(_DWORD *)(result + 524) = *(int *)(result + 208) >> 4;
  if ((*(_DWORD *)(result + 1872) & 0xFFFFFFFE) == 2)
  {
    *(_DWORD *)(result + 520) = (*(int *)(result + 204) >> 5) + 2;
    *(_DWORD *)(result + 528) = *(int *)(result + 212) >> 4;
  }
  *(_DWORD *)(result + 740) &= ~0x40u;
  return result;
}

uint64_t tcp_cubic_post_fr(uint64_t result, uint64_t a2)
{
  int *v2;
  int v3;
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;

  v2 = (int *)(a2 + 8);
  if (!a2)
    v2 = (int *)(result + 92);
  v3 = *v2;
  v4 = *(_DWORD *)(result + 96);
  v5 = *(_DWORD *)(sysctls + 276);
  if (v3 - v4 <= 0)
  {
    if (!v5 || *(_DWORD *)(sysctls + 292))
    {
      v6 = v4 - v3;
      if ((*(_BYTE *)(result + 740) & 0x20) == 0)
        goto LABEL_28;
      goto LABEL_12;
    }
    goto LABEL_5;
  }
  if (v5)
  {
LABEL_5:
    v6 = *(_DWORD *)(result + 148);
    v5 = 1;
    if ((*(_BYTE *)(result + 740) & 0x20) == 0)
      goto LABEL_28;
    goto LABEL_12;
  }
  v6 = 0;
  if ((*(_BYTE *)(result + 740) & 0x20) == 0)
    goto LABEL_28;
LABEL_12:
  v7 = *(_DWORD *)(result + 984);
  if (v7 && !v5)
  {
    v8 = *(_QWORD *)(result + 952);
    if (v8)
    {
      v9 = 0;
      do
      {
        v9 = v9 + *(_DWORD *)(v8 + 4) - *(_DWORD *)v8 + 1;
        v8 = *(_QWORD *)(v8 + 16);
      }
      while (v8);
    }
    else
    {
      v9 = 0;
    }
    if (*(_DWORD *)(result + 980) > v7)
      v7 = *(_DWORD *)(result + 980);
    if (v9 <= v7)
      v10 = v9;
    else
      v10 = 0;
    v11 = v7 - v10;
    if (v11 >= *(_DWORD *)(result + 196) << 6)
      v11 = *(_DWORD *)(result + 196) << 6;
    v12 = v11 >> 1;
    if (v12 > v6)
      v6 = v12;
  }
LABEL_28:
  v13 = *(_DWORD *)(result + 148);
  if (v6 < v13)
  {
    v14 = *(_DWORD *)(result + 196);
    if (v6 <= v14)
      v6 = *(_DWORD *)(result + 196);
    v13 = v6 + v14;
  }
  *(_DWORD *)(result + 144) = v13;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 12) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 16) = 0;
  return result;
}

void nw_protocol_tcp_wake_keepalive(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint8_t buf[4];
  const char *v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) <= 2u && (*(_BYTE *)(v2 + 5309) & 1) != 0)
  {
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }
  else if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    v3 = __nwlog_tcp_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v5 = "nw_protocol_tcp_wake_keepalive";
      v6 = 2082;
      v7 = a1 + 604;
      _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }
}

void __nw_protocol_tcp_timer_init_block_invoke(uint64_t a1)
{
  uint64_t v1;
  int v2;
  unsigned int v3;
  int v4;
  NSObject *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  uint64_t *v13;
  int v14;
  int v15;
  __int128 v16;
  char v17;
  char v18;
  char v19;
  char v20;
  char v21;
  uint64_t v22;
  _QWORD *v23;
  char v24;
  void (*v25)(uint64_t, uint64_t *);
  __int128 v26;
  void (*v27)(uint64_t, uint64_t *);
  __int128 v28;
  void (*v29)(uint64_t, uint64_t *);
  __int128 v30;
  void (*v31)(uint64_t, uint64_t *);
  __int128 v32;
  NSObject *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  __int16 v50;
  int v51;
  __int16 v52;
  unsigned int v53;
  __int16 v54;
  int v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(a1 + 40))
  {
    v12 = *(_BYTE *)(v1 + 328);
    *(_BYTE *)(v1 + 328) = v12 & 0xF9;
    if ((v12 & 6) != 0)
    {
      v13 = *(uint64_t **)(v1 + 112);
      if (v13)
      {
        if ((v12 & 2) != 0)
        {
          if ((v12 & 4) != 0)
          {
            v15 = 0;
            v14 = 0;
            v16 = 0uLL;
            v38 = 0u;
            do
            {
              v41 = v16;
              if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
              {
                *((_DWORD *)v13 + 12) = 0;
                v13[5] = 0;
                v29 = (void (*)(uint64_t, uint64_t *))v13[2];
                if (v29)
                {
                  v29(v1, v13);
                  *((_QWORD *)&v30 + 1) = *((_QWORD *)&v38 + 1);
                  *(int32x2_t *)&v30 = vadd_s32((int32x2_t)v13[5], *(int32x2_t *)&v38);
                  v38 = v30;
                  v16 = v41;
                  v14 += *((_DWORD *)v13 + 12);
                }
              }
              if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
              {
                *((_DWORD *)v13 + 15) = 0;
                *(uint64_t *)((char *)v13 + 52) = 0;
                v31 = (void (*)(uint64_t, uint64_t *))v13[3];
                if (v31)
                {
                  v31(v1, v13);
                  *((_QWORD *)&v32 + 1) = *((_QWORD *)&v41 + 1);
                  *(int32x2_t *)&v32 = vadd_s32(*(int32x2_t *)((char *)v13 + 52), *(int32x2_t *)&v41);
                  v16 = v32;
                  v15 += *((_DWORD *)v13 + 15);
                }
              }
              v13 = (uint64_t *)*v13;
            }
            while (v13);
          }
          else
          {
            v14 = 0;
            v16 = 0uLL;
            do
            {
              if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
              {
                *((_DWORD *)v13 + 12) = 0;
                v13[5] = 0;
                v25 = (void (*)(uint64_t, uint64_t *))v13[2];
                if (v25)
                {
                  v39 = v16;
                  v25(v1, v13);
                  *((_QWORD *)&v26 + 1) = *((_QWORD *)&v39 + 1);
                  *(int32x2_t *)&v26 = vadd_s32((int32x2_t)v13[5], *(int32x2_t *)&v39);
                  v16 = v26;
                  v14 += *((_DWORD *)v13 + 12);
                }
              }
              if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
              {
                *((_DWORD *)v13 + 15) = 0;
                *(uint64_t *)((char *)v13 + 52) = 0;
              }
              v13 = (uint64_t *)*v13;
            }
            while (v13);
            *(_QWORD *)&v38 = v16;
            v15 = 0;
            *(_QWORD *)&v16 = 0;
          }
LABEL_23:
          v17 = *(_BYTE *)(v1 + 328);
          if ((_QWORD)v38)
            v18 = 2;
          else
            v18 = 2 * (v14 != 0);
          v19 = v17 & 0xFD | v18;
          if ((*(_BYTE *)(v1 + 328) & 2) == 0)
            v17 = v19;
          if ((_QWORD)v16)
            v20 = 4;
          else
            v20 = 4 * (v15 != 0);
          v21 = v17 & 0xFB | v20;
          if ((v17 & 4) == 0)
            v17 = v21;
          *(_BYTE *)(v1 + 328) = v17 & 0xFE;
          if (v14 | v15)
          {
            if ((v17 & 6) == 0)
              return;
          }
          else
          {
            if (vadd_s32(*(int32x2_t *)&v16, *(int32x2_t *)&v38).u32[1] <= 5)
            {
              if ((v17 & 6) == 0)
                return;
              v24 = v17 & 0xF6 | 1;
LABEL_48:
              *(_BYTE *)(v1 + 328) = v24;
              nw_protocol_timer_run_inner(v1, 1000000000);
              return;
            }
            if ((v17 & 6) == 0)
              return;
          }
          v24 = v17 | 9;
          goto LABEL_48;
        }
        if ((v12 & 4) != 0)
        {
          v15 = 0;
          v16 = 0uLL;
          do
          {
            if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
            {
              *((_DWORD *)v13 + 12) = 0;
              v13[5] = 0;
            }
            if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
            {
              *((_DWORD *)v13 + 15) = 0;
              *(uint64_t *)((char *)v13 + 52) = 0;
              v27 = (void (*)(uint64_t, uint64_t *))v13[3];
              if (v27)
              {
                v40 = v16;
                v27(v1, v13);
                *((_QWORD *)&v28 + 1) = *((_QWORD *)&v40 + 1);
                *(int32x2_t *)&v28 = vadd_s32(*(int32x2_t *)((char *)v13 + 52), *(int32x2_t *)&v40);
                v16 = v28;
                v15 += *((_DWORD *)v13 + 15);
              }
            }
            v13 = (uint64_t *)*v13;
          }
          while (v13);
          v14 = 0;
          goto LABEL_22;
        }
        do
        {
          if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
          {
            *((_DWORD *)v13 + 12) = 0;
            v13[5] = 0;
          }
          if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
          {
            *((_DWORD *)v13 + 15) = 0;
            *(uint64_t *)((char *)v13 + 52) = 0;
          }
          v13 = (uint64_t *)*v13;
        }
        while (v13);
      }
    }
    v14 = 0;
    v15 = 0;
    *(_QWORD *)&v16 = 0;
LABEL_22:
    *(_QWORD *)&v38 = 0;
    goto LABEL_23;
  }
  calculate_tcp_clock(*(_QWORD *)(a1 + 32));
  *(_BYTE *)(v1 + 310) &= ~2u;
  v2 = *(_DWORD *)(v1 + 272);
  v3 = *(_DWORD *)(v1 + 316) - v2;
  if (*(_QWORD *)(v1 + 256))
  {
    v4 = v2 - *(_DWORD *)(v1 + 276);
    if ((int)v3 < 11)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v33 = __nwlog_obj();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          v34 = *(_DWORD *)(v1 + 292);
          v35 = *(_DWORD *)(v1 + 276);
          v36 = *(_DWORD *)(v1 + 272);
          v37 = *(_DWORD *)(v1 + 316);
          *(_DWORD *)buf = 136447746;
          v43 = "tcp_run_timerlist";
          v44 = 1024;
          v45 = v34;
          v46 = 1024;
          v47 = v35;
          v48 = 1024;
          v49 = v36;
          v50 = 1024;
          v51 = v37;
          v52 = 1024;
          v53 = v3;
          v54 = 1024;
          v55 = v4;
          v10 = v33;
          v11 = OS_LOG_TYPE_DEBUG;
          goto LABEL_7;
        }
      }
    }
    else if ((*(char *)(v1 + 328) & 0x80000000) == 0)
    {
      v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        v6 = *(_DWORD *)(v1 + 292);
        v7 = *(_DWORD *)(v1 + 276);
        v8 = *(_DWORD *)(v1 + 272);
        v9 = *(_DWORD *)(v1 + 316);
        *(_DWORD *)buf = 136447746;
        v43 = "tcp_run_timerlist";
        v44 = 1024;
        v45 = v6;
        v46 = 1024;
        v47 = v7;
        v48 = 1024;
        v49 = v8;
        v50 = 1024;
        v51 = v9;
        v52 = 1024;
        v53 = v3;
        v54 = 1024;
        v55 = v4;
        v10 = v5;
        v11 = OS_LOG_TYPE_INFO;
LABEL_7:
        _os_log_impl(&dword_209FB3000, v10, v11, "%{public}s mode %d schedtime %u runtime %u tcp_now %u drift %d / offset %d", buf, 0x30u);
      }
    }
  }
  tcp_process_timerlist(v1);
  v22 = *(_QWORD *)(v1 + 256);
  if (v22)
  {
    v23 = *(_QWORD **)(v22 + 1008);
    if (v23)
    {
      if ((int)v3 > 1)
      {
        if (v3 > 0xA)
        {
          if (v3 > 0x14)
          {
            if (v3 > 0x32)
            {
              if (v3 > 0x64)
              {
                if (v3 > 0xC8)
                {
                  if (v3 > 0x1F4)
                  {
                    if (v3 > 0x3E8)
                      ++v23[159];
                    else
                      ++v23[158];
                  }
                  else
                  {
                    ++v23[157];
                  }
                }
                else
                {
                  ++v23[156];
                }
              }
              else
              {
                ++v23[155];
              }
            }
            else
            {
              ++v23[154];
            }
          }
          else
          {
            ++v23[153];
          }
        }
        else
        {
          ++v23[152];
        }
      }
      else
      {
        ++v23[151];
      }
    }
  }
}

void tcp_disconnect(uint64_t a1)
{
  uint64_t v2;
  void (**v3)(uint64_t);
  void (*v4)(uint64_t);
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  const char *v8;
  int v9;
  int v10;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
  if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v8 = (const char *)(v2 + 604);
        v9 = *(_DWORD *)(v2 + 360);
        v10 = *(_DWORD *)(a1 + 12);
        if (!v2)
          v8 = "";
        v11 = 136446978;
        v12 = "tcp_disconnect";
        v13 = 2082;
        v14 = v8;
        v15 = 1024;
        v16 = v9;
        v17 = 1024;
        v18 = v10;
        _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s so_usecount %u t_state %u", (uint8_t *)&v11, 0x22u);
      }
    }
  }
  if (*(_DWORD *)(v2 + 488) || *(_WORD *)(a1 + 224) || (*(_BYTE *)(v2 + 368) & 8) != 0)
    goto LABEL_18;
  if (*(int *)(a1 + 12) <= 3)
  {
    tcp_close(a1);
    return;
  }
  if ((*(_BYTE *)(v2 + 372) & 0x80) != 0 && !*(_DWORD *)(v2 + 16))
  {
LABEL_18:
    tcp_drop(a1, 0);
  }
  else
  {
    *(_WORD *)(v2 + 376) = *(_WORD *)(v2 + 376) & 0xFFC3 | 0x38;
    v3 = *(void (***)(uint64_t))(v2 + 32);
    if (v3)
    {
      if (!*v3 || ((*v3)(v2), (v3 = *(void (***)(uint64_t))(v2 + 32)) != 0))
      {
        v4 = v3[3];
        if (v4)
          v4(v2);
      }
    }
    tcp_input_aggregate_end(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224), *(_QWORD *)(*(_QWORD *)(a1 + 80) + 240));
    sbflush(v2 + 488);
    v6 = tcp_usrclosed(a1, v5);
    if (v6)
      tcp_output(v6);
  }
}

void nw_protocol_tcp_input_flush(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(uint64_t);
  void *v7;
  NSObject *v8;
  const char *v9;
  uint8_t buf[4];
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = nw_protocol_downcast();
    if (v1)
    {
      v2 = v1;
      if ((*(_BYTE *)(v1 + 828) & 1) != 0)
      {
        v3 = *(_QWORD *)v1;
        v4 = nw_tcp_access_globals(v1);
        tcp_coalesce_timer_updates_end(v4);
        v5 = *(_QWORD *)(v2 + 32);
        if (v5)
        {
          v6 = *(void (**)(uint64_t))(v5 + 24);
          if (v6)
            v6(v2);
        }
        if (v3)
          tcp_input_aggregate_end(*(_QWORD *)(v3 + 224), *(_QWORD *)(v3 + 240));
        *(_BYTE *)(v2 + 828) &= ~1u;
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v11 = "nw_protocol_tcp_input_flush";
    v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_protocol_tcp_input_flush";
        v9 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v11 = "nw_protocol_tcp_input_flush";
    v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_protocol_tcp_input_flush";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_19:
        _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
      }
    }
  }
  if (v7)
    free(v7);
}

uint64_t tcp_input_aggregate_end(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  NSObject *v5;
  int v6;
  int v7;
  NSObject *v9;
  int v10;
  int v11;
  NSObject *v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v15 = 0;
  v16 = 0;
  if (__nwlog_is_datapath_logging_enabled())
  {
    v12 = __nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      v13 = *(_DWORD *)(a1 + 552);
      v14 = *(_DWORD *)(a1 + 488);
      *(_DWORD *)buf = 136446722;
      v18 = "tcp_input_aggregate_end";
      v19 = 1024;
      v20 = v13;
      v21 = 1024;
      v22 = v14;
      _os_log_impl(&dword_209FB3000, v12, OS_LOG_TYPE_DEBUG, "%{public}s start sb_agg_bytes %u sb_cc %u", buf, 0x18u);
    }
  }
  if (*(_DWORD *)(a1 + 552))
  {
    while (*(_QWORD *)(a1 + 520))
    {
      v15 = 0;
      v16 = &v15;
      if (!tcp_input_get_aggregate_frames(a1, *(_DWORD *)(a1 + 824), 0, 0, (uint64_t)&v15))
      {
        v9 = __nwlog_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          v10 = *(_DWORD *)(a1 + 548);
          v11 = *(_DWORD *)(a1 + 552);
          *(_DWORD *)buf = 136446722;
          v18 = "tcp_input_aggregate_end";
          v19 = 1024;
          v20 = v10;
          v21 = 1024;
          v22 = v11;
          _os_log_impl(&dword_209FB3000, v9, OS_LOG_TYPE_ERROR, "%{public}s tcp_input_get_aggregate_frame failed, drop %u segments of length %u", buf, 0x18u);
        }
        tcp_drop(a2, 53);
        return 0xFFFFFFFFLL;
      }
      if (v15)
      {
        **(_QWORD **)(a1 + 512) = v15;
        v4 = v16;
        *(_QWORD *)(v15 + 40) = *(_QWORD *)(a1 + 512);
        *(_QWORD *)(a1 + 512) = v4;
        v15 = 0;
        v16 = &v15;
      }
      if (__nwlog_is_datapath_logging_enabled())
      {
        v5 = __nwlog_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          v6 = *(_DWORD *)(a1 + 552);
          v7 = *(_DWORD *)(a1 + 488);
          *(_DWORD *)buf = 136446722;
          v18 = "tcp_input_aggregate_end";
          v19 = 1024;
          v20 = v6;
          v21 = 1024;
          v22 = v7;
          _os_log_impl(&dword_209FB3000, v5, OS_LOG_TYPE_DEBUG, "%{public}s added agg frame to sb_mb sb_agg_bytes %u sb_cc %u", buf, 0x18u);
        }
      }
      if (!*(_DWORD *)(a1 + 552))
        break;
    }
  }
  sb_agg_empty_verify((int *)(a1 + 488), (uint64_t)"tcp_input_aggregate_end");
  return 0;
}

void sb_agg_empty_verify(int *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  const char *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  void *v17;
  uint64_t i;
  int v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  int v23;
  const char *v24;
  int v25;
  int v26;
  void *v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  NSObject *v32;
  int v33;
  int v34;
  const char *v35;
  int v36;
  int v37;
  void *v38;
  uint64_t v39;
  NSObject *v40;
  const char *v41;
  uint64_t v42;
  _QWORD *v43;
  void (*v44)(uint64_t, uint64_t, uint64_t);
  uint64_t v45;
  void *v46;
  NSObject *v47;
  NSObject *v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint8_t buf[4];
  const char *v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  int v60;
  __int16 v61;
  int v62;
  __int16 v63;
  int v64;
  __int16 v65;
  int v66;
  __int16 v67;
  uint64_t v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  if (a1[15])
  {
    if (!a1[16])
    {
      for (i = *((_QWORD *)a1 + 4); i; i = *((_QWORD *)a1 + 4))
      {
        v19 = a1[15];
        if (!v19)
        {
          v20 = *((_QWORD *)a1 + 9);
          if (v20 && (*(_BYTE *)(v20 + 828) & 2) != 0)
          {
            v19 = 0;
          }
          else
          {
            v21 = __nwlog_tcp_log();
            os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
            v22 = a1[12];
            v23 = *a1;
            v24 = (const char *)(v20 + 604);
            if (!v20)
              v24 = "";
            v25 = a1[15];
            v26 = a1[16];
            *(_DWORD *)buf = 136447746;
            v54 = "sb_agg_empty_verify";
            v55 = 2082;
            v56 = v24;
            v57 = 2082;
            v58 = a2;
            v59 = 1024;
            v60 = v22;
            v61 = 1024;
            v62 = v23;
            v63 = 1024;
            v64 = v25;
            v65 = 1024;
            v66 = v26;
            v27 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_abort())
              goto LABEL_54;
            free(v27);
            v19 = a1[15];
          }
        }
        a1[15] = v19 - 1;
        v28 = *(_DWORD *)(i + 52);
        if (v28)
        {
          v29 = *(_DWORD *)(i + 60) + *(_DWORD *)(i + 56);
          v30 = v28 - v29;
          if (v28 != v29)
          {
            v31 = *((_QWORD *)a1 + 9);
            if (!v31 || (*(_BYTE *)(v31 + 828) & 2) == 0)
            {
              v32 = __nwlog_tcp_log();
              os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
              v33 = a1[12];
              v34 = *a1;
              v35 = (const char *)(v31 + 604);
              if (!v31)
                v35 = "";
              v36 = a1[15];
              v37 = a1[16];
              *(_DWORD *)buf = 136448002;
              v54 = "sb_agg_empty_verify";
              v55 = 2082;
              v56 = v35;
              v57 = 2082;
              v58 = a2;
              v59 = 1024;
              v60 = v30;
              v61 = 1024;
              v62 = v33;
              v63 = 1024;
              v64 = v34;
              v65 = 1024;
              v66 = v36;
              v67 = 1024;
              LODWORD(v68) = v37;
              v38 = (void *)_os_log_send_and_compose_impl();
              if (__nwlog_abort())
                goto LABEL_54;
              free(v38);
            }
          }
        }
        if (nw_frame_is_wake_packet())
        {
          v39 = *((_QWORD *)a1 + 9);
          if (!v39 || (*(_BYTE *)(v39 + 828) & 2) == 0)
          {
            v40 = __nwlog_tcp_log();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
            {
              v41 = (const char *)(v39 + 604);
              *(_DWORD *)buf = 136446466;
              if (!v39)
                v41 = "";
              v54 = "sb_agg_empty_verify";
              v55 = 2082;
              v56 = v41;
              _os_log_impl(&dword_209FB3000, v40, OS_LOG_TYPE_INFO, "%{public}s %{public}s removing empty wake packet", buf, 0x16u);
            }
          }
        }
        v42 = *(_QWORD *)(i + 32);
        v43 = *(_QWORD **)(i + 40);
        if (v42)
        {
          *(_QWORD *)(v42 + 40) = v43;
          v43 = *(_QWORD **)(i + 40);
        }
        else
        {
          *((_QWORD *)a1 + 5) = v43;
        }
        *v43 = v42;
        v44 = *(void (**)(uint64_t, uint64_t, uint64_t))(i + 80);
        *(_QWORD *)(i + 32) = 0;
        *(_QWORD *)(i + 40) = 0;
        if (v44)
        {
          v45 = *(_QWORD *)(i + 88);
          *(_QWORD *)(i + 80) = 0;
          *(_QWORD *)(i + 88) = 0;
          v44(i, 1, v45);
        }
        else
        {
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v54 = "__nw_frame_finalize";
          v46 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            v47 = __nwlog_obj();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v54 = "__nw_frame_finalize";
              _os_log_impl(&dword_209FB3000, v47, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v46)
            free(v46);
        }
      }
    }
  }
  if (a1[16])
  {
    v4 = *((_QWORD *)a1 + 9);
    if ((~*(unsigned __int16 *)(v4 + 376) & 0x30) != 0)
    {
      if ((*(_BYTE *)(v4 + 828) & 2) != 0)
        return;
      v11 = __nwlog_tcp_log();
      os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
      v12 = a1[12];
      v13 = *a1;
      v14 = a1[15];
      v15 = a1[16];
      *(_DWORD *)buf = 136447746;
      v54 = "sb_agg_empty_verify";
      v55 = 2082;
      v56 = (const char *)(v4 + 604);
      v57 = 2082;
      v58 = a2;
      v59 = 1024;
      v60 = v12;
      v61 = 1024;
      v62 = v13;
      v63 = 1024;
      v64 = v14;
      v65 = 1024;
      v66 = v15;
      v16 = _os_log_send_and_compose_impl();
      if (__nwlog_abort())
LABEL_54:
        __break(1u);
      v17 = (void *)v16;
      goto LABEL_52;
    }
    if ((*(_BYTE *)(v4 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      v5 = a1[12];
      v6 = (const char *)(v4 + 604);
      v7 = *a1;
      v8 = a1[15];
      v9 = a1[16];
      *(_DWORD *)buf = 136447746;
      v54 = "sb_agg_empty_verify";
      v55 = 2082;
      v56 = (const char *)(v4 + 604);
      v57 = 2082;
      v58 = a2;
      v59 = 1024;
      v60 = v5;
      v61 = 1024;
      v62 = v7;
      v63 = 1024;
      v64 = v8;
      v65 = 1024;
      v66 = v9;
      v10 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v48 = __nwlog_tcp_log();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          v49 = a1[12];
          v50 = *a1;
          v51 = a1[15];
          v52 = a1[16];
          *(_DWORD *)buf = 136447746;
          v54 = "sb_agg_empty_verify";
          v55 = 2082;
          v56 = v6;
          v57 = 2082;
          v58 = a2;
          v59 = 1024;
          v60 = v49;
          v61 = 1024;
          v62 = v50;
          v63 = 1024;
          v64 = v51;
          v65 = 1024;
          v66 = v52;
          _os_log_impl(&dword_209FB3000, v48, OS_LOG_TYPE_ERROR, "%{public}s %{public}s %{public}s: sb flags 0x%x cc %d agg_cnt %u agg_bytes %u, backtrace limit exceeded", buf, 0x38u);
        }
      }
      if (v10)
      {
        v17 = (void *)v10;
LABEL_52:
        free(v17);
      }
    }
  }
}

void tcp_coalesce_timer_updates_end(uint64_t a1)
{
  int v2;
  NSObject *v3;
  void *v4;
  int v5;

  v2 = *(_DWORD *)(a1 + 288);
  if (!v2)
  {
    v3 = __nwlog_obj();
    os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
    v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v4);
    v2 = *(_DWORD *)(a1 + 288);
  }
  v5 = v2 - 1;
  *(_DWORD *)(a1 + 288) = v5;
  if (!v5 && (*(_BYTE *)(a1 + 310) & 4) != 0)
    tcp_process_timerlist(a1);
}

void tcp_process_timerlist(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  unsigned int v3;
  uint64_t v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  void *v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  void *v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t *v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  int v33;
  uint64_t *v34;
  uint64_t *v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  char v46;
  int v47;
  int v48;
  char v49;
  int v50;
  int v51;
  char v52;
  int v53;
  int v54;
  int v55;
  int v56;
  char v57;
  int v58;
  int v59;
  char v60;
  int v61;
  int v62;
  char v63;
  int v64;
  BOOL v65;
  int v66;
  NSObject *v67;
  void *v68;
  unsigned int v69;
  char v70;
  char v71;
  char v72;
  uint64_t v73;
  int v74;
  int v75;
  _BOOL4 v76;
  int v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  int v82;
  char v83;
  char v84;
  char v85;
  BOOL v86;
  BOOL v87;
  char v88;
  uint8_t buf[4];
  const char *v91;
  __int16 v92;
  uint64_t v93;
  uint64_t v94;

  v94 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a1 + 310) & 1) != 0)
    return;
  v1 = a1;
  *(_BYTE *)(a1 + 310) = *(_BYTE *)(a1 + 310) & 0xFA | 1;
  v2 = *(_QWORD **)(a1 + 256);
  if (!v2)
  {
LABEL_171:
    v78 = tcp_timerlist_max_offset;
    goto LABEL_185;
  }
  v3 = 0;
  v4 = 0;
  do
  {
    v5 = v2;
    v2 = (_QWORD *)*v2;
    if (*((unsigned __int16 *)v5 + 12) <= 7u)
    {
      v6 = *((_DWORD *)v5 + 5) - *(_DWORD *)(v1 + 316);
      if (v6 >= 1)
      {
        if (v3 - 1 >= v6)
          v3 = *((_DWORD *)v5 + 5) - *(_DWORD *)(v1 + 316);
        v4 = *((unsigned __int16 *)v5 + 13) | v4;
        continue;
      }
    }
    v7 = (uint64_t)(v5 - 6);
    v8 = (unsigned int *)(v5[4] + 456);
LABEL_12:
    v9 = *v8;
    if (*(_WORD *)v8 != 0xFFFF)
    {
      do
      {
        v10 = __ldxr(v8);
        if (v10 != v9)
        {
          __clrex();
          goto LABEL_12;
        }
      }
      while (__stxr(v9 + 1, v8));
      v11 = v4;
      v13 = (uint64_t *)(v7 + 48);
      v12 = *(_QWORD *)(v7 + 48);
      if (v12 && *(uint64_t **)(v12 + 8) != v13)
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446466;
        v91 = "tcp_process_timerlist";
        v92 = 2048;
        v93 = v7 + 48;
        v14 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v15 = __nwlog_obj();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v91 = "tcp_process_timerlist";
            v92 = 2048;
            v93 = v7 + 48;
            _os_log_impl(&dword_209FB3000, v15, OS_LOG_TYPE_ERROR, "%{public}s Bad link elm %p next->prev != elm, backtrace limit exceeded", buf, 0x16u);
          }
        }
        if (v14)
          free(v14);
      }
      if (**(uint64_t ***)(v7 + 56) != v13)
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446466;
        v91 = "tcp_process_timerlist";
        v92 = 2048;
        v93 = v7 + 48;
        v18 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v19 = __nwlog_obj();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v91 = "tcp_process_timerlist";
            v92 = 2048;
            v93 = v7 + 48;
            _os_log_impl(&dword_209FB3000, v19, OS_LOG_TYPE_ERROR, "%{public}s Bad link elm %p prev->next != elm, backtrace limit exceeded", buf, 0x16u);
          }
        }
        if (v18)
          free(v18);
      }
      v20 = *(unsigned __int16 *)(v1 + 308);
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 80) + 224) + 8) + 16))(*(_QWORD *)(*(_QWORD *)(v7 + 80) + 224), 1);
      v21 = *(_QWORD *)(*(_QWORD *)(v7 + 80) + 224);
      v22 = nw_tcp_access_globals(v21);
      if (in_pcb_checkstate(*(_QWORD *)(v7 + 80), 2, 1) == 0xFFFF)
      {
        if ((*(_BYTE *)(v7 + 91) & 0x40) != 0)
        {
          v23 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v7 + 80) + 224));
          (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 80) + 224) + 8) + 32))(*(_QWORD *)(*(_QWORD *)(v7 + 80) + 224), 0);
          v24 = *(_DWORD *)(v7 + 88);
          v4 = v11;
          if ((v24 & 0x40000000) != 0)
          {
            v29 = *(uint64_t **)(v23 + 264);
            v30 = *v13;
            if (v29)
              v31 = v29 == v13;
            else
              v31 = 0;
            if (v31)
              *(_QWORD *)(v23 + 264) = v30;
            if (v30)
              *(_QWORD *)(v30 + 8) = *(_QWORD *)(v7 + 56);
            v25 = 0;
            v26 = 0;
            **(_QWORD **)(v7 + 56) = v30;
            *(_DWORD *)(v7 + 88) = v24 & 0xBFFFFFFF;
            --*(_DWORD *)(v23 + 280);
            *v13 = 0;
            *(_QWORD *)(v7 + 56) = 0;
            goto LABEL_55;
          }
          goto LABEL_37;
        }
        goto LABEL_43;
      }
      if (v20)
      {
        v27 = *(_QWORD *)(*(_QWORD *)(v7 + 80) + 448);
        if (v27)
        {
          if (*(unsigned __int16 *)(v27 + 1072) == v20)
          {
            *(_DWORD *)(v7 + 740) |= 0x200000u;
            tcp_timers(v7, 0);
            *(_DWORD *)(v7 + 16) = 0;
            *(_DWORD *)(v7 + 740) &= 0x200000u;
          }
        }
      }
      v28 = *(unsigned __int16 *)(v7 + 72);
      if (v28 == 8)
      {
LABEL_43:
        v25 = 0;
        v26 = 0;
        v4 = v11;
        goto LABEL_55;
      }
      v26 = *(_DWORD *)(v7 + 68) - *(_DWORD *)(v22 + 316);
      if (v26 >= 1)
      {
        v25 = *(unsigned __int16 *)(v7 + 74);
        v4 = v11;
        goto LABEL_55;
      }
      v38 = v7 + 4 * *(unsigned __int16 *)(v7 + 72);
      v39 = *(_DWORD *)(v38 + 16);
      *(_DWORD *)(v38 + 16) = 0;
      if (v39)
      {
        v7 = tcp_timers(v7, v28);
        if (!v7)
        {
          v25 = 0;
          v26 = 0;
          v4 = v11;
          goto LABEL_67;
        }
      }
      *(_WORD *)(v7 + 74) = 0;
      v40 = *(_DWORD *)(v7 + 16);
      v41 = *(_DWORD *)(v22 + 316);
      if (v40)
      {
        v42 = *(_DWORD *)(v7 + 64) + v40 - v41;
        v43 = 1;
        if (v42 < 1)
        {
          v45 = 0;
          v46 = 0;
          v42 = 0;
          v44 = 8;
          v47 = *(_DWORD *)(v7 + 20);
          if (!v47)
            goto LABEL_85;
        }
        else
        {
          v44 = 0;
          *(_DWORD *)(v7 + 16) = v42;
          *(_WORD *)(v7 + 74) = 1;
          v41 = *(_DWORD *)(v22 + 316);
          v45 = 1;
          v46 = 1;
          v43 = 0;
          v47 = *(_DWORD *)(v7 + 20);
          if (!v47)
            goto LABEL_85;
        }
      }
      else
      {
        v45 = 0;
        v43 = 0;
        v42 = 0;
        v44 = 8;
        v46 = 1;
        v47 = *(_DWORD *)(v7 + 20);
        if (!v47)
          goto LABEL_85;
      }
      v48 = *(_DWORD *)(v7 + 64) + v47 - v41;
      if (v48 < 1)
      {
        v49 = 0;
        ++v43;
        v50 = *(_DWORD *)(v7 + 24);
        if (!v50)
          goto LABEL_92;
LABEL_88:
        v51 = *(_DWORD *)(v7 + 64) + v50 - v41;
        if (v51 < 1)
        {
          v52 = 0;
          ++v43;
          v53 = *(_DWORD *)(v7 + 28);
          if (!v53)
            goto LABEL_99;
LABEL_95:
          v54 = *(_DWORD *)(v7 + 64) + v53 - v41;
          if (v54 < 1)
          {
            v88 = 0;
            ++v43;
            v55 = *(_DWORD *)(v7 + 32);
            if (!v55)
              goto LABEL_106;
LABEL_102:
            v56 = *(_DWORD *)(v7 + 64) + v55 - v41;
            if (v56 < 1)
            {
              v57 = 0;
              ++v43;
              v58 = *(_DWORD *)(v7 + 36);
              if (!v58)
                goto LABEL_113;
LABEL_109:
              v59 = *(_DWORD *)(v7 + 64) + v58 - v41;
              if (v59 < 1)
              {
                v60 = 0;
                ++v43;
                v61 = *(_DWORD *)(v7 + 40);
                if (v61)
                {
LABEL_114:
                  v62 = *(_DWORD *)(v7 + 64) + v61 - v41;
                  if (v62 < 1)
                  {
                    v63 = 0;
                    ++v43;
                  }
                  else
                  {
                    *(_DWORD *)(v7 + 40) = v62;
                    if (v42 - 1 >= v62)
                    {
                      v42 = v62;
                      v44 = 6;
                    }
                    v45 |= 4u;
                    *(_WORD *)(v7 + 74) = v45;
                    v41 = *(_DWORD *)(v22 + 316);
                    v63 = 1;
                  }
LABEL_121:
                  v64 = *(_DWORD *)(v7 + 44);
                  v65 = v64 == 0;
                  if (v64)
                  {
                    v66 = *(_DWORD *)(v7 + 64) + v64 - v41;
                    if (v66 >= 1)
                    {
                      *(_DWORD *)(v7 + 44) = v66;
                      *(_WORD *)(v7 + 74) = v45 | 4;
                      v41 = *(_DWORD *)(v22 + 316);
                      *(_DWORD *)(v7 + 64) = v41;
                      if (v42 - 1 >= v66)
                      {
                        v44 = 7;
                        *(_WORD *)(v7 + 72) = 7;
                        v65 = 1;
                        v4 = v11;
                      }
                      else
                      {
                        *(_WORD *)(v7 + 72) = v44;
                        v65 = 1;
                        v4 = v11;
                        if (v44 == 8)
                          goto LABEL_136;
                      }
LABEL_133:
                      v69 = *(_DWORD *)(v7 + 4 * v44 + 16) + v41;
                      if (v69 <= 1)
                        v69 = 1;
                      *(_DWORD *)(v7 + 68) = v69;
LABEL_136:
                      if (!v43)
                      {
LABEL_156:
                        if (v44 > 7)
                        {
LABEL_37:
                          v25 = 0;
                          v26 = 0;
                          goto LABEL_55;
                        }
                        v26 = *(_DWORD *)(v7 + 4 * v44 + 16);
                        v25 = *(unsigned __int16 *)(v7 + 74);
LABEL_55:
                        if (*(_WORD *)(v7 + 72) == 8)
                        {
                          v32 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v7 + 80) + 224));
                          (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 80) + 224)
                                                                             + 8)
                                                                 + 32))(*(_QWORD *)(*(_QWORD *)(v7 + 80) + 224), 0);
                          v33 = *(_DWORD *)(v7 + 88);
                          if ((v33 & 0x40000000) != 0)
                          {
                            v34 = *(uint64_t **)(v32 + 264);
                            v35 = (uint64_t *)(v7 + 48);
                            if (v34)
                              v36 = v34 == v35;
                            else
                              v36 = 0;
                            if (v36)
                              *(_QWORD *)(v32 + 264) = *v34;
                            v37 = *v35;
                            if (*v35)
                              *(_QWORD *)(v37 + 8) = *(_QWORD *)(v7 + 56);
                            v26 = 0;
                            **(_QWORD **)(v7 + 56) = v37;
                            *(_DWORD *)(v7 + 88) = v33 & 0xBFFFFFFF;
                            --*(_DWORD *)(v32 + 280);
                            *v35 = 0;
                            *(_QWORD *)(v7 + 56) = 0;
                          }
                          else
                          {
                            v26 = 0;
                          }
                        }
                        goto LABEL_67;
                      }
                      v87 = v65;
                      v70 = v57;
                      if ((v46 & 1) != 0)
                      {
                        v71 = v52;
                      }
                      else
                      {
                        v71 = v52;
                        *(_DWORD *)(v7 + 16) = 0;
                        v72 = v49;
                        v73 = tcp_timers(v7, 0);
                        v49 = v72;
                        v7 = v73;
                        if (!v73)
                        {
LABEL_158:
                          v25 = 0;
                          v26 = 0;
LABEL_67:
                          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v21 + 8) + 24))(v21, 1);
                          if (v26)
                          {
                            if (v25)
                            {
                              v4 = v25 | v4;
                              if (v3 - 1 >= v26)
                                v3 = v26;
                            }
                          }
                          v1 = a1;
                          continue;
                        }
                      }
                      if ((v49 & 1) != 0 || (*(_DWORD *)(v7 + 20) = 0, (v7 = tcp_timers(v7, 1)) != 0))
                      {
                        if ((v71 & 1) == 0)
                        {
                          *(_DWORD *)(v7 + 24) = 0;
                          nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v7 + 80) + 224));
                          if ((*(_DWORD *)(v7 + 740) & 0x20400020) == 0x20000020)
                            tcp_rack_reordering_timeout(v7);
                        }
                        if ((v88 & 1) != 0 || (*(_DWORD *)(v7 + 28) = 0, (v7 = tcp_timers(v7, 3)) != 0))
                        {
                          if ((v70 & 1) != 0 || (*(_DWORD *)(v7 + 32) = 0, (v7 = tcp_timers(v7, 4)) != 0))
                          {
                            if ((v60 & 1) != 0 || (*(_DWORD *)(v7 + 36) = 0, (v7 = tcp_timers(v7, 5)) != 0))
                            {
                              if ((v63 & 1) != 0 || (*(_DWORD *)(v7 + 40) = 0, (v7 = tcp_timers(v7, 6)) != 0))
                              {
                                if (v87 || (*(_DWORD *)(v7 + 44) = 0, (v7 = tcp_timers(v7, 7)) != 0))
                                {
                                  tcp_set_lotimer_index(v7);
                                  v44 = *(unsigned __int16 *)(v7 + 72);
                                  goto LABEL_156;
                                }
                              }
                            }
                          }
                        }
                      }
                      goto LABEL_158;
                    }
                    ++v43;
                  }
                  *(_DWORD *)(v7 + 64) = v41;
                  *(_WORD *)(v7 + 72) = v44;
                  v4 = v11;
                  if (v44 == 8)
                    goto LABEL_136;
                  if (!v45)
                  {
                    v86 = v65;
                    v83 = v57;
                    v84 = v52;
                    v85 = v49;
                    v67 = __nwlog_obj();
                    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)buf = 136446210;
                    v91 = "tcp_run_conn_timer";
                    v68 = (void *)_os_log_send_and_compose_impl();
                    if (__nwlog_abort())
                    {
                      __break(1u);
                      return;
                    }
                    free(v68);
                    v44 = *(unsigned __int16 *)(v7 + 72);
                    if (v44 == 8)
                    {
                      v4 = v11;
                      v52 = v84;
                      v49 = v85;
                      v57 = v83;
                      v65 = v86;
                      goto LABEL_136;
                    }
                    v41 = *(_DWORD *)(v7 + 64);
                    v4 = v11;
                    v52 = v84;
                    v49 = v85;
                    v57 = v83;
                    v65 = v86;
                  }
                  goto LABEL_133;
                }
LABEL_119:
                v63 = 1;
                goto LABEL_121;
              }
              *(_DWORD *)(v7 + 36) = v59;
              if (v42 - 1 >= v59)
              {
                v42 = v59;
                v44 = 5;
              }
              v45 |= 4u;
              *(_WORD *)(v7 + 74) = v45;
              v41 = *(_DWORD *)(v22 + 316);
LABEL_113:
              v60 = 1;
              v61 = *(_DWORD *)(v7 + 40);
              if (v61)
                goto LABEL_114;
              goto LABEL_119;
            }
            *(_DWORD *)(v7 + 32) = v56;
            if (v42 - 1 >= v56)
            {
              v42 = v56;
              v44 = 4;
            }
            v45 |= 2u;
            *(_WORD *)(v7 + 74) = v45;
            v41 = *(_DWORD *)(v22 + 316);
LABEL_106:
            v57 = 1;
            v58 = *(_DWORD *)(v7 + 36);
            if (!v58)
              goto LABEL_113;
            goto LABEL_109;
          }
          *(_DWORD *)(v7 + 28) = v54;
          if (v42 - 1 >= v54)
          {
            v42 = v54;
            v44 = 3;
          }
          v45 |= 2u;
          *(_WORD *)(v7 + 74) = v45;
          v41 = *(_DWORD *)(v22 + 316);
LABEL_99:
          v88 = 1;
          v55 = *(_DWORD *)(v7 + 32);
          if (!v55)
            goto LABEL_106;
          goto LABEL_102;
        }
        *(_DWORD *)(v7 + 24) = v51;
        if (v42 - 1 >= v51)
        {
          v44 = 2;
          v42 = v51;
        }
        v45 = 1;
        *(_WORD *)(v7 + 74) = 1;
        v41 = *(_DWORD *)(v22 + 316);
LABEL_92:
        v52 = 1;
        v53 = *(_DWORD *)(v7 + 28);
        if (!v53)
          goto LABEL_99;
        goto LABEL_95;
      }
      *(_DWORD *)(v7 + 20) = v48;
      if (v42 - 1 >= v48)
      {
        v44 = 1;
        v42 = v48;
      }
      v45 = 1;
      *(_WORD *)(v7 + 74) = 1;
      v41 = *(_DWORD *)(v22 + 316);
LABEL_85:
      v49 = 1;
      v50 = *(_DWORD *)(v7 + 24);
      if (!v50)
        goto LABEL_92;
      goto LABEL_88;
    }
    v16 = *(_DWORD *)(v7 + 88);
    if ((v16 & 0x40000000) != 0)
    {
      v17 = *(_QWORD *)(v7 + 48);
      *(_DWORD *)(v7 + 88) = v16 & 0xBFFFFFFF;
      if (v17)
        *(_QWORD *)(v17 + 8) = *(_QWORD *)(v7 + 56);
      **(_QWORD **)(v7 + 56) = v17;
      --*(_DWORD *)(v1 + 280);
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
    }
  }
  while (v2);
  if (!*(_QWORD *)(v1 + 256))
    goto LABEL_171;
  if ((v4 & 1) != 0)
  {
    v76 = 0;
    v77 = 1;
  }
  else
  {
    v74 = *(_DWORD *)(v1 + 296);
    if (((v74 | v4) & 2) != 0)
      v75 = 2;
    else
      v75 = 4;
    v76 = (v74 & 1) == 0 && ((v74 | v4) & 2) == 0;
    if ((*(_DWORD *)(v1 + 296) & 1) != 0)
      v77 = 1;
    else
      v77 = v75;
  }
  *(_DWORD *)(v1 + 304) = 0;
  *(_DWORD *)(v1 + 292) = v77;
  v79 = *(_DWORD *)(v1 + 300);
  if (v79 >= v3)
    v80 = v3;
  else
    v80 = *(_DWORD *)(v1 + 300);
  if (v79)
    v81 = v80;
  else
    v81 = v3;
  if (v81 <= 0x1F4)
    v82 = 500;
  else
    v82 = v81;
  if (v76)
    v78 = v82;
  else
    v78 = v81;
LABEL_185:
  tcp_sched_timerlist(v1, v78);
  *(_BYTE *)(v1 + 310) &= ~1u;
  *(_QWORD *)(v1 + 296) = 0;
  *(_WORD *)(v1 + 308) = 0;
}

void tcp_sched_timerlist(uint64_t a1, unsigned int a2)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int64_t v14;
  int v15;
  NSObject *v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;
  NSObject *v21;
  int v22;
  int v23;
  int v24;
  NSObject *v25;
  int v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  unsigned int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  unsigned int v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a1 + 288))
    return;
  v3 = tcp_timerlist_max_offset;
  if (tcp_timerlist_max_offset >= a2)
    v4 = a2;
  else
    v4 = tcp_timerlist_max_offset;
  v5 = *(_DWORD *)(a1 + 316);
  v6 = v5 + v4;
  if ((*(_BYTE *)(a1 + 310) & 2) == 0 || (v7 = *(_DWORD *)(a1 + 272), v6 < v7))
  {
    *(_DWORD *)(a1 + 272) = v6;
    if (!v6)
    {
      *(_DWORD *)(a1 + 272) = 1;
      ++v4;
    }
    goto LABEL_17;
  }
  if (v7 <= v5 && v6 > v5)
  {
    *(_DWORD *)(a1 + 272) = v6;
LABEL_17:
    *(_DWORD *)(a1 + 276) = v5;
    if (v4 == v3)
    {
      if (__nwlog_is_datapath_logging_enabled()
        && (v15 = v3, v16 = __nwlog_obj(), os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)))
      {
        v17 = *(_DWORD *)(a1 + 292);
        v18 = *(_DWORD *)(a1 + 276);
        v19 = *(_DWORD *)(a1 + 272);
        v26 = 136447234;
        v27 = "tcp_sched_timerlist";
        v28 = 1024;
        v29 = v17;
        v30 = 1024;
        v31 = v18;
        v32 = 1024;
        v33 = v19;
        v34 = 1024;
        v35 = v15;
        _os_log_impl(&dword_209FB3000, v16, OS_LOG_TYPE_DEBUG, "%{public}s mode %d schedtime %u runtime %u offset %u, deadline set to forever", (uint8_t *)&v26, 0x24u);
        v14 = -1;
      }
      else
      {
        v14 = -1;
      }
    }
    else
    {
      v14 = 1000000 * v4;
      if (__nwlog_is_datapath_logging_enabled())
      {
        v20 = v4;
        v21 = __nwlog_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          v22 = *(_DWORD *)(a1 + 292);
          v23 = *(_DWORD *)(a1 + 276);
          v24 = *(_DWORD *)(a1 + 272);
          v26 = 136447234;
          v27 = "tcp_sched_timerlist";
          v28 = 1024;
          v29 = v22;
          v30 = 1024;
          v31 = v23;
          v32 = 1024;
          v33 = v24;
          v34 = 1024;
          v35 = v20;
          v25 = v21;
          v4 = v20;
          _os_log_impl(&dword_209FB3000, v25, OS_LOG_TYPE_DEBUG, "%{public}s mode %d schedtime %u runtime %u offset %u", (uint8_t *)&v26, 0x24u);
        }
        else
        {
          v4 = v20;
        }
      }
    }
    nw_protocol_timer_run_inner(a1, v14);
    if (v4 != tcp_timerlist_max_offset)
      *(_BYTE *)(a1 + 310) |= 2u;
    return;
  }
  if (__nwlog_is_datapath_logging_enabled())
  {
    v9 = __nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      v10 = *(_DWORD *)(a1 + 292);
      v11 = *(_DWORD *)(a1 + 276);
      v12 = *(_DWORD *)(a1 + 272);
      v13 = *(_DWORD *)(a1 + 316);
      v26 = 136447746;
      v27 = "tcp_sched_timerlist";
      v28 = 1024;
      v29 = v10;
      v30 = 1024;
      v31 = v11;
      v32 = 1024;
      v33 = v12;
      v34 = 1024;
      v35 = v6;
      v36 = 1024;
      v37 = v13;
      v38 = 1024;
      v39 = v4;
      _os_log_impl(&dword_209FB3000, v9, OS_LOG_TYPE_DEBUG, "%{public}s mode %d schedtime %u runtime %u new_runtime %u tcp_now %u offset %u, not pushing timer out", (uint8_t *)&v26, 0x30u);
    }
  }
}

void nw_protocol_tcp_wake_read(uint64_t a1)
{
  _DWORD *v2;
  unsigned int v3;
  NSObject *v4;
  int v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  int v9;
  int v10;
  const char *v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD **)(a1 + 40);
  if (v2[1306] == 2)
  {
    v3 = *(_DWORD *)(a1 + 488);
    if (v3 >= v2[124] || v3 >= *(_DWORD *)(a1 + 496))
    {
      nw_protocol_upcast();
      nw_protocol_get_input_handler();
      if (nw_protocol_input_available_is_valid())
      {
        if ((*(_BYTE *)(a1 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            v8 = __nwlog_tcp_log();
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
            {
              v9 = *(_DWORD *)(a1 + 488);
              v10 = 136446722;
              v11 = "nw_protocol_tcp_wake_read";
              v12 = 2082;
              v13 = a1 + 604;
              v14 = 1024;
              v15 = v9;
              _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s waking the input_handler with %d bytes in our queue", (uint8_t *)&v10, 0x1Cu);
            }
          }
        }
        nw_protocol_get_input_handler();
        nw_protocol_input_available();
      }
    }
    else if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
    {
      v4 = __nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        v5 = v2[124];
        v6 = v2[122];
        v10 = 136446978;
        v11 = "nw_protocol_tcp_wake_read";
        v12 = 2082;
        v13 = a1 + 604;
        v14 = 1024;
        v15 = v5;
        v16 = 1024;
        v17 = v6;
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s ignoring wake low_water %u sb_cc %u", (uint8_t *)&v10, 0x22u);
      }
    }
  }
  else if ((*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v10 = 136446466;
        v11 = "nw_protocol_tcp_wake_read";
        v12 = 2082;
        v13 = a1 + 604;
        _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v10, 0x16u);
      }
    }
  }
}

uint64_t nw_protocol_tcp_wake_send()
{
  nw_protocol_upcast();
  nw_protocol_retain();
  return nw_queue_context_async();
}

void nw_protocol_timer_run_inner(uint64_t a1, int64_t a2)
{
  void *v2;
  NSObject *v3;
  uint8_t buf[4];
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  if (a2 != -1 && dispatch_time(0x8000000000000000, a2) == -1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v5 = "nw_protocol_timer_run_inner";
    v2 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v3 = __nwlog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v5 = "nw_protocol_timer_run_inner";
        _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_ERROR, "%{public}s dispatch_time: Integer overflow failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v2)
      free(v2);
  }
  else
  {
    nw_queue_set_timer_values();
  }
}

void sbflush(uint64_t a1)
{
  uint64_t v2;
  __int128 v3;
  uint64_t v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  int v10;
  int v11;
  unsigned int v12;
  NSObject *v13;
  NSObject *v14;
  void *v15;
  NSObject *v16;
  const char *v17;
  void *v18;
  __int128 v19;
  __int128 v20;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  const char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 72);
  sblock(a1);
  if (*(_QWORD *)(a1 + 32))
  {
    if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v16 = __nwlog_tcp_log();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          v17 = "";
          if (v2)
            v17 = (const char *)(v2 + 604);
          *(_DWORD *)buf = 136446466;
          v22 = "sbflush";
          v23 = 2082;
          v24 = v17;
          _os_log_impl(&dword_209FB3000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s sb_mb_aggregate not empty", buf, 0x16u);
        }
      }
    }
    v4 = *(_QWORD *)(a1 + 32);
    if (v4)
    {
      *(_QWORD *)&v3 = 136446210;
      do
      {
        v7 = *(_QWORD *)(v4 + 32);
        v8 = *(_QWORD **)(v4 + 40);
        v9 = (_QWORD *)(v4 + 32);
        if (v7)
        {
          *(_QWORD *)(v7 + 40) = v8;
          v8 = *(_QWORD **)(v4 + 40);
        }
        else
        {
          *(_QWORD *)(a1 + 40) = v8;
        }
        *v8 = v7;
        *v9 = 0;
        *(_QWORD *)(v4 + 40) = 0;
        v10 = *(_DWORD *)(a1 + 60);
        if (!v10)
        {
          v20 = v3;
          v14 = __nwlog_obj();
          os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = v20;
          v22 = "sbflush";
          v15 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_abort())
          {
LABEL_27:
            __break(1u);
            return;
          }
          free(v15);
          v10 = *(_DWORD *)(a1 + 60);
          v3 = v20;
        }
        *(_DWORD *)(a1 + 60) = v10 - 1;
        v11 = *(_DWORD *)(v4 + 52);
        v12 = *(_DWORD *)(a1 + 64);
        if (v11)
        {
          v5 = v11 - (*(_DWORD *)(v4 + 56) + *(_DWORD *)(v4 + 60));
          if (v12 < v5)
          {
            v19 = v3;
            v13 = __nwlog_obj();
            os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = v19;
            v22 = "sbflush";
            v18 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_abort())
              goto LABEL_27;
            free(v18);
            v12 = *(_DWORD *)(a1 + 64);
            v3 = v19;
          }
        }
        else
        {
          v5 = 0;
        }
        *(_DWORD *)(a1 + 64) = v12 - v5;
        *(_QWORD *)(v4 + 32) = 0;
        v6 = *(_QWORD **)(a1 + 24);
        *(_QWORD *)(v4 + 40) = v6;
        *v6 = v4;
        *(_QWORD *)(a1 + 24) = v9;
        v4 = *(_QWORD *)(a1 + 32);
      }
      while (v4);
    }
    sb_agg_empty_verify((int *)a1, (uint64_t)"sbflush");
  }
  if (nw_frame_array_first())
    sbdrop((int *)a1, *(_DWORD *)a1);
  sb_empty_assert((int *)a1, (uint64_t)"sbflush");
  sbunlock(a1);
}

void sbunlock(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  void (*v5)(uint64_t);
  int v6;
  int v7;
  void *v8;
  NSObject *v9;
  int v10;
  int v11;
  NSObject *v12;
  void *v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 72);
  if ((*(_DWORD *)(v2 + 360) & 0x80000000) != 0)
  {
    if ((*(_BYTE *)(v2 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      v6 = *(_DWORD *)(a1 + 48);
      v7 = *(_DWORD *)(v2 + 360);
      *(_DWORD *)buf = 136447490;
      v15 = "sbunlock";
      v16 = 2082;
      v17 = v2 + 604;
      v18 = 2048;
      v19 = a1;
      v20 = 1024;
      v21 = v6;
      v22 = 2048;
      v23 = v2;
      v24 = 1024;
      v25 = v7;
      v8 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v9 = __nwlog_tcp_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          v10 = *(_DWORD *)(a1 + 48);
          v11 = *(_DWORD *)(v2 + 360);
          *(_DWORD *)buf = 136447490;
          v15 = "sbunlock";
          v16 = 2082;
          v17 = v2 + 604;
          v18 = 2048;
          v19 = a1;
          v20 = 1024;
          v21 = v10;
          v22 = 2048;
          v23 = v2;
          v24 = 1024;
          v25 = v11;
          _os_log_impl(&dword_209FB3000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s sb=%p sb_flags=0x%x sb_so=%p usecount=%d, backtrace limit exceeded", buf, 0x36u);
        }
      }
      if (v8)
        free(v8);
    }
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 48);
    if ((v3 & 1) == 0 && (*(__int16 *)(v2 + 376) & 0x80000000) == 0 && (*(_BYTE *)(v2 + 368) & 8) == 0)
    {
      v12 = __nwlog_obj();
      os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v15 = "sbunlock";
      v13 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
      {
        __break(1u);
        return;
      }
      free(v13);
      v3 = *(_DWORD *)(a1 + 48);
    }
    *(_DWORD *)(a1 + 48) = v3 & 0xFFFFFFFE;
    if (*(_DWORD *)(a1 + 56))
    {
      v4 = *(_QWORD *)(v2 + 32);
      if ((v3 & 4) == 0)
      {
        if (!v4)
          return;
        v5 = *(void (**)(uint64_t))(v4 + 8);
        if (!v5)
          return;
LABEL_15:
        v5(v2);
        return;
      }
      if (v4)
      {
        v5 = *(void (**)(uint64_t))(v4 + 32);
        if (v5)
          goto LABEL_15;
      }
    }
  }
}

void sblock(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  void (*v7)(uint64_t, uint64_t, _QWORD);
  int v8;
  NSObject *v9;
  NSObject *v10;
  void *v11;
  int v12;
  int v13;
  void *v14;
  NSObject *v15;
  int v16;
  int v17;
  void *v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 72);
  if ((*(_DWORD *)(v2 + 360) & 0x80000000) == 0)
  {
    v3 = *(_DWORD *)(a1 + 48);
    if ((v3 & 1) == 0)
    {
LABEL_18:
      *(_DWORD *)(a1 + 48) = v3 | 1;
      return;
    }
    while (1)
    {
      v4 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(v2 + 8) + 32))(v2, 0);
      v5 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(a1 + 56) = v5 + 1;
      if (v5 == -1)
      {
        v9 = __nwlog_obj();
        os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v20 = "sblock";
        v18 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_abort())
          goto LABEL_26;
        free(v18);
      }
      v6 = *(_QWORD *)(v2 + 32);
      if ((*(_BYTE *)(a1 + 48) & 4) != 0)
      {
        if (v6)
        {
          v7 = *(void (**)(uint64_t, uint64_t, _QWORD))(v6 + 104);
          if (v7)
LABEL_10:
            v7(v2, v4, 0);
        }
      }
      else if (v6)
      {
        v7 = *(void (**)(uint64_t, uint64_t, _QWORD))(v6 + 96);
        if (v7)
          goto LABEL_10;
      }
      v8 = *(_DWORD *)(a1 + 56);
      if (!v8)
      {
        v10 = __nwlog_obj();
        os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v20 = "sblock";
        v11 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_abort())
        {
LABEL_26:
          __break(1u);
          return;
        }
        free(v11);
        v8 = *(_DWORD *)(a1 + 56);
      }
      *(_DWORD *)(a1 + 56) = v8 - 1;
      v3 = *(_DWORD *)(a1 + 48);
      if ((v3 & 1) == 0)
        goto LABEL_18;
    }
  }
  if ((*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    v12 = *(_DWORD *)(a1 + 48);
    v13 = *(_DWORD *)(v2 + 360);
    *(_DWORD *)buf = 136447490;
    v20 = "sblock";
    v21 = 2082;
    v22 = v2 + 604;
    v23 = 2048;
    v24 = a1;
    v25 = 1024;
    v26 = v12;
    v27 = 2048;
    v28 = v2;
    v29 = 1024;
    v30 = v13;
    v14 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v15 = __nwlog_tcp_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v16 = *(_DWORD *)(a1 + 48);
        v17 = *(_DWORD *)(v2 + 360);
        *(_DWORD *)buf = 136447490;
        v20 = "sblock";
        v21 = 2082;
        v22 = v2 + 604;
        v23 = 2048;
        v24 = a1;
        v25 = 1024;
        v26 = v16;
        v27 = 2048;
        v28 = v2;
        v29 = 1024;
        v30 = v17;
        _os_log_impl(&dword_209FB3000, v15, OS_LOG_TYPE_ERROR, "%{public}s %{public}s sb=%p sb_flags=0x%x sb_so=%p usecount=%d, backtrace limit exceeded", buf, 0x36u);
      }
    }
    if (v14)
      free(v14);
  }
}

void sb_empty_assert(int *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  const char *v7;
  void *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (*a1 || !nw_frame_array_is_empty() || *((_QWORD *)a1 + 4))
  {
    v4 = *((_QWORD *)a1 + 9);
    if (!v4 || (*(_BYTE *)(v4 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      v5 = *((_QWORD *)a1 + 9);
      v6 = *a1;
      *(_DWORD *)buf = 136447746;
      if (v4)
        v7 = (const char *)(v4 + 604);
      else
        v7 = "";
      v13 = "sb_empty_assert";
      v14 = 2082;
      v15 = v7;
      v16 = 2082;
      v17 = a2;
      v18 = 2048;
      v19 = a1;
      v20 = 2048;
      v21 = v5;
      v22 = 1024;
      v23 = v6;
      v24 = 2048;
      v25 = a1 + 4;
      v8 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v9 = __nwlog_tcp_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          v10 = *((_QWORD *)a1 + 9);
          v11 = *a1;
          *(_DWORD *)buf = 136447746;
          v13 = "sb_empty_assert";
          v14 = 2082;
          v15 = v7;
          v16 = 2082;
          v17 = a2;
          v18 = 2048;
          v19 = a1;
          v20 = 2048;
          v21 = v10;
          v22 = 1024;
          v23 = v11;
          v24 = 2048;
          v25 = a1 + 4;
          _os_log_impl(&dword_209FB3000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s %{public}s: sb %p so %p cc %d mb %p, backtrace limit exceeded", buf, 0x44u);
        }
      }
      if (v8)
        free(v8);
    }
  }
}

uint64_t tcp_usrclosed(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t all_stats;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t);
  NSObject *v12;
  const char *v13;
  char *v14;
  NSObject *v15;
  const char *v16;
  char *v17;
  int v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v2 = a1;
  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 12);
  switch(v3)
  {
    case 0:
    case 1:
    case 2:
      tcp_close(a1);
      return 0;
    case 3:
      *(_DWORD *)(a1 + 88) |= 0x800u;
      goto LABEL_17;
    case 4:
      *(_DWORD *)(a1 + 12) = 6;
      v4 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
      if (!v4 || (*(_BYTE *)(v4 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v12 = __nwlog_tcp_log();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            v13 = (const char *)(v4 + 604);
            v14 = tcpstates[*(int *)(v2 + 12)];
            v18 = 136446722;
            v19 = "tcp_usrclosed";
            if (!v4)
              v13 = "";
            v20 = 2082;
            v21 = v13;
            v22 = 2082;
            v23 = v14;
            _os_log_impl(&dword_209FB3000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", (uint8_t *)&v18, 0x20u);
          }
        }
      }
      if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 80) + 224) + 24))
        goto LABEL_17;
      all_stats = nw_protocol_tcp_get_all_stats();
      if (!all_stats)
        goto LABEL_17;
      v6 = 6;
      break;
    case 5:
      *(_DWORD *)(a1 + 12) = 8;
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
      if (!v7 || (*(_BYTE *)(v7 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v15 = __nwlog_tcp_log();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            v16 = (const char *)(v7 + 604);
            v17 = tcpstates[*(int *)(v2 + 12)];
            v18 = 136446722;
            v19 = "tcp_usrclosed";
            if (!v7)
              v16 = "";
            v20 = 2082;
            v21 = v16;
            v22 = 2082;
            v23 = v17;
            _os_log_impl(&dword_209FB3000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", (uint8_t *)&v18, 0x20u);
          }
        }
      }
      if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 80) + 224) + 24))
        goto LABEL_17;
      all_stats = nw_protocol_tcp_get_all_stats();
      if (!all_stats)
        goto LABEL_17;
      v6 = 8;
      break;
    default:
      goto LABEL_18;
  }
  *(_DWORD *)(all_stats + 136) = v6;
LABEL_17:
  v3 = *(_DWORD *)(v2 + 12);
LABEL_18:
  if (v3 >= 9)
  {
    v8 = *(_QWORD *)(*(_QWORD *)(v2 + 80) + 224);
    *(_WORD *)(v8 + 376) = *(_WORD *)(v8 + 376) & 0xDFC1 | 0x2030;
    v9 = *(_QWORD *)(v8 + 32);
    if (v9)
    {
      v10 = *(void (**)(uint64_t, uint64_t))(v9 + 56);
      if (v10)
      {
        v10(v8, a2);
        v3 = *(_DWORD *)(v2 + 12);
      }
    }
    if (v3 == 9)
      tcp_set_finwait_timeout(v2);
  }
  return v2;
}

uint64_t tcp_timers(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int16 v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t all_stats;
  char v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  unsigned int v31;
  int v32;
  BOOL v33;
  NSObject *v35;
  const char *v36;
  int v37;
  void (*v38)(uint64_t);
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  const char *v48;
  void *v49;
  NSObject *v50;
  os_log_type_t v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  int v58;
  __int16 v59;
  int v60;
  int v61;
  int v62;
  int v63;
  NSObject *v64;
  const char *v65;
  int v66;
  int v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  unsigned int v71;
  uint64_t v72;
  void (*v73)(uint64_t);
  uint64_t v74;
  int v75;
  uint64_t v76;
  _QWORD *v77;
  char v78;
  _QWORD *v79;
  _QWORD *v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  void (*v85)(uint64_t);
  int v86;
  uint64_t v87;
  unsigned int v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  unsigned int v93;
  int v94;
  int v95;
  int v96;
  uint64_t v97;
  unsigned int v98;
  unsigned int v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  void (*v103)(uint64_t);
  uint64_t v104;
  uint64_t v105;
  void (**v106)(uint64_t);
  void (*v107)(uint64_t);
  void (*v108)(uint64_t);
  uint64_t v109;
  void (**v110)(uint64_t);
  void (*v111)(uint64_t);
  void (*v112)(uint64_t);
  int v113;
  uint64_t v114;
  int v115;
  uint64_t v116;
  int v117;
  int v118;
  int v119;
  unsigned int v120;
  int v121;
  int v122;
  int v123;
  unsigned int v124;
  uint64_t v125;
  unsigned int v126;
  unsigned int v127;
  uint64_t v128;
  unsigned int v129;
  unsigned int v130;
  uint64_t v131;
  unsigned int v132;
  void (*v133)(uint64_t);
  unsigned int v134;
  NSObject *v135;
  const char *v136;
  int v137;
  const char *v138;
  NSObject *v139;
  os_log_type_t v140;
  uint32_t v141;
  NSObject *v142;
  const char *v143;
  const char *v144;
  int v145;
  int v146;
  int v147;
  uint64_t v148;
  void (*v149)(uint64_t);
  int v150;
  int v151;
  int v152;
  uint64_t result;
  NSObject *v154;
  void *v155;
  os_log_type_t type[8];
  uint8_t buf[32];
  uint64_t v158;
  __int128 v159;
  __int16 v160;
  __int16 v161;
  uint64_t v162;

  v3 = a1;
  v162 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 80);
  v5 = *(_QWORD *)(v4 + 448);
  v6 = *(_QWORD *)(v4 + 224);
  v7 = nw_tcp_access_globals(v6);
  v8 = v7;
  v9 = *(_DWORD *)(v7 + 316);
  v10 = v9 - *(_DWORD *)(v3 + 160);
  switch(a2)
  {
    case 0:
      v11 = *(_DWORD *)(v3 + 740);
      *(_DWORD *)(v3 + 740) = v11 & 0xFFFFEFFF;
      if (*(_DWORD *)(v3 + 12) == 4 && (!*(_WORD *)(v3 + 226) || (v11 & 0x200000) != 0))
      {
        v12 = *(_DWORD *)(v3 + 96);
        v13 = v12 - *(_DWORD *)(v3 + 92);
        if (v13)
        {
          if ((v11 & 0x20) != 0 && (*(_BYTE *)(v3 + 90) & 0x20) == 0)
          {
            v14 = *(_DWORD *)(v6 + 384);
            if (v14 >= *(_DWORD *)(v3 + 140))
              v14 = *(_DWORD *)(v3 + 140);
            if ((int)(v14 - v13) <= 0)
            {
              if (v13 >= *(_DWORD *)(v3 + 196))
                v13 = *(_DWORD *)(v3 + 196);
              v12 -= v13;
            }
            *(_DWORD *)(v3 + 100) = v12;
            v15 = *(_QWORD *)(v3 + 1056);
            if (v15)
            {
              ++*(_QWORD *)(v15 + 712);
              if ((v11 & 0x200000) != 0)
                ++*(_QWORD *)(v15 + 728);
            }
            *(_DWORD *)(v3 + 172) = 0;
            *(_DWORD *)(v3 + 740) = v11 | 0x1000;
            *(_DWORD *)(v3 + 936) = v9;
            *(_DWORD *)(v3 + 144) += *(_DWORD *)(v3 + 196);
            *(_DWORD *)(v3 + 28) = 0;
            tcp_output(v3);
            *(_DWORD *)(v3 + 144) -= *(_DWORD *)(v3 + 196);
            v16 = *(_DWORD *)(v3 + 100);
            *(_DWORD *)(v3 + 928) = v16;
            *(_DWORD *)(v3 + 932) = v16;
          }
        }
      }
      return v3;
    case 1:
      v37 = *(_DWORD *)(v3 + 740);
      *(_DWORD *)(v3 + 740) = v37 & 0xFFFFBFFF;
      if ((*(_BYTE *)(v3 + 90) & 0x20) != 0
        || *(_DWORD *)(v3 + 92) - *(_DWORD *)(v3 + 152) >= 0
        || *(_WORD *)(v3 + 226))
      {
        return v3;
      }
      if ((v37 & 0x20) != 0)
        goto LABEL_75;
      v154 = __nwlog_obj();
      os_log_type_enabled(v154, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_timers";
      v155 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort();
      if ((_DWORD)result)
      {
        __break(1u);
        return result;
      }
      free(v155);
LABEL_75:
      tcp_rexmt_save_state(v3);
      v38 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v3 + 264)] + 64);
      if (v38)
      {
        if ((v38(v3), v39 = *(_DWORD *)(v3 + 740), (v39 & 0x10000000) != 0)
          || (v39 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
          || (~*(_DWORD *)(v3 + 348) & 0x300000) != 0)
        {
          v40 = *(_DWORD *)(v3 + 348);
          if ((~v40 & 3) == 0)
            *(_DWORD *)(v3 + 348) = v40 | 8;
        }
      }
      *(_DWORD *)(v3 + 88) |= 0x200000u;
      v41 = *(_QWORD *)(v3 + 80);
      if ((*(_BYTE *)(v41 + 2231) & 0x40) != 0)
        inp_reset_fc_state(v41);
      if (*(_QWORD *)(v3 + 952))
        tcp_rxtseg_clean(v3);
      *(_DWORD *)(v3 + 28) = 0;
      v42 = *(_QWORD *)(v3 + 1056);
      if (v42)
        ++*(_QWORD *)(v42 + 568);
      ++*(_DWORD *)(v3 + 1004);
      *(_DWORD *)(v3 + 144) = *(_DWORD *)(v3 + 196);
      goto LABEL_360;
    case 2:
      if ((*(_DWORD *)(v3 + 740) & 0x20400020) == 0x20000020)
        tcp_rack_reordering_timeout(v3);
      return v3;
    case 3:
      v22 = *(_WORD *)(v3 + 226) + 1;
      *(_WORD *)(v3 + 226) = v22;
      if (v22 > 0xCu)
        goto LABEL_170;
      v23 = *(_DWORD *)(v3 + 244);
      if (v23)
      {
        v24 = *(_DWORD *)(v3 + 248);
        if (v24)
        {
          if (v9 - v24 >= v23)
            goto LABEL_170;
        }
      }
      if ((*(_BYTE *)(v3 + 740) & 1) == 0 || (*(_BYTE *)(v3 + 88) & 0x10) == 0)
      {
        if (v22 < 5u)
          goto LABEL_198;
        v25 = *(_DWORD *)(v3 + 12);
        if (v25 >= 4 && v5)
        {
          if ((*(_BYTE *)(v5 + 1052) & 8) != 0)
          {
            if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 224) + 24))
            {
              all_stats = nw_protocol_tcp_get_all_stats();
              if (all_stats)
              {
                v27 = 2;
LABEL_197:
                *(_BYTE *)(all_stats + 96) |= v27;
              }
            }
          }
        }
        else if (v25 <= 3)
        {
          if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 224) + 24))
          {
            all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats)
            {
              v27 = 8;
              goto LABEL_197;
            }
          }
        }
LABEL_198:
        v83 = *(_QWORD *)(v3 + 1056);
        if (v83)
          ++*(_QWORD *)(v83 + 480);
        *(_QWORD *)(v3 + 216) = 0;
        if (*(_WORD *)(v3 + 226) == 1 && *(_DWORD *)(v3 + 12) == 4)
        {
          *(_DWORD *)(v3 + 248) = *(_DWORD *)(v8 + 316);
          tcp_rexmt_save_state(v3);
        }
        if (*(_BYTE *)(v3 + 266))
        {
          if (*(unsigned __int16 *)(v3 + 226) > *(unsigned __int8 *)(v3 + 266) && *(int *)(v3 + 12) >= 4)
          {
            if (v6)
            {
              v84 = *(_QWORD *)(v6 + 32);
              if (v84)
              {
                v85 = *(void (**)(uint64_t))(v84 + 80);
                if (v85)
                  v85(v6);
              }
            }
          }
        }
        v86 = *(_DWORD *)(v3 + 740);
        if ((v86 & 0x1000) != 0)
        {
          v86 &= ~0x1000u;
          *(_DWORD *)(v3 + 740) = v86;
          v87 = *(_QWORD *)(v3 + 1056);
          if (v87)
            ++*(_QWORD *)(v87 + 720);
        }
        if ((v86 & 0x4000) != 0)
        {
          *(_WORD *)(v3 + 536) = 0;
          *(_DWORD *)(v3 + 20) = 0;
          v86 &= ~0x4000u;
          *(_DWORD *)(v3 + 740) = v86;
        }
        if ((v86 & 0x1000000) == 0 && *(_DWORD *)(v3 + 12) == 3)
        {
          v86 &= ~0x400000u;
          *(_DWORD *)(v3 + 740) = v86;
        }
        if ((v86 & 0x1000000) == 0
          && (*(_BYTE *)(v3 + 988) & 0x40) == 0
          && (*(_BYTE *)(v3 + 988) & 0x20) == 0
          && (*(_WORD *)(v3 + 990) & 0x40) != 0)
        {
          v88 = *(unsigned __int16 *)(v3 + 226);
          if (*(_DWORD *)(v3 + 12) == 2)
          {
            if (v88 < 5)
              goto LABEL_271;
          }
          else if (v88 <= 1)
          {
            goto LABEL_271;
          }
          tcp_heuristic_tfo_middlebox(v3);
          *(_WORD *)(v6 + 378) = 96;
          user_north_signal_error(v6);
          v106 = *(void (***)(uint64_t))(v6 + 32);
          if (v106)
          {
            v107 = v106[3];
            if (!v107 || (v107(v6), (v106 = *(void (***)(uint64_t))(v6 + 32)) != 0))
            {
              v108 = *v106;
              if (v108)
                v108(v6);
            }
          }
          *(_WORD *)(v3 + 990) |= 0x1000u;
          v109 = *(_QWORD *)(v3 + 1056);
          if (v109)
            ++*(_QWORD *)(v109 + 1176);
        }
LABEL_271:
        if ((*(_BYTE *)(v3 + 743) & 1) == 0
          && (*(_BYTE *)(v3 + 988) & 0x40) == 0
          && (*(_WORD *)(v3 + 990) & 0x80) != 0
          && *(unsigned __int16 *)(v3 + 226) >= 4u
          && *(_DWORD *)(v3 + 164) - *(_DWORD *)(v3 + 160) - 10000 >= 1)
        {
          tcp_heuristic_tfo_middlebox(v3);
          *(_WORD *)(v6 + 378) = 96;
          user_north_signal_error(v6);
          v110 = *(void (***)(uint64_t))(v6 + 32);
          if (v110)
          {
            v111 = v110[3];
            if (!v111 || (v111(v6), (v110 = *(void (***)(uint64_t))(v6 + 32)) != 0))
            {
              v112 = *v110;
              if (v112)
                v112(v6);
            }
          }
        }
        v113 = *(_DWORD *)(v3 + 12);
        v114 = *(unsigned int *)(v3 + 228);
        v115 = (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2;
        if (v114 > v115)
          v115 = *(_DWORD *)(v3 + 228);
        v116 = *(unsigned __int16 *)(v3 + 226);
        if (v113 == 2)
        {
          v117 = v115 * tcp_syn_backoff[v116];
          *(_BYTE *)(v3 + 716) = v116;
          v118 = *(_DWORD *)(v3 + 740);
          if ((v118 & 0x1400000) == 0x400000)
          {
            v119 = 0;
            *(_DWORD *)(v3 + 740) = v118 & 0xFFBFFFFF;
            *(_BYTE *)(v3 + 988) |= 0x10u;
            goto LABEL_289;
          }
        }
        else
        {
          v117 = v115 * tcp_backoff[v116];
          if (v113 >= 4)
          {
            v119 = *(_DWORD *)(sysctls + 176);
            goto LABEL_289;
          }
        }
        v119 = 0;
LABEL_289:
        v120 = v119 + v117;
        *(_DWORD *)(v3 + 192) = v120;
        if (v120 >= v114)
        {
          if (v120 < 0xFA01)
            goto LABEL_293;
          LODWORD(v114) = 64000;
        }
        *(_DWORD *)(v3 + 192) = v114;
LABEL_293:
        *(_DWORD *)(v3 + 28) = *(_DWORD *)(v3 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 224)) + 316)
                             - *(_DWORD *)(v3 + 64);
        if ((*(_BYTE *)(*(_QWORD *)(v3 + 80) + 2231) & 0x50) != 0)
        {
LABEL_360:
          tcp_output(v3);
          return v3;
        }
        tcp_free_sackholes(v3);
        v121 = *(_DWORD *)(v3 + 740);
        if ((v121 & 0x20400020) == 0x20000020)
        {
          tcp_segs_clear_sacked(v3);
          tcp_rack_loss_on_rto(v3);
          v121 = *(_DWORD *)(v3 + 740);
        }
        if ((v121 & 0x20000) == 0)
        {
          v122 = *(_DWORD *)(v3 + 12);
          if (v122 != 4)
            goto LABEL_323;
          v123 = *(_DWORD *)(v3 + 88);
          if ((v123 & 0x4000000) == 0)
            goto LABEL_320;
          v124 = *(_DWORD *)(v3 + 156);
          v125 = sysctls;
          v126 = *(_DWORD *)(sysctls + 228);
          v127 = v126;
          if (v124 <= v126)
          {
            v128 = 148;
            if ((*(_BYTE *)(*(_QWORD *)(v3 + 80) + 2236) & 1) == 0)
              v128 = 152;
            v127 = *(_DWORD *)(sysctls + v128);
          }
          if (v127 < *(unsigned __int16 *)(v3 + 696) && *(_WORD *)(v3 + 226) == 2)
          {
            *(_DWORD *)(v3 + 88) = v123 & 0xDBFFFFFF | 0x20000000;
            v129 = *(_DWORD *)(v3 + 196) - v124;
            *(_WORD *)(v3 + 698) = v124;
            v130 = *(_DWORD *)(v8 + 316);
            if (v130 <= 1)
              v130 = 1;
            *(_DWORD *)(v3 + 700) = v130;
            if (v124 <= v126)
            {
              v131 = 148;
              if ((*(_BYTE *)(*(_QWORD *)(v3 + 80) + 2236) & 1) == 0)
                v131 = 152;
              v126 = *(_DWORD *)(v125 + v131);
            }
            *(_DWORD *)(v3 + 156) = v126;
            v132 = v129 + v126;
            *(_DWORD *)(v3 + 196) = v132;
            v133 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v3 + 264)] + 40);
            if (v133)
            {
              v133(v3);
              v132 = *(_DWORD *)(v3 + 196);
              v125 = sysctls;
            }
            *(_DWORD *)(v3 + 144) = v132;
            if (*(_DWORD *)(v125 + 308) == 1
              && (~*(_DWORD *)(v3 + 88) & 0x180) == 0
              && (*(_DWORD *)(v125 + 40) == 1 || (*(_BYTE *)(v6 + 369) & 0x40) != 0)
              && off_253CF8698)
            {
              off_253CF8698((_DWORD *)v3);
            }
          }
          else
          {
LABEL_320:
            if ((v123 & 0x20000000) != 0 && *(unsigned __int16 *)(v3 + 226) >= 5u)
            {
              tcp_pmtud_revert_segment_size(v3);
              *(_DWORD *)(v3 + 144) = *(_DWORD *)(v3 + 196);
            }
          }
        }
        v122 = *(_DWORD *)(v3 + 12);
LABEL_323:
        v134 = *(unsigned __int16 *)(v3 + 226);
        if (v122 == 2)
        {
          if (*(_DWORD *)(sysctls + 220) == v134)
            *(_DWORD *)(v3 + 88) &= 0xFFFFFF5F;
          if (v134 <= 2)
          {
            if (!v6 || (*(_BYTE *)(v6 + 828) & 2) == 0)
            {
              v135 = __nwlog_tcp_log();
              if (os_log_type_enabled(v135, OS_LOG_TYPE_INFO))
              {
                v136 = (const char *)(v6 + 604);
                v137 = *(unsigned __int16 *)(v3 + 226);
                *(_QWORD *)&buf[4] = "tcp_timers";
                *(_DWORD *)buf = 136446722;
                if (!v6)
                  v136 = "";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v136;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = v137;
                v138 = "%{public}s %{public}s retransmit SYN %u";
                v139 = v135;
                v140 = OS_LOG_TYPE_INFO;
                v141 = 28;
LABEL_342:
                _os_log_impl(&dword_209FB3000, v139, v140, v138, buf, v141);
                goto LABEL_343;
              }
            }
            goto LABEL_343;
          }
        }
        else if (v134 < 3)
        {
          goto LABEL_346;
        }
        if (!v6 || (*(_BYTE *)(v6 + 828) & 2) == 0)
        {
          v142 = __nwlog_tcp_log();
          if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
          {
            v143 = (const char *)(v6 + 604);
            v144 = "";
            v145 = *(_DWORD *)(v3 + 92);
            if (!v6)
              v143 = "";
            v33 = *(_DWORD *)(v3 + 12) == 2;
            v146 = *(unsigned __int16 *)(v3 + 226);
            *(_QWORD *)&buf[4] = "tcp_timers";
            *(_DWORD *)buf = 136447234;
            if (v33)
              v144 = " SYN";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v143;
            *(_WORD *)&buf[22] = 2082;
            *(_QWORD *)&buf[24] = v144;
            LOWORD(v158) = 1024;
            *(_DWORD *)((char *)&v158 + 2) = v145;
            HIWORD(v158) = 1024;
            LODWORD(v159) = v146;
            v138 = "%{public}s %{public}s retransmit%{public}s seq=%u %u";
            v139 = v142;
            v140 = OS_LOG_TYPE_DEFAULT;
            v141 = 44;
            goto LABEL_342;
          }
        }
LABEL_343:
        v134 = *(unsigned __int16 *)(v3 + 226);
        if (v134 >= 4)
        {
          *(_DWORD *)(v3 + 208) += *(int *)(v3 + 200) >> 5;
          *(_DWORD *)(v3 + 200) = 0;
          if ((*(_DWORD *)(v3 + 1872) & 0xFFFFFFFE) == 2)
          {
            *(_DWORD *)(v3 + 212) += *(int *)(v3 + 204) >> 5;
            *(_DWORD *)(v3 + 204) = 0;
          }
        }
LABEL_346:
        v147 = *(_DWORD *)(v3 + 88);
        *(_DWORD *)(v3 + 100) = *(_DWORD *)(v3 + 92);
        *(_DWORD *)(v3 + 152) = *(_DWORD *)(v3 + 96);
        *(_DWORD *)(v3 + 88) = v147 | 1;
        *(_DWORD *)(v3 + 172) = 0;
        if ((v147 & 0x200000) != 0)
        {
          if (v134 == 1)
          {
LABEL_351:
            v149 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v3 + 264)] + 88);
            if (v149)
            {
              if ((v149(v3), v150 = *(_DWORD *)(v3 + 740), (v150 & 0x10000000) != 0)
                || (v150 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
                || (~*(_DWORD *)(v3 + 348) & 0x300000) != 0)
              {
                v151 = *(_DWORD *)(v3 + 348);
                if ((~v151 & 3) == 0)
                  *(_DWORD *)(v3 + 348) = v151 | 8;
              }
            }
          }
        }
        else if (v134 == 1)
        {
          v148 = *(_QWORD *)(v3 + 1056);
          if (v148)
            ++*(_QWORD *)(v148 + 1608);
          goto LABEL_351;
        }
        *(_DWORD *)(v3 + 88) &= ~0x200000u;
        *(_DWORD *)(v3 + 8) = 0;
        *(_BYTE *)(v3 + 310) = 3;
        *(_DWORD *)(v3 + 288) = 0;
        *(_DWORD *)(v3 + 348) &= ~0x20u;
        *(_DWORD *)(v3 + 16) = 0;
        v152 = *(_DWORD *)(v3 + 740);
        *(_DWORD *)(v3 + 984) = 0;
        *(_DWORD *)(v3 + 628) = 0;
        *(_DWORD *)(v3 + 740) = v152 & 0xFFE7FFFF;
        goto LABEL_360;
      }
      if (v22 < 4u)
        goto LABEL_198;
LABEL_170:
      v74 = *(_QWORD *)(v3 + 1056);
      if ((*(_BYTE *)(v3 + 740) & 1) != 0)
      {
        if (v74)
          ++*(_QWORD *)(v74 + 496);
      }
      else if (v74)
      {
        ++*(_QWORD *)(v74 + 488);
      }
      v75 = *(_DWORD *)(v3 + 348) & 3;
      if (v22 < 0xCu)
        goto LABEL_184;
      v76 = *(_QWORD *)(v3 + 80);
      v77 = *(_QWORD **)(v76 + 448);
      if (v75 == 3)
      {
        if (!v77)
        {
          *(_WORD *)(v3 + 226) = 12;
LABEL_185:
          if (*(_DWORD *)(v3 + 12) == 4)
            tcp_heuristic_ecn_droprxmt(v3);
          goto LABEL_189;
        }
        v78 = *(_BYTE *)(v76 + 2236);
        v79 = v77 + 45;
        v80 = v77 + 93;
      }
      else
      {
        if (!v77)
        {
          *(_WORD *)(v3 + 226) = 12;
          goto LABEL_189;
        }
        v78 = *(_BYTE *)(v76 + 2236);
        v79 = v77 + 58;
        v80 = v77 + 106;
      }
      if ((v78 & 2) == 0)
        v80 = v79;
      ++*v80;
LABEL_184:
      *(_WORD *)(v3 + 226) = 12;
      if (v75 == 3)
        goto LABEL_185;
LABEL_189:
      if (*(_DWORD *)(v3 + 256))
        v81 = *(_DWORD *)(v3 + 256);
      else
        v81 = 60;
      v82 = v3;
      goto LABEL_262;
    case 4:
      v17 = sysctls;
      if (!*(_DWORD *)(sysctls + 36))
        return v3;
      v18 = *(_DWORD *)(v3 + 88);
      if ((v18 & 2) == 0)
        return v3;
      *(_DWORD *)(v3 + 32) = 0;
      *(_DWORD *)(v3 + 88) = v18 & 0xFFFFFFFC | 1;
      if (v18 < 0)
      {
        v19 = *(unsigned __int16 *)(v3 + 304);
        if (v19 >= 2 && *(_DWORD *)(v17 + 52) > (signed int)v19)
          ++*(_BYTE *)(v3 + 267);
        if (*(unsigned __int8 *)(v3 + 267) >= 6u)
        {
          *(_DWORD *)(v3 + 740) |= 0x10000u;
          *(_DWORD *)(v3 + 336) = *(_DWORD *)(v7 + 316);
          v20 = *(_QWORD *)(v3 + 1056);
          if (v20)
            ++*(_QWORD *)(v20 + 1624);
          *(_BYTE *)(v3 + 267) = 0;
          *(_DWORD *)(v3 + 340) = 0;
        }
        tcp_reset_stretch_ack(v3);
      }
      *(_WORD *)(v3 + 308) = 16;
      *(_DWORD *)(v3 + 744) = 0;
      v21 = *(_QWORD *)(v3 + 1056);
      if (v21)
        ++*(_QWORD *)(v21 + 56);
      ++*(_DWORD *)(v3 + 724);
      goto LABEL_360;
    case 5:
      v43 = *(_QWORD *)(v3 + 1056);
      if (v43)
        ++*(_QWORD *)(v43 + 504);
      if (*(_WORD *)(v3 + 226) != 12)
        goto LABEL_98;
      if (v10 <= 7199999)
      {
        v44 = *(unsigned int *)(v3 + 228);
        if (v44 <= (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2)
          LODWORD(v44) = (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2;
        if (v10 < 511 * (int)v44)
        {
LABEL_98:
          v45 = *(_DWORD *)(v3 + 316);
          if (!v45 || v45 - v9 > 0)
          {
            tcp_setpersist(v3);
            *(_DWORD *)(v3 + 740) |= 0x8000u;
            tcp_output(v3);
            *(_DWORD *)(v3 + 740) &= ~0x8000u;
            return v3;
          }
        }
      }
      if (v43)
        ++*(_QWORD *)(v43 + 512);
      goto LABEL_261;
    case 6:
      v46 = *(_QWORD *)(v3 + 1056);
      if (v46)
        ++*(_QWORD *)(v46 + 520);
      v47 = *(_DWORD *)(v3 + 12);
      if (v47 <= 3)
      {
        if (v47 != 1 || v6 && (*(_BYTE *)(v6 + 828) & 2) != 0)
          goto LABEL_259;
        __nwlog_tcp_log();
        if (v6)
          v48 = (const char *)(v6 + 604);
        else
          v48 = "";
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_timers";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v48;
        v49 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        if (!__nwlog_fault())
          goto LABEL_257;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v50 = __nwlog_tcp_log();
          v51 = type[0];
          if (!os_log_type_enabled(v50, type[0]))
            goto LABEL_257;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "tcp_timers";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v48;
          v52 = "%{public}s %{public}s TCP listener failed to receive inbound connection within timeout, dropping connection";
        }
        else
        {
          v50 = __nwlog_tcp_log();
          v51 = type[0];
          if (!os_log_type_enabled(v50, type[0]))
            goto LABEL_257;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "tcp_timers";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v48;
          v52 = "%{public}s %{public}s TCP listener failed to receive inbound connection within timeout, dropping connect"
                "ion, backtrace limit exceeded";
        }
        _os_log_impl(&dword_209FB3000, v50, v51, v52, buf, 0x16u);
LABEL_257:
        if (v49)
          free(v49);
        goto LABEL_259;
      }
      v53 = *(_QWORD *)(v3 + 80);
      v54 = *(_QWORD *)(v53 + 224);
      v55 = *(_DWORD *)(v54 + 372);
      if ((v55 & 8) == 0 && (*(_BYTE *)(v3 + 740) & 0x80) == 0 && *(_BYTE *)(v3 + 993) != 1
        || (v47 - 4) >= 4 && v47 != 9)
      {
        v66 = *(_DWORD *)(nw_tcp_access_globals(v54) + 316);
        v67 = *(_DWORD *)(v3 + 676);
        if (!v67 || (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 224) + 372) & 8) == 0)
          v67 = *(_DWORD *)(sysctls + 192);
LABEL_155:
        *(_DWORD *)(v3 + 40) = v67 + v66 - *(_DWORD *)(v3 + 64);
        if (v5)
        {
          if ((*(_BYTE *)(v5 + 1052) & 8) != 0 && *(unsigned __int8 *)(v3 + 311) >= 5u)
          {
            if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 224) + 24))
            {
              v69 = nw_protocol_tcp_get_all_stats();
              if (v69)
                *(_BYTE *)(v69 + 96) |= 4u;
            }
          }
        }
        v70 = *(_DWORD *)(v3 + 740);
        if ((v70 & 0x80) == 0)
          goto LABEL_235;
        if (*(_BYTE *)(v3 + 265))
        {
          v71 = *(unsigned __int8 *)(v3 + 311);
          if (v71 > *(unsigned __int8 *)(v3 + 265))
          {
            if (v6)
            {
              v72 = *(_QWORD *)(v6 + 32);
              if (v72)
              {
                v73 = *(void (**)(uint64_t))(v72 + 72);
                if (v73)
                  v73(v6);
              }
            }
            tcp_keepalive_reset(v3);
            goto LABEL_235;
          }
        }
        else if (!v5 || (*(_BYTE *)(v5 + 1052) & 8) == 0 || (v71 = *(unsigned __int8 *)(v3 + 311), v71 >= 6))
        {
          *(_DWORD *)(v3 + 740) = v70 & 0xFFFFFF7F;
LABEL_235:
          v92 = *(unsigned __int8 *)(v3 + 993);
          if (v92 == 1)
          {
            v93 = ++*(_BYTE *)(v3 + 992);
            if (v93 >= 0xC)
              v94 = 12;
            else
              v94 = v93;
            v95 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 224)) + 316);
            v96 = tcp_backoff[v94];
            v97 = *(unsigned int *)(v3 + 228);
            if (v97 <= (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2)
              LODWORD(v97) = (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2;
            v98 = v95 - *(_DWORD *)(v3 + 64) + v97 * v96;
            v99 = *(_DWORD *)(v3 + 40);
            if (v98 < v99)
            {
              v100 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 224)) + 316);
              v101 = *(unsigned int *)(v3 + 228);
              if (v101 <= (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2)
                LODWORD(v101) = (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2;
              v99 = v100 - *(_DWORD *)(v3 + 64) + v101 * v96;
            }
            *(_DWORD *)(v3 + 40) = v99;
          }
          else if ((*(_BYTE *)(v3 + 743) & 1) == 0 && v92 == 2 && (*(_BYTE *)(v3 + 988) & 0x40) == 0)
          {
            tcp_heuristic_tfo_middlebox(v3);
            *(_WORD *)(v6 + 378) = 96;
            user_north_signal_error(v6);
            v102 = *(_QWORD *)(v6 + 32);
            if (v102)
            {
              v103 = *(void (**)(uint64_t))(v102 + 24);
              if (v103)
                v103(v6);
            }
            *(_WORD *)(v3 + 990) |= 0x2000u;
            v104 = *(_QWORD *)(v3 + 1056);
            if (v104)
              ++*(_QWORD *)(v104 + 1144);
          }
          return v3;
        }
        if (v71 >= 0xC)
          v89 = 12;
        else
          v89 = v71;
        v90 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 224));
        v91 = *(unsigned int *)(v3 + 228);
        if (v91 <= (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2)
          LODWORD(v91) = (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2;
        *(_DWORD *)(v3 + 40) = *(_DWORD *)(v90 + 316) - *(_DWORD *)(v3 + 64) + v91 * tcp_backoff[v89];
        goto LABEL_235;
      }
      if ((v55 & 8) != 0 && (v56 = *(_DWORD *)(v3 + 676)) != 0)
      {
        v57 = *(_DWORD *)(v3 + 688);
        if (v57)
          goto LABEL_122;
      }
      else
      {
        v56 = *(_DWORD *)(sysctls + 192);
        v57 = *(_DWORD *)(v3 + 688);
        if (v57)
        {
LABEL_122:
          v58 = *(_DWORD *)(v3 + 684);
          if (v58)
            goto LABEL_123;
          goto LABEL_139;
        }
      }
      v57 = *(_DWORD *)(sysctls + 200);
      v58 = *(_DWORD *)(v3 + 684);
      if (v58)
        goto LABEL_123;
LABEL_139:
      v58 = *(_DWORD *)(sysctls + 196);
LABEL_123:
      if (v10 < v56 + v58 * v57)
      {
        v158 = 0;
        memset(buf, 0, sizeof(buf));
        *(_QWORD *)type = 0x1000000000;
        if (v46)
          ++*(_QWORD *)(v46 + 528);
        if ((*(_BYTE *)(v53 + 2236) & 2) != 0)
          v59 = in6_pseudo();
        else
          v59 = in_pseudo();
        v160 = v59;
        HIDWORD(v68) = *(_DWORD *)(v53 + 2224);
        LODWORD(v68) = HIDWORD(v68);
        *(_QWORD *)&v159 = (v68 >> 16);
        *((_QWORD *)&v159 + 1) = 0x5000000000;
        v161 = 0;
        tcp_respond(v3, &v159, 0, *(_DWORD *)(v3 + 120), *(_DWORD *)(v3 + 92) - 1, 0, (uint64_t)type);
        if ((*(_BYTE *)(v3 + 740) & 0x80) != 0)
          ++*(_BYTE *)(v3 + 311);
        v66 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 224)) + 316);
        v67 = *(_DWORD *)(v3 + 684);
        if (!v67)
          v67 = *(_DWORD *)(sysctls + 196);
        goto LABEL_155;
      }
      if (!v6 || (*(_BYTE *)(v6 + 828) & 2) == 0)
      {
        v64 = __nwlog_tcp_log();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
        {
          v65 = "";
          if (v6)
            v65 = (const char *)(v6 + 604);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "tcp_timers";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v65;
          _os_log_impl(&dword_209FB3000, v64, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s dropping connection on keepalive timeout", buf, 0x16u);
        }
      }
LABEL_259:
      v105 = *(_QWORD *)(v3 + 1056);
      if (v105)
        ++*(_QWORD *)(v105 + 536);
LABEL_261:
      v82 = v3;
      v81 = 60;
LABEL_262:
      tcp_drop(v82, v81);
      return 0;
    case 7:
      v28 = *(_QWORD **)(v3 + 544);
      if (!v28)
        goto LABEL_56;
      break;
    default:
      return v3;
  }
  while (1)
  {
    v29 = v28[2];
    if (*(_QWORD **)(v3 + 616) == v28)
    {
      *(_QWORD *)(v3 + 616) = v29;
      v30 = (_QWORD *)v28[3];
      if (v29)
      {
LABEL_50:
        *(_QWORD *)(v29 + 24) = v30;
        v30 = (_QWORD *)v28[3];
        goto LABEL_53;
      }
    }
    else
    {
      v30 = (_QWORD *)v28[3];
      if (v29)
        goto LABEL_50;
    }
    *(_QWORD *)(v3 + 552) = v30;
LABEL_53:
    *v30 = v29;
    nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 224));
    free(v28);
    --*(_WORD *)(v3 + 538);
    do
      v31 = __ldxr(tcp_sack_globalholes);
    while (__stxr(v31 - 1, tcp_sack_globalholes));
    v28 = *(_QWORD **)(v3 + 544);
    if (!v28)
    {
LABEL_56:
      *(_OWORD *)(v3 + 616) = 0u;
      v32 = *(_DWORD *)(v3 + 12);
      v33 = v32 == 10 || v32 == 9;
      if (v33 || v10 < 1)
        goto LABEL_367;
      v60 = *(_DWORD *)(v3 + 688);
      if (!v60)
        v60 = *(_DWORD *)(sysctls + 200);
      v61 = *(_DWORD *)(v3 + 684);
      if (!v61)
        v61 = *(_DWORD *)(sysctls + 196);
      if (v10 >= v61 * v60)
      {
LABEL_367:
        if (!v6 || (*(_BYTE *)(v6 + 828) & 2) == 0)
        {
          v35 = __nwlog_tcp_log();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            v36 = "";
            if (v6)
              v36 = (const char *)(v6 + 604);
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "tcp_timers";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v36;
            _os_log_impl(&dword_209FB3000, v35, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s dropping connection on 2 MSL timeout", buf, 0x16u);
          }
        }
        tcp_close(v3);
        return 0;
      }
      else
      {
        v62 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 224)) + 316);
        v63 = *(_DWORD *)(v3 + 684);
        if (!v63)
          v63 = *(_DWORD *)(sysctls + 196);
        *(_DWORD *)(v3 + 44) = v63 + v62 - *(_DWORD *)(v3 + 64);
      }
      return v3;
    }
  }
}

uint64_t nw_protocol_tcp_waiting_for_output(uint64_t a1)
{
  uint64_t v1;
  void *v3;
  NSObject *v4;
  const char *v5;
  uint8_t buf[4];
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = nw_protocol_downcast();
    if (v1)
      return (*(unsigned __int8 *)(v1 + 5308) >> 5) & 1;
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v7 = "nw_protocol_tcp_waiting_for_output";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v7 = "nw_protocol_tcp_waiting_for_output";
        v5 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_12;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v7 = "nw_protocol_tcp_waiting_for_output";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v7 = "nw_protocol_tcp_waiting_for_output";
        v5 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_12:
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_ERROR, v5, buf, 0xCu);
      }
    }
  }
  if (v3)
    free(v3);
  return 0;
}

uint64_t tcp_output(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  char v6;
  int v7;
  int v8;
  int v9;
  void (*v10)(uint64_t);
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  unsigned int *v32;
  unsigned int v33;
  int v34;
  int v35;
  _BOOL4 v36;
  int v37;
  int v38;
  int v39;
  int v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  int v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  int v53;
  int v54;
  uint64_t v55;
  int v56;
  int v57;
  int v58;
  BOOL v59;
  unsigned int v60;
  int *v61;
  _BOOL4 v62;
  int v63;
  int v64;
  int v65;
  int v66;
  unsigned int v67;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  NSObject *v72;
  _BOOL4 v73;
  const char *v74;
  uint64_t v75;
  NSObject *v76;
  _BOOL4 v77;
  const char *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unsigned __int16 v82;
  unsigned int v83;
  unsigned __int16 v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  int v92;
  uint64_t v95;
  uint64_t v96;
  unsigned int v97;
  int v98;
  int v99;
  int v100;
  uint64_t v101;
  int v102;
  int v103;
  int v104;
  unsigned int v105;
  int v106;
  int v107;
  BOOL v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  unint64_t v121;
  int v122;
  uint64_t v123;
  uint64_t v124;
  char v125;
  int v126;
  unsigned int v127;
  int v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  unsigned int v132;
  uint64_t v133;
  unint64_t v134;
  unsigned int v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t all_stats;
  unsigned int v139;
  uint64_t v140;
  int v141;
  int v142;
  _BOOL4 v143;
  _DWORD *v145;
  unsigned int v146;
  int v147;
  int v148;
  uint64_t v149;
  int v150;
  int v151;
  int v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  int v156;
  unsigned int v157;
  unsigned int v158;
  uint64_t v159;
  unsigned int v160;
  unsigned int v161;
  unsigned int v162;
  int v163;
  int v164;
  int v165;
  char v166;
  int v167;
  int v168;
  int v169;
  uint64_t v170;
  uint64_t v171;
  int v172;
  uint64_t v173;
  int v174;
  int v175;
  int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  unsigned int v181;
  int v182;
  int v183;
  int v184;
  int v185;
  int v186;
  int v187;
  int v188;
  int v189;
  int v190;
  unsigned int v191;
  uint64_t v192;
  char v193;
  int v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  unsigned int v198;
  unsigned int v199;
  unsigned int v200;
  _DWORD *v201;
  unsigned int v202;
  int v203;
  int v204;
  unsigned int v205;
  int v206;
  uint64_t v207;
  uint64_t v208;
  unsigned int v209;
  unsigned int v210;
  char *v211;
  char v212;
  int v213;
  uint64_t v214;
  _BOOL4 v215;
  uint64_t v216;
  unsigned int v217;
  _QWORD *v218;
  unsigned int v219;
  char *v220;
  uint64_t v221;
  uint64_t v222;
  int v223;
  uint64_t v224;
  uint64_t v225;
  unsigned int v226;
  unsigned int v227;
  int v228;
  int v230;
  unsigned int v231;
  int v232;
  _BOOL4 v233;
  int v234;
  int v236;
  uint64_t v238;
  unsigned __int8 v239;
  int v240;
  _DWORD *v241;
  unsigned int v242;
  NSObject *v243;
  const char *v244;
  NSObject *v245;
  const char *v246;
  _BYTE *v247;
  int v248;
  uint64_t v249;
  int v250;
  unsigned int v251;
  uint64_t v252;
  int v253;
  int8x8_t *v254;
  unsigned int v255;
  BOOL v256;
  unsigned int v257;
  int v258;
  NSObject *v259;
  const char *v260;
  int v261;
  BOOL v262;
  unsigned int v263;
  int v264;
  NSObject *v265;
  const char *v266;
  uint64_t v267;
  uint64_t v268;
  const float *v269;
  uint64_t v270;
  int8x8_t *v271;
  int8x8_t v272;
  uint64_t v273;
  int v274;
  unsigned int v275;
  char v276;
  char v277;
  int v278;
  BOOL v279;
  int v280;
  int v281;
  _BOOL4 v282;
  int v283;
  BOOL v285;
  unsigned int v286;
  _BOOL4 v287;
  uint64_t v288;
  int v289;
  int v290;
  uint64_t v291;
  uint64_t v292;
  char v293;
  BOOL v294;
  BOOL v295;
  int v296;
  uint64_t v297;
  NSObject *v298;
  unsigned int v299;
  int v300;
  int v301;
  int v302;
  int v303;
  int v304;
  uint64_t v305;
  unsigned int v306;
  unsigned int v307;
  _DWORD *v309;
  unsigned int v310;
  unsigned int v311;
  BOOL v313;
  int v314;
  int v315;
  int v316;
  int v317;
  unsigned int v318;
  uint64_t v319;
  _QWORD *v320;
  uint64_t v321;
  _QWORD *v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  unsigned int v331;
  unsigned int v332;
  int v333;
  NSObject *v334;
  int v335;
  uint64_t v336;
  int v337;
  unsigned int v338;
  int v339;
  NSObject *v340;
  _BOOL4 v341;
  size_t v342;
  size_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  unsigned int v347;
  BOOL v348;
  unsigned int v349;
  uint64_t v350;
  uint64_t v351;
  NSObject *v352;
  os_log_type_t v353;
  uint64_t v354;
  NSObject *v355;
  os_log_type_t v356;
  const char *v357;
  unsigned int v358;
  uint64_t v359;
  uint64_t v360;
  int v361;
  unsigned int v362;
  int v363;
  NSObject *v364;
  _BOOL4 v365;
  size_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  unsigned int v370;
  unsigned int v371;
  uint64_t v372;
  uint64_t v373;
  NSObject *v374;
  os_log_type_t v375;
  uint64_t v376;
  NSObject *v377;
  os_log_type_t v378;
  const char *v379;
  void *v380;
  NSObject *v381;
  os_log_type_t v382;
  _BOOL4 v383;
  uint64_t v384;
  void *v385;
  NSObject *v386;
  os_log_type_t v387;
  NSObject *v388;
  os_log_type_t v389;
  const char *v390;
  void *v391;
  NSObject *v392;
  os_log_type_t v393;
  _BOOL4 v394;
  uint64_t v395;
  NSObject *v396;
  os_log_type_t v397;
  uint64_t v398;
  void *v399;
  NSObject *v400;
  os_log_type_t v401;
  _BOOL4 v402;
  uint64_t v403;
  NSObject *v404;
  os_log_type_t v405;
  uint64_t v406;
  uint64_t v407;
  unsigned int v408;
  unsigned int v409;
  NSObject *v410;
  int v411;
  int v412;
  uint64_t v413;
  uint64_t v414;
  float *v416;
  uint64_t v417;
  const float *v418;
  float *v419;
  BOOL v420;
  unsigned int v421;
  int v422;
  NSObject *v423;
  const char *v424;
  uint64_t v425;
  unsigned int v426;
  unsigned int v427;
  NSObject *v428;
  int v429;
  int v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  __int16 v436;
  uint64_t v437;
  uint64_t v438;
  void *v439;
  NSObject *v440;
  os_log_type_t v441;
  NSObject *v442;
  os_log_type_t v443;
  const char *v444;
  void *v445;
  NSObject *v446;
  os_log_type_t v447;
  _BOOL4 v448;
  NSObject *v449;
  os_log_type_t v450;
  uint64_t v451;
  __int16 v452;
  unint64_t v453;
  int v454;
  int v455;
  int v456;
  __int16 v457;
  kern_return_t v458;
  kern_return_t v459;
  NSObject *v460;
  int v461;
  char v462;
  char v463;
  int v464;
  unsigned int v465;
  int v466;
  int v467;
  int v468;
  int v469;
  unsigned int v470;
  char v471;
  unsigned int v472;
  int v473;
  int v474;
  uint64_t v475;
  uint64_t v476;
  int v477;
  char v478;
  uint64_t (*v479)(uint64_t, uint64_t, _QWORD, _QWORD);
  char v480;
  int v481;
  int v482;
  NSObject *v483;
  int v484;
  int v485;
  unsigned int v486;
  int v487;
  int v488;
  int v489;
  uint64_t v490;
  unsigned int v491;
  unsigned int v492;
  int v493;
  unsigned int v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  int v498;
  int v499;
  int v500;
  int v501;
  int v502;
  int v503;
  uint64_t v504;
  int v505;
  int v506;
  int v507;
  uint64_t v508;
  int v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t *v512;
  int v513;
  int v514;
  int v515;
  unsigned int v516;
  unsigned int v517;
  unsigned int v518;
  int v519;
  char v520;
  int v521;
  void *v522;
  NSObject *v523;
  os_log_type_t v524;
  int v525;
  NSObject *v526;
  os_log_type_t v527;
  const char *v528;
  unint64_t v529;
  uint64_t v530;
  _QWORD *v531;
  unint64_t v532;
  uint64_t v533;
  _QWORD *v534;
  unint64_t v535;
  unint64_t v536;
  int v537;
  unint64_t v538;
  unint64_t v539;
  unint64_t v540;
  int v541;
  unint64_t v542;
  uint64_t v543;
  void *v544;
  void *v545;
  NSObject *v546;
  os_log_type_t v547;
  _BOOL4 v548;
  int v549;
  int v550;
  unint64_t v551;
  unint64_t v552;
  int v553;
  unint64_t *v554;
  uint64_t v555;
  void *v556;
  NSObject *v557;
  int v558;
  int v559;
  unint64_t v560;
  unint64_t *v561;
  uint64_t v562;
  unint64_t v563;
  uint64_t v564;
  unint64_t v565;
  unint64_t v566;
  int v567;
  unint64_t v568;
  unint64_t v569;
  int v570;
  unint64_t *v571;
  NSObject *v572;
  int v573;
  int v574;
  NSObject *v575;
  os_log_type_t v576;
  int v577;
  unint64_t *v578;
  int v579;
  int v580;
  char v581;
  int v582;
  int v583;
  uint64_t v584;
  _QWORD *v585;
  _QWORD *v586;
  _QWORD *v587;
  int v588;
  uint64_t v589;
  NSObject *v590;
  os_log_type_t v591;
  unint64_t v592;
  uint64_t v593;
  _QWORD *v594;
  uint64_t v595;
  uint64_t v596;
  uint64_t v597;
  uint64_t v598;
  uint64_t v599;
  int v600;
  int v601;
  uint64_t v602;
  NSObject *v603;
  os_log_type_t v604;
  uint64_t v605;
  int v606;
  int v607;
  NSObject *v608;
  os_log_type_t v609;
  const char *v610;
  NSObject *v611;
  void *v612;
  NSObject *v613;
  int v614;
  unsigned int v615;
  unsigned int v616;
  unsigned int v617;
  int v618;
  int v619;
  int v620;
  NSObject *v621;
  os_log_type_t v622;
  NSObject *v623;
  int v624;
  unsigned int v625;
  unsigned int v626;
  unsigned int v627;
  int v628;
  int v629;
  int v630;
  void *v631;
  NSObject *v632;
  os_log_type_t v633;
  _BOOL4 v634;
  uint64_t v635;
  int v636;
  int v637;
  int v638;
  void *v639;
  NSObject *v640;
  os_log_type_t v641;
  int v642;
  NSObject *v643;
  os_log_type_t v644;
  const char *v645;
  void *v646;
  NSObject *v647;
  os_log_type_t v648;
  NSObject *v649;
  os_log_type_t v650;
  const char *v651;
  int v652;
  int v653;
  int v654;
  uint64_t v655;
  int v656;
  _QWORD *v657;
  void *v658;
  NSObject *v659;
  os_log_type_t v660;
  _BOOL4 v661;
  int v662;
  NSObject *v663;
  os_log_type_t v664;
  uint64_t v665;
  int v666;
  int v667;
  void *v668;
  NSObject *v669;
  os_log_type_t v670;
  _BOOL4 v671;
  uint64_t v672;
  int v673;
  int v674;
  NSObject *v675;
  os_log_type_t v676;
  int v677;
  void *v678;
  NSObject *v679;
  os_log_type_t v680;
  NSObject *v681;
  os_log_type_t v682;
  const char *v683;
  int v684;
  int64x2_t *v685;
  NSObject *v686;
  os_log_type_t v687;
  NSObject *v688;
  const char *v689;
  void *v690;
  NSObject *v691;
  os_log_type_t v692;
  NSObject *v693;
  os_log_type_t v694;
  const char *v695;
  void *v696;
  NSObject *v697;
  os_log_type_t v698;
  _BOOL4 v699;
  void *v700;
  NSObject *v701;
  os_log_type_t v702;
  NSObject *v703;
  os_log_type_t v704;
  const char *v705;
  void *v706;
  NSObject *v707;
  os_log_type_t v708;
  _BOOL4 v709;
  NSObject *v710;
  os_log_type_t v711;
  void *v712;
  NSObject *v713;
  os_log_type_t v714;
  NSObject *v715;
  os_log_type_t v716;
  const char *v717;
  void *v718;
  NSObject *v719;
  os_log_type_t v720;
  _BOOL4 v721;
  NSObject *v722;
  os_log_type_t v723;
  int v724;
  int v725;
  void *v726;
  void *v727;
  NSObject *v728;
  os_log_type_t v729;
  _BOOL4 v730;
  NSObject *v731;
  os_log_type_t v732;
  NSObject *v733;
  os_log_type_t v734;
  char v735;
  int v736;
  char v737;
  int v738;
  int v739;
  int v740;
  _QWORD *v741;
  int v742;
  char *v743;
  const char *v744;
  void *v745;
  NSObject *v746;
  os_log_type_t v747;
  const char *v748;
  int v749;
  char *v750;
  const char *v751;
  uint64_t v752;
  _QWORD *v753;
  NSObject *v754;
  void (*v755)(uint64_t, _QWORD, uint64_t);
  uint64_t v756;
  NSObject *v757;
  void (*v758)(uint64_t, _QWORD, uint64_t);
  uint64_t v759;
  uint64_t v760;
  _QWORD *v761;
  void (*v762)(_QWORD *, _QWORD, uint64_t);
  uint64_t v763;
  uint64_t v764;
  NSObject *v765;
  os_log_type_t v766;
  const char *v767;
  _BOOL4 v768;
  os_log_t v769;
  void *v770;
  _BOOL4 v771;
  const char *v772;
  int v773;
  char *v774;
  int v775;
  int v776;
  const char *v777;
  int v778;
  char *v779;
  _BYTE *v780;
  const char *v781;
  int v782;
  char *v783;
  char v784;
  void *v785;
  NSObject *v786;
  os_log_type_t numer;
  const char *v788;
  NSObject *v789;
  void *v790;
  NSObject *v791;
  os_log_type_t v792;
  const char *v793;
  NSObject *v794;
  void (*v795)(uint64_t, _QWORD, uint64_t);
  uint64_t v796;
  void *backtrace_string;
  NSObject *v798;
  os_log_type_t v799;
  _BOOL4 v800;
  const char *v801;
  _BOOL4 v802;
  void *v803;
  NSObject *v804;
  os_log_type_t v805;
  _BOOL4 v806;
  NSObject *v807;
  os_log_type_t v808;
  NSObject *v809;
  _QWORD *v810;
  uint64_t v811;
  _QWORD *v812;
  void (*v813)(_QWORD *, _QWORD, uint64_t);
  uint64_t v814;
  uint64_t v815;
  NSObject *v816;
  os_log_type_t v817;
  const char *v818;
  _BOOL4 v819;
  NSObject *v820;
  os_log_type_t v821;
  int v822;
  void *v824;
  NSObject *v825;
  os_log_type_t v826;
  const char *v827;
  void *v828;
  NSObject *v829;
  os_log_type_t v830;
  _BOOL4 v831;
  void *v832;
  _BOOL4 v833;
  void *v834;
  NSObject *v835;
  os_log_type_t v836;
  const char *v837;
  void *v838;
  NSObject *v839;
  os_log_type_t v840;
  _BOOL4 v841;
  void *v842;
  _BOOL4 v843;
  NSObject *v844;
  os_log_type_t v845;
  NSObject *v846;
  os_log_type_t v847;
  void *v848;
  NSObject *v849;
  os_log_type_t v850;
  const char *v851;
  void *v852;
  NSObject *v853;
  os_log_type_t v854;
  _BOOL4 v855;
  NSObject *v856;
  os_log_type_t v857;
  NSObject *v858;
  char *v859;
  void (*v860)(uint64_t, _QWORD, uint64_t);
  uint64_t v861;
  void *v862;
  NSObject *v863;
  os_log_type_t v864;
  const char *v865;
  void *v866;
  NSObject *v867;
  os_log_type_t v868;
  _BOOL4 v869;
  NSObject *v870;
  os_log_type_t v871;
  NSObject *log;
  os_log_t v873;
  NSObject *v874;
  NSObject *v875;
  NSObject *v876;
  int v877;
  char v878;
  unint64_t v879;
  uint64_t v880;
  unsigned int v881;
  unsigned int v882;
  int v883;
  unsigned int v884;
  uint64_t v885;
  uint64_t v886;
  unint64_t *v887;
  int v888;
  int v889;
  int v890;
  unsigned int *v891;
  int v892;
  int v893;
  unsigned int *v894;
  _BOOL4 v895;
  char v896;
  _BOOL4 v897;
  uint64_t v898;
  int v899;
  int v900;
  unsigned int v901;
  int v902;
  int *v903;
  int v904;
  int v905;
  int v906;
  int v907;
  unsigned int *type;
  os_log_type_t typea;
  signed int v910;
  os_log_t v911;
  NSObject *v912;
  os_log_type_t v913;
  NSObject *v914;
  os_log_type_t v915;
  uint64_t v916;
  int v917;
  os_log_t v918;
  int v919;
  int v920;
  os_log_t v921;
  NSObject *v922;
  NSObject *v923;
  NSObject *v924;
  os_log_t v925;
  NSObject *v926;
  os_log_type_t v927;
  int v928;
  void *v929;
  os_log_type_t v930;
  NSObject *v931;
  os_log_type_t v932;
  _BYTE *v933;
  NSObject *v934;
  void *v935;
  NSObject *v936;
  int v937;
  unsigned int v938;
  unsigned int v939;
  unsigned int v940;
  void *v941;
  _QWORD *v942;
  mach_timebase_info info;
  mach_timebase_info *p_info;
  char v945;
  os_log_type_t v946;
  _BYTE buf[24];
  _BYTE v948[28];
  char *v949;
  _DWORD v950[3];
  _WORD __src[2];
  unsigned int v952;
  uint64_t v953;
  float32x4x2_t v954;
  float32x4x2_t v955;
  float32x4x2_t v956;

  v953 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 80);
  v3 = v2[28];
  v892 = *(_DWORD *)(v3 + 600);
  v4 = nw_tcp_access_globals(v3);
  v900 = *((_BYTE *)v2 + 2236) & 2;
  v5 = *(_DWORD *)(a1 + 88);
  if ((v5 & 0x100000) != 0)
  {
    v903 = (int *)(v4 + 316);
    goto LABEL_5;
  }
  v903 = (int *)(v4 + 316);
  if (*(_DWORD *)(a1 + 96) == *(_DWORD *)(a1 + 92))
  {
LABEL_5:
    v7 = *(_DWORD *)(v4 + 316) - *(_DWORD *)(a1 + 160);
    if (*(int *)(a1 + 12) <= 3)
      v8 = *(_DWORD *)(sysctls + 176);
    else
      v8 = 0;
    if (v7 >= *(_DWORD *)(a1 + 192) + v8)
    {
      v9 = *(unsigned __int8 *)(a1 + 264);
      v10 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 80);
      if (v10 && (v9 != 3 && v9 != 4 || v7 > 179999))
        v10(a1);
      v11 = *(_QWORD **)(a1 + 952);
      if (v11)
      {
        v12 = (_QWORD *)(a1 + 952);
        do
        {
          v14 = (_QWORD *)*v12;
          v15 = (_QWORD *)(a1 + 952);
          if ((_QWORD *)*v12 != v11)
          {
            do
            {
              v16 = v14;
              v14 = (_QWORD *)v14[2];
            }
            while (v14 != v11);
            v15 = v16 + 2;
          }
          v13 = (_QWORD *)v11[2];
          *v15 = v13;
          nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
          free(v11);
          v11 = v13;
        }
        while (v13);
        *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
      }
      if ((*(_BYTE *)(a1 + 742) & 1) != 0)
      {
        v17 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316)
            - *(_DWORD *)(a1 + 336);
        if (v17 < 0)
          v17 = -v17;
        if (v17 >= 0xDBBA1)
        {
          *(_DWORD *)(a1 + 740) &= ~0x10000u;
          *(_BYTE *)(a1 + 267) = 0;
          *(_DWORD *)(a1 + 88) &= 0x7DFFFFFFu;
          *(_QWORD *)(a1 + 328) = 0;
          *(_DWORD *)(a1 + 324) = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316)
                                + 100;
          *(_DWORD *)(a1 + 740) |= 2u;
          *(_WORD *)(a1 + 344) = 0;
        }
      }
      *(_WORD *)(a1 + 308) = 16;
      v5 = *(_DWORD *)(a1 + 88);
    }
    v6 = 1;
    goto LABEL_28;
  }
  v6 = 0;
LABEL_28:
  v893 = 0;
  v890 = 0;
  v898 = 0;
  v899 = 0;
  v888 = 0;
  v884 = 0;
  v18 = 0;
  v901 = 0;
  v19 = v5 & 0xFFEFFFFF;
  v20 = *(_DWORD *)&v6 & ((v5 & 0x10000u) >> 16);
  if (v20)
    v21 = 0x100000;
  else
    v21 = 0;
  v878 = v20 ^ v6;
  *(_DWORD *)(a1 + 88) = v19 | v21;
  type = (unsigned int *)(a1 + 100);
  v894 = (unsigned int *)(a1 + 940);
  v880 = v3 + 604;
  if (v900)
    v22 = -40;
  else
    v22 = -20;
  v883 = v22;
  if (v900)
    v23 = 40;
  else
    v23 = 20;
  if (v900)
    v24 = 56;
  else
    v24 = 36;
  v881 = v24;
  v882 = v23;
  v25 = (_QWORD *)(a1 + 632);
  v879 = a1 + 568;
  v26 = 17;
  if (v900)
  {
    v27 = 18;
  }
  else
  {
    v26 = 15;
    v27 = 16;
  }
  v885 = 8 * v27;
  v886 = 8 * v26;
  v887 = (unint64_t *)(a1 + 2000);
  v942 = (_QWORD *)(a1 + 632);
  v916 = v3;
  v933 = v2;
  while (1)
  {
    *(_DWORD *)(a1 + 88) &= ~0x10000000u;
    if (!*(_QWORD *)(v3 + 24))
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_path_is_viable";
      v785 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v946 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault())
        goto LABEL_1740;
      if (LOBYTE(info.numer) == 17)
      {
        v786 = __nwlog_obj();
        numer = info.numer;
        if (!os_log_type_enabled(v786, info.numer))
          goto LABEL_1740;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v788 = "%{public}s called with null protocol";
LABEL_1738:
        v807 = v786;
        v808 = numer;
LABEL_1739:
        _os_log_impl(&dword_209FB3000, v807, v808, v788, buf, 0xCu);
        goto LABEL_1740;
      }
      if (v946 == OS_LOG_TYPE_DEFAULT)
      {
        v786 = __nwlog_obj();
        numer = info.numer;
        if (!os_log_type_enabled(v786, info.numer))
          goto LABEL_1740;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v788 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_1738;
      }
      backtrace_string = (void *)__nw_create_backtrace_string();
      v798 = __nwlog_obj();
      v799 = info.numer;
      v800 = os_log_type_enabled(v798, info.numer);
      if (backtrace_string)
      {
        if (v800)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_path_is_viable";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          v801 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_1726:
          _os_log_impl(&dword_209FB3000, v798, v799, v801, buf, 0x16u);
        }
LABEL_1727:
        free(backtrace_string);
        goto LABEL_1740;
      }
      if (v800)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v788 = "%{public}s called with null protocol, no backtrace";
LABEL_1780:
        v807 = v798;
        v808 = v799;
        goto LABEL_1739;
      }
LABEL_1740:
      if (v785)
        free(v785);
      v25 = (_QWORD *)(a1 + 632);
LABEL_1743:
      if (*(int *)(a1 + 12) >= 5)
      {
        v508 = 49;
        tcp_drop(a1, 49);
        return v508;
      }
      if ((*(_BYTE *)(v3 + 828) & 2) == 0)
      {
        v809 = __nwlog_tcp_log();
        if (os_log_type_enabled(v809, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v880;
          _os_log_impl(&dword_209FB3000, v809, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s path is non-viable, dropping output", buf, 0x16u);
        }
      }
      if (!*(_DWORD *)(a1 + 28))
      {
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316)
                             - *(_DWORD *)(a1 + 64);
        if (*(_DWORD *)(a1 + 36))
        {
          *(_DWORD *)(a1 + 36) = 0;
          *(_DWORD *)(a1 + 316) = 0;
          *(_WORD *)(a1 + 226) = 0;
          *(_DWORD *)(a1 + 248) = 0;
        }
      }
      v810 = (_QWORD *)*v25;
      if (!*v25)
      {
LABEL_1775:
        *(_QWORD *)(a1 + 632) = 0;
        *(_QWORD *)(a1 + 640) = v942;
        *(_DWORD *)(a1 + 648) = 0;
        *(_DWORD *)(a1 + 300) = 0;
        goto LABEL_1696;
      }
      while (1)
      {
        v811 = v810[4];
        v812 = (_QWORD *)v810[5];
        if (v811)
        {
          *(_QWORD *)(v811 + 40) = v812;
          v812 = (_QWORD *)v810[5];
        }
        else
        {
          *(_QWORD *)(a1 + 640) = v812;
        }
        *v812 = v811;
        v813 = (void (*)(_QWORD *, _QWORD, uint64_t))v810[10];
        v810[4] = 0;
        v810[5] = 0;
        if (!v813)
          break;
        v814 = v810[11];
        v810[10] = 0;
        v810[11] = 0;
        v813(v810, 0, v814);
LABEL_1757:
        v810 = (_QWORD *)*v942;
        if (!*v942)
          goto LABEL_1775;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_finalize";
      v815 = _os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v946 = OS_LOG_TYPE_DEFAULT;
      v941 = (void *)v815;
      if (__nwlog_fault())
      {
        if (LOBYTE(info.numer) == 17)
        {
          v934 = __nwlog_obj();
          v930 = info.numer;
          if (!os_log_type_enabled(v934, info.numer))
            goto LABEL_1773;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v816 = v934;
          v817 = v930;
          v818 = "%{public}s called with null frame->finalizer";
          goto LABEL_1772;
        }
        if (v946 == OS_LOG_TYPE_DEFAULT)
        {
          v936 = __nwlog_obj();
          v932 = info.numer;
          if (!os_log_type_enabled(v936, info.numer))
            goto LABEL_1773;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v816 = v936;
          v817 = v932;
          v818 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_1772;
        }
        v935 = (void *)__nw_create_backtrace_string();
        v931 = __nwlog_obj();
        v927 = info.numer;
        v819 = os_log_type_enabled(v931, info.numer);
        if (v935)
        {
          if (v819)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v935;
            _os_log_impl(&dword_209FB3000, v931, v927, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v935);
          goto LABEL_1773;
        }
        if (v819)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v816 = v931;
          v817 = v927;
          v818 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1772:
          _os_log_impl(&dword_209FB3000, v816, v817, v818, buf, 0xCu);
        }
      }
LABEL_1773:
      if (v941)
        free(v941);
      goto LABEL_1757;
    }
    v28 = nw_protocol_downcast();
    if (!v28)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_path_is_viable";
      v785 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v946 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault())
        goto LABEL_1740;
      if (LOBYTE(info.numer) == 17)
      {
        v786 = __nwlog_obj();
        numer = info.numer;
        if (!os_log_type_enabled(v786, info.numer))
          goto LABEL_1740;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v788 = "%{public}s called with null tcp";
        goto LABEL_1738;
      }
      if (v946 == OS_LOG_TYPE_DEFAULT)
      {
        v786 = __nwlog_obj();
        numer = info.numer;
        if (!os_log_type_enabled(v786, info.numer))
          goto LABEL_1740;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v788 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_1738;
      }
      backtrace_string = (void *)__nw_create_backtrace_string();
      v798 = __nwlog_obj();
      v799 = info.numer;
      v802 = os_log_type_enabled(v798, info.numer);
      if (backtrace_string)
      {
        if (v802)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_path_is_viable";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          v801 = "%{public}s called with null tcp, dumping backtrace:%{public}s";
          goto LABEL_1726;
        }
        goto LABEL_1727;
      }
      if (v802)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v788 = "%{public}s called with null tcp, no backtrace";
        goto LABEL_1780;
      }
      goto LABEL_1740;
    }
    if (*(_QWORD *)(v28 + 5208) && (*(_BYTE *)(v28 + 5309) & 0x20) == 0)
      goto LABEL_1743;
    v29 = v2[62];
    if (v29)
    {
      v30 = *(_QWORD *)(v29 + 216);
      v31 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)(a1 + 88) = v31 & 0xEFFFFFFF;
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 80) + 2236) & 2) != 0)
      {
        if (!v30)
        {
LABEL_68:
          v898 = 0;
          v899 = 0;
          v37 = *(_DWORD *)(a1 + 740);
          if ((v37 & 0x20) == 0)
            goto LABEL_101;
          goto LABEL_73;
        }
        if ((*(_BYTE *)(v30 + 1050) & 0x40) == 0)
          goto LABEL_63;
        *(_DWORD *)(a1 + 88) = v31 | 0x10000000;
        v32 = (unsigned int *)(v30 + 1060);
      }
      else
      {
        if (!v30)
          goto LABEL_68;
        if ((*(_BYTE *)(v30 + 1050) & 0x20) == 0)
          goto LABEL_63;
        *(_DWORD *)(a1 + 88) = v31 | 0x10000000;
        v32 = (unsigned int *)(v30 + 1056);
      }
      v33 = *v32;
      if (v33 >= 0xFFFF)
        v34 = 0xFFFF;
      else
        v34 = v33;
      if (v33)
        v35 = v34;
      else
        v35 = 0xFFFF;
      *(_DWORD *)(a1 + 692) = v35;
LABEL_63:
      if (*(unsigned __int8 *)(v30 + 1076) == 255 || *(_DWORD *)(v30 + 1024) == 255)
      {
        v899 = 1;
      }
      else
      {
        if (*(_DWORD *)(v30 + 1068) == 3 || *(_DWORD *)(v30 + 1032) == 3)
        {
          v899 = 0;
          v898 = 0x100000000;
          v37 = *(_DWORD *)(a1 + 740);
          if ((v37 & 0x20) == 0)
            goto LABEL_101;
          goto LABEL_73;
        }
        v899 = 0;
      }
      HIDWORD(v898) = 0;
      v36 = *(_DWORD *)(v30 + 1064) == 2 || *(_DWORD *)(v30 + 1028) == 2;
      LODWORD(v898) = v36;
    }
    v37 = *(_DWORD *)(a1 + 740);
    if ((v37 & 0x20) == 0)
      goto LABEL_101;
LABEL_73:
    v38 = *(_DWORD *)(a1 + 100);
    if (v38 - *(_DWORD *)(a1 + 96) >= 0)
      goto LABEL_101;
    if ((v37 & 0x20400000) != 0x20000000)
    {
      v47 = *(_QWORD *)(a1 + 544);
      if (v47)
      {
        v48 = *(_DWORD *)(a1 + 560);
        if ((int)(v38 - v48) < 0)
        {
          while (1)
          {
            v65 = *(_DWORD *)(v47 + 4);
            v47 = *(_QWORD *)(v47 + 16);
            v66 = v38 - v65;
            if (!v47)
              break;
            if (v66 < 0)
              goto LABEL_311;
            v67 = *(_DWORD *)v47;
            if (v38 - *(_DWORD *)v47 < 0)
            {
              *type = v67;
              v901 = *(_DWORD *)(v47 + 4) - v67;
              goto LABEL_101;
            }
          }
          if ((v66 & 0x80000000) == 0)
          {
            v901 = 0;
            *type = v48;
            goto LABEL_101;
          }
LABEL_311:
          v901 = v65 - v38;
          goto LABEL_101;
        }
      }
LABEL_100:
      v901 = 0;
      goto LABEL_101;
    }
    v39 = *(_DWORD *)(a1 + 144);
    v40 = v39 - tcp_flight_size((_DWORD *)a1);
    if (v40 < 1)
      goto LABEL_101;
    v41 = *v887;
    if (!*v887)
      goto LABEL_100;
    do
    {
      v42 = v41;
      v41 = *(_QWORD *)(v41 + 32);
    }
    while (v41);
    v901 = 0;
    while (1)
    {
      v43 = *(_DWORD *)(v42 + 4);
      v44 = *type - v43;
      if ((*(_BYTE *)(v42 + 12) & 1) != 0)
      {
        if (v44 < 0 && (int)(*type - *(_DWORD *)v42) >= 0)
          *type = v43;
      }
      else if (v44 < 0)
      {
        v901 += tcp_seg_len((int *)v42);
      }
      v45 = *(_QWORD *)(v42 + 40);
      if (!v45)
        break;
      do
      {
        v46 = v45;
        v45 = *(_QWORD *)(v45 + 32);
      }
      while (v45);
LABEL_87:
      v42 = v46;
      if (v901 >= v40)
        goto LABEL_101;
    }
    v46 = *(_QWORD *)(v42 + 48) & 0xFFFFFFFFFFFFFFFELL;
    if (v46 && *(_QWORD *)(v46 + 32) == v42)
      goto LABEL_87;
    while (1)
    {
      v46 = *(_QWORD *)(v42 + 48) & 0xFFFFFFFFFFFFFFFELL;
      if (!v46)
        break;
      v59 = v42 == *(_QWORD *)(v46 + 40);
      v42 = *(_QWORD *)(v42 + 48) & 0xFFFFFFFFFFFFFFFELL;
      if (!v59)
        goto LABEL_87;
    }
LABEL_101:
    if (*(_DWORD *)(a1 + 140) >= *(_DWORD *)(a1 + 144))
      v49 = *(_DWORD *)(a1 + 144);
    else
      v49 = *(_DWORD *)(a1 + 140);
    v50 = *(_DWORD *)(a1 + 88);
    v51 = v49;
    if ((v50 & 0x80000) != 0)
    {
      v52 = *(unsigned int *)(sysctls + 48);
      if (v49 >= v52)
        v53 = *(_DWORD *)(sysctls + 48);
      else
        v53 = v49;
      if ((int)v52 >= 1)
        v51 = v53;
      else
        v51 = v49;
    }
    v54 = 0;
    v55 = 0;
    v917 = *(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 92);
    v56 = tcp_outflags[*(int *)(a1 + 12)];
    v57 = 1;
    if ((*(_BYTE *)(a1 + 740) & 0x20) == 0 || (v50 & 0x200000) == 0)
    {
      v61 = 0;
      v928 = 0;
      v62 = 0;
      v63 = 0;
      goto LABEL_201;
    }
    v58 = v49 - tcp_flight_size((_DWORD *)a1);
    v59 = v58 <= 0 && v893 == 0;
    if (v59)
      v58 = *(_DWORD *)(a1 + 196);
    v60 = v58 & ~(v58 >> 31);
    if ((*(_DWORD *)(a1 + 740) & 0x20400020) == 0x20000020)
    {
      v55 = *(_QWORD *)(a1 + 1984);
      if (!v55)
      {
LABEL_123:
        v54 = 0;
        goto LABEL_160;
      }
      while ((*(_BYTE *)(v55 + 12) & 7) != 2)
      {
        v55 = *(_QWORD *)(v55 + 16);
        if (!v55)
          goto LABEL_123;
      }
      if (*(_DWORD *)(a1 + 196) >= v60)
        v82 = v58 & ~(unsigned __int16)(v58 >> 31);
      else
        v82 = *(_DWORD *)(a1 + 196);
      v83 = tcp_seg_len((int *)v55);
      v84 = v82;
      if (v83 <= v82)
        v84 = tcp_seg_len((int *)v55);
      v63 = v84;
      if (v60 < v84)
        v63 = v60;
      if (!v63)
      {
        v54 = 0;
        v55 = 0;
        v61 = 0;
        v928 = 0;
        v62 = 0;
        goto LABEL_162;
      }
      v917 = *(_DWORD *)v55 - *(_DWORD *)(a1 + 92);
      v85 = *(_QWORD *)(a1 + 1056);
      if (!v85)
      {
        v54 = 0;
        v61 = 0;
        v57 = 0;
        v893 = 1;
        v928 = 1;
        v62 = 1;
        goto LABEL_201;
      }
      v54 = 0;
      v61 = 0;
      v86 = (_QWORD *)(v85 + 616);
      v87 = 1;
      v62 = 1;
LABEL_192:
      v57 = 0;
      *v86 += v87;
      goto LABEL_200;
    }
    v61 = *(int **)(a1 + 544);
    if (!v61)
    {
      v54 = 0;
      goto LABEL_137;
    }
    v54 = 0;
    while (2)
    {
      v64 = v61[2];
      if (v64 - v61[1] >= 0)
      {
        v54 += v64 - *v61;
LABEL_128:
        v61 = (int *)*((_QWORD *)v61 + 2);
        if (!v61)
          goto LABEL_137;
        continue;
      }
      break;
    }
    if (v64 - *(_DWORD *)(a1 + 92) < 0)
      goto LABEL_128;
    v54 = v64 + v54 - *v61;
LABEL_137:
    v68 = *(_QWORD *)(a1 + 616);
    v937 = v51;
    if (v68 && *(_DWORD *)(v68 + 8) - *(_DWORD *)(v68 + 4) >= 0)
    {
      while (1)
      {
        v68 = *(_QWORD *)(v68 + 16);
        if (!v68)
          break;
        if (*(_DWORD *)(v68 + 8) - *(_DWORD *)(v68 + 4) < 0)
        {
          *(_QWORD *)(a1 + 616) = v68;
          break;
        }
      }
    }
    v69 = *(_DWORD *)(a1 + 624);
    v70 = v54;
    if (v61 != (int *)v68)
    {
      v71 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
      if (!v71 || (*(_BYTE *)(v71 + 828) & 2) == 0)
      {
        v72 = __nwlog_tcp_log();
        v73 = os_log_type_enabled(v72, OS_LOG_TYPE_ERROR);
        v54 = v70;
        if (v73)
        {
          v74 = (const char *)(v71 + 604);
          *(_DWORD *)buf = 136446466;
          if (!v71)
            v74 = "";
          *(_QWORD *)&buf[4] = "tcp_sack_output";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v74;
          _os_log_impl(&dword_209FB3000, v72, OS_LOG_TYPE_ERROR, "%{public}s %{public}s computed sack hole not the same as cached value", buf, 0x16u);
          v54 = v70;
        }
      }
    }
    if (v69 != v54)
    {
      v75 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
      if (!v75 || (*(_BYTE *)(v75 + 828) & 2) == 0)
      {
        v76 = __nwlog_tcp_log();
        v77 = os_log_type_enabled(v76, OS_LOG_TYPE_ERROR);
        v54 = v70;
        if (v77)
        {
          v78 = (const char *)(v75 + 604);
          *(_DWORD *)buf = 136446978;
          if (!v75)
            v78 = "";
          *(_QWORD *)&buf[4] = "tcp_sack_output";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v78;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)v948 = v70;
          *(_WORD *)&v948[4] = 1024;
          *(_DWORD *)&v948[6] = v69;
          _os_log_impl(&dword_209FB3000, v76, OS_LOG_TYPE_ERROR, "%{public}s %{public}s computed sack_bytes_retransmitted (%d) not the same as cached value (%d)", buf, 0x22u);
          v54 = v70;
        }
      }
    }
    if (!v61)
    {
      v55 = 0;
      v928 = 0;
      v62 = 0;
      v63 = 0;
      v893 = 1;
      v57 = 1;
      v2 = v933;
      v51 = v937;
      goto LABEL_201;
    }
    v79 = v61[1];
    v80 = *(unsigned int *)(a1 + 152);
    v2 = v933;
    v51 = v937;
    if ((int)v79 - (int)v80 < 1)
    {
      v88 = v61[2];
      v89 = v79 - v88;
      v90 = v79 - v88;
      if (v89 <= v60)
        v63 = v90;
      else
        v63 = v60;
      LODWORD(v81) = v61[2];
      if (v63 >= 1)
      {
LABEL_178:
        v917 = v81 - *(_DWORD *)(a1 + 92);
        v91 = *(_DWORD *)(a1 + 100);
        v92 = v91 - v81;
        v62 = v91 - *(_DWORD *)(a1 + 96) >= 0 || v92 > 0 || v63 > v901;
        v95 = *(_QWORD *)(a1 + 1056);
        if (v95)
        {
          v55 = 0;
          ++*(_QWORD *)(v95 + 576);
          LODWORD(v87) = *(_DWORD *)(a1 + 196);
          if (v63 >= v87)
            v87 = v87;
          else
            v87 = v63;
          v86 = (_QWORD *)(v95 + 584);
          goto LABEL_192;
        }
        v55 = 0;
        v57 = 0;
LABEL_200:
        v893 = 1;
        v928 = 1;
        goto LABEL_201;
      }
LABEL_196:
      v55 = 0;
      goto LABEL_161;
    }
    v81 = v61[2];
    if ((int)v81 - (int)v80 < 0)
    {
      v96 = v80 - v81;
      v63 = v80 - v81;
      if (v96 > v60)
        v63 = v60;
      if (v63 >= 1)
        goto LABEL_178;
      goto LABEL_196;
    }
    v55 = 0;
LABEL_160:
    v61 = 0;
LABEL_161:
    v928 = 0;
    v62 = 0;
    v63 = 0;
LABEL_162:
    v893 = 1;
    v57 = 1;
LABEL_201:
    v97 = *(_DWORD *)(a1 + 88);
    v98 = (v97 >> 11) & 1 | v56;
    v99 = *(_DWORD *)(a1 + 740);
    v904 = v57;
    if ((v99 & 0x8000) == 0)
    {
LABEL_204:
      v905 = v54;
      if (!v57)
        goto LABEL_241;
LABEL_205:
      v100 = (v97 >> 21) & 1;
      if ((v99 & 0x20400020) != 0x20000020)
        LOBYTE(v100) = 0;
      if (v54 || (v100 & 1) != 0)
      {
        v102 = *(_DWORD *)(a1 + 144);
        v103 = v102 - tcp_flight_size((_DWORD *)a1);
        v104 = v103 & ~(v103 >> 31);
        v105 = *(_DWORD *)(v3 + 384);
        if (v105 >= *(_DWORD *)(a1 + 140))
          v105 = *(_DWORD *)(a1 + 140);
        v106 = v105 - v917;
        if (v106 >= v104)
          v107 = v103 & ~(v103 >> 31);
        else
          v107 = v106;
        if (v106 <= 0)
          v63 = 0;
        else
          v63 = v107;
        if (v63)
          v108 = 1;
        else
          v108 = v103 < 1;
        if (v108)
        {
          v54 = v905;
        }
        else
        {
          v109 = *(_DWORD *)(a1 + 560);
          v110 = *(_DWORD *)(a1 + 152);
          v54 = v905;
          v63 = 0;
          if (v109 - v110 < 0)
          {
            v111 = *(_DWORD *)(a1 + 740);
            if ((v111 & 0x80000) == 0 && (v111 & 0x20400020) != 0x20000020)
            {
              v63 = v110 - v109;
              if ((v110 - v109) >= *(_DWORD *)(a1 + 196))
                v63 = *(_DWORD *)(a1 + 196);
              if (v63 >= v104)
                v63 = v104;
              v884 = *(_DWORD *)(a1 + 100);
              v112 = v110 - v63;
              *(_DWORD *)(a1 + 100) = v110 - v63;
              if ((*(_BYTE *)(a1 + 88) & 0x10) != 0 && *(_DWORD *)(a1 + 96) == v110)
                *type = --v112;
              v62 = 0;
              v917 = v112 - *(_DWORD *)(a1 + 92);
              *(_DWORD *)(a1 + 740) = v111 | 0x80000;
              v890 = 1;
            }
          }
        }
      }
      else
      {
        v101 = *(unsigned int *)(v3 + 384);
        if (v101 >= v51)
          LODWORD(v101) = v51;
        v63 = v101 - v917;
      }
      goto LABEL_241;
    }
    if (v51)
    {
      *(_DWORD *)(a1 + 36) = 0;
      *(_DWORD *)(a1 + 316) = 0;
      *(_WORD *)(a1 + 226) = 0;
      *(_DWORD *)(a1 + 248) = 0;
      goto LABEL_204;
    }
    if (v917 < *(_DWORD *)(v3 + 384))
      v98 = v56 & 0xFE;
    v51 = 1;
    v905 = v54;
    if (v57)
      goto LABEL_205;
LABEL_241:
    if (v63 >= v901)
      v113 = v901;
    else
      v113 = v63;
    if (v63 <= 0 || v901 == 0)
      v113 = v63;
    if ((v98 & 2) == 0 || (v115 = *(_DWORD *)(a1 + 100), v116 = *(_DWORD *)(a1 + 92), v115 - v116 < 1))
    {
      v119 = v113;
      goto LABEL_259;
    }
    v117 = *(_DWORD *)(a1 + 12);
    if (v117 != 3)
    {
      v98 &= ~2u;
      --v917;
      v119 = v113 + 1;
      if (v113 < 0 || v117 != 2)
        goto LABEL_259;
      if (*((_BYTE *)v2 + 2238))
        goto LABEL_1696;
      v656 = *(_DWORD *)(a1 + 88);
      if (*(_QWORD *)(a1 + 632))
      {
        v775 = *(_DWORD *)(a1 + 300);
        if (v54)
          v776 = 1;
        else
          v776 = v928;
        *(_DWORD *)(a1 + 284) = *(_DWORD *)(a1 + 120);
        *(_DWORD *)(a1 + 88) = v656 & 0xFFFFFFFC;
        *(_DWORD *)(a1 + 32) = 0;
        *(_DWORD *)(a1 + 304) = 0;
        tcp_ip_output_send(v3, a1, v942, v775, v776);
        *(_QWORD *)(a1 + 632) = 0;
        *(_QWORD *)(a1 + 640) = v942;
        *(_DWORD *)(a1 + 648) = 0;
        *(_DWORD *)(a1 + 300) = 0;
        if (*((_BYTE *)v2 + 2238))
          goto LABEL_1696;
        v656 = *(_DWORD *)(a1 + 88);
      }
      if ((v656 & 0x8000000) == 0)
        goto LABEL_1696;
      goto LABEL_1796;
    }
    v118 = *(_DWORD *)(a1 + 740);
    if ((v115 != v116 + 1 || (v118 & 0x400000) == 0) && (v118 & 0x400000) != 0)
      v98 &= ~2u;
    --v917;
    v119 = v113 + 1;
LABEL_259:
    if ((v98 & 2) != 0)
    {
      v120 = *(_DWORD *)(a1 + 740);
      if ((v120 & 0x400000) == 0)
        v98 &= ~1u;
      v119 &= v120 << 9 >> 31;
    }
    if ((v98 & 4) != 0)
      LODWORD(v121) = 0;
    else
      LODWORD(v121) = v119;
    if ((v98 & 2) != 0)
    {
      if (*(int *)(a1 + 12) > 2)
        goto LABEL_295;
      v122 = *(_DWORD *)(a1 + 740);
      if ((v122 & 0x400000) == 0)
        goto LABEL_295;
      if ((*(_BYTE *)(a1 + 88) & 8) == 0)
      {
        v123 = *(_QWORD *)(a1 + 80);
        v124 = *(_QWORD *)(v123 + 224);
        if ((v122 & 0x1000000) != 0
          || (v125 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v123 + 2136) + 32))(*(_QWORD *)(v123 + 224)),
              v54 = v905,
              (v125 & 1) != 0))
        {
          if ((*(_BYTE *)(v124 + 370) & 1) != 0)
            goto LABEL_295;
          v126 = *(_DWORD *)(a1 + 88);
          v938 = *(_DWORD *)(a1 + 740);
          v127 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 2136) + 48))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
          if (!v127)
          {
            LODWORD(v121) = 0;
            v3 = v916;
            v54 = v905;
            goto LABEL_295;
          }
          if ((v126 & 0x20) != 0)
            v128 = -8;
          else
            v128 = -4;
          if ((v126 & 0x80) != 0)
            v128 -= 12;
          v3 = v916;
          v54 = v905;
          if (v128 - ((v938 >> 4) & 2) + 40 >= v127
            && *(_DWORD *)(v124 + 384) <= (*(_DWORD *)(a1 + 156) - 40))
          {
            goto LABEL_295;
          }
        }
        else
        {
          *(_WORD *)(a1 + 990) |= 0x800u;
          v129 = *(_QWORD *)(a1 + 1056);
          if (v129)
            ++*(_QWORD *)(v129 + 1168);
        }
      }
      LODWORD(v121) = 0;
      *(_DWORD *)(a1 + 740) &= ~0x400000u;
      goto LABEL_295;
    }
    if ((int)v121 <= 0)
    {
      if (!v51)
      {
        v917 = 0;
        LODWORD(v121) = 0;
        *(_DWORD *)(a1 + 28) = 0;
        *(_DWORD *)(a1 + 16) = 0;
        *(_WORD *)(a1 + 226) = 0;
        *(_DWORD *)(a1 + 248) = 0;
        *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 92);
        if (*(_DWORD *)(a1 + 36))
          goto LABEL_295;
        tcp_setpersist(a1);
        v54 = v905;
        v917 = 0;
      }
      LODWORD(v121) = 0;
    }
    else
    {
      LODWORD(v121) = v119;
    }
LABEL_295:
    if ((v933[2231] & 0x50) == 0 && (*(_BYTE *)(a1 + 90) & 0x20) == 0)
    {
      v130 = *(_DWORD *)(v3 + 432);
      if ((v130 & 0xC00) == 0x400)
      {
        v131 = *(unsigned int *)(v3 + 388);
        if (5 * (*(_DWORD *)(a1 + 140) >> 2) >= v131)
        {
          v132 = *(_DWORD *)(v3 + 384);
          if (v132 >= 7 * (v131 >> 3)
            && v51 >= (int)(v132 - *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 92)))
          {
            v133 = *(unsigned int *)(sysctls + 116);
            v134 = v133 + v131;
            v135 = v133 + v131;
            if (v134 >= *(unsigned int *)(sysctls + 120))
              v135 = *(_DWORD *)(sysctls + 120);
            if (v135 <= 0x71C71C)
            {
              *(_DWORD *)(v3 + 388) = v135;
              v136 = *(_QWORD *)(*(_QWORD *)(v3 + 456) + 24);
              if ((v130 & 4) != 0)
              {
                if (v136)
                {
                  all_stats = nw_protocol_tcp_get_all_stats();
                  v54 = v905;
                  if (all_stats)
                    *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v3 + 388);
                }
              }
              else if (v136)
              {
                v137 = nw_protocol_tcp_get_all_stats();
                v54 = v905;
                if (v137)
                  *(_DWORD *)(v137 + 100) = *(_DWORD *)(v3 + 388);
              }
              v139 = *(_DWORD *)(v3 + 388);
              if (*(_DWORD *)(v3 + 392) > v139)
                *(_DWORD *)(v3 + 392) = v139;
              *(_DWORD *)(v3 + 436) = v139;
            }
          }
        }
      }
    }
    v140 = *(unsigned int *)(a1 + 196);
    if ((int)v121 <= (int)v140)
    {
      v141 = 0;
    }
    else if ((*(_BYTE *)(a1 + 91) & 0x10) != 0
           && *(_DWORD *)(sysctls + 324)
           && !(*(_DWORD *)(a1 + 564) | v928 | v54)
           && !*((_QWORD *)v933 + 273))
    {
      v62 = 0;
      v141 = 1;
    }
    else
    {
      v141 = 0;
      v62 = 1;
      LODWORD(v121) = *(_DWORD *)(a1 + 196);
    }
    v142 = *(_DWORD *)(a1 + 740);
    if ((v142 & 0x1000) != 0)
      v141 = 0;
    v907 = v141;
    v143 = (v142 & 0x1000) == 0 && v62;
    v906 = v143;
    if ((int)v121 < v140 || (*(_DWORD *)(a1 + 740) & 0x1000) == 0)
      v121 = v121;
    else
      v121 = v140;
    v891 = (unsigned int *)(v61 + 2);
    if ((v142 & 0x20400020) == 0x20000020)
      v145 = (_DWORD *)v55;
    else
      v145 = v61 + 2;
    if (!v928)
      v145 = (_DWORD *)(a1 + 100);
    if (*v145 + (int)v121 - (*(_DWORD *)(a1 + 92) + *(_DWORD *)(v3 + 384)) >= 0)
      v146 = v98;
    else
      v146 = v98 & 0xFFFFFFFE;
    v147 = tcp_sbspace(a1);
    v148 = v147;
    if (v147 < *(_DWORD *)(v3 + 492) >> 2)
    {
      if (v147 >= *(_DWORD *)(a1 + 196))
        v148 = v147;
      else
        v148 = 0;
    }
    v149 = sysctls;
    if (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v3 + 369) & 0x40) != 0)
    {
      v150 = *(_DWORD *)(sysctls + 308);
      if (v150 && (v150 == 1 && (~*(_DWORD *)(a1 + 88) & 0x180) == 0 || *(int *)(a1 + 12) <= 3))
      {
        if (v148 >= 1)
        {
          if (off_253CF86A8)
          {
            v151 = off_253CF86A8(a1);
            if (v148 >= v151)
              v148 = v151;
          }
        }
        goto LABEL_380;
      }
      if (v148 < 1)
        goto LABEL_380;
      if (*(_DWORD *)(sysctls + 124) != 1 || (~*(_DWORD *)(a1 + 88) & 0x180) != 0)
        goto LABEL_374;
      v152 = *(_DWORD *)(a1 + 740);
      if ((v152 & 0x100) != 0)
        goto LABEL_375;
      v153 = *(_QWORD *)(a1 + 80);
      v154 = *(_QWORD *)(v153 + 496);
      if (v154
        && (v155 = *(_QWORD *)(v154 + 1488)) != 0
        && (v156 = *(_DWORD *)(v155 + 40)) != 0
        && (v157 = *(_DWORD *)(a1 + 236)) != 0)
      {
        if (v157 <= *(_DWORD *)(sysctls + 4) + v156)
          goto LABEL_380;
        v158 = v146;
        v159 = *(_QWORD *)(v153 + 224);
        *(_DWORD *)(a1 + 740) = v152 | 0x100;
        if (!*(_DWORD *)(a1 + 1040))
        {
          *(_DWORD *)(a1 + 1040) = *(_DWORD *)(nw_tcp_access_globals(v159) + 316);
          v149 = sysctls;
        }
        v160 = *(_DWORD *)(v159 + 540);
        v161 = *(_DWORD *)(v149 + 128);
        if (v160 > v161)
        {
          v162 = v160 >> 1;
          if (v162 > v161)
            v161 = v162;
          *(_DWORD *)(v159 + 540) = v161;
        }
        v146 = v158;
      }
      else
      {
LABEL_374:
        if (*(_DWORD *)(sysctls + 112) >= (int)*(unsigned __int16 *)(a1 + 754))
          goto LABEL_380;
      }
LABEL_375:
      v163 = *(_DWORD *)(a1 + 120);
      v164 = v163 + *(_DWORD *)(a1 + 196) * *(_DWORD *)(v149 + 108);
      if (*(_DWORD *)(a1 + 124) - v164 >= 0)
        v164 = *(_DWORD *)(a1 + 124);
      v165 = v164 - v163;
      if (v165 >= v148)
        v165 = v148;
      v148 = v165 & ~(v165 >> 31);
    }
LABEL_380:
    v166 = *(_BYTE *)(a1 + 261);
    v167 = 0xFFFF << v166;
    if (v148 >= 0xFFFF << v166)
      v168 = 0xFFFF << v166;
    else
      v168 = v148;
    if ((*(_BYTE *)(v3 + 367) & 2) == 0 && v168 <= *(_DWORD *)(a1 + 124) - *(_DWORD *)(a1 + 120))
      v168 = *(_DWORD *)(a1 + 124) - *(_DWORD *)(a1 + 120);
    v902 = v168;
    if (!(_DWORD)v121)
      goto LABEL_420;
    v169 = *(_DWORD *)(a1 + 740);
    if ((v169 & 0x8000) != 0)
      goto LABEL_448;
    v171 = *(unsigned int *)(a1 + 96);
    v170 = *(unsigned int *)(a1 + 100);
    if ((int)v170 - (int)v171 < 0)
    {
      if ((~v169 & 0x20000020) == 0 && !(v169 & 0x400000 | v928))
      {
        if (v171 - v170 <= (int)v121)
          v121 = (v171 - v170);
        else
          v121 = v121;
      }
      goto LABEL_448;
    }
    if ((v928 & 1) != 0)
      goto LABEL_448;
    v172 = *(_DWORD *)(a1 + 12);
    if ((v169 & 0x400000) == 0 || v172 != 3)
    {
      if (v172 == 4 && (*((_DWORD *)v933 + 557) & 0x50000000) != 0)
      {
        v173 = *(_QWORD *)(a1 + 1056);
        v168 = v902;
        if (v173)
          ++*(_QWORD *)(v173 + 96);
        goto LABEL_420;
      }
LABEL_404:
      if ((int)v121 >= *(_DWORD *)(a1 + 196))
        goto LABEL_448;
      v174 = *(_DWORD *)(a1 + 88);
      if ((v174 & 0x10000) == 0)
      {
        if (v878 & 1 | ((v174 & 0x1000004) != 0))
        {
          if ((v174 & 0x1000) != 0)
            goto LABEL_415;
        }
        else
        {
          v175 = *(_DWORD *)(a1 + 8);
          if (v175 < 1
            || (v174 & 0x1000) != 0
            || (*(_DWORD *)(a1 + 740) & 0x6000) == 0x6000
            || v175 >= *(unsigned __int8 *)(a1 + 310))
          {
            goto LABEL_415;
          }
        }
        if ((int)v121 + v917 >= *(_DWORD *)(v3 + 384))
          goto LABEL_448;
      }
LABEL_415:
      v176 = *(_DWORD *)(a1 + 252);
      if (v176 >= 0)
        v177 = *(_DWORD *)(a1 + 252);
      else
        v177 = v176 + 1;
      v168 = v902;
      if (v176 && (int)v121 >= v177 >> 1)
        goto LABEL_448;
LABEL_420:
      if (v168 >= 1)
      {
        if (v168 < v167)
          v167 = v168;
        v178 = *(_DWORD *)(a1 + 120);
        v179 = *(_DWORD *)(a1 + 124) - v178;
        v180 = v167 - v179;
        v181 = v179 & ~(v179 >> 31);
        v182 = *(_DWORD *)(sysctls + 288);
        v183 = 2 * *(_DWORD *)(a1 + 196);
        if (v182)
        {
          if (v180 < v183)
          {
            if ((*(_BYTE *)(a1 + 88) & 2) != 0
              && !*(_DWORD *)(v3 + 488)
              && *(_DWORD *)(a1 + 284) != v178
              && (*(_BYTE *)(a1 + 740) & 0x10) != 0)
            {
              goto LABEL_448;
            }
            goto LABEL_436;
          }
          if (*(_DWORD *)(v3 + 488) >= *(_DWORD *)(v3 + 496))
            goto LABEL_436;
        }
        else if (v180 < v183 || (*(_DWORD *)(a1 + 88) & 0x80000000) != 0)
        {
          goto LABEL_436;
        }
        if (*(_DWORD *)(a1 + 284) != v178 || (int)(v181 + v180) >> v166 > (int)(v181 >> v166))
          goto LABEL_448;
LABEL_436:
        if (*(_DWORD *)(v3 + 492) <= 4 * v180)
          goto LABEL_448;
        if (!v182)
        {
          v184 = *(_DWORD *)(a1 + 88);
          if ((v184 & 0x80000002) == 0x80000000)
          {
            *(_DWORD *)(a1 + 88) = v184 | 2;
            *(_DWORD *)(a1 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316)
                                 - *(_DWORD *)(a1 + 64)
                                 + 100;
          }
        }
      }
      v185 = *(_DWORD *)(a1 + 88);
      if ((v185 & 1) != 0)
      {
        if (*(_WORD *)(a1 + 308))
          --*(_WORD *)(a1 + 308);
        goto LABEL_448;
      }
      if ((v146 & 6) != 0 || (v146 & 1) != 0 && ((v185 & 0x10) == 0 || *(_DWORD *)(a1 + 100) == *(_DWORD *)(a1 + 92)))
        goto LABEL_448;
      if ((*(_BYTE *)(a1 + 740) & 0x20) == 0
        || *(int *)(a1 + 12) < 4
        || *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92) < 1
        || *(_DWORD *)(a1 + 28)
        || *(_DWORD *)(a1 + 36))
      {
        v780 = v933;
        if (*(_DWORD *)(v3 + 384) && !*(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 36))
        {
          *(_WORD *)(a1 + 226) = 0;
          *(_DWORD *)(a1 + 248) = 0;
          tcp_setpersist(a1);
        }
      }
      else
      {
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316)
                             - *(_DWORD *)(a1 + 64);
        v780 = v933;
      }
      if (!v780[2238])
      {
        v822 = v905 ? 1 : v928;
        tcp_ip_output(v3, a1, v942, *(_DWORD *)(a1 + 300), v822);
        *(_QWORD *)(a1 + 632) = 0;
        *(_QWORD *)(a1 + 640) = v942;
        *(_DWORD *)(a1 + 648) = 0;
        *(_DWORD *)(a1 + 300) = 0;
        if (!v780[2238])
        {
          v656 = *(_DWORD *)(a1 + 88);
          if ((v656 & 0x8000000) != 0)
          {
LABEL_1796:
            *(_DWORD *)(a1 + 88) = v656 & 0xF7FFFFFF;
            tcp_close(a1);
            return 0;
          }
        }
      }
LABEL_1696:
      tcp_check_timer_state(a1);
      return 0;
    }
    if ((*(_BYTE *)(a1 + 988) & 2) == 0 || (_DWORD)v170 != *(_DWORD *)(a1 + 112) + 1)
      goto LABEL_404;
LABEL_448:
    if ((int)v121 >= 1)
      *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 88) & 0xFEFFFFFF | (((int)v121 >= *(_DWORD *)(a1 + 196)) << 24);
    v186 = *(_DWORD *)(a1 + 740);
    if ((v186 & 0x10000000) == 0 && ((v186 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
    {
      v187 = *(_DWORD *)(a1 + 348);
      if ((~v187 & 0x300000) == 0 && *(_DWORD *)(a1 + 12) == 4)
      {
        v188 = *(_DWORD *)(a1 + 112);
        if (*(_DWORD *)(a1 + 92) == v188 + 1
          && *(_DWORD *)(a1 + 560) == v188
          && (v187 & 0x2000000) == 0
          && *(_WORD *)(a1 + 226))
        {
          *(_DWORD *)(a1 + 348) = v187 | 0x2000000;
        }
      }
    }
    v189 = *(_DWORD *)(a1 + 88);
    if ((v146 & 2) == 0
      || (v190 = *(_DWORD *)(a1 + 112), *(_DWORD *)(a1 + 100) = v190, *(_DWORD *)(a1 + 560) = v190, (v189 & 8) != 0))
    {
      v200 = 0;
      if ((v146 & 4) == 0)
        goto LABEL_478;
    }
    else
    {
      v191 = v146;
      __src[0] = 1026;
      v192 = *(_QWORD *)(a1 + 80);
      v193 = *(_BYTE *)(v192 + 2236);
      if ((v193 & 2) != 0)
        v194 = -60;
      else
        v194 = -40;
      if ((*(_BYTE *)(v192 + 2236) & 2) != 0)
      {
        v195 = tcp_rtlookup6(v192, 0);
        if (v195)
          goto LABEL_468;
      }
      else
      {
        v195 = tcp_rtlookup(v192, 0);
        if (v195)
        {
LABEL_468:
          v196 = *(_QWORD *)(v195 + 216);
          if (*(_BYTE *)(v196 + 1076) == 23
            && *(int *)(sysctls + 48) >= 1
            && (*(_DWORD *)(v196 + 1040) - 9601) >> 7 <= 0x39C)
          {
            *(_DWORD *)(a1 + 88) |= 0x80000u;
          }
          v197 = *(_QWORD *)(v195 + 1488);
          if (v197 && (v198 = *(_DWORD *)(v197 + 48)) != 0)
          {
            v199 = *(_DWORD *)(v196 + 1044);
            if (v198 < v199)
              v199 = v198;
          }
          else
          {
            v199 = *(_DWORD *)(v196 + 1044);
          }
          v217 = v199 + v194;
          goto LABEL_512;
        }
      }
      v216 = 152;
      if ((v193 & 2) == 0)
        v216 = 148;
      v217 = *(_DWORD *)(sysctls + v216);
LABEL_512:
      __src[1] = bswap32(v217) >> 16;
      v189 = *(_DWORD *)(a1 + 88);
      v146 = v191;
      if ((v189 & 0x20) != 0 && ((v191 & 0x10) == 0 || (v189 & 0x40) != 0))
      {
        v952 = bswap32(*(unsigned __int8 *)(a1 + 262) | 0x1030300);
        v200 = 8;
        if ((v191 & 4) != 0)
          goto LABEL_482;
      }
      else
      {
        v200 = 4;
        if ((v191 & 4) != 0)
          goto LABEL_482;
      }
LABEL_478:
      if ((v189 & 0x88) == 0x80 && ((v146 & 0x10) == 0 || (v189 & 0x100) != 0))
      {
        v201 = (_DWORD *)((char *)__src + v200);
        *v201 = 168296705;
        v202 = bswap32(*(_DWORD *)(a1 + 276));
        v201[1] = bswap32(*(_DWORD *)(a1 + 1888) + *v903);
        v201[2] = v202;
        v200 += 12;
      }
    }
LABEL_482:
    v203 = v146 & 2;
    v204 = *(_DWORD *)(a1 + 740);
    if ((v204 & 0x20) != 0 && (v146 & 2) != 0 && (v189 & 8) == 0 && ((v146 & 0x10) == 0 || (v189 & 0x200) != 0))
    {
      *(_WORD *)((char *)__src + v200) = 516;
      v200 += 2;
    }
    if ((v204 & 0x400000) == 0)
    {
      v205 = 0;
      v206 = v146 & 0x12;
      goto LABEL_530;
    }
    if ((v146 & 0x12) != 2 || (v189 & 8) != 0)
    {
      if ((v146 & 0x12) == 0x12)
      {
        if ((*(_BYTE *)(a1 + 988) & 1) != 0)
        {
          v219 = v200;
          tcp_tfo_gen_cookie(*(_QWORD *)(a1 + 80), buf);
          v220 = (char *)__src + v219;
          *(_WORD *)v220 = 2594;
          *(_QWORD *)(v220 + 2) = *(_QWORD *)buf;
          *(_WORD *)(a1 + 990) |= 4u;
          v221 = *(_QWORD *)(a1 + 1056);
          if (v221)
            ++*(_QWORD *)(v221 + 1072);
          v205 = 0;
          LOBYTE(v200) = v219 + 10;
          v204 = *(_DWORD *)(a1 + 740);
        }
        else
        {
          v205 = 0;
        }
        v215 = 1;
        if ((v204 & 0x20) != 0)
          goto LABEL_531;
      }
      else
      {
        v215 = 0;
        v205 = 0;
        if ((v204 & 0x20) != 0)
          goto LABEL_531;
      }
LABEL_557:
      if ((v204 & 0x10000000) != 0)
        goto LABEL_648;
LABEL_558:
      if ((v204 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1)
        goto LABEL_648;
      v236 = *(_DWORD *)(a1 + 348);
      if ((~v236 & 0x300000) != 0)
      {
        if ((v236 & 0x2000000) != 0 || !v215)
          goto LABEL_648;
      }
      else if ((v236 & 0x2000000) != 0)
      {
        goto LABEL_648;
      }
      v238 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
      if ((40 - v200) <= 1u)
      {
        v239 = v200;
        if (v238 && (*(_BYTE *)(v238 + 828) & 2) != 0 || !__nwlog_is_datapath_logging_enabled())
          goto LABEL_575;
        v242 = v146;
        v688 = __nwlog_tcp_log();
        if (os_log_type_enabled(v688, OS_LOG_TYPE_DEBUG))
        {
          v689 = (const char *)(v238 + 604);
          *(_DWORD *)buf = 136446466;
          if (!v238)
            v689 = "";
          *(_QWORD *)&buf[4] = "tcp_add_accecn_option";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v689;
          _os_log_impl(&dword_209FB3000, v688, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s not enough space to add any AccECN option", buf, 0x16u);
        }
LABEL_1482:
        v3 = v916;
        v146 = v242;
LABEL_576:
        LOBYTE(v200) = v239;
        goto LABEL_648;
      }
      v240 = *(_DWORD *)(a1 + 432);
      if ((v236 & 0x400000 | v203 || (v236 & 0x1800000) != 0 || *(_DWORD *)(a1 + 92) == *(_DWORD *)(a1 + 112) + 1)
        && (!v215 || !*(_WORD *)(a1 + 226)))
      {
        v241 = (_DWORD *)((char *)__src + (v200 | ((unint64_t)v205 << 8)));
        if ((40 - v200) > 4u)
        {
          if ((40 - v200) > 7u)
          {
            v261 = *(_DWORD *)(a1 + 448) & 0xFFFFFF;
            if ((40 - v200) > 0xAu)
            {
              v420 = (v236 & 0x800000) == 0;
              if ((v236 & 0x800000) != 0)
                v421 = *(_DWORD *)(a1 + 432);
              else
                v421 = *(_DWORD *)(a1 + 440);
              if (v420)
                v422 = -1408565248;
              else
                v422 = -1375010816;
              if (!v420)
                v240 = *(_DWORD *)(a1 + 440);
              *v241 = bswap32(v422 & 0xFFFF0000 | (unsigned __int16)(v421 >> 8));
              v241[1] = bswap32(v261 | (v421 << 24));
              v241[2] = bswap32((v240 << 8) | 1);
              v239 = v200 + 12;
              if (v238 && (*(_BYTE *)(v238 + 828) & 2) != 0 || !__nwlog_is_datapath_logging_enabled())
                goto LABEL_575;
              v242 = v146;
              v423 = __nwlog_tcp_log();
              if (!os_log_type_enabled(v423, OS_LOG_TYPE_DEBUG))
                goto LABEL_1482;
              v424 = (const char *)(v238 + 604);
              *(_DWORD *)buf = 136446722;
              if (!v238)
                v424 = "";
              *(_QWORD *)&buf[4] = "tcp_add_accecn_option";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v424;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)v948 = v239;
              v245 = v423;
              v246 = "%{public}s %{public}s add all 3 counters for AccECN option, optlen=%u";
            }
            else
            {
              v262 = (v236 & 0x800000) == 0;
              if ((v236 & 0x800000) != 0)
                v263 = *(_DWORD *)(a1 + 432);
              else
                v263 = *(_DWORD *)(a1 + 440);
              if (v262)
                v264 = -1408761856;
              else
                v264 = -1375207424;
              *v241 = bswap32(v264 & 0xFFFF0000 | (unsigned __int16)(v263 >> 8));
              v241[1] = bswap32(v261 | (v263 << 24));
              v239 = v200 + 8;
              if (v238 && (*(_BYTE *)(v238 + 828) & 2) != 0 || !__nwlog_is_datapath_logging_enabled())
                goto LABEL_575;
              v242 = v146;
              v265 = __nwlog_tcp_log();
              if (!os_log_type_enabled(v265, OS_LOG_TYPE_DEBUG))
                goto LABEL_1482;
              v266 = (const char *)(v238 + 604);
              *(_DWORD *)buf = 136446722;
              if (!v238)
                v266 = "";
              *(_QWORD *)&buf[4] = "tcp_add_accecn_option";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v266;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)v948 = v239;
              v245 = v265;
              v246 = "%{public}s %{public}s add 2 counters for AccECN option, optlen=%u";
            }
          }
          else
          {
            v256 = (v236 & 0x800000) == 0;
            if ((v236 & 0x800000) != 0)
              v257 = *(_DWORD *)(a1 + 432);
            else
              v257 = *(_DWORD *)(a1 + 440);
            if (v256)
              v258 = -1408958464;
            else
              v258 = -1375404032;
            *v241 = bswap32(v258 & 0xFFFF0000 | (unsigned __int16)(v257 >> 8));
            v241[1] = bswap32((v257 << 24) | 0x10101);
            v239 = v200 + 8;
            if (v238 && (*(_BYTE *)(v238 + 828) & 2) != 0 || !__nwlog_is_datapath_logging_enabled())
              goto LABEL_575;
            v242 = v146;
            v259 = __nwlog_tcp_log();
            if (!os_log_type_enabled(v259, OS_LOG_TYPE_DEBUG))
              goto LABEL_1482;
            v260 = (const char *)(v238 + 604);
            *(_DWORD *)buf = 136446722;
            if (!v238)
              v260 = "";
            *(_QWORD *)&buf[4] = "tcp_add_accecn_option";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v260;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)v948 = v239;
            v245 = v259;
            v246 = "%{public}s %{public}s add single counter for AccECN option, optlen=%u";
          }
LABEL_983:
          _os_log_impl(&dword_209FB3000, v245, OS_LOG_TYPE_DEBUG, v246, buf, 0x1Cu);
          LOBYTE(v200) = v239;
          v3 = v916;
          v146 = v242;
          goto LABEL_648;
        }
        if (v203)
        {
          *v241 = 16843438;
          v239 = v200 + 4;
          if ((!v238 || (*(_BYTE *)(v238 + 828) & 2) == 0) && __nwlog_is_datapath_logging_enabled())
          {
            v242 = v146;
            v243 = __nwlog_tcp_log();
            if (!os_log_type_enabled(v243, OS_LOG_TYPE_DEBUG))
              goto LABEL_1482;
            v244 = (const char *)(v238 + 604);
            *(_DWORD *)buf = 136446722;
            if (!v238)
              v244 = "";
            *(_QWORD *)&buf[4] = "tcp_add_accecn_option";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v244;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)v948 = v239;
            v245 = v243;
            v246 = "%{public}s %{public}s add empty AccECN option, optlen=%u";
            goto LABEL_983;
          }
LABEL_575:
          v3 = v916;
          goto LABEL_576;
        }
      }
      v3 = v916;
      goto LABEL_648;
    }
    v207 = *(_QWORD *)(a1 + 80);
    v208 = *(_QWORD *)(v207 + 224);
    buf[0] = 38 - v200;
    if ((*(_BYTE *)(v208 + 370) & 1) != 0)
    {
      if ((int)v121 >= 1)
      {
        *(_WORD *)(a1 + 990) |= 0x40u;
        v214 = *(_QWORD *)(a1 + 1056);
        if (v214)
        {
          v213 = 0;
          goto LABEL_509;
        }
      }
      v213 = 0;
      goto LABEL_529;
    }
    v209 = v146;
    v210 = v200;
    v211 = (char *)__src + v200;
    v212 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)(v207 + 2136) + 40))(v208, v211 + 2);
    *v211 = 34;
    if ((v212 & 1) == 0)
    {
      v213 = 2;
      v211[1] = 2;
      *(_BYTE *)(a1 + 988) |= 4u;
      *(_WORD *)(a1 + 990) |= 0x10u;
      v222 = *(_QWORD *)(a1 + 1056);
      if (v222)
      {
        v218 = (_QWORD *)(v222 + 1104);
        v146 = v209;
        v200 = v210;
        goto LABEL_527;
      }
LABEL_528:
      v146 = v209;
      v200 = v210;
      goto LABEL_529;
    }
    v213 = buf[0] + 2;
    v211[1] = buf[0] + 2;
    *(_BYTE *)(a1 + 988) |= 8u;
    if ((int)v121 < 1)
      goto LABEL_528;
    *(_WORD *)(a1 + 990) |= 0x40u;
    v214 = *(_QWORD *)(a1 + 1056);
    v146 = v209;
    v200 = v210;
    if (!v214)
      goto LABEL_529;
LABEL_509:
    v218 = (_QWORD *)(v214 + 1120);
LABEL_527:
    ++*v218;
LABEL_529:
    v200 += v213;
    v205 = v200 >> 8;
    v204 = *(_DWORD *)(a1 + 740);
    v206 = 2;
LABEL_530:
    v215 = v206 == 18;
    if ((v204 & 0x20) == 0)
      goto LABEL_557;
LABEL_531:
    v223 = *(_DWORD *)(a1 + 88);
    if ((v223 & 8) != 0 || (v223 & 0x200) == 0 || *(int *)(a1 + 12) < 4)
      goto LABEL_557;
    v224 = *(int *)(a1 + 564);
    if ((int)v224 <= 0 && (!*v894 || !*(_DWORD *)(a1 + 944))
      || (v225 = v200 | (v205 << 8), v226 = 38 - v225, (38 - v225) < 8))
    {
      v3 = v916;
      goto LABEL_557;
    }
    v939 = v146;
    v227 = v226 >> 3;
    if ((v204 & 0x10000000) == 0
      && v226 >= 0x18
      && ((v204 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
    {
      v228 = *(_DWORD *)(a1 + 348);
      v230 = (v228 & 0x1800000) != 0 && (v228 & 0x2300000) == 3145728;
      v227 -= v230;
    }
    v231 = *v894;
    if (!*v894)
    {
      if (v227 < v224)
        goto LABEL_595;
      v233 = 0;
LABEL_594:
      v227 = v224 + v233;
      goto LABEL_595;
    }
    v232 = *(_DWORD *)(a1 + 944);
    v59 = v232 == 0;
    v233 = v232 != 0;
    if (v59)
      v234 = *(_DWORD *)(a1 + 564);
    else
      v234 = v224 + 1;
    if (v227 >= (uint64_t)v234)
      goto LABEL_594;
LABEL_595:
    v910 = *(_DWORD *)(a1 + 564);
    v247 = (char *)__src + v225;
    v248 = (2 - (_BYTE)v200) & 3;
    if (((2 - (_BYTE)v200) & 3) != 0)
    {
      v895 = v215;
      v249 = v200 | (v205 << 8);
      v250 = v203;
      v251 = v227;
      memset(v247, 1, (2 - (_BYTE)v200) & 3);
      v215 = v895;
      v227 = v251;
      v203 = v250;
      LODWORD(v225) = v249;
      v247 = (char *)__src + v249 + (v248 - 1) + 1;
    }
    v252 = *(_QWORD *)(a1 + 1056);
    if (v252)
      ++*(_QWORD *)(v252 + 600);
    v253 = (8 * v227) | 2;
    *v247 = 5;
    v254 = (int8x8_t *)(v247 + 2);
    v247[1] = (8 * v227) | 2;
    if (v231)
    {
      v255 = *(_DWORD *)(a1 + 944);
      if (v255)
      {
        if ((int)v227 >= 1)
        {
          if (v910 && v227 < 2)
          {
            v227 = 1;
            goto LABEL_637;
          }
          *(_DWORD *)(v247 + 2) = bswap32(v231);
          *(_DWORD *)(v247 + 6) = bswap32(v255);
          if (v252)
            ++*(_QWORD *)(v252 + 1008);
          v254 = (int8x8_t *)(v247 + 10);
          ++*(_DWORD *)(a1 + 1020);
          --v227;
        }
      }
    }
    if (!v227)
      goto LABEL_647;
LABEL_637:
    if (v910 < (int)v227)
    {
      v897 = v215;
      v724 = v227;
      v877 = v253;
      v889 = v248;
      v725 = v225;
      v912 = __nwlog_obj();
      os_log_type_enabled(v912, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_output";
      v726 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_abort())
      {
        free(v726);
        LODWORD(v225) = v725;
        v248 = v889;
        v253 = v877;
        v227 = v724;
        v215 = v897;
        if (v724 < 1)
          goto LABEL_647;
LABEL_639:
        v267 = v227;
        if (v227 < 8)
        {
          v268 = 0;
          goto LABEL_641;
        }
        v269 = (const float *)(a1 + 568);
        if ((unint64_t)v254 >= v879 + 8 * v227 || v879 >= (unint64_t)&v254[v227])
        {
          v268 = v227 & 0xFFFFFFF8;
          v416 = (float *)&v254[4];
          v417 = v268;
          do
          {
            v418 = v269;
            v954 = vld2q_f32(v418);
            v418 += 8;
            v419 = v416 - 8;
            v955 = vld2q_f32(v418);
            v956.val[0] = (float32x4_t)vrev32q_s8((int8x16_t)v954.val[0]);
            v956.val[1] = (float32x4_t)vrev32q_s8((int8x16_t)v954.val[1]);
            vst2q_f32(v419, v956);
            v954.val[0] = (float32x4_t)vrev32q_s8((int8x16_t)v955.val[0]);
            v954.val[1] = (float32x4_t)vrev32q_s8((int8x16_t)v955.val[1]);
            vst2q_f32(v416, v954);
            v269 += 16;
            v416 += 16;
            v417 -= 8;
          }
          while (v417);
          if (v268 == v267)
            goto LABEL_647;
          v254 += v267 & 0xFFFFFFF8;
LABEL_641:
          v269 = (const float *)(a1 + 568);
        }
        else
        {
          v268 = 0;
        }
        v270 = v267 - v268;
        v271 = (int8x8_t *)&v269[2 * v268];
        do
        {
          v272 = *v271++;
          *v254++ = vrev32_s8(v272);
          --v270;
        }
        while (v270);
        goto LABEL_647;
      }
LABEL_1885:
      __break(1u);
LABEL_1886:
      *(_QWORD *)(a1 + 1056) = 0;
      v508 = 6;
LABEL_1887:
      if ((*(_BYTE *)(v916 + 828) & 2) == 0)
      {
        v858 = __nwlog_tcp_log();
        if (os_log_type_enabled(v858, OS_LOG_TYPE_INFO))
        {
          v859 = strerror(v508);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v880;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)v948 = v859;
          _os_log_impl(&dword_209FB3000, v858, OS_LOG_TYPE_INFO, "%{public}s %{public}s failed to finalize tcp checksum, %s", buf, 0x20u);
        }
      }
      v860 = *(void (**)(uint64_t, _QWORD, uint64_t))(v18 + 80);
      v25 = (_QWORD *)(a1 + 632);
      if (v860)
      {
        v861 = *(_QWORD *)(v18 + 88);
        *(_QWORD *)(v18 + 80) = 0;
        *(_QWORD *)(v18 + 88) = 0;
        v860(v18, 0, v861);
        v735 = v939;
        if ((_DWORD)v508 == 6)
        {
LABEL_1892:
          v654 = 0;
          goto LABEL_1558;
        }
LABEL_1909:
        v654 = *(_DWORD *)(a1 + 648);
        v508 = 55;
        goto LABEL_1558;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_finalize";
      v862 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v946 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (LOBYTE(info.numer) != 17)
        {
          if (v946)
          {
            v866 = (void *)__nw_create_backtrace_string();
            v867 = __nwlog_obj();
            v868 = info.numer;
            v869 = os_log_type_enabled(v867, info.numer);
            if (v866)
            {
              if (v869)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "__nw_frame_finalize";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v866;
                _os_log_impl(&dword_209FB3000, v867, v868, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v866);
              goto LABEL_1906;
            }
            if (!v869)
              goto LABEL_1906;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v865 = "%{public}s called with null frame->finalizer, no backtrace";
            v870 = v867;
            v871 = v868;
          }
          else
          {
            v863 = __nwlog_obj();
            v864 = info.numer;
            if (!os_log_type_enabled(v863, info.numer))
              goto LABEL_1906;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v865 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
LABEL_1904:
            v870 = v863;
            v871 = v864;
          }
          _os_log_impl(&dword_209FB3000, v870, v871, v865, buf, 0xCu);
          goto LABEL_1906;
        }
        v863 = __nwlog_obj();
        v864 = info.numer;
        if (os_log_type_enabled(v863, info.numer))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v865 = "%{public}s called with null frame->finalizer";
          goto LABEL_1904;
        }
      }
LABEL_1906:
      if (v862)
        free(v862);
      v25 = (_QWORD *)(a1 + 632);
      v735 = v939;
      v121 = a1 + 100;
      if ((_DWORD)v508 == 6)
        goto LABEL_1892;
      goto LABEL_1909;
    }
    if ((int)v227 >= 1)
      goto LABEL_639;
LABEL_647:
    v200 = v248 + v225 + v253;
    v205 = v200 >> 8;
    v204 = *(_DWORD *)(a1 + 740);
    v3 = v916;
    v146 = v939;
    if ((v204 & 0x10000000) == 0)
      goto LABEL_558;
LABEL_648:
    v273 = v200 | (v205 << 8);
    if (v273 <= 0x27)
    {
      v274 = v200 & 3;
      if ((v200 & 3) != 0)
      {
        v275 = v146;
        v276 = 4 - v274;
        v277 = v200;
        bzero((char *)__src + v273, (4 - v274));
        v205 = 0;
        LOBYTE(v200) = v277 + v276;
        v146 = v275;
      }
    }
    v278 = *(_DWORD *)(a1 + 740);
    if ((v278 & 0x10000000) == 0)
    {
      if ((v278 & 0x8000000) != 0
        || (*(_DWORD *)(sysctls + 320) != 1 ? (v279 = tcp_do_acc_ecn == 1) : (v279 = 1), v279))
      {
        v280 = *(_DWORD *)(a1 + 348);
        if ((~v280 & 0x300000) == 0 && (v280 & 0x400000) == 0 && *(int *)(a1 + 12) >= 4)
          v146 = v146 & 0xFFFFFE3F | ((*(_DWORD *)(a1 + 416) & 7) << 6);
      }
    }
    v896 = v200;
    if ((v146 & 0x12) == 2)
    {
      v283 = *(_DWORD *)(a1 + 348);
      if ((v283 & 0x1000) == 0)
        goto LABEL_669;
      v287 = (v283 & 0x100000) != 0 && *(unsigned __int16 *)(a1 + 226) < 2u;
      if ((v283 & 0x100001) == 0 || v287)
      {
        if ((v278 & 0x10000000) != 0
          || (v289 = 0x100000, v290 = 448, (v278 & 0x8000000) == 0)
          && *(_DWORD *)(sysctls + 320) != 1
          && tcp_do_acc_ecn != 1)
        {
          v289 = 5;
          v290 = 192;
        }
        v291 = *(_QWORD *)(a1 + 1056);
        if (v291)
          ++*(_QWORD *)(v291 + 768);
        v146 |= v290;
        v286 = v283 | v289 | 0x4000;
      }
      else
      {
        v288 = *(_QWORD *)(a1 + 1056);
        if (v288)
          ++*(_QWORD *)(v288 + 792);
        v286 = v283 & 0xFFFFFEFB | 0x100;
      }
LABEL_714:
      *(_DWORD *)(a1 + 348) = v286;
    }
    else
    {
      if ((v146 & 0x12) == 0x12)
      {
        v281 = *(_DWORD *)(a1 + 348);
        if ((v281 & 0x1000) != 0)
        {
          if ((v281 & 0x200002) == 0)
          {
            v286 = *(_DWORD *)(a1 + 348);
            goto LABEL_715;
          }
          v282 = (v281 & 0x100000) != 0 && *(unsigned __int16 *)(a1 + 226) < 2u;
          if ((v281 & 0x100001) != 0 && !v282)
          {
            v292 = *(_QWORD *)(a1 + 1056);
            if (v292)
            {
              ++*(_QWORD *)(v292 + 848);
              --*(_QWORD *)(v292 + 808);
            }
            v286 = v281 | 0x200;
            *(_DWORD *)(a1 + 348) = v281 | 0x200;
            if ((v278 & 0x10000000) != 0
              || (v278 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1)
            {
              v286 = v281 & 0xFFFFFDF1 | 0x200;
              goto LABEL_714;
            }
            goto LABEL_715;
          }
          if ((v278 & 0x10000000) != 0
            || (*(_DWORD *)(sysctls + 320) != 1 ? (v294 = tcp_do_acc_ecn == 1) : (v294 = 1),
                !v294 ? (v295 = (v278 & 0x8000000) == 0) : (v295 = 0),
                (v281 & 0x200000) == 0 || v295))
          {
            if ((v281 & 2) == 0)
            {
              v286 = *(_DWORD *)(a1 + 348);
              goto LABEL_1473;
            }
            v146 |= 0x40u;
            v296 = 5;
          }
          else
          {
            *(_QWORD *)(a1 + 416) = 0x500000005;
            *(_QWORD *)(a1 + 472) = 0;
            *(_QWORD *)(a1 + 448) = 0;
            if ((v281 & 0x10000) != 0)
            {
              *(_WORD *)(a1 + 404) = 128;
              v146 |= 0x80u;
              v281 &= ~0x10000u;
              *(_DWORD *)(a1 + 348) = v281;
              v403 = *(_QWORD *)(a1 + 1056);
              if (v403)
                ++*(_QWORD *)(v403 + 816);
            }
            else if ((v281 & 0x20000) != 0)
            {
              *(_WORD *)(a1 + 404) = 192;
              v146 |= 0xC0u;
              v281 &= ~0x20000u;
              v589 = *(_QWORD *)(a1 + 1056);
              if (v589)
                ++*(_QWORD *)(v589 + 824);
            }
            else if ((v281 & 0x40000) != 0)
            {
              *(_WORD *)(a1 + 404) = 256;
              v146 |= 0x100u;
              v281 &= ~0x40000u;
              v597 = *(_QWORD *)(a1 + 1056);
              if (v597)
                ++*(_QWORD *)(v597 + 832);
            }
            else
            {
              if ((v281 & 0x80000) == 0)
              {
                if (*(_WORD *)(a1 + 404))
                {
                  v146 |= *(unsigned __int16 *)(a1 + 404);
                  goto LABEL_1469;
                }
                v940 = v146;
                if ((*(_BYTE *)(v3 + 828) & 2) == 0)
                {
                  __nwlog_tcp_log();
                  v638 = *(_DWORD *)(a1 + 348);
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "tcp_output";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v880;
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)v948 = v638;
                  v639 = (void *)_os_log_send_and_compose_impl();
                  LOBYTE(info.numer) = 16;
                  v946 = OS_LOG_TYPE_DEFAULT;
                  if (!__nwlog_fault())
                    goto LABEL_1465;
                  if (LOBYTE(info.numer) != 17)
                  {
                    if (v946)
                    {
                      v658 = (void *)__nw_create_backtrace_string();
                      v659 = __nwlog_tcp_log();
                      v660 = info.numer;
                      v661 = os_log_type_enabled(v659, info.numer);
                      if (v658)
                      {
                        if (v661)
                        {
                          v662 = *(_DWORD *)(a1 + 348);
                          *(_DWORD *)buf = 136446978;
                          *(_QWORD *)&buf[4] = "tcp_output";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v880;
                          *(_WORD *)&buf[22] = 1024;
                          *(_DWORD *)v948 = v662;
                          *(_WORD *)&v948[4] = 2082;
                          *(_QWORD *)&v948[6] = v658;
                          _os_log_impl(&dword_209FB3000, v659, v660, "%{public}s %{public}s ECN flags (0x%x) not set correctly, dumping backtrace:%{public}s", buf, 0x26u);
                        }
                        free(v658);
                        v3 = v916;
                        goto LABEL_1465;
                      }
                      v3 = v916;
                      if (!v661)
                        goto LABEL_1465;
                      v684 = *(_DWORD *)(a1 + 348);
                      *(_DWORD *)buf = 136446722;
                      *(_QWORD *)&buf[4] = "tcp_output";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v880;
                      *(_WORD *)&buf[22] = 1024;
                      *(_DWORD *)v948 = v684;
                      v643 = v659;
                      v644 = v660;
                      v645 = "%{public}s %{public}s ECN flags (0x%x) not set correctly, no backtrace";
                    }
                    else
                    {
                      v675 = __nwlog_tcp_log();
                      v676 = info.numer;
                      if (!os_log_type_enabled(v675, info.numer))
                        goto LABEL_1465;
                      v677 = *(_DWORD *)(a1 + 348);
                      *(_DWORD *)buf = 136446722;
                      *(_QWORD *)&buf[4] = "tcp_output";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v880;
                      *(_WORD *)&buf[22] = 1024;
                      *(_DWORD *)v948 = v677;
                      v643 = v675;
                      v644 = v676;
                      v645 = "%{public}s %{public}s ECN flags (0x%x) not set correctly, backtrace limit exceeded";
                    }
LABEL_1464:
                    _os_log_impl(&dword_209FB3000, v643, v644, v645, buf, 0x1Cu);
                    goto LABEL_1465;
                  }
                  v640 = __nwlog_tcp_log();
                  v641 = info.numer;
                  if (os_log_type_enabled(v640, info.numer))
                  {
                    v642 = *(_DWORD *)(a1 + 348);
                    *(_DWORD *)buf = 136446722;
                    *(_QWORD *)&buf[4] = "tcp_output";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v880;
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)v948 = v642;
                    v643 = v640;
                    v644 = v641;
                    v645 = "%{public}s %{public}s ECN flags (0x%x) not set correctly";
                    goto LABEL_1464;
                  }
LABEL_1465:
                  if (v639)
                    free(v639);
                  v281 = *(_DWORD *)(a1 + 348);
                  v278 = *(_DWORD *)(a1 + 740);
                }
                v146 = v940;
                LOBYTE(v200) = v896;
                goto LABEL_1469;
              }
              *(_WORD *)(a1 + 404) = 384;
              v146 |= 0x180u;
              v281 &= ~0x80000u;
              v598 = *(_QWORD *)(a1 + 1056);
              if (v598)
                ++*(_QWORD *)(v598 + 840);
            }
LABEL_1469:
            v286 = v281 | 0x100000;
            *(_DWORD *)(a1 + 348) = v281 | 0x100000;
            if ((v278 & 0x10000000) != 0
              || (v278 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 336) != 1 && tcp_do_l4s != 1)
            {
LABEL_1473:
              v685 = *(int64x2_t **)(a1 + 1056);
              if (v685)
                v685[50] = vaddq_s64(v685[50], vdupq_n_s64(1uLL));
              goto LABEL_715;
            }
            v296 = 1048580;
          }
          v286 = v281 | v296;
          *(_DWORD *)(a1 + 348) = v286;
          goto LABEL_1473;
        }
      }
LABEL_669:
      if ((v278 & 0x10000000) != 0)
      {
        v286 = *(_DWORD *)(a1 + 348);
        goto LABEL_715;
      }
      v285 = tcp_do_acc_ecn != 1 && *(_DWORD *)(sysctls + 320) != 1 && (v278 & 0x8000000) == 0;
      v286 = *(_DWORD *)(a1 + 348);
      if (!v285
        && (v286 & 0x300000) == 0x300000
        && v146 == 16
        && !(_DWORD)v121
        && (v286 & 0x400000) != 0)
      {
        v146 &= 0xFFFFFE3F;
        if ((v286 & 0x10000) != 0)
        {
          v146 |= 0x80u;
          v286 &= ~0x10000u;
        }
        else if ((v286 & 0x20000) != 0)
        {
          v146 |= 0xC0u;
          v286 &= ~0x20000u;
        }
        else if ((v286 & 0x40000) != 0)
        {
          v146 |= 0x100u;
          v286 &= ~0x40000u;
        }
        else if ((v286 & 0x80000) != 0)
        {
          v146 |= 0x180u;
          v286 &= ~0x80000u;
        }
        v286 &= ~0x400000u;
        *(_DWORD *)(a1 + 348) = v286;
LABEL_744:
        if (!(_DWORD)v121 && (v286 & 0x10) != 0)
        {
          v146 |= 0x40u;
          v297 = *(_QWORD *)(a1 + 1056);
          if (v297)
            ++*(_QWORD *)(v297 + 872);
        }
        goto LABEL_748;
      }
    }
LABEL_715:
    if (!(_DWORD)v121 || (v286 & 8) == 0)
      goto LABEL_744;
    v293 = v928;
    if (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) < 0)
      v293 = 1;
    if ((v293 & 1) == 0)
    {
      v146 |= 0x80u;
      *(_DWORD *)(a1 + 348) = v286 & 0xFFFFFFF7;
    }
LABEL_748:
    v298 = (v200 | (v205 << 8));
    *(_QWORD *)v894 = 0;
    v299 = *(_DWORD *)(a1 + 156);
    if ((int)v298 + (int)v121 <= v299)
    {
      v303 = v121;
      if ((v278 & 8) != 0)
        goto LABEL_765;
    }
    else
    {
      v146 &= ~1u;
      if (v907)
      {
        v300 = *(_DWORD *)(a1 + 692);
        if (!v300)
          v300 = 0xFFFF;
        v301 = v883 - (_DWORD)v298 + v300 - 20;
        if ((int)v121 <= v301)
        {
          v302 = v906;
          if ((*(_BYTE *)(a1 + 89) & 8) != 0)
            v302 = 1;
          v301 = v121;
        }
        else
        {
          v302 = 1;
        }
        v303 = v301 / (v299 - v298) * (v299 - (_DWORD)v298);
        if (v301 == v303)
          v304 = v302;
        else
          v304 = 1;
        v906 = v304;
        if ((v278 & 8) != 0)
        {
LABEL_765:
          if ((v278 & 4) == 0)
          {
            v305 = *(_QWORD *)(a1 + 768);
            if (v305)
            {
              v306 = *(_DWORD *)(v3 + 384) - *(_DWORD *)(a1 + 96) + *(_DWORD *)(a1 + 92);
              if (v306 >= *(_DWORD *)(a1 + 144))
                v306 = *(_DWORD *)(a1 + 144);
              if (v306 >= *(_DWORD *)(a1 + 140))
                v306 = *(_DWORD *)(a1 + 140);
              v307 = *(_DWORD *)(v305 + 20);
              if (v306 < v307 && v307 != 0)
                v306 = 0;
              *(_DWORD *)(v305 + 8) = v306;
              v309 = *(_DWORD **)(a1 + 768);
              v310 = v309[6];
              v311 = v309[2];
              if (v310)
              {
                if (v311 >= v310)
                  v311 = v309[6];
                v309[2] = v311;
              }
              if (v311)
              {
                *(_DWORD *)(a1 + 740) |= 4u;
                *v309 = *(_DWORD *)(a1 + 96);
                v309[1] = *v903;
              }
            }
          }
        }
      }
      else
      {
        v303 = v299 - (_DWORD)v298;
        v906 = 1;
        if ((v278 & 8) != 0)
          goto LABEL_765;
      }
    }
    v939 = v146;
    if (!*((_DWORD *)v933 + 115))
    {
      v611 = __nwlog_obj();
      os_log_type_enabled(v611, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_output";
      v612 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_abort())
      {
        free(v612);
        v146 = v939;
        goto LABEL_783;
      }
      goto LABEL_1885;
    }
LABEL_783:
    v313 = (v146 & 0xFFFFFFEF) != 0 || (int)v121 >= 1 || *(_BYTE *)(a1 + 261) == 0;
    v314 = !v313;
    if (!v313)
    {
      v315 = *v903;
      if (*(_DWORD *)(sysctls + 268) + *(_DWORD *)(a1 + 1880) - *v903 < 0)
      {
        v316 = *(_DWORD *)(a1 + 1876);
        if ((v316 + 1) > 1)
          v317 = v316 + 1;
        else
          v317 = 1;
        *(_DWORD *)(a1 + 1876) = v317;
        *(_DWORD *)(a1 + 1880) = v315;
      }
    }
    v318 = (_DWORD)v298 + 20;
    LOBYTE(v889) = v303 != 0;
    v911 = v298;
    if (!v303)
    {
      if ((*(_BYTE *)(a1 + 88) & 1) != 0)
      {
        v326 = *(_QWORD *)(a1 + 1056);
        if (v326)
          ++*(_QWORD *)(v326 + 48);
      }
      else
      {
        v321 = *(_QWORD *)(a1 + 1056);
        if ((v146 & 7) != 0)
        {
          if (v321)
            ++*(_QWORD *)(v321 + 88);
        }
        else if (v321)
        {
          ++*(_QWORD *)(v321 + 80);
        }
      }
      if (!v314 || (*(_BYTE *)(a1 + 743) & 2) == 0 || !*(_DWORD *)(a1 + 672))
        goto LABEL_891;
      v18 = **(_QWORD **)(*(_QWORD *)(a1 + 664) + 8);
      if (v18)
      {
        v358 = *(_DWORD *)(v18 + 52);
        goto LABEL_890;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_effective_length";
      v690 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v946 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault())
        goto LABEL_1552;
      if (LOBYTE(info.numer) == 17)
      {
        v691 = __nwlog_obj();
        v692 = info.numer;
        if (os_log_type_enabled(v691, info.numer))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_effective_length";
          v693 = v691;
          v694 = v692;
          v695 = "%{public}s called with null frame";
          goto LABEL_1551;
        }
        goto LABEL_1552;
      }
      if (v946 == OS_LOG_TYPE_DEFAULT)
      {
        v733 = __nwlog_obj();
        v734 = info.numer;
        if (!os_log_type_enabled(v733, info.numer))
          goto LABEL_1552;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_effective_length";
        v693 = v733;
        v694 = v734;
        v695 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_1551:
        _os_log_impl(&dword_209FB3000, v693, v694, v695, buf, 0xCu);
        goto LABEL_1552;
      }
      v727 = (void *)__nw_create_backtrace_string();
      v728 = __nwlog_obj();
      v729 = info.numer;
      v923 = v728;
      v730 = os_log_type_enabled(v728, info.numer);
      if (v727)
      {
        if (v730)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "__nw_frame_effective_length";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v727;
          _os_log_impl(&dword_209FB3000, v923, v729, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v727);
        goto LABEL_1552;
      }
      if (v730)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_effective_length";
        v693 = v923;
        v694 = v729;
        v695 = "%{public}s called with null frame, no backtrace";
        goto LABEL_1551;
      }
LABEL_1552:
      if (v690)
        free(v690);
      v358 = 0;
      v3 = v916;
LABEL_890:
      if (v358 < *(_DWORD *)(v18 + 56) + v318)
      {
LABEL_891:
        v359 = *(_QWORD *)(v3 + 24);
        v360 = *(_QWORD *)(v359 + 32);
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)(v360 + 24) + 88))(v360, v359))
        {
          LOBYTE(v889) = 0;
          v508 = 55;
          goto LABEL_1678;
        }
        v18 = *(_QWORD *)buf;
        if (*(_QWORD *)buf)
          goto LABEL_893;
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
        v646 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v946 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) != 17)
          {
            if (v946)
            {
              v668 = (void *)__nw_create_backtrace_string();
              v669 = __nwlog_obj();
              v670 = info.numer;
              v671 = os_log_type_enabled(v669, info.numer);
              if (v668)
              {
                if (v671)
                {
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v668;
                  _os_log_impl(&dword_209FB3000, v669, v670, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v668);
                goto LABEL_1495;
              }
              if (!v671)
                goto LABEL_1495;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
              v649 = v669;
              v650 = v670;
              v651 = "%{public}s called with null frame, no backtrace";
            }
            else
            {
              v686 = __nwlog_obj();
              v687 = info.numer;
              if (!os_log_type_enabled(v686, info.numer))
                goto LABEL_1495;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
              v649 = v686;
              v650 = v687;
              v651 = "%{public}s called with null frame, backtrace limit exceeded";
            }
LABEL_1494:
            _os_log_impl(&dword_209FB3000, v649, v650, v651, buf, 0xCu);
            goto LABEL_1495;
          }
          v647 = __nwlog_obj();
          v648 = info.numer;
          if (os_log_type_enabled(v647, info.numer))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
            v649 = v647;
            v650 = v648;
            v651 = "%{public}s called with null frame";
            goto LABEL_1494;
          }
        }
LABEL_1495:
        if (v646)
          free(v646);
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_collapse";
        v700 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v946 = OS_LOG_TYPE_DEFAULT;
        if ((__nwlog_fault() & 1) != 0)
        {
          if (LOBYTE(info.numer) != 17)
          {
            if (v946)
            {
              v706 = (void *)__nw_create_backtrace_string();
              v707 = __nwlog_obj();
              v708 = info.numer;
              v709 = os_log_type_enabled(v707, info.numer);
              if (v706)
              {
                if (v709)
                {
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "__nw_frame_collapse";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v706;
                  _os_log_impl(&dword_209FB3000, v707, v708, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v706);
                goto LABEL_1511;
              }
              if (!v709)
                goto LABEL_1511;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "__nw_frame_collapse";
              v703 = v707;
              v704 = v708;
              v705 = "%{public}s called with null frame, no backtrace";
            }
            else
            {
              v710 = __nwlog_obj();
              v711 = info.numer;
              if (!os_log_type_enabled(v710, info.numer))
                goto LABEL_1511;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "__nw_frame_collapse";
              v703 = v710;
              v704 = v711;
              v705 = "%{public}s called with null frame, backtrace limit exceeded";
            }
LABEL_1510:
            _os_log_impl(&dword_209FB3000, v703, v704, v705, buf, 0xCu);
            goto LABEL_1511;
          }
          v701 = __nwlog_obj();
          v702 = info.numer;
          if (os_log_type_enabled(v701, info.numer))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_collapse";
            v703 = v701;
            v704 = v702;
            v705 = "%{public}s called with null frame";
            goto LABEL_1510;
          }
        }
LABEL_1511:
        if (v700)
          free(v700);
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_unclaim_internal";
        v712 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v946 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) != 17)
          {
            if (v946)
            {
              v718 = (void *)__nw_create_backtrace_string();
              v719 = __nwlog_obj();
              v720 = info.numer;
              v721 = os_log_type_enabled(v719, info.numer);
              if (v718)
              {
                if (v721)
                {
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "__nw_frame_unclaim_internal";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v718;
                  _os_log_impl(&dword_209FB3000, v719, v720, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v718);
                goto LABEL_1527;
              }
              if (!v721)
                goto LABEL_1527;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "__nw_frame_unclaim_internal";
              v715 = v719;
              v716 = v720;
              v717 = "%{public}s called with null frame, no backtrace";
            }
            else
            {
              v722 = __nwlog_obj();
              v723 = info.numer;
              if (!os_log_type_enabled(v722, info.numer))
                goto LABEL_1527;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "__nw_frame_unclaim_internal";
              v715 = v722;
              v716 = v723;
              v717 = "%{public}s called with null frame, backtrace limit exceeded";
            }
LABEL_1526:
            _os_log_impl(&dword_209FB3000, v715, v716, v717, buf, 0xCu);
            goto LABEL_1527;
          }
          v713 = __nwlog_obj();
          v714 = info.numer;
          if (os_log_type_enabled(v713, info.numer))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_unclaim_internal";
            v715 = v713;
            v716 = v714;
            v717 = "%{public}s called with null frame";
            goto LABEL_1526;
          }
        }
LABEL_1527:
        if (v712)
          free(v712);
        v18 = 0;
        v430 = 1;
        v342 = (size_t)v911;
        if (!*(_QWORD *)(v3 + 24))
        {
LABEL_1005:
          if (v18)
          {
            v412 = v939;
            goto LABEL_1007;
          }
          LOBYTE(v889) = 0;
LABEL_1607:
          v25 = (_QWORD *)(a1 + 632);
LABEL_1608:
          if ((*(_BYTE *)(v3 + 828) & 2) == 0)
          {
            v757 = __nwlog_tcp_log();
            if (os_log_type_enabled(v757, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "tcp_output";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v880;
              _os_log_impl(&dword_209FB3000, v757, OS_LOG_TYPE_INFO, "%{public}s %{public}s output buffer is no longer valid", buf, 0x16u);
            }
          }
          if (v18)
          {
            v758 = *(void (**)(uint64_t, _QWORD, uint64_t))(v18 + 80);
            if (v758)
            {
              v759 = *(_QWORD *)(v18 + 88);
              *(_QWORD *)(v18 + 80) = 0;
              *(_QWORD *)(v18 + 88) = 0;
              v758(v18, 0, v759);
              v508 = 6;
LABEL_1614:
              v741 = (_QWORD *)*v25;
              if (*v25)
                goto LABEL_1615;
              goto LABEL_1679;
            }
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v824 = (void *)_os_log_send_and_compose_impl();
            LOBYTE(info.numer) = 16;
            v946 = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault())
              goto LABEL_1845;
            if (LOBYTE(info.numer) == 17)
            {
              v825 = __nwlog_obj();
              v826 = info.numer;
              if (os_log_type_enabled(v825, info.numer))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "__nw_frame_finalize";
                v827 = "%{public}s called with null frame->finalizer";
                goto LABEL_1843;
              }
LABEL_1845:
              if (v824)
LABEL_1846:
                free(v824);
LABEL_1847:
              v508 = 6;
LABEL_1678:
              v741 = (_QWORD *)*v942;
              if (*v942)
                goto LABEL_1615;
              goto LABEL_1679;
            }
            if (v946)
            {
              v832 = (void *)__nw_create_backtrace_string();
              v829 = __nwlog_obj();
              v830 = info.numer;
              v833 = os_log_type_enabled(v829, info.numer);
              if (v832)
              {
                if (v833)
                {
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "__nw_frame_finalize";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v832;
                  _os_log_impl(&dword_209FB3000, v829, v830, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v832);
                if (v824)
                  goto LABEL_1846;
                goto LABEL_1847;
              }
              if (!v833)
                goto LABEL_1845;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "__nw_frame_finalize";
              v827 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1852:
              v844 = v829;
              v845 = v830;
LABEL_1844:
              _os_log_impl(&dword_209FB3000, v844, v845, v827, buf, 0xCu);
              goto LABEL_1845;
            }
            v825 = __nwlog_obj();
            v826 = info.numer;
            if (!os_log_type_enabled(v825, info.numer))
              goto LABEL_1845;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v827 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          }
          else
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v824 = (void *)_os_log_send_and_compose_impl();
            LOBYTE(info.numer) = 16;
            v946 = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault())
              goto LABEL_1845;
            if (LOBYTE(info.numer) == 17)
            {
              v825 = __nwlog_obj();
              v826 = info.numer;
              if (os_log_type_enabled(v825, info.numer))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "__nw_frame_finalize";
                v827 = "%{public}s called with null frame";
                goto LABEL_1843;
              }
              goto LABEL_1845;
            }
            if (v946)
            {
              v828 = (void *)__nw_create_backtrace_string();
              v829 = __nwlog_obj();
              v830 = info.numer;
              v831 = os_log_type_enabled(v829, info.numer);
              if (v828)
              {
                if (v831)
                {
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "__nw_frame_finalize";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v828;
                  _os_log_impl(&dword_209FB3000, v829, v830, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v828);
                goto LABEL_1845;
              }
              if (!v831)
                goto LABEL_1845;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "__nw_frame_finalize";
              v827 = "%{public}s called with null frame, no backtrace";
              goto LABEL_1852;
            }
            v825 = __nwlog_obj();
            v826 = info.numer;
            if (!os_log_type_enabled(v825, info.numer))
              goto LABEL_1845;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v827 = "%{public}s called with null frame, backtrace limit exceeded";
          }
LABEL_1843:
          v844 = v825;
          v845 = v826;
          goto LABEL_1844;
        }
LABEL_998:
        v431 = nw_protocol_tcp_get_all_stats();
        if (v431)
          ++*(_QWORD *)(v431 + 32);
        if (!*(_QWORD *)(v3 + 24))
          goto LABEL_1005;
        v432 = nw_protocol_tcp_get_all_stats();
        if (!v432)
          goto LABEL_1005;
        v433 = v432;
        if (!v430)
        {
          v434 = *(unsigned int *)(v18 + 52);
LABEL_1004:
          *(_QWORD *)(v433 + 40) += v434;
          goto LABEL_1005;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_effective_length";
        v678 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v946 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault())
          goto LABEL_1546;
        if (LOBYTE(info.numer) == 17)
        {
          v679 = __nwlog_obj();
          v680 = info.numer;
          if (os_log_type_enabled(v679, info.numer))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_effective_length";
            v681 = v679;
            v682 = v680;
            v683 = "%{public}s called with null frame";
            goto LABEL_1545;
          }
          goto LABEL_1546;
        }
        if (v946)
        {
          v696 = (void *)__nw_create_backtrace_string();
          v697 = __nwlog_obj();
          v698 = info.numer;
          v922 = v697;
          v699 = os_log_type_enabled(v697, info.numer);
          if (v696)
          {
            if (v699)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "__nw_frame_effective_length";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v696;
              _os_log_impl(&dword_209FB3000, v922, v698, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v696);
            goto LABEL_1546;
          }
          if (!v699)
          {
LABEL_1546:
            if (v678)
              free(v678);
            v434 = 0;
            v342 = (size_t)v911;
            v3 = v916;
            goto LABEL_1004;
          }
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_effective_length";
          v681 = v922;
          v682 = v698;
          v683 = "%{public}s called with null frame, no backtrace";
        }
        else
        {
          v731 = __nwlog_obj();
          v732 = info.numer;
          if (!os_log_type_enabled(v731, info.numer))
            goto LABEL_1546;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_effective_length";
          v681 = v731;
          v682 = v732;
          v683 = "%{public}s called with null frame, backtrace limit exceeded";
        }
LABEL_1545:
        _os_log_impl(&dword_209FB3000, v681, v682, v683, buf, 0xCu);
        goto LABEL_1546;
      }
      if ((*(_WORD *)(v18 + 204) & 0x40) == 0)
      {
        if (*(_DWORD *)(a1 + 1876) != *(_DWORD *)(v18 + 192))
          goto LABEL_891;
LABEL_1377:
        v593 = *(_QWORD *)(v18 + 32);
        v594 = *(_QWORD **)(v18 + 40);
        if (v593)
        {
          *(_QWORD *)(v593 + 40) = v594;
          v594 = *(_QWORD **)(v18 + 40);
        }
        else
        {
          *(_QWORD *)(a1 + 664) = v594;
        }
        *v594 = v593;
        *(_QWORD *)(v18 + 32) = 0;
        *(_QWORD *)(v18 + 40) = 0;
        --*(_DWORD *)(a1 + 672);
        if (*(_QWORD *)(v3 + 24))
        {
          v595 = nw_protocol_tcp_get_all_stats();
          if (v595)
            --*(_QWORD *)(v595 + 32);
          if (*(_QWORD *)(v3 + 24))
          {
            v596 = nw_protocol_tcp_get_all_stats();
            if (v596)
              *(_QWORD *)(v596 + 40) -= *(unsigned int *)(v18 + 52);
          }
        }
        ++*(_DWORD *)(a1 + 1884);
LABEL_893:
        if ((*(_WORD *)(v18 + 204) & 0x80) != 0)
          *(_WORD *)(v18 + 196) -= v318;
        v361 = *(_DWORD *)(v18 + 52);
        v362 = *(_DWORD *)(v18 + 56) + v318;
        v363 = *(_DWORD *)(v18 + 60);
        if (v362 <= v361 - v363)
        {
          *(_DWORD *)(v18 + 56) = v362;
          *(_DWORD *)(v18 + 60) = v363;
        }
        else
        {
          v364 = __nwlog_obj();
          v365 = os_log_type_enabled(v364, OS_LOG_TYPE_ERROR);
          v361 = *(_DWORD *)(v18 + 52);
          if (v365)
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v362;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v361;
            *(_WORD *)v948 = 1024;
            *(_DWORD *)&v948[2] = v363;
            _os_log_impl(&dword_209FB3000, v364, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
            v361 = *(_DWORD *)(v18 + 52);
          }
        }
        v342 = (size_t)v911;
        if (v361)
        {
          v367 = *(unsigned int *)(v18 + 56);
          v366 = *(unsigned int *)(v18 + 60);
          v368 = (v361 - (v366 + v367));
          if (v361 != (_DWORD)v366 + (_DWORD)v367)
          {
            if ((_DWORD)v366)
            {
              v369 = *(_QWORD *)(v18 + 112);
              if (v369)
              {
                memmove((void *)(v369 + v367), (const void *)(v369 + v367 + v368), v366);
                v361 = *(_DWORD *)(v18 + 52);
              }
            }
            *(_DWORD *)(v18 + 52) = v361 - v368;
            if ((*(_WORD *)(v18 + 204) & 0x80) != 0)
            {
              v370 = *(unsigned __int16 *)(v18 + 196);
              v348 = v370 >= v368;
              v371 = v370 - v368;
              *(_WORD *)(v18 + 196) = v371;
              if (!v348 || v371 >= 0x10000)
              {
                __nwlog_obj();
                v372 = *(unsigned __int16 *)(v18 + 196);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "__nw_frame_collapse";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "frame->aggregate_buffer_length";
                *(_WORD *)&buf[22] = 2048;
                *(_QWORD *)v948 = v368;
                *(_WORD *)&v948[8] = 2048;
                *(_QWORD *)&v948[10] = v372;
                v373 = _os_log_send_and_compose_impl();
                LOBYTE(info.numer) = 16;
                v946 = OS_LOG_TYPE_DEFAULT;
                v918 = (os_log_t)v373;
                if (!__nwlog_fault())
                  goto LABEL_987;
                if (LOBYTE(info.numer) != 17)
                {
                  if (v946)
                  {
                    v391 = (void *)__nw_create_backtrace_string();
                    v392 = __nwlog_obj();
                    v393 = info.numer;
                    v874 = v392;
                    v394 = os_log_type_enabled(v392, info.numer);
                    if (v391)
                    {
                      if (v394)
                      {
                        v395 = *(unsigned __int16 *)(v18 + 196);
                        *(_DWORD *)buf = 136447234;
                        *(_QWORD *)&buf[4] = "__nw_frame_collapse";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = "frame->aggregate_buffer_length";
                        *(_WORD *)&buf[22] = 2048;
                        *(_QWORD *)v948 = v368;
                        *(_WORD *)&v948[8] = 2048;
                        *(_QWORD *)&v948[10] = v395;
                        *(_WORD *)&v948[18] = 2082;
                        *(_QWORD *)&v948[20] = v391;
                        _os_log_impl(&dword_209FB3000, v874, v393, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                      }
                      free(v391);
                      goto LABEL_987;
                    }
                    if (!v394)
                      goto LABEL_987;
                    v425 = *(unsigned __int16 *)(v18 + 196);
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "__nw_frame_collapse";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = "frame->aggregate_buffer_length";
                    *(_WORD *)&buf[22] = 2048;
                    *(_QWORD *)v948 = v368;
                    *(_WORD *)&v948[8] = 2048;
                    *(_QWORD *)&v948[10] = v425;
                    v377 = v874;
                    v378 = v393;
                    v379 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                  }
                  else
                  {
                    v404 = __nwlog_obj();
                    v405 = info.numer;
                    if (!os_log_type_enabled(v404, info.numer))
                      goto LABEL_987;
                    v406 = *(unsigned __int16 *)(v18 + 196);
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "__nw_frame_collapse";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = "frame->aggregate_buffer_length";
                    *(_WORD *)&buf[22] = 2048;
                    *(_QWORD *)v948 = v368;
                    *(_WORD *)&v948[8] = 2048;
                    *(_QWORD *)&v948[10] = v406;
                    v377 = v404;
                    v378 = v405;
                    v379 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                  }
LABEL_986:
                  _os_log_impl(&dword_209FB3000, v377, v378, v379, buf, 0x2Au);
                  goto LABEL_987;
                }
                v374 = __nwlog_obj();
                v375 = info.numer;
                if (os_log_type_enabled(v374, info.numer))
                {
                  v376 = *(unsigned __int16 *)(v18 + 196);
                  *(_DWORD *)buf = 136446978;
                  *(_QWORD *)&buf[4] = "__nw_frame_collapse";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = "frame->aggregate_buffer_length";
                  *(_WORD *)&buf[22] = 2048;
                  *(_QWORD *)v948 = v368;
                  *(_WORD *)&v948[8] = 2048;
                  *(_QWORD *)&v948[10] = v376;
                  v377 = v374;
                  v378 = v375;
                  v379 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
                  goto LABEL_986;
                }
LABEL_987:
                if (v918)
                  free(v918);
                *(_WORD *)(v18 + 196) = 0;
                v342 = (size_t)v911;
              }
            }
          }
        }
        if ((*(_WORD *)(v18 + 204) & 0x80) != 0)
          *(_WORD *)(v18 + 196) += v318;
        v426 = *(_DWORD *)(v18 + 56);
        v348 = v426 >= v318;
        v427 = v426 - v318;
        v3 = v916;
        if (v348)
        {
          v430 = 0;
          *(_DWORD *)(v18 + 56) = v427;
          if (!*(_QWORD *)(v916 + 24))
            goto LABEL_1005;
        }
        else
        {
          v428 = __nwlog_obj();
          if (os_log_type_enabled(v428, OS_LOG_TYPE_ERROR))
          {
            v429 = *(_DWORD *)(v18 + 56);
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_frame_unclaim_internal";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v318;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v429;
            _os_log_impl(&dword_209FB3000, v428, OS_LOG_TYPE_ERROR, "%{public}s Frame cannot unclaim %u start bytes (has %u left)", buf, 0x18u);
          }
          v430 = 0;
          if (!*(_QWORD *)(v916 + 24))
            goto LABEL_1005;
        }
        goto LABEL_998;
      }
      v919 = *(_DWORD *)(a1 + 1876);
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_get_compression_generation_count";
      v385 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v946 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (LOBYTE(info.numer) != 17)
        {
          if (v946)
          {
            v399 = (void *)__nw_create_backtrace_string();
            v400 = __nwlog_obj();
            v401 = info.numer;
            v875 = v400;
            v402 = os_log_type_enabled(v400, info.numer);
            if (v399)
            {
              if (v402)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "__nw_frame_get_compression_generation_count";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v399;
                _os_log_impl(&dword_209FB3000, v875, v401, "%{public}s Attempt to get generation-count on a chain-member, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v399);
              goto LABEL_1374;
            }
            if (!v402)
              goto LABEL_1374;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_get_compression_generation_count";
            v388 = v875;
            v389 = v401;
            v390 = "%{public}s Attempt to get generation-count on a chain-member, no backtrace";
          }
          else
          {
            v590 = __nwlog_obj();
            v591 = info.numer;
            if (!os_log_type_enabled(v590, info.numer))
              goto LABEL_1374;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_get_compression_generation_count";
            v388 = v590;
            v389 = v591;
            v390 = "%{public}s Attempt to get generation-count on a chain-member, backtrace limit exceeded";
          }
LABEL_1373:
          _os_log_impl(&dword_209FB3000, v388, v389, v390, buf, 0xCu);
          goto LABEL_1374;
        }
        v386 = __nwlog_obj();
        v387 = info.numer;
        if (os_log_type_enabled(v386, info.numer))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_get_compression_generation_count";
          v388 = v386;
          v389 = v387;
          v390 = "%{public}s Attempt to get generation-count on a chain-member";
          goto LABEL_1373;
        }
      }
LABEL_1374:
      if (v385)
        free(v385);
      v3 = v916;
      if (v919)
        goto LABEL_891;
      goto LABEL_1377;
    }
    if (!*(_WORD *)(a1 + 696) && *(_DWORD *)(a1 + 100) == *(_DWORD *)(a1 + 92))
      *(_WORD *)(a1 + 696) = v303 + (_WORD)v298;
    if (v303 != 1 || (*(_DWORD *)(a1 + 740) & 0x8000) == 0)
    {
      v322 = *(_QWORD **)(a1 + 1056);
      if (((*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) >= 0) & ~v928) != 0)
      {
        if (v322)
        {
          v327 = v322[2] + v303;
          ++v322[1];
          v322[2] = v327;
        }
        v328 = *((_QWORD *)v933 + 31);
        ++*(_QWORD *)(v328 + 16);
        if (v899)
          ++*(_QWORD *)(*((_QWORD *)v933 + 32) + 16);
        if (HIDWORD(v898))
          ++*(_QWORD *)(*((_QWORD *)v933 + 33) + 16);
        if ((_DWORD)v898)
          ++*(_QWORD *)(*((_QWORD *)v933 + 34) + 16);
        *(_QWORD *)(v328 + 24) += v303;
        if (v899)
          *(_QWORD *)(*((_QWORD *)v933 + 32) + 24) += v303;
        if (HIDWORD(v898))
          *(_QWORD *)(*((_QWORD *)v933 + 33) + 24) += v303;
        if ((_DWORD)v898)
          *(_QWORD *)(*((_QWORD *)v933 + 34) + 24) += v303;
        v320 = (_QWORD *)(a1 + 368);
        if ((*(_BYTE *)(a1 + 348) & 4) == 0)
          goto LABEL_848;
      }
      else
      {
        if (v322)
        {
          v323 = v322[4] + v303;
          ++v322[3];
          v322[4] = v323;
        }
        v324 = *((_QWORD *)v933 + 31);
        ++*(_QWORD *)(v324 + 16);
        if (v899)
          ++*(_QWORD *)(*((_QWORD *)v933 + 32) + 16);
        if (HIDWORD(v898))
          ++*(_QWORD *)(*((_QWORD *)v933 + 33) + 16);
        if ((_DWORD)v898)
          ++*(_QWORD *)(*((_QWORD *)v933 + 34) + 16);
        *(_QWORD *)(v324 + 24) += v303;
        if (v899)
          *(_QWORD *)(*((_QWORD *)v933 + 32) + 24) += v303;
        if (HIDWORD(v898))
          *(_QWORD *)(*((_QWORD *)v933 + 33) + 24) += v303;
        if ((_DWORD)v898)
          *(_QWORD *)(*((_QWORD *)v933 + 34) + 24) += v303;
        *(_DWORD *)(a1 + 712) += v303;
        ++*(_DWORD *)(a1 + 720);
        if (*(_QWORD *)(v3 + 24))
        {
          v325 = nw_protocol_tcp_get_all_stats();
          if (v325)
            *(_DWORD *)(v325 + 56) += v303;
        }
        v320 = (_QWORD *)(a1 + 392);
        if ((*(_BYTE *)(a1 + 348) & 4) == 0)
          goto LABEL_848;
      }
LABEL_847:
      ++*v320;
      goto LABEL_848;
    }
    v319 = *(_QWORD *)(a1 + 1056);
    if (v319)
    {
      v320 = (_QWORD *)(v319 + 72);
      goto LABEL_847;
    }
LABEL_848:
    if (!*(_QWORD *)(v3 + 400) || v917 < 0)
    {
      if (v18 && (*(_BYTE *)(v3 + 828) & 2) == 0)
      {
        __nwlog_tcp_log();
        v742 = *(_DWORD *)(v3 + 384);
        v743 = tcpstates[*(int *)(a1 + 12)];
        if (*(_QWORD *)(v3 + 400))
          v744 = "not";
        else
          v744 = "is";
        *(_DWORD *)buf = 136447746;
        *(_QWORD *)&buf[4] = "tcp_output";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v880;
        *(_WORD *)&buf[22] = 2082;
        *(_QWORD *)v948 = v744;
        *(_WORD *)&v948[8] = 1024;
        *(_DWORD *)&v948[10] = v742;
        *(_WORD *)&v948[14] = 1024;
        *(_DWORD *)&v948[16] = v917;
        *(_WORD *)&v948[20] = 1024;
        *(_DWORD *)&v948[22] = v303;
        *(_WORD *)&v948[26] = 2082;
        v949 = v743;
        v745 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v946 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault())
          goto LABEL_1675;
        if (LOBYTE(info.numer) != 17)
        {
          if (v946)
          {
            v770 = (void *)__nw_create_backtrace_string();
            v746 = __nwlog_tcp_log();
            v747 = info.numer;
            v771 = os_log_type_enabled(v746, info.numer);
            if (v770)
            {
              if (v771)
              {
                if (*(_QWORD *)(v3 + 400))
                  v772 = "not";
                else
                  v772 = "is";
                v773 = *(_DWORD *)(v3 + 384);
                v774 = tcpstates[*(int *)(a1 + 12)];
                *(_DWORD *)buf = 136448002;
                *(_QWORD *)&buf[4] = "tcp_output";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v880;
                *(_WORD *)&buf[22] = 2082;
                *(_QWORD *)v948 = v772;
                *(_WORD *)&v948[8] = 1024;
                *(_DWORD *)&v948[10] = v773;
                *(_WORD *)&v948[14] = 1024;
                *(_DWORD *)&v948[16] = v917;
                *(_WORD *)&v948[20] = 1024;
                *(_DWORD *)&v948[22] = v303;
                *(_WORD *)&v948[26] = 2082;
                v949 = v774;
                LOWORD(v950[0]) = 2082;
                *(_QWORD *)((char *)v950 + 2) = v770;
                _os_log_impl(&dword_209FB3000, v746, v747, "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd.sb_cc %u off %d len %d t_state[%{public}s], dumping backtrace:%{public}s", buf, 0x46u);
              }
              free(v770);
              goto LABEL_1675;
            }
            if (!v771)
              goto LABEL_1675;
            if (*(_QWORD *)(v3 + 400))
              v781 = "not";
            else
              v781 = "is";
            v782 = *(_DWORD *)(v3 + 384);
            v783 = tcpstates[*(int *)(a1 + 12)];
            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "tcp_output";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v880;
            *(_WORD *)&buf[22] = 2082;
            *(_QWORD *)v948 = v781;
            *(_WORD *)&v948[8] = 1024;
            *(_DWORD *)&v948[10] = v782;
            *(_WORD *)&v948[14] = 1024;
            *(_DWORD *)&v948[16] = v917;
            *(_WORD *)&v948[20] = 1024;
            *(_DWORD *)&v948[22] = v303;
            *(_WORD *)&v948[26] = 2082;
            v949 = v783;
            v751 = "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd"
                   ".sb_cc %u off %d len %d t_state[%{public}s], no backtrace";
          }
          else
          {
            v746 = __nwlog_tcp_log();
            v747 = info.numer;
            if (!os_log_type_enabled(v746, info.numer))
              goto LABEL_1675;
            if (*(_QWORD *)(v3 + 400))
              v777 = "not";
            else
              v777 = "is";
            v778 = *(_DWORD *)(v3 + 384);
            v779 = tcpstates[*(int *)(a1 + 12)];
            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "tcp_output";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v880;
            *(_WORD *)&buf[22] = 2082;
            *(_QWORD *)v948 = v777;
            *(_WORD *)&v948[8] = 1024;
            *(_DWORD *)&v948[10] = v778;
            *(_WORD *)&v948[14] = 1024;
            *(_DWORD *)&v948[16] = v917;
            *(_WORD *)&v948[20] = 1024;
            *(_DWORD *)&v948[22] = v303;
            *(_WORD *)&v948[26] = 2082;
            v949 = v779;
            v751 = "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd"
                   ".sb_cc %u off %d len %d t_state[%{public}s], backtrace limit exceeded";
          }
LABEL_1674:
          _os_log_impl(&dword_209FB3000, v746, v747, v751, buf, 0x3Cu);
          goto LABEL_1675;
        }
        v746 = __nwlog_tcp_log();
        v747 = info.numer;
        if (os_log_type_enabled(v746, info.numer))
        {
          if (*(_QWORD *)(v3 + 400))
            v748 = "not";
          else
            v748 = "is";
          v749 = *(_DWORD *)(v3 + 384);
          v750 = tcpstates[*(int *)(a1 + 12)];
          *(_DWORD *)buf = 136447746;
          *(_QWORD *)&buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v880;
          *(_WORD *)&buf[22] = 2082;
          *(_QWORD *)v948 = v748;
          *(_WORD *)&v948[8] = 1024;
          *(_DWORD *)&v948[10] = v749;
          *(_WORD *)&v948[14] = 1024;
          *(_DWORD *)&v948[16] = v917;
          *(_WORD *)&v948[20] = 1024;
          *(_DWORD *)&v948[22] = v303;
          *(_WORD *)&v948[26] = 2082;
          v949 = v750;
          v751 = "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd.s"
                 "b_cc %u off %d len %d t_state[%{public}s]";
          goto LABEL_1674;
        }
LABEL_1675:
        if (v745)
          free(v745);
      }
      v508 = 0;
      LOBYTE(v889) = 1;
      goto LABEL_1678;
    }
    v329 = *(_QWORD *)(v3 + 24);
    v330 = *(_QWORD *)(v329 + 32);
    info = 0;
    p_info = &info;
    v331 = v303 + v318;
    if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)(v330 + 24) + 88))(v330, v329))
    {
      if ((*(_BYTE *)(v916 + 828) & 2) == 0)
      {
        v789 = __nwlog_tcp_log();
        v753 = (_QWORD *)(a1 + 632);
        if (os_log_type_enabled(v789, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v880;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)v948 = v303 + v318;
          *(_WORD *)&v948[4] = 1024;
          *(_DWORD *)&v948[6] = v907;
          _os_log_impl(&dword_209FB3000, v789, OS_LOG_TYPE_INFO, "%{public}s %{public}s no output frames len %d, TSO %d", buf, 0x22u);
        }
        v508 = 55;
LABEL_1604:
        LOBYTE(v889) = 1;
        v741 = (_QWORD *)*v753;
        if (*v753)
          goto LABEL_1615;
        goto LABEL_1679;
      }
LABEL_1882:
      v508 = 55;
      v753 = (_QWORD *)(a1 + 632);
      goto LABEL_1604;
    }
    v18 = (uint64_t)info;
    if (!*(_QWORD *)&info)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
      v790 = (void *)_os_log_send_and_compose_impl();
      v946 = OS_LOG_TYPE_ERROR;
      v945 = 0;
      if (!__nwlog_fault())
        goto LABEL_1785;
      if (v946 != OS_LOG_TYPE_FAULT)
      {
        if (v945)
        {
          v803 = (void *)__nw_create_backtrace_string();
          v804 = __nwlog_obj();
          v805 = v946;
          v806 = os_log_type_enabled(v804, v946);
          if (v803)
          {
            if (v806)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v803;
              _os_log_impl(&dword_209FB3000, v804, v805, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v803);
            goto LABEL_1785;
          }
          if (!v806)
            goto LABEL_1785;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
          v793 = "%{public}s called with null frame, no backtrace";
          v820 = v804;
          v821 = v805;
        }
        else
        {
          v791 = __nwlog_obj();
          v792 = v946;
          if (!os_log_type_enabled(v791, v946))
            goto LABEL_1785;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
          v793 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_1783:
          v820 = v791;
          v821 = v792;
        }
        _os_log_impl(&dword_209FB3000, v820, v821, v793, buf, 0xCu);
        goto LABEL_1785;
      }
      v791 = __nwlog_obj();
      v792 = v946;
      if (os_log_type_enabled(v791, v946))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
        v793 = "%{public}s called with null frame";
        goto LABEL_1783;
      }
LABEL_1785:
      if (v790)
        free(v790);
      v752 = 0;
      v753 = (_QWORD *)(a1 + 632);
      if ((*(_BYTE *)(v916 + 828) & 2) != 0)
      {
LABEL_1601:
        if (v18)
        {
          v755 = *(void (**)(uint64_t, _QWORD, uint64_t))(v752 + 80);
          if (v755)
          {
            v756 = *(_QWORD *)(v752 + 88);
            *(_QWORD *)(v752 + 80) = 0;
            *(_QWORD *)(v752 + 88) = 0;
            v755(v752, 0, v756);
            v508 = 6;
            goto LABEL_1604;
          }
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v834 = (void *)_os_log_send_and_compose_impl();
          v946 = OS_LOG_TYPE_ERROR;
          v945 = 0;
          if (!__nwlog_fault())
            goto LABEL_1859;
          if (v946 == OS_LOG_TYPE_FAULT)
          {
            v835 = __nwlog_obj();
            v836 = v946;
            if (os_log_type_enabled(v835, v946))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "__nw_frame_finalize";
              v837 = "%{public}s called with null frame->finalizer";
              goto LABEL_1857;
            }
LABEL_1859:
            if (v834)
LABEL_1860:
              free(v834);
LABEL_1861:
            v508 = 6;
            v753 = (_QWORD *)(a1 + 632);
            goto LABEL_1604;
          }
          if (v945)
          {
            v842 = (void *)__nw_create_backtrace_string();
            v839 = __nwlog_obj();
            v840 = v946;
            v843 = os_log_type_enabled(v839, v946);
            if (v842)
            {
              if (v843)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "__nw_frame_finalize";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v842;
                _os_log_impl(&dword_209FB3000, v839, v840, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v842);
              if (v834)
                goto LABEL_1860;
              goto LABEL_1861;
            }
            if (!v843)
              goto LABEL_1859;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v837 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1866:
            v846 = v839;
            v847 = v840;
LABEL_1858:
            _os_log_impl(&dword_209FB3000, v846, v847, v837, buf, 0xCu);
            goto LABEL_1859;
          }
          v835 = __nwlog_obj();
          v836 = v946;
          if (!os_log_type_enabled(v835, v946))
            goto LABEL_1859;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v837 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        }
        else
        {
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v834 = (void *)_os_log_send_and_compose_impl();
          v946 = OS_LOG_TYPE_ERROR;
          v945 = 0;
          if (!__nwlog_fault())
            goto LABEL_1859;
          if (v946 == OS_LOG_TYPE_FAULT)
          {
            v835 = __nwlog_obj();
            v836 = v946;
            if (os_log_type_enabled(v835, v946))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "__nw_frame_finalize";
              v837 = "%{public}s called with null frame";
              goto LABEL_1857;
            }
            goto LABEL_1859;
          }
          if (v945)
          {
            v838 = (void *)__nw_create_backtrace_string();
            v839 = __nwlog_obj();
            v840 = v946;
            v841 = os_log_type_enabled(v839, v946);
            if (v838)
            {
              if (v841)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "__nw_frame_finalize";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v838;
                _os_log_impl(&dword_209FB3000, v839, v840, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v838);
              goto LABEL_1859;
            }
            if (!v841)
              goto LABEL_1859;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v837 = "%{public}s called with null frame, no backtrace";
            goto LABEL_1866;
          }
          v835 = __nwlog_obj();
          v836 = v946;
          if (!os_log_type_enabled(v835, v946))
            goto LABEL_1859;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v837 = "%{public}s called with null frame, backtrace limit exceeded";
        }
LABEL_1857:
        v846 = v835;
        v847 = v836;
        goto LABEL_1858;
      }
LABEL_1599:
      v754 = __nwlog_tcp_log();
      if (os_log_type_enabled(v754, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_output";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v880;
        _os_log_impl(&dword_209FB3000, v754, OS_LOG_TYPE_INFO, "%{public}s %{public}s output buffer is no longer valid", buf, 0x16u);
      }
      goto LABEL_1601;
    }
    if ((*(_WORD *)(*(_QWORD *)&info + 204) & 0x80) != 0)
      *(_WORD *)(*(_QWORD *)&info + 196) -= v318;
    v332 = *(_DWORD *)(v18 + 56) + v318;
    v333 = *(_DWORD *)(v18 + 60);
    if (v332 <= *(_DWORD *)(v18 + 52) - v333)
    {
      *(_DWORD *)(v18 + 56) = v332;
    }
    else
    {
      v334 = __nwlog_obj();
      if (os_log_type_enabled(v334, OS_LOG_TYPE_ERROR))
      {
        v335 = *(_DWORD *)(v18 + 52);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v332;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v335;
        *(_WORD *)v948 = 1024;
        *(_DWORD *)&v948[2] = v333;
        _os_log_impl(&dword_209FB3000, v334, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
      }
    }
    v336 = *(_QWORD *)(v18 + 112);
    if (!v336
      || (*(_WORD *)(v18 + 204) & 0x100) != 0
      && *MEMORY[0x24BDE08C0]
      && (!((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v18, *(_QWORD *)(v18 + 88))
       || (v336 = *(_QWORD *)(v18 + 112)) == 0))
    {
      v752 = v18;
      v753 = (_QWORD *)(a1 + 632);
      if ((*(_WORD *)(v18 + 204) & 0x100) != 0)
      {
        v752 = v18;
        if (*MEMORY[0x24BDE08C0])
        {
          v752 = v18;
          if ((((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v18, *(_QWORD *)(v18 + 88)) & 1) == 0)
          {
            *(_QWORD *)(a1 + 1056) = 0;
            v752 = v18;
          }
        }
      }
      if ((*(_BYTE *)(v916 + 828) & 2) != 0)
        goto LABEL_1601;
      goto LABEL_1599;
    }
    if (!nw_protocol_tcp_copy_frame_to_buffer(*(_QWORD *)(v916 + 400), v917, v303, (char *)(v336 + *(unsigned int *)(v18 + 56))))
    {
      if ((*(_BYTE *)(v916 + 828) & 2) == 0)
      {
        v794 = __nwlog_tcp_log();
        if (os_log_type_enabled(v794, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v880;
          _os_log_impl(&dword_209FB3000, v794, OS_LOG_TYPE_INFO, "%{public}s %{public}s copy from snd buffer to channel buffer failed", buf, 0x16u);
        }
      }
      v795 = *(void (**)(uint64_t, _QWORD, uint64_t))(v18 + 80);
      v753 = (_QWORD *)(a1 + 632);
      if (v795)
      {
        v796 = *(_QWORD *)(v18 + 88);
        *(_QWORD *)(v18 + 80) = 0;
        *(_QWORD *)(v18 + 88) = 0;
        v795(v18, 0, v796);
        v508 = 55;
        goto LABEL_1604;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_finalize";
      v848 = (void *)_os_log_send_and_compose_impl();
      v946 = OS_LOG_TYPE_ERROR;
      v945 = 0;
      if (!__nwlog_fault())
        goto LABEL_1880;
      if (v946 == OS_LOG_TYPE_FAULT)
      {
        v849 = __nwlog_obj();
        v850 = v946;
        if (os_log_type_enabled(v849, v946))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v851 = "%{public}s called with null frame->finalizer";
          goto LABEL_1878;
        }
        goto LABEL_1880;
      }
      if (v945)
      {
        v852 = (void *)__nw_create_backtrace_string();
        v853 = __nwlog_obj();
        v854 = v946;
        v855 = os_log_type_enabled(v853, v946);
        if (v852)
        {
          if (v855)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v852;
            _os_log_impl(&dword_209FB3000, v853, v854, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v852);
          goto LABEL_1880;
        }
        if (!v855)
        {
LABEL_1880:
          if (v848)
            free(v848);
          goto LABEL_1882;
        }
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v851 = "%{public}s called with null frame->finalizer, no backtrace";
        v856 = v853;
        v857 = v854;
      }
      else
      {
        v849 = __nwlog_obj();
        v850 = v946;
        if (!os_log_type_enabled(v849, v946))
          goto LABEL_1880;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v851 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
LABEL_1878:
        v856 = v849;
        v857 = v850;
      }
      _os_log_impl(&dword_209FB3000, v856, v857, v851, buf, 0xCu);
      goto LABEL_1880;
    }
    if ((*(_WORD *)(v18 + 204) & 0x80) != 0)
      *(_WORD *)(v18 + 196) -= v303;
    v337 = *(_DWORD *)(v18 + 52);
    v338 = *(_DWORD *)(v18 + 56) + v303;
    v339 = *(_DWORD *)(v18 + 60);
    if (v338 <= v337 - v339)
    {
      *(_DWORD *)(v18 + 56) = v338;
    }
    else
    {
      v340 = __nwlog_obj();
      v341 = os_log_type_enabled(v340, OS_LOG_TYPE_ERROR);
      v337 = *(_DWORD *)(v18 + 52);
      if (v341)
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "__nw_frame_claim_internal";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v338;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v337;
        *(_WORD *)v948 = 1024;
        *(_DWORD *)&v948[2] = v339;
        _os_log_impl(&dword_209FB3000, v340, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
        v337 = *(_DWORD *)(v18 + 52);
      }
    }
    v342 = (size_t)v911;
    if (v337)
    {
      v344 = *(unsigned int *)(v18 + 56);
      v343 = *(unsigned int *)(v18 + 60);
      v345 = (v337 - (v343 + v344));
      if (v337 != (_DWORD)v343 + (_DWORD)v344)
      {
        if ((_DWORD)v343)
        {
          v346 = *(_QWORD *)(v18 + 112);
          if (v346)
          {
            memmove((void *)(v346 + v344), (const void *)(v346 + v344 + v345), v343);
            v337 = *(_DWORD *)(v18 + 52);
          }
        }
        *(_DWORD *)(v18 + 52) = v337 - v345;
        if ((*(_WORD *)(v18 + 204) & 0x80) != 0)
        {
          v347 = *(unsigned __int16 *)(v18 + 196);
          v348 = v347 >= v345;
          v349 = v347 - v345;
          *(_WORD *)(v18 + 196) = v349;
          if (!v348 || v349 >= 0x10000)
          {
            __nwlog_obj();
            v350 = *(unsigned __int16 *)(v18 + 196);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "__nw_frame_collapse";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "frame->aggregate_buffer_length";
            *(_WORD *)&buf[22] = 2048;
            *(_QWORD *)v948 = v345;
            *(_WORD *)&v948[8] = 2048;
            *(_QWORD *)&v948[10] = v350;
            v351 = _os_log_send_and_compose_impl();
            v946 = OS_LOG_TYPE_ERROR;
            v945 = 0;
            v873 = (os_log_t)v351;
            if (!__nwlog_fault())
              goto LABEL_943;
            if (v946 != OS_LOG_TYPE_FAULT)
            {
              if (v945)
              {
                v380 = (void *)__nw_create_backtrace_string();
                v381 = __nwlog_obj();
                v382 = v946;
                log = v381;
                v383 = os_log_type_enabled(v381, v946);
                if (v380)
                {
                  if (v383)
                  {
                    v384 = *(unsigned __int16 *)(v18 + 196);
                    *(_DWORD *)buf = 136447234;
                    *(_QWORD *)&buf[4] = "__nw_frame_collapse";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = "frame->aggregate_buffer_length";
                    *(_WORD *)&buf[22] = 2048;
                    *(_QWORD *)v948 = v345;
                    *(_WORD *)&v948[8] = 2048;
                    *(_QWORD *)&v948[10] = v384;
                    *(_WORD *)&v948[18] = 2082;
                    *(_QWORD *)&v948[20] = v380;
                    _os_log_impl(&dword_209FB3000, log, v382, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                  }
                  free(v380);
                  goto LABEL_943;
                }
                if (!v383)
                  goto LABEL_943;
                v407 = *(unsigned __int16 *)(v18 + 196);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "__nw_frame_collapse";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "frame->aggregate_buffer_length";
                *(_WORD *)&buf[22] = 2048;
                *(_QWORD *)v948 = v345;
                *(_WORD *)&v948[8] = 2048;
                *(_QWORD *)&v948[10] = v407;
                v355 = log;
                v356 = v382;
                v357 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              }
              else
              {
                v396 = __nwlog_obj();
                v397 = v946;
                if (!os_log_type_enabled(v396, v946))
                  goto LABEL_943;
                v398 = *(unsigned __int16 *)(v18 + 196);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "__nw_frame_collapse";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "frame->aggregate_buffer_length";
                *(_WORD *)&buf[22] = 2048;
                *(_QWORD *)v948 = v345;
                *(_WORD *)&v948[8] = 2048;
                *(_QWORD *)&v948[10] = v398;
                v355 = v396;
                v356 = v397;
                v357 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              }
LABEL_942:
              _os_log_impl(&dword_209FB3000, v355, v356, v357, buf, 0x2Au);
              goto LABEL_943;
            }
            v352 = __nwlog_obj();
            v353 = v946;
            if (os_log_type_enabled(v352, v946))
            {
              v354 = *(unsigned __int16 *)(v18 + 196);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "__nw_frame_collapse";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "frame->aggregate_buffer_length";
              *(_WORD *)&buf[22] = 2048;
              *(_QWORD *)v948 = v345;
              *(_WORD *)&v948[8] = 2048;
              *(_QWORD *)&v948[10] = v354;
              v355 = v352;
              v356 = v353;
              v357 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
              goto LABEL_942;
            }
LABEL_943:
            if (v873)
              free(v873);
            *(_WORD *)(v18 + 196) = 0;
            v342 = (size_t)v911;
          }
        }
      }
    }
    if ((*(_WORD *)(v18 + 204) & 0x80) != 0)
      *(_WORD *)(v18 + 196) += v331;
    v408 = *(_DWORD *)(v18 + 56);
    v348 = v408 >= v331;
    v409 = v408 - v331;
    if (v348)
    {
      *(_DWORD *)(v18 + 56) = v409;
    }
    else
    {
      v410 = __nwlog_obj();
      if (os_log_type_enabled(v410, OS_LOG_TYPE_ERROR))
      {
        v411 = *(_DWORD *)(v18 + 56);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_frame_unclaim_internal";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v331;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v411;
        _os_log_impl(&dword_209FB3000, v410, OS_LOG_TYPE_ERROR, "%{public}s Frame cannot unclaim %u start bytes (has %u left)", buf, 0x18u);
      }
    }
    v3 = v916;
    v412 = v939;
    if (*(_QWORD *)(v916 + 24))
    {
      v413 = nw_protocol_tcp_get_all_stats();
      if (v413)
        ++*(_QWORD *)(v413 + 32);
      if (*(_QWORD *)(v916 + 24))
      {
        v414 = nw_protocol_tcp_get_all_stats();
        if (v414)
          *(_QWORD *)(v414 + 40) += *(unsigned int *)(v18 + 52);
      }
    }
    if ((v939 & 2) == 0 && v303 + v917 == *(_DWORD *)(v916 + 384))
      v412 = v939 | 8;
LABEL_1007:
    v939 = v412;
    v435 = *(_QWORD *)(v18 + 112);
    if (!v435)
      goto LABEL_1572;
    LOBYTE(v436) = *(_WORD *)(v18 + 204);
    if ((*(_WORD *)(v18 + 204) & 0x100) == 0 || !*MEMORY[0x24BDE08C0])
    {
      v438 = v435 + *(unsigned int *)(v18 + 56);
      if (v314)
        goto LABEL_1016;
LABEL_1013:
      if ((v436 & 0x40) == 0)
      {
        *(_DWORD *)(v18 + 192) = 0;
        goto LABEL_1035;
      }
      goto LABEL_1018;
    }
    if (!((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v18, *(_QWORD *)(v18 + 88))
      || (v437 = *(_QWORD *)(v18 + 112)) == 0)
    {
LABEL_1572:
      if ((*(_WORD *)(v18 + 204) & 0x100) == 0)
        goto LABEL_1607;
      v25 = (_QWORD *)(a1 + 632);
      if (*MEMORY[0x24BDE08C0]
        && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v18, *(_QWORD *)(v18 + 88)) & 1) == 0)
      {
        *(_QWORD *)(a1 + 1056) = 0;
      }
      goto LABEL_1608;
    }
    v438 = v437 + *(unsigned int *)(v18 + 56);
    v436 = *(_WORD *)(v18 + 204);
    if (!v314)
      goto LABEL_1013;
LABEL_1016:
    if ((v436 & 0x40) == 0)
    {
      *(_DWORD *)(v18 + 192) = *(_DWORD *)(a1 + 1876);
      goto LABEL_1035;
    }
LABEL_1018:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_frame_set_compression_generation_count";
    v439 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(info.numer) = 16;
    v946 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault())
      goto LABEL_1032;
    if (LOBYTE(info.numer) == 17)
    {
      v440 = __nwlog_obj();
      v441 = info.numer;
      if (os_log_type_enabled(v440, info.numer))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_set_compression_generation_count";
        v442 = v440;
        v443 = v441;
        v444 = "%{public}s Attempt to set generation-count on a chain-member";
        goto LABEL_1031;
      }
      goto LABEL_1032;
    }
    if (v946 == OS_LOG_TYPE_DEFAULT)
    {
      v449 = __nwlog_obj();
      v450 = info.numer;
      if (!os_log_type_enabled(v449, info.numer))
        goto LABEL_1032;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_set_compression_generation_count";
      v442 = v449;
      v443 = v450;
      v444 = "%{public}s Attempt to set generation-count on a chain-member, backtrace limit exceeded";
LABEL_1031:
      _os_log_impl(&dword_209FB3000, v442, v443, v444, buf, 0xCu);
      goto LABEL_1032;
    }
    v445 = (void *)__nw_create_backtrace_string();
    v446 = __nwlog_obj();
    v447 = info.numer;
    v448 = os_log_type_enabled(v446, info.numer);
    if (v445)
    {
      if (v448)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "__nw_frame_set_compression_generation_count";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v445;
        _os_log_impl(&dword_209FB3000, v446, v447, "%{public}s Attempt to set generation-count on a chain-member, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v445);
      goto LABEL_1032;
    }
    if (v448)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_set_compression_generation_count";
      v442 = v446;
      v443 = v447;
      v444 = "%{public}s Attempt to set generation-count on a chain-member, no backtrace";
      goto LABEL_1031;
    }
LABEL_1032:
    if (v439)
      free(v439);
    v342 = (size_t)v911;
LABEL_1035:
    v451 = *(_QWORD *)(a1 + 80);
    if ((*(_BYTE *)(v451 + 2236) & 2) != 0)
      v452 = in6_pseudo();
    else
      v452 = in_pseudo();
    *(_WORD *)(v438 + 16) = v452;
    HIDWORD(v453) = *(_DWORD *)(v451 + 2224);
    LODWORD(v453) = HIDWORD(v453);
    *(_DWORD *)(v438 + 4) = 0;
    *(_DWORD *)(v438 + 8) = 0;
    *(_DWORD *)v438 = v453 >> 16;
    *(_BYTE *)(v438 + 12) = 80;
    *(_BYTE *)(v438 + 13) = 0;
    *(_WORD *)(v438 + 14) = 0;
    *(_WORD *)(v438 + 18) = 0;
    v454 = *(_DWORD *)(a1 + 740);
    v455 = v904;
    if ((v454 & 0x10000000) == 0
      && ((v454 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 336) == 1 || tcp_do_l4s == 1)
      && ((v454 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
    {
      v456 = *(_DWORD *)(a1 + 348);
      if ((~v456 & 0x300000) == 0)
      {
        v457 = v939;
        if ((v456 & 4) == 0 || (v939 & 2) != 0)
          goto LABEL_1066;
        *(_BYTE *)(v18 + 186) = *(_BYTE *)(v18 + 186) & 0xFC | 1;
        info = 0;
        v458 = mach_timebase_info(&info);
        if (v458)
        {
          v459 = v458;
          v460 = __nwlog_obj();
          if (os_log_type_enabled(v460, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "microuptime_ns";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v459;
            _os_log_impl(&dword_209FB3000, v460, OS_LOG_TYPE_ERROR, "%{public}s mach_timebase_info returned %u", buf, 0x12u);
          }
          v457 = v939;
          v455 = v904;
          v342 = (size_t)v911;
          goto LABEL_1066;
        }
        v562 = mach_absolute_time() * info.numer;
        v563 = v562 / info.denom;
        if ((_WORD)v303)
        {
          v457 = v939;
          v455 = v904;
          if (v562 < info.denom)
          {
            v592 = v562 / info.denom;
          }
          else
          {
            v564 = *(_QWORD *)(a1 + 496);
            if (!v564)
            {
              *(_QWORD *)(a1 + 496) = v563;
              tcp_pacer_get_packet_tx_time_size = (unsigned __int16)v303;
              *(_QWORD *)(v18 + 160) = v563;
              goto LABEL_1066;
            }
            tcp_pacer_get_packet_tx_time_size += (unsigned __int16)v303;
            if (tcp_pacer_get_packet_tx_time_size <= *(_DWORD *)(a1 + 488))
            {
              *(_QWORD *)(v18 + 160) = v564;
              goto LABEL_1066;
            }
            v565 = *(_QWORD *)(a1 + 480);
            if (v565)
            {
              v566 = 1000000000 * (unint64_t)(unsigned __int16)v303 / v565;
              if (v566 >= 0x989680)
                v566 = 10000000;
              goto LABEL_1452;
            }
            __nwlog_obj();
            v599 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
            v600 = *(_DWORD *)(a1 + 144);
            v601 = *(int *)(a1 + 200) >> 5;
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "tcp_pacer_get_packet_interval";
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v599;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)v948 = v600;
            *(_WORD *)&v948[4] = 1024;
            *(_DWORD *)&v948[6] = v601;
            v602 = _os_log_send_and_compose_impl();
            LOBYTE(info.numer) = 16;
            v946 = OS_LOG_TYPE_DEFAULT;
            v921 = (os_log_t)v602;
            if (!__nwlog_fault())
              goto LABEL_1449;
            if (LOBYTE(info.numer) == 17)
            {
              v603 = __nwlog_obj();
              v604 = info.numer;
              if (os_log_type_enabled(v603, info.numer))
              {
                v605 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
                v606 = *(_DWORD *)(a1 + 144);
                v607 = *(int *)(a1 + 200) >> 5;
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "tcp_pacer_get_packet_interval";
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = v605;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)v948 = v606;
                *(_WORD *)&v948[4] = 1024;
                *(_DWORD *)&v948[6] = v607;
                v608 = v603;
                v609 = v604;
                v610 = "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms)";
                goto LABEL_1448;
              }
              goto LABEL_1449;
            }
            if (v946 == OS_LOG_TYPE_DEFAULT)
            {
              v663 = __nwlog_obj();
              v664 = info.numer;
              if (!os_log_type_enabled(v663, info.numer))
                goto LABEL_1449;
              v665 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
              v666 = *(_DWORD *)(a1 + 144);
              v667 = *(int *)(a1 + 200) >> 5;
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "tcp_pacer_get_packet_interval";
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v665;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)v948 = v666;
              *(_WORD *)&v948[4] = 1024;
              *(_DWORD *)&v948[6] = v667;
              v608 = v663;
              v609 = v664;
              v610 = "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms), backtrace limit exceeded";
LABEL_1448:
              _os_log_impl(&dword_209FB3000, v608, v609, v610, buf, 0x22u);
              goto LABEL_1449;
            }
            v631 = (void *)__nw_create_backtrace_string();
            v632 = __nwlog_obj();
            v633 = info.numer;
            v876 = v632;
            v634 = os_log_type_enabled(v632, info.numer);
            if (v631)
            {
              if (v634)
              {
                v635 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
                v636 = *(_DWORD *)(a1 + 144);
                v637 = *(int *)(a1 + 200) >> 5;
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "tcp_pacer_get_packet_interval";
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = v635;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)v948 = v636;
                *(_WORD *)&v948[4] = 1024;
                *(_DWORD *)&v948[6] = v637;
                *(_WORD *)&v948[10] = 2082;
                *(_QWORD *)&v948[12] = v631;
                _os_log_impl(&dword_209FB3000, v876, v633, "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms), dumping backtrace:%{public}s", buf, 0x2Cu);
              }
              free(v631);
              goto LABEL_1449;
            }
            if (v634)
            {
              v672 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
              v673 = *(_DWORD *)(a1 + 144);
              v674 = *(int *)(a1 + 200) >> 5;
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "tcp_pacer_get_packet_interval";
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v672;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)v948 = v673;
              *(_WORD *)&v948[4] = 1024;
              *(_DWORD *)&v948[6] = v674;
              v608 = v876;
              v609 = v633;
              v610 = "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms), no backtrace";
              goto LABEL_1448;
            }
LABEL_1449:
            if (v921)
              free(v921);
            v564 = *(_QWORD *)(a1 + 496);
            v566 = 10000000;
            v457 = v939;
            v455 = v904;
            v342 = (size_t)v911;
LABEL_1452:
            v592 = v564 + v566;
            *(_QWORD *)(a1 + 496) = v592;
            tcp_pacer_get_packet_tx_time_size = (unsigned __int16)v303;
            if (v563 > v592)
            {
              *(_QWORD *)(a1 + 496) = v563;
              goto LABEL_1455;
            }
          }
        }
        else
        {
          v592 = v562 / info.denom;
          v457 = v939;
          v455 = v904;
        }
        v563 = v592;
        if (!v592)
          goto LABEL_1066;
LABEL_1455:
        *(_QWORD *)(v18 + 160) = v563;
        goto LABEL_1066;
      }
    }
    v461 = (*(unsigned __int8 *)(a1 + 348) >> 2) & 1;
    if (!v303)
      v461 = 0;
    v457 = v939;
    if (!v900)
    {
      if (!v461)
        goto LABEL_1066;
      v462 = v928;
      if (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) < 0)
        v462 = 1;
      if ((v462 & 1) != 0 || (v939 & 2) != 0)
        goto LABEL_1066;
LABEL_1065:
      *(_BYTE *)(v18 + 186) = *(_BYTE *)(v18 + 186) & 0xFC | 2;
      goto LABEL_1066;
    }
    if (v461)
    {
      v463 = v928;
      if (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) < 0)
        v463 = 1;
      if ((v463 & 1) == 0)
        goto LABEL_1065;
    }
LABEL_1066:
    v121 = a1 + 100;
    if ((v457 & 1) != 0 && (*(_BYTE *)(a1 + 88) & 0x10) != 0)
    {
      v464 = *(_DWORD *)(a1 + 100);
      if (v464 == *(_DWORD *)(a1 + 96))
        *type = v464 - 1;
    }
    if (!v455)
    {
      v466 = v303 - 1;
      if ((*(_DWORD *)(a1 + 740) & 0x20400020) == 0x20000020)
      {
        v467 = *(_DWORD *)v55;
        *(_DWORD *)(v438 + 4) = bswap32(*(_DWORD *)v55);
        tcp_rxtseg_insert((_QWORD *)a1, v467, v466 + v467);
      }
      else
      {
        v469 = *v891;
        *(_DWORD *)(v438 + 4) = bswap32(*v891);
        tcp_rxtseg_insert((_QWORD *)a1, v469, v466 + v469);
        *v891 += v303;
        v342 = (size_t)v911;
        *(_DWORD *)(a1 + 624) += v303;
      }
      goto LABEL_1081;
    }
    if (v303 | v457 & 3)
    {
      v465 = *(_DWORD *)(a1 + 96);
      goto LABEL_1076;
    }
    v465 = *(_DWORD *)(a1 + 96);
    if (*(_DWORD *)(a1 + 36))
    {
LABEL_1076:
      v468 = *type;
      *(_DWORD *)(v438 + 4) = bswap32(*type);
      if ((int)(v468 - v465) < 0)
      {
        if (v303 > 1 && (*(_DWORD *)(a1 + 740) & 0x1020) == 0x20)
        {
          tcp_rxtseg_insert((_QWORD *)a1, v468, v303 + v468 - 1);
          goto LABEL_1082;
        }
LABEL_1081:
        if (v303 >= 1)
LABEL_1082:
          *(_BYTE *)(v18 + 186) |= 4u;
      }
    }
    else
    {
      *(_DWORD *)(v438 + 4) = bswap32(v465);
    }
    v470 = *(_DWORD *)(a1 + 120);
    *(_DWORD *)(v438 + 8) = bswap32(v470);
    *(_DWORD *)(a1 + 284) = v470;
    if ((_DWORD)v342)
    {
      memmove((void *)(v438 + 20), __src, v342);
      v471 = ((4 * v896) & 0xF0) + 80;
    }
    else
    {
      v471 = *(_BYTE *)(v438 + 12);
    }
    *(_BYTE *)(v438 + 13) = v457;
    *(_BYTE *)(v438 + 12) = v471 & 0xF0 | HIBYTE(v457) & 1;
    v472 = v902 >> *(_BYTE *)(a1 + 261);
    *(_WORD *)(v438 + 14) = bswap32(v472) >> 16;
    *(_DWORD *)(a1 + 132) = v902;
    if (v902 >= 1)
    {
      v473 = *(_DWORD *)(a1 + 120) + v902;
      if (*(_DWORD *)(a1 + 124) - v473 < 0)
        *(_DWORD *)(a1 + 124) = v473;
    }
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 88) & 0xFFFBFFFF | (((unsigned __int16)v472 == 0) << 18);
    v474 = *(_DWORD *)(a1 + 12);
    if ((v474 - 7) < 2 || v474 != 4 && (v474 == 10 || (v457 & 4) != 0))
      *(_BYTE *)(v18 + 186) |= 8u;
    v475 = *((_QWORD *)v933 + 62);
    if (v303 + (_DWORD)v342)
      *(_WORD *)(v438 + 16) = in_addword();
    if (!v475)
      goto LABEL_1262;
    v476 = *(_QWORD *)(v475 + 216);
    if (!v476)
      goto LABEL_1262;
    v477 = *(_DWORD *)(v476 + 1048);
    if ((v477 & 0x1000) != 0)
    {
      if ((*(_WORD *)(v18 + 204) & 0x100) == 0)
        goto LABEL_1112;
      v479 = (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD))*MEMORY[0x24BDE08C8];
      if (!*MEMORY[0x24BDE08C8])
        goto LABEL_1112;
      *(_BYTE *)(v18 + 203) |= 1u;
      v480 = 1;
      v481 = v479(v18, 1, v882, v881);
      if (v481)
      {
        v482 = v481;
        if (v481 != 45 && (*(_BYTE *)(v916 + 828) & 2) == 0)
        {
          v483 = __nwlog_tcp_log();
          if (os_log_type_enabled(v483, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "tcp_output";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v880;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)v948 = v482;
            _os_log_impl(&dword_209FB3000, v483, OS_LOG_TYPE_ERROR, "%{public}s %{public}s set internet checksum offload failed (err %d)", buf, 0x1Cu);
          }
        }
        goto LABEL_1112;
      }
LABEL_1113:
      LOWORD(v484) = v907;
      if (!v907)
        goto LABEL_1115;
LABEL_1114:
      v484 = *(_DWORD *)(a1 + 156) - (_DWORD)v911;
      goto LABEL_1115;
    }
    if (!v900)
    {
      if ((((v477 & 2) == 0) & ~v907) == 0 && (*(_WORD *)(v18 + 204) & 0x100) != 0)
      {
        v478 = *(_BYTE *)(v18 + 203) | 8;
        goto LABEL_1261;
      }
LABEL_1112:
      v480 = 0;
      goto LABEL_1113;
    }
    if ((((v477 & 0x20) == 0) & ~v907) != 0 || (*(_WORD *)(v18 + 204) & 0x100) == 0)
      goto LABEL_1112;
    v478 = *(_BYTE *)(v18 + 203) | 0x20;
LABEL_1261:
    *(_BYTE *)(v18 + 203) = v478;
LABEL_1262:
    v480 = 1;
    LOWORD(v484) = v907;
    if (v907)
      goto LABEL_1114;
LABEL_1115:
    v485 = *(unsigned __int16 *)(v18 + 204);
    *(_WORD *)(v18 + 198) = v484;
    v486 = (v485 | (*(unsigned __int8 *)(v18 + 206) << 16)) & 0xFFFDFFFF | (v900 << 16);
    *(_WORD *)(v18 + 204) = v485;
    *(_BYTE *)(v18 + 206) = BYTE2(v486);
    if ((*(_BYTE *)(a1 + 741) & 0x80) != 0 && *(_DWORD *)(a1 + 36))
    {
      v487 = ((v939 >> 1) & 1) + v303;
      if ((v939 & 1) != 0)
      {
        v488 = *(_DWORD *)(a1 + 88);
        if ((v488 & 0x10) == 0)
        {
          ++v487;
          *(_DWORD *)(a1 + 88) = v488 | 0x10;
        }
      }
      v489 = *(_DWORD *)(a1 + 100);
      if (v489 + v487 - *(_DWORD *)(a1 + 96) >= 1)
      {
        *(_DWORD *)(a1 + 96) = v489 + v303;
        *(_DWORD *)(a1 + 164) = *v903;
        if (*(_QWORD *)(v916 + 24))
        {
          v490 = nw_protocol_tcp_get_all_stats();
          if (v490)
            *(_DWORD *)(v490 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
        }
      }
      goto LABEL_1171;
    }
    v491 = *type;
    v492 = *type;
    if ((v939 & 3) != 0)
    {
      v492 = *type;
      if ((v939 & 2) != 0)
      {
        v492 = v491 + 1;
        *type = v491 + 1;
      }
      if ((v939 & 1) != 0)
      {
        v493 = *(_DWORD *)(a1 + 88);
        if ((v493 & 0x10) == 0)
        {
          *(_DWORD *)(a1 + 100) = ++v492;
          *(_DWORD *)(a1 + 88) = v493 | 0x10;
        }
      }
    }
    if ((v928 & 1) == 0)
    {
      if (v890 == 1)
      {
        v494 = v884;
        *(_DWORD *)(a1 + 100) = v884;
        v495 = *(_QWORD *)(a1 + 1056);
        if (v495)
        {
          ++*(_QWORD *)(v495 + 760);
          v494 = v884;
        }
      }
      else
      {
        v494 = v492 + v303;
        *type = v494;
      }
      if ((int)(v494 - *(_DWORD *)(a1 + 96)) < 1)
        goto LABEL_1914;
      *(_DWORD *)(a1 + 96) = v494;
      *(_DWORD *)(a1 + 164) = *v903;
      if (*(_QWORD *)(v916 + 24))
      {
        v496 = nw_protocol_tcp_get_all_stats();
        if (v496)
          *(_DWORD *)(v496 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
      }
      if (*(_DWORD *)(a1 + 172))
      {
LABEL_1914:
        if (*(_DWORD *)(a1 + 28))
        {
LABEL_1145:
          v890 = 0;
          goto LABEL_1155;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 172) = *v903;
        *(_DWORD *)(a1 + 176) = v491;
        v497 = *(_QWORD *)(a1 + 1056);
        if (v497)
          ++*(_QWORD *)(v497 + 472);
        *(_DWORD *)(a1 + 976) = *(_DWORD *)(a1 + 92);
        if (*(_DWORD *)(a1 + 28))
          goto LABEL_1145;
      }
      v890 = 0;
      v492 = *type;
      if ((v939 & 1) != 0)
        goto LABEL_1152;
      goto LABEL_1151;
    }
    if (!*(_DWORD *)(a1 + 28))
    {
      if (v492 != *(_DWORD *)(a1 + 96) || (v939 & 1) != 0)
      {
LABEL_1152:
        if (*(_DWORD *)(a1 + 36))
        {
          *(_DWORD *)(a1 + 36) = 0;
          *(_DWORD *)(a1 + 316) = 0;
          *(_WORD *)(a1 + 226) = 0;
          *(_DWORD *)(a1 + 248) = 0;
        }
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316)
                             - *(_DWORD *)(a1 + 64);
        goto LABEL_1155;
      }
LABEL_1151:
      if (v492 != *(_DWORD *)(a1 + 92))
        goto LABEL_1152;
    }
LABEL_1155:
    if (v303)
    {
      if (*(_DWORD *)(sysctls + 132))
      {
        if (*(_DWORD *)(a1 + 12) == 4)
        {
          v498 = *(_DWORD *)(a1 + 740);
          if ((v498 & 0x20) != 0 && (*(_BYTE *)(a1 + 90) & 0x20) == 0)
          {
            v499 = *(_DWORD *)(a1 + 100);
            if (v499 == *(_DWORD *)(a1 + 96))
            {
              v500 = v499 - *(_DWORD *)(a1 + 92);
              if (v500 >= 1 && (v498 & 0x3000) == 0 && !*(_WORD *)(a1 + 226))
              {
                if (v500 <= *(_DWORD *)(a1 + 196))
                  v501 = 100;
                else
                  v501 = 2;
                v502 = v501 + 2 * (*(int *)(a1 + 200) >> 5);
                if (*(_DWORD *)(a1 + 192) >= v502)
                  v503 = v502;
                else
                  v503 = *(_DWORD *)(a1 + 192);
                *(_DWORD *)(a1 + 16) = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316)
                                     + v503
                                     - *(_DWORD *)(a1 + 64);
              }
            }
          }
        }
      }
    }
LABEL_1171:
    v504 = *((_QWORD *)v933 + 56);
    if (!v504 || (*(_WORD *)(v504 + 1074) & 8) != 0)
    {
      v507 = v892;
      if (v892 > 499)
      {
        if (v892 <= 699)
        {
          if (v892 == 500)
          {
            v507 = 2621728;
            goto LABEL_1182;
          }
          if (v892 == 600)
          {
            v507 = 3146000;
            goto LABEL_1182;
          }
        }
        else
        {
          switch(v892)
          {
            case 700:
              v507 = 3670272;
              goto LABEL_1182;
            case 800:
              v507 = 4194688;
              goto LABEL_1182;
            case 900:
              v507 = 4718992;
              goto LABEL_1182;
          }
        }
      }
      else if (v892 <= 199)
      {
        if (!v892)
          goto LABEL_1182;
        if (v892 == 100)
        {
          v507 = 524432;
          goto LABEL_1182;
        }
      }
      else
      {
        switch(v892)
        {
          case 200:
            v507 = 1048704;
            goto LABEL_1182;
          case 300:
            v507 = 1572880;
            goto LABEL_1182;
          case 400:
            v507 = 2097184;
            goto LABEL_1182;
        }
      }
      v507 = 0;
    }
    else
    {
      if (!v303 && (*(_DWORD *)(v504 + 1052) & 0x200080) == 0x80)
      {
        v505 = *(unsigned __int8 *)(v438 + 13);
        if (v505 == 16 && *(_DWORD *)(a1 + 92) == *(_DWORD *)(a1 + 96))
        {
          v506 = v888;
          if (!*(_DWORD *)(a1 + 28))
            v506 = v888 | 2;
          v888 = v506;
        }
        v888 |= (2 * v505) & 4;
      }
      *(_DWORD *)buf = 0;
      set_frame_service_class(v18, v916, v892, v888, (int *)buf);
      v507 = *(_DWORD *)buf;
    }
LABEL_1182:
    *(_DWORD *)(v18 + 176) = v507;
    *(_DWORD *)(a1 + 648) += v303;
    ++*(_DWORD *)(a1 + 300);
    if ((v480 & 1) != 0)
      goto LABEL_1191;
    v508 = in_finalize_cksum();
    if ((_DWORD)v508
      && (*(_WORD *)(v18 + 204) & 0x100) != 0
      && *MEMORY[0x24BDE08C0]
      && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v18, *(_QWORD *)(v18 + 88)) & 1) == 0)
    {
      goto LABEL_1886;
    }
    v509 = *(_DWORD *)(v18 + 52);
    if (v509)
    {
      v510 = (v509 - (*(_DWORD *)(v18 + 56) + *(_DWORD *)(v18 + 60)));
      v511 = *(_QWORD *)(a1 + 1056);
      if (v511)
        goto LABEL_1189;
    }
    else
    {
      v510 = 0;
      v511 = *(_QWORD *)(a1 + 1056);
      if (v511)
      {
LABEL_1189:
        ++*(_QWORD *)(v511 + v886);
        *(_QWORD *)(v511 + v885) += v510;
      }
    }
    if ((_DWORD)v508)
      goto LABEL_1887;
LABEL_1191:
    if ((*(_BYTE *)(v438 + 13) & 0x24) != 0)
    {
      if ((*(_BYTE *)(v916 + 828) & 2) == 0)
      {
        v613 = __nwlog_tcp_log();
        if (os_log_type_enabled(v613, OS_LOG_TYPE_ERROR))
        {
          v614 = *(unsigned __int8 *)(v438 + 13);
          v615 = bswap32(*(_DWORD *)(v438 + 4));
          v616 = bswap32(*(_DWORD *)(v438 + 8));
          v617 = bswap32(*(unsigned __int16 *)(v438 + 14));
          v618 = *(_DWORD *)(a1 + 12);
          v619 = *(_DWORD *)(a1 + 120);
          v620 = *(_DWORD *)(a1 + 92);
          *(_DWORD *)buf = 136448258;
          *(_QWORD *)&buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v880;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)v948 = v614;
          *(_WORD *)&v948[4] = 1024;
          *(_DWORD *)&v948[6] = v615;
          *(_WORD *)&v948[10] = 1024;
          *(_DWORD *)&v948[12] = v616;
          *(_WORD *)&v948[16] = 1024;
          *(_DWORD *)&v948[18] = HIWORD(v617);
          *(_WORD *)&v948[22] = 1024;
          *(_DWORD *)&v948[24] = v618;
          LOWORD(v949) = 1024;
          *(_DWORD *)((char *)&v949 + 2) = v619;
          HIWORD(v949) = 1024;
          v950[0] = v620;
          v621 = v613;
          v622 = OS_LOG_TYPE_ERROR;
          goto LABEL_1404;
        }
      }
    }
    else if ((*(_BYTE *)(v438 + 13) & 3) != 0 && (*(_BYTE *)(v916 + 828) & 2) == 0)
    {
      v623 = __nwlog_tcp_log();
      if (os_log_type_enabled(v623, OS_LOG_TYPE_DEFAULT))
      {
        v624 = *(unsigned __int8 *)(v438 + 13);
        v625 = bswap32(*(_DWORD *)(v438 + 4));
        v626 = bswap32(*(_DWORD *)(v438 + 8));
        v627 = bswap32(*(unsigned __int16 *)(v438 + 14));
        v628 = *(_DWORD *)(a1 + 12);
        v629 = *(_DWORD *)(a1 + 120);
        v630 = *(_DWORD *)(a1 + 92);
        *(_DWORD *)buf = 136448258;
        *(_QWORD *)&buf[4] = "tcp_output";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v880;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v948 = v624;
        *(_WORD *)&v948[4] = 1024;
        *(_DWORD *)&v948[6] = v625;
        *(_WORD *)&v948[10] = 1024;
        *(_DWORD *)&v948[12] = v626;
        *(_WORD *)&v948[16] = 1024;
        *(_DWORD *)&v948[18] = HIWORD(v627);
        *(_WORD *)&v948[22] = 1024;
        *(_DWORD *)&v948[24] = v628;
        LOWORD(v949) = 1024;
        *(_DWORD *)((char *)&v949 + 2) = v629;
        HIWORD(v949) = 1024;
        v950[0] = v630;
        v621 = v623;
        v622 = OS_LOG_TYPE_DEFAULT;
LABEL_1404:
        _os_log_impl(&dword_209FB3000, v621, v622, "%{public}s %{public}s flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u", buf, 0x40u);
      }
    }
    tcp_log_packet(a1);
    *(_QWORD *)(v18 + 32) = 0;
    v512 = *(uint64_t **)(a1 + 640);
    *(_QWORD *)(v18 + 40) = v512;
    *v512 = v18;
    *(_QWORD *)(a1 + 640) = v18 + 32;
    v513 = *(_DWORD *)(a1 + 740);
    v514 = v905;
    if ((~v513 & 0x20000020) != 0 || !v303 || (v513 & 0x400000) != 0)
      goto LABEL_1351;
    v515 = *(unsigned __int8 *)(v18 + 186);
    if ((v513 & 0x1000) != 0)
      v516 = (2 * v515) & 8;
    else
      v516 = (v515 << 29 >> 31) & 0xC;
    v517 = bswap32(*(_DWORD *)(v438 + 4));
    v518 = v517 + v303;
    v519 = *v903;
    if (!v55)
    {
      if (v516 > 7)
      {
        v535 = *v887;
        if (!*v887)
          goto LABEL_1351;
        v536 = *v887;
        do
        {
          while (1)
          {
            v537 = *(_DWORD *)(v536 + 4);
            if ((int)(v518 - v537) >= 0)
              break;
            v536 = *(_QWORD *)(v536 + 32);
            if (!v536)
              goto LABEL_1244;
          }
          if (v518 == v537)
          {
            tcp_process_rxmt_segs_after_rto(a1, (int *)v536, v517, *v903, v516);
            goto LABEL_1333;
          }
          v536 = *(_QWORD *)(v536 + 40);
        }
        while (v536);
        do
        {
LABEL_1244:
          v538 = v535;
          v535 = *(_QWORD *)(v535 + 32);
        }
        while (v535);
        do
        {
          while (1)
          {
LABEL_1253:
            v540 = v538;
            if ((int)(v518 - *(_DWORD *)(v538 + 4)) < 0 && (int)(v518 - *(_DWORD *)v538) >= 1)
            {
              tcp_seg_rto_insert_end(a1, *(_DWORD *)v538, v517 + v303, *v903, *(_BYTE *)(v538 + 12) | v516);
              v514 = v905;
              v541 = *(_DWORD *)v540;
              if ((int)(*(_DWORD *)v540 - v517) >= 1)
              {
                v542 = *v887;
                if (*v887)
                {
                  while (1)
                  {
                    while (1)
                    {
                      v588 = *(_DWORD *)(v542 + 4);
                      if (v541 - v588 >= 0)
                        break;
                      v542 = *(_QWORD *)(v542 + 32);
                      if (!v542)
                        goto LABEL_1420;
                    }
                    if (v541 == v588)
                      break;
                    v542 = *(_QWORD *)(v542 + 40);
                    if (!v542)
                      goto LABEL_1420;
                  }
                  tcp_process_rxmt_segs_after_rto(a1, (int *)v542, v517, v519, v516);
                  v514 = v905;
                }
              }
LABEL_1420:
              *(_DWORD *)v540 = v518;
              v579 = v906;
              if (v906)
                goto LABEL_1352;
              goto LABEL_1421;
            }
            v539 = *(_QWORD *)(v538 + 40);
            if (!v539)
              break;
            do
            {
              v538 = v539;
              v539 = *(_QWORD *)(v539 + 32);
            }
            while (v539);
          }
          v538 = *(_QWORD *)(v538 + 48) & 0xFFFFFFFFFFFFFFFELL;
        }
        while (v538 && *(_QWORD *)(v538 + 32) == v540);
        while (1)
        {
          v538 = *(_QWORD *)(v540 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v538)
            break;
          v59 = v540 == *(_QWORD *)(v538 + 40);
          v540 = *(_QWORD *)(v540 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v59)
            goto LABEL_1253;
        }
LABEL_1351:
        v579 = v906;
        if (v906)
        {
LABEL_1352:
          if (*(_DWORD *)(a1 + 12) == 4
            && *(_DWORD *)(a1 + 144) > *(_DWORD *)(a1 + 140) >> 3
            && (*(_BYTE *)(a1 + 88) & 1) == 0
            && (*(_BYTE *)(a1 + 741) & 0x80) == 0
            && *(_DWORD *)(a1 + 300) < *(_DWORD *)(sysctls + 100))
          {
            v587 = *(_QWORD **)(a1 + 1056);
            v25 = (_QWORD *)(a1 + 632);
            v3 = v916;
            v2 = v933;
            if (v587)
              ++*v587;
            continue;
          }
        }
        goto LABEL_1421;
      }
      v529 = *(_QWORD *)(a1 + 2024);
      if (v529)
      {
        v530 = *(_QWORD *)(v529 + 72);
        v531 = *(_QWORD **)(v529 + 80);
        if (v530)
        {
          *(_QWORD *)(v530 + 80) = v531;
          v531 = *(_QWORD **)(v529 + 80);
        }
        else
        {
          *(_QWORD *)(a1 + 2032) = v531;
        }
        *v531 = v530;
        --*(_DWORD *)(a1 + 2040);
      }
      else
      {
        v555 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
        v556 = malloc_type_malloc(**(_QWORD **)(v555 + 64), 0xB9BAFBABuLL);
        v514 = v905;
        v529 = (unint64_t)v556;
        if (!v556)
          goto LABEL_1351;
      }
      *(_OWORD *)(v529 + 72) = 0u;
      *(_OWORD *)(v529 + 60) = 0u;
      *(_OWORD *)(v529 + 44) = 0u;
      *(_OWORD *)(v529 + 28) = 0u;
      *(_OWORD *)(v529 + 12) = 0u;
      *(_DWORD *)v529 = v517;
      *(_DWORD *)(v529 + 4) = v518;
      *(_DWORD *)(v529 + 8) = v519;
      if ((int)(v517 - *(_DWORD *)(a1 + 2060)) < 0)
      {
        *(_DWORD *)(a1 + 2060) = v517;
        *(_BYTE *)(v529 + 12) = v516;
        if ((v516 & 4) != 0)
          goto LABEL_1319;
LABEL_1309:
        v567 = *(char *)(a1 + 2069);
        if (v567 < 0)
        {
LABEL_1311:
          v568 = *v887;
          if (*v887)
          {
            while (1)
            {
              while (1)
              {
                v569 = v568;
                v570 = *(_DWORD *)(v529 + 4) - *(_DWORD *)(v568 + 4);
                if (v570 >= 0)
                  break;
                v568 = *(_QWORD *)(v568 + 32);
                if (!v568)
                  goto LABEL_1322;
              }
              if (!v570)
                break;
              v568 = *(_QWORD *)(v568 + 40);
              if (!v568)
                goto LABEL_1322;
            }
            v572 = __nwlog_obj();
            if (os_log_type_enabled(v572, OS_LOG_TYPE_ERROR))
            {
              v573 = *(_DWORD *)v569;
              v574 = *(_DWORD *)(v569 + 4);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "tcp_seg_sent_insert";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v569;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)v948 = v573;
              *(_WORD *)&v948[4] = 1024;
              *(_DWORD *)&v948[6] = v574;
              _os_log_impl(&dword_209FB3000, v572, OS_LOG_TYPE_ERROR, "%{public}s segment %p[%u %u) was not inserted in the RB tree", buf, 0x22u);
            }
          }
          else
          {
            v569 = 0;
            v570 = 0;
LABEL_1322:
            *(_QWORD *)(v529 + 32) = 0;
            *(_QWORD *)(v529 + 40) = 0;
            *(_QWORD *)(v529 + 48) = v569 | 1;
            v571 = (unint64_t *)(a1 + 2000);
            if (v569)
            {
              if (v570 < 0)
                v571 = (unint64_t *)(v569 + 32);
              else
                v571 = (unint64_t *)(v569 + 40);
            }
            *v571 = v529;
            tcp_seg_sent_tree_head_RB_INSERT_COLOR((uint64_t)v887, v529);
          }
          *(_QWORD *)(v529 + 16) = 0;
          v560 = v529 + 16;
          v578 = *(unint64_t **)(a1 + 1992);
          *(_QWORD *)(v529 + 24) = v578;
          *v578 = v529;
          goto LABEL_1332;
        }
      }
      else
      {
        *(_BYTE *)(v529 + 12) = v516;
        if ((v516 & 4) == 0)
          goto LABEL_1309;
LABEL_1319:
        *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v529);
        v567 = *(char *)(a1 + 2069);
        if (v567 < 0)
          goto LABEL_1311;
      }
      *(_BYTE *)(a1 + 2069) = v567 | (32 * v516);
      goto LABEL_1311;
    }
    v520 = *(_BYTE *)(v55 + 12) | v516;
    if (*(_DWORD *)(v55 + 4) == v518)
    {
      if (*(_DWORD *)v55 != v517)
      {
        v920 = *v903;
        __nwlog_obj();
        v521 = *(_DWORD *)v55;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "tcp_seg_sent_insert";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v521;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v517;
        v522 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v946 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault())
          goto LABEL_1338;
        if (LOBYTE(info.numer) != 17)
        {
          if (v946)
          {
            v545 = (void *)__nw_create_backtrace_string();
            v546 = __nwlog_obj();
            v547 = info.numer;
            v548 = os_log_type_enabled(v546, info.numer);
            if (v545)
            {
              if (v548)
              {
                v549 = *(_DWORD *)v55;
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "tcp_seg_sent_insert";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v549;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v517;
                *(_WORD *)v948 = 2082;
                *(_QWORD *)&v948[2] = v545;
                _os_log_impl(&dword_209FB3000, v546, v547, "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u), dumping backtrace:%{public}s", buf, 0x22u);
              }
              free(v545);
              goto LABEL_1338;
            }
            if (!v548)
              goto LABEL_1338;
            v580 = *(_DWORD *)v55;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "tcp_seg_sent_insert";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v580;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v517;
            v526 = v546;
            v527 = v547;
            v528 = "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u), no backtrace";
          }
          else
          {
            v575 = __nwlog_obj();
            v576 = info.numer;
            if (!os_log_type_enabled(v575, info.numer))
              goto LABEL_1338;
            v577 = *(_DWORD *)v55;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "tcp_seg_sent_insert";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v577;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v517;
            v526 = v575;
            v527 = v576;
            v528 = "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u), backtrace limit exceeded";
          }
LABEL_1337:
          _os_log_impl(&dword_209FB3000, v526, v527, v528, buf, 0x18u);
          goto LABEL_1338;
        }
        v523 = __nwlog_obj();
        v524 = info.numer;
        if (os_log_type_enabled(v523, info.numer))
        {
          v525 = *(_DWORD *)v55;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "tcp_seg_sent_insert";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v525;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v517;
          v526 = v523;
          v527 = v524;
          v528 = "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u)";
          goto LABEL_1337;
        }
LABEL_1338:
        if (v522)
          free(v522);
        v517 = *(_DWORD *)v55;
        v518 = *(_DWORD *)(v55 + 4);
        v514 = v905;
        v519 = v920;
      }
      *(_DWORD *)v55 = v517;
      *(_DWORD *)(v55 + 4) = v518;
      *(_DWORD *)(v55 + 8) = v519;
      if ((int)(v517 - *(_DWORD *)(a1 + 2060)) < 0)
        *(_DWORD *)(a1 + 2060) = v517;
      v581 = *(_BYTE *)(v55 + 12) | v520;
      *(_BYTE *)(v55 + 12) = v581;
      if ((v581 & 4) != 0)
      {
        v582 = tcp_seg_len((int *)v55);
        v514 = v905;
        *(_DWORD *)(a1 + 2076) += v582;
      }
      v583 = *(char *)(a1 + 2069);
      if ((v583 & 0x80000000) == 0)
        *(_BYTE *)(a1 + 2069) = v583 | (32 * v520) & 0x80;
      v584 = *(_QWORD *)(v55 + 16);
      v585 = *(_QWORD **)(v55 + 24);
      if (v584)
      {
        *(_QWORD *)(v584 + 24) = v585;
        v585 = *(_QWORD **)(v55 + 24);
      }
      else
      {
        *(_QWORD *)(a1 + 1992) = v585;
      }
      *v585 = v584;
      *(_QWORD *)(v55 + 16) = 0;
      v586 = *(_QWORD **)(a1 + 1992);
      *(_QWORD *)(v55 + 24) = v586;
      *v586 = v55;
      *(_QWORD *)(a1 + 1992) = v55 + 16;
      goto LABEL_1351;
    }
    v532 = *(_QWORD *)(a1 + 2024);
    if (v532)
    {
      v533 = *(_QWORD *)(v532 + 72);
      v534 = *(_QWORD **)(v532 + 80);
      if (v533)
      {
        *(_QWORD *)(v533 + 80) = v534;
        v534 = *(_QWORD **)(v532 + 80);
      }
      else
      {
        *(_QWORD *)(a1 + 2032) = v534;
      }
      *v534 = v533;
      --*(_DWORD *)(a1 + 2040);
    }
    else
    {
      v543 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
      v544 = malloc_type_malloc(**(_QWORD **)(v543 + 64), 0xB9BAFBABuLL);
      v514 = v905;
      v532 = (unint64_t)v544;
      if (!v544)
        goto LABEL_1351;
    }
    *(_QWORD *)(v532 + 80) = 0;
    *(_OWORD *)(v532 + 48) = 0u;
    *(_OWORD *)(v532 + 64) = 0u;
    *(_OWORD *)(v532 + 16) = 0u;
    *(_OWORD *)(v532 + 32) = 0u;
    *(_OWORD *)v532 = 0u;
    *(_DWORD *)v55 += v303;
    *(_DWORD *)v532 = v517;
    *(_DWORD *)(v532 + 4) = v518;
    *(_DWORD *)(v532 + 8) = v519;
    if ((int)(v517 - *(_DWORD *)(a1 + 2060)) >= 0)
    {
      *(_BYTE *)(v532 + 12) = v520;
      if ((v520 & 4) == 0)
        goto LABEL_1273;
LABEL_1283:
      *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v532);
      v550 = *(char *)(a1 + 2069);
      if (v550 < 0)
        goto LABEL_1275;
LABEL_1274:
      *(_BYTE *)(a1 + 2069) = v550 | (32 * v520) & 0x80;
      goto LABEL_1275;
    }
    *(_DWORD *)(a1 + 2060) = v517;
    *(_BYTE *)(v532 + 12) = v520;
    if ((v520 & 4) != 0)
      goto LABEL_1283;
LABEL_1273:
    v550 = *(char *)(a1 + 2069);
    if ((v550 & 0x80000000) == 0)
      goto LABEL_1274;
LABEL_1275:
    v551 = *v887;
    if (*v887)
    {
      while (1)
      {
        while (1)
        {
          v552 = v551;
          v553 = *(_DWORD *)(v532 + 4) - *(_DWORD *)(v551 + 4);
          if (v553 >= 0)
            break;
          v551 = *(_QWORD *)(v551 + 32);
          if (!v551)
            goto LABEL_1286;
        }
        if (!v553)
          break;
        v551 = *(_QWORD *)(v551 + 40);
        if (!v551)
          goto LABEL_1286;
      }
      v557 = __nwlog_obj();
      if (os_log_type_enabled(v557, OS_LOG_TYPE_ERROR))
      {
        v558 = *(_DWORD *)v552;
        v559 = *(_DWORD *)(v552 + 4);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "tcp_seg_sent_insert";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v552;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v948 = v558;
        *(_WORD *)&v948[4] = 1024;
        *(_DWORD *)&v948[6] = v559;
        _os_log_impl(&dword_209FB3000, v557, OS_LOG_TYPE_ERROR, "%{public}s segment %p[%u %u) was not inserted in the RB tree", buf, 0x22u);
      }
    }
    else
    {
      v552 = 0;
      v553 = 0;
LABEL_1286:
      *(_QWORD *)(v532 + 32) = 0;
      *(_QWORD *)(v532 + 40) = 0;
      *(_QWORD *)(v532 + 48) = v552 | 1;
      v554 = (unint64_t *)(a1 + 2000);
      if (v552)
      {
        if (v553 < 0)
          v554 = (unint64_t *)(v552 + 32);
        else
          v554 = (unint64_t *)(v552 + 40);
      }
      *v554 = v532;
      tcp_seg_sent_tree_head_RB_INSERT_COLOR((uint64_t)v887, v532);
    }
    *(_QWORD *)(v532 + 16) = 0;
    v560 = v532 + 16;
    v561 = *(unint64_t **)(a1 + 1992);
    *(_QWORD *)(v532 + 24) = v561;
    *v561 = v532;
LABEL_1332:
    *(_QWORD *)(a1 + 1992) = v560;
LABEL_1333:
    v514 = v905;
    v579 = v906;
    if (v906)
      goto LABEL_1352;
LABEL_1421:
    v652 = v514 ? 1 : v928;
    v25 = (_QWORD *)(a1 + 632);
    v3 = v916;
    v2 = v933;
LABEL_1425:
    if (v933[2238])
      goto LABEL_1430;
    if (*v942)
      break;
    v656 = *(_DWORD *)(a1 + 88);
    if ((v656 & 0x8000000) != 0)
      goto LABEL_1796;
LABEL_1430:
    v657 = *(_QWORD **)(a1 + 1056);
    if (v657)
      ++*v657;
    if (!v579)
      goto LABEL_1696;
  }
  v653 = *(_DWORD *)(a1 + 300);
  v654 = *(_DWORD *)(a1 + 648);
  *(_DWORD *)(a1 + 284) = *(_DWORD *)(a1 + 120);
  *(_DWORD *)(a1 + 88) &= 0xFFFFFFFC;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 304) = 0;
  v655 = tcp_ip_output_send(v916, a1, v942, v653, v652);
  *(_QWORD *)(a1 + 632) = 0;
  *(_QWORD *)(a1 + 640) = v942;
  *(_DWORD *)(a1 + 648) = 0;
  *(_DWORD *)(a1 + 300) = 0;
  if (!(_DWORD)v655)
    goto LABEL_1425;
  v508 = v655;
  if (v933[2238])
  {
    v735 = v939;
    v121 = a1 + 100;
    goto LABEL_1558;
  }
  v656 = *(_DWORD *)(a1 + 88);
  v735 = v939;
  v121 = a1 + 100;
  if ((v656 & 0x8000000) != 0)
    goto LABEL_1796;
LABEL_1558:
  v736 = *(_DWORD *)(a1 + 740);
  if ((v736 & 0x8000) != 0)
  {
    if (!(*(_DWORD *)(a1 + 36) | v735 & 2))
      goto LABEL_1562;
    goto LABEL_1614;
  }
  if ((v735 & 2) != 0)
    goto LABEL_1614;
LABEL_1562:
  v59 = (v736 & 0x20400020) == 536870944;
  v737 = v928 ^ 1;
  v738 = *(_DWORD *)(a1 + 92);
  if (v59)
    v737 = 1;
  if ((v737 & 1) == 0)
  {
    v739 = *v891 - v654;
    if (v739 - v738 < 1)
    {
      v654 = *v891 - v738;
      if (v738 - *v61 < 0)
        v738 = *v61;
    }
    else
    {
      v738 = *v61;
      if (v739 - *v61 >= 0)
        v738 = *v891 - v654;
    }
    *v891 = v738;
    *(_DWORD *)(a1 + 624) = (*(_DWORD *)(a1 + 624) - v654) & ~((*(_DWORD *)(a1 + 624) - v654) >> 31);
    v741 = (_QWORD *)*v25;
    if (!*v25)
      goto LABEL_1679;
LABEL_1615:
    while (2)
    {
      v760 = v741[4];
      v761 = (_QWORD *)v741[5];
      if (v760)
      {
        *(_QWORD *)(v760 + 40) = v761;
        v761 = (_QWORD *)v741[5];
      }
      else
      {
        *(_QWORD *)(a1 + 640) = v761;
      }
      *v761 = v760;
      v762 = (void (*)(_QWORD *, _QWORD, uint64_t))v741[10];
      v741[4] = 0;
      v741[5] = 0;
      if (v762)
      {
        v763 = v741[11];
        v741[10] = 0;
        v741[11] = 0;
        v762(v741, 0, v763);
        goto LABEL_1620;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_finalize";
      v764 = _os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v946 = OS_LOG_TYPE_DEFAULT;
      v929 = (void *)v764;
      if (!__nwlog_fault())
        goto LABEL_1636;
      if (LOBYTE(info.numer) == 17)
      {
        v924 = __nwlog_obj();
        v913 = info.numer;
        if (os_log_type_enabled(v924, info.numer))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v765 = v924;
          v766 = v913;
          v767 = "%{public}s called with null frame->finalizer";
          break;
        }
        goto LABEL_1636;
      }
      if (v946)
      {
        v925 = (os_log_t)__nw_create_backtrace_string();
        v914 = __nwlog_obj();
        typea = info.numer;
        v768 = os_log_type_enabled(v914, info.numer);
        v769 = v925;
        if (v925)
        {
          if (v768)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v925;
            _os_log_impl(&dword_209FB3000, v914, typea, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
            v769 = v925;
          }
          free(v769);
          goto LABEL_1636;
        }
        if (!v768)
        {
LABEL_1636:
          if (v929)
            free(v929);
LABEL_1620:
          v741 = (_QWORD *)*v942;
          if (!*v942)
            goto LABEL_1679;
          continue;
        }
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v765 = v914;
        v766 = typea;
        v767 = "%{public}s called with null frame->finalizer, no backtrace";
      }
      else
      {
        v926 = __nwlog_obj();
        v915 = info.numer;
        if (!os_log_type_enabled(v926, info.numer))
          goto LABEL_1636;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v765 = v926;
        v766 = v915;
        v767 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }
      break;
    }
    _os_log_impl(&dword_209FB3000, v765, v766, v767, buf, 0xCu);
    goto LABEL_1636;
  }
  v740 = *(_DWORD *)v121 - v654;
  if (v740 - v738 < 1)
  {
    *(_DWORD *)v121 = v738;
    v741 = (_QWORD *)*v25;
    if (*v25)
      goto LABEL_1615;
  }
  else
  {
    *(_DWORD *)v121 = v740;
    v741 = (_QWORD *)*v25;
    if (*v25)
      goto LABEL_1615;
  }
LABEL_1679:
  *(_QWORD *)(a1 + 632) = 0;
  *(_QWORD *)(a1 + 640) = v942;
  *(_DWORD *)(a1 + 648) = 0;
  *(_DWORD *)(a1 + 300) = 0;
  switch((_DWORD)v508)
  {
    case '(':
      if (v907)
        *(_DWORD *)(a1 + 88) &= ~0x10000000u;
      tcp_mtudisc(v933);
      goto LABEL_1696;
    case '2':
      if (*(int *)(a1 + 12) >= 3)
      {
        *(_DWORD *)(a1 + 256) = 50;
        v508 = 0;
      }
      break;
    case '7':
      if (!*(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 36))
      {
        v784 = v889;
        if ((v939 & 3) != 0)
          v784 = 1;
        if ((v784 & 1) != 0 || *(_DWORD *)(v916 + 384))
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
                               + *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316)
                               - *(_DWORD *)(a1 + 64);
      }
      *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 196);
      *(_DWORD *)(a1 + 288) = 0;
      goto LABEL_1696;
  }
  tcp_check_timer_state(a1);
  return v508;
}

uint64_t tcp_ip_output(uint64_t a1, uint64_t a2, _QWORD *a3, int a4, int a5)
{
  if (*a3 || *(_QWORD *)(a2 + 656))
  {
    *(_DWORD *)(a2 + 284) = *(_DWORD *)(a2 + 120);
    *(_DWORD *)(a2 + 88) &= 0xFFFFFFFC;
    *(_DWORD *)(a2 + 32) = 0;
    *(_DWORD *)(a2 + 304) = 0;
    return tcp_ip_output_send(a1, a2, a3, a4, a5);
  }
  return a1;
}

BOOL nw_protocol_tcp_copy_frame_to_buffer(uint64_t a1, int a2, int a3, char *__dst)
{
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  void *v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  char *v19;
  unsigned int (**v20)(uint64_t, _QWORD);
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  _BOOL8 result;
  NSObject *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  NSObject *v32;
  void *v33;
  void *v34;
  NSObject *v35;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  int v41;
  uint64_t i;

  v5 = a3;
  v6 = a1;
  for (i = *MEMORY[0x24BDAC8D0]; a2 >= 1 && v6; v6 = *(_QWORD *)(v6 + 32))
  {
    v7 = *(_DWORD *)(v6 + 52);
    if (v7)
    {
      v8 = *(_DWORD *)(v6 + 56);
      v9 = *(_DWORD *)(v6 + 60);
      v10 = v7 - (v8 + v9);
      if (a2 < v10)
        goto LABEL_13;
      v11 = v8 - v7 + v9;
    }
    else
    {
      v11 = 0;
    }
    a2 += v11;
  }
  if ((a2 & 0x80000000) == 0)
  {
    if (!v6)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v37 = "__nw_frame_unclaimed_length";
      v34 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v35 = __nwlog_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "__nw_frame_unclaimed_length";
          _os_log_impl(&dword_209FB3000, v35, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v34)
        free(v34);
      goto LABEL_14;
    }
    v10 = *(_DWORD *)(v6 + 52);
    if (v10)
      v10 -= *(_DWORD *)(v6 + 56) + *(_DWORD *)(v6 + 60);
LABEL_13:
    if (v10 < a2)
    {
LABEL_14:
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      v12 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v26 = __nwlog_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_protocol_tcp_copy_frame_to_buffer";
          v27 = "%{public}s invalid source frame, backtrace limit exceeded";
LABEL_63:
          _os_log_impl(&dword_209FB3000, v26, OS_LOG_TYPE_ERROR, v27, buf, 0xCu);
          goto LABEL_64;
        }
      }
      goto LABEL_64;
    }
    if (a3 < 1)
      return v5 == 0;
    v13 = a2;
    if ((uint64_t)(v10 - (unint64_t)a2) >= a3)
      v14 = a3;
    else
      v14 = (v10 - a2);
    if (!(_DWORD)v14)
    {
LABEL_54:
      v24 = __nwlog_obj();
      result = os_log_type_enabled(v24, OS_LOG_TYPE_INFO);
      if (!(_DWORD)result)
        return result;
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      goto LABEL_62;
    }
    if ((*(_WORD *)(v6 + 204) & 2) == 0)
    {
      v15 = *(_QWORD *)(v6 + 112);
      if (!v15
        || (*(_WORD *)(v6 + 204) & 0x100) != 0
        && *MEMORY[0x24BDE08C0]
        && (!((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v6, *(_QWORD *)(v6 + 88))
         || (v15 = *(_QWORD *)(v6 + 112)) == 0))
      {
LABEL_60:
        v24 = __nwlog_obj();
        result = os_log_type_enabled(v24, OS_LOG_TYPE_INFO);
        if (!(_DWORD)result)
          return result;
        *(_DWORD *)buf = 136446210;
        v37 = "nw_protocol_tcp_copy_frame_to_buffer";
LABEL_62:
        _os_log_impl(&dword_209FB3000, v24, OS_LOG_TYPE_INFO, "%{public}s source buffer is no longer valid", buf, 0xCu);
        return 0;
      }
      memcpy(__dst, (const void *)(v15 + v13 + *(unsigned int *)(v6 + 56)), v14);
LABEL_32:
      v5 -= v14;
      v17 = *(_QWORD *)(v6 + 32);
      if (v17)
      {
        v18 = *(_DWORD *)(v17 + 52);
        if (v18)
          v18 -= *(_DWORD *)(v17 + 56) + *(_DWORD *)(v17 + 60);
        if (v5 >= 1)
        {
          v19 = &__dst[v14];
          v20 = (unsigned int (**)(uint64_t, _QWORD))MEMORY[0x24BDE08C0];
          while (1)
          {
            v21 = v18 >= v5 ? v5 : v18;
            if (!(_DWORD)v21)
              goto LABEL_54;
            if ((*(_WORD *)(v17 + 204) & 2) != 0)
            {
              if (!*(_QWORD *)(v17 + 96))
                goto LABEL_67;
              v23 = nw_dispatch_data_copyout_from_offset();
              if (v23 != v21)
              {
                v29 = v23;
                LODWORD(v14) = v21;
                goto LABEL_70;
              }
            }
            else
            {
              v22 = *(_QWORD *)(v17 + 112);
              if (!v22)
                goto LABEL_60;
              if ((*(_WORD *)(v17 + 204) & 0x100) != 0)
              {
                if (*v20)
                {
                  if (!(*v20)(v17, *(_QWORD *)(v17 + 88)))
                    goto LABEL_60;
                  v22 = *(_QWORD *)(v17 + 112);
                  if (!v22)
                    goto LABEL_60;
                }
              }
              memcpy(v19, (const void *)(v22 + *(unsigned int *)(v17 + 56)), v21);
            }
            v5 -= v21;
            v17 = *(_QWORD *)(v17 + 32);
            if (v17)
            {
              v18 = *(_DWORD *)(v17 + 52);
              if (v18)
                v18 -= *(_DWORD *)(v17 + 56) + *(_DWORD *)(v17 + 60);
              v19 += v21;
              if (v5 > 0)
                continue;
            }
            return v5 == 0;
          }
        }
      }
      return v5 == 0;
    }
    if (*(_QWORD *)(v6 + 96))
    {
      v16 = nw_dispatch_data_copyout_from_offset();
      if (v16 == v14)
        goto LABEL_32;
      v29 = v16;
LABEL_70:
      __nwlog_obj();
      *(_DWORD *)buf = 136446722;
      v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      v38 = 2048;
      v39 = v29;
      v40 = 1024;
      v41 = v14;
      v30 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v32 = __nwlog_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          v37 = "nw_protocol_tcp_copy_frame_to_buffer";
          v38 = 2048;
          v39 = v29;
          v40 = 1024;
          v41 = v14;
          _os_log_impl(&dword_209FB3000, v32, OS_LOG_TYPE_ERROR, "%{public}s Copied %zu out of expected %u bytes, backtrace limit exceeded", buf, 0x1Cu);
        }
      }
      if (!v30)
        return v5 == 0;
      v33 = (void *)v30;
    }
    else
    {
LABEL_67:
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      v28 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v31 = __nwlog_obj();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_protocol_tcp_copy_frame_to_buffer";
          _os_log_impl(&dword_209FB3000, v31, OS_LOG_TYPE_ERROR, "%{public}s Failed to extract data from frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (!v28)
        return v5 == 0;
      v33 = (void *)v28;
    }
    free(v33);
    return v5 == 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v37 = "nw_protocol_tcp_copy_frame_to_buffer";
  v12 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v26 = __nwlog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      v27 = "%{public}s source_offset < 0, backtrace limit exceeded";
      goto LABEL_63;
    }
  }
LABEL_64:
  if (v12)
    free(v12);
  return 0;
}

void tcp_gc(uint64_t a1, unsigned int *a2)
{
  _QWORD *v4;
  unsigned int *v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;

  calculate_tcp_clock(a1);
  *(_BYTE *)(a1 + 328) |= 0x20u;
  v4 = *(_QWORD **)(a1 + 104);
  if (v4)
  {
    v5 = a2 + 11;
    do
    {
      v6 = (uint64_t)v4;
      v4 = (_QWORD *)*v4;
      if (tcp_garbage_collect(v6, 0))
      {
        do
          v7 = __ldaxr(v5);
        while (__stlxr(v7 + 1, v5));
      }
    }
    while (v4);
  }
  v8 = *(_QWORD *)(a1 + 128);
  if (v8)
  {
    v9 = a2 + 10;
    do
    {
      v10 = v8;
      v8 = *(_QWORD *)(v8 + 824);
      if (!*(_DWORD *)(v10 + 12) || *(_DWORD *)(a1 + 316) - *(_DWORD *)(v10 + 44) >= 0)
      {
        if (tcp_garbage_collect(*(_QWORD *)(v10 + 80), 1))
        {
          do
            v11 = __ldaxr(v9);
          while (__stlxr(v11 + 1, v9));
        }
      }
    }
    while (v8);
  }
  v12 = a2[16];
  v13 = a2 + 10;
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 + v12, v13));
}

uint64_t tcp_garbage_collect(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t *v12;
  uint64_t *v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  void *v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  NSObject *v34;
  int v35;
  int v36;
  const char *v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t all_stats;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  void (*v50)(uint64_t);
  NSObject *v51;
  uint32_t v52;
  NSObject *v53;
  NSObject *v54;
  int v55;
  NSObject *v56;
  void *v57;
  NSObject *v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  NSObject *v64;
  NSObject *v65;
  void *v66;
  uint8_t buf[4];
  const char *v68;
  __int16 v69;
  uint64_t v70;
  __int16 v71;
  uint64_t v72;
  __int16 v73;
  _BYTE v74[14];
  __int16 v75;
  int v76;
  __int16 v77;
  int v78;
  __int16 v79;
  int v80;
  __int16 v81;
  int v82;
  uint64_t v83;

  v83 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 224);
  v5 = *(_QWORD *)(a1 + 240);
  v6 = nw_tcp_access_globals(v4);
  v7 = *(_DWORD *)(v4 + 360);
  if (v7 >= 2)
    return *(_DWORD *)(a1 + 456) == 0xFFFF;
  if (!a2)
  {
    if (v7 != 1)
      goto LABEL_15;
    if (!v5)
      goto LABEL_14;
    goto LABEL_13;
  }
  if (*(_DWORD *)(v6 + 316) - *(_DWORD *)(v5 + 44) >= 0 && *(_DWORD *)(v5 + 12))
  {
    tcp_close(v5);
    v7 = *(_DWORD *)(v4 + 360);
  }
  if (v7 == 1)
  {
    if ((*(_BYTE *)(v4 + 365) & 2) != 0)
    {
LABEL_9:
      if (*(_DWORD *)(a1 + 232) == 3)
      {
        v9 = 1;
      }
      else
      {
        in_pcbdetach(a1);
        v9 = *(_DWORD *)(v4 + 360);
        if (v9 <= 0 && (*(_BYTE *)(v4 + 828) & 2) == 0)
        {
          __nwlog_tcp_log();
          *(_DWORD *)buf = 136446466;
          v68 = "tcp_garbage_collect";
          v69 = 2082;
          v70 = v4 + 604;
          v20 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            v53 = __nwlog_tcp_log();
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v68 = "tcp_garbage_collect";
              v69 = 2082;
              v70 = v4 + 604;
              _os_log_impl(&dword_209FB3000, v53, OS_LOG_TYPE_ERROR, "%{public}s %{public}s so->so_usecount <= 0, backtrace limit exceeded", buf, 0x16u);
            }
          }
          if (v20)
            free(v20);
          v9 = *(_DWORD *)(v4 + 360);
        }
      }
      *(_DWORD *)(v4 + 360) = v9 - 1;
      return *(_DWORD *)(a1 + 456) == 0xFFFF;
    }
LABEL_13:
    if (!*(_DWORD *)(v5 + 12) && *(_QWORD *)(v4 + 296) && (~*(unsigned __int16 *)(v4 + 376) & 0x830) == 0)
      goto LABEL_9;
LABEL_14:
    v7 = 1;
  }
LABEL_15:
  if (*(_DWORD *)(a1 + 456) != 0xFFFF)
    return 0;
  if (v7)
    return 1;
  if ((*(_BYTE *)(v4 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v64 = __nwlog_tcp_log();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v68 = "tcp_garbage_collect";
        v69 = 2082;
        v70 = v4 + 604;
        v71 = 1024;
        LODWORD(v72) = 0;
        _os_log_impl(&dword_209FB3000, v64, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{network:tcp_state}d", buf, 0x1Cu);
      }
    }
  }
  if ((*(_BYTE *)(v5 + 91) & 0x40) != 0)
  {
    v10 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v5 + 80) + 224));
    (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 80) + 224) + 8) + 32))();
    v11 = *(_DWORD *)(v5 + 88);
    if ((v11 & 0x40000000) != 0)
    {
      v12 = *(uint64_t **)(v10 + 264);
      v13 = (uint64_t *)(v5 + 48);
      if (v12)
        v14 = v12 == v13;
      else
        v14 = 0;
      if (v14)
        *(_QWORD *)(v10 + 264) = *v12;
      v15 = *v13;
      if (*v13)
        *(_QWORD *)(v15 + 8) = *(_QWORD *)(v5 + 56);
      **(_QWORD **)(v5 + 56) = v15;
      *(_DWORD *)(v5 + 88) = v11 & 0xBFFFFFFF;
      --*(_DWORD *)(v10 + 280);
      *v13 = 0;
      *(_QWORD *)(v5 + 56) = 0;
    }
  }
  if (*(_DWORD *)(a1 + 232) != 3)
    in_pcbdetach(a1);
  v16 = *(_QWORD *)(a1 + 224);
  if (v16)
  {
    if (*(_DWORD *)(v16 + 360))
    {
      if ((*(_BYTE *)(v16 + 828) & 2) != 0)
        return 0;
      __nwlog_tcp_log();
      v17 = **(_DWORD **)(*(_QWORD *)(v16 + 8) + 8);
      v18 = *(_DWORD *)(v16 + 360);
      *(_DWORD *)buf = 136447234;
      v68 = "in_pcbdispose";
      v69 = 2082;
      v70 = v16 + 604;
      v71 = 2048;
      v72 = v16;
      v73 = 1024;
      *(_DWORD *)v74 = v17;
      *(_WORD *)&v74[4] = 1024;
      *(_DWORD *)&v74[6] = v18;
      v19 = _os_log_send_and_compose_impl();
      if (!__nwlog_fault())
        goto LABEL_109;
      v34 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        goto LABEL_109;
      v35 = **(_DWORD **)(*(_QWORD *)(v16 + 8) + 8);
      v36 = *(_DWORD *)(v16 + 360);
      *(_DWORD *)buf = 136447234;
      v68 = "in_pcbdispose";
      v69 = 2082;
      v70 = v16 + 604;
      v71 = 2048;
      v72 = v16;
      v73 = 1024;
      *(_DWORD *)v74 = v35;
      *(_WORD *)&v74[4] = 1024;
      *(_DWORD *)&v74[6] = v36;
      v37 = "%{public}s %{public}s so %p [%d] usecount %d, backtrace limit exceeded";
      v51 = v34;
      v52 = 44;
      goto LABEL_108;
    }
    if (*(_DWORD *)(a1 + 456) != 0xFFFF)
    {
      if ((*(_BYTE *)(v16 + 828) & 2) != 0)
        return 0;
      __nwlog_tcp_log();
      v28 = *(_DWORD *)(a1 + 456);
      v29 = **(_DWORD **)(*(_QWORD *)(v16 + 8) + 8);
      v30 = *(_DWORD *)(v16 + 360);
      v31 = *(__int16 *)(v16 + 376);
      v32 = *(_DWORD *)(v16 + 364);
      *(_DWORD *)buf = 136448258;
      v68 = "in_pcbdispose";
      v69 = 2082;
      v70 = v16 + 604;
      v71 = 2048;
      v72 = a1;
      v73 = 1024;
      *(_DWORD *)v74 = v28;
      *(_WORD *)&v74[4] = 2048;
      *(_QWORD *)&v74[6] = v16;
      v75 = 1024;
      v76 = v29;
      v77 = 1024;
      v78 = v30;
      v79 = 1024;
      v80 = v31;
      v81 = 1024;
      v82 = v32;
      v33 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v58 = __nwlog_tcp_log();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        {
          v59 = *(_DWORD *)(a1 + 456);
          v60 = **(_DWORD **)(*(_QWORD *)(v16 + 8) + 8);
          v61 = *(_DWORD *)(v16 + 360);
          v62 = *(__int16 *)(v16 + 376);
          v63 = *(_DWORD *)(v16 + 364);
          *(_DWORD *)buf = 136448258;
          v68 = "in_pcbdispose";
          v69 = 2082;
          v70 = v16 + 604;
          v71 = 2048;
          v72 = a1;
          v73 = 1024;
          *(_DWORD *)v74 = v59;
          *(_WORD *)&v74[4] = 2048;
          *(_QWORD *)&v74[6] = v16;
          v75 = 1024;
          v76 = v60;
          v77 = 1024;
          v78 = v61;
          v79 = 1024;
          v80 = v62;
          v81 = 1024;
          v82 = v63;
          _os_log_impl(&dword_209FB3000, v58, OS_LOG_TYPE_ERROR, "%{public}s %{public}s inp %p invalid wantcnt %d, so %p [%d] usecount %d retaincnt state 0x%x flags 0x%x, backtrace limit exceeded", buf, 0x48u);
        }
      }
      if (!v33)
        return 0;
      v57 = (void *)v33;
      goto LABEL_111;
    }
  }
  else if (*(_DWORD *)(a1 + 456) != 0xFFFF)
  {
    __nwlog_obj();
    v21 = *(_DWORD *)(a1 + 456);
    *(_DWORD *)buf = 136446722;
    v68 = "in_pcbdispose";
    v69 = 2048;
    v70 = a1;
    v71 = 1024;
    LODWORD(v72) = v21;
    v22 = _os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v54 = __nwlog_obj();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        v55 = *(_DWORD *)(a1 + 456);
        *(_DWORD *)buf = 136446722;
        v68 = "in_pcbdispose";
        v69 = 2048;
        v70 = a1;
        v71 = 1024;
        LODWORD(v72) = v55;
        _os_log_impl(&dword_209FB3000, v54, OS_LOG_TYPE_ERROR, "%{public}s inp %p invalid wantcnt %d no socket, backtrace limit exceeded", buf, 0x1Cu);
      }
    }
    if (!v22)
      return 0;
    v57 = (void *)v22;
    goto LABEL_111;
  }
  v23 = *(_DWORD *)(a1 + 2232);
  if ((v23 & 1) == 0)
  {
    v24 = *(_QWORD *)a1;
    if (*(_QWORD *)a1)
      *(_QWORD *)(v24 + 8) = *(_QWORD *)(a1 + 8);
    **(_QWORD **)(a1 + 8) = v24;
    goto LABEL_64;
  }
  v25 = *(_QWORD *)(a1 + 240);
  v26 = *(_QWORD *)(v25 + 824);
  v27 = *(_QWORD *)(v25 + 832);
  if (v26)
  {
    *(_QWORD *)(v26 + 832) = v27;
  }
  else
  {
    *(_QWORD *)(nw_tcp_access_globals(*(_QWORD *)(a1 + 224)) + 136) = v27;
    v26 = *(_QWORD *)(v25 + 824);
    v23 = *(_DWORD *)(a1 + 2232);
  }
  **(_QWORD **)(v25 + 832) = v26;
  *(_DWORD *)(a1 + 2232) = v23 & 0xFFFFFFFE;
  v38 = *(_QWORD *)(a1 + 16);
  v39 = *(_DWORD *)(v38 + 64);
  if (v39)
  {
LABEL_62:
    *(_DWORD *)(v38 + 64) = v39 - 1;
    v40 = *(_QWORD *)(*(_QWORD *)(a1 + 240) + 1056);
    if (v40)
      --*(_QWORD *)(v40 + 1696);
LABEL_64:
    if (!v16)
      return 0;
    sofreelastref(v16);
    if (*(_DWORD *)(v16 + 488) || *(_DWORD *)(v16 + 384))
    {
      sbflush(v16 + 488);
      *(_DWORD *)(v16 + 492) = 0;
      v41 = *(_QWORD *)(*(_QWORD *)(v16 + 560) + 24);
      if ((*(_BYTE *)(v16 + 536) & 4) != 0)
      {
        if (v41)
        {
          all_stats = nw_protocol_tcp_get_all_stats();
          if (all_stats)
            *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v16 + 492);
        }
      }
      else if (v41)
      {
        v42 = nw_protocol_tcp_get_all_stats();
        if (v42)
          *(_DWORD *)(v42 + 100) = *(_DWORD *)(v16 + 492);
      }
      sbflush(v16 + 384);
      *(_DWORD *)(v16 + 388) = 0;
      v44 = *(_QWORD *)(*(_QWORD *)(v16 + 456) + 24);
      if ((*(_BYTE *)(v16 + 432) & 4) != 0)
      {
        if (v44)
        {
          v46 = nw_protocol_tcp_get_all_stats();
          if (v46)
            *(_DWORD *)(v46 + 88) = *(_DWORD *)(v16 + 388);
        }
      }
      else if (v44)
      {
        v45 = nw_protocol_tcp_get_all_stats();
        if (v45)
          *(_DWORD *)(v45 + 100) = *(_DWORD *)(v16 + 388);
      }
    }
    if (!*(_QWORD *)(v16 + 296))
    {
      *(_DWORD *)(v16 + 364) |= 4u;
      *(_QWORD *)v16 = 0;
      *(_QWORD *)(a1 + 224) = 0;
      v47 = *(_QWORD *)(a1 + 496);
      if (v47)
      {
        if (*(_BYTE *)(v47 + 1496))
        {
          v48 = *(void **)(v47 + 1488);
          if (v48)
          {
            free(v48);
            v47 = *(_QWORD *)(a1 + 496);
            *(_QWORD *)(v47 + 1488) = 0;
          }
          *(_BYTE *)(v47 + 1496) = 0;
        }
        *(_QWORD *)(a1 + 496) = 0;
      }
      v49 = *(_QWORD *)(v16 + 32);
      if (v49)
      {
        v50 = *(void (**)(uint64_t))(v49 + 64);
        if (v50)
          v50(v16);
      }
      return 0;
    }
    if ((*(_BYTE *)(v16 + 828) & 2) != 0)
      return 0;
    __nwlog_tcp_log();
    *(_DWORD *)buf = 136446722;
    v68 = "in_pcbdispose";
    v69 = 2082;
    v70 = v16 + 604;
    v71 = 2048;
    v72 = v16;
    v19 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()
      || (v56 = __nwlog_tcp_log(), !os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)))
    {
LABEL_109:
      if (v19)
      {
        v57 = (void *)v19;
LABEL_111:
        free(v57);
      }
      return 0;
    }
    *(_DWORD *)buf = 136446722;
    v68 = "in_pcbdispose";
    v69 = 2082;
    v70 = v16 + 604;
    v71 = 2048;
    v72 = v16;
    v37 = "%{public}s %{public}s so=%p head still exist, backtrace limit exceeded";
    v51 = v56;
    v52 = 32;
LABEL_108:
    _os_log_impl(&dword_209FB3000, v51, OS_LOG_TYPE_ERROR, v37, buf, v52);
    goto LABEL_109;
  }
  v65 = __nwlog_obj();
  os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v68 = "in_pcbremlists";
  v66 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v66);
    v38 = *(_QWORD *)(a1 + 16);
    v39 = *(_DWORD *)(v38 + 64);
    goto LABEL_62;
  }
  __break(1u);
  return result;
}

void in_pcbdetach(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  char v9;
  char v10;
  int v11;
  const char *v12;
  void *v13;
  NSObject *v14;
  int v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 224);
  if (in_pcb_checkstate(a1, 0xFFFFLL, 1) == 0xFFFF)
  {
    if ((*(_BYTE *)(v2 + 364) & 4) != 0)
      return;
    v3 = *(_QWORD *)(a1 + 496);
    if (v3)
    {
      if (*(_BYTE *)(v3 + 1496))
      {
        v4 = *(void **)(v3 + 1488);
        if (v4)
        {
          free(v4);
          v3 = *(_QWORD *)(a1 + 496);
          *(_QWORD *)(v3 + 1488) = 0;
        }
        *(_BYTE *)(v3 + 1496) = 0;
      }
      *(_QWORD *)(a1 + 496) = 0;
    }
    sofreelastref(v2);
    *(_DWORD *)(a1 + 232) = 3;
    *(_DWORD *)(v2 + 364) |= 4u;
    v5 = nw_tcp_access_globals(v2);
    v6 = *(_QWORD *)(a1 + 16);
    *(_BYTE *)(v5 + 328) |= 2u;
    v7 = (unsigned int *)(v6 + 44);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 + 1, v7));
    v9 = *(_BYTE *)(v5 + 328);
    if ((v9 & 1) != 0)
    {
      if ((*(_BYTE *)(v5 + 328) & 8) != 0)
        return;
      v10 = v9 | 8;
    }
    else
    {
      if ((*(_BYTE *)(v5 + 328) & 6) == 0)
        return;
      v10 = v9 | 9;
    }
    *(_BYTE *)(v5 + 328) = v10;
    nw_protocol_timer_run_inner(v5, 1000000000);
  }
  else if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    v11 = **(__int16 **)(v2 + 8);
    if (v2)
      v12 = (const char *)(v2 + 604);
    else
      v12 = "";
    *(_DWORD *)buf = 136446978;
    v17 = "in_pcbdetach";
    v18 = 2082;
    v19 = v12;
    v20 = 2048;
    v21 = v2;
    v22 = 1024;
    v23 = v11;
    v13 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v14 = __nwlog_tcp_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v15 = **(__int16 **)(v2 + 8);
        *(_DWORD *)buf = 136446978;
        v17 = "in_pcbdetach";
        v18 = 2082;
        v19 = v12;
        v20 = 2048;
        v21 = v2;
        v22 = 1024;
        v23 = v15;
        _os_log_impl(&dword_209FB3000, v14, OS_LOG_TYPE_ERROR, "%{public}s %{public}s so=%p proto=%d couldn't set to STOPUSING, backtrace limit exceeded", buf, 0x26u);
      }
    }
    if (v13)
      free(v13);
  }
}

uint64_t in_pcb_checkstate(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  unsigned int *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  NSObject *v38;
  uint32_t v39;
  NSObject *v41;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  uint64_t v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v6 = (unsigned int *)(a1 + 456);
  if ((_DWORD)a2 == 0xFFFF)
  {
    if (!a3)
      (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 8) + 16))();
    *(_DWORD *)(a1 + 232) = 3;
    goto LABEL_28;
  }
  v7 = a2;
  if ((_DWORD)a2 == 2)
  {
    if (!a3)
      (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 8) + 16))();
LABEL_14:
    v10 = *v6;
    if ((unsigned __int16)*v6 == 0xFFFF)
    {
      if (!a3)
        (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 8) + 24))();
      return 0xFFFFLL;
    }
    if (!(unsigned __int16)*v6)
    {
      v35 = *(_QWORD *)(a1 + 224);
      if (!v35 || (*(_BYTE *)(v35 + 828) & 2) == 0)
      {
        __nwlog_tcp_log();
        *(_DWORD *)buf = 136446722;
        v43 = "in_pcb_checkstate";
        if (v35)
          v36 = (const char *)(v35 + 604);
        else
          v36 = "";
        v44 = 2082;
        v45 = v36;
        v46 = 2048;
        v47 = a1;
        v24 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v41 = __nwlog_tcp_log();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v43 = "in_pcb_checkstate";
            v44 = 2082;
            v45 = v36;
            v46 = 2048;
            v47 = a1;
            v34 = "%{public}s %{public}s pcb=%p release with zero count, backtrace limit exceeded";
            v38 = v41;
            v39 = 32;
            goto LABEL_72;
          }
        }
        goto LABEL_73;
      }
      return 0xFFFFLL;
    }
    do
    {
      v11 = __ldxr(v6);
      if (v11 != v10)
      {
        __clrex();
        goto LABEL_14;
      }
    }
    while (__stxr(v10 - 1, v6));
    if (*(_DWORD *)(a1 + 232) != 3)
    {
      v27 = *(_QWORD *)(a1 + 224);
      if ((*(_DWORD *)(v27 + 360) & 0x80000000) == 0)
      {
        if (!a3)
          (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(v27 + 8) + 24))(*(_QWORD *)(a1 + 224), 1, v3);
        return 2;
      }
      if ((*(_BYTE *)(v27 + 828) & 2) == 0)
      {
        __nwlog_tcp_log();
        v30 = (const char *)(v27 + 604);
        v31 = *(_QWORD *)(a1 + 224);
        *(_DWORD *)buf = 136446978;
        v43 = "in_pcb_checkstate";
        v44 = 2082;
        v45 = (const char *)(v27 + 604);
        v46 = 2048;
        v47 = a1;
        v48 = 2048;
        v49 = v31;
        v24 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v32 = __nwlog_tcp_log();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          {
            v37 = *(_QWORD *)(a1 + 224);
            *(_DWORD *)buf = 136446978;
            v43 = "in_pcb_checkstate";
            v44 = 2082;
            v45 = v30;
            v46 = 2048;
            v47 = a1;
            v48 = 2048;
            v49 = v37;
            v34 = "%{public}s %{public}s RELEASE pcb=%p so=%p usecount is negative, backtrace limit exceeded";
            goto LABEL_71;
          }
        }
LABEL_73:
        if (v24)
          free(v24);
      }
      return 0xFFFFLL;
    }
LABEL_28:
    v16 = *(_QWORD *)(a1 + 224);
    if ((*(_DWORD *)(v16 + 360) & 0x80000000) == 0)
    {
      if (!a3)
      {
        (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(v16 + 8) + 24))(*(_QWORD *)(a1 + 224), 1, v3);
        v16 = *(_QWORD *)(a1 + 224);
      }
      v17 = nw_tcp_access_globals(v16);
      v18 = *(_QWORD *)(a1 + 16);
      *(_BYTE *)(v17 + 328) |= 2u;
      v19 = (unsigned int *)(v18 + 44);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 + 1, v19));
      if ((*(_BYTE *)(v17 + 328) & 1) != 0)
      {
        if ((*(_BYTE *)(v17 + 328) & 8) != 0)
          goto LABEL_42;
        v21 = 8;
      }
      else
      {
        if ((*(_BYTE *)(v17 + 328) & 6) == 0)
          goto LABEL_42;
        v21 = 9;
      }
      *(_BYTE *)(v17 + 328) |= v21;
      nw_protocol_timer_run_inner(v17, 1000000000);
LABEL_42:
      v25 = *v6;
      if (!(unsigned __int16)*v6)
      {
        while (1)
        {
          v26 = __ldxr(v6);
          if (v26 != v25)
            break;
          v7 = 0xFFFFLL;
          if (!__stxr(0xFFFFu, v6))
            return v7;
        }
        __clrex();
      }
      return 0xFFFFLL;
    }
    if ((*(_BYTE *)(v16 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      v22 = v16 + 604;
      v23 = *(_QWORD *)(a1 + 224);
      *(_DWORD *)buf = 136446978;
      v43 = "in_pcb_checkstate";
      v44 = 2082;
      v45 = (const char *)(v16 + 604);
      v46 = 2048;
      v47 = a1;
      v48 = 2048;
      v49 = v23;
      v24 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v32 = __nwlog_tcp_log();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          v33 = *(_QWORD *)(a1 + 224);
          *(_DWORD *)buf = 136446978;
          v43 = "in_pcb_checkstate";
          v44 = 2082;
          v45 = (const char *)v22;
          v46 = 2048;
          v47 = a1;
          v48 = 2048;
          v49 = v33;
          v34 = "%{public}s %{public}s pcb=%p so=%p usecount is negative, backtrace limit exceeded";
LABEL_71:
          v38 = v32;
          v39 = 42;
LABEL_72:
          _os_log_impl(&dword_209FB3000, v38, OS_LOG_TYPE_ERROR, v34, buf, v39);
          goto LABEL_73;
        }
      }
      goto LABEL_73;
    }
    return 0xFFFFLL;
  }
  if ((_DWORD)a2 == 1)
  {
    while (1)
    {
      v8 = *v6;
      v7 = 0xFFFFLL;
      if (*(_WORD *)v6 == 0xFFFF)
        break;
      while (1)
      {
        v9 = __ldxr(v6);
        if (v9 != v8)
          break;
        if (!__stxr(v8 + 1, v6))
          return 1;
      }
      __clrex();
    }
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 224);
    if (!v12 || (*(_BYTE *)(v12 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      v13 = *(_QWORD *)(a1 + 224);
      *(_DWORD *)buf = 136446978;
      v44 = 2082;
      v43 = "in_pcb_checkstate";
      if (v12)
        v14 = (const char *)(v12 + 604);
      else
        v14 = "";
      v45 = v14;
      v46 = 2048;
      v47 = v13;
      v48 = 1024;
      LODWORD(v49) = v7;
      v15 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v28 = __nwlog_tcp_log();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          v29 = *(_QWORD *)(a1 + 224);
          *(_DWORD *)buf = 136446978;
          v43 = "in_pcb_checkstate";
          v44 = 2082;
          v45 = v14;
          v46 = 2048;
          v47 = v29;
          v48 = 1024;
          LODWORD(v49) = v7;
          _os_log_impl(&dword_209FB3000, v28, OS_LOG_TYPE_ERROR, "%{public}s %{public}s so=%p not a valid state =%x, backtrace limit exceeded", buf, 0x26u);
        }
      }
      if (v15)
        free(v15);
    }
  }
  return v7;
}

uint64_t ____nw_protocol_tcp_disconnect_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  const char *v4;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 5308) & 2) == 0)
  {
    v2 = *(_QWORD *)(a1 + 40);
    if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
    {
      v3 = __nwlog_tcp_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        v4 = "";
        if (v2)
          v4 = (const char *)(v2 + 604);
        v6 = 136446466;
        v7 = "__nw_protocol_tcp_disconnect_block_invoke";
        v8 = 2082;
        v9 = v4;
        _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s send disconnect to input protocol", (uint8_t *)&v6, 0x16u);
      }
    }
    nw_protocol_get_input_handler();
    if (nw_protocol_disconnected_is_valid())
    {
      if (*MEMORY[0x24BDE08B8] != -1)
        dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_16);
      if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
        kdebug_trace();
      nw_protocol_get_input_handler();
      nw_protocol_disconnected();
    }
    *(_DWORD *)(*(_QWORD *)(a1 + 32) + 5308) |= 2u;
  }
  tcp_close_locked(*(_QWORD *)(a1 + 40));
  return nw_protocol_release();
}

void tcp_close_locked(uint64_t a1)
{
  uint64_t v1;
  void *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  uint64_t v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  uint64_t v19;
  void (*v20)(uint64_t, _QWORD);
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  void (*v26)(uint64_t, _QWORD);
  uint64_t v27;
  __int16 v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(uint64_t);
  int v33;
  __int16 v34;
  uint64_t v35;
  void (*v36)(uint64_t, _QWORD);
  uint64_t v37;
  uint64_t (*v38)(uint64_t, _QWORD);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  NSObject *v42;
  os_log_type_t v43;
  const char *v44;
  _BYTE *v45;
  uint64_t v46;
  unsigned int (*v47)(uint64_t, uint64_t, _BYTE *);
  int v48;
  int v49;
  int v50;
  kern_return_t v51;
  uint64_t v52;
  unint64_t v53;
  int64_t v54;
  void *v55;
  NSObject *v56;
  int v57;
  int v58;
  os_log_type_t type[8];
  _BYTE buf[22];
  __int16 v61;
  _BYTE v62[10];
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  if (!*(_DWORD *)(a1 + 360))
  {
    if ((*(_BYTE *)(a1 + 828) & 2) != 0)
      return;
    __nwlog_tcp_log();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 604;
    v61 = 2048;
    *(_QWORD *)v62 = a1;
    v7 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_122;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_tcp_log();
      v9 = type[0];
      if (!os_log_type_enabled(v8, type[0]))
        goto LABEL_122;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "tcp_close_locked";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      v61 = 2048;
      *(_QWORD *)v62 = a1;
      v10 = "%{public}s %{public}s soclose: so=%p refcount=0";
    }
    else
    {
      v8 = __nwlog_tcp_log();
      v9 = type[0];
      if (!os_log_type_enabled(v8, type[0]))
        goto LABEL_122;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "tcp_close_locked";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      v61 = 2048;
      *(_QWORD *)v62 = a1;
      v10 = "%{public}s %{public}s soclose: so=%p refcount=0, backtrace limit exceeded";
    }
LABEL_121:
    _os_log_impl(&dword_209FB3000, v8, v9, v10, buf, 0x20u);
    goto LABEL_122;
  }
  if (*(_DWORD *)(a1 + 592))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "soclose_wait_locked";
    v3 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_19;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type[0];
      if (!os_log_type_enabled(v4, type[0]))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "soclose_wait_locked";
      v6 = "%{public}s currently not supported";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type[0];
      if (!os_log_type_enabled(v4, type[0]))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "soclose_wait_locked";
      v6 = "%{public}s currently not supported, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v4, v5, v6, buf, 0xCu);
LABEL_19:
    if (v3)
      free(v3);
  }
  *(_DWORD *)(a1 + 368) &= ~0x40u;
  v11 = *(_DWORD *)(a1 + 372);
  if ((v11 & 2) != 0)
  {
    *(_DWORD *)(a1 + 372) = v11 & 0xFFFFFFFD;
    v12 = *(_QWORD *)(a1 + 304);
    if (v12)
    {
      v13 = 0;
      do
      {
        v14 = v12;
        v12 = *(_QWORD *)(v12 + 336);
        if ((*(_BYTE *)(v14 + 365) & 2) == 0)
        {
          v15 = *(_QWORD *)(a1 + 8);
          v16 = v12;
          if (*(_QWORD *)(v15 + 32))
          {
            (*(void (**)(uint64_t, _QWORD, uint64_t))(v15 + 24))(a1, 0, v1);
            v13 = 1;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v14 + 8) + 16))(v14, 1, v1);
            (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 0, v1);
            v16 = *(_QWORD *)(v14 + 336);
          }
          v17 = *(uint64_t **)(v14 + 344);
          if (v16)
          {
            *(_QWORD *)(v16 + 344) = v17;
            v17 = *(uint64_t **)(v14 + 344);
          }
          else
          {
            *(_QWORD *)(a1 + 312) = v17;
          }
          *v17 = v16;
          --*(_WORD *)(a1 + 356);
          if ((*(_WORD *)(v14 + 376) & 0x800) != 0)
          {
            *(_WORD *)(v14 + 376) &= ~0x800u;
            *(_QWORD *)(v14 + 296) = 0;
            v18 = *(_DWORD *)(v14 + 364);
            if ((v18 & 0x100) == 0)
            {
              *(_DWORD *)(v14 + 364) = v18 | 0x100;
              if ((**(unsigned int (***)(uint64_t))(*(_QWORD *)(v14 + 8) + 40))(v14))
              {
                v19 = *(_QWORD *)(v14 + 8);
                if (v19)
                {
                  v20 = *(void (**)(uint64_t, _QWORD))(v19 + 32);
                  if (v20)
                    v20(v14, 0);
                }
                sofreelastref(v14);
              }
            }
          }
          if (v13)
          {
            v13 = 1;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v14 + 8) + 24))(v14, 1, v1);
          }
        }
      }
      while (v12);
    }
    while (1)
    {
      v27 = *(_QWORD *)(a1 + 320);
      if (!v27)
        break;
      v21 = *(_QWORD *)(v27 + 336);
      v22 = *(_QWORD **)(v27 + 344);
      if (v21)
      {
        *(_QWORD *)(v21 + 344) = v22;
        v22 = *(_QWORD **)(v27 + 344);
      }
      else
      {
        *(_QWORD *)(a1 + 328) = v22;
      }
      *v22 = v21;
      --*(_WORD *)(a1 + 352);
      v23 = *(_QWORD *)(a1 + 8);
      if (*(_QWORD *)(v23 + 32))
      {
        (*(void (**)(uint64_t, _QWORD, uint64_t))(v23 + 24))(a1, 0, v1);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v27 + 8) + 16))(v27, 1, v1);
      }
      if ((*(_WORD *)(v27 + 376) & 0x1000) != 0)
      {
        *(_WORD *)(v27 + 376) &= ~0x1000u;
        *(_QWORD *)(v27 + 296) = 0;
        v24 = *(_DWORD *)(v27 + 364);
        if ((v24 & 0x100) == 0)
        {
          *(_DWORD *)(v27 + 364) = v24 | 0x100;
          if ((**(unsigned int (***)(uint64_t))(*(_QWORD *)(v27 + 8) + 40))(v27))
          {
            v25 = *(_QWORD *)(v27 + 8);
            if (v25)
            {
              v26 = *(void (**)(uint64_t, _QWORD))(v25 + 32);
              if (v26)
                v26(v27, 0);
            }
            sofreelastref(v27);
          }
        }
      }
      if (*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32))
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v27 + 8) + 24))(v27, 1, v1);
        (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 0, v1);
      }
    }
  }
  if (!*(_QWORD *)a1)
  {
    v33 = *(_DWORD *)(a1 + 364) | 4;
    *(_DWORD *)(a1 + 364) = v33;
LABEL_76:
    *(_WORD *)(a1 + 376) |= 1u;
    if ((v33 & 0x1000000) == 0)
      goto LABEL_91;
    goto LABEL_90;
  }
  if ((*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v56 = __nwlog_tcp_log();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
      {
        v57 = *(_DWORD *)(a1 + 360);
        v58 = *(__int16 *)(a1 + 376);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "tcp_close_locked";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 604;
        v61 = 1024;
        *(_DWORD *)v62 = v57;
        *(_WORD *)&v62[4] = 1024;
        *(_DWORD *)&v62[6] = v58;
        _os_log_impl(&dword_209FB3000, v56, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s so_usecount %u so_state 0x%x", buf, 0x22u);
      }
    }
  }
  v28 = *(_WORD *)(a1 + 376);
  if ((v28 & 2) != 0
    && ((v28 & 8) != 0 || !(*(unsigned int (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40) + 40))(a1))
    && (*(_BYTE *)(a1 + 372) & 0x80) != 0
    && (~*(unsigned __int16 *)(a1 + 376) & 0x108) != 0)
  {
    v37 = *(_QWORD *)(a1 + 8);
    if (v37 && (v38 = *(uint64_t (**)(uint64_t, _QWORD))(v37 + 32)) != 0)
      v39 = v38(a1, 0);
    else
      v39 = 0;
    while ((*(_WORD *)(a1 + 376) & 2) != 0)
    {
      v46 = *(_QWORD *)(a1 + 32);
      if (v46)
      {
        v47 = *(unsigned int (**)(uint64_t, uint64_t, _BYTE *))(v46 + 112);
        if (v47)
        {
          v48 = *(_DWORD *)(a1 + 16);
          v49 = v48 / 100;
          v50 = v48 % 100;
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = 0;
          if ((v48 + 99) > 0xC6 || (v45 = 0, v50))
          {
            *(_QWORD *)type = 0;
            v51 = mach_timebase_info((mach_timebase_info_t)type);
            v45 = 0;
            if (!v51)
            {
              v52 = mach_absolute_time() * *(unsigned int *)type / *(unsigned int *)&type[4];
              v53 = v52 / 0x3B9ACA00;
              v54 = 10000000 * v50 + v52 % 0x3B9ACA00;
              *(_QWORD *)&buf[8] = v54;
              if (v54 > 999999999)
              {
                *(_QWORD *)&buf[8] = v54 - 1000000000;
                ++v53;
              }
              *(_QWORD *)buf = v53 + v49;
              v45 = buf;
            }
          }
          if (v47(a1, v39, v45))
            break;
        }
      }
    }
  }
  v29 = *(_DWORD *)(a1 + 360);
  if (!v29)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) != 0)
      return;
    __nwlog_tcp_log();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 604;
    v61 = 2048;
    *(_QWORD *)v62 = a1;
    v7 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_122;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_tcp_log();
      v9 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
LABEL_82:
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "tcp_close_locked";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 604;
        v61 = 2048;
        *(_QWORD *)v62 = a1;
        v10 = "%{public}s %{public}s soclose: usecount is zero so=%p";
        goto LABEL_121;
      }
LABEL_122:
      if (!v7)
        return;
      v55 = (void *)v7;
      goto LABEL_124;
    }
    v8 = __nwlog_tcp_log();
    v9 = type[0];
    if (!os_log_type_enabled(v8, type[0]))
      goto LABEL_122;
LABEL_100:
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 604;
    v61 = 2048;
    *(_QWORD *)v62 = a1;
    v10 = "%{public}s %{public}s soclose: usecount is zero so=%p, backtrace limit exceeded";
    goto LABEL_121;
  }
  if (*(_QWORD *)a1)
  {
    if ((*(_BYTE *)(a1 + 364) & 4) == 0)
    {
      v30 = *(_QWORD *)(a1 + 8);
      if (v30)
      {
        v31 = *(_QWORD *)(v30 + 40);
        if (v31)
        {
          v32 = *(void (**)(uint64_t))(v31 + 32);
          if (v32)
          {
            v32(a1);
            v29 = *(_DWORD *)(a1 + 360);
          }
        }
      }
    }
  }
  if (v29 <= 0)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) != 0)
      return;
    __nwlog_tcp_log();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 604;
    v61 = 2048;
    *(_QWORD *)v62 = a1;
    v7 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_122;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_tcp_log();
      v9 = type[0];
      if (os_log_type_enabled(v8, type[0]))
        goto LABEL_82;
      goto LABEL_122;
    }
    v8 = __nwlog_tcp_log();
    v9 = type[0];
    if (!os_log_type_enabled(v8, type[0]))
      goto LABEL_122;
    goto LABEL_100;
  }
  v33 = *(_DWORD *)(a1 + 364);
  if (!*(_QWORD *)a1)
    goto LABEL_76;
  v34 = *(_WORD *)(a1 + 376);
  if ((v33 & 0x1000000) != 0)
  {
    *(_WORD *)(a1 + 376) = v34 | 1;
LABEL_90:
    *(_DWORD *)(a1 + 364) = v33 & 0xFEFFFFFF;
    goto LABEL_91;
  }
  if ((v34 & 1) != 0)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) != 0)
      return;
    __nwlog_tcp_log();
    v40 = a1 + 604;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 604;
    v41 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_129;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v42 = __nwlog_tcp_log();
      v43 = type[0];
      if (os_log_type_enabled(v42, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_close_locked";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v40;
        v44 = "%{public}s %{public}s soclose: NOFDREF";
LABEL_128:
        _os_log_impl(&dword_209FB3000, v42, v43, v44, buf, 0x16u);
      }
    }
    else
    {
      v42 = __nwlog_tcp_log();
      v43 = type[0];
      if (os_log_type_enabled(v42, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_close_locked";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v40;
        v44 = "%{public}s %{public}s soclose: NOFDREF, backtrace limit exceeded";
        goto LABEL_128;
      }
    }
LABEL_129:
    if (!v41)
      return;
    v55 = (void *)v41;
LABEL_124:
    free(v55);
    return;
  }
  *(_WORD *)(a1 + 376) = v34 | 1;
LABEL_91:
  --*(_DWORD *)(a1 + 360);
  v35 = *(_QWORD *)(a1 + 8);
  if (v35)
  {
    v36 = *(void (**)(uint64_t, _QWORD))(v35 + 32);
    if (v36)
      v36(a1, 0);
  }
  sofreelastref(a1);
}

uint64_t sofreelastref(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  __int16 v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t all_stats;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(result + 364) & 4) != 0)
  {
    v2 = result;
    if ((*(_WORD *)(result + 376) & 1) != 0)
    {
      v3 = *(_QWORD *)(result + 296);
      if (v3)
      {
        (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(v3 + 8) + 16))(*(_QWORD *)(result + 296), 1, v1);
        v4 = *(_WORD *)(v2 + 376);
        if ((v4 & 0x800) != 0)
        {
          v6 = *(_QWORD *)(v2 + 336);
          v7 = *(_QWORD **)(v2 + 344);
          if (v6)
          {
            *(_QWORD *)(v6 + 344) = v7;
            v7 = *(_QWORD **)(v2 + 344);
          }
          else
          {
            *(_QWORD *)(v3 + 312) = v7;
          }
          *v7 = v6;
          --*(_WORD *)(v3 + 356);
        }
        else
        {
          if ((*(_WORD *)(v2 + 376) & 0x1000) != 0)
            return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v3 + 8) + 24))(v3, 1, v1);
          if ((*(_BYTE *)(v2 + 828) & 2) == 0)
          {
            __nwlog_tcp_log();
            *(_DWORD *)buf = 136446466;
            v13 = "sofreelastref";
            v14 = 2082;
            v15 = v2 + 604;
            v5 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_fault())
            {
              v8 = __nwlog_tcp_log();
              if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                v13 = "sofreelastref";
                v14 = 2082;
                v15 = v2 + 604;
                _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_ERROR, "%{public}s %{public}s sofree: not queued, backtrace limit exceeded", buf, 0x16u);
              }
            }
            if (v5)
              free(v5);
            v4 = *(_WORD *)(v2 + 376);
          }
        }
        --*(_WORD *)(v3 + 352);
        *(_WORD *)(v2 + 376) = v4 & 0xF7FF;
        *(_QWORD *)(v2 + 296) = 0;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v3 + 8) + 24))(v3, 1, v1);
      }
      sblock(v2 + 384);
      *(_DWORD *)(v2 + 432) |= 0x80u;
      sbunlock(v2 + 384);
      sbflush(v2 + 384);
      *(_DWORD *)(v2 + 388) = 0;
      v9 = *(_QWORD *)(*(_QWORD *)(v2 + 456) + 24);
      if ((*(_BYTE *)(v2 + 432) & 4) != 0)
      {
        if (v9)
        {
          all_stats = nw_protocol_tcp_get_all_stats();
          if (all_stats)
            *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v2 + 388);
        }
      }
      else if (v9)
      {
        v10 = nw_protocol_tcp_get_all_stats();
        if (v10)
          *(_DWORD *)(v10 + 100) = *(_DWORD *)(v2 + 388);
      }
      return sorflush(v2);
    }
  }
  return result;
}

uint64_t tcp_usr_disconnect(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v1 = *a1;
  (*(void (**)(void))(a1[1] + 32))();
  if (!v1 || *(_DWORD *)(v1 + 232) == 3)
    return 22;
  v3 = *(_QWORD *)(v1 + 240);
  v4 = nw_tcp_access_globals(*(_QWORD *)(v1 + 224));
  calculate_tcp_clock(v4);
  if (v3)
    tcp_disconnect(v3);
  return 0;
}

uint64_t tcp_usr_detach(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v4;
  uint64_t v5;

  v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3)
    return 22;
  (*(void (**)(void))(a1[1] + 32))();
  v4 = *(_QWORD *)(v1 + 240);
  if (v4)
  {
    v5 = nw_tcp_access_globals((uint64_t)a1);
    calculate_tcp_clock(v5);
    tcp_disconnect(v4);
  }
  return 0;
}

void nw_protocol_tcp_wake_disconnected(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  uint8_t buf[4];
  const char *v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) == 4)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
    {
      v3 = __nwlog_tcp_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v6 = "nw_protocol_tcp_wake_disconnected";
        v7 = 2082;
        v8 = a1 + 604;
        _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
      }
    }
  }
  else
  {
    *(_DWORD *)(v2 + 5224) = 4;
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      v4 = __nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        v6 = "nw_protocol_tcp_wake_disconnected";
        v7 = 2082;
        v8 = a1 + 604;
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s tcp disconnected", buf, 0x16u);
      }
    }
    if (*MEMORY[0x24BDE08B8] != -1)
      dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_16);
    if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
      kdebug_trace();
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }
}

uint64_t tcp_rledbat_get_rlwin(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  int v4;
  int v5;
  char v6;
  unsigned int v7;

  LODWORD(v1) = *(_DWORD *)(a1 + 1948);
  v2 = *(_DWORD *)(a1 + 1960);
  v3 = v2 - v1;
  if (v2 >= v1)
  {
    v4 = v2 <= v1 ? 0 : *(_DWORD *)(a1 + 1956);
    v5 = v2 - v4;
    if (v3 >= *(_DWORD *)(a1 + 1956))
      LODWORD(v1) = v5;
  }
  *(_DWORD *)(a1 + 1956) = 0;
  v6 = *(_BYTE *)(a1 + 261);
  v7 = ((1 << v6) + v1) & -(1 << v6);
  if ((v1 & ((1 << v6) - 1)) == 0)
    v7 = v1;
  if (*(_BYTE *)(a1 + 261))
    v1 = v7;
  else
    v1 = v1;
  *(_DWORD *)(a1 + 1960) = v1;
  return v1;
}

uint64_t nw_protocol_tcp_copy_info(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int32x2_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int8x16_t v15;
  nw_protocol_definition_t v16;
  void *v17;
  NSObject *v18;
  uint64_t result;
  void *v20;
  NSObject *v21;
  const char *v22;
  NSObject *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  NSObject *v27;
  void *v28;
  uint8_t buf[32];
  __int128 v30;
  __int128 v31;
  _OWORD v32[2];
  _OWORD v33[3];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_copy_info";
    v20 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v21 = __nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_copy_info";
        v22 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_48:
        _os_log_impl(&dword_209FB3000, v21, OS_LOG_TYPE_ERROR, v22, buf, 0xCu);
      }
    }
LABEL_49:
    if (v20)
      free(v20);
    return 0;
  }
  v5 = nw_protocol_downcast();
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_copy_info";
    v20 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v21 = __nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_copy_info";
        v22 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_48;
      }
    }
    goto LABEL_49;
  }
  v6 = v5;
  v7 = v5 + 832;
  v8 = (int32x2_t *)(v5 + 3072);
  if (a2 > 253)
  {
    if (a2 == 254)
    {
      nw_protocol_get_output_handler();
      v9 = nw_protocol_copy_info_quiet();
      if (!v9)
        v9 = nw_array_create();
      v16 = nw_protocol_copy_tcp_definition();
      v17 = (void *)nw_protocol_establishment_report_create();
      if (v16)
        nw_release(v16);
      v50 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      v36 = 0u;
      v37 = 0u;
      v34 = 0u;
      v35 = 0u;
      memset(v33, 0, sizeof(v33));
      memset(v32, 0, sizeof(v32));
      v30 = 0u;
      v31 = 0u;
      memset(buf, 0, sizeof(buf));
      tcp_fill_info((uint64_t)v8, v7, v6, (uint64_t)buf);
      nw_protocol_establishment_report_set_client_accurate_ecn_state();
      nw_protocol_establishment_report_set_server_accurate_ecn_state();
      nw_array_append();
      if (v17)
        nw_release(v17);
      return v9;
    }
    if (a2 == 255)
    {
      nw_protocol_get_output_handler();
      v9 = nw_protocol_copy_info_quiet();
      if (!v9)
        v9 = nw_array_create();
      nw_array_append();
      return v9;
    }
    goto LABEL_15;
  }
  if (a2 == 1)
  {
    if ((*(_BYTE *)(v5 + 5310) & 4) != 0)
    {
      v9 = (uint64_t)malloc_type_malloc(0x198uLL, 0xF2B69DE5uLL);
      if (v9)
      {
        tcp_fill_info((uint64_t)v8, v7, v6, v9);
        if (!a3)
          return v9;
      }
      else
      {
        v25 = __nwlog_obj();
        os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "strict_malloc";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = 408;
        v26 = (void *)_os_log_send_and_compose_impl();
        result = __nwlog_abort();
        if ((_DWORD)result)
          goto LABEL_59;
        free(v26);
        tcp_fill_info((uint64_t)v8, v7, v6, 0);
        if (!a3)
          return v9;
      }
      v10 = 408;
      goto LABEL_38;
    }
    return 0;
  }
  if (a2 != 2)
  {
LABEL_15:
    nw_protocol_get_output_handler();
    v11 = nw_protocol_copy_info_quiet();
    v9 = v11;
    if (a2 != 5)
    {
      if ((*(_BYTE *)(v6 + 828) & 2) == 0)
      {
        v18 = __nwlog_tcp_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_copy_info";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v6 + 604;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = a2;
          _os_log_impl(&dword_209FB3000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s unknown protocol info type %d", buf, 0x1Cu);
        }
      }
      return v9;
    }
    if (!v11)
    {
      v9 = (uint64_t)malloc_type_calloc(1uLL, 0xB8uLL, 0xEAFB8F1AuLL);
      if (!v9)
      {
        v27 = __nwlog_obj();
        os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "strict_calloc";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = 1;
        *(_WORD *)&buf[22] = 2048;
        *(_QWORD *)&buf[24] = 184;
        v28 = (void *)_os_log_send_and_compose_impl();
        result = __nwlog_abort();
        if ((_DWORD)result)
          goto LABEL_59;
        free(v28);
        v9 = 0;
      }
    }
    v50 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v44 = 0u;
    v45 = 0u;
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    memset(v33, 0, sizeof(v33));
    memset(v32, 0, sizeof(v32));
    v30 = 0u;
    v31 = 0u;
    memset(buf, 0, sizeof(buf));
    tcp_fill_info((uint64_t)v8, v7, v6, (uint64_t)buf);
    *(_QWORD *)(v9 + 72) = *(_QWORD *)((char *)v32 + 12);
    *(_OWORD *)(v9 + 48) = *(_OWORD *)((char *)v33 + 12);
    *(_QWORD *)(v9 + 64) = *(_QWORD *)((char *)&v33[1] + 12);
    *(_QWORD *)(v9 + 80) = *(_QWORD *)((char *)&v32[1] + 4);
    v12 = *(unsigned int *)&buf[20];
    v14 = *(unsigned int *)&buf[28];
    v13 = v30;
    *(_QWORD *)(v9 + 120) = *(unsigned int *)&buf[24];
    *(_QWORD *)(v9 + 128) = v13;
    *(_QWORD *)(v9 + 136) = v12;
    *(_QWORD *)(v9 + 144) = v14;
    v15.i64[0] = DWORD1(v30);
    v15.i64[1] = DWORD2(v30);
    *(int8x16_t *)(v9 + 152) = vextq_s8(v15, v15, 8uLL);
    if (!*(_QWORD *)(v9 + 8))
      *(_QWORD *)(v9 + 8) = *(_QWORD *)((char *)v33 + 4);
    if (!*(_QWORD *)(v9 + 40))
      *(_QWORD *)(v9 + 40) = *(_QWORD *)((char *)v32 + 4);
    *(_OWORD *)(v9 + 88) = v44;
    *(_OWORD *)(v9 + 104) = v45;
    if (!a3)
      return v9;
    v10 = 184;
    goto LABEL_38;
  }
  if ((*(_BYTE *)(v5 + 5310) & 4) == 0)
    return 0;
  v9 = (uint64_t)malloc_type_malloc(0x70uLL, 0xF2B69DE5uLL);
  if (v9)
  {
    tcp_connection_fill_info(v8, v7, v6, v9);
    if (a3)
    {
LABEL_9:
      v10 = 112;
LABEL_38:
      *a3 = v10;
    }
    return v9;
  }
  v23 = __nwlog_obj();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  *(_QWORD *)&buf[4] = "strict_malloc";
  *(_WORD *)&buf[12] = 2048;
  *(_QWORD *)&buf[14] = 112;
  v24 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v24);
    tcp_connection_fill_info(v8, v7, v6, 0);
    if (!a3)
      return v9;
    goto LABEL_9;
  }
LABEL_59:
  __break(1u);
  return result;
}

void tcp_fill_info(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_lock_s *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  BOOL v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD *v20;
  uint64_t v21;
  __int128 v22;
  char v23;
  _OWORD *v24;
  _OWORD *v25;
  _OWORD *v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  int v46;
  int v47;
  NSObject *v48;
  const char *v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  __int128 v56;
  int64x2_t v57;
  int8x16_t v58;
  int v59;
  const char *v60;
  __int16 v61;
  const char *v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a4 + 400) = 0;
  *(_OWORD *)(a4 + 368) = 0u;
  *(_OWORD *)(a4 + 384) = 0u;
  *(_OWORD *)(a4 + 336) = 0u;
  *(_OWORD *)(a4 + 352) = 0u;
  *(_OWORD *)(a4 + 304) = 0u;
  *(_OWORD *)(a4 + 320) = 0u;
  *(_OWORD *)(a4 + 272) = 0u;
  *(_OWORD *)(a4 + 288) = 0u;
  *(_OWORD *)(a4 + 240) = 0u;
  *(_OWORD *)(a4 + 256) = 0u;
  *(_OWORD *)(a4 + 208) = 0u;
  *(_OWORD *)(a4 + 224) = 0u;
  *(_OWORD *)(a4 + 176) = 0u;
  *(_OWORD *)(a4 + 192) = 0u;
  *(_OWORD *)(a4 + 144) = 0u;
  *(_OWORD *)(a4 + 160) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  if (a1 && a2)
  {
    v8 = (os_unfair_lock_s *)(a1 + 1864);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1864));
    v9 = *(_DWORD *)(a1 + 12);
    *(_BYTE *)a4 = v9;
    *(_DWORD *)(a4 + 280) = *(_DWORD *)(a2 + 460);
    v10 = *(_DWORD *)(a1 + 88);
    if ((~v10 & 0x180) == 0)
      *(_BYTE *)(a4 + 1) |= 1u;
    v11 = *(_DWORD *)(a1 + 740);
    if ((v11 & 0x20) != 0)
      *(_BYTE *)(a4 + 1) |= 2u;
    if ((~v10 & 0x60) == 0)
    {
      *(_BYTE *)(a4 + 1) |= 4u;
      *(_WORD *)(a4 + 2) = *(_WORD *)(a1 + 260);
    }
    if ((~*(_DWORD *)(a1 + 348) & 3) == 0)
      *(_BYTE *)(a4 + 1) |= 8u;
    if ((v10 & 0x200000) != 0 || *(_WORD *)(a1 + 226))
      *(_DWORD *)(a4 + 4) |= 1u;
    if ((v10 & 0x2000000) != 0)
      *(_DWORD *)(a4 + 4) |= 2u;
    v12 = *(_DWORD *)(a1 + 28);
    if (v12)
      v12 = *(_DWORD *)(a1 + 192);
    *(_DWORD *)(a4 + 8) = v12;
    v13 = *(_DWORD *)(a1 + 196);
    *(_DWORD *)(a4 + 12) = v13;
    *(_DWORD *)(a4 + 16) = v13;
    *(_DWORD *)(a4 + 20) = *(_DWORD *)(a1 + 236);
    *(_DWORD *)(a4 + 24) = *(int *)(a1 + 200) >> 5;
    *(_DWORD *)(a4 + 292) = *(_DWORD *)(a1 + 1968) >> 5;
    *(_DWORD *)(a4 + 28) = *(int *)(a1 + 208) >> 4;
    *(_DWORD *)(a4 + 32) = *(_DWORD *)(a1 + 232) >> 5;
    *(int32x2_t *)(a4 + 36) = vrev64_s32(*(int32x2_t *)(a1 + 144));
    *(_DWORD *)(a4 + 64) = *(_DWORD *)(a3 + 384);
    v15 = *(_DWORD *)(a1 + 120);
    v14 = *(_DWORD *)(a1 + 124);
    v16 = v14 >= v15;
    v17 = v14 - v15;
    if (!v16)
      v17 = 0;
    *(_DWORD *)(a4 + 44) = v17;
    *(_DWORD *)(a4 + 48) = *(_DWORD *)(a1 + 140);
    *(_DWORD *)(a4 + 52) = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a4 + 56) = v15;
    if ((v11 & 8) != 0)
    {
      v18 = *(_QWORD *)(a1 + 768);
      if (v18)
        *(_QWORD *)(a4 + 132) = (8000 * *(_DWORD *)(v18 + 28));
    }
    v19 = *(_QWORD *)(a2 + 448);
    if (v19)
      LODWORD(v19) = *(unsigned __int16 *)(v19 + 1072);
    *(_DWORD *)(a4 + 60) = v19;
    v20 = *(_OWORD **)(a2 + 248);
    *(_OWORD *)(a4 + 68) = v20[1];
    *(_QWORD *)(a4 + 84) = *(unsigned int *)(a1 + 712);
    *(_QWORD *)(a4 + 284) = *(unsigned int *)(a1 + 720);
    *(_QWORD *)(a4 + 92) = (*(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92));
    *(_OWORD *)(a4 + 100) = *v20;
    v21 = *(_QWORD *)(a1 + 704);
    *(_QWORD *)&v22 = v21;
    *((_QWORD *)&v22 + 1) = HIDWORD(v21);
    *(_OWORD *)(a4 + 116) = v22;
    if (v9 >= 2)
      *(_BYTE *)(a4 + 140) = *(_BYTE *)(a1 + 716);
    v23 = 0;
    v24 = *(_OWORD **)(a2 + 256);
    *(_OWORD *)(a4 + 144) = *v24;
    *(_OWORD *)(a4 + 160) = v24[1];
    v25 = *(_OWORD **)(a2 + 264);
    *(_OWORD *)(a4 + 176) = *v25;
    *(_OWORD *)(a4 + 192) = v25[1];
    v26 = *(_OWORD **)(a2 + 272);
    *(_OWORD *)(a4 + 208) = *v26;
    *(_OWORD *)(a4 + 224) = v26[1];
    *(_DWORD *)(a4 + 240) = 0;
    if (*(unsigned __int16 *)(a1 + 226) >= 5u)
    {
      if (*(int *)(a1 + 12) <= 3)
        v23 = 8;
      else
        v23 = 2;
      *(_BYTE *)(a4 + 240) = v23;
    }
    if (*(unsigned __int8 *)(a1 + 311) >= 5u)
    {
      v23 |= 4u;
      *(_BYTE *)(a4 + 240) = v23;
    }
    v27 = *(_QWORD *)(a1 + 80);
    if (v27)
    {
      v28 = *(_QWORD *)(v27 + 448);
      if (v28)
      {
        if ((*(_BYTE *)(v28 + 1052) & 8) != 0)
          *(_BYTE *)(a4 + 240) = v23 | 1;
      }
    }
    v29 = *(_DWORD *)(a4 + 244) & 0xFFFFFFDF | (32 * (*(_WORD *)(a1 + 990) & 1));
    *(_DWORD *)(a4 + 244) = v29;
    v30 = v29 & 0xFFFFFFBF | (((*(unsigned __int16 *)(a1 + 990) >> 1) & 1) << 6);
    *(_DWORD *)(a4 + 244) = v30;
    v31 = v30 & 0xFFFFFF7F | (((*(unsigned __int16 *)(a1 + 990) >> 2) & 1) << 7);
    *(_DWORD *)(a4 + 244) = v31;
    v32 = v31 & 0xFFFFFEFF | (((*(unsigned __int16 *)(a1 + 990) >> 3) & 1) << 8);
    *(_DWORD *)(a4 + 244) = v32;
    v33 = v32 & 0xFFFFFFFE | (*(unsigned __int16 *)(a1 + 990) >> 4) & 1;
    *(_DWORD *)(a4 + 244) = v33;
    v34 = v33 & 0xFFFFFFFD | (2 * ((*(unsigned __int16 *)(a1 + 990) >> 5) & 1));
    *(_DWORD *)(a4 + 244) = v34;
    v35 = v34 & 0xFFFFFFF7 | (8 * ((*(unsigned __int16 *)(a1 + 990) >> 6) & 1));
    *(_DWORD *)(a4 + 244) = v35;
    v36 = v35 & 0xFFFFFFEF | (16 * ((*(unsigned __int16 *)(a1 + 990) >> 7) & 1));
    *(_DWORD *)(a4 + 244) = v36;
    v37 = v36 & 0xFFFFFFFB | (4 * (HIBYTE(*(unsigned __int16 *)(a1 + 990)) & 1));
    *(_DWORD *)(a4 + 244) = v37;
    v38 = v37 & 0xFFFFFDFF | (((*(unsigned __int16 *)(a1 + 990) >> 9) & 1) << 9);
    *(_DWORD *)(a4 + 244) = v38;
    v39 = v38 & 0xFFFFFBFF | (((*(unsigned __int16 *)(a1 + 990) >> 10) & 1) << 10);
    *(_DWORD *)(a4 + 244) = v39;
    v40 = v39 & 0xFFFFF7FF | (((*(unsigned __int16 *)(a1 + 990) >> 11) & 1) << 11);
    *(_DWORD *)(a4 + 244) = v40;
    v41 = v40 & 0xFFFFEFFF | (((*(unsigned __int16 *)(a1 + 990) >> 12) & 1) << 12);
    *(_DWORD *)(a4 + 244) = v41;
    v42 = v41 & 0xFFFFDFFF | (((*(unsigned __int16 *)(a1 + 990) >> 13) & 1) << 13);
    *(_DWORD *)(a4 + 244) = v42;
    v43 = v42 & 0xFFFFBFFF | (((*(unsigned __int16 *)(a1 + 990) >> 14) & 1) << 14);
    *(_DWORD *)(a4 + 244) = v43;
    v44 = v43 & 0xFFFF7FFF | (((*(_DWORD *)(a1 + 348) & 0x100001) != 0) << 15);
    *(_DWORD *)(a4 + 244) = v44;
    v45 = v44 & 0xFFFEFFFF | (((*(_DWORD *)(a1 + 348) & 0x200002) != 0) << 16);
    *(_DWORD *)(a4 + 244) = v45;
    v46 = *(_DWORD *)(a1 + 348);
    if ((~v46 & 3) != 0)
    {
      v50 = *(_DWORD *)(a1 + 740);
      if ((v50 & 0x10000000) == 0 && ((v50 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
        v47 = ((~v46 & 0x300000) == 0) << 17;
      else
        v47 = 0;
    }
    else
    {
      v47 = 0x20000;
    }
    v51 = v47 | v45 & 0xFFFDFFFF;
    *(_DWORD *)(a4 + 244) = v51;
    v52 = v51 & 0xFFFBFFFF | (((*(_DWORD *)(a1 + 348) >> 8) & 1) << 18);
    *(_DWORD *)(a4 + 244) = v52;
    v53 = v52 & 0xFFF7FFFF | (((*(_DWORD *)(a1 + 348) >> 9) & 1) << 19);
    *(_DWORD *)(a4 + 244) = v53;
    v54 = v53 & 0xFFEFFFFF | (((*(_DWORD *)(a1 + 88) >> 17) & 1) << 20);
    *(_DWORD *)(a4 + 244) = v54;
    v55 = *(_QWORD *)(a2 + 448);
    if (v55)
    {
      if (*(unsigned __int8 *)(v55 + 1076) == 255 || *(_DWORD *)(v55 + 1024) == 255)
      {
        v54 |= 0x200000u;
        *(_DWORD *)(a4 + 244) = v54;
        v55 = *(_QWORD *)(a2 + 448);
      }
      if (*(_DWORD *)(v55 + 1068) == 3 || *(_DWORD *)(v55 + 1032) == 3)
      {
        v54 |= 0x400000u;
        *(_DWORD *)(a4 + 244) = v54;
        v55 = *(_QWORD *)(a2 + 448);
      }
      if (*(_DWORD *)(v55 + 1064) == 2 || *(_DWORD *)(v55 + 1028) == 2)
      {
        v54 |= 0x800000u;
        *(_DWORD *)(a4 + 244) = v54;
        v55 = *(_QWORD *)(a2 + 448);
        if (*(_DWORD *)(v55 + 1064) == 2 && *(_DWORD *)(v55 + 1068) == 3 && (*(_BYTE *)(v55 + 1054) & 0x10) == 0)
        {
          v54 |= 0x1000000u;
          *(_DWORD *)(a4 + 244) = v54;
          v55 = *(_QWORD *)(a2 + 448);
        }
      }
      if ((*(_BYTE *)(v55 + 1054) & 0x10) != 0)
      {
        v54 |= 0x2000000u;
        *(_DWORD *)(a4 + 244) = v54;
      }
    }
    if (*(_BYTE *)(a1 + 264) == 2)
    {
      v54 |= 0x4000000u;
      *(_DWORD *)(a4 + 244) = v54;
    }
    if (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(a3 + 369) & 0x40) != 0)
      *(_DWORD *)(a4 + 244) = v54 | 0x8000000;
    *(_QWORD *)&v56 = *(_QWORD *)(a1 + 352);
    *((_QWORD *)&v56 + 1) = *(_QWORD *)(a1 + 996);
    *(_OWORD *)(a4 + 248) = v56;
    *(_DWORD *)(a4 + 264) = *(_DWORD *)(a1 + 1004);
    *(_QWORD *)(a4 + 268) = *(_QWORD *)(a1 + 1016);
    *(_DWORD *)(a4 + 276) = *(_DWORD *)(a1 + 1024);
    *(_QWORD *)(a4 + 296) = *(_QWORD *)(a1 + 360);
    *(_OWORD *)(a4 + 304) = *(_OWORD *)(a1 + 368);
    *(_OWORD *)(a4 + 320) = *(_OWORD *)(a1 + 384);
    *(_QWORD *)(a4 + 336) = (*(_DWORD *)(a1 + 416) - 5);
    v57.i64[0] = -1;
    v57.i64[1] = -1;
    v58 = (int8x16_t)vaddq_s64(*(int64x2_t *)(a1 + 432), v57);
    *(int8x16_t *)(a4 + 344) = vextq_s8(v58, v58, 8uLL);
    *(_QWORD *)(a4 + 360) = *(_QWORD *)(a1 + 448);
    *(_QWORD *)(a4 + 368) = *(_QWORD *)(a1 + 464) - 1;
    *(_QWORD *)(a4 + 376) = *(_QWORD *)(a1 + 456) - 1;
    *(_QWORD *)(a4 + 384) = *(_QWORD *)(a1 + 472);
    os_unfair_lock_unlock(v8);
  }
  else
  {
    v48 = __nwlog_obj();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
    {
      v49 = "tp";
      if (!a2)
        v49 = "inp";
      v59 = 136446466;
      v60 = "tcp_fill_info";
      v61 = 2082;
      v62 = v49;
      _os_log_impl(&dword_209FB3000, v48, OS_LOG_TYPE_INFO, "%{public}s %{public}s is NULL", (uint8_t *)&v59, 0x16u);
    }
  }
}

__n128 tcp_connection_fill_info(int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int32 v5;
  int v6;
  __int32 v7;
  NSObject *v8;
  __n128 result;
  const char *v10;
  int v11;
  __int32 v12;
  unsigned __int32 v13;
  unsigned __int32 v14;
  BOOL v15;
  unsigned __int32 v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  const char *v23;
  __int16 v24;
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  if (a1 && a2)
  {
    *(_BYTE *)a4 = a1[1].i32[1];
    v5 = a1[11].i32[0];
    if ((~v5 & 0x180) != 0)
    {
      v6 = 0;
      v7 = a1[92].i32[1];
      if ((v7 & 0x20) == 0)
        goto LABEL_12;
    }
    else
    {
      v6 = 1;
      *(_DWORD *)(a4 + 4) = 1;
      v7 = a1[92].i32[1];
      if ((v7 & 0x20) == 0)
      {
LABEL_12:
        if ((~v5 & 0x60) == 0)
        {
          v6 |= 4u;
          *(_DWORD *)(a4 + 4) = v6;
          *(_WORD *)(a4 + 1) = a1[32].i16[2];
        }
        if ((~a1[43].i32[1] & 3) == 0)
          *(_DWORD *)(a4 + 4) = v6 | 8;
        if ((v5 & 0x200000) != 0 || a1[28].i16[1])
        {
          *(_DWORD *)(a4 + 8) = 1;
          v11 = 3;
          if ((v7 & 0x2000) == 0)
          {
LABEL_20:
            v12 = a1[3].i32[1];
            if (v12)
              v12 = a1[24].i32[0];
            *(_DWORD *)(a4 + 12) = v12;
            *(_DWORD *)(a4 + 16) = a1[24].i32[1];
            *(int32x2_t *)(a4 + 20) = vrev64_s32(a1[18]);
            *(_DWORD *)(a4 + 28) = a1[17].i32[1];
            *(_DWORD *)(a4 + 32) = *(_DWORD *)(a3 + 384);
            v14 = a1[15].u32[0];
            v13 = a1[15].u32[1];
            v15 = v13 >= v14;
            v16 = v13 - v14;
            if (!v15)
              v16 = 0;
            *(_DWORD *)(a4 + 36) = v16;
            *(_DWORD *)(a4 + 40) = a1[29].i32[1];
            *(_DWORD *)(a4 + 44) = a1[25].i32[0] >> 5;
            *(_DWORD *)(a4 + 48) = a1[26].i32[0] >> 4;
            v17 = *(_QWORD *)(a2 + 248);
            *(_OWORD *)(a4 + 56) = *(_OWORD *)(v17 + 16);
            *(_QWORD *)(a4 + 72) = a1[89].u32[0];
            *(_QWORD *)(a4 + 104) = a1[90].u32[0];
            result = *(__n128 *)v17;
            *(_OWORD *)(a4 + 80) = *(_OWORD *)v17;
            *(_QWORD *)(a4 + 96) = a1[88].u32[1];
            LOBYTE(v17) = a1[123].i16[3];
            *(_DWORD *)(a4 + 52) = 32 * (v17 & 1);
            v18 = (32 * a1[123].u16[3]) & 0x40 | (32 * (v17 & 1));
            *(_DWORD *)(a4 + 52) = v18;
            v19 = v18 & 0xFFFFFF7F | (((a1[123].u16[3] >> 2) & 1) << 7);
            *(_DWORD *)(a4 + 52) = v19;
            v20 = v19 & 0xFFFFFEFF | (((a1[123].u16[3] >> 3) & 1) << 8);
            *(_DWORD *)(a4 + 52) = v20;
            v21 = v20 & 0xFFFFFFFE | (a1[123].u16[3] >> 4) & 1;
            *(_DWORD *)(a4 + 52) = v21;
            LODWORD(v17) = v21 | (a1[123].u16[3] >> 4) & 2;
            *(_DWORD *)(a4 + 52) = v17;
            LODWORD(v17) = v17 & 0xFFFFFFF7 | (a1[123].u16[3] >> 3) & 8;
            *(_DWORD *)(a4 + 52) = v17;
            LODWORD(v17) = v17 & 0xFFFFFFEF | (a1[123].u16[3] >> 3) & 0x10;
            *(_DWORD *)(a4 + 52) = v17;
            LODWORD(v17) = v17 & 0xFFFFFFFB | (a1[123].u16[3] >> 6) & 4;
            *(_DWORD *)(a4 + 52) = v17;
            LODWORD(v17) = v17 & 0xFFFFFDFF | a1[123].i16[3] & 0x200;
            *(_DWORD *)(a4 + 52) = v17;
            LODWORD(v17) = v17 & 0xFFFFFBFF | a1[123].i16[3] & 0x400;
            *(_DWORD *)(a4 + 52) = v17;
            LODWORD(v17) = v17 & 0xFFFFF7FF | a1[123].i16[3] & 0x800;
            *(_DWORD *)(a4 + 52) = v17;
            LODWORD(v17) = v17 & 0xFFFFEFFF | a1[123].i16[3] & 0x1000;
            *(_DWORD *)(a4 + 52) = v17;
            LODWORD(v17) = v17 & 0xFFFFDFFF | a1[123].i16[3] & 0x2000;
            *(_DWORD *)(a4 + 52) = v17;
            *(_DWORD *)(a4 + 52) = v17 & 0xFFFFBFFF | a1[123].i16[3] & 0x4000;
            return result;
          }
        }
        else
        {
          v11 = 2;
          if ((v7 & 0x2000) == 0)
            goto LABEL_20;
        }
        *(_DWORD *)(a4 + 8) = v11;
        goto LABEL_20;
      }
    }
    v6 |= 2u;
    *(_DWORD *)(a4 + 4) = v6;
    goto LABEL_12;
  }
  v8 = __nwlog_obj();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    v10 = "tp";
    if (!a2)
      v10 = "inp";
    v22 = 136446466;
    v23 = "tcp_connection_fill_info";
    v24 = 2082;
    v25 = v10;
    _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_INFO, "%{public}s %{public}s is NULL", (uint8_t *)&v22, 0x16u);
  }
  return result;
}

void tcp_release_route_heuristics(uint64_t a1)
{
  NSObject *v1;
  uint64_t heuristics;
  uint64_t v3;
  int v4;
  uint64_t v5;
  const char *v6;
  int v7;
  void *v8;
  uint64_t v9;
  char *v10;
  NSObject *v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  void *v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v1 = a1;
  v18 = *MEMORY[0x24BDAC8D0];
  heuristics = tcp_get_heuristics(*(_QWORD *)(a1 + 80), 0);
  if (heuristics)
  {
    v3 = heuristics;
    v4 = *(_DWORD *)(heuristics + 148);
    *(_DWORD *)(heuristics + 148) = v4 - 1;
    if (v4 > 0)
      return;
    v5 = *((_QWORD *)v1[10].isa + 28);
    if (v5)
    {
      if ((*(_BYTE *)(v5 + 828) & 2) != 0)
        return;
    }
    v1 = __nwlog_tcp_log();
    os_log_type_enabled(v1, OS_LOG_TYPE_ERROR);
    v6 = (const char *)(v5 + 604);
    v13 = "tcp_release_route_heuristics";
    v7 = *(_DWORD *)(v3 + 148);
    *(_DWORD *)buf = 136446722;
    if (!v5)
      v6 = "";
    v14 = 2082;
    v15 = (void *)v6;
    v16 = 1024;
    LODWORD(v17) = v7;
    v8 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort())
      goto LABEL_18;
    __break(1u);
  }
  v9 = *((_QWORD *)v1[10].isa + 28);
  if (!v9 || (*(_BYTE *)(v9 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    v10 = v9 ? (char *)(v9 + 604) : "";
    *(_DWORD *)buf = 136446466;
    v13 = "tcp_release_route_heuristics";
    v14 = 2082;
    v15 = v10;
    v8 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v11 = __nwlog_tcp_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v13 = "tcp_release_route_heuristics";
        v14 = 2082;
        v15 = v10;
        _os_log_impl(&dword_209FB3000, v11, OS_LOG_TYPE_ERROR, "%{public}s %{public}s tcp get heuristics failed, backtrace limit exceeded", buf, 0x16u);
      }
    }
    if (v8)
LABEL_18:
      free(v8);
  }
}

_QWORD *tcp_mtudisc(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  char v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  void (*v11)(uint64_t);
  uint64_t v12;
  uint64_t v13;
  int v14;
  NSObject *v15;
  void *v16;
  uint64_t v17;

  v1 = result[28];
  if (*(__int16 *)(v1 + 376) < 0)
    return result;
  v2 = result[30];
  if (!v2 || !*(_DWORD *)(v2 + 12))
    return result;
  v3 = *(_BYTE *)(*(_QWORD *)(v2 + 80) + 2236);
  if ((v3 & 2) != 0)
    v4 = -60;
  else
    v4 = -40;
  if ((*(_BYTE *)(*(_QWORD *)(v2 + 80) + 2236) & 2) != 0)
  {
    result = (_QWORD *)tcp_rtlookup6((uint64_t)result, 0);
    if (!result)
      goto LABEL_38;
  }
  else
  {
    result = (_QWORD *)tcp_rtlookup((uint64_t)result, 0);
    if (!result)
      goto LABEL_38;
  }
  v5 = result[186];
  if (!v5 || (v6 = *(_DWORD *)(v5 + 48)) == 0)
  {
LABEL_38:
    v13 = 152;
    if ((v3 & 2) == 0)
      v13 = 148;
    v14 = *(_DWORD *)(sysctls + v13);
    *(_DWORD *)(v2 + 196) = v14;
    *(_DWORD *)(v2 + 156) = v14;
    return result;
  }
  v7 = *(_DWORD *)(v5 + 52);
  if (v6 >= *(_DWORD *)(result[27] + 1044))
    v6 = *(_DWORD *)(result[27] + 1044);
  v8 = v6 + v4;
  if (v8 >= v7)
    v9 = v7;
  else
    v9 = v8;
  if (v7)
    v10 = v9;
  else
    v10 = v8;
  if (*(_DWORD *)(v2 + 156) > v10)
  {
    *(_DWORD *)(v2 + 156) = v10;
    if ((*(_DWORD *)(v2 + 88) & 0x188) == 0x180)
      v10 -= 12;
    if (*(_DWORD *)(v1 + 388) < v10)
      v10 = *(_DWORD *)(v1 + 388);
    *(_DWORD *)(v2 + 196) = v10;
    if (!v10)
    {
      v17 = v1;
      v15 = __nwlog_obj();
      os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
      v16 = (void *)_os_log_send_and_compose_impl();
      result = (_QWORD *)__nwlog_abort();
      if ((_DWORD)result)
      {
        __break(1u);
        return result;
      }
      free(v16);
      v1 = v17;
    }
    v11 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v2 + 264)] + 40);
    if (v11)
      v11(v2);
    if (*(_DWORD *)(sysctls + 308) == 1
      && (~*(_DWORD *)(v2 + 88) & 0x180) == 0
      && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v1 + 369) & 0x40) != 0)
      && off_253CF8698)
    {
      off_253CF8698((_DWORD *)v2);
    }
    v12 = *(_QWORD *)(v2 + 1056);
    if (v12)
      ++*(_QWORD *)(v12 + 40);
    *(_DWORD *)(v2 + 172) = 0;
    *(_DWORD *)(v2 + 100) = *(_DWORD *)(v2 + 92);
    return (_QWORD *)tcp_output(v2);
  }
  return result;
}

void tcp_mss(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  char v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  int *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _DWORD *v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v27;
  unint64_t v28;
  unsigned int *v29;
  _DWORD *v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t all_stats;
  unsigned int v37;
  uint64_t v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  void (*v52)(uint64_t);
  NSObject *v53;
  void *v54;

  v3 = *(_QWORD *)(a1 + 80);
  if (*(__int16 *)(*(_QWORD *)(v3 + 224) + 376) < 0 || !*(_DWORD *)(a1 + 12))
    return;
  v6 = *(_BYTE *)(v3 + 2236);
  if ((v6 & 2) != 0)
    v7 = -60;
  else
    v7 = -40;
  v8 = *(_QWORD *)(a1 + 80);
  if ((*(_BYTE *)(v3 + 2236) & 2) != 0)
  {
    v9 = tcp_rtlookup6(v8, a3);
    if (v9)
      goto LABEL_8;
  }
  else
  {
    v9 = tcp_rtlookup(v8, a3);
    if (v9)
    {
LABEL_8:
      v10 = *(_DWORD *)(a1 + 88);
      v11 = *(_QWORD *)(v9 + 216);
      if (*(_BYTE *)(v11 + 1076) == 23
        && *(int *)(sysctls + 48) >= 1
        && (*(_DWORD *)(v11 + 1040) - 9601) >> 7 <= 0x39C)
      {
        *(_DWORD *)(a1 + 88) = v10 | 0x80000;
      }
      v12 = a2;
      if (a2 == -1)
      {
        v16 = *(_QWORD *)(v9 + 1488);
        if (v16)
        {
          v12 = *(_DWORD *)(v16 + 52);
          v13 = (int *)sysctls;
          if (!v12)
          {
LABEL_21:
            v17 = 38;
            if ((v6 & 2) == 0)
              v17 = 37;
            v18 = v13[v17];
            goto LABEL_30;
          }
        }
        else
        {
          v13 = (int *)sysctls;
          v12 = -1;
        }
      }
      else
      {
        v13 = (int *)sysctls;
        if (!a2)
          goto LABEL_21;
      }
      if (v12 <= v13[41])
        v12 = v13[41];
      if (v12 <= 64)
        v18 = 64;
      else
        v18 = v12;
LABEL_30:
      v19 = *(_QWORD *)(v3 + 224);
      v20 = *(_DWORD **)(v9 + 1488);
      if (v20 && (v20[13] = v18, !*(_DWORD *)(a1 + 200)) && v20[16])
      {
        tcp_getrt_rtt(a1, (uint64_t)v20);
        v20 = *(_DWORD **)(v9 + 1488);
        if (!v20)
        {
LABEL_42:
          v23 = *(_DWORD *)(*(_QWORD *)(v9 + 216) + 1044);
          goto LABEL_43;
        }
      }
      else
      {
        if ((v10 & 0x20000) != 0)
          v21 = v13[43];
        else
          v21 = 30;
        *(_DWORD *)(a1 + 228) = v21;
        if (!v20)
          goto LABEL_42;
      }
      v22 = v20[12];
      v23 = *(_DWORD *)(*(_QWORD *)(v9 + 216) + 1044);
      if (v22)
      {
        if (v22 < v23)
          v23 = v20[12];
        LODWORD(v24) = v23 + v7;
        goto LABEL_50;
      }
LABEL_43:
      v24 = v23 + v7;
      if ((v6 & 2) == 0 || (v10 & 0x20000) != 0)
      {
        if ((v10 & 0x20000) != 0)
          goto LABEL_50;
        v25 = v13[37];
      }
      else
      {
        v25 = v13[38];
      }
      if (v24 >= v25)
        LODWORD(v24) = v25;
LABEL_50:
      if (v24 >= (uint64_t)v18)
        LODWORD(v24) = v18;
      *(_DWORD *)(a1 + 156) = v24;
      if ((*(_DWORD *)(a1 + 88) & 0x100) != 0 || a2 == -1)
        v27 = v24 - 12;
      else
        v27 = v24;
      if ((*(_DWORD *)(a1 + 88) & 0x88) == 0x80)
        v28 = v27;
      else
        v28 = v24;
      *(_DWORD *)(a1 + 196) = v28;
      v29 = v20 + 14;
      v30 = (_DWORD *)(v19 + 388);
      if (!v20)
        v29 = (unsigned int *)(v19 + 388);
      v31 = *v29;
      if (v31 <= *(_DWORD *)(v19 + 388))
        v32 = *(_DWORD *)(v19 + 388);
      else
        v32 = v31;
      v33 = v32;
      if (v32 >= v28)
      {
        v33 = (v28 + v32 - 1) / v28 * v28;
        if (v33 <= 0x71C71C)
        {
          *(_DWORD *)(v19 + 388) = v33;
          v34 = *(_QWORD *)(*(_QWORD *)(v19 + 456) + 24);
          if ((*(_BYTE *)(v19 + 432) & 4) != 0)
          {
            if (v34)
            {
              all_stats = nw_protocol_tcp_get_all_stats();
              if (all_stats)
                *(_DWORD *)(all_stats + 88) = *v30;
            }
          }
          else if (v34)
          {
            v35 = nw_protocol_tcp_get_all_stats();
            if (v35)
              *(_DWORD *)(v35 + 100) = *v30;
          }
          v37 = *(_DWORD *)(v19 + 388);
          if (*(_DWORD *)(v19 + 392) > v37)
            *(_DWORD *)(v19 + 392) = v37;
        }
        v32 = v28;
      }
      *(_DWORD *)(a1 + 196) = v32;
      if (!v32)
      {
        v53 = __nwlog_obj();
        os_log_type_enabled(v53, OS_LOG_TYPE_ERROR);
        v54 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_abort())
        {
          __break(1u);
          return;
        }
        free(v54);
        v32 = 0;
      }
      v38 = *(_QWORD *)(*(_QWORD *)v19 + 240);
      if (*(unsigned __int8 *)(v11 + 1076) != 255 && *(_DWORD *)(v11 + 1024) != 255
        || *(int *)(v38 + 12) > 5
        || (*(_BYTE *)(v38 + 91) & 0x20) != 0
        || (*(_BYTE *)(v11 + 9) & 0x80) == 0)
      {
        goto LABEL_98;
      }
      v39 = *(_DWORD *)(v38 + 156);
      v40 = *(_DWORD *)(v38 + 196) - v39;
      v41 = *(unsigned __int16 *)(v11 + 72);
      if (v41 == 1200)
      {
        if (v39 <= 0x4B0)
          goto LABEL_96;
        v42 = 1200;
      }
      else
      {
        if (v41 != 512)
        {
          if (*(_WORD *)(v11 + 72) || (v42 = *(unsigned __int16 *)(v38 + 734), !*(_WORD *)(v38 + 734)) || v39 >= v42)
          {
LABEL_96:
            *(_DWORD *)(v38 + 196) = v40 + v39;
            if (v39 == *(unsigned __int16 *)(v38 + 734))
              *(_WORD *)(v38 + 734) = 0;
LABEL_98:
            v43 = *(_DWORD *)(v19 + 492);
            if (v33 > v43)
              v43 = v33;
            if (v43 > v32)
            {
              v44 = (v32 + (unint64_t)v43 - 1) / v32 * v32;
              if (v44 <= 0x71C71C)
              {
                *(_DWORD *)(v19 + 492) = v44;
                v45 = *(_QWORD *)(*(_QWORD *)(v19 + 560) + 24);
                if ((*(_BYTE *)(v19 + 536) & 4) != 0)
                {
                  if (v45)
                  {
                    v47 = nw_protocol_tcp_get_all_stats();
                    if (v47)
                      *(_DWORD *)(v47 + 88) = *(_DWORD *)(v19 + 492);
                  }
                }
                else if (v45)
                {
                  v46 = nw_protocol_tcp_get_all_stats();
                  if (v46)
                    *(_DWORD *)(v46 + 100) = *(_DWORD *)(v19 + 492);
                }
                v48 = *(_DWORD *)(v19 + 492);
                if (*(_DWORD *)(v19 + 496) > v48)
                  *(_DWORD *)(v19 + 496) = v48;
              }
            }
            set_tcp_stream_priority(v19);
            v49 = *(_QWORD *)(v9 + 1488);
            if (v49 && (v50 = *(unsigned int *)(v49 + 60), (_DWORD)v50))
            {
              if (v50 < 2 * (unint64_t)v32)
                LODWORD(v50) = 2 * v32;
              *(_DWORD *)(a1 + 148) = v50;
              v51 = *(_QWORD *)(a1 + 1056);
              if (v51)
                ++*(_QWORD *)(v51 + 1296);
            }
            else
            {
              *(_DWORD *)(a1 + 148) = 1073725440;
            }
            v52 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 40);
            if (v52)
              v52(a1);
            if (*(_DWORD *)(sysctls + 308) == 1
              && (~*(_DWORD *)(a1 + 88) & 0x180) == 0
              && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v19 + 369) & 0x40) != 0))
            {
              if (off_253CF8698)
                off_253CF8698((_DWORD *)a1);
            }
            return;
          }
LABEL_95:
          *(_DWORD *)(v38 + 156) = v42;
          v39 = v42;
          goto LABEL_96;
        }
        if (v39 < 0x201)
          goto LABEL_96;
        v42 = 512;
      }
      *(_WORD *)(v38 + 734) = v39;
      goto LABEL_95;
    }
  }
  v14 = 152;
  if ((v6 & 2) == 0)
    v14 = 148;
  v15 = *(_DWORD *)(sysctls + v14);
  *(_DWORD *)(a1 + 196) = v15;
  *(_DWORD *)(a1 + 156) = v15;
}

uint64_t tcp_rtlookup(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  _DWORD *v13;
  int v14;
  unsigned int *v15;
  unsigned int v16;
  int v17;
  int v18;

  v4 = (uint64_t *)(a1 + 496);
  v5 = *(_QWORD *)(a1 + 496);
  if (v5)
  {
    if ((*(_DWORD *)(v5 + 1480) & 0x2000001) == 1)
    {
LABEL_11:
      v7 = *(_QWORD *)(a1 + 240);
      if (*(_DWORD *)(sysctls + 80)
        && ((v8 = *(_QWORD *)(v5 + 1488)) == 0 || (*(_BYTE *)(v5 + 1480) & 1) != 0 && !*(_BYTE *)(v8 + 73)))
      {
        v9 = *(_DWORD *)(v7 + 88) | 0x4000000;
      }
      else
      {
        v9 = *(_DWORD *)(v7 + 88) & 0xFBFFFFFF;
      }
      *(_DWORD *)(v7 + 88) = v9;
      v13 = *(_DWORD **)(v5 + 216);
      if (!v13)
      {
LABEL_36:
        if (*(_BYTE *)(v5 + 1484))
          *(_DWORD *)(v7 + 88) |= 0x20000u;
        return v5;
      }
      *(_DWORD *)(v7 + 88) = v9 & 0xEFFFFFFF;
      v14 = v13[262];
      if ((*(_BYTE *)(*(_QWORD *)(v7 + 80) + 2236) & 2) != 0)
      {
        if ((v14 & 0x400000) != 0)
        {
          *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
          v15 = v13 + 265;
          goto LABEL_26;
        }
      }
      else if ((v14 & 0x200000) != 0)
      {
        *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
        v15 = v13 + 264;
LABEL_26:
        v16 = *v15;
        if (v16 >= 0xFFFF)
          v17 = 0xFFFF;
        else
          v17 = v16;
        if (v16)
          v18 = v17;
        else
          v18 = 0xFFFF;
        *(_DWORD *)(v7 + 692) = v18;
      }
      tcp_set_ecn(v7);
      os_unfair_lock_lock((os_unfair_lock_t)(v7 + 1864));
      if (!*(_QWORD *)(a1 + 448))
        *(_QWORD *)(a1 + 448) = *(_QWORD *)(v5 + 216);
      os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 1864));
      goto LABEL_36;
    }
    if (*(_BYTE *)(v5 + 1496))
    {
      v6 = *(void **)(v5 + 1488);
      if (v6)
      {
        free(v6);
        v5 = *v4;
        *(_QWORD *)(*v4 + 1488) = 0;
      }
      *(_BYTE *)(v5 + 1496) = 0;
    }
  }
  *(_WORD *)(a1 + 2008) = 528;
  *(_DWORD *)(a1 + 2012) = *(_DWORD *)(a1 + 476);
  if ((*(_BYTE *)(a1 + 2229) & 0x40) != 0)
    a2 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 440) + 1072);
  bzero((void *)(a1 + 504), 0x5E0uLL);
  *(_OWORD *)(a1 + 704) = *(_OWORD *)(a1 + 2008);
  *(_QWORD *)(a1 + 720) = a1 + 728;
  *(_OWORD *)(a1 + 1768) = 0u;
  *(_DWORD *)(a1 + 1784) = 0;
  *(_WORD *)(a1 + 1800) = 1;
  *(_BYTE *)(a1 + 1804) = 6;
  *(_QWORD *)(a1 + 1960) = a1 + 1968;
  *(_BYTE *)(a1 + 1969) = 2;
  *(_DWORD *)(a1 + 1984) = 1;
  *(_QWORD *)(a1 + 496) = a1 + 504;
  if (((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t))(a1 + 2136))(v4, a1 + 504, a2) & 0x80000000) != 0)
  {
    *v4 = 0;
  }
  else
  {
    v5 = *v4;
    if (*v4)
      goto LABEL_11;
  }
  v10 = *(_QWORD *)(a1 + 240);
  v11 = *(_DWORD *)(v10 + 88);
  v5 = 0;
  if (*(_DWORD *)(sysctls + 80))
    v12 = v11 | 0x4000000;
  else
    v12 = v11 & 0xFBFFFFFF;
  *(_DWORD *)(v10 + 88) = v12;
  return v5;
}

uint64_t tcp_set_ecn(uint64_t a1)
{
  uint64_t result;
  int v3;
  unsigned int v4;
  BOOL v5;

  tcp_do_acc_ecn = network_config_get_tcp_accurate_ecn_enabled();
  tcp_do_l4s = network_config_get_tcp_l4s_enabled();
  result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 2136) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  v3 = *(_DWORD *)(a1 + 740);
  if ((result & 1) == 0)
  {
    if ((v3 & 0x10000000) != 0
      || (v3 & 0x8000000) == 0 && (*(_DWORD *)(sysctls + 320) != 1 ? (v5 = tcp_do_acc_ecn == 1) : (v5 = 1), !v5))
    {
      v4 = *(_DWORD *)(a1 + 348) & 0xFFFFEFFF;
      *(_DWORD *)(a1 + 348) = v4;
      goto LABEL_22;
    }
    v4 = *(_DWORD *)(a1 + 348) | 0x1000;
    *(_DWORD *)(a1 + 348) = v4;
    if ((v3 & 0x8000000) != 0)
      goto LABEL_18;
    goto LABEL_13;
  }
  v4 = *(_DWORD *)(a1 + 348) | 0x1000;
  *(_DWORD *)(a1 + 348) = v4;
  if ((v3 & 0x10000000) != 0)
    goto LABEL_22;
  if ((v3 & 0x8000000) == 0)
  {
LABEL_13:
    if (*(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1)
      goto LABEL_22;
  }
LABEL_18:
  if (*(_DWORD *)(a1 + 360) == 1)
    *(_DWORD *)(a1 + 360) = 2;
  if (*(_DWORD *)(a1 + 364) == 1)
    *(_DWORD *)(a1 + 364) = 2;
LABEL_22:
  if ((v4 & 0x1C00) == 0x1000
    && *(_DWORD *)(a1 + 112) % 0x64u >= *(_DWORD *)(sysctls + 88)
    && ((v3 & 0x10000000) != 0 || (v3 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1))
  {
    *(_DWORD *)(a1 + 348) = v4 & 0xFFFFEFFF;
  }
  return result;
}

uint64_t nw_proto_tcp_ecn_enabled(uint64_t a1)
{
  uint64_t v1;
  void *v3;
  NSObject *v4;
  uint8_t buf[4];
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 40);
    if (v1 && *(_QWORD *)(v1 + 5208) && *(_QWORD *)(v1 + 5216))
      return nw_path_flow_registration_ecn_enabled();
    else
      return 1;
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v6 = "nw_proto_tcp_ecn_enabled";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v6 = "nw_proto_tcp_ecn_enabled";
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_ERROR, "%{public}s called with null so, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v3)
      free(v3);
    return 0;
  }
}

uint64_t nw_proto_tcp_route_init(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  int v7;
  int mtu;
  int v9;
  int tso_max_segment_size_v4;
  uint64_t v11;
  int tso_max_segment_size_v6;
  uint64_t v13;
  NSObject *v14;
  const char *v15;
  uint64_t result;
  uint64_t v17;
  uint64_t heuristics;
  uint64_t v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  const char *v23;
  int v24;
  void *v25;
  _DWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int partial_checksum_offload;
  unsigned int v32;
  NSObject *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  char v38;
  NSObject *v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __int16 recommended_mss;
  uint64_t v46;
  NSObject *v47;
  uint64_t all_stats;
  NSObject *v49;
  int v50;
  int v51;
  void *v52;
  NSObject *v53;
  os_log_type_t v54;
  const char *v55;
  NSObject *v56;
  void *v57;
  NSObject *v58;
  const char *v59;
  int interface_index;
  int v61;
  int v62;
  uint8_t __n[13];
  __int16 v64;
  uint64_t v65;
  __int16 v66;
  _BYTE v67[10];
  __int16 v68;
  int v69;
  os_log_type_t __src[20];
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 1648);
  v3 = *(_BYTE **)(a1 + 1656);
  v4 = *(_QWORD *)v3;
  v5 = *(_QWORD *)(*(_QWORD *)v3 + 240);
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)&__n[1] = 136446210;
    *(_QWORD *)&__n[5] = "nw_proto_tcp_route_init";
    v52 = (void *)_os_log_send_and_compose_impl();
    __src[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_113;
    if (__src[0] == OS_LOG_TYPE_FAULT)
    {
      v53 = __nwlog_obj();
      v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0]))
        goto LABEL_113;
      *(_DWORD *)&__n[1] = 136446210;
      *(_QWORD *)&__n[5] = "nw_proto_tcp_route_init";
      v55 = "%{public}s called with null rt";
    }
    else
    {
      v53 = __nwlog_obj();
      v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0]))
        goto LABEL_113;
      *(_DWORD *)&__n[1] = 136446210;
      *(_QWORD *)&__n[5] = "nw_proto_tcp_route_init";
      v55 = "%{public}s called with null rt, backtrace limit exceeded";
    }
    goto LABEL_112;
  }
  if (!*(_QWORD *)(a2 + 216))
  {
    __nwlog_obj();
    *(_DWORD *)&__n[1] = 136446210;
    *(_QWORD *)&__n[5] = "nw_proto_tcp_route_init";
    v52 = (void *)_os_log_send_and_compose_impl();
    __src[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_113;
    if (__src[0] == OS_LOG_TYPE_FAULT)
    {
      v53 = __nwlog_obj();
      v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0]))
        goto LABEL_113;
      *(_DWORD *)&__n[1] = 136446210;
      *(_QWORD *)&__n[5] = "nw_proto_tcp_route_init";
      v55 = "%{public}s called with null rt->rt_ifp";
    }
    else
    {
      v53 = __nwlog_obj();
      v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0]))
        goto LABEL_113;
      *(_DWORD *)&__n[1] = 136446210;
      *(_QWORD *)&__n[5] = "nw_proto_tcp_route_init";
      v55 = "%{public}s called with null rt->rt_ifp, backtrace limit exceeded";
    }
LABEL_112:
    _os_log_impl(&dword_209FB3000, v53, v54, v55, &__n[1], 0xCu);
LABEL_113:
    if (v52)
      free(v52);
    return 0xFFFFFFFFLL;
  }
  v7 = *(_DWORD *)(v4 + 492);
  nw_protocol_upcast();
  if (!nw_protocol_get_input_handler())
  {
    if ((v3[828] & 2) != 0)
      return 0xFFFFFFFFLL;
    v14 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return 0xFFFFFFFFLL;
    *(_DWORD *)&__n[1] = 136446466;
    *(_QWORD *)&__n[5] = "nw_proto_tcp_route_init";
    v64 = 2082;
    v65 = (uint64_t)(v3 + 604);
    v15 = "%{public}s %{public}s no input handler";
    goto LABEL_22;
  }
  if (!*(_QWORD *)(v2 + 5208))
  {
    if ((v3[828] & 2) != 0)
      return 0xFFFFFFFFLL;
    v14 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return 0xFFFFFFFFLL;
    *(_DWORD *)&__n[1] = 136446466;
    *(_QWORD *)&__n[5] = "nw_proto_tcp_route_init";
    v64 = 2082;
    v65 = (uint64_t)(v3 + 604);
    v15 = "%{public}s %{public}s no path from input_handler received";
LABEL_22:
    _os_log_impl(&dword_209FB3000, v14, OS_LOG_TYPE_ERROR, v15, &__n[1], 0x16u);
    return 0xFFFFFFFFLL;
  }
  mtu = nw_path_get_mtu();
  if (!mtu)
  {
    if ((v3[828] & 2) == 0)
    {
      v14 = __nwlog_tcp_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)&__n[1] = 136446466;
        *(_QWORD *)&__n[5] = "nw_proto_tcp_route_init";
        v64 = 2082;
        v65 = (uint64_t)(v3 + 604);
        v15 = "%{public}s %{public}s no mtu received";
        goto LABEL_22;
      }
    }
    return 0xFFFFFFFFLL;
  }
  v9 = mtu;
  *(_DWORD *)(*(_QWORD *)(a2 + 216) + 1044) = mtu;
  tso_max_segment_size_v4 = nw_path_get_tso_max_segment_size_v4();
  v11 = *(_QWORD *)(a2 + 216);
  *(_DWORD *)(v11 + 1056) = tso_max_segment_size_v4;
  if (tso_max_segment_size_v4)
    *(_DWORD *)(v11 + 1048) |= 0x200000u;
  tso_max_segment_size_v6 = nw_path_get_tso_max_segment_size_v6();
  v13 = *(_QWORD *)(a2 + 216);
  *(_DWORD *)(v13 + 1060) = tso_max_segment_size_v6;
  if (tso_max_segment_size_v6)
    *(_DWORD *)(v13 + 1048) |= 0x400000u;
  *(_DWORD *)(*(_QWORD *)(a2 + 216) + 1048) |= nw_path_get_csum_flags();
  if ((*(_BYTE *)(v4 + 2236) & 2) != 0)
  {
    if (!nw_path_get_ipv6_network_signature())
      goto LABEL_25;
    goto LABEL_24;
  }
  if (nw_path_get_ipv4_network_signature())
  {
LABEL_24:
    memcpy((void *)(*(_QWORD *)(a2 + 216) + 1078), __src, 0x14uLL);
    *(_BYTE *)(*(_QWORD *)(a2 + 216) + 1077) = 20;
  }
LABEL_25:
  interface_index = nw_path_get_interface_index();
  *(_WORD *)(*(_QWORD *)(a2 + 216) + 1072) = interface_index;
  v17 = *(_QWORD *)(v4 + 240);
  heuristics = tcp_get_heuristics(*(_QWORD *)(v17 + 80), 1);
  if (!heuristics)
  {
    v62 = v9;
    v28 = *(_QWORD *)(*(_QWORD *)(v17 + 80) + 224);
    if (!v28 || (*(_BYTE *)(v28 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v58 = __nwlog_tcp_log();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
        {
          v59 = "";
          if (v28)
            v59 = (const char *)(v28 + 604);
          *(_DWORD *)&__n[1] = 136446466;
          *(_QWORD *)&__n[5] = "tcp_get_route_heuristics";
          v64 = 2082;
          v65 = (uint64_t)v59;
          _os_log_impl(&dword_209FB3000, v58, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s tcp get heuristics failed", &__n[1], 0x16u);
        }
      }
    }
    *(_QWORD *)(a2 + 1488) = 0;
    v26 = malloc_type_calloc(1uLL, 0x4CuLL, 0xEAFB8F1AuLL);
    if (!v26)
    {
      v56 = __nwlog_obj();
      os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
      *(_DWORD *)&__n[1] = 136446722;
      *(_QWORD *)&__n[5] = "strict_calloc";
      v64 = 2048;
      v65 = 1;
      v66 = 2048;
      *(_QWORD *)v67 = 76;
      v57 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort();
      if ((_DWORD)result)
        goto LABEL_123;
      free(v57);
      v26 = 0;
    }
    v27 = (_QWORD *)(a2 + 1488);
    *(_QWORD *)(a2 + 1488) = v26;
    *(_BYTE *)(a2 + 1496) = 1;
    v9 = v62;
    goto LABEL_39;
  }
  v19 = heuristics;
  v20 = *(_DWORD *)(heuristics + 148);
  *(_DWORD *)(heuristics + 148) = v20 + 1;
  if ((v20 & 0x80000000) == 0)
    goto LABEL_33;
  v21 = *(_QWORD *)(*(_QWORD *)(v17 + 80) + 224);
  if (v21)
  {
    if ((*(_BYTE *)(v21 + 828) & 2) != 0)
      goto LABEL_33;
  }
  v61 = v9;
  v22 = __nwlog_tcp_log();
  os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
  v23 = (const char *)(v21 + 604);
  v24 = *(_DWORD *)(v19 + 148);
  *(_DWORD *)&__n[1] = 136446722;
  *(_QWORD *)&__n[5] = "tcp_get_route_heuristics";
  if (!v21)
    v23 = "";
  v64 = 2082;
  v65 = (uint64_t)v23;
  v66 = 1024;
  *(_DWORD *)v67 = v24;
  v25 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if ((_DWORD)result)
  {
LABEL_123:
    __break(1u);
    return result;
  }
  free(v25);
  v9 = v61;
LABEL_33:
  v26 = (_DWORD *)(v19 + 68);
  v27 = (_QWORD *)(a2 + 1488);
  *(_QWORD *)(a2 + 1488) = v26;
LABEL_39:
  *(_DWORD *)(v5 + 1872) = 1;
  if (*(_DWORD *)(sysctls + 256))
  {
    if (v26[16])
    {
      *(_DWORD *)(v5 + 1872) = 2;
    }
    else
    {
      *(_DWORD *)&__n[1] = 0;
      nw_path_get_rtt_values();
      v26 = (_DWORD *)*v27;
    }
  }
  if (!v26[12])
    v26[12] = v9;
  *(_DWORD *)(a2 + 1328) = 528;
  *(_DWORD *)(a2 + 1332) = v7;
  *(_QWORD *)(a2 + 1336) = 0;
  v29 = *(_QWORD *)(a2 + 216);
  v30 = *(_DWORD *)(v29 + 1048);
  if (((v30 & 0x400020) == 0 && (*(_BYTE *)(v4 + 2236) & 2) != 0
     || (v30 & 0x200002) == 0 && (*(_BYTE *)(v4 + 2236) & 1) != 0)
    && (partial_checksum_offload = nw_path_flow_registration_get_partial_checksum_offload(),
        v29 = *(_QWORD *)(a2 + 216),
        v30 = *(_DWORD *)(v29 + 1048),
        partial_checksum_offload))
  {
    v32 = v30 | 0x1000;
  }
  else
  {
    v32 = v30 & 0xFFFFEFFF;
  }
  *(_DWORD *)(v29 + 1048) = v32;
  if ((nw_path_is_local() & 1) != 0 || nw_path_is_direct())
    *(_BYTE *)(a2 + 1484) = 1;
  v33 = nw_path_copy_direct_interface();
  if (v33)
  {
    v34 = v33;
    switch(nw_interface_get_type(v33))
    {
      case nw_interface_type_other:
        *(_BYTE *)(*(_QWORD *)(a2 + 216) + 1076) = 1;
        break;
      case nw_interface_type_wifi:
        v35 = *(_QWORD *)(a2 + 216);
        *(_BYTE *)(v35 + 1076) = 6;
        *(_QWORD *)(v35 + 1064) = 0x300000002;
        break;
      case nw_interface_type_cellular:
        v36 = *(_QWORD *)(a2 + 216);
        *(_BYTE *)(v36 + 1076) = -1;
        v37 = 15;
        goto LABEL_63;
      case nw_interface_type_wired:
        v36 = *(_QWORD *)(a2 + 216);
        v38 = 6;
        goto LABEL_62;
      case nw_interface_type_loopback:
        v36 = *(_QWORD *)(a2 + 216);
        v38 = 24;
LABEL_62:
        *(_BYTE *)(v36 + 1076) = v38;
        v37 = 2;
LABEL_63:
        *(_DWORD *)(v36 + 1064) = v37;
        break;
      default:
        break;
    }
    if (nw_interface_get_subtype() == 1002)
      *(_DWORD *)(*(_QWORD *)(a2 + 216) + 1052) |= 0x100000u;
    if (nw_interface_supports_tx_start())
      *(_DWORD *)(*(_QWORD *)(a2 + 216) + 1052) |= 0x80u;
    if ((nw_interface_supports_ack_priority() & 1) == 0)
      *(_DWORD *)(*(_QWORD *)(a2 + 216) + 1052) |= 0x200000u;
    if (nw_interface_supports_carrier_aggregation())
      *(_DWORD *)(*(_QWORD *)(a2 + 216) + 1052) |= 0x8000000u;
    nw_release(v34);
  }
  v39 = nw_path_copy_delegate_interface();
  if (v39)
  {
    v40 = v39;
    switch(nw_interface_get_type(v39))
    {
      case nw_interface_type_other:
        *(_DWORD *)(*(_QWORD *)(a2 + 216) + 1024) = 1;
        break;
      case nw_interface_type_wifi:
        v41 = *(_QWORD *)(a2 + 216);
        *(_DWORD *)(v41 + 1032) = 3;
        *(_QWORD *)(v41 + 1024) = 0x200000006;
        break;
      case nw_interface_type_cellular:
        v42 = *(_QWORD *)(a2 + 216);
        v43 = 0xF000000FFLL;
        goto LABEL_80;
      case nw_interface_type_wired:
        v42 = *(_QWORD *)(a2 + 216);
        v43 = 0x200000006;
        goto LABEL_80;
      case nw_interface_type_loopback:
        v42 = *(_QWORD *)(a2 + 216);
        v43 = 0x200000018;
LABEL_80:
        *(_QWORD *)(v42 + 1024) = v43;
        break;
      default:
        break;
    }
    nw_release(v40);
  }
  v44 = *(_QWORD *)(a2 + 216);
  if (v44 && (*(unsigned __int8 *)(v44 + 1076) == 255 || *(_DWORD *)(v44 + 1024) == 255))
  {
    recommended_mss = nw_path_get_recommended_mss();
    v46 = *(_QWORD *)(a2 + 216);
    *(_DWORD *)(v46 + 8) |= 0x8000u;
    *(_WORD *)(v46 + 72) = recommended_mss;
  }
  if (nw_path_should_probe_connectivity())
  {
    if ((v3[828] & 2) == 0)
    {
      v47 = __nwlog_tcp_log();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)&__n[1] = 136446466;
        *(_QWORD *)&__n[5] = "nw_proto_tcp_route_init";
        v64 = 2082;
        v65 = (uint64_t)(v3 + 604);
        _os_log_impl(&dword_209FB3000, v47, OS_LOG_TYPE_INFO, "%{public}s %{public}s probe connectivity enabled", &__n[1], 0x16u);
      }
    }
    *(_DWORD *)(v2 + 5308) |= 0x10u;
    *(_DWORD *)(*(_QWORD *)(a2 + 216) + 1052) |= 8u;
    if (*(_QWORD *)(*(_QWORD *)(v4 + 224) + 24))
    {
      all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats)
        *(_BYTE *)(all_stats + 96) |= 1u;
    }
  }
  if ((v3[828] & 2) != 0)
    return 0;
  result = __nwlog_is_datapath_logging_enabled();
  if ((_DWORD)result)
  {
    v49 = __nwlog_tcp_log();
    result = os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      v50 = *(_DWORD *)(*(_QWORD *)(a2 + 1488) + 48);
      v51 = *(_DWORD *)(*(_QWORD *)(a2 + 216) + 1048);
      *(_DWORD *)&__n[1] = 136447234;
      *(_QWORD *)&__n[5] = "nw_proto_tcp_route_init";
      v64 = 2082;
      v65 = (uint64_t)(v3 + 604);
      v66 = 1024;
      *(_DWORD *)v67 = v50;
      *(_WORD *)&v67[4] = 1024;
      *(_DWORD *)&v67[6] = interface_index;
      v68 = 1024;
      v69 = v51;
      _os_log_impl(&dword_209FB3000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s got mtu %d, ifindex %d, offloads %#x", &__n[1], 0x28u);
      return 0;
    }
  }
  return result;
}

uint64_t tcp_get_heuristics(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  int v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  _OWORD *v12;
  unsigned int v13;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  NSObject *v24;
  void *v25;
  _OWORD v26[4];
  int v27;
  const char *v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  result = nw_tcp_access_globals(*(_QWORD *)(a1 + 224));
  if (!result)
    return result;
  v5 = result;
  if (!*(_QWORD *)(result + 32))
    return 0;
  memset(v26, 0, 60);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 496) + 216);
  DWORD1(v26[3]) = *(unsigned __int16 *)(v6 + 1072);
  if ((*(_BYTE *)(a1 + 2236) & 2) != 0)
  {
    BYTE8(v26[3]) = 30;
    if (*(unsigned __int8 *)(v6 + 1077) - 1 <= 0x12)
      __memcpy_chk();
    v8 = *(_OWORD *)(a1 + 464);
    *(_OWORD *)((char *)&v26[1] + 4) = *(_OWORD *)(a1 + 480);
    *(_OWORD *)((char *)&v26[2] + 4) = v8;
  }
  else
  {
    BYTE8(v26[3]) = 2;
    if (*(unsigned __int8 *)(v6 + 1077) - 1 <= 0x12)
      __memcpy_chk();
    v7 = *(_DWORD *)(a1 + 476);
    DWORD1(v26[1]) = *(_DWORD *)(a1 + 492);
    DWORD1(v26[2]) = v7;
  }
  v9 = ((unsigned int (*)(_OWORD *, uint64_t, _QWORD))*MEMORY[0x24BDE0900])(v26, 60, *(unsigned int *)(v5 + 312))% 0x64;
  v10 = *(_QWORD *)(v5 + 32);
  result = *(_QWORD *)(v10 + 8 * v9);
  if (!result)
  {
    if (a2)
    {
LABEL_49:
      v12 = malloc_type_calloc(1uLL, 0x98uLL, 0xEAFB8F1AuLL);
      if (!v12)
      {
        v24 = __nwlog_obj();
        os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
        v27 = 136446722;
        v28 = "strict_calloc";
        v29 = 2048;
        v30 = 1;
        v31 = 2048;
        v32 = 152;
        v25 = (void *)_os_log_send_and_compose_impl();
        result = __nwlog_abort();
        if ((_DWORD)result)
        {
          __break(1u);
          return result;
        }
        free(v25);
        v12 = 0;
      }
      *(_QWORD *)v12 = *(_QWORD *)(v10 + 8 * v9);
      *(_QWORD *)(v10 + 8 * v9) = v12;
      goto LABEL_51;
    }
    return 0;
  }
  v11 = 0;
  v12 = 0;
  v13 = -1;
  do
  {
    if (*(_QWORD *)(result + 8) == *(_QWORD *)&v26[0]
      && *(_QWORD *)(result + 16) == *((_QWORD *)&v26[0] + 1)
      && *(_QWORD *)(result + 24) == *(_QWORD *)&v26[1]
      && *(_QWORD *)(result + 32) == *((_QWORD *)&v26[1] + 1)
      && *(_QWORD *)(result + 40) == *(_QWORD *)&v26[2]
      && *(_QWORD *)(result + 48) == *((_QWORD *)&v26[2] + 1)
      && *(_QWORD *)(result + 56) == *(_QWORD *)&v26[3]
      && *(_DWORD *)(result + 64) == (unint64_t)DWORD2(v26[3]))
    {
      if (!*(_DWORD *)(result + 148) && (*(_DWORD *)(v5 + 316) - *(_DWORD *)(result + 144)) >= 0xE10)
      {
        *(_OWORD *)(result + 128) = 0u;
        *(_OWORD *)(result + 116) = 0u;
        *(_OWORD *)(result + 100) = 0u;
        *(_OWORD *)(result + 84) = 0u;
        *(_OWORD *)(result + 68) = 0u;
      }
      goto LABEL_52;
    }
    if (!*(_DWORD *)(result + 148) && *(_DWORD *)(v5 + 316) - *(_DWORD *)(result + 144) > v11)
    {
      v12 = (_OWORD *)result;
      v11 = *(_DWORD *)(v5 + 316) - *(_DWORD *)(result + 144);
    }
    result = *(_QWORD *)result;
    ++v13;
  }
  while (result);
  if (!a2)
    return 0;
  if (v13 < 9)
    goto LABEL_49;
  if (!v12)
    return 0;
  v12[8] = 0u;
  *(_OWORD *)((char *)v12 + 116) = 0u;
  *(_OWORD *)((char *)v12 + 100) = 0u;
  *(_OWORD *)((char *)v12 + 84) = 0u;
  *(_OWORD *)((char *)v12 + 68) = 0u;
LABEL_51:
  v21 = v26[0];
  v22 = v26[1];
  v23 = v26[2];
  *(_OWORD *)((char *)v12 + 52) = *(_OWORD *)((char *)&v26[2] + 12);
  *(_OWORD *)((char *)v12 + 40) = v23;
  *(_OWORD *)((char *)v12 + 24) = v22;
  *(_OWORD *)((char *)v12 + 8) = v21;
  result = (uint64_t)v12;
LABEL_52:
  *(_DWORD *)(result + 144) = *(_DWORD *)(v5 + 316);
  return result;
}

void tcp_cubic_cwnd_init_or_reset(uint64_t a1)
{
  _DWORD *v2;
  _DWORD *v3;
  int v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  NSObject *v10;
  void *v11;

  v2 = *(_DWORD **)(a1 + 840);
  if (!v2)
  {
    v10 = __nwlog_obj();
    os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    v11 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v11);
    v2 = *(_DWORD **)(a1 + 840);
  }
  *v2 = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 4) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 8) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 12) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 16) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 28) = 0;
  if ((*(_BYTE *)(a1 + 90) & 2) != 0)
  {
    LODWORD(v5) = *(_DWORD *)(a1 + 196);
    v3 = (_DWORD *)sysctls;
    LODWORD(v6) = *(_DWORD *)(sysctls + 84) * v5;
  }
  else
  {
    v3 = (_DWORD *)sysctls;
    if (*(_DWORD *)(sysctls + 276))
    {
      if (*(_DWORD *)(sysctls + 304))
        v4 = *(_DWORD *)(sysctls + 16);
      else
        v4 = 10;
      LODWORD(v5) = *(_DWORD *)(a1 + 196);
      LODWORD(v6) = v5 * v4;
    }
    else
    {
      v5 = *(unsigned int *)(a1 + 196);
      LODWORD(v6) = 2 * v5;
      if (v5 <= 0x88E)
        v6 = 4380;
      else
        v6 = v6;
      if (v6 > 4 * v5)
        LODWORD(v6) = 4 * v5;
    }
  }
  *(_DWORD *)(a1 + 144) = v6;
  *(_QWORD *)(a1 + 980) = 0;
  *(_DWORD *)(a1 + 972) = 0;
  *(_QWORD *)(a1 + 964) = 0;
  *(_BYTE *)(a1 + 751) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  if (v3[76])
  {
    v7 = v3[4];
  }
  else
  {
    if (!v3[69])
    {
      v8 = 4380;
      goto LABEL_20;
    }
    v7 = 10;
  }
  v8 = (v5 * v7);
LABEL_20:
  v9 = *(_DWORD *)(a1 + 148);
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 248) + 24) <= v8 && v9 <= 0x3FFFBFFF)
  {
    v9 = 1073725440;
    *(_DWORD *)(a1 + 148) = 1073725440;
  }
  **(_DWORD **)(a1 + 840) = v9;
}

_DWORD *tcp_ledbat_cwnd_init(_DWORD *result)
{
  result[36] = *(_DWORD *)(sysctls + 16) * result[49];
  result[184] = result[37];
  return result;
}

_DWORD *tcp_rledbat_rwnd_init(_DWORD *result)
{
  result[487] = *(_DWORD *)(sysctls + 16) * result[49];
  if (!result[488])
    result[488] = 1073725440;
  return result;
}

uint64_t nw_protocol_tcp_get_output_frames(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t all_stats;
  uint64_t result;
  NSObject *v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  uint32_t v20;
  __int16 v21;
  int v22;
  void *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  NSObject *v27;
  unint64_t StatusReg;
  int v29;
  NSObject *v30;
  NSObject *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  void *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  void *backtrace_string;
  _BOOL4 v42;
  int v43;
  int v44;
  int v45;
  int v46;
  unsigned int v47;
  int v48;
  BOOL v49;
  unsigned int v50;
  int *v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  int v58;
  NSObject *v59;
  os_log_type_t v60;
  uint32_t v61;
  void *v62;
  NSObject *v63;
  os_log_type_t v64;
  const char *v65;
  unsigned int v66;
  void *v67;
  NSObject *v68;
  os_log_type_t v69;
  const char *v70;
  NSObject *v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  void *v77;
  NSObject *v78;
  _BOOL4 v79;
  NSObject *v80;
  os_log_type_t v81;
  NSObject *v82;
  os_log_type_t v83;
  uint32_t v84;
  NSObject *v85;
  NSObject *v86;
  os_log_type_t v87;
  NSObject *v88;
  void *v89;
  _BOOL4 v90;
  NSObject *log;
  os_log_type_t v92[4];
  char v93;
  os_log_type_t type;
  _BYTE buf[34];
  __int16 v96;
  int v97;
  __int16 v98;
  unsigned int v99;
  __int16 v100;
  uint64_t v101;
  uint64_t v102;

  v102 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
    v37 = (void *)_os_log_send_and_compose_impl();
    v92[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault())
      goto LABEL_100;
    if (v92[0] == OS_LOG_TYPE_FAULT)
    {
      v80 = __nwlog_obj();
      v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0]))
        goto LABEL_100;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
      v40 = "%{public}s called with null protocol";
    }
    else
    {
      v80 = __nwlog_obj();
      v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0]))
        goto LABEL_100;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
      v40 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_178;
  }
  v11 = nw_protocol_downcast();
  if (!v11)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
    v37 = (void *)_os_log_send_and_compose_impl();
    v92[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault())
      goto LABEL_100;
    if (v92[0] == OS_LOG_TYPE_FAULT)
    {
      v80 = __nwlog_obj();
      v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0]))
        goto LABEL_100;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
      v40 = "%{public}s called with null tcp";
    }
    else
    {
      v80 = __nwlog_obj();
      v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0]))
        goto LABEL_100;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
      v40 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
LABEL_178:
    v59 = v80;
    v60 = v81;
    v61 = 12;
    goto LABEL_99;
  }
  v12 = v11;
  if (*(_DWORD *)(v11 + 5224) == 2)
  {
    if (a5)
    {
      v13 = *(_DWORD *)(v11 + 5308);
      if ((v13 & 0xC00) == 0x400)
      {
        all_stats = nw_protocol_tcp_get_all_stats();
        if (all_stats)
          *(_DWORD *)(all_stats + 124) |= 0x400u;
        v13 = *(_DWORD *)(v12 + 5308) | 0x800;
        *(_DWORD *)(v12 + 5308) = v13;
      }
LABEL_15:
      *(_DWORD *)v92 = 0;
      if ((*(_BYTE *)(v12 + 364) & 8) != 0)
      {
        if ((*(_BYTE *)(v12 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
        {
          v85 = __nwlog_tcp_log();
          v22 = 32;
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "sosendcheck";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v12 + 604;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 32;
            _os_log_impl(&dword_209FB3000, v85, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s defunct flow error (%d)", buf, 0x1Cu);
          }
          goto LABEL_28;
        }
      }
      else
      {
        v21 = *(_WORD *)(v12 + 376);
        if ((v21 & 0x10) == 0)
        {
          v22 = *(unsigned __int16 *)(v12 + 378);
          if (*(_WORD *)(v12 + 378))
          {
            *(_WORD *)(v12 + 378) = 0;
            __nwlog_obj();
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "sosendcheck";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v12 + 604;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = v22;
            v23 = (void *)_os_log_send_and_compose_impl();
            type = OS_LOG_TYPE_ERROR;
            v93 = 0;
            if (!__nwlog_fault())
              goto LABEL_115;
            if (type == OS_LOG_TYPE_FAULT)
            {
              v24 = __nwlog_obj();
              v25 = type;
              if (!os_log_type_enabled(v24, type))
                goto LABEL_115;
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "sosendcheck";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v12 + 604;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = v22;
              v26 = "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d";
            }
            else
            {
              v24 = __nwlog_obj();
              v25 = type;
              if (!os_log_type_enabled(v24, type))
                goto LABEL_115;
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "sosendcheck";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v12 + 604;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = v22;
              v26 = "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d, backtrace limit exceeded";
            }
            _os_log_impl(&dword_209FB3000, v24, v25, v26, buf, 0x1Cu);
LABEL_115:
            if (v23)
              free(v23);
            goto LABEL_28;
          }
          if ((v21 & 2) == 0 && a4 && (*(_WORD *)(v12 + 376) & 0x400) == 0 && (*(_BYTE *)(v12 + 368) & 0x20) == 0)
          {
            v22 = 57;
            goto LABEL_28;
          }
          v43 = *(_DWORD *)(v12 + 384);
          v44 = *(_DWORD *)(v12 + 388) - v43;
          v45 = *(_DWORD *)(v12 + 484);
          v46 = v45 - v43;
          if (v46 >= v44)
            v46 = v44;
          if (!v45)
            v46 = v44;
          v47 = v46 & ~(v46 >> 31);
          if (v47 >= a4 || v47 >= *(_DWORD *)(v12 + 392))
          {
            v48 = **(_DWORD **)(*(_QWORD *)(v12 + 8) + 8);
            v49 = v48 == 30 || v48 == 2;
            if (!v49 || (v21 & 2) == 0 || (*(_BYTE *)(*(_QWORD *)v12 + 2231) & 0x50) == 0)
            {
LABEL_72:
              if (v47 >= a4)
                v50 = a4;
              else
                v50 = v46 & ~(v46 >> 31);
              if (a3 > v50 && v50 < *(_DWORD *)(v12 + 392))
              {
                StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                v51 = *(int **)(StatusReg + 8);
                v52 = 35;
LABEL_113:
                *v51 = v52;
LABEL_29:
                v29 = **(_DWORD **)(StatusReg + 8);
                if (v29 != 35)
                {
                  if (v29 == 32)
                  {
                    v30 = __nwlog_obj();
                    result = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
                    if (!(_DWORD)result)
                      return result;
                    *(_DWORD *)buf = 136446466;
                    *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = 32;
                    v17 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d";
                    v18 = v30;
                    v19 = OS_LOG_TYPE_ERROR;
                    v20 = 18;
                    goto LABEL_33;
                  }
                  __nwlog_obj();
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v29;
                  v37 = (void *)_os_log_send_and_compose_impl();
                  type = OS_LOG_TYPE_ERROR;
                  v93 = 0;
                  if (__nwlog_fault())
                  {
                    if (type == OS_LOG_TYPE_FAULT)
                    {
                      v38 = __nwlog_obj();
                      v39 = type;
                      if (!os_log_type_enabled(v38, type))
                        goto LABEL_100;
                      *(_DWORD *)buf = 136446466;
                      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v29;
                      v40 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d";
                      goto LABEL_98;
                    }
                    if (!v93)
                    {
                      v38 = __nwlog_obj();
                      v39 = type;
                      if (!os_log_type_enabled(v38, type))
                        goto LABEL_100;
                      *(_DWORD *)buf = 136446466;
                      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v29;
                      v40 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_98;
                    }
                    backtrace_string = (void *)__nw_create_backtrace_string();
                    v38 = __nwlog_obj();
                    v39 = type;
                    v42 = os_log_type_enabled(v38, type);
                    if (backtrace_string)
                    {
                      if (v42)
                      {
                        *(_DWORD *)buf = 136446722;
                        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v29;
                        *(_WORD *)&buf[18] = 2082;
                        *(_QWORD *)&buf[20] = backtrace_string;
                        _os_log_impl(&dword_209FB3000, v38, v39, "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                      }
                      free(backtrace_string);
                      goto LABEL_100;
                    }
                    if (v42)
                    {
                      *(_DWORD *)buf = 136446466;
                      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v29;
                      v40 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d, no backtrace";
LABEL_98:
                      v59 = v38;
                      v60 = v39;
                      v61 = 18;
LABEL_99:
                      _os_log_impl(&dword_209FB3000, v59, v60, v40, buf, v61);
                    }
                  }
LABEL_100:
                  if (v37)
                    free(v37);
                  return 0;
                }
                if ((*(_BYTE *)(v12 + 828) & 2) != 0)
                  return 0;
                result = __nwlog_is_datapath_logging_enabled();
                if ((_DWORD)result)
                {
                  v31 = __nwlog_tcp_log();
                  result = os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG);
                  if ((_DWORD)result)
                  {
                    v32 = *(_DWORD *)(v12 + 392);
                    v33 = *(_DWORD *)(v12 + 384);
                    v34 = *(_DWORD *)(v12 + 388) - v33;
                    v35 = *(_DWORD *)(v12 + 484);
                    v36 = v35 - v33;
                    if (v36 >= v34)
                      v36 = v34;
                    if (v35)
                      v34 = v36;
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v12 + 604;
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = v32;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v34 & ~(v34 >> 31);
                    v17 = "%{public}s %{public}s tcp_get_southbound_frame failed, socket is full minimum %u sbspace %u";
                    v18 = v31;
                    v19 = OS_LOG_TYPE_DEBUG;
                    v20 = 34;
                    goto LABEL_33;
                  }
                }
                return result;
              }
              *(_QWORD *)buf = 0;
              *(_QWORD *)&buf[8] = buf;
              if (!nw_protocol_tcp_get_frames(v12, v50, (uint64_t)buf, a5, (int *)v92, (v13 & 0x1000) != 0))
              {
                StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                v51 = *(int **)(StatusReg + 8);
                v52 = 55;
                goto LABEL_113;
              }
              if (*(_QWORD *)buf)
              {
                **(_QWORD **)(a6 + 8) = *(_QWORD *)buf;
                v53 = *(_QWORD *)&buf[8];
                *(_QWORD *)(*(_QWORD *)buf + 40) = *(_QWORD *)(a6 + 8);
                *(_QWORD *)(a6 + 8) = v53;
              }
              v54 = nw_protocol_downcast();
              if (!v54)
              {
                __nwlog_obj();
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                v67 = (void *)_os_log_send_and_compose_impl();
                type = OS_LOG_TYPE_ERROR;
                v93 = 0;
                if (!__nwlog_fault())
                  goto LABEL_163;
                if (type == OS_LOG_TYPE_FAULT)
                {
                  v86 = __nwlog_obj();
                  v87 = type;
                  if (!os_log_type_enabled(v86, type))
                    goto LABEL_163;
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  v70 = "%{public}s called with null tcp";
                }
                else if (v93)
                {
                  v89 = (void *)__nw_create_backtrace_string();
                  v86 = __nwlog_obj();
                  v87 = type;
                  v90 = os_log_type_enabled(v86, type);
                  if (v89)
                  {
                    if (v90)
                    {
                      *(_DWORD *)buf = 136446466;
                      *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v89;
                      _os_log_impl(&dword_209FB3000, v86, v87, "%{public}s called with null tcp, dumping backtrace:%{public}s", buf, 0x16u);
                    }
                    free(v89);
                    goto LABEL_163;
                  }
                  if (!v90)
                    goto LABEL_163;
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  v70 = "%{public}s called with null tcp, no backtrace";
                }
                else
                {
                  v86 = __nwlog_obj();
                  v87 = type;
                  if (!os_log_type_enabled(v86, type))
                    goto LABEL_163;
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  v70 = "%{public}s called with null tcp, backtrace limit exceeded";
                }
                v82 = v86;
                v83 = v87;
                v84 = 12;
                goto LABEL_162;
              }
              v55 = v54;
              if (a3 - v50 <= 1)
                v56 = 1;
              else
                v56 = a3 - v50;
              if (a3 <= v50)
                v57 = 2048;
              else
                v57 = v56;
              if (*(_DWORD *)(v54 + 392) == v57)
                goto LABEL_165;
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v54 + 8) + 16))(v54, 1, v6);
              if ((~*(unsigned __int16 *)(v55 + 376) & 0x30) != 0)
              {
                if (v57 < 1)
                {
                  v58 = 1;
                  goto LABEL_127;
                }
              }
              else
              {
                v58 = 1;
                if ((*(_BYTE *)(v55 + 365) & 0x20) == 0 || v57 < 1)
                  goto LABEL_127;
              }
              v58 = 0;
              v66 = *(_DWORD *)(v55 + 388) / 3u;
              if (v57 <= *(_DWORD *)(v55 + 388) / 3)
                v66 = v57;
              if (v66 <= 1)
                v66 = 1;
              *(_DWORD *)(v55 + 392) = v66;
LABEL_127:
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v55 + 8) + 24))(v55, 1, v6);
              if (!v58)
              {
                if ((*(_BYTE *)(v55 + 828) & 2) == 0)
                {
                  if (__nwlog_is_datapath_logging_enabled())
                  {
                    v71 = __nwlog_tcp_log();
                    if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
                    {
                      v72 = *(_DWORD *)(v55 + 392);
                      v73 = *(_DWORD *)(v55 + 384);
                      v74 = *(_DWORD *)(v55 + 388) - v73;
                      v75 = *(_DWORD *)(v55 + 484);
                      v76 = v75 - v73;
                      if (v76 >= v74)
                        v76 = v74;
                      if (v75)
                        v74 = v76;
                      *(_DWORD *)buf = 136446978;
                      *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v55 + 604;
                      *(_WORD *)&buf[22] = 1024;
                      *(_DWORD *)&buf[24] = v72;
                      *(_WORD *)&buf[28] = 1024;
                      *(_DWORD *)&buf[30] = v74 & ~(v74 >> 31);
                      _os_log_impl(&dword_209FB3000, v71, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s so_snd.sb_lowat %u sbspace %u", buf, 0x22u);
                    }
                  }
                }
                goto LABEL_165;
              }
              __nwlog_obj();
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v57;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v58;
              v67 = (void *)_os_log_send_and_compose_impl();
              type = OS_LOG_TYPE_ERROR;
              v93 = 0;
              if (__nwlog_fault())
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  v68 = __nwlog_obj();
                  v69 = type;
                  if (!os_log_type_enabled(v68, type))
                    goto LABEL_163;
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v57;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v58;
                  v70 = "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d";
LABEL_160:
                  v82 = v68;
LABEL_161:
                  v83 = v69;
                  v84 = 24;
LABEL_162:
                  _os_log_impl(&dword_209FB3000, v82, v83, v70, buf, v84);
                  goto LABEL_163;
                }
                if (!v93)
                {
                  v68 = __nwlog_obj();
                  v69 = type;
                  if (!os_log_type_enabled(v68, type))
                    goto LABEL_163;
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v57;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v58;
                  v70 = "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d, backtrace limit exceeded";
                  goto LABEL_160;
                }
                v77 = (void *)__nw_create_backtrace_string();
                v78 = __nwlog_obj();
                v69 = type;
                log = v78;
                v79 = os_log_type_enabled(v78, type);
                if (v77)
                {
                  if (v79)
                  {
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v57;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = v58;
                    *(_WORD *)&buf[24] = 2082;
                    *(_QWORD *)&buf[26] = v77;
                    _os_log_impl(&dword_209FB3000, log, v69, "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
                  }
                  free(v77);
                  if (!v67)
                    goto LABEL_165;
LABEL_164:
                  free(v67);
LABEL_165:
                  if ((*(_BYTE *)(v12 + 828) & 2) == 0)
                  {
                    if (__nwlog_is_datapath_logging_enabled())
                    {
                      v88 = __nwlog_tcp_log();
                      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 136447746;
                        *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v12 + 604;
                        *(_WORD *)&buf[22] = 1024;
                        *(_DWORD *)&buf[24] = a3;
                        *(_WORD *)&buf[28] = 1024;
                        *(_DWORD *)&buf[30] = a4;
                        v96 = 1024;
                        v97 = a5;
                        v98 = 1024;
                        v99 = v50;
                        v100 = 2048;
                        v101 = v12;
                        _os_log_impl(&dword_209FB3000, v88, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s asked for min %u max %u bytes, max %u frames and got 1 frame of %u bytes on %p", buf, 0x38u);
                      }
                    }
                  }
                  return *(unsigned int *)v92;
                }
                if (v79)
                {
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v57;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v58;
                  v70 = "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d, no backtrace";
                  v82 = log;
                  goto LABEL_161;
                }
              }
LABEL_163:
              if (!v67)
                goto LABEL_165;
              goto LABEL_164;
            }
          }
          if ((*(_BYTE *)(v12 + 368) & 0x20) != 0)
          {
            if (v46 < 1)
              goto LABEL_149;
            if (v47 < *(_DWORD *)(v12 + 392))
              goto LABEL_72;
          }
          if ((*(_WORD *)(v12 + 376) & 0x100) == 0 && (*(_BYTE *)(v12 + 828) & 2) == 0)
          {
            __nwlog_tcp_log();
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "sosendcheck";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v12 + 604;
            v62 = (void *)_os_log_send_and_compose_impl();
            type = OS_LOG_TYPE_ERROR;
            v93 = 0;
            if (!__nwlog_fault())
              goto LABEL_147;
            if (type == OS_LOG_TYPE_FAULT)
            {
              v63 = __nwlog_tcp_log();
              v64 = type;
              if (!os_log_type_enabled(v63, type))
                goto LABEL_147;
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "sosendcheck";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v12 + 604;
              v65 = "%{public}s %{public}s NBIO not set";
            }
            else
            {
              v63 = __nwlog_tcp_log();
              v64 = type;
              if (!os_log_type_enabled(v63, type))
                goto LABEL_147;
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "sosendcheck";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v12 + 604;
              v65 = "%{public}s %{public}s NBIO not set, backtrace limit exceeded";
            }
            _os_log_impl(&dword_209FB3000, v63, v64, v65, buf, 0x16u);
LABEL_147:
            if (v62)
              free(v62);
          }
LABEL_149:
          v22 = 35;
          goto LABEL_28;
        }
      }
      v22 = 32;
LABEL_28:
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(StatusReg + 8) = v22;
      goto LABEL_29;
    }
    goto LABEL_22;
  }
  v13 = *(_DWORD *)(v11 + 5308);
  if ((v13 & 0x20) != 0)
  {
    if (a5)
      goto LABEL_15;
LABEL_22:
    if ((*(_BYTE *)(v11 + 828) & 2) == 0)
    {
      v27 = __nwlog_tcp_log();
      result = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v12 + 604;
      v17 = "%{public}s %{public}s cannot specify 0 as maximum_frame_count on a streaming socket";
      v18 = v27;
      v19 = OS_LOG_TYPE_ERROR;
      v20 = 22;
      goto LABEL_33;
    }
    return 0;
  }
  if ((*(_BYTE *)(v11 + 828) & 2) != 0)
    return 0;
  result = __nwlog_is_datapath_logging_enabled();
  if ((_DWORD)result)
  {
    v16 = __nwlog_tcp_log();
    result = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_get_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v12 + 604;
      v17 = "%{public}s %{public}s skipping";
      v18 = v16;
      v19 = OS_LOG_TYPE_DEBUG;
      v20 = 22;
LABEL_33:
      _os_log_impl(&dword_209FB3000, v18, v19, v17, buf, v20);
      return 0;
    }
  }
  return result;
}

BOOL nw_protocol_tcp_add_input_handler(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v5;
  void *v6;
  NSObject *v7;
  const char *v8;
  uint8_t buf[4];
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v10 = "nw_protocol_tcp_add_input_handler";
    v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v10 = "nw_protocol_tcp_add_input_handler";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_19:
        _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_ERROR, v8, buf, 0xCu);
      }
    }
LABEL_20:
    if (v6)
      free(v6);
    return 0;
  }
  v2 = nw_protocol_downcast();
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v10 = "nw_protocol_tcp_add_input_handler";
    v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v10 = "nw_protocol_tcp_add_input_handler";
        v8 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
    goto LABEL_20;
  }
  v3 = v2;
  if (*(_DWORD *)(v2 + 5224))
    return 0;
  nw_protocol_set_input_handler();
  nw_protocol_set_flow_id_from_protocol();
  if (!nw_protocol_get_output_handler())
    nw_protocol_set_output_handler();
  if (nw_protocol_supports_external_data())
    v5 = 4096;
  else
    v5 = 0;
  *(_DWORD *)(v3 + 5308) = *(_DWORD *)(v3 + 5308) & 0xFFFFEFFF | v5;
  return nw_protocol_tcp_initialize(a1);
}

uint64_t nw_protocol_tcp_set_no_wake_from_sleep(os_unfair_lock_s *a1)
{
  os_unfair_lock_s *v1;
  uint64_t v2;
  void *v4;
  NSObject *v5;
  uint8_t buf[24];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = a1 + 1316;
    os_unfair_lock_lock(a1 + 1316);
    *(_OWORD *)buf = 0uLL;
    v2 = 0;
    if (nw_path_flow_registration_get_nexus_instance())
    {
      nw_protocol_upcast();
      nw_protocol_get_flow_id();
      v2 = os_nexus_flow_set_wake_from_sleep();
    }
    os_unfair_lock_unlock(v1);
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_wake_from_sleep";
    v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_wake_from_sleep";
        _os_log_impl(&dword_209FB3000, v5, OS_LOG_TYPE_ERROR, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v4)
      free(v4);
    return 22;
  }
  return v2;
}

uint64_t nw_protocol_tcp_connect(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v4;
  NSObject *v5;
  NSObject *v6;
  const char *v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v9 = "nw_protocol_tcp_connect";
    v4 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_24;
    v6 = __nwlog_obj();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      goto LABEL_24;
    *(_DWORD *)buf = 136446210;
    v9 = "nw_protocol_tcp_connect";
    v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_23;
  }
  v1 = nw_protocol_downcast();
  if (v1)
  {
    v2 = v1;
    if ((*(_BYTE *)(v1 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v5 = __nwlog_tcp_log();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v9 = "nw_protocol_tcp_connect";
          v10 = 2082;
          v11 = v2 + 604;
          _os_log_impl(&dword_209FB3000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s got connect event", buf, 0x16u);
        }
      }
    }
    if (*MEMORY[0x24BDE08B8] != -1)
      dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_16);
    if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
      kdebug_trace();
    if (*(_DWORD *)(v2 + 5224) == 2)
    {
      nw_protocol_get_input_handler();
      nw_protocol_connected_quiet();
      return 1;
    }
    else
    {
      nw_protocol_get_output_handler();
      return nw_protocol_connect_quiet();
    }
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v9 = "nw_protocol_tcp_connect";
  v4 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v6 = __nwlog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v9 = "nw_protocol_tcp_connect";
      v7 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_23:
      _os_log_impl(&dword_209FB3000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
    }
  }
LABEL_24:
  if (v4)
    free(v4);
  return 0;
}

BOOL nw_protocol_tcp_initialize(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *local_endpoint;
  NSObject *v5;
  NSObject *remote_endpoint;
  NSObject *v7;
  const sockaddr *address;
  const sockaddr *v9;
  void *v10;
  void *path;
  int v12;
  uint64_t v13;
  NSObject *v14;
  void *v15;
  uint64_t v16;
  char v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  nw_protocol_definition_t v21;
  char v22;
  int sa_family;
  _QWORD *v24;
  int v25;
  int v26;
  unint64_t StatusReg;
  int v28;
  uint64_t v29;
  NSObject *v30;
  const char *v31;
  _QWORD *v32;
  NSObject *v33;
  const char *v34;
  NSObject *v35;
  uint32_t v36;
  void *v37;
  _BOOL8 result;
  NSObject *v39;
  NSObject *v40;
  int v41;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v2 = nw_protocol_downcast();
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_tcp_initialize";
    v13 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_66;
    v30 = __nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      goto LABEL_66;
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_tcp_initialize";
    v31 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_65:
    _os_log_impl(&dword_209FB3000, v30, OS_LOG_TYPE_ERROR, v31, buf, 0xCu);
    goto LABEL_66;
  }
  v3 = v2;
  _os_feature_enabled_impl();
  nw_protocol_get_input_handler();
  local_endpoint = nw_protocol_get_local_endpoint();
  if (!local_endpoint)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_tcp_initialize";
    v13 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_66;
    v30 = __nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      goto LABEL_66;
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_tcp_initialize";
    v31 = "%{public}s get_local_endpoint failed, backtrace limit exceeded";
    goto LABEL_65;
  }
  v5 = local_endpoint;
  *(_QWORD *)(v3 + 5272) = nw_endpoint_copy_address_string(local_endpoint);
  *(_WORD *)(v3 + 5300) = nw_endpoint_get_port(v5);
  remote_endpoint = nw_protocol_get_remote_endpoint();
  if (!remote_endpoint)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_tcp_initialize";
    v13 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_66;
    v30 = __nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      goto LABEL_66;
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_tcp_initialize";
    v31 = "%{public}s get_remote_endpoint failed, backtrace limit exceeded";
    goto LABEL_65;
  }
  v7 = remote_endpoint;
  *(_QWORD *)(v3 + 5280) = nw_endpoint_copy_address_string(remote_endpoint);
  *(_WORD *)(v3 + 5302) = nw_endpoint_get_port(v7);
  address = nw_endpoint_get_address(v5);
  if (!address)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_tcp_initialize";
    v13 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_66;
    v30 = __nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      goto LABEL_66;
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_tcp_initialize";
    v31 = "%{public}s nw_endpoint_get_address failed, backtrace limit exceeded";
    goto LABEL_65;
  }
  v9 = address;
  v10 = *(void **)(v3 + 5208);
  if (v10)
  {
    nw_release(v10);
    *(_QWORD *)(v3 + 5208) = 0;
  }
  path = (void *)nw_protocol_get_path();
  *(_QWORD *)(v3 + 5208) = path;
  if (path)
  {
    nw_retain(path);
    if (nw_path_is_viable())
      v12 = 0x2000;
    else
      v12 = 0;
    *(_DWORD *)(v3 + 5308) = *(_DWORD *)(v3 + 5308) & 0xFFFFDFFF | v12;
  }
  else
  {
    v14 = __nwlog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_tcp_initialize";
      _os_log_impl(&dword_209FB3000, v14, OS_LOG_TYPE_ERROR, "%{public}s Unable to get path from input protocol, will not be able to get stats", buf, 0xCu);
    }
  }
  nw_protocol_get_input_handler();
  if (!nw_protocol_get_parameters())
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_tcp_initialize";
    v13 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_66;
    v30 = __nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      goto LABEL_66;
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_tcp_initialize";
    v31 = "%{public}s called with null parameters, backtrace limit exceeded";
    goto LABEL_65;
  }
  v15 = (void *)nw_parameters_copy_protocol_options_legacy();
  v16 = v3 + 604;
  if (!nw_protocol_options_get_log_id_str() || !nw_protocol_options_get_log_id_str())
  {
    snprintf((char *)(v3 + 604), 0x54uLL, "tcp[%llu]", ++tcp_flow_gencnt);
    snprintf((char *)(v3 + 4852), 0x54uLL, "tcp[%llu]", tcp_flow_gencnt);
  }
  *(_WORD *)(v3 + 688) = nw_protocol_options_get_log_id_num();
  if (v15)
    nw_release(v15);
  if (nw_parameters_get_logging_disabled())
    v17 = 2;
  else
    v17 = 0;
  *(_BYTE *)(v3 + 828) = *(_BYTE *)(v3 + 828) & 0xFD | v17;
  if (nw_parameters_get_sensitive_redacted())
    v18 = 4;
  else
    v18 = 0;
  *(_BYTE *)(v3 + 828) = *(_BYTE *)(v3 + 828) & 0xFB | v18;
  v19 = nw_parameters_copy_context();
  if (!v19)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_tcp_initialize";
    v13 = _os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v30 = __nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_tcp_initialize";
        v31 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_65;
      }
    }
LABEL_66:
    if (v13)
    {
      v37 = (void *)v13;
LABEL_79:
      free(v37);
    }
    return 0;
  }
  v20 = v19;
  *(_QWORD *)(v3 + 5216) = nw_path_copy_flow_registration();
  *(_QWORD *)(v3 + 5200) = v20;
  v21 = nw_protocol_copy_tcp_definition();
  *(_QWORD *)(v3 + 5240) = nw_context_get_globals_for_protocol();
  if (nw_context_get_logging_disabled())
    v22 = 0x80;
  else
    v22 = 0;
  *(_BYTE *)(*(_QWORD *)(v3 + 5240) + 328) = v22 & 0x80 | *(_BYTE *)(*(_QWORD *)(v3 + 5240) + 328) & 0x7F;
  if (v21)
    nw_release(v21);
  *(_QWORD *)(v3 + 24) = a1;
  *(_QWORD *)(v3 + 40) = v3;
  sa_family = v9->sa_family;
  if (sa_family == 2)
  {
    v24 = &inetsw;
  }
  else
  {
    if (sa_family != 30)
    {
      v26 = 22;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
LABEL_45:
      **(_DWORD **)(StatusReg + 8) = v26;
      v28 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      __nwlog_obj();
      *(_DWORD *)buf = 136446722;
      v43 = "nw_protocol_tcp_initialize";
      v44 = 2082;
      v45 = v3 + 604;
      v46 = 1024;
      LODWORD(v47) = v28;
      v29 = _os_log_send_and_compose_impl();
      if (!__nwlog_fault()
        || (v33 = __nwlog_obj(), !os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)))
      {
LABEL_77:
        if (v29)
        {
          v37 = (void *)v29;
          goto LABEL_79;
        }
        return 0;
      }
      *(_DWORD *)buf = 136446722;
      v43 = "nw_protocol_tcp_initialize";
      v44 = 2082;
      v45 = v16;
      v46 = 1024;
      LODWORD(v47) = v28;
      v34 = "%{public}s %{public}s setup state failed %{darwin.errno}d, backtrace limit exceeded";
      v35 = v33;
      v36 = 28;
LABEL_76:
      _os_log_impl(&dword_209FB3000, v35, OS_LOG_TYPE_ERROR, v34, buf, v36);
      goto LABEL_77;
    }
    v24 = &inet6sw;
  }
  *(_QWORD *)(v3 + 304) = 0;
  *(_QWORD *)(v3 + 312) = v3 + 304;
  *(_QWORD *)(v3 + 320) = 0;
  *(_QWORD *)(v3 + 328) = v3 + 320;
  *(_QWORD *)(v3 + 400) = 0;
  *(_QWORD *)(v3 + 408) = v3 + 400;
  *(_QWORD *)(v3 + 504) = 0;
  *(_QWORD *)(v3 + 512) = v3 + 504;
  *(_QWORD *)(v3 + 416) = 0;
  *(_QWORD *)(v3 + 424) = v3 + 416;
  *(_QWORD *)(v3 + 444) = 0;
  *(_QWORD *)(v3 + 520) = 0;
  *(_QWORD *)(v3 + 528) = v3 + 520;
  *(_QWORD *)(v3 + 548) = 0;
  *(_DWORD *)(v3 + 360) = 1;
  *(_DWORD *)(v3 + 536) |= 0x1004u;
  *(_DWORD *)(v3 + 432) |= 0x1000u;
  *(_WORD *)(v3 + 376) |= 0x100u;
  *(_QWORD *)(v3 + 456) = v3;
  *(_QWORD *)(v3 + 560) = v3;
  *(_QWORD *)v3 = v3 + 832;
  *(_QWORD *)(v3 + 8) = v24;
  v25 = (*(uint64_t (**)(uint64_t))(v24[5] + 8))(v3);
  if (v25)
  {
    v26 = v25;
    *(_WORD *)(v3 + 376) |= 1u;
    --*(_DWORD *)(v3 + 360);
    sofreelastref(v3);
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    goto LABEL_45;
  }
  *(_QWORD *)(v3 + 32) = &nw_proto_north;
  v32 = *(_QWORD **)v3;
  v32[267] = &nw_proto_south;
  v32[268] = v3;
  v32[269] = v3;
  *(_DWORD *)(v3 + 824) = networkd_settings_get_int64_with_default();
  if ((*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v40 = __nwlog_tcp_log();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
      {
        v41 = *(_DWORD *)(v3 + 824);
        *(_DWORD *)buf = 136446722;
        v43 = "nw_protocol_tcp_initialize";
        v44 = 2082;
        v45 = v3 + 604;
        v46 = 1024;
        LODWORD(v47) = v41;
        _os_log_impl(&dword_209FB3000, v40, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s tcp_input_max_aggregate %u", buf, 0x1Cu);
      }
    }
  }
  if ((nw_protocol_tcp_apply_parameters(v3) & 1) == 0)
  {
    if ((*(_BYTE *)(v3 + 828) & 2) != 0)
      return 0;
    __nwlog_tcp_log();
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_tcp_initialize";
    v44 = 2082;
    v45 = v3 + 604;
    v29 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_77;
    v39 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      goto LABEL_77;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_tcp_initialize";
    v44 = 2082;
    v45 = v16;
    v34 = "%{public}s %{public}s apply socket parameters failed, backtrace limit exceeded";
    goto LABEL_75;
  }
  if ((*(unsigned int (**)(uint64_t, const sockaddr *))(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 40) + 16))(v3, v9))
  {
    if ((*(_BYTE *)(v3 + 828) & 2) != 0)
      return 0;
    __nwlog_tcp_log();
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_tcp_initialize";
    v44 = 2082;
    v45 = v3 + 604;
    v29 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_77;
    v39 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      goto LABEL_77;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_tcp_initialize";
    v44 = 2082;
    v45 = v16;
    v34 = "%{public}s %{public}s tcp_bind failed, backtrace limit exceeded";
LABEL_75:
    v35 = v39;
    v36 = 22;
    goto LABEL_76;
  }
  if ((*(_BYTE *)(v3 + 372) & 2) == 0 || (result = nw_protocol_tcp_initialize_inbound(v3, v7)))
  {
    result = 1;
    *(_DWORD *)(v3 + 5224) = 1;
    *(_DWORD *)(v3 + 5308) |= 0x40000u;
  }
  return result;
}

uint64_t tcp_usr_attach(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int64x2_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t result;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  char v19;
  char v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t all_stats;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void (*v34)(uint64_t);
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  NSObject *v54;
  void *v55;
  NSObject *v56;
  void *v57;
  unsigned int __buf;
  const char *v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v2 = **(_DWORD **)(*(_QWORD *)(a1 + 8) + 8);
  v3 = nw_tcp_access_globals(a1);
  v4 = v3;
  if (v3)
  {
    v5 = *(_QWORD *)(v3 + 72);
    if (v5)
      goto LABEL_3;
  }
  else
  {
    v54 = __nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    __buf = 136446210;
    v59 = "tcp_attach";
    v55 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort();
    if ((_DWORD)result)
    {
LABEL_105:
      __break(1u);
      return result;
    }
    free(v55);
    v5 = MEMORY[0x48];
    if (MEMORY[0x48])
      goto LABEL_3;
  }
  v56 = __nwlog_obj();
  os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
  __buf = 136446210;
  v59 = "tcp_attach";
  v57 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if ((_DWORD)result)
    goto LABEL_105;
  free(v57);
  v5 = *(_QWORD *)(v4 + 72);
LABEL_3:
  v6 = *(_QWORD *)a1;
  *(_QWORD *)(v6 + 16) = v5;
  *(_QWORD *)(v6 + 224) = a1;
  v7.i64[0] = v6 + 280;
  v7.i64[1] = v6 + 320;
  *(int64x2_t *)(v6 + 248) = vnegq_s64((int64x2_t)vandq_s8((int8x16_t)vnegq_s64(v7), (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFFF8)));
  *(_QWORD *)(v6 + 264) = -(uint64_t)((-360 - v6) & 0xFFFFFFFFFFFFFFF8);
  *(_QWORD *)(v6 + 272) = -(uint64_t)((-400 - v6) & 0xFFFFFFFFFFFFFFF8);
  v8 = *(uint64_t **)(v5 + 32);
  v9 = *v8;
  *(_QWORD *)v6 = *v8;
  if (v9)
    *(_QWORD *)(v9 + 8) = v6;
  *v8 = v6;
  *(_QWORD *)(v6 + 8) = v8;
  v10 = *(_QWORD *)a1;
  if (!*(_DWORD *)(a1 + 388) || !*(_DWORD *)(a1 + 492))
  {
    v13 = *(_DWORD *)(sysctls + 232);
    if (v13 > 0x71C71C)
      return 55;
    v15 = *(_DWORD *)(sysctls + 236);
    *(_DWORD *)(a1 + 388) = v13;
    v16 = *(_QWORD *)(*(_QWORD *)(a1 + 456) + 24);
    if ((*(_BYTE *)(a1 + 432) & 4) != 0)
    {
      if (v16)
      {
        all_stats = nw_protocol_tcp_get_all_stats();
        if (all_stats)
          *(_DWORD *)(all_stats + 88) = *(_DWORD *)(a1 + 388);
      }
    }
    else if (v16)
    {
      v17 = nw_protocol_tcp_get_all_stats();
      if (v17)
        *(_DWORD *)(v17 + 100) = *(_DWORD *)(a1 + 388);
    }
    v29 = *(_DWORD *)(a1 + 388);
    if (*(_DWORD *)(a1 + 392) > v29)
      *(_DWORD *)(a1 + 392) = v29;
    *(_DWORD *)(a1 + 436) = v13;
    if (v15 > 0x71C71C)
    {
      sbflush(a1 + 384);
      *(_DWORD *)(a1 + 388) = 0;
      v30 = *(_QWORD *)(*(_QWORD *)(a1 + 456) + 24);
      if ((*(_BYTE *)(a1 + 432) & 4) != 0)
      {
        if (v30)
        {
          v48 = nw_protocol_tcp_get_all_stats();
          if (v48)
            *(_DWORD *)(v48 + 88) = *(_DWORD *)(a1 + 388);
        }
      }
      else if (v30)
      {
        v31 = nw_protocol_tcp_get_all_stats();
        if (v31)
          *(_DWORD *)(v31 + 100) = *(_DWORD *)(a1 + 388);
      }
      return 55;
    }
    *(_DWORD *)(a1 + 492) = v15;
    v32 = *(_QWORD *)(*(_QWORD *)(a1 + 560) + 24);
    if ((*(_BYTE *)(a1 + 536) & 4) != 0)
    {
      if (v32)
      {
        v49 = nw_protocol_tcp_get_all_stats();
        if (v49)
          *(_DWORD *)(v49 + 88) = *(_DWORD *)(a1 + 492);
      }
    }
    else if (v32)
    {
      v33 = nw_protocol_tcp_get_all_stats();
      if (v33)
        *(_DWORD *)(v33 + 100) = *(_DWORD *)(a1 + 492);
    }
    v50 = *(_DWORD *)(a1 + 496);
    v51 = *(_DWORD *)(a1 + 492);
    if (v50 <= v51)
    {
      *(_DWORD *)(a1 + 540) = v15;
      if (!v50)
      {
LABEL_95:
        *(_DWORD *)(a1 + 496) = 1;
        v52 = *(_DWORD *)(a1 + 392);
        if (v52)
          goto LABEL_99;
        goto LABEL_96;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 496) = v51;
      *(_DWORD *)(a1 + 540) = v15;
      if (!v51)
        goto LABEL_95;
    }
    v52 = *(_DWORD *)(a1 + 392);
    if (v52)
    {
LABEL_99:
      v53 = *(_DWORD *)(a1 + 388);
      if (v52 > v53)
        *(_DWORD *)(a1 + 392) = v53;
      goto LABEL_7;
    }
LABEL_96:
    v52 = 2048;
    *(_DWORD *)(a1 + 392) = 2048;
    goto LABEL_99;
  }
LABEL_7:
  if (*(_DWORD *)(a1 + 484))
  {
    v11 = *(_DWORD *)(a1 + 536);
    if ((v11 & 0x200) == 0)
      goto LABEL_9;
LABEL_18:
    v12 = *(_DWORD *)(a1 + 432);
    if ((v12 & 0x200) != 0)
      goto LABEL_20;
    goto LABEL_19;
  }
  *(_DWORD *)(a1 + 484) = 2048;
  *(_DWORD *)(a1 + 588) = 2048;
  v11 = *(_DWORD *)(a1 + 536);
  if ((v11 & 0x200) != 0)
    goto LABEL_18;
LABEL_9:
  *(_DWORD *)(a1 + 536) = v11 | 0x400;
  v12 = *(_DWORD *)(a1 + 432);
  if ((v12 & 0x200) == 0)
LABEL_19:
    *(_DWORD *)(a1 + 432) = v12 | 0x400;
LABEL_20:
  v18 = *(_BYTE *)(v10 + 2236);
  if (v2 == 30)
    v19 = 2;
  else
    v19 = 1;
  v20 = v18 | v19;
  *(_BYTE *)(v10 + 2236) = v18 | v19;
  v21 = nw_tcp_access_globals(*(_QWORD *)(v10 + 224));
  calculate_tcp_clock(v21);
  *(_DWORD *)(v10 + 4104) = 0;
  *(_QWORD *)(v10 + 2240) = 0;
  v22 = (_DWORD *)sysctls;
  v23 = 152;
  if ((v20 & 2) == 0)
    v23 = 148;
  v24 = *(_DWORD *)(sysctls + v23);
  *(_DWORD *)(v10 + 2396) = v24;
  *(_DWORD *)(v10 + 2436) = v24;
  *(_DWORD *)(v10 + 2328) = 160;
  v25 = *(_DWORD *)(v10 + 2980);
  v26 = v25 | 0x20;
  *(_DWORD *)(v10 + 2980) = v25 | 0x20;
  if (v22[83])
  {
    v26 = v25 | 0x20000020;
    *(_DWORD *)(v10 + 2980) = v25 | 0x20000020;
  }
  *(_QWORD *)(v10 + 2784) = 0;
  *(_QWORD *)(v10 + 2792) = v10 + 2784;
  *(_QWORD *)(v10 + 3192) = 0;
  *(_QWORD *)(v10 + 4224) = 0;
  *(_QWORD *)(v10 + 4232) = v10 + 4224;
  *(_OWORD *)(v10 + 4240) = 0u;
  *(_QWORD *)(v10 + 4256) = v10 + 4248;
  *(_QWORD *)(v10 + 4264) = 0;
  *(_QWORD *)(v10 + 4272) = v10 + 4264;
  *(_QWORD *)(v10 + 3272) = 0;
  *(_QWORD *)(v10 + 2320) = v10;
  *(_OWORD *)(v10 + 2440) = xmmword_20A010BB0;
  *(_DWORD *)(v10 + 2468) = v22[43];
  *(_DWORD *)(v10 + 2432) = 1000;
  if (v22[5])
  {
    v27 = 1;
    *(_BYTE *)(v10 + 2504) = 1;
  }
  else
  {
    if (v22[76])
    {
      v27 = 2;
    }
    else if ((v26 & 0x10000000) != 0 || (v27 = 4, (v26 & 0x8000000) == 0) && v22[84] != 1 && tcp_do_l4s != 1)
    {
      v27 = 3;
    }
    *(_BYTE *)(v10 + 2504) = v27;
    if (!*(_QWORD *)(v10 + 3080))
    {
      *(_QWORD *)(v10 + 3080) = v10 + 3088;
      *(_OWORD *)(v10 + 3088) = 0u;
      *(_OWORD *)(v10 + 3104) = 0u;
      *(_OWORD *)(v10 + 3120) = 0u;
      *(_OWORD *)(v10 + 3136) = 0u;
      *(_OWORD *)(v10 + 3152) = 0u;
    }
  }
  v34 = *(void (**)(uint64_t))(tcp_cc_algo_list[v27] + 24);
  if (v34)
  {
    v34(v10 + 2240);
    v22 = (_DWORD *)sysctls;
  }
  if (v22[77] == 1 && (v22[10] == 1 || (*(_BYTE *)(*(_QWORD *)(v10 + 224) + 369) & 0x40) != 0) && off_253CF8688)
  {
    off_253CF8688(v10 + 2240);
    v22 = (_DWORD *)sysctls;
  }
  v35 = v22[76];
  if (v35)
  {
    v36 = v22[4];
LABEL_63:
    v37 = *(_DWORD *)(v10 + 2436) * v36;
    goto LABEL_64;
  }
  if (v22[69])
  {
    v36 = 10;
    goto LABEL_63;
  }
  v37 = 4380;
LABEL_64:
  *(_DWORD *)(v10 + 2384) = v37;
  *(_DWORD *)(v10 + 2388) = 1073725440;
  *(_DWORD *)(v10 + 2748) = 1073725440;
  v38 = *(_DWORD *)(v21 + 316);
  *(_DWORD *)(v10 + 2400) = v38;
  *(_DWORD *)(v10 + 2304) = v38;
  *(_DWORD *)(v10 + 2564) = v38;
  *(_DWORD *)(v10 + 2552) = v22[52];
  *(_DWORD *)(v10 + 2556) = 0;
  v39 = *(_DWORD *)(v10 + 2980);
  *(_BYTE *)(v10 + 2550) = 3;
  *(_BYTE *)(v10 + 4308) = 1;
  *(_DWORD *)(v10 + 2420) = v38;
  if (v35)
  {
    v40 = v22[4];
    v41 = *(_DWORD *)(v10 + 2436);
  }
  else
  {
    v42 = v22[69];
    v41 = *(_DWORD *)(v10 + 2436);
    if (!v42)
    {
      v43 = 4380;
      goto LABEL_69;
    }
    v40 = 10;
  }
  v43 = v41 * v40;
LABEL_69:
  __buf = 0;
  *(_DWORD *)(v10 + 2428) = v43;
  *(_WORD *)(v10 + 2548) = 16;
  *(_DWORD *)(v10 + 4320) = 0;
  *(_QWORD *)(v10 + 4312) = 0;
  *(_OWORD *)(v10 + 3016) = 0u;
  *(_OWORD *)(v10 + 3032) = 0u;
  *(_QWORD *)(v10 + 3048) = 0;
  *(_QWORD *)(v10 + 3008) = v10 + 3016;
  *(_DWORD *)(v10 + 3028) = 6;
  *(_DWORD *)(v10 + 3036) = 6 * v41;
  *(_DWORD *)(v10 + 2980) = v39 | 0xA;
  *(_OWORD *)(v10 + 3064) = 0u;
  arc4random_buf(&__buf, 4uLL);
  v44 = __buf;
  if (__buf <= 1)
    v45 = 1;
  else
    v45 = __buf;
  *(_DWORD *)(v10 + 4116) = v45;
  *(_DWORD *)(v10 + 4120) = *(_DWORD *)(v21 + 316);
  if (*(_DWORD *)(sysctls + 296))
    *(_DWORD *)(v10 + 4128) = v44;
  *(_QWORD *)(v10 + 2600) = 0x100000001;
  *(_QWORD *)(v10 + 2872) = 0;
  *(_QWORD *)(v10 + 2880) = v10 + 2872;
  *(_DWORD *)(v10 + 2888) = 0;
  *(_DWORD *)(v10 + 2540) = 0;
  *(_BYTE *)(v10 + 2237) = 64;
  *(_QWORD *)(v10 + 240) = v10 + 2240;
  *(_QWORD *)(v10 + 3312) = 680;
  *(_QWORD *)(v10 + 3328) = 0;
  *(_QWORD *)(v10 + 3320) = 0;
  *(_DWORD *)(v10 + 2252) = 0;
  if (*(_QWORD *)(a1 + 24))
  {
    v46 = nw_protocol_tcp_get_all_stats();
    if (v46)
      *(_DWORD *)(v46 + 132) = *(unsigned __int8 *)(v10 + 2504);
    if (*(_QWORD *)(a1 + 24))
    {
      v47 = nw_protocol_tcp_get_all_stats();
      if (v47)
        *(_DWORD *)(v47 + 136) = 0;
    }
  }
  if ((*(_BYTE *)(a1 + 372) & 0x80) == 0 || *(_DWORD *)(a1 + 16))
    return 0;
  result = 0;
  *(_DWORD *)(a1 + 16) = 120000;
  return result;
}

uint64_t tcp_cubic_init(uint64_t a1)
{
  unsigned int v2;
  float v3;
  float v4;
  float v5;
  _DWORD *v6;
  uint64_t result;
  NSObject *v8;
  void *v9;

  do
    v2 = __ldaxr(dword_253CF8760);
  while (__stlxr(v2 + 1, dword_253CF8760));
  v3 = 0.3;
  if (!*(_DWORD *)(sysctls + 280))
    v3 = 0.2;
  v4 = 0.85;
  if (!*(_DWORD *)(sysctls + 280))
    v4 = 0.875;
  v5 = 0.7;
  if (!*(_DWORD *)(sysctls + 280))
    v5 = 0.8;
  tcp_cubic_backoff = LODWORD(v3);
  tcp_cubic_fast_convergence_factor = LODWORD(v4);
  tcp_cubic_beta = LODWORD(v5);
  v6 = *(_DWORD **)(a1 + 840);
  if (v6)
    goto LABEL_9;
  v8 = __nwlog_obj();
  os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  v9 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v9);
    v6 = *(_DWORD **)(a1 + 840);
LABEL_9:
    *v6 = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 4) = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 8) = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 12) = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 16) = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 28) = 0;
    return 0;
  }
  __break(1u);
  return result;
}

uint64_t tcp_usr_bind(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  __n128 v5;
  uint64_t result;
  _QWORD v7[3];

  v7[2] = *MEMORY[0x24BDAC8D0];
  v2 = *a1;
  if (!*a1 || *(_DWORD *)(v2 + 232) == 3)
    return 22;
  v4 = nw_tcp_access_globals(*(_QWORD *)(v2 + 224));
  v5.n128_f64[0] = calculate_tcp_clock(v4);
  if (*(_BYTE *)(a2 + 1) && (*(_BYTE *)(a2 + 1) != 2 || (*(_DWORD *)(a2 + 4) & 0xF0) == 0xE0))
    return 47;
  if (*(_WORD *)(v2 + 2226))
    return 22;
  if (*(_DWORD *)(v2 + 492))
    return 22;
  v7[0] = 0;
  v7[1] = 0;
  if (*(_BYTE *)a2 != 16)
    return 22;
  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD *, uint64_t, __n128))(*(_QWORD *)(v2 + 2136) + 8))(*(_QWORD *)(v2 + 224), a2, 16, v7, 16, v5);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v7[0]))
      *(_DWORD *)(v2 + 492) = HIDWORD(v7[0]);
    result = 0;
    *(_WORD *)(v2 + 2226) = WORD1(v7[0]);
  }
  return result;
}

uint64_t nw_proto_tcp_bind(uint64_t a1, const void *a2, int a3, void *__dst, size_t __n)
{
  const char *v7;
  void *v8;
  const char *v9;
  NSObject *v10;
  const char *v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    if (a1 && (*(_BYTE *)(a1 + 828) & 2) != 0)
      return 0xFFFFFFFFLL;
    __nwlog_tcp_log();
    if (a1)
      v7 = (const char *)(a1 + 604);
    else
      v7 = "";
    *(_DWORD *)buf = 136446466;
    v13 = "nw_proto_tcp_bind";
    v14 = 2082;
    v15 = v7;
    v8 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_23;
    v10 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    *(_DWORD *)buf = 136446466;
    v13 = "nw_proto_tcp_bind";
    v14 = 2082;
    v15 = v7;
    v11 = "%{public}s %{public}s nam is NULL, backtrace limit exceeded";
    goto LABEL_22;
  }
  if (__dst)
  {
    memcpy(__dst, a2, __n);
    return 0;
  }
  if (!a1 || (*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    if (a1)
      v9 = (const char *)(a1 + 604);
    else
      v9 = "";
    *(_DWORD *)buf = 136446466;
    v13 = "nw_proto_tcp_bind";
    v14 = 2082;
    v15 = v9;
    v8 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_23;
    v10 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    *(_DWORD *)buf = 136446466;
    v13 = "nw_proto_tcp_bind";
    v14 = 2082;
    v15 = v9;
    v11 = "%{public}s %{public}s outaddr is NULL, backtrace limit exceeded";
LABEL_22:
    _os_log_impl(&dword_209FB3000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0x16u);
LABEL_23:
    if (v8)
      free(v8);
  }
  return 0xFFFFFFFFLL;
}

uint64_t nw_protocol_tcp_updated_path(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v7;
  _QWORD **v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  _QWORD *v16;
  void *v17;
  int v18;
  int is_traffic_mgmt_background;
  int v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  os_log_type_t v24;
  NSObject *v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  int effective_traffic_class;
  int should_probe_connectivity;
  int v33;
  NSObject *v34;
  const char *v35;
  NSObject *v36;
  os_log_type_t v37;
  NSObject *v38;
  const char *v39;
  int v40;
  int v41;
  uint64_t v42;
  __n128 v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int v46;
  __int16 recommended_mss;
  _QWORD *v48;
  unsigned int v49;
  unint64_t v50;
  unsigned int *v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  int v55;
  NSObject *v56;
  const char *v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  void (*v69)(_QWORD *);
  NSObject *v70;
  int v71;
  NSObject *v72;
  _DWORD *v73;
  NSObject *v74;
  int v75;
  int v76;
  NSObject *v77;
  const char *v78;
  _QWORD *v79;
  NSObject *v80;
  os_log_type_t v81;
  NSObject *v82;
  const char *v83;
  _QWORD *v84;
  _DWORD *v85;
  _DWORD *v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  void *v90;
  NSObject *v91;
  os_log_type_t v92;
  const char *v93;
  NSObject *v94;
  void *v95;
  NSObject *v96;
  _BOOL4 v97;
  uint64_t all_stats;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  NSObject *v102;
  void *v103;
  NSObject *v104;
  os_log_type_t v105;
  const char *v106;
  uint64_t v107;
  NSObject *v108;
  int v109;
  const void *v110;
  const char *v111;
  unsigned int v112;
  int v113;
  const void *v114;
  const char *v115;
  unsigned int v116;
  int v117;
  int v118;
  __int16 v119;
  void *backtrace_string;
  _BOOL4 v121;
  _QWORD *v122;
  void (*v123)(_QWORD **);
  uint64_t v124;
  _QWORD *v125;
  void (*v126)(_QWORD **);
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  void *v134;
  NSObject *v135;
  os_log_type_t v136;
  const char *v137;
  NSObject *v138;
  uint64_t v139;
  unsigned int v140;
  void *v141;
  _BOOL4 v142;
  NSObject *v143;
  const char *v144;
  NSObject *v145;
  NSObject *log;
  uint8_t buf[4];
  const char *v148;
  __int16 v149;
  _BYTE v150[10];
  _BYTE v151[10];
  const char *v152;
  __int16 v153;
  unsigned int v154;
  __int16 v155;
  const char *v156;
  __int16 v157;
  unsigned int v158;
  __int16 v159;
  int v160;
  __int16 v161;
  int v162;
  char v163[4];
  os_log_type_t v164[64];
  uint64_t v165;

  v165 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v148 = "nw_protocol_tcp_updated_path";
    v134 = (void *)_os_log_send_and_compose_impl();
    v164[0] = OS_LOG_TYPE_ERROR;
    v163[0] = 0;
    if (!__nwlog_fault())
      goto LABEL_341;
    if (v164[0] != OS_LOG_TYPE_FAULT)
    {
      v135 = __nwlog_obj();
      v136 = v164[0];
      if (os_log_type_enabled(v135, v164[0]))
      {
        *(_DWORD *)buf = 136446210;
        v148 = "nw_protocol_tcp_updated_path";
        v137 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_340;
      }
      goto LABEL_341;
    }
    v135 = __nwlog_obj();
    v136 = v164[0];
    if (!os_log_type_enabled(v135, v164[0]))
      goto LABEL_341;
    *(_DWORD *)buf = 136446210;
    v148 = "nw_protocol_tcp_updated_path";
    v137 = "%{public}s called with null protocol";
LABEL_340:
    _os_log_impl(&dword_209FB3000, v135, v136, v137, buf, 0xCu);
    goto LABEL_341;
  }
  v4 = v3;
  v7 = nw_protocol_downcast();
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v148 = "nw_protocol_tcp_updated_path";
    v134 = (void *)_os_log_send_and_compose_impl();
    v164[0] = OS_LOG_TYPE_ERROR;
    v163[0] = 0;
    if (!__nwlog_fault())
      goto LABEL_341;
    if (v164[0] != OS_LOG_TYPE_FAULT)
    {
      v135 = __nwlog_obj();
      v136 = v164[0];
      if (os_log_type_enabled(v135, v164[0]))
      {
        *(_DWORD *)buf = 136446210;
        v148 = "nw_protocol_tcp_updated_path";
        v137 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_340;
      }
      goto LABEL_341;
    }
    v135 = __nwlog_obj();
    v136 = v164[0];
    if (!os_log_type_enabled(v135, v164[0]))
      goto LABEL_341;
    *(_DWORD *)buf = 136446210;
    v148 = "nw_protocol_tcp_updated_path";
    v137 = "%{public}s called with null tcp";
    goto LABEL_340;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v148 = "nw_protocol_tcp_updated_path";
    v134 = (void *)_os_log_send_and_compose_impl();
    v164[0] = OS_LOG_TYPE_ERROR;
    v163[0] = 0;
    if (!__nwlog_fault())
      goto LABEL_341;
    if (v164[0] != OS_LOG_TYPE_FAULT)
    {
      v135 = __nwlog_obj();
      v136 = v164[0];
      if (os_log_type_enabled(v135, v164[0]))
      {
        *(_DWORD *)buf = 136446210;
        v148 = "nw_protocol_tcp_updated_path";
        v137 = "%{public}s called with null path, backtrace limit exceeded";
        goto LABEL_340;
      }
      goto LABEL_341;
    }
    v135 = __nwlog_obj();
    v136 = v164[0];
    if (!os_log_type_enabled(v135, v164[0]))
      goto LABEL_341;
    *(_DWORD *)buf = 136446210;
    v148 = "nw_protocol_tcp_updated_path";
    v137 = "%{public}s called with null path";
    goto LABEL_340;
  }
  v8 = (_QWORD **)v7;
  v9 = *(_QWORD *)(v7 + 1280);
  if ((*(_BYTE *)(v7 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v138 = __nwlog_tcp_log();
      if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v148 = "nw_protocol_tcp_updated_path";
        v149 = 2082;
        *(_QWORD *)v150 = (char *)v8 + 604;
        _os_log_impl(&dword_209FB3000, v138, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s ", buf, 0x16u);
      }
    }
  }
  if (v8[651] != a3)
  {
    v10 = nw_retain(a3);
    v11 = v8[651];
    if (v11)
      nw_release(v11);
    v8[651] = v10;
    if (nw_path_is_viable())
      v12 = 0x2000;
    else
      v12 = 0;
    *((_DWORD *)v8 + 1327) = *((_DWORD *)v8 + 1327) & 0xFFFFDFFF | v12;
  }
  nw_proto_tcp_notify_segmentation_offload(a1);
  v13 = (uint64_t)*v8;
  if (*v8)
  {
    v14 = *(_QWORD *)(v13 + 496);
    if (v14 && *(_BYTE *)(v14 + 1496))
    {
      v15 = *(void **)(v14 + 1488);
      if (v15)
      {
        free(v15);
        v13 = (uint64_t)*v8;
        *(_QWORD *)((*v8)[62] + 1488) = 0;
        v14 = *(_QWORD *)(v13 + 496);
      }
      *(_BYTE *)(v14 + 1496) = 0;
    }
    *(_QWORD *)(v13 + 496) = 0;
    tcp_mtudisc(*v8);
  }
  v16 = v8[652];
  nw_protocol_get_input_handler();
  if (nw_protocol_get_parameters())
  {
    v17 = (void *)nw_parameters_copy_context();
    v8[652] = (_QWORD *)nw_path_copy_flow_registration();
    if (v17)
      nw_release(v17);
    if (v16)
      nw_release(v16);
    v18 = *((_DWORD *)v8 + 1306);
    if ((v18 - 1) > 1)
    {
LABEL_82:
      if ((v18 | 4) == 4)
        goto LABEL_286;
      v48 = v8[652];
      if (!v8[651])
        goto LABEL_163;
      if (!v48)
        goto LABEL_165;
      *(_DWORD *)v164 = 0;
      *(_DWORD *)v163 = 0;
      if (!nw_path_flow_registration_get_ctl_command())
      {
LABEL_162:
        v48 = v8[652];
LABEL_163:
        if (v48 && !nw_path_is_defunct())
          goto LABEL_286;
LABEL_165:
        if (tcp_perf_measurement)
        {
          if ((*((_BYTE *)v8 + 828) & 2) == 0)
          {
            if (__nwlog_is_datapath_logging_enabled())
            {
              v77 = __nwlog_tcp_log();
              if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
              {
                v78 = "defunct";
                v79 = v8[652];
                v148 = "nw_protocol_tcp_updated_path";
                *(_DWORD *)buf = 136446722;
                v149 = 2082;
                if (!v79)
                  v78 = "unregistered";
                *(_QWORD *)v150 = (char *)v8 + 604;
                *(_WORD *)&v150[8] = 2082;
                *(_QWORD *)v151 = v78;
                v80 = v77;
                v81 = OS_LOG_TYPE_DEBUG;
LABEL_177:
                _os_log_impl(&dword_209FB3000, v80, v81, "%{public}s %{public}s flow is %{public}s", buf, 0x20u);
              }
            }
          }
        }
        else if ((*((_BYTE *)v8 + 828) & 2) == 0)
        {
          v82 = __nwlog_tcp_log();
          if (os_log_type_enabled(v82, OS_LOG_TYPE_INFO))
          {
            v83 = "defunct";
            v84 = v8[652];
            v148 = "nw_protocol_tcp_updated_path";
            *(_DWORD *)buf = 136446722;
            v149 = 2082;
            if (!v84)
              v83 = "unregistered";
            *(_QWORD *)v150 = (char *)v8 + 604;
            *(_WORD *)&v150[8] = 2082;
            *(_QWORD *)v151 = v83;
            v80 = v82;
            v81 = OS_LOG_TYPE_INFO;
            goto LABEL_177;
          }
        }
        ((void (*)(_QWORD **, uint64_t, uint64_t))v8[1][2])(v8, 1, v3);
        v85 = v8 + 61;
        v86 = v8 + 48;
        v87 = *((_DWORD *)v8 + 91);
        if ((v87 & 8) == 0)
        {
          if ((v87 & 0x8000) != 0)
          {
            if ((*((_BYTE *)v8 + 828) & 2) == 0)
            {
              if (__nwlog_is_datapath_logging_enabled())
              {
                v94 = __nwlog_tcp_log();
                if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446978;
                  v148 = "sosetdefunct";
                  v149 = 2082;
                  *(_QWORD *)v150 = (char *)v8 + 604;
                  *(_WORD *)&v150[8] = 2082;
                  *(_QWORD *)v151 = "process_suspended";
                  *(_WORD *)&v151[8] = 1024;
                  LODWORD(v152) = 102;
                  _os_log_impl(&dword_209FB3000, v94, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s level %{public}s flow is not eligible for defunct (%d)", buf, 0x26u);
                }
              }
            }
            goto LABEL_285;
          }
          *((_DWORD *)v8 + 91) = v87 | 8;
          *((_DWORD *)v8 + 108) |= 0x80u;
          *((_DWORD *)v8 + 134) |= 0x80u;
          if (*((_DWORD *)v8 + 122))
          {
            sbflush((uint64_t)(v8 + 61));
            *((_DWORD *)v8 + 123) = 0;
            v88 = v8[70][3];
            if (((_BYTE)v8[67] & 4) != 0)
            {
              if (v88)
              {
                all_stats = nw_protocol_tcp_get_all_stats();
                if (all_stats)
                  *(_DWORD *)(all_stats + 88) = *((_DWORD *)v8 + 123);
              }
            }
            else if (v88)
            {
              v89 = nw_protocol_tcp_get_all_stats();
              if (v89)
                *(_DWORD *)(v89 + 100) = *((_DWORD *)v8 + 123);
            }
          }
          if (*v86)
          {
            sbflush((uint64_t)(v8 + 48));
            *((_DWORD *)v8 + 97) = 0;
            v99 = v8[57][3];
            if (((_BYTE)v8[54] & 4) != 0)
            {
              if (v99)
              {
                v101 = nw_protocol_tcp_get_all_stats();
                if (v101)
                  *(_DWORD *)(v101 + 88) = *((_DWORD *)v8 + 97);
              }
            }
            else if (v99)
            {
              v100 = nw_protocol_tcp_get_all_stats();
              if (v100)
                *(_DWORD *)(v100 + 100) = *((_DWORD *)v8 + 97);
            }
          }
LABEL_218:
          if ((*((_BYTE *)v8 + 828) & 2) == 0)
          {
            if (__nwlog_is_datapath_logging_enabled())
            {
              v143 = __nwlog_tcp_log();
              if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
              {
                v144 = "is already";
                *(_DWORD *)buf = 136446978;
                v148 = "sosetdefunct";
                if ((v87 & 8) == 0)
                  v144 = "marked as";
                v149 = 2082;
                *(_QWORD *)v150 = (char *)v8 + 604;
                *(_WORD *)&v150[8] = 2082;
                *(_QWORD *)v151 = "process_suspended";
                *(_WORD *)&v151[8] = 2082;
                v152 = v144;
                _os_log_impl(&dword_209FB3000, v143, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s level %{public}s flow %{public}s defunct", buf, 0x2Au);
              }
            }
          }
          if ((*((_BYTE *)v8 + 364) & 8) == 0)
          {
            if ((*((_BYTE *)v8 + 828) & 2) == 0)
            {
              __nwlog_tcp_log();
              *(_DWORD *)buf = 136446466;
              v148 = "sodefunct";
              v149 = 2082;
              *(_QWORD *)v150 = (char *)v8 + 604;
              v103 = (void *)_os_log_send_and_compose_impl();
              v164[0] = OS_LOG_TYPE_ERROR;
              v163[0] = 0;
              if (!__nwlog_fault())
                goto LABEL_283;
              if (v164[0] == OS_LOG_TYPE_FAULT)
              {
                v104 = __nwlog_tcp_log();
                v105 = v164[0];
                if (!os_log_type_enabled(v104, v164[0]))
                  goto LABEL_283;
                *(_DWORD *)buf = 136446466;
                v148 = "sodefunct";
                v149 = 2082;
                *(_QWORD *)v150 = (char *)v8 + 604;
                v106 = "%{public}s %{public}s improperly called sodefunct";
              }
              else if (v163[0])
              {
                backtrace_string = (void *)__nw_create_backtrace_string();
                v104 = __nwlog_tcp_log();
                v105 = v164[0];
                v121 = os_log_type_enabled(v104, v164[0]);
                if (backtrace_string)
                {
                  if (v121)
                  {
                    *(_DWORD *)buf = 136446722;
                    v148 = "sodefunct";
                    v149 = 2082;
                    *(_QWORD *)v150 = (char *)v8 + 604;
                    *(_WORD *)&v150[8] = 2082;
                    *(_QWORD *)v151 = backtrace_string;
                    _os_log_impl(&dword_209FB3000, v104, v105, "%{public}s %{public}s improperly called sodefunct, dumping backtrace:%{public}s", buf, 0x20u);
                  }
                  free(backtrace_string);
                  goto LABEL_283;
                }
                if (!v121)
                {
LABEL_283:
                  if (v103)
                    free(v103);
                  goto LABEL_285;
                }
                *(_DWORD *)buf = 136446466;
                v148 = "sodefunct";
                v149 = 2082;
                *(_QWORD *)v150 = (char *)v8 + 604;
                v106 = "%{public}s %{public}s improperly called sodefunct, no backtrace";
              }
              else
              {
                v104 = __nwlog_tcp_log();
                v105 = v164[0];
                if (!os_log_type_enabled(v104, v164[0]))
                  goto LABEL_283;
                *(_DWORD *)buf = 136446466;
                v148 = "sodefunct";
                v149 = 2082;
                *(_QWORD *)v150 = (char *)v8 + 604;
                v106 = "%{public}s %{public}s improperly called sodefunct, backtrace limit exceeded";
              }
              _os_log_impl(&dword_209FB3000, v104, v105, v106, buf, 0x16u);
              goto LABEL_283;
            }
LABEL_285:
            ((void (*)(_QWORD **, uint64_t, uint64_t))v8[1][3])(v8, 1, v4);
LABEL_286:
            nw_protocol_get_output_handler();
            if (!nw_protocol_updated_path_is_valid())
              return 1;
            nw_protocol_get_output_handler();
            return nw_protocol_updated_path();
          }
          if ((__int16)v8[47] < 0)
            goto LABEL_285;
          v107 = (uint64_t)*v8;
          if ((*((_BYTE *)v8 + 828) & 2) == 0)
          {
            v108 = __nwlog_tcp_log();
            if (os_log_type_enabled(v108, OS_LOG_TYPE_INFO))
            {
              v109 = *(_DWORD *)v8[1][1];
              if (v109 == 2)
                v110 = (const void *)(v107 + 492);
              else
                v110 = (const void *)(v107 + 480);
              v111 = inet_ntop(v109, v110, (char *)v164, 0x40u);
              v112 = bswap32(*(unsigned __int16 *)(v107 + 2226)) >> 16;
              v113 = *(_DWORD *)v8[1][1];
              if (v113 == 2)
                v114 = (const void *)(v107 + 476);
              else
                v114 = (const void *)(v107 + 464);
              v115 = inet_ntop(v113, v114, v163, 0x40u);
              v116 = bswap32(*(unsigned __int16 *)(v107 + 2224)) >> 16;
              v117 = *((_DWORD *)v8 + 134);
              v118 = *((_DWORD *)v8 + 108);
              *(_DWORD *)buf = 136448259;
              v148 = "sodefunct";
              v149 = 2082;
              *(_QWORD *)v150 = (char *)v8 + 604;
              v86 = v8 + 48;
              v4 = v3;
              *(_WORD *)&v150[8] = 2082;
              *(_QWORD *)v151 = "process_suspended";
              *(_WORD *)&v151[8] = 2081;
              v152 = v111;
              v153 = 1024;
              v154 = v112;
              v155 = 2081;
              v156 = v115;
              v157 = 1024;
              v158 = v116;
              v159 = 1024;
              v160 = v117;
              v161 = 1024;
              v162 = v118;
              _os_log_impl(&dword_209FB3000, v108, OS_LOG_TYPE_INFO, "%{public}s %{public}s level %{public}s flow [TCP %{private}s:%d -> %{private}s:%d] is now defunct [rcv_fl 0x%x, snd_fl 0x%x]", buf, 0x4Cu);
            }
          }
          *((_DWORD *)v8 + 92) |= 8u;
          if (((_BYTE)v8[67] & 1) != 0)
          {
            sbunlock((uint64_t)v85);
            if (((_BYTE)v8[54] & 1) == 0)
            {
LABEL_238:
              v119 = *((_WORD *)v8 + 188);
              if ((v119 & 0x20) == 0)
                goto LABEL_239;
              goto LABEL_248;
            }
          }
          else if (((_BYTE)v8[54] & 1) == 0)
          {
            goto LABEL_238;
          }
          sbunlock((uint64_t)v86);
          v119 = *((_WORD *)v8 + 188);
          if ((v119 & 0x20) == 0)
          {
LABEL_239:
            sorflush((uint64_t)v8);
            v119 = *((_WORD *)v8 + 188);
            if ((v119 & 0x10) == 0)
            {
LABEL_249:
              *((_WORD *)v8 + 188) = v119 | 0x10;
              v122 = v8[4];
              if (v122)
              {
                v123 = (void (*)(_QWORD **))v122[2];
                if (v123)
                  v123(v8);
              }
              v124 = *(_QWORD *)(v107 + 240);
              *((_WORD *)v8 + 189) = 53;
              user_north_signal_error((uint64_t)v8);
              tcp_close(v124);
              v119 = *((_WORD *)v8 + 188);
            }
LABEL_253:
            if ((v119 & 0xA) == 2)
              (*(void (**)(_QWORD **))(v8[1][5] + 40))(v8);
            if ((*((_BYTE *)v8 + 365) & 0x20) == 0)
            {
              *((_WORD *)v8 + 188) = (_WORD)v8[47] & 0xDFC1 | 0x2030;
              v125 = v8[4];
              if (v125)
              {
                v126 = (void (*)(_QWORD **))v125[7];
                if (v126)
                  v126(v8);
              }
            }
            if (!*((_WORD *)v8 + 189))
              *((_WORD *)v8 + 189) = 9;
            if (*v85)
            {
              sbflush((uint64_t)v85);
              *((_DWORD *)v8 + 123) = 0;
              v127 = v8[70][3];
              if (((_BYTE)v8[67] & 4) != 0)
              {
                if (v127)
                {
                  v129 = nw_protocol_tcp_get_all_stats();
                  if (v129)
                    *(_DWORD *)(v129 + 88) = *((_DWORD *)v8 + 123);
                }
              }
              else if (v127)
              {
                v128 = nw_protocol_tcp_get_all_stats();
                if (v128)
                  *(_DWORD *)(v128 + 100) = *((_DWORD *)v8 + 123);
              }
            }
            if (*v86)
            {
              sbflush((uint64_t)v86);
              *((_DWORD *)v8 + 97) = 0;
              v130 = v8[57][3];
              if (((_BYTE)v8[54] & 4) != 0)
              {
                if (v130)
                {
                  v132 = nw_protocol_tcp_get_all_stats();
                  if (v132)
                    *(_DWORD *)(v132 + 88) = *((_DWORD *)v8 + 97);
                }
              }
              else if (v130)
              {
                v131 = nw_protocol_tcp_get_all_stats();
                if (v131)
                  *(_DWORD *)(v131 + 100) = *((_DWORD *)v8 + 97);
              }
            }
            *((_WORD *)v8 + 188) |= 0x8000u;
            goto LABEL_285;
          }
LABEL_248:
          if ((v119 & 0x10) == 0)
            goto LABEL_249;
          goto LABEL_253;
        }
        if (((_DWORD)v8[54] & (_DWORD)v8[67] & 0x80) != 0 || (*((_BYTE *)v8 + 828) & 2) != 0)
          goto LABEL_218;
        __nwlog_tcp_log();
        *(_DWORD *)buf = 136446466;
        v148 = "sosetdefunct";
        v149 = 2082;
        *(_QWORD *)v150 = (char *)v8 + 604;
        v90 = (void *)_os_log_send_and_compose_impl();
        v164[0] = OS_LOG_TYPE_ERROR;
        v163[0] = 0;
        if (__nwlog_fault())
        {
          if (v164[0] == OS_LOG_TYPE_FAULT)
          {
            v91 = __nwlog_tcp_log();
            v92 = v164[0];
            if (os_log_type_enabled(v91, v164[0]))
            {
              *(_DWORD *)buf = 136446466;
              v148 = "sosetdefunct";
              v149 = 2082;
              *(_QWORD *)v150 = (char *)v8 + 604;
              v93 = "%{public}s %{public}s SB_DROP not set";
LABEL_213:
              v102 = v91;
LABEL_214:
              _os_log_impl(&dword_209FB3000, v102, v92, v93, buf, 0x16u);
            }
          }
          else if (v163[0])
          {
            v95 = (void *)__nw_create_backtrace_string();
            v96 = __nwlog_tcp_log();
            v92 = v164[0];
            log = v96;
            v97 = os_log_type_enabled(v96, v164[0]);
            if (v95)
            {
              if (v97)
              {
                *(_DWORD *)buf = 136446722;
                v148 = "sosetdefunct";
                v149 = 2082;
                *(_QWORD *)v150 = (char *)v8 + 604;
                *(_WORD *)&v150[8] = 2082;
                *(_QWORD *)v151 = v95;
                _os_log_impl(&dword_209FB3000, log, v92, "%{public}s %{public}s SB_DROP not set, dumping backtrace:%{public}s", buf, 0x20u);
              }
              free(v95);
              goto LABEL_215;
            }
            if (v97)
            {
              *(_DWORD *)buf = 136446466;
              v148 = "sosetdefunct";
              v149 = 2082;
              *(_QWORD *)v150 = (char *)v8 + 604;
              v93 = "%{public}s %{public}s SB_DROP not set, no backtrace";
              v102 = log;
              goto LABEL_214;
            }
          }
          else
          {
            v91 = __nwlog_tcp_log();
            v92 = v164[0];
            if (os_log_type_enabled(v91, v164[0]))
            {
              *(_DWORD *)buf = 136446466;
              v148 = "sosetdefunct";
              v149 = 2082;
              *(_QWORD *)v150 = (char *)v8 + 604;
              v93 = "%{public}s %{public}s SB_DROP not set, backtrace limit exceeded";
              goto LABEL_213;
            }
          }
        }
LABEL_215:
        if (v90)
          free(v90);
        v85 = v8 + 61;
        goto LABEL_218;
      }
      if ((*((_BYTE *)v8 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v145 = __nwlog_tcp_log();
          if (os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            v148 = "nw_protocol_tcp_updated_path";
            v149 = 2082;
            *(_QWORD *)v150 = (char *)v8 + 604;
            *(_WORD *)&v150[8] = 1024;
            *(_DWORD *)v151 = *(_DWORD *)v164;
            *(_WORD *)&v151[4] = 1024;
            *(_DWORD *)&v151[6] = *(_DWORD *)v163;
            _os_log_impl(&dword_209FB3000, v145, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Protocol event %d=%d", buf, 0x22u);
          }
        }
      }
      v49 = *(_DWORD *)v164;
      v50 = *(unsigned int *)v163;
      v51 = (unsigned int *)(v8 + 161);
LABEL_89:
      v52 = *v51;
      if ((unsigned __int16)*v51 == 0xFFFF)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v72 = __nwlog_obj();
          if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            v148 = "tcp_ctlinput";
            _os_log_impl(&dword_209FB3000, v72, OS_LOG_TYPE_DEBUG, "%{public}s PCB marked as WNT_STOPUSING, exiting early", buf, 0xCu);
          }
        }
        goto LABEL_162;
      }
      do
      {
        v53 = __ldxr(v51);
        if (v53 != v52)
        {
          __clrex();
          goto LABEL_89;
        }
      }
      while (__stxr(v52 + 1, v51));
      v54 = v8[132][1];
      v55 = **(_DWORD **)(v54 + 8);
      if (v55 == 30)
      {
        if (v8[162] == (_QWORD *)*MEMORY[0x24BDAE878] && v8[163] == *(_QWORD **)(MEMORY[0x24BDAE878] + 8))
        {
          v56 = __nwlog_obj();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v148 = "tcp_ctlinput";
            v57 = "%{public}s Protocol event reported for socket with faddr IN6ADDR_ANY";
            goto LABEL_141;
          }
LABEL_161:
          in_pcb_checkstate((uint64_t)(v8 + 104), 2, 0);
          goto LABEL_162;
        }
      }
      else
      {
        if (v55 != 2)
        {
          v70 = __nwlog_obj();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
          {
            v71 = **(_DWORD **)(v8[132][1] + 8);
            *(_DWORD *)buf = 136446466;
            v148 = "tcp_ctlinput";
            v149 = 1024;
            *(_DWORD *)v150 = v71;
            _os_log_impl(&dword_209FB3000, v70, OS_LOG_TYPE_ERROR, "%{public}s Protocol event reported for unknown address family %d", buf, 0x12u);
          }
          goto LABEL_161;
        }
        if (!*((_DWORD *)v8 + 327))
        {
          v56 = __nwlog_obj();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v148 = "tcp_ctlinput";
            v57 = "%{public}s Protocol event reported for socket with faddr INADDR_ANY";
LABEL_141:
            _os_log_impl(&dword_209FB3000, v56, OS_LOG_TYPE_ERROR, v57, buf, 0xCu);
            goto LABEL_161;
          }
          goto LABEL_161;
        }
      }
      if (v49 <= 0x15)
      {
        if (v49 == 5)
        {
          v69 = (void (*)(_QWORD *))tcp_mtudisc;
        }
        else if (*(_DWORD *)(sysctls + 168) && ((1 << v49) & 0x240C00) != 0)
        {
          v69 = (void (*)(_QWORD *))tcp_drop_syn_sent;
        }
        else
        {
          if (v49 == 4 || ((0xFC01FuLL >> v49) & 1) != 0)
            goto LABEL_161;
          v69 = (void (*)(_QWORD *))tcp_notify;
        }
        (*(void (**)(void))(v54 + 16))();
        v73 = v8[134];
        if ((int)v73[23] <= 0 && -v73[24] < 1)
        {
          if (v49 != 5
            || (tcp_handle_msgsize((uint64_t)v8[166], v50), (*((_BYTE *)v8 + 3068) & 2) == 0)
            || (unint64_t)v73[49] + 60 > v50)
          {
            v69(v8 + 104);
          }
        }
        else if (__nwlog_is_datapath_logging_enabled())
        {
          v74 = __nwlog_obj();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
          {
            v75 = v73[23];
            v76 = v73[24];
            *(_DWORD *)buf = 136446978;
            v148 = "tcp_ctlinput";
            v149 = 1024;
            *(_DWORD *)v150 = 0;
            *(_WORD *)&v150[4] = 1024;
            *(_DWORD *)&v150[6] = v75;
            *(_WORD *)v151 = 1024;
            *(_DWORD *)&v151[2] = v76;
            _os_log_impl(&dword_209FB3000, v74, OS_LOG_TYPE_DEBUG, "%{public}s ICMP response for ineligible TCP seq num (%d, una %d max %d)", buf, 0x1Eu);
          }
        }
        (*(void (**)(void))(v8[132][1] + 24))();
        goto LABEL_161;
      }
      goto LABEL_161;
    }
    is_traffic_mgmt_background = nw_path_is_traffic_mgmt_background();
    if (((is_traffic_mgmt_background ^ ((*((_BYTE *)v8 + 5308) & 8) == 0)) & 1) != 0)
    {
LABEL_46:
      effective_traffic_class = nw_path_get_effective_traffic_class();
      tcp_set_traffic_class((uint64_t)v8, effective_traffic_class);
      should_probe_connectivity = nw_path_should_probe_connectivity();
      if (((should_probe_connectivity ^ ((*((_BYTE *)v8 + 5308) & 0x10) == 0)) & 1) != 0)
      {
        if (!v9)
        {
LABEL_81:
          v18 = *((_DWORD *)v8 + 1306);
          goto LABEL_82;
        }
        goto LABEL_78;
      }
      v33 = should_probe_connectivity;
      if (tcp_perf_measurement)
      {
        if ((*((_BYTE *)v8 + 828) & 2) != 0)
          goto LABEL_62;
        if (!__nwlog_is_datapath_logging_enabled())
          goto LABEL_62;
        v34 = __nwlog_tcp_log();
        if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
          goto LABEL_62;
        v35 = "disabled";
        v148 = "nw_protocol_tcp_updated_path";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)v150 = (char *)v8 + 604;
        v149 = 2082;
        if (v33)
          v35 = "enabled";
        *(_WORD *)&v150[8] = 2082;
        *(_QWORD *)v151 = v35;
        v36 = v34;
        v37 = OS_LOG_TYPE_DEBUG;
      }
      else
      {
        if ((*((_BYTE *)v8 + 828) & 2) != 0)
          goto LABEL_62;
        v38 = __nwlog_tcp_log();
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
          goto LABEL_62;
        v39 = "disabled";
        v148 = "nw_protocol_tcp_updated_path";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)v150 = (char *)v8 + 604;
        v149 = 2082;
        if (v33)
          v39 = "enabled";
        *(_WORD *)&v150[8] = 2082;
        *(_QWORD *)v151 = v39;
        v36 = v38;
        v37 = OS_LOG_TYPE_INFO;
      }
      _os_log_impl(&dword_209FB3000, v36, v37, "%{public}s %{public}s probe connectivity %{public}s", buf, 0x20u);
LABEL_62:
      if (v33)
        v40 = 16;
      else
        v40 = 0;
      *((_DWORD *)v8 + 1327) = *((_DWORD *)v8 + 1327) & 0xFFFFFFEF | v40;
      if (!v9)
        goto LABEL_81;
      if (v33)
        v41 = 8;
      else
        v41 = 0;
      *(_DWORD *)(v9 + 1052) = *(_DWORD *)(v9 + 1052) & 0xFFFFFFF7 | v41;
      v42 = nw_tcp_access_globals((uint64_t)v8[132]);
      v43.n128_f64[0] = calculate_tcp_clock(v42);
      v44 = (unsigned int *)(v8 + 161);
LABEL_70:
      v45 = *v44;
      if ((unsigned __int16)*v44 == 0xFFFF)
      {
LABEL_78:
        if (*(unsigned __int8 *)(v9 + 1076) == 255 || *(_DWORD *)(v9 + 1024) == 255)
        {
          recommended_mss = nw_path_get_recommended_mss();
          *(_DWORD *)(v9 + 8) |= 0x8000u;
          *(_WORD *)(v9 + 72) = recommended_mss;
        }
        goto LABEL_81;
      }
      do
      {
        v46 = __ldxr(v44);
        if (v46 != v45)
        {
          __clrex();
          goto LABEL_70;
        }
      }
      while (__stxr(v45 + 1, v44));
      (*(void (**)(__n128))(v8[132][1] + 16))(v43);
      if (!v8[134] || in_pcb_checkstate((uint64_t)(v8 + 104), 2, 1) == 0xFFFF)
      {
LABEL_77:
        (*(void (**)(void))(v8[132][1] + 24))();
        goto LABEL_78;
      }
      v58 = v8[134];
      if (!v33)
      {
        if (!*((_BYTE *)v58 + 265) && ((*((_BYTE *)v58 + 740) & 0x80) != 0 || *((_BYTE *)v58 + 311)))
          tcp_keepalive_reset((uint64_t)v8[134]);
        if (v8[132][3])
        {
          v64 = nw_protocol_tcp_get_all_stats();
          if (v64)
            *(_BYTE *)(v64 + 96) &= ~1u;
        }
        if (v8[132][3])
        {
          v65 = nw_protocol_tcp_get_all_stats();
          if (v65)
            *(_BYTE *)(v65 + 96) &= ~2u;
        }
        if (v8[132][3])
        {
          v66 = nw_protocol_tcp_get_all_stats();
          if (v66)
            *(_BYTE *)(v66 + 96) &= ~4u;
        }
        if (v8[132][3])
        {
          v67 = nw_protocol_tcp_get_all_stats();
          if (v67)
            *(_BYTE *)(v67 + 96) &= ~8u;
        }
        goto LABEL_77;
      }
      v59 = nw_tcp_access_globals(*(_QWORD *)(v58[10] + 224));
      if (*((_DWORD *)v58 + 3) != 4
        || *((_DWORD *)v58 + 24) != *((_DWORD *)v58 + 23)
        || (v60 = v58[10], *(_QWORD *)(v60 + 448) != v9)
        || (v61 = *((_DWORD *)v58 + 185), (v61 & 0x80) != 0)
        || *((_BYTE *)v58 + 311))
      {
        v62 = 0;
        goto LABEL_106;
      }
      v139 = v59;
      *((_DWORD *)v58 + 185) = v61 | 0x80;
      *((_BYTE *)v58 + 311) = 0;
      *((_DWORD *)v58 + 10) = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(v60 + 224)) + 316)
                            - *((_DWORD *)v58 + 16)
                            + 10;
      if (*((_WORD *)v58 + 36) == 8)
      {
        *((_WORD *)v58 + 36) = 6;
        v140 = *(_DWORD *)(v139 + 316) + 10;
      }
      else
      {
        v140 = *(_DWORD *)(v139 + 316) + 10;
        if ((int)(*((_DWORD *)v58 + 17) - v140) < 1)
        {
LABEL_325:
          v62 = 1;
LABEL_106:
          if (v8[132][3])
          {
            v63 = nw_protocol_tcp_get_all_stats();
            if (v63)
              *(_BYTE *)(v63 + 96) |= 1u;
          }
          (*(void (**)(void))(v8[132][1] + 24))();
          if ((v62 & 1) != 0)
          {
            if ((*(_BYTE *)(v42 + 310) & 1) != 0)
            {
              *(_DWORD *)(v42 + 296) |= 1u;
            }
            else if ((*(_BYTE *)(v42 + 310) & 2) == 0 || *(_DWORD *)(v42 + 272) - *(_DWORD *)(v42 + 316) - 10 >= 1)
            {
              *(_DWORD *)(v42 + 292) = 1;
              *(_DWORD *)(v42 + 304) = 0;
              tcp_sched_timerlist(v42, 0xAu);
            }
          }
          goto LABEL_78;
        }
        *((_WORD *)v58 + 36) = 6;
        if (v140 <= 1)
          v140 = 1;
      }
      *((_DWORD *)v58 + 17) = v140;
      goto LABEL_325;
    }
    v20 = is_traffic_mgmt_background;
    if (tcp_perf_measurement)
    {
      if ((*((_BYTE *)v8 + 828) & 2) != 0)
        goto LABEL_36;
      if (!__nwlog_is_datapath_logging_enabled())
        goto LABEL_36;
      v21 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        goto LABEL_36;
      v22 = (*((_DWORD *)v8 + 1327) >> 3) & 1;
      *(_DWORD *)buf = 136446978;
      v148 = "nw_protocol_tcp_updated_path";
      v149 = 2082;
      *(_QWORD *)v150 = (char *)v8 + 604;
      *(_WORD *)&v150[8] = 1024;
      *(_DWORD *)v151 = v22;
      *(_WORD *)&v151[4] = 1024;
      *(_DWORD *)&v151[6] = v20;
      v23 = v21;
      v24 = OS_LOG_TYPE_DEBUG;
    }
    else
    {
      if ((*((_BYTE *)v8 + 828) & 2) != 0)
        goto LABEL_36;
      v25 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
        goto LABEL_36;
      v26 = (*((_DWORD *)v8 + 1327) >> 3) & 1;
      *(_DWORD *)buf = 136446978;
      v148 = "nw_protocol_tcp_updated_path";
      v149 = 2082;
      *(_QWORD *)v150 = (char *)v8 + 604;
      *(_WORD *)&v150[8] = 1024;
      *(_DWORD *)v151 = v26;
      *(_WORD *)&v151[4] = 1024;
      *(_DWORD *)&v151[6] = v20;
      v23 = v25;
      v24 = OS_LOG_TYPE_INFO;
    }
    _os_log_impl(&dword_209FB3000, v23, v24, "%{public}s %{public}s traffic_mgmt_background current %d new %d", buf, 0x22u);
LABEL_36:
    if (v20)
      v27 = 8;
    else
      v27 = 0;
    *((_DWORD *)v8 + 1327) = *((_DWORD *)v8 + 1327) & 0xFFFFFFF7 | v27;
    v28 = *((_DWORD *)v8 + 92);
    if (v20)
    {
      *((_DWORD *)v8 + 92) = v28 | 0x2000;
      v29 = nw_protocol_tcp_get_all_stats();
      if (v29)
      {
        v30 = *(_DWORD *)(v29 + 128) | 1;
LABEL_44:
        *(_DWORD *)(v29 + 128) = v30;
      }
    }
    else
    {
      *((_DWORD *)v8 + 92) = v28 & 0xFFFFDFFF;
      v29 = nw_protocol_tcp_get_all_stats();
      if (v29)
      {
        v30 = *(_DWORD *)(v29 + 128) & 0xFFFFFFFE;
        goto LABEL_44;
      }
    }
    set_tcp_stream_priority((uint64_t)v8);
    goto LABEL_46;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v148 = "nw_protocol_tcp_updated_path";
  v134 = (void *)_os_log_send_and_compose_impl();
  v164[0] = OS_LOG_TYPE_ERROR;
  v163[0] = 0;
  if (__nwlog_fault())
  {
    if (v164[0] == OS_LOG_TYPE_FAULT)
    {
      v135 = __nwlog_obj();
      v136 = v164[0];
      if (os_log_type_enabled(v135, v164[0]))
      {
        *(_DWORD *)buf = 136446210;
        v148 = "nw_protocol_tcp_updated_path";
        v137 = "%{public}s called with null parameters";
        goto LABEL_340;
      }
    }
    else if (v163[0])
    {
      v141 = (void *)__nw_create_backtrace_string();
      v135 = __nwlog_obj();
      v136 = v164[0];
      v142 = os_log_type_enabled(v135, v164[0]);
      if (v141)
      {
        if (v142)
        {
          *(_DWORD *)buf = 136446466;
          v148 = "nw_protocol_tcp_updated_path";
          v149 = 2082;
          *(_QWORD *)v150 = v141;
          _os_log_impl(&dword_209FB3000, v135, v136, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v141);
        goto LABEL_341;
      }
      if (v142)
      {
        *(_DWORD *)buf = 136446210;
        v148 = "nw_protocol_tcp_updated_path";
        v137 = "%{public}s called with null parameters, no backtrace";
        goto LABEL_340;
      }
    }
    else
    {
      v135 = __nwlog_obj();
      v136 = v164[0];
      if (os_log_type_enabled(v135, v164[0]))
      {
        *(_DWORD *)buf = 136446210;
        v148 = "nw_protocol_tcp_updated_path";
        v137 = "%{public}s called with null parameters, backtrace limit exceeded";
        goto LABEL_340;
      }
    }
  }
LABEL_341:
  if (v134)
    free(v134);
  return 0;
}

void nw_protocol_tcp_connected(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t stats_region;
  NSObject *remote_endpoint;
  const sockaddr *address;
  const sockaddr *v7;
  __int16 v8;
  int v9;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  const char *v19;
  int v20;
  void *v21;
  NSObject *v22;
  int v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  os_log_type_t v27;
  void *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  const char *v32;
  NSObject *v33;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_tcp_connected";
    v28 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v31 = __nwlog_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_tcp_connected";
        v32 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_97:
        _os_log_impl(&dword_209FB3000, v31, OS_LOG_TYPE_ERROR, v32, buf, 0xCu);
      }
    }
LABEL_98:
    if (v28)
      free(v28);
    return;
  }
  v2 = nw_protocol_downcast();
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_tcp_connected";
    v28 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v31 = __nwlog_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_tcp_connected";
        v32 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_97;
      }
    }
    goto LABEL_98;
  }
  v3 = v2;
  if ((*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v29 = __nwlog_tcp_log();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v35 = "nw_protocol_tcp_connected";
        v36 = 2082;
        v37 = v3 + 604;
        _os_log_impl(&dword_209FB3000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s got a connected event from the lower layer", buf, 0x16u);
      }
    }
  }
  if ((*(_DWORD *)(v3 + 5224) - 1) >= 2)
  {
    if ((*(_BYTE *)(v3 + 828) & 2) != 0)
      return;
    if (!__nwlog_is_datapath_logging_enabled())
      return;
    v12 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      return;
    *(_DWORD *)buf = 136446466;
    v35 = "nw_protocol_tcp_connected";
    v36 = 2082;
    v37 = v3 + 604;
    v11 = "%{public}s %{public}s skipping";
    goto LABEL_28;
  }
  if (*(_QWORD *)(v3 + 5216))
  {
    nw_protocol_get_identifier();
    stats_region = nw_path_flow_registration_get_stats_region();
    *(_QWORD *)(v3 + 4128) = stats_region;
    if (stats_region)
      goto LABEL_9;
    goto LABEL_8;
  }
  if (!*(_QWORD *)(v3 + 4128))
LABEL_8:
    *(_QWORD *)(v3 + 4128) = &tcpstat;
LABEL_9:
  *(_QWORD *)(v3 + 4136) = nw_path_flow_registration_get_advisory_region();
  remote_endpoint = nw_protocol_get_remote_endpoint();
  if (!remote_endpoint)
  {
    if ((*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      v15 = v3 + 604;
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_tcp_connected";
      v36 = 2082;
      v37 = v3 + 604;
      v16 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v18 = __nwlog_tcp_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v35 = "nw_protocol_tcp_connected";
          v36 = 2082;
          v37 = v15;
          v19 = "%{public}s %{public}s get_remote_endpoint failed, backtrace limit exceeded";
LABEL_52:
          _os_log_impl(&dword_209FB3000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0x16u);
        }
      }
LABEL_53:
      if (v16)
        free(v16);
    }
LABEL_55:
    nw_protocol_get_input_handler();
    nw_protocol_error();
    return;
  }
  address = nw_endpoint_get_address(remote_endpoint);
  if (!address)
  {
    if ((*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      v17 = v3 + 604;
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_tcp_connected";
      v36 = 2082;
      v37 = v3 + 604;
      v16 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v18 = __nwlog_tcp_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v35 = "nw_protocol_tcp_connected";
          v36 = 2082;
          v37 = v17;
          v19 = "%{public}s %{public}s nw_endpoint_get_address failed, backtrace limit exceeded";
          goto LABEL_52;
        }
      }
      goto LABEL_53;
    }
    goto LABEL_55;
  }
  if ((*(_BYTE *)(v3 + 5310) & 0x20) == 0)
  {
    v7 = address;
    microuptime(v3 + 5248);
    v8 = *(_WORD *)(v3 + 376);
    if ((v8 & 4) == 0)
    {
      v9 = *(_DWORD *)(v3 + 364);
      if ((*(_BYTE *)(v3 + 372) & 2) != 0)
      {
        if ((v9 & 8) == 0)
          goto LABEL_47;
      }
      else if ((v9 & 8) == 0)
      {
        if ((v8 & 6) != 0)
        {
LABEL_16:
          *(_DWORD *)(v3 + 5224) = 2;
          nw_protocol_tcp_input_available(a1);
          if (*MEMORY[0x24BDE08B8] != -1)
            dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_16);
          if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
            kdebug_trace();
          nw_protocol_get_input_handler();
          nw_protocol_connected();
          if ((*(_BYTE *)(v3 + 828) & 2) == 0)
          {
            v10 = __nwlog_tcp_log();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446466;
              v35 = "nw_protocol_tcp_connected";
              v36 = 2082;
              v37 = v3 + 604;
              v11 = "%{public}s %{public}s is already connected";
LABEL_40:
              v13 = v10;
              v14 = OS_LOG_TYPE_INFO;
              goto LABEL_41;
            }
          }
          return;
        }
        v23 = (*(uint64_t (**)(uint64_t, const sockaddr *))(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 40) + 24))(v3, v7);
        if (v23)
        {
          v20 = v23;
          *(_WORD *)(v3 + 376) &= ~4u;
          switch(v23)
          {
            case 1:
            case 6:
            case 13:
            case 49:
            case 50:
            case 51:
            case 60:
            case 61:
            case 64:
            case 65:
              v24 = __nwlog_obj();
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                v35 = "nw_protocol_tcp_connected";
                v36 = 1024;
                LODWORD(v37) = v20;
                _os_log_impl(&dword_209FB3000, v24, OS_LOG_TYPE_ERROR, "%{public}s tcp_trigger_connect failed %{darwin.errno}d", buf, 0x12u);
              }
              goto LABEL_55;
            case 37:
              goto LABEL_63;
            case 56:
              goto LABEL_16;
            default:
              goto LABEL_48;
          }
        }
        if ((*(_BYTE *)(v3 + 5308) & 0x20) == 0)
        {
          nw_protocol_tcp_input_available(a1);
          return;
        }
        if (tcp_perf_measurement)
        {
          if ((*(_BYTE *)(v3 + 828) & 2) != 0)
            goto LABEL_87;
          if (!__nwlog_is_datapath_logging_enabled())
            goto LABEL_87;
          v25 = __nwlog_tcp_log();
          if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
            goto LABEL_87;
          *(_DWORD *)buf = 136446466;
          v35 = "nw_protocol_tcp_connected";
          v36 = 2082;
          v37 = v3 + 604;
          v26 = v25;
          v27 = OS_LOG_TYPE_DEBUG;
        }
        else
        {
          if ((*(_BYTE *)(v3 + 828) & 2) != 0)
            goto LABEL_87;
          v30 = __nwlog_tcp_log();
          if (!os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
            goto LABEL_87;
          *(_DWORD *)buf = 136446466;
          v35 = "nw_protocol_tcp_connected";
          v36 = 2082;
          v37 = v3 + 604;
          v26 = v30;
          v27 = OS_LOG_TYPE_INFO;
        }
        _os_log_impl(&dword_209FB3000, v26, v27, "%{public}s %{public}s tfo preconnect", buf, 0x16u);
LABEL_87:
        if (*MEMORY[0x24BDE08B8] != -1)
          dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_16);
        if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
          kdebug_trace();
        nw_protocol_get_input_handler();
        nw_protocol_connected();
        return;
      }
      if ((*(_BYTE *)(v3 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
      {
        v33 = __nwlog_tcp_log();
        v20 = 102;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v35 = "tcp_trigger_connect";
          v36 = 2082;
          v37 = v3 + 604;
          v38 = 1024;
          LODWORD(v39) = 102;
          _os_log_impl(&dword_209FB3000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s defunct flow error (%d)", buf, 0x1Cu);
        }
        goto LABEL_48;
      }
LABEL_47:
      v20 = 102;
LABEL_48:
      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_tcp_connected";
      v36 = 1024;
      LODWORD(v37) = v20;
      v21 = (void *)_os_log_send_and_compose_impl();
      if ((__nwlog_fault() & 1) != 0)
      {
        v22 = __nwlog_obj();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v35 = "nw_protocol_tcp_connected";
          v36 = 1024;
          LODWORD(v37) = v20;
          _os_log_impl(&dword_209FB3000, v22, OS_LOG_TYPE_ERROR, "%{public}s tcp_trigger_connect failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }
      if (v21)
        free(v21);
      goto LABEL_55;
    }
LABEL_63:
    if ((*(_BYTE *)(v3 + 828) & 2) != 0)
      return;
    if (!__nwlog_is_datapath_logging_enabled())
      return;
    v12 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      return;
    *(_DWORD *)buf = 136446466;
    v35 = "nw_protocol_tcp_connected";
    v36 = 2082;
    v37 = v3 + 604;
    v11 = "%{public}s %{public}s is already connecting";
LABEL_28:
    v13 = v12;
    v14 = OS_LOG_TYPE_DEBUG;
LABEL_41:
    _os_log_impl(&dword_209FB3000, v13, v14, v11, buf, 0x16u);
    return;
  }
  if ((*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    v10 = __nwlog_tcp_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_tcp_connected";
      v36 = 2082;
      v37 = v3 + 604;
      v11 = "%{public}s %{public}s is accepting an inbound connection";
      goto LABEL_40;
    }
  }
}

uint64_t tcp_usr_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v12;
  int v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)a1;
  if (!*(_QWORD *)a1)
    return 22;
  if (*(_DWORD *)(v2 + 232) == 3)
  {
    v4 = *(unsigned __int16 *)(a1 + 378);
    if (*(_WORD *)(a1 + 378))
    {
      *(_WORD *)(a1 + 378) = 0;
      __nwlog_obj();
      v5 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      v15 = "tcp_usr_connect";
      v16 = 2082;
      v17 = a1 + 604;
      v18 = 1024;
      v19 = v4;
      v6 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v12 = __nwlog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          v15 = "tcp_usr_connect";
          v16 = 2082;
          v17 = v5;
          v18 = 1024;
          v19 = v4;
          _os_log_impl(&dword_209FB3000, v12, OS_LOG_TYPE_ERROR, "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d, backtrace limit exceeded", buf, 0x1Cu);
        }
      }
      if (v6)
        free(v6);
      return v4;
    }
    return 22;
  }
  v8 = *(_QWORD *)(v2 + 240);
  if ((*(_BYTE *)(a1 + 368) & 0x10) != 0 && (*(_BYTE *)(sysctls + 160) & 2) != 0)
    *(_DWORD *)(v8 + 740) |= 0x400000u;
  v9 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v9);
  if (*(_BYTE *)(a2 + 1) && (*(_BYTE *)(a2 + 1) != 2 || (*(_DWORD *)(a2 + 4) & 0xF0) == 0xE0))
    return 47;
  v4 = tcp_connect(v8, a2);
  if (!(_DWORD)v4)
  {
    v10 = *(_QWORD *)(*(_QWORD *)a1 + 240);
    (*(void (**)(_QWORD))(*(_QWORD *)(*(_QWORD *)(v10 + 80) + 2136) + 64))(*(_QWORD *)(a1 + 24));
    if ((*(_BYTE *)(a1 + 368) & 0x20) == 0)
      return tcp_output(v10);
    tcp_mss(v10, -1, 0);
    v4 = 0;
    v13 = *(_DWORD *)(v10 + 196);
    *(_DWORD *)(v10 + 140) = v13;
    *(_DWORD *)(v10 + 252) = v13;
  }
  return v4;
}

void nw_proto_tcp_notify_segmentation_offload(uint64_t a1)
{
  _BYTE *v1;
  _BYTE *v2;
  NSObject *v3;
  int tso_max_segment_size_v6;
  _BOOL4 v5;
  NSObject *v6;
  void *v7;
  NSObject *v8;
  const char *v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  _BYTE *v13;
  __int16 v14;
  _BOOL4 v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = (_BYTE *)nw_protocol_downcast();
    if (v1)
    {
      v2 = v1;
      if ((v1[5310] & 0x40) != 0)
      {
        if (*(_QWORD *)v1)
        {
          if ((*(_BYTE *)(*(_QWORD *)v1 + 2236) & 2) != 0)
            tso_max_segment_size_v6 = nw_path_get_tso_max_segment_size_v6();
          else
            tso_max_segment_size_v6 = nw_path_get_tso_max_segment_size_v4();
          v5 = tso_max_segment_size_v6 != 0;
        }
        else
        {
          v5 = 0;
        }
        if ((v2[828] & 2) == 0)
        {
          v6 = __nwlog_tcp_log();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446722;
            v11 = "nw_proto_tcp_notify_segmentation_offload";
            v12 = 2082;
            v13 = v2 + 604;
            v14 = 1024;
            v15 = v5;
            _os_log_impl(&dword_209FB3000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}s notifying segmentation offload value %d", buf, 0x1Cu);
          }
        }
        nw_protocol_get_output_handler();
        nw_protocol_notify_quiet();
      }
      else if ((v1[828] & 2) == 0)
      {
        v3 = __nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_proto_tcp_notify_segmentation_offload";
          v12 = 2082;
          v13 = v2 + 604;
          _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s segmentation offload notification not enabled", buf, 0x16u);
        }
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v11 = "nw_proto_tcp_notify_segmentation_offload";
    v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_proto_tcp_notify_segmentation_offload";
        v9 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_26;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v11 = "nw_proto_tcp_notify_segmentation_offload";
    v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_proto_tcp_notify_segmentation_offload";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_26:
        _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
      }
    }
  }
  if (v7)
    free(v7);
}

uint64_t tcp_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int v10;
  uint64_t v11;
  int *v12;
  int v13;
  unsigned int v14;
  int v16;
  uint64_t v17;
  uint64_t all_stats;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  const char *v27;
  _BYTE v29[22];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 80);
  v5 = *(_QWORD *)(v4 + 224);
  v6 = *(unsigned __int16 *)(v4 + 2226);
  if (!*(_WORD *)(v4 + 2226))
  {
    if (*(_DWORD *)(v4 + 492))
    {
LABEL_39:
      v24 = 22;
LABEL_58:
      tcp_drop(a1, v24);
      return v24;
    }
    *(_QWORD *)v29 = 0;
    *(_QWORD *)&v29[8] = 0;
    v24 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)(v4 + 2136) + 8))(v5, 0, 16, v29, 16);
    if ((_DWORD)v24)
      goto LABEL_58;
    if (*(_DWORD *)&v29[4])
      *(_DWORD *)(v4 + 492) = *(_DWORD *)&v29[4];
    v6 = *(unsigned __int16 *)&v29[2];
    *(_WORD *)(v4 + 2226) = *(_WORD *)&v29[2];
  }
  if (*(_BYTE *)a2 != 16)
  {
    v24 = 22;
    if (!v5)
      goto LABEL_54;
    goto LABEL_53;
  }
  if (*(_BYTE *)(a2 + 1) != 2)
  {
    v24 = 47;
    if (!v5)
      goto LABEL_54;
    goto LABEL_53;
  }
  v7 = *(unsigned __int16 *)(a2 + 2);
  if (!*(_WORD *)(a2 + 2))
  {
    v24 = 49;
    if (!v5)
      goto LABEL_54;
    goto LABEL_53;
  }
  v8 = *(_DWORD *)(a2 + 4);
  if (v8 == -1)
  {
    v25 = __nwlog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v29 = 136446210;
      *(_QWORD *)&v29[4] = "in_pcbladdr";
      _os_log_impl(&dword_209FB3000, v25, OS_LOG_TYPE_ERROR, "%{public}s INADDR_BROADCAST destination not supported", v29, 0xCu);
    }
    v24 = 61;
    if (!v5)
      goto LABEL_54;
LABEL_53:
    if ((*(_BYTE *)(v5 + 828) & 2) != 0)
      goto LABEL_58;
LABEL_54:
    v26 = __nwlog_tcp_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v27 = "";
      if (v5)
        v27 = (const char *)(v5 + 604);
      *(_DWORD *)v29 = 136446466;
      *(_QWORD *)&v29[4] = "tcp_connect";
      *(_WORD *)&v29[12] = 2082;
      *(_QWORD *)&v29[14] = v27;
      _os_log_impl(&dword_209FB3000, v26, OS_LOG_TYPE_ERROR, "%{public}s %{public}s ipv4 pcb local address lookup failed", v29, 0x16u);
    }
    goto LABEL_58;
  }
  if (*(_DWORD *)(v4 + 492) == v8 && v6 == v7)
    goto LABEL_39;
  *(_DWORD *)(v4 + 476) = v8;
  *(_WORD *)(v4 + 2224) = v7;
  if (!*(_DWORD *)(v4 + 460))
  {
    v10 = inp_calc_flowhash_flow_hash++;
    *(_DWORD *)(v4 + 460) = v10;
  }
  v11 = *(int *)(sysctls + 184);
  if (v11 <= *(unsigned __int8 *)(a1 + 262))
    LOBYTE(v11) = *(_BYTE *)(a1 + 262);
  v12 = (int *)(sysctls + 72);
  if ((*(_BYTE *)(v5 + 537) & 2) != 0)
    v12 = (int *)(v5 + 492);
  v13 = *v12;
  v14 = v11;
  if (v11 <= 0xDu && 0x10000 << v11 < v13)
  {
    do
    {
      LOBYTE(v11) = v14 + 1;
      if (v14 > 0xC)
        break;
      v16 = 0x20000 << v14++;
    }
    while (v16 < v13);
  }
  if (v11 >= 0xEu)
    LOBYTE(v11) = 14;
  *(_BYTE *)(a1 + 262) = v11;
  *(_WORD *)(v5 + 376) = *(_WORD *)(v5 + 376) & 0xFFF1 | 4;
  v17 = *(_QWORD *)(a1 + 1056);
  if (v17)
    ++*(_QWORD *)(v17 + 376);
  *(_DWORD *)(a1 + 12) = 2;
  if (*(_QWORD *)(v5 + 24))
  {
    all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats)
      *(_DWORD *)(all_stats + 136) = 2;
  }
  v19 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316);
  v20 = *(_DWORD *)(a1 + 680);
  if (!v20)
    v20 = *(_DWORD *)(sysctls + 188);
  *(_DWORD *)(a1 + 40) = v20 + v19 - *(_DWORD *)(a1 + 64);
  v21 = tcp_new_isn(a1);
  *(_DWORD *)(a1 + 112) = v21;
  *(_DWORD *)(a1 + 152) = v21;
  *(_DWORD *)(a1 + 96) = v21;
  *(_DWORD *)(a1 + 100) = v21;
  *(_DWORD *)(a1 + 92) = v21;
  if (!*(_QWORD *)(v5 + 24))
    return 0;
  v22 = nw_protocol_tcp_get_all_stats();
  if (v22)
    *(_DWORD *)(v22 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
  if (!*(_QWORD *)(v5 + 24))
    return 0;
  v23 = nw_protocol_tcp_get_all_stats();
  v24 = 0;
  if (v23)
    ++*(_DWORD *)(v23 + 60);
  return v24;
}

uint64_t tcp_new_isn(uint64_t a1)
{
  int v1;
  _BYTE *v5;
  const void *v6;
  CC_LONG v7;
  CC_SHA256_CTX v8;
  _QWORD v9[2];
  unsigned __int8 __buf[64];
  unsigned __int8 md[32];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v9[0] = 0;
  v9[1] = 0;
  v1 = *(_DWORD *)(a1 + 12);
  if (v1 == 10 || v1 == 1)
    return arc4random();
  memset(&v8, 0, sizeof(v8));
  microuptime((uint64_t)v9);
  arc4random_buf(__buf, 0x40uLL);
  CC_SHA256_Init(&v8);
  CC_SHA256_Update(&v8, __buf, 0x40u);
  CC_SHA256_Update(&v8, (const void *)(*(_QWORD *)(a1 + 80) + 2224), 2u);
  CC_SHA256_Update(&v8, (const void *)(*(_QWORD *)(a1 + 80) + 2226), 2u);
  v5 = *(_BYTE **)(a1 + 80);
  if ((v5[2236] & 2) != 0)
  {
    CC_SHA256_Update(&v8, v5 + 464, 0x10u);
    v6 = (const void *)(*(_QWORD *)(a1 + 80) + 480);
    v7 = 16;
  }
  else
  {
    CC_SHA256_Update(&v8, v5 + 476, 4u);
    v6 = (const void *)(*(_QWORD *)(a1 + 80) + 492);
    v7 = 4;
  }
  CC_SHA256_Update(&v8, v6, v7);
  CC_SHA256_Final(md, &v8);
  return (*(_DWORD *)md + 1048 * LODWORD(v9[0]));
}

uint64_t nw_protocol_tcp_register_notification(uint64_t a1, uint64_t a2, int a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  int v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  os_log_type_t v21;
  uint64_t v22;
  int v23;
  NSObject *v24;
  os_log_type_t v25;
  uint32_t v26;
  NSObject *v28;
  os_log_type_t v29;
  os_log_type_t type[4];
  _BYTE buf[24];
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v9 = nw_protocol_downcast();
    if (v9)
    {
      v10 = v9;
      v11 = 1;
      switch(a3)
      {
        case 0:
          __nwlog_obj();
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = nw_protocol_notification_type_to_string();
          v12 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (!__nwlog_fault())
            goto LABEL_63;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v13 = __nwlog_obj();
            v14 = type[0];
            if (!os_log_type_enabled(v13, type[0]))
              goto LABEL_63;
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = nw_protocol_notification_type_to_string();
            v15 = "%{public}s invalid registration notification: %{public}s";
          }
          else
          {
            v13 = __nwlog_obj();
            v14 = type[0];
            if (!os_log_type_enabled(v13, type[0]))
              goto LABEL_63;
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = nw_protocol_notification_type_to_string();
            v15 = "%{public}s invalid registration notification: %{public}s, backtrace limit exceeded";
          }
          goto LABEL_61;
        case 1:
          if (!a4)
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
            v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (!__nwlog_fault())
              goto LABEL_63;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v28 = __nwlog_obj();
              v29 = type[0];
              if (!os_log_type_enabled(v28, type[0]))
                goto LABEL_63;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
              v15 = "%{public}s called with null val";
            }
            else
            {
              v28 = __nwlog_obj();
              v29 = type[0];
              if (!os_log_type_enabled(v28, type[0]))
                goto LABEL_63;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
              v15 = "%{public}s called with null val, backtrace limit exceeded";
            }
            goto LABEL_95;
          }
          if (a5)
          {
            *(_DWORD *)type = *a4;
            *(_QWORD *)buf = 0x600000001;
            *(_QWORD *)&buf[8] = 517;
            *(_QWORD *)&buf[16] = type;
            v32 = 4;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 + 8) + 16))(v9, 1, v5);
            if ((~*(unsigned __int16 *)(v10 + 376) & 0x30) != 0 || (*(_BYTE *)(v10 + 365) & 0x20) != 0)
              v16 = tcp_ctloutput(v10, (uint64_t)buf);
            else
              v16 = 22;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v10 + 8) + 24))(v10, 1, v5);
            if (!v16)
            {
              v23 = *(_DWORD *)(v10 + 5308) | 0x40;
              goto LABEL_45;
            }
            __nwlog_obj();
            v19 = v10 + 604;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v10 + 604;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v32) = v16;
            v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (!__nwlog_fault())
              goto LABEL_63;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v20 = __nwlog_obj();
              v21 = type[0];
              if (!os_log_type_enabled(v20, type[0]))
                goto LABEL_63;
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v19;
              *(_WORD *)&buf[22] = 1024;
              LODWORD(v32) = v16;
              v15 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d";
            }
            else
            {
              v20 = __nwlog_obj();
              v21 = type[0];
              if (!os_log_type_enabled(v20, type[0]))
                goto LABEL_63;
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v19;
              *(_WORD *)&buf[22] = 1024;
              LODWORD(v32) = v16;
              v15 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d, backtrace limit exceeded";
            }
            goto LABEL_60;
          }
          __nwlog_obj();
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = nw_protocol_notification_type_to_string();
          v12 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (!__nwlog_fault())
            goto LABEL_63;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v13 = __nwlog_obj();
            v14 = type[0];
            if (!os_log_type_enabled(v13, type[0]))
              goto LABEL_63;
            goto LABEL_38;
          }
          v13 = __nwlog_obj();
          v14 = type[0];
          if (!os_log_type_enabled(v13, type[0]))
            goto LABEL_63;
          goto LABEL_57;
        case 2:
          if (!a4)
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
            v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (!__nwlog_fault())
              goto LABEL_63;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v28 = __nwlog_obj();
              v29 = type[0];
              if (!os_log_type_enabled(v28, type[0]))
                goto LABEL_63;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
              v15 = "%{public}s called with null val";
            }
            else
            {
              v28 = __nwlog_obj();
              v29 = type[0];
              if (!os_log_type_enabled(v28, type[0]))
                goto LABEL_63;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
              v15 = "%{public}s called with null val, backtrace limit exceeded";
            }
            goto LABEL_95;
          }
          if (a5)
          {
            *(_DWORD *)type = *a4;
            *(_QWORD *)buf = 0x600000001;
            *(_QWORD *)&buf[8] = 519;
            *(_QWORD *)&buf[16] = type;
            v32 = 4;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 + 8) + 16))(v9, 1, v5);
            if ((~*(unsigned __int16 *)(v10 + 376) & 0x30) != 0 || (*(_BYTE *)(v10 + 365) & 0x20) != 0)
              v17 = tcp_ctloutput(v10, (uint64_t)buf);
            else
              v17 = 22;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v10 + 8) + 24))(v10, 1, v5);
            if (!v17)
            {
              v23 = *(_DWORD *)(v10 + 5308) | 0x80;
LABEL_45:
              *(_DWORD *)(v10 + 5308) = v23;
              return 1;
            }
            __nwlog_obj();
            v22 = v10 + 604;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v10 + 604;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v32) = v17;
            v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (!__nwlog_fault())
              goto LABEL_63;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v20 = __nwlog_obj();
              v21 = type[0];
              if (!os_log_type_enabled(v20, type[0]))
                goto LABEL_63;
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v22;
              *(_WORD *)&buf[22] = 1024;
              LODWORD(v32) = v17;
              v15 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d";
            }
            else
            {
              v20 = __nwlog_obj();
              v21 = type[0];
              if (!os_log_type_enabled(v20, type[0]))
                goto LABEL_63;
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v22;
              *(_WORD *)&buf[22] = 1024;
              LODWORD(v32) = v17;
              v15 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d, backtrace limit exceeded";
            }
LABEL_60:
            v24 = v20;
            v25 = v21;
            v26 = 28;
          }
          else
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = nw_protocol_notification_type_to_string();
            v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (!__nwlog_fault())
              goto LABEL_63;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v13 = __nwlog_obj();
              v14 = type[0];
              if (!os_log_type_enabled(v13, type[0]))
                goto LABEL_63;
LABEL_38:
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = nw_protocol_notification_type_to_string();
              v15 = "%{public}s register notification for %{public}s called with zero length";
            }
            else
            {
              v13 = __nwlog_obj();
              v14 = type[0];
              if (!os_log_type_enabled(v13, type[0]))
                goto LABEL_63;
LABEL_57:
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = nw_protocol_notification_type_to_string();
              v15 = "%{public}s register notification for %{public}s called with zero length, backtrace limit exceeded";
            }
LABEL_61:
            v24 = v13;
            v25 = v14;
            v26 = 22;
          }
          break;
        case 3:
          *(_DWORD *)(v9 + 5308) |= 0x100u;
          return v11;
        case 4:
        case 5:
          return v11;
        case 14:
          *(_DWORD *)(v9 + 5308) |= 0x400000u;
          if ((*(_BYTE *)(v9 + 828) & 2) == 0)
          {
            v18 = __nwlog_tcp_log();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v10 + 604;
              _os_log_impl(&dword_209FB3000, v18, OS_LOG_TYPE_INFO, "%{public}s %{public}s segmentation_offload_notification enabled", buf, 0x16u);
            }
          }
          return v11;
        default:
          return 0;
      }
      goto LABEL_62;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
    v12 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_63;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type[0];
      if (!os_log_type_enabled(v28, type[0]))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
      v15 = "%{public}s called with null tcp";
    }
    else
    {
      v28 = __nwlog_obj();
      v29 = type[0];
      if (!os_log_type_enabled(v28, type[0]))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
      v15 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
    v12 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_63;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type[0];
      if (!os_log_type_enabled(v28, type[0]))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
      v15 = "%{public}s called with null protocol";
    }
    else
    {
      v28 = __nwlog_obj();
      v29 = type[0];
      if (!os_log_type_enabled(v28, type[0]))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_register_notification";
      v15 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
  }
LABEL_95:
  v24 = v28;
  v25 = v29;
  v26 = 12;
LABEL_62:
  _os_log_impl(&dword_209FB3000, v24, v25, v15, buf, v26);
LABEL_63:
  if (v12)
    free(v12);
  return 0;
}

uint64_t __nw_protocol_tcp_identifier_block_invoke()
{
  unk_253CF88BC = 0;
  unk_253CF88B4 = 0;
  dword_253CF88CC = 0;
  unk_253CF88C4 = 0;
  nw_protocol_tcp_identifier_identifier = 7365492;
  qword_253CF88D0 = 0x100000003;
  return nw_protocol_register_extended();
}

uint64_t nw_protocol_tcp_apply_parameters(uint64_t a1)
{
  uint64_t v1;
  uint64_t parameters;
  NSObject *v4;
  void *v5;
  int v6;
  uint64_t v7;
  void *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int ecn_mode;
  int v19;
  int v20;
  NSObject *v21;
  void *v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  int enable_l4s;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int effective_traffic_class;
  int v32;
  int v33;
  uint64_t v34;
  NSObject *v35;
  os_log_type_t v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  NSObject *v43;
  os_log_type_t v44;
  int keepalive_idle_time;
  int v47;
  int v48;
  uint64_t v49;
  int keepalive_interval;
  int v51;
  int v52;
  int v53;
  void *v54;
  NSObject *v55;
  os_log_type_t v56;
  const char *v57;
  void *v58;
  NSObject *v59;
  os_log_type_t v60;
  const char *v61;
  int v62;
  int v63;
  void *v64;
  NSObject *v65;
  os_log_type_t v66;
  const char *v67;
  int v68;
  int v69;
  void *v70;
  NSObject *v71;
  os_log_type_t v72;
  const char *v73;
  int v74;
  int v75;
  void *v76;
  NSObject *v77;
  os_log_type_t v78;
  const char *v79;
  int v80;
  int v81;
  void *v82;
  NSObject *v83;
  os_log_type_t v84;
  const char *v85;
  int v86;
  int v87;
  void *v88;
  NSObject *v89;
  os_log_type_t v90;
  const char *v91;
  int v92;
  int v93;
  void *v94;
  NSObject *v95;
  os_log_type_t v96;
  const char *v97;
  int v98;
  int v99;
  void *v100;
  NSObject *v101;
  os_log_type_t v102;
  const char *v103;
  int v104;
  int v105;
  void *v106;
  NSObject *v107;
  os_log_type_t v108;
  const char *v109;
  os_log_type_t v110[4];
  os_log_type_t v111;
  os_log_type_t v112[4];
  os_log_type_t v113[4];
  os_log_type_t v114[4];
  os_log_type_t type[4];
  _BYTE buf[24];
  uint64_t v117;
  uint64_t v118;

  v118 = *MEMORY[0x24BDAC8D0];
  nw_protocol_upcast();
  nw_protocol_get_input_handler();
  parameters = nw_protocol_get_parameters();
  if (!parameters)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
    v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault())
      goto LABEL_282;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v59 = __nwlog_obj();
      v60 = type[0];
      if (!os_log_type_enabled(v59, type[0]))
        goto LABEL_282;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      v61 = "%{public}s called with null parameters";
    }
    else
    {
      v59 = __nwlog_obj();
      v60 = type[0];
      if (!os_log_type_enabled(v59, type[0]))
        goto LABEL_282;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      v61 = "%{public}s called with null parameters, backtrace limit exceeded";
    }
    goto LABEL_281;
  }
  if (!*(_QWORD *)(a1 + 5208))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
    v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault())
      goto LABEL_282;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v59 = __nwlog_obj();
      v60 = type[0];
      if (!os_log_type_enabled(v59, type[0]))
        goto LABEL_282;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      v61 = "%{public}s called with null path";
    }
    else
    {
      v59 = __nwlog_obj();
      v60 = type[0];
      if (!os_log_type_enabled(v59, type[0]))
        goto LABEL_282;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      v61 = "%{public}s called with null path, backtrace limit exceeded";
    }
LABEL_281:
    _os_log_impl(&dword_209FB3000, v59, v60, v61, buf, 0xCu);
LABEL_282:
    if (v58)
      free(v58);
    return 0;
  }
  v4 = parameters;
  v5 = (void *)nw_parameters_copy_protocol_options_legacy();
  if (nw_parameters_get_discretionary())
    *(_DWORD *)(a1 + 5308) |= 0x200u;
  if (nw_tcp_options_get_no_delay())
  {
    *(_DWORD *)type = 1;
    *(_QWORD *)buf = 0x600000001;
    *(_QWORD *)&buf[8] = 1;
    *(_QWORD *)&buf[16] = type;
    v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
      v6 = tcp_ctloutput(a1, (uint64_t)buf);
    else
      v6 = 22;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v1);
    if (v6)
    {
      __nwlog_obj();
      v7 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v6;
      v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v7;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v6;
            v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d";
LABEL_130:
            v43 = v9;
            v44 = v10;
LABEL_131:
            _os_log_impl(&dword_209FB3000, v43, v44, v11, buf, 0x1Cu);
            goto LABEL_132;
          }
        }
        else
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v7;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v6;
            v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
      goto LABEL_132;
    }
  }
  if (nw_tcp_options_get_no_push())
  {
    *(_DWORD *)type = 1;
    *(_QWORD *)buf = 0x600000001;
    *(_QWORD *)&buf[8] = 4;
    *(_QWORD *)&buf[16] = type;
    v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
      v12 = tcp_ctloutput(a1, (uint64_t)buf);
    else
      v12 = 22;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v1);
    if (v12)
    {
      __nwlog_obj();
      v13 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v12;
      v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v13;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v12;
            v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }
        else
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v13;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v12;
            v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
LABEL_132:
      if (v8)
        free(v8);
      if (v5)
        nw_release(v5);
      return 0;
    }
  }
  if (nw_tcp_options_get_reduce_buffering())
  {
    *(_DWORD *)type = 0x4000;
    *(_QWORD *)buf = 0x600000001;
    *(_QWORD *)&buf[8] = 513;
    *(_QWORD *)&buf[16] = type;
    v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
      v14 = tcp_ctloutput(a1, (uint64_t)buf);
    else
      v14 = 22;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v1);
    if (v14)
    {
      __nwlog_obj();
      v15 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v14;
      v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v15;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v14;
            v11 = "%{public}s %{public}s tcp_set_notsent_lowat failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }
        else
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v15;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v14;
            v11 = "%{public}s %{public}s tcp_set_notsent_lowat failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
      goto LABEL_132;
    }
  }
  if (nw_tcp_options_get_disable_blackhole_detection())
  {
    *(_DWORD *)type = 1;
    *(_QWORD *)buf = 0x600000001;
    *(_QWORD *)&buf[8] = 521;
    *(_QWORD *)&buf[16] = type;
    v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
      v16 = tcp_ctloutput(a1, (uint64_t)buf);
    else
      v16 = 22;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v1);
    if (v16)
    {
      __nwlog_obj();
      v17 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v16;
      v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v17;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v16;
            v11 = "%{public}s %{public}s tcp_disable_blackhole_detection(so) %{darwin.errno}d";
            goto LABEL_130;
          }
        }
        else
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v17;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v16;
            v11 = "%{public}s %{public}s tcp_disable_blackhole_detection(so) %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
      goto LABEL_132;
    }
  }
  ecn_mode = nw_parameters_get_ecn_mode();
  if (!ecn_mode)
    goto LABEL_77;
  if (ecn_mode == 1)
    v19 = 1;
  else
    v19 = 2;
  *(_DWORD *)(a1 + 5304) = v19;
  *(_DWORD *)type = v19;
  *(_QWORD *)buf = 0x600000001;
  *(_QWORD *)&buf[8] = 528;
  *(_QWORD *)&buf[16] = type;
  v117 = 4;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v1);
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) == 0 && (*(_BYTE *)(a1 + 365) & 0x20) == 0)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v1);
    goto LABEL_56;
  }
  v20 = tcp_ctloutput(a1, (uint64_t)buf);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v1);
  if (v20)
  {
    if (v20 == 22)
    {
LABEL_56:
      v21 = __nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 22;
        _os_log_impl(&dword_209FB3000, v21, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d", buf, 0x12u);
      }
      goto LABEL_77;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v20;
    v22 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v23 = __nwlog_obj();
        v24 = type[0];
        if (!os_log_type_enabled(v23, type[0]))
          goto LABEL_75;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v20;
        v25 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d";
      }
      else
      {
        v23 = __nwlog_obj();
        v24 = type[0];
        if (!os_log_type_enabled(v23, type[0]))
          goto LABEL_75;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v20;
        v25 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_209FB3000, v23, v24, v25, buf, 0x12u);
    }
LABEL_75:
    if (v22)
      free(v22);
  }
LABEL_77:
  enable_l4s = nw_tcp_options_get_enable_l4s();
  if (enable_l4s != 2)
  {
    *(_DWORD *)type = enable_l4s == 1;
    *(_QWORD *)buf = 0x600000001;
    *(_QWORD *)&buf[8] = 539;
    *(_QWORD *)&buf[16] = type;
    v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
      v27 = tcp_ctloutput(a1, (uint64_t)buf);
    else
      v27 = 22;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v1);
    if (v27)
    {
      __nwlog_obj();
      v28 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v27;
      v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v28;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v27;
            v11 = "%{public}s %{public}s tcp_set_enable_l4s failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }
        else
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v28;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v27;
            v11 = "%{public}s %{public}s tcp_set_enable_l4s failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
      goto LABEL_132;
    }
  }
  if (nw_parameters_get_fast_open_enabled(v4)
    || nw_tcp_options_get_enable_fast_open()
    && (nw_protocol_upcast(), nw_protocol_get_input_handler(), (nw_protocol_input_handler_is_connection_flow() & 1) == 0))
  {
    *(_DWORD *)(a1 + 368) |= 0x30u;
    if (nw_tcp_options_get_no_fast_open_cookie())
      *(_DWORD *)(a1 + 368) |= 0x10000u;
    *(_DWORD *)(a1 + 5308) |= 0x8020u;
  }
  if (nw_tcp_options_get_fast_open_force_enable())
  {
    *(_DWORD *)type = 1;
    *(_QWORD *)buf = 0x600000001;
    *(_QWORD *)&buf[8] = 536;
    *(_QWORD *)&buf[16] = type;
    v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
      v29 = tcp_ctloutput(a1, (uint64_t)buf);
    else
      v29 = 22;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v1);
    if (v29)
    {
      __nwlog_obj();
      v30 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v29;
      v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v30;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v29;
            v11 = "%{public}s %{public}s tcp_set_fast_open_force_enable failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }
        else
        {
          v9 = __nwlog_obj();
          v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v30;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v117) = v29;
            v11 = "%{public}s %{public}s tcp_set_fast_open_force_enable failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
      goto LABEL_132;
    }
  }
  effective_traffic_class = nw_path_get_effective_traffic_class();
  v32 = tcp_set_traffic_class(a1, effective_traffic_class);
  if (v32)
  {
    v33 = v32;
    __nwlog_obj();
    v34 = a1 + 604;
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 604;
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v117) = v33;
    v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault())
      goto LABEL_132;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v35 = __nwlog_obj();
      v36 = type[0];
      if (!os_log_type_enabled(v35, type[0]))
        goto LABEL_132;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v34;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v33;
      v11 = "%{public}s %{public}s tcp_set_traffic_class failed %{darwin.errno}d";
    }
    else
    {
      v35 = __nwlog_obj();
      v36 = type[0];
      if (!os_log_type_enabled(v35, type[0]))
        goto LABEL_132;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v34;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v33;
      v11 = "%{public}s %{public}s tcp_set_traffic_class failed %{darwin.errno}d, backtrace limit exceeded";
    }
LABEL_178:
    v43 = v35;
    v44 = v36;
    goto LABEL_131;
  }
  if (nw_tcp_options_get_enable_background_traffic_management())
  {
    v37 = tcp_set_background_management(a1);
    if (v37)
    {
      v38 = v37;
      __nwlog_obj();
      v39 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v38;
      v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault())
        goto LABEL_132;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        v36 = type[0];
        if (!os_log_type_enabled(v35, type[0]))
          goto LABEL_132;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v39;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v117) = v38;
        v11 = "%{public}s %{public}s tcp_set_background_management failed %{darwin.errno}d";
      }
      else
      {
        v35 = __nwlog_obj();
        v36 = type[0];
        if (!os_log_type_enabled(v35, type[0]))
          goto LABEL_132;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v39;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v117) = v38;
        v11 = "%{public}s %{public}s tcp_set_background_management failed %{darwin.errno}d, backtrace limit exceeded";
      }
      goto LABEL_178;
    }
  }
  if (nw_tcp_options_get_enable_keepalive())
  {
    v40 = tcp_set_keepalive(a1, 1);
    if (v40)
    {
      v41 = v40;
      __nwlog_obj();
      v42 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v41;
      v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault())
        goto LABEL_132;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        v36 = type[0];
        if (!os_log_type_enabled(v35, type[0]))
          goto LABEL_132;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v42;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v117) = v41;
        v11 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d";
      }
      else
      {
        v35 = __nwlog_obj();
        v36 = type[0];
        if (!os_log_type_enabled(v35, type[0]))
          goto LABEL_132;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v42;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v117) = v41;
        v11 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d, backtrace limit exceeded";
      }
      goto LABEL_178;
    }
    keepalive_idle_time = nw_tcp_options_get_keepalive_idle_time();
    if (keepalive_idle_time)
    {
      v47 = tcp_set_keepalive_idle_time(a1, keepalive_idle_time);
      if (v47)
      {
        v48 = v47;
        __nwlog_obj();
        v49 = a1 + 604;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 604;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v117) = v48;
        v8 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v114[0] = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault())
          goto LABEL_132;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v35 = __nwlog_obj();
          v36 = type[0];
          if (!os_log_type_enabled(v35, type[0]))
            goto LABEL_132;
          goto LABEL_142;
        }
        v35 = __nwlog_obj();
        v36 = type[0];
        if (!os_log_type_enabled(v35, type[0]))
          goto LABEL_132;
        goto LABEL_171;
      }
    }
    keepalive_interval = nw_tcp_options_get_keepalive_interval();
    if (keepalive_interval)
    {
      v51 = tcp_set_keepalive_interval(a1, keepalive_interval);
      if (v51)
      {
        v48 = v51;
        __nwlog_obj();
        v49 = a1 + 604;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 604;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v117) = v48;
        v8 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v114[0] = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault())
          goto LABEL_132;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v35 = __nwlog_obj();
          v36 = type[0];
          if (!os_log_type_enabled(v35, type[0]))
            goto LABEL_132;
LABEL_142:
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v49;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v117) = v48;
          v11 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d";
          goto LABEL_178;
        }
        v35 = __nwlog_obj();
        v36 = type[0];
        if (!os_log_type_enabled(v35, type[0]))
          goto LABEL_132;
LABEL_171:
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v49;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v117) = v48;
        v11 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_178;
      }
    }
    *(_DWORD *)type = 0;
    *(_DWORD *)type = nw_tcp_options_get_keepalive_count();
    v52 = tcp_setsockopt(a1, 6, 258, (int *)type);
    if (v52)
    {
      v53 = v52;
      __nwlog_obj();
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v53;
      v54 = (void *)_os_log_send_and_compose_impl();
      v114[0] = OS_LOG_TYPE_ERROR;
      v113[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault())
        goto LABEL_180;
      if (v114[0] == OS_LOG_TYPE_FAULT)
      {
        v55 = __nwlog_obj();
        v56 = v114[0];
        if (!os_log_type_enabled(v55, v114[0]))
          goto LABEL_180;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 604;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v117) = v53;
        v57 = "%{public}s %{public}s tcp_setsockopt TCP_KEEPCNT failed %{darwin.errno}d";
      }
      else
      {
        v55 = __nwlog_obj();
        v56 = v114[0];
        if (!os_log_type_enabled(v55, v114[0]))
          goto LABEL_180;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 604;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v117) = v53;
        v57 = "%{public}s %{public}s tcp_setsockopt TCP_KEEPCNT failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_209FB3000, v55, v56, v57, buf, 0x1Cu);
LABEL_180:
      if (v54)
        free(v54);
    }
  }
  *(_DWORD *)type = 1;
  if (!nw_tcp_options_get_disable_ack_stretching())
    goto LABEL_193;
  v62 = tcp_setsockopt(a1, 6, 259, (int *)type);
  if (!v62)
    goto LABEL_193;
  v63 = v62;
  __nwlog_obj();
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = a1 + 604;
  *(_WORD *)&buf[22] = 1024;
  LODWORD(v117) = v63;
  v64 = (void *)_os_log_send_and_compose_impl();
  v114[0] = OS_LOG_TYPE_ERROR;
  v113[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v114[0] == OS_LOG_TYPE_FAULT)
    {
      v65 = __nwlog_obj();
      v66 = v114[0];
      if (!os_log_type_enabled(v65, v114[0]))
        goto LABEL_191;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v63;
      v67 = "%{public}s %{public}s tcp_setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d";
    }
    else
    {
      v65 = __nwlog_obj();
      v66 = v114[0];
      if (!os_log_type_enabled(v65, v114[0]))
        goto LABEL_191;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v63;
      v67 = "%{public}s %{public}s tcp_setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v65, v66, v67, buf, 0x1Cu);
  }
LABEL_191:
  if (v64)
    free(v64);
LABEL_193:
  if (!nw_tcp_options_get_no_options())
    goto LABEL_204;
  v68 = tcp_setsockopt(a1, 6, 8, (int *)type);
  if (!v68)
    goto LABEL_204;
  v69 = v68;
  __nwlog_obj();
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = a1 + 604;
  *(_WORD *)&buf[22] = 1024;
  LODWORD(v117) = v69;
  v70 = (void *)_os_log_send_and_compose_impl();
  v114[0] = OS_LOG_TYPE_ERROR;
  v113[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v114[0] == OS_LOG_TYPE_FAULT)
    {
      v71 = __nwlog_obj();
      v72 = v114[0];
      if (!os_log_type_enabled(v71, v114[0]))
        goto LABEL_202;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v69;
      v73 = "%{public}s %{public}s tcp_setsockopt TCP_NOOPT failed %{darwin.errno}d";
    }
    else
    {
      v71 = __nwlog_obj();
      v72 = v114[0];
      if (!os_log_type_enabled(v71, v114[0]))
        goto LABEL_202;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v69;
      v73 = "%{public}s %{public}s tcp_setsockopt TCP_NOOPT failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v71, v72, v73, buf, 0x1Cu);
  }
LABEL_202:
  if (v70)
    free(v70);
LABEL_204:
  if (!nw_tcp_options_get_no_timewait())
    goto LABEL_215;
  v74 = tcp_setsockopt(a1, 6, 520, (int *)type);
  if (!v74)
    goto LABEL_215;
  v75 = v74;
  __nwlog_obj();
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = a1 + 604;
  *(_WORD *)&buf[22] = 1024;
  LODWORD(v117) = v75;
  v76 = (void *)_os_log_send_and_compose_impl();
  v114[0] = OS_LOG_TYPE_ERROR;
  v113[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v114[0] == OS_LOG_TYPE_FAULT)
    {
      v77 = __nwlog_obj();
      v78 = v114[0];
      if (!os_log_type_enabled(v77, v114[0]))
        goto LABEL_213;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v75;
      v79 = "%{public}s %{public}s tcp_setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d";
    }
    else
    {
      v77 = __nwlog_obj();
      v78 = v114[0];
      if (!os_log_type_enabled(v77, v114[0]))
        goto LABEL_213;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v75;
      v79 = "%{public}s %{public}s tcp_setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v77, v78, v79, buf, 0x1Cu);
  }
LABEL_213:
  if (v76)
    free(v76);
LABEL_215:
  *(_DWORD *)v114 = nw_tcp_options_get_maximum_segment_size();
  if (!*(_DWORD *)v114)
    goto LABEL_226;
  v80 = tcp_setsockopt(a1, 6, 2, (int *)v114);
  if (!v80)
    goto LABEL_226;
  v81 = v80;
  __nwlog_obj();
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = a1 + 604;
  *(_WORD *)&buf[22] = 1024;
  LODWORD(v117) = v81;
  v82 = (void *)_os_log_send_and_compose_impl();
  v113[0] = OS_LOG_TYPE_ERROR;
  v112[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v113[0] == OS_LOG_TYPE_FAULT)
    {
      v83 = __nwlog_obj();
      v84 = v113[0];
      if (!os_log_type_enabled(v83, v113[0]))
        goto LABEL_224;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v81;
      v85 = "%{public}s %{public}s tcp_setsockopt TCP_MAXSEG failed %{darwin.errno}d";
    }
    else
    {
      v83 = __nwlog_obj();
      v84 = v113[0];
      if (!os_log_type_enabled(v83, v113[0]))
        goto LABEL_224;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v81;
      v85 = "%{public}s %{public}s tcp_setsockopt TCP_MAXSEG failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v83, v84, v85, buf, 0x1Cu);
  }
LABEL_224:
  if (v82)
    free(v82);
LABEL_226:
  *(_DWORD *)v113 = nw_tcp_options_get_retransmit_connection_drop_time();
  if (!*(_DWORD *)v113)
    goto LABEL_237;
  v86 = tcp_setsockopt(a1, 6, 128, (int *)v113);
  if (!v86)
    goto LABEL_237;
  v87 = v86;
  __nwlog_obj();
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = a1 + 604;
  *(_WORD *)&buf[22] = 1024;
  LODWORD(v117) = v87;
  v88 = (void *)_os_log_send_and_compose_impl();
  v112[0] = OS_LOG_TYPE_ERROR;
  v110[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v112[0] == OS_LOG_TYPE_FAULT)
    {
      v89 = __nwlog_obj();
      v90 = v112[0];
      if (!os_log_type_enabled(v89, v112[0]))
        goto LABEL_235;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v87;
      v91 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d";
    }
    else
    {
      v89 = __nwlog_obj();
      v90 = v112[0];
      if (!os_log_type_enabled(v89, v112[0]))
        goto LABEL_235;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v87;
      v91 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v89, v90, v91, buf, 0x1Cu);
  }
LABEL_235:
  if (v88)
    free(v88);
LABEL_237:
  if (!nw_tcp_options_get_retransmit_fin_drop())
    goto LABEL_248;
  v92 = tcp_setsockopt(a1, 6, 256, (int *)type);
  if (!v92)
    goto LABEL_248;
  v93 = v92;
  __nwlog_obj();
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = a1 + 604;
  *(_WORD *)&buf[22] = 1024;
  LODWORD(v117) = v93;
  v94 = (void *)_os_log_send_and_compose_impl();
  v112[0] = OS_LOG_TYPE_ERROR;
  v110[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v112[0] == OS_LOG_TYPE_FAULT)
    {
      v95 = __nwlog_obj();
      v96 = v112[0];
      if (!os_log_type_enabled(v95, v112[0]))
        goto LABEL_246;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v93;
      v97 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d";
    }
    else
    {
      v95 = __nwlog_obj();
      v96 = v112[0];
      if (!os_log_type_enabled(v95, v112[0]))
        goto LABEL_246;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v93;
      v97 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v95, v96, v97, buf, 0x1Cu);
  }
LABEL_246:
  if (v94)
    free(v94);
LABEL_248:
  *(_DWORD *)v112 = nw_tcp_options_get_connection_timeout();
  if (!*(_DWORD *)v112)
    goto LABEL_259;
  v98 = tcp_setsockopt(a1, 6, 32, (int *)v112);
  if (!v98)
    goto LABEL_259;
  v99 = v98;
  __nwlog_obj();
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = a1 + 604;
  *(_WORD *)&buf[22] = 1024;
  LODWORD(v117) = v99;
  v100 = (void *)_os_log_send_and_compose_impl();
  v110[0] = OS_LOG_TYPE_ERROR;
  v111 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v110[0] == OS_LOG_TYPE_FAULT)
    {
      v101 = __nwlog_obj();
      v102 = v110[0];
      if (!os_log_type_enabled(v101, v110[0]))
        goto LABEL_257;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v99;
      v103 = "%{public}s %{public}s tcp_setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d";
    }
    else
    {
      v101 = __nwlog_obj();
      v102 = v110[0];
      if (!os_log_type_enabled(v101, v110[0]))
        goto LABEL_257;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v99;
      v103 = "%{public}s %{public}s tcp_setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v101, v102, v103, buf, 0x1Cu);
  }
LABEL_257:
  if (v100)
    free(v100);
LABEL_259:
  *(_DWORD *)v110 = nw_tcp_options_get_persist_timeout();
  if (*(_DWORD *)v110)
  {
    v104 = tcp_setsockopt(a1, 6, 64, (int *)v110);
    if (v104)
    {
      v105 = v104;
      __nwlog_obj();
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v117) = v105;
      v106 = (void *)_os_log_send_and_compose_impl();
      v111 = OS_LOG_TYPE_ERROR;
      if (!__nwlog_fault())
        goto LABEL_268;
      if (v111 == OS_LOG_TYPE_FAULT)
      {
        v107 = __nwlog_obj();
        v108 = v111;
        if (!os_log_type_enabled(v107, v111))
          goto LABEL_268;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 604;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v117) = v105;
        v109 = "%{public}s %{public}s tcp_setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d";
      }
      else
      {
        v107 = __nwlog_obj();
        v108 = v111;
        if (!os_log_type_enabled(v107, v111))
          goto LABEL_268;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 604;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v117) = v105;
        v109 = "%{public}s %{public}s tcp_setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_209FB3000, v107, v108, v109, buf, 0x1Cu);
LABEL_268:
      if (v106)
        free(v106);
    }
  }
  if (nw_parameters_is_fallback())
    *(_DWORD *)(a1 + 5308) |= 0x400u;
  if (nw_parameters_get_server_mode())
  {
    *(_DWORD *)(a1 + 5308) |= 0x200000u;
    *(_DWORD *)(a1 + 372) |= 2u;
  }
  if (v5)
    nw_release(v5);
  return 1;
}

uint64_t tcp_ctloutput(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v5;
  int v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t result;
  unsigned int v12;
  int v13;
  int v14;
  void *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  void *v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  int v27;
  uint64_t all_stats;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  _DWORD *v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  int v52;
  unsigned int v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  unsigned int v72;
  size_t v73;
  uint8_t *p_src;
  int v75;
  int v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  int v80;
  int v81;
  int __src;
  char v83;
  os_log_type_t type;
  uint8_t buf[16];
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  uint64_t v110;
  uint64_t v111;

  v111 = *MEMORY[0x24BDAC8D0];
  __src = 0;
  v2 = *(_QWORD *)a1;
  if (!*(_QWORD *)a1)
    return 54;
  v5 = *(_DWORD *)(a2 + 4);
  if (v5 != 6)
  {
    if (v5 != 0xFFFF || ((v6 = *(_DWORD *)(a2 + 8), v6 != 4355) ? (v7 = v6 == 4357) : (v7 = 1), !v7))
    {
      v14 = **(_DWORD **)(*(_QWORD *)(a1 + 8) + 8);
      __nwlog_obj();
      if (v14 == 30)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "ip6_ctloutput";
        v15 = (void *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v83 = 0;
        if (!__nwlog_fault())
          goto LABEL_55;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v16 = __nwlog_obj();
          v17 = type;
          if (!os_log_type_enabled(v16, type))
            goto LABEL_55;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "ip6_ctloutput";
          v18 = "%{public}s currently unsupported";
        }
        else
        {
          v16 = __nwlog_obj();
          v17 = type;
          if (!os_log_type_enabled(v16, type))
            goto LABEL_55;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "ip6_ctloutput";
          v18 = "%{public}s currently unsupported, backtrace limit exceeded";
        }
      }
      else
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "ip_ctloutput";
        v15 = (void *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v83 = 0;
        if (!__nwlog_fault())
          goto LABEL_55;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v16 = __nwlog_obj();
          v17 = type;
          if (!os_log_type_enabled(v16, type))
            goto LABEL_55;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "ip_ctloutput";
          v18 = "%{public}s currently unsupported";
        }
        else
        {
          v16 = __nwlog_obj();
          v17 = type;
          if (!os_log_type_enabled(v16, type))
            goto LABEL_55;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "ip_ctloutput";
          v18 = "%{public}s currently unsupported, backtrace limit exceeded";
        }
      }
      _os_log_impl(&dword_209FB3000, v16, v17, v18, buf, 0xCu);
LABEL_55:
      if (v15)
        free(v15);
      return 0;
    }
  }
  v8 = *(_QWORD *)(v2 + 240);
  if (!v8)
    return 54;
  v9 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v9);
  if (!*(_DWORD *)a2)
  {
    v19 = *(_DWORD *)(a2 + 8);
    result = 42;
    if (v19 > 511)
    {
      switch(v19)
      {
        case 512:
          v110 = 0;
          v108 = 0u;
          v109 = 0u;
          v106 = 0u;
          v107 = 0u;
          v104 = 0u;
          v105 = 0u;
          v102 = 0u;
          v103 = 0u;
          v100 = 0u;
          v101 = 0u;
          v98 = 0u;
          v99 = 0u;
          v96 = 0u;
          v97 = 0u;
          v94 = 0u;
          v95 = 0u;
          v93 = 0u;
          v91 = 0u;
          v92 = 0u;
          v89 = 0u;
          v90 = 0u;
          v87 = 0u;
          v88 = 0u;
          *(_OWORD *)buf = 0u;
          v86 = 0u;
          tcp_fill_info(v8, *(_QWORD *)a1, a1, (uint64_t)buf);
          v23 = *(void **)(a2 + 16);
          v24 = *(_QWORD *)(a2 + 24);
          v25 = v24 < 408;
          v26 = 408;
          goto LABEL_189;
        case 513:
          if ((*(_BYTE *)(a1 + 366) & 8) == 0)
            goto LABEL_182;
          v20 = *(_DWORD *)(v8 + 320);
          goto LABEL_223;
        case 514:
          v20 = *(_DWORD *)(v8 + 740) & 8;
          goto LABEL_223;
        case 515:
          if ((*(_BYTE *)(v8 + 740) & 8) == 0)
            return 22;
          v61 = *(_QWORD *)(v8 + 768);
          if (!v61)
            return 22;
          *(_QWORD *)buf = *(_QWORD *)(v61 + 12);
          v23 = *(void **)(a2 + 16);
          v24 = *(_QWORD *)(a2 + 24);
          v25 = v24 < 8;
          v26 = 8;
LABEL_189:
          if (v25)
            v73 = v24;
          else
            v73 = v26;
          *(_QWORD *)(a2 + 24) = v73;
          p_src = buf;
          goto LABEL_228;
        case 516:
        case 518:
        case 522:
        case 523:
        case 524:
        case 525:
        case 526:
        case 527:
        case 531:
        case 532:
        case 533:
        case 534:
        case 535:
        case 537:
        case 538:
          return result;
        case 517:
          v20 = *(unsigned __int8 *)(v8 + 265);
          goto LABEL_223;
        case 519:
          v20 = *(unsigned __int8 *)(v8 + 266);
          goto LABEL_223;
        case 520:
          v20 = (*(_DWORD *)(v8 + 740) >> 11) & 1;
          goto LABEL_223;
        case 521:
          if ((*(_BYTE *)(v8 + 742) & 2) != 0)
            goto LABEL_183;
          goto LABEL_182;
        case 528:
          v62 = *(_DWORD *)(v8 + 348);
          if ((v62 & 0x400) != 0)
          {
LABEL_183:
            v20 = 1;
          }
          else
          {
            if ((v62 & 0x800) == 0)
            {
LABEL_182:
              __src = 0;
              break;
            }
            v20 = 2;
          }
LABEL_223:
          __src = v20;
          break;
        case 529:
          v20 = (*(_DWORD *)(v2 + 2232) >> 6) & 1;
          goto LABEL_223;
        case 530:
          if (*(_QWORD *)(a2 + 24) != 48)
            return 22;
          v86 = 0u;
          v87 = 0u;
          *(_OWORD *)buf = 0u;
          tcp_get_notify_ack_count(v8, (int *)buf);
          if (*(_DWORD *)&buf[4])
          {
            tcp_get_notify_ack_ids(v8, (uint64_t)buf);
            v63 = *(_QWORD *)(a2 + 24);
          }
          else
          {
            v63 = 48;
          }
          if (v63 >= 48)
            v73 = 48;
          else
            v73 = v63;
          *(_QWORD *)(a2 + 24) = v73;
          v23 = *(void **)(a2 + 16);
          p_src = buf;
          goto LABEL_228;
        case 536:
          v20 = HIBYTE(*(_DWORD *)(v8 + 740)) & 1;
          goto LABEL_223;
        case 539:
          v20 = (*(_DWORD *)(v8 + 740) >> 27) & 1;
          goto LABEL_223;
        default:
          if (v19 != 4357)
            return result;
          v20 = (*(_DWORD *)(a1 + 368) >> 13) & 1;
          goto LABEL_223;
      }
    }
    else
    {
      switch(v19)
      {
        case 1:
          v20 = *(_DWORD *)(v8 + 88) & 4;
          goto LABEL_223;
        case 2:
          v20 = *(_DWORD *)(v8 + 196);
          goto LABEL_223;
        case 3:
        case 5:
        case 6:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
          return result;
        case 4:
          v20 = *(_DWORD *)(v8 + 88) & 0x1000;
          goto LABEL_223;
        case 8:
          v20 = *(_DWORD *)(v8 + 88) & 8;
          goto LABEL_223;
        case 16:
          v58 = *(_DWORD *)(v8 + 676);
          if (!v58)
          {
            v59 = *(_DWORD *)(sysctls + 192);
LABEL_203:
            v20 = v59 / 1000;
            goto LABEL_223;
          }
LABEL_177:
          v60 = 274877907 * v58;
LABEL_178:
          __src = v60 >> 38;
          break;
        case 32:
          v33 = *(_DWORD *)(v8 + 680);
          goto LABEL_135;
        case 64:
          v33 = *(_DWORD *)(v8 + 312);
LABEL_135:
          v60 = 274877907 * v33;
          goto LABEL_178;
        default:
          switch(v19)
          {
            case 256:
              v20 = *(_DWORD *)(v8 + 740) & 1;
              goto LABEL_223;
            case 257:
              v58 = *(_DWORD *)(v8 + 684);
              if (v58)
                goto LABEL_177;
              v59 = *(_DWORD *)(sysctls + 196);
              goto LABEL_203;
            case 258:
              v20 = *(_DWORD *)(v8 + 688);
              if (!v20)
                v20 = *(_DWORD *)(sysctls + 200);
              goto LABEL_223;
            case 259:
              if ((*(_BYTE *)(v8 + 741) & 2) == 0)
                goto LABEL_182;
              goto LABEL_183;
            case 260:
              v20 = (*(_DWORD *)(v8 + 348) >> 10) & 1;
              goto LABEL_223;
            case 261:
              if (*(_DWORD *)(v8 + 12) != 1 || (*(_BYTE *)(sysctls + 160) & 1) == 0)
                return 45;
              v20 = (*(_DWORD *)(v8 + 740) >> 22) & 1;
              break;
            case 262:
              v90 = 0u;
              v91 = 0u;
              v88 = 0u;
              v89 = 0u;
              v86 = 0u;
              v87 = 0u;
              *(_OWORD *)buf = 0u;
              tcp_connection_fill_info((int32x2_t *)v8, *(_QWORD *)a1, a1, (uint64_t)buf);
              v23 = *(void **)(a2 + 16);
              v24 = *(_QWORD *)(a2 + 24);
              v25 = v24 < 112;
              v26 = 112;
              goto LABEL_189;
            default:
              if (v19 != 128)
                return result;
              v33 = *(_DWORD *)(v8 + 244);
              goto LABEL_135;
          }
          goto LABEL_223;
      }
    }
    v23 = *(void **)(a2 + 16);
    if (*(uint64_t *)(a2 + 24) >= 4)
      v73 = 4;
    else
      v73 = *(_QWORD *)(a2 + 24);
    *(_QWORD *)(a2 + 24) = v73;
    p_src = (uint8_t *)&__src;
LABEL_228:
    memcpy(v23, p_src, v73);
    return 0;
  }
  if (*(_DWORD *)a2 == 1)
  {
    v10 = *(_DWORD *)(a2 + 8);
    result = 42;
    if (v10 <= 512)
    {
      switch(v10)
      {
        case 1:
        case 4:
        case 8:
          if (v10 == 1)
          {
            v10 = 4;
          }
          else if (v10 == 4)
          {
            v10 = 4096;
          }
          else if (v10 != 8)
          {
            v10 = 0;
          }
          result = 0;
          if (**(_DWORD **)(a2 + 16))
            v75 = *(_DWORD *)(v8 + 88) | v10;
          else
            v75 = *(_DWORD *)(v8 + 88) & ~v10;
          *(_DWORD *)(v8 + 88) = v75;
          return result;
        case 2:
          v34 = **(_DWORD **)(a2 + 16);
          if (v34 < 1 || v34 > *(_DWORD *)(v8 + 196) || v34 + 40 < *(_DWORD *)(sysctls + 164))
            return 22;
          result = 0;
          *(_DWORD *)(v8 + 196) = v34;
          return result;
        case 3:
        case 5:
        case 6:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
          return result;
        case 16:
          v35 = **(_DWORD **)(a2 + 16);
          if (v35 > 0x418937)
            return 22;
          *(_DWORD *)(v8 + 676) = 1000 * v35;
          v36 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v8 + 80) + 224)) + 316);
          v37 = *(_DWORD *)(v8 + 676);
          if (!v37 || (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v8 + 80) + 224) + 372) & 8) == 0)
            v37 = *(_DWORD *)(sysctls + 192);
          goto LABEL_88;
        case 32:
          v38 = **(_DWORD **)(a2 + 16);
          if (v38 > 0x418937)
            return 22;
          *(_DWORD *)(v8 + 680) = 1000 * v38;
          if ((*(_DWORD *)(v8 + 12) - 1) > 2)
            return 0;
          v36 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v8 + 80) + 224)) + 316);
          v37 = *(_DWORD *)(v8 + 680);
          if (!v37)
            v37 = *(_DWORD *)(sysctls + 188);
LABEL_88:
          *(_DWORD *)(v8 + 40) = v37 + v36 - *(_DWORD *)(v8 + 64);
          goto LABEL_252;
        case 64:
          v39 = **(_DWORD **)(a2 + 16);
          if (v39 < 0)
            return 22;
          result = 0;
          *(_DWORD *)(v8 + 312) = 1000 * v39;
          return result;
        default:
          switch(v10)
          {
            case 256:
              goto LABEL_63;
            case 257:
              v12 = **(_DWORD **)(a2 + 16);
              if (v12 > 0x418937)
                return 22;
              *(_DWORD *)(v8 + 684) = 1000 * v12;
              if (*(_DWORD *)(v8 + 12) != 9)
                return 0;
              v13 = *(_DWORD *)(v8 + 688);
              if (v13)
              {
                if (v12)
                  goto LABEL_19;
              }
              else
              {
                v13 = *(_DWORD *)(sysctls + 200);
                if (v12)
                {
LABEL_19:
                  if (!(1000 * v12 * v13))
                    return 0;
                  goto LABEL_247;
                }
              }
              if (!(*(_DWORD *)(sysctls + 196) * v13))
                return 0;
LABEL_247:
              v79 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(v8 + 80) + 224));
              v80 = *(_DWORD *)(v8 + 688);
              if (!v80)
                v80 = *(_DWORD *)(sysctls + 200);
              v81 = *(_DWORD *)(v8 + 684);
              if (!v81)
                v81 = *(_DWORD *)(sysctls + 196);
              *(_DWORD *)(v8 + 44) = *(_DWORD *)(v79 + 316) + v81 * v80 - *(_DWORD *)(v8 + 64);
LABEL_252:
              tcp_check_timer_state(v8);
              return 0;
            case 258:
              v64 = **(_DWORD **)(a2 + 16);
              if (v64 < 0)
                return 22;
              *(_DWORD *)(v8 + 688) = v64;
              if (*(_DWORD *)(v8 + 12) != 9)
                return 0;
              if (!v64)
                v64 = *(_DWORD *)(sysctls + 200);
              v65 = *(_DWORD *)(v8 + 684);
              if (!v65)
                v65 = *(_DWORD *)(sysctls + 196);
              if (!(v65 * v64))
                return 0;
              goto LABEL_247;
            case 259:
              v66 = **(_DWORD **)(a2 + 16);
              if (v66 > 1)
                return 22;
              v67 = *(_DWORD *)(v8 + 740);
              result = 0;
              if (v66)
                v68 = v67 | 0x200;
              else
                v68 = v67 & 0xFFFFFDFF;
              *(_DWORD *)(v8 + 740) = v68;
              return result;
            case 260:
              v69 = *(_DWORD *)(v8 + 348) & 0xFFFFF3FF;
              result = 0;
              if (!**(_DWORD **)(a2 + 16))
                goto LABEL_216;
              goto LABEL_218;
            case 261:
              if ((*(_BYTE *)(sysctls + 160) & 1) == 0)
                return 45;
              v70 = **(_DWORD **)(a2 + 16);
              if (v70 > 1 || *(_DWORD *)(v8 + 12) != 1)
                return 22;
              v71 = *(_DWORD *)(v8 + 740);
              result = 0;
              if (v70)
                v72 = v71 | 0x400000;
              else
                v72 = v71 & 0xFFBFFFFF;
              *(_DWORD *)(v8 + 740) = v72;
              return result;
            default:
              if (v10 != 128)
                return result;
              v32 = **(_DWORD **)(a2 + 16);
              if (v32 < 0)
                return 22;
              result = 0;
              *(_DWORD *)(v8 + 244) = 1000 * v32;
              return result;
          }
      }
    }
    switch(v10)
    {
      case 513:
        v21 = **(_DWORD **)(a2 + 16);
        if (v21 < 0)
          return 22;
        v22 = *(_DWORD *)(a1 + 364);
        result = 0;
        if (v21)
        {
          *(_DWORD *)(a1 + 364) = v22 | 0x80000;
          *(_DWORD *)(v8 + 320) = v21;
        }
        else
        {
          *(_DWORD *)(a1 + 364) = v22 & 0xFFF7FFFF;
          *(_DWORD *)(v8 + 320) = 0;
        }
        return result;
      case 514:
        result = 0;
        if (**(_DWORD **)(a2 + 16))
        {
          *(_OWORD *)(v8 + 776) = 0u;
          *(_OWORD *)(v8 + 792) = 0u;
          *(_QWORD *)(v8 + 768) = v8 + 776;
          *(_DWORD *)(v8 + 788) = 6;
          *(_DWORD *)(v8 + 796) = 6 * *(_DWORD *)(v8 + 196);
          *(_DWORD *)(v8 + 740) |= 8u;
          *(_QWORD *)(v8 + 808) = 0;
        }
        else
        {
          *(_DWORD *)(v8 + 740) &= 0xFFFFFFF3;
        }
        return result;
      case 515:
        if ((*(_BYTE *)(v8 + 740) & 8) == 0)
          return 22;
        v40 = *(_DWORD **)(v8 + 768);
        if (!v40)
          return 22;
        v41 = *(unsigned int **)(a2 + 16);
        v43 = *v41;
        v42 = v41[1];
        if (v43)
        {
          if (v42)
            goto LABEL_97;
        }
        else
        {
          v43 = v40[3];
          if (v42)
          {
LABEL_97:
            if (v43 > v42)
              return 22;
            goto LABEL_242;
          }
        }
        v42 = v40[4];
        if (v43 > v42)
          return 22;
LABEL_242:
        result = 0;
        v40[3] = v43;
        v40[4] = v42;
        v78 = *(_DWORD *)(v8 + 196);
        v40[5] = v78 * v43;
        v40[6] = v78 * v42;
        return result;
      case 516:
      case 518:
      case 522:
      case 523:
      case 524:
      case 525:
      case 526:
      case 527:
      case 531:
      case 532:
      case 533:
      case 534:
      case 535:
      case 537:
      case 538:
        return result;
      case 517:
        v44 = **(_DWORD **)(a2 + 16);
        if (v44 > 0xA)
          return 22;
        if (!v44)
        {
          *(_BYTE *)(v8 + 265) = 0;
          tcp_keepalive_reset(v8);
          return 0;
        }
        result = 0;
        *(_BYTE *)(v8 + 265) = v44;
        return result;
      case 519:
        v45 = **(_DWORD **)(a2 + 16);
        if (v45 > 0xA)
          return 22;
        result = 0;
        *(_BYTE *)(v8 + 266) = v45;
        return result;
      case 520:
LABEL_63:
        if (v10 == 256)
          v30 = 1;
        else
          v30 = (v10 == 520) << 11;
        result = 0;
        if (**(_DWORD **)(a2 + 16))
          v31 = *(_DWORD *)(v8 + 740) | v30;
        else
          v31 = *(_DWORD *)(v8 + 740) & ~v30;
        *(_DWORD *)(v8 + 740) = v31;
        return result;
      case 521:
        v46 = **(_DWORD **)(a2 + 16);
        if (v46 > 1)
          return 22;
        v47 = *(_DWORD *)(v8 + 740);
        if (v46)
        {
          *(_DWORD *)(v8 + 740) = v47 | 0x20000;
          if ((*(_BYTE *)(v8 + 91) & 0x20) != 0 && *(_WORD *)(v8 + 698))
            tcp_pmtud_revert_segment_size(v8);
          return 0;
        }
        result = 0;
        *(_DWORD *)(v8 + 740) = v47 & 0xFFFDFFFF;
        return result;
      case 528:
        v48 = **(_DWORD **)(a2 + 16);
        if (v48 == 2)
        {
          result = 0;
          v69 = *(_DWORD *)(v8 + 348) & 0xFFFFF3FF;
LABEL_216:
          *(_DWORD *)(v8 + 348) = v69 | 0x800;
        }
        else if (v48 == 1)
        {
          result = 0;
          v69 = *(_DWORD *)(v8 + 348) & 0xFFFFF3FF;
LABEL_218:
          *(_DWORD *)(v8 + 348) = v69 | 0x400;
        }
        else
        {
          if (v48)
            return 22;
          result = 0;
          *(_DWORD *)(v8 + 348) &= 0xFFFFF3FF;
        }
        return result;
      case 529:
        v49 = **(_DWORD **)(a2 + 16);
        if (v49 < 0)
          return 22;
        v50 = *(_DWORD *)(v2 + 2232);
        result = 0;
        if (v49)
          v51 = v50 | 0x40;
        else
          v51 = v50 & 0xFFFFFFBF;
        *(_DWORD *)(v2 + 2232) = v51;
        return result;
      case 530:
        v52 = **(_DWORD **)(a2 + 16);
        if (v52 < 1)
          return 22;
        if (*(unsigned __int8 *)(v8 + 732) > 9u)
          return 59;
        v76 = *(_DWORD *)(a1 + 384);
        if (!v76)
          return 55;
        v77 = *(_QWORD *)(v8 + 1032);
        if (!v77)
        {
LABEL_214:
          tcp_add_notify_ack_marker(v8, v52);
          return 0;
        }
        while (*(_DWORD *)(v77 + 4) != v52 && *(_DWORD *)v77 != *(_DWORD *)(v8 + 92) + v76)
        {
          v77 = *(_QWORD *)(v77 + 8);
          if (!v77)
            goto LABEL_214;
        }
        return 22;
      case 536:
        v53 = **(_DWORD **)(a2 + 16);
        if (v53 > 1 || *(_DWORD *)(v8 + 12))
          return 22;
        v54 = *(_DWORD *)(v8 + 740);
        result = 0;
        if (v53)
          v55 = v54 | 0x1000000;
        else
          v55 = v54 & 0xFEFFFFFF;
        *(_DWORD *)(v8 + 740) = v55;
        return result;
      case 539:
        v56 = **(_DWORD **)(a2 + 16);
        if (v56 > 1 || *(_DWORD *)(v8 + 12))
          return 22;
        v57 = *(_DWORD *)(v8 + 740) & 0xE7FFFFFF;
        result = 0;
        if (v56 == 1)
          *(_DWORD *)(v8 + 740) = v57 | 0x8000000;
        else
          *(_DWORD *)(v8 + 740) = v57 | 0x10000000;
        return result;
      default:
        if (v10 == 4355)
        {
          inp_flush();
          return 0;
        }
        if (v10 != 4357)
          return result;
        v27 = *(_DWORD *)(a1 + 368);
        if (**(_DWORD **)(a2 + 16))
        {
          *(_DWORD *)(a1 + 368) = v27 | 0x2000;
          if (*(_QWORD *)(a1 + 24))
          {
            all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats)
            {
              v29 = *(_DWORD *)(all_stats + 128) | 1;
LABEL_207:
              *(_DWORD *)(all_stats + 128) = v29;
            }
          }
        }
        else
        {
          *(_DWORD *)(a1 + 368) = v27 & 0xFFFFDFFF;
          if (*(_QWORD *)(a1 + 24))
          {
            all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats)
            {
              v29 = *(_DWORD *)(all_stats + 128) & 0xFFFFFFFE;
              goto LABEL_207;
            }
          }
        }
        set_tcp_stream_priority(a1);
        break;
    }
  }
  return 0;
}

_QWORD *__tcp_publish_necp_if_stats_block_invoke(_QWORD *result, uint64_t a2)
{
  __int16 v2;
  __int16 v3;
  __int16 v4;
  __int16 v5;
  uint64_t v6;
  int v7;
  int v8;
  __int128 v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  __int16 v23;

  *(_QWORD *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v2 = (*(_BYTE *)(result[4] + 2236) & 2) == 0;
  *(_WORD *)(a2 + 96) = v2;
  v3 = *(_WORD *)(result[5] + 90) & 2 | v2;
  *(_WORD *)(a2 + 96) = v3;
  v4 = v3 | (4 * (*(_WORD *)(result[6] + 378) == 54));
  *(_WORD *)(a2 + 96) = v4;
  v5 = v4 | (8 * (*(_WORD *)(result[6] + 378) == 60));
  *(_WORD *)(a2 + 96) = v5;
  v6 = result[5];
  *(_DWORD *)(a2 + 92) = *(_DWORD *)(v6 + 348);
  v7 = *(_DWORD *)(v6 + 708);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(v6 + 712);
  *(_DWORD *)(a2 + 28) = v7;
  v8 = *(_DWORD *)(v6 + 996);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(v6 + 720);
  *(_DWORD *)(a2 + 36) = v8;
  *(_QWORD *)&v9 = *(_QWORD *)(v6 + 1000);
  *((_QWORD *)&v9 + 1) = *(_QWORD *)(v6 + 1016);
  *(_OWORD *)(a2 + 40) = v9;
  v10 = *(_DWORD *)(v6 + 200);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(v6 + 1024);
  *(_DWORD *)(a2 + 60) = v10;
  v11 = *(_DWORD *)(v6 + 208);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(v6 + 240);
  *(_DWORD *)(a2 + 68) = v11;
  v12 = *(_QWORD *)(*(_QWORD *)(v6 + 80) + 496);
  if (v12)
  {
    v12 = *(_QWORD *)(v12 + 1488);
    if (v12)
      LODWORD(v12) = *(_DWORD *)(v12 + 40);
  }
  *(_DWORD *)(a2 + 72) = v12;
  v13 = *(_QWORD *)(v6 + 768);
  if (v13)
  {
    *(_DWORD *)(a2 + 76) = *(_DWORD *)(v13 + 32);
    v14 = *(_DWORD *)(v13 + 36);
    if (v14)
      goto LABEL_9;
  }
  else
  {
    *(_DWORD *)(a2 + 76) = 0;
  }
  v14 = 0;
LABEL_9:
  *(_DWORD *)(a2 + 80) = v14;
  v15 = result[4];
  v16 = *(_QWORD **)(v15 + 248);
  v17 = v16[2];
  *(_QWORD *)a2 = *(_QWORD *)(result[6] + 744);
  *(_QWORD *)(a2 + 8) = v17;
  *(_QWORD *)(a2 + 16) = *v16;
  v18 = *(_QWORD *)(v15 + 448);
  if (v18)
  {
    v19 = (_QWORD *)(v18 + 504);
    v20 = (_QWORD *)(v18 + 120);
    if ((*(_BYTE *)(v15 + 2236) & 2) != 0)
      v21 = v19;
    else
      v21 = v20;
    v22 = v21[8];
    *(_DWORD *)(a2 + 84) = v21[9];
    *(_DWORD *)(a2 + 88) = v22;
    v23 = v5 | ((v21[17] != 0) << 8);
    *(_WORD *)(a2 + 96) = v23;
    *(_WORD *)(a2 + 96) = v23 | ((v21[16] != 0) << 9);
  }
  return result;
}

uint64_t __nw_protocol_tcp_wake_read_closed_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  const char *v3;
  NSObject *v4;
  const char *v5;
  int v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 40);
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 5224) < 3u)
  {
    if (!v1 || (*(_BYTE *)(v1 + 828) & 2) == 0)
    {
      v4 = __nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        v5 = "";
        if (v1)
          v5 = (const char *)(v1 + 604);
        v7 = 136446466;
        v8 = "nw_protocol_tcp_wake_read_closed_block_invoke";
        v9 = 2082;
        v10 = v5;
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s read closed", (uint8_t *)&v7, 0x16u);
      }
    }
    nw_protocol_get_input_handler();
    nw_protocol_input_finished_quiet();
  }
  else if (!v1 || (*(_BYTE *)(v1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v2 = __nwlog_tcp_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        v3 = "";
        if (v1)
          v3 = (const char *)(v1 + 604);
        v7 = 136446466;
        v8 = "nw_protocol_tcp_wake_read_closed_block_invoke";
        v9 = 2082;
        v10 = v3;
        _os_log_impl(&dword_209FB3000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v7, 0x16u);
      }
    }
  }
  return nw_protocol_release();
}

uint64_t sorflush(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void (*v4)(uint64_t);
  uint64_t result;

  v2 = a1 + 488;
  *(_WORD *)(a1 + 376) |= 0x20u;
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    v4 = *(void (**)(uint64_t))(v3 + 40);
    if (v4)
      v4(a1);
  }
  sblock(v2);
  *(_DWORD *)(a1 + 536) |= 0x80u;
  sbunlock(v2);
  sbflush(v2);
  *(_DWORD *)(a1 + 492) = 0;
  result = *(_QWORD *)(*(_QWORD *)(a1 + 560) + 24);
  if ((*(_BYTE *)(a1 + 536) & 4) != 0)
  {
    if (result)
    {
      result = nw_protocol_tcp_get_all_stats();
      if (result)
        *(_DWORD *)(result + 88) = *(_DWORD *)(a1 + 492);
    }
  }
  else if (result)
  {
    result = nw_protocol_tcp_get_all_stats();
    if (result)
      *(_DWORD *)(result + 100) = *(_DWORD *)(a1 + 492);
  }
  return result;
}

uint64_t nw_protocol_tcp_wake_read_closed(uint64_t a1)
{
  nw_protocol_tcp_log_summary(a1);
  nw_protocol_upcast();
  nw_protocol_retain();
  return nw_queue_context_async();
}

void tcp_close(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  char v4;
  int v5;
  uint64_t v6;
  uint64_t all_stats;
  _DWORD *v8;
  int v9;
  int v10;
  int v11;
  BOOL v12;
  unsigned int v13;
  _QWORD *v14;
  int v15;
  int v16;
  int v17;
  BOOL v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  NSObject *v28;
  const char *v29;
  uint64_t *v30;
  uint64_t v31;
  _QWORD *v32;
  void (*v33)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v34;
  uint64_t v35;
  void *v36;
  NSObject *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  void *v46;
  _QWORD *i;
  uint64_t v48;
  _QWORD *v49;
  unsigned int v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  _QWORD *v54;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *v59;
  _QWORD *v60;
  _QWORD *v61;
  _QWORD *v62;
  const char *v63;
  void *v64;
  NSObject *v65;
  os_log_type_t v66;
  const char *v67;
  uint64_t v68;
  void (**v69)(uint64_t);
  void (*v70)(uint64_t);
  void (*v71)(uint64_t);
  uint64_t v72;
  char v73;
  unsigned int v74;
  uint64_t v75;
  int v76;
  NSObject *v77;
  int v78;
  uint64_t v79;
  void (*v80)(uint64_t);
  uint64_t v81;
  void *v82;
  NSObject *v83;
  os_log_type_t v84;
  const char *v85;
  NSObject *v86;
  char *v87;
  const char *v88;
  NSObject *v89;
  void *v90;
  NSObject *v91;
  char *v92;
  const char *v93;
  os_log_type_t type[4];
  const char *v95;
  __int16 v96;
  uint64_t v97;
  __int16 v98;
  int v99;
  __int16 v100;
  _BYTE *v101;
  __int16 v102;
  int v103;
  _BYTE buf[24];
  char *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;

  v109 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 80);
  if (!*(_QWORD *)(v1 + 240))
    return;
  v3 = *(_QWORD *)(v1 + 224);
  v4 = *(_BYTE *)(v1 + 2236);
  tcp_canceltimers(a1);
  v5 = *(_DWORD *)(a1 + 88);
  if ((v5 & 0x8000000) != 0 || *(_BYTE *)(v1 + 2238))
  {
    *(_DWORD *)(a1 + 88) = v5 | 0x8000000;
    return;
  }
  if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v86 = __nwlog_tcp_log();
      if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
      {
        v87 = tcpstates[*(int *)(a1 + 12)];
        *(_QWORD *)&buf[4] = "tcp_close";
        v88 = "";
        *(_DWORD *)buf = 136446722;
        if (v3)
          v88 = (const char *)(v3 + 604);
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v88;
        *(_WORD *)&buf[22] = 2082;
        v105 = v87;
        _os_log_impl(&dword_209FB3000, v86, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state is %{public}s", buf, 0x20u);
      }
    }
  }
  v6 = *(_QWORD *)(v1 + 496);
  if (!v6)
  {
    if ((v4 & 2) != 0)
      goto LABEL_62;
    goto LABEL_15;
  }
  if ((v4 & 2) != 0)
  {
    if (!*(_DWORD *)(v6 + 208) && !*(_DWORD *)(v6 + 212) && !*(_DWORD *)(v6 + 216) && !*(_DWORD *)(v6 + 220))
      goto LABEL_62;
LABEL_25:
    v8 = *(_DWORD **)(v6 + 1488);
    if (!v8)
      goto LABEL_62;
    if (*(_BYTE *)(v6 + 1496))
    {
      free(v8);
      *(_QWORD *)(v6 + 1488) = 0;
      *(_BYTE *)(v6 + 1496) = 0;
      goto LABEL_62;
    }
    v9 = *(_DWORD *)(a1 + 200);
    v10 = 31 * v9;
    v11 = v8[16];
    if (v9)
      v12 = v11 == 0;
    else
      v12 = 1;
    v13 = (v11 + v10) >> 1;
    if (v12)
      v13 = v10;
    v8[16] = v13;
    v14 = *(_QWORD **)(a1 + 1056);
    if (v14)
      ++v14[54];
    v15 = *(_DWORD *)(a1 + 208);
    v16 = 62 * v15;
    v17 = v8[17];
    if (v15)
      v18 = v17 == 0;
    else
      v18 = 1;
    v19 = (v17 + v16) >> 1;
    if (v18)
      v19 = v16;
    v8[17] = v19;
    if (v14)
      ++v14[55];
    v20 = *(_DWORD *)(a1 + 148);
    v21 = v8[14];
    if (!v21)
      v21 = *(_DWORD *)(v3 + 388);
    v22 = v21 >> 1;
    if (v20)
    {
      v23 = v8[15];
      if (v23 || v20 < v22)
        goto LABEL_52;
    }
    else if (v22)
    {
      v23 = v8[15];
LABEL_52:
      v24 = *(_DWORD *)(a1 + 196);
      v25 = (v20 + (v24 >> 1)) / v24;
      if (v25 <= 2)
        v25 = 2;
      if ((v4 & 2) != 0)
        v26 = 60;
      else
        v26 = 40;
      v27 = v25 * (v24 + v26);
      if (v23)
        v27 = (v27 + v23) >> 1;
      v8[15] = v27;
      if (v14)
        ++v14[56];
    }
    *(_DWORD *)(a1 + 1964) = v8[10];
    tcp_release_route_heuristics(a1);
    *(_QWORD *)(v6 + 1488) = 0;
    goto LABEL_62;
  }
  if ((*(_DWORD *)(v6 + 1480) & 0x2000001) == 1 && *(_DWORD *)(v6 + 204))
    goto LABEL_25;
LABEL_15:
  *(_DWORD *)(a1 + 12) = 0;
  if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v91 = __nwlog_tcp_log();
      if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
      {
        v92 = tcpstates[*(int *)(a1 + 12)];
        *(_QWORD *)&buf[4] = "tcp_close";
        v93 = "";
        *(_DWORD *)buf = 136446722;
        if (v3)
          v93 = (const char *)(v3 + 604);
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v93;
        *(_WORD *)&buf[22] = 2082;
        v105 = v92;
        _os_log_impl(&dword_209FB3000, v91, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
      }
    }
  }
  if (*(_QWORD *)(v3 + 24))
  {
    all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats)
      *(_DWORD *)(all_stats + 136) = 0;
  }
LABEL_62:
  if (*(_BYTE *)(v1 + 2000) && (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0))
  {
    v28 = __nwlog_tcp_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      v29 = "";
      if (v3)
        v29 = (const char *)(v3 + 604);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "tcp_close";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v29;
      _os_log_impl(&dword_209FB3000, v28, OS_LOG_TYPE_ERROR, "%{public}s %{public}s rt_heur rt_heur_alloc unexpectly set", buf, 0x16u);
    }
  }
  v30 = *(uint64_t **)a1;
  if (*(_QWORD *)a1)
  {
    while (1)
    {
      v31 = *v30;
      if (*v30)
        *(_QWORD *)(v31 + 8) = v30[1];
      *(_QWORD *)v30[1] = v31;
      v32 = (_QWORD *)v30[4];
      if (v32)
        break;
LABEL_71:
      nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
      free(v30);
      v30 = *(uint64_t **)a1;
      if (!*(_QWORD *)a1)
        goto LABEL_89;
    }
    while (1)
    {
      while (1)
      {
        v33 = (void (*)(_QWORD *, uint64_t, uint64_t))v32[10];
        v34 = (_QWORD *)v32[4];
        if (!v33)
          break;
        v35 = v32[11];
        v32[10] = 0;
        v32[11] = 0;
        v33(v32, 1, v35);
        v32 = v34;
        if (!v34)
          goto LABEL_71;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_finalize";
      v36 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      if (!__nwlog_fault())
        goto LABEL_85;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v37 = __nwlog_obj();
        if (os_log_type_enabled(v37, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v38 = v37;
          v39 = type[0];
          v40 = "%{public}s called with null frame->finalizer";
LABEL_84:
          _os_log_impl(&dword_209FB3000, v38, v39, v40, buf, 0xCu);
        }
      }
      else
      {
        v41 = __nwlog_obj();
        if (os_log_type_enabled(v41, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v38 = v41;
          v39 = type[0];
          v40 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_84;
        }
      }
LABEL_85:
      if (v36)
        free(v36);
      v32 = v34;
      if (!v34)
        goto LABEL_71;
    }
  }
LABEL_89:
  *(_WORD *)(a1 + 224) = 0;
  v42 = *(_QWORD *)(a1 + 80);
  v43 = *(_QWORD *)(v42 + 224);
  if (!*(_QWORD *)(v43 + 24))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_copy_flow_registration";
    v82 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_196;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v83 = __nwlog_obj();
      v84 = type[0];
      if (!os_log_type_enabled(v83, type[0]))
        goto LABEL_196;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_copy_flow_registration";
      v85 = "%{public}s called with null protocol";
    }
    else
    {
      v83 = __nwlog_obj();
      v84 = type[0];
      if (!os_log_type_enabled(v83, type[0]))
        goto LABEL_196;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_copy_flow_registration";
      v85 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_195:
    _os_log_impl(&dword_209FB3000, v83, v84, v85, buf, 0xCu);
    goto LABEL_196;
  }
  v44 = nw_protocol_downcast();
  if (v44)
  {
    v45 = nw_retain(*(void **)(v44 + 5216));
    if (v45)
    {
      v46 = v45;
      *(_QWORD *)buf = MEMORY[0x24BDAC760];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = __tcp_publish_necp_if_stats_block_invoke;
      v105 = (char *)&__block_descriptor_tmp_15_102;
      v106 = v42;
      v107 = a1;
      v108 = v43;
      nw_path_flow_registration_access_interface_stats();
      nw_release(v46);
    }
    goto LABEL_93;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_tcp_copy_flow_registration";
  v82 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v83 = __nwlog_obj();
      v84 = type[0];
      if (!os_log_type_enabled(v83, type[0]))
        goto LABEL_196;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_copy_flow_registration";
      v85 = "%{public}s called with null tcp";
    }
    else
    {
      v83 = __nwlog_obj();
      v84 = type[0];
      if (!os_log_type_enabled(v83, type[0]))
        goto LABEL_196;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_copy_flow_registration";
      v85 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
    goto LABEL_195;
  }
LABEL_196:
  if (v82)
    free(v82);
LABEL_93:
  for (i = *(_QWORD **)(a1 + 544); i; i = *(_QWORD **)(a1 + 544))
  {
    v48 = i[2];
    if (*(_QWORD **)(a1 + 616) == i)
    {
      *(_QWORD *)(a1 + 616) = v48;
      v49 = (_QWORD *)i[3];
      if (v48)
      {
LABEL_96:
        *(_QWORD *)(v48 + 24) = v49;
        v49 = (_QWORD *)i[3];
        goto LABEL_99;
      }
    }
    else
    {
      v49 = (_QWORD *)i[3];
      if (v48)
        goto LABEL_96;
    }
    *(_QWORD *)(a1 + 552) = v49;
LABEL_99:
    *v49 = v48;
    nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
    free(i);
    --*(_WORD *)(a1 + 538);
    do
      v50 = __ldxr(tcp_sack_globalholes);
    while (__stxr(v50 - 1, tcp_sack_globalholes));
  }
  *(_OWORD *)(a1 + 616) = 0u;
  v51 = *(_QWORD **)(a1 + 1032);
  if (v51)
  {
    v52 = (_QWORD *)(a1 + 1032);
    do
    {
      v54 = (_QWORD *)*v52;
      v55 = (_QWORD *)(a1 + 1032);
      if ((_QWORD *)*v52 != v51)
      {
        do
        {
          v56 = v54;
          v54 = (_QWORD *)v54[1];
        }
        while (v54 != v51);
        v55 = v56 + 1;
      }
      v53 = (_QWORD *)v51[1];
      *v55 = v53;
      free(v51);
      v51 = v53;
    }
    while (v53);
    *(_QWORD *)(a1 + 1032) = 0;
    *(_BYTE *)(a1 + 732) = 0;
  }
  if (*(_QWORD *)(a1 + 768))
    *(_DWORD *)(a1 + 740) &= 0xFFFFFFF3;
  v57 = *(_QWORD **)(a1 + 952);
  if (v57)
  {
    v58 = (_QWORD *)(a1 + 952);
    do
    {
      v60 = (_QWORD *)*v58;
      v61 = (_QWORD *)(a1 + 952);
      if ((_QWORD *)*v58 != v57)
      {
        do
        {
          v62 = v60;
          v60 = (_QWORD *)v60[2];
        }
        while (v60 != v57);
        v61 = v62 + 2;
      }
      v59 = (_QWORD *)v57[2];
      *v61 = v59;
      nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
      free(v57);
      v57 = v59;
    }
    while (v59);
  }
  *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
  tcp_segs_sent_clean(a1, 1);
  if (!*(_QWORD *)(a1 + 632) || v3 && (*(_BYTE *)(v3 + 828) & 2) != 0)
    goto LABEL_132;
  __nwlog_tcp_log();
  if (v3)
    v63 = (const char *)(v3 + 604);
  else
    v63 = "";
  *(_DWORD *)buf = 136446466;
  *(_QWORD *)&buf[4] = "tcp_close";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = v63;
  v64 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v65 = __nwlog_tcp_log();
      v66 = type[0];
      if (!os_log_type_enabled(v65, type[0]))
        goto LABEL_130;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "tcp_close";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v63;
      v67 = "%{public}s %{public}s t_pktlist is not empty in tcp_close";
    }
    else
    {
      v65 = __nwlog_tcp_log();
      v66 = type[0];
      if (!os_log_type_enabled(v65, type[0]))
        goto LABEL_130;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "tcp_close";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v63;
      v67 = "%{public}s %{public}s t_pktlist is not empty in tcp_close, backtrace limit exceeded";
    }
    _os_log_impl(&dword_209FB3000, v65, v66, v67, buf, 0x16u);
  }
LABEL_130:
  if (v64)
    free(v64);
LABEL_132:
  *(_DWORD *)(a1 + 12) = 0;
  if (*(_QWORD *)(v3 + 24))
  {
    v68 = nw_protocol_tcp_get_all_stats();
    if (v68)
      *(_DWORD *)(v68 + 136) = 0;
  }
  *(_WORD *)(v3 + 376) = *(_WORD *)(v3 + 376) & 0xDFC1 | 0x2030;
  v69 = *(void (***)(uint64_t))(v3 + 32);
  if (v69)
  {
    if (!*v69 || ((*v69)(v3), (v69 = *(void (***)(uint64_t))(v3 + 32)) != 0))
    {
      v70 = v69[3];
      if (v70)
        v70(v3);
    }
  }
  if ((*(_BYTE *)(v3 + 374) & 1) != 0 && *(_DWORD *)(v1 + 232) != 3 && (*(_BYTE *)(v1 + 2232) & 1) == 0)
    socket_post_kev_msg_closed();
  v71 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 32);
  if (v71)
    v71(a1);
  if (*(_QWORD *)(a1 + 840))
    *(_QWORD *)(a1 + 840) = 0;
  *(_BYTE *)(a1 + 264) = 0;
  if (*(_QWORD *)(v3 + 24))
  {
    v72 = nw_protocol_tcp_get_all_stats();
    if (v72)
      *(_DWORD *)(v72 + 132) = *(unsigned __int8 *)(a1 + 264);
  }
  if (*(_DWORD *)(sysctls + 308) == 1
    && (~*(_DWORD *)(a1 + 88) & 0x180) == 0
    && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v3 + 369) & 0x40) != 0)
    && off_253CF8690)
  {
    off_253CF8690();
  }
  v73 = *(_BYTE *)(a1 + 988);
  if ((v73 & 2) != 0)
  {
    do
      v74 = __ldxr((unsigned int *)&tcp_tfo_halfcnt);
    while (__stxr(v74 - 1, (unsigned int *)&tcp_tfo_halfcnt));
    if (tcp_tfo_halfcnt < 0)
    {
      v89 = __nwlog_obj();
      os_log_type_enabled(v89, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_close";
      v90 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
      {
        __break(1u);
        return;
      }
      free(v90);
      v73 = *(_BYTE *)(a1 + 988);
    }
    *(_BYTE *)(a1 + 988) = v73 & 0xFD;
  }
  if ((*(_BYTE *)(v3 + 828) & 6) == 0)
  {
    buf[0] = 1;
    v75 = nw_log_ring_copyout();
    v76 = v75 + 1;
    if ((unint64_t)(v75 + 1) >= 3 && (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      v77 = __nwlog_tcp_log();
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
      {
        v78 = *(_DWORD *)(nw_tcp_access_globals(v3) + 316) - *(_DWORD *)(a1 + 1776);
        *(_DWORD *)type = 136447235;
        v95 = "tcp_close";
        v96 = 2082;
        v97 = v3 + 604;
        v98 = 1040;
        v99 = v76;
        v100 = 2097;
        v101 = buf;
        v102 = 1024;
        v103 = v78;
        _os_log_impl(&dword_209FB3000, v77, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s TCP Packets:\n%{private,network:tcp_packets}.*P\n\tLast packet %ums ago.", (uint8_t *)type, 0x2Cu);
      }
    }
  }
  in_pcbdetach(v1);
  *(_WORD *)(v3 + 376) = *(_WORD *)(v3 + 376) & 0xDFC1 | 0x2030;
  v79 = *(_QWORD *)(v3 + 32);
  if (v79)
  {
    v80 = *(void (**)(uint64_t))(v79 + 56);
    if (v80)
      v80(v3);
  }
  v81 = *(_QWORD *)(a1 + 1056);
  if (v81)
    ++*(_QWORD *)(v81 + 416);
}

void nw_protocol_tcp_disconnect(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  _BYTE *v4;
  NSObject *v5;
  NSObject *v6;
  void *v7;
  NSObject *v8;
  const char *v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = nw_protocol_downcast();
    if (v1)
    {
      v2 = v1;
      v3 = (_QWORD *)MEMORY[0x24BDE08B8];
      if (*MEMORY[0x24BDE08B8] != -1)
        dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_16);
      v4 = (_BYTE *)MEMORY[0x24BDE08B0];
      if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
      {
        kdebug_trace();
        if ((*(_BYTE *)(v2 + 828) & 2) != 0)
          goto LABEL_10;
      }
      else if ((*(_BYTE *)(v2 + 828) & 2) != 0)
      {
        goto LABEL_10;
      }
      v5 = __nwlog_tcp_log();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        v11 = "nw_protocol_tcp_disconnect";
        v12 = 2082;
        v13 = v2 + 604;
        _os_log_impl(&dword_209FB3000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s input protocol initiated disconnect", buf, 0x16u);
      }
LABEL_10:
      __nw_protocol_tcp_disconnect(v2);
      if ((*(_BYTE *)(v2 + 5308) & 2) != 0)
        return;
      if ((*(_BYTE *)(v2 + 828) & 2) == 0)
      {
        v6 = __nwlog_tcp_log();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_protocol_tcp_disconnect";
          v12 = 2082;
          v13 = v2 + 604;
          _os_log_impl(&dword_209FB3000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}s send disconnect to input protocol", buf, 0x16u);
        }
      }
      nw_protocol_get_input_handler();
      if (!nw_protocol_disconnected_is_valid())
        goto LABEL_20;
      if (*v3 == -1)
      {
        if (*v4)
          goto LABEL_17;
      }
      else
      {
        dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_16);
        if (*v4)
        {
LABEL_17:
          if (kdebug_is_enabled())
            kdebug_trace();
        }
      }
      nw_protocol_get_input_handler();
      nw_protocol_disconnected();
LABEL_20:
      *(_DWORD *)(v2 + 5308) |= 2u;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v11 = "nw_protocol_tcp_disconnect";
    v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_protocol_tcp_disconnect";
        v9 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_34;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v11 = "nw_protocol_tcp_disconnect";
    v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_protocol_tcp_disconnect";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_34:
        _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
      }
    }
  }
  if (v7)
    free(v7);
}

void __nw_protocol_tcp_disconnect(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  uint8_t buf[4];
  const char *v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a1 + 5224) < 3u)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      v3 = __nwlog_tcp_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        v5 = "__nw_protocol_tcp_disconnect";
        v6 = 2082;
        v7 = a1 + 604;
        _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s disconnect tcp", buf, 0x16u);
      }
    }
    *(_DWORD *)(a1 + 5224) = 3;
    nw_protocol_tcp_log_summary(a1);
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }
  else if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    v2 = __nwlog_tcp_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v5 = "__nw_protocol_tcp_disconnect";
      v6 = 2082;
      v7 = a1 + 604;
      _os_log_impl(&dword_209FB3000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }
}

void nw_protocol_tcp_log_summary(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  _BOOL4 v19;
  int v20;
  unsigned int v21;
  const char *v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  _BOOL4 v28;
  int v29;
  unsigned int v30;
  const char *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  const char *v36;
  int v37;
  int v38;
  int v39;
  int v40;
  NSObject *v41;
  const char *v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  int v69;
  int v70;
  uint64_t v71;
  _BOOL4 v72;
  _BOOL4 v73;
  uint64_t v74;
  uint8_t buf[4];
  const char *v76;
  __int16 v77;
  uint64_t v78;
  __int16 v79;
  int v80;
  __int16 v81;
  _QWORD *v82;
  __int16 v83;
  uint64_t v84;
  __int16 v85;
  int v86;
  __int16 v87;
  uint64_t v88;
  __int16 v89;
  int v90;
  __int16 v91;
  int v92;
  __int16 v93;
  unsigned int v94;
  __int16 v95;
  unsigned int v96;
  __int16 v97;
  int v98;
  __int16 v99;
  int v100;
  __int16 v101;
  int v102;
  __int16 v103;
  int v104;
  __int16 v105;
  int v106;
  __int16 v107;
  int v108;
  __int16 v109;
  _BOOL4 v110;
  __int16 v111;
  int v112;
  __int16 v113;
  int v114;
  __int16 v115;
  int v116;
  __int16 v117;
  int v118;
  __int16 v119;
  uint64_t v120;
  __int16 v121;
  uint64_t v122;
  __int16 v123;
  _BOOL4 v124;
  __int16 v125;
  int v126;
  __int16 v127;
  const char *v128;
  __int16 v129;
  int v130;
  __int16 v131;
  int v132;
  __int16 v133;
  int v134;
  __int16 v135;
  int v136;
  __int16 v137;
  int v138;
  __int16 v139;
  int v140;
  __int16 v141;
  int v142;
  __int16 v143;
  int v144;
  __int16 v145;
  int v146;
  __int16 v147;
  int v148;
  __int16 v149;
  int v150;
  __int16 v151;
  int v152;
  __int16 v153;
  int v154;
  _QWORD v155[5];

  v155[2] = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)a1)
  {
    v2 = *(_QWORD *)(*(_QWORD *)a1 + 240);
    if (v2)
    {
      v3 = *(_QWORD *)(a1 + 40);
      if ((*(_BYTE *)(v3 + 5309) & 0x40) != 0)
        return;
      if ((*(_DWORD *)(v2 + 1872) & 0xFFFFFFFE) != 2)
      {
        *(_DWORD *)(v2 + 204) = *(_DWORD *)(v2 + 200);
        *(_DWORD *)(v2 + 212) = *(_DWORD *)(v2 + 208);
      }
      v4 = *(_QWORD *)(*(_QWORD *)(v2 + 80) + 496);
      if (!v4 || (v5 = *(_QWORD *)(v4 + 1488)) == 0 || (v6 = *(_DWORD *)(v5 + 40)) == 0)
        v6 = *(_DWORD *)(v2 + 1964);
      v155[0] = 0;
      v155[1] = 0;
      nw_protocol_upcast();
      nw_protocol_get_flow_id();
      if ((*(_BYTE *)(a1 + 828) & 4) != 0)
      {
        if ((*(_BYTE *)(a1 + 828) & 2) != 0)
          goto LABEL_30;
        v7 = __nwlog_tcp_log();
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          goto LABEL_30;
        v74 = a1 + 604;
        v11 = *(_DWORD *)(v3 + 5308);
        v12 = *(_DWORD *)(v3 + 5296);
        v13 = v12 / 0x3E8;
        v72 = ((v11 >> 15) & 1) != 0 && (*(_WORD *)(v2 + 990) & 0x800) == 0;
        v60 = *(_QWORD *)(v3 + 5272);
        v56 = *(unsigned __int16 *)(v3 + 5300);
        v64 = *(_QWORD *)(v3 + 5280);
        v70 = *(unsigned __int16 *)(v3 + 5302);
        v66 = v12 % 0x3E8;
        v68 = (v11 >> 18) & 1;
        v62 = *(unsigned __int8 *)(v2 + 1868);
        v58 = *(unsigned __int8 *)(v2 + 266);
        v52 = *(unsigned __int8 *)(v2 + 265);
        v54 = (v11 >> 19) & 1;
        v50 = (v11 >> 20) & 1;
        v46 = HIWORD(v11) & 1;
        v48 = (v11 >> 15) & 1;
        v23 = *(_DWORD *)(v3 + 5304);
        v44 = (*(_DWORD *)(v2 + 348) >> 12) & 1;
        v24 = (v11 >> 17) & 1;
        v25 = nw_connection_client_accurate_ecn_state_to_string();
        v26 = nw_connection_server_accurate_ecn_state_to_string();
        v27 = *(_DWORD *)(v2 + 88);
        v28 = (~v27 & 0x180) == 0;
        v29 = (v27 >> 28) & 1;
        v30 = *(_DWORD *)(v2 + 1872) - 1;
        if (v30 > 2)
          v31 = "invalid";
        else
          v31 = off_24C2B2B68[v30];
        v37 = *(_DWORD *)(v2 + 200);
        v38 = *(_DWORD *)(v2 + 204);
        v39 = *(_DWORD *)(v2 + 208);
        v40 = *(_DWORD *)(v2 + 212);
        v114 = v23;
        v118 = v24;
        v120 = v25;
        v122 = v26;
        v126 = v29;
        v128 = v31;
        v130 = *(_DWORD *)(v2 + 240);
        v134 = ((1000 * v37) >> 5) % 1000;
        v138 = ((1000 * v39) >> 4) % 1000;
        v142 = ((1000 * v38) >> 5) % 1000;
        v146 = ((1000 * v40) >> 4) % 1000;
        v150 = *(_DWORD *)(v2 + 1884);
        v154 = *(_DWORD *)(v2 + 724);
        v76 = "nw_protocol_tcp_log_summary";
        v78 = v74;
        v79 = 1042;
        v80 = 16;
        v81 = 2098;
        v82 = v155;
        v84 = v60;
        v86 = v56;
        v83 = 2085;
        v87 = 2085;
        v88 = v64;
        v85 = 1026;
        v89 = 1026;
        v90 = v70;
        v92 = v68;
        v94 = v13;
        v96 = v66;
        v98 = v62;
        v100 = v58;
        v102 = v54;
        v104 = v52;
        v106 = v50;
        v108 = v48;
        v110 = v72;
        v112 = v46;
        v116 = v44;
        v119 = 2080;
        v121 = 2080;
        v124 = v28;
        v77 = 2082;
        v127 = 2082;
        v132 = v37 >> 5;
        v136 = v39 >> 4;
        v140 = v38 >> 5;
        v144 = v40 >> 4;
        v148 = v6;
        v152 = *(_DWORD *)(v2 + 728);
        v91 = 1024;
        v93 = 1024;
        v95 = 1024;
        v97 = 1024;
        v99 = 1024;
        v101 = 1024;
        v103 = 1024;
        v105 = 1024;
        v107 = 1024;
        v109 = 1024;
        v111 = 1024;
        v113 = 1024;
        v115 = 1024;
        v117 = 1024;
        v123 = 1024;
        v125 = 1024;
        v129 = 1024;
        v131 = 1024;
        v133 = 1024;
        v135 = 1024;
        v137 = 1024;
        v139 = 1024;
        v141 = 1024;
        v143 = 1024;
        v145 = 1024;
        v147 = 1024;
        v149 = 1024;
        v151 = 1024;
        v153 = 1024;
        *(_DWORD *)buf = 136456195;
        v36 = "%{public}s %{public}s \n"
              "\t[%{public,uuid_t}.16P %{sensitive}s:%{public}d<->%{sensitive}s:%{public}d]\n"
              "\tInit: %d, Conn_Time: %u.%03ums, SYNs: %u, WR_T: %d/%d, RD_T: %d/%d, TFO: %d/%d/%d, ECN: %d/%d/%d, Accura"
              "te ECN (client/server): %s/%s, TS: %d, TSO: %d\n"
              "\trtt_cache: %{public}s, rtt_upd: %d, rtt: %u.%03ums, rtt_var: %u.%03ums rtt_nc: %u.%03ums, rtt_var_nc: %u"
              ".%03ums base rtt: %ums\n"
              "\tACKs-compressed: %u, ACKs delayed: %u delayed ACKs sent: %u";
      }
      else
      {
        if ((*(_BYTE *)(a1 + 828) & 2) != 0)
          goto LABEL_30;
        v7 = __nwlog_tcp_log();
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          goto LABEL_30;
        v71 = a1 + 604;
        v8 = *(_DWORD *)(v3 + 5308);
        v9 = *(_DWORD *)(v3 + 5296);
        v10 = v9 / 0x3E8;
        v73 = ((v8 >> 15) & 1) != 0 && (*(_WORD *)(v2 + 990) & 0x800) == 0;
        v47 = *(_QWORD *)(v3 + 5272);
        v45 = *(unsigned __int16 *)(v3 + 5300);
        v43 = *(_QWORD *)(v3 + 5280);
        v53 = *(unsigned __int16 *)(v3 + 5302);
        v67 = v9 % 0x3E8;
        v65 = *(unsigned __int8 *)(v2 + 1868);
        v61 = (v8 >> 19) & 1;
        v63 = *(unsigned __int8 *)(v2 + 266);
        v57 = (v8 >> 20) & 1;
        v59 = *(unsigned __int8 *)(v2 + 265);
        v55 = (v8 >> 15) & 1;
        v69 = HIWORD(v8) & 1;
        v14 = *(_DWORD *)(v3 + 5304);
        v49 = (*(_DWORD *)(v2 + 348) >> 12) & 1;
        v51 = (v8 >> 18) & 1;
        v15 = (v8 >> 17) & 1;
        v16 = nw_connection_client_accurate_ecn_state_to_string();
        v17 = nw_connection_server_accurate_ecn_state_to_string();
        v18 = *(_DWORD *)(v2 + 88);
        v19 = (~v18 & 0x180) == 0;
        v20 = (v18 >> 28) & 1;
        v21 = *(_DWORD *)(v2 + 1872) - 1;
        if (v21 > 2)
          v22 = "invalid";
        else
          v22 = off_24C2B2B68[v21];
        v32 = *(_DWORD *)(v2 + 200);
        v33 = *(_DWORD *)(v2 + 204);
        v34 = *(_DWORD *)(v2 + 208);
        v35 = *(_DWORD *)(v2 + 212);
        v114 = v14;
        v118 = v15;
        v120 = v16;
        v122 = v17;
        v126 = v20;
        v128 = v22;
        v130 = *(_DWORD *)(v2 + 240);
        v134 = ((1000 * v32) >> 5) % 1000;
        v138 = ((1000 * v34) >> 4) % 1000;
        v142 = ((1000 * v33) >> 5) % 1000;
        v146 = ((1000 * v35) >> 4) % 1000;
        v150 = *(_DWORD *)(v2 + 1884);
        v154 = *(_DWORD *)(v2 + 724);
        v76 = "nw_protocol_tcp_log_summary";
        v78 = v71;
        v79 = 1042;
        v80 = 16;
        v81 = 2098;
        v82 = v155;
        v84 = v47;
        v86 = v45;
        v88 = v43;
        v85 = 1026;
        v89 = 1026;
        v90 = v53;
        v92 = v51;
        v94 = v10;
        v96 = v67;
        v98 = v65;
        v100 = v63;
        v102 = v61;
        v104 = v59;
        v106 = v57;
        v108 = v55;
        v110 = v73;
        v112 = v69;
        v116 = v49;
        v119 = 2080;
        v121 = 2080;
        v124 = v19;
        v77 = 2082;
        v83 = 2082;
        v87 = 2082;
        v127 = 2082;
        v132 = v32 >> 5;
        v136 = v34 >> 4;
        v140 = v33 >> 5;
        v144 = v35 >> 4;
        v148 = v6;
        v152 = *(_DWORD *)(v2 + 728);
        v91 = 1024;
        v93 = 1024;
        v95 = 1024;
        v97 = 1024;
        v99 = 1024;
        v101 = 1024;
        v103 = 1024;
        v105 = 1024;
        v107 = 1024;
        v109 = 1024;
        v111 = 1024;
        v113 = 1024;
        v115 = 1024;
        v117 = 1024;
        v123 = 1024;
        v125 = 1024;
        v129 = 1024;
        v131 = 1024;
        v133 = 1024;
        v135 = 1024;
        v137 = 1024;
        v139 = 1024;
        v141 = 1024;
        v143 = 1024;
        v145 = 1024;
        v147 = 1024;
        v149 = 1024;
        v151 = 1024;
        v153 = 1024;
        *(_DWORD *)buf = 136456194;
        v36 = "%{public}s %{public}s \n"
              "\t[%{public,uuid_t}.16P %{public}s:%{public}d<->%{public}s:%{public}d]\n"
              "\tInit: %d, Conn_Time: %u.%03ums, SYNs: %u, WR_T: %d/%d, RD_T: %d/%d, TFO: %d/%d/%d, ECN: %d/%d/%d, Accura"
              "te ECN (client/server): %s/%s, TS: %d, TSO: %d\n"
              "\trtt_cache: %{public}s, rtt_upd: %d, rtt: %u.%03ums, rtt_var: %u.%03ums rtt_nc: %u.%03ums, rtt_var_nc: %u"
              ".%03ums base rtt: %ums\n"
              "\tACKs-compressed: %u, ACKs delayed: %u delayed ACKs sent: %u";
      }
      _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_DEFAULT, v36, buf, 0x112u);
LABEL_30:
      *(_DWORD *)(v3 + 5308) |= 0x4000u;
      return;
    }
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      v41 = __nwlog_tcp_log();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        v76 = "nw_protocol_tcp_log_summary";
        v77 = 2082;
        v78 = a1 + 604;
        v42 = "%{public}s %{public}s tcp pcb is NULL";
        goto LABEL_38;
      }
    }
  }
  else if ((*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    v41 = __nwlog_tcp_log();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v76 = "nw_protocol_tcp_log_summary";
      v77 = 2082;
      v78 = a1 + 604;
      v42 = "%{public}s %{public}s socket inpcb is NULL";
LABEL_38:
      _os_log_impl(&dword_209FB3000, v41, OS_LOG_TYPE_INFO, v42, buf, 0x16u);
    }
  }
}

void nw_protocol_tcp_wake_disconnect(uint64_t a1)
{
  __nw_protocol_tcp_disconnect(*(_QWORD *)(a1 + 40));
}

uint64_t tcp_canceltimers(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t *v4;
  uint64_t *v5;
  BOOL v6;
  uint64_t v7;
  uint64_t result;

  v2 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 8) + 32))();
  v3 = *(_DWORD *)(a1 + 88);
  if ((v3 & 0x40000000) != 0)
  {
    v4 = *(uint64_t **)(v2 + 264);
    v5 = (uint64_t *)(a1 + 48);
    if (v4)
      v6 = v4 == v5;
    else
      v6 = 0;
    if (v6)
      *(_QWORD *)(v2 + 264) = *v4;
    v7 = *v5;
    if (*v5)
      *(_QWORD *)(v7 + 8) = *(_QWORD *)(a1 + 56);
    **(_QWORD **)(a1 + 56) = v7;
    *(_DWORD *)(a1 + 88) = v3 & 0xBFFFFFFF;
    --*(_DWORD *)(v2 + 280);
    *v5 = 0;
    *(_QWORD *)(a1 + 56) = 0;
  }
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(result + 316);
  *(_WORD *)(a1 + 72) = 8;
  return result;
}

uint64_t tcp_cubic_cleanup()
{
  unsigned int v0;

  do
    v0 = __ldaxr(dword_253CF8760);
  while (__stlxr(v0 - 1, dword_253CF8760));
  return 0;
}

void tcp_rledbat_cleanup()
{
  unsigned int v0;

  do
    v0 = __ldaxr((unsigned int *)&unk_253CF8680);
  while (__stlxr(v0 - 1, (unsigned int *)&unk_253CF8680));
}

uint64_t tcp_ledbat_cleanup()
{
  unsigned int v0;

  do
    v0 = __ldaxr(dword_253CF86D0);
  while (__stlxr(v0 - 1, dword_253CF86D0));
  return 0;
}

uint64_t nw_protocol_tcp_remove_input_handler(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  void *v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  void *v16;
  NSObject *v17;
  NSObject *v18;
  const char *v19;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_tcp_remove_input_handler";
    v16 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v18 = __nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_tcp_remove_input_handler";
        v19 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_41:
        _os_log_impl(&dword_209FB3000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0xCu);
      }
    }
LABEL_42:
    if (v16)
      free(v16);
    return 0;
  }
  v7 = nw_protocol_downcast();
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_tcp_remove_input_handler";
    v16 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v18 = __nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_tcp_remove_input_handler";
        v19 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_41;
      }
    }
    goto LABEL_42;
  }
  v8 = v7;
  if ((*(_BYTE *)(v7 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v17 = __nwlog_tcp_log();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_protocol_tcp_remove_input_handler";
        v23 = 2082;
        v24 = v8 + 604;
        _os_log_impl(&dword_209FB3000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s protocol upper layer initiated remove_input_handler", buf, 0x16u);
      }
    }
  }
  if (nw_protocol_get_output_handler() == a1)
    nw_protocol_set_output_handler();
  if (nw_protocol_get_input_handler() != a2)
  {
    if ((*(_BYTE *)(v8 + 828) & 2) == 0)
    {
      v9 = __nwlog_tcp_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_protocol_tcp_remove_input_handler";
        v23 = 2082;
        v24 = v8 + 604;
        _os_log_impl(&dword_209FB3000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s default_input_handler is different from the input_protocol", buf, 0x16u);
        return 0;
      }
    }
    return 0;
  }
  nw_protocol_set_input_handler();
  if (!a3)
    return 1;
  v11 = *(_DWORD *)(v8 + 5308);
  if ((v11 & 1) != 0)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_tcp_remove_input_handler";
    v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_tcp_remove_input_handler";
        _os_log_impl(&dword_209FB3000, v13, OS_LOG_TYPE_ERROR, "%{public}s tcp->release_is_delayed already set, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v12)
      free(v12);
    v11 = *(_DWORD *)(v8 + 5308);
  }
  *(_DWORD *)(v8 + 5308) = v11 | 1;
  v14 = *(_DWORD *)(v8 + 5224);
  if ((v14 - 1) >= 2)
  {
    if (!v14 || v14 == 4)
      nw_protocol_tcp_release(v8);
    return 1;
  }
  *(_DWORD *)(v8 + 5308) = v11 | 3;
  *(_DWORD *)(v8 + 5224) = 3;
  if ((*(_BYTE *)(v8 + 828) & 2) == 0)
  {
    v15 = __nwlog_tcp_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_tcp_remove_input_handler";
      v23 = 2082;
      v24 = v8 + 604;
      _os_log_impl(&dword_209FB3000, v15, OS_LOG_TYPE_INFO, "%{public}s %{public}s force closing tcp", buf, 0x16u);
    }
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v8 + 8) + 16))(v8, 1, v3);
  if ((~*(unsigned __int16 *)(v8 + 376) & 0x30) != 0 || (*(_BYTE *)(v8 + 365) & 0x20) != 0)
  {
    *(_DWORD *)(v8 + 16) = 0;
    *(_DWORD *)(v8 + 372) |= 0x80u;
  }
  v10 = 1;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v8 + 8) + 24))(v8, 1, v3);
  tcp_close_locked(v8);
  return v10;
}

uint64_t tcp_cubic_pre_fr(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  _DWORD *v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  unsigned int v17;

  *(_DWORD *)(*(_QWORD *)(result + 840) + 4) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 12) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 16) = 0;
  if ((*(_BYTE *)(result + 742) & 0x10) != 0)
  {
    v1 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    v3 = *(_DWORD *)(result + 980);
    if (v3 <= v1)
      v3 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    v2 = v3 >> (*(_DWORD *)(sysctls + 292) == 0);
  }
  else
  {
    v1 = 0;
    v2 = *(_DWORD *)(result + 144);
    if (v2 >= *(_DWORD *)(result + 140))
      v2 = *(_DWORD *)(result + 140);
  }
  *(_DWORD *)(result + 984) = v1;
  v4 = *(unsigned int **)(result + 840);
  v5 = v2;
  if (v2 < *v4)
  {
    v5 = v2;
    if (*(_DWORD *)(sysctls + 276))
      v5 = (float)(*(float *)&tcp_cubic_fast_convergence_factor * (float)v2);
  }
  *v4 = v5;
  v6 = *(unsigned int **)(result + 840);
  if (*v6)
  {
    v7 = v6[5];
    if (v7)
    {
LABEL_12:
      v8 = (*v6 - v7 + (v7 << 6)) >> 6;
      goto LABEL_15;
    }
  }
  else
  {
    *v6 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    v6 = *(unsigned int **)(result + 840);
    v7 = v6[5];
    if (v7)
      goto LABEL_12;
  }
  v8 = *v6;
LABEL_15:
  v6[5] = v8;
  v9 = *(_DWORD **)(result + 840);
  v10 = v9[6];
  v11 = v9[5] - *v9;
  if (v11 < 0)
    v11 = *v9 - v9[5];
  if (v10)
    v11 = (v11 - v10 + 16 * v10) >> 4;
  v9[6] = v11;
  v12 = *(_DWORD *)(result + 196);
  v13 = ((float)((float)v2 - (float)(*(float *)&tcp_cubic_backoff * (float)v2)) + (v12 >> 1)) / v12 * v12;
  v14 = 2 * v12;
  if (v13 > v14)
    v14 = v13;
  *(_DWORD *)(result + 148) = v14;
  v15 = *(_DWORD **)(*(_QWORD *)(result + 80) + 224);
  if (v15[97] > v14)
  {
    v16 = v15[108];
    if ((v16 & 0x400) != 0)
    {
      if (v15[109] > v14)
      {
        if (*(int *)(sysctls + 232) > (uint64_t)v14)
          v14 = *(_DWORD *)(sysctls + 232);
        v17 = *(_DWORD *)(sysctls + 120);
        if (v14 < v17)
          v17 = v14;
        v15[109] = v17;
      }
      v15[108] = v16 | 0x800;
    }
  }
  return result;
}

uint64_t __nw_protocol_tcp_wake_disconnected_block_invoke(uint64_t a1)
{
  uint64_t v2;
  int v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_DWORD *)(v2 + 5308);
  if ((v3 & 4) == 0)
  {
    nw_protocol_get_output_handler();
    nw_protocol_disconnect_quiet();
    v2 = *(_QWORD *)(a1 + 32);
    v3 = *(_DWORD *)(v2 + 5308);
  }
  if ((v3 & 1) != 0)
    nw_protocol_tcp_release(v2);
  return nw_protocol_release();
}

void nw_protocol_tcp_disconnected(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  int v4;
  void *v5;
  NSObject *v6;
  NSObject *v7;
  const char *v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = nw_protocol_downcast();
    if (v1)
    {
      v2 = v1;
      if ((*(_BYTE *)(v1 + 828) & 2) == 0)
      {
        v3 = __nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446466;
          v10 = "nw_protocol_tcp_disconnected";
          v11 = 2082;
          v12 = v2 + 604;
          _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s output protocol is disconnected", buf, 0x16u);
        }
      }
      v4 = *(_DWORD *)(v2 + 5308);
      if ((v4 & 4) != 0)
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
        {
          v6 = __nwlog_tcp_log();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v10 = "nw_protocol_tcp_disconnected";
            v11 = 2082;
            v12 = v2 + 604;
            _os_log_impl(&dword_209FB3000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
          }
        }
      }
      else
      {
        *(_DWORD *)(v2 + 5308) = v4 | 4;
        *(_OWORD *)(v2 + 4128) = 0u;
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v10 = "nw_protocol_tcp_disconnected";
    v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v10 = "nw_protocol_tcp_disconnected";
        v8 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v10 = "nw_protocol_tcp_disconnected";
    v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v10 = "nw_protocol_tcp_disconnected";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_21:
        _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_ERROR, v8, buf, 0xCu);
      }
    }
  }
  if (v5)
    free(v5);
}

uint64_t nw_protocol_tcp_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  int v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  unsigned int v18;
  uint64_t v19;
  NSObject *v20;
  os_log_type_t v21;
  uint32_t v22;
  NSObject *v24;
  os_log_type_t v25;
  os_log_type_t type[4];
  _BYTE buf[24];
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v5 = nw_protocol_downcast();
    if (v5)
    {
      v6 = v5;
      if (*(_DWORD *)(v5 + 5224) > 2u)
        return 1;
      v7 = 1;
      switch(a3)
      {
        case 0:
          __nwlog_obj();
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = nw_protocol_notification_type_to_string();
          v8 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (!__nwlog_fault())
            goto LABEL_49;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v9 = __nwlog_obj();
            v10 = type[0];
            if (!os_log_type_enabled(v9, type[0]))
              goto LABEL_49;
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = nw_protocol_notification_type_to_string();
            v11 = "%{public}s invalid registration notification: %{public}s";
          }
          else
          {
            v9 = __nwlog_obj();
            v10 = type[0];
            if (!os_log_type_enabled(v9, type[0]))
              goto LABEL_49;
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = nw_protocol_notification_type_to_string();
            v11 = "%{public}s invalid registration notification: %{public}s, backtrace limit exceeded";
          }
          v20 = v9;
          v21 = v10;
          v22 = 22;
          goto LABEL_48;
        case 1:
          if ((~*(unsigned __int16 *)(v5 + 376) & 0x30) == 0)
            goto LABEL_29;
          *(_DWORD *)type = 0;
          *(_QWORD *)buf = 0x600000001;
          *(_QWORD *)&buf[8] = 517;
          *(_QWORD *)&buf[16] = type;
          v28 = 4;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 + 8) + 16))(v5, 1, v3);
          if ((~*(unsigned __int16 *)(v6 + 376) & 0x30) != 0 || (*(_BYTE *)(v6 + 365) & 0x20) != 0)
            v12 = tcp_ctloutput(v6, (uint64_t)buf);
          else
            v12 = 22;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 + 8) + 24))(v6, 1, v3);
          if (!v12)
          {
LABEL_29:
            v18 = *(_DWORD *)(v6 + 5308) & 0xFFFFFFBF;
            goto LABEL_37;
          }
          __nwlog_obj();
          v15 = v6 + 604;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v6 + 604;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v28) = v12;
          v8 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (!__nwlog_fault())
            goto LABEL_49;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v16 = __nwlog_obj();
            v17 = type[0];
            if (!os_log_type_enabled(v16, type[0]))
              goto LABEL_49;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v15;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v28) = v12;
            v11 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d";
          }
          else
          {
            v16 = __nwlog_obj();
            v17 = type[0];
            if (!os_log_type_enabled(v16, type[0]))
              goto LABEL_49;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v15;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v28) = v12;
            v11 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d, backtrace limit exceeded";
          }
          goto LABEL_47;
        case 2:
          if ((~*(unsigned __int16 *)(v5 + 376) & 0x30) == 0)
            goto LABEL_36;
          *(_DWORD *)type = 0;
          *(_QWORD *)buf = 0x600000001;
          *(_QWORD *)&buf[8] = 519;
          *(_QWORD *)&buf[16] = type;
          v28 = 4;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 + 8) + 16))(v5, 1, v3);
          if ((~*(unsigned __int16 *)(v6 + 376) & 0x30) != 0 || (*(_BYTE *)(v6 + 365) & 0x20) != 0)
            v13 = tcp_ctloutput(v6, (uint64_t)buf);
          else
            v13 = 22;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 + 8) + 24))(v6, 1, v3);
          if (!v13)
          {
LABEL_36:
            v18 = *(_DWORD *)(v6 + 5308) & 0xFFFFFF7F;
LABEL_37:
            *(_DWORD *)(v6 + 5308) = v18;
            return 1;
          }
          __nwlog_obj();
          v19 = v6 + 604;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v6 + 604;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v28) = v13;
          v8 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (!__nwlog_fault())
            goto LABEL_49;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v16 = __nwlog_obj();
            v17 = type[0];
            if (!os_log_type_enabled(v16, type[0]))
              goto LABEL_49;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v19;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v28) = v13;
            v11 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d";
          }
          else
          {
            v16 = __nwlog_obj();
            v17 = type[0];
            if (!os_log_type_enabled(v16, type[0]))
              goto LABEL_49;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v19;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v28) = v13;
            v11 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d, backtrace limit exceeded";
          }
LABEL_47:
          v20 = v16;
          v21 = v17;
          v22 = 28;
          break;
        case 3:
          *(_DWORD *)(v5 + 5308) &= ~0x100u;
          return v7;
        case 4:
        case 5:
          return v7;
        case 14:
          *(_DWORD *)(v5 + 5308) &= ~0x400000u;
          if ((*(_BYTE *)(v5 + 828) & 2) == 0)
          {
            v14 = __nwlog_tcp_log();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v6 + 604;
              _os_log_impl(&dword_209FB3000, v14, OS_LOG_TYPE_INFO, "%{public}s %{public}s segmentation_offload_notification disabled", buf, 0x16u);
            }
          }
          return v7;
        default:
          return 0;
      }
      goto LABEL_48;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
    v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_49;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
      v11 = "%{public}s called with null tcp";
    }
    else
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
      v11 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
    v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault())
      goto LABEL_49;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
      v11 = "%{public}s called with null protocol";
    }
    else
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_unregister_notification";
      v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
  }
  v20 = v24;
  v21 = v25;
  v22 = 12;
LABEL_48:
  _os_log_impl(&dword_209FB3000, v20, v21, v11, buf, v22);
LABEL_49:
  if (v8)
    free(v8);
  return 0;
}

uint64_t tcp_is_ack_ratelimited(uint64_t a1)
{
  int v2;
  int v3;
  unsigned int v4;
  int v5;
  uint64_t result;

  v2 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316);
  v3 = *(_DWORD *)(a1 + 1044);
  if (!v3 || v2 - v3 >= 1000)
  {
    *(_DWORD *)(a1 + 1044) = v2;
    v5 = 1;
    goto LABEL_6;
  }
  v4 = *(_DWORD *)(a1 + 1048);
  if (v4 < *(_DWORD *)(sysctls + 248))
  {
    v5 = v4 + 1;
LABEL_6:
    result = 0;
    *(_DWORD *)(a1 + 1048) = v5;
    return result;
  }
  return 1;
}

double tcp_free_sackholes(uint64_t a1)
{
  _QWORD *i;
  uint64_t v3;
  _QWORD *v4;
  unsigned int v5;
  double result;

  for (i = *(_QWORD **)(a1 + 544); i; i = *(_QWORD **)(a1 + 544))
  {
    v3 = i[2];
    if (*(_QWORD **)(a1 + 616) == i)
    {
      *(_QWORD *)(a1 + 616) = v3;
      v4 = (_QWORD *)i[3];
      if (v3)
      {
LABEL_4:
        *(_QWORD *)(v3 + 24) = v4;
        v4 = (_QWORD *)i[3];
        goto LABEL_7;
      }
    }
    else
    {
      v4 = (_QWORD *)i[3];
      if (v3)
        goto LABEL_4;
    }
    *(_QWORD *)(a1 + 552) = v4;
LABEL_7:
    *v4 = v3;
    nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
    free(i);
    --*(_WORD *)(a1 + 538);
    do
      v5 = __ldxr(tcp_sack_globalholes);
    while (__stxr(v5 - 1, tcp_sack_globalholes));
  }
  result = 0.0;
  *(_OWORD *)(a1 + 616) = 0u;
  return result;
}

void tcp_cubic_after_timeout(uint64_t a1)
{
  NSObject *v2;
  void *v3;

  if (!*(_QWORD *)(a1 + 840))
  {
    v2 = __nwlog_obj();
    os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v3);
  }
  if (*(int *)(a1 + 12) > 3 || *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92) >= 2)
  {
    if ((*(_BYTE *)(a1 + 90) & 0x20) == 0)
    {
      **(_DWORD **)(a1 + 840) = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 4) = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 8) = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 12) = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 16) = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 28) = 0;
      tcp_cubic_pre_fr(a1);
    }
    *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 196);
  }
}

uint64_t tcp_ledbat_init(uint64_t a1)
{
  unsigned int v1;

  do
    v1 = __ldaxr(dword_253CF86D0);
  while (__stlxr(v1 + 1, dword_253CF86D0));
  **(_DWORD **)(a1 + 840) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 4) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 8) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 12) = 0;
  return 0;
}

_DWORD *tcp_ledbat_congestion_avd(_DWORD *result, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  BOOL v5;
  unsigned int v6;
  int v7;

  v2 = *(_DWORD *)(a2 + 8) - result[23];
  if (*(_DWORD *)(sysctls + 300))
    return (_DWORD *)ledbat_pp_ack_rcvd((uint64_t)result, v2);
  v3 = result[72] + v2;
  result[72] = v3;
  v4 = result[36];
  v5 = v3 >= v4;
  v6 = v3 - v4;
  if (v6 != 0 && v5)
  {
    result[72] = v6;
    v7 = result[49];
    if (v4 < result[35] && v7 != 0)
      return (_DWORD *)update_cwnd((uint64_t)result, v7, 1);
  }
  return result;
}

uint64_t tcp_ledbat_pre_fr(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  _DWORD *v6;
  int v7;

  if ((*(_BYTE *)(result + 742) & 0x10) != 0)
  {
    v1 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    v2 = *(_DWORD *)(result + 980);
    if (v2 <= v1)
      v2 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
  }
  else
  {
    v1 = 0;
    v2 = *(_DWORD *)(result + 140);
    if (v2 >= *(_DWORD *)(result + 144))
      v2 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 984) = v1;
  v3 = *(_DWORD *)(result + 196);
  v4 = ((v3 >> 1) + (v2 >> 1)) / v3 * v3;
  v5 = 2 * v3;
  if (v4 > v5)
    v5 = v4;
  *(_DWORD *)(result + 148) = v5;
  if (*(_DWORD *)(result + 736) > v5)
    *(_DWORD *)(result + 736) = v5;
  v6 = *(_DWORD **)(*(_QWORD *)(result + 80) + 224);
  if (v6[97] > v5)
  {
    v7 = v6[108];
    if ((v7 & 0x400) != 0)
    {
      if (v6[109] > v5)
      {
        if (*(int *)(sysctls + 232) > (uint64_t)v5)
          v5 = *(_DWORD *)(sysctls + 232);
        if (v5 >= *(_DWORD *)(sysctls + 120))
          v5 = *(_DWORD *)(sysctls + 120);
        v6[109] = v5;
      }
      v6[108] = v7 | 0x800;
    }
  }
  return result;
}

uint64_t tcp_ledbat_post_fr(uint64_t result, uint64_t a2)
{
  _DWORD *v2;
  int v3;
  int v4;
  uint64_t v5;

  v2 = (_DWORD *)(result + 92);
  if (a2)
    v2 = (_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)(result + 96) - *v2;
  v4 = *(_DWORD *)(result + 148);
  if (v3 < v4)
  {
    v5 = *(unsigned int *)(result + 196);
    if (v3 <= v5)
      v3 = *(_DWORD *)(result + 196);
    v4 = v3 + v5;
  }
  *(_DWORD *)(result + 144) = v4;
  *(_DWORD *)(result + 288) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 12) = 0;
  return result;
}

uint64_t tcp_ledbat_after_idle(uint64_t result)
{
  **(_DWORD **)(result + 840) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 4) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 8) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 12) = 0;
  *(_DWORD *)(result + 144) = *(_DWORD *)(sysctls + 16) * *(_DWORD *)(result + 196);
  *(_DWORD *)(result + 288) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 12) = 0;
  return result;
}

uint64_t tcp_ledbat_after_timeout(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  _DWORD *v5;
  int v6;

  if (*(int *)(result + 12) >= 4)
  {
    **(_DWORD **)(result + 840) = 0;
    *(_DWORD *)(*(_QWORD *)(result + 840) + 4) = 0;
    *(_DWORD *)(*(_QWORD *)(result + 840) + 8) = 0;
    *(_DWORD *)(*(_QWORD *)(result + 840) + 12) = 0;
    if ((*(_BYTE *)(result + 742) & 0x10) != 0)
    {
      v1 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
      v2 = *(_DWORD *)(result + 980);
      if (v2 <= v1)
        v2 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    }
    else
    {
      v1 = 0;
      v2 = *(_DWORD *)(result + 140);
      if (v2 >= *(_DWORD *)(result + 144))
        v2 = *(_DWORD *)(result + 144);
    }
    *(_DWORD *)(result + 984) = v1;
    v3 = *(_DWORD *)(result + 196);
    v4 = ((v3 >> 1) + (v2 >> 1)) / v3 * v3;
    if (v4 <= 2 * v3)
      v4 = 2 * v3;
    *(_DWORD *)(result + 148) = v4;
    if (*(_DWORD *)(result + 736) > v4)
      *(_DWORD *)(result + 736) = v4;
    v5 = *(_DWORD **)(*(_QWORD *)(result + 80) + 224);
    if (v5[97] > v4)
    {
      v6 = v5[108];
      if ((v6 & 0x400) != 0)
      {
        if (v5[109] > v4)
        {
          if (*(int *)(sysctls + 232) > (uint64_t)v4)
            v4 = *(_DWORD *)(sysctls + 232);
          if (v4 >= *(_DWORD *)(sysctls + 120))
            v4 = *(_DWORD *)(sysctls + 120);
          v5[109] = v4;
        }
        v5[108] = v6 | 0x800;
      }
    }
    *(_DWORD *)(result + 144) = v3;
  }
  return result;
}

uint64_t in_pcbbind(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  if (*(_WORD *)(a1 + 2226) || *(_DWORD *)(a1 + 492) || a2 && *a2 != 16)
    return 22;
  result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 2136) + 8))(*(_QWORD *)(a1 + 224));
  if (!(_DWORD)result)
  {
    result = 0;
    *(_WORD *)(a1 + 2226) = 0;
  }
  return result;
}

uint64_t inp_reset_fc_state(uint64_t a1)
{
  uint64_t result;
  int v3;
  int v4;
  uint64_t (**v5)(void);

  result = *(_QWORD *)(a1 + 224);
  v3 = *(_DWORD *)(a1 + 2228);
  if ((v3 & 0x10000000) != 0)
  {
    *(_DWORD *)(a1 + 2228) = v3 & 0xAFFFFFFF;
    *(_DWORD *)(result + 364) &= ~0x20000u;
    if ((v3 & 0x50000000) == 0)
      return result;
    goto LABEL_7;
  }
  v4 = *(_DWORD *)(result + 364);
  *(_DWORD *)(a1 + 2228) = v3 & 0xAFFFFFFF;
  if ((v4 & 0x20000) != 0)
    *(_DWORD *)(result + 364) = v4 & 0xFFFDFFFF;
  if ((v3 & 0x50000000) != 0)
  {
LABEL_7:
    v5 = *(uint64_t (***)(void))(result + 32);
    if (v5)
    {
      if (*v5)
        return (*v5)();
    }
  }
  return result;
}

uint64_t nw_protocol_tcp_get_malloc_frame(uint64_t a1, unsigned int a2, uint64_t a3, int a4, _DWORD *a5)
{
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  void *v16;
  unsigned int v17;
  void *v18;
  int v19;
  unsigned int v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  __int16 v27;
  int v28;
  unsigned int v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  __int16 v36;
  int v37;
  unsigned int v38;
  int v39;
  NSObject *v40;
  int v41;
  size_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  BOOL v47;
  unsigned int v48;
  uint64_t v49;
  void *v50;
  NSObject *v51;
  uint64_t v52;
  unsigned int v53;
  unsigned int v54;
  NSObject *v55;
  int v56;
  __int16 v57;
  uint64_t *v58;
  uint64_t result;
  uint64_t v60;
  NSObject *v61;
  void *v62;
  NSObject *v63;
  void *v64;
  uint64_t v65;
  __int16 v66;
  _BYTE *v67;
  uint64_t *v68;
  uint64_t *v69;
  void *v70;
  NSObject *v71;
  void *v72;
  NSObject *v73;
  const char *v74;
  uint8_t buf[4];
  const char *v76;
  __int16 v77;
  _BYTE v78[10];
  uint64_t v79;
  __int16 v80;
  uint64_t v81;
  uint64_t v82;

  v82 = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_tcp_get_malloc_frame";
    v60 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_103;
    v73 = __nwlog_obj();
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
      goto LABEL_103;
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_tcp_get_malloc_frame";
    v74 = "%{public}s called with null ret_frame_array, backtrace limit exceeded";
    goto LABEL_102;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_tcp_get_malloc_frame";
    v60 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_103;
    v73 = __nwlog_obj();
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
      goto LABEL_103;
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_tcp_get_malloc_frame";
    v74 = "%{public}s called with null (max_frame_count > 0), backtrace limit exceeded";
LABEL_102:
    _os_log_impl(&dword_209FB3000, v73, OS_LOG_TYPE_ERROR, v74, buf, 0xCu);
LABEL_103:
    if (!v60)
      return 0;
    v72 = (void *)v60;
    goto LABEL_96;
  }
  v8 = (_QWORD *)nw_tcp_access_globals(a1);
  v9 = v8;
  if (a5)
    *a5 = 0;
  v10 = v8[18];
  if (!v10)
    goto LABEL_16;
  v12 = *(_QWORD *)(v10 + 16);
  v13 = *(_QWORD **)(v10 + 24);
  v11 = (_QWORD *)(v10 + 16);
  if (v12)
  {
    *(_QWORD *)(v12 + 24) = v13;
    v13 = *(_QWORD **)(v10 + 24);
  }
  else
  {
    v8[19] = v13;
  }
  *v13 = v12;
  *v11 = 0;
  *(_QWORD *)(v10 + 24) = 0;
  v14 = (uint64_t *)v8[21];
  *(_QWORD *)(v10 + 24) = v14;
  *v14 = v10;
  v8[21] = v11;
  v15 = v8[1];
  if (v15 <= 0)
  {
    v61 = __nwlog_obj();
    os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_tcp_get_malloc_frame";
    v62 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort();
    if ((_DWORD)result)
      goto LABEL_105;
    free(v62);
    v15 = v9[1];
  }
  if ((v9[1] = v15 - 1, (*(_WORD *)(v10 + 204) & 0x100) != 0)
    && *MEMORY[0x24BDE08C0]
    && !((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v10, *(_QWORD *)(v10 + 88))
    || (v16 = *(void **)(v10 + 112)) == 0)
  {
LABEL_16:
    if ((int)a2 < 1)
      goto LABEL_80;
    v18 = malloc_type_malloc(a2, 0xF2B69DE5uLL);
    if (v18)
    {
      if (v10)
      {
LABEL_19:
        v19 = *(unsigned __int16 *)(v10 + 204);
        *(_QWORD *)(v10 + 80) = nw_frame_tcp_finalize;
        *(_QWORD *)(v10 + 88) = v9;
        *(_QWORD *)(v10 + 112) = v18;
        *(_QWORD *)(v10 + 104) = 0;
        *(_WORD *)(v10 + 196) = 0;
        *(_DWORD *)(v10 + 48) = a2;
        *(_DWORD *)(v10 + 52) = a2;
        *(_QWORD *)(v10 + 56) = 0;
        *(_DWORD *)(v10 + 192) = 0;
        *(_BYTE *)(v10 + 200) = 0;
        v20 = v19 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v10 + 206) << 16);
        *(_WORD *)(v10 + 204) = v19 & 0xFFC7;
        *(_BYTE *)(v10 + 206) = BYTE2(v20);
        v21 = *(_QWORD **)(v10 + 64);
        if (v21)
        {
          do
          {
            v22 = (_QWORD *)*v21;
            v23 = (void *)v21[6];
            v24 = (_QWORD *)*v21;
            if (v23)
            {
              nw_release(v23);
              v21[6] = 0;
              v24 = (_QWORD *)*v21;
            }
            v25 = (_QWORD *)v21[1];
            if (v24)
            {
              v24[1] = v25;
              v25 = (_QWORD *)v21[1];
            }
            else
            {
              *(_QWORD *)(v10 + 72) = v25;
            }
            *v25 = v24;
            if (v21 != (_QWORD *)(v10 + 120))
              free(v21);
            v21 = v22;
          }
          while (v22);
        }
        *(_QWORD *)(v10 + 64) = 0;
        *(_QWORD *)(v10 + 72) = v10 + 64;
        v26 = *(void **)(v10 + 168);
        if (v26)
          nw_release(v26);
        v27 = *(_WORD *)(v10 + 204);
        *(_QWORD *)(v10 + 184) = 0;
        *(_OWORD *)(v10 + 168) = 0u;
        *(_OWORD *)(v10 + 152) = 0u;
        *(_OWORD *)(v10 + 136) = 0u;
        *(_OWORD *)(v10 + 120) = 0u;
        *(_BYTE *)(v10 + 203) = 0;
        *(_WORD *)(v10 + 198) = 0;
        *(_WORD *)(v10 + 204) = v27 & 0x213E | 1;
LABEL_86:
        *(_QWORD *)(v10 + 32) = 0;
        v69 = *(uint64_t **)(a3 + 8);
        *(_QWORD *)(v10 + 40) = v69;
        *v69 = v10;
        *(_QWORD *)(a3 + 8) = v10 + 32;
        result = 1;
        if (!a5)
          return result;
        goto LABEL_87;
      }
      goto LABEL_81;
    }
    v63 = __nwlog_obj();
    os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v76 = "strict_malloc";
    v77 = 2048;
    *(_QWORD *)v78 = a2;
    v64 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort();
    if (!(_DWORD)result)
    {
      free(v64);
LABEL_80:
      v18 = 0;
      if (v10)
        goto LABEL_19;
LABEL_81:
      v65 = nw_frame_create();
      if (v65)
      {
        v10 = v65;
        v66 = *(_WORD *)(v65 + 204);
        if ((v66 & 4) != 0)
          v67 = (_BYTE *)(v65 + 208);
        else
          v67 = 0;
        *v67 |= 4u;
        *(_WORD *)(v65 + 204) = v66 | 1;
        *(_QWORD *)(v65 + 16) = 0;
        v68 = (uint64_t *)v9[21];
        *(_QWORD *)(v65 + 24) = v68;
        *v68 = v65;
        v9[21] = v65 + 16;
        goto LABEL_86;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_tcp_get_malloc_frame";
      v70 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v71 = __nwlog_obj();
        if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v76 = "nw_protocol_tcp_get_malloc_frame";
          _os_log_impl(&dword_209FB3000, v71, OS_LOG_TYPE_ERROR, "%{public}s nw_frame_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v70)
        free(v70);
      if (!v18)
        return 0;
      v72 = v18;
LABEL_96:
      free(v72);
      return 0;
    }
LABEL_105:
    __break(1u);
    return result;
  }
  v17 = *(_DWORD *)(v10 + 48);
  if (v17 < a2)
  {
    free(v16);
    goto LABEL_16;
  }
  v28 = *(unsigned __int16 *)(v10 + 204);
  *(_QWORD *)(v10 + 80) = nw_frame_tcp_finalize;
  *(_QWORD *)(v10 + 88) = v9;
  *(_QWORD *)(v10 + 112) = v16;
  *(_QWORD *)(v10 + 104) = 0;
  *(_WORD *)(v10 + 196) = 0;
  *(_DWORD *)(v10 + 48) = v17;
  *(_DWORD *)(v10 + 52) = v17;
  *(_QWORD *)(v10 + 56) = 0;
  *(_DWORD *)(v10 + 192) = 0;
  *(_BYTE *)(v10 + 200) = 0;
  v29 = v28 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v10 + 206) << 16);
  *(_WORD *)(v10 + 204) = v28 & 0xFFC7;
  *(_BYTE *)(v10 + 206) = BYTE2(v29);
  v30 = *(_QWORD **)(v10 + 64);
  if (v30)
  {
    do
    {
      v31 = (_QWORD *)*v30;
      v32 = (void *)v30[6];
      v33 = (_QWORD *)*v30;
      if (v32)
      {
        nw_release(v32);
        v30[6] = 0;
        v33 = (_QWORD *)*v30;
      }
      v34 = (_QWORD *)v30[1];
      if (v33)
      {
        v33[1] = v34;
        v34 = (_QWORD *)v30[1];
      }
      else
      {
        *(_QWORD *)(v10 + 72) = v34;
      }
      *v34 = v33;
      if (v30 != (_QWORD *)(v10 + 120))
        free(v30);
      v30 = v31;
    }
    while (v31);
  }
  *(_QWORD *)(v10 + 64) = 0;
  *(_QWORD *)(v10 + 72) = v10 + 64;
  v35 = *(void **)(v10 + 168);
  if (v35)
    nw_release(v35);
  v36 = *(_WORD *)(v10 + 204);
  *(_QWORD *)(v10 + 184) = 0;
  *(_OWORD *)(v10 + 168) = 0u;
  *(_OWORD *)(v10 + 152) = 0u;
  *(_OWORD *)(v10 + 136) = 0u;
  *(_OWORD *)(v10 + 120) = 0u;
  *(_WORD *)(v10 + 204) = v36 & 0x213F;
  *(_BYTE *)(v10 + 203) = 0;
  *(_WORD *)(v10 + 198) = 0;
  v37 = *(_DWORD *)(v10 + 52);
  v38 = *(_DWORD *)(v10 + 56) + a2;
  v39 = *(_DWORD *)(v10 + 60);
  if (v38 <= v37 - v39)
  {
    *(_DWORD *)(v10 + 56) = v38;
    if (!v37)
      goto LABEL_64;
    goto LABEL_50;
  }
  v40 = __nwlog_obj();
  if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
  {
    v41 = *(_DWORD *)(v10 + 52);
    *(_DWORD *)buf = 136446978;
    v76 = "__nw_frame_claim_internal";
    v77 = 1024;
    *(_DWORD *)v78 = v38;
    *(_WORD *)&v78[4] = 1024;
    *(_DWORD *)&v78[6] = v41;
    LOWORD(v79) = 1024;
    *(_DWORD *)((char *)&v79 + 2) = v39;
    _os_log_impl(&dword_209FB3000, v40, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
  }
  v37 = *(_DWORD *)(v10 + 52);
  if (v37)
  {
LABEL_50:
    v43 = *(unsigned int *)(v10 + 56);
    v42 = *(unsigned int *)(v10 + 60);
    v44 = (v37 - (v42 + v43));
    if (v37 != (_DWORD)v42 + (_DWORD)v43)
    {
      if ((_DWORD)v42)
      {
        v45 = *(_QWORD *)(v10 + 112);
        if (v45)
        {
          memmove((void *)(v45 + v43), (const void *)(v45 + v43 + v44), v42);
          v37 = *(_DWORD *)(v10 + 52);
        }
      }
      *(_DWORD *)(v10 + 52) = v37 - v44;
      if ((*(_WORD *)(v10 + 204) & 0x80) != 0)
      {
        v46 = *(unsigned __int16 *)(v10 + 196);
        v47 = v46 >= v44;
        v48 = v46 - v44;
        *(_WORD *)(v10 + 196) = v48;
        if (!v47 || v48 >= 0x10000)
        {
          __nwlog_obj();
          v49 = *(unsigned __int16 *)(v10 + 196);
          *(_DWORD *)buf = 136446978;
          v76 = "__nw_frame_collapse";
          v77 = 2082;
          *(_QWORD *)v78 = "frame->aggregate_buffer_length";
          *(_WORD *)&v78[8] = 2048;
          v79 = v44;
          v80 = 2048;
          v81 = v49;
          v50 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            v51 = __nwlog_obj();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
            {
              v52 = *(unsigned __int16 *)(v10 + 196);
              *(_DWORD *)buf = 136446978;
              v76 = "__nw_frame_collapse";
              v77 = 2082;
              *(_QWORD *)v78 = "frame->aggregate_buffer_length";
              *(_WORD *)&v78[8] = 2048;
              v79 = v44;
              v80 = 2048;
              v81 = v52;
              _os_log_impl(&dword_209FB3000, v51, OS_LOG_TYPE_ERROR, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded", buf, 0x2Au);
            }
          }
          if (v50)
            free(v50);
          *(_WORD *)(v10 + 196) = 0;
        }
      }
    }
  }
LABEL_64:
  if ((*(_WORD *)(v10 + 204) & 0x80) != 0)
    *(_WORD *)(v10 + 196) += a2;
  v53 = *(_DWORD *)(v10 + 56);
  v47 = v53 >= a2;
  v54 = v53 - a2;
  if (v47)
  {
    *(_DWORD *)(v10 + 56) = v54;
  }
  else
  {
    v55 = __nwlog_obj();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      v56 = *(_DWORD *)(v10 + 56);
      *(_DWORD *)buf = 136446722;
      v76 = "__nw_frame_unclaim_internal";
      v77 = 1024;
      *(_DWORD *)v78 = a2;
      *(_WORD *)&v78[4] = 1024;
      *(_DWORD *)&v78[6] = v56;
      _os_log_impl(&dword_209FB3000, v55, OS_LOG_TYPE_ERROR, "%{public}s Frame cannot unclaim %u start bytes (has %u left)", buf, 0x18u);
    }
  }
  v57 = *(_WORD *)(v10 + 204) | 1;
  *(_QWORD *)(v10 + 32) = 0;
  *(_WORD *)(v10 + 204) = v57;
  v58 = *(uint64_t **)(a3 + 8);
  *(_QWORD *)(v10 + 40) = v58;
  *v58 = v10;
  *(_QWORD *)(a3 + 8) = v10 + 32;
  result = 1;
  if (a5)
LABEL_87:
    *a5 = 1;
  return result;
}

uint64_t __nw_protocol_tcp_get_slab_frame_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  NSObject *v14;
  void *v15;

  v4 = *(_QWORD *)(a2 + 32);
  if (v4)
  {
    *(_QWORD *)(v4 + 40) = *(_QWORD *)(a2 + 40);
    v5 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    v5 = *(_QWORD **)(a2 + 40);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 32) = v5;
  }
  *v5 = v4;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  if (((*(_WORD *)(a2 + 204) & 0x100) == 0
     || !*MEMORY[0x24BDE08C0]
     || ((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(a2, *(_QWORD *)(a2 + 88)))
    && *(_QWORD *)(a2 + 112))
  {
    nw_mem_buffer_free();
  }
  v6 = (_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(a2 + 16);
  if (v7)
  {
    *(_QWORD *)(v7 + 24) = *(_QWORD *)(a2 + 24);
    v8 = *(_QWORD **)(a2 + 24);
  }
  else
  {
    v8 = *(_QWORD **)(a2 + 24);
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 232) = v8;
  }
  *v8 = v7;
  *v6 = 0;
  *(_QWORD *)(a2 + 24) = 0;
  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(_QWORD **)(v9 + 216);
  *(_QWORD *)(a2 + 24) = v10;
  *v10 = a2;
  *(_QWORD *)(v9 + 216) = v6;
  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(_QWORD *)(v11 + 24);
  if ((v12 & 0x8000000000000000) == 0)
    goto LABEL_13;
  v14 = __nwlog_obj();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  v15 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v15);
    v11 = *(_QWORD *)(a1 + 48);
    v12 = *(_QWORD *)(v11 + 24);
LABEL_13:
    *(_QWORD *)(v11 + 24) = v12 + 1;
    return 1;
  }
  __break(1u);
  return result;
}

uint64_t __nw_frame_tcp_finalize_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  void *v7;
  void *v8;
  int v9;
  unsigned int v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  __int16 v17;
  uint64_t result;
  NSObject *v19;
  uint64_t v20;
  uint8_t buf[4];
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v2 = **(_QWORD **)(a1 + 32);
  if (v2 < 21)
    return v2 > 20;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4)
  {
    *(_QWORD *)(v4 + 24) = *(_QWORD *)(a2 + 24);
    v5 = *(_QWORD **)(a2 + 24);
  }
  else
  {
    v5 = *(_QWORD **)(a2 + 24);
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) = v5;
  }
  *v5 = v4;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  --**(_QWORD **)(a1 + 32);
  if (*(_BYTE *)(a1 + 48))
  {
    if ((*(_WORD *)(a2 + 204) & 2) != 0)
    {
      v8 = *(void **)(a2 + 96);
      if (v8)
      {
        nw_release(v8);
        *(_QWORD *)(a2 + 96) = 0;
      }
    }
    else
    {
      v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "__nw_frame_set_external_data";
        _os_log_impl(&dword_209FB3000, v6, OS_LOG_TYPE_ERROR, "%{public}s Frame does not use external data", buf, 0xCu);
      }
    }
    goto LABEL_22;
  }
  if (*(_BYTE *)(a1 + 49))
  {
    if ((*(_WORD *)(a2 + 204) & 0x100) != 0
      && *MEMORY[0x24BDE08C0]
      && !((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(a2, *(_QWORD *)(a2 + 88)))
    {
      goto LABEL_22;
    }
    v7 = *(void **)(a2 + 112);
    if (!v7)
      goto LABEL_22;
    goto LABEL_14;
  }
  if (!*(_BYTE *)(a1 + 50)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && *MEMORY[0x24BDE08C0]
    && !((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(a2, *(_QWORD *)(a2 + 88))
    || !*(_QWORD *)(a2 + 112))
  {
    goto LABEL_22;
  }
  v19 = __nwlog_obj();
  os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v22 = "nw_frame_tcp_finalize_block_invoke";
  v20 = _os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    v7 = (void *)v20;
LABEL_14:
    free(v7);
LABEL_22:
    v9 = *(unsigned __int16 *)(a2 + 204);
    *(_WORD *)(a2 + 196) = 0;
    *(_DWORD *)(a2 + 192) = 0;
    *(_BYTE *)(a2 + 200) = 0;
    *(_QWORD *)(a2 + 56) = 0;
    *(_QWORD *)(a2 + 48) = 0;
    *(_QWORD *)(a2 + 88) = 0;
    *(_QWORD *)(a2 + 80) = 0;
    *(_QWORD *)(a2 + 112) = 0;
    *(_QWORD *)(a2 + 104) = 0;
    v10 = v9 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a2 + 206) << 16);
    *(_WORD *)(a2 + 204) = v10;
    *(_BYTE *)(a2 + 206) = BYTE2(v10);
    v11 = *(_QWORD **)(a2 + 64);
    if (v11)
    {
      do
      {
        v12 = (_QWORD *)*v11;
        v13 = (void *)v11[6];
        v14 = (_QWORD *)*v11;
        if (v13)
        {
          nw_release(v13);
          v11[6] = 0;
          v14 = (_QWORD *)*v11;
        }
        v15 = (_QWORD *)v11[1];
        if (v14)
        {
          v14[1] = v15;
          v15 = (_QWORD *)v11[1];
        }
        else
        {
          *(_QWORD *)(a2 + 72) = v15;
        }
        *v15 = v14;
        if (v11 != (_QWORD *)(a2 + 120))
          free(v11);
        v11 = v12;
      }
      while (v12);
    }
    *(_QWORD *)(a2 + 64) = 0;
    *(_QWORD *)(a2 + 72) = a2 + 64;
    v16 = *(void **)(a2 + 168);
    if (v16)
      nw_release(v16);
    *(_QWORD *)(a2 + 184) = 0;
    *(_OWORD *)(a2 + 168) = 0u;
    *(_OWORD *)(a2 + 152) = 0u;
    *(_OWORD *)(a2 + 136) = 0u;
    v17 = *(_WORD *)(a2 + 204);
    *(_OWORD *)(a2 + 120) = 0u;
    *(_WORD *)(a2 + 204) = v17 & 0x213F;
    *(_BYTE *)(a2 + 203) = 0;
    *(_WORD *)(a2 + 198) = 0;
    nw_release((void *)a2);
    return v2 > 20;
  }
  __break(1u);
  return result;
}

BOOL nw_protocol_tcp_copy_frame_to_frame(uint64_t a1, int a2)
{
  void *v4;
  NSObject *v5;
  uint8_t buf[4];
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v8 = "__nw_frame_unclaimed_bytes";
  v4 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v5 = __nwlog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v8 = "__nw_frame_unclaimed_bytes";
      _os_log_impl(&dword_209FB3000, v5, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v4)
    free(v4);
  return nw_protocol_tcp_copy_frame_to_buffer(a1, 0, a2, 0);
}

uint64_t nw_protocol_tcp_copy_frame(uint64_t a1, uint64_t a2, signed int a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  char *v8;
  void *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  NSObject *v13;
  void *backtrace_string;
  _BOOL4 v15;
  int v16;
  int v17;
  unsigned int v18;
  NSObject *v19;
  os_log_type_t v20;
  uint32_t v21;
  NSObject *v22;
  void *v23;
  uint64_t result;
  void *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  void *v29;
  _BOOL4 v30;
  NSObject *v31;
  os_log_type_t v32;
  void *v33;
  _BOOL4 v34;
  const char *v35;
  void (*v36)(uint64_t, _QWORD, uint64_t);
  uint64_t v37;
  _BOOL4 v38;
  _BOOL4 v39;
  _QWORD v40[2];
  char v41;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  _WORD v46[17];

  *(_QWORD *)&v46[13] = *MEMORY[0x24BDAC8D0];
  v40[0] = 0;
  v40[1] = v40;
  if (a3 <= 0)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v44 = "nw_protocol_tcp_copy_frame";
    v45 = 1024;
    *(_DWORD *)v46 = a3;
    v9 = (void *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault())
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446466;
      v44 = "nw_protocol_tcp_copy_frame";
      v45 = 1024;
      *(_DWORD *)v46 = a3;
      v12 = "%{public}s called with null invalid len %d";
    }
    else if (v41)
    {
      backtrace_string = (void *)__nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v15 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446722;
          v44 = "nw_protocol_tcp_copy_frame";
          v45 = 1024;
          *(_DWORD *)v46 = a3;
          v46[2] = 2082;
          *(_QWORD *)&v46[3] = backtrace_string;
          _os_log_impl(&dword_209FB3000, v10, v11, "%{public}s called with null invalid len %d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_37;
      }
      if (!v15)
        goto LABEL_37;
      *(_DWORD *)buf = 136446466;
      v44 = "nw_protocol_tcp_copy_frame";
      v45 = 1024;
      *(_DWORD *)v46 = a3;
      v12 = "%{public}s called with null invalid len %d, no backtrace";
    }
    else
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446466;
      v44 = "nw_protocol_tcp_copy_frame";
      v45 = 1024;
      *(_DWORD *)v46 = a3;
      v12 = "%{public}s called with null invalid len %d, backtrace limit exceeded";
    }
    v19 = v10;
    v20 = v11;
    v21 = 18;
LABEL_36:
    _os_log_impl(&dword_209FB3000, v19, v20, v12, buf, v21);
    goto LABEL_37;
  }
  if ((nw_protocol_tcp_get_frames(a1, a3, (uint64_t)v40, 1, 0, 0) & 1) == 0)
  {
    v13 = __nwlog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_tcp_copy_frame";
      _os_log_impl(&dword_209FB3000, v13, OS_LOG_TYPE_ERROR, "%{public}s failed to get tcp frame array", buf, 0xCu);
    }
    return 0;
  }
  v5 = v40[0];
  v6 = (_QWORD *)MEMORY[0x24BDE08C0];
  if (v40[0])
  {
    v7 = *(_QWORD *)(v40[0] + 112);
    if (v7)
    {
      if ((*(_WORD *)(v40[0] + 204) & 0x100) == 0 || !*MEMORY[0x24BDE08C0])
        goto LABEL_9;
      if (((unsigned int (*)(_QWORD, _QWORD))*MEMORY[0x24BDE08C0])(v40[0], *(_QWORD *)(v40[0] + 88)))
      {
        v7 = *(_QWORD *)(v5 + 112);
LABEL_9:
        v8 = (char *)(v7 + *(unsigned int *)(v5 + 56));
        goto LABEL_22;
      }
    }
    v8 = 0;
LABEL_22:
    if (!nw_protocol_tcp_copy_frame_to_buffer(a2, 0, a3, v8))
      goto LABEL_67;
    goto LABEL_23;
  }
  v22 = __nwlog_obj();
  os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v44 = "nw_protocol_tcp_copy_frame";
  v23 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v23);
    if (!nw_protocol_tcp_copy_frame_to_frame(a2, a3))
      goto LABEL_71;
LABEL_23:
    if (a2)
    {
      v16 = *(unsigned __int16 *)(a2 + 204);
      v17 = v16 | (*(unsigned __int8 *)(a2 + 206) << 16);
      if ((v16 & 0x100) == 0 || !*v6)
      {
LABEL_28:
        if ((v17 & 0x4000) == 0)
          return v5;
        v18 = v17 & 0xFFFFBFFF;
        *(_WORD *)(a2 + 204) = v18;
        *(_BYTE *)(a2 + 206) = BYTE2(v18);
        if (v5)
        {
          *(_WORD *)(v5 + 204) |= 0x4000u;
          return v5;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v44 = "__nw_frame_set_is_wake_packet";
        v9 = (void *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v41 = 0;
        if (!__nwlog_fault())
          goto LABEL_37;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v31 = __nwlog_obj();
          v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)buf = 136446210;
            v44 = "__nw_frame_set_is_wake_packet";
            v12 = "%{public}s called with null frame";
LABEL_101:
            v19 = v31;
            v20 = v32;
            v21 = 12;
            goto LABEL_36;
          }
          goto LABEL_37;
        }
        if (!v41)
        {
          v31 = __nwlog_obj();
          v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)buf = 136446210;
            v44 = "__nw_frame_set_is_wake_packet";
            v12 = "%{public}s called with null frame, backtrace limit exceeded";
            goto LABEL_101;
          }
          goto LABEL_37;
        }
        v33 = (void *)__nw_create_backtrace_string();
        v31 = __nwlog_obj();
        v32 = type;
        v34 = os_log_type_enabled(v31, type);
        if (!v33)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446210;
            v44 = "__nw_frame_set_is_wake_packet";
            v12 = "%{public}s called with null frame, no backtrace";
            goto LABEL_101;
          }
          goto LABEL_37;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "__nw_frame_set_is_wake_packet";
          v45 = 2082;
          *(_QWORD *)v46 = v33;
          v35 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_87:
          _os_log_impl(&dword_209FB3000, v31, v32, v35, buf, 0x16u);
          goto LABEL_88;
        }
        goto LABEL_88;
      }
      if (((unsigned int (*)(uint64_t, _QWORD))*v6)(a2, *(_QWORD *)(a2 + 88)))
      {
        v17 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
        goto LABEL_28;
      }
LABEL_66:
      if (v5)
      {
LABEL_67:
        v36 = *(void (**)(uint64_t, _QWORD, uint64_t))(v5 + 80);
        if (v36)
        {
          v37 = *(_QWORD *)(v5 + 88);
          *(_QWORD *)(v5 + 80) = 0;
          *(_QWORD *)(v5 + 88) = 0;
          v36(v5, 0, v37);
          return 0;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v44 = "__nw_frame_finalize";
        v9 = (void *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v41 = 0;
        if (!__nwlog_fault())
          goto LABEL_37;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v31 = __nwlog_obj();
          v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)buf = 136446210;
            v44 = "__nw_frame_finalize";
            v12 = "%{public}s called with null frame->finalizer";
            goto LABEL_101;
          }
          goto LABEL_37;
        }
        if (!v41)
        {
          v31 = __nwlog_obj();
          v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)buf = 136446210;
            v44 = "__nw_frame_finalize";
            v12 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
            goto LABEL_101;
          }
          goto LABEL_37;
        }
        v33 = (void *)__nw_create_backtrace_string();
        v31 = __nwlog_obj();
        v32 = type;
        v39 = os_log_type_enabled(v31, type);
        if (!v33)
        {
          if (v39)
          {
            *(_DWORD *)buf = 136446210;
            v44 = "__nw_frame_finalize";
            v12 = "%{public}s called with null frame->finalizer, no backtrace";
            goto LABEL_101;
          }
          goto LABEL_37;
        }
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "__nw_frame_finalize";
          v45 = 2082;
          *(_QWORD *)v46 = v33;
          v35 = "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s";
          goto LABEL_87;
        }
        goto LABEL_88;
      }
LABEL_71:
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v44 = "__nw_frame_finalize";
      v9 = (void *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v41 = 0;
      if (!__nwlog_fault())
        goto LABEL_37;
      if (type == OS_LOG_TYPE_FAULT)
      {
        v31 = __nwlog_obj();
        v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          v44 = "__nw_frame_finalize";
          v12 = "%{public}s called with null frame";
          goto LABEL_101;
        }
LABEL_37:
        if (v9)
          free(v9);
        return 0;
      }
      if (!v41)
      {
        v31 = __nwlog_obj();
        v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          v44 = "__nw_frame_finalize";
          v12 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_101;
        }
        goto LABEL_37;
      }
      v33 = (void *)__nw_create_backtrace_string();
      v31 = __nwlog_obj();
      v32 = type;
      v38 = os_log_type_enabled(v31, type);
      if (!v33)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          v44 = "__nw_frame_finalize";
          v12 = "%{public}s called with null frame, no backtrace";
          goto LABEL_101;
        }
        goto LABEL_37;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446466;
        v44 = "__nw_frame_finalize";
        v45 = 2082;
        *(_QWORD *)v46 = v33;
        v35 = "%{public}s called with null frame, dumping backtrace:%{public}s";
        goto LABEL_87;
      }
LABEL_88:
      free(v33);
      goto LABEL_37;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v44 = "__nw_frame_check_validity";
    v25 = (void *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (__nwlog_fault())
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v26 = __nwlog_obj();
        v27 = type;
        if (!os_log_type_enabled(v26, type))
          goto LABEL_64;
        *(_DWORD *)buf = 136446210;
        v44 = "__nw_frame_check_validity";
        v28 = "%{public}s called with null frame";
        goto LABEL_63;
      }
      if (!v41)
      {
        v26 = __nwlog_obj();
        v27 = type;
        if (!os_log_type_enabled(v26, type))
          goto LABEL_64;
        *(_DWORD *)buf = 136446210;
        v44 = "__nw_frame_check_validity";
        v28 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_63;
      }
      v29 = (void *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = type;
      v30 = os_log_type_enabled(v26, type);
      if (v29)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "__nw_frame_check_validity";
          v45 = 2082;
          *(_QWORD *)v46 = v29;
          _os_log_impl(&dword_209FB3000, v26, v27, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v29);
        goto LABEL_64;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        v44 = "__nw_frame_check_validity";
        v28 = "%{public}s called with null frame, no backtrace";
LABEL_63:
        _os_log_impl(&dword_209FB3000, v26, v27, v28, buf, 0xCu);
      }
    }
LABEL_64:
    if (v25)
      free(v25);
    goto LABEL_66;
  }
  __break(1u);
  return result;
}

uint64_t tcp_newreno_init()
{
  unsigned int v0;

  do
    v0 = __ldaxr(dword_2545C7080);
  while (__stlxr(v0 + 1, dword_2545C7080));
  return 0;
}

uint64_t tcp_newreno_cleanup()
{
  unsigned int v0;

  do
    v0 = __ldaxr(dword_2545C7080);
  while (__stlxr(v0 - 1, dword_2545C7080));
  return 0;
}

uint64_t tcp_newreno_cwnd_init_or_reset(uint64_t result)
{
  int v1;
  int v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if ((*(_BYTE *)(result + 90) & 2) != 0)
  {
    v1 = *(_DWORD *)(result + 196);
    v2 = *(_DWORD *)(sysctls + 84);
LABEL_15:
    *(_DWORD *)(result + 144) = v2 * v1;
    return result;
  }
  if (*(_DWORD *)(sysctls + 276))
  {
    if (*(_DWORD *)(sysctls + 304))
      v1 = *(_DWORD *)(sysctls + 16);
    else
      v1 = 10;
    v2 = *(_DWORD *)(result + 196);
    goto LABEL_15;
  }
  v3 = *(unsigned int *)(result + 196);
  LODWORD(v4) = 2 * v3;
  if (v3 <= 0x88E)
    v4 = 4380;
  else
    v4 = v4;
  if (v4 <= 4 * v3)
    v5 = v4;
  else
    v5 = 4 * v3;
  *(_DWORD *)(result + 144) = v5;
  return result;
}

_DWORD *tcp_newreno_congestion_avd(_DWORD *result, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  v2 = result[36];
  if (v2 < result[35])
  {
    v3 = result[72] + *(_DWORD *)(a2 + 8) - result[23];
    result[72] = v3;
    v4 = v3 >= v2;
    v5 = v3 - v2;
    if (v5 != 0 && v4)
    {
      result[72] = v5;
      result[36] = result[49] + v2;
    }
  }
  return result;
}

uint64_t tcp_newreno_ack_rcvd(uint64_t result, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  char v7;
  int v8;

  v2 = *(_DWORD *)(result + 196);
  v3 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(result + 92);
  v4 = *(unsigned int *)(result + 144);
  if (v4 >= *(_DWORD *)(result + 148))
  {
    v5 = *(_DWORD *)(result + 288) + v3;
    *(_DWORD *)(result + 288) = v5;
    if (v5 >= v4)
      *(_DWORD *)(result + 288) = v5 - v4;
    else
      v2 = 0;
  }
  else
  {
    v2 <<= *(_DWORD *)(result + 100) == *(_DWORD *)(result + 96);
    if (v3 < v2)
      v2 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(result + 92);
  }
  v6 = v4 + v2;
  v7 = *(_BYTE *)(result + 260);
  v8 = v2 + v4;
  if (v6 >= 0xFFFFLL << v7)
    v8 = 0xFFFF << v7;
  *(_DWORD *)(result + 144) = v8;
  return result;
}

uint64_t tcp_newreno_pre_fr(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  _DWORD *v5;
  int v6;

  v1 = *(_DWORD *)(result + 140);
  if (v1 >= *(_DWORD *)(result + 144))
    v1 = *(_DWORD *)(result + 144);
  v2 = *(_DWORD *)(result + 196);
  v3 = (v1 >> 1) / v2;
  if (v3 <= 2)
    v3 = 2;
  v4 = v3 * v2;
  *(_DWORD *)(result + 148) = v4;
  v5 = *(_DWORD **)(*(_QWORD *)(result + 80) + 224);
  if (v5[97] > v4)
  {
    v6 = v5[108];
    if ((v6 & 0x400) != 0)
    {
      if (v5[109] > v4)
      {
        if (*(int *)(sysctls + 232) > (uint64_t)v4)
          v4 = *(_DWORD *)(sysctls + 232);
        if (v4 >= *(_DWORD *)(sysctls + 120))
          v4 = *(_DWORD *)(sysctls + 120);
        v5[109] = v4;
      }
      v5[108] = v6 | 0x800;
    }
  }
  return result;
}

_DWORD *tcp_newreno_post_fr(_DWORD *result, uint64_t a2)
{
  _DWORD *v2;
  int v3;
  int v4;
  uint64_t v5;

  v2 = result + 23;
  if (a2)
    v2 = (_DWORD *)(a2 + 8);
  v3 = result[24] - *v2;
  v4 = result[37];
  if (v3 < v4)
  {
    v5 = result[49];
    if (v3 <= v5)
      v3 = result[49];
    v4 = v3 + v5;
  }
  result[36] = v4;
  result[72] = 0;
  return result;
}

uint64_t tcp_newreno_after_timeout(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  _DWORD *v5;
  int v6;

  if (*(int *)(result + 12) >= 4)
  {
    v1 = *(_DWORD *)(result + 140);
    if (v1 >= *(_DWORD *)(result + 144))
      v1 = *(_DWORD *)(result + 144);
    v2 = *(_DWORD *)(result + 196);
    v3 = (v1 >> 1) / v2;
    if (v3 <= 2)
      v3 = 2;
    v4 = v3 * v2;
    *(_DWORD *)(result + 144) = v2;
    *(_DWORD *)(result + 148) = v3 * v2;
    v5 = *(_DWORD **)(*(_QWORD *)(result + 80) + 224);
    if (v5[97] > v4)
    {
      v6 = v5[108];
      if ((v6 & 0x400) != 0)
      {
        if (v5[109] > v4)
        {
          if (*(int *)(sysctls + 232) > (uint64_t)v4)
            v4 = *(_DWORD *)(sysctls + 232);
          if (v4 >= *(_DWORD *)(sysctls + 120))
            v4 = *(_DWORD *)(sysctls + 120);
          v5[109] = v4;
        }
        v5[108] = v6 | 0x800;
      }
    }
  }
  return result;
}

_DWORD *tcp_newreno_switch_cc(_DWORD *result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  unsigned int v6;

  v1 = result[36];
  if (result[35] >= v1)
    v2 = result[36];
  else
    v2 = result[35];
  if (v1 < result[37])
    v2 >>= 1;
  v3 = result[49];
  v4 = v2 / v3;
  if (*(_DWORD *)(sysctls + 304))
  {
    v5 = v3 * *(_DWORD *)(sysctls + 16);
    if (v3 * (unint64_t)v4 < v5)
      goto LABEL_15;
    goto LABEL_14;
  }
  if (*(_DWORD *)(sysctls + 276))
  {
    v5 = 10 * v3;
    if (v3 * (unint64_t)v4 < v5)
      goto LABEL_15;
    goto LABEL_14;
  }
  if ((v3 * (unint64_t)v4) >> 2 >= 0x447)
  {
LABEL_14:
    LODWORD(v5) = v3 * v4;
    goto LABEL_15;
  }
  LODWORD(v5) = 4380;
LABEL_15:
  result[36] = v5;
  result[72] = 0;
  do
    v6 = __ldaxr(dword_2545C7080);
  while (__stlxr(v6 + 1, dword_2545C7080));
  return result;
}

double tcp_rledbat_init(uint64_t a1)
{
  unsigned int v1;
  double result;

  do
    v1 = __ldaxr((unsigned int *)&unk_253CF8680);
  while (__stlxr(v1 + 1, (unsigned int *)&unk_253CF8680));
  *(_DWORD *)(a1 + 1932) = 0;
  *(_QWORD *)(a1 + 1924) = 0;
  *(_QWORD *)(a1 + 1940) = 0;
  *(_DWORD *)(a1 + 1948) = *(_DWORD *)(sysctls + 16) * *(_DWORD *)(a1 + 196);
  *(_QWORD *)&result = 1073725440;
  *(_QWORD *)(a1 + 1952) = 1073725440;
  return result;
}

uint64_t tcp_rledbat_after_idle(uint64_t result)
{
  *(_DWORD *)(result + 1932) = 0;
  *(_QWORD *)(result + 1924) = 0;
  *(_QWORD *)(result + 1940) = 0;
  *(_DWORD *)(result + 1956) = 0;
  *(_DWORD *)(result + 1948) = *(_DWORD *)(sysctls + 16) * *(_DWORD *)(result + 196);
  return result;
}

uint64_t tcp_rledbat_switch_to(uint64_t result)
{
  _DWORD *v1;
  unsigned int v2;
  int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;

  v1 = (_DWORD *)result;
  *(_DWORD *)(result + 1932) = 0;
  *(_QWORD *)(result + 1924) = 0;
  *(_QWORD *)(result + 1940) = 0;
  *(_DWORD *)(result + 1956) = 0;
  v2 = *(_DWORD *)(result + 1948);
  if (v2)
  {
    if (v2 >> 17)
      v3 = v2 >> 1;
    else
      v3 = 0xFFFF;
  }
  else
  {
    result = tcp_sbspace(result);
    v4 = v1[31] - v1[30];
    if ((int)result > v4)
      v4 = result;
    v3 = (v4 & ~(v4 >> 31)) >> 1;
  }
  v5 = v1[49];
  v6 = (v3 + (v5 >> 1)) / v5 * v5;
  v7 = v5 * *(_DWORD *)(sysctls + 16);
  if (v6 <= v7)
    v6 = v7;
  v1[487] = v6;
  v8 = v1[488];
  if (v8 >= 0x3FFFC000)
    v9 = 1073725440;
  else
    v9 = v1[488];
  if (v8)
    v10 = v9;
  else
    v10 = 1073725440;
  v1[488] = v10;
  return result;
}

void user_north_signal_error(uint64_t a1)
{
  uint64_t v2;
  void (*v3)(uint64_t, _QWORD);
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 32);
    if (v2)
    {
      if ((*(_WORD *)(a1 + 376) & 1) != 0)
      {
        if ((*(_BYTE *)(a1 + 828) & 2) == 0)
        {
          v4 = __nwlog_tcp_log();
          if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
          {
            v5 = 136446722;
            v6 = "user_north_signal_error";
            v7 = 2082;
            v8 = a1 + 604;
            v9 = 2048;
            v10 = a1;
            _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping so %p SS_NOFDREF", (uint8_t *)&v5, 0x20u);
          }
        }
      }
      else
      {
        v3 = *(void (**)(uint64_t, _QWORD))(v2 + 120);
        if (v3)
          v3(a1, *(unsigned __int16 *)(a1 + 378));
      }
      *(_WORD *)(a1 + 378) = 0;
    }
  }
}

uint64_t nw_tcp_destroy_globals(_QWORD *a1)
{
  _QWORD **v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *i;
  void *v7;
  uint64_t result;

  v2 = (_QWORD **)a1[4];
  v3 = *v2;
  if (!*v2)
    goto LABEL_8;
  do
  {
    v5 = *v2;
    for (i = v2; v5 != v3; v5 = (_QWORD *)*v5)
      i = v5;
    v4 = (_QWORD *)*v3;
    *i = *v3;
    free(v3);
    v3 = v4;
  }
  while (v4);
  v2 = (_QWORD **)a1[4];
  if (v2)
  {
LABEL_8:
    free(v2);
    a1[4] = 0;
  }
  if (a1[11])
  {
    nw_queue_cancel_source();
    a1[11] = 0;
  }
  if (a1[12])
  {
    nw_queue_cancel_source();
    a1[12] = 0;
  }
  v7 = (void *)a1[9];
  if (v7)
  {
    free(v7);
    a1[9] = 0;
  }
  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  result = nw_tcp_release_frame_array();
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

uint64_t nw_tcp_release_frame_array()
{
  _QWORD *v0;
  uint64_t result;
  uint64_t v2;
  _QWORD *v3;
  __int16 v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  int v15;
  unsigned int v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  __int16 v23;
  void *v24;
  NSObject *v25;
  void *v26;
  NSObject *v27;
  void *v28;
  NSObject *v29;
  uint8_t buf[4];
  const char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v0 = (_QWORD *)MEMORY[0x24BDE08C0];
  while (1)
  {
    result = nw_frame_array_is_empty();
    if ((result & 1) != 0)
      return result;
    v2 = nw_frame_array_first();
    nw_frame_array_remove();
    if (v2)
    {
      v3 = (_QWORD *)(v2 + 104);
      v4 = *(_WORD *)(v2 + 204);
      if ((v4 & 2) != 0)
      {
        v13 = *(void **)(v2 + 96);
        if (v13)
        {
          nw_release(v13);
          *(_QWORD *)(v2 + 96) = 0;
        }
        *(_DWORD *)(v2 + 52) = 0;
        *(_DWORD *)(v2 + 56) = 0;
        *(_WORD *)(v2 + 196) = 0;
      }
      else
      {
        if (*(_QWORD *)(v2 + 104))
        {
          if (((*(_WORD *)(v2 + 204) & 0x100) == 0
             || !*v0
             || ((unsigned int (*)(uint64_t, _QWORD))*v0)(v2, *(_QWORD *)(v2 + 88)))
            && *(_QWORD *)(v2 + 112))
          {
            nw_mem_buffer_free();
          }
          v5 = *(unsigned __int16 *)(v2 + 204);
          *(_WORD *)(v2 + 196) = 0;
          *(_DWORD *)(v2 + 192) = 0;
          *(_BYTE *)(v2 + 200) = 0;
          *(_QWORD *)(v2 + 56) = 0;
          *(_QWORD *)(v2 + 48) = 0;
          *(_QWORD *)(v2 + 88) = 0;
          *(_QWORD *)(v2 + 80) = 0;
          *v3 = 0;
          *(_QWORD *)(v2 + 112) = 0;
          v6 = v5 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v2 + 206) << 16);
          *(_WORD *)(v2 + 204) = v6;
          *(_BYTE *)(v2 + 206) = BYTE2(v6);
          v8 = v2 + 64;
          v7 = *(_QWORD **)(v2 + 64);
          if (v7)
          {
            do
            {
              v9 = (_QWORD *)*v7;
              v10 = (void *)v7[6];
              v11 = (_QWORD *)*v7;
              if (v10)
              {
                nw_release(v10);
                v7[6] = 0;
                v11 = (_QWORD *)*v7;
              }
              v12 = (_QWORD *)v7[1];
              if (v11)
              {
                v11[1] = v12;
                v12 = (_QWORD *)v7[1];
              }
              else
              {
                *(_QWORD *)(v2 + 72) = v12;
              }
              *v12 = v11;
              if (v7 != (_QWORD *)(v2 + 120))
                free(v7);
              v7 = v9;
            }
            while (v9);
          }
        }
        else
        {
          if ((v4 & 1) == 0)
            goto LABEL_3;
          if ((*(_WORD *)(v2 + 204) & 0x100) == 0
            || !*v0
            || ((unsigned int (*)(uint64_t, _QWORD))*v0)(v2, *(_QWORD *)(v2 + 88)))
          {
            v14 = *(void **)(v2 + 112);
            if (v14)
              free(v14);
          }
          v15 = *(unsigned __int16 *)(v2 + 204);
          *(_WORD *)(v2 + 196) = 0;
          *(_DWORD *)(v2 + 192) = 0;
          *(_BYTE *)(v2 + 200) = 0;
          *(_QWORD *)(v2 + 56) = 0;
          *(_QWORD *)(v2 + 48) = 0;
          *(_QWORD *)(v2 + 88) = 0;
          *(_QWORD *)(v2 + 80) = 0;
          *v3 = 0;
          *(_QWORD *)(v2 + 112) = 0;
          v16 = v15 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v2 + 206) << 16);
          *(_WORD *)(v2 + 204) = v16;
          *(_BYTE *)(v2 + 206) = BYTE2(v16);
          v8 = v2 + 64;
          v17 = *(_QWORD **)(v2 + 64);
          if (v17)
          {
            do
            {
              v18 = (_QWORD *)*v17;
              v19 = (void *)v17[6];
              v20 = (_QWORD *)*v17;
              if (v19)
              {
                nw_release(v19);
                v17[6] = 0;
                v20 = (_QWORD *)*v17;
              }
              v21 = (_QWORD *)v17[1];
              if (v20)
              {
                v20[1] = v21;
                v21 = (_QWORD *)v17[1];
              }
              else
              {
                *(_QWORD *)(v2 + 72) = v21;
              }
              *v21 = v20;
              if (v17 != (_QWORD *)(v2 + 120))
                free(v17);
              v17 = v18;
            }
            while (v18);
          }
        }
        *(_QWORD *)(v2 + 64) = 0;
        *(_QWORD *)(v2 + 72) = v8;
        v22 = *(void **)(v2 + 168);
        if (v22)
          nw_release(v22);
        v23 = *(_WORD *)(v2 + 204);
        *(_QWORD *)(v2 + 184) = 0;
        *(_OWORD *)(v2 + 168) = 0u;
        *(_OWORD *)(v2 + 152) = 0u;
        *(_OWORD *)(v2 + 136) = 0u;
        *(_OWORD *)(v2 + 120) = 0u;
        *(_WORD *)(v2 + 204) = v23 & 0x213F;
        *(_BYTE *)(v2 + 203) = 0;
        *(_WORD *)(v2 + 198) = 0;
      }
LABEL_3:
      nw_release((void *)v2);
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v31 = "__nw_frame_buffer_get_manager";
      v24 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v25 = __nwlog_obj();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "__nw_frame_buffer_get_manager";
          _os_log_impl(&dword_209FB3000, v25, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v24)
        free(v24);
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v31 = "__nw_frame_uses_external_data";
      v26 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v27 = __nwlog_obj();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "__nw_frame_uses_external_data";
          _os_log_impl(&dword_209FB3000, v27, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v26)
        free(v26);
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v31 = "__nw_frame_buffer_used_malloc";
      v28 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v29 = __nwlog_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "__nw_frame_buffer_used_malloc";
          _os_log_impl(&dword_209FB3000, v29, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v28)
        free(v28);
    }
  }
}

void nw_protocol_tcp_update_metadata(uint64_t a1)
{
  _DWORD *v1;
  void *v2;
  NSObject *v3;
  const char *v4;
  uint8_t buf[4];
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v6 = "nw_protocol_tcp_update_metadata";
    v2 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_14;
    v3 = __nwlog_obj();
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      goto LABEL_14;
    *(_DWORD *)buf = 136446210;
    v6 = "nw_protocol_tcp_update_metadata";
    v4 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_13;
  }
  v1 = (_DWORD *)nw_protocol_downcast();
  if (v1)
  {
    v1[1322] = v1[96];
    v1[1323] = v1[122];
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v6 = "nw_protocol_tcp_update_metadata";
  v2 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v3 = __nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v6 = "nw_protocol_tcp_update_metadata";
      v4 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_13:
      _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_ERROR, v4, buf, 0xCu);
    }
  }
LABEL_14:
  if (v2)
    free(v2);
}

uint64_t nw_protocol_tcp_get_receive_buffer_size(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  uint8_t buf[4];
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(unsigned int *)(a1 + 5292);
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v5 = "nw_protocol_tcp_get_receive_buffer_size";
  v2 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v3 = __nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v5 = "nw_protocol_tcp_get_receive_buffer_size";
      _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_ERROR, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v2)
    free(v2);
  return 0;
}

uint64_t nw_protocol_tcp_get_send_buffer_size(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  uint8_t buf[4];
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(unsigned int *)(a1 + 5288);
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v5 = "nw_protocol_tcp_get_send_buffer_size";
  v2 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v3 = __nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v5 = "nw_protocol_tcp_get_send_buffer_size";
      _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_ERROR, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v2)
    free(v2);
  return 0;
}

uint64_t nw_protocol_tcp_reset_keepalives(uint64_t a1, int a2, int a3, int a4, int a5)
{
  uint64_t v5;
  os_unfair_lock_s *v11;
  uint64_t v12;
  void *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  void *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  os_log_type_t type[4];
  _BYTE buf[24];
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v11 = (os_unfair_lock_s *)(a1 + 5264);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 5264));
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v5);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) == 0 && (*(_BYTE *)(a1 + 365) & 0x20) == 0)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v5);
      __nwlog_obj();
      v12 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v33) = 22;
      v13 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v14 = __nwlog_obj();
          v15 = type[0];
          if (os_log_type_enabled(v14, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v12;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v33) = 22;
            v16 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d";
LABEL_45:
            _os_log_impl(&dword_209FB3000, v14, v15, v16, buf, 0x1Cu);
          }
        }
        else
        {
          v14 = __nwlog_obj();
          v15 = type[0];
          if (os_log_type_enabled(v14, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v12;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v33) = 22;
            v16 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_45;
          }
        }
      }
      if (v13)
        free(v13);
      v18 = 22;
LABEL_54:
      os_unfair_lock_unlock(v11);
      return v18;
    }
    if (a2)
      v17 = 8;
    else
      v17 = 0;
    *(_DWORD *)(a1 + 372) = *(_DWORD *)(a1 + 372) & 0xFFFFFFF7 | v17;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v5);
    *(_DWORD *)type = a4;
    *(_QWORD *)buf = 0x600000001;
    *(_QWORD *)&buf[8] = 16;
    *(_QWORD *)&buf[16] = type;
    v33 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v5);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
      v18 = tcp_ctloutput(a1, (uint64_t)buf);
    else
      v18 = 22;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v5);
    if ((_DWORD)v18)
    {
      __nwlog_obj();
      v19 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 604;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v33) = v18;
      v20 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      if (!__nwlog_fault())
        goto LABEL_52;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v21 = __nwlog_obj();
        v22 = type[0];
        if (!os_log_type_enabled(v21, type[0]))
          goto LABEL_52;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v19;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v33) = v18;
        v23 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d";
      }
      else
      {
        v21 = __nwlog_obj();
        v22 = type[0];
        if (!os_log_type_enabled(v21, type[0]))
          goto LABEL_52;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v19;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v33) = v18;
        v23 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d, backtrace limit exceeded";
      }
    }
    else
    {
      *(_DWORD *)type = a5;
      *(_QWORD *)buf = 0x600000001;
      *(_QWORD *)&buf[8] = 257;
      *(_QWORD *)&buf[16] = type;
      v33 = 4;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v5);
      if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
        v18 = tcp_ctloutput(a1, (uint64_t)buf);
      else
        v18 = 22;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v5);
      if ((_DWORD)v18)
      {
        __nwlog_obj();
        v24 = a1 + 604;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 604;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v33) = v18;
        v20 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        if (!__nwlog_fault())
          goto LABEL_52;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v21 = __nwlog_obj();
          v22 = type[0];
          if (!os_log_type_enabled(v21, type[0]))
            goto LABEL_52;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v24;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v33) = v18;
          v23 = "%{public}s %{public}s tcp_set_keepalive_interval failed %{darwin.errno}d";
        }
        else
        {
          v21 = __nwlog_obj();
          v22 = type[0];
          if (!os_log_type_enabled(v21, type[0]))
            goto LABEL_52;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v24;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v33) = v18;
          v23 = "%{public}s %{public}s tcp_set_keepalive_interval failed %{darwin.errno}d, backtrace limit exceeded";
        }
      }
      else
      {
        *(_DWORD *)type = a3;
        *(_QWORD *)buf = 0x600000001;
        *(_QWORD *)&buf[8] = 258;
        *(_QWORD *)&buf[16] = type;
        v33 = 4;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v5);
        if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
          v18 = tcp_ctloutput(a1, (uint64_t)buf);
        else
          v18 = 22;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v5);
        if (!(_DWORD)v18)
          goto LABEL_54;
        __nwlog_obj();
        v25 = a1 + 604;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 604;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v33) = v18;
        v20 = (void *)_os_log_send_and_compose_impl();
        if (!__nwlog_fault()
          || (v21 = __nwlog_obj(), v22 = OS_LOG_TYPE_ERROR, !os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)))
        {
LABEL_52:
          if (v20)
            free(v20);
          goto LABEL_54;
        }
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v25;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v33) = v18;
        v23 = "%{public}s %{public}s tcp_setsockopt TCP_KEEPCNT failed %{darwin.errno}d, backtrace limit exceeded";
      }
    }
    _os_log_impl(&dword_209FB3000, v21, v22, v23, buf, 0x1Cu);
    goto LABEL_52;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
  v27 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
        v30 = "%{public}s called with null handle";
LABEL_62:
        _os_log_impl(&dword_209FB3000, v28, v29, v30, buf, 0xCu);
      }
    }
    else
    {
      v28 = __nwlog_obj();
      v29 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_reset_keepalives";
        v30 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_62;
      }
    }
  }
  if (v27)
    free(v27);
  return 22;
}

uint64_t nw_protocol_tcp_set_no_delay(uint64_t a1, int a2)
{
  uint64_t v2;
  os_unfair_lock_s *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  void *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  os_log_type_t type[4];
  _BYTE buf[24];
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v5 = (os_unfair_lock_s *)(a1 + 5264);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 5264));
    *(_DWORD *)type = a2;
    *(_QWORD *)buf = 0x600000001;
    *(_QWORD *)&buf[8] = 1;
    *(_QWORD *)&buf[16] = type;
    v19 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v2);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
      v6 = tcp_ctloutput(a1, (uint64_t)buf);
    else
      v6 = 22;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v2);
    if (!(_DWORD)v6)
      goto LABEL_16;
    __nwlog_obj();
    v7 = a1 + 604;
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_delay";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 604;
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v19) = v6;
    v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type[0];
        if (!os_log_type_enabled(v9, type[0]))
          goto LABEL_14;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_delay";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v7;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v19) = v6;
        v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d";
      }
      else
      {
        v9 = __nwlog_obj();
        v10 = type[0];
        if (!os_log_type_enabled(v9, type[0]))
          goto LABEL_14;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_delay";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v7;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v19) = v6;
        v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_209FB3000, v9, v10, v11, buf, 0x1Cu);
    }
LABEL_14:
    if (v8)
      free(v8);
LABEL_16:
    os_unfair_lock_unlock(v5);
    return v6;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_delay";
  v13 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_delay";
        v16 = "%{public}s called with null handle";
LABEL_24:
        _os_log_impl(&dword_209FB3000, v14, v15, v16, buf, 0xCu);
      }
    }
    else
    {
      v14 = __nwlog_obj();
      v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_delay";
        v16 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_24;
      }
    }
  }
  if (v13)
    free(v13);
  return 22;
}

uint64_t nw_protocol_tcp_set_no_push(uint64_t a1, int a2)
{
  uint64_t v2;
  os_unfair_lock_s *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  void *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  os_log_type_t type[4];
  _BYTE buf[24];
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v5 = (os_unfair_lock_s *)(a1 + 5264);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 5264));
    *(_DWORD *)type = a2;
    *(_QWORD *)buf = 0x600000001;
    *(_QWORD *)&buf[8] = 4;
    *(_QWORD *)&buf[16] = type;
    v19 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v2);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
      v6 = tcp_ctloutput(a1, (uint64_t)buf);
    else
      v6 = 22;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v2);
    if (!(_DWORD)v6)
      goto LABEL_16;
    __nwlog_obj();
    v7 = a1 + 604;
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_push";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 604;
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v19) = v6;
    v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type[0];
        if (!os_log_type_enabled(v9, type[0]))
          goto LABEL_14;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_push";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v7;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v19) = v6;
        v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d";
      }
      else
      {
        v9 = __nwlog_obj();
        v10 = type[0];
        if (!os_log_type_enabled(v9, type[0]))
          goto LABEL_14;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_push";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v7;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v19) = v6;
        v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_209FB3000, v9, v10, v11, buf, 0x1Cu);
    }
LABEL_14:
    if (v8)
      free(v8);
LABEL_16:
    os_unfair_lock_unlock(v5);
    return v6;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_push";
  v13 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_push";
        v16 = "%{public}s called with null handle";
LABEL_24:
        _os_log_impl(&dword_209FB3000, v14, v15, v16, buf, 0xCu);
      }
    }
    else
    {
      v14 = __nwlog_obj();
      v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_set_no_push";
        v16 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_24;
      }
    }
  }
  if (v13)
    free(v13);
  return 22;
}

uint64_t __nw_protocol_tcp_callbacks_block_invoke()
{
  nw_protocol_tcp_callbacks_callbacks = nw_protocol_one_to_one_callbacks_new();
  nw_protocol_callbacks_set_add_input_handler();
  nw_protocol_callbacks_set_replace_input_handler();
  nw_protocol_callbacks_set_remove_input_handler();
  nw_protocol_callbacks_set_input_available();
  nw_protocol_callbacks_set_input_flush();
  nw_protocol_callbacks_set_output_available();
  nw_protocol_callbacks_set_get_input_frames();
  nw_protocol_callbacks_set_get_output_frames();
  nw_protocol_callbacks_set_finalize_output_frames();
  nw_protocol_callbacks_set_link_state();
  nw_protocol_callbacks_set_disconnect();
  nw_protocol_callbacks_set_connect();
  nw_protocol_callbacks_set_connected();
  nw_protocol_callbacks_set_reset();
  nw_protocol_callbacks_set_disconnected();
  nw_protocol_callbacks_set_waiting_for_output();
  nw_protocol_callbacks_set_output_finished();
  nw_protocol_callbacks_set_updated_path();
  nw_protocol_callbacks_set_copy_info();
  nw_protocol_callbacks_set_register_notification();
  nw_protocol_callbacks_set_unregister_notification();
  nw_protocol_callbacks_set_get_message_properties();
  return nw_protocol_callbacks_set_error();
}

uint64_t nw_protocol_tcp_replace_input_handler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  NSObject *v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  uint64_t input_handler;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_tcp_replace_input_handler";
    v12 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_38;
    v13 = __nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_tcp_replace_input_handler";
    v14 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_37;
  }
  v5 = nw_protocol_downcast();
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_tcp_replace_input_handler";
    v12 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_38;
    v13 = __nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_tcp_replace_input_handler";
    v14 = "%{public}s called with null tcp, backtrace limit exceeded";
    goto LABEL_37;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_tcp_replace_input_handler";
    v12 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_38;
    v13 = __nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_tcp_replace_input_handler";
    v14 = "%{public}s called with null old_input_handler, backtrace limit exceeded";
    goto LABEL_37;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_tcp_replace_input_handler";
    v12 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_38;
    v13 = __nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_tcp_replace_input_handler";
    v14 = "%{public}s called with null new_input_handler, backtrace limit exceeded";
LABEL_37:
    _os_log_impl(&dword_209FB3000, v13, OS_LOG_TYPE_ERROR, v14, buf, 0xCu);
LABEL_38:
    if (!v12)
      return 0;
    v11 = (void *)v12;
LABEL_19:
    free(v11);
    return 0;
  }
  v6 = v5;
  if (nw_protocol_get_input_handler() != a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    v16 = "nw_protocol_tcp_replace_input_handler";
    v17 = 2048;
    input_handler = nw_protocol_get_input_handler();
    v19 = 2048;
    v20 = a2;
    v7 = _os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v10 = __nwlog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v16 = "nw_protocol_tcp_replace_input_handler";
        v17 = 2048;
        input_handler = nw_protocol_get_input_handler();
        v19 = 2048;
        v20 = a2;
        _os_log_impl(&dword_209FB3000, v10, OS_LOG_TYPE_ERROR, "%{public}s Old input handler does not match (%p != %p), backtrace limit exceeded", buf, 0x20u);
      }
    }
    if (!v7)
      return 0;
    v11 = (void *)v7;
    goto LABEL_19;
  }
  nw_protocol_set_input_handler();
  if (!nw_protocol_get_output_handler())
    nw_protocol_set_output_handler();
  if (nw_protocol_supports_external_data_is_valid() && nw_protocol_supports_external_data())
    v8 = *(_DWORD *)(v6 + 5308) | 0x1000;
  else
    v8 = *(_DWORD *)(v6 + 5308) & 0xFFFFEFFF;
  *(_DWORD *)(v6 + 5308) = v8;
  return 1;
}

void nw_protocol_tcp_output_available(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;
  NSObject *v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = nw_protocol_downcast();
    if (v1)
    {
      v2 = v1;
      if ((*(_DWORD *)(v1 + 5224) | 4) == 4 || (*(_BYTE *)(v1 + 5308) & 0x20) != 0)
      {
        if ((*(_BYTE *)(v1 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            v4 = __nwlog_tcp_log();
            if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              v9 = "nw_protocol_tcp_output_available";
              v10 = 2082;
              v11 = v2 + 604;
              _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
            }
          }
        }
      }
      else if (*(_DWORD *)(*(_QWORD *)v1 + 460))
      {
        if ((*(_BYTE *)(v1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
        {
          v7 = __nwlog_tcp_log();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v9 = "nw_protocol_tcp_output_available";
            v10 = 2082;
            v11 = v2 + 604;
            _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s restarting TCP output on output available", buf, 0x16u);
          }
        }
        tcp_output(*(_QWORD *)(*(_QWORD *)v2 + 240));
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v9 = "nw_protocol_tcp_output_available";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v9 = "nw_protocol_tcp_output_available";
        v6 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_22;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v9 = "nw_protocol_tcp_output_available";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v9 = "nw_protocol_tcp_output_available";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_22:
        _os_log_impl(&dword_209FB3000, v5, OS_LOG_TYPE_ERROR, v6, buf, 0xCu);
      }
    }
  }
  if (v3)
    free(v3);
}

void nw_protocol_tcp_link_state(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int flow_control_status;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  void *v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  unsigned int *v24;
  void (**v25)(uint64_t, uint64_t);
  void (*v26)(uint64_t, uint64_t);
  uint64_t v27;
  uint64_t v28;
  void (*v29)(uint64_t, _QWORD);
  void (*v30)(uint64_t);
  NSObject *v31;
  void *v32;
  void (*v33)(void);
  NSObject *v34;
  const char *v35;
  NSObject *v36;
  void *v37;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_tcp_link_state";
    v32 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_64;
    v34 = __nwlog_obj();
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      goto LABEL_64;
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_tcp_link_state";
    v35 = "%{public}s called with null link_info, backtrace limit exceeded";
LABEL_63:
    _os_log_impl(&dword_209FB3000, v34, OS_LOG_TYPE_ERROR, v35, buf, 0xCu);
    goto LABEL_64;
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_tcp_link_state";
    v32 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_64;
    v34 = __nwlog_obj();
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      goto LABEL_64;
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_tcp_link_state";
    v35 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_63;
  }
  v4 = nw_protocol_downcast();
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_tcp_link_state";
    v32 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v34 = __nwlog_obj();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_protocol_tcp_link_state";
        v35 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_63;
      }
    }
LABEL_64:
    if (v32)
      free(v32);
    return;
  }
  v5 = v4;
  if (*(_DWORD *)(v4 + 5224) == 2)
  {
    v6 = *(_QWORD *)v4;
    flow_control_status = nw_link_get_flow_control_status();
    if (flow_control_status != 1)
    {
      if (flow_control_status)
        return;
      v8 = *(_QWORD *)(v6 + 224);
      v9 = (unsigned int *)(v6 + 456);
LABEL_8:
      v10 = *v9;
      if ((unsigned __int16)*v9 != 0xFFFF)
      {
        do
        {
          v11 = __ldxr(v9);
          if (v11 != v10)
          {
            __clrex();
            goto LABEL_8;
          }
        }
        while (__stxr(v10 + 1, v9));
        if (v8)
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v8 + 8) + 16))(v8, 1, v3);
        }
        else
        {
          v36 = __nwlog_obj();
          os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          v39 = "inp_fc_feedback";
          v37 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_abort())
          {
            __break(1u);
            JUMPOUT(0x209FFEF90);
          }
          free(v37);
          (*(void (**)(_QWORD, uint64_t, uint64_t))(MEMORY[8] + 16))(0, 1, v3);
        }
        if (in_pcb_checkstate(v6, 2, 1) == 0xFFFF)
        {
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v39 = "inp_fc_feedback";
          v19 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            v31 = __nwlog_obj();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v39 = "inp_fc_feedback";
              _os_log_impl(&dword_209FB3000, v31, OS_LOG_TYPE_ERROR, "%{public}s failed to release inpcb reference, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v19)
            free(v19);
          goto LABEL_56;
        }
        v21 = *(_DWORD *)(v6 + 2228);
        if ((v21 & 0x50000000) == 0)
        {
LABEL_56:
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v8 + 8) + 24))(v8, 1, v3);
          return;
        }
        v22 = *(_QWORD *)(v6 + 224);
        if ((v21 & 0x10000000) != 0)
        {
          *(_DWORD *)(v6 + 2228) = v21 & 0xAFFFFFFF;
          v24 = (unsigned int *)(v22 + 364);
          v23 = *(_DWORD *)(v22 + 364);
        }
        else
        {
          v23 = *(_DWORD *)(v22 + 364);
          *(_DWORD *)(v6 + 2228) = v21 & 0xAFFFFFFF;
          if ((v23 & 0x20000) == 0)
            goto LABEL_39;
          v24 = (unsigned int *)(v22 + 364);
        }
        *v24 = v23 & 0xFFFDFFFF;
LABEL_39:
        v25 = *(void (***)(uint64_t, uint64_t))(v22 + 32);
        if (v25)
        {
          v26 = *v25;
          if (v26)
            v26(v22, v18);
        }
        v27 = *(_QWORD *)(v6 + 240);
        v28 = tcp_cc_algo_list[*(unsigned __int8 *)(v27 + 264)];
        if (*(_DWORD *)(sysctls + 292))
        {
          v29 = *(void (**)(uint64_t, _QWORD))(v28 + 72);
          if (v29)
            v29(v27, 0);
          *(_DWORD *)(v27 + 288) = 0;
          *(_WORD *)(v27 + 226) = 0;
          *(_DWORD *)(v27 + 248) = 0;
          *(_DWORD *)(v27 + 740) &= ~0x100000u;
        }
        else
        {
          v30 = *(void (**)(uint64_t))(v28 + 64);
          if (v30)
            v30(v27);
          *(_DWORD *)(v27 + 144) = *(_DWORD *)(v27 + 148);
          *(_DWORD *)(v27 + 740) &= ~0x100000u;
          *(_DWORD *)(v27 + 288) = 0;
          *(_WORD *)(v27 + 226) = 0;
          *(_DWORD *)(v27 + 248) = 0;
        }
        tcp_output(v27);
        goto LABEL_56;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v39 = "inp_fc_feedback";
      v32 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_fault())
        goto LABEL_64;
      v34 = __nwlog_obj();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      v39 = "inp_fc_feedback";
      v35 = "%{public}s failed to acquire inpcb reference, backtrace limit exceeded";
      goto LABEL_63;
    }
    v13 = *(_QWORD *)(*(_QWORD *)v5 + 240);
    v14 = *(_QWORD *)(v13 + 80);
    v15 = (unsigned int *)(v14 + 456);
LABEL_18:
    v16 = *v15;
    if ((unsigned __int16)*v15 != 0xFFFF)
    {
      do
      {
        v17 = __ldxr(v15);
        if (v17 != v16)
        {
          __clrex();
          goto LABEL_18;
        }
      }
      while (__stxr(v16 + 1, v15));
      if ((*(_WORD *)(v13 + 90) & 0x820) == 0
        && *(_DWORD *)(v13 + 12) == 4
        && *(_DWORD *)(v13 + 96) - *(_DWORD *)(v13 + 92) >= 1)
      {
        v20 = *(_DWORD *)(v14 + 2228);
        *(_DWORD *)(v14 + 2228) = v20 & 0xAFFFFFFF | 0x40000000;
        if ((v20 & 0x50000000) == 0)
        {
          if (*(_DWORD *)(sysctls + 292))
          {
            v33 = *(void (**)(void))(tcp_cc_algo_list[*(unsigned __int8 *)(*(_QWORD *)(v14 + 240) + 264)] + 64);
            if (v33)
              v33();
          }
        }
      }
      in_pcb_checkstate(v14, 2, 0);
    }
  }
  else if ((*(_BYTE *)(v4 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v12 = __nwlog_tcp_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v39 = "nw_protocol_tcp_link_state";
        v40 = 2082;
        v41 = v5 + 604;
        _os_log_impl(&dword_209FB3000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
      }
    }
  }
}

uint64_t nw_protocol_tcp_reset(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  void *v7;
  NSObject *v8;
  const char *v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v11 = "nw_protocol_tcp_reset";
    v7 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_21;
    v8 = __nwlog_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    *(_DWORD *)buf = 136446210;
    v11 = "nw_protocol_tcp_reset";
    v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_20;
  }
  v3 = nw_protocol_downcast();
  if (v3)
  {
    v4 = v3;
    if ((*(_DWORD *)(v3 + 5224) - 1) <= 1)
    {
      *(_DWORD *)(v3 + 5308) |= 2u;
      *(_DWORD *)(v3 + 5224) = 3;
      if ((*(_BYTE *)(v3 + 828) & 2) == 0)
      {
        v5 = __nwlog_tcp_log();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_protocol_tcp_reset";
          v12 = 2082;
          v13 = v4 + 604;
          _os_log_impl(&dword_209FB3000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s force closing tcp", buf, 0x16u);
        }
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 8) + 16))(v4, 1, v1);
      if ((~*(unsigned __int16 *)(v4 + 376) & 0x30) != 0 || (*(_BYTE *)(v4 + 365) & 0x20) != 0)
      {
        *(_DWORD *)(v4 + 16) = 0;
        *(_DWORD *)(v4 + 372) |= 0x80u;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 8) + 24))(v4, 1, v1);
      tcp_close_locked(v4);
    }
    *(_DWORD *)(v4 + 5308) &= 0xFFFFFFDD;
    *(_DWORD *)(v4 + 5224) = 0;
    bzero((void *)v4, 0x1440uLL);
    nw_protocol_tcp_initialize(a1);
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "nw_protocol_tcp_reset";
  v7 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v8 = __nwlog_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v11 = "nw_protocol_tcp_reset";
      v9 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_20:
      _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
    }
  }
LABEL_21:
  if (v7)
    free(v7);
  return 0;
}

void nw_protocol_tcp_output_finished(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  const char *v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = nw_protocol_downcast();
    if (v1)
    {
      v2 = v1;
      if (*(_DWORD *)(v1 + 5224) == 2)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v4 = __nwlog_obj();
          if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            v9 = "nw_protocol_tcp_output_finished";
            _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_DEBUG, "%{public}s ", buf, 0xCu);
          }
        }
        (*(void (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(v2 + 8) + 40) + 80))(v2);
      }
      else if ((*(_BYTE *)(v1 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v5 = __nwlog_tcp_log();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v9 = "nw_protocol_tcp_output_finished";
            v10 = 2082;
            v11 = v2 + 604;
            _os_log_impl(&dword_209FB3000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
          }
        }
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v9 = "nw_protocol_tcp_output_finished";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v9 = "nw_protocol_tcp_output_finished";
        v7 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v9 = "nw_protocol_tcp_output_finished";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v9 = "nw_protocol_tcp_output_finished";
        v7 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_21:
        _os_log_impl(&dword_209FB3000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
      }
    }
  }
  if (v3)
    free(v3);
}

void nw_protocol_tcp_error(uint64_t a1)
{
  void *v1;
  NSObject *v2;
  const char *v3;
  uint8_t buf[4];
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v5 = "nw_protocol_tcp_error";
    v1 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_13;
    v2 = __nwlog_obj();
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      goto LABEL_13;
    *(_DWORD *)buf = 136446210;
    v5 = "nw_protocol_tcp_error";
    v3 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_12;
  }
  if (nw_protocol_downcast())
  {
    nw_protocol_get_input_handler();
    nw_protocol_error_quiet();
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v5 = "nw_protocol_tcp_error";
  v1 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v2 = __nwlog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v5 = "nw_protocol_tcp_error";
      v3 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_12:
      _os_log_impl(&dword_209FB3000, v2, OS_LOG_TYPE_ERROR, v3, buf, 0xCu);
    }
  }
LABEL_13:
  if (v1)
    free(v1);
}

BOOL nw_protocol_tcp_initialize_inbound(uint64_t a1, nw_endpoint_t endpoint)
{
  uint64_t v2;
  uint64_t v4;
  const sockaddr *address;
  int sa_family;
  uint64_t v7;
  void *v8;
  int v9;
  NSObject *v10;
  _BOOL8 result;
  const char *v12;
  void *v13;
  NSObject *v14;
  int connection_timeout;
  _BYTE buf[24];
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v4 = a1 + 832;
  address = nw_endpoint_get_address(endpoint);
  sa_family = address->sa_family;
  if (sa_family == 2)
  {
    *(_DWORD *)(a1 + 1308) = *(_DWORD *)&address->sa_data[2];
    *(_WORD *)(a1 + 3056) = *(_WORD *)address->sa_data;
    *(_DWORD *)(a1 + 3084) = 1;
    v7 = tcp_rtlookup(v4, 0);
    if (v7)
      goto LABEL_4;
    goto LABEL_10;
  }
  if (sa_family != 30)
  {
    v10 = __nwlog_obj();
    result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_initialize_inbound";
    v12 = "%{public}s Invalid address family";
    goto LABEL_14;
  }
  *(sockaddr *)(a1 + 1296) = *(sockaddr *)&address->sa_data[6];
  *(_WORD *)(a1 + 3056) = *(_WORD *)address->sa_data;
  *(_DWORD *)(a1 + 3084) = 1;
  v7 = tcp_rtlookup6(v4, 0);
  if (!v7)
  {
LABEL_10:
    v10 = __nwlog_obj();
    result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_tcp_initialize_inbound";
    v12 = "%{public}s tcp_rtlookup[6] failed";
LABEL_14:
    _os_log_impl(&dword_209FB3000, v10, OS_LOG_TYPE_ERROR, v12, buf, 0xCu);
    return 0;
  }
LABEL_4:
  *(_QWORD *)(a1 + 1280) = *(_QWORD *)(v7 + 216);
  *(_DWORD *)(v7 + 1480) |= 0x2000000u;
  nw_protocol_upcast();
  nw_protocol_get_input_handler();
  if (nw_protocol_get_parameters())
  {
    v8 = (void *)nw_parameters_copy_protocol_options_legacy();
    connection_timeout = nw_tcp_options_get_connection_timeout();
    if (connection_timeout)
    {
      *(_QWORD *)buf = 0x600000001;
      *(_QWORD *)&buf[8] = 32;
      *(_QWORD *)&buf[16] = &connection_timeout;
      v17 = 4;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v2);
      if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
        v9 = tcp_ctloutput(a1, (uint64_t)buf);
      else
        v9 = 22;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v2);
      if (v9)
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_tcp_initialize_inbound";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v9;
        v13 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v14 = __nwlog_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_tcp_initialize_inbound";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v9;
            _os_log_impl(&dword_209FB3000, v14, OS_LOG_TYPE_ERROR, "%{public}s tcp_setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }
        if (v13)
          free(v13);
      }
    }
    if (v8)
      nw_release(v8);
  }
  return 1;
}

uint64_t nw_proto_tcp_tfo_enabled(uint64_t a1)
{
  uint64_t v1;
  void *v3;
  NSObject *v4;
  uint8_t buf[4];
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 40);
    if (v1 && *(_QWORD *)(v1 + 5208) && *(_QWORD *)(v1 + 5216))
      return nw_path_flow_registration_fast_open_blocked() ^ 1;
    else
      return 1;
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v6 = "nw_proto_tcp_tfo_enabled";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v6 = "nw_proto_tcp_tfo_enabled";
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_ERROR, "%{public}s called with null so, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v3)
      free(v3);
    return 0;
  }
}

uint64_t nw_proto_tcp_tfo_get_cookie(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  void *v5;
  NSObject *v6;
  const char *v7;
  uint8_t buf[4];
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v9 = "nw_proto_tcp_tfo_get_cookie";
    v5 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_21;
    v6 = __nwlog_obj();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    *(_DWORD *)buf = 136446210;
    v9 = "nw_proto_tcp_tfo_get_cookie";
    v7 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_20:
    _os_log_impl(&dword_209FB3000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
    goto LABEL_21;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v9 = "nw_proto_tcp_tfo_get_cookie";
    v5 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_21;
    v6 = __nwlog_obj();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    *(_DWORD *)buf = 136446210;
    v9 = "nw_proto_tcp_tfo_get_cookie";
    v7 = "%{public}s called with null cookie, backtrace limit exceeded";
    goto LABEL_20;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v9 = "nw_proto_tcp_tfo_get_cookie";
    v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v9 = "nw_proto_tcp_tfo_get_cookie";
        v7 = "%{public}s called with null len, backtrace limit exceeded";
        goto LABEL_20;
      }
    }
LABEL_21:
    if (v5)
      free(v5);
    return 0;
  }
  v3 = *(_QWORD *)(a1 + 40);
  if (v3 && *(_QWORD *)(v3 + 5208) && *(_QWORD *)(v3 + 5216))
    return nw_path_flow_registration_get_tfo_cookie();
  return 0;
}

uint64_t nw_proto_tcp_tfo_cookie_len(uint64_t a1)
{
  uint64_t v1;
  void *v3;
  NSObject *v4;
  uint8_t buf[4];
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 40);
    if (v1 && *(_QWORD *)(v1 + 5208) && *(_QWORD *)(v1 + 5216))
      return nw_path_flow_registration_get_tfo_cookie_len();
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v6 = "nw_proto_tcp_tfo_cookie_len";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v6 = "nw_proto_tcp_tfo_cookie_len";
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_ERROR, "%{public}s called with null so, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v3)
      free(v3);
  }
  return 0;
}

void nw_proto_tcp_tfo_update_cache(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;
  void *v4;
  NSObject *v5;
  const char *v6;
  uint8_t buf[4];
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      v2 = *(_QWORD *)(a1 + 40);
      if (v2)
      {
        if ((*(_BYTE *)(a2 + 17) & 9) != 0 || !*(_BYTE *)(a2 + 16))
          v3 = *(_DWORD *)(v2 + 5308) | 0x10000;
        else
          v3 = *(_DWORD *)(v2 + 5308) & 0xFFFEFFFF;
        *(_DWORD *)(v2 + 5308) = v3;
        if (*(_QWORD *)(v2 + 5208))
        {
          if (*(_QWORD *)(v2 + 5216))
            nw_path_flow_registration_set_tfo_cache();
        }
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v8 = "nw_proto_tcp_tfo_update_cache";
    v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v8 = "nw_proto_tcp_tfo_update_cache";
        v6 = "%{public}s called with null tfo_cache_buffer, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v8 = "nw_proto_tcp_tfo_update_cache";
    v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v8 = "nw_proto_tcp_tfo_update_cache";
        v6 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_19:
        _os_log_impl(&dword_209FB3000, v5, OS_LOG_TYPE_ERROR, v6, buf, 0xCu);
      }
    }
  }
  if (v4)
    free(v4);
}

void nw_protocol_tcp_wake_read_timeout(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  uint8_t buf[4];
  const char *v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) <= 2u && (v3 = *(_DWORD *)(v2 + 5308), (v3 & 0x40) != 0))
  {
    *(_DWORD *)(v2 + 5308) = v3 | 0x100000;
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }
  else if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    v4 = __nwlog_tcp_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v6 = "nw_protocol_tcp_wake_read_timeout";
      v7 = 2082;
      v8 = a1 + 604;
      _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }
}

void nw_protocol_tcp_wake_write_timeout(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  uint8_t buf[4];
  const char *v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) <= 2u && (v3 = *(_DWORD *)(v2 + 5308), (v3 & 0x80) != 0))
  {
    *(_DWORD *)(v2 + 5308) = v3 | 0x80000;
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }
  else if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    v4 = __nwlog_tcp_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v6 = "nw_protocol_tcp_wake_write_timeout";
      v7 = 2082;
      v8 = a1 + 604;
      _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }
}

uint64_t nw_protocol_tcp_signal_error(uint64_t a1, int a2)
{
  NSObject *v4;
  uint8_t buf[4];
  const char *v7;
  __int16 v8;
  uint64_t v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    v4 = __nwlog_tcp_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446722;
      v7 = "nw_protocol_tcp_signal_error";
      v8 = 2082;
      v9 = a1 + 604;
      v10 = 1024;
      v11 = a2;
      _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s tcp signal error: %d", buf, 0x1Cu);
    }
  }
  nw_protocol_upcast();
  nw_protocol_retain();
  return nw_queue_context_async();
}

uint64_t __nw_protocol_tcp_signal_error_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;
  const char *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 5308) & 2) != 0)
  {
    v1 = *(_QWORD *)(a1 + 40);
    if (!v1 || (*(_BYTE *)(v1 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v3 = __nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        {
          v4 = "";
          if (v1)
            v4 = (const char *)(v1 + 604);
          v5 = 136446466;
          v6 = "nw_protocol_tcp_signal_error_block_invoke";
          v7 = 2082;
          v8 = v4;
          _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v5, 0x16u);
        }
      }
    }
  }
  else
  {
    nw_protocol_get_input_handler();
    nw_protocol_error_quiet();
  }
  return nw_protocol_release();
}

uint64_t __nw_protocol_tcp_wake_keepalive_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  NSObject *v7;
  const char *v8;
  int v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v8 = "";
        if (v2)
          v8 = (const char *)(v2 + 604);
        v9 = 136446466;
        v10 = "nw_protocol_tcp_wake_keepalive_block_invoke";
        v11 = 2082;
        v12 = v8;
        _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s keepalive", (uint8_t *)&v9, 0x16u);
      }
    }
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 5224) < 3u)
  {
    nw_protocol_get_input_handler();
    nw_protocol_notify_quiet();
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v5 = "";
          if (v3)
            v5 = (const char *)(v3 + 604);
          v9 = 136446466;
          v10 = "nw_protocol_tcp_wake_keepalive_block_invoke";
          v11 = 2082;
          v12 = v5;
          _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v9, 0x16u);
        }
      }
    }
  }
  return nw_protocol_release();
}

uint64_t __nw_protocol_tcp_wake_write_timeout_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  NSObject *v7;
  const char *v8;
  int v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v8 = "";
        if (v2)
          v8 = (const char *)(v2 + 604);
        v9 = 136446466;
        v10 = "nw_protocol_tcp_wake_write_timeout_block_invoke";
        v11 = 2082;
        v12 = v8;
        _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s write timeout", (uint8_t *)&v9, 0x16u);
      }
    }
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 5224) < 3u)
  {
    nw_protocol_get_input_handler();
    nw_protocol_notify_quiet();
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v5 = "";
          if (v3)
            v5 = (const char *)(v3 + 604);
          v9 = 136446466;
          v10 = "nw_protocol_tcp_wake_write_timeout_block_invoke";
          v11 = 2082;
          v12 = v5;
          _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v9, 0x16u);
        }
      }
    }
  }
  return nw_protocol_release();
}

uint64_t __nw_protocol_tcp_wake_read_timeout_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  NSObject *v7;
  const char *v8;
  int v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v8 = "";
        if (v2)
          v8 = (const char *)(v2 + 604);
        v9 = 136446466;
        v10 = "nw_protocol_tcp_wake_read_timeout_block_invoke";
        v11 = 2082;
        v12 = v8;
        _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s read timeout", (uint8_t *)&v9, 0x16u);
      }
    }
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 5224) < 3u)
  {
    nw_protocol_get_input_handler();
    nw_protocol_notify_quiet();
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v5 = "";
          if (v3)
            v5 = (const char *)(v3 + 604);
          v9 = 136446466;
          v10 = "nw_protocol_tcp_wake_read_timeout_block_invoke";
          v11 = 2082;
          v12 = v5;
          _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v9, 0x16u);
        }
      }
    }
  }
  return nw_protocol_release();
}

void nw_protocol_tcp_release(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  NSObject *v4;
  uint8_t buf[4];
  const char *v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    *(_DWORD *)(a1 + 5308) &= ~1u;
    nw_protocol_upcast();
    nw_protocol_get_output_handler();
    if (nw_protocol_remove_input_handler_is_valid())
    {
      nw_protocol_get_output_handler();
      nw_protocol_remove_input_handler();
    }
    else if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      v2 = __nwlog_tcp_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v6 = "nw_protocol_tcp_release";
        v7 = 2082;
        v8 = a1 + 604;
        _os_log_impl(&dword_209FB3000, v2, OS_LOG_TYPE_ERROR, "%{public}s %{public}s remove_input_handler is not valid", buf, 0x16u);
      }
    }
    nw_protocol_destroy();
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v6 = "nw_protocol_tcp_release";
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v6 = "nw_protocol_tcp_release";
        _os_log_impl(&dword_209FB3000, v4, OS_LOG_TYPE_ERROR, "%{public}s called with null tcp, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v3)
      free(v3);
  }
}

void __nw_protocol_tcp_release_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  NSObject *v10;
  const char *v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_tcp_dispose";
    v9 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_23;
    v10 = __nwlog_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_tcp_dispose";
    v11 = "%{public}s called with null object, backtrace limit exceeded";
    goto LABEL_22;
  }
  if ((*(_BYTE *)(v1 + 828) & 2) == 0)
  {
    v2 = __nwlog_tcp_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v13 = "nw_protocol_tcp_dispose";
      v14 = 2082;
      v15 = v1 + 604;
      _os_log_impl(&dword_209FB3000, v2, OS_LOG_TYPE_INFO, "%{public}s %{public}s tcp dispose", buf, 0x16u);
    }
  }
  v3 = *(void **)(v1 + 5208);
  if (v3)
  {
    nw_release(v3);
    *(_QWORD *)(v1 + 5208) = 0;
  }
  if (*(_QWORD *)(v1 + 5232))
  {
    nw_tcp_set_callbacks();
    v4 = *(void **)(v1 + 5232);
    if (v4)
    {
      nw_release(v4);
      *(_QWORD *)(v1 + 5232) = 0;
    }
  }
  v5 = *(void **)(v1 + 5216);
  if (v5)
  {
    nw_release(v5);
    *(_QWORD *)(v1 + 5216) = 0;
  }
  v6 = *(void **)(v1 + 5200);
  if (v6)
  {
    nw_release(v6);
    *(_QWORD *)(v1 + 5200) = 0;
  }
  v7 = *(void **)(v1 + 5272);
  if (v7)
  {
    free(v7);
    *(_QWORD *)(v1 + 5272) = 0;
  }
  v8 = *(void **)(v1 + 5280);
  if (v8)
  {
    free(v8);
    *(_QWORD *)(v1 + 5280) = 0;
  }
  bzero((void *)v1, 0x1440uLL);
  if ((*(_BYTE *)(v1 + 5308) & 1) != 0)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_tcp_dispose";
    v9 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault())
      goto LABEL_23;
    v10 = __nwlog_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_tcp_dispose";
    v11 = "%{public}s tcp->release_is_delayed set during dispose, backtrace limit exceeded";
LABEL_22:
    _os_log_impl(&dword_209FB3000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0xCu);
LABEL_23:
    if (v9)
      free(v9);
  }
}

uint64_t ____nw_signpost_is_enabled_block_invoke()
{
  uint64_t result;

  result = networkd_settings_get_BOOL();
  *MEMORY[0x24BDE08B0] = result;
  return result;
}

void tcp_tfo_gen_cookie(uint64_t a1, _QWORD *a2)
{
  char v3;
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  NSObject *v9;
  size_t dataOutMoved;
  __int128 dataIn;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  size_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v3 = *(_BYTE *)(a1 + 2236);
  *(_QWORD *)((char *)&dataIn + 4) = 0;
  HIDWORD(dataIn) = 0;
  *a2 = 0;
  a2[1] = 0;
  if ((v3 & 2) != 0)
    dataIn = *(_OWORD *)(a1 + 464);
  else
    LODWORD(dataIn) = *(_DWORD *)(a1 + 476);
  v4 = nw_tcp_access_globals(*(_QWORD *)(a1 + 224));
  dataOutMoved = 0;
  if (CCCryptorUpdate(*(CCCryptorRef *)(v4 + 80), &dataIn, 0x10uLL, a2, 0x10uLL, &dataOutMoved))
  {
    v5 = __nwlog_obj();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446210;
    v13 = "aes_encrypt_cbc";
    v6 = "%{public}s CCCryptorUpdate";
    v7 = v5;
    v8 = 12;
    goto LABEL_10;
  }
  if (dataOutMoved != 16)
  {
    v9 = __nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v13 = "aes_encrypt_cbc";
      v14 = 2048;
      v15 = dataOutMoved;
      v6 = "%{public}s out_moved is %lu";
      v7 = v9;
      v8 = 22;
LABEL_10:
      _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    }
  }
}

uint64_t ____nw_signpost_is_enabled_block_invoke_84()
{
  uint64_t result;

  result = networkd_settings_get_BOOL();
  *MEMORY[0x24BDE08B0] = result;
  return result;
}

void tcp_drop(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t all_stats;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  char *v11;
  const char *v12;
  int v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
  if (*(int *)(a1 + 12) < 3)
  {
    v8 = *(_QWORD *)(a1 + 1056);
    if (!v8)
      goto LABEL_13;
    v7 = (_QWORD *)(v8 + 456);
    goto LABEL_12;
  }
  *(_DWORD *)(a1 + 12) = 0;
  if (!v4 || (*(_BYTE *)(v4 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v10 = __nwlog_tcp_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v11 = tcpstates[*(int *)(a1 + 12)];
        v14 = "tcp_drop";
        v12 = "";
        v13 = 136446722;
        if (v4)
          v12 = (const char *)(v4 + 604);
        v15 = 2082;
        v16 = v12;
        v17 = 2082;
        v18 = v11;
        _os_log_impl(&dword_209FB3000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", (uint8_t *)&v13, 0x20u);
      }
    }
  }
  if (*(_QWORD *)(v4 + 24))
  {
    all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats)
      *(_DWORD *)(all_stats + 136) = 0;
  }
  tcp_output(a1);
  v6 = *(_QWORD *)(a1 + 1056);
  if (v6)
  {
    v7 = (_QWORD *)(v6 + 424);
LABEL_12:
    ++*v7;
  }
LABEL_13:
  if (a2 == 60)
  {
    v9 = *(_DWORD *)(a1 + 256);
    if (!v9)
      LOWORD(v9) = 60;
    *(_WORD *)(v4 + 378) = v9;
    goto LABEL_18;
  }
  *(_WORD *)(v4 + 378) = a2;
  if (a2)
LABEL_18:
    user_north_signal_error(v4);
  tcp_close(a1);
}

void tcp_segs_sent_clean(uint64_t a1, int a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  void *v12;
  NSObject *v13;
  NSObject *v14;
  uint8_t buf[4];
  const char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 1984);
  if (v4)
  {
    while (1)
    {
      v6 = *(_QWORD *)(v4 + 16);
      if (*(_DWORD *)(v4 + 4) - *(_DWORD *)(a1 + 560) >= 0 || (*(_BYTE *)(v4 + 12) & 9) != 0)
      {
        v7 = *(_QWORD **)(v4 + 24);
        if (!v6)
          goto LABEL_9;
      }
      else
      {
        ++*(_DWORD *)(a1 + 1016);
        v7 = *(_QWORD **)(v4 + 24);
        if (!v6)
        {
LABEL_9:
          *(_QWORD *)(a1 + 1992) = v7;
          goto LABEL_10;
        }
      }
      *(_QWORD *)(v6 + 24) = v7;
      v7 = *(_QWORD **)(v4 + 24);
LABEL_10:
      *v7 = v6;
      tcp_seg_sent_tree_head_RB_REMOVE((unint64_t *)(a1 + 2000), (_QWORD *)v4);
      if (*(_DWORD *)(a1 + 2040) < 0x40u)
      {
        *(_QWORD *)(v4 + 80) = 0;
        *(_OWORD *)(v4 + 48) = 0u;
        *(_OWORD *)(v4 + 64) = 0u;
        *(_OWORD *)(v4 + 16) = 0u;
        *(_OWORD *)(v4 + 32) = 0u;
        *(_OWORD *)v4 = 0u;
        v5 = *(_QWORD **)(a1 + 2032);
        *(_QWORD *)(v4 + 80) = v5;
        *v5 = v4;
        *(_QWORD *)(a1 + 2032) = v4 + 72;
        ++*(_DWORD *)(a1 + 2040);
        v4 = v6;
        if (!v6)
          break;
      }
      else
      {
        nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
        free((void *)v4);
        v4 = v6;
        if (!v6)
          break;
      }
    }
  }
  if (*(_QWORD *)(a1 + 2000))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "tcp_segs_sent_clean";
    v11 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "tcp_segs_sent_clean";
        _os_log_impl(&dword_209FB3000, v13, OS_LOG_TYPE_ERROR, "%{public}s RB tree still contains segments while time ordered list is already empty, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v11)
      free(v11);
  }
  if (*(_QWORD *)(a1 + 2008))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "tcp_segs_sent_clean";
    v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v14 = __nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "tcp_segs_sent_clean";
        _os_log_impl(&dword_209FB3000, v14, OS_LOG_TYPE_ERROR, "%{public}s Segment ACKed list shouldn't contain any segments as they are removed immediately after being ACKed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v12)
      free(v12);
  }
  *(_BYTE *)(a1 + 2069) &= ~0x80u;
  *(_DWORD *)(a1 + 2080) = 0;
  *(_QWORD *)(a1 + 2072) = 0;
  if (a2)
  {
    v8 = *(_QWORD **)(a1 + 2024);
    if (v8)
    {
      do
      {
        v10 = (_QWORD *)v8[9];
        v9 = (_QWORD *)v8[10];
        if (v10)
        {
          v10[10] = v9;
          v9 = (_QWORD *)v8[10];
        }
        else
        {
          *(_QWORD *)(a1 + 2032) = v9;
        }
        *v9 = v10;
        nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
        free(v8);
        v8 = v10;
      }
      while (v10);
    }
    *(_DWORD *)(a1 + 2040) = 0;
  }
}

void socket_post_kev_msg_closed()
{
  void *v0;
  NSObject *v1;
  uint8_t buf[4];
  const char *v3;
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v3 = "socket_post_kev_msg_closed";
  v0 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v1 = __nwlog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v3 = "socket_post_kev_msg_closed";
      _os_log_impl(&dword_209FB3000, v1, OS_LOG_TYPE_ERROR, "%{public}s currently not supported, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v0)
    free(v0);
}

_QWORD *tcp_seg_sent_tree_head_RB_REMOVE(unint64_t *a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  int v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;

  v2 = a2[5];
  if (!a2[4])
  {
    v5 = a2[6] & 0xFFFFFFFFFFFFFFFELL;
    v17 = a2[6] & 1;
    if (!v2)
    {
      if (!v5)
      {
LABEL_37:
        v18 = a1;
        goto LABEL_38;
      }
LABEL_29:
      v18 = (unint64_t *)(v5 + 32);
      if (*(_QWORD **)(v5 + 32) != a2)
        v18 = (unint64_t *)(v5 + 40);
LABEL_38:
      *v18 = v2;
      if (!(_DWORD)v17)
        goto LABEL_41;
      return a2;
    }
LABEL_33:
    if ((*(_QWORD *)(v2 + 48) & 1) != 0)
      v19 = v5 | 1;
    else
      v19 = v5;
    *(_QWORD *)(v2 + 48) = v19;
    if (!v5)
      goto LABEL_37;
    goto LABEL_29;
  }
  if (!v2)
  {
    v5 = a2[6] & 0xFFFFFFFFFFFFFFFELL;
    v17 = a2[6] & 1;
    v2 = a2[4];
    goto LABEL_33;
  }
  do
  {
    v3 = v2;
    v2 = *(_QWORD *)(v2 + 32);
  }
  while (v2);
  v2 = *(_QWORD *)(v3 + 40);
  v4 = *(_QWORD *)(v3 + 48);
  v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
  if (v2)
  {
    if ((*(_QWORD *)(v2 + 48) & 1) != 0)
      v6 = v4 | 1;
    else
      v6 = v4 & 0xFFFFFFFFFFFFFFFELL;
    *(_QWORD *)(v2 + 48) = v6;
  }
  v7 = a1;
  if (v5)
  {
    v7 = (unint64_t *)(v5 + 32);
    if (*(_QWORD *)(v5 + 32) != v3)
      v7 = (unint64_t *)(v5 + 40);
  }
  v8 = v4 & 1;
  *v7 = v2;
  if ((_QWORD *)(*(_QWORD *)(v3 + 48) & 0xFFFFFFFFFFFFFFFELL) == a2)
    v5 = v3;
  v9 = a2[6];
  *(_OWORD *)(v3 + 32) = *((_OWORD *)a2 + 2);
  *(_QWORD *)(v3 + 48) = v9;
  v10 = a1;
  v11 = a2[6] & 0xFFFFFFFFFFFFFFFELL;
  if (v11)
  {
    v13 = *(_QWORD **)(v11 + 32);
    v12 = (unint64_t *)(v11 + 32);
    if (v13 == a2)
      v10 = v12;
    else
      v10 = v12 + 1;
  }
  *v10 = v3;
  v15 = a2[4];
  v14 = a2[5];
  if ((*(_QWORD *)(v15 + 48) & 1) != 0)
    v16 = v3 | 1;
  else
    v16 = v3;
  *(_QWORD *)(v15 + 48) = v16;
  if (v14)
  {
    if ((*(_QWORD *)(v14 + 48) & 1) != 0)
      v3 |= 1uLL;
    *(_QWORD *)(v14 + 48) = v3;
  }
  if (v8)
    return a2;
LABEL_41:
  while (1)
  {
    v20 = (_QWORD *)v2;
    v2 = v5;
    if (v20)
    {
      v21 = v20[6];
      if ((v21 & 1) != 0)
        break;
    }
    v22 = *a1;
    if (v20 == (_QWORD *)*a1)
      goto LABEL_127;
    v23 = *(_QWORD *)(v2 + 32);
    if ((_QWORD *)v23 == v20)
    {
      v23 = *(_QWORD *)(v2 + 40);
      v30 = *(_QWORD *)(v23 + 48);
      if ((v30 & 1) != 0)
      {
        *(_QWORD *)(v23 + 48) = v30 & 0xFFFFFFFFFFFFFFFELL;
        v31 = *(_QWORD *)(v2 + 48) | 1;
        v32 = *(_QWORD **)(v23 + 32);
        *(_QWORD *)(v2 + 40) = v32;
        *(_QWORD *)(v2 + 48) = v31;
        if (v32)
        {
          if ((v32[6] & 1) != 0)
            v33 = v2 | 1;
          else
            v33 = v2;
          v32[6] = v33;
          v31 = *(_QWORD *)(v2 + 48);
        }
        *(_QWORD *)(v23 + 48) = v31 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v23 + 48) & 1;
        if ((v31 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          v34 = *(_QWORD *)(v2 + 48);
          v35 = v34 & 0xFFFFFFFFFFFFFFFELL;
          if (v2 == *(_QWORD *)((v34 & 0xFFFFFFFFFFFFFFFELL) + 32))
          {
            *(_QWORD *)(v35 + 32) = v23;
          }
          else
          {
            *(_QWORD *)(v35 + 40) = v23;
            v32 = *(_QWORD **)(v2 + 40);
          }
        }
        else
        {
          *a1 = v23;
          v34 = *(_QWORD *)(v2 + 48);
          v22 = v23;
        }
        *(_QWORD *)(v23 + 32) = v2;
        if ((v34 & 1) != 0)
          v23 |= 1uLL;
        *(_QWORD *)(v2 + 48) = v23;
        v23 = (unint64_t)v32;
      }
      v40 = *(_QWORD *)(v23 + 32);
      if (v40)
      {
        v41 = *(_QWORD *)(v40 + 48);
        if ((v41 & 1) != 0)
        {
          v42 = *(_QWORD *)(v23 + 40);
          if (!v42 || (*(_BYTE *)(v42 + 48) & 1) == 0)
          {
            *(_QWORD *)(v40 + 48) = v41 & 0xFFFFFFFFFFFFFFFELL;
            v48 = *(_QWORD *)(v23 + 48) | 1;
            *(_QWORD *)(v23 + 48) = v48;
            v49 = *(_QWORD *)(v40 + 40);
            *(_QWORD *)(v23 + 32) = v49;
            if (v49)
            {
              if ((*(_QWORD *)(v49 + 48) & 1) != 0)
                v50 = v23 | 1;
              else
                v50 = v23;
              *(_QWORD *)(v49 + 48) = v50;
              v48 = *(_QWORD *)(v23 + 48);
            }
            *(_QWORD *)(v40 + 48) = v48 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v40 + 48) & 1;
            if ((v48 & 0xFFFFFFFFFFFFFFFELL) != 0)
            {
              v51 = *(_QWORD *)(v23 + 48);
              v52 = v51 & 0xFFFFFFFFFFFFFFFELL;
              if (v23 == *(_QWORD *)((v51 & 0xFFFFFFFFFFFFFFFELL) + 32))
                *(_QWORD *)(v52 + 32) = v40;
              else
                *(_QWORD *)(v52 + 40) = v40;
            }
            else
            {
              *a1 = v40;
              v51 = *(_QWORD *)(v23 + 48);
              v22 = v40;
            }
            *(_QWORD *)(v40 + 40) = v23;
            if ((v51 & 1) != 0)
              v40 |= 1uLL;
            *(_QWORD *)(v23 + 48) = v40;
            v23 = *(_QWORD *)(v2 + 40);
            v42 = *(_QWORD *)(v23 + 40);
          }
LABEL_136:
          *(_QWORD *)(v23 + 48) = *(_QWORD *)(v23 + 48) & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v2 + 48) & 1;
          *(_QWORD *)(v2 + 48) &= ~1uLL;
          if (v42)
            *(_QWORD *)(v42 + 48) &= ~1uLL;
          v53 = (unint64_t *)(v23 + 32);
          v54 = *(_QWORD *)(v23 + 32);
          *(_QWORD *)(v2 + 40) = v54;
          if (v54)
            goto LABEL_115;
          goto LABEL_119;
        }
      }
      v42 = *(_QWORD *)(v23 + 40);
      if (v42 && (*(_BYTE *)(v42 + 48) & 1) != 0)
        goto LABEL_136;
    }
    else
    {
      v24 = *(_QWORD *)(v23 + 48);
      if ((v24 & 1) != 0)
      {
        *(_QWORD *)(v23 + 48) = v24 & 0xFFFFFFFFFFFFFFFELL;
        v25 = *(_QWORD *)(v2 + 48) | 1;
        *(_QWORD *)(v2 + 48) = v25;
        v26 = *(_QWORD **)(v23 + 40);
        *(_QWORD *)(v2 + 32) = v26;
        if (v26)
        {
          if ((v26[6] & 1) != 0)
            v27 = v2 | 1;
          else
            v27 = v2;
          v26[6] = v27;
          v25 = *(_QWORD *)(v2 + 48);
        }
        *(_QWORD *)(v23 + 48) = v25 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v23 + 48) & 1;
        if ((v25 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          v28 = *(_QWORD *)(v2 + 48);
          v29 = v28 & 0xFFFFFFFFFFFFFFFELL;
          if (v2 == *(_QWORD *)((v28 & 0xFFFFFFFFFFFFFFFELL) + 32))
          {
            *(_QWORD *)(v29 + 32) = v23;
            v26 = *(_QWORD **)(v2 + 32);
          }
          else
          {
            *(_QWORD *)(v29 + 40) = v23;
          }
        }
        else
        {
          *a1 = v23;
          v28 = *(_QWORD *)(v2 + 48);
          v22 = v23;
        }
        *(_QWORD *)(v23 + 40) = v2;
        if ((v28 & 1) != 0)
          v23 |= 1uLL;
        *(_QWORD *)(v2 + 48) = v23;
        v23 = (unint64_t)v26;
      }
      v36 = *(_QWORD *)(v23 + 32);
      if (v36)
      {
        v37 = *(_QWORD *)(v36 + 48);
        if ((v37 & 1) != 0)
          goto LABEL_85;
      }
      v38 = *(_QWORD *)(v23 + 40);
      if (v38)
      {
        v39 = *(_QWORD *)(v38 + 48);
        if ((v39 & 1) != 0)
        {
          if (!v36)
            goto LABEL_88;
          v37 = *(_QWORD *)(v36 + 48);
LABEL_85:
          if ((v37 & 1) == 0)
          {
            v38 = *(_QWORD *)(v23 + 40);
            if (v38)
            {
              v39 = *(_QWORD *)(v38 + 48);
LABEL_88:
              *(_QWORD *)(v38 + 48) = v39 & 0xFFFFFFFFFFFFFFFELL;
            }
            v43 = *(_QWORD *)(v23 + 48) | 1;
            v44 = *(_QWORD *)(v38 + 32);
            *(_QWORD *)(v23 + 40) = v44;
            *(_QWORD *)(v23 + 48) = v43;
            if (v44)
            {
              if ((*(_QWORD *)(v44 + 48) & 1) != 0)
                v45 = v23 | 1;
              else
                v45 = v23;
              *(_QWORD *)(v44 + 48) = v45;
              v43 = *(_QWORD *)(v23 + 48);
            }
            *(_QWORD *)(v38 + 48) = v43 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v38 + 48) & 1;
            if ((v43 & 0xFFFFFFFFFFFFFFFELL) != 0)
            {
              v46 = *(_QWORD *)(v23 + 48);
              v47 = v46 & 0xFFFFFFFFFFFFFFFELL;
              if (v23 == *(_QWORD *)((v46 & 0xFFFFFFFFFFFFFFFELL) + 32))
                *(_QWORD *)(v47 + 32) = v38;
              else
                *(_QWORD *)(v47 + 40) = v38;
            }
            else
            {
              *a1 = v38;
              v46 = *(_QWORD *)(v23 + 48);
              v22 = v38;
            }
            *(_QWORD *)(v38 + 32) = v23;
            if ((v46 & 1) != 0)
              v38 |= 1uLL;
            *(_QWORD *)(v23 + 48) = v38;
            v23 = *(_QWORD *)(v2 + 32);
            v36 = *(_QWORD *)(v23 + 32);
          }
          *(_QWORD *)(v23 + 48) = *(_QWORD *)(v23 + 48) & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v2 + 48) & 1;
          *(_QWORD *)(v2 + 48) &= ~1uLL;
          if (v36)
            *(_QWORD *)(v36 + 48) &= ~1uLL;
          v53 = (unint64_t *)(v23 + 40);
          v54 = *(_QWORD *)(v23 + 40);
          *(_QWORD *)(v2 + 32) = v54;
          if (v54)
          {
LABEL_115:
            if ((*(_QWORD *)(v54 + 48) & 1) != 0)
              v55 = v2 | 1;
            else
              v55 = v2;
            *(_QWORD *)(v54 + 48) = v55;
          }
LABEL_119:
          v56 = *(_QWORD *)(v2 + 48);
          *(_QWORD *)(v23 + 48) = v56 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v23 + 48) & 1;
          if ((v56 & 0xFFFFFFFFFFFFFFFELL) != 0)
          {
            v57 = *(_QWORD *)(v2 + 48);
            v58 = v57 & 0xFFFFFFFFFFFFFFFELL;
            if (v2 == *(_QWORD *)((v57 & 0xFFFFFFFFFFFFFFFELL) + 32))
              *(_QWORD *)(v58 + 32) = v23;
            else
              *(_QWORD *)(v58 + 40) = v23;
          }
          else
          {
            *a1 = v23;
            v57 = *(_QWORD *)(v2 + 48);
            v22 = v23;
          }
          *v53 = v2;
          if ((v57 & 1) != 0)
            v23 |= 1uLL;
          *(_QWORD *)(v2 + 48) = v23;
          v20 = (_QWORD *)v22;
LABEL_127:
          if (!v20)
            return a2;
          v21 = v20[6];
          break;
        }
      }
    }
    *(_QWORD *)(v23 + 48) |= 1uLL;
    v5 = *(_QWORD *)(v2 + 48) & 0xFFFFFFFFFFFFFFFELL;
  }
  v20[6] = v21 & 0xFFFFFFFFFFFFFFFELL;
  return a2;
}

void tcp_rxtseg_clean(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;

  v2 = *(_QWORD **)(a1 + 952);
  if (v2)
  {
    v3 = (_QWORD *)(a1 + 952);
    do
    {
      v5 = (_QWORD *)*v3;
      v6 = (_QWORD *)(a1 + 952);
      if ((_QWORD *)*v3 != v2)
      {
        do
        {
          v7 = v5;
          v5 = (_QWORD *)v5[2];
        }
        while (v5 != v2);
        v6 = v7 + 2;
      }
      v4 = (_QWORD *)v2[2];
      *v6 = v4;
      nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
      free(v2);
      v2 = v4;
    }
    while (v4);
  }
  *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
}

uint64_t tcp_next_mtu(int a1, int a2)
{
  uint64_t v2;
  BOOL v3;
  uint64_t v5;

  if (a1 > 65534)
  {
    if ((a2 & 0x80000000) == 0)
    {
      v2 = 0;
      goto LABEL_28;
    }
    return 0;
  }
  if (a1 > 31999)
  {
    v3 = 0;
    v2 = 1;
  }
  else if (a1 > 17913)
  {
    v3 = 0;
    v2 = 2;
  }
  else if (a1 > 8165)
  {
    v3 = 0;
    v2 = 3;
  }
  else if (a1 > 4351)
  {
    v3 = 0;
    v2 = 4;
  }
  else if (a1 > 2001)
  {
    v3 = 0;
    v2 = 5;
  }
  else if (a1 > 1491)
  {
    v3 = 0;
    v2 = 6;
  }
  else if (a1 > 1005)
  {
    v3 = 0;
    v2 = 7;
  }
  else if (a1 > 507)
  {
    v3 = 0;
    v2 = 8;
  }
  else if (a1 > 295)
  {
    v3 = 0;
    v2 = 9;
  }
  else
  {
    v3 = a1 < 68;
    v2 = 10;
    if (a1 < 68)
      v2 = 11;
  }
  if (a2 < 0)
  {
    v5 = v2 - 1;
    return tcp_next_mtu_mtutab[v5];
  }
  if (v3)
    return 0;
LABEL_28:
  if ((int)tcp_next_mtu_mtutab[v2] < a1)
    return tcp_next_mtu_mtutab[v2];
  v5 = v2 + 1;
  return tcp_next_mtu_mtutab[v5];
}

void tcp_notify(uint64_t a1, int a2)
{
  uint64_t v4;
  int v5;
  NSObject *v6;
  void *v7;

  if (a1 && *(_DWORD *)(a1 + 232) != 3)
  {
    v4 = *(_QWORD *)(a1 + 240);
    if (!v4)
    {
      v6 = __nwlog_obj();
      os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
      v7 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
      {
        __break(1u);
        return;
      }
      free(v7);
    }
    v5 = *(_DWORD *)(v4 + 12);
    if (v5 == 4)
    {
      if ((a2 - 51) <= 0xE && ((1 << (a2 - 51)) & 0x6001) != 0)
      {
        if (*(_QWORD *)(a1 + 496))
          *(_QWORD *)(a1 + 496) = 0;
        return;
      }
    }
    else if (v5 <= 3 && *(unsigned __int16 *)(v4 + 226) >= 4u && *(_DWORD *)(v4 + 256))
    {
      tcp_drop(v4, a2);
      return;
    }
    *(_DWORD *)(v4 + 256) = a2;
  }
}

void tcp_drop_syn_sent(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 240);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 12) == 2)
      tcp_drop(v2, a2);
  }
}

void tcp_handle_msgsize(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  uint64_t v5;
  void *v6;
  NSObject *v7;
  uint64_t v8;
  unint64_t v9;
  BOOL v10;
  unint64_t v11;
  NSObject *v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (a1 && (*(_DWORD *)(a1 + 1480) & 0x2000001) == 1)
  {
    v2 = *(_QWORD *)(a1 + 1488);
    if (!v2 || *(_BYTE *)(v2 + 73))
      return;
    v3 = a2;
    if (a2)
      goto LABEL_37;
    v4 = *(_DWORD *)(v2 + 48);
    if (v4 <= 65534)
    {
      if (v4 > 31999)
      {
        v5 = 1;
      }
      else if (v4 > 17913)
      {
        v5 = 2;
      }
      else if (v4 > 8165)
      {
        v5 = 3;
      }
      else if (v4 > 4351)
      {
        v5 = 4;
      }
      else if (v4 > 2001)
      {
        v5 = 5;
      }
      else if (v4 > 1491)
      {
        v5 = 6;
      }
      else if (v4 > 1005)
      {
        v5 = 7;
      }
      else if (v4 > 507)
      {
        v5 = 8;
      }
      else if (v4 > 295)
      {
        v5 = 9;
      }
      else
      {
        if (v4 < 68)
        {
          v3 = 0;
LABEL_37:
          v8 = *(int *)(sysctls + 164);
          v9 = v8 + 40;
          v10 = (int)v8 < 256;
          v11 = 296;
          if (!v10)
            v11 = v9;
          if (v11 <= v3)
          {
            if (*(_DWORD *)(v2 + 48) > v3)
            {
              *(_DWORD *)(v2 + 48) = v3;
              if (__nwlog_is_datapath_logging_enabled())
              {
                v12 = __nwlog_obj();
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446466;
                  v14 = "tcp_handle_msgsize";
                  v15 = 1024;
                  LODWORD(v16) = v3;
                  _os_log_impl(&dword_209FB3000, v12, OS_LOG_TYPE_DEBUG, "%{public}s MTU reduced to %d\n", buf, 0x12u);
                }
              }
            }
          }
          else
          {
            *(_BYTE *)(v2 + 73) = 1;
          }
          return;
        }
        v5 = 10;
      }
    }
    else
    {
      v5 = 0;
    }
    v3 = tcp_next_mtu_mtutab[v5];
    if ((int)v3 >= v4)
      v3 = tcp_next_mtu_mtutab[v5 + 1];
    goto LABEL_37;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "tcp_handle_msgsize";
  v6 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v7 = __nwlog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v14 = "tcp_handle_msgsize";
      _os_log_impl(&dword_209FB3000, v7, OS_LOG_TYPE_ERROR, "%{public}s TCP route unusable, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v6)
    free(v6);
}

uint64_t tcp_rtlookup6(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  _DWORD *v13;
  int v14;
  unsigned int *v15;
  unsigned int v16;
  int v17;
  int v18;

  v4 = (uint64_t *)(a1 + 496);
  v5 = *(_QWORD *)(a1 + 496);
  if (v5)
  {
    if ((*(_DWORD *)(v5 + 1480) & 0x2000001) == 1)
    {
LABEL_11:
      v7 = *(_QWORD *)(a1 + 240);
      if (*(_DWORD *)(sysctls + 80)
        && ((v8 = *(_QWORD *)(v5 + 1488)) == 0 || (*(_BYTE *)(v5 + 1480) & 1) != 0 && !*(_BYTE *)(v8 + 73)))
      {
        v9 = *(_DWORD *)(v7 + 88) | 0x4000000;
      }
      else
      {
        v9 = *(_DWORD *)(v7 + 88) & 0xFBFFFFFF;
      }
      *(_DWORD *)(v7 + 88) = v9;
      v13 = *(_DWORD **)(v5 + 216);
      if (!v13)
      {
LABEL_36:
        if (*(_BYTE *)(v5 + 1484))
          *(_DWORD *)(v7 + 88) |= 0x20000u;
        return v5;
      }
      *(_DWORD *)(v7 + 88) = v9 & 0xEFFFFFFF;
      v14 = v13[262];
      if ((*(_BYTE *)(*(_QWORD *)(v7 + 80) + 2236) & 2) != 0)
      {
        if ((v14 & 0x400000) != 0)
        {
          *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
          v15 = v13 + 265;
          goto LABEL_26;
        }
      }
      else if ((v14 & 0x200000) != 0)
      {
        *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
        v15 = v13 + 264;
LABEL_26:
        v16 = *v15;
        if (v16 >= 0xFFFF)
          v17 = 0xFFFF;
        else
          v17 = v16;
        if (v16)
          v18 = v17;
        else
          v18 = 0xFFFF;
        *(_DWORD *)(v7 + 692) = v18;
      }
      tcp_set_ecn(v7);
      os_unfair_lock_lock((os_unfair_lock_t)(v7 + 1864));
      if (!*(_QWORD *)(a1 + 448))
        *(_QWORD *)(a1 + 448) = *(_QWORD *)(v5 + 216);
      os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 1864));
      goto LABEL_36;
    }
    if (*(_BYTE *)(v5 + 1496))
    {
      v6 = *(void **)(v5 + 1488);
      if (v6)
      {
        free(v6);
        v5 = *v4;
        *(_QWORD *)(*v4 + 1488) = 0;
      }
      *(_BYTE *)(v5 + 1496) = 0;
    }
  }
  *(_WORD *)(a1 + 2008) = 7708;
  *(_OWORD *)(a1 + 2016) = *(_OWORD *)(a1 + 464);
  if ((*(_BYTE *)(a1 + 2229) & 0x40) != 0)
    a2 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 440) + 1072);
  bzero((void *)(a1 + 504), 0x5E0uLL);
  *(_OWORD *)(a1 + 704) = *(_OWORD *)(a1 + 2008);
  *(_QWORD *)(a1 + 720) = a1 + 728;
  *(_OWORD *)(a1 + 1768) = 0u;
  *(_DWORD *)(a1 + 1784) = 0;
  *(_WORD *)(a1 + 1800) = 1;
  *(_BYTE *)(a1 + 1804) = 6;
  *(_QWORD *)(a1 + 1960) = a1 + 1968;
  *(_BYTE *)(a1 + 1969) = 2;
  *(_DWORD *)(a1 + 1984) = 1;
  *(_QWORD *)(a1 + 496) = a1 + 504;
  if (((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t))(a1 + 2136))(v4, a1 + 504, a2) & 0x80000000) != 0)
  {
    *v4 = 0;
  }
  else
  {
    v5 = *v4;
    if (*v4)
      goto LABEL_11;
  }
  v10 = *(_QWORD *)(a1 + 240);
  v11 = *(_DWORD *)(v10 + 88);
  v5 = 0;
  if (*(_DWORD *)(sysctls + 80))
    v12 = v11 | 0x4000000;
  else
    v12 = v11 & 0xFBFFFFFF;
  *(_DWORD *)(v10 + 88) = v12;
  return v5;
}

uint64_t tcp_set_max_rwinscale(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  int *v3;
  int v4;
  unsigned int v5;
  int v7;

  v2 = *(int *)(sysctls + 184);
  if (v2 <= *(unsigned __int8 *)(result + 262))
    LOBYTE(v2) = *(_BYTE *)(result + 262);
  v3 = (int *)(sysctls + 72);
  if ((*(_BYTE *)(a2 + 537) & 2) != 0)
    v3 = (int *)(a2 + 492);
  v4 = *v3;
  v5 = v2;
  if (v2 <= 0xDu && 0x10000 << v2 < v4)
  {
    do
    {
      LOBYTE(v2) = v5 + 1;
      if (v5 > 0xC)
        break;
      v7 = 0x20000 << v5++;
    }
    while (v7 < v4);
  }
  if (v2 >= 0xEu)
    LOBYTE(v2) = 14;
  *(_BYTE *)(result + 262) = v2;
  return result;
}

_QWORD *tcp_rxtseg_insert(_QWORD *result, int a2, int a3)
{
  int v3;
  int v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;
  __int16 v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;

  v3 = a3;
  v4 = a2;
  v5 = result;
  v6 = (_QWORD *)result[119];
  if (v6)
  {
    v7 = *(_DWORD *)v6 - a2 > 0;
    if (*(_DWORD *)v6 - a2 > 0)
    {
      v8 = 0;
      v9 = 0;
      goto LABEL_4;
    }
    do
    {
      v9 = v6;
      v6 = (_QWORD *)v6[2];
      if (!v6)
      {
        result = 0;
        goto LABEL_17;
      }
    }
    while (*(_DWORD *)v6 - a2 <= 0);
    result = v6;
LABEL_17:
    v11 = *((_DWORD *)v9 + 1);
    if (*(_DWORD *)v9 - a2 <= 0 && ((v11 - a3) & 0x80000000) == 0)
    {
      ++*((_WORD *)v9 + 4);
      return result;
    }
    if (v11 - a2 < 1)
    {
      if (v6)
      {
LABEL_33:
        v8 = 0;
        goto LABEL_34;
      }
      goto LABEL_31;
    }
    if (*(_DWORD *)v9 == a2 && a3 - v11 >= 1)
    {
      v4 = v11 + 1;
      ++*((_WORD *)v9 + 4);
      if (v6)
        goto LABEL_33;
LABEL_31:
      v7 = 0;
      v8 = 0;
      goto LABEL_11;
    }
    *((_DWORD *)v9 + 1) = a2 - 1;
    v8 = *((_WORD *)v9 + 4);
    if (v6)
    {
LABEL_34:
      v6 = result;
LABEL_4:
      if (*(_DWORD *)v6 - a3 < 0)
      {
        if (*((_DWORD *)v6 + 1) - a3 <= 0)
        {
          v3 = *(_DWORD *)v6 - 1;
          ++*((_WORD *)v6 + 4);
        }
        else
        {
          *(_DWORD *)v6 = a3 + 1;
          v8 = *((_WORD *)v6 + 4);
        }
      }
      goto LABEL_11;
    }
    v7 = 0;
  }
  else
  {
    v9 = 0;
    v8 = 0;
    *((_DWORD *)result + 240) = *((_DWORD *)result + 23);
    v7 = 1;
  }
LABEL_11:
  if (v4 - v3 < 0)
  {
    v10 = nw_tcp_access_globals(*(_QWORD *)(v5[10] + 224));
    result = malloc_type_malloc(**(_QWORD **)(v10 + 56), 0xB9BAFBABuLL);
    if (result)
    {
      result[2] = 0;
      *(_QWORD *)((char *)result + 10) = 0;
      *(_DWORD *)result = v4;
      *((_DWORD *)result + 1) = v3;
      *((_WORD *)result + 4) = v8 + 1;
      if (v7)
      {
        result[2] = v5[119];
        v5[119] = result;
      }
      else
      {
        result[2] = v9[2];
        v9[2] = result;
      }
    }
  }
  return result;
}

uint64_t tcp_seg_sent_tree_head_RB_INSERT_COLOR(uint64_t result, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;

  v2 = *(_QWORD *)(a2 + 48);
  while (1)
  {
    v4 = (_QWORD *)(v2 & 0xFFFFFFFFFFFFFFFELL);
    if ((v2 & 0xFFFFFFFFFFFFFFFELL) == 0)
      break;
    v5 = v4[6];
    if ((v5 & 1) == 0)
      break;
    v6 = (_QWORD *)(v5 & 0xFFFFFFFFFFFFFFFELL);
    v7 = *(_QWORD **)((v5 & 0xFFFFFFFFFFFFFFFELL) + 32);
    if (v7 == v4)
    {
      v7 = (_QWORD *)v6[5];
      if (v7)
      {
        v8 = v7[6];
        if ((v8 & 1) != 0)
        {
LABEL_2:
          v7[6] = v8 & 0xFFFFFFFFFFFFFFFELL;
          v4[6] &= ~1uLL;
          v6[6] |= 1uLL;
          v3 = v5 & 0xFFFFFFFFFFFFFFFELL;
          goto LABEL_3;
        }
      }
      v10 = (_QWORD *)v4[5];
      if (v10 == (_QWORD *)a2)
      {
        v16 = *(_QWORD *)(a2 + 32);
        v4[5] = v16;
        if (v16)
        {
          v17 = v2 | 1;
          if ((*(_QWORD *)(v16 + 48) & 1) == 0)
            v17 = (uint64_t)v4;
          *(_QWORD *)(v16 + 48) = v17;
          v18 = v4[6];
          v2 = *(_QWORD *)(a2 + 48);
        }
        else
        {
          v18 = v5;
        }
        *(_QWORD *)(a2 + 48) = v18 & 0xFFFFFFFFFFFFFFFELL | v2 & 1;
        if ((v18 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          v29 = v4[6];
          v30 = v29 & 0xFFFFFFFFFFFFFFFELL;
          if (*(_QWORD **)((v29 & 0xFFFFFFFFFFFFFFFELL) + 32) == v4)
            *(_QWORD *)(v30 + 32) = a2;
          else
            *(_QWORD *)(v30 + 40) = a2;
        }
        else
        {
          *(_QWORD *)result = a2;
          v29 = v4[6];
        }
        *(_QWORD *)(a2 + 32) = v4;
        if ((v29 & 1) != 0)
          v31 = a2 | 1;
        else
          v31 = a2;
        v4[6] = v31;
        v12 = v6[4];
        v10 = *(_QWORD **)(v12 + 40);
        v11 = *(_QWORD *)(a2 + 48) & 0xFFFFFFFFFFFFFFFELL;
        v3 = (unint64_t)v4;
      }
      else
      {
        v11 = v5 & 0xFFFFFFFFFFFFFFFELL;
        v12 = v2 & 0xFFFFFFFFFFFFFFFELL;
        v3 = a2;
        a2 = (unint64_t)v4;
      }
      *(_QWORD *)(a2 + 48) = v11;
      v32 = v6[6] | 1;
      v6[6] = v32;
      v6[4] = v10;
      if (v10)
      {
        v33 = v5 | 1;
        if ((v10[6] & 1) == 0)
          v33 = (uint64_t)v6;
        v10[6] = v33;
        v32 = v6[6];
      }
      *(_QWORD *)(v12 + 48) = v32 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v12 + 48) & 1;
      if ((v32 & 0xFFFFFFFFFFFFFFFELL) != 0)
      {
        v34 = v6[6];
        v35 = v34 & 0xFFFFFFFFFFFFFFFELL;
        if (*(_QWORD **)((v34 & 0xFFFFFFFFFFFFFFFELL) + 32) == v6)
          *(_QWORD *)(v35 + 32) = v12;
        else
          *(_QWORD *)(v35 + 40) = v12;
      }
      else
      {
        *(_QWORD *)result = v12;
        v34 = v6[6];
      }
      *(_QWORD *)(v12 + 40) = v6;
      if ((v34 & 1) != 0)
        v36 = v12 | 1;
      else
        v36 = v12;
      v6[6] = v36;
    }
    else
    {
      if (v7)
      {
        v8 = v7[6];
        if ((v8 & 1) != 0)
          goto LABEL_2;
      }
      if (v4[4] == a2)
      {
        v13 = *(_QWORD *)(a2 + 40);
        v4[4] = v13;
        if (v13)
        {
          v14 = v2 | 1;
          if ((*(_QWORD *)(v13 + 48) & 1) == 0)
            v14 = (uint64_t)v4;
          *(_QWORD *)(v13 + 48) = v14;
          v15 = v4[6];
          v2 = *(_QWORD *)(a2 + 48);
        }
        else
        {
          v15 = v5;
        }
        *(_QWORD *)(a2 + 48) = v15 & 0xFFFFFFFFFFFFFFFELL | v2 & 1;
        if ((v15 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          v19 = v4[6];
          v20 = v19 & 0xFFFFFFFFFFFFFFFELL;
          if (*(_QWORD **)((v19 & 0xFFFFFFFFFFFFFFFELL) + 32) == v4)
            *(_QWORD *)(v20 + 32) = a2;
          else
            *(_QWORD *)(v20 + 40) = a2;
        }
        else
        {
          *(_QWORD *)result = a2;
          v19 = v4[6];
        }
        *(_QWORD *)(a2 + 40) = v4;
        if ((v19 & 1) != 0)
          v21 = a2 | 1;
        else
          v21 = a2;
        v4[6] = v21;
        v9 = *(_QWORD *)(a2 + 48) & 0xFFFFFFFFFFFFFFFELL;
        v3 = (unint64_t)v4;
      }
      else
      {
        v9 = v5 & 0xFFFFFFFFFFFFFFFELL;
        v3 = a2;
        a2 = (unint64_t)v4;
      }
      *(_QWORD *)(a2 + 48) = v9;
      v22 = v6[5];
      v23 = v6[6] | 1;
      v24 = *(_QWORD *)(v22 + 32);
      v6[5] = v24;
      v6[6] = v23;
      if (v24)
      {
        v25 = v5 | 1;
        if ((*(_QWORD *)(v24 + 48) & 1) == 0)
          v25 = (uint64_t)v6;
        *(_QWORD *)(v24 + 48) = v25;
        v23 = v6[6];
      }
      *(_QWORD *)(v22 + 48) = v23 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v22 + 48) & 1;
      if ((v23 & 0xFFFFFFFFFFFFFFFELL) != 0)
      {
        v26 = v6[6];
        v27 = v26 & 0xFFFFFFFFFFFFFFFELL;
        if (*(_QWORD **)((v26 & 0xFFFFFFFFFFFFFFFELL) + 32) == v6)
          *(_QWORD *)(v27 + 32) = v22;
        else
          *(_QWORD *)(v27 + 40) = v22;
      }
      else
      {
        *(_QWORD *)result = v22;
        v26 = v6[6];
      }
      *(_QWORD *)(v22 + 32) = v6;
      if ((v26 & 1) != 0)
        v28 = v22 | 1;
      else
        v28 = v22;
      v6[6] = v28;
    }
LABEL_3:
    v2 = *(_QWORD *)(v3 + 48);
    a2 = v3;
  }
  *(_QWORD *)(*(_QWORD *)result + 48) &= ~1uLL;
  return result;
}

uint64_t tcp_seg_len(int *a1)
{
  int v2;
  int v3;
  uint64_t result;
  int v5;
  int v6;
  void *v7;
  NSObject *v8;
  int v9;
  int v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v3 = *a1;
  v2 = a1[1];
  result = (v2 - *a1);
  if (v2 - v3 < 0)
  {
    __nwlog_obj();
    v6 = *a1;
    v5 = a1[1];
    *(_DWORD *)buf = 136446722;
    v12 = "tcp_seg_len";
    v13 = 1024;
    v14 = v5;
    v15 = 1024;
    v16 = v6;
    v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v10 = *a1;
        v9 = a1[1];
        *(_DWORD *)buf = 136446722;
        v12 = "tcp_seg_len";
        v13 = 1024;
        v14 = v9;
        v15 = 1024;
        v16 = v10;
        _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_ERROR, "%{public}s segment end(%u) can't be smaller than segment start(%u), backtrace limit exceeded", buf, 0x18u);
      }
    }
    if (v7)
      free(v7);
    return (a1[1] - *a1);
  }
  return result;
}

uint64_t tcp_process_rxmt_segs_after_rto(uint64_t result, int *a2, int a3, int a4, char a5)
{
  int *v7;
  uint64_t v8;
  int v9;
  char v11;
  int v12;
  char v13;
  int v14;
  uint64_t v15;
  _QWORD *v16;
  int **v17;
  int v18;
  char v19;
  int v20;
  uint64_t v21;
  _QWORD *v22;
  int **v23;

  v7 = a2;
  v8 = result;
  v9 = *a2;
  if (*a2 - a3 <= 0)
  {
    v12 = a2[1];
LABEL_24:
    *v7 = v9;
    v7[1] = v12;
    v7[2] = a4;
    if (v9 - *(_DWORD *)(v8 + 2060) < 0)
      *(_DWORD *)(v8 + 2060) = v9;
    v19 = *((_BYTE *)v7 + 12) | a5;
    *((_BYTE *)v7 + 12) = v19;
    if ((v19 & 4) != 0)
    {
      result = tcp_seg_len(v7);
      *(_DWORD *)(v8 + 2076) += result;
    }
    v20 = *(char *)(v8 + 2069);
    if ((v20 & 0x80000000) == 0)
      *(_BYTE *)(v8 + 2069) = v20 | (32 * a5) & 0x80;
    if (*(int **)(v8 + 1984) == v7)
    {
      v21 = *((_QWORD *)v7 + 2);
      v22 = (_QWORD *)*((_QWORD *)v7 + 3);
      if (v21)
      {
        *(_QWORD *)(v21 + 24) = v22;
        v22 = (_QWORD *)*((_QWORD *)v7 + 3);
      }
      else
      {
        *(_QWORD *)(v8 + 1992) = v22;
      }
      *v22 = v21;
      v23 = *(int ***)(v8 + 1992);
      *((_QWORD *)v7 + 2) = 0;
      *((_QWORD *)v7 + 3) = v23;
      *v23 = v7;
      *(_QWORD *)(v8 + 1992) = v7 + 4;
    }
  }
  else
  {
    v11 = (32 * a5) & 0x80;
    v12 = a2[1];
    while (1)
    {
      *v7 = v9;
      v7[1] = v12;
      v7[2] = a4;
      if (v9 - *(_DWORD *)(v8 + 2060) < 0)
        *(_DWORD *)(v8 + 2060) = v9;
      v13 = *((_BYTE *)v7 + 12) | a5;
      *((_BYTE *)v7 + 12) = v13;
      if ((v13 & 4) != 0)
      {
        result = tcp_seg_len(v7);
        *(_DWORD *)(v8 + 2076) += result;
      }
      v14 = *(char *)(v8 + 2069);
      if ((v14 & 0x80000000) == 0)
        *(_BYTE *)(v8 + 2069) = v14 | v11;
      if (*(int **)(v8 + 1984) == v7)
      {
        v15 = *((_QWORD *)v7 + 2);
        v16 = (_QWORD *)*((_QWORD *)v7 + 3);
        if (v15)
        {
          *(_QWORD *)(v15 + 24) = v16;
          v16 = (_QWORD *)*((_QWORD *)v7 + 3);
        }
        else
        {
          *(_QWORD *)(v8 + 1992) = v16;
        }
        *v16 = v15;
        v17 = *(int ***)(v8 + 1992);
        *((_QWORD *)v7 + 2) = 0;
        *((_QWORD *)v7 + 3) = v17;
        *v17 = v7;
        *(_QWORD *)(v8 + 1992) = v7 + 4;
      }
      if (!*(_QWORD *)(v8 + 2000))
        break;
      v12 = *v7;
      v7 = *(int **)(v8 + 2000);
      while (1)
      {
        while (1)
        {
          v18 = v7[1];
          if (v12 - v18 >= 0)
            break;
          v7 = (int *)*((_QWORD *)v7 + 4);
          if (!v7)
            return result;
        }
        if (v12 == v18)
          break;
        v7 = (int *)*((_QWORD *)v7 + 5);
        if (!v7)
          return result;
      }
      v9 = *v7;
      if (*v7 - a3 <= 0)
        goto LABEL_24;
    }
  }
  return result;
}

void tcp_seg_rto_insert_end(uint64_t a1, int a2, int a3, int a4, char a5)
{
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  char v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  _QWORD *v19;
  _QWORD *v20;
  NSObject *v21;
  int v22;
  int v23;
  int v24;
  const char *v25;
  __int16 v26;
  unint64_t v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD **)(a1 + 2024);
  if (v10)
  {
    v11 = v10[9];
    v12 = (_QWORD *)v10[10];
    if (v11)
    {
      *(_QWORD *)(v11 + 80) = v12;
      v12 = (_QWORD *)v10[10];
    }
    else
    {
      *(_QWORD *)(a1 + 2032) = v12;
    }
    *v12 = v11;
    --*(_DWORD *)(a1 + 2040);
    goto LABEL_8;
  }
  v13 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  v10 = malloc_type_malloc(**(_QWORD **)(v13 + 64), 0xB9BAFBABuLL);
  if (v10)
  {
LABEL_8:
    v10[10] = 0;
    *((_OWORD *)v10 + 3) = 0u;
    *((_OWORD *)v10 + 4) = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *(_OWORD *)v10 = 0u;
  }
  *(_DWORD *)v10 = a2;
  *((_DWORD *)v10 + 1) = a3;
  *((_DWORD *)v10 + 2) = a4;
  if (a2 - *(_DWORD *)(a1 + 2060) < 0)
    *(_DWORD *)(a1 + 2060) = a2;
  v14 = *((_BYTE *)v10 + 12) | a5;
  *((_BYTE *)v10 + 12) = v14;
  if ((v14 & 4) != 0)
    *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v10);
  v15 = *(char *)(a1 + 2069);
  if ((v15 & 0x80000000) == 0)
    *(_BYTE *)(a1 + 2069) = v15 | (32 * a5) & 0x80;
  v16 = *(_QWORD *)(a1 + 2000);
  if (v16)
  {
    while (1)
    {
      while (1)
      {
        v17 = v16;
        v18 = *((_DWORD *)v10 + 1) - *(_DWORD *)(v16 + 4);
        if (v18 >= 0)
          break;
        v16 = *(_QWORD *)(v16 + 32);
        if (!v16)
          goto LABEL_23;
      }
      if (!v18)
        break;
      v16 = *(_QWORD *)(v16 + 40);
      if (!v16)
        goto LABEL_23;
    }
    v21 = __nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v22 = *(_DWORD *)v17;
      v23 = *(_DWORD *)(v17 + 4);
      v24 = 136446978;
      v25 = "tcp_seg_rto_insert_end";
      v26 = 2048;
      v27 = v17;
      v28 = 1024;
      v29 = v22;
      v30 = 1024;
      v31 = v23;
      _os_log_impl(&dword_209FB3000, v21, OS_LOG_TYPE_ERROR, "%{public}s segment %p[%u %u) was not inserted in the RB tree", (uint8_t *)&v24, 0x22u);
    }
  }
  else
  {
    v17 = 0;
    v18 = 0;
LABEL_23:
    v10[4] = 0;
    v10[5] = 0;
    v10[6] = v17 | 1;
    if (v18 < 0)
      v19 = (_QWORD *)(v17 + 32);
    else
      v19 = (_QWORD *)(v17 + 40);
    if (!v17)
      v19 = (_QWORD *)(a1 + 2000);
    *v19 = v10;
    tcp_seg_sent_tree_head_RB_INSERT_COLOR(a1 + 2000, (unint64_t)v10);
  }
  v10[2] = 0;
  v20 = *(_QWORD **)(a1 + 1992);
  v10[3] = v20;
  *v20 = v10;
  *(_QWORD *)(a1 + 1992) = v10 + 2;
}

void tcp_segs_doack(uint64_t a1, uint64_t a2, int a3, int a4)
{
  int v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  BOOL v23;
  unsigned int v24;

  if (*(_QWORD *)(a1 + 1984))
  {
    v6 = (a3 << 31 >> 31) & a4;
    if ((*(char *)(a1 + 2069) & 0x80000000) == 0)
    {
      v7 = **(_QWORD **)(*(_QWORD *)(a1 + 1992) + 8);
      v8 = *(_DWORD *)(v7 + 4);
      if ((int)a2 - v8 >= 0)
      {
        v9 = *(_DWORD *)(v7 + 8);
        v10 = (*(unsigned __int8 *)(v7 + 12) >> 3) & 1;
        tcp_segs_sent_clean(a1, 0);
        v11 = a1;
        v12 = v6;
        v13 = v9;
        v14 = v8;
LABEL_29:
        tcp_rack_update_segment_acked(v11, v12, v13, v14, v10);
        return;
      }
    }
    v15 = *(_QWORD *)(a1 + 2000);
    if (v15)
    {
      v16 = *(_QWORD *)(a1 + 2000);
      do
      {
        while (1)
        {
          v17 = *(_DWORD *)(v16 + 4);
          if ((int)a2 - v17 >= 0)
            break;
          v16 = *(_QWORD *)(v16 + 32);
          if (!v16)
            goto LABEL_11;
        }
        if ((_DWORD)a2 == v17)
        {
          v24 = *(_DWORD *)(v16 + 8);
          v10 = (*(unsigned __int8 *)(v16 + 12) >> 3) & 1;
          tcp_seg_collect_acked(a1, v15, a2);
          tcp_seg_delete_acked(a1, v24, v6);
          goto LABEL_28;
        }
        v16 = *(_QWORD *)(v16 + 40);
      }
      while (v16);
LABEL_11:
      v18 = *(_QWORD *)(a1 + 2000);
      do
      {
        v19 = v18;
        v18 = *(_QWORD *)(v18 + 32);
      }
      while (v18);
      while (1)
      {
        v20 = *(_QWORD *)(v19 + 40);
        if (v20)
        {
          do
          {
            v21 = v20;
            v20 = *(_QWORD *)(v20 + 32);
          }
          while (v20);
        }
        else
        {
          v21 = *(_QWORD *)(v19 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v21 || *(_QWORD *)(v21 + 32) != v19)
          {
            v22 = v19;
            do
            {
              v21 = *(_QWORD *)(v22 + 48) & 0xFFFFFFFFFFFFFFFELL;
              if (!v21)
                break;
              v23 = v22 == *(_QWORD *)(v21 + 40);
              v22 = *(_QWORD *)(v22 + 48) & 0xFFFFFFFFFFFFFFFELL;
            }
            while (v23);
          }
        }
        if ((int)a2 - *(_DWORD *)(v19 + 4) < 0 && (int)a2 - *(_DWORD *)v19 >= 1)
          break;
        v19 = v21;
        if (!v21)
          return;
      }
      v24 = *(_DWORD *)(v19 + 8);
      v10 = (*(unsigned __int8 *)(v19 + 12) >> 3) & 1;
      tcp_seg_collect_acked(a1, v15, a2);
      tcp_seg_delete_acked(a1, v24, v6);
      *(_DWORD *)v19 = a2;
LABEL_28:
      v11 = a1;
      v12 = v6;
      v13 = v24;
      v14 = a2;
      goto LABEL_29;
    }
  }
}

uint64_t tcp_seg_collect_acked(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;

  if (a2)
  {
    v4 = a2;
    v5 = result;
    while (1)
    {
      v6 = *(_QWORD **)(v4 + 32);
      if ((int)a3 - *(_DWORD *)(v4 + 4) >= 0)
        break;
      v4 = *(_QWORD *)(v4 + 32);
      if (!v6)
        return result;
    }
    tcp_seg_collect_acked_subtree(result, v6);
    result = tcp_seg_collect_acked(v5, *(_QWORD *)(v4 + 40), a3);
    *(_QWORD *)(v4 + 56) = 0;
    v7 = *(_QWORD **)(v5 + 2016);
    *(_QWORD *)(v4 + 64) = v7;
    *v7 = v4;
    *(_QWORD *)(v5 + 2016) = v4 + 56;
  }
  return result;
}

void tcp_seg_delete_acked(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3;
  _QWORD *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  char v11;
  uint64_t v12;
  _QWORD *v13;
  unsigned int v14;
  int v15;
  void *v16;
  NSObject *v17;
  int v18;
  unsigned int v19;
  int v20;
  void *v21;
  NSObject *v22;
  int v23;
  unsigned int v24;
  int v25;
  void *v26;
  NSObject *v27;
  int v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t *v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  unsigned int v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 2008);
  if (v3)
  {
    v32 = (unint64_t *)(a1 + 2000);
    while (1)
    {
      v7 = *(_QWORD *)(v3 + 56);
      v8 = *(_DWORD *)(v3 + 8);
      if (v8 > a2)
        tcp_rack_update_segment_acked(a1, a3, v8, *(_DWORD *)(v3 + 4), (*(unsigned __int8 *)(v3 + 12) >> 3) & 1);
      if (*(_DWORD *)(v3 + 4) - *(_DWORD *)(a1 + 560) < 0 && (*(_BYTE *)(v3 + 12) & 9) == 0)
        ++*(_DWORD *)(a1 + 1016);
      v9 = tcp_seg_len((int *)v3);
      v10 = v9;
      v11 = *(_BYTE *)(v3 + 12);
      if ((v11 & 2) != 0)
      {
        v14 = *(_DWORD *)(a1 + 2072);
        if (v14 < v9)
        {
          __nwlog_obj();
          v15 = *(_DWORD *)(a1 + 2072);
          *(_DWORD *)buf = 136446722;
          v34 = "tcp_seg_delete_acked";
          v35 = 1024;
          v36 = v15;
          v37 = 1024;
          v38 = v10;
          v16 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            v17 = __nwlog_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              v18 = *(_DWORD *)(a1 + 2072);
              *(_DWORD *)buf = 136446722;
              v34 = "tcp_seg_delete_acked";
              v35 = 1024;
              v36 = v18;
              v37 = 1024;
              v38 = v10;
              _os_log_impl(&dword_209FB3000, v17, OS_LOG_TYPE_ERROR, "%{public}s bytes_lost (%u) can't be smaller than already lost segment length (%u), backtrace limit exceeded", buf, 0x18u);
            }
          }
          if (v16)
            free(v16);
          v14 = *(_DWORD *)(a1 + 2072);
          v11 = *(_BYTE *)(v3 + 12);
        }
        *(_DWORD *)(a1 + 2072) = v14 - v10;
        if ((v11 & 4) == 0)
        {
LABEL_11:
          if ((v11 & 1) == 0)
            goto LABEL_12;
          goto LABEL_30;
        }
      }
      else if ((*(_BYTE *)(v3 + 12) & 4) == 0)
      {
        goto LABEL_11;
      }
      v19 = *(_DWORD *)(a1 + 2076);
      if (v19 < v10)
      {
        __nwlog_obj();
        v20 = *(_DWORD *)(a1 + 2076);
        *(_DWORD *)buf = 136446722;
        v34 = "tcp_seg_delete_acked";
        v35 = 1024;
        v36 = v20;
        v37 = 1024;
        v38 = v10;
        v21 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v22 = __nwlog_obj();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            v23 = *(_DWORD *)(a1 + 2076);
            *(_DWORD *)buf = 136446722;
            v34 = "tcp_seg_delete_acked";
            v35 = 1024;
            v36 = v23;
            v37 = 1024;
            v38 = v10;
            _os_log_impl(&dword_209FB3000, v22, OS_LOG_TYPE_ERROR, "%{public}s bytes_retransmitted (%u) can't be smaller than already retransmited segment length (%u), backtrace limit exceeded", buf, 0x18u);
          }
        }
        if (v21)
          free(v21);
        v19 = *(_DWORD *)(a1 + 2076);
        v11 = *(_BYTE *)(v3 + 12);
      }
      *(_DWORD *)(a1 + 2076) = v19 - v10;
      if ((v11 & 1) == 0)
      {
LABEL_12:
        v12 = *(_QWORD *)(v3 + 56);
        v13 = *(_QWORD **)(v3 + 64);
        if (!v12)
          goto LABEL_38;
        goto LABEL_13;
      }
LABEL_30:
      v24 = *(_DWORD *)(a1 + 2080);
      if (v24 < v10)
      {
        __nwlog_obj();
        v25 = *(_DWORD *)(a1 + 2080);
        *(_DWORD *)buf = 136446722;
        v34 = "tcp_seg_delete_acked";
        v35 = 1024;
        v36 = v25;
        v37 = 1024;
        v38 = v10;
        v26 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v27 = __nwlog_obj();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            v28 = *(_DWORD *)(a1 + 2080);
            *(_DWORD *)buf = 136446722;
            v34 = "tcp_seg_delete_acked";
            v35 = 1024;
            v36 = v28;
            v37 = 1024;
            v38 = v10;
            _os_log_impl(&dword_209FB3000, v27, OS_LOG_TYPE_ERROR, "%{public}s bytes_sacked (%u) can't be smaller than already SACKed segment length (%u), backtrace limit exceeded", buf, 0x18u);
          }
        }
        if (v26)
          free(v26);
        v24 = *(_DWORD *)(a1 + 2080);
      }
      *(_DWORD *)(a1 + 2080) = v24 - v10;
      v12 = *(_QWORD *)(v3 + 56);
      v13 = *(_QWORD **)(v3 + 64);
      if (!v12)
      {
LABEL_38:
        *(_QWORD *)(a1 + 2016) = v13;
        goto LABEL_39;
      }
LABEL_13:
      *(_QWORD *)(v12 + 64) = v13;
      v13 = *(_QWORD **)(v3 + 64);
LABEL_39:
      *v13 = v12;
      v29 = *(_QWORD *)(v3 + 16);
      v30 = *(_QWORD **)(v3 + 24);
      if (v29)
      {
        *(_QWORD *)(v29 + 24) = v30;
        v30 = *(_QWORD **)(v3 + 24);
      }
      else
      {
        *(_QWORD *)(a1 + 1992) = v30;
      }
      *v30 = v29;
      tcp_seg_sent_tree_head_RB_REMOVE(v32, (_QWORD *)v3);
      if (*(_DWORD *)(a1 + 2040) < 0x40u)
      {
        *(_QWORD *)(v3 + 80) = 0;
        *(_OWORD *)(v3 + 48) = 0u;
        *(_OWORD *)(v3 + 64) = 0u;
        *(_OWORD *)(v3 + 16) = 0u;
        *(_OWORD *)(v3 + 32) = 0u;
        *(_OWORD *)v3 = 0u;
        v6 = *(_QWORD **)(a1 + 2032);
        *(_QWORD *)(v3 + 80) = v6;
        *v6 = v3;
        *(_QWORD *)(a1 + 2032) = v3 + 72;
        ++*(_DWORD *)(a1 + 2040);
        v3 = v7;
        if (!v7)
          return;
      }
      else
      {
        nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
        free((void *)v3);
        v3 = v7;
        if (!v7)
          return;
      }
    }
  }
}

uint64_t tcp_seg_collect_acked_subtree(uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;

  if (a2)
  {
    v3 = result;
    tcp_seg_collect_acked_subtree(result, a2[4]);
    result = tcp_seg_collect_acked_subtree(v3, a2[5]);
    a2[7] = 0;
    v4 = *(_QWORD **)(v3 + 2016);
    a2[8] = v4;
    *v4 = a2;
    *(_QWORD *)(v3 + 2016) = a2 + 7;
  }
  return result;
}

void tcp_segs_dosack_matched(uint64_t a1, int *a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v8;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;

  v8 = (uint64_t)a2;
  v10 = *a2;
  if (*a2 == a3)
  {
LABEL_13:
    v14 = *(unsigned __int8 *)(v8 + 12);
    if (!tcp_seg_mark_sacked((_DWORD *)a1, v8, a5))
      return;
    goto LABEL_14;
  }
  while (1)
  {
    v11 = *(unsigned __int8 *)(v8 + 12);
    if (a3 - v10 >= 1)
      break;
    if (tcp_seg_mark_sacked((_DWORD *)a1, v8, a5))
      tcp_rack_update_segment_acked(a1, a4, *(_DWORD *)(v8 + 8), *(_DWORD *)(v8 + 4), (v11 >> 3) & 1);
    if (!*(_QWORD *)(a1 + 2000))
      return;
    v12 = *(_DWORD *)v8;
    v8 = *(_QWORD *)(a1 + 2000);
    while (1)
    {
      while (1)
      {
        v13 = *(_DWORD *)(v8 + 4);
        if (v12 - v13 >= 0)
          break;
        v8 = *(_QWORD *)(v8 + 32);
        if (!v8)
          return;
      }
      if (v12 == v13)
        break;
      v8 = *(_QWORD *)(v8 + 40);
      if (!v8)
        return;
    }
    v10 = *(_DWORD *)v8;
    if (*(_DWORD *)v8 == a3)
      goto LABEL_13;
  }
  if ((v11 & 1) == 0)
  {
    tcp_seg_sent_insert_before(a1, v8, v10, a3, *(_DWORD *)(v8 + 8), *(_BYTE *)(v8 + 12));
    *(_DWORD *)v8 = a3;
    v14 = *(unsigned __int8 *)(v8 + 12);
    if (tcp_seg_mark_sacked((_DWORD *)a1, v8, a5))
LABEL_14:
      tcp_rack_update_segment_acked(a1, a4, *(_DWORD *)(v8 + 8), *(_DWORD *)(v8 + 4), (v14 >> 3) & 1);
  }
}

_QWORD *tcp_seg_sent_insert_before(uint64_t a1, uint64_t a2, int a3, int a4, int a5, char a6)
{
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  char v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  _QWORD *v21;
  NSObject *v23;
  int v24;
  int v25;
  int v26;
  const char *v27;
  __int16 v28;
  unint64_t v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v12 = *(_QWORD **)(a1 + 2024);
  if (v12)
  {
    v13 = v12[9];
    v14 = (_QWORD *)v12[10];
    if (v13)
    {
      *(_QWORD *)(v13 + 80) = v14;
      v14 = (_QWORD *)v12[10];
    }
    else
    {
      *(_QWORD *)(a1 + 2032) = v14;
    }
    *v14 = v13;
    --*(_DWORD *)(a1 + 2040);
    goto LABEL_8;
  }
  v15 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  v12 = malloc_type_malloc(**(_QWORD **)(v15 + 64), 0xB9BAFBABuLL);
  if (v12)
  {
LABEL_8:
    v12[10] = 0;
    *((_OWORD *)v12 + 3) = 0u;
    *((_OWORD *)v12 + 4) = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    *((_OWORD *)v12 + 2) = 0u;
    *(_OWORD *)v12 = 0u;
  }
  *(_DWORD *)v12 = a3;
  *((_DWORD *)v12 + 1) = a4;
  *((_DWORD *)v12 + 2) = a5;
  if (a3 - *(_DWORD *)(a1 + 2060) < 0)
    *(_DWORD *)(a1 + 2060) = a3;
  v16 = *((_BYTE *)v12 + 12) | a6;
  *((_BYTE *)v12 + 12) = v16;
  if ((v16 & 4) != 0)
    *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v12);
  v17 = *(char *)(a1 + 2069);
  if ((v17 & 0x80000000) == 0)
    *(_BYTE *)(a1 + 2069) = v17 | (32 * a6) & 0x80;
  v18 = *(_QWORD *)(a1 + 2000);
  if (v18)
  {
    while (1)
    {
      while (1)
      {
        v19 = v18;
        v20 = *((_DWORD *)v12 + 1) - *(_DWORD *)(v18 + 4);
        if (v20 >= 0)
          break;
        v18 = *(_QWORD *)(v18 + 32);
        if (!v18)
          goto LABEL_23;
      }
      if (!v20)
        break;
      v18 = *(_QWORD *)(v18 + 40);
      if (!v18)
        goto LABEL_23;
    }
    v23 = __nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v24 = *(_DWORD *)v19;
      v25 = *(_DWORD *)(v19 + 4);
      v26 = 136446978;
      v27 = "tcp_seg_sent_insert_before";
      v28 = 2048;
      v29 = v19;
      v30 = 1024;
      v31 = v24;
      v32 = 1024;
      v33 = v25;
      _os_log_impl(&dword_209FB3000, v23, OS_LOG_TYPE_ERROR, "%{public}s segment %p[%u %u) was not inserted in the RB tree", (uint8_t *)&v26, 0x22u);
    }
  }
  else
  {
    v19 = 0;
    v20 = 0;
LABEL_23:
    v12[4] = 0;
    v12[5] = 0;
    v12[6] = v19 | 1;
    if (v20 < 0)
      v21 = (_QWORD *)(v19 + 32);
    else
      v21 = (_QWORD *)(v19 + 40);
    if (!v19)
      v21 = (_QWORD *)(a1 + 2000);
    *v21 = v12;
    tcp_seg_sent_tree_head_RB_INSERT_COLOR(a1 + 2000, (unint64_t)v12);
  }
  v12[3] = *(_QWORD *)(a2 + 24);
  v12[2] = a2;
  **(_QWORD **)(a2 + 24) = v12;
  *(_QWORD *)(a2 + 24) = v12 + 2;
  return v12;
}

BOOL tcp_seg_mark_sacked(_DWORD *a1, uint64_t a2, _DWORD *a3)
{
  char v3;
  unsigned int v7;
  unsigned int v8;
  char v9;
  unsigned int v10;
  int v11;
  void *v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  void *v17;
  NSObject *v18;
  int v19;
  unsigned int v20;
  NSObject *v21;
  int v22;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  unsigned int v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v3 = *(_BYTE *)(a2 + 12);
  if ((v3 & 1) == 0)
  {
    v7 = tcp_seg_len((int *)a2);
    v8 = v7;
    v9 = *(_BYTE *)(a2 + 12);
    if (*(_DWORD *)(a2 + 4) - a1[140] < 0 && (*(_BYTE *)(a2 + 12) & 9) == 0)
      ++a1[254];
    if ((v9 & 4) != 0)
    {
      if ((v9 & 2) != 0)
      {
        *(_BYTE *)(a2 + 12) = v9 & 0xF9;
        v13 = a1[518];
        if (v13 < v7 || (v14 = a1[519], v14 < v7))
        {
          __nwlog_obj();
          v15 = a1[518];
          v16 = a1[519];
          *(_DWORD *)buf = 136446978;
          v25 = "tcp_seg_mark_sacked";
          v26 = 1024;
          v27 = v15;
          v28 = 1024;
          v29 = v16;
          v30 = 1024;
          LODWORD(v31) = v8;
          v17 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            v18 = __nwlog_obj();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              v19 = a1[518];
              v20 = a1[519];
              *(_DWORD *)buf = 136446978;
              v25 = "tcp_seg_mark_sacked";
              v26 = 1024;
              v27 = v19;
              v28 = 1024;
              v29 = v20;
              v30 = 1024;
              LODWORD(v31) = v8;
              _os_log_impl(&dword_209FB3000, v18, OS_LOG_TYPE_ERROR, "%{public}s bytes_lost (%u) and/or bytes_retransmitted (%u) can't be smaller than already lost/retransmitted segment length (%u), backtrace limit exceeded", buf, 0x1Eu);
            }
          }
          if (v17)
            free(v17);
          v13 = a1[518];
          v14 = a1[519];
        }
        a1[518] = v13 - v8;
        a1[519] = v14 - v8;
      }
    }
    else if ((v9 & 2) != 0)
    {
      *(_BYTE *)(a2 + 12) = v9 & 0xFD;
      v10 = a1[518];
      if (v10 < v7)
      {
        __nwlog_obj();
        v11 = a1[518];
        *(_DWORD *)buf = 136446722;
        v25 = "tcp_seg_mark_sacked";
        v26 = 1024;
        v27 = v11;
        v28 = 1024;
        v29 = v8;
        v12 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v21 = __nwlog_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            v22 = a1[518];
            *(_DWORD *)buf = 136446722;
            v25 = "tcp_seg_mark_sacked";
            v26 = 1024;
            v27 = v22;
            v28 = 1024;
            v29 = v8;
            _os_log_impl(&dword_209FB3000, v21, OS_LOG_TYPE_ERROR, "%{public}s bytes_lost (%u) can't be smaller than already lost segment length (%u), backtrace limit exceeded", buf, 0x18u);
          }
        }
        if (v12)
          free(v12);
        v10 = a1[518];
      }
      a1[518] = v10 - v8;
    }
    *a3 += v8;
    *(_BYTE *)(a2 + 12) |= 1u;
    a1[520] += v8;
  }
  return (v3 & 1) == 0;
}

void tcp_segs_clear_sacked(uint64_t a1)
{
  uint64_t i;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  void *v7;
  NSObject *v8;
  int v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  unsigned int v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  for (i = *(_QWORD *)(a1 + 1984); i; i = *(_QWORD *)(i + 16))
  {
    v4 = tcp_seg_len((int *)i);
    if ((*(_BYTE *)(i + 12) & 1) != 0)
    {
      v5 = v4;
      *(_BYTE *)(i + 12) &= ~1u;
      v3 = *(_DWORD *)(a1 + 2080);
      if (v3 < v4)
      {
        __nwlog_obj();
        v6 = *(_DWORD *)(a1 + 2080);
        *(_DWORD *)buf = 136446722;
        v11 = "tcp_segs_clear_sacked";
        v12 = 1024;
        v13 = v6;
        v14 = 1024;
        v15 = v5;
        v7 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v8 = __nwlog_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            v9 = *(_DWORD *)(a1 + 2080);
            *(_DWORD *)buf = 136446722;
            v11 = "tcp_segs_clear_sacked";
            v12 = 1024;
            v13 = v9;
            v14 = 1024;
            v15 = v5;
            _os_log_impl(&dword_209FB3000, v8, OS_LOG_TYPE_ERROR, "%{public}s bytes_sacked (%u) can't be smaller than already SACKed segment length (%u), backtrace limit exceeded", buf, 0x18u);
          }
        }
        if (v7)
          free(v7);
        v3 = *(_DWORD *)(a1 + 2080);
      }
      *(_DWORD *)(a1 + 2080) = v3 - v5;
    }
  }
}

void tcp_mark_seg_lost(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  char v6;
  unsigned int v7;
  BOOL v8;
  unsigned int v9;
  int v10;
  void *v11;
  NSObject *v12;
  int v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unsigned int v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v4 = tcp_seg_len((int *)a2);
  v5 = v4;
  v6 = *(_BYTE *)(a2 + 12);
  if ((v6 & 2) != 0)
  {
    if ((*(_BYTE *)(a2 + 12) & 4) != 0)
    {
      *(_BYTE *)(a2 + 12) = v6 & 0xFB;
      v7 = *(_DWORD *)(a1 + 2076);
      v8 = v7 >= v4;
      v9 = v7 - v4;
      if (v8)
      {
        *(_DWORD *)(a1 + 2076) = v9;
      }
      else
      {
        __nwlog_obj();
        v10 = *(_DWORD *)(a1 + 2076);
        *(_DWORD *)buf = 136446722;
        v15 = "tcp_mark_seg_lost";
        v16 = 1024;
        v17 = v10;
        v18 = 1024;
        v19 = v5;
        v11 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v12 = __nwlog_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            v13 = *(_DWORD *)(a1 + 2076);
            *(_DWORD *)buf = 136446722;
            v15 = "tcp_mark_seg_lost";
            v16 = 1024;
            v17 = v13;
            v18 = 1024;
            v19 = v5;
            _os_log_impl(&dword_209FB3000, v12, OS_LOG_TYPE_ERROR, "%{public}s bytes_retransmitted (%u) can't be smaller than retransmited segment length (%u), backtrace limit exceeded", buf, 0x18u);
          }
        }
        if (v11)
          free(v11);
      }
    }
  }
  else
  {
    *(_BYTE *)(a2 + 12) = v6 | 2;
    *(_DWORD *)(a1 + 2072) += v4;
  }
}

void tcp_add_notify_ack_marker(uint64_t a1, int a2)
{
  uint64_t v4;
  _DWORD *v5;
  int v6;
  uint64_t *v7;
  _DWORD *v8;
  uint64_t *v9;
  int v10;
  NSObject *v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  void *v15;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
  v5 = malloc_type_malloc(0x10uLL, 0xF2B69DE5uLL);
  if (!v5)
  {
    v14 = __nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    v15 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
LABEL_13:
      __break(1u);
      return;
    }
    free(v15);
  }
  v5[1] = a2;
  v6 = *(_DWORD *)(v4 + 384) + *(_DWORD *)(a1 + 92);
  *v5 = v6;
  v7 = (uint64_t *)(a1 + 1032);
  v8 = *(_DWORD **)(a1 + 1032);
  if (v8)
  {
    do
    {
      v10 = *v8;
      v9 = (uint64_t *)(v8 + 2);
      if (v6 - v10 > 0)
      {
        v7 = v9;
        goto LABEL_9;
      }
      v8 = (_DWORD *)*v9;
    }
    while (v8);
    v11 = __nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
      goto LABEL_13;
    free(v12);
LABEL_9:
    v13 = *v7;
  }
  else
  {
    v13 = 0;
  }
  *((_QWORD *)v5 + 1) = v13;
  *v7 = (uint64_t)v5;
  ++*(_BYTE *)(a1 + 732);
}

uint64_t tcp_get_notify_ack_count(uint64_t result, int *a2)
{
  uint64_t v2;
  int v3;
  int v4;

  v2 = *(_QWORD *)(result + 1032);
  if (v2)
  {
    LOBYTE(v3) = 0;
    do
    {
      if (*(_DWORD *)(result + 92) - *(_DWORD *)v2 < 0)
        break;
      LOBYTE(v3) = v3 + 1;
      v2 = *(_QWORD *)(v2 + 8);
    }
    while (v2);
  }
  else
  {
    LOBYTE(v3) = 0;
  }
  v3 = v3;
  v4 = *(unsigned __int8 *)(result + 732) - v3;
  if (v3 >= 0xAu)
    v3 = 10;
  *a2 = v4;
  a2[1] = v3;
  return result;
}

_QWORD *tcp_get_notify_ack_ids(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;

  result = *(_QWORD **)(a1 + 1032);
  if (result)
  {
    v5 = 0;
    v6 = (_QWORD *)(a1 + 1032);
    do
    {
      if (v5 >= *(unsigned int *)(a2 + 4) || *(_DWORD *)(a1 + 92) - *(_DWORD *)result < 0)
        break;
      v7 = (_QWORD *)result[1];
      *(_DWORD *)(a2 + 4 * v5 + 8) = *((_DWORD *)result + 1);
      v8 = (_QWORD *)*v6;
      v9 = (_QWORD *)(a1 + 1032);
      if ((_QWORD *)*v6 != result)
      {
        do
        {
          v10 = v8;
          v8 = (_QWORD *)v8[1];
        }
        while (v8 != result);
        v9 = v10 + 1;
      }
      ++v5;
      *v9 = v7;
      free(result);
      --*(_BYTE *)(a1 + 732);
      result = v7;
    }
    while (v7);
  }
  return result;
}

uint64_t tcp_validate_cksum(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = validate_tcp_cksum();
  if ((v5 & 1) == 0)
  {
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0
      && *MEMORY[0x24BDE08C0]
      && (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(a1, *(_QWORD *)(a1 + 88)) & 1) == 0)
    {
      *(_QWORD *)(a3 + 1056) = 0;
    }
    else
    {
      v6 = *(_QWORD *)(a3 + 1056);
      if (v6)
        ++*(_QWORD *)(v6 + 320);
    }
  }
  return v5;
}

uint64_t tcp_prague_init(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t result;
  NSObject *v5;
  void *v6;

  do
    v2 = __ldaxr(dword_2545C6F40);
  while (__stlxr(v2 + 1, dword_2545C6F40));
  v3 = *(_QWORD *)(a1 + 840);
  if (v3)
    goto LABEL_3;
  v5 = __nwlog_obj();
  os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  v6 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v6);
    v3 = *(_QWORD *)(a1 + 840);
LABEL_3:
    *(_QWORD *)(v3 + 32) = 0x1000000;
    *(_DWORD *)(a1 + 504) = 0;
    **(_WORD **)(a1 + 840) = 0;
    *(_WORD *)(*(_QWORD *)(a1 + 840) + 2) = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 840) + 40) = 0x100000;
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 76) = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 52) = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 56) = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 48) = 0;
    return 0;
  }
  __break(1u);
  return result;
}

uint64_t tcp_prague_cleanup()
{
  unsigned int v0;

  do
    v0 = __ldaxr(dword_2545C6F40);
  while (__stlxr(v0 - 1, dword_2545C6F40));
  return 0;
}

void tcp_prague_cwnd_init_or_reset(uint64_t a1)
{
  _WORD *v2;
  _DWORD *v3;
  int v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  int v10;
  NSObject *v11;
  void *v12;

  v2 = *(_WORD **)(a1 + 840);
  if (!v2)
  {
    v11 = __nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v12);
    v2 = *(_WORD **)(a1 + 840);
  }
  *(_DWORD *)(a1 + 504) = 0;
  *v2 = 0;
  *(_WORD *)(*(_QWORD *)(a1 + 840) + 2) = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 840) + 40) = 0x100000;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 76) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 52) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 56) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 48) = 0;
  if ((*(_BYTE *)(a1 + 90) & 2) != 0)
  {
    LODWORD(v5) = *(_DWORD *)(a1 + 196);
    v3 = (_DWORD *)sysctls;
    LODWORD(v6) = *(_DWORD *)(sysctls + 84) * v5;
  }
  else
  {
    v3 = (_DWORD *)sysctls;
    if (*(_DWORD *)(sysctls + 276))
    {
      if (*(_DWORD *)(sysctls + 304))
        v4 = *(_DWORD *)(sysctls + 16);
      else
        v4 = 10;
      LODWORD(v5) = *(_DWORD *)(a1 + 196);
      LODWORD(v6) = v5 * v4;
    }
    else
    {
      v5 = *(unsigned int *)(a1 + 196);
      LODWORD(v6) = 2 * v5;
      if (v5 <= 0x88E)
        v6 = 4380;
      else
        v6 = v6;
      if (v6 > 4 * v5)
        LODWORD(v6) = 4 * v5;
    }
  }
  *(_DWORD *)(a1 + 144) = v6;
  *(_QWORD *)(a1 + 980) = 0;
  *(_DWORD *)(a1 + 972) = 0;
  *(_QWORD *)(a1 + 964) = 0;
  *(_BYTE *)(a1 + 751) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  if (v3[76])
  {
    v7 = v3[4];
  }
  else
  {
    if (!v3[69])
    {
      v8 = 4380;
      goto LABEL_20;
    }
    v7 = 10;
  }
  v8 = (v5 * v7);
LABEL_20:
  v9 = *(_DWORD *)(a1 + 148);
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 248) + 24) <= v8 && v9 <= 0x3FFFBFFF)
  {
    v9 = 1073725440;
    *(_DWORD *)(a1 + 148) = 1073725440;
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 48) = v9;
  v10 = *(_DWORD *)(a1 + 196);
  *(_QWORD *)(a1 + 480) = 10 * *(unsigned int *)(a1 + 144);
  *(_DWORD *)(a1 + 488) = v10;
}

void tcp_prague_ack_rcvd(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  BOOL v18;
  unsigned int v19;
  unint64_t v20;
  unint64_t v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  unsigned int v32;
  void *v33;
  NSObject *v34;
  float v35;
  float v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  _DWORD *v41;
  unsigned int v42;
  unsigned int v43;
  float v44;
  uint64_t v45;
  unsigned int v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  char v52;
  uint8_t buf[4];
  const char *v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
  v5 = *(_DWORD *)(a1 + 980);
  if (v5)
  {
    v6 = *(_DWORD *)(a1 + 144);
    if (v5 < v6 >> 1 && (!v4 || *(_DWORD *)(v4 + 384) <= v6))
    {
      *(_DWORD *)(a1 + 740) |= 0x100000u;
      return;
    }
  }
  v7 = *(_DWORD *)(a1 + 740) & 0xFFEFFFFF;
  *(_DWORD *)(a1 + 740) = v7;
  v8 = *(_QWORD *)(a1 + 840);
  v9 = *(_DWORD *)(v8 + 16);
  if (v9)
  {
    v10 = *(unsigned int *)(a1 + 144);
    if (v10 >= *(_DWORD *)(a1 + 148))
    {
      if ((*(_BYTE *)(v8 + 28) & 4) == 0)
      {
        if (v5 && v5 < v10 >> 1 && (!v4 || *(_DWORD *)(v4 + 384) <= v10))
        {
          *(_DWORD *)(a1 + 740) = v7 | 0x100000;
        }
        else
        {
          *(_DWORD *)(a1 + 740) = v7;
          *(_DWORD *)(a1 + 288) += v9;
          v12 = *(_DWORD *)(a1 + 200);
          v13 = nw_tcp_access_globals(v4);
          v14 = v13;
          v10 = *(_QWORD *)(a1 + 840);
          if (!*(_DWORD *)(v10 + 52))
          {
            *(_DWORD *)(v10 + 52) = *(_DWORD *)(v13 + 316);
            v15 = *(_QWORD *)(a1 + 840);
            if (!*(_DWORD *)(v15 + 52))
            {
              *(_DWORD *)(v15 + 52) = 1;
              v15 = *(_QWORD *)(a1 + 840);
            }
            v16 = *(_DWORD *)(a1 + 144);
            v17 = *(_DWORD *)(v15 + 48);
            v18 = v17 >= v16;
            v19 = v17 - v16;
            if (v19 != 0 && v18)
            {
              *(float *)(v15 + 76) = cbrtf((float)((float)v19 * 2.5) / (float)*(unsigned int *)(a1 + 196)) * 1000.0;
              v30 = *(_QWORD *)(a1 + 840);
              v29 = *(_DWORD *)(v30 + 48);
            }
            else
            {
              *(_DWORD *)(v15 + 76) = 0;
              v29 = *(_DWORD *)(a1 + 144);
              *(_DWORD *)(*(_QWORD *)(a1 + 840) + 48) = v29;
              v30 = *(_QWORD *)(a1 + 840);
            }
            *(_DWORD *)(v30 + 56) = v29;
            v10 = *(_QWORD *)(a1 + 840);
          }
          v31 = v12 >> 5;
          v32 = *(_DWORD *)(v10 + 56);
          if (!v32)
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            v54 = "cubic_target";
            v33 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_fault())
            {
              v34 = __nwlog_obj();
              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446210;
                v54 = "cubic_target";
                _os_log_impl(&dword_209FB3000, v34, OS_LOG_TYPE_ERROR, "%{public}s Prague CC: Cubic origin point should be greater than 0, backtrace limit exceeded", buf, 0xCu);
              }
            }
            if (v33)
              free(v33);
            v10 = *(_QWORD *)(a1 + 840);
            v32 = *(_DWORD *)(v10 + 56);
          }
          v35 = (float)(*(_DWORD *)(v14 + 316) - *(_DWORD *)(v10 + 52) + v31) - *(float *)(v10 + 76);
          v36 = (float)v32
              + (float)((float)((float)((float)(v35 * 0.001) * (float)(v35 * 0.001)) * (float)(v35 * 0.0004))
                      * (float)*(unsigned int *)(a1 + 196));
          v37 = (int)v36 & ~((int)v36 >> 31);
          v38 = *(_DWORD *)(a1 + 144);
          v39 = v38;
          if (v37 >= v38)
          {
            v39 = ((double)v38 * 1.5);
            if (v37 < v39)
              v39 = (int)v36 & ~((int)v36 >> 31);
          }
          if (!*(_DWORD *)(v10 + 60))
          {
            *(_DWORD *)(v10 + 60) = v38;
            *(_DWORD *)(*(_QWORD *)(a1 + 840) + 64) = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
            v10 = *(_QWORD *)(a1 + 840);
          }
          *(_DWORD *)(v10 + 64) += *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
          v40 = *(_QWORD *)(a1 + 840);
          v41 = (_DWORD *)(v40 + 64);
          v42 = *(_DWORD *)(v40 + 64);
          for (LODWORD(v10) = *(_DWORD *)(a1 + 144); v42 >= v10; LODWORD(v10) = *(_DWORD *)(a1 + 144))
          {
            *v41 = v42 - v10;
            v10 = *(_QWORD *)(a1 + 840);
            v43 = *(_DWORD *)(v10 + 60);
            v44 = 0.52941;
            if (v43 >= *(_DWORD *)(v10 + 48))
              v44 = 1.0;
            *(_DWORD *)(v10 + 60) = v43 + (float)(v44 * (float)*(unsigned int *)(a1 + 196));
            v40 = *(_QWORD *)(a1 + 840);
            v41 = (_DWORD *)(v40 + 64);
            v42 = *(_DWORD *)(v40 + 64);
          }
          v45 = *(unsigned int *)(a1 + 196);
          v46 = (*(_DWORD *)(v40 + 60) + (v45 >> 1)) / v45 * v45;
          v18 = v39 >= v10;
          v47 = v39 - v10;
          if ((_DWORD)v47 != 0 && v18)
            v48 = v45 * (unint64_t)v10 / v47;
          else
            v48 = 0;
          v49 = v45 * (unint64_t)v10 / (v46 - v10);
          if (v49 >= v48)
            v49 = v48;
          if (v46 > v10)
            v48 = v49;
          if (v48)
          {
            v50 = *(unsigned int *)(a1 + 288);
            if (v48 <= v50)
            {
              *(_DWORD *)(a1 + 288) = v50 - v48;
              v51 = v45 + v10;
              v52 = *(_BYTE *)(a1 + 260);
              LODWORD(v10) = v45 + v10;
              if (v51 >= 0xFFFFLL << v52)
                LODWORD(v10) = 0xFFFF << v52;
            }
          }
        }
        goto LABEL_29;
      }
      v20 = *(_DWORD *)(a1 + 288) + v9;
      *(_DWORD *)(a1 + 288) = v20;
      v21 = (unint64_t)(v10 << 20) / *(_QWORD *)(v8 + 40);
      if (v21 > v20)
      {
LABEL_29:
        v23 = *(_DWORD *)(a1 + 196);
        v24 = *(_DWORD *)(a1 + 200);
        LODWORD(v10) = (v10 + (v23 >> 1)) / v23 * v23;
        v25 = 2 * v23;
        if (v10 <= v25)
          v10 = v25;
        else
          v10 = v10;
        *(_DWORD *)(a1 + 144) = v10;
        v26 = v10 << (v10 < *(_DWORD *)(a1 + 148));
        LODWORD(v27) = v24 >> 5;
        if (v24 >= 0x20)
          v27 = v27;
        else
          v27 = 100;
        v28 = 1000 * v26 / v27;
        *(_QWORD *)(a1 + 480) = v28;
        *(_DWORD *)(a1 + 488) = v28 >> 12;
        return;
      }
      *(_DWORD *)(a1 + 288) = v20 - v21;
      v9 = *(_DWORD *)(a1 + 196);
LABEL_28:
      LODWORD(v10) = v9 + v10;
      goto LABEL_29;
    }
    if (*(_DWORD *)(sysctls + 304))
    {
      v11 = *(_DWORD *)(sysctls + 16);
    }
    else
    {
      if (!*(_DWORD *)(sysctls + 276))
      {
        v22 = 4380;
LABEL_26:
        if (v9 >= v22)
          v9 = v22;
        goto LABEL_28;
      }
      v11 = 10;
    }
    v22 = *(_DWORD *)(a1 + 196) * v11;
    goto LABEL_26;
  }
}

uint64_t tcp_prague_pre_fr(uint64_t a1)
{
  uint64_t result;
  unsigned int v3;
  uint64_t v4;
  float v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  _DWORD *v9;
  int v10;

  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 52) = 0;
  if ((*(_BYTE *)(a1 + 742) & 0x10) != 0)
  {
    result = tcp_flight_size((_DWORD *)a1);
    v3 = *(_DWORD *)(a1 + 980);
    if (v3 <= result)
      v3 = result;
  }
  else
  {
    result = 0;
    v3 = *(_DWORD *)(a1 + 144);
  }
  *(_DWORD *)(a1 + 984) = result;
  v4 = *(_QWORD *)(a1 + 840);
  v5 = (float)v3;
  if (v3 < *(_DWORD *)(v4 + 48))
    v3 = (float)((float)v3 * 0.85);
  *(_DWORD *)(v4 + 48) = v3;
  v6 = *(_DWORD *)(a1 + 196);
  v7 = ((float)(v5 * 0.7) + (v6 >> 1)) / v6 * v6;
  v8 = 2 * v6;
  if (v7 > v8)
    v8 = v7;
  *(_DWORD *)(a1 + 148) = v8;
  v9 = *(_DWORD **)(*(_QWORD *)(a1 + 80) + 224);
  if (v9[97] > v8)
  {
    v10 = v9[108];
    if ((v10 & 0x400) != 0)
    {
      if (v9[109] > v8)
      {
        if (*(int *)(sysctls + 232) > (uint64_t)v8)
          v8 = *(_DWORD *)(sysctls + 232);
        if (v8 >= *(_DWORD *)(sysctls + 120))
          v8 = *(_DWORD *)(sysctls + 120);
        v9[109] = v8;
      }
      v9[108] = v10 | 0x800;
    }
  }
  ++**(_WORD **)(a1 + 840);
  *(_BYTE *)(*(_QWORD *)(a1 + 840) + 28) |= 2u;
  *(_BYTE *)(*(_QWORD *)(a1 + 840) + 28) &= ~4u;
  return result;
}

uint64_t tcp_prague_post_fr(uint64_t result)
{
  unsigned int v1;
  int v2;
  unint64_t v3;
  unint64_t v4;

  v1 = *(_DWORD *)(result + 148);
  *(_DWORD *)(result + 144) = v1;
  v2 = *(_DWORD *)(result + 200);
  if (v2 >= 0x20)
    v3 = (v2 >> 5);
  else
    v3 = 100;
  v4 = 1000 * (unint64_t)v1 / v3;
  *(_QWORD *)(result + 480) = v4;
  *(_DWORD *)(result + 488) = v4 >> 12;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 60) = 0;
  *(_DWORD *)(*(_QWORD *)(result + 840) + 64) = 0;
  *(_BYTE *)(*(_QWORD *)(result + 840) + 28) &= ~2u;
  return result;
}

void tcp_prague_after_timeout(uint64_t a1)
{
  NSObject *v2;
  void *v3;

  if (!*(_QWORD *)(a1 + 840))
  {
    v2 = __nwlog_obj();
    os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
    v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v3);
  }
  if (*(int *)(a1 + 12) > 3 || *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92) >= 2)
  {
    if ((*(_BYTE *)(a1 + 90) & 0x20) == 0)
    {
      *(_DWORD *)(a1 + 504) = 0;
      **(_WORD **)(a1 + 840) = 0;
      *(_WORD *)(*(_QWORD *)(a1 + 840) + 2) = 0;
      *(_QWORD *)(*(_QWORD *)(a1 + 840) + 40) = 0x100000;
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 76) = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 52) = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 56) = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 48) = 0;
      tcp_prague_pre_fr(a1);
    }
    *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 196);
  }
}

void tcp_prague_process_ecn(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  void *v14;
  unsigned int v15;
  BOOL v16;
  unsigned int v17;
  int v18;
  BOOL v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unint64_t v28;
  uint64_t v29;
  int v30;
  NSObject *v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  NSObject *v39;
  uint64_t v40;
  int v41;
  NSObject *v42;
  unsigned int v43;
  NSObject *v44;
  NSObject *v45;
  uint8_t buf[4];
  const char *v47;
  __int16 v48;
  unsigned int v49;
  __int16 v50;
  int v51;
  __int16 v52;
  unsigned int v53;
  __int16 v54;
  int v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(a1 + 840);
  v11 = *(_DWORD *)(v10 + 12);
  if (v11 <= a4 && *(_DWORD *)(v10 + 4) <= a5)
  {
    if (v11 >= a4)
      goto LABEL_7;
    goto LABEL_6;
  }
  __nwlog_obj();
  v12 = *(_QWORD *)(a1 + 840);
  v13 = *(_DWORD *)(v12 + 12);
  LODWORD(v12) = *(_DWORD *)(v12 + 4);
  *(_DWORD *)buf = 136447234;
  v47 = "tcp_prague_process_ecn";
  v48 = 1024;
  v49 = a4;
  v50 = 1024;
  v51 = v13;
  v52 = 1024;
  v53 = a5;
  v54 = 1024;
  v55 = v12;
  v14 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v39 = __nwlog_obj();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      v40 = *(_QWORD *)(a1 + 840);
      v41 = *(_DWORD *)(v40 + 12);
      LODWORD(v40) = *(_DWORD *)(v40 + 4);
      *(_DWORD *)buf = 136447234;
      v47 = "tcp_prague_process_ecn";
      v48 = 1024;
      v49 = a4;
      v50 = 1024;
      v51 = v41;
      v52 = 1024;
      v53 = a5;
      v54 = 1024;
      v55 = v40;
      _os_log_impl(&dword_209FB3000, v39, OS_LOG_TYPE_ERROR, "%{public}s new CE count (%u) can't be less than current CE count (%u)OR newly ACKed (%u) can't be less that current ACKed (%u), backtrace limit exceeded", buf, 0x24u);
    }
  }
  if (v14)
    free(v14);
  v10 = *(_QWORD *)(a1 + 840);
  if (*(_DWORD *)(v10 + 12) < a4)
  {
LABEL_6:
    *(_BYTE *)(v10 + 28) |= 1u;
    v10 = *(_QWORD *)(a1 + 840);
  }
LABEL_7:
  v15 = *(_DWORD *)(v10 + 4);
  v16 = a5 >= v15;
  v17 = a5 - v15;
  if (v17 != 0 && v16)
  {
    v18 = *(_DWORD *)(v10 + 20);
    if (v18)
      v19 = *(_DWORD *)(a2 + 8) - v18 <= 0;
    else
      v19 = 0;
    if (v19)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v44 = __nwlog_obj();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "prague_update_alpha";
          _os_log_impl(&dword_209FB3000, v44, OS_LOG_TYPE_DEBUG, "%{public}s one RTT hasn't elapsed, not updating alpha", buf, 0xCu);
        }
      }
    }
    else if ((*(_BYTE *)(v10 + 28) & 1) != 0)
    {
      v20 = *(_DWORD *)(v10 + 8);
      v16 = a4 >= v20;
      v21 = a4 - v20;
      v19 = v21 != 0 && v16;
      v22 = v21 << 20;
      if (!v19)
        v22 = 0;
      v23 = *(_QWORD *)(v10 + 32) - (*(_QWORD *)(v10 + 32) >> 4) + v22 / v17;
      if (v23 >= 0x1000000)
        v23 = 0x1000000;
      *(_QWORD *)(v10 + 32) = v23;
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 20) = *(_DWORD *)(a1 + 100);
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 8) = a4;
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 4) = a5;
    }
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 840) + 12) != a4)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v42 = __nwlog_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      {
        v43 = a4 - *(_DWORD *)(*(_QWORD *)(a1 + 840) + 12);
        *(_DWORD *)buf = 136446466;
        v47 = "tcp_prague_process_ecn";
        v48 = 1024;
        v49 = v43;
        _os_log_impl(&dword_209FB3000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %u packets were newly CE marked", buf, 0x12u);
      }
    }
    v24 = *(_QWORD *)(a1 + 840);
    v25 = *(_DWORD *)(v24 + 16);
    v16 = v25 >= a3;
    v26 = v25 - a3;
    if (!v16)
      v26 = 0;
    *(_DWORD *)(v24 + 16) = v26;
    *(_DWORD *)(*(_QWORD *)(a1 + 840) + 12) = a4;
    v27 = *(_DWORD *)(a1 + 200);
    v19 = v27 > 0x33F;
    v28 = ((((v27 >> 5) * (v27 >> 5)) << 20) | 0x138) / 0x271uLL;
    if (v19)
      v28 = 0x100000;
    *(_QWORD *)(*(_QWORD *)(a1 + 840) + 40) = v28;
    v29 = *(_QWORD *)(a1 + 840);
    v30 = *(_DWORD *)(v29 + 24);
    if (v30 && *(_DWORD *)(a2 + 8) - v30 <= 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v31 = __nwlog_obj();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "tcp_prague_process_ecn";
          _os_log_impl(&dword_209FB3000, v31, OS_LOG_TYPE_DEBUG, "%{public}s one RTT hasn't elapsed, not doing CWR", buf, 0xCu);
        }
      }
    }
    else
    {
      if ((*(_BYTE *)(v29 + 28) & 2) != 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v45 = __nwlog_obj();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            v47 = "prague_cwr";
            _os_log_impl(&dword_209FB3000, v45, OS_LOG_TYPE_DEBUG, "%{public}s currently in loss recovery, no need to do CWR", buf, 0xCu);
          }
        }
      }
      else
      {
        ++*(_WORD *)(v29 + 2);
        v32 = *(_QWORD *)(a1 + 840);
        v33 = *(_DWORD *)(a1 + 144)
            - (((*(_QWORD *)(v32 + 32) >> 4) * (unint64_t)*(unsigned int *)(a1 + 144)) >> 21);
        *(_DWORD *)(a1 + 144) = v33;
        v34 = *(_DWORD *)(a1 + 196);
        if (!*(_DWORD *)(v32 + 16))
        {
          v33 = (v33 + (v34 >> 1)) / v34 * v34;
          *(_DWORD *)(a1 + 144) = v33;
        }
        v35 = 2 * v34;
        if (v33 < v35)
        {
          *(_DWORD *)(a1 + 144) = v35;
          v33 = v35;
        }
        *(_DWORD *)(a1 + 148) = v33;
        *(_BYTE *)(v32 + 28) |= 4u;
        v36 = *(_DWORD *)(a1 + 200);
        if (v36 >= 0x20)
          v37 = (v36 >> 5);
        else
          v37 = 100;
        v38 = 1000
            * ((unint64_t)*(unsigned int *)(a1 + 144) << (*(_DWORD *)(a1 + 144) < *(_DWORD *)(a1 + 148)))
            / v37;
        *(_QWORD *)(a1 + 480) = v38;
        *(_DWORD *)(a1 + 488) = v38 >> 12;
      }
      *(_DWORD *)(*(_QWORD *)(a1 + 840) + 24) = *(_DWORD *)(a1 + 100);
    }
  }
}

uint64_t tcp_prague_set_bytes_acked(uint64_t result, int a2)
{
  *(_DWORD *)(*(_QWORD *)(result + 840) + 16) = a2;
  return result;
}

void tcp_prague_switch_cc(uint64_t a1)
{
  unsigned int v1;

  tcp_prague_cwnd_init_or_reset(a1);
  do
    v1 = __ldaxr(dword_2545C6F40);
  while (__stlxr(v1 + 1, dword_2545C6F40));
}

void tcp_enter_fast_recovery(uint64_t a1)
{
  void (*v2)(uint64_t);
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  void (**v7)(void);
  void (*v8)(void);
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  int v15;

  v2 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 64);
  if (v2)
    v2(a1);
  *(_DWORD *)(a1 + 88) |= 0x200000u;
  v3 = *(_QWORD *)(a1 + 80);
  v4 = *(_DWORD *)(v3 + 2228);
  if ((v4 & 0x40000000) != 0)
  {
    v5 = *(_QWORD *)(v3 + 224);
    if ((v4 & 0x10000000) != 0)
    {
      *(_DWORD *)(v3 + 2228) = v4 & 0xAFFFFFFF;
      *(_DWORD *)(v5 + 364) &= ~0x20000u;
      if ((v4 & 0x50000000) == 0)
        goto LABEL_13;
    }
    else
    {
      v6 = *(_DWORD *)(v5 + 364);
      *(_DWORD *)(v3 + 2228) = v4 & 0xAFFFFFFF;
      if ((v6 & 0x20000) != 0)
        *(_DWORD *)(v5 + 364) = v6 & 0xFFFDFFFF;
      if ((v4 & 0x50000000) == 0)
        goto LABEL_13;
    }
    v7 = *(void (***)(void))(v5 + 32);
    if (v7)
    {
      v8 = *v7;
      if (v8)
        v8();
    }
  }
LABEL_13:
  v9 = *(_QWORD **)(a1 + 952);
  if (v9)
  {
    v10 = (_QWORD *)(a1 + 952);
    do
    {
      v12 = (_QWORD *)*v10;
      v13 = (_QWORD *)(a1 + 952);
      if ((_QWORD *)*v10 != v9)
      {
        do
        {
          v14 = v12;
          v12 = (_QWORD *)v12[2];
        }
        while (v12 != v9);
        v13 = v14 + 2;
      }
      v11 = (_QWORD *)v9[2];
      *v13 = v11;
      nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
      free(v9);
      v9 = v11;
    }
    while (v11);
    v15 = *(_DWORD *)(a1 + 96);
    *(_DWORD *)(a1 + 960) = v15;
  }
  else
  {
    v15 = *(_DWORD *)(a1 + 96);
  }
  *(_DWORD *)(a1 + 152) = v15 + ((int)(*(_DWORD *)(a1 + 88) << 27) >> 31);
  *(_DWORD *)(a1 + 740) &= ~0x100000u;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 172) = 0;
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 148);
}

uint64_t tcp_reset_stretch_ack(uint64_t a1)
{
  uint64_t result;

  *(_DWORD *)(a1 + 88) &= 0x7DFFFFFFu;
  *(_QWORD *)(a1 + 328) = 0;
  result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  *(_DWORD *)(a1 + 324) = *(_DWORD *)(result + 316) + 100;
  *(_DWORD *)(a1 + 740) |= 2u;
  *(_WORD *)(a1 + 344) = 0;
  return result;
}

uint64_t tcp_input_ip_ecn(uint64_t result, uint64_t a2, unsigned int a3, int a4, int a5)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  if (a5 != 3)
  {
    if (a5 == 2)
    {
      *(_DWORD *)(result + 348) |= 0x1000000u;
      v5 = (_QWORD *)(result + 440);
    }
    else
    {
      if (a5 != 1)
        return result;
      *(_DWORD *)(result + 348) |= 0x800000u;
      v5 = (_QWORD *)(result + 432);
    }
    goto LABEL_13;
  }
  *(_DWORD *)(result + 416) += a4;
  *(_QWORD *)(result + 448) += a3;
  ++*(_DWORD *)(result + 352);
  v6 = *(_QWORD *)(result + 1056);
  if (v6)
    ++*(_QWORD *)(v6 + 856);
  v7 = *(_QWORD *)(a2 + 448);
  if (v7)
  {
    v8 = (_QWORD *)(v7 + 184);
    v5 = (_QWORD *)(v7 + 568);
    if ((*(_BYTE *)(a2 + 2236) & 2) == 0)
      v5 = v8;
    a3 = 1;
LABEL_13:
    *v5 += a3;
  }
  return result;
}

void tcp_process_accecn(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, char a5)
{
  uint64_t v6;
  unsigned int v7;
  unsigned __int8 *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  void (*v18)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD);
  int v19;
  int v20;
  BOOL v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a1 + 428) & 1) != 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v23 = __nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        v24 = 136446210;
        v25 = "tcp_process_accecn";
        _os_log_impl(&dword_209FB3000, v23, OS_LOG_TYPE_DEBUG, "%{public}s already processed AccECN field/options for this ACK", (uint8_t *)&v24, 0xCu);
      }
    }
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 472);
    v7 = *(unsigned __int8 *)(a2 + 32);
    if (!*(_BYTE *)(a2 + 32))
      goto LABEL_6;
    v8 = *(unsigned __int8 **)(a2 + 40);
    v9 = *(unsigned __int8 *)(a2 + 48);
    v10 = 456;
    if (!*(_BYTE *)(a2 + 48))
      v10 = 464;
    *(_QWORD *)(a1 + v10) += (((*v8 << 16) | (v8[1] << 8) | v8[2]) - *(_QWORD *)(a1 + v10)) & 0xFFFFFF;
    if (v7 != 1)
    {
      v11 = (((v8[3] << 16) | (v8[4] << 8) | v8[5]) - (_DWORD)v6) & 0xFFFFFF;
      v12 = v6 + v11;
      *(_QWORD *)(a1 + 472) = v6 + v11;
      if (v7 >= 3)
      {
        v19 = (v8[6] << 16) | (v8[7] << 8);
        v20 = v8[8];
        v21 = v9 == 0;
        v22 = 464;
        if (v21)
          v22 = 456;
        *(_QWORD *)(a1 + v22) += ((v19 | v20) - *(_QWORD *)(a1 + v22)) & 0xFFFFFF;
      }
    }
    else
    {
LABEL_6:
      v11 = 0;
      v12 = v6;
    }
    v13 = *(_DWORD *)(a1 + 420);
    v14 = (a5 - (_BYTE)v13) & 7;
    if (a4 >= 8)
    {
      v15 = v12 - v6;
      if (v15)
      {
        if (v15 >= (*(_DWORD *)(a1 + 196) * (a4 - (((_BYTE)a4 - (a5 - (_BYTE)v13)) & 7))) >> 1)
          v14 = a4 - (((_BYTE)a4 - (a5 - (_BYTE)v13)) & 7);
      }
    }
    *(_DWORD *)(a1 + 420) = v14 + v13;
    *(_DWORD *)(a1 + 424) = v14;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      v16 = *(_DWORD *)(a2 + 8);
      if (v16)
      {
        if (v16 - *(_DWORD *)(a1 + 400) >= 0)
          *(_DWORD *)(a1 + 400) = v16;
      }
    }
    if (v14)
    {
      *(_DWORD *)(a1 + 348) |= 0x20u;
      *(_DWORD *)(a1 + 292) += v14;
      v17 = *(_QWORD *)(a1 + 1056);
      if (v17)
        *(_QWORD *)(v17 + 880) += v14;
      *(_QWORD *)(a1 + 384) = v14 + v13 - 5;
    }
    v18 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)]
                                                                           + 104);
    if (v18)
      v18(a1, a3, v11, *(unsigned int *)(a1 + 292), *(unsigned int *)(a1 + 296));
    *(_BYTE *)(a1 + 428) |= 1u;
  }
}

uint64_t tcp_tfo_syn(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  char *v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  signed int v10;
  uint64_t v11;
  unsigned int v12;
  _QWORD __s1[3];

  __s1[2] = *MEMORY[0x24BDAC8D0];
  if ((*(_DWORD *)a2 & 0xC00) == 0 || (*(_BYTE *)(sysctls + 160) & 1) == 0)
    return 0;
  if ((*(_DWORD *)a2 & 0x800) != 0)
  {
    *(_BYTE *)(a1 + 988) |= 1u;
    *(_WORD *)(a1 + 990) |= 2u;
    v8 = *(_QWORD *)(a1 + 1056);
    if (!v8)
      return 0;
    result = 0;
    ++*(_QWORD *)(v8 + 1088);
  }
  else
  {
    tcp_tfo_gen_cookie(*(_QWORD *)(a1 + 80), __s1);
    v5 = *(char **)(a2 + 24);
    v6 = *v5++;
    *(_QWORD *)(a2 + 24) = v5;
    if (memcmp(__s1, v5, (v6 - 2)))
    {
      *(_BYTE *)(a1 + 988) |= 1u;
      *(_WORD *)(a1 + 990) |= 8u;
      v7 = *(_QWORD *)(a1 + 1056);
      if (v7)
      {
        result = 0;
        ++*(_QWORD *)(v7 + 1096);
        return result;
      }
      return 0;
    }
    do
    {
      v9 = __ldxr((unsigned int *)&tcp_tfo_halfcnt);
      v10 = v9 + 1;
    }
    while (__stxr(v10, (unsigned int *)&tcp_tfo_halfcnt));
    if (v10 >= *(_DWORD *)(sysctls + 156))
    {
      result = 0;
      do
        v12 = __ldxr((unsigned int *)&tcp_tfo_halfcnt);
      while (__stxr(v12 - 1, (unsigned int *)&tcp_tfo_halfcnt));
    }
    else
    {
      *(_BYTE *)(a1 + 988) |= 2u;
      *(_WORD *)(a1 + 990) |= 1u;
      v11 = *(_QWORD *)(a1 + 1056);
      if (v11)
        ++*(_QWORD *)(v11 + 1080);
      return 1;
    }
  }
  return result;
}

int64x2_t tcp_input_process_accecn_syn(int64x2_t *a1, int a2, int a3)
{
  __int32 v3;
  BOOL v4;
  __int32 v5;
  BOOL v6;
  int v7;
  int64x2_t result;

  if (a2 == 448)
  {
    v3 = a1[46].i32[1];
    if ((v3 & 0x10000000) == 0
      && ((v3 & 0x8000000) != 0 || (*(_DWORD *)(sysctls + 320) != 1 ? (v4 = tcp_do_acc_ecn == 1) : (v4 = 1), v4)))
    {
      switch(a3)
      {
        case 0:
LABEL_22:
          v7 = a1[21].i32[3] | 0x10000;
          break;
        case 1:
LABEL_24:
          v7 = a1[21].i32[3] | 0x20000;
          break;
        case 2:
LABEL_25:
          v7 = a1[21].i32[3] | 0x40000;
          break;
        case 3:
LABEL_26:
          v7 = a1[21].i32[3] | 0x80000;
          break;
        default:
LABEL_23:
          v7 = a1[21].i32[3];
          break;
      }
      result = vdupq_n_s64(1uLL);
      a1[21].i32[3] = v7 | 0x200000;
      a1[27] = result;
      a1[28].i64[1] = 1;
      a1[29].i64[0] = 1;
      a1[22].i32[3] = 5;
    }
    else
    {
      a1[21].i32[3] |= 6u;
    }
  }
  else if (a2 == 192)
  {
    a1[21].i32[3] |= 6u;
    a1[22].i32[3] = 4;
  }
  else if (a2)
  {
    v5 = a1[46].i32[1];
    if ((v5 & 0x10000000) == 0)
    {
      if ((v5 & 0x8000000) != 0 || (*(_DWORD *)(sysctls + 320) != 1 ? (v6 = tcp_do_acc_ecn == 1) : (v6 = 1), v6))
      {
        switch(a3)
        {
          case 0:
            goto LABEL_22;
          case 1:
            goto LABEL_24;
          case 2:
            goto LABEL_25;
          case 3:
            goto LABEL_26;
          default:
            goto LABEL_23;
        }
      }
    }
  }
  else
  {
    a1[22].i32[3] = 3;
  }
  return result;
}

uint64_t tcp_tfo_synack(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  const char *v7;
  NSObject *v8;
  os_log_type_t v9;
  unsigned __int8 *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  __int16 v15;
  uint8_t v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;
  uint8_t v20;
  uint64_t result;
  __int16 v22;
  uint64_t v23;
  NSObject *v24;
  const char *v25;
  __int16 v26;
  uint8_t v27;
  NSObject *v28;
  void *v29;
  uint8_t buf[24];
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 1) & 4) != 0)
  {
    v11 = *(unsigned __int8 **)(a2 + 24);
    v12 = *v11 - 2;
    if (v12 >= 0x11)
    {
      v28 = __nwlog_obj();
      os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_tfo_synack";
      v29 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort();
      if ((_DWORD)result)
      {
        __break(1u);
        return result;
      }
      free(v29);
      v11 = *(unsigned __int8 **)(a2 + 24);
    }
    *(_QWORD *)(a2 + 24) = v11 + 1;
    v13 = *(_QWORD *)(a1 + 80);
    memset(buf, 0, 18);
    __memcpy_chk();
    buf[16] = v12;
    (*(void (**)(_QWORD, uint8_t *))(*(_QWORD *)(v13 + 2136) + 56))(*(_QWORD *)(v13 + 224), buf);
    v14 = *(_QWORD *)(a1 + 80);
    memset(buf, 0, 18);
    v15 = *(_WORD *)(a1 + 990);
    if ((v15 & 0x40) != 0)
    {
      buf[17] = 1;
      v16 = 9;
      if ((v15 & 0x10) == 0)
        goto LABEL_26;
    }
    else
    {
      v16 = 8;
      if ((v15 & 0x10) == 0)
      {
LABEL_26:
        result = (*(uint64_t (**)(_QWORD, uint8_t *))(*(_QWORD *)(v14 + 2136) + 56))(*(_QWORD *)(v14 + 224), buf);
        v22 = *(_WORD *)(a1 + 990);
        *(_WORD *)(a1 + 990) = v22 | 0x20;
        v23 = *(_QWORD *)(a1 + 1056);
        if (v23)
        {
          ++*(_QWORD *)(v23 + 1112);
          if ((*(_BYTE *)(a1 + 988) & 8) == 0)
            return result;
          ++*(_QWORD *)(v23 + 1152);
        }
        else if ((*(_BYTE *)(a1 + 988) & 8) == 0)
        {
          return result;
        }
        *(_WORD *)(a1 + 990) = v22 | 0x220;
        return result;
      }
    }
    buf[17] = v16;
    goto LABEL_26;
  }
  if ((*(_BYTE *)(a1 + 743) & 1) != 0 || (*(_BYTE *)(a1 + 988) & 0x10) == 0)
  {
    v17 = *(_WORD *)(a1 + 990);
    if ((*(_BYTE *)(a1 + 988) & 4) != 0)
    {
      v17 |= 0x400u;
      *(_WORD *)(a1 + 990) = v17;
      v18 = *(_QWORD *)(a1 + 1056);
      if (v18)
        ++*(_QWORD *)(v18 + 1160);
    }
    v19 = *(_QWORD *)(a1 + 80);
    memset(buf, 0, 18);
    if ((v17 & 0x40) != 0)
    {
      buf[17] = 1;
      v20 = 9;
      if ((v17 & 0x10) == 0)
        return (*(uint64_t (**)(_QWORD, uint8_t *))(*(_QWORD *)(v19 + 2136) + 56))(*(_QWORD *)(v19 + 224), buf);
    }
    else
    {
      v20 = 8;
      if ((v17 & 0x10) == 0)
        return (*(uint64_t (**)(_QWORD, uint8_t *))(*(_QWORD *)(v19 + 2136) + 56))(*(_QWORD *)(v19 + 224), buf);
    }
    buf[17] = v20;
    return (*(uint64_t (**)(_QWORD, uint8_t *))(*(_QWORD *)(v19 + 2136) + 56))(*(_QWORD *)(v19 + 224), buf);
  }
  *(_WORD *)(a1 + 990) |= 0x100u;
  v3 = *(_QWORD *)(a1 + 1056);
  if (v3)
    ++*(_QWORD *)(v3 + 1136);
  v4 = *(_QWORD *)(a1 + 80);
  v5 = *(_QWORD *)(v4 + 224);
  if (tcp_perf_measurement)
  {
    if (!v5 || (*(_BYTE *)(v5 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v6 = __nwlog_tcp_log();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          v7 = "";
          if (v5)
            v7 = (const char *)(v5 + 604);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "tcp_heuristic_tfo_loss";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v7;
          v8 = v6;
          v9 = OS_LOG_TYPE_DEBUG;
LABEL_40:
          _os_log_impl(&dword_209FB3000, v8, v9, "%{public}s %{public}s ", buf, 0x16u);
        }
      }
    }
  }
  else if (!v5 || (*(_BYTE *)(v5 + 828) & 2) == 0)
  {
    v24 = __nwlog_tcp_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      v25 = "";
      if (v5)
        v25 = (const char *)(v5 + 604);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "tcp_heuristic_tfo_loss";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v25;
      v8 = v24;
      v9 = OS_LOG_TYPE_INFO;
      goto LABEL_40;
    }
  }
  memset(buf, 0, 18);
  v26 = *(_WORD *)(a1 + 990);
  if ((v26 & 0x40) == 0)
  {
    v27 = 16;
    if ((v26 & 0x10) == 0)
      return (*(uint64_t (**)(_QWORD, uint8_t *))(*(_QWORD *)(v4 + 2136) + 56))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224), buf);
    goto LABEL_45;
  }
  buf[17] = 2;
  v27 = 18;
  if ((v26 & 0x10) != 0)
LABEL_45:
    buf[17] = v27;
  return (*(uint64_t (**)(_QWORD, uint8_t *))(*(_QWORD *)(v4 + 2136) + 56))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224), buf);
}

void tcp_tfo_rcv_probe(uint64_t a1, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  const char *v7;
  int v8;
  unsigned int v9;
  const char *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    *(_BYTE *)(a1 + 993) = 1;
    v3 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316);
    v4 = *(unsigned int *)(a1 + 228);
    if (v4 <= (*(_DWORD *)(a1 + 208) + (*(int *)(a1 + 200) >> 3)) >> 2)
      LODWORD(v4) = (*(_DWORD *)(a1 + 208) + (*(int *)(a1 + 200) >> 3)) >> 2;
    *(_DWORD *)(a1 + 40) = v3 - *(_DWORD *)(a1 + 64) + v4;
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
    if (!v5 || (*(_BYTE *)(v5 + 828) & 2) == 0)
    {
      v6 = __nwlog_tcp_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = "";
        if (v5)
          v7 = (const char *)(v5 + 604);
        v8 = *(_DWORD *)(a1 + 40);
        v9 = *(_DWORD *)(a1 + 1872) - 1;
        if (v9 > 2)
          v10 = "invalid";
        else
          v10 = off_24C2B2B68[v9];
        v11 = *(_DWORD *)(a1 + 240);
        v12 = *(_DWORD *)(a1 + 200);
        v13 = *(_DWORD *)(a1 + 204);
        v15 = *(_DWORD *)(a1 + 208);
        v14 = *(_DWORD *)(a1 + 212);
        v16 = 136449282;
        v17 = "tcp_tfo_rcv_probe";
        v18 = 2082;
        v19 = v7;
        v20 = 1024;
        v21 = v8;
        v22 = 2082;
        v23 = v10;
        v24 = 1024;
        v25 = v11;
        v26 = 1024;
        v27 = v12 >> 5;
        v28 = 1024;
        v29 = ((1000 * v12) >> 5) % 1000;
        v30 = 1024;
        v31 = v15 >> 4;
        v32 = 1024;
        v33 = ((1000 * v15) >> 4) % 1000;
        v34 = 1024;
        v35 = v13 >> 5;
        v36 = 1024;
        v37 = ((1000 * v13) >> 5) % 1000;
        v38 = 1024;
        v39 = v14 >> 4;
        v40 = 1024;
        v41 = ((1000 * v14) >> 4) % 1000;
        _os_log_impl(&dword_209FB3000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s UTCPT_KEEP: %u RTT_Cache: %{public}s, rtt_upd: %d, rtt: %u.%03ums, rtt_var: %u.%03ums rtt_nc: %u.%03ums, rtt_var_nc: %u.%03ums", (uint8_t *)&v16, 0x5Cu);
      }
    }
  }
}

uint64_t tcp_newreno_partial_ack(_DWORD *a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  int v6;
  uint64_t result;
  unsigned int v8;
  BOOL v9;
  unsigned int v10;

  v4 = a1[25];
  v5 = a1[36];
  a1[7] = 0;
  a1[4] = 0;
  a1[43] = 0;
  v6 = *(_DWORD *)(a2 + 8);
  a1[25] = v6;
  a1[36] = a1[49] + v6 - a1[23];
  result = tcp_output((uint64_t)a1);
  if (v4 - a1[25] >= 1)
    a1[25] = v4;
  v8 = *(_DWORD *)(a2 + 8) - a1[23];
  v9 = v5 >= v8;
  v10 = v5 - v8;
  if (!v9)
    v10 = 0;
  a1[36] = v10 + a1[49];
  return result;
}

uint64_t tcp_reass(uint64_t a1, int *a2, uint64_t *a3, uint64_t a4, unsigned int a5, _BYTE *a6, _DWORD *a7)
{
  uint64_t v11;
  int v12;
  _BOOL4 v13;
  uint64_t v14;
  unsigned int v15;
  BOOL v16;
  __int16 v17;
  int v18;
  void *v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  NSObject *v28;
  int v29;
  NSObject *v30;
  int v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  const char *v37;
  void *v38;
  uint64_t v39;
  _DWORD *v40;
  uint64_t v41;
  NSObject *v42;
  uint64_t result;
  const char *v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  NSObject *v50;
  int v51;
  int *v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  void *v56;
  void *v57;
  _QWORD *v58;
  int v59;
  uint64_t v60;
  _BOOL4 v61;
  int v62;
  int v63;
  _QWORD *v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  NSObject *v68;
  const char *v69;
  void (*v70)(uint64_t, uint64_t, uint64_t);
  uint64_t v71;
  uint64_t v72;
  void (*v73)(uint64_t, uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t v80;
  const char *v81;
  int v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  int v88;
  _QWORD *v89;
  uint64_t v90;
  _QWORD *v91;
  void (*v92)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v93;
  uint64_t v94;
  void *v95;
  NSObject *v96;
  NSObject *v97;
  int v98;
  int v99;
  int v100;
  int v101;
  uint64_t v102;
  unsigned int v103;
  int v104;
  void *v105;
  uint64_t v106;
  uint64_t v107;
  unsigned int v108;
  int v109;
  NSObject *v110;
  _BOOL4 v111;
  int v112;
  uint64_t v113;
  uint64_t v114;
  _QWORD *v115;
  uint64_t all_stats;
  void (*v117)(uint64_t, uint64_t, uint64_t);
  uint64_t v118;
  NSObject *v119;
  int v120;
  uint64_t v121;
  unsigned int v122;
  int v123;
  int v124;
  int v125;
  unsigned int v126;
  unsigned int v127;
  int v128;
  NSObject *v129;
  int v130;
  NSObject *v131;
  _QWORD *v132;
  uint64_t v133;
  _QWORD *v134;
  uint64_t v135;
  int v136;
  int v137;
  uint64_t v138;
  int v139;
  const char *v140;
  uint64_t v141;
  char v142;
  uint64_t v143;
  int v144;
  unsigned int v145;
  NSObject *v146;
  uint64_t v147;
  signed int v148;
  int v149;
  _QWORD *v150;
  void (*v151)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v152;
  uint64_t v153;
  void *v154;
  NSObject *v155;
  void *v156;
  NSObject *v157;
  const char *v158;
  int v159;
  void *v160;
  NSObject *v161;
  void *v162;
  NSObject *v163;
  const char *v164;
  int v165;
  int v166;
  int v167;
  void *v168;
  NSObject *v169;
  void *v170;
  NSObject *v171;
  NSObject *v172;
  NSObject *v173;
  const char *v174;
  int v175;
  int v176;
  int v177;
  void *v178;
  NSObject *v179;
  NSObject *v180;
  uint64_t v182;
  int type;
  int v184;
  _BOOL4 v185;
  uint64_t v186;
  int v187;
  uint64_t v188;
  _QWORD *v189;
  uint64_t v190;
  int *v191;
  uint64_t v192;
  uint8_t buf[4];
  const char *v195;
  __int16 v196;
  _BYTE v197[10];
  _BYTE v198[10];
  _BYTE v199[6];
  __int16 v200;
  int v201;
  uint64_t v202;

  v202 = *MEMORY[0x24BDAC8D0];
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
  v182 = *(_QWORD *)(a1 + 80);
  if (!a4)
  {
    type = 0;
    v184 = 0;
    v185 = 0;
    goto LABEL_10;
  }
  if (*(unsigned __int8 *)(a4 + 1076) == 255 || *(_DWORD *)(a4 + 1024) == 255)
  {
    v12 = 1;
  }
  else
  {
    if (*(_DWORD *)(a4 + 1068) == 3)
    {
      v185 = 0;
      type = 1;
      v184 = 0;
      goto LABEL_10;
    }
    v12 = 0;
    if (*(_DWORD *)(a4 + 1032) == 3)
    {
      type = 1;
      v184 = 0;
      v185 = 0;
      goto LABEL_10;
    }
  }
  v184 = v12;
  type = 0;
  v13 = *(_DWORD *)(a4 + 1064) == 2 || *(_DWORD *)(a4 + 1028) == 2;
  v185 = v13;
LABEL_10:
  v188 = nw_tcp_access_globals(v11);
  if (a7)
    *a7 = 0;
  v186 = *a3;
  v190 = nw_protocol_tcp_copy_frame(v11, *a3, *a2 + a5);
  v14 = *a3;
  v192 = v11;
  v191 = a2;
  if (!*a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v195 = "__nw_frame_is_single_ip_aggregate";
    v156 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v161 = __nwlog_obj();
      if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v195 = "__nw_frame_is_single_ip_aggregate";
        _os_log_impl(&dword_209FB3000, v161, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v156)
    {
      free(v156);
      if (!a5)
        goto LABEL_47;
LABEL_19:
      v20 = *a3;
      if (!*a3)
        goto LABEL_43;
      goto LABEL_20;
    }
LABEL_18:
    if (!a5)
      goto LABEL_47;
    goto LABEL_19;
  }
  if ((*(_WORD *)(v14 + 204) & 0x80) == 0)
    goto LABEL_18;
  v15 = *(unsigned __int16 *)(v14 + 196);
  v16 = v15 >= a5;
  v17 = v15 - a5;
  if (v16)
  {
    *(_WORD *)(v14 + 196) = v17;
    goto LABEL_18;
  }
  __nwlog_obj();
  v18 = *(unsigned __int16 *)(v14 + 196);
  *(_DWORD *)buf = 136446722;
  v195 = "__nw_frame_array_claim";
  v196 = 1024;
  *(_DWORD *)v197 = v18;
  *(_WORD *)&v197[4] = 1024;
  *(_DWORD *)&v197[6] = a5;
  v19 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v30 = __nwlog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v31 = *(unsigned __int16 *)(v14 + 196);
      *(_DWORD *)buf = 136446722;
      v195 = "__nw_frame_array_claim";
      v196 = 1024;
      *(_DWORD *)v197 = v31;
      *(_WORD *)&v197[4] = 1024;
      *(_DWORD *)&v197[6] = a5;
      _os_log_impl(&dword_209FB3000, v30, OS_LOG_TYPE_ERROR, "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded", buf, 0x18u);
    }
  }
  if (v19)
    free(v19);
  *(_WORD *)(v14 + 196) = 0;
  v20 = *a3;
  if (!*a3)
  {
LABEL_43:
    v21 = 0;
LABEL_44:
    if (v21 != a5)
    {
      v32 = __nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v195 = "__nw_frame_array_claim";
        v196 = 1024;
        *(_DWORD *)v197 = v21;
        *(_WORD *)&v197[4] = 1024;
        *(_DWORD *)&v197[6] = a5;
        _os_log_impl(&dword_209FB3000, v32, OS_LOG_TYPE_ERROR, "%{public}s start_offset %u != start_bytes %u", buf, 0x18u);
      }
    }
    goto LABEL_47;
  }
LABEL_20:
  v21 = 0;
  while (1)
  {
    v22 = *(_DWORD *)(v20 + 52);
    v23 = *(_DWORD *)(v20 + 56);
    v24 = *(_DWORD *)(v20 + 60);
    v25 = v22 - (v23 + v24);
    if (v25 >= a5 - v21)
      v25 = a5 - v21;
    v26 = v22 ? v25 : 0;
    v27 = v23 + v26;
    if (v23 + v26 <= v22 - v24)
    {
      *(_DWORD *)(v20 + 56) = v27;
    }
    else
    {
      v28 = __nwlog_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        v29 = *(_DWORD *)(v20 + 52);
        *(_DWORD *)buf = 136446978;
        v195 = "__nw_frame_claim_internal";
        v196 = 1024;
        *(_DWORD *)v197 = v27;
        *(_WORD *)&v197[4] = 1024;
        *(_DWORD *)&v197[6] = v29;
        *(_WORD *)v198 = 1024;
        *(_DWORD *)&v198[2] = v24;
        _os_log_impl(&dword_209FB3000, v28, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
      }
    }
    v21 += v26;
    if (v21 == a5)
      break;
    if (v21 < a5)
    {
      v20 = *(_QWORD *)(v20 + 32);
      if (v20)
        continue;
    }
    goto LABEL_44;
  }
LABEL_47:
  v33 = v190;
  if (!v190)
  {
    v39 = v192;
    if (v186)
    {
      v40 = a7;
      if ((*(_WORD *)(v186 + 204) & 0x100) == 0
        || !*MEMORY[0x24BDE08C0]
        || (((uint64_t (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v186, *(_QWORD *)(v186 + 88)) & 1) != 0)
      {
        if (!a7)
          goto LABEL_64;
        goto LABEL_63;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v195 = "__nw_frame_check_validity";
      v160 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v169 = __nwlog_obj();
        if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v195 = "__nw_frame_check_validity";
          _os_log_impl(&dword_209FB3000, v169, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v160)
        free(v160);
      v39 = v192;
      v40 = a7;
    }
    *(_QWORD *)(a1 + 1056) = 0;
    if (!v40)
    {
LABEL_64:
      v41 = *(_QWORD *)(a1 + 1056);
      if (v41)
        ++*(_QWORD *)(v41 + 232);
      if (!v39 || (*(_BYTE *)(v39 + 828) & 2) == 0)
      {
        v42 = __nwlog_tcp_log();
        result = os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
          return result;
        v44 = "";
        if (v39)
          v44 = (const char *)(v39 + 604);
        *(_DWORD *)buf = 136446466;
        v195 = "tcp_reass";
        v196 = 2082;
        *(_QWORD *)v197 = v44;
        _os_log_impl(&dword_209FB3000, v42, OS_LOG_TYPE_ERROR, "%{public}s %{public}s unable to copy frame for reassembly", buf, 0x16u);
      }
      return 0;
    }
LABEL_63:
    *v40 = 12;
    goto LABEL_64;
  }
  v34 = v192;
  v35 = a1;
  if ((*(_WORD *)(v190 + 204) & 0x4000) != 0)
  {
    *(_DWORD *)(a1 + 740) |= 0x4000000u;
    v36 = *(_WORD *)(v190 + 204) & 0xBFFF | (*(unsigned __int8 *)(v190 + 206) << 16);
    *(_WORD *)(v190 + 204) &= ~0x4000u;
    *(_BYTE *)(v190 + 206) = BYTE2(v36);
  }
  if (*(_QWORD *)(v190 + 32) && (!v192 || (*(_BYTE *)(v192 + 828) & 2) == 0))
  {
    __nwlog_tcp_log();
    if (v192)
      v37 = (const char *)(v192 + 604);
    else
      v37 = "";
    *(_DWORD *)buf = 136446466;
    v195 = "tcp_reass";
    v196 = 2082;
    *(_QWORD *)v197 = v37;
    v38 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v45 = __nwlog_tcp_log();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v195 = "tcp_reass";
        v196 = 2082;
        *(_QWORD *)v197 = v37;
        _os_log_impl(&dword_209FB3000, v45, OS_LOG_TYPE_ERROR, "%{public}s %{public}s new_frame has next, backtrace limit exceeded", buf, 0x16u);
      }
    }
    if (v38)
      free(v38);
    v33 = v190;
  }
  v46 = *(_QWORD *)(v33 + 112);
  if (v46)
  {
    if ((*(_WORD *)(v33 + 204) & 0x100) == 0 || !*MEMORY[0x24BDE08C0])
      goto LABEL_82;
    if (((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(v33, *(_QWORD *)(v33 + 88)))
    {
      v46 = *(_QWORD *)(v33 + 112);
LABEL_82:
      v47 = v46 + *(unsigned int *)(v33 + 56);
      goto LABEL_84;
    }
  }
  v47 = 0;
LABEL_84:
  if ((*(_WORD *)(v33 + 204) & 0x80) != 0)
    *(_WORD *)(v33 + 196) -= a5;
  v48 = *(_DWORD *)(v33 + 56) + a5;
  v49 = *(_DWORD *)(v33 + 60);
  if (v48 > *(_DWORD *)(v33 + 52) - v49)
  {
    v50 = __nwlog_obj();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      v51 = *(_DWORD *)(v33 + 52);
      *(_DWORD *)buf = 136446978;
      v195 = "__nw_frame_claim_internal";
      v196 = 1024;
      *(_DWORD *)v197 = v48;
      *(_WORD *)&v197[4] = 1024;
      *(_DWORD *)&v197[6] = v51;
      *(_WORD *)v198 = 1024;
      *(_DWORD *)&v198[2] = v49;
      _os_log_impl(&dword_209FB3000, v50, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
    }
    if (!v192)
      goto LABEL_93;
LABEL_92:
    if ((*(_BYTE *)(v192 + 828) & 2) != 0)
      goto LABEL_94;
    goto LABEL_93;
  }
  *(_DWORD *)(v33 + 56) = v48;
  if (v192)
    goto LABEL_92;
LABEL_93:
  if (__nwlog_is_datapath_logging_enabled())
  {
    v157 = __nwlog_tcp_log();
    if (os_log_type_enabled(v157, OS_LOG_TYPE_DEBUG))
    {
      v158 = (const char *)(v192 + 604);
      if (!v192)
        v158 = "";
      v159 = *(_DWORD *)(v33 + 52);
      if (v159)
        v159 -= *(_DWORD *)(v33 + 56) + *(_DWORD *)(v33 + 60);
      *(_DWORD *)buf = 136446978;
      v195 = "tcp_reass";
      v196 = 2082;
      *(_QWORD *)v197 = v158;
      *(_WORD *)&v197[8] = 2048;
      *(_QWORD *)v198 = v33;
      *(_WORD *)&v198[8] = 1024;
      *(_DWORD *)v199 = v159;
      _os_log_impl(&dword_209FB3000, v157, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s queueing frame %p of length %u", buf, 0x26u);
    }
  }
LABEL_94:
  *(_DWORD *)(a1 + 88) &= 0x7DFFFFFFu;
  *(_QWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 324) = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316) + 100;
  *(_DWORD *)(a1 + 740) |= 2u;
  *(_WORD *)(a1 + 344) = 0;
  *(_WORD *)(a1 + 308) = 16;
  if (*(_WORD *)(a1 + 754))
  {
    *(_WORD *)(a1 + 754) = 0;
    *(_DWORD *)(a1 + 744) = 0;
  }
  v52 = v191;
  if (*(_DWORD *)(v47 + 4) != *(_DWORD *)(a1 + 120))
  {
    v53 = *(_DWORD *)(v192 + 492);
    if (v53 >= 0x19000)
      v54 = v53 >> 10;
    else
      v54 = 100;
    if (v54 >= *(_DWORD *)(sysctls + 72) >> 10)
      LOWORD(v54) = *(_DWORD *)(sysctls + 72) >> 10;
    v55 = (unsigned __int16)v54;
    if (*(unsigned __int16 *)(a1 + 224) + 1 >= (unsigned __int16)v54)
    {
      v72 = *(_QWORD *)(a1 + 1056);
      if (v72)
        ++*(_QWORD *)(v72 + 232);
      if ((*(_BYTE *)(v192 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v163 = __nwlog_tcp_log();
          if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
          {
            v164 = (const char *)(v192 + 604);
            v165 = *(_DWORD *)(v47 + 4);
            v166 = *(_DWORD *)(a1 + 120);
            if (!v192)
              v164 = "";
            v167 = *(unsigned __int16 *)(a1 + 224);
            *(_DWORD *)buf = 136447490;
            v195 = "tcp_reass";
            v196 = 2082;
            *(_QWORD *)v197 = v164;
            *(_WORD *)&v197[8] = 1024;
            *(_DWORD *)v198 = v165;
            *(_WORD *)&v198[4] = 1024;
            *(_DWORD *)&v198[6] = v166;
            *(_WORD *)v199 = 1024;
            *(_DWORD *)&v199[2] = v167;
            v200 = 1024;
            v201 = v55;
            _os_log_impl(&dword_209FB3000, v163, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s drop due to limit: seq %u rcv_nxt %u reqssqlen %u qlimit %u", buf, 0x2Eu);
          }
        }
      }
      v73 = *(void (**)(uint64_t, uint64_t, uint64_t))(v33 + 80);
      if (v73)
      {
        v74 = *(_QWORD *)(v33 + 88);
        *(_QWORD *)(v33 + 80) = 0;
        *(_QWORD *)(v33 + 88) = 0;
        v73(v33, 1, v74);
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v195 = "__nw_frame_finalize";
        v168 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v172 = __nwlog_obj();
          if (os_log_type_enabled(v172, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v195 = "__nw_frame_finalize";
            _os_log_impl(&dword_209FB3000, v172, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
          }
        }
        if (v168)
          free(v168);
      }
      result = 0;
      *v191 = 0;
      return result;
    }
  }
  v56 = malloc_type_malloc(**(_QWORD **)(v188 + 48), 0xB9BAFBABuLL);
  if (!v56)
  {
    v67 = *(_QWORD *)(a1 + 1056);
    if (v67)
      ++*(_QWORD *)(v67 + 232);
    if ((*(_BYTE *)(v192 + 828) & 2) == 0)
    {
      v68 = __nwlog_tcp_log();
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
        v69 = "";
        if (v192)
          v69 = (const char *)(v192 + 604);
        *(_DWORD *)buf = 136446466;
        v195 = "tcp_reass";
        v196 = 2082;
        *(_QWORD *)v197 = v69;
        _os_log_impl(&dword_209FB3000, v68, OS_LOG_TYPE_ERROR, "%{public}s %{public}s couldn't allocate memory for tcp_reass_zone", buf, 0x16u);
      }
    }
    v70 = *(void (**)(uint64_t, uint64_t, uint64_t))(v33 + 80);
    if (v70)
    {
      v71 = *(_QWORD *)(v33 + 88);
      *(_QWORD *)(v33 + 80) = 0;
      *(_QWORD *)(v33 + 88) = 0;
      v70(v33, 1, v71);
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v195 = "__nw_frame_finalize";
      v162 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v171 = __nwlog_obj();
        if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v195 = "__nw_frame_finalize";
          _os_log_impl(&dword_209FB3000, v171, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v162)
        free(v162);
    }
    return 0;
  }
  v57 = v56;
  ++*(_WORD *)(a1 + 224);
  v58 = *(_QWORD **)a1;
  v59 = *(_DWORD *)(v47 + 4);
  if (!*(_QWORD *)a1)
  {
    v64 = 0;
    v65 = 0;
    v187 = 1;
    v60 = v182;
    v61 = v185;
    v63 = type;
    v62 = v184;
    goto LABEL_129;
  }
  v60 = v182;
  v61 = v185;
  v63 = type;
  v62 = v184;
  if (*(_DWORD *)(v58[3] + 4) - v59 > 0)
  {
    v64 = 0;
    v65 = 0;
    v187 = 1;
    goto LABEL_129;
  }
  do
  {
    v64 = v58;
    v58 = (_QWORD *)*v58;
  }
  while (v58 && *(_DWORD *)(v58[3] + 4) - v59 < 1);
  v66 = (*((_DWORD *)v64 + 4) + *(_DWORD *)(v64[3] + 4) - v59);
  if ((int)v66 < 1)
  {
    v187 = 0;
    v65 = 0;
    goto LABEL_129;
  }
  if ((_DWORD)v66 == 1)
  {
    v65 = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 940) = v59;
    v106 = *v191;
    if (v66 < v106)
      LODWORD(v106) = v66;
    *(_DWORD *)(a1 + 944) = v106 + v59;
    v65 = 1;
  }
  v107 = *v191;
  if ((int)v66 >= (int)v107)
  {
    v113 = *(_QWORD *)(a1 + 1056);
    if (v113)
    {
      v114 = *(_QWORD *)(v113 + 216) + v107;
      ++*(_QWORD *)(v113 + 208);
      *(_QWORD *)(v113 + 216) = v114;
    }
    v115 = *(_QWORD **)(v182 + 248);
    ++*v115;
    if (v184)
    {
      ++**(_QWORD **)(v182 + 256);
      if (!type)
        goto LABEL_206;
    }
    else if (!type)
    {
LABEL_206:
      if (!v185)
        goto LABEL_208;
      goto LABEL_207;
    }
    ++**(_QWORD **)(v182 + 264);
    if (!v185)
    {
LABEL_208:
      v115[1] += v107;
      if (v184)
      {
        *(_QWORD *)(*(_QWORD *)(v182 + 256) + 8) += v107;
        if (!type)
          goto LABEL_210;
      }
      else if (!type)
      {
LABEL_210:
        if (!v185)
          goto LABEL_212;
        goto LABEL_211;
      }
      *(_QWORD *)(*(_QWORD *)(v182 + 264) + 8) += v107;
      if (!v185)
      {
LABEL_212:
        *(_DWORD *)(a1 + 704) += v107;
        if (*(_QWORD *)(v192 + 24))
        {
          all_stats = nw_protocol_tcp_get_all_stats();
          if (all_stats)
            *(_DWORD *)(all_stats + 48) += *v191;
        }
        if ((*(_BYTE *)(v192 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            v173 = __nwlog_tcp_log();
            if (os_log_type_enabled(v173, OS_LOG_TYPE_DEBUG))
            {
              v174 = (const char *)(v192 + 604);
              v175 = *(_DWORD *)(v64[3] + 4);
              if (!v192)
                v174 = "";
              v176 = *((_DWORD *)v64 + 4);
              v177 = *(_DWORD *)(v47 + 4);
              *(_DWORD *)buf = 136447234;
              v195 = "tcp_reass";
              v196 = 2082;
              *(_QWORD *)v197 = v174;
              *(_WORD *)&v197[8] = 1024;
              *(_DWORD *)v198 = v175;
              *(_WORD *)&v198[4] = 1024;
              *(_DWORD *)&v198[6] = v176;
              *(_WORD *)v199 = 1024;
              *(_DWORD *)&v199[2] = v177;
              _os_log_impl(&dword_209FB3000, v173, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s It's a duplicate segment: tqe_seq %u tqe_len %u th_seq %u", buf, 0x28u);
            }
          }
        }
        v117 = *(void (**)(uint64_t, uint64_t, uint64_t))(v190 + 80);
        if (v117)
        {
          v118 = *(_QWORD *)(v190 + 88);
          *(_QWORD *)(v190 + 80) = 0;
          *(_QWORD *)(v190 + 88) = 0;
          v117(v190, 1, v118);
        }
        else
        {
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v195 = "__nw_frame_finalize";
          v178 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            v180 = __nwlog_obj();
            if (os_log_type_enabled(v180, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v195 = "__nw_frame_finalize";
              _os_log_impl(&dword_209FB3000, v180, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v178)
            free(v178);
          v35 = a1;
        }
        free(v57);
        --*(_WORD *)(v35 + 224);
        goto LABEL_259;
      }
LABEL_211:
      *(_QWORD *)(*(_QWORD *)(v182 + 272) + 8) += v107;
      goto LABEL_212;
    }
LABEL_207:
    ++**(_QWORD **)(v182 + 272);
    goto LABEL_208;
  }
  if ((*(_WORD *)(v190 + 204) & 0x80) != 0)
    *(_WORD *)(v190 + 196) -= v66;
  v108 = *(_DWORD *)(v190 + 56) + v66;
  v109 = *(_DWORD *)(v190 + 60);
  if (v108 <= *(_DWORD *)(v190 + 52) - v109)
  {
    *(_DWORD *)(v190 + 56) = v108;
  }
  else
  {
    v110 = __nwlog_obj();
    v111 = os_log_type_enabled(v110, OS_LOG_TYPE_ERROR);
    v63 = type;
    v62 = v184;
    v61 = v185;
    v60 = v182;
    if (v111)
    {
      v112 = *(_DWORD *)(v190 + 52);
      *(_DWORD *)buf = 136446978;
      v195 = "__nw_frame_claim_internal";
      v196 = 1024;
      *(_DWORD *)v197 = v108;
      *(_WORD *)&v197[4] = 1024;
      *(_DWORD *)&v197[6] = v112;
      *(_WORD *)v198 = 1024;
      *(_DWORD *)&v198[2] = v109;
      _os_log_impl(&dword_209FB3000, v110, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
      v63 = type;
      v62 = v184;
      v61 = v185;
      v60 = v182;
    }
  }
  v187 = 0;
  v52 = v191;
  *v191 -= v66;
  v59 = *(_DWORD *)(v47 + 4) + v66;
  *(_DWORD *)(v47 + 4) = v59;
  v34 = v192;
LABEL_129:
  if (v59 != *(_DWORD *)(a1 + 120))
  {
    ++*(_DWORD *)(a1 + 996);
    v75 = *(_QWORD *)(a1 + 1056);
    v76 = *v52;
    if (v75)
    {
      v77 = *(_QWORD *)(v75 + 264) + v76;
      ++*(_QWORD *)(v75 + 256);
      *(_QWORD *)(v75 + 264) = v77;
    }
    *(_DWORD *)(a1 + 708) += v76;
  }
  v78 = *(_QWORD **)(v60 + 248);
  ++*v78;
  if (v62)
  {
    ++**(_QWORD **)(v60 + 256);
    if (!v63)
      goto LABEL_135;
  }
  else if (!v63)
  {
LABEL_135:
    if (!v61)
      goto LABEL_137;
    goto LABEL_136;
  }
  ++**(_QWORD **)(v60 + 264);
  if (v61)
LABEL_136:
    ++**(_QWORD **)(v60 + 272);
LABEL_137:
  v79 = *v52;
  v78[1] += v79;
  if (v62)
  {
    *(_QWORD *)(*(_QWORD *)(v60 + 256) + 8) += v79;
    if (!v63)
      goto LABEL_139;
  }
  else if (!v63)
  {
LABEL_139:
    v189 = v57;
    if (v61)
      goto LABEL_140;
    goto LABEL_147;
  }
  *(_QWORD *)(*(_QWORD *)(v60 + 264) + 8) += v79;
  v189 = v57;
  if (v61)
  {
LABEL_140:
    *(_QWORD *)(*(_QWORD *)(v60 + 272) + 8) += v79;
    if (!*(_QWORD *)(v34 + 24))
      goto LABEL_150;
LABEL_148:
    v80 = nw_protocol_tcp_get_all_stats();
    if (v80)
      *(_DWORD *)(v80 + 52) += *v52;
    goto LABEL_150;
  }
LABEL_147:
  if (*(_QWORD *)(v34 + 24))
    goto LABEL_148;
LABEL_150:
  if (v58)
  {
    if (v192)
      v81 = (const char *)(v192 + 604);
    else
      v81 = "";
    do
    {
      v82 = *v191 + *(_DWORD *)(v47 + 4);
      v83 = v58[3];
      v84 = *(_DWORD *)(v83 + 4);
      v85 = (v82 - v84);
      if ((int)v85 < 1)
        break;
      if (v65 || (_DWORD)v85 == 1)
      {
        LODWORD(v86) = *((_DWORD *)v58 + 4);
      }
      else if (*(_DWORD *)(a1 + 940))
      {
        v86 = *((int *)v58 + 4);
        if (v85 >= v86)
          v87 = *((_DWORD *)v58 + 4);
        else
          v87 = v82 - v84;
        *(_DWORD *)(a1 + 944) += v87;
      }
      else
      {
        *(_DWORD *)(a1 + 940) = v84;
        v86 = *((int *)v58 + 4);
        if (v85 >= v86)
          v88 = *((_DWORD *)v58 + 4);
        else
          v88 = v82 - v84;
        *(_DWORD *)(a1 + 944) = v88 + v84;
      }
      if ((int)v86 > (int)v85)
      {
        *(_DWORD *)(v83 + 4) = v82;
        *((_DWORD *)v58 + 4) = v86 - v85;
        v102 = v58[4];
        if (v102)
        {
          if ((*(_WORD *)(v102 + 204) & 0x80) != 0)
          {
            v103 = *(unsigned __int16 *)(v102 + 196);
            if (v85 <= v103)
            {
              *(_WORD *)(v102 + 196) = v103 - v85;
            }
            else
            {
              __nwlog_obj();
              v104 = *(unsigned __int16 *)(v102 + 196);
              *(_DWORD *)buf = 136446722;
              v195 = "__nw_frame_array_claim";
              v196 = 1024;
              *(_DWORD *)v197 = v104;
              *(_WORD *)&v197[4] = 1024;
              *(_DWORD *)&v197[6] = v85;
              v105 = (void *)_os_log_send_and_compose_impl();
              if (__nwlog_fault())
              {
                v119 = __nwlog_obj();
                if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
                {
                  v120 = *(unsigned __int16 *)(v102 + 196);
                  *(_DWORD *)buf = 136446722;
                  v195 = "__nw_frame_array_claim";
                  v196 = 1024;
                  *(_DWORD *)v197 = v120;
                  *(_WORD *)&v197[4] = 1024;
                  *(_DWORD *)&v197[6] = v85;
                  _os_log_impl(&dword_209FB3000, v119, OS_LOG_TYPE_ERROR, "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded", buf, 0x18u);
                }
              }
              if (v105)
                free(v105);
              *(_WORD *)(v102 + 196) = 0;
            }
          }
        }
        else
        {
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v195 = "__nw_frame_is_single_ip_aggregate";
          v170 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            v179 = __nwlog_obj();
            if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v195 = "__nw_frame_is_single_ip_aggregate";
              _os_log_impl(&dword_209FB3000, v179, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v170)
            free(v170);
        }
        v121 = v58[4];
        if (v121)
        {
          v122 = 0;
          while (1)
          {
            v123 = *(_DWORD *)(v121 + 52);
            v124 = *(_DWORD *)(v121 + 56);
            v125 = *(_DWORD *)(v121 + 60);
            v126 = v123 - (v124 + v125);
            if (v126 >= v85 - v122)
              v126 = v85 - v122;
            v127 = v123 ? v126 : 0;
            v128 = v124 + v127;
            if (v124 + v127 <= v123 - v125)
            {
              *(_DWORD *)(v121 + 56) = v128;
            }
            else
            {
              v129 = __nwlog_obj();
              if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
              {
                v130 = *(_DWORD *)(v121 + 52);
                *(_DWORD *)buf = 136446978;
                v195 = "__nw_frame_claim_internal";
                v196 = 1024;
                *(_DWORD *)v197 = v128;
                *(_WORD *)&v197[4] = 1024;
                *(_DWORD *)&v197[6] = v130;
                *(_WORD *)v198 = 1024;
                *(_DWORD *)&v198[2] = v125;
                _os_log_impl(&dword_209FB3000, v129, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
              }
            }
            v122 += v127;
            if (v122 == (_DWORD)v85)
              break;
            if (v122 < v85)
            {
              v121 = *(_QWORD *)(v121 + 32);
              if (v121)
                continue;
            }
            goto LABEL_250;
          }
        }
        else
        {
          v122 = 0;
LABEL_250:
          v131 = __nwlog_obj();
          if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v195 = "__nw_frame_array_claim";
            v196 = 1024;
            *(_DWORD *)v197 = v122;
            *(_WORD *)&v197[4] = 1024;
            *(_DWORD *)&v197[6] = v85;
            _os_log_impl(&dword_209FB3000, v131, OS_LOG_TYPE_ERROR, "%{public}s start_offset %u != start_bytes %u", buf, 0x18u);
          }
        }
        break;
      }
      v89 = (_QWORD *)*v58;
      if (*v58)
        v89[1] = v58[1];
      *(_QWORD *)v58[1] = v89;
      v90 = a1;
      if (!v192 || (*(_BYTE *)(v192 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v97 = __nwlog_tcp_log();
          if (os_log_type_enabled(v97, OS_LOG_TYPE_DEBUG))
          {
            v98 = *(_DWORD *)(v58[3] + 4);
            v99 = *(_DWORD *)(v47 + 4);
            v100 = *((_DWORD *)v58 + 4);
            v101 = *v191;
            *(_DWORD *)buf = 136447490;
            v195 = "tcp_reass";
            v196 = 2082;
            *(_QWORD *)v197 = v81;
            *(_WORD *)&v197[8] = 1024;
            *(_DWORD *)v198 = v98;
            *(_WORD *)&v198[4] = 1024;
            *(_DWORD *)&v198[6] = v99;
            *(_WORD *)v199 = 1024;
            *(_DWORD *)&v199[2] = v100;
            v200 = 1024;
            v201 = v101;
            _os_log_impl(&dword_209FB3000, v97, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s dropping a completely overlapping segment: tqe_seq %u th_seq %u tqe_len %u tlen %u", buf, 0x2Eu);
          }
        }
      }
      v91 = (_QWORD *)v58[4];
      if (v91)
      {
        do
        {
          while (1)
          {
            v92 = (void (*)(_QWORD *, uint64_t, uint64_t))v91[10];
            v93 = (_QWORD *)v91[4];
            if (!v92)
              break;
            v94 = v91[11];
            v91[10] = 0;
            v91[11] = 0;
            v92(v91, 1, v94);
            v91 = v93;
            if (!v93)
              goto LABEL_154;
          }
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v195 = "__nw_frame_finalize";
          v95 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            v96 = __nwlog_obj();
            if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v195 = "__nw_frame_finalize";
              _os_log_impl(&dword_209FB3000, v96, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v95)
            free(v95);
          v90 = a1;
          v91 = v93;
        }
        while (v93);
      }
LABEL_154:
      free(v58);
      --*(_WORD *)(v90 + 224);
      v58 = v89;
    }
    while (v89);
  }
  *(_QWORD *)(v190 + 32) = 0;
  *(_QWORD *)(v190 + 40) = v189 + 4;
  v189[4] = v190;
  v189[5] = v190 + 32;
  v189[3] = v47;
  *((_DWORD *)v189 + 4) = *v191;
  if (v187)
  {
    v35 = a1;
    v132 = *(_QWORD **)a1;
    *v189 = *(_QWORD *)a1;
    if (v132)
      v132[1] = v189;
    *(_QWORD *)a1 = v189;
    v189[1] = a1;
  }
  else
  {
    v133 = *v64;
    *v189 = *v64;
    v35 = a1;
    if (v133)
      *(_QWORD *)(*v64 + 8) = v189;
    *v64 = v189;
    v189[1] = v64;
  }
LABEL_259:
  if (*(int *)(v35 + 12) < 4)
    return 0;
  v134 = *(_QWORD **)v35;
  if (!*(_QWORD *)v35)
    return 0;
  v135 = v134[3];
  v136 = *(_DWORD *)(v135 + 4);
  if (v136 != *(_DWORD *)(v35 + 120))
    return 0;
  v137 = *(_DWORD *)(v35 + 740);
  if ((v137 & 0x800000) != 0)
    return 0;
  *(_DWORD *)(v35 + 740) = v137 | 0x800000;
  v138 = *(_QWORD *)(v35 + 1056);
  if (v138)
    ++*(_QWORD *)(v138 + 1616);
  v139 = 0;
  if (v192)
    v140 = (const char *)(v192 + 604);
  else
    v140 = "";
  v141 = a1;
  do
  {
    *(_DWORD *)(v141 + 120) = v136 + *((_DWORD *)v134 + 4);
    v142 = *(_BYTE *)(v135 + 13);
    v143 = *v134;
    if (*v134)
      *(_QWORD *)(v143 + 8) = v134[1];
    *(_QWORD *)v134[1] = v143;
    if ((*(_WORD *)(v192 + 376) & 0x20) == 0)
    {
      v144 = *(_DWORD *)(a1 + 740);
      v145 = v144 & 0xFFFFFFEF | (16 * ((*(unsigned __int8 *)(v134[3] + 13) >> 3) & 1));
      *(_DWORD *)(a1 + 740) = v145;
      if ((v144 & 0x4000000) != 0)
      {
        *(_DWORD *)(a1 + 740) = v145 & 0xFBFFFFFF;
        nw_frame_array_first();
        nw_frame_set_is_wake_packet();
        if ((*(_BYTE *)(v192 + 828) & 2) == 0)
        {
          v146 = __nwlog_tcp_log();
          if (os_log_type_enabled(v146, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446466;
            v195 = "tcp_reass";
            v196 = 2082;
            *(_QWORD *)v197 = v140;
            _os_log_impl(&dword_209FB3000, v146, OS_LOG_TYPE_INFO, "%{public}s %{public}s reassembled segment is wake packet", buf, 0x16u);
          }
        }
      }
      v147 = v134[4];
      if (v147)
      {
        v148 = 0;
        do
        {
          v149 = *(_DWORD *)(v147 + 52);
          if (v149)
            v149 -= *(_DWORD *)(v147 + 56) + *(_DWORD *)(v147 + 60);
          v148 += v149;
          v147 = *(_QWORD *)(v147 + 32);
        }
        while (v147);
      }
      else
      {
        v148 = 0;
      }
      if (tcp_input_sbappendstream(v192, v134 + 4, v148, 0))
        v139 = 1;
    }
    v150 = (_QWORD *)v134[4];
    if (v150)
    {
      do
      {
        while (1)
        {
          v151 = (void (*)(_QWORD *, uint64_t, uint64_t))v150[10];
          v152 = (_QWORD *)v150[4];
          if (!v151)
            break;
          v153 = v150[11];
          v150[10] = 0;
          v150[11] = 0;
          v151(v150, 1, v153);
          v150 = v152;
          if (!v152)
            goto LABEL_294;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v195 = "__nw_frame_finalize";
        v154 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          v155 = __nwlog_obj();
          if (os_log_type_enabled(v155, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v195 = "__nw_frame_finalize";
            _os_log_impl(&dword_209FB3000, v155, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
          }
        }
        if (v154)
          free(v154);
        v150 = v152;
      }
      while (v152);
    }
LABEL_294:
    free(v134);
    v141 = a1;
    --*(_WORD *)(a1 + 224);
    v134 = *(_QWORD **)a1;
    if (!*(_QWORD *)a1)
      break;
    v135 = v134[3];
    v136 = *(_DWORD *)(v135 + 4);
  }
  while (v136 == *(_DWORD *)(a1 + 120));
  result = v142 & 1;
  *(_DWORD *)(a1 + 740) &= ~0x800000u;
  if (a6)
  {
    if (v139)
      *a6 = 1;
  }
  return result;
}

uint64_t tcp_bad_rexmt_restore_state(uint64_t a1, uint64_t a2)
{
  int v3;
  int v4;
  int v5;
  unsigned int v6;
  void (*v7)(uint64_t);
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  void (**v14)(void);
  void (*v15)(void);
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t all_stats;
  unsigned int v31;
  int v32;
  char v33;
  char v34;
  uint64_t result;

  v3 = *(_DWORD *)(a1 + 88);
  if ((~v3 & 0x180) != 0)
  {
    *(_QWORD *)(a1 + 144) = *(_QWORD *)(a1 + 504);
    if ((v3 & 0x400000) == 0)
    {
LABEL_25:
      *(_DWORD *)(a1 + 984) = 0;
      v9 = *(_DWORD *)(a1 + 144);
      goto LABEL_26;
    }
    *(_DWORD *)(a1 + 88) = v3 | 0x200000;
    v10 = *(_QWORD *)(a1 + 80);
    v11 = *(_DWORD *)(v10 + 2228);
    if ((v11 & 0x40000000) != 0)
    {
      v12 = *(_QWORD *)(v10 + 224);
      if ((v11 & 0x10000000) == 0)
      {
        v13 = *(_DWORD *)(v12 + 364);
        *(_DWORD *)(v10 + 2228) = v11 & 0xAFFFFFFF;
        if ((v13 & 0x20000) != 0)
          *(_DWORD *)(v12 + 364) = v13 & 0xFFFDFFFF;
        if ((v11 & 0x50000000) == 0)
          goto LABEL_18;
        goto LABEL_15;
      }
      *(_DWORD *)(v10 + 2228) = v11 & 0xAFFFFFFF;
      *(_DWORD *)(v12 + 364) &= ~0x20000u;
      if ((v11 & 0x50000000) != 0)
      {
LABEL_15:
        v14 = *(void (***)(void))(v12 + 32);
        if (v14)
        {
          v15 = *v14;
          if (v15)
            v15();
        }
      }
    }
LABEL_18:
    v16 = *(_QWORD **)(a1 + 952);
    if (v16)
    {
      v17 = (_QWORD *)(a1 + 952);
      do
      {
        v19 = (_QWORD *)*v17;
        v20 = (_QWORD *)(a1 + 952);
        if ((_QWORD *)*v17 != v16)
        {
          do
          {
            v21 = v19;
            v19 = (_QWORD *)v19[2];
          }
          while (v19 != v16);
          v20 = v21 + 2;
        }
        v18 = (_QWORD *)v16[2];
        *v20 = v18;
        nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
        free(v16);
        v16 = v18;
      }
      while (v18);
      *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
    }
    goto LABEL_25;
  }
  v4 = *(_DWORD *)(a2 + 8);
  v5 = *(_DWORD *)(a1 + 96) - v4;
  v6 = v4 - *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 148) = *(_DWORD *)(a1 + 508);
  v7 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 40);
  if (v7)
    v7(a1);
  v8 = *(_DWORD *)(a1 + 144);
  if (v6 < v8)
    v8 = v6;
  v9 = v5 + v8;
LABEL_26:
  v22 = sysctls;
  if (*(_DWORD *)(sysctls + 304))
  {
    v23 = *(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 16);
    if (v9 > v23)
      goto LABEL_34;
LABEL_31:
    v9 = v23;
    goto LABEL_34;
  }
  if (*(_DWORD *)(sysctls + 276))
  {
    v23 = 10 * *(_DWORD *)(a1 + 196);
    if (v9 > v23)
      goto LABEL_34;
    goto LABEL_31;
  }
  if (v9 <= 0x111C)
    v9 = 4380;
LABEL_34:
  *(_DWORD *)(a1 + 144) = v9;
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 512);
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 96);
  v24 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
  v25 = *(_DWORD *)(v24 + 432);
  if ((~v25 & 0xC00) == 0)
  {
    v26 = *(int *)(v22 + 232);
    if (v26 <= *(unsigned int *)(a1 + 148))
      LODWORD(v26) = *(_DWORD *)(a1 + 148);
    v27 = *(_DWORD *)(v22 + 120);
    if (v26 < v27)
      v27 = v26;
    *(_DWORD *)(v24 + 436) = v27;
    if (*(_DWORD *)(v24 + 388) <= v27)
    {
      if (v27 <= 0x71C71C)
      {
        *(_DWORD *)(v24 + 388) = v27;
        v28 = *(_QWORD *)(*(_QWORD *)(v24 + 456) + 24);
        if ((v25 & 4) != 0)
        {
          if (v28)
          {
            all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats)
              *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v24 + 388);
          }
        }
        else if (v28)
        {
          v29 = nw_protocol_tcp_get_all_stats();
          if (v29)
            *(_DWORD *)(v29 + 100) = *(_DWORD *)(v24 + 388);
        }
        v31 = *(_DWORD *)(v24 + 388);
        if (*(_DWORD *)(v24 + 392) > v31)
          *(_DWORD *)(v24 + 392) = v31;
      }
      *(_DWORD *)(v24 + 432) &= ~0x800u;
    }
  }
  v32 = *(_DWORD *)(a1 + 740);
  if ((v32 & 0x20400020) == 0x20000020)
  {
    v33 = *(_BYTE *)(a1 + 2069);
    if ((v33 & 0x1Fu) >= 0xF)
      v34 = 16;
    else
      v34 = (v33 + 1) & 0x1F;
    *(_BYTE *)(a1 + 2069) = v33 & 0xC0 | v34 | 0x20;
  }
  *(_DWORD *)(a1 + 740) = v32 | 0x40;
  result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  *(_DWORD *)(a1 + 532) = *(_DWORD *)(result + 316);
  *(_DWORD *)(a1 + 172) = 0;
  return result;
}

uint64_t tcp_usr_abort(uint64_t *a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  void *v8;

  v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3)
    return 22;
  v4 = *(_QWORD *)(v1 + 240);
  v5 = nw_tcp_access_globals(*(_QWORD *)(v1 + 224));
  calculate_tcp_clock(v5);
  if (!v4)
    return 0;
  tcp_drop(v4, 53);
  v6 = *((_DWORD *)a1 + 90);
  if (v6 > 0)
  {
LABEL_6:
    result = 0;
    *((_DWORD *)a1 + 90) = v6 - 1;
    return result;
  }
  v7 = __nwlog_obj();
  os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  v8 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v8);
    v6 = *((_DWORD *)a1 + 90);
    goto LABEL_6;
  }
  __break(1u);
  return result;
}

uint64_t tcp_usr_listen(uint64_t *a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  double v6;
  uint64_t v7;
  _QWORD v8[3];

  v8[2] = *MEMORY[0x24BDAC8D0];
  v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3)
    return 22;
  v4 = *(_QWORD *)(v1 + 240);
  v5 = nw_tcp_access_globals(*(_QWORD *)(v1 + 224));
  v6 = calculate_tcp_clock(v5);
  if (*(_WORD *)(v1 + 2226))
    goto LABEL_6;
  if (*(_DWORD *)(v1 + 492))
    return 22;
  v8[0] = 0;
  v8[1] = 0;
  result = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD *, uint64_t, double))(*(_QWORD *)(v1 + 2136) + 8))(*(_QWORD *)(v1 + 224), 0, 16, v8, 16, v6);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v8[0]))
      *(_DWORD *)(v1 + 492) = HIDWORD(v8[0]);
    *(_WORD *)(v1 + 2226) = WORD1(v8[0]);
LABEL_6:
    *(_DWORD *)(v4 + 12) = 1;
    result = a1[3];
    if (result)
    {
      result = nw_protocol_tcp_get_all_stats();
      if (result)
      {
        v7 = result;
        result = 0;
        *(_DWORD *)(v7 + 136) = 1;
      }
    }
  }
  return result;
}

uint64_t tcp_usr_rcvoob()
{
  void *v0;
  NSObject *v1;
  uint8_t buf[4];
  const char *v4;
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v4 = "tcp_usr_rcvoob";
  v0 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v1 = __nwlog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v4 = "tcp_usr_rcvoob";
      _os_log_impl(&dword_209FB3000, v1, OS_LOG_TYPE_ERROR, "%{public}s currently not supported, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v0)
    free(v0);
  return 0;
}

uint64_t tcp_usr_shutdown(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;
  void (*v5)(uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v1 = *(_QWORD *)a1;
  if (!*(_QWORD *)a1 || *(_DWORD *)(v1 + 232) == 3)
    return 22;
  *(_WORD *)(a1 + 376) |= 0x10u;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    v5 = *(void (**)(uint64_t))(v4 + 16);
    if (v5)
      v5(a1);
  }
  v6 = *(_QWORD *)(v1 + 240);
  if (!v6)
    return 0;
  v7 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v7);
  result = tcp_usrclosed(v6, v8);
  if (result)
    return tcp_output(result);
  return result;
}

uint64_t tcp_usr_preconnect(_DWORD *a1)
{
  uint64_t result;

  result = tcp_output(*(_QWORD *)(*(_QWORD *)a1 + 240));
  if ((a1[92] & 0x30) != 0)
    a1[92] &= a1[92] & 0x10 ^ 0xFFFFFFDF;
  return result;
}

uint64_t tcp6_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int *v8;
  int v9;
  unsigned int v10;
  int v12;
  uint64_t v13;
  uint64_t all_stats;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  const char *v22;
  _QWORD v24[3];
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 80);
  v5 = *(_QWORD *)(v4 + 224);
  if (!*(_WORD *)(v4 + 2226))
  {
    if (*(_DWORD *)(v4 + 480) || *(_DWORD *)(v4 + 484) || *(_DWORD *)(v4 + 488) || *(_DWORD *)(v4 + 492))
    {
      v20 = 22;
      goto LABEL_49;
    }
    v25 = 0;
    memset(v24, 0, sizeof(v24));
    v20 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD *, uint64_t))(*(_QWORD *)(v4 + 2136) + 8))(v5, 0, 28, v24, 28);
    if ((_DWORD)v20)
      goto LABEL_49;
    if ((vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(*(int32x4_t *)&v24[1], *(int32x4_t *)&v24[1]))) & 1) != 0)
      *(_OWORD *)(v4 + 480) = *(_OWORD *)&v24[1];
    *(_WORD *)(v4 + 2226) = WORD1(v24[0]);
  }
  if (*(_BYTE *)a2 != 28)
  {
    v20 = 22;
    if (v5)
      goto LABEL_44;
    goto LABEL_45;
  }
  if (*(_BYTE *)(a2 + 1) != 30)
  {
    v20 = 47;
    if (v5)
      goto LABEL_44;
LABEL_45:
    v21 = __nwlog_tcp_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v22 = "";
      if (v5)
        v22 = (const char *)(v5 + 604);
      LODWORD(v24[0]) = 136446466;
      *(_QWORD *)((char *)v24 + 4) = "tcp6_connect";
      WORD2(v24[1]) = 2082;
      *(_QWORD *)((char *)&v24[1] + 6) = v22;
      _os_log_impl(&dword_209FB3000, v21, OS_LOG_TYPE_ERROR, "%{public}s %{public}s ipv6 pcb local address lookup failed", (uint8_t *)v24, 0x16u);
    }
    goto LABEL_49;
  }
  if (!*(_WORD *)(a2 + 2))
  {
    v20 = 49;
    if (!v5)
      goto LABEL_45;
LABEL_44:
    if ((*(_BYTE *)(v5 + 828) & 2) == 0)
      goto LABEL_45;
LABEL_49:
    tcp_drop(a1, v20);
    return v20;
  }
  *(_OWORD *)(v4 + 464) = *(_OWORD *)(a2 + 8);
  *(_WORD *)(v4 + 2224) = *(_WORD *)(a2 + 2);
  if (!*(_DWORD *)(v4 + 460))
  {
    v6 = inp_calc_flowhash_flow_hash++;
    *(_DWORD *)(v4 + 460) = v6;
  }
  v7 = *(int *)(sysctls + 184);
  if (v7 <= *(unsigned __int8 *)(a1 + 262))
    LOBYTE(v7) = *(_BYTE *)(a1 + 262);
  v8 = (int *)(sysctls + 72);
  if ((*(_BYTE *)(v5 + 537) & 2) != 0)
    v8 = (int *)(v5 + 492);
  v9 = *v8;
  v10 = v7;
  if (v7 <= 0xDu && 0x10000 << v7 < v9)
  {
    do
    {
      LOBYTE(v7) = v10 + 1;
      if (v10 > 0xC)
        break;
      v12 = 0x20000 << v10++;
    }
    while (v12 < v9);
  }
  if (v7 >= 0xEu)
    LOBYTE(v7) = 14;
  *(_BYTE *)(a1 + 262) = v7;
  *(_WORD *)(v5 + 376) = *(_WORD *)(v5 + 376) & 0xFFF1 | 4;
  v13 = *(_QWORD *)(a1 + 1056);
  if (v13)
    ++*(_QWORD *)(v13 + 376);
  *(_DWORD *)(a1 + 12) = 2;
  if (*(_QWORD *)(v5 + 24))
  {
    all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats)
      *(_DWORD *)(all_stats + 136) = 2;
  }
  v15 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316);
  v16 = *(_DWORD *)(a1 + 680);
  if (!v16)
    v16 = *(_DWORD *)(sysctls + 188);
  *(_DWORD *)(a1 + 40) = v16 + v15 - *(_DWORD *)(a1 + 64);
  v17 = tcp_new_isn(a1);
  *(_DWORD *)(a1 + 112) = v17;
  *(_DWORD *)(a1 + 152) = v17;
  *(_DWORD *)(a1 + 96) = v17;
  *(_DWORD *)(a1 + 100) = v17;
  *(_DWORD *)(a1 + 92) = v17;
  if (!*(_QWORD *)(v5 + 24))
    return 0;
  v18 = nw_protocol_tcp_get_all_stats();
  if (v18)
    *(_DWORD *)(v18 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
  if (!*(_QWORD *)(v5 + 24))
    return 0;
  v19 = nw_protocol_tcp_get_all_stats();
  v20 = 0;
  if (v19)
    ++*(_DWORD *)(v19 + 60);
  return v20;
}

uint64_t tcp6_usr_bind(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  __n128 v5;
  char v6;
  uint64_t result;
  int v8;
  uint64_t v9;
  int32x4_t v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = *a1;
  if (!*a1 || *(_DWORD *)(v2 + 232) == 3)
    return 22;
  v4 = nw_tcp_access_globals(*(_QWORD *)(v2 + 224));
  v5.n128_f64[0] = calculate_tcp_clock(v4);
  if (*(_BYTE *)(a2 + 1) && (*(_BYTE *)(a2 + 1) != 30 || *(unsigned __int8 *)(a2 + 8) == 255))
    return 47;
  v6 = *(_BYTE *)(v2 + 2236);
  *(_BYTE *)(v2 + 2236) = v6 & 0xFC | 2;
  if ((*(_BYTE *)(v2 + 2229) & 0x80) == 0 && !*(_DWORD *)(a2 + 8) && !*(_DWORD *)(a2 + 12))
  {
    v8 = *(_DWORD *)(a2 + 16);
    if (v8 == -65536)
    {
      v10.i64[0] = 0;
      LOWORD(v9) = 528;
      WORD1(v9) = *(_WORD *)(a2 + 2);
      HIDWORD(v9) = *(_DWORD *)(a2 + 20);
      *(_BYTE *)(v2 + 2236) = v6 & 0xFC | 1;
      return in_pcbbind(v2, &v9);
    }
    if (!v8 && !*(_DWORD *)(a2 + 20))
      *(_BYTE *)(v2 + 2236) = v6 | 3;
  }
  if (*(_WORD *)(v2 + 2226))
    return 22;
  if (*(_DWORD *)(v2 + 480))
    return 22;
  if (*(_DWORD *)(v2 + 484))
    return 22;
  if (*(_DWORD *)(v2 + 488))
    return 22;
  if (*(_DWORD *)(v2 + 492))
    return 22;
  v9 = 0;
  v10 = 0uLL;
  v11 = 0;
  if (*(_BYTE *)a2 != 28)
    return 22;
  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t *, uint64_t, __n128))(*(_QWORD *)(v2 + 2136) + 8))(*(_QWORD *)(v2 + 224), a2, 28, &v9, 28, v5);
  if (!(_DWORD)result)
  {
    if ((vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(v10, v10))) & 1) != 0)
      *(int32x4_t *)(v2 + 480) = v10;
    result = 0;
    *(_WORD *)(v2 + 2226) = WORD1(v9);
  }
  return result;
}

uint64_t tcp6_usr_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v12;
  int v13;
  uint8_t buf[4];
  _BYTE v15[18];
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)a1;
  if (!*(_QWORD *)a1)
    return 22;
  if (*(_DWORD *)(v2 + 232) == 3)
  {
    v4 = *(unsigned __int16 *)(a1 + 378);
    if (*(_WORD *)(a1 + 378))
    {
      *(_WORD *)(a1 + 378) = 0;
      __nwlog_obj();
      v5 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)v15 = "tcp6_usr_connect";
      *(_WORD *)&v15[8] = 2082;
      *(_QWORD *)&v15[10] = a1 + 604;
      v16 = 1024;
      v17 = v4;
      v6 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v12 = __nwlog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)v15 = "tcp6_usr_connect";
          *(_WORD *)&v15[8] = 2082;
          *(_QWORD *)&v15[10] = v5;
          v16 = 1024;
          v17 = v4;
          _os_log_impl(&dword_209FB3000, v12, OS_LOG_TYPE_ERROR, "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d, backtrace limit exceeded", buf, 0x1Cu);
        }
      }
      if (v6)
        free(v6);
      return v4;
    }
    return 22;
  }
  v8 = *(_QWORD *)(v2 + 240);
  if ((*(_BYTE *)(a1 + 368) & 0x10) != 0 && (*(_BYTE *)(sysctls + 160) & 2) != 0)
    *(_DWORD *)(v8 + 740) |= 0x400000u;
  v9 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v9);
  if (*(_BYTE *)(a2 + 1) && (*(_BYTE *)(a2 + 1) != 30 || *(unsigned __int8 *)(a2 + 8) == 255))
    return 47;
  if (!*(_DWORD *)(a2 + 8) && !*(_DWORD *)(a2 + 12) && *(_DWORD *)(a2 + 16) == -65536)
  {
    if ((*(_BYTE *)(v2 + 2229) & 0x80) == 0)
    {
      *(_QWORD *)&v15[4] = 0;
      *(_WORD *)buf = 528;
      *(_WORD *)&buf[2] = *(_WORD *)(a2 + 2);
      *(_DWORD *)v15 = *(_DWORD *)(a2 + 20);
      *(_BYTE *)(v2 + 2236) = *(_BYTE *)(v2 + 2236) & 0xFC | 1;
      v4 = tcp_connect(v8, (uint64_t)buf);
      if (!(_DWORD)v4)
        return tcp_connect_complete(a1);
      return v4;
    }
    return 22;
  }
  *(_BYTE *)(v2 + 2236) = *(_BYTE *)(v2 + 2236) & 0xFC | 2;
  v4 = tcp6_connect(v8, a2);
  if (!(_DWORD)v4)
  {
    v10 = *(_QWORD *)(*(_QWORD *)a1 + 240);
    (*(void (**)(_QWORD))(*(_QWORD *)(*(_QWORD *)(v10 + 80) + 2136) + 64))(*(_QWORD *)(a1 + 24));
    if ((*(_BYTE *)(a1 + 368) & 0x20) == 0)
      return tcp_output(v10);
    tcp_mss(v10, -1, 0);
    v4 = 0;
    v13 = *(_DWORD *)(v10 + 196);
    *(_DWORD *)(v10 + 140) = v13;
    *(_DWORD *)(v10 + 252) = v13;
  }
  return v4;
}

uint64_t tcp6_usr_listen(uint64_t *a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  int32x4_t v10;
  int v11;

  v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3)
    return 22;
  v4 = *(_QWORD *)(v1 + 240);
  v5 = nw_tcp_access_globals(*(_QWORD *)(v1 + 224));
  v6.n128_f64[0] = calculate_tcp_clock(v5);
  if (*(_WORD *)(v1 + 2226))
    goto LABEL_6;
  v8 = *(_BYTE *)(v1 + 2236);
  *(_BYTE *)(v1 + 2236) = v8 & 0xFE;
  if ((*(_BYTE *)(v1 + 2229) & 0x80) == 0)
    *(_BYTE *)(v1 + 2236) = v8 | 1;
  if (*(_DWORD *)(v1 + 480) || *(_DWORD *)(v1 + 484) || *(_DWORD *)(v1 + 488) || *(_DWORD *)(v1 + 492))
    return 22;
  v11 = 0;
  v10 = 0uLL;
  v9 = 0;
  result = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t *, uint64_t, __n128))(*(_QWORD *)(v1 + 2136) + 8))(*(_QWORD *)(v1 + 224), 0, 28, &v9, 28, v6);
  if (!(_DWORD)result)
  {
    if ((vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(v10, v10))) & 1) != 0)
      *(int32x4_t *)(v1 + 480) = v10;
    *(_WORD *)(v1 + 2226) = WORD1(v9);
LABEL_6:
    *(_DWORD *)(v4 + 12) = 1;
    result = a1[3];
    if (result)
    {
      result = nw_protocol_tcp_get_all_stats();
      if (result)
      {
        v7 = result;
        result = 0;
        *(_DWORD *)(v7 + 136) = 1;
      }
    }
  }
  return result;
}

uint64_t tcp_connect_complete(uint64_t a1)
{
  uint64_t v2;
  int v4;

  v2 = *(_QWORD *)(*(_QWORD *)a1 + 240);
  (*(void (**)(_QWORD))(*(_QWORD *)(*(_QWORD *)(v2 + 80) + 2136) + 64))(*(_QWORD *)(a1 + 24));
  if ((*(_BYTE *)(a1 + 368) & 0x20) == 0)
    return tcp_output(v2);
  tcp_mss(v2, -1, 0);
  v4 = *(_DWORD *)(v2 + 196);
  *(_DWORD *)(v2 + 140) = v4;
  *(_DWORD *)(v2 + 252) = v4;
  return 0;
}

void inp_flush()
{
  void *v0;
  NSObject *v1;
  uint8_t buf[4];
  const char *v3;
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v3 = "inp_flush";
  v0 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    v1 = __nwlog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v3 = "inp_flush";
      _os_log_impl(&dword_209FB3000, v1, OS_LOG_TYPE_ERROR, "%{public}s currently unsupported, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v0)
    free(v0);
}

uint64_t tcp_flight_size(_DWORD *a1)
{
  int v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  void *v13;
  NSObject *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t result;
  NSObject *v22;
  void *v23;
  NSObject *v24;
  void *v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  if ((a1[157] & 0x80000000) != 0)
  {
    v22 = __nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v27 = "tcp_flight_size";
    v23 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort();
    if ((_DWORD)result)
      goto LABEL_20;
    free(v23);
    if ((a1[156] & 0x80000000) == 0)
      goto LABEL_3;
LABEL_18:
    v24 = __nwlog_obj();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v27 = "tcp_flight_size";
    v25 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort();
    if (!(_DWORD)result)
    {
      free(v25);
      goto LABEL_3;
    }
LABEL_20:
    __break(1u);
    return result;
  }
  if ((a1[156] & 0x80000000) != 0)
    goto LABEL_18;
LABEL_3:
  v2 = a1[25];
  v3 = a1[23];
  if ((a1[185] & 0x20400020) != 0x20000020)
    return (v2 - (v3 + a1[157])) & ~((v2 - (v3 + a1[157])) >> 31);
  if (a1[24] - v2 > 0)
    v2 = a1[24];
  v4 = a1[519];
  v5 = v2 - (a1[520] + v3 + a1[518]);
  v6 = (v5 + v4);
  if (v5 + v4 < 0)
  {
    __nwlog_obj();
    v8 = a1[24];
    v7 = a1[25];
    v9 = a1[23];
    v10 = a1[520];
    v11 = a1[518];
    v12 = a1[519];
    *(_DWORD *)buf = 136448002;
    v27 = "tcp_flight_size";
    v28 = 1024;
    v29 = v6;
    v30 = 1024;
    v31 = v7;
    v32 = 1024;
    v33 = v8;
    v34 = 1024;
    v35 = v9;
    v36 = 1024;
    v37 = v10;
    v38 = 1024;
    v39 = v11;
    v40 = 1024;
    v41 = v12;
    v13 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v14 = __nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v16 = a1[24];
        v15 = a1[25];
        v17 = a1[23];
        v18 = a1[520];
        v19 = a1[518];
        v20 = a1[519];
        *(_DWORD *)buf = 136448002;
        v27 = "tcp_flight_size";
        v28 = 1024;
        v29 = v6;
        v30 = 1024;
        v31 = v15;
        v32 = 1024;
        v33 = v16;
        v34 = 1024;
        v35 = v17;
        v36 = 1024;
        v37 = v18;
        v38 = 1024;
        v39 = v19;
        v40 = 1024;
        v41 = v20;
        _os_log_impl(&dword_209FB3000, v14, OS_LOG_TYPE_ERROR, "%{public}s flight_size (%d) can't be negative (snd_nxt:%u snd_max:%u, snd_una:%u, sacked:%u lost:%u retransmitted:%u), backtrace limit exceeded", buf, 0x36u);
      }
    }
    if (v13)
      free(v13);
    return 0;
  }
  return v6;
}

uint64_t tcp_setpersist(uint64_t a1)
{
  int v2;
  unsigned int v3;
  int v4;
  uint64_t result;
  unsigned int v6;

  v2 = (*(_DWORD *)(a1 + 208) + (*(int *)(a1 + 200) >> 2)) >> 1;
  if (*(_DWORD *)(a1 + 312) && !*(_DWORD *)(a1 + 36) && !*(_DWORD *)(a1 + 316))
    *(_DWORD *)(a1 + 316) = *(_DWORD *)(a1 + 312)
                          + *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316);
  v3 = tcp_backoff[*(unsigned __int16 *)(a1 + 226)] * v2;
  *(_DWORD *)(a1 + 36) = v3;
  if (v3 >> 3 >= 0x271)
  {
    if (v3 < 0xEA61)
      goto LABEL_10;
    v4 = 60000;
  }
  else
  {
    v4 = 5000;
  }
  *(_DWORD *)(a1 + 36) = v4;
LABEL_10:
  result = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 36) + *(_DWORD *)(result + 316) - *(_DWORD *)(a1 + 64);
  v6 = *(unsigned __int16 *)(a1 + 226);
  if (v6 <= 0xB)
    *(_WORD *)(a1 + 226) = v6 + 1;
  return result;
}

uint64_t __tcp_ip_output_send_block_invoke(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t v6;
  _QWORD *v7;
  unsigned __int16 *v8;
  uint64_t v9;
  void *v11;
  NSObject *v12;
  const char *v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  _DWORD *v20;
  int v21;
  const char *v22;
  NSObject *v23;
  int v24;
  unsigned int v25;
  int v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  unsigned int v32;
  __int16 v33;
  unsigned int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  unsigned int v40;
  __int16 v41;
  unsigned int v42;
  __int16 v43;
  unsigned int v44;
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  __int16 v51;
  const char *v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v4 = *(_DWORD *)(a2 + 52);
    if (v4)
    {
      v5 = v4 - (*(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60));
      if (!*(_QWORD *)(a1 + 32))
        return 1;
    }
    else
    {
      v5 = 0;
      if (!*(_QWORD *)(a1 + 32))
        return 1;
    }
    v6 = *(_QWORD *)(a2 + 112);
    v7 = (_QWORD *)MEMORY[0x24BDE08C0];
    if (v6
      && ((*(_WORD *)(a2 + 204) & 0x100) == 0
       || !*MEMORY[0x24BDE08C0]
       || ((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(a2, *(_QWORD *)(a2 + 88))
       && (v6 = *(_QWORD *)(a2 + 112)) != 0))
    {
      v8 = (unsigned __int16 *)(v6 + *(unsigned int *)(a2 + 56));
      v9 = *(_QWORD *)(a1 + 40);
      if (!v9 || (*(_BYTE *)(v9 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v12 = __nwlog_tcp_log();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            if (v9)
              v13 = (const char *)(v9 + 604);
            else
              v13 = "";
            v14 = bswap32(*v8) >> 16;
            v15 = bswap32(v8[1]) >> 16;
            v16 = *((unsigned __int8 *)v8 + 13);
            v17 = bswap32(*((_DWORD *)v8 + 1));
            v18 = bswap32(*((_DWORD *)v8 + 2));
            v19 = bswap32(v8[7]) >> 16;
            v20 = *(_DWORD **)(a1 + 32);
            v21 = v20[3];
            v24 = v20[30];
            v25 = v18;
            v26 = v20[23];
            v22 = packet_service_class_to_str(*(_DWORD *)(a2 + 176));
            *(_DWORD *)buf = 136449282;
            v28 = "tcp_ip_output_send_block_invoke";
            v29 = 2082;
            v30 = v13;
            v31 = 1024;
            v32 = v14;
            v33 = 1024;
            v34 = v15;
            v35 = 1024;
            v36 = v5;
            v37 = 1024;
            v38 = v16;
            v39 = 1024;
            v40 = v17;
            v41 = 1024;
            v42 = v25;
            v43 = 1024;
            v44 = v19;
            v45 = 1024;
            v46 = v21;
            v47 = 1024;
            v48 = v24;
            v49 = 1024;
            v50 = v26;
            v51 = 2082;
            v52 = v22;
            _os_log_impl(&dword_209FB3000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s sending frame, %u:%u tlen %u flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u svc %{public}s", buf, 0x5Cu);
          }
        }
      }
    }
    else if ((*(_WORD *)(a2 + 204) & 0x100) != 0
           && *v7
           && (((uint64_t (*)(uint64_t, _QWORD))*v7)(a2, *(_QWORD *)(a2 + 88)) & 1) == 0)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1056) = 0;
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "__nw_frame_unclaimed_length";
    v11 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      v23 = __nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "__nw_frame_unclaimed_length";
        _os_log_impl(&dword_209FB3000, v23, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v11)
      free(v11);
  }
  return 1;
}

uint64_t __tcp_ip_output_send_block_invoke_7(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (a2 && *(_QWORD *)(a1 + 40))
  {
    v4 = (_QWORD *)MEMORY[0x24BDE08C0];
    if (*(_QWORD *)(a2 + 112)
      && ((*(_WORD *)(a2 + 204) & 0x100) == 0
       || !*MEMORY[0x24BDE08C0]
       || ((unsigned int (*)(uint64_t, _QWORD))*MEMORY[0x24BDE08C0])(a2, *(_QWORD *)(a2 + 88))
       && *(_QWORD *)(a2 + 112)))
    {
      if (*MEMORY[0x24BDE08B8] != -1)
        dispatch_once(MEMORY[0x24BDE08B8], &__block_literal_global_486);
      if (*MEMORY[0x24BDE08B0] && kdebug_is_enabled())
        kdebug_trace();
    }
    else if ((*(_WORD *)(a2 + 204) & 0x100) != 0
           && *v4
           && (((uint64_t (*)(uint64_t, _QWORD))*v4)(a2, *(_QWORD *)(a2 + 88)) & 1) == 0)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1056) = 0;
    }
  }
  return 1;
}

uint64_t ____nw_signpost_is_enabled_block_invoke_490()
{
  uint64_t result;

  result = networkd_settings_get_BOOL();
  *MEMORY[0x24BDE08B0] = result;
  return result;
}

void tcp_sack_doack(uint64_t a1, uint64_t a2, int a3, _DWORD *a4, _DWORD *a5)
{
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int8x8_t *v13;
  int8x8_t v14;
  int v15;
  int v17;
  int v18;
  BOOL v19;
  uint64_t v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  _DWORD *v25;
  uint64_t v26;
  int v27;
  int v28;
  int *v29;
  unint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  BOOL v37;
  unint64_t v38;
  int v39;
  _QWORD *v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  int *v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  int v63;
  int v64;
  _DWORD *v65;
  int v66;
  int v67;
  NSObject *v68;
  void *v69;
  int v70;
  const char *v71;
  _DWORD v72[3];
  _BYTE v73[36];

  *(_QWORD *)&v73[28] = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)a2 & 1) != 0)
    v9 = *(_DWORD *)(a2 + 8);
  else
    v9 = 0;
  v10 = *(_DWORD *)(a1 + 740);
  if ((v10 & 0x20400020) == 0x20000020 || *(_DWORD *)(a1 + 92) - a3 >= 0 || !*(_QWORD *)(a1 + 544))
  {
    v11 = 0;
    v12 = *(unsigned __int8 *)(a2 + 15);
    if (!*(_BYTE *)(a2 + 15))
      goto LABEL_22;
  }
  else
  {
    v72[0] = *(_DWORD *)(a1 + 92);
    v72[1] = a3;
    v11 = 1;
    v12 = *(unsigned __int8 *)(a2 + 15);
    if (!*(_BYTE *)(a2 + 15))
      goto LABEL_22;
  }
  v13 = *(int8x8_t **)(a2 + 16);
  do
  {
    v14 = vrev32_s8(*v13);
    if (v14.i32[1] - v14.i32[0] >= 1)
    {
      v15 = *(_DWORD *)(a1 + 92);
      if (v14.i32[0] - v15 >= 1 && v14.i32[0] - a3 >= 1)
      {
        v17 = *(_DWORD *)(a1 + 96);
        v18 = v14.i32[1] - v15;
        v19 = v14.i32[1] - v17 > 0 || v18 < 1;
        if (!v19 && v14.i32[0] - v17 < 0)
          *(int8x8_t *)&v72[2 * v11++] = v14;
      }
    }
    ++v13;
    --v12;
  }
  while (v12);
LABEL_22:
  if (!v11)
    return;
  if (v11 >= 6)
  {
    v68 = __nwlog_obj();
    os_log_type_enabled(v68, OS_LOG_TYPE_ERROR);
    v70 = 136446210;
    v71 = "tcp_sack_doack";
    v69 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v69);
  }
  else if (v11 < 1)
  {
    goto LABEL_33;
  }
  v20 = 0;
  v21 = v73;
  v22 = 1;
  do
  {
    v23 = v20 + 1;
    if (v20 + 1 < (unint64_t)v11)
    {
      v24 = &v72[2 * v20];
      v25 = v21;
      v26 = v11;
      do
      {
        v27 = v24[1];
        if (v27 - *v25 >= 1)
        {
          v28 = *v24;
          *(_QWORD *)v24 = *(_QWORD *)(v25 - 1);
          *(v25 - 1) = v28;
          *v25 = v27;
        }
        --v26;
        v25 += 2;
      }
      while (v22 != v26);
    }
    ++v22;
    v21 += 8;
    v20 = v23;
  }
  while (v23 != v11);
  v10 = *(_DWORD *)(a1 + 740);
LABEL_33:
  if ((v10 & 0x20400020) == 0x20000020)
  {
    v29 = &v72[2 * v11 - 2];
    *a5 = v29[1];
    if (v11 >= 1)
    {
      do
      {
        v30 = *(_QWORD *)(a1 + 2000);
        if (!v30)
          goto LABEL_37;
        v32 = *v29;
        v31 = v29[1];
        v33 = *(_QWORD *)(a1 + 2000);
        do
        {
          while (1)
          {
            v34 = *(_DWORD *)(v33 + 4);
            if (v31 - v34 >= 0)
              break;
            v33 = *(_QWORD *)(v33 + 32);
            if (!v33)
              goto LABEL_44;
          }
          if (v31 == v34)
          {
            tcp_segs_dosack_matched(a1, (int *)v33, *v29, v9, a4);
            goto LABEL_37;
          }
          v33 = *(_QWORD *)(v33 + 40);
        }
        while (v33);
        do
        {
LABEL_44:
          v35 = v30;
          v30 = *(_QWORD *)(v30 + 32);
        }
        while (v30);
        do
        {
          while (1)
          {
LABEL_53:
            v38 = v35;
            if (v31 - *(_DWORD *)(v35 + 4) < 0 && v31 - *(_DWORD *)v35 >= 1)
            {
              if (v32 - *(_DWORD *)v35 >= 1)
                v39 = *v29;
              else
                v39 = *(_DWORD *)v35;
              v40 = tcp_seg_sent_insert_before(a1, v35, v39, v29[1], *(_DWORD *)(v35 + 8), *(_BYTE *)(v35 + 12));
              v41 = *((unsigned __int8 *)v40 + 12);
              tcp_seg_mark_sacked((_DWORD *)a1, (uint64_t)v40, a4);
              tcp_rack_update_segment_acked(a1, v9, *((_DWORD *)v40 + 2), *((_DWORD *)v40 + 1), (v41 >> 3) & 1);
              v42 = *(_DWORD *)v38;
              if (v32 != *(_DWORD *)v38)
              {
                if (v32 - *(_DWORD *)v38 >= 1)
                {
                  tcp_seg_sent_insert_before(a1, (uint64_t)v40, v42, v32, *(_DWORD *)(v38 + 8), *(_BYTE *)(v38 + 12));
                  *(_DWORD *)v38 = v31;
                  goto LABEL_37;
                }
                v43 = *(_QWORD *)(a1 + 2000);
                if (v43)
                {
                  while (1)
                  {
                    while (1)
                    {
                      v44 = *(_DWORD *)(v43 + 4);
                      if (v42 - v44 >= 0)
                        break;
                      v43 = *(_QWORD *)(v43 + 32);
                      if (!v43)
                        goto LABEL_59;
                    }
                    if (v42 == v44)
                      break;
                    v43 = *(_QWORD *)(v43 + 40);
                    if (!v43)
                      goto LABEL_59;
                  }
                  tcp_segs_dosack_matched(a1, (int *)v43, v32, v9, a4);
                }
              }
LABEL_59:
              *(_DWORD *)v38 = v31;
              goto LABEL_37;
            }
            v36 = *(_QWORD *)(v35 + 40);
            if (!v36)
              break;
            do
            {
              v35 = v36;
              v36 = *(_QWORD *)(v36 + 32);
            }
            while (v36);
          }
          v35 = *(_QWORD *)(v35 + 48) & 0xFFFFFFFFFFFFFFFELL;
        }
        while (v35 && *(_QWORD *)(v35 + 32) == v38);
        while (1)
        {
          v35 = *(_QWORD *)(v38 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v35)
            break;
          v37 = v38 == *(_QWORD *)(v35 + 40);
          v38 = *(_QWORD *)(v38 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v37)
            goto LABEL_53;
        }
LABEL_37:
        v29 -= 2;
      }
      while (v29 >= v72);
    }
    return;
  }
  if (*(_QWORD *)(a1 + 544))
  {
    v45 = *(_DWORD *)(a1 + 560);
  }
  else
  {
    if (*(_DWORD *)(a1 + 92) - a3 <= 0)
      v45 = a3;
    else
      v45 = *(_DWORD *)(a1 + 92);
    *(_DWORD *)(a1 + 560) = v45;
  }
  v46 = v11 - 1;
  v47 = &v72[2 * v46];
  if (v45 - *v47 < 0)
  {
    if (tcp_sackhole_insert(a1, v45, *v47, 0))
    {
      v49 = v72[2 * v46 + 1];
      *(_DWORD *)(a1 + 560) = v49;
      v50 = *v47;
      v47 -= 2;
      *a4 += v49 - v50;
    }
    else if (v11 >= 1)
    {
      v66 = *(_DWORD *)(a1 + 560);
      while (v66 - *v47 < 0)
      {
        v47 -= 2;
        if (v47 < v72)
          goto LABEL_81;
      }
      v67 = v47[1];
      if (v66 - v67 < 0)
      {
        *a4 += v67 - v66;
        *(_DWORD *)(a1 + 560) = v67;
      }
    }
  }
  else
  {
    v48 = v47[1];
    if (v45 - v48 < 0)
    {
      *a4 += v48 - v45;
      *(_DWORD *)(a1 + 560) = v48;
    }
  }
LABEL_81:
  if (v47 >= v72)
  {
    v51 = **(_QWORD **)(*(_QWORD *)(a1 + 552) + 8);
    if (v51)
    {
      while (1)
      {
        v53 = *v47;
        v54 = *(_DWORD *)(v51 + 4);
        if (*v47 - v54 >= 0)
          goto LABEL_106;
        v55 = v47[1];
        v56 = *(_DWORD *)v51;
        v57 = v55 - *(_DWORD *)v51;
        if (v57 <= 0)
        {
          v52 = **(_QWORD **)(*(_QWORD *)(v51 + 24) + 8);
LABEL_85:
          v51 = v52;
          if (!v52)
            return;
        }
        else
        {
          v58 = v56 - *(_DWORD *)(v51 + 8) + *(_DWORD *)(a1 + 624);
          *(_DWORD *)(a1 + 624) = v58 & ~(v58 >> 31);
          v59 = v55 - v54;
          if (v53 - v56 > 0)
          {
            if (v59 < 0)
            {
              tcp_sack_detect_reordering(a1, (_DWORD *)v51, v55, v45);
              v65 = tcp_sackhole_insert(a1, v47[1], *(_DWORD *)(v51 + 4), v51);
              if (v65)
              {
                *a4 += v47[1] - *v47;
                v63 = *(_DWORD *)(v51 + 8);
                if (v63 - v65[2] >= 1)
                {
                  v65[2] = v63;
                  *(_DWORD *)(a1 + 624) += v63 - *v65;
                  v63 = *(_DWORD *)(v51 + 8);
                }
                if (v63 - *v47 >= 0)
                  v63 = *v47;
                *(_DWORD *)(v51 + 4) = *v47;
                *(_DWORD *)(v51 + 8) = v63;
                v65[3] = *(_DWORD *)(v51 + 12);
              }
              else
              {
                v63 = *(_DWORD *)(v51 + 8);
              }
            }
            else
            {
              *a4 += v54 - v53;
              tcp_sack_detect_reordering(a1, (_DWORD *)v51, *(_DWORD *)(v51 + 4), v45);
              v63 = *(_DWORD *)(v51 + 8);
              if (v63 - *v47 >= 0)
                v63 = *v47;
              *(_DWORD *)(v51 + 4) = *v47;
              *(_DWORD *)(v51 + 8) = v63;
            }
          }
          else
          {
            if ((v59 & 0x80000000) == 0)
            {
              *a4 += v54 - v56;
              tcp_sack_detect_reordering(a1, (_DWORD *)v51, *(_DWORD *)(v51 + 4), v45);
              v61 = *(_QWORD *)(v51 + 16);
              v60 = *(_QWORD *)(v51 + 24);
              v52 = **(_QWORD **)(v60 + 8);
              if (*(_QWORD *)(a1 + 616) == v51)
              {
                *(_QWORD *)(a1 + 616) = v61;
                if (!v61)
                  goto LABEL_94;
LABEL_92:
                *(_QWORD *)(v61 + 24) = v60;
                v60 = *(_QWORD *)(v51 + 24);
              }
              else
              {
                if (v61)
                  goto LABEL_92;
LABEL_94:
                *(_QWORD *)(a1 + 552) = v60;
              }
              *(_QWORD *)v60 = v61;
              nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
              free((void *)v51);
              --*(_WORD *)(a1 + 538);
              do
                v62 = __ldxr(tcp_sack_globalholes);
              while (__stxr(v62 - 1, tcp_sack_globalholes));
              goto LABEL_85;
            }
            *a4 += v57;
            tcp_sack_detect_reordering(a1, (_DWORD *)v51, v47[1], v45);
            v63 = v47[1];
            *(_DWORD *)v51 = v63;
            if (*(_DWORD *)(v51 + 8) - v63 > 0)
              v63 = *(_DWORD *)(v51 + 8);
            *(_DWORD *)(v51 + 8) = v63;
          }
          v64 = *(_DWORD *)v51;
          *(_DWORD *)(a1 + 624) += v63 - *(_DWORD *)v51;
          if (*v47 - v64 <= 0)
          {
            v51 = **(_QWORD **)(*(_QWORD *)(v51 + 24) + 8);
            if (v47 < v72)
              return;
            goto LABEL_109;
          }
LABEL_106:
          v47 -= 2;
          if (v47 < v72)
            return;
LABEL_109:
          if (!v51)
            return;
        }
      }
    }
  }
}

_DWORD *tcp_sackhole_insert(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v8;
  _DWORD *v9;
  _DWORD *v10;
  unsigned int v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v18;

  if (*(_DWORD *)(sysctls + 140) <= *(__int16 *)(a1 + 538)
    || (int)tcp_sack_globalholes[0] >= *(_DWORD *)(sysctls + 144))
  {
    v16 = *(_QWORD *)(a1 + 1056);
    v10 = 0;
    if (v16)
      ++*(_QWORD *)(v16 + 608);
  }
  else
  {
    v8 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
    v9 = malloc_type_malloc(**(_QWORD **)(v8 + 40), 0xB9BAFBABuLL);
    v10 = v9;
    if (v9)
    {
      *v9 = a2;
      v9[1] = a3;
      v9[2] = a2;
      ++*(_WORD *)(a1 + 538);
      do
        v11 = __ldxr(tcp_sack_globalholes);
      while (__stxr(v11 + 1, tcp_sack_globalholes));
      v9[3] = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316);
      if (a4)
      {
        v13 = *(_QWORD *)(a4 + 16);
        v12 = (_QWORD *)(a4 + 16);
        *((_QWORD *)v10 + 2) = v13;
        v14 = (_QWORD *)(v13 + 24);
        if (v13)
          v15 = v14;
        else
          v15 = (_QWORD *)(a1 + 552);
        *v15 = v10 + 4;
        *v12 = v10;
        *((_QWORD *)v10 + 3) = v12;
        if (!*(_QWORD *)(a1 + 616))
          goto LABEL_16;
      }
      else
      {
        *((_QWORD *)v10 + 2) = 0;
        v18 = *(_QWORD **)(a1 + 552);
        *((_QWORD *)v10 + 3) = v18;
        *v18 = v10;
        *(_QWORD *)(a1 + 552) = v10 + 4;
        if (!*(_QWORD *)(a1 + 616))
LABEL_16:
          *(_QWORD *)(a1 + 616) = v10;
      }
    }
  }
  return v10;
}

void tcp_sack_detect_reordering(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  int v6;
  uint64_t v8;
  int v9;
  _QWORD *v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  int v17;
  int v18;
  NSObject *v19;
  void *v20;

  if (a2[1] - a4 > 0)
    return;
  if (*(_WORD *)(a1 + 226))
    return;
  v6 = a2[2];
  if (v6 - a3 >= 0)
    return;
  v8 = *(_QWORD *)(a1 + 952);
  if (v8)
  {
    v9 = a3 - 1;
    do
    {
      if (*(_DWORD *)v8 - v9 > 0)
        break;
      if (*(_DWORD *)(v8 + 4) - v9 >= 0)
        return;
      v8 = *(_QWORD *)(v8 + 16);
    }
    while (v8);
  }
  v10 = *(_QWORD **)(a1 + 1056);
  if (v10)
  {
    ++v10[124];
    v11 = *(_DWORD *)(a1 + 740);
    if ((v11 & 0x2000) == 0)
    {
      *(_DWORD *)(a1 + 740) = v11 | 0x2000;
      ++v10[121];
    }
    ++v10[122];
  }
  else
  {
    v12 = *(_DWORD *)(a1 + 740);
    if ((v12 & 0x2000) == 0)
      *(_DWORD *)(a1 + 740) = v12 | 0x2000;
  }
  ++*(_DWORD *)(a1 + 1016);
  if ((~*(_DWORD *)(a1 + 348) & 3) == 0)
  {
    v13 = *(_QWORD *)(a1 + 80);
    v14 = *(_QWORD *)(v13 + 448);
    if (v14)
    {
      v15 = (*(_BYTE *)(v13 + 2236) & 2) == 0;
      v16 = 632;
      if (v15)
        v16 = 248;
      ++*(_QWORD *)(v14 + v16);
    }
    if (v10)
      ++v10[117];
    tcp_heuristic_ecn_aggressive(a1);
    v6 = a2[2];
  }
  if (a4 - v6 >= 0)
  {
    if (!a2[3])
      return;
    goto LABEL_26;
  }
  v19 = __nwlog_obj();
  os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  v20 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort())
  {
    __break(1u);
    return;
  }
  free(v20);
  if (a2[3])
  {
LABEL_26:
    v17 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316) - a2[3];
    if (v17 >= 0)
    {
      if (v17 < *(unsigned __int16 *)(a1 + 536))
        LOWORD(v17) = *(_WORD *)(a1 + 536);
      v18 = *(_DWORD *)(a1 + 200);
      if ((uint64_t)v18 >> 6 <= (unsigned __int16)v17)
        LOWORD(v17) = v18 >> 6;
      if ((unsigned __int16)v17 <= 0xAu)
        LOWORD(v17) = 10;
      *(_WORD *)(a1 + 536) = v17;
    }
  }
}

uint64_t tcp_sack_partialack(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  char v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t result;
  int v11;

  v4 = *(_DWORD *)(a1 + 100);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 172) = 0;
  v5 = *(_DWORD *)(a2 + 8);
  if (v4 - v5 < 0)
    *(_DWORD *)(a1 + 100) = v5;
  v6 = (v5 - *(_DWORD *)(a1 + 92)) / *(_DWORD *)(a1 + 196) > 2;
  v7 = (*(_DWORD *)(a1 + 196) << v6) + tcp_flight_size((_DWORD *)a1);
  v8 = *(_DWORD *)(a1 + 152);
  if (v7 >= *(_DWORD *)(a1 + 148))
    v7 = *(_DWORD *)(a1 + 148);
  *(_DWORD *)(a1 + 144) = v7;
  v9 = *(_DWORD *)(a1 + 560);
  if (v9 - v8 < 0 && v9 == *(_DWORD *)(a2 + 8) && !*(_QWORD *)(a1 + 544) && tcp_sackhole_insert(a1, v9, v8, 0))
    *(_DWORD *)(a1 + 560) = *(_DWORD *)(a1 + 152);
  result = tcp_output(a1);
  v11 = *(_DWORD *)(a1 + 100);
  if ((*(_BYTE *)(a1 + 88) & 0x10) == 0)
  {
    if (v4 - v11 < 1)
      return result;
LABEL_15:
    *(_DWORD *)(a1 + 100) = v4;
    return result;
  }
  if (v11 != *(_DWORD *)(a1 + 96) - 1 && v4 - v11 > 0)
    goto LABEL_15;
  return result;
}

uint64_t tcp_cc_adjust_nonvalidated_cwnd(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;

  v1 = *(_DWORD *)(result + 964);
  if (v1 <= *(_DWORD *)(result + 968))
    v1 = *(_DWORD *)(result + 968);
  if (*(_DWORD *)(result + 972) > v1)
    v1 = *(_DWORD *)(result + 972);
  *(_DWORD *)(result + 980) = v1;
  *(_QWORD *)(result + 964) = 0;
  *(_DWORD *)(result + 972) = 0;
  *(_BYTE *)(result + 751) = 0;
  *(_DWORD *)(result + 984) = 0;
  v2 = v1 >> 1;
  if (*(_DWORD *)(sysctls + 276))
  {
    v3 = *(_DWORD *)(result + 196);
    if (v2 <= v3)
      v2 = *(_DWORD *)(result + 196);
  }
  else
  {
    if (v1 <= 0x2239)
      v2 = 4380;
    v3 = *(_DWORD *)(result + 196);
  }
  *(_DWORD *)(result + 144) = 3 * v3 + v2;
  *(_DWORD *)(result + 740) &= ~0x100000u;
  return result;
}

uint64_t soabort(uint64_t result)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  void (*v4)(uint64_t, _QWORD);

  v1 = *(_DWORD *)(result + 364);
  if ((v1 & 0x100) == 0)
  {
    v2 = result;
    *(_DWORD *)(result + 364) = v1 | 0x100;
    result = (**(uint64_t (***)(void))(*(_QWORD *)(result + 8) + 40))();
    if ((_DWORD)result)
    {
      v3 = *(_QWORD *)(v2 + 8);
      if (v3)
      {
        v4 = *(void (**)(uint64_t, _QWORD))(v3 + 32);
        if (v4)
          v4(v2, 0);
      }
      return sofreelastref(v2);
    }
  }
  return result;
}

uint64_t sbreserve(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t all_stats;
  unsigned int v7;

  if (a2 > 0x71C71C)
    return 0;
  *(_DWORD *)(a1 + 4) = a2;
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 24);
  if ((*(_BYTE *)(a1 + 48) & 4) != 0)
  {
    if (v4)
    {
      all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats)
        *(_DWORD *)(all_stats + 88) = *(_DWORD *)(a1 + 4);
    }
  }
  else if (v4)
  {
    v5 = nw_protocol_tcp_get_all_stats();
    if (v5)
      *(_DWORD *)(v5 + 100) = *(_DWORD *)(a1 + 4);
  }
  v7 = *(_DWORD *)(a1 + 4);
  if (*(_DWORD *)(a1 + 8) > v7)
    *(_DWORD *)(a1 + 8) = v7;
  return 1;
}

uint64_t tcp_setsockopt(uint64_t a1, int a2, int a3, int *a4)
{
  uint64_t v4;
  int v9;
  uint64_t v10;
  int v11;
  signed int v12;
  uint64_t v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t all_stats;
  unsigned int v21;
  _DWORD v22[2];
  uint64_t v23;
  int *v24;
  uint64_t v25;

  v22[0] = 1;
  v22[1] = a2;
  v24 = a4;
  v23 = a3;
  v25 = 4;
  v9 = *a4;
  (*(void (**)(uint64_t, uint64_t, uint64_t, int *))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v4, a4);
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) == 0 && (*(_BYTE *)(a1 + 365) & 0x20) == 0)
    goto LABEL_3;
  if (a2 != 0xFFFF)
  {
    v10 = tcp_ctloutput(a1, (uint64_t)v22);
    goto LABEL_27;
  }
  v10 = 42;
  if (a3 > 2047)
  {
    if (a3 >= 0x2000)
    {
      if (a3 >= 0x8000)
      {
        if (a3 != 0x8000 && a3 != 0x10000)
          goto LABEL_27;
      }
      else if (a3 != 0x2000 && a3 != 0x4000)
      {
        goto LABEL_27;
      }
      goto LABEL_9;
    }
    if ((a3 - 4097) >= 4)
    {
      if (a3 != 2048)
        goto LABEL_27;
LABEL_9:
      v10 = 0;
      if (v9)
        v11 = *(_DWORD *)(a1 + 372) | a3;
      else
        v11 = *(_DWORD *)(a1 + 372) & ~a3;
      *(_DWORD *)(a1 + 372) = v11;
      goto LABEL_27;
    }
    if (v9 < 1)
    {
LABEL_3:
      v10 = 22;
      goto LABEL_27;
    }
    if ((a3 - 4097) < 2)
    {
      if (a3 == 4097)
        v14 = a1 + 384;
      else
        v14 = a1 + 488;
      if (v9 <= 0x71C71C)
      {
        *(_DWORD *)(v14 + 4) = v9;
        v18 = *(_QWORD *)(*(_QWORD *)(v14 + 72) + 24);
        if ((*(_BYTE *)(v14 + 48) & 4) != 0)
        {
          if (v18)
          {
            all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats)
              *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v14 + 4);
          }
        }
        else if (v18)
        {
          v19 = nw_protocol_tcp_get_all_stats();
          if (v19)
            *(_DWORD *)(v19 + 100) = *(_DWORD *)(v14 + 4);
        }
        v21 = *(_DWORD *)(v14 + 4);
        if (*(_DWORD *)(v14 + 8) > v21)
          *(_DWORD *)(v14 + 8) = v21;
        v10 = 0;
        *(_DWORD *)(v14 + 48) = *(_DWORD *)(v14 + 48) & 0xFFFFF9FF | 0x200;
        *(_DWORD *)(v14 + 52) = v9;
      }
      else
      {
        v10 = 55;
      }
    }
    else if (a3 == 4099)
    {
      v10 = 0;
      v17 = *(_DWORD *)(a1 + 388) / 3u;
      if (v9 <= *(_DWORD *)(a1 + 388) / 3)
        v17 = v9;
      if (v17 <= 1)
        v17 = 1;
      *(_DWORD *)(a1 + 392) = v17;
    }
    else if (a3 == 4100)
    {
      v10 = 0;
      v12 = *(_DWORD *)(a1 + 492) / 3u;
      if (v9 <= *(_DWORD *)(a1 + 492) / 3)
        v12 = v9;
      if (v12 >= 0x4000)
        v12 = 0x4000;
      if (v12 <= 1)
        v12 = 1;
      *(_DWORD *)(a1 + 496) = v12;
    }
    else
    {
      v10 = 0;
    }
  }
  else
  {
    if (a3 <= 127)
    {
      if ((a3 - 1) > 0x3F || ((1 << (a3 - 1)) & 0x8000000080008089) == 0)
        goto LABEL_27;
      goto LABEL_9;
    }
    if (a3 != 128)
    {
      if (a3 != 512 && a3 != 1024)
        goto LABEL_27;
      goto LABEL_9;
    }
    *(_DWORD *)(a1 + 16) = a4[1];
    v15 = *(_DWORD *)(a1 + 372);
    v10 = 0;
    if (*a4)
      v16 = v15 | 0x80;
    else
      v16 = v15 & 0xFFFFFF7F;
    *(_DWORD *)(a1 + 372) = v16;
  }
LABEL_27:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v4);
  return v10;
}

uint64_t tcp_set_keepalive(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v5;

  (*(void (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
  {
    v5 = 0;
    *(_DWORD *)(a1 + 372) = *(_DWORD *)(a1 + 372) & 0xFFFFFFF7 | (8 * (a2 != 0));
  }
  else
  {
    v5 = 22;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v2);
  return v5;
}

uint64_t tcp_set_keepalive_idle_time(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v4;
  int v6;
  _QWORD v7[4];

  v6 = a2;
  v7[0] = 0x600000001;
  v7[2] = &v6;
  v7[3] = 4;
  (*(void (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
  {
    v7[1] = 16;
    v4 = tcp_ctloutput(a1, (uint64_t)v7);
  }
  else
  {
    v4 = 22;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v2);
  return v4;
}

uint64_t tcp_set_keepalive_interval(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v4;
  int v6;
  _QWORD v7[4];

  v6 = a2;
  v7[0] = 0x600000001;
  v7[2] = &v6;
  v7[3] = 4;
  (*(void (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
  {
    v7[1] = 257;
    v4 = tcp_ctloutput(a1, (uint64_t)v7);
  }
  else
  {
    v4 = 22;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v2);
  return v4;
}

uint64_t tcp_set_background_management(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  int v5;
  _QWORD v6[4];

  v5 = 1;
  v6[0] = 0xFFFF00000001;
  v6[2] = &v5;
  v6[3] = 4;
  (*(void (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
  {
    v6[1] = 4357;
    v3 = tcp_ctloutput(a1, (uint64_t)v6);
  }
  else
  {
    v3 = 22;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, 1, v1);
  return v3;
}

void tcp_rack_update_segment_acked(uint64_t a1, int a2, unsigned int a3, int a4, int a5)
{
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  BOOL v16;
  uint64_t v17;
  NSObject *v18;
  const char *v19;
  uint64_t v20;
  int v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  unsigned int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v10 = *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316);
  v11 = v10 - a3;
  if (v10 == a3)
    v11 = 1;
  if (!a5)
    goto LABEL_10;
  if (a2 && (((a2 - a3) & 0x80000000) != 0 || a2 - v10 >= 1))
  {
    v12 = *(_QWORD *)(a1 + 80);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 80);
    v13 = *(_QWORD *)(v12 + 496);
    if (!v13 || (v14 = *(_QWORD *)(v13 + 1488)) == 0 || v11 >= *(_DWORD *)(v14 + 40))
    {
LABEL_10:
      v15 = *(_DWORD *)(a1 + 2048);
      if (v15 < a3 || (v15 == a3 ? (v16 = a4 - *(_DWORD *)(a1 + 2052) < 1) : (v16 = 1), !v16))
      {
        *(_BYTE *)(a1 + 2069) |= 0x20u;
        *(_DWORD *)(a1 + 2048) = a3;
        *(_DWORD *)(a1 + 2052) = a4;
        *(_DWORD *)(a1 + 2056) = v11;
        *(_DWORD *)(a1 + 24) = 0;
      }
      return;
    }
  }
  v17 = *(_QWORD *)(v12 + 224);
  if (!v17 || (*(_BYTE *)(v17 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v18 = __nwlog_tcp_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        v19 = (const char *)(v17 + 604);
        if (!v17)
          v19 = "";
        v20 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 496);
        if (v20)
        {
          v20 = *(_QWORD *)(v20 + 1488);
          if (v20)
            LODWORD(v20) = *(_DWORD *)(v20 + 40);
        }
        v21 = 136447490;
        v22 = "tcp_rack_update_segment_acked";
        v23 = 2082;
        v24 = v19;
        v25 = 1024;
        v26 = a2;
        v27 = 1024;
        v28 = a3;
        v29 = 1024;
        v30 = v10;
        v31 = 1024;
        v32 = v20;
        _os_log_impl(&dword_209FB3000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Spurious inference as eithertsecr (%u) doesn't lie between xmit_ts(%u) and now (%u) ORthe segment was transmitted less than base rtt (%u) ago", (uint8_t *)&v21, 0x2Eu);
      }
    }
  }
}

uint64_t tcp_rack_update_reordering_window(uint64_t result, int a2)
{
  char v2;
  __int16 v3;
  char v4;

  v2 = *(_BYTE *)(result + 2069);
  if (a2 - *(_DWORD *)(result + 2060) < 0)
  {
    v2 &= ~0x40u;
    *(_BYTE *)(result + 2069) = v2;
    if ((v2 & 0x40) == 0)
    {
LABEL_3:
      if ((v2 & 0x1F) == 0)
        *(_BYTE *)(result + 2068) = 1;
      return result;
    }
  }
  else if ((*(_BYTE *)(result + 2069) & 0x40) == 0)
  {
    goto LABEL_3;
  }
  *(_DWORD *)(result + 2060) = *(_DWORD *)(result + 100);
  v3 = *(unsigned __int8 *)(result + 2068);
  if (((v3 + 1) & 0x100) != 0)
    v4 = -1;
  else
    v4 = v3 + 1;
  *(_BYTE *)(result + 2068) = v4;
  *(_BYTE *)(result + 2069) = v2 & 0xA0 | 0x10;
  return result;
}

BOOL tcp_rack_detect_loss_and_arm_timer(uint64_t a1, unsigned int a2)
{
  _BOOL8 result;
  int v4;
  int v5;
  char v6;

  result = 0;
  v6 = 0;
  if ((*(_BYTE *)(a1 + 2069) & 0x20) != 0)
  {
    *(_DWORD *)(a1 + 24) = 0;
    v4 = tcp_rack_detect_loss(a1, a2, &v6);
    if (v4)
    {
      v5 = v4
         + *(_DWORD *)(nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224)) + 316)
         - *(_DWORD *)(a1 + 64)
         + 2;
      *(_DWORD *)(a1 + 16) = 0;
    }
    else
    {
      v5 = 0;
    }
    *(_DWORD *)(a1 + 24) = v5;
    return v6 != 0;
  }
  return result;
}

uint64_t tcp_rack_detect_loss(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  int v28;
  uint64_t v29;

  v6 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  if (*(_DWORD *)(a1 + 1016) || (*(_BYTE *)(a1 + 90) & 0x20) == 0 && *(unsigned __int8 *)(a1 + 310) > a2)
  {
    v7 = *(unsigned __int8 *)(a1 + 2068);
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 496);
    if (v8)
    {
      v9 = *(_QWORD *)(v8 + 1488);
      if (v9)
        LODWORD(v9) = *(_DWORD *)(v9 + 40) >> 2;
      v10 = v9 * v7;
      v11 = *(int *)(a1 + 200) >> 5;
      if (v10 >= v11)
      {
LABEL_16:
        if (v11 <= 2)
          v13 = 2;
        else
          v13 = v11;
        v14 = *(_QWORD *)(a1 + 1984);
        if (!v14)
          return 0;
        goto LABEL_20;
      }
      v12 = *(_QWORD *)(v8 + 1488);
      if (v12)
        LODWORD(v12) = *(_DWORD *)(v12 + 40) >> 2;
    }
    else
    {
      v11 = *(int *)(a1 + 200) >> 5;
      if (!v11)
        goto LABEL_16;
      LODWORD(v12) = 0;
    }
    v11 = v12 * v7;
    goto LABEL_16;
  }
  v13 = 0;
  v14 = *(_QWORD *)(a1 + 1984);
  if (!v14)
    return 0;
LABEL_20:
  v17 = *(_DWORD *)(v6 + 316);
  v15 = 0;
  if (a3)
  {
    do
    {
      v18 = *(_DWORD *)(a1 + 2048);
      v19 = *(_DWORD *)(v14 + 8);
      if (v18 <= v19 && (v18 != v19 || *(_DWORD *)(a1 + 2052) - *(_DWORD *)(v14 + 4) < 1))
        break;
      if ((*(_BYTE *)(v14 + 12) & 6) != 2 && (*(_BYTE *)(v14 + 12) & 1) == 0)
      {
        v22 = v19 + v13 + *(_DWORD *)(a1 + 2056);
        if (v17 - v22 >= 0)
        {
          tcp_mark_seg_lost(a1, v14);
          *a3 = 1;
        }
        else
        {
          LODWORD(v23) = v22 - v17;
          if (v22 - v17 <= v15)
            v23 = v15;
          else
            v23 = v23;
          if (v22 != v17)
            v15 = v23;
        }
      }
      v14 = *(_QWORD *)(v14 + 16);
    }
    while (v14);
  }
  else
  {
    do
    {
      v24 = *(_DWORD *)(a1 + 2048);
      v25 = *(_DWORD *)(v14 + 8);
      if (v24 <= v25 && (v24 != v25 || *(_DWORD *)(a1 + 2052) - *(_DWORD *)(v14 + 4) < 1))
        break;
      if ((*(_BYTE *)(v14 + 12) & 6) != 2 && (*(_BYTE *)(v14 + 12) & 1) == 0)
      {
        v28 = v25 + v13 + *(_DWORD *)(a1 + 2056);
        if (v17 - v28 >= 0)
        {
          tcp_mark_seg_lost(a1, v14);
        }
        else
        {
          LODWORD(v29) = v28 - v17;
          if (v28 - v17 <= v15)
            v29 = v15;
          else
            v29 = v29;
          if (v28 != v17)
            v15 = v29;
        }
      }
      v14 = *(_QWORD *)(v14 + 16);
    }
    while (v14);
  }
  return v15;
}

uint64_t tcp_rack_reordering_timeout(uint64_t a1)
{
  uint64_t result;
  int v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  v8 = 0;
  result = tcp_rack_detect_loss(a1, 0, &v8);
  if (v8)
  {
    v3 = *(_DWORD *)(a1 + 88);
    if ((v3 & 0x200000) == 0)
    {
      if ((~v3 & 0x180) != 0)
      {
        v6 = *(_QWORD *)(a1 + 144);
        *(_DWORD *)(a1 + 512) = *(_DWORD *)(a1 + 152);
        *(_QWORD *)(a1 + 504) = v6;
        *(_DWORD *)(a1 + 88) = v3 & 0xFFBFFFFF;
      }
      else
      {
        v4 = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
        v5 = *(_DWORD *)(a1 + 152);
        if (v4 <= *(_DWORD *)(a1 + 148))
          v4 = *(_DWORD *)(a1 + 148);
        *(_DWORD *)(a1 + 508) = v4;
        *(_DWORD *)(a1 + 512) = v5;
      }
      *(_DWORD *)(a1 + 516) = (*(int *)(a1 + 200) >> 5) + 2;
      *(_DWORD *)(a1 + 524) = *(int *)(a1 + 208) >> 4;
      if ((*(_DWORD *)(a1 + 1872) & 0xFFFFFFFE) == 2)
      {
        *(_DWORD *)(a1 + 520) = (*(int *)(a1 + 204) >> 5) + 2;
        *(_DWORD *)(a1 + 528) = *(int *)(a1 + 212) >> 4;
      }
      *(_DWORD *)(a1 + 740) &= ~0x40u;
      tcp_enter_fast_recovery(a1);
    }
    v7 = *(_QWORD *)(a1 + 1056);
    if (v7)
      ++*(_QWORD *)(v7 + 632);
    ++*(_DWORD *)(a1 + 1012);
    return tcp_output(a1);
  }
  return result;
}

void tcp_rack_loss_on_rto(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v2 = nw_tcp_access_globals(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224));
  if (*(_DWORD *)(a1 + 1016))
  {
    v3 = *(unsigned __int8 *)(a1 + 2068);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 496);
    if (v4)
    {
      v5 = *(_QWORD *)(v4 + 1488);
      if (v5)
        LODWORD(v5) = *(_DWORD *)(v5 + 40) >> 2;
      v6 = v5 * v3;
      v7 = *(int *)(a1 + 200) >> 5;
      if (v6 >= v7)
      {
LABEL_13:
        if (v7 <= 2)
          v9 = 2;
        else
          v9 = v7;
        v10 = *(_QWORD *)(a1 + 1984);
        if (!v10)
          return;
        goto LABEL_17;
      }
      v8 = *(_QWORD *)(v4 + 1488);
      if (v8)
        LODWORD(v8) = *(_DWORD *)(v8 + 40) >> 2;
    }
    else
    {
      v7 = *(int *)(a1 + 200) >> 5;
      if (!v7)
        goto LABEL_13;
      LODWORD(v8) = 0;
    }
    v7 = v8 * v3;
    goto LABEL_13;
  }
  v9 = 0;
  v10 = *(_QWORD *)(a1 + 1984);
  if (!v10)
    return;
LABEL_17:
  v11 = *(_DWORD *)(v2 + 316);
  do
  {
    if (*(_DWORD *)v10 == *(_DWORD *)(a1 + 92))
      tcp_mark_seg_lost(a1, v10);
    if ((*(_BYTE *)(v10 + 12) & 6) != 2
      && (*(_BYTE *)(v10 + 12) & 1) == 0
      && v11 - *(_DWORD *)(a1 + 2056) - (v9 + *(_DWORD *)(v10 + 8)) >= 0)
    {
      tcp_mark_seg_lost(a1, v10);
    }
    v10 = *(_QWORD *)(v10 + 16);
  }
  while (v10);
}

const char *packet_service_class_to_str(int a1)
{
  NSObject *v3;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a1 <= 2621727)
  {
    if (a1 <= 1048703)
    {
      if (!a1)
        return "be";
      if (a1 == 524432)
        return "bk_sys";
    }
    else
    {
      switch(a1)
      {
        case 1048704:
          return "bk";
        case 1572880:
          return "rd";
        case 2097184:
          return "oam";
      }
    }
  }
  else if (a1 > 3670319)
  {
    switch(a1)
    {
      case 3670320:
        return "sig";
      case 4194688:
        return "vo";
      case 4718992:
        return "ctl";
    }
  }
  else
  {
    switch(a1)
    {
      case 2621728:
        return "av";
      case 3146000:
        return "rv";
      case 3670272:
        return "vi";
    }
  }
  v3 = __nwlog_obj();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    v4 = 136446466;
    v5 = "packet_service_class_to_str";
    v6 = 1024;
    v7 = a1;
    _os_log_impl(&dword_209FB3000, v3, OS_LOG_TYPE_ERROR, "%{public}s invalid packet service class %d", (uint8_t *)&v4, 0x12u);
  }
  return "unknown";
}

void tcp_pmtud_revert_segment_size(uint64_t a1)
{
  int v2;
  int v3;
  void (*v4)(uint64_t);
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  NSObject *v14;
  void *v15;

  v2 = *(unsigned __int16 *)(a1 + 698);
  if (!*(_WORD *)(a1 + 698))
  {
    v14 = __nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    v15 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v15);
    v2 = *(unsigned __int16 *)(a1 + 698);
  }
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 88) & 0xDBFFFFFF | 0x4000000;
  v3 = *(_DWORD *)(a1 + 196) - *(_DWORD *)(a1 + 156);
  *(_DWORD *)(a1 + 156) = v2;
  *(_DWORD *)(a1 + 196) = v3 + v2;
  v4 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 40);
  if (v4)
    v4(a1);
  if (*(_DWORD *)(sysctls + 308) == 1
    && (~*(_DWORD *)(a1 + 88) & 0x180) == 0
    && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224) + 369) & 0x40) != 0)
    && off_253CF8698)
  {
    off_253CF8698((_DWORD *)a1);
  }
  *(_DWORD *)(a1 + 700) = 0;
  v5 = *(_QWORD *)(a1 + 1056);
  if (v5)
    ++*(_QWORD *)(v5 + 1056);
  v6 = **(_QWORD **)(*(_QWORD *)(a1 + 80) + 224);
  v7 = *(_QWORD *)(v6 + 448);
  if (v7)
  {
    v8 = *(_QWORD *)(v6 + 240);
    if ((*(unsigned __int8 *)(v7 + 1076) == 255 || *(_DWORD *)(v7 + 1024) == 255)
      && *(int *)(v8 + 12) <= 5
      && (*(_BYTE *)(v8 + 91) & 0x20) == 0
      && (*(_BYTE *)(v7 + 9) & 0x80) != 0)
    {
      v9 = *(_DWORD *)(v8 + 156);
      v10 = *(_DWORD *)(v8 + 196) - v9;
      v11 = *(unsigned __int16 *)(v7 + 72);
      if (v11 == 1200)
      {
        if (v9 <= 0x4B0)
          goto LABEL_33;
        v12 = 1200;
      }
      else
      {
        if (v11 != 512)
        {
          if (v11)
            goto LABEL_33;
          v12 = *(unsigned __int16 *)(v8 + 734);
          if (!*(_WORD *)(v8 + 734) || v9 >= v12)
            goto LABEL_33;
          goto LABEL_32;
        }
        if (v9 < 0x201)
          goto LABEL_33;
        v12 = 512;
      }
      *(_WORD *)(v8 + 734) = v9;
LABEL_32:
      *(_DWORD *)(v8 + 156) = v12;
      v9 = v12;
LABEL_33:
      *(_DWORD *)(v8 + 196) = v10 + v9;
      if (v9 == *(unsigned __int16 *)(v8 + 734))
        *(_WORD *)(v8 + 734) = 0;
    }
  }
}

uint64_t tcp_itimer(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  _QWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  BOOL v16;
  unsigned int v17;

  *(_BYTE *)(result + 328) |= 0x10u;
  v4 = *(_QWORD **)(result + 104);
  while (v4)
  {
    v5 = (uint64_t)v4;
    v4 = (_QWORD *)*v4;
    if (*(_QWORD *)(v5 + 240))
    {
      v6 = (unsigned int *)(v5 + 456);
      while (1)
      {
        v7 = *v6;
        if ((unsigned __int16)*v6 == 0xFFFF)
          break;
        while (1)
        {
          v8 = __ldxr(v6);
          if (v8 != v7)
            break;
          if (!__stxr(v7 + 1, v6))
          {
            v9 = *(_QWORD **)(v5 + 224);
            (*(void (**)(_QWORD *, uint64_t, uint64_t))(v9[1] + 16))(v9, 1, v2);
            v10 = in_pcb_checkstate(v5, 2, 1);
            if (v10 == 0xFFFF)
              goto LABEL_3;
            if ((*(_BYTE *)(a2 + 68) & 1) == 0)
              goto LABEL_3;
            v11 = *(_QWORD *)(*v9 + 448);
            if (!v11)
              goto LABEL_3;
            v12 = *(_QWORD *)(*v9 + 240);
            if (*(unsigned __int8 *)(v11 + 1076) != 255 && *(_DWORD *)(v11 + 1024) != 255)
              goto LABEL_3;
            if (*(int *)(v12 + 12) > 5 || (*(_BYTE *)(v12 + 91) & 0x20) != 0 || (*(_BYTE *)(v11 + 9) & 0x80) == 0)
              goto LABEL_3;
            v13 = *(_DWORD *)(v12 + 156);
            v14 = *(unsigned __int16 *)(v11 + 72);
            switch(v14)
            {
              case 1200:
                if (v13 <= 0x4B0)
                  goto LABEL_35;
                v15 = 1200;
                break;
              case 512:
                if (v13 < 0x201)
                  goto LABEL_35;
                v15 = 512;
                break;
              case 0:
                v15 = *(unsigned __int16 *)(v12 + 734);
                if (*(_WORD *)(v12 + 734))
                  v16 = v13 >= v15;
                else
                  v16 = 1;
                v17 = *(_DWORD *)(v12 + 156);
                if (!v16)
                {
LABEL_34:
                  *(_DWORD *)(v12 + 156) = v15;
                  v17 = v15;
                }
LABEL_36:
                *(_DWORD *)(v12 + 196) = *(_DWORD *)(v12 + 196) - v13 + v17;
                if (v17 == *(unsigned __int16 *)(v12 + 734))
                  *(_WORD *)(v12 + 734) = 0;
LABEL_3:
                result = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t))(v9[1] + 24))(v9, 1, v2);
                goto LABEL_4;
              default:
LABEL_35:
                v17 = *(_DWORD *)(v12 + 156);
                goto LABEL_36;
            }
            *(_WORD *)(v12 + 734) = v13;
            goto LABEL_34;
          }
        }
        __clrex();
      }
    }
LABEL_4:
    ;
  }
  *(_DWORD *)(a2 + 68) &= ~1u;
  return result;
}

uint64_t tcp_heuristic_tfo_middlebox(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  NSObject *v6;
  os_log_type_t v7;
  NSObject *v8;
  const char *v9;
  _BYTE v11[22];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(_QWORD *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v5 = "";
          if (v3)
            v5 = (const char *)(v3 + 604);
          *(_DWORD *)v11 = 136446466;
          *(_QWORD *)&v11[4] = "tcp_heuristic_tfo_middlebox";
          *(_WORD *)&v11[12] = 2082;
          *(_QWORD *)&v11[14] = v5;
          v6 = v4;
          v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_209FB3000, v6, v7, "%{public}s %{public}s ", v11, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = "";
      if (v3)
        v9 = (const char *)(v3 + 604);
      *(_DWORD *)v11 = 136446466;
      *(_QWORD *)&v11[4] = "tcp_heuristic_tfo_middlebox";
      *(_WORD *)&v11[12] = 2082;
      *(_QWORD *)&v11[14] = v9;
      v6 = v8;
      v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  *(_BYTE *)(a1 + 988) |= 0x40u;
  *(_QWORD *)v11 = 0;
  *(_QWORD *)&v11[8] = 0;
  *(_WORD *)&v11[16] = 1024;
  return (*(uint64_t (**)(_QWORD, _BYTE *))(*(_QWORD *)(v2 + 2136) + 56))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224), v11);
}

uint64_t tcp_heuristic_tfo_rst(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  NSObject *v6;
  os_log_type_t v7;
  NSObject *v8;
  const char *v9;
  __int16 v10;
  char v11;
  _BYTE v13[22];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(_QWORD *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v5 = "";
          if (v3)
            v5 = (const char *)(v3 + 604);
          *(_DWORD *)v13 = 136446466;
          *(_QWORD *)&v13[4] = "tcp_heuristic_tfo_rst";
          *(_WORD *)&v13[12] = 2082;
          *(_QWORD *)&v13[14] = v5;
          v6 = v4;
          v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_209FB3000, v6, v7, "%{public}s %{public}s ", v13, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = "";
      if (v3)
        v9 = (const char *)(v3 + 604);
      *(_DWORD *)v13 = 136446466;
      *(_QWORD *)&v13[4] = "tcp_heuristic_tfo_rst";
      *(_WORD *)&v13[12] = 2082;
      *(_QWORD *)&v13[14] = v9;
      v6 = v8;
      v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  memset(v13, 0, 18);
  v10 = *(_WORD *)(a1 + 990);
  if ((v10 & 0x40) == 0)
  {
    v11 = 64;
    if ((v10 & 0x10) == 0)
      return (*(uint64_t (**)(_QWORD, _BYTE *))(*(_QWORD *)(v2 + 2136) + 56))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224), v13);
    goto LABEL_20;
  }
  v13[17] = 32;
  v11 = 96;
  if ((v10 & 0x10) != 0)
LABEL_20:
    v13[17] = v11;
  return (*(uint64_t (**)(_QWORD, _BYTE *))(*(_QWORD *)(v2 + 2136) + 56))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224), v13);
}

uint64_t tcp_heuristic_ecn_loss(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  NSObject *v6;
  os_log_type_t v7;
  NSObject *v8;
  const char *v9;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(_QWORD *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v5 = "";
          if (v3)
            v5 = (const char *)(v3 + 604);
          v11 = 136446466;
          v12 = "tcp_heuristic_ecn_loss";
          v13 = 2082;
          v14 = v5;
          v6 = v4;
          v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_209FB3000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = "";
      if (v3)
        v9 = (const char *)(v3 + 604);
      v11 = 136446466;
      v12 = "tcp_heuristic_ecn_loss";
      v13 = 2082;
      v14 = v9;
      v6 = v8;
      v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  LOBYTE(v11) = 2;
  return (*(uint64_t (**)(_QWORD, int *))(*(_QWORD *)(v2 + 2136) + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224), &v11);
}

uint64_t tcp_heuristic_ecn_droprst(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  NSObject *v6;
  os_log_type_t v7;
  NSObject *v8;
  const char *v9;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(_QWORD *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v5 = "";
          if (v3)
            v5 = (const char *)(v3 + 604);
          v11 = 136446466;
          v12 = "tcp_heuristic_ecn_droprst";
          v13 = 2082;
          v14 = v5;
          v6 = v4;
          v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_209FB3000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = "";
      if (v3)
        v9 = (const char *)(v3 + 604);
      v11 = 136446466;
      v12 = "tcp_heuristic_ecn_droprst";
      v13 = 2082;
      v14 = v9;
      v6 = v8;
      v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  LOBYTE(v11) = 4;
  return (*(uint64_t (**)(_QWORD, int *))(*(_QWORD *)(v2 + 2136) + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224), &v11);
}

uint64_t tcp_heuristic_ecn_droprxmt(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  NSObject *v6;
  os_log_type_t v7;
  NSObject *v8;
  const char *v9;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(_QWORD *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v5 = "";
          if (v3)
            v5 = (const char *)(v3 + 604);
          v11 = 136446466;
          v12 = "tcp_heuristic_ecn_droprxmt";
          v13 = 2082;
          v14 = v5;
          v6 = v4;
          v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_209FB3000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = "";
      if (v3)
        v9 = (const char *)(v3 + 604);
      v11 = 136446466;
      v12 = "tcp_heuristic_ecn_droprxmt";
      v13 = 2082;
      v14 = v9;
      v6 = v8;
      v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  LOBYTE(v11) = 8;
  return (*(uint64_t (**)(_QWORD, int *))(*(_QWORD *)(v2 + 2136) + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224), &v11);
}

uint64_t tcp_heuristic_ecn_synrst(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  const char *v4;
  NSObject *v5;
  os_log_type_t v6;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 224);
  if (tcp_perf_measurement)
  {
    if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v3 = __nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        {
          v4 = "";
          if (v2)
            v4 = (const char *)(v2 + 604);
          v11 = 136446466;
          v12 = "tcp_heuristic_ecn_synrst";
          v13 = 2082;
          v14 = v4;
          v5 = v3;
          v6 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_209FB3000, v5, v6, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }
  else if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    v7 = __nwlog_tcp_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = "";
      if (v2)
        v8 = (const char *)(v2 + 604);
      v11 = 136446466;
      v12 = "tcp_heuristic_ecn_synrst";
      v13 = 2082;
      v14 = v8;
      v5 = v7;
      v6 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  v9 = *(_QWORD *)(a1 + 80);
  LOBYTE(v11) = 32;
  return (*(uint64_t (**)(_QWORD, int *))(*(_QWORD *)(v9 + 2136) + 24))(*(_QWORD *)(v9 + 224), &v11);
}

uint64_t tcp_heuristic_ecn_aggressive(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  NSObject *v6;
  os_log_type_t v7;
  NSObject *v8;
  const char *v9;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(_QWORD *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v5 = "";
          if (v3)
            v5 = (const char *)(v3 + 604);
          v11 = 136446466;
          v12 = "tcp_heuristic_ecn_aggressive";
          v13 = 2082;
          v14 = v5;
          v6 = v4;
          v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_209FB3000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = "";
      if (v3)
        v9 = (const char *)(v3 + 604);
      v11 = 136446466;
      v12 = "tcp_heuristic_ecn_aggressive";
      v13 = 2082;
      v14 = v9;
      v6 = v8;
      v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  LOBYTE(v11) = 16;
  return (*(uint64_t (**)(_QWORD, int *))(*(_QWORD *)(v2 + 2136) + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 224), &v11);
}

void tcp_cubic_switch_cc(uint64_t a1)
{
  unsigned int v1;

  tcp_cubic_cwnd_init_or_reset(a1);
  do
    v1 = __ldaxr(dword_253CF8760);
  while (__stlxr(v1 + 1, dword_253CF8760));
}

CCCryptorStatus CCCryptorCreate(CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, CCCryptorRef *cryptorRef)
{
  return MEMORY[0x24BDAC110](*(_QWORD *)&op, *(_QWORD *)&alg, *(_QWORD *)&options, key, keyLength, iv, cryptorRef);
}

CCCryptorStatus CCCryptorUpdate(CCCryptorRef cryptorRef, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x24BDAC198](cryptorRef, dataIn, dataInLength, dataOut, dataOutAvailable, dataOutMoved);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x24BDAC360](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x24BDAC368](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x24BDAC370](c, data, *(_QWORD *)&len);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x24BDAC848]();
}

uint64_t __nw_create_backtrace_string()
{
  return MEMORY[0x24BDE07F8]();
}

uint64_t __nwlog_abort()
{
  return MEMORY[0x24BDE0800]();
}

uint64_t __nwlog_fault()
{
  return MEMORY[0x24BDE0808]();
}

uint64_t __nwlog_is_datapath_logging_enabled()
{
  return MEMORY[0x24BDE0818]();
}

uint64_t __nwlog_obj()
{
  return MEMORY[0x24BDE0820]();
}

uint64_t __nwlog_tcp_log()
{
  return MEMORY[0x24BDE0830]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x24BDACB60]();
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x24BDACBA8]();
}

uint32_t arc4random(void)
{
  return MEMORY[0x24BDAD158]();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
  MEMORY[0x24BDAD160](__buf, __nbytes);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

float cbrtf(float a1)
{
  float result;

  MEMORY[0x24BDAD338](a1);
  return result;
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x24BDADFF8](when, delta);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

uint64_t in6_pseudo()
{
  return MEMORY[0x24BDE08D0]();
}

uint64_t in_addword()
{
  return MEMORY[0x24BDE08D8]();
}

uint64_t in_finalize_cksum()
{
  return MEMORY[0x24BDE08E0]();
}

uint64_t in_pseudo()
{
  return MEMORY[0x24BDE08E8]();
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return (const char *)MEMORY[0x24BDAE8B0](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

uint64_t kdebug_is_enabled()
{
  return MEMORY[0x24BDAE950]();
}

uint64_t kdebug_trace()
{
  return MEMORY[0x24BDAE958]();
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x24BDAEB30]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x24BDAEC68](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

uint64_t network_config_get_tcp_accurate_ecn_enabled()
{
  return MEMORY[0x24BDE0928]();
}

uint64_t network_config_get_tcp_l4s_enabled()
{
  return MEMORY[0x24BDE0930]();
}

uint64_t networkd_settings_get_BOOL()
{
  return MEMORY[0x24BDE0940]();
}

uint64_t networkd_settings_get_int64_with_default()
{
  return MEMORY[0x24BDE0948]();
}

uint64_t nw_array_append()
{
  return MEMORY[0x24BDE0A10]();
}

uint64_t nw_array_create()
{
  return MEMORY[0x24BDE0A38]();
}

uint64_t nw_connection_client_accurate_ecn_state_to_string()
{
  return MEMORY[0x24BDE0B08]();
}

uint64_t nw_connection_server_accurate_ecn_state_to_string()
{
  return MEMORY[0x24BDE0C60]();
}

uint64_t nw_context_128k_buffer_length()
{
  return MEMORY[0x24BDE0D50]();
}

uint64_t nw_context_128k_buffer_manager()
{
  return MEMORY[0x24BDE0D58]();
}

uint64_t nw_context_16k_buffer_length()
{
  return MEMORY[0x24BDE0D60]();
}

uint64_t nw_context_16k_buffer_manager()
{
  return MEMORY[0x24BDE0D68]();
}

uint64_t nw_context_2k_buffer_length()
{
  return MEMORY[0x24BDE0D70]();
}

uint64_t nw_context_2k_buffer_manager()
{
  return MEMORY[0x24BDE0D78]();
}

uint64_t nw_context_64k_buffer_length()
{
  return MEMORY[0x24BDE0D80]();
}

uint64_t nw_context_64k_buffer_manager()
{
  return MEMORY[0x24BDE0D88]();
}

uint64_t nw_context_8k_buffer_length()
{
  return MEMORY[0x24BDE0D90]();
}

uint64_t nw_context_8k_buffer_manager()
{
  return MEMORY[0x24BDE0D98]();
}

uint64_t nw_context_get_globals_for_protocol()
{
  return MEMORY[0x24BDE0DA8]();
}

uint64_t nw_context_get_logging_disabled()
{
  return MEMORY[0x24BDE0DB0]();
}

uint64_t nw_dispatch_data_copyout_from_offset()
{
  return MEMORY[0x24BDE0E28]();
}

char *__cdecl nw_endpoint_copy_address_string(nw_endpoint_t endpoint)
{
  return (char *)MEMORY[0x24BDE0E30](endpoint);
}

const sockaddr *__cdecl nw_endpoint_get_address(nw_endpoint_t endpoint)
{
  return (const sockaddr *)MEMORY[0x24BDE0EC0](endpoint);
}

uint16_t nw_endpoint_get_port(nw_endpoint_t endpoint)
{
  return MEMORY[0x24BDE0F40](endpoint);
}

uint64_t nw_frame_array_first()
{
  return MEMORY[0x24BDE1030]();
}

uint64_t nw_frame_array_foreach()
{
  return MEMORY[0x24BDE1038]();
}

uint64_t nw_frame_array_is_empty()
{
  return MEMORY[0x24BDE1048]();
}

uint64_t nw_frame_array_remove()
{
  return MEMORY[0x24BDE1068]();
}

uint64_t nw_frame_array_unclaimed_length()
{
  return MEMORY[0x24BDE1070]();
}

uint64_t nw_frame_create()
{
  return MEMORY[0x24BDE1088]();
}

uint64_t nw_frame_create_external()
{
  return MEMORY[0x24BDE1090]();
}

uint64_t nw_frame_is_wake_packet()
{
  return MEMORY[0x24BDE10B0]();
}

uint64_t nw_frame_set_is_wake_packet()
{
  return MEMORY[0x24BDE10C8]();
}

uint64_t nw_interface_get_subtype()
{
  return MEMORY[0x24BDE13D0]();
}

nw_interface_type_t nw_interface_get_type(nw_interface_t interface)
{
  return MEMORY[0x24BDE13D8](interface);
}

uint64_t nw_interface_supports_ack_priority()
{
  return MEMORY[0x24BDE13E8]();
}

uint64_t nw_interface_supports_carrier_aggregation()
{
  return MEMORY[0x24BDE13F0]();
}

uint64_t nw_interface_supports_tx_start()
{
  return MEMORY[0x24BDE13F8]();
}

uint64_t nw_ip_metadata_get_dscp_value()
{
  return MEMORY[0x24BDE1408]();
}

nw_ip_ecn_flag_t nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x24BDE1410](metadata);
}

uint64_t nw_ip_metadata_get_fragmentation_value()
{
  return MEMORY[0x24BDE1418]();
}

nw_service_class_t nw_ip_metadata_get_service_class(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x24BDE1420](metadata);
}

uint64_t nw_link_get_flow_control_status()
{
  return MEMORY[0x24BDE1430]();
}

uint64_t nw_log_ms_to_delta()
{
  return MEMORY[0x24BDE14B8]();
}

uint64_t nw_log_ring_append()
{
  return MEMORY[0x24BDE14C0]();
}

uint64_t nw_log_ring_copyout()
{
  return MEMORY[0x24BDE14C8]();
}

uint64_t nw_mem_buffer_allocate()
{
  return MEMORY[0x24BDE14D8]();
}

uint64_t nw_mem_buffer_free()
{
  return MEMORY[0x24BDE14E0]();
}

uint64_t nw_parameters_copy_context()
{
  return MEMORY[0x24BDE1520]();
}

uint64_t nw_parameters_copy_protocol_options_legacy()
{
  return MEMORY[0x24BDE1540]();
}

uint64_t nw_parameters_get_discretionary()
{
  return MEMORY[0x24BDE15B0]();
}

uint64_t nw_parameters_get_ecn_mode()
{
  return MEMORY[0x24BDE15C0]();
}

BOOL nw_parameters_get_fast_open_enabled(nw_parameters_t parameters)
{
  return MEMORY[0x24BDE15D0](parameters);
}

uint64_t nw_parameters_get_logging_disabled()
{
  return MEMORY[0x24BDE15E0]();
}

uint64_t nw_parameters_get_sensitive_redacted()
{
  return MEMORY[0x24BDE15F8]();
}

uint64_t nw_parameters_get_server_mode()
{
  return MEMORY[0x24BDE1600]();
}

uint64_t nw_parameters_is_fallback()
{
  return MEMORY[0x24BDE1610]();
}

uint64_t nw_path_copy_delegate_interface()
{
  return MEMORY[0x24BDE17A8]();
}

uint64_t nw_path_copy_direct_interface()
{
  return MEMORY[0x24BDE17B0]();
}

uint64_t nw_path_copy_flow_registration()
{
  return MEMORY[0x24BDE17C8]();
}

uint64_t nw_path_flow_registration_access_interface_stats()
{
  return MEMORY[0x24BDE1868]();
}

uint64_t nw_path_flow_registration_ecn_enabled()
{
  return MEMORY[0x24BDE1870]();
}

uint64_t nw_path_flow_registration_fast_open_blocked()
{
  return MEMORY[0x24BDE1878]();
}

uint64_t nw_path_flow_registration_get_advisory_region()
{
  return MEMORY[0x24BDE1880]();
}

uint64_t nw_path_flow_registration_get_ctl_command()
{
  return MEMORY[0x24BDE1888]();
}

uint64_t nw_path_flow_registration_get_nexus_instance()
{
  return MEMORY[0x24BDE1890]();
}

uint64_t nw_path_flow_registration_get_partial_checksum_offload()
{
  return MEMORY[0x24BDE1898]();
}

uint64_t nw_path_flow_registration_get_stats_area()
{
  return MEMORY[0x24BDE18A0]();
}

uint64_t nw_path_flow_registration_get_stats_region()
{
  return MEMORY[0x24BDE18A8]();
}

uint64_t nw_path_flow_registration_get_tfo_cookie()
{
  return MEMORY[0x24BDE18B0]();
}

uint64_t nw_path_flow_registration_get_tfo_cookie_len()
{
  return MEMORY[0x24BDE18B8]();
}

uint64_t nw_path_flow_registration_set_ecn_cache()
{
  return MEMORY[0x24BDE18C0]();
}

uint64_t nw_path_flow_registration_set_tfo_cache()
{
  return MEMORY[0x24BDE18C8]();
}

uint64_t nw_path_get_csum_flags()
{
  return MEMORY[0x24BDE18D0]();
}

uint64_t nw_path_get_effective_traffic_class()
{
  return MEMORY[0x24BDE18D8]();
}

uint64_t nw_path_get_interface_index()
{
  return MEMORY[0x24BDE18F8]();
}

uint64_t nw_path_get_ipv4_network_signature()
{
  return MEMORY[0x24BDE1900]();
}

uint64_t nw_path_get_ipv6_network_signature()
{
  return MEMORY[0x24BDE1908]();
}

uint64_t nw_path_get_mtu()
{
  return MEMORY[0x24BDE1910]();
}

uint64_t nw_path_get_recommended_mss()
{
  return MEMORY[0x24BDE1920]();
}

uint64_t nw_path_get_rtt_values()
{
  return MEMORY[0x24BDE1928]();
}

uint64_t nw_path_get_sysctls_region()
{
  return MEMORY[0x24BDE1940]();
}

uint64_t nw_path_get_tso_max_segment_size_v4()
{
  return MEMORY[0x24BDE1948]();
}

uint64_t nw_path_get_tso_max_segment_size_v6()
{
  return MEMORY[0x24BDE1950]();
}

uint64_t nw_path_is_defunct()
{
  return MEMORY[0x24BDE19A8]();
}

uint64_t nw_path_is_direct()
{
  return MEMORY[0x24BDE19B0]();
}

uint64_t nw_path_is_local()
{
  return MEMORY[0x24BDE19D8]();
}

uint64_t nw_path_is_traffic_mgmt_background()
{
  return MEMORY[0x24BDE19F0]();
}

uint64_t nw_path_is_viable()
{
  return MEMORY[0x24BDE19F8]();
}

uint64_t nw_path_should_probe_connectivity()
{
  return MEMORY[0x24BDE1A60]();
}

uint64_t nw_protocol_callbacks_set_add_input_handler()
{
  return MEMORY[0x24BDE1A70]();
}

uint64_t nw_protocol_callbacks_set_connect()
{
  return MEMORY[0x24BDE1A78]();
}

uint64_t nw_protocol_callbacks_set_connected()
{
  return MEMORY[0x24BDE1A80]();
}

uint64_t nw_protocol_callbacks_set_copy_info()
{
  return MEMORY[0x24BDE1A88]();
}

uint64_t nw_protocol_callbacks_set_disconnect()
{
  return MEMORY[0x24BDE1A90]();
}

uint64_t nw_protocol_callbacks_set_disconnected()
{
  return MEMORY[0x24BDE1A98]();
}

uint64_t nw_protocol_callbacks_set_error()
{
  return MEMORY[0x24BDE1AA0]();
}

uint64_t nw_protocol_callbacks_set_finalize_output_frames()
{
  return MEMORY[0x24BDE1AA8]();
}

uint64_t nw_protocol_callbacks_set_get_input_frames()
{
  return MEMORY[0x24BDE1AB0]();
}

uint64_t nw_protocol_callbacks_set_get_message_properties()
{
  return MEMORY[0x24BDE1AB8]();
}

uint64_t nw_protocol_callbacks_set_get_output_frames()
{
  return MEMORY[0x24BDE1AC0]();
}

uint64_t nw_protocol_callbacks_set_input_available()
{
  return MEMORY[0x24BDE1AC8]();
}

uint64_t nw_protocol_callbacks_set_input_flush()
{
  return MEMORY[0x24BDE1AD0]();
}

uint64_t nw_protocol_callbacks_set_link_state()
{
  return MEMORY[0x24BDE1AD8]();
}

uint64_t nw_protocol_callbacks_set_output_available()
{
  return MEMORY[0x24BDE1AE0]();
}

uint64_t nw_protocol_callbacks_set_output_finished()
{
  return MEMORY[0x24BDE1AE8]();
}

uint64_t nw_protocol_callbacks_set_register_notification()
{
  return MEMORY[0x24BDE1AF0]();
}

uint64_t nw_protocol_callbacks_set_remove_input_handler()
{
  return MEMORY[0x24BDE1AF8]();
}

uint64_t nw_protocol_callbacks_set_replace_input_handler()
{
  return MEMORY[0x24BDE1B00]();
}

uint64_t nw_protocol_callbacks_set_reset()
{
  return MEMORY[0x24BDE1B08]();
}

uint64_t nw_protocol_callbacks_set_unregister_notification()
{
  return MEMORY[0x24BDE1B10]();
}

uint64_t nw_protocol_callbacks_set_updated_path()
{
  return MEMORY[0x24BDE1B18]();
}

uint64_t nw_protocol_callbacks_set_waiting_for_output()
{
  return MEMORY[0x24BDE1B20]();
}

uint64_t nw_protocol_connect_quiet()
{
  return MEMORY[0x24BDE1B28]();
}

uint64_t nw_protocol_connected()
{
  return MEMORY[0x24BDE1B30]();
}

uint64_t nw_protocol_connected_quiet()
{
  return MEMORY[0x24BDE1B38]();
}

uint64_t nw_protocol_copy_info_quiet()
{
  return MEMORY[0x24BDE1B50]();
}

nw_protocol_definition_t nw_protocol_copy_tcp_definition(void)
{
  return (nw_protocol_definition_t)MEMORY[0x24BDE1B80]();
}

BOOL nw_protocol_definition_is_equal(nw_protocol_definition_t definition1, nw_protocol_definition_t definition2)
{
  return MEMORY[0x24BDE1BD8](definition1, definition2);
}

uint64_t nw_protocol_destroy()
{
  return MEMORY[0x24BDE1CB8]();
}

uint64_t nw_protocol_disconnect_quiet()
{
  return MEMORY[0x24BDE1CC0]();
}

uint64_t nw_protocol_disconnected()
{
  return MEMORY[0x24BDE1CC8]();
}

uint64_t nw_protocol_disconnected_is_valid()
{
  return MEMORY[0x24BDE1CD0]();
}

uint64_t nw_protocol_downcast()
{
  return MEMORY[0x24BDE1CD8]();
}

uint64_t nw_protocol_error()
{
  return MEMORY[0x24BDE1CE0]();
}

uint64_t nw_protocol_error_quiet()
{
  return MEMORY[0x24BDE1CE8]();
}

uint64_t nw_protocol_establishment_report_create()
{
  return MEMORY[0x24BDE1CF0]();
}

uint64_t nw_protocol_establishment_report_set_client_accurate_ecn_state()
{
  return MEMORY[0x24BDE1CF8]();
}

uint64_t nw_protocol_establishment_report_set_server_accurate_ecn_state()
{
  return MEMORY[0x24BDE1D08]();
}

uint64_t nw_protocol_get_flow_id()
{
  return MEMORY[0x24BDE1D10]();
}

uint64_t nw_protocol_get_identifier()
{
  return MEMORY[0x24BDE1D18]();
}

uint64_t nw_protocol_get_input_frames()
{
  return MEMORY[0x24BDE1D20]();
}

uint64_t nw_protocol_get_input_handler()
{
  return MEMORY[0x24BDE1D28]();
}

uint64_t nw_protocol_get_local_endpoint()
{
  return MEMORY[0x24BDE1D30]();
}

uint64_t nw_protocol_get_output_handler()
{
  return MEMORY[0x24BDE1D38]();
}

uint64_t nw_protocol_get_parameters()
{
  return MEMORY[0x24BDE1D40]();
}

uint64_t nw_protocol_get_path()
{
  return MEMORY[0x24BDE1D48]();
}

uint64_t nw_protocol_get_remote_endpoint()
{
  return MEMORY[0x24BDE1D50]();
}

uint64_t nw_protocol_input_available()
{
  return MEMORY[0x24BDE1D60]();
}

uint64_t nw_protocol_input_available_is_valid()
{
  return MEMORY[0x24BDE1D68]();
}

uint64_t nw_protocol_input_finished_quiet()
{
  return MEMORY[0x24BDE1D70]();
}

uint64_t nw_protocol_input_handler_is_connection_flow()
{
  return MEMORY[0x24BDE1D78]();
}

nw_protocol_definition_t nw_protocol_metadata_copy_definition(nw_protocol_metadata_t metadata)
{
  return (nw_protocol_definition_t)MEMORY[0x24BDE1F18](metadata);
}

uint64_t nw_protocol_metadata_copy_identifier()
{
  return MEMORY[0x24BDE1F20]();
}

BOOL nw_protocol_metadata_is_ip(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x24BDE1F48](metadata);
}

uint64_t nw_protocol_new()
{
  return MEMORY[0x24BDE1F70]();
}

uint64_t nw_protocol_notification_type_to_string()
{
  return MEMORY[0x24BDE1F78]();
}

uint64_t nw_protocol_notify_quiet()
{
  return MEMORY[0x24BDE1F80]();
}

uint64_t nw_protocol_one_to_one_callbacks_new()
{
  return MEMORY[0x24BDE1F88]();
}

uint64_t nw_protocol_options_get_log_id_num()
{
  return MEMORY[0x24BDE1FA0]();
}

uint64_t nw_protocol_options_get_log_id_str()
{
  return MEMORY[0x24BDE1FA8]();
}

uint64_t nw_protocol_output_available_quiet()
{
  return MEMORY[0x24BDE1FB8]();
}

uint64_t nw_protocol_register_extended()
{
  return MEMORY[0x24BDE1FC8]();
}

uint64_t nw_protocol_release()
{
  return MEMORY[0x24BDE1FD0]();
}

uint64_t nw_protocol_remove_input_handler()
{
  return MEMORY[0x24BDE1FD8]();
}

uint64_t nw_protocol_remove_input_handler_is_valid()
{
  return MEMORY[0x24BDE1FE0]();
}

uint64_t nw_protocol_retain()
{
  return MEMORY[0x24BDE1FF0]();
}

uint64_t nw_protocol_set_flow_id_from_protocol()
{
  return MEMORY[0x24BDE2000]();
}

uint64_t nw_protocol_set_input_handler()
{
  return MEMORY[0x24BDE2008]();
}

uint64_t nw_protocol_set_output_handler()
{
  return MEMORY[0x24BDE2010]();
}

uint64_t nw_protocol_supports_external_data()
{
  return MEMORY[0x24BDE2060]();
}

uint64_t nw_protocol_supports_external_data_is_valid()
{
  return MEMORY[0x24BDE2068]();
}

uint64_t nw_protocol_upcast()
{
  return MEMORY[0x24BDE2070]();
}

uint64_t nw_protocol_updated_path()
{
  return MEMORY[0x24BDE2078]();
}

uint64_t nw_protocol_updated_path_is_valid()
{
  return MEMORY[0x24BDE2080]();
}

uint64_t nw_queue_activate_source()
{
  return MEMORY[0x24BDE2090]();
}

uint64_t nw_queue_cancel_source()
{
  return MEMORY[0x24BDE2098]();
}

uint64_t nw_queue_context_async()
{
  return MEMORY[0x24BDE20A0]();
}

uint64_t nw_queue_context_create_source()
{
  return MEMORY[0x24BDE20B0]();
}

uint64_t nw_queue_set_timer_values()
{
  return MEMORY[0x24BDE20C0]();
}

uint64_t nw_queue_source_set_qos_class_fallback()
{
  return MEMORY[0x24BDE20C8]();
}

void nw_release(void *obj)
{
  MEMORY[0x24BDE2380](obj);
}

void *__cdecl nw_retain(void *obj)
{
  return (void *)MEMORY[0x24BDE2498](obj);
}

uint64_t nw_tcp_create_metadata()
{
  return MEMORY[0x24BDE2500]();
}

uint64_t nw_tcp_options_get_connection_timeout()
{
  return MEMORY[0x24BDE2510]();
}

uint64_t nw_tcp_options_get_disable_ack_stretching()
{
  return MEMORY[0x24BDE2518]();
}

uint64_t nw_tcp_options_get_disable_blackhole_detection()
{
  return MEMORY[0x24BDE2520]();
}

uint64_t nw_tcp_options_get_enable_background_traffic_management()
{
  return MEMORY[0x24BDE2528]();
}

uint64_t nw_tcp_options_get_enable_fast_open()
{
  return MEMORY[0x24BDE2530]();
}

uint64_t nw_tcp_options_get_enable_keepalive()
{
  return MEMORY[0x24BDE2538]();
}

uint64_t nw_tcp_options_get_enable_l4s()
{
  return MEMORY[0x24BDE2540]();
}

uint64_t nw_tcp_options_get_fast_open_force_enable()
{
  return MEMORY[0x24BDE2548]();
}

uint64_t nw_tcp_options_get_keepalive_count()
{
  return MEMORY[0x24BDE2550]();
}

uint64_t nw_tcp_options_get_keepalive_idle_time()
{
  return MEMORY[0x24BDE2558]();
}

uint64_t nw_tcp_options_get_keepalive_interval()
{
  return MEMORY[0x24BDE2560]();
}

uint64_t nw_tcp_options_get_maximum_segment_size()
{
  return MEMORY[0x24BDE2568]();
}

uint64_t nw_tcp_options_get_no_delay()
{
  return MEMORY[0x24BDE2570]();
}

uint64_t nw_tcp_options_get_no_fast_open_cookie()
{
  return MEMORY[0x24BDE2578]();
}

uint64_t nw_tcp_options_get_no_options()
{
  return MEMORY[0x24BDE2580]();
}

uint64_t nw_tcp_options_get_no_push()
{
  return MEMORY[0x24BDE2588]();
}

uint64_t nw_tcp_options_get_no_timewait()
{
  return MEMORY[0x24BDE2590]();
}

uint64_t nw_tcp_options_get_persist_timeout()
{
  return MEMORY[0x24BDE2598]();
}

uint64_t nw_tcp_options_get_reduce_buffering()
{
  return MEMORY[0x24BDE25A0]();
}

uint64_t nw_tcp_options_get_retransmit_connection_drop_time()
{
  return MEMORY[0x24BDE25A8]();
}

uint64_t nw_tcp_options_get_retransmit_fin_drop()
{
  return MEMORY[0x24BDE25B0]();
}

uint64_t nw_tcp_set_callbacks()
{
  return MEMORY[0x24BDE25E8]();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

uint64_t os_nexus_flow_set_wake_from_sleep()
{
  return MEMORY[0x24BDAF3C8]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF460](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF488](lock);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x24BDAFF18](*(_QWORD *)&__errnum);
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x24BDB0308](uu1, uu2);
}

void uuid_generate(uuid_t out)
{
  MEMORY[0x24BDB0318](out);
}

