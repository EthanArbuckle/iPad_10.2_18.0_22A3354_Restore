__n128 ETLDebugRegisterDelegate(__n128 *a1)
{
  __n128 result;

  result = *a1;
  gDelegate = (__int128)*a1;
  return result;
}

uint64_t lz4_decode_fast(int8x16_t **a1, unint64_t a2, unint64_t a3, unsigned __int8 **a4, unint64_t a5)
{
  unsigned __int8 *v5;
  int8x16_t *v6;
  int8x16_t *v7;
  unsigned __int8 *v8;
  _OWORD *v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;
  int8x16_t *v14;
  int8x16_t *v15;
  unsigned __int16 *v16;
  int8x16_t *v17;
  int8x16_t *v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t *v21;
  int8x16_t v22;
  int8x16_t v23;
  unint64_t v24;
  unsigned int v25;
  int8x16_t *v26;
  int8x16_t *v27;
  unsigned int v28;
  int8x16_t *v29;
  int8x16_t v30;
  int8x16_t v31;
  uint64_t v32;
  int8x16_t *v33;
  int8x16_t *v34;
  int8x16_t *v35;
  int8x16_t v36;
  int8x16_t *v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t *v40;
  int8x16_t v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t v44;
  int8x16_t *v45;
  int8x16_t v46;
  uint64_t v47;

  v5 = *a4;
  v6 = *a1;
  while (1)
  {
    v7 = v6;
    v8 = v5;
    if ((unint64_t)v5 >= a5 || (unint64_t)v6 >= a3)
      break;
    v10 = *v5;
    v9 = v5 + 1;
    v11 = (unint64_t)v10 >> 4;
    v12 = (v10 & 0xF) + 4;
    if (v11 > 0xE)
    {
      while ((unint64_t)v9 < a5)
      {
        v13 = *(unsigned __int8 *)v9;
        v9 = (_OWORD *)((char *)v9 + 1);
        v11 += v13;
        if (v13 != 255)
        {
          v14 = (int8x16_t *)v9;
          v15 = v6;
          v16 = (unsigned __int16 *)((char *)v9 + v11);
          v17 = (int8x16_t *)((char *)v6 + v11);
          if ((unint64_t)v16 < a5 && (unint64_t)v17 < a3)
          {
            v19 = *v14;
            v20 = v14[1];
            v18 = v14 + 2;
            *v15 = v19;
            v15[1] = v20;
            v21 = v15 + 2;
            do
            {
              v22 = *v18;
              v23 = v18[1];
              v18 += 2;
              *v21 = v22;
              v21[1] = v23;
              v21 += 2;
            }
            while (v17 > v21);
            goto LABEL_13;
          }
          goto LABEL_34;
        }
      }
      break;
    }
    *v6 = *(int8x16_t *)v9;
    v16 = (unsigned __int16 *)((char *)v9 + v11);
    v17 = (int8x16_t *)((char *)v6 + v11);
LABEL_13:
    v25 = *v16;
    v5 = (unsigned __int8 *)(v16 + 1);
    v24 = v25;
    v26 = (int8x16_t *)((char *)v17 - v25);
    if ((unint64_t)v26 < a2)
    {
      v47 = -1;
      goto LABEL_35;
    }
    v27 = v17;
    v6 = (int8x16_t *)((char *)v17 + v12);
    if (v12 == 19)
    {
      while ((unint64_t)v5 < a5)
      {
        v28 = *v5++;
        v6 = (int8x16_t *)((char *)v6 + v28);
        if (v28 != 255)
        {
          if ((unint64_t)v6 >= a3)
            goto LABEL_34;
          goto LABEL_22;
        }
      }
      break;
    }
    if (v12 > 0x10)
    {
LABEL_22:
      if (v24 > 0x1F)
      {
        v36 = *v26;
        v35 = v26 + 1;
        *v27 = v36;
        v37 = v27 + 1;
        do
        {
          v38 = *v35;
          v39 = v35[1];
          v35 += 2;
          *v37 = v38;
          v37[1] = v39;
          v37 += 2;
        }
        while (v6 > v37);
      }
      else if (v24 > 0xF)
      {
        v41 = *v26;
        v40 = v26 + 1;
        *v27 = v41;
        v42 = v27 + 1;
        do
        {
          v44 = *v40;
          v43 = v40 + 1;
          *v42 = v44;
          v45 = v42 + 1;
          v46 = *v43;
          v40 = v43 + 1;
          *v45 = v46;
          v42 = v45 + 1;
        }
        while (v6 > v42);
      }
      else
      {
        v29 = (int8x16_t *)&qword_1DACD1A40[4 * v24];
        v30 = vqtbl1q_s8(*v26, *v29);
        v31 = vqtbl1q_s8(*v26, v29[1]);
        v32 = *((unsigned __int8 *)qword_1DACD1C40 + v24);
        *v27 = v30;
        v27[1] = v31;
        v33 = (int8x16_t *)((char *)v27 + v32);
        do
        {
          *v33 = v30;
          v33[1] = v31;
          v34 = (int8x16_t *)((char *)v33 + v32);
          *v34 = v30;
          v34[1] = v31;
          v33 = (int8x16_t *)((char *)v34 + v32);
        }
        while (v6 > v33);
      }
    }
    else if (v24 <= 0xF)
    {
      *v27 = vqtbl1q_s8(*v26, *(int8x16_t *)&qword_1DACD1A40[4 * v24]);
    }
    else
    {
      *v27 = *v26;
    }
  }
LABEL_34:
  v47 = 0;
LABEL_35:
  *a4 = v8;
  *a1 = v7;
  return v47;
}

uint64_t lz4_decode(char *__dst, unint64_t a2, unsigned __int8 *a3, unint64_t a4)
{
  char *v5;
  unint64_t v6;
  char *v8;
  uint64_t v9;
  unsigned __int8 *v10;
  char *v11;

  if (a2 < 0x100 || a4 <= 0xFF)
    return (int)LZ4_decompress_safe(a3, __dst, a4, a2);
  v10 = a3;
  v11 = __dst;
  v5 = &__dst[a2];
  v6 = (unint64_t)&a3[a4];
  if (lz4_decode_fast((int8x16_t **)&v11, (unint64_t)__dst, (unint64_t)&__dst[a2 - 128], &v10, (unint64_t)&a3[a4 - 128]))
  {
    return 0;
  }
  v8 = v11;
  v9 = lz4_decode_safe((void **)&v11, (unint64_t)__dst, v5, (unint64_t *)&v10, v6);
  if (v9)
    return v8 - __dst + v9;
  else
    return 0;
}

uint64_t LZ4_compressBound(unsigned int a1)
{
  if (a1 <= 0x7E000000)
    return a1 + a1 / 0xFF + 16;
  else
    return 0;
}

uint64_t LZ4_compress()
{
  uint64_t v0;
  int v1;
  int v2;
  _BYTE *v3;
  _BYTE *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  _DWORD *v10;
  unint64_t v11;
  int v12;
  unsigned int v13;
  _DWORD *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  int v29;
  _QWORD *v30;
  int v31;
  unsigned int v32;
  char v33;
  _DWORD *v34;
  _WORD *v35;
  uint64_t v36;
  _BYTE *v37;
  int v38;
  _DWORD *v39;
  unint64_t v40;
  char v41;
  BOOL v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  size_t v48;
  int v49;
  _BYTE *v50;
  int v51;
  unint64_t v52;
  unint64_t v54;
  _BYTE *v55;
  unint64_t v56;
  _DWORD *v57;
  unint64_t v58;
  int v59;
  unsigned int v60;
  _DWORD *v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  char v67;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  int v76;
  _QWORD *v77;
  int v78;
  unsigned int v79;
  char v80;
  _DWORD *v81;
  _WORD *v82;
  uint64_t v83;
  _BYTE *v84;
  int v85;
  _DWORD *v86;
  unint64_t v87;
  char v88;
  unsigned int v89;
  unsigned int v90;
  uint64_t v91;
  unsigned int v92;
  int v93;
  _BYTE *v94;
  int v95;
  unint64_t v96;
  void *v97;
  char v98;
  char v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  int v108;
  int v109;
  int v110;
  int v111;
  _WORD v112[8192];
  uint64_t v113;

  v0 = MEMORY[0x1E0C80A78]();
  v2 = v1;
  v4 = v3;
  v5 = v0;
  v113 = *MEMORY[0x1E0C80C00];
  bzero(v112, 0x4000uLL);
  if (v2 > 65546)
  {
    if (v2 <= 0x7E000000)
    {
      v109 = v2;
      v54 = v5 + v2;
      v55 = v4;
      v56 = v54 - 12;
      v57 = (_DWORD *)(v5 + 2);
      v103 = v54 - 8;
      v105 = v54 - 5;
      v107 = v54;
      v101 = v54 - 6;
      v111 = (int)v55;
      v7 = v5;
LABEL_65:
      v58 = v7 + 1;
      v59 = *(_DWORD *)(v7 + 1);
      v60 = 68;
      while (1)
      {
        v61 = v57;
        v62 = (-1640531535 * v59) >> 20;
        v59 = *v57;
        v63 = *(unsigned int *)&v112[2 * v62];
        *(_DWORD *)&v112[2 * v62] = v58 - v5;
        if (v5 + v63 + 0xFFFF >= v58 && *(_DWORD *)(v5 + v63) == *(_DWORD *)v58)
          break;
        v64 = v60++ >> 6;
        v57 = (_DWORD *)((char *)v57 + v64);
        v58 = (unint64_t)v61;
        if ((unint64_t)v57 > v56)
          goto LABEL_115;
      }
      v65 = 0;
      v66 = v58 - v7;
      v67 = v58 - v7 - 14;
      v68 = (v58 << 32) - (v7 << 32);
      v69 = v58 - v7 - 15;
      do
      {
        v70 = v69;
        v71 = v65;
        v72 = v68;
        v73 = v58 + v65;
        v74 = v5 + v63 + v65;
        if (v73 <= v7 || v74 <= v5)
          break;
        v76 = *(unsigned __int8 *)(v74 - 1);
        --v69;
        v65 = v71 - 1;
        v68 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v73 - 1) == v76);
      v77 = v55 + 1;
      if (v66 + (int)v71 < 15)
      {
        *v55 = 16 * (v73 - v7);
      }
      else
      {
        *v55 = -16;
        if ((v66 + v71) <= 0x10D)
        {
          v80 = v71 + v58 - v7 - 15;
        }
        else
        {
          if (v70 >= 509)
            v78 = 509;
          else
            v78 = v70;
          v79 = v66 - v78 + v71 + 239;
          v99 = v67;
          memset(v77, 255, v79 / 0xFF + 1);
          v77 = &v55[v79 / 0xFFuLL + 2];
          v80 = v79 / 0xFF + v99 + v71;
        }
        *(_BYTE *)v77 = v80;
        v77 = (_QWORD *)((char *)v77 + 1);
      }
      v81 = (_DWORD *)(v5 + v63 + v71);
      v82 = (_WORD *)((char *)v77 + (v72 >> 32));
      do
      {
        v83 = *(_QWORD *)v7;
        v7 += 8;
        *v77++ = v83;
      }
      while (v77 < (_QWORD *)v82);
      while (1)
      {
        v84 = v55;
        *v82 = v73 - (_WORD)v81;
        v55 = v82 + 1;
        v85 = v73 + 4;
        v86 = v81 + 1;
        v7 = v73 + 4;
        if (v73 + 4 >= v56)
        {
LABEL_93:
          if (v7 < v103 && *v86 == *(_DWORD *)v7)
          {
            v7 += 4;
            ++v86;
          }
          if (v7 < v101 && *(unsigned __int16 *)v86 == *(unsigned __int16 *)v7)
          {
            v7 += 2;
            v86 = (_DWORD *)((char *)v86 + 2);
          }
          if (v7 < v105 && *(unsigned __int8 *)v86 == *(unsigned __int8 *)v7)
            ++v7;
        }
        else
        {
          while (1)
          {
            v87 = *(_QWORD *)v7 ^ *(_QWORD *)v86;
            if (v87)
              break;
            v7 += 8;
            v86 += 2;
            if (v7 >= v56)
              goto LABEL_93;
          }
          v7 += __clz(__rbit64(v87)) >> 3;
        }
        v88 = v7 - v85;
        v42 = __OFSUB__(v7 - v85, 15);
        v89 = v7 - v85 - 15;
        if (((v89 & 0x80000000) != 0) != v42)
        {
          *v84 += v88;
        }
        else
        {
          *v84 += 15;
          if (v89 >= 0x1FE)
          {
            v90 = v7 - v73 - 529;
            v91 = v90 / 0x1FE;
            memset(v82 + 1, 255, v91 * 2 + 2);
            v89 = v90 % 0x1FE;
            v55 = &v82[v91 + 2];
          }
          if (v89 >= 0xFF)
          {
            *v55++ = -1;
            LOBYTE(v89) = v89 + 1;
          }
          *v55++ = v89;
        }
        if (v7 > v56)
          break;
        *(_DWORD *)&v112[2 * ((-1640531535 * *(_DWORD *)(v7 - 2)) >> 20)] = v7 - 2 - v5;
        v92 = (-1640531535 * *(_DWORD *)v7) >> 20;
        v81 = (_DWORD *)(v5 + *(unsigned int *)&v112[2 * v92]);
        *(_DWORD *)&v112[2 * v92] = v7 - v5;
        if ((unint64_t)v81 + 0xFFFF < v7 || *v81 != *(_DWORD *)v7)
        {
          v57 = (_DWORD *)(v7 + 2);
          if (v7 + 2 <= v56)
            goto LABEL_65;
          break;
        }
        *v55 = 0;
        v82 = v55 + 1;
        v73 = v7;
      }
LABEL_115:
      v48 = v107 - v7;
      v93 = v107 - v7 - 15;
      LODWORD(v4) = v111;
      if ((int)v107 - (int)v7 < 15)
      {
        *v55 = 16 * v48;
      }
      else
      {
        *v55 = -16;
        v94 = v55 + 1;
        if (v48 >= 0x10E)
        {
          v95 = v5 + v109;
          if (v93 >= 509)
            v93 = 509;
          v96 = (v95 - (v93 + v7) + 239) / 0xFFuLL;
          memset(v94, 255, v96 + 1);
          LOBYTE(v93) = v95 - v7 + v96 - 14;
          v94 = &v55[v96 + 2];
        }
        *v94 = v93;
        v55 = v94;
      }
      v97 = v55 + 1;
      goto LABEL_125;
    }
    return 0;
  }
  if (v2 > 0x7E000000)
    return 0;
  v6 = v5 + v2;
  v7 = v5;
  v8 = v4;
  if (v2 >= 0xE)
  {
    v108 = v2;
    v8 = v4;
    v9 = v6 - 12;
    v10 = (_DWORD *)(v5 + 2);
    v102 = v6 - 8;
    v104 = v6 - 5;
    v106 = v5 + v2;
    v100 = v6 - 6;
    v110 = (int)v8;
    v7 = v5;
LABEL_5:
    v11 = v7 + 1;
    v12 = *(_DWORD *)(v7 + 1);
    v13 = 68;
    while (1)
    {
      v14 = v10;
      v15 = (-1640531535 * v12) >> 19;
      v12 = *v10;
      v16 = (unsigned __int16)v112[v15];
      v112[v15] = v11 - v5;
      if (v5 + v16 + 0xFFFF >= v11 && *(_DWORD *)(v5 + v16) == *(_DWORD *)v11)
        break;
      v17 = v13++ >> 6;
      v10 = (_DWORD *)((char *)v10 + v17);
      v11 = (unint64_t)v14;
      if ((unint64_t)v10 > v9)
        goto LABEL_55;
    }
    v18 = 0;
    v19 = v11 - v7;
    v20 = v11 - v7 - 14;
    v21 = (v11 << 32) - (v7 << 32);
    v22 = v11 - v7 - 15;
    do
    {
      v23 = v22;
      v24 = v18;
      v25 = v21;
      v26 = v11 + v18;
      v27 = v5 + v16 + v18;
      if (v26 <= v7 || v27 <= v5)
        break;
      v29 = *(unsigned __int8 *)(v27 - 1);
      --v22;
      v18 = v24 - 1;
      v21 -= 0x100000000;
    }
    while (*(unsigned __int8 *)(v26 - 1) == v29);
    v30 = v8 + 1;
    if (v19 + (int)v24 < 15)
    {
      *v8 = 16 * (v26 - v7);
    }
    else
    {
      *v8 = -16;
      if ((v19 + v24) <= 0x10D)
      {
        v33 = v24 + v11 - v7 - 15;
      }
      else
      {
        if (v23 >= 509)
          v31 = 509;
        else
          v31 = v23;
        v32 = v19 - v31 + v24 + 239;
        v98 = v20;
        memset(v30, 255, v32 / 0xFF + 1);
        v30 = &v8[v32 / 0xFFuLL + 2];
        v33 = v32 / 0xFF + v98 + v24;
      }
      *(_BYTE *)v30 = v33;
      v30 = (_QWORD *)((char *)v30 + 1);
    }
    v34 = (_DWORD *)(v5 + v16 + v24);
    v35 = (_WORD *)((char *)v30 + (v25 >> 32));
    do
    {
      v36 = *(_QWORD *)v7;
      v7 += 8;
      *v30++ = v36;
    }
    while (v30 < (_QWORD *)v35);
    while (1)
    {
      v37 = v8;
      *v35 = v26 - (_WORD)v34;
      v8 = v35 + 1;
      v38 = v26 + 4;
      v39 = v34 + 1;
      v7 = v26 + 4;
      if (v26 + 4 >= v9)
      {
LABEL_33:
        if (v7 < v102 && *v39 == *(_DWORD *)v7)
        {
          v7 += 4;
          ++v39;
        }
        if (v7 < v100 && *(unsigned __int16 *)v39 == *(unsigned __int16 *)v7)
        {
          v7 += 2;
          v39 = (_DWORD *)((char *)v39 + 2);
        }
        if (v7 < v104 && *(unsigned __int8 *)v39 == *(unsigned __int8 *)v7)
          ++v7;
      }
      else
      {
        while (1)
        {
          v40 = *(_QWORD *)v7 ^ *(_QWORD *)v39;
          if (v40)
            break;
          v7 += 8;
          v39 += 2;
          if (v7 >= v9)
            goto LABEL_33;
        }
        v7 += __clz(__rbit64(v40)) >> 3;
      }
      v41 = v7 - v38;
      v42 = __OFSUB__(v7 - v38, 15);
      v43 = v7 - v38 - 15;
      if (((v43 & 0x80000000) != 0) != v42)
      {
        *v37 += v41;
      }
      else
      {
        *v37 += 15;
        if (v43 >= 0x1FE)
        {
          v44 = v7 - v26 - 529;
          v45 = v44 / 0x1FE;
          memset(v35 + 1, 255, v45 * 2 + 2);
          v43 = v44 % 0x1FE;
          v8 = &v35[v45 + 2];
        }
        if (v43 >= 0xFF)
        {
          *v8++ = -1;
          LOBYTE(v43) = v43 + 1;
        }
        *v8++ = v43;
      }
      if (v7 > v9)
        break;
      v112[(-1640531535 * *(_DWORD *)(v7 - 2)) >> 19] = v7 - 2 - v5;
      v46 = *(_DWORD *)v7;
      v47 = (-1640531535 * *(_DWORD *)v7) >> 19;
      v34 = (_DWORD *)(v5 + (unsigned __int16)v112[v47]);
      v112[v47] = v7 - v5;
      if ((unint64_t)v34 + 0xFFFF < v7 || *v34 != v46)
      {
        v10 = (_DWORD *)(v7 + 2);
        if (v7 + 2 <= v9)
          goto LABEL_5;
        break;
      }
      *v8 = 0;
      v35 = v8 + 1;
      v26 = v7;
    }
LABEL_55:
    LODWORD(v4) = v110;
    v2 = v108;
    v6 = v106;
  }
  v48 = v6 - v7;
  v42 = __OFSUB__(v6 - v7, 15);
  v49 = v6 - v7 - 15;
  if (v49 < 0 != v42)
  {
    *v8 = 16 * v48;
  }
  else
  {
    *v8 = -16;
    v50 = v8 + 1;
    if (v48 >= 0x10E)
    {
      v51 = v5 + v2;
      if (v49 >= 509)
        v49 = 509;
      v52 = (v51 - (v49 + v7) + 239) / 0xFFuLL;
      memset(v50, 255, v52 + 1);
      LOBYTE(v49) = v51 - v7 + v52 - 14;
      v50 = &v8[v52 + 2];
    }
    *v50 = v49;
    v8 = v50;
  }
  v97 = v8 + 1;
LABEL_125:
  memcpy(v97, (const void *)v7, v48);
  return ((_DWORD)v97 + v48 - (_DWORD)v4);
}

uint64_t LZ4_compress_limitedOutput()
{
  uint64_t v0;
  unsigned int v1;
  unsigned int v2;
  int v3;
  int v4;
  _BYTE *v5;
  _BYTE *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _BYTE *v11;
  unint64_t v12;
  _DWORD *v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  _DWORD *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  char v23;
  char v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  int v33;
  int v34;
  _QWORD *v35;
  int v36;
  unsigned int v37;
  char v38;
  _DWORD *v39;
  _WORD *v40;
  uint64_t v41;
  _BYTE *v42;
  int v43;
  _DWORD *v44;
  unint64_t v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  int v50;
  unsigned int v51;
  size_t v52;
  int v53;
  _BYTE *v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  _DWORD *v59;
  unint64_t v60;
  unint64_t v61;
  int v62;
  unsigned int v63;
  _DWORD *v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  char v70;
  char v71;
  uint64_t v72;
  int v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  int v80;
  int v81;
  _QWORD *v82;
  int v83;
  unsigned int v84;
  char v85;
  _DWORD *v86;
  _WORD *v87;
  uint64_t v88;
  _BYTE *v89;
  int v90;
  _DWORD *v91;
  unint64_t v92;
  int v93;
  unsigned int v94;
  unsigned int v95;
  uint64_t v96;
  unsigned int v97;
  size_t v98;
  int v100;
  _BYTE *v101;
  int v102;
  unint64_t v103;
  char v104;
  char v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  int v114;
  int v115;
  unsigned int v116;
  _BYTE *v117;
  unint64_t v118;
  _WORD v119[8192];
  uint64_t v120;

  v0 = MEMORY[0x1E0C80A78]();
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v7 = v0;
  v120 = *MEMORY[0x1E0C80C00];
  bzero(v119, 0x4000uLL);
  v8 = (unint64_t)&v6[v2];
  v118 = v8;
  if (v4 <= 65546)
  {
    if (v4 <= 0x7E000000)
    {
      v9 = v7 + v4;
      v10 = v7;
      v11 = v6;
      if (v4 >= 0xE)
      {
        v114 = v4;
        v116 = v2;
        v12 = v9 - 12;
        v13 = (_DWORD *)(v7 + 2);
        v108 = v9 - 8;
        v110 = v9 - 5;
        v112 = v7 + v4;
        v106 = v9 - 6;
        v11 = v6;
        v10 = v7;
LABEL_5:
        v14 = v10 + 1;
        v15 = *(_DWORD *)(v10 + 1);
        v16 = 68;
        while (1)
        {
          v17 = v13;
          v18 = (-1640531535 * v15) >> 19;
          v15 = *v13;
          v19 = (unsigned __int16)v119[v18];
          v119[v18] = v14 - v7;
          if (v7 + v19 + 0xFFFF >= v14 && *(_DWORD *)(v7 + v19) == *(_DWORD *)v14)
            break;
          v20 = v16++ >> 6;
          v13 = (_DWORD *)((char *)v13 + v20);
          v14 = (unint64_t)v17;
          if ((unint64_t)v13 > v12)
          {
LABEL_57:
            v4 = v114;
            v2 = v116;
            v9 = v112;
            goto LABEL_58;
          }
        }
        v21 = 0;
        v22 = v14 - v10;
        v23 = v14 - v10 - 15;
        v24 = v14 - v10 - 14;
        v25 = (v14 << 32) - (v10 << 32);
        v26 = v14 - v10 - 15;
        do
        {
          v27 = v26;
          v28 = v21;
          v29 = v25;
          v30 = v14 + v21;
          v31 = v7 + v19 + v21;
          if (v30 <= v10 || v31 <= v7)
            break;
          v33 = *(unsigned __int8 *)(v31 - 1);
          --v26;
          v21 = v28 - 1;
          v25 -= 0x100000000;
        }
        while (*(unsigned __int8 *)(v30 - 1) == v33);
        v34 = v22 + v28;
        v35 = v11 + 1;
        if ((unint64_t)&v11[(v29 >> 32) + 9 + (v22 + (int)v28) / 255] <= v8)
        {
          if (v34 < 15)
          {
            *v11 = 16 * (v30 - v10);
          }
          else
          {
            *v11 = -16;
            if (v34 <= 0x10D)
            {
              v38 = v28 + v23;
            }
            else
            {
              if (v27 >= 509)
                v36 = 509;
              else
                v36 = v27;
              v37 = v22 - v36 + v28 + 239;
              v104 = v24;
              memset(v35, 255, v37 / 0xFF + 1);
              v8 = v118;
              v35 = &v11[v37 / 0xFFuLL + 2];
              v38 = v37 / 0xFF + v104 + v28;
            }
            *(_BYTE *)v35 = v38;
            v35 = (_QWORD *)((char *)v35 + 1);
          }
          v39 = (_DWORD *)(v7 + v19 + v28);
          v40 = (_WORD *)((char *)v35 + (v29 >> 32));
          do
          {
            v41 = *(_QWORD *)v10;
            v10 += 8;
            *v35++ = v41;
          }
          while (v35 < (_QWORD *)v40);
          while (1)
          {
            v42 = v11;
            *v40 = v30 - (_WORD)v39;
            v11 = v40 + 1;
            v43 = v30 + 4;
            v44 = v39 + 1;
            v10 = v30 + 4;
            if (v30 + 4 >= v12)
            {
LABEL_34:
              if (v10 < v108 && *v44 == *(_DWORD *)v10)
              {
                v10 += 4;
                ++v44;
              }
              if (v10 < v106 && *(unsigned __int16 *)v44 == *(unsigned __int16 *)v10)
              {
                v10 += 2;
                v44 = (_DWORD *)((char *)v44 + 2);
              }
              if (v10 < v110 && *(unsigned __int8 *)v44 == *(unsigned __int8 *)v10)
                ++v10;
            }
            else
            {
              while (1)
              {
                v45 = *(_QWORD *)v10 ^ *(_QWORD *)v44;
                if (v45)
                  break;
                v10 += 8;
                v44 += 2;
                if (v10 >= v12)
                  goto LABEL_34;
              }
              v10 += __clz(__rbit64(v45)) >> 3;
            }
            v46 = v10 - v43;
            if ((unint64_t)v40 + (((int)v10 - v43) >> 8) + 8 > v8)
              break;
            v47 = v46 - 15;
            if (v46 < 15)
            {
              *v42 += v46;
            }
            else
            {
              *v42 += 15;
              if (v47 >= 0x1FE)
              {
                v48 = v10 - v30 - 529;
                v49 = v48 / 0x1FE;
                memset(v40 + 1, 255, v49 * 2 + 2);
                v8 = v118;
                v47 = v48 % 0x1FE;
                v11 = &v40[v49 + 2];
              }
              if (v47 >= 0xFF)
              {
                *v11++ = -1;
                LOBYTE(v47) = v47 + 1;
              }
              *v11++ = v47;
            }
            if (v10 > v12)
              goto LABEL_57;
            v119[(-1640531535 * *(_DWORD *)(v10 - 2)) >> 19] = v10 - 2 - v7;
            v50 = *(_DWORD *)v10;
            v51 = (-1640531535 * *(_DWORD *)v10) >> 19;
            v39 = (_DWORD *)(v7 + (unsigned __int16)v119[v51]);
            v119[v51] = v10 - v7;
            if ((unint64_t)v39 + 0xFFFF < v10 || *v39 != v50)
            {
              v13 = (_DWORD *)(v10 + 2);
              if (v10 + 2 <= v12)
                goto LABEL_5;
              goto LABEL_57;
            }
            *v11 = 0;
            v40 = v11 + 1;
            v30 = v10;
          }
        }
        return 0;
      }
LABEL_58:
      v52 = v9 - v10;
      if ((uint64_t)(v11 - v6 + (int)v9 - (int)v10 + (v9 - v10 + 240) / 0xFFuLL + 1) <= v2)
      {
        v53 = v52 - 15;
        if ((int)v52 < 15)
        {
          *v11 = 16 * v52;
        }
        else
        {
          *v11 = -16;
          v54 = v11 + 1;
          if (v52 >= 0x10E)
          {
            v55 = v7 + v4;
            if (v53 >= 509)
              v53 = 509;
            v56 = (v55 - (v53 + v10) + 239) / 0xFFuLL;
            memset(v54, 255, v56 + 1);
            LOBYTE(v53) = v55 - v10 + v56 - 14;
            v54 = &v11[v56 + 2];
          }
          *v54 = v53;
          v11 = v54;
        }
        memcpy(v11 + 1, (const void *)v10, v52);
        return ((_DWORD)v11 + 1 + v52 - (_DWORD)v6);
      }
    }
    return 0;
  }
  if (v4 > 0x7E000000)
    return 0;
  v115 = v4;
  v57 = v7 + v4;
  v58 = v57 - 12;
  v59 = (_DWORD *)(v7 + 2);
  v109 = v57 - 8;
  v111 = v57 - 5;
  v113 = v57;
  v107 = v57 - 6;
  v117 = v6;
  v60 = v7;
LABEL_67:
  v61 = v60 + 1;
  v62 = *(_DWORD *)(v60 + 1);
  v63 = 68;
  do
  {
    v64 = v59;
    v65 = (-1640531535 * v62) >> 20;
    v62 = *v59;
    v66 = *(unsigned int *)&v119[2 * v65];
    *(_DWORD *)&v119[2 * v65] = v61 - v7;
    if (v7 + v66 + 0xFFFF >= v61 && *(_DWORD *)(v7 + v66) == *(_DWORD *)v61)
    {
      v68 = 0;
      v69 = v61 - v60;
      v70 = v61 - v60 - 15;
      v71 = v61 - v60 - 14;
      v72 = (v61 << 32) - (v60 << 32);
      v73 = v61 - v60 - 15;
      do
      {
        v74 = v73;
        v75 = v68;
        v76 = v72;
        v77 = v61 + v68;
        v78 = v7 + v66 + v68;
        if (v77 <= v60 || v78 <= v7)
          break;
        v80 = *(unsigned __int8 *)(v78 - 1);
        --v73;
        v68 = v75 - 1;
        v72 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v77 - 1) == v80);
      v81 = v69 + v75;
      v82 = v6 + 1;
      if ((unint64_t)&v6[(v76 >> 32) + 9 + (v69 + (int)v75) / 255] <= v8)
      {
        if (v81 < 15)
        {
          *v6 = 16 * (v77 - v60);
        }
        else
        {
          *v6 = -16;
          if (v81 <= 0x10D)
          {
            v85 = v75 + v70;
          }
          else
          {
            if (v74 >= 509)
              v83 = 509;
            else
              v83 = v74;
            v84 = v69 - v83 + v75 + 239;
            v105 = v71;
            memset(v82, 255, v84 / 0xFF + 1);
            v8 = v118;
            v82 = &v6[v84 / 0xFFuLL + 2];
            v85 = v84 / 0xFF + v105 + v75;
          }
          *(_BYTE *)v82 = v85;
          v82 = (_QWORD *)((char *)v82 + 1);
        }
        v86 = (_DWORD *)(v7 + v66 + v75);
        v87 = (_WORD *)((char *)v82 + (v76 >> 32));
        do
        {
          v88 = *(_QWORD *)v60;
          v60 += 8;
          *v82++ = v88;
        }
        while (v82 < (_QWORD *)v87);
        while (1)
        {
          v89 = v6;
          *v87 = v77 - (_WORD)v86;
          v6 = v87 + 1;
          v90 = v77 + 4;
          v91 = v86 + 1;
          v60 = v77 + 4;
          if (v77 + 4 >= v58)
          {
LABEL_96:
            if (v60 < v109 && *v91 == *(_DWORD *)v60)
            {
              v60 += 4;
              ++v91;
            }
            if (v60 < v107 && *(unsigned __int16 *)v91 == *(unsigned __int16 *)v60)
            {
              v60 += 2;
              v91 = (_DWORD *)((char *)v91 + 2);
            }
            if (v60 < v111 && *(unsigned __int8 *)v91 == *(unsigned __int8 *)v60)
              ++v60;
          }
          else
          {
            while (1)
            {
              v92 = *(_QWORD *)v60 ^ *(_QWORD *)v91;
              if (v92)
                break;
              v60 += 8;
              v91 += 2;
              if (v60 >= v58)
                goto LABEL_96;
            }
            v60 += __clz(__rbit64(v92)) >> 3;
          }
          v93 = v60 - v90;
          if ((unint64_t)v87 + (((int)v60 - v90) >> 8) + 8 > v8)
            break;
          v94 = v93 - 15;
          if (v93 < 15)
          {
            *v89 += v93;
          }
          else
          {
            *v89 += 15;
            if (v94 >= 0x1FE)
            {
              v95 = v60 - v77 - 529;
              v96 = v95 / 0x1FE;
              memset(v87 + 1, 255, v96 * 2 + 2);
              v8 = v118;
              v94 = v95 % 0x1FE;
              v6 = &v87[v96 + 2];
            }
            if (v94 >= 0xFF)
            {
              *v6++ = -1;
              LOBYTE(v94) = v94 + 1;
            }
            *v6++ = v94;
          }
          if (v60 > v58)
            goto LABEL_119;
          *(_DWORD *)&v119[2 * ((-1640531535 * *(_DWORD *)(v60 - 2)) >> 20)] = v60 - 2 - v7;
          v97 = (-1640531535 * *(_DWORD *)v60) >> 20;
          v86 = (_DWORD *)(v7 + *(unsigned int *)&v119[2 * v97]);
          *(_DWORD *)&v119[2 * v97] = v60 - v7;
          if ((unint64_t)v86 + 0xFFFF < v60 || *v86 != *(_DWORD *)v60)
          {
            v59 = (_DWORD *)(v60 + 2);
            if (v60 + 2 <= v58)
              goto LABEL_67;
            goto LABEL_119;
          }
          *v6 = 0;
          v87 = v6 + 1;
          v77 = v60;
        }
      }
      return 0;
    }
    v67 = v63++ >> 6;
    v59 = (_DWORD *)((char *)v59 + v67);
    v61 = (unint64_t)v64;
  }
  while ((unint64_t)v59 <= v58);
LABEL_119:
  v98 = v113 - v60;
  if ((uint64_t)(v6 - v117 + (int)v113 - (int)v60 + (v113 - v60 + 240) / 0xFFuLL + 1) > v2)
    return 0;
  v100 = v98 - 15;
  if ((int)v98 < 15)
  {
    *v6 = 16 * v98;
  }
  else
  {
    *v6 = -16;
    v101 = v6 + 1;
    if (v98 >= 0x10E)
    {
      v102 = v7 + v115;
      if (v100 >= 509)
        v100 = 509;
      v103 = (v102 - (v100 + v60) + 239) / 0xFFuLL;
      memset(v101, 255, v103 + 1);
      LOBYTE(v100) = v102 - v60 + v103 - 14;
      v101 = &v6[v103 + 2];
    }
    *v101 = v100;
    v6 = v101;
  }
  memcpy(v6 + 1, (const void *)v60, v98);
  return ((_DWORD)v6 + 1 + v98 - (_DWORD)v117);
}

uint64_t LZ4_sizeofState()
{
  return 0x4000;
}

uint64_t LZ4_compress_withState(unsigned int *a1, _DWORD *a2, _BYTE *a3, int a4)
{
  char *v9;
  unint64_t v10;
  _BYTE *v11;
  unint64_t v12;
  _DWORD *v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  _DWORD *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  char v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  int v32;
  _QWORD *v33;
  int v34;
  unsigned int v35;
  char v36;
  _DWORD *v37;
  _WORD *v38;
  uint64_t v39;
  _BYTE *v40;
  int v41;
  _DWORD *v42;
  unint64_t v43;
  char v44;
  BOOL v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  int v49;
  unsigned int v50;
  size_t v51;
  int v52;
  _BYTE *v53;
  int v54;
  unint64_t v55;
  char *v56;
  unint64_t v57;
  _DWORD *v58;
  _BYTE *v59;
  unint64_t v60;
  int v61;
  unsigned int v62;
  _DWORD *v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  char v69;
  uint64_t v70;
  int v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  int v78;
  _QWORD *v79;
  int v80;
  unsigned int v81;
  char v82;
  _DWORD *v83;
  _WORD *v84;
  uint64_t v85;
  _BYTE *v86;
  int v87;
  _DWORD *v88;
  unint64_t v89;
  char v90;
  unsigned int v91;
  unsigned int v92;
  uint64_t v93;
  unsigned int v94;
  int v95;
  _BYTE *v96;
  int v97;
  unint64_t v98;
  void *v99;
  char v100;
  char v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  char *v108;
  char *v109;
  int v110;
  int v111;
  int v112;
  int v113;

  if ((a1 & 3) != 0)
    return 0;
  bzero(a1, 0x4000uLL);
  if (a4 > 65546)
  {
    if (a4 <= 0x7E000000)
    {
      v111 = a4;
      v56 = (char *)a2 + a4;
      v57 = (unint64_t)(v56 - 12);
      v58 = (_DWORD *)((char *)a2 + 2);
      a1[(-1640531535 * *a2) >> 20] = 0;
      v105 = (unint64_t)(v56 - 8);
      v107 = (unint64_t)(v56 - 5);
      v109 = v56;
      v103 = (unint64_t)(v56 - 6);
      v113 = (int)a3;
      v59 = a3;
      v10 = (unint64_t)a2;
LABEL_68:
      v60 = v10 + 1;
      v61 = *(_DWORD *)(v10 + 1);
      v62 = 68;
      while (1)
      {
        v63 = v58;
        v64 = (-1640531535 * v61) >> 20;
        v61 = *v58;
        v65 = a1[v64];
        a1[v64] = v60 - (_DWORD)a2;
        if ((unint64_t)a2 + v65 + 0xFFFF >= v60 && *(_DWORD *)((char *)a2 + v65) == *(_DWORD *)v60)
          break;
        v66 = v62++ >> 6;
        v58 = (_DWORD *)((char *)v58 + v66);
        v60 = (unint64_t)v63;
        if ((unint64_t)v58 > v57)
          goto LABEL_118;
      }
      v67 = 0;
      v68 = v60 - v10;
      v69 = v60 - v10 - 14;
      v70 = (v60 << 32) - (v10 << 32);
      v71 = v60 - v10 - 15;
      do
      {
        v72 = v71;
        v73 = v67;
        v74 = v70;
        v75 = v60 + v67;
        v76 = (char *)a2 + v65 + v67;
        if (v75 <= v10 || v76 <= (char *)a2)
          break;
        v78 = *(v76 - 1);
        --v71;
        v67 = v73 - 1;
        v70 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v75 - 1) == v78);
      v79 = v59 + 1;
      if (v68 + (int)v73 < 15)
      {
        *v59 = 16 * (v75 - v10);
      }
      else
      {
        *v59 = -16;
        if ((v68 + v73) <= 0x10D)
        {
          v82 = v73 + v60 - v10 - 15;
        }
        else
        {
          if (v72 >= 509)
            v80 = 509;
          else
            v80 = v72;
          v81 = v68 - v80 + v73 + 239;
          v101 = v69;
          memset(v79, 255, v81 / 0xFF + 1);
          v79 = &v59[v81 / 0xFFuLL + 2];
          v82 = v81 / 0xFF + v101 + v73;
        }
        *(_BYTE *)v79 = v82;
        v79 = (_QWORD *)((char *)v79 + 1);
      }
      v83 = (_DWORD *)((char *)a2 + v65 + v73);
      v84 = (_WORD *)((char *)v79 + (v74 >> 32));
      do
      {
        v85 = *(_QWORD *)v10;
        v10 += 8;
        *v79++ = v85;
      }
      while (v79 < (_QWORD *)v84);
      while (1)
      {
        v86 = v59;
        *v84 = v75 - (_WORD)v83;
        v59 = v84 + 1;
        v87 = v75 + 4;
        v88 = v83 + 1;
        v10 = v75 + 4;
        if (v75 + 4 >= v57)
        {
LABEL_96:
          if (v10 < v105 && *v88 == *(_DWORD *)v10)
          {
            v10 += 4;
            ++v88;
          }
          if (v10 < v103 && *(unsigned __int16 *)v88 == *(unsigned __int16 *)v10)
          {
            v10 += 2;
            v88 = (_DWORD *)((char *)v88 + 2);
          }
          if (v10 < v107 && *(unsigned __int8 *)v88 == *(unsigned __int8 *)v10)
            ++v10;
        }
        else
        {
          while (1)
          {
            v89 = *(_QWORD *)v10 ^ *(_QWORD *)v88;
            if (v89)
              break;
            v10 += 8;
            v88 += 2;
            if (v10 >= v57)
              goto LABEL_96;
          }
          v10 += __clz(__rbit64(v89)) >> 3;
        }
        v90 = v10 - v87;
        v45 = __OFSUB__(v10 - v87, 15);
        v91 = v10 - v87 - 15;
        if (((v91 & 0x80000000) != 0) != v45)
        {
          *v86 += v90;
        }
        else
        {
          *v86 += 15;
          if (v91 >= 0x1FE)
          {
            v92 = v10 - v75 - 529;
            v93 = v92 / 0x1FE;
            memset(v84 + 1, 255, v93 * 2 + 2);
            v91 = v92 % 0x1FE;
            v59 = &v84[v93 + 2];
          }
          if (v91 >= 0xFF)
          {
            *v59++ = -1;
            LOBYTE(v91) = v91 + 1;
          }
          *v59++ = v91;
        }
        if (v10 > v57)
          break;
        a1[(-1640531535 * *(_DWORD *)(v10 - 2)) >> 20] = v10 - 2 - (_DWORD)a2;
        v94 = (-1640531535 * *(_DWORD *)v10) >> 20;
        v83 = (_DWORD *)((char *)a2 + a1[v94]);
        a1[v94] = v10 - (_DWORD)a2;
        if ((unint64_t)v83 + 0xFFFF < v10 || *v83 != *(_DWORD *)v10)
        {
          v58 = (_DWORD *)(v10 + 2);
          if (v10 + 2 <= v57)
            goto LABEL_68;
          break;
        }
        *v59 = 0;
        v84 = v59 + 1;
        v75 = v10;
      }
LABEL_118:
      v51 = (size_t)&v109[-v10];
      v95 = (_DWORD)v109 - v10 - 15;
      LODWORD(a3) = v113;
      if ((int)v109 - (int)v10 < 15)
      {
        *v59 = 16 * v51;
      }
      else
      {
        *v59 = -16;
        v96 = v59 + 1;
        if (v51 >= 0x10E)
        {
          v97 = (_DWORD)a2 + v111;
          if (v95 >= 509)
            v95 = 509;
          v98 = (v97 - (v95 + v10) + 239) / 0xFFuLL;
          memset(v96, 255, v98 + 1);
          LOBYTE(v95) = v97 - v10 + v98 - 14;
          v96 = &v59[v98 + 2];
        }
        *v96 = v95;
        v59 = v96;
      }
      v99 = v59 + 1;
      goto LABEL_128;
    }
    return 0;
  }
  if (a4 > 0x7E000000)
    return 0;
  v9 = (char *)a2 + a4;
  v10 = (unint64_t)a2;
  v11 = a3;
  if (a4 >= 0xD)
  {
    v112 = (int)a3;
    *((_WORD *)a1 + ((-1640531535 * *a2) >> 19)) = 0;
    v110 = a4;
    if (a4 == 13)
    {
      v10 = (unint64_t)a2;
      v11 = a3;
      a4 = 13;
    }
    else
    {
      v12 = (unint64_t)(v9 - 12);
      v13 = (_DWORD *)((char *)a2 + 2);
      v104 = (unint64_t)(v9 - 8);
      v106 = (unint64_t)(v9 - 5);
      v108 = (char *)a2 + a4;
      v102 = (unint64_t)(v9 - 6);
      v11 = a3;
      v10 = (unint64_t)a2;
LABEL_8:
      v14 = v10 + 1;
      v15 = *(_DWORD *)(v10 + 1);
      v16 = 68;
      while (1)
      {
        v17 = v13;
        v18 = (-1640531535 * v15) >> 19;
        v15 = *v13;
        v19 = *((unsigned __int16 *)a1 + v18);
        *((_WORD *)a1 + v18) = v14 - (_WORD)a2;
        if ((unint64_t)a2 + v19 + 0xFFFF >= v14 && *(_DWORD *)((char *)a2 + v19) == *(_DWORD *)v14)
          break;
        v20 = v16++ >> 6;
        v13 = (_DWORD *)((char *)v13 + v20);
        v14 = (unint64_t)v17;
        if ((unint64_t)v13 > v12)
          goto LABEL_58;
      }
      v21 = 0;
      v22 = v14 - v10;
      v23 = v14 - v10 - 14;
      v24 = (v14 << 32) - (v10 << 32);
      v25 = v14 - v10 - 15;
      do
      {
        v26 = v25;
        v27 = v21;
        v28 = v24;
        v29 = v14 + v21;
        v30 = (char *)a2 + v19 + v21;
        if (v29 <= v10 || v30 <= (char *)a2)
          break;
        v32 = *(v30 - 1);
        --v25;
        v21 = v27 - 1;
        v24 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v29 - 1) == v32);
      v33 = v11 + 1;
      if (v22 + (int)v27 < 15)
      {
        *v11 = 16 * (v29 - v10);
      }
      else
      {
        *v11 = -16;
        if ((v22 + v27) <= 0x10D)
        {
          v36 = v27 + v14 - v10 - 15;
        }
        else
        {
          if (v26 >= 509)
            v34 = 509;
          else
            v34 = v26;
          v35 = v22 - v34 + v27 + 239;
          v100 = v23;
          memset(v33, 255, v35 / 0xFF + 1);
          v33 = &v11[v35 / 0xFFuLL + 2];
          v36 = v35 / 0xFF + v100 + v27;
        }
        *(_BYTE *)v33 = v36;
        v33 = (_QWORD *)((char *)v33 + 1);
      }
      v37 = (_DWORD *)((char *)a2 + v19 + v27);
      v38 = (_WORD *)((char *)v33 + (v28 >> 32));
      do
      {
        v39 = *(_QWORD *)v10;
        v10 += 8;
        *v33++ = v39;
      }
      while (v33 < (_QWORD *)v38);
      while (1)
      {
        v40 = v11;
        *v38 = v29 - (_WORD)v37;
        v11 = v38 + 1;
        v41 = v29 + 4;
        v42 = v37 + 1;
        v10 = v29 + 4;
        if (v29 + 4 >= v12)
        {
LABEL_36:
          if (v10 < v104 && *v42 == *(_DWORD *)v10)
          {
            v10 += 4;
            ++v42;
          }
          if (v10 < v102 && *(unsigned __int16 *)v42 == *(unsigned __int16 *)v10)
          {
            v10 += 2;
            v42 = (_DWORD *)((char *)v42 + 2);
          }
          if (v10 < v106 && *(unsigned __int8 *)v42 == *(unsigned __int8 *)v10)
            ++v10;
        }
        else
        {
          while (1)
          {
            v43 = *(_QWORD *)v10 ^ *(_QWORD *)v42;
            if (v43)
              break;
            v10 += 8;
            v42 += 2;
            if (v10 >= v12)
              goto LABEL_36;
          }
          v10 += __clz(__rbit64(v43)) >> 3;
        }
        v44 = v10 - v41;
        v45 = __OFSUB__(v10 - v41, 15);
        v46 = v10 - v41 - 15;
        if (((v46 & 0x80000000) != 0) != v45)
        {
          *v40 += v44;
        }
        else
        {
          *v40 += 15;
          if (v46 >= 0x1FE)
          {
            v47 = v10 - v29 - 529;
            v48 = v47 / 0x1FE;
            memset(v38 + 1, 255, v48 * 2 + 2);
            v46 = v47 % 0x1FE;
            v11 = &v38[v48 + 2];
          }
          if (v46 >= 0xFF)
          {
            *v11++ = -1;
            LOBYTE(v46) = v46 + 1;
          }
          *v11++ = v46;
        }
        if (v10 > v12)
          break;
        *((_WORD *)a1 + ((-1640531535 * *(_DWORD *)(v10 - 2)) >> 19)) = v10 - 2 - (_WORD)a2;
        v49 = *(_DWORD *)v10;
        v50 = (-1640531535 * *(_DWORD *)v10) >> 19;
        v37 = (_DWORD *)((char *)a2 + *((unsigned __int16 *)a1 + v50));
        *((_WORD *)a1 + v50) = v10 - (_WORD)a2;
        if ((unint64_t)v37 + 0xFFFF < v10 || *v37 != v49)
        {
          v13 = (_DWORD *)(v10 + 2);
          if (v10 + 2 <= v12)
            goto LABEL_8;
          break;
        }
        *v11 = 0;
        v38 = v11 + 1;
        v29 = v10;
      }
LABEL_58:
      LODWORD(a3) = v112;
      a4 = v110;
      v9 = v108;
    }
  }
  v51 = (size_t)&v9[-v10];
  v52 = (_DWORD)v9 - v10 - 15;
  if ((int)v9 - (int)v10 < 15)
  {
    *v11 = 16 * v51;
  }
  else
  {
    *v11 = -16;
    v53 = v11 + 1;
    if (v51 >= 0x10E)
    {
      v54 = (_DWORD)a2 + a4;
      if (v52 >= 509)
        v52 = 509;
      v55 = (v54 - (v52 + v10) + 239) / 0xFFuLL;
      memset(v53, 255, v55 + 1);
      LOBYTE(v52) = v54 - v10 + v55 - 14;
      v53 = &v11[v55 + 2];
    }
    *v53 = v52;
    v11 = v53;
  }
  v99 = v11 + 1;
LABEL_128:
  memcpy(v99, (const void *)v10, v51);
  return ((_DWORD)v99 + v51 - (_DWORD)a3);
}

uint64_t LZ4_compress_limitedOutput_withState(unsigned int *a1, _DWORD *a2, _BYTE *a3, int a4, unsigned int a5)
{
  unint64_t v11;
  char *v12;
  unint64_t v13;
  _BYTE *v14;
  unint64_t v15;
  _DWORD *v16;
  unint64_t v17;
  int v18;
  unsigned int v19;
  _DWORD *v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  char v26;
  char v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  int v36;
  int v37;
  _QWORD *v38;
  int v39;
  unsigned int v40;
  char v41;
  _DWORD *v42;
  _WORD *v43;
  uint64_t v44;
  _BYTE *v45;
  int v46;
  _DWORD *v47;
  unint64_t v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  int v53;
  unsigned int v54;
  size_t v55;
  int v56;
  _BYTE *v57;
  int v58;
  char *v59;
  unint64_t v60;
  _DWORD *v61;
  unint64_t v62;
  int v63;
  unsigned int v64;
  _DWORD *v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  char v71;
  char v72;
  uint64_t v73;
  int v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  int v81;
  int v82;
  _QWORD *v83;
  int v84;
  unsigned int v85;
  char v86;
  _DWORD *v87;
  _WORD *v88;
  uint64_t v89;
  _BYTE *v90;
  int v91;
  _DWORD *v92;
  unint64_t v93;
  int v94;
  unsigned int v95;
  unsigned int v96;
  uint64_t v97;
  unsigned int v98;
  unint64_t v99;
  char v100;
  char v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  char *v108;
  char *v109;
  unsigned int v110;
  unsigned int v111;
  int v112;
  int v113;
  _BYTE *v114;
  _BYTE *v115;
  unint64_t v116;

  if ((a1 & 3) != 0)
    return 0;
  bzero(a1, 0x4000uLL);
  v11 = (unint64_t)&a3[a5];
  v116 = v11;
  if (a4 > 65546)
  {
    if (a4 <= 0x7E000000)
    {
      v111 = a5;
      v113 = a4;
      v59 = (char *)a2 + a4;
      v60 = (unint64_t)(v59 - 12);
      v61 = (_DWORD *)((char *)a2 + 2);
      a1[(-1640531535 * *a2) >> 20] = 0;
      v105 = (unint64_t)(v59 - 8);
      v107 = (unint64_t)(v59 - 5);
      v109 = v59;
      v103 = (unint64_t)(v59 - 6);
      v115 = a3;
      v14 = a3;
      v13 = (unint64_t)a2;
LABEL_67:
      v62 = v13 + 1;
      v63 = *(_DWORD *)(v13 + 1);
      v64 = 68;
      do
      {
        v65 = v61;
        v66 = (-1640531535 * v63) >> 20;
        v63 = *v61;
        v67 = a1[v66];
        a1[v66] = v62 - (_DWORD)a2;
        if ((unint64_t)a2 + v67 + 0xFFFF >= v62 && *(_DWORD *)((char *)a2 + v67) == *(_DWORD *)v62)
        {
          v69 = 0;
          v70 = v62 - v13;
          v71 = v62 - v13 - 15;
          v72 = v62 - v13 - 14;
          v73 = (v62 << 32) - (v13 << 32);
          v74 = v62 - v13 - 15;
          do
          {
            v75 = v74;
            v76 = v69;
            v77 = v73;
            v78 = v62 + v69;
            v79 = (char *)a2 + v67 + v69;
            if (v78 <= v13 || v79 <= (char *)a2)
              break;
            v81 = *(v79 - 1);
            --v74;
            v69 = v76 - 1;
            v73 -= 0x100000000;
          }
          while (*(unsigned __int8 *)(v78 - 1) == v81);
          v82 = v70 + v76;
          v83 = v14 + 1;
          if ((unint64_t)&v14[(v77 >> 32) + 9 + (v70 + (int)v76) / 255] <= v11)
          {
            if (v82 < 15)
            {
              *v14 = 16 * (v78 - v13);
            }
            else
            {
              *v14 = -16;
              if (v82 <= 0x10D)
              {
                v86 = v76 + v71;
              }
              else
              {
                if (v75 >= 509)
                  v84 = 509;
                else
                  v84 = v75;
                v85 = v70 - v84 + v76 + 239;
                v101 = v72;
                memset(v83, 255, v85 / 0xFF + 1);
                v11 = v116;
                v83 = &v14[v85 / 0xFFuLL + 2];
                v86 = v85 / 0xFF + v101 + v76;
              }
              *(_BYTE *)v83 = v86;
              v83 = (_QWORD *)((char *)v83 + 1);
            }
            v87 = (_DWORD *)((char *)a2 + v67 + v76);
            v88 = (_WORD *)((char *)v83 + (v77 >> 32));
            do
            {
              v89 = *(_QWORD *)v13;
              v13 += 8;
              *v83++ = v89;
            }
            while (v83 < (_QWORD *)v88);
            while (1)
            {
              v90 = v14;
              *v88 = v78 - (_WORD)v87;
              v14 = v88 + 1;
              v91 = v78 + 4;
              v92 = v87 + 1;
              v13 = v78 + 4;
              if (v78 + 4 >= v60)
              {
LABEL_96:
                if (v13 < v105 && *v92 == *(_DWORD *)v13)
                {
                  v13 += 4;
                  ++v92;
                }
                if (v13 < v103 && *(unsigned __int16 *)v92 == *(unsigned __int16 *)v13)
                {
                  v13 += 2;
                  v92 = (_DWORD *)((char *)v92 + 2);
                }
                if (v13 < v107 && *(unsigned __int8 *)v92 == *(unsigned __int8 *)v13)
                  ++v13;
              }
              else
              {
                while (1)
                {
                  v93 = *(_QWORD *)v13 ^ *(_QWORD *)v92;
                  if (v93)
                    break;
                  v13 += 8;
                  v92 += 2;
                  if (v13 >= v60)
                    goto LABEL_96;
                }
                v13 += __clz(__rbit64(v93)) >> 3;
              }
              v94 = v13 - v91;
              if ((unint64_t)v88 + (((int)v13 - v91) >> 8) + 8 > v11)
                break;
              v95 = v94 - 15;
              if (v94 < 15)
              {
                *v90 += v94;
              }
              else
              {
                *v90 += 15;
                if (v95 >= 0x1FE)
                {
                  v96 = v13 - v78 - 529;
                  v97 = v96 / 0x1FE;
                  memset(v88 + 1, 255, v97 * 2 + 2);
                  v11 = v116;
                  v95 = v96 % 0x1FE;
                  v14 = &v88[v97 + 2];
                }
                if (v95 >= 0xFF)
                {
                  *v14++ = -1;
                  LOBYTE(v95) = v95 + 1;
                }
                *v14++ = v95;
              }
              if (v13 > v60)
                goto LABEL_119;
              a1[(-1640531535 * *(_DWORD *)(v13 - 2)) >> 20] = v13 - 2 - (_DWORD)a2;
              v98 = (-1640531535 * *(_DWORD *)v13) >> 20;
              v87 = (_DWORD *)((char *)a2 + a1[v98]);
              a1[v98] = v13 - (_DWORD)a2;
              if ((unint64_t)v87 + 0xFFFF < v13 || *v87 != *(_DWORD *)v13)
              {
                v61 = (_DWORD *)(v13 + 2);
                if (v13 + 2 <= v60)
                  goto LABEL_67;
                goto LABEL_119;
              }
              *v14 = 0;
              v88 = v14 + 1;
              v78 = v13;
            }
          }
          return 0;
        }
        v68 = v64++ >> 6;
        v61 = (_DWORD *)((char *)v61 + v68);
        v62 = (unint64_t)v65;
      }
      while ((unint64_t)v61 <= v60);
LABEL_119:
      v55 = (size_t)&v109[-v13];
      LODWORD(a3) = (_DWORD)v115;
      if ((uint64_t)(v14 - v115 + (int)v109 - (int)v13 + ((_DWORD)v109 - v13 + 240) / 0xFFuLL + 1) > v111)
        return 0;
      v56 = v55 - 15;
      if ((int)v55 >= 15)
      {
        *v14 = -16;
        v57 = v14 + 1;
        if (v55 < 0x10E)
          goto LABEL_127;
        v58 = (_DWORD)a2 + v113;
        goto LABEL_124;
      }
LABEL_128:
      *v14 = 16 * v55;
      goto LABEL_129;
    }
    return 0;
  }
  if (a4 > 0x7E000000)
    return 0;
  v12 = (char *)a2 + a4;
  v13 = (unint64_t)a2;
  v14 = a3;
  if (a4 >= 0xD)
  {
    v110 = a5;
    v112 = a4;
    v114 = a3;
    *((_WORD *)a1 + ((-1640531535 * *a2) >> 19)) = 0;
    if (a4 != 13)
    {
      v15 = (unint64_t)(v12 - 12);
      v16 = (_DWORD *)((char *)a2 + 2);
      v104 = (unint64_t)(v12 - 8);
      v106 = (unint64_t)(v12 - 5);
      v108 = (char *)a2 + a4;
      v102 = (unint64_t)(v12 - 6);
      v14 = a3;
      v13 = (unint64_t)a2;
LABEL_8:
      v17 = v13 + 1;
      v18 = *(_DWORD *)(v13 + 1);
      v19 = 68;
      while (1)
      {
        v20 = v16;
        v21 = (-1640531535 * v18) >> 19;
        v18 = *v16;
        v22 = *((unsigned __int16 *)a1 + v21);
        *((_WORD *)a1 + v21) = v17 - (_WORD)a2;
        if ((unint64_t)a2 + v22 + 0xFFFF >= v17 && *(_DWORD *)((char *)a2 + v22) == *(_DWORD *)v17)
          break;
        v23 = v19++ >> 6;
        v16 = (_DWORD *)((char *)v16 + v23);
        v17 = (unint64_t)v20;
        if ((unint64_t)v16 > v15)
        {
LABEL_60:
          a3 = v114;
          a5 = v110;
          a4 = v112;
          v12 = v108;
          goto LABEL_61;
        }
      }
      v24 = 0;
      v25 = v17 - v13;
      v26 = v17 - v13 - 15;
      v27 = v17 - v13 - 14;
      v28 = (v17 << 32) - (v13 << 32);
      v29 = v17 - v13 - 15;
      do
      {
        v30 = v29;
        v31 = v24;
        v32 = v28;
        v33 = v17 + v24;
        v34 = (char *)a2 + v22 + v24;
        if (v33 <= v13 || v34 <= (char *)a2)
          break;
        v36 = *(v34 - 1);
        --v29;
        v24 = v31 - 1;
        v28 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v33 - 1) == v36);
      v37 = v25 + v31;
      v38 = v14 + 1;
      if ((unint64_t)&v14[(v32 >> 32) + 9 + (v25 + (int)v31) / 255] <= v11)
      {
        if (v37 < 15)
        {
          *v14 = 16 * (v33 - v13);
        }
        else
        {
          *v14 = -16;
          if (v37 <= 0x10D)
          {
            v41 = v31 + v26;
          }
          else
          {
            if (v30 >= 509)
              v39 = 509;
            else
              v39 = v30;
            v40 = v25 - v39 + v31 + 239;
            v100 = v27;
            memset(v38, 255, v40 / 0xFF + 1);
            v11 = v116;
            v38 = &v14[v40 / 0xFFuLL + 2];
            v41 = v40 / 0xFF + v100 + v31;
          }
          *(_BYTE *)v38 = v41;
          v38 = (_QWORD *)((char *)v38 + 1);
        }
        v42 = (_DWORD *)((char *)a2 + v22 + v31);
        v43 = (_WORD *)((char *)v38 + (v32 >> 32));
        do
        {
          v44 = *(_QWORD *)v13;
          v13 += 8;
          *v38++ = v44;
        }
        while (v38 < (_QWORD *)v43);
        while (1)
        {
          v45 = v14;
          *v43 = v33 - (_WORD)v42;
          v14 = v43 + 1;
          v46 = v33 + 4;
          v47 = v42 + 1;
          v13 = v33 + 4;
          if (v33 + 4 >= v15)
          {
LABEL_37:
            if (v13 < v104 && *v47 == *(_DWORD *)v13)
            {
              v13 += 4;
              ++v47;
            }
            if (v13 < v102 && *(unsigned __int16 *)v47 == *(unsigned __int16 *)v13)
            {
              v13 += 2;
              v47 = (_DWORD *)((char *)v47 + 2);
            }
            if (v13 < v106 && *(unsigned __int8 *)v47 == *(unsigned __int8 *)v13)
              ++v13;
          }
          else
          {
            while (1)
            {
              v48 = *(_QWORD *)v13 ^ *(_QWORD *)v47;
              if (v48)
                break;
              v13 += 8;
              v47 += 2;
              if (v13 >= v15)
                goto LABEL_37;
            }
            v13 += __clz(__rbit64(v48)) >> 3;
          }
          v49 = v13 - v46;
          if ((unint64_t)v43 + (((int)v13 - v46) >> 8) + 8 > v11)
            break;
          v50 = v49 - 15;
          if (v49 < 15)
          {
            *v45 += v49;
          }
          else
          {
            *v45 += 15;
            if (v50 >= 0x1FE)
            {
              v51 = v13 - v33 - 529;
              v52 = v51 / 0x1FE;
              memset(v43 + 1, 255, v52 * 2 + 2);
              v11 = v116;
              v50 = v51 % 0x1FE;
              v14 = &v43[v52 + 2];
            }
            if (v50 >= 0xFF)
            {
              *v14++ = -1;
              LOBYTE(v50) = v50 + 1;
            }
            *v14++ = v50;
          }
          if (v13 > v15)
            goto LABEL_60;
          *((_WORD *)a1 + ((-1640531535 * *(_DWORD *)(v13 - 2)) >> 19)) = v13 - 2 - (_WORD)a2;
          v53 = *(_DWORD *)v13;
          v54 = (-1640531535 * *(_DWORD *)v13) >> 19;
          v42 = (_DWORD *)((char *)a2 + *((unsigned __int16 *)a1 + v54));
          *((_WORD *)a1 + v54) = v13 - (_WORD)a2;
          if ((unint64_t)v42 + 0xFFFF < v13 || *v42 != v53)
          {
            v16 = (_DWORD *)(v13 + 2);
            if (v13 + 2 <= v15)
              goto LABEL_8;
            goto LABEL_60;
          }
          *v14 = 0;
          v43 = v14 + 1;
          v33 = v13;
        }
      }
      return 0;
    }
    v13 = (unint64_t)a2;
    v14 = a3;
    a4 = 13;
  }
LABEL_61:
  v55 = (size_t)&v12[-v13];
  if ((uint64_t)(v14 - a3 + (int)v12 - (int)v13 + ((_DWORD)v12 - v13 + 240) / 0xFFuLL + 1) > a5)
    return 0;
  v56 = v55 - 15;
  if ((int)v55 < 15)
    goto LABEL_128;
  *v14 = -16;
  v57 = v14 + 1;
  if (v55 >= 0x10E)
  {
    v58 = (_DWORD)a2 + a4;
LABEL_124:
    if (v56 >= 509)
      v56 = 509;
    v99 = (v58 - (v56 + v13) + 239) / 0xFFuLL;
    memset(v57, 255, v99 + 1);
    LOBYTE(v56) = v58 - v13 + v99 - 14;
    v57 = &v14[v99 + 2];
  }
LABEL_127:
  *v57 = v56;
  v14 = v57;
LABEL_129:
  memcpy(v14 + 1, (const void *)v13, v55);
  return ((_DWORD)v14 + 1 + v55 - (_DWORD)a3);
}

uint64_t LZ4_sizeofStreamState()
{
  return 16408;
}

uint64_t LZ4_resetStreamState(_QWORD *a1, uint64_t a2)
{
  uint64_t result;

  if ((a1 & 3) != 0)
    return 1;
  bzero(a1, 0x4000uLL);
  result = 0;
  a1[2048] = a2;
  a1[2049] = a2;
  a1[2050] = a2;
  return result;
}

_QWORD *LZ4_create(uint64_t a1)
{
  _QWORD *v2;

  v2 = calloc(1uLL, 0x4018uLL);
  bzero(v2, 0x4000uLL);
  v2[2048] = a1;
  v2[2049] = a1;
  v2[2050] = a1;
  return v2;
}

uint64_t LZ4_free(void *a1)
{
  free(a1);
  return 0;
}

uint64_t LZ4_slideInputBuffer(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  uint64_t v8;
  unint64_t v9;
  uint64x2_t v10;
  int32x4_t v11;
  int32x4_t v12;
  uint64x2_t v13;
  uint64x2_t v14;
  uint64_t v15;
  uint64_t result;

  v2 = a1[2050];
  v3 = (void *)a1[2048];
  v4 = (uint64_t)v3 - v2 + 0x10000;
  v5 = a1[2049];
  v6 = (const void *)(v2 - 0x10000);
  if (v4 > 0 || (unint64_t)(v2 - v5) >= 0xE0000001)
  {
    v8 = 0;
    v9 = (unint64_t)v6 - v5;
    v10 = (uint64x2_t)vdupq_n_s64(v9);
    v11 = vdupq_n_s32(v9);
    do
    {
      v12 = *(int32x4_t *)&a1[v8];
      v13.i64[0] = v12.u32[0];
      v13.i64[1] = v12.u32[1];
      v14 = v13;
      v13.i64[0] = v12.u32[2];
      v13.i64[1] = v12.u32[3];
      *(int8x16_t *)&a1[v8] = vbicq_s8((int8x16_t)vsubq_s32(v12, v11), (int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v10, v14), (int32x4_t)vcgtq_u64(v10, v13)));
      v8 += 2;
    }
    while (v8 != 2048);
    memcpy(v3, v6, 0x10000uLL);
    v15 = a1[2048];
    a1[2049] = v15;
    result = v15 + 0x10000;
    a1[2050] = v15 + 0x10000;
  }
  else
  {
    memcpy(v3, v6, 0x10000uLL);
    result = a1[2050] + v4;
    a1[2050] = result;
    a1[2049] += v4;
  }
  return result;
}

uint64_t LZ4_compress_continue(uint64_t a1, char *__src, _BYTE *a3, unsigned int a4)
{
  uint64_t v7;
  unint64_t v8;
  char *v9;
  unint64_t v10;
  _BYTE *v11;
  unint64_t v12;
  _DWORD *v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  _DWORD *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  char v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  int v32;
  _QWORD *v33;
  int v34;
  unsigned int v35;
  char v36;
  _DWORD *v37;
  _WORD *v38;
  uint64_t v39;
  _BYTE *v40;
  int v41;
  _DWORD *v42;
  unint64_t v43;
  char v44;
  BOOL v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  unsigned int v49;
  size_t v50;
  int v51;
  _BYTE *v52;
  int v53;
  unint64_t v54;
  void *v55;
  char v56;
  unsigned int v57;
  char *v58;
  int v59;
  int v60;
  unint64_t v61;

  if (a4 > 0x7E000000)
    return 0;
  if (*(char **)(a1 + 16400) != __src)
    return 0;
  v7 = *(_QWORD *)(a1 + 16392);
  v8 = *(_QWORD *)(a1 + 0x4000);
  v9 = &__src[a4];
  *(_QWORD *)(a1 + 16400) = v9;
  v60 = (int)__src;
  v10 = (unint64_t)__src;
  v11 = a3;
  if (a4 >= 0xD)
  {
    v58 = &__src[a4];
    v59 = (int)a3;
    v10 = (unint64_t)__src;
    *(_DWORD *)(a1 + 4 * ((-1640531535 * *(_DWORD *)__src) >> 20)) = (_DWORD)__src - v7;
    v57 = a4;
    if (a4 == 13)
    {
      v11 = a3;
    }
    else
    {
      v11 = a3;
      v12 = (unint64_t)(v58 - 12);
      v13 = __src + 2;
      v61 = v8;
LABEL_8:
      v14 = v10 + 1;
      v15 = *(_DWORD *)(v10 + 1);
      v16 = 68;
      while (1)
      {
        v17 = v13;
        v18 = (-1640531535 * v15) >> 20;
        v15 = *v13;
        v19 = *(unsigned int *)(a1 + 4 * v18);
        *(_DWORD *)(a1 + 4 * v18) = v14 - v7;
        if (v7 + v19 + 0xFFFF >= v14 && *(_DWORD *)(v7 + v19) == *(_DWORD *)v14)
          break;
        v20 = v16++ >> 6;
        v13 = (_DWORD *)((char *)v13 + v20);
        v14 = (unint64_t)v17;
        if ((unint64_t)v13 > v12)
          goto LABEL_58;
      }
      v21 = 0;
      v22 = v14 - v10;
      v23 = v14 - v10 - 14;
      v24 = (v14 << 32) - (v10 << 32);
      v25 = v14 - v10 - 15;
      do
      {
        v26 = v25;
        v27 = v21;
        v28 = v24;
        v29 = v14 + v21;
        v30 = v7 + v19 + v21;
        if (v29 <= v10 || v30 <= v8)
          break;
        v32 = *(unsigned __int8 *)(v30 - 1);
        --v25;
        v21 = v27 - 1;
        v24 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v29 - 1) == v32);
      v33 = v11 + 1;
      if (v22 + (int)v27 < 15)
      {
        *v11 = 16 * (v29 - v10);
      }
      else
      {
        *v11 = -16;
        if ((v22 + v27) <= 0x10D)
        {
          v36 = v27 + v14 - v10 - 15;
        }
        else
        {
          if (v26 >= 509)
            v34 = 509;
          else
            v34 = v26;
          v35 = v22 - v34 + v27 + 239;
          v56 = v23;
          memset(v33, 255, v35 / 0xFF + 1);
          v8 = v61;
          v33 = &v11[v35 / 0xFFuLL + 2];
          v36 = v35 / 0xFF + v56 + v27;
        }
        *(_BYTE *)v33 = v36;
        v33 = (_QWORD *)((char *)v33 + 1);
      }
      v37 = (_DWORD *)(v7 + v19 + v27);
      v38 = (_WORD *)((char *)v33 + (v28 >> 32));
      do
      {
        v39 = *(_QWORD *)v10;
        v10 += 8;
        *v33++ = v39;
      }
      while (v33 < (_QWORD *)v38);
      while (1)
      {
        v40 = v11;
        *v38 = v29 - (_WORD)v37;
        v11 = v38 + 1;
        v41 = v29 + 4;
        v42 = v37 + 1;
        v10 = v29 + 4;
        if (v29 + 4 >= v12)
        {
LABEL_36:
          if (v10 < (unint64_t)(v58 - 8) && *v42 == *(_DWORD *)v10)
          {
            v10 += 4;
            ++v42;
          }
          if (v10 < (unint64_t)(v58 - 6) && *(unsigned __int16 *)v42 == *(unsigned __int16 *)v10)
          {
            v10 += 2;
            v42 = (_DWORD *)((char *)v42 + 2);
          }
          if (v10 < (unint64_t)(v58 - 5) && *(unsigned __int8 *)v42 == *(unsigned __int8 *)v10)
            ++v10;
        }
        else
        {
          while (1)
          {
            v43 = *(_QWORD *)v10 ^ *(_QWORD *)v42;
            if (v43)
              break;
            v10 += 8;
            v42 += 2;
            if (v10 >= v12)
              goto LABEL_36;
          }
          v10 += __clz(__rbit64(v43)) >> 3;
        }
        v44 = v10 - v41;
        v45 = __OFSUB__(v10 - v41, 15);
        v46 = v10 - v41 - 15;
        if (((v46 & 0x80000000) != 0) != v45)
        {
          *v40 += v44;
        }
        else
        {
          *v40 += 15;
          if (v46 >= 0x1FE)
          {
            v47 = v10 - v29 - 529;
            v48 = v47 / 0x1FE;
            memset(v38 + 1, 255, v48 * 2 + 2);
            v8 = v61;
            v46 = v47 % 0x1FE;
            v11 = &v38[v48 + 2];
          }
          if (v46 >= 0xFF)
          {
            *v11++ = -1;
            LOBYTE(v46) = v46 + 1;
          }
          *v11++ = v46;
        }
        if (v10 > v12)
          break;
        *(_DWORD *)(a1 + 4 * ((-1640531535 * *(_DWORD *)(v10 - 2)) >> 20)) = v10 - 2 - v7;
        v49 = (-1640531535 * *(_DWORD *)v10) >> 20;
        v37 = (_DWORD *)(v7 + *(unsigned int *)(a1 + 4 * v49));
        *(_DWORD *)(a1 + 4 * v49) = v10 - v7;
        if ((unint64_t)v37 + 0xFFFF < v10 || *v37 != *(_DWORD *)v10)
        {
          v13 = (_DWORD *)(v10 + 2);
          if (v10 + 2 <= v12)
            goto LABEL_8;
          break;
        }
        *v11 = 0;
        v38 = v11 + 1;
        v29 = v10;
      }
LABEL_58:
      LODWORD(a3) = v59;
    }
    a4 = v57;
    v9 = v58;
  }
  v50 = (size_t)&v9[-v10];
  v45 = __OFSUB__((_DWORD)v9 - v10, 15);
  v51 = (_DWORD)v9 - v10 - 15;
  if (v51 < 0 != v45)
  {
    *v11 = 16 * v50;
  }
  else
  {
    *v11 = -16;
    v52 = v11 + 1;
    if (v50 >= 0x10E)
    {
      v53 = v60 + a4;
      if (v51 >= 509)
        v51 = 509;
      v54 = (v53 - (v51 + v10) + 239) / 0xFFuLL;
      memset(v52, 255, v54 + 1);
      LOBYTE(v51) = v53 - v10 + v54 - 14;
      v52 = &v11[v54 + 2];
    }
    *v52 = v51;
    v11 = v52;
  }
  v55 = v11 + 1;
  memcpy(v55, (const void *)v10, v50);
  return ((_DWORD)v55 + v50 - (_DWORD)a3);
}

uint64_t LZ4_compress_limitedOutput_continue(uint64_t a1, char *__src, _BYTE *a3, unsigned int a4, unsigned int a5)
{
  uint64_t v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  _BYTE *v12;
  unint64_t v13;
  _DWORD *v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  unsigned int v18;
  _DWORD *v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  char v25;
  char v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  int v35;
  int v36;
  _QWORD *v37;
  int v38;
  unsigned int v39;
  char v40;
  _DWORD *v41;
  _WORD *v42;
  uint64_t v43;
  _BYTE *v44;
  int v45;
  _DWORD *v46;
  unint64_t v47;
  int v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  size_t v53;
  int v54;
  _BYTE *v55;
  unsigned int v56;
  unint64_t v57;
  char v58;
  char *v59;
  char *v60;
  char *v61;
  char *v62;
  int v63;
  unsigned int v64;
  unsigned int v65;
  _BYTE *v66;
  unint64_t v67;
  unint64_t v68;

  if (a4 > 0x7E000000)
    return 0;
  if (*(char **)(a1 + 16400) != __src)
    return 0;
  v8 = *(_QWORD *)(a1 + 16392);
  v9 = *(_QWORD *)(a1 + 0x4000);
  v10 = &__src[a4];
  *(_QWORD *)(a1 + 16400) = v10;
  v11 = (unint64_t)__src;
  v12 = a3;
  if (a4 >= 0xD)
  {
    v64 = a4;
    v65 = a5;
    v66 = a3;
    *(_DWORD *)(a1 + 4 * ((-1640531535 * *(_DWORD *)__src) >> 20)) = (_DWORD)__src - v8;
    if (a4 != 13)
    {
      v13 = (unint64_t)(v10 - 12);
      v14 = __src + 2;
      v60 = v10 - 8;
      v61 = v10 - 5;
      v62 = &__src[a4];
      v63 = (int)__src;
      v59 = v10 - 6;
      v12 = a3;
      v11 = (unint64_t)__src;
      v15 = (unint64_t)&a3[a5];
      v67 = v15;
      v68 = v9;
LABEL_7:
      v16 = v11 + 1;
      v17 = *(_DWORD *)(v11 + 1);
      v18 = 68;
      while (1)
      {
        v19 = v14;
        v20 = (-1640531535 * v17) >> 20;
        v17 = *v14;
        v21 = *(unsigned int *)(a1 + 4 * v20);
        *(_DWORD *)(a1 + 4 * v20) = v16 - v8;
        if (v8 + v21 + 0xFFFF >= v16 && *(_DWORD *)(v8 + v21) == *(_DWORD *)v16)
          break;
        v22 = v18++ >> 6;
        v14 = (_DWORD *)((char *)v14 + v22);
        v16 = (unint64_t)v19;
        if ((unint64_t)v14 > v13)
        {
LABEL_59:
          a3 = v66;
          a4 = v64;
          a5 = v65;
          v10 = v62;
          LODWORD(__src) = v63;
          goto LABEL_60;
        }
      }
      v23 = 0;
      v24 = v16 - v11;
      v25 = v16 - v11 - 15;
      v26 = v16 - v11 - 14;
      v27 = (v16 << 32) - (v11 << 32);
      v28 = v16 - v11 - 15;
      do
      {
        v29 = v28;
        v30 = v23;
        v31 = v27;
        v32 = v16 + v23;
        v33 = v8 + v21 + v23;
        if (v32 <= v11 || v33 <= v9)
          break;
        v35 = *(unsigned __int8 *)(v33 - 1);
        --v28;
        v23 = v30 - 1;
        v27 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v32 - 1) == v35);
      v36 = v24 + v30;
      v37 = v12 + 1;
      if ((unint64_t)&v12[(v31 >> 32) + 9 + (v24 + (int)v30) / 255] <= v15)
      {
        if (v36 < 15)
        {
          *v12 = 16 * (v32 - v11);
        }
        else
        {
          *v12 = -16;
          if (v36 <= 0x10D)
          {
            v40 = v30 + v25;
          }
          else
          {
            if (v29 >= 509)
              v38 = 509;
            else
              v38 = v29;
            v39 = v24 - v38 + v30 + 239;
            v58 = v26;
            memset(v37, 255, v39 / 0xFF + 1);
            v15 = v67;
            v9 = v68;
            v37 = &v12[v39 / 0xFFuLL + 2];
            v40 = v39 / 0xFF + v58 + v30;
          }
          *(_BYTE *)v37 = v40;
          v37 = (_QWORD *)((char *)v37 + 1);
        }
        v41 = (_DWORD *)(v8 + v21 + v30);
        v42 = (_WORD *)((char *)v37 + (v31 >> 32));
        do
        {
          v43 = *(_QWORD *)v11;
          v11 += 8;
          *v37++ = v43;
        }
        while (v37 < (_QWORD *)v42);
        while (1)
        {
          v44 = v12;
          *v42 = v32 - (_WORD)v41;
          v12 = v42 + 1;
          v45 = v32 + 4;
          v46 = v41 + 1;
          v11 = v32 + 4;
          if (v32 + 4 >= v13)
          {
LABEL_36:
            if (v11 < (unint64_t)v60 && *v46 == *(_DWORD *)v11)
            {
              v11 += 4;
              ++v46;
            }
            if (v11 < (unint64_t)v59 && *(unsigned __int16 *)v46 == *(unsigned __int16 *)v11)
            {
              v11 += 2;
              v46 = (_DWORD *)((char *)v46 + 2);
            }
            if (v11 < (unint64_t)v61 && *(unsigned __int8 *)v46 == *(unsigned __int8 *)v11)
              ++v11;
          }
          else
          {
            while (1)
            {
              v47 = *(_QWORD *)v11 ^ *(_QWORD *)v46;
              if (v47)
                break;
              v11 += 8;
              v46 += 2;
              if (v11 >= v13)
                goto LABEL_36;
            }
            v11 += __clz(__rbit64(v47)) >> 3;
          }
          v48 = v11 - v45;
          if ((unint64_t)v42 + (((int)v11 - v45) >> 8) + 8 > v15)
            break;
          v49 = v48 - 15;
          if (v48 < 15)
          {
            *v44 += v48;
          }
          else
          {
            *v44 += 15;
            if (v49 >= 0x1FE)
            {
              v50 = v11 - v32 - 529;
              v51 = v50 / 0x1FE;
              memset(v42 + 1, 255, v51 * 2 + 2);
              v15 = v67;
              v9 = v68;
              v49 = v50 % 0x1FE;
              v12 = &v42[v51 + 2];
            }
            if (v49 >= 0xFF)
            {
              *v12++ = -1;
              LOBYTE(v49) = v49 + 1;
            }
            *v12++ = v49;
          }
          if (v11 > v13)
            goto LABEL_59;
          *(_DWORD *)(a1 + 4 * ((-1640531535 * *(_DWORD *)(v11 - 2)) >> 20)) = v11 - 2 - v8;
          v52 = (-1640531535 * *(_DWORD *)v11) >> 20;
          v41 = (_DWORD *)(v8 + *(unsigned int *)(a1 + 4 * v52));
          *(_DWORD *)(a1 + 4 * v52) = v11 - v8;
          if ((unint64_t)v41 + 0xFFFF < v11 || *v41 != *(_DWORD *)v11)
          {
            v14 = (_DWORD *)(v11 + 2);
            if (v11 + 2 <= v13)
              goto LABEL_7;
            goto LABEL_59;
          }
          *v12 = 0;
          v42 = v12 + 1;
          v32 = v11;
        }
      }
      return 0;
    }
    v11 = (unint64_t)__src;
    v12 = a3;
    a4 = 13;
  }
LABEL_60:
  v53 = (size_t)&v10[-v11];
  if ((uint64_t)(v12 - a3 + (int)v10 - (int)v11 + ((_DWORD)v10 - v11 + 240) / 0xFFuLL + 1) > a5)
    return 0;
  v54 = v53 - 15;
  if ((int)v53 < 15)
  {
    *v12 = 16 * v53;
  }
  else
  {
    *v12 = -16;
    v55 = v12 + 1;
    if (v53 >= 0x10E)
    {
      v56 = (_DWORD)__src + a4;
      if (v54 >= 509)
        v54 = 509;
      v57 = (v56 - (v54 + (_DWORD)v11) + 239) / 0xFFuLL;
      memset(v55, 255, v57 + 1);
      LOBYTE(v54) = v56 - v11 + v57 - 14;
      v55 = &v12[v57 + 2];
    }
    *v55 = v54;
    v12 = v55;
  }
  memcpy(v12 + 1, (const void *)v11, v53);
  return ((_DWORD)v12 + 1 + v53 - (_DWORD)a3);
}

uint64_t LZ4_decompress_safe(unsigned __int8 *a1, char *__dst, int a3, int a4)
{
  unsigned __int8 *v5;
  char *v6;
  char *v7;
  char *v8;
  unsigned __int8 *v9;
  char v10;
  unsigned int v11;
  size_t v12;
  unsigned int v13;
  unsigned int v14;
  char *v15;
  unint64_t v16;
  uint64_t v18;
  unsigned __int8 *v19;
  int v20;
  char *v21;
  uint64_t v22;
  unsigned int v23;
  int64_t v24;
  char *v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char v32;

  if (a4)
  {
    v5 = &a1[a3];
    v6 = &__dst[a4];
    v7 = v6 - 12;
    v8 = __dst;
    v9 = a1;
    while (1)
    {
      v11 = *v9++;
      v10 = v11;
      v12 = (unint64_t)v11 >> 4;
      if ((_DWORD)v12 == 15)
      {
        v12 = 15;
        if (v9 < v5)
        {
          do
          {
            v14 = *v9++;
            v13 = v14;
            v12 += v14;
          }
          while (v9 < v5 && v13 == 255);
        }
      }
      v15 = &v8[v12];
      v16 = (unint64_t)&v9[v12];
      if (&v8[v12] > v7 || v16 > (unint64_t)(v5 - 8))
        break;
      do
      {
        v18 = *(_QWORD *)v9;
        v9 += 8;
        *(_QWORD *)v8 = v18;
        v8 += 8;
        v12 -= 8;
      }
      while (v8 < v15);
      v19 = &v9[v12];
      v20 = *(unsigned __int16 *)v19;
      v9 = v19 + 2;
      v21 = &v15[-v20];
      if (v21 < __dst)
        return (~(_DWORD)v9 + (_DWORD)a1);
      v22 = v10 & 0xF;
      if ((v10 & 0xF) == 0xF)
      {
        v22 = 15;
        do
        {
          if (v9 >= v5 - 6)
            break;
          v23 = *v9++;
          v22 += v23;
        }
        while (v23 == 255);
      }
      v24 = v15 - v21;
      if (v15 - v21 <= 7)
      {
        v29 = LZ4_decompress_generic_dec64table[v24];
        *v15 = *v21;
        v15[1] = v21[1];
        v15[2] = v21[2];
        v15[3] = v21[3];
        v30 = &v21[qword_1DAD14190[v24]];
        *((_DWORD *)v15 + 1) = *(_DWORD *)v30;
        v25 = &v30[-v29];
      }
      else
      {
        v26 = *(_QWORD *)v21;
        v25 = v21 + 8;
        *(_QWORD *)v15 = v26;
      }
      v27 = v15 + 8;
      v8 = &v15[v22 + 4];
      if (v8 > v7)
      {
        if (v8 > v6 - 5)
          return (~(_DWORD)v9 + (_DWORD)a1);
        while (v27 < (_QWORD *)v6 - 1)
        {
          v31 = *(_QWORD *)v25;
          v25 += 8;
          *v27++ = v31;
        }
        while (v27 < (_QWORD *)v8)
        {
          v32 = *v25++;
          *(_BYTE *)v27 = v32;
          v27 = (_QWORD *)((char *)v27 + 1);
        }
      }
      else
      {
        do
        {
          v28 = *(_QWORD *)v25;
          v25 += 8;
          *v27++ = v28;
        }
        while (v27 < (_QWORD *)v8);
      }
    }
    if ((unsigned __int8 *)v16 == v5 && v15 <= v6)
    {
      memcpy(v8, v9, v12);
      return ((_DWORD)v15 - (_DWORD)__dst);
    }
    return (~(_DWORD)v9 + (_DWORD)a1);
  }
  else if (a3 == 1)
  {
    if (*a1)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t LZ4_decompress_safe_withPrefix64k(unsigned __int8 *a1, char *__dst, int a3, int a4)
{
  int v4;
  unsigned __int8 *v5;
  char *v6;
  char *v7;
  char *v8;
  unsigned __int8 *v9;
  char v10;
  unsigned int v11;
  size_t v12;
  unsigned int v13;
  unsigned int v14;
  char *v15;
  unint64_t v16;
  uint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  char *v24;
  int64_t v25;
  char *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  char v33;

  if (a4)
  {
    v4 = (int)__dst;
    v5 = &a1[a3];
    v6 = &__dst[a4];
    v7 = v6 - 12;
    v8 = __dst;
    v9 = a1;
    while (1)
    {
      v11 = *v9++;
      v10 = v11;
      v12 = (unint64_t)v11 >> 4;
      if ((_DWORD)v12 == 15)
      {
        v12 = 15;
        if (v9 < v5)
        {
          do
          {
            v14 = *v9++;
            v13 = v14;
            v12 += v14;
          }
          while (v9 < v5 && v13 == 255);
        }
      }
      v15 = &v8[v12];
      v16 = (unint64_t)&v9[v12];
      if (&v8[v12] > v7 || v16 > (unint64_t)(v5 - 8))
        break;
      do
      {
        v18 = *(_QWORD *)v9;
        v9 += 8;
        *(_QWORD *)v8 = v18;
        v8 += 8;
        v12 -= 8;
      }
      while (v8 < v15);
      v19 = &v9[v12];
      v21 = *(unsigned __int16 *)v19;
      v9 = v19 + 2;
      v20 = v21;
      v22 = v10 & 0xF;
      if ((v10 & 0xF) == 0xF)
      {
        v22 = 15;
        do
        {
          if (v9 >= v5 - 6)
            break;
          v23 = *v9++;
          v22 += v23;
        }
        while (v23 == 255);
      }
      v24 = &v15[-v20];
      v25 = v15 - v24;
      if (v15 - v24 <= 7)
      {
        v30 = LZ4_decompress_generic_dec64table[v25];
        *v15 = *v24;
        v15[1] = v24[1];
        v15[2] = v24[2];
        v15[3] = v24[3];
        v31 = &v24[qword_1DAD14190[v25]];
        *((_DWORD *)v15 + 1) = *(_DWORD *)v31;
        v26 = &v31[-v30];
      }
      else
      {
        v27 = *(_QWORD *)v24;
        v26 = v24 + 8;
        *(_QWORD *)v15 = v27;
      }
      v28 = v15 + 8;
      v8 = &v15[v22 + 4];
      if (v8 > v7)
      {
        if (v8 > v6 - 5)
          return (~(_DWORD)v9 + (_DWORD)a1);
        while (v28 < (_QWORD *)v6 - 1)
        {
          v32 = *(_QWORD *)v26;
          v26 += 8;
          *v28++ = v32;
        }
        while (v28 < (_QWORD *)v8)
        {
          v33 = *v26++;
          *(_BYTE *)v28 = v33;
          v28 = (_QWORD *)((char *)v28 + 1);
        }
      }
      else
      {
        do
        {
          v29 = *(_QWORD *)v26;
          v26 += 8;
          *v28++ = v29;
        }
        while (v28 < (_QWORD *)v8);
      }
    }
    if ((unsigned __int8 *)v16 == v5 && v15 <= v6)
    {
      memcpy(v8, v9, v12);
      return ((_DWORD)v15 - v4);
    }
    return (~(_DWORD)v9 + (_DWORD)a1);
  }
  else if (a3 == 1)
  {
    if (*a1)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t LZ4_decompress_safe_partial(unsigned __int8 *a1, char *__dst, int a3, int a4, int a5)
{
  char *v5;
  char *v6;
  unsigned __int8 *v8;
  char *v9;
  unsigned __int8 *v10;
  char v11;
  unsigned int v12;
  size_t v13;
  unsigned int v14;
  unsigned int v15;
  char *v16;
  unint64_t v17;
  uint64_t v19;
  unsigned __int8 *v20;
  int v21;
  char *v22;
  uint64_t v23;
  unsigned int v24;
  int64_t v25;
  char *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  char v33;

  v5 = &__dst[a5];
  if (&__dst[a4] <= v5 - 12)
    v6 = &__dst[a4];
  else
    v6 = v5 - 12;
  if (a5)
  {
    v8 = &a1[a3];
    v9 = __dst;
    v10 = a1;
    while (1)
    {
      v12 = *v10++;
      v11 = v12;
      v13 = (unint64_t)v12 >> 4;
      if ((_DWORD)v13 == 15)
      {
        v13 = 15;
        if (v10 < v8)
        {
          do
          {
            v15 = *v10++;
            v14 = v15;
            v13 += v15;
          }
          while (v10 < v8 && v14 == 255);
        }
      }
      v16 = &v9[v13];
      v17 = (unint64_t)&v10[v13];
      if (&v9[v13] > v6 || v17 > (unint64_t)(v8 - 8))
        break;
      do
      {
        v19 = *(_QWORD *)v10;
        v10 += 8;
        *(_QWORD *)v9 = v19;
        v9 += 8;
        v13 -= 8;
      }
      while (v9 < v16);
      v20 = &v10[v13];
      v21 = *(unsigned __int16 *)v20;
      v10 = v20 + 2;
      v22 = &v16[-v21];
      if (v22 < __dst)
        return (~(_DWORD)v10 + (_DWORD)a1);
      v23 = v11 & 0xF;
      if ((v11 & 0xF) == 0xF)
      {
        v23 = 15;
        do
        {
          if (v10 >= v8 - 6)
            break;
          v24 = *v10++;
          v23 += v24;
        }
        while (v24 == 255);
      }
      v25 = v16 - v22;
      if (v16 - v22 <= 7)
      {
        v30 = LZ4_decompress_generic_dec64table[v25];
        *v16 = *v22;
        v16[1] = v22[1];
        v16[2] = v22[2];
        v16[3] = v22[3];
        v31 = &v22[qword_1DAD14190[v25]];
        *((_DWORD *)v16 + 1) = *(_DWORD *)v31;
        v26 = &v31[-v30];
      }
      else
      {
        v27 = *(_QWORD *)v22;
        v26 = v22 + 8;
        *(_QWORD *)v16 = v27;
      }
      v28 = v16 + 8;
      v9 = &v16[v23 + 4];
      if (v9 > v5 - 12)
      {
        if (v9 > v5 - 5)
          return (~(_DWORD)v10 + (_DWORD)a1);
        while (v28 < (_QWORD *)v5 - 1)
        {
          v32 = *(_QWORD *)v26;
          v26 += 8;
          *v28++ = v32;
        }
        while (v28 < (_QWORD *)v9)
        {
          v33 = *v26++;
          *(_BYTE *)v28 = v33;
          v28 = (_QWORD *)((char *)v28 + 1);
        }
      }
      else
      {
        do
        {
          v29 = *(_QWORD *)v26;
          v26 += 8;
          *v28++ = v29;
        }
        while (v28 < (_QWORD *)v9);
      }
    }
    if (v16 <= v5 && v17 <= (unint64_t)v8)
    {
      memcpy(v9, v10, v13);
      return ((_DWORD)v16 - (_DWORD)__dst);
    }
    return (~(_DWORD)v10 + (_DWORD)a1);
  }
  else if (a3 == 1)
  {
    if (*a1)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t LZ4_decompress_fast_withPrefix64k(unsigned __int8 *__src, char *__dst, int a3)
{
  int v3;
  char *v4;
  char *v5;
  unsigned __int8 *v6;
  char v7;
  unsigned int v8;
  size_t v9;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  char *v18;
  char *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char v26;

  v3 = (int)__src;
  if (a3)
  {
    v4 = &__dst[a3];
    v5 = v4 - 8;
    v6 = __src;
    while (1)
    {
      v8 = *v6++;
      v7 = v8;
      v9 = (unint64_t)v8 >> 4;
      if ((_DWORD)v9 == 15)
      {
        v9 = 15;
        do
        {
          v10 = *v6++;
          v9 += v10;
        }
        while (v10 == 255);
      }
      v11 = &__dst[v9];
      if (&__dst[v9] > v5)
        break;
      do
      {
        v12 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)__dst = v12;
        __dst += 8;
        v9 -= 8;
      }
      while (__dst < v11);
      v13 = &v6[v9];
      v15 = *(unsigned __int16 *)v13;
      v6 = v13 + 2;
      v14 = v15;
      v16 = v7 & 0xF;
      if ((v7 & 0xF) == 0xF)
      {
        v16 = 15;
        do
        {
          v17 = *v6++;
          v16 += v17;
        }
        while (v17 == 255);
      }
      v18 = &v11[-v14];
      if (v14 <= 7)
      {
        v23 = LZ4_decompress_generic_dec64table[v14];
        *v11 = *v18;
        v11[1] = v18[1];
        v11[2] = v18[2];
        v11[3] = v18[3];
        v24 = &v18[qword_1DAD14190[v14]];
        *((_DWORD *)v11 + 1) = *(_DWORD *)v24;
        v19 = &v24[-v23];
      }
      else
      {
        v20 = *(_QWORD *)v18;
        v19 = v18 + 8;
        *(_QWORD *)v11 = v20;
      }
      v21 = v11 + 8;
      __dst = (char *)v21 + v16 - 4;
      if (__dst > v4 - 12)
      {
        if (__dst > v4 - 5)
          return (~(_DWORD)v6 + v3);
        while (v21 < (_QWORD *)v5)
        {
          v25 = *(_QWORD *)v19;
          v19 += 8;
          *v21++ = v25;
        }
        while (v21 < (_QWORD *)__dst)
        {
          v26 = *v19++;
          *(_BYTE *)v21 = v26;
          v21 = (_QWORD *)((char *)v21 + 1);
        }
      }
      else
      {
        do
        {
          v22 = *(_QWORD *)v19;
          v19 += 8;
          *v21++ = v22;
        }
        while (v21 < (_QWORD *)__dst);
      }
    }
    if (v11 != v4)
      return (~(_DWORD)v6 + v3);
    memcpy(__dst, v6, v9);
    return ((_DWORD)v6 + v9 - v3);
  }
  else if (*__src)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

uint64_t LZ4_decompress_fast(unsigned __int8 *__src, char *__dst, int a3)
{
  int v3;
  char *v4;
  char *v5;
  unsigned __int8 *v6;
  char v7;
  unsigned int v8;
  size_t v9;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  char *v18;
  char *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char v26;

  v3 = (int)__src;
  if (a3)
  {
    v4 = &__dst[a3];
    v5 = v4 - 8;
    v6 = __src;
    while (1)
    {
      v8 = *v6++;
      v7 = v8;
      v9 = (unint64_t)v8 >> 4;
      if ((_DWORD)v9 == 15)
      {
        v9 = 15;
        do
        {
          v10 = *v6++;
          v9 += v10;
        }
        while (v10 == 255);
      }
      v11 = &__dst[v9];
      if (&__dst[v9] > v5)
        break;
      do
      {
        v12 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)__dst = v12;
        __dst += 8;
        v9 -= 8;
      }
      while (__dst < v11);
      v13 = &v6[v9];
      v15 = *(unsigned __int16 *)v13;
      v6 = v13 + 2;
      v14 = v15;
      v16 = v7 & 0xF;
      if ((v7 & 0xF) == 0xF)
      {
        v16 = 15;
        do
        {
          v17 = *v6++;
          v16 += v17;
        }
        while (v17 == 255);
      }
      v18 = &v11[-v14];
      if (v14 <= 7)
      {
        v23 = LZ4_decompress_generic_dec64table[v14];
        *v11 = *v18;
        v11[1] = v18[1];
        v11[2] = v18[2];
        v11[3] = v18[3];
        v24 = &v18[qword_1DAD14190[v14]];
        *((_DWORD *)v11 + 1) = *(_DWORD *)v24;
        v19 = &v24[-v23];
      }
      else
      {
        v20 = *(_QWORD *)v18;
        v19 = v18 + 8;
        *(_QWORD *)v11 = v20;
      }
      v21 = v11 + 8;
      __dst = (char *)v21 + v16 - 4;
      if (__dst > v4 - 12)
      {
        if (__dst > v4 - 5)
          return (~(_DWORD)v6 + v3);
        while (v21 < (_QWORD *)v5)
        {
          v25 = *(_QWORD *)v19;
          v19 += 8;
          *v21++ = v25;
        }
        while (v21 < (_QWORD *)__dst)
        {
          v26 = *v19++;
          *(_BYTE *)v21 = v26;
          v21 = (_QWORD *)((char *)v21 + 1);
        }
      }
      else
      {
        do
        {
          v22 = *(_QWORD *)v19;
          v19 += 8;
          *v21++ = v22;
        }
        while (v21 < (_QWORD *)__dst);
      }
    }
    if (v11 != v4)
      return (~(_DWORD)v6 + v3);
    memcpy(__dst, v6, v9);
    return ((_DWORD)v6 + v9 - v3);
  }
  else if (*__src)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

uint64_t lz4_decode_safe(void **a1, unint64_t a2, char *a3, unint64_t *a4, unint64_t a5)
{
  char *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v12;
  char v13;
  unsigned int v14;
  size_t v15;
  unsigned __int8 *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  size_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  _BYTE *v30;

  v6 = (char *)*a1;
  v7 = (unsigned __int8 *)*a4;
  v30 = *a1;
  if (*a4 >= a5)
  {
    v20 = (char *)*a1;
    return v20 - v30;
  }
  else
  {
    while (1)
    {
      *a4 = (unint64_t)v7;
      *a1 = v6;
      v14 = *v7;
      v12 = v7 + 1;
      v13 = v14;
      v15 = (unint64_t)v14 >> 4;
      if ((_DWORD)v15 == 15)
      {
        v15 = 15;
        while ((unint64_t)v12 < a5)
        {
          v22 = *v12++;
          v15 += v22;
          if (v22 != 255)
            goto LABEL_3;
        }
        return 0;
      }
LABEL_3:
      v16 = &v12[v15];
      if ((unint64_t)&v12[v15] > a5)
        return 0;
      v17 = &v6[v15];
      if (&v6[v15] > a3)
        break;
      memcpy(v6, v12, v15);
      if ((unint64_t)v16 >= a5)
      {
        v20 = &v6[v15];
        return v20 - v30;
      }
      v7 = v16 + 2;
      if ((unint64_t)(v16 + 2) > a5)
        return 0;
      v18 = *(unsigned __int16 *)v16;
      if (!*(_WORD *)v16 || (unint64_t)&v17[-v18] < a2)
        return 0;
      v19 = (v13 & 0xF) + 4;
      if ((v13 & 0xF) == 0xF)
      {
        v19 = 19;
        while ((unint64_t)v7 < a5)
        {
          v23 = *v7++;
          v19 += v23;
          if (v23 != 255)
            goto LABEL_10;
        }
        return 0;
      }
LABEL_10:
      v20 = &v17[v19];
      if (&v17[v19] > a3)
      {
        if (a3 != v17)
        {
          if ((unint64_t)(a3 - v17) <= 1)
            v27 = 1;
          else
            v27 = a3 - v17;
          v28 = &v6[v15];
          v29 = -v18;
          do
          {
            *v28 = v28[v29];
            ++v28;
            --v27;
          }
          while (v27);
        }
        v26 = a3;
        return v26 - v30;
      }
      if (v19)
      {
        v21 = -v18;
        do
        {
          *v17 = v17[v21];
          ++v17;
          --v19;
        }
        while (v19);
      }
      v6 = v20;
      if ((unint64_t)v7 >= a5)
        return v20 - v30;
    }
    v25 = a3 - v6;
    if (v25)
      memcpy(v6, v12, v25);
    v26 = &v6[v25];
    return v26 - v30;
  }
}

uint64_t APPLIB_API_SUBSYS_SendCommand(void *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  unsigned int v7;

  if (!a1)
    return 0xFFFFFFFFLL;
  bzero(a1, a2);
  if (!HDLCFrameCreateUplink())
    return 0xFFFFFFFFLL;
  if ((HDLCFrameInject() & 1) == 0 || a6 && (HDLCFrameInject() & 1) == 0)
  {
    HDLCFrameFree();
    return 0xFFFFFFFFLL;
  }
  v7 = HDLCFrameEncode();
  HDLCFrameFree();
  if (v7)
    return v7;
  else
    return 0xFFFFFFFFLL;
}

uint64_t APPLIB_API_SUBSYS_ParseHeader(uint64_t a1, unsigned int a2, int a3, _WORD *a4, _DWORD *a5)
{
  if (a2 < 4)
    return 0;
  if (*(_BYTE *)a1 != 75 || *(unsigned __int8 *)(a1 + 1) != a3)
    return 0;
  *a4 = *(_WORD *)(a1 + 2);
  *a5 = 4;
  return 1;
}

BOOL APPLIB_API_SUBSYS_ParseGetAntennaConfigResp(uint64_t a1, _DWORD *a2)
{
  int v2;

  v2 = *(unsigned __int16 *)(a1 + 4);
  if (v2 == 1)
    *a2 = *(unsigned __int16 *)(a1 + 6);
  return v2 == 1;
}

uint64_t APPLIB_API_SUBSYS_ParseGetRSSIResp(uint64_t a1, int a2, float *a3)
{
  if (a2 > 1 || *(_WORD *)(a1 + 4) != 1)
    return 0;
  *a3 = (float)(__int16)~*(_WORD *)(a1 + 2 * a2 + 12) * -0.1;
  return 1;
}

uint64_t ETLBBCreateDeassertResetDetectCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLBBParseDeassertResetDetectResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;

  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v8 = **a1;
    if (v8 == 75)
    {
      if (BYTE1(v8) == 253)
      {
        v9 = HIWORD(v8);
        if ((_DWORD)v9 == 7)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v9);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v8));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLBBCreatePingCommand()
{
  return HDLCFrameInjectUnsignedChar();
}

BOOL ETLBBParsePingResponse(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  _BOOL8 result;

  v2 = *a2;
  result = *(_DWORD *)(a1 + 8) != (_DWORD)v2 && *(unsigned __int8 *)(*(_QWORD *)a1 + v2) == 123;
  *a2 = v2 + 1;
  return result;
}

_QWORD *ETLBBEchoParametersInit(_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  return result;
}

uint64_t ETLBBCreateEchoCommand(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = HDLCFrameInjectUnsignedChar();
  if ((_DWORD)result)
  {
    v4 = *(unsigned int *)(a2 + 8);
    if (HDLCFrameGetFreeSpace() >= v4)
    {
      if (*(_DWORD *)(a2 + 8))
        return HDLCFrameInject();
      else
        return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v5, v6, v7, v8, v9, v10, v4);
      return 0;
    }
  }
  return result;
}

uint64_t ETLBBParseEchoResponse(uint64_t a1, uint64_t a2, BOOL *a3)
{
  int v3;
  _BYTE *v4;
  size_t v6;
  int v7;
  BOOL v8;

  *a3 = 0;
  v3 = *(_DWORD *)(a1 + 8);
  if (!v3)
    return 0;
  v4 = *(_BYTE **)a1;
  if (**(_BYTE **)a1 != 123)
    return 0;
  v6 = (v3 - 1);
  v7 = *(_DWORD *)(a2 + 8);
  *a3 = (_DWORD)v6 == v7;
  if (v7)
  {
    v8 = (_DWORD)v6 == v7 && memcmp(v4 + 1, *(const void **)a2, v6) == 0;
    *a3 = v8;
  }
  return 1;
}

uint64_t ETLBBCreateSimulateCrashCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLBBCreateSimulateCrashCommandExt(uint64_t a1, uint64_t a2)
{
  uint64_t FreeSpace;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v4, v5, v6, v7, v8, v9, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (a2)
      return HDLCFrameInject();
    else
      return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v10, v11, v12, v13, v14, v15, v17);
    return 0;
  }
}

uint64_t ETLBBParseSimulateCrashResponse(unsigned int *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  capabilities::etl::supportsBBAppsCrash((capabilities::etl *)a1);
  if (a1[2] < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v2, v3, v4, v5, v6, v7, a1[2]);
    return 0;
  }
  else if (**(_BYTE **)a1 == 75)
  {
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v2, v3, v4, v5, v6, v7, **(unsigned __int8 **)a1);
    return 0;
  }
}

uint64_t ETLBBPing(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  int v16;

  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBPing", (uint64_t)"Failed to create command frame\n", v2, v3, v4, v5, v6, v7, 0);
LABEL_10:
    v14 = 0;
    goto LABEL_11;
  }
  if (!HDLCFrameInjectUnsignedChar())
    goto LABEL_10;
  v8 = malloc(0x20uLL);
  if (!v8)
    goto LABEL_10;
  v9 = v8;
  v10 = HDLCFrameEncode();
  if ((_DWORD)v10)
  {
    v11 = v10;
    v12 = -1431655766;
    v16 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v9, v10);
    if (*a1)
    {
      v13 = (*a1)(a1, v9, v11, &v16, 1, 1000, 0);
      v12 = v16;
    }
    else
    {
      v13 = 0;
    }
    if (v12 == (_DWORD)v11)
      v14 = v13;
    else
      v14 = 0;
  }
  else
  {
    v14 = 0;
  }
  free(v9);
LABEL_11:
  HDLCFrameFree();
  return v14;
}

BOOL ETLBBPingCheckResponse(uint64_t a1, unsigned int a2)
{
  int v4;
  _BOOL8 v5;
  char v7;
  _OWORD v8[2];
  uint64_t v9;

  v9 = 0;
  memset(v8, 0, sizeof(v8));
  v7 = 123;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v4 = ETLFindMatchingResponseUsingBuffer(a1, (unsigned __int8 **)v8, (uint64_t)&_ETLResponseRingBuffer, &v7, a2);
  v5 = 0;
  if (v4 && DWORD2(v8[0]))
    v5 = **(_BYTE **)&v8[0] == 123;
  HDLCFrameFree();
  return v5;
}

uint64_t ETLBBSendEcho(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;

  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBSendEcho", (uint64_t)"Failed to create command frame\n", v4, v5, v6, v7, v8, v9, v25);
    goto LABEL_6;
  }
  if (!HDLCFrameInjectUnsignedChar())
  {
LABEL_6:
    v17 = 0;
    goto LABEL_7;
  }
  v10 = *(unsigned int *)(a2 + 8);
  if (HDLCFrameGetFreeSpace() < v10)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v11, v12, v13, v14, v15, v16, v10);
    goto LABEL_6;
  }
  if (*(_DWORD *)(a2 + 8) && !HDLCFrameInject())
    goto LABEL_6;
  v19 = malloc(0x20uLL);
  if (!v19)
    goto LABEL_6;
  v20 = v19;
  v21 = HDLCFrameEncode();
  if ((_DWORD)v21)
  {
    v22 = v21;
    v23 = -1431655766;
    v26 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v20, v21);
    if (*a1)
    {
      v24 = (*a1)(a1, v20, v22, &v26, 1, 1000, 0);
      v23 = v26;
    }
    else
    {
      v24 = 0;
    }
    if (v23 == (_DWORD)v22)
      v17 = v24;
    else
      v17 = 0;
  }
  else
  {
    v17 = 0;
  }
  free(v20);
LABEL_7:
  HDLCFrameFree();
  return v17;
}

uint64_t ETLBBCheckEchoResponse(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  char v27;
  _OWORD v28[2];
  uint64_t v29;

  v29 = 0;
  memset(v28, 0, sizeof(v28));
  v27 = 123;
  if (a3)
  {
    while (1)
    {
      if (!_ETLResponseRingBuffer)
        TelephonyUtilRingBufferInitialize();
      if (!ETLFindMatchingResponseUsingBuffer(a1, (unsigned __int8 **)v28, (uint64_t)&_ETLResponseRingBuffer, &v27, a4)|| !DWORD2(v28[0])|| **(_BYTE **)&v28[0] != 123)
      {
        break;
      }
      v14 = DWORD2(v28[0]) - 1;
      v15 = *(_DWORD *)(a2 + 8);
      if (v15 && v14 == v15)
      {
        v7 = memcmp((const void *)(*(_QWORD *)&v28[0] + 1), *(const void **)a2, (DWORD2(v28[0]) - 1));
        HDLCFrameFree();
        if (!v7)
          return 1;
      }
      else
      {
        HDLCFrameFree();
        if (!v15 && !v14)
          return 1;
      }
      _ETLDebugPrint((uint64_t)"ETLBBCheckEchoResponse", (uint64_t)"Mismatch, continue\n", v8, v9, v10, v11, v12, v13, v26);
    }
    goto LABEL_24;
  }
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  if (!ETLFindMatchingResponseUsingBuffer(a1, (unsigned __int8 **)v28, (uint64_t)&_ETLResponseRingBuffer, &v27, a4)|| !DWORD2(v28[0])|| **(_BYTE **)&v28[0] != 123)
  {
LABEL_24:
    HDLCFrameFree();
    return 0;
  }
  v16 = DWORD2(v28[0]) - 1;
  v17 = *(_DWORD *)(a2 + 8);
  if (!v17 || v16 != v17)
  {
    HDLCFrameFree();
    if (!v17 && !v16)
      return 1;
LABEL_29:
    _ETLDebugPrint((uint64_t)"ETLBBCheckEchoResponse", (uint64_t)"Mismatch, bail\n", v19, v20, v21, v22, v23, v24, v26);
    return 0;
  }
  v18 = memcmp((const void *)(*(_QWORD *)&v28[0] + 1), *(const void **)a2, (DWORD2(v28[0]) - 1));
  HDLCFrameFree();
  if (v18)
    goto LABEL_29;
  return 1;
}

uint64_t ETLBBGetVersion(_QWORD *a1, _OWORD *a2, unsigned int a3)
{
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  const void *v9;
  size_t v10;
  char v12;
  _OWORD v13[2];
  unint64_t v14;
  int v15;
  int v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  _BYTE v47[28];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v15 = -1431655766;
  v46 = 0u;
  memset(v47, 0, sizeof(v47));
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v33 = 0u;
  v32 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  v16 = 2118751100;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(void *, _QWORD, int *, uint64_t))*(&gDelegate + 1))(&unk_1DAD155B3, 0, &v16, 4);
  if (!*a1)
    return 0;
  v6 = 0;
  if (((unsigned int (*)(_QWORD *, int *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, &v16, 4, &v15, 1, 1000, 0)&& v15 == 4)
  {
    v14 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v13[0] = v7;
    v13[1] = v7;
    v12 = 124;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v8 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v13, (uint64_t)&_ETLResponseRingBuffer, &v12, a3);
    if (v12 == 124)
      v6 = v8;
    else
      v6 = 0;
    if ((_DWORD)v6 == 1)
    {
      *(_OWORD *)((char *)a2 + 251) = 0u;
      a2[14] = 0u;
      a2[15] = 0u;
      a2[12] = 0u;
      a2[13] = 0u;
      a2[10] = 0u;
      a2[11] = 0u;
      a2[8] = 0u;
      a2[9] = 0u;
      a2[6] = 0u;
      a2[7] = 0u;
      a2[4] = 0u;
      a2[5] = 0u;
      a2[2] = 0u;
      a2[3] = 0u;
      v9 = (const void *)(*(_QWORD *)&v13[0] + 1);
      if ((unint64_t)DWORD2(v13[0]) - 1 >= 0x10B)
        v10 = 267;
      else
        v10 = DWORD2(v13[0]) - 1;
      *a2 = 0uLL;
      a2[1] = 0uLL;
      memcpy(a2, v9, v10);
    }
    HDLCFrameFree();
  }
  return v6;
}

uint64_t ETLBBEnterDownloadMode(_QWORD *a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v13;
  uint64_t v14;
  char v15;
  _OWORD v16[2];
  unint64_t v17;
  int v18;
  int v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _BYTE v50[28];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v18 = -1431655766;
  v49 = 0u;
  memset(v50, 0, sizeof(v50));
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v36 = 0u;
  v35 = 0u;
  v34 = 0u;
  v33 = 0u;
  v32 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 2121179450;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(void *, _QWORD, int *, uint64_t))*(&gDelegate + 1))(&unk_1DAD155B3, 0, &v19, 4);
  if (!*a1)
    return 0;
  v4 = 0;
  if (((unsigned int (*)(_QWORD *, int *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, &v19, 4, &v18, 1, 1000, 0)&& v18 == 4)
  {
    v17 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v16[0] = v5;
    v16[1] = v5;
    v15 = 58;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if ((ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v16, (uint64_t)&_ETLResponseRingBuffer, &v15, a2) & 1) != 0)
    {
      if (v15 == 58)
      {
        v4 = 1;
LABEL_16:
        HDLCFrameFree();
        return v4;
      }
      v14 = 58;
      v13 = "Command code expected %u, got %u\n";
    }
    else
    {
      v13 = "Failed to get response\n";
    }
    _ETLDebugPrint((uint64_t)"ETLBBEnterDownloadMode", (uint64_t)v13, v6, v7, v8, v9, v10, v11, v14);
    v4 = 0;
    goto LABEL_16;
  }
  return v4;
}

uint64_t ETLBBCreateUnlockCommand(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = (*(_DWORD *)(a2 + 8) + 2);
  if (HDLCFrameGetFreeSpace() >= v2)
  {
    if (HDLCFrameInjectUnsignedChar())
      return HDLCFrameInject();
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v3, v4, v5, v6, v7, v8, v2);
  }
  return 0;
}

BOOL ETLBBParseUnlockResponse(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[2] != 1)
    return *(_BYTE *)(*(_QWORD *)a1 + 1) == 1;
  _ETLDebugPrint((uint64_t)"ETLCheckPayloadLength", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 1);
  return 0;
}

unint64_t ETLBBUnlock(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v25[2];
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  char v30;
  int v31;

  v3 = 0;
  v30 = 65;
  if (a1 && a2)
  {
    v27 = 0u;
    v28 = 0u;
    v29 = 0;
    memset(v25, 0, sizeof(v25));
    v26 = 0;
    if (HDLCFrameCreateUplink())
    {
      v7 = (*(_DWORD *)(a2 + 8) + 2);
      if (HDLCFrameGetFreeSpace() >= v7)
      {
        if (HDLCFrameInjectUnsignedChar() && HDLCFrameInject())
        {
          v3 = (unint64_t)malloc((2 * DWORD2(v27) + 32));
          if (!v3)
          {
LABEL_21:
            HDLCFrameFree();
            HDLCFrameFree();
            return v3;
          }
          v14 = HDLCFrameEncode();
          if (!(_DWORD)v14)
            goto LABEL_19;
          v15 = v14;
          v31 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v3, v14);
          if (*a1)
          {
            v16 = (*a1)(a1, (void *)v3, v15, &v31, 1, a3, 0);
            v17 = v31;
            free((void *)v3);
            v3 = 0;
            if (!v16 || v17 != (_DWORD)v15)
              goto LABEL_21;
            if (ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v25, &v30, a3))
            {
              if (DWORD2(v25[0]) != 1)
              {
                v3 = *(unsigned __int8 *)(*(_QWORD *)&v25[0] + 1) == 1;
                goto LABEL_21;
              }
              _ETLDebugPrint((uint64_t)"ETLCheckPayloadLength", (uint64_t)"Need %u bytes, but only have %u\n", v18, v19, v20, v21, v22, v23, 1);
            }
          }
          else
          {
LABEL_19:
            free((void *)v3);
          }
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v8, v9, v10, v11, v12, v13, v7);
      }
    }
    v3 = 0;
    goto LABEL_21;
  }
  return v3;
}

uint64_t ETLBBDeAssertResetDetect(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v30 = "ETLBBDeAssertResetDetect";
    v31 = "Failed to create command frame\n";
LABEL_23:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v4, v5, v6, v7, v8, v9, v33);
    goto LABEL_24;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_24;
  }
  v39 = 523595;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v30 = "ETLSubsysAddHeaderInternal";
    v31 = "Failed to inject\n";
    goto LABEL_23;
  }
  v17 = (uint64_t)malloc((2 * DWORD2(v36) + 32));
  if (v17)
  {
    v18 = HDLCFrameEncode();
    if (!(_DWORD)v18)
      goto LABEL_26;
    v19 = v18;
    v39 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
    if (!*a1)
    {
LABEL_26:
      free((void *)v17);
      goto LABEL_24;
    }
    v20 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v17, v19, &v39, 1, a2, 0);
    v21 = v39;
    free((void *)v17);
    v17 = 0;
    if (v20)
    {
      if (v21 == (_DWORD)v19)
      {
        LOBYTE(v39) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v17 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2))
        {
          if (v39 == 75)
          {
            if (DWORD2(v34[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v22, v23, v24, v25, v26, v27, DWORD2(v34[0]));
            }
            else
            {
              v28 = **(_DWORD **)&v34[0];
              if (**(_DWORD **)&v34[0] == 75)
              {
                if (BYTE1(v28) == 253)
                {
                  v29 = HIWORD(v28);
                  if ((_DWORD)v29 == 7)
                  {
                    v17 = 1;
                    goto LABEL_25;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, v29);
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, BYTE1(v28));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, **(_DWORD **)&v34[0]);
              }
            }
LABEL_24:
            v17 = 0;
          }
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

uint64_t ETLBBPowerDown(uint64_t (**a1)(_QWORD, _OWORD *, uint64_t, int *, uint64_t, uint64_t, _QWORD))
{
  __int128 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v14;
  int v15;
  _OWORD v16[32];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v15 = -1431655766;
  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[30] = v2;
  v16[31] = v2;
  v16[28] = v2;
  v16[29] = v2;
  v16[26] = v2;
  v16[27] = v2;
  v16[24] = v2;
  v16[25] = v2;
  v16[22] = v2;
  v16[23] = v2;
  v16[20] = v2;
  v16[21] = v2;
  v16[18] = v2;
  v16[19] = v2;
  v16[16] = v2;
  v16[17] = v2;
  v16[14] = v2;
  v16[15] = v2;
  v16[12] = v2;
  v16[13] = v2;
  v16[10] = v2;
  v16[11] = v2;
  v16[8] = v2;
  v16[9] = v2;
  v16[6] = v2;
  v16[7] = v2;
  v16[4] = v2;
  v16[5] = v2;
  v16[2] = v2;
  v16[3] = v2;
  v16[0] = v2;
  v16[1] = v2;
  v3 = APPLIB_API_SUBSYS_SendCommand(v16, 0x200u, 253, 9, 0, 0);
  if ((int)v3 <= 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBPowerDown", (uint64_t)"Failed to create unlock command\n", v4, v5, v6, v7, v8, v9, v14);
    return 0;
  }
  else
  {
    v10 = v3;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(void *, _QWORD, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1DAD155B3, 0, v16, v3);
    if (*a1)
    {
      v11 = (*a1)(a1, v16, v10, &v15, 1, 1000, 0);
      v12 = 0;
      if (v11 && v15 == (_DWORD)v10)
      {
        v12 = 1;
        sleep(1u);
      }
    }
    else
    {
      return 0;
    }
  }
  return v12;
}

BOOL ETLBBSetCoreDumpMode(unsigned int (**a1)(_QWORD, _OWORD *, uint64_t, int *, uint64_t, uint64_t, _QWORD), __int16 a2, unsigned int a3)
{
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL8 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  char v24;
  _OWORD v25[2];
  unint64_t v26;
  int v27;
  _OWORD v28[32];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v27 = -1431655766;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v28[30] = v5;
  v28[31] = v5;
  v28[28] = v5;
  v28[29] = v5;
  v28[26] = v5;
  v28[27] = v5;
  v28[24] = v5;
  v28[25] = v5;
  v28[22] = v5;
  v28[23] = v5;
  v28[20] = v5;
  v28[21] = v5;
  v28[18] = v5;
  v28[19] = v5;
  v28[16] = v5;
  v28[17] = v5;
  v28[14] = v5;
  v28[15] = v5;
  v28[12] = v5;
  v28[13] = v5;
  v28[10] = v5;
  v28[11] = v5;
  v28[8] = v5;
  v28[9] = v5;
  v28[6] = v5;
  v28[7] = v5;
  v28[5] = v5;
  v28[3] = v5;
  v28[4] = v5;
  v28[1] = v5;
  v28[2] = v5;
  v28[0] = v5;
  LOWORD(v25[0]) = a2;
  v6 = APPLIB_API_SUBSYS_SendCommand(v28, 0x200u, 253, 10, (uint64_t)v25, 2);
  if ((int)v6 <= 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBSetCoreDumpMode", (uint64_t)"Failed to create set core dump mode command\n", v7, v8, v9, v10, v11, v12, v23);
    return 0;
  }
  else
  {
    v13 = v6;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(void *, _QWORD, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1DAD155B3, 0, v28, v6);
    if (*a1)
    {
      v14 = 0;
      if ((*a1)(a1, v28, v13, &v27, 1, 1000, 0) && v27 == (_DWORD)v13)
      {
        v26 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v25[0] = v15;
        v25[1] = v15;
        v24 = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        if ((ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &v24, a3) & 1) != 0)
        {
          v14 = v24 == 75;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLBBSetCoreDumpMode", (uint64_t)"Did not find matching response\n", v16, v17, v18, v19, v20, v21, v23);
          v14 = 0;
        }
        HDLCFrameFree();
      }
    }
    else
    {
      return 0;
    }
  }
  return v14;
}

uint64_t ETLBBSimulateCrash(_QWORD *a1, uint64_t a2)
{
  return ETLBBSimulateCrashExt(a1, a2, 0);
}

uint64_t ETLBBSimulateCrashExt(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  const char *v26;
  const char *v27;
  uint64_t v29;
  int v30;

  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v26 = "ETLBBSimulateCrashExt";
    v27 = "Failed to create command frame\n";
LABEL_17:
    _ETLDebugPrint((uint64_t)v26, (uint64_t)v27, v6, v7, v8, v9, v10, v11, v29);
    goto LABEL_18;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
LABEL_18:
    v25 = 0;
    goto LABEL_19;
  }
  v30 = 268641611;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v26 = "ETLSubsysAddHeaderInternal";
    v27 = "Failed to inject\n";
    goto LABEL_17;
  }
  if (a3 && !HDLCFrameInject())
    goto LABEL_18;
  v19 = malloc(0x20uLL);
  if (!v19)
    goto LABEL_18;
  v20 = v19;
  v21 = HDLCFrameEncode();
  if (!(_DWORD)v21)
    goto LABEL_20;
  v22 = v21;
  v30 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v20, v21);
  if (!*a1)
  {
LABEL_20:
    free(v20);
    goto LABEL_18;
  }
  v23 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v20, v22, &v30, 1, a2, 0);
  v24 = v30;
  free(v20);
  v25 = 0;
  if (v23 && v24 == (_DWORD)v22)
  {
    usleep(0x30D40u);
    v25 = 1;
  }
LABEL_19:
  HDLCFrameFree();
  HDLCFrameFree();
  return v25;
}

uint64_t ETLBBCreateSetModeCommand()
{
  uint64_t result;

  result = HDLCFrameInjectUnsignedChar();
  if ((_DWORD)result)
    return HDLCFrameInjectUnsignedShort();
  return result;
}

BOOL ETLBBParseSetModeResponse(unsigned __int8 **a1)
{
  return *((_DWORD *)a1 + 2) && **a1 == 41;
}

unint64_t ETLBBSetMode(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v17;
  char v18;
  _OWORD v19[2];
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  int v24;

  v21 = 0u;
  v22 = 0u;
  v23 = 0;
  memset(v19, 0, sizeof(v19));
  v20 = 0;
  v18 = 41;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBSetMode", (uint64_t)"Failed to create command frame\n", v5, v6, v7, v8, v9, v10, v17);
LABEL_17:
    v11 = 0;
    goto LABEL_18;
  }
  if (!HDLCFrameInjectUnsignedChar() || !HDLCFrameInjectUnsignedShort())
    goto LABEL_17;
  v11 = (unint64_t)malloc((2 * DWORD2(v21) + 32));
  if (!v11)
    goto LABEL_18;
  v12 = HDLCFrameEncode();
  if (!(_DWORD)v12)
    goto LABEL_19;
  v13 = v12;
  v24 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
  if (!*a1)
  {
LABEL_19:
    free((void *)v11);
    goto LABEL_17;
  }
  v14 = ((uint64_t (*)(_QWORD *, unint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v11, v13, &v24, 1, a3, 0);
  v15 = v24;
  free((void *)v11);
  v11 = 0;
  if (v14 && v15 == (_DWORD)v13)
  {
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v11 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v19, (uint64_t)&_ETLResponseRingBuffer, &v18, a3)&& DWORD2(v19[0]))
    {
      v11 = **(_BYTE **)&v19[0] == 41;
    }
  }
LABEL_18:
  HDLCFrameFree();
  HDLCFrameFree();
  return v11;
}

uint64_t ETLBBSetAntennaConfig(_QWORD *a1, __int16 a2, unsigned int a3)
{
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  __int128 v15;
  unsigned int v16;
  uint64_t v17;
  _OWORD v19[2];
  unint64_t v20;
  int v21;
  char v22;
  _OWORD v23[32];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v21 = 0;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[30] = v5;
  v23[31] = v5;
  v23[28] = v5;
  v23[29] = v5;
  v23[26] = v5;
  v23[27] = v5;
  v23[24] = v5;
  v23[25] = v5;
  v23[22] = v5;
  v23[23] = v5;
  v23[20] = v5;
  v23[21] = v5;
  v23[18] = v5;
  v23[19] = v5;
  v23[16] = v5;
  v23[17] = v5;
  v23[14] = v5;
  v23[15] = v5;
  v23[12] = v5;
  v23[13] = v5;
  v23[10] = v5;
  v23[11] = v5;
  v23[8] = v5;
  v23[9] = v5;
  v23[6] = v5;
  v23[7] = v5;
  v23[4] = v5;
  v23[5] = v5;
  v23[2] = v5;
  v23[3] = v5;
  v23[0] = v5;
  v23[1] = v5;
  v6 = APPLIB_DIAG_SetOneRx(v23, 512, a2);
  v13 = v6;
  if ((int)v6 <= 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBSetAntennaConfig", (uint64_t)"length %u\n", v7, v8, v9, v10, v11, v12, v6);
    return 0;
  }
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(void *, _QWORD, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1DAD155B3, 0, v23, v6);
  if (!*a1)
  {
    v14 = 0;
LABEL_15:
    _ETLDebugPrint((uint64_t)"ETLBBSetAntennaConfig", (uint64_t)"Failed to write, success = %u, written = %u of %d\n", v7, v8, v9, v10, v11, v12, v14);
    return 0;
  }
  v14 = ((uint64_t (*)(_QWORD *, _OWORD *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v23, v13, &v21, 1, 1000, 0);
  if (!v14 || v21 != (_DWORD)v13)
    goto LABEL_15;
  v20 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[0] = v15;
  v19[1] = v15;
  v22 = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v16 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v19, (uint64_t)&_ETLResponseRingBuffer, &v22, a3);
  if (v22 == 75)
    v17 = v16;
  else
    v17 = 0;
  HDLCFrameFree();
  return v17;
}

uint64_t ETLBBGetAntennaConfig(_QWORD *a1, _DWORD *a2, unsigned int a3)
{
  __int128 v6;
  uint64_t OneRxConfig;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  __int128 v16;
  int v17;
  uint64_t v18;
  _OWORD v20[2];
  unint64_t v21;
  int v22;
  char v23;
  _OWORD v24[32];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v22 = 0;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v24[30] = v6;
  v24[31] = v6;
  v24[28] = v6;
  v24[29] = v6;
  v24[26] = v6;
  v24[27] = v6;
  v24[24] = v6;
  v24[25] = v6;
  v24[22] = v6;
  v24[23] = v6;
  v24[20] = v6;
  v24[21] = v6;
  v24[18] = v6;
  v24[19] = v6;
  v24[16] = v6;
  v24[17] = v6;
  v24[14] = v6;
  v24[15] = v6;
  v24[12] = v6;
  v24[13] = v6;
  v24[10] = v6;
  v24[11] = v6;
  v24[8] = v6;
  v24[9] = v6;
  v24[6] = v6;
  v24[7] = v6;
  v24[4] = v6;
  v24[5] = v6;
  v24[2] = v6;
  v24[3] = v6;
  v24[0] = v6;
  v24[1] = v6;
  OneRxConfig = APPLIB_DIAG_Get_OneRxConfig(v24, 512);
  if (!a2)
    return 0;
  v14 = OneRxConfig;
  *a2 = 0;
  if ((int)OneRxConfig <= 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBGetAntennaConfig", (uint64_t)"length %u\n", v8, v9, v10, v11, v12, v13, OneRxConfig);
    return 0;
  }
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(void *, _QWORD, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1DAD155B3, 0, v24, OneRxConfig);
  if (!*a1)
  {
    v15 = 0;
LABEL_16:
    _ETLDebugPrint((uint64_t)"ETLBBGetAntennaConfig", (uint64_t)"Failed to write, success = %u, written = %u of %d\n", v8, v9, v10, v11, v12, v13, v15);
    return 0;
  }
  v15 = ((uint64_t (*)(_QWORD *, _OWORD *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v24, v14, &v22, 1, 1000, 0);
  if (!v15 || v22 != (_DWORD)v14)
    goto LABEL_16;
  v21 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[0] = v16;
  v20[1] = v16;
  v23 = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v17 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v20, (uint64_t)&_ETLResponseRingBuffer, &v23, a3);
  v18 = 0;
  if (v17 && v23 == 75)
  {
    if (*(_WORD *)(*(_QWORD *)&v20[0] + 4) == 1)
    {
      *a2 = *(unsigned __int16 *)(*(_QWORD *)&v20[0] + 6);
      v18 = 1;
    }
    else
    {
      v18 = 0;
    }
  }
  HDLCFrameFree();
  return v18;
}

uint64_t ETLBBGetRSSI(_QWORD *a1, int a2, unsigned int a3, float *a4)
{
  __int128 v8;
  uint64_t RSSI_Channel;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  __int128 v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD v28[2];
  unint64_t v29;
  int v30;
  char v31;
  _OWORD v32[32];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v30 = 0;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v32[30] = v8;
  v32[31] = v8;
  v32[28] = v8;
  v32[29] = v8;
  v32[26] = v8;
  v32[27] = v8;
  v32[24] = v8;
  v32[25] = v8;
  v32[22] = v8;
  v32[23] = v8;
  v32[20] = v8;
  v32[21] = v8;
  v32[18] = v8;
  v32[19] = v8;
  v32[16] = v8;
  v32[17] = v8;
  v32[14] = v8;
  v32[15] = v8;
  v32[12] = v8;
  v32[13] = v8;
  v32[10] = v8;
  v32[11] = v8;
  v32[8] = v8;
  v32[9] = v8;
  v32[6] = v8;
  v32[7] = v8;
  v32[4] = v8;
  v32[5] = v8;
  v32[2] = v8;
  v32[3] = v8;
  v32[0] = v8;
  v32[1] = v8;
  RSSI_Channel = APPLIB_DIAG_Get_RSSI_Channel(v32, 512, a2);
  if (!a4)
    return 0;
  v16 = RSSI_Channel;
  *a4 = 0.0;
  if ((int)RSSI_Channel <= 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBGetRSSI", (uint64_t)"length %u\n", v10, v11, v12, v13, v14, v15, RSSI_Channel);
    return 0;
  }
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(void *, _QWORD, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1DAD155B3, 0, v32, RSSI_Channel);
  if (!*a1)
  {
    v17 = 0;
LABEL_17:
    _ETLDebugPrint((uint64_t)"ETLBBGetRSSI", (uint64_t)"Failed to write, success = %u, written = %u of %u\n", v10, v11, v12, v13, v14, v15, v17);
    return 0;
  }
  v17 = ((uint64_t (*)(_QWORD *, _OWORD *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v32, v16, &v30, 1, 1000, 0);
  if (!v17 || v30 != (_DWORD)v16)
    goto LABEL_17;
  v29 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v18 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v28[0] = v18;
  v28[1] = v18;
  v31 = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v19 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v28, (uint64_t)&_ETLResponseRingBuffer, &v31, a3);
  v26 = 0;
  if (v19 && v31 == 75)
  {
    if (a2 <= 1 && *(_WORD *)(*(_QWORD *)&v28[0] + 4) == 1)
    {
      *a4 = (float)(__int16)~*(_WORD *)(*(_QWORD *)&v28[0] + 2 * a2 + 12) * -0.1;
      v26 = 1;
    }
    else
    {
      v26 = 0;
    }
    _ETLDebugPrint((uint64_t)"ETLBBGetRSSI", (uint64_t)"Read success rssi %f\n", v20, v21, v22, v23, v24, v25, COERCE__INT64(*a4));
  }
  HDLCFrameFree();
  return v26;
}

uint64_t crc_16_calc(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v2;
  int v3;
  unsigned __int8 *v4;
  int v5;
  __int16 v6;
  __int16 v7;

  if (a2 < 8)
  {
    v3 = 0xFFFF;
    if (!(_WORD)a2)
      return (unsigned __int16)~(_WORD)v3;
  }
  else
  {
    v2 = ((unsigned __int16)(a2 - 8) >> 3) + 1;
    v3 = 0xFFFF;
    v4 = a1;
    do
    {
      v5 = *v4++;
      v3 = crc16_table[v5 ^ ((unsigned __int16)(v3 & 0xFF00) >> 8)] ^ (v3 << 8);
      LOWORD(a2) = a2 - 8;
    }
    while ((unsigned __int16)a2 > 7u);
    a1 += v2;
    if (!(_WORD)a2)
      return (unsigned __int16)~(_WORD)v3;
  }
  v6 = *a1 << 8;
  do
  {
    LOWORD(a2) = a2 - 1;
    v7 = v6 ^ v3;
    v3 *= 2;
    if (v7 < 0)
      v3 ^= 0x1021u;
    v6 = (2 * v6) & 0xFE00;
  }
  while ((_WORD)a2);
  return (unsigned __int16)~(_WORD)v3;
}

uint64_t crc_16_l_calc(char *a1, unsigned int a2)
{
  unsigned int v2;
  int v3;
  char *v4;
  char v5;
  unsigned __int16 v6;
  char v7;

  if (a2 < 8)
  {
    LOWORD(v3) = -1;
    if (!(_WORD)a2)
      return (unsigned __int16)~(_WORD)v3;
  }
  else
  {
    v2 = ((unsigned __int16)(a2 - 8) >> 3) + 1;
    LOWORD(v3) = -1;
    v4 = a1;
    do
    {
      v5 = *v4++;
      v3 = crc_16_l_table[(v5 ^ v3)] ^ ((unsigned __int16)(v3 & 0xFF00) >> 8);
      LOWORD(a2) = a2 - 8;
    }
    while ((unsigned __int16)a2 > 7u);
    a1 += v2;
    if (!(_WORD)a2)
      return (unsigned __int16)~(_WORD)v3;
  }
  v6 = *a1 << 8;
  do
  {
    LOWORD(a2) = a2 - 1;
    v7 = v6 ^ v3;
    LOWORD(v3) = (unsigned __int16)v3 >> 1;
    if ((v7 & 1) != 0)
      LOWORD(v3) = v3 ^ 0x8408;
    v6 >>= 1;
  }
  while ((_WORD)a2);
  return (unsigned __int16)~(_WORD)v3;
}

uint64_t crc_30_calc(char *a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  char *v4;
  char v5;
  int v6;
  int v7;

  if (a2 < 8)
  {
    v3 = 0x3FFFFFFF;
    if (!(_WORD)a2)
      return ~v3 & 0x3FFFFFFF;
  }
  else
  {
    v2 = ((unsigned __int16)(a2 - 8) >> 3) + 1;
    v3 = 0x3FFFFFFF;
    v4 = a1;
    do
    {
      v5 = *v4++;
      v3 = crc30_table[(v5 ^ (v3 >> 22))] ^ (v3 << 8);
      LOWORD(a2) = a2 - 8;
    }
    while ((unsigned __int16)a2 > 7u);
    a1 += v2;
    if (!(_WORD)a2)
      return ~v3 & 0x3FFFFFFF;
  }
  v6 = *a1 << 22;
  do
  {
    LOWORD(a2) = a2 - 1;
    v7 = v6 ^ v3;
    v3 *= 2;
    if ((v7 & 0x20000000) != 0)
      v3 ^= 0x6030B9C7u;
    v6 *= 2;
  }
  while ((_WORD)a2);
  return ~v3 & 0x3FFFFFFF;
}

uint64_t crc_30_step(int a1, char *a2, unsigned int a3)
{
  unsigned int v3;
  unsigned int v4;
  char *v5;
  char v6;
  int v7;
  int v8;

  v3 = ~a1 & 0x3FFFFFFF;
  if (a3 >= 8)
  {
    v4 = ((unsigned __int16)(a3 - 8) >> 3) + 1;
    v5 = a2;
    do
    {
      v6 = *v5++;
      v3 = crc30_table[(v6 ^ (v3 >> 22))] ^ (v3 << 8);
      LOWORD(a3) = a3 - 8;
    }
    while ((unsigned __int16)a3 > 7u);
    a2 += v4;
  }
  if ((_WORD)a3)
  {
    v7 = *a2 << 22;
    do
    {
      LOWORD(a3) = a3 - 1;
      v8 = v7 ^ v3;
      v3 *= 2;
      if ((v8 & 0x20000000) != 0)
        v3 ^= 0x6030B9C7u;
      v7 *= 2;
    }
    while ((_WORD)a3);
  }
  return ~v3 & 0x3FFFFFFF;
}

uint64_t crc_16_step(uint64_t result, unsigned __int8 *a2, int a3)
{
  __int16 v3;
  int v4;

  if (a3)
  {
    v3 = ~(_WORD)result;
    do
    {
      v4 = *a2++;
      v3 = crc16_table[v4 ^ ((unsigned __int16)(v3 & 0xFF00) >> 8)] ^ (v3 << 8);
      --a3;
    }
    while ((_WORD)a3);
    LOWORD(result) = ~v3;
  }
  return (unsigned __int16)result;
}

uint64_t crc_16_l_step(uint64_t result, char *a2, int a3)
{
  int v3;
  char v4;

  if (a3)
  {
    LOWORD(v3) = ~(_WORD)result;
    do
    {
      v4 = *a2++;
      v3 = crc_16_l_table[(v4 ^ v3)] ^ ((unsigned __int16)(v3 & 0xFF00) >> 8);
      --a3;
    }
    while (a3);
    LOWORD(result) = ~(_WORD)v3;
  }
  return (unsigned __int16)result;
}

uint64_t crc_32_calc(unsigned __int8 *a1, unsigned int a2, uint64_t a3)
{
  unsigned int v3;
  unsigned __int8 *v4;
  int v5;
  int v6;

  if (a2 >= 8)
  {
    v3 = ((unsigned __int16)(a2 - 8) >> 3) + 1;
    v4 = a1;
    do
    {
      v5 = *v4++;
      a3 = (crc32_table[v5 ^ BYTE3(a3)] ^ ((_DWORD)a3 << 8));
      LOWORD(a2) = a2 - 8;
    }
    while ((unsigned __int16)a2 > 7u);
    a1 += v3;
  }
  if ((_WORD)a2)
  {
    v6 = *a1 << 24;
    do
    {
      LOWORD(a2) = a2 - 1;
      if ((int)(v6 ^ a3) >= 0)
        a3 = (2 * a3);
      else
        a3 = (2 * (_DWORD)a3) ^ 0x4C11DB7u;
      v6 *= 2;
    }
    while ((_WORD)a2);
  }
  return a3;
}

uint64_t ETLGSDIAddCommandHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLGSDIParseResponseHeader(uint64_t a1, _WORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;

  v8 = *a3;
  v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v10 = *(_DWORD *)(*(_QWORD *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = HIWORD(v10);
      *a3 = v8 + 4;
      if (BYTE1(v10) == 33)
      {
        return 1;
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLGSDIParseResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLGSDIAddDelayedCommandHeaderInternal()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLGSDIParseDelayedCommandHeaderInternal(uint64_t *a1, _WORD *a2, _DWORD *a3, _WORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int *v13;
  uint64_t v14;

  v8 = *a5;
  v9 = (*((_DWORD *)a1 + 2) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = *(_DWORD *)(*a1 + v8);
    if (v11 == 128)
    {
      *a2 = HIWORD(v11);
      *a5 = v8 + 4;
      if ((*((_DWORD *)a1 + 2) - (v8 + 4)) <= 5)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsys2ParseHeader", (uint64_t)"Need %u bytes, only have %u\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, 6);
        return 0;
      }
      else
      {
        v12 = BYTE1(v11);
        v13 = (unsigned int *)(v10 + (v8 + 4));
        *a5 = v8 + 10;
        v14 = *v13;
        *a4 = *((_WORD *)v13 + 2);
        if ((_DWORD)v12 == 33)
        {
          *a3 = v14;
          if ((_DWORD)v14)
          {
            _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeaderInternal", (uint64_t)"Status was %u\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v14);
            return 0;
          }
          else
          {
            return 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeaderInternal", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v12);
          return 0;
        }
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v11);
      return 0;
    }
  }
}

uint64_t ETLGSDIAddDelayedCommandHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v14;
  const char *v15;
  uint64_t v16;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
  }
  else
  {
    if ((HDLCFrameInject() & 1) != 0)
    {
      if (HDLCFrameGetFreeSpace() > 0x19)
      {
        HDLCFrameInjectUnsignedInt();
        HDLCFrameInjectUnsignedInt();
        HDLCFrameInjectUnsignedChar();
        HDLCFrameInjectUnsignedChar();
        return HDLCFrameInject();
      }
      v16 = 26;
      v14 = "ETLRequireFreeSpace";
      v15 = "Need %u bytes free space, but only have %u\n";
    }
    else
    {
      v14 = "ETLSubsysAddHeaderInternal";
      v15 = "Failed to inject\n";
    }
    _ETLDebugPrint((uint64_t)v14, (uint64_t)v15, v7, v8, v9, v10, v11, v12, v16);
  }
  return 0;
}

uint64_t ETLGSDIParseDelayedCommandHeader(uint64_t *a1, _WORD *a2, _WORD *a3, uint64_t a4, uint64_t a5, _DWORD *a6, unsigned int *a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v16;
  int v17;
  unsigned int v18;
  unsigned int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  *a6 = 0;
  v8 = *a7;
  v9 = (*((_DWORD *)a1 + 2) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v9);
    return 0;
  }
  v10 = *a1;
  v11 = *(_DWORD *)(*a1 + v8);
  if (v11 != 128)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, *(_DWORD *)(*a1 + v8));
    return 0;
  }
  *a7 = v8 + 4;
  if ((*((_DWORD *)a1 + 2) - (v8 + 4)) <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsys2ParseHeader", (uint64_t)"Need %u bytes, only have %u\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, 6);
    return 0;
  }
  v12 = (unsigned int *)(v10 + (v8 + 4));
  v13 = v8 + 10;
  *a7 = v8 + 10;
  v14 = *v12;
  *a2 = *((_WORD *)v12 + 2);
  if (BYTE1(v11) != 33)
  {
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeaderInternal", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, BYTE1(v11));
    return 0;
  }
  if ((_DWORD)v14)
  {
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeaderInternal", (uint64_t)"Status was %u\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v14);
    return 0;
  }
  v16 = HIWORD(v11);
  if ((_DWORD)v16 != 72)
  {
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeader", (uint64_t)"Response subcommand code was 0x%x, expected 0x%x\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v16);
    return 0;
  }
  if (*((_DWORD *)a1 + 2) - v13 <= 1)
  {
    v22 = 2;
LABEL_21:
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeader", (uint64_t)"Need %u bytes, only have %u in response\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v22);
    return 0;
  }
  v17 = *(unsigned __int16 *)(v10 + v13);
  *a3 = v17;
  v18 = v8 + 12;
  *a7 = v18;
  if (v17 != 1)
    return 1;
  if (*((_DWORD *)a1 + 2) - v18 <= 0xB)
  {
    v22 = 12;
    goto LABEL_21;
  }
  v19 = (unsigned int *)(v10 + v18);
  v21 = *v19;
  v20 = v19[1];
  *a6 = v19[2];
  if ((_DWORD)v21 == (_DWORD)a4)
  {
    if ((_DWORD)v20 == (_DWORD)a5)
    {
      *a7 += 12;
      return 1;
    }
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeader", (uint64_t)"Received subcommand 0x%x mismatches expected 0x%x\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v20);
    return 0;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeader", (uint64_t)"Received status location %u mismatches expected %u\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v21);
    return 0;
  }
}

uint64_t ETLGSDICreateGetFeatureCommand()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (ETLGSDIAddDelayedCommandHeader())
  {
    if (HDLCFrameGetFreeSpace() > 3)
      return HDLCFrameInjectUnsignedInt();
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 4);
  }
  return 0;
}

uint64_t ETLGSDIParseGetFeatureResponse(uint64_t a1, _WORD *a2, _WORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t result;
  unsigned int v18;
  unsigned __int16 *v19;
  size_t v20;
  unsigned int v21;

  v21 = 0;
  *a4 = 0;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  *(_OWORD *)(a5 + 144) = 0u;
  *(_OWORD *)(a5 + 160) = 0u;
  *(_OWORD *)(a5 + 176) = 0u;
  *(_OWORD *)(a5 + 192) = 0u;
  *(_OWORD *)(a5 + 208) = 0u;
  *(_OWORD *)(a5 + 224) = 0u;
  *(_OWORD *)(a5 + 240) = 0u;
  *(_DWORD *)(a5 + 256) = 0;
  v16 = ETLGSDIParseDelayedCommandHeader((uint64_t *)a1, a2, a3, 1, 174, a4, &v21, a8);
  result = 0;
  if (v16)
  {
    v18 = *(_DWORD *)(a1 + 8) - v21;
    if (v18 <= 3)
    {
      _ETLDebugPrint((uint64_t)"ETLGSDIParseGetFeatureResponse", (uint64_t)"Need %u bytes, only have %u\n", v10, v11, v12, v13, v14, v15, 4);
    }
    else
    {
      v19 = (unsigned __int16 *)(*(_QWORD *)a1 + v21);
      v20 = *v19;
      *(_DWORD *)a5 = v20;
      if (v20 <= v18 - 4)
      {
        memcpy((void *)(a5 + 4), v19 + 2, v20);
        return 1;
      }
      _ETLDebugPrint((uint64_t)"ETLGSDIParseGetFeatureResponse", (uint64_t)"Data length is %u, but only have %u\n", v20, v11, v12, v13, v14, v15, v20);
    }
    return 0;
  }
  return result;
}

uint64_t ETLGSDICreateGetECCCommand()
{
  return ETLGSDIAddDelayedCommandHeader();
}

uint64_t ETLGSDIParseGetECCResponse(uint64_t a1, _WORD *a2, _WORD *a3, _DWORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t result;
  unsigned int v18;

  v18 = 0;
  *a4 = 0;
  v16 = ETLGSDIParseDelayedCommandHeader((uint64_t *)a1, a2, a3, 1, 85, a4, &v18, a8);
  result = 0;
  if (v16)
  {
    if (*(_DWORD *)(a1 + 8) - v18 <= 3)
    {
      _ETLDebugPrint((uint64_t)"ETLGSDIParseGetECCResponse", (uint64_t)"Need %u bytes, only have %u\n", v10, v11, v12, v13, v14, v15, 4);
      return 0;
    }
    else
    {
      *a5 = *(_DWORD *)(*(_QWORD *)a1 + v18);
      return 1;
    }
  }
  return result;
}

uint64_t ETLGSDIAddReadTransparentCmdHeader()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (ETLGSDIAddDelayedCommandHeader())
  {
    if (HDLCFrameGetFreeSpace() <= 0xB)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 12);
    }
    else if (HDLCFrameInjectUnsignedInt() && HDLCFrameInjectUnsignedInt())
    {
      return HDLCFrameInjectUnsignedInt();
    }
  }
  return 0;
}

uint64_t ETLGSDICreateReadTransparentCmdCommand()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;

  if (!ETLGSDIAddDelayedCommandHeader())
    return 0;
  if (HDLCFrameGetFreeSpace() <= 0xB)
  {
    v7 = 12;
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, v7);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedInt())
  {
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 0xF)
  {
    v7 = 16;
    goto LABEL_12;
  }
  if (HDLCFrameInjectUnsignedInt()
    && HDLCFrameInjectUnsignedInt()
    && HDLCFrameInjectUnsignedInt())
  {
    return HDLCFrameInjectUnsignedInt();
  }
  return 0;
}

uint64_t ETLGSDIParseReadTransparentCmdResponse(uint64_t a1, _WORD *a2, _WORD *a3, int a4, unsigned int a5, void *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t result;
  unsigned int v21;
  _DWORD *v22;
  unsigned int v23;
  char *v24;
  size_t v25;
  char *v26;
  unsigned int v27;
  int v28;
  unsigned int v29;

  v29 = 0;
  v19 = ETLGSDIParseDelayedCommandHeader((uint64_t *)a1, a2, a3, 1, 119, &v28, &v29, a8);
  result = 0;
  if (v19)
  {
    if (*a3 != 1)
      return 1;
    v21 = *(_DWORD *)(a1 + 8) - v29;
    if (v21 <= 0xB)
    {
      _ETLDebugPrint((uint64_t)"ETLGSDIParseReadTransparentCmdResponse", (uint64_t)"Need %u bytes, only have %u\n", v13, v14, v15, v16, v17, v18, 12);
    }
    else
    {
      v22 = (_DWORD *)(*(_QWORD *)a1 + v29);
      if (*v22)
        return 0;
      if (v22[1] == a4)
      {
        v23 = v21 - 12;
        if (v21 - 12 < a5 + 4)
        {
          _ETLDebugPrint((uint64_t)"ETLGSDIParseReadTransparentCmdResponse", (uint64_t)"Need %u bytes, only have %u\n", v13, v14, v15, v16, v17, v18, a5 + 4);
          return 0;
        }
        v24 = (char *)v22 + a5;
        v27 = *((_DWORD *)v24 + 3);
        v26 = v24 + 12;
        v25 = v27;
        if (v23 - (a5 + 4) < v27)
          return 0;
        memcpy(a6, v26 + 4, v25);
        return 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t ETLGSDICreateGetPINStatusCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v14;
  const char *v15;
  uint64_t v16;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
  }
  else
  {
    if ((HDLCFrameInject() & 1) != 0)
    {
      if (HDLCFrameGetFreeSpace() > 0x11)
      {
        HDLCFrameInjectUnsignedChar();
        HDLCFrameInjectUnsignedChar();
        HDLCFrameInject();
        return HDLCFrameInjectUnsignedChar();
      }
      v16 = 18;
      v14 = "ETLRequireFreeSpace";
      v15 = "Need %u bytes free space, but only have %u\n";
    }
    else
    {
      v14 = "ETLSubsysAddHeaderInternal";
      v15 = "Failed to inject\n";
    }
    _ETLDebugPrint((uint64_t)v14, (uint64_t)v15, v7, v8, v9, v10, v11, v12, v16);
  }
  return 0;
}

uint64_t ETLGSDIParseGetPINStatusReponse(int **a1, _DWORD *a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v14;

  *a2 = 0;
  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 33)
      {
        v12 = HIWORD(v11);
        if ((_DWORD)v12 == 5)
        {
          if (v9 <= 0x18)
          {
            _ETLDebugPrint((uint64_t)"ETLGSDIParseGetPINStatusReponse", (uint64_t)"response has %u bytes, need %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else
          {
            *a2 = v10[1];
            *a3 = *((unsigned __int8 *)v10 + 8);
            if (*a2)
            {
              _ETLDebugPrint((uint64_t)"ETLGSDIParseGetPINStatusReponse", (uint64_t)"Status was %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, *a2);
              return 0;
            }
            else if (*((unsigned __int8 *)v10 + 10) == (_DWORD)a4)
            {
              v14 = *((unsigned __int8 *)v10 + 28);
              if ((_DWORD)v14 == (_DWORD)a5)
              {
                return 1;
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLGSDIParseGetPINStatusReponse", (uint64_t)"Received PIN ID %u mismatches %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v14);
                return 0;
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLGSDIParseGetPINStatusReponse", (uint64_t)"Received slot ID %u mismatches %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned __int8 *)v10 + 10));
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLGSDIParseGetPINStatusReponse", (uint64_t)"Received subcommand %u mismatches %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLGSDIParseResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

BOOL ETLGSDIParsePINStatusEvent(uint64_t a1, unsigned int a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 8) = 0;
  *(_QWORD *)a3 = 0;
  if (a2 >= 7)
  {
    *(_DWORD *)a3 = *(_DWORD *)a1;
    *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
    *(_DWORD *)(a3 + 8) = *(unsigned __int8 *)(a1 + 5);
  }
  return a2 > 6;
}

void *ETLGSDIPerformGetFeatureRaw(_QWORD *a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *FeatureResponse;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int16 v25;
  _OWORD v26[2];
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  int v31;

  v28 = 0u;
  v29 = 0u;
  v30 = 0;
  memset(v26, 0, sizeof(v26));
  v27 = 0;
  if (!HDLCFrameCreateUplink() || !ETLGSDIAddDelayedCommandHeader())
    goto LABEL_18;
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v10, v11, v12, v13, v14, v15, 4);
    goto LABEL_18;
  }
  if (!HDLCFrameInjectUnsignedInt())
  {
LABEL_18:
    FeatureResponse = 0;
    goto LABEL_19;
  }
  FeatureResponse = malloc((2 * DWORD2(v28) + 32));
  if (!FeatureResponse)
    goto LABEL_19;
  v17 = HDLCFrameEncode();
  if (!(_DWORD)v17)
    goto LABEL_20;
  v18 = v17;
  v31 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, FeatureResponse, v17);
  if (!*a1)
  {
LABEL_20:
    free(FeatureResponse);
    goto LABEL_18;
  }
  v19 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, FeatureResponse, v18, &v31, 1, a6, 0);
  v20 = v31;
  free(FeatureResponse);
  FeatureResponse = 0;
  if (v19 && v20 == (_DWORD)v18)
  {
    LOBYTE(v31) = 0x80;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    FeatureResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v26, (uint64_t)&_ETLResponseRingBuffer, &v31, a6)&& v31 == 128)
    {
      FeatureResponse = (void *)ETLGSDIParseGetFeatureResponse((uint64_t)v26, &v31, &v25, a4, a5, v21, v22, v23);
    }
  }
LABEL_19:
  HDLCFrameFree();
  HDLCFrameFree();
  return FeatureResponse;
}

uint64_t ETLGSDIPerformGetECC(_QWORD *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int16 v33;
  __int16 v34;
  _OWORD v35[2];
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  unsigned int v40;

  v37 = 0u;
  v38 = 0u;
  v39 = 0;
  memset(v35, 0, sizeof(v35));
  v36 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_22;
  if (!ETLGSDIAddDelayedCommandHeader())
    goto LABEL_22;
  v9 = malloc((2 * DWORD2(v37) + 32));
  if (!v9)
    goto LABEL_22;
  v10 = v9;
  v11 = HDLCFrameEncode();
  if (!(_DWORD)v11)
    goto LABEL_21;
  v12 = v11;
  v40 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v10, v11);
  if (!*a1)
  {
LABEL_21:
    free(v10);
    goto LABEL_22;
  }
  v13 = ((uint64_t (*)(_QWORD *, void *, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v10, v12, &v40, 1, a5, 0);
  v14 = v40;
  free(v10);
  if (!v13 || v14 != (_DWORD)v12)
    goto LABEL_22;
  LOBYTE(v40) = 0x80;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v35, (uint64_t)&_ETLResponseRingBuffer, &v40, a5)|| v40 != 128|| (v40 = 0, *a3 = 0, !ETLGSDIParseDelayedCommandHeader((uint64_t *)v35, &v34, &v33, 1, 85, a3, &v40, v16)))
  {
LABEL_22:
    LOBYTE(v40) = 0x80;
    if (!_ETLResponseRingBuffer)
      goto LABEL_23;
    goto LABEL_24;
  }
  if (DWORD2(v35[0]) - v40 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLGSDIParseGetECCResponse", (uint64_t)"Need %u bytes, only have %u\n", v17, v18, v19, v20, v21, v22, 4);
    LOBYTE(v40) = 0x80;
    if (_ETLResponseRingBuffer)
      goto LABEL_24;
    goto LABEL_23;
  }
  *a4 = *(_DWORD *)(*(_QWORD *)&v35[0] + v40);
  LOBYTE(v40) = 0x80;
  if (!_ETLResponseRingBuffer)
LABEL_23:
    TelephonyUtilRingBufferInitialize();
LABEL_24:
  v23 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v35, (uint64_t)&_ETLResponseRingBuffer, &v40, a5);
  v25 = 0;
  if (v23)
  {
    if (v40 == 128)
    {
      v40 = 0;
      *a3 = 0;
      v25 = 0;
      if (ETLGSDIParseDelayedCommandHeader((uint64_t *)v35, &v34, &v33, 1, 85, a3, &v40, v24))
      {
        if (DWORD2(v35[0]) - v40 <= 3)
        {
          _ETLDebugPrint((uint64_t)"ETLGSDIParseGetECCResponse", (uint64_t)"Need %u bytes, only have %u\n", v26, v27, v28, v29, v30, v31, 4);
          v25 = 0;
        }
        else
        {
          *a4 = *(_DWORD *)(*(_QWORD *)&v35[0] + v40);
          v25 = 1;
        }
      }
    }
  }
  HDLCFrameFree();
  HDLCFrameFree();
  return v25;
}

uint64_t ETLGSDIPerformGetIccid(_QWORD *a1, uint64_t a2, int8x8_t *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  int v20;
  unsigned __int16 v22;
  _OWORD v23[2];
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  int v28;
  unsigned __int8 v29;
  unint64_t v30;
  __int16 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v25 = 0u;
  v26 = 0u;
  v27 = 0;
  memset(v23, 0, sizeof(v23));
  v24 = 0;
  v31 = -21846;
  v30 = 0xAAAAAAAAAAAAAAAALL;
  if (!a3 || !HDLCFrameCreateUplink())
    goto LABEL_23;
  v7 = 0;
  if (!ETLGSDICreateReadTransparentCmdCommand())
    goto LABEL_24;
  v7 = (uint64_t)malloc((2 * DWORD2(v25) + 32));
  if (!v7)
    goto LABEL_24;
  v8 = HDLCFrameEncode();
  if (!(_DWORD)v8)
    goto LABEL_22;
  v9 = v8;
  v28 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v7, v8);
  if (!*a1)
  {
LABEL_22:
    free((void *)v7);
LABEL_23:
    v7 = 0;
    goto LABEL_24;
  }
  v10 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v7, v9, &v28, 1, a4, 0);
  v11 = v28;
  free((void *)v7);
  v7 = 0;
  if (v10 && v11 == (_DWORD)v9)
  {
    LOBYTE(v28) = 0x80;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v7 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v23, (uint64_t)&_ETLResponseRingBuffer, &v28, a4)&& v28 == 128)
    {
      LOWORD(v28) = -21846;
      v22 = -21846;
      v7 = ETLGSDIParseReadTransparentCmdResponse((uint64_t)v23, &v28, &v22, 1, 0xAu, &v30, v12, v13);
      v14 = v22;
      if ((_DWORD)v7 && v22 != 1)
      {
        v15 = (unsigned __int16)v28;
        v29 = 0x80;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v18 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v23, (uint64_t)&_ETLResponseRingBuffer, &v29, a4);
        v19 = 0;
        if (v18)
        {
          v20 = v15;
          if (v29 == 128)
          {
            v19 = ETLGSDIParseReadTransparentCmdResponse((uint64_t)v23, &v28, &v22, 1, 0xAu, &v30, v16, v17);
            v14 = v22;
            v20 = (unsigned __int16)v28;
          }
        }
        else
        {
          v20 = v15;
        }
        if (v15 == v20)
          v7 = v19;
        else
          v7 = 0;
      }
      if ((_DWORD)v7 && v14 == 1)
      {
        *a3 = vorr_s8(vshl_n_s8((int8x8_t)v30, 4uLL), (int8x8_t)vshr_n_u8((uint8x8_t)v30, 4uLL));
        a3[1].i8[0] = (v31 >> 4) | (16 * v31);
        a3[1].i8[1] = (HIBYTE(v31) >> 4) | (16 * HIBYTE(v31));
        v7 = 1;
      }
    }
  }
LABEL_24:
  HDLCFrameFree();
  HDLCFrameFree();
  return v7;
}

uint64_t ETLGSDIGetICCID(_QWORD *a1, int8x8_t *a2, uint64_t a3)
{
  return ETLGSDIPerformGetIccid(a1, 1, a2, a3);
}

uint64_t ETLGSDIMakeStringFromDigit(unint64_t a1, unsigned int a2, uint8x16_t *a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint8x16_t *v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  uint8x16_t v19;
  uint8x16_t v20;
  char *v21;
  char *v22;
  int8x16x2_t v23;
  int8x16x2_t v24;

  v4 = 0;
  if (!a1 || !a3)
    return v4;
  if (((2 * a4) | 1) > a2)
    return 0;
  if (!a4)
  {
    v7 = 0;
    goto LABEL_12;
  }
  if (a4 >= 0x20)
  {
    LODWORD(v7) = 0;
    v6 = 0;
    if (((unint64_t)a4 - 1) >> 32)
      goto LABEL_8;
    v12 = 2 * (a4 - 1);
    if (a1 + v12 < a1 || a1 + 1 + v12 < a1 + 1)
      goto LABEL_8;
    if (a1 + 2 * a4 <= (unint64_t)a3 || (unint64_t)a3->u64 + a4 <= a1)
    {
      v13 = 0;
      v6 = a4 & 0xFFFFFFE0;
      LODWORD(v7) = 2 * (a4 & 0xFFFFFFE0);
      v14 = a1 - 1;
      v15 = a3 + 1;
      v16.i64[0] = 0x3030303030303030;
      v16.i64[1] = 0x3030303030303030;
      v17.i64[0] = 0xF0F0F0F0F0F0F0FLL;
      v17.i64[1] = 0xF0F0F0F0F0F0F0FLL;
      do
      {
        v18 = (int8x16_t)v15[-1];
        v19.i64[0] = 0x3030303030303030;
        v19.i64[1] = 0x3030303030303030;
        v23.val[0] = (int8x16_t)vsraq_n_u8(v19, (uint8x16_t)v18, 4uLL);
        v23.val[1] = vorrq_s8(vandq_s8(v18, v17), v16);
        v20.i64[0] = 0x3030303030303030;
        v20.i64[1] = 0x3030303030303030;
        v24.val[0] = (int8x16_t)vsraq_n_u8(v20, *v15, 4uLL);
        v24.val[1] = vorrq_s8(vandq_s8(*(int8x16_t *)v15, v17), v16);
        v21 = (char *)(v14 + (v13 + 1));
        vst2q_s8(v21, v23);
        v22 = (char *)(v14 + (v13 + 33));
        vst2q_s8(v22, v24);
        v15 += 2;
        v13 += 64;
      }
      while (((2 * a4) & 0x1FFFFFFC0) != v13);
      if (v6 == a4)
        goto LABEL_10;
      goto LABEL_8;
    }
  }
  v6 = 0;
  LODWORD(v7) = 0;
LABEL_8:
  v8 = a4 - v6;
  v9 = &a3->u8[v6];
  do
  {
    v10 = *v9++;
    v11 = v7 + 1;
    *(_BYTE *)(a1 + v7) = (v10 >> 4) | 0x30;
    LODWORD(v7) = v7 + 2;
    *(_BYTE *)(a1 + v11) = v10 & 0xF | 0x30;
    --v8;
  }
  while (v8);
LABEL_10:
  v7 = v7;
LABEL_12:
  *(_BYTE *)(a1 + v7) = 0;
  return 1;
}

uint64_t ETLGSDIMakeStringFromICCID(_BYTE *a1, unsigned int a2, char *a3)
{
  BOOL v3;
  BOOL v4;
  int v5;
  char v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  unsigned __int8 v15;

  if (a1)
    v3 = a3 == 0;
  else
    v3 = 1;
  v4 = !v3 && a2 >= 0x15;
  v5 = !v4;
  if (v4)
  {
    v6 = *a3;
    *a1 = (*a3 >> 4) | 0x30;
    a1[1] = v6 & 0xF | 0x30;
    v7 = a3[1];
    a1[2] = (v7 >> 4) | 0x30;
    a1[3] = v7 & 0xF | 0x30;
    v8 = a3[2];
    a1[4] = (v8 >> 4) | 0x30;
    a1[5] = v8 & 0xF | 0x30;
    v9 = a3[3];
    a1[6] = (v9 >> 4) | 0x30;
    a1[7] = v9 & 0xF | 0x30;
    v10 = a3[4];
    a1[8] = (v10 >> 4) | 0x30;
    a1[9] = v10 & 0xF | 0x30;
    v11 = a3[5];
    a1[10] = (v11 >> 4) | 0x30;
    a1[11] = v11 & 0xF | 0x30;
    v12 = a3[6];
    a1[12] = (v12 >> 4) | 0x30;
    a1[13] = v12 & 0xF | 0x30;
    v13 = a3[7];
    a1[14] = (v13 >> 4) | 0x30;
    a1[15] = v13 & 0xF | 0x30;
    v14 = a3[8];
    a1[16] = (v14 >> 4) | 0x30;
    a1[17] = v14 & 0xF | 0x30;
    v15 = a3[9];
    a1[18] = (v15 >> 4) | 0x30;
    a1[19] = v15 & 0xF | 0x30;
    a1[20] = 0;
  }
  return v5 ^ 1u;
}

void *ETLGSDIGetPINStatus(_QWORD *a1, uint64_t a2, uint64_t a3, _WORD *a4, _DWORD *a5, uint64_t a6)
{
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *PINStatusReponse;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  const char *v34;
  uint64_t v36;
  _OWORD v37[2];
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  _QWORD v42[3];

  v42[2] = *MEMORY[0x1E0C80C00];
  v39 = 0u;
  v40 = 0u;
  v41 = 0;
  memset(v37, 0, sizeof(v37));
  v38 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_22;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
LABEL_22:
    PINStatusReponse = 0;
    goto LABEL_23;
  }
  LODWORD(v42[0]) = 336203;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v33 = "ETLSubsysAddHeaderInternal";
    v34 = "Failed to inject\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v33, (uint64_t)v34, v19, v20, v21, v22, v23, v24, v36);
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 0x11)
  {
    v36 = 18;
    v33 = "ETLRequireFreeSpace";
    v34 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_21;
  }
  v42[0] = 0;
  v42[1] = 0;
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInject();
  PINStatusReponse = 0;
  if (!HDLCFrameInjectUnsignedChar())
    goto LABEL_23;
  PINStatusReponse = malloc((2 * DWORD2(v39) + 32));
  if (!PINStatusReponse)
    goto LABEL_23;
  v26 = HDLCFrameEncode();
  if (!(_DWORD)v26)
    goto LABEL_24;
  v27 = v26;
  LODWORD(v42[0]) = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, PINStatusReponse, v26);
  if (!*a1)
  {
LABEL_24:
    free(PINStatusReponse);
    goto LABEL_22;
  }
  v28 = ((uint64_t (*)(_QWORD *, void *, uint64_t, _QWORD *, uint64_t, uint64_t, _QWORD))*a1)(a1, PINStatusReponse, v27, v42, 1, a6, 0);
  v29 = v42[0];
  free(PINStatusReponse);
  PINStatusReponse = 0;
  if (v28 && v29 == (_DWORD)v27)
  {
    LOBYTE(v42[0]) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    PINStatusReponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v37, (uint64_t)&_ETLResponseRingBuffer, v42, a6)&& LOBYTE(v42[0]) == 75)
    {
      PINStatusReponse = (void *)ETLGSDIParseGetPINStatusReponse((int **)v37, a5, a4, a2, a3, v30, v31, v32);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return PINStatusReponse;
}

uint64_t ETLGSDIWaitForPINStatusEvent(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  char v23;
  BOOL v24;
  unsigned int *v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  uint64_t v30;
  _QWORD v33[2];
  uint64_t v34;
  char v35;
  _OWORD v36[2];
  uint64_t v37;

  while (1)
  {
    v35 = 96;
    memset(v36, 0, sizeof(v36));
    v37 = 0;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer(a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v35, a5))break;
    v8 = a5;
    v33[0] = 0;
    v33[1] = 0;
    v34 = 0;
    if (ETLEVENTParseEventReport((uint64_t)v36, v33))
    {
      v15 = v33[0];
      _ETLDebugPrint((uint64_t)"ETLGSDIWaitForPINStatusEvent", (uint64_t)"report has %u items\n", v9, v10, v11, v12, v13, v14, v34);
      v22 = 0;
      v23 = 1;
      if (v15)
      {
        do
        {
          if (*(_WORD *)v15 == 1002)
          {
            _ETLDebugPrint((uint64_t)"ETLGSDIWaitForPINStatusEvent", (uint64_t)"Found ID match\n", v16, v17, v18, v19, v20, v21, v30);
            if (*(unsigned __int8 *)(v15 + 24) < 7u)
            {
              v23 = 0;
            }
            else
            {
              v25 = *(unsigned int **)(v15 + 16);
              v26 = *v25;
              v27 = *((unsigned __int8 *)v25 + 5);
              v28 = *((unsigned __int8 *)v25 + 4) | (v27 << 8);
              _ETLDebugPrint((uint64_t)"ETLGSDIWaitForPINStatusEvent", (uint64_t)"TransactionID %u, expected %u\n", v16, v17, v18, v19, v20, v21, v28);
              if (v28 == a2)
              {
                *a3 = v26;
                if ((_DWORD)v26)
                {
                  _ETLDebugPrint((uint64_t)"ETLGSDIWaitForPINStatusEvent", (uint64_t)"Status was %u\n", v16, v17, v18, v19, v20, v21, v26);
                  v23 = 0;
                }
                else
                {
                  *a4 = v27;
                  v23 = 1;
                }
                v22 = 1;
              }
              else
              {
                v23 = 1;
              }
            }
          }
          v15 = *(_QWORD *)(v15 + 32);
          if (v15)
            v24 = (v23 & 1) == 0;
          else
            v24 = 1;
        }
        while (!v24);
      }
    }
    else
    {
      v23 = 0;
      v22 = 0;
    }
    a5 = v8;
    HDLCFrameFree();
    if ((v23 & 1) == 0 || (v22 & 1) != 0)
      return v23 & 1;
  }
  v23 = 0;
  HDLCFrameFree();
  return v23 & 1;
}

uint64_t APPLIB_DIAG_FTM_SetRFMode(unsigned __int8 *a1, int a2, __int16 a3)
{
  uint64_t result;
  int v7;
  int v8;
  char v9;
  unsigned __int16 v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  uint64_t v16;
  char v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  __int16 __src;
  _BYTE v28[2046];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF)
    return result;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v7 = gModeId;
  a1[2] = gModeId;
  v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 7;
  *((_WORD *)a1 + 3) = a3;
  v9 = HIBYTE(a3);
  v10 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 7];
  v11 = a1[5];
  v12 = crc_16_l_table[(v11 ^ v10 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  v13 = crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)];
  v14 = crc_16_l_table[HIBYTE(a3) ^ crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)] ^ (v12 >> 8)];
  *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)]);
  if (a2 < 20)
    return 0xFFFFFFFFLL;
  v26 = v14 ^ ~(v13 >> 8);
  bzero(v28, 0x7FEuLL);
  __src = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    v15 = 3;
    v28[1] = v7 ^ 0x20;
    v16 = 4;
    if ((v8 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v15 = 2;
  v28[0] = v7;
  v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  v17 = a3;
  v18 = &v28[v16 - 2];
  *v18 = v8;
  v18[1] = 7;
  v19 = v16 + 2;
  if ((v11 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v11) = v11 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v11;
  v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    v17 = a3 ^ 0x20;
    LODWORD(v20) = v19 + 2;
  }
  v21 = ~(v14 ^ BYTE1(v13));
  v28[v20 - 2] = v17;
  v22 = v20 + 1;
  if (HIBYTE(a3) - 125 <= 1)
  {
    v28[v22 - 2] = 125;
    v9 = HIBYTE(a3) ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  v23 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
  v28[v22 - 2] = v9;
  v24 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v24 - 2] = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v24) = v22 + 2;
  }
  v28[v24 - 2] = v21;
  v25 = v24 + 1;
  if (BYTE1(v26) - 125 <= 1)
  {
    v28[v25 - 2] = 125;
    v23 = BYTE1(v26) ^ 0x20;
    LODWORD(v25) = v24 + 2;
  }
  v28[v25 - 2] = v23;
  memcpy(a1, &__src, v25 + 1);
  result = (v25 + 2);
  a1[v25 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetChannel(unsigned __int8 *a1, int a2, __int16 a3)
{
  uint64_t result;
  int v7;
  int v8;
  char v9;
  unsigned __int16 v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  uint64_t v16;
  char v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  __int16 __src;
  _BYTE v28[2046];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF)
    return result;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v7 = gModeId;
  a1[2] = gModeId;
  v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 8;
  *((_WORD *)a1 + 3) = a3;
  v9 = HIBYTE(a3);
  v10 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 8];
  v11 = a1[5];
  v12 = crc_16_l_table[(v11 ^ v10 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  v13 = crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)];
  v14 = crc_16_l_table[HIBYTE(a3) ^ crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)] ^ (v12 >> 8)];
  *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)]);
  if (a2 < 20)
    return 0xFFFFFFFFLL;
  v26 = v14 ^ ~(v13 >> 8);
  bzero(v28, 0x7FEuLL);
  __src = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    v15 = 3;
    v28[1] = v7 ^ 0x20;
    v16 = 4;
    if ((v8 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v15 = 2;
  v28[0] = v7;
  v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  v17 = a3;
  v18 = &v28[v16 - 2];
  *v18 = v8;
  v18[1] = 8;
  v19 = v16 + 2;
  if ((v11 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v11) = v11 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v11;
  v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    v17 = a3 ^ 0x20;
    LODWORD(v20) = v19 + 2;
  }
  v21 = ~(v14 ^ BYTE1(v13));
  v28[v20 - 2] = v17;
  v22 = v20 + 1;
  if (HIBYTE(a3) - 125 <= 1)
  {
    v28[v22 - 2] = 125;
    v9 = HIBYTE(a3) ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  v23 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
  v28[v22 - 2] = v9;
  v24 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v24 - 2] = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v24) = v22 + 2;
  }
  v28[v24 - 2] = v21;
  v25 = v24 + 1;
  if (BYTE1(v26) - 125 <= 1)
  {
    v28[v25 - 2] = 125;
    v23 = BYTE1(v26) ^ 0x20;
    LODWORD(v25) = v24 + 2;
  }
  v28[v25 - 2] = v23;
  memcpy(a1, &__src, v25 + 1);
  result = (v25 + 2);
  a1[v25 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_Tx_On(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  char *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  __int16 __src;
  char v21[2046];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0xD)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    v5 = gModeId;
    a1[2] = gModeId;
    v6 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 2;
    v7 = crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC];
    v8 = crc_16_l_table[v7 ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 2];
    v9 = a1[5];
    v10 = crc_16_l_table[(v9 ^ v8 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))];
    v11 = v10 ^ ~(v8 >> 8);
    *((_WORD *)a1 + 3) = v10 ^ ~HIBYTE(crc_16_l_table[v7 ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 2]);
    if (a2 >= 16)
    {
      bzero(v21, 0x7FEuLL);
      __src = 2891;
      if ((v5 - 125) > 1)
      {
        v12 = 2;
      }
      else
      {
        v21[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        v12 = 3;
      }
      v21[v12 - 2] = v5;
      v13 = v12 + 1;
      if ((v6 - 125) <= 1)
      {
        v21[v13 - 2] = 125;
        LODWORD(v13) = v12 + 2;
        LOBYTE(v6) = v6 ^ 0x20;
      }
      v14 = ~(v10 ^ BYTE1(v8));
      v15 = &v21[v13 - 2];
      *v15 = v6;
      v15[1] = 2;
      v16 = v13 + 2;
      if ((v9 - 125) <= 1)
      {
        v21[v16 - 2] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v16) = v13 + 3;
      }
      v17 = (unsigned __int16)(v10 ^ ~(unsigned __int16)(v8 >> 8)) >> 8;
      v21[v16 - 2] = v9;
      v18 = v16 + 1;
      if ((v14 - 125) <= 1)
      {
        v21[v18 - 2] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v18) = v16 + 2;
      }
      v21[v18 - 2] = v14;
      v19 = v18 + 1;
      if (BYTE1(v11) - 125 <= 1)
      {
        v21[v19 - 2] = 125;
        v17 = BYTE1(v11) ^ 0x20;
        LODWORD(v19) = v18 + 2;
      }
      v21[v19 - 2] = v17;
      memcpy(a1, &__src, v19 + 1);
      result = (v19 + 2);
      a1[v19 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_Tx_Off(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  char *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  __int16 __src;
  char v21[2046];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0xD)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    v5 = gModeId;
    a1[2] = gModeId;
    v6 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 3;
    v7 = crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC];
    v8 = crc_16_l_table[v7 ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 3];
    v9 = a1[5];
    v10 = crc_16_l_table[(v9 ^ v8 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))];
    v11 = v10 ^ ~(v8 >> 8);
    *((_WORD *)a1 + 3) = v10 ^ ~HIBYTE(crc_16_l_table[v7 ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 3]);
    if (a2 >= 16)
    {
      bzero(v21, 0x7FEuLL);
      __src = 2891;
      if ((v5 - 125) > 1)
      {
        v12 = 2;
      }
      else
      {
        v21[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        v12 = 3;
      }
      v21[v12 - 2] = v5;
      v13 = v12 + 1;
      if ((v6 - 125) <= 1)
      {
        v21[v13 - 2] = 125;
        LODWORD(v13) = v12 + 2;
        LOBYTE(v6) = v6 ^ 0x20;
      }
      v14 = ~(v10 ^ BYTE1(v8));
      v15 = &v21[v13 - 2];
      *v15 = v6;
      v15[1] = 3;
      v16 = v13 + 2;
      if ((v9 - 125) <= 1)
      {
        v21[v16 - 2] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v16) = v13 + 3;
      }
      v17 = (unsigned __int16)(v10 ^ ~(unsigned __int16)(v8 >> 8)) >> 8;
      v21[v16 - 2] = v9;
      v18 = v16 + 1;
      if ((v14 - 125) <= 1)
      {
        v21[v18 - 2] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v18) = v16 + 2;
      }
      v21[v18 - 2] = v14;
      v19 = v18 + 1;
      if (BYTE1(v11) - 125 <= 1)
      {
        v21[v19 - 2] = 125;
        v17 = BYTE1(v11) ^ 0x20;
        LODWORD(v19) = v18 + 2;
      }
      v21[v19 - 2] = v17;
      memcpy(a1, &__src, v19 + 1);
      result = (v19 + 2);
      a1[v19 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetWaveForm(unsigned __int8 *a1, int a2, int a3, int a4)
{
  uint64_t result;
  unsigned int v9;
  int v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  int v17;
  char *v18;
  char v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  int v23;
  int v24;
  _BYTE __src[2048];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF)
    return result;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  *((_WORD *)a1 + 1) = gModeId;
  if (a3)
  {
    if (a3 != 1)
      return 0xFFFFFFFFLL;
    if (a4)
    {
      if (a4 == 1)
      {
        a1[4] = -120;
        v9 = 10;
        v10 = 64;
        v11 = 1;
        v12 = 9;
        v13 = 8;
        v14 = 7;
        v15 = 6;
        v16 = 1;
        goto LABEL_11;
      }
      return 0xFFFFFFFFLL;
    }
    v9 = 9;
    v10 = 56;
    v16 = 1;
  }
  else
  {
    v16 = 0;
    v9 = 9;
    v10 = 56;
  }
  v11 = 50;
  v12 = 8;
  v13 = 7;
  v14 = 6;
  v15 = 4;
LABEL_11:
  a1[v15] = v11;
  a1[v14] = v16;
  LOWORD(v17) = -1;
  v18 = (char *)a1;
  do
  {
    v19 = *v18++;
    v17 = crc_16_l_table[(v19 ^ v17)] ^ ((unsigned __int16)(v17 & 0xFF00) >> 8);
    v10 -= 8;
  }
  while ((_WORD)v10);
  a1[v13] = ~(_BYTE)v17;
  a1[v12] = (unsigned __int16)~(_WORD)v17 >> 8;
  if (a2 < (int)(2 * v9))
    return 0xFFFFFFFFLL;
  bzero(__src, 0x800uLL);
  v20 = 0;
  LODWORD(v21) = 0;
  v22 = v9;
  do
  {
    while (1)
    {
      v24 = a1[v20];
      if ((v24 - 125) > 1)
        break;
      v23 = v21 + 1;
      __src[(int)v21] = 125;
      __src[(int)v21 + 1] = v24 ^ 0x20;
      v21 = (int)v21 + 1 + 1;
      if (v22 == ++v20)
        goto LABEL_19;
    }
    v23 = v21;
    __src[(int)v21] = v24;
    v21 = (int)v21 + 1;
    ++v20;
  }
  while (v22 != v20);
LABEL_19:
  memcpy(a1, __src, v21);
  result = (v23 + 2);
  a1[v21] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetPARange(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t result;
  int v7;
  int v8;
  unsigned __int16 v9;
  int v10;
  unsigned __int16 v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  char v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  __int16 v27;
  _BYTE v28[2046];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF)
    return result;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v7 = gModeId;
  a1[2] = gModeId;
  v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 54;
  a1[6] = a3;
  v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x36];
  v10 = a1[5];
  v11 = crc_16_l_table[(v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  v12 = crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)];
  v13 = crc_16_l_table[(a1[7] ^ v12 ^ HIBYTE(v11))];
  v14 = v13 ^ ~(v12 >> 8);
  *((_WORD *)a1 + 4) = v13 ^ ~HIBYTE(crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)]);
  if (a2 < 20)
    return 0xFFFFFFFFLL;
  bzero(v28, 0x7FEuLL);
  v27 = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    v15 = 3;
    v28[1] = v7 ^ 0x20;
    v16 = 4;
    if ((v8 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v15 = 2;
  v28[0] = v7;
  v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  v17 = a3;
  v18 = &v28[v16 - 2];
  *v18 = v8;
  v18[1] = 54;
  v19 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v10;
  v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    LODWORD(v20) = v19 + 2;
    v17 = a3 ^ 0x20;
  }
  v21 = ~(v13 ^ BYTE1(v12));
  v28[v20 - 2] = v17;
  v22 = v20 + 1;
  v23 = a1[7];
  if ((v23 - 125) <= 1)
  {
    v28[v22 - 2] = 125;
    LOBYTE(v23) = v23 ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  v24 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v28[v22 - 2] = v23;
  v25 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v25 - 2] = 125;
    LODWORD(v25) = v22 + 2;
    LOBYTE(v21) = v21 ^ 0x20;
  }
  v28[v25 - 2] = v21;
  v26 = v25 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v28[v26 - 2] = 125;
    v24 = BYTE1(v14) ^ 0x20;
    LODWORD(v26) = v25 + 2;
  }
  v28[v26 - 2] = v24;
  memcpy(a1, &v27, v26 + 1);
  result = (v26 + 2);
  a1[v26 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetPDM(unsigned __int8 *a1, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  uint64_t result;
  int v9;
  int v10;
  unsigned __int16 v11;
  int v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned int v16;
  int v17;
  int v18;
  uint64_t v19;
  char v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  __int16 __src;
  _BYTE v36[2046];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x11)
    return result;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v9 = gModeId;
  a1[2] = gModeId;
  v10 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 0;
  a1[6] = a3;
  a1[8] = a4;
  v11 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5])];
  v12 = a1[5];
  v13 = crc_16_l_table[(v12 ^ v11 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC]))];
  v14 = crc_16_l_table[(v13 ^ HIBYTE(v11) ^ a3)];
  v15 = crc_16_l_table[(a1[7] ^ v14 ^ HIBYTE(v13))];
  v16 = crc_16_l_table[(v15 ^ HIBYTE(v14) ^ a4)];
  v17 = crc_16_l_table[(a1[9] ^ v16 ^ HIBYTE(v15))];
  *((_WORD *)a1 + 5) = v17 ^ ~HIBYTE(crc_16_l_table[(v15 ^ HIBYTE(v14) ^ a4)]);
  if (a2 < 24)
    return 0xFFFFFFFFLL;
  v34 = v17 ^ ~(v16 >> 8);
  bzero(v36, 0x7FEuLL);
  __src = 2891;
  if ((v9 - 125) <= 1)
  {
    v36[0] = 125;
    v18 = 3;
    v36[1] = v9 ^ 0x20;
    v19 = 4;
    if ((v10 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v18 = 2;
  v36[0] = v9;
  v19 = 3;
  if ((v10 - 125) <= 1)
  {
LABEL_9:
    v36[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v18 + 2;
  }
LABEL_10:
  v20 = a3;
  v21 = &v36[v19 - 2];
  *v21 = v10;
  v21[1] = 0;
  v22 = v19 + 2;
  if ((v12 - 125) <= 1)
  {
    v36[v22 - 2] = 125;
    LOBYTE(v12) = v12 ^ 0x20;
    LODWORD(v22) = v19 + 3;
  }
  v36[v22 - 2] = v12;
  v23 = v22 + 1;
  if (a3 - 125 <= 1)
  {
    v36[v23 - 2] = 125;
    v20 = a3 ^ 0x20;
    LODWORD(v23) = v22 + 2;
  }
  v24 = a4;
  v36[v23 - 2] = v20;
  v25 = v23 + 1;
  v26 = a1[7];
  if ((v26 - 125) <= 1)
  {
    v36[v25 - 2] = 125;
    LODWORD(v25) = v23 + 2;
    LOBYTE(v26) = v26 ^ 0x20;
  }
  v36[v25 - 2] = v26;
  v27 = v25 + 1;
  if (a4 - 125 <= 1)
  {
    v36[v27 - 2] = 125;
    v24 = a4 ^ 0x20;
    LODWORD(v27) = v25 + 2;
  }
  v28 = ~(v17 ^ BYTE1(v16));
  v36[v27 - 2] = v24;
  v29 = v27 + 1;
  v30 = a1[9];
  if ((v30 - 125) <= 1)
  {
    v36[v29 - 2] = 125;
    LOBYTE(v30) = v30 ^ 0x20;
    LODWORD(v29) = v27 + 2;
  }
  v31 = (unsigned __int16)(v17 ^ ~(unsigned __int16)(v16 >> 8)) >> 8;
  v36[v29 - 2] = v30;
  v32 = v29 + 1;
  if ((v28 - 125) <= 1)
  {
    v36[v32 - 2] = 125;
    LODWORD(v32) = v29 + 2;
    LOBYTE(v28) = v28 ^ 0x20;
  }
  v36[v32 - 2] = v28;
  v33 = v32 + 1;
  if (BYTE1(v34) - 125 <= 1)
  {
    v36[v33 - 2] = 125;
    v31 = BYTE1(v34) ^ 0x20;
    LODWORD(v33) = v32 + 2;
  }
  v36[v33 - 2] = v31;
  memcpy(a1, &__src, v33 + 1);
  result = (v33 + 2);
  a1[v33 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_ExecuteTxSweep(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t result;
  int v6;
  int v7;
  int v8;
  unsigned __int16 v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _BYTE *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  __int16 v24;
  _BYTE v25[2046];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xE)
    return result;
  v6 = a3;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v7 = gModeId;
  a1[2] = gModeId;
  v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 116;
  a1[6] = v6;
  v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x74];
  v10 = a1[5];
  v11 = (v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]));
  v12 = crc_16_l_table[v11];
  v13 = crc_16_l_table[(v12 ^ HIBYTE(v9)) ^ v6];
  v14 = v13 ^ ~(v12 >> 8);
  *(_WORD *)(a1 + 7) = v13 ^ ~HIBYTE(crc_16_l_table[v11]);
  if (a2 < 18)
    return 0xFFFFFFFFLL;
  bzero(v25, 0x7FEuLL);
  v24 = 2891;
  if ((v7 - 125) <= 1)
  {
    v25[0] = 125;
    v15 = 3;
    v25[1] = v7 ^ 0x20;
    v16 = 4;
    if ((v8 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v15 = 2;
  v25[0] = v7;
  v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v25[v16 - 2] = 125;
    LODWORD(v16) = v15 + 2;
    LOBYTE(v8) = v8 ^ 0x20;
  }
LABEL_10:
  v17 = &v25[v16 - 2];
  *v17 = v8;
  v17[1] = 116;
  v18 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v25[v18 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v18) = v16 + 3;
  }
  v19 = ~(v13 ^ BYTE1(v12));
  v25[v18 - 2] = v10;
  v20 = v18 + 1;
  if ((v6 - 125) <= 1)
  {
    v25[v20 - 2] = 125;
    LOBYTE(v6) = v6 ^ 0x20;
    LODWORD(v20) = v18 + 2;
  }
  v21 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v25[v20 - 2] = v6;
  v22 = v20 + 1;
  if ((v19 - 125) <= 1)
  {
    v25[v22 - 2] = 125;
    LODWORD(v22) = v20 + 2;
    LOBYTE(v19) = v19 ^ 0x20;
  }
  v25[v22 - 2] = v19;
  v23 = v22 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v25[v23 - 2] = 125;
    v21 = BYTE1(v14) ^ 0x20;
    LODWORD(v23) = v22 + 2;
  }
  v25[v23 - 2] = v21;
  memcpy(a1, &v24, v23 + 1);
  result = (v23 + 2);
  a1[v23 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetPDMStepSize(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t result;
  int v6;
  int v7;
  int v8;
  unsigned __int16 v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _BYTE *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  __int16 v24;
  _BYTE v25[2046];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xE)
    return result;
  v6 = a3;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v7 = gModeId;
  a1[2] = gModeId;
  v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = -127;
  a1[6] = v6;
  v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x81];
  v10 = a1[5];
  v11 = (v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]));
  v12 = crc_16_l_table[v11];
  v13 = crc_16_l_table[(v12 ^ HIBYTE(v9)) ^ v6];
  v14 = v13 ^ ~(v12 >> 8);
  *(_WORD *)(a1 + 7) = v13 ^ ~HIBYTE(crc_16_l_table[v11]);
  if (a2 < 18)
    return 0xFFFFFFFFLL;
  bzero(v25, 0x7FEuLL);
  v24 = 2891;
  if ((v7 - 125) <= 1)
  {
    v25[0] = 125;
    v15 = 3;
    v25[1] = v7 ^ 0x20;
    v16 = 4;
    if ((v8 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v15 = 2;
  v25[0] = v7;
  v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v25[v16 - 2] = 125;
    LODWORD(v16) = v15 + 2;
    LOBYTE(v8) = v8 ^ 0x20;
  }
LABEL_10:
  v17 = &v25[v16 - 2];
  *v17 = v8;
  v17[1] = -127;
  v18 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v25[v18 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v18) = v16 + 3;
  }
  v19 = ~(v13 ^ BYTE1(v12));
  v25[v18 - 2] = v10;
  v20 = v18 + 1;
  if ((v6 - 125) <= 1)
  {
    v25[v20 - 2] = 125;
    LOBYTE(v6) = v6 ^ 0x20;
    LODWORD(v20) = v18 + 2;
  }
  v21 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v25[v20 - 2] = v6;
  v22 = v20 + 1;
  if ((v19 - 125) <= 1)
  {
    v25[v22 - 2] = 125;
    LODWORD(v22) = v20 + 2;
    LOBYTE(v19) = v19 ^ 0x20;
  }
  v25[v22 - 2] = v19;
  v23 = v22 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v25[v23 - 2] = 125;
    v21 = BYTE1(v14) ^ 0x20;
    LODWORD(v23) = v22 + 2;
  }
  v25[v23 - 2] = v21;
  memcpy(a1, &v24, v23 + 1);
  result = (v23 + 2);
  a1[v23 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_ConfigTxSweep(unsigned __int8 *a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t result;
  int v9;
  int v10;
  char v11;
  char v12;
  unsigned __int16 v13;
  int v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  _BYTE *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  int v39;
  _BYTE __src[2048];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x11)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    v9 = gModeId;
    a1[2] = gModeId;
    v10 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 125;
    *((_WORD *)a1 + 3) = a3;
    v11 = HIBYTE(a3);
    *((_WORD *)a1 + 4) = a4;
    v12 = HIBYTE(a4);
    v13 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0x7D];
    v14 = a1[5];
    v15 = crc_16_l_table[(v14 ^ v13 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC]))];
    v16 = crc_16_l_table[(v15 ^ HIBYTE(v13) ^ a3)];
    v17 = crc_16_l_table[(HIBYTE(a3) ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    *((_WORD *)a1 + 5) = v19 ^ ~(unsigned __int16)(v18 >> 8);
    if (a2 >= 24)
    {
      v38 = v19;
      v39 = v19 ^ ~(v18 >> 8);
      bzero(__src, 0x800uLL);
      v20 = *a1;
      if ((v20 - 125) > 1)
      {
        v21 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v20) = v20 ^ 0x20;
        v21 = 1;
      }
      __src[v21] = v20;
      v22 = v21 + 1;
      v23 = a1[1];
      if ((v23 - 125) <= 1)
      {
        __src[v22] = 125;
        LODWORD(v22) = v21 | 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      __src[v22] = v23;
      v24 = v22 + 1;
      if ((v9 - 125) <= 1)
      {
        __src[v24] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      __src[v24] = v9;
      v25 = v24 + 1;
      if ((v10 - 125) <= 1)
      {
        __src[v25] = 125;
        LOBYTE(v10) = v10 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      v26 = a3;
      v27 = &__src[v25];
      *v27 = v10;
      *(_WORD *)(v27 + 1) = 23933;
      v28 = v25 + 3;
      if ((v14 - 125) <= 1)
      {
        __src[v28] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v28) = v25 + 4;
      }
      __src[v28] = v14;
      v29 = v28 + 1;
      if (a3 - 125 <= 1)
      {
        __src[v29] = 125;
        v26 = a3 ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      v30 = a4;
      __src[v29] = v26;
      v31 = v29 + 1;
      if (HIBYTE(a3) - 125 <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v29 + 2;
        v11 = HIBYTE(a3) ^ 0x20;
      }
      __src[v31] = v11;
      v32 = v31 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v32] = 125;
        v30 = a4 ^ 0x20;
        LODWORD(v32) = v31 + 2;
      }
      v33 = ~(v38 ^ BYTE1(v18));
      __src[v32] = v30;
      v34 = v32 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v34] = 125;
        v12 = HIBYTE(a4) ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      v35 = BYTE1(v39);
      __src[v34] = v12;
      v36 = v34 + 1;
      if ((v33 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v34 + 2;
        LOBYTE(v33) = v33 ^ 0x20;
      }
      __src[v36] = v33;
      v37 = v36 + 1;
      if (BYTE1(v39) - 125 <= 1)
      {
        __src[v37] = 125;
        v35 = BYTE1(v39) ^ 0x20;
        LODWORD(v37) = v36 + 2;
      }
      __src[v37] = v35;
      memcpy(a1, __src, v37 + 1);
      result = (v37 + 2);
      a1[v37 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetAllHDETValues(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  int v5;
  int v6;
  char *v7;
  char v8;
  uint64_t v9;
  size_t v10;
  int v11;
  int v12;
  _BYTE __src[2048];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x2D)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    *((_WORD *)a1 + 1) = gModeId;
    a1[4] = -112;
    v5 = 560;
    LOWORD(v6) = -1;
    v7 = (char *)a1;
    do
    {
      v8 = *v7++;
      v6 = crc_16_l_table[(v8 ^ v6)] ^ ((unsigned __int16)(v6 & 0xFF00) >> 8);
      v5 -= 8;
    }
    while ((_WORD)v5);
    *((_WORD *)a1 + 35) = ~(_WORD)v6;
    if (a2 >= 144)
    {
      bzero(__src, 0x800uLL);
      v9 = 0;
      LODWORD(v10) = 0;
      do
      {
        while (1)
        {
          v12 = a1[v9];
          if ((v12 - 125) > 1)
            break;
          v11 = v10 + 1;
          __src[(int)v10] = 125;
          __src[(int)v10 + 1] = v12 ^ 0x20;
          v10 = (int)v10 + 1 + 1;
          if (++v9 == 72)
            goto LABEL_11;
        }
        v11 = v10;
        __src[(int)v10] = v12;
        v10 = (int)v10 + 1;
        ++v9;
      }
      while (v9 != 72);
LABEL_11:
      memcpy(a1, __src, v10);
      result = (v11 + 2);
      a1[v10] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetADCValue(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t result;
  int v6;
  int v7;
  int v8;
  unsigned __int16 v9;
  int v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  char v25;
  _BYTE *v26;
  uint64_t v27;
  uint64_t v28;
  __int16 v29;
  _BYTE v30[2046];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x11)
    return result;
  v6 = a3;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v7 = gModeId;
  a1[2] = gModeId;
  v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 59;
  a1[6] = v6;
  *((_WORD *)a1 + 4) = -14636;
  v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x3B];
  v10 = a1[5];
  v11 = crc_16_l_table[(v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  v12 = crc_16_l_table[(v11 ^ HIBYTE(v9)) ^ v6];
  v13 = crc_16_l_table[(a1[7] ^ v12 ^ HIBYTE(v11))];
  v14 = crc_16_l_table[(v13 ^ HIBYTE(v12)) ^ 0xD4];
  v15 = crc_16_l_table[crc_16_l_table[(v13 ^ HIBYTE(v12)) ^ 0xD4] ^ (v13 >> 8) ^ 0xC6];
  v16 = v15 ^ ~(v14 >> 8);
  *((_WORD *)a1 + 5) = v15 ^ ~HIBYTE(crc_16_l_table[(v13 ^ HIBYTE(v12)) ^ 0xD4]);
  if (a2 < 24)
    return 0xFFFFFFFFLL;
  bzero(v30, 0x7FEuLL);
  v29 = 2891;
  if ((v7 - 125) <= 1)
  {
    v30[0] = 125;
    v17 = 3;
    v30[1] = v7 ^ 0x20;
    v18 = 4;
    if ((v8 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v17 = 2;
  v30[0] = v7;
  v18 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v30[v18 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v18) = v17 + 2;
  }
LABEL_10:
  v19 = &v30[v18 - 2];
  *v19 = v8;
  v19[1] = 59;
  v20 = v18 + 2;
  if ((v10 - 125) <= 1)
  {
    v30[v20 - 2] = 125;
    LODWORD(v20) = v18 + 3;
    LOBYTE(v10) = v10 ^ 0x20;
  }
  v30[v20 - 2] = v10;
  v21 = v20 + 1;
  if ((v6 - 125) <= 1)
  {
    v30[v21 - 2] = 125;
    LOBYTE(v6) = v6 ^ 0x20;
    LODWORD(v21) = v20 + 2;
  }
  v22 = ~(v15 ^ BYTE1(v14));
  v30[v21 - 2] = v6;
  v23 = v21 + 1;
  v24 = a1[7];
  if ((v24 - 125) <= 1)
  {
    v30[v23 - 2] = 125;
    LOBYTE(v24) = v24 ^ 0x20;
    LODWORD(v23) = v21 + 2;
  }
  v25 = (unsigned __int16)(v15 ^ ~(unsigned __int16)(v14 >> 8)) >> 8;
  v26 = &v30[v23 - 2];
  *v26 = v24;
  *(_WORD *)(v26 + 1) = -14636;
  v27 = v23 + 3;
  if ((v22 - 125) <= 1)
  {
    v30[v27 - 2] = 125;
    LOBYTE(v22) = v22 ^ 0x20;
    LODWORD(v27) = v23 + 4;
  }
  v30[v27 - 2] = v22;
  v28 = v27 + 1;
  if (BYTE1(v16) - 125 <= 1)
  {
    v30[v28 - 2] = 125;
    v25 = BYTE1(v16) ^ 0x20;
    LODWORD(v28) = v27 + 2;
  }
  v30[v28 - 2] = v25;
  memcpy(a1, &v29, v28 + 1);
  result = (v28 + 2);
  a1[v28 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetHDETTracking(unsigned __int8 *a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t result;
  int v9;
  int v10;
  char v11;
  char v12;
  unsigned __int16 v13;
  int v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  _BYTE *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  int v39;
  _BYTE __src[2048];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x11)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    v9 = gModeId;
    a1[2] = gModeId;
    v10 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 124;
    *((_WORD *)a1 + 3) = a3;
    v11 = HIBYTE(a3);
    *((_WORD *)a1 + 4) = a4;
    v12 = HIBYTE(a4);
    v13 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0x7C];
    v14 = a1[5];
    v15 = crc_16_l_table[(v14 ^ v13 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC]))];
    v16 = crc_16_l_table[(v15 ^ HIBYTE(v13) ^ a3)];
    v17 = crc_16_l_table[(HIBYTE(a3) ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    *((_WORD *)a1 + 5) = v19 ^ ~HIBYTE(crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))]);
    if (a2 >= 24)
    {
      v38 = v19;
      v39 = v19 ^ ~(v18 >> 8);
      bzero(__src, 0x800uLL);
      v20 = *a1;
      if ((v20 - 125) > 1)
      {
        v21 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v20) = v20 ^ 0x20;
        v21 = 1;
      }
      __src[v21] = v20;
      v22 = v21 + 1;
      v23 = a1[1];
      if ((v23 - 125) <= 1)
      {
        __src[v22] = 125;
        LODWORD(v22) = v21 | 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      __src[v22] = v23;
      v24 = v22 + 1;
      if ((v9 - 125) <= 1)
      {
        __src[v24] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      __src[v24] = v9;
      v25 = v24 + 1;
      if ((v10 - 125) <= 1)
      {
        __src[v25] = 125;
        LOBYTE(v10) = v10 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      v26 = a3;
      v27 = &__src[v25];
      *v27 = v10;
      v27[1] = 124;
      v28 = v25 + 2;
      if ((v14 - 125) <= 1)
      {
        __src[v28] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v28) = v25 + 3;
      }
      __src[v28] = v14;
      v29 = v28 + 1;
      if (a3 - 125 <= 1)
      {
        __src[v29] = 125;
        v26 = a3 ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      v30 = a4;
      __src[v29] = v26;
      v31 = v29 + 1;
      if (HIBYTE(a3) - 125 <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v29 + 2;
        v11 = HIBYTE(a3) ^ 0x20;
      }
      __src[v31] = v11;
      v32 = v31 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v32] = 125;
        v30 = a4 ^ 0x20;
        LODWORD(v32) = v31 + 2;
      }
      v33 = ~(v38 ^ BYTE1(v18));
      __src[v32] = v30;
      v34 = v32 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v34] = 125;
        v12 = HIBYTE(a4) ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      v35 = BYTE1(v39);
      __src[v34] = v12;
      v36 = v34 + 1;
      if ((v33 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v34 + 2;
        LOBYTE(v33) = v33 ^ 0x20;
      }
      __src[v36] = v33;
      v37 = v36 + 1;
      if (BYTE1(v39) - 125 <= 1)
      {
        __src[v37] = 125;
        v35 = BYTE1(v39) ^ 0x20;
        LODWORD(v37) = v36 + 2;
      }
      __src[v37] = v35;
      memcpy(a1, __src, v37 + 1);
      result = (v37 + 2);
      a1[v37 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetThermistorValue(_DWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = -2115764917;
    if (a2 >= 8)
    {
      *a1 = -2115764917;
      *((_BYTE *)a1 + 4) = 126;
      return 5;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetRxAGC(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  char *v16;
  uint64_t v17;
  char v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  __int16 __src;
  char v23[2046];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0xF)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    v5 = gModeId;
    a1[2] = gModeId;
    v6 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 53;
    *((_WORD *)a1 + 3) = 0;
    v7 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 0x35];
    v8 = a1[5];
    v9 = crc_16_l_table[(v8 ^ v7 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))];
    v10 = crc_16_l_table[v9 ^ (v7 >> 8)];
    v11 = crc_16_l_table[crc_16_l_table[v9 ^ (v7 >> 8)] ^ HIBYTE(crc_16_l_table[(v8 ^ v7 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))])];
    v12 = v11 ^ ~(v10 >> 8);
    *((_WORD *)a1 + 4) = v11 ^ ~HIBYTE(crc_16_l_table[v9 ^ (v7 >> 8)]);
    if (a2 >= 20)
    {
      bzero(v23, 0x7FEuLL);
      __src = 2891;
      if ((v5 - 125) > 1)
      {
        v13 = 2;
      }
      else
      {
        v23[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        v13 = 3;
      }
      v23[v13 - 2] = v5;
      v14 = v13 + 1;
      if ((v6 - 125) <= 1)
      {
        v23[v14 - 2] = 125;
        LODWORD(v14) = v13 + 2;
        LOBYTE(v6) = v6 ^ 0x20;
      }
      v15 = ~(v11 ^ BYTE1(v10));
      v16 = &v23[v14 - 2];
      *v16 = v6;
      v16[1] = 53;
      v17 = v14 + 2;
      if ((v8 - 125) <= 1)
      {
        v23[v17 - 2] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        LODWORD(v17) = v14 + 3;
      }
      v18 = (unsigned __int16)(v11 ^ ~(unsigned __int16)(v10 >> 8)) >> 8;
      v19 = &v23[v17 - 2];
      *v19 = v8;
      *(_WORD *)(v19 + 1) = 0;
      v20 = v17 + 3;
      if ((v15 - 125) <= 1)
      {
        v23[v20 - 2] = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v20) = v17 + 4;
      }
      v23[v20 - 2] = v15;
      v21 = v20 + 1;
      if (BYTE1(v12) - 125 <= 1)
      {
        v23[v21 - 2] = 125;
        v18 = BYTE1(v12) ^ 0x20;
        LODWORD(v21) = v20 + 2;
      }
      v23[v21 - 2] = v18;
      memcpy(a1, &__src, v21 + 1);
      result = (v21 + 2);
      a1[v21 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetSynthState(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  char *v15;
  uint64_t v16;
  char v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  __int16 __src;
  char v22[2046];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0xF)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    v5 = gModeId;
    a1[2] = gModeId;
    v6 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 16;
    a1[6] = -8;
    v7 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 0x10];
    v8 = a1[5];
    v9 = crc_16_l_table[(v8 ^ v7 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))];
    v10 = crc_16_l_table[crc_16_l_table[(v8 ^ v7 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))] ^ (v7 >> 8) ^ 0xF8];
    v11 = v10 ^ ~(v9 >> 8);
    *(_WORD *)(a1 + 7) = v10 ^ ~HIBYTE(crc_16_l_table[(v8 ^ v7 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))]);
    if (a2 >= 18)
    {
      bzero(v22, 0x7FEuLL);
      __src = 2891;
      if ((v5 - 125) > 1)
      {
        v12 = 2;
      }
      else
      {
        v22[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        v12 = 3;
      }
      v22[v12 - 2] = v5;
      v13 = v12 + 1;
      if ((v6 - 125) <= 1)
      {
        v22[v13 - 2] = 125;
        LODWORD(v13) = v12 + 2;
        LOBYTE(v6) = v6 ^ 0x20;
      }
      v14 = ~(v10 ^ BYTE1(v9));
      v15 = &v22[v13 - 2];
      *v15 = v6;
      v15[1] = 16;
      v16 = v13 + 2;
      if ((v8 - 125) <= 1)
      {
        v22[v16 - 2] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        LODWORD(v16) = v13 + 3;
      }
      v17 = (unsigned __int16)(v10 ^ ~(unsigned __int16)(v9 >> 8)) >> 8;
      v18 = &v22[v16 - 2];
      *v18 = v8;
      v18[1] = -8;
      v19 = v16 + 2;
      if ((v14 - 125) <= 1)
      {
        v22[v19 - 2] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v19) = v16 + 3;
      }
      v22[v19 - 2] = v14;
      v20 = v19 + 1;
      if (BYTE1(v11) - 125 <= 1)
      {
        v22[v20 - 2] = 125;
        v17 = BYTE1(v11) ^ 0x20;
        LODWORD(v20) = v19 + 2;
      }
      v22[v20 - 2] = v17;
      memcpy(a1, &__src, v20 + 1);
      result = (v20 + 2);
      a1[v20 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetLNARange(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t result;
  int v7;
  int v8;
  unsigned __int16 v9;
  int v10;
  unsigned __int16 v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  char v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  __int16 v27;
  _BYTE v28[2046];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF)
    return result;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v7 = gModeId;
  a1[2] = gModeId;
  v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 58;
  a1[6] = a3;
  v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x3A];
  v10 = a1[5];
  v11 = crc_16_l_table[(v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  v12 = crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)];
  v13 = crc_16_l_table[(a1[7] ^ v12 ^ HIBYTE(v11))];
  v14 = v13 ^ ~(v12 >> 8);
  *((_WORD *)a1 + 4) = v13 ^ ~HIBYTE(crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)]);
  if (a2 < 20)
    return 0xFFFFFFFFLL;
  bzero(v28, 0x7FEuLL);
  v27 = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    v15 = 3;
    v28[1] = v7 ^ 0x20;
    v16 = 4;
    if ((v8 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v15 = 2;
  v28[0] = v7;
  v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  v17 = a3;
  v18 = &v28[v16 - 2];
  *v18 = v8;
  v18[1] = 58;
  v19 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v10;
  v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    LODWORD(v20) = v19 + 2;
    v17 = a3 ^ 0x20;
  }
  v21 = ~(v13 ^ BYTE1(v12));
  v28[v20 - 2] = v17;
  v22 = v20 + 1;
  v23 = a1[7];
  if ((v23 - 125) <= 1)
  {
    v28[v22 - 2] = 125;
    LOBYTE(v23) = v23 ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  v24 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v28[v22 - 2] = v23;
  v25 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v25 - 2] = 125;
    LODWORD(v25) = v22 + 2;
    LOBYTE(v21) = v21 ^ 0x20;
  }
  v28[v25 - 2] = v21;
  v26 = v25 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v28[v26 - 2] = 125;
    v24 = BYTE1(v14) ^ 0x20;
    LODWORD(v26) = v25 + 2;
  }
  v28[v26 - 2] = v24;
  memcpy(a1, &v27, v26 + 1);
  result = (v26 + 2);
  a1[v26 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetDVGAOffset(unsigned __int8 *a1, int a2, __int16 a3)
{
  uint64_t result;
  int v7;
  int v8;
  char v9;
  unsigned __int16 v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  uint64_t v16;
  char v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  __int16 __src;
  _BYTE v28[2046];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF)
    return result;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v7 = gModeId;
  a1[2] = gModeId;
  v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 117;
  *((_WORD *)a1 + 3) = a3;
  v9 = HIBYTE(a3);
  v10 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x75];
  v11 = a1[5];
  v12 = crc_16_l_table[(v11 ^ v10 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  v13 = crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)];
  v14 = crc_16_l_table[HIBYTE(a3) ^ crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)] ^ (v12 >> 8)];
  *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)]);
  if (a2 < 20)
    return 0xFFFFFFFFLL;
  v26 = v14 ^ ~(v13 >> 8);
  bzero(v28, 0x7FEuLL);
  __src = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    v15 = 3;
    v28[1] = v7 ^ 0x20;
    v16 = 4;
    if ((v8 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v15 = 2;
  v28[0] = v7;
  v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  v17 = a3;
  v18 = &v28[v16 - 2];
  *v18 = v8;
  v18[1] = 117;
  v19 = v16 + 2;
  if ((v11 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v11) = v11 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v11;
  v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    v17 = a3 ^ 0x20;
    LODWORD(v20) = v19 + 2;
  }
  v21 = ~(v14 ^ BYTE1(v13));
  v28[v20 - 2] = v17;
  v22 = v20 + 1;
  if (HIBYTE(a3) - 125 <= 1)
  {
    v28[v22 - 2] = 125;
    v9 = HIBYTE(a3) ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  v23 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
  v28[v22 - 2] = v9;
  v24 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v24 - 2] = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v24) = v22 + 2;
  }
  v28[v24 - 2] = v21;
  v25 = v24 + 1;
  if (BYTE1(v26) - 125 <= 1)
  {
    v28[v25 - 2] = 125;
    v23 = BYTE1(v26) ^ 0x20;
    LODWORD(v25) = v24 + 2;
  }
  v28[v25 - 2] = v23;
  memcpy(a1, &__src, v25 + 1);
  result = (v25 + 2);
  a1[v25 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetDVGAOffset(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t result;
  int v7;
  int v8;
  unsigned __int16 v9;
  int v10;
  unsigned __int16 v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  char v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  __int16 v27;
  _BYTE v28[2046];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF)
    return result;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v7 = gModeId;
  a1[2] = gModeId;
  v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 111;
  a1[6] = a3;
  v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x6F];
  v10 = a1[5];
  v11 = crc_16_l_table[(v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  v12 = crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)];
  v13 = crc_16_l_table[(a1[7] ^ v12 ^ HIBYTE(v11))];
  v14 = v13 ^ ~(v12 >> 8);
  *((_WORD *)a1 + 4) = v13 ^ ~HIBYTE(crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)]);
  if (a2 < 20)
    return 0xFFFFFFFFLL;
  bzero(v28, 0x7FEuLL);
  v27 = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    v15 = 3;
    v28[1] = v7 ^ 0x20;
    v16 = 4;
    if ((v8 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v15 = 2;
  v28[0] = v7;
  v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  v17 = a3;
  v18 = &v28[v16 - 2];
  *v18 = v8;
  v18[1] = 111;
  v19 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v10;
  v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    LODWORD(v20) = v19 + 2;
    v17 = a3 ^ 0x20;
  }
  v21 = ~(v13 ^ BYTE1(v12));
  v28[v20 - 2] = v17;
  v22 = v20 + 1;
  v23 = a1[7];
  if ((v23 - 125) <= 1)
  {
    v28[v22 - 2] = 125;
    LOBYTE(v23) = v23 ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  v24 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v28[v22 - 2] = v23;
  v25 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v25 - 2] = 125;
    LODWORD(v25) = v22 + 2;
    LOBYTE(v21) = v21 ^ 0x20;
  }
  v28[v25 - 2] = v21;
  v26 = v25 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v28[v26 - 2] = 125;
    v24 = BYTE1(v14) ^ 0x20;
    LODWORD(v26) = v25 + 2;
  }
  v28[v26 - 2] = v24;
  memcpy(a1, &v27, v26 + 1);
  result = (v26 + 2);
  a1[v26 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetLNAOffset(unsigned __int8 *a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t result;
  int v9;
  int v10;
  char v11;
  char v12;
  unsigned __int16 v13;
  int v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  _BYTE *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  int v39;
  _BYTE __src[2048];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x11)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    v9 = gModeId;
    a1[2] = gModeId;
    v10 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 118;
    *((_WORD *)a1 + 3) = a3;
    v11 = HIBYTE(a3);
    *((_WORD *)a1 + 4) = a4;
    v12 = HIBYTE(a4);
    v13 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0x76];
    v14 = a1[5];
    v15 = crc_16_l_table[(v14 ^ v13 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC]))];
    v16 = crc_16_l_table[(v15 ^ HIBYTE(v13) ^ a3)];
    v17 = crc_16_l_table[(HIBYTE(a3) ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    *((_WORD *)a1 + 5) = v19 ^ ~(unsigned __int16)(v18 >> 8);
    if (a2 >= 24)
    {
      v38 = v19;
      v39 = v19 ^ ~(v18 >> 8);
      bzero(__src, 0x800uLL);
      v20 = *a1;
      if ((v20 - 125) > 1)
      {
        v21 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v20) = v20 ^ 0x20;
        v21 = 1;
      }
      __src[v21] = v20;
      v22 = v21 + 1;
      v23 = a1[1];
      if ((v23 - 125) <= 1)
      {
        __src[v22] = 125;
        LODWORD(v22) = v21 | 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      __src[v22] = v23;
      v24 = v22 + 1;
      if ((v9 - 125) <= 1)
      {
        __src[v24] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      __src[v24] = v9;
      v25 = v24 + 1;
      if ((v10 - 125) <= 1)
      {
        __src[v25] = 125;
        LOBYTE(v10) = v10 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      v26 = a3;
      v27 = &__src[v25];
      *v27 = v10;
      v27[1] = 118;
      v28 = v25 + 2;
      if ((v14 - 125) <= 1)
      {
        __src[v28] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v28) = v25 + 3;
      }
      __src[v28] = v14;
      v29 = v28 + 1;
      if (a3 - 125 <= 1)
      {
        __src[v29] = 125;
        v26 = a3 ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      v30 = a4;
      __src[v29] = v26;
      v31 = v29 + 1;
      if (HIBYTE(a3) - 125 <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v29 + 2;
        v11 = HIBYTE(a3) ^ 0x20;
      }
      __src[v31] = v11;
      v32 = v31 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v32] = 125;
        v30 = a4 ^ 0x20;
        LODWORD(v32) = v31 + 2;
      }
      v33 = ~(v38 ^ BYTE1(v18));
      __src[v32] = v30;
      v34 = v32 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v34] = 125;
        v12 = HIBYTE(a4) ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      v35 = BYTE1(v39);
      __src[v34] = v12;
      v36 = v34 + 1;
      if ((v33 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v34 + 2;
        LOBYTE(v33) = v33 ^ 0x20;
      }
      __src[v36] = v33;
      v37 = v36 + 1;
      if (BYTE1(v39) - 125 <= 1)
      {
        __src[v37] = 125;
        v35 = BYTE1(v39) ^ 0x20;
        LODWORD(v37) = v36 + 2;
      }
      __src[v37] = v35;
      memcpy(a1, __src, v37 + 1);
      result = (v37 + 2);
      a1[v37 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetLNAOffset(unsigned __int8 *a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t result;
  int v9;
  int v10;
  char v11;
  char v12;
  unsigned __int16 v13;
  int v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  _BYTE *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  int v39;
  _BYTE __src[2048];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x11)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    v9 = gModeId;
    a1[2] = gModeId;
    v10 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 81;
    *((_WORD *)a1 + 3) = a3;
    v11 = HIBYTE(a3);
    *((_WORD *)a1 + 4) = a4;
    v12 = HIBYTE(a4);
    v13 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0x51];
    v14 = a1[5];
    v15 = crc_16_l_table[(v14 ^ v13 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC]))];
    v16 = crc_16_l_table[(v15 ^ HIBYTE(v13) ^ a3)];
    v17 = crc_16_l_table[(HIBYTE(a3) ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    *((_WORD *)a1 + 5) = v19 ^ ~(unsigned __int16)(v18 >> 8);
    if (a2 >= 24)
    {
      v38 = v19;
      v39 = v19 ^ ~(v18 >> 8);
      bzero(__src, 0x800uLL);
      v20 = *a1;
      if ((v20 - 125) > 1)
      {
        v21 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v20) = v20 ^ 0x20;
        v21 = 1;
      }
      __src[v21] = v20;
      v22 = v21 + 1;
      v23 = a1[1];
      if ((v23 - 125) <= 1)
      {
        __src[v22] = 125;
        LODWORD(v22) = v21 | 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      __src[v22] = v23;
      v24 = v22 + 1;
      if ((v9 - 125) <= 1)
      {
        __src[v24] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      __src[v24] = v9;
      v25 = v24 + 1;
      if ((v10 - 125) <= 1)
      {
        __src[v25] = 125;
        LOBYTE(v10) = v10 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      v26 = a3;
      v27 = &__src[v25];
      *v27 = v10;
      v27[1] = 81;
      v28 = v25 + 2;
      if ((v14 - 125) <= 1)
      {
        __src[v28] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v28) = v25 + 3;
      }
      __src[v28] = v14;
      v29 = v28 + 1;
      if (a3 - 125 <= 1)
      {
        __src[v29] = 125;
        v26 = a3 ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      v30 = a4;
      __src[v29] = v26;
      v31 = v29 + 1;
      if (HIBYTE(a3) - 125 <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v29 + 2;
        v11 = HIBYTE(a3) ^ 0x20;
      }
      __src[v31] = v11;
      v32 = v31 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v32] = 125;
        v30 = a4 ^ 0x20;
        LODWORD(v32) = v31 + 2;
      }
      v33 = ~(v38 ^ BYTE1(v18));
      __src[v32] = v30;
      v34 = v32 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v34] = 125;
        v12 = HIBYTE(a4) ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      v35 = BYTE1(v39);
      __src[v34] = v12;
      v36 = v34 + 1;
      if ((v33 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v34 + 2;
        LOBYTE(v33) = v33 ^ 0x20;
      }
      __src[v36] = v33;
      v37 = v36 + 1;
      if (BYTE1(v39) - 125 <= 1)
      {
        __src[v37] = 125;
        v35 = BYTE1(v39) ^ 0x20;
        LODWORD(v37) = v36 + 2;
      }
      __src[v37] = v35;
      memcpy(a1, __src, v37 + 1);
      result = (v37 + 2);
      a1[v37 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetgModeId(unsigned int a1)
{
  if (a1 > 0x8002)
    return 0xFFFFFFFFLL;
  gModeId = a1;
  return 1;
}

uint64_t APPLIB_DIAG_FTM_SetCalibrationState(_WORD *a1, int a2)
{
  return APPLIB_DIAG_ModeChange(a1, a2, 3u);
}

uint64_t APPLIB_DIAG_FTM_CDMA_API2_CALIBRATE_DVGA(char *a1, int a2, int a3, __int16 a4)
{
  uint64_t result;
  char v9;
  uint64_t v10;
  unsigned __int16 v11;
  int v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE v40[2048];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x14)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 1182539;
    a1[4] = 1;
    a1[10] = a3;
    *(_WORD *)(a1 + 11) = a4;
    v9 = HIBYTE(a4);
    v10 = a1[5];
    v11 = crc_16_l_table[v10 ^ 0xF7];
    v12 = a1[6];
    v13 = crc_16_l_table[(v12 ^ v11) ^ 0x57];
    v14 = crc_16_l_table[(a1[7] ^ v13 ^ HIBYTE(v11))];
    v15 = crc_16_l_table[(a1[8] ^ v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[(a1[9] ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(a3 ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    v20 = v19 ^ ~(v18 >> 8);
    *(_WORD *)(a1 + 13) = v19 ^ ~HIBYTE(crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))]);
    if (a2 >= 30)
    {
      bzero(v40, 0x800uLL);
      v21 = *a1;
      if ((v21 - 125) > 1)
      {
        v22 = 0;
      }
      else
      {
        v40[0] = 125;
        LOBYTE(v21) = v21 ^ 0x20;
        v22 = 1;
      }
      v23 = &v40[v22];
      *v23 = v21;
      *(_DWORD *)(v23 + 1) = 16781835;
      v24 = v22 + 5;
      if ((v10 - 125) <= 1)
      {
        v40[v24] = 125;
        LODWORD(v24) = v22 | 6;
        LOBYTE(v10) = v10 ^ 0x20;
      }
      v40[v24] = v10;
      v25 = v24 + 1;
      if ((v12 - 125) <= 1)
      {
        v40[v25] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      v40[v25] = v12;
      v26 = v25 + 1;
      v27 = a1[7];
      if ((v27 - 125) <= 1)
      {
        v40[v26] = 125;
        LODWORD(v26) = v25 + 2;
        LOBYTE(v27) = v27 ^ 0x20;
      }
      v40[v26] = v27;
      v28 = v26 + 1;
      v29 = a1[8];
      if ((v29 - 125) <= 1)
      {
        v40[v28] = 125;
        LOBYTE(v29) = v29 ^ 0x20;
        LODWORD(v28) = v26 + 2;
      }
      v40[v28] = v29;
      v30 = v28 + 1;
      v31 = a1[9];
      if ((v31 - 125) <= 1)
      {
        v40[v30] = 125;
        LOBYTE(v31) = v31 ^ 0x20;
        LODWORD(v30) = v28 + 2;
      }
      v32 = a4;
      v40[v30] = v31;
      v33 = v30 + 1;
      if ((a3 - 125) <= 1)
      {
        v40[v33] = 125;
        LOBYTE(a3) = a3 ^ 0x20;
        LODWORD(v33) = v30 + 2;
      }
      v40[v33] = a3;
      v34 = v33 + 1;
      if (a4 - 125 <= 1)
      {
        v40[v34] = 125;
        LODWORD(v34) = v33 + 2;
        v32 = a4 ^ 0x20;
      }
      v35 = ~(v19 ^ BYTE1(v18));
      v40[v34] = v32;
      v36 = v34 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        v40[v36] = 125;
        v9 = HIBYTE(a4) ^ 0x20;
        LODWORD(v36) = v34 + 2;
      }
      v37 = (unsigned __int16)(v19 ^ ~(unsigned __int16)(v18 >> 8)) >> 8;
      v40[v36] = v9;
      v38 = v36 + 1;
      if ((v35 - 125) <= 1)
      {
        v40[v38] = 125;
        LODWORD(v38) = v36 + 2;
        LOBYTE(v35) = v35 ^ 0x20;
      }
      v40[v38] = v35;
      v39 = v38 + 1;
      if (BYTE1(v20) - 125 <= 1)
      {
        v40[v39] = 125;
        v37 = BYTE1(v20) ^ 0x20;
        LODWORD(v39) = v38 + 2;
      }
      v40[v39] = v37;
      memcpy(a1, v40, v39 + 1);
      result = (v39 + 2);
      a1[v39 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA_API2_CALIBRATE_LNA(unsigned __int8 *a1, int a2, unsigned __int8 a3, __int16 a4, unsigned __int8 a5)
{
  uint64_t result;
  char v11;
  uint64_t v12;
  unsigned __int16 v13;
  int v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  char v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  char v50;
  uint64_t v51;
  uint64_t v52;
  _BYTE __src[2048];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x14)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 1182539;
    a1[4] = 2;
    a1[10] = a3;
    a1[11] = a5;
    *((_WORD *)a1 + 6) = a4;
    v11 = HIBYTE(a4);
    v12 = a1[5];
    v13 = crc_16_l_table[v12 ^ 0x6C];
    v14 = a1[6];
    v15 = crc_16_l_table[(v14 ^ v13) ^ 0x65];
    v16 = crc_16_l_table[(a1[7] ^ v15 ^ HIBYTE(v13))];
    v17 = crc_16_l_table[(a1[8] ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a1[9] ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[(a3 ^ v18 ^ HIBYTE(v17))];
    v20 = crc_16_l_table[(a5 ^ v19 ^ HIBYTE(v18))];
    v21 = crc_16_l_table[(a4 ^ v20 ^ HIBYTE(v19))];
    v22 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v20 ^ HIBYTE(v19))] ^ (v20 >> 8)];
    v23 = v22 ^ ~(v21 >> 8);
    *((_WORD *)a1 + 7) = v22 ^ ~HIBYTE(crc_16_l_table[(a4 ^ v20 ^ HIBYTE(v19))]);
    if (a2 >= 32)
    {
      bzero(__src, 0x800uLL);
      v24 = *a1;
      if ((v24 - 125) > 1)
      {
        v25 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v24) = v24 ^ 0x20;
        v25 = 1;
      }
      __src[v25] = v24;
      v26 = v25 + 1;
      v27 = a1[1];
      if ((v27 - 125) <= 1)
      {
        __src[v26] = 125;
        LODWORD(v26) = v25 | 2;
        LOBYTE(v27) = v27 ^ 0x20;
      }
      __src[v26] = v27;
      v28 = v26 + 1;
      v29 = a1[2];
      if ((v29 - 125) <= 1)
      {
        __src[v28] = 125;
        LOBYTE(v29) = v29 ^ 0x20;
        LODWORD(v28) = v26 + 2;
      }
      __src[v28] = v29;
      v30 = v28 + 1;
      v31 = a1[3];
      if ((v31 - 125) <= 1)
      {
        __src[v30] = 125;
        LODWORD(v30) = v28 + 2;
        LOBYTE(v31) = v31 ^ 0x20;
      }
      __src[v30] = v31;
      v32 = v30 + 1;
      v33 = a1[4];
      if ((v33 - 125) <= 1)
      {
        __src[v32] = 125;
        LOBYTE(v33) = v33 ^ 0x20;
        LODWORD(v32) = v30 + 2;
      }
      __src[v32] = v33;
      v34 = v32 + 1;
      if ((v12 - 125) <= 1)
      {
        __src[v34] = 125;
        LODWORD(v34) = v32 + 2;
        LOBYTE(v12) = v12 ^ 0x20;
      }
      __src[v34] = v12;
      v35 = v34 + 1;
      if ((v14 - 125) <= 1)
      {
        __src[v35] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v35) = v34 + 2;
      }
      __src[v35] = v14;
      v36 = v35 + 1;
      v37 = a1[7];
      if ((v37 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v35 + 2;
        LOBYTE(v37) = v37 ^ 0x20;
      }
      __src[v36] = v37;
      v38 = v36 + 1;
      v39 = a1[8];
      if ((v39 - 125) <= 1)
      {
        __src[v38] = 125;
        LOBYTE(v39) = v39 ^ 0x20;
        LODWORD(v38) = v36 + 2;
      }
      __src[v38] = v39;
      v40 = v38 + 1;
      v41 = a1[9];
      if ((v41 - 125) <= 1)
      {
        __src[v40] = 125;
        LODWORD(v40) = v38 + 2;
        LOBYTE(v41) = v41 ^ 0x20;
      }
      __src[v40] = v41;
      v42 = v40 + 1;
      v43 = a1[10];
      if ((v43 - 125) <= 1)
      {
        __src[v42] = 125;
        LOBYTE(v43) = v43 ^ 0x20;
        LODWORD(v42) = v40 + 2;
      }
      v44 = a4;
      __src[v42] = v43;
      v45 = v42 + 1;
      v46 = a1[11];
      if ((v46 - 125) <= 1)
      {
        __src[v45] = 125;
        LODWORD(v45) = v42 + 2;
        LOBYTE(v46) = v46 ^ 0x20;
      }
      __src[v45] = v46;
      v47 = v45 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v47] = 125;
        v44 = a4 ^ 0x20;
        LODWORD(v47) = v45 + 2;
      }
      v48 = ~(v22 ^ BYTE1(v21));
      __src[v47] = v44;
      v49 = v47 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v49] = 125;
        v11 = HIBYTE(a4) ^ 0x20;
        LODWORD(v49) = v47 + 2;
      }
      v50 = (unsigned __int16)(v22 ^ ~(unsigned __int16)(v21 >> 8)) >> 8;
      __src[v49] = v11;
      v51 = v49 + 1;
      if ((v48 - 125) <= 1)
      {
        __src[v51] = 125;
        LOBYTE(v48) = v48 ^ 0x20;
        LODWORD(v51) = v49 + 2;
      }
      __src[v51] = v48;
      v52 = v51 + 1;
      if (BYTE1(v23) - 125 <= 1)
      {
        __src[v52] = 125;
        v50 = BYTE1(v23) ^ 0x20;
        LODWORD(v52) = v51 + 2;
      }
      __src[v52] = v50;
      memcpy(a1, __src, v52 + 1);
      result = (v52 + 2);
      a1[v52 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SecondChainTestCall(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t result;
  int v7;
  int v8;
  unsigned __int16 v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  char v17;
  _BYTE *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  __int16 v25;
  _BYTE v26[2046];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xE)
    return result;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v7 = gModeId;
  a1[2] = gModeId;
  v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 123;
  a1[6] = a3;
  v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x7B];
  v10 = a1[5];
  v11 = (v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]));
  v12 = crc_16_l_table[v11];
  v13 = crc_16_l_table[(v12 ^ HIBYTE(v9) ^ a3)];
  v14 = v13 ^ ~(v12 >> 8);
  *(_WORD *)(a1 + 7) = v13 ^ ~HIBYTE(crc_16_l_table[v11]);
  if (a2 < 18)
    return 0xFFFFFFFFLL;
  bzero(v26, 0x7FEuLL);
  v25 = 2891;
  if ((v7 - 125) <= 1)
  {
    v26[0] = 125;
    v15 = 3;
    v26[1] = v7 ^ 0x20;
    v16 = 4;
    if ((v8 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v15 = 2;
  v26[0] = v7;
  v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v26[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  v17 = a3;
  v18 = &v26[v16 - 2];
  *v18 = v8;
  v18[1] = 123;
  v19 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v26[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v20 = ~(v13 ^ BYTE1(v12));
  v26[v19 - 2] = v10;
  v21 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v26[v21 - 2] = 125;
    v17 = a3 ^ 0x20;
    LODWORD(v21) = v19 + 2;
  }
  v22 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v26[v21 - 2] = v17;
  v23 = v21 + 1;
  if ((v20 - 125) <= 1)
  {
    v26[v23 - 2] = 125;
    LODWORD(v23) = v21 + 2;
    LOBYTE(v20) = v20 ^ 0x20;
  }
  v26[v23 - 2] = v20;
  v24 = v23 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v26[v24 - 2] = 125;
    v22 = BYTE1(v14) ^ 0x20;
    LODWORD(v24) = v23 + 2;
  }
  v26[v24 - 2] = v22;
  memcpy(a1, &v25, v24 + 1);
  result = (v24 + 2);
  a1[v24 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetSecondaryChain(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t result;
  int v7;
  int v8;
  unsigned __int16 v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  char v17;
  _BYTE *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  __int16 v25;
  _BYTE v26[2046];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xE)
    return result;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  v7 = gModeId;
  a1[2] = gModeId;
  v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 121;
  a1[6] = a3;
  v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x79];
  v10 = a1[5];
  v11 = (v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]));
  v12 = crc_16_l_table[v11];
  v13 = crc_16_l_table[(v12 ^ HIBYTE(v9) ^ a3)];
  v14 = v13 ^ ~(v12 >> 8);
  *(_WORD *)(a1 + 7) = v13 ^ ~HIBYTE(crc_16_l_table[v11]);
  if (a2 < 18)
    return 0xFFFFFFFFLL;
  bzero(v26, 0x7FEuLL);
  v25 = 2891;
  if ((v7 - 125) <= 1)
  {
    v26[0] = 125;
    v15 = 3;
    v26[1] = v7 ^ 0x20;
    v16 = 4;
    if ((v8 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v15 = 2;
  v26[0] = v7;
  v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v26[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  v17 = a3;
  v18 = &v26[v16 - 2];
  *v18 = v8;
  v18[1] = 121;
  v19 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v26[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v20 = ~(v13 ^ BYTE1(v12));
  v26[v19 - 2] = v10;
  v21 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v26[v21 - 2] = 125;
    v17 = a3 ^ 0x20;
    LODWORD(v21) = v19 + 2;
  }
  v22 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v26[v21 - 2] = v17;
  v23 = v21 + 1;
  if ((v20 - 125) <= 1)
  {
    v26[v23 - 2] = 125;
    LODWORD(v23) = v21 + 2;
    LOBYTE(v20) = v20 ^ 0x20;
  }
  v26[v23 - 2] = v20;
  v24 = v23 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v26[v24 - 2] = 125;
    v22 = BYTE1(v14) ^ 0x20;
    LODWORD(v24) = v23 + 2;
  }
  v26[v24 - 2] = v22;
  memcpy(a1, &v25, v24 + 1);
  result = (v24 + 2);
  a1[v24 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_ChangeFTM_BootMode(char *a1, int a2, char a3)
{
  char __src;

  __src = a3;
  return APPLIB_DIAG_NvItemWrite(a1, a2, 453, &__src, 1);
}

uint64_t APPLIB_DIAG_FTM_CDMA_API2_CALIBRATE_IM2(unsigned __int8 *a1, int a2, int a3)
{
  uint64_t result;
  uint64_t v7;
  unsigned __int16 v8;
  int v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  int __src;
  char v32;
  _BYTE v33[2043];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x14)
    return result;
  bzero(a1, a2);
  *(_DWORD *)a1 = 1182539;
  a1[4] = 3;
  a1[10] = a3;
  v7 = a1[5];
  v8 = crc_16_l_table[v7 ^ 0xE5];
  v9 = a1[6];
  v10 = crc_16_l_table[(v9 ^ v8) ^ 0x74];
  v11 = crc_16_l_table[(a1[7] ^ v10 ^ HIBYTE(v8))];
  v12 = crc_16_l_table[(a1[8] ^ v11 ^ HIBYTE(v10))];
  v13 = crc_16_l_table[(a1[9] ^ v12 ^ HIBYTE(v11))];
  v14 = crc_16_l_table[(v13 ^ HIBYTE(v12)) ^ a3];
  v15 = v14 ^ ~(v13 >> 8);
  *((_WORD *)a1 + 6) = v14 ^ ~HIBYTE(crc_16_l_table[(a1[9] ^ v12 ^ HIBYTE(v11))]);
  if (a2 < 28)
    return 0xFFFFFFFFLL;
  bzero(v33, 0x7FBuLL);
  __src = 1182539;
  v32 = 3;
  if ((v7 - 125) <= 1)
  {
    v33[0] = 125;
    v16 = 6;
    v33[1] = v7 ^ 0x20;
    v17 = 7;
    if ((v9 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v16 = 5;
  v33[0] = v7;
  v17 = 6;
  if ((v9 - 125) <= 1)
  {
LABEL_9:
    *((_BYTE *)&__src + v17) = 125;
    LODWORD(v17) = v16 + 2;
    LOBYTE(v9) = v9 ^ 0x20;
  }
LABEL_10:
  *((_BYTE *)&__src + v17) = v9;
  v18 = v17 + 1;
  v19 = a1[7];
  if ((v19 - 125) <= 1)
  {
    *((_BYTE *)&__src + v18) = 125;
    LOBYTE(v19) = v19 ^ 0x20;
    LODWORD(v18) = v17 + 2;
  }
  *((_BYTE *)&__src + v18) = v19;
  v20 = v18 + 1;
  v21 = a1[8];
  if ((v21 - 125) <= 1)
  {
    *((_BYTE *)&__src + v20) = 125;
    LODWORD(v20) = v18 + 2;
    LOBYTE(v21) = v21 ^ 0x20;
  }
  *((_BYTE *)&__src + v20) = v21;
  v22 = v20 + 1;
  v23 = a1[9];
  if ((v23 - 125) <= 1)
  {
    *((_BYTE *)&__src + v22) = 125;
    LODWORD(v22) = v20 + 2;
    LOBYTE(v23) = v23 ^ 0x20;
  }
  *((_BYTE *)&__src + v22) = v23;
  v24 = v22 + 1;
  if ((a3 - 125) <= 1)
  {
    *((_BYTE *)&__src + v24) = 125;
    LOBYTE(a3) = a3 ^ 0x20;
    LODWORD(v24) = v22 + 2;
  }
  v25 = ~(v14 ^ BYTE1(v13));
  *((_BYTE *)&__src + v24) = a3;
  v26 = v24 + 1;
  v27 = a1[11];
  if ((v27 - 125) <= 1)
  {
    *((_BYTE *)&__src + v26) = 125;
    LOBYTE(v27) = v27 ^ 0x20;
    LODWORD(v26) = v24 + 2;
  }
  v28 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
  *((_BYTE *)&__src + v26) = v27;
  v29 = v26 + 1;
  if ((v25 - 125) <= 1)
  {
    *((_BYTE *)&__src + v29) = 125;
    LOBYTE(v25) = v25 ^ 0x20;
    LODWORD(v29) = v26 + 2;
  }
  *((_BYTE *)&__src + v29) = v25;
  v30 = v29 + 1;
  if (BYTE1(v15) - 125 <= 1)
  {
    *((_BYTE *)&__src + v30) = 125;
    v28 = BYTE1(v15) ^ 0x20;
    LODWORD(v30) = v29 + 2;
  }
  *((_BYTE *)&__src + v30) = v28;
  memcpy(a1, &__src, v30 + 1);
  result = (v30 + 2);
  a1[v30 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA_API2_CALIBRATE_INTELLICEIVER(char *a1, int a2, int a3, __int16 a4)
{
  uint64_t result;
  char v9;
  uint64_t v10;
  unsigned __int16 v11;
  int v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE v40[2048];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x14)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 1182539;
    a1[4] = 4;
    a1[10] = a3;
    *(_WORD *)(a1 + 11) = a4;
    v9 = HIBYTE(a4);
    v10 = a1[5];
    v11 = crc_16_l_table[v10 ^ 0x5A];
    v12 = a1[6];
    v13 = crc_16_l_table[(v12 ^ v11)];
    v14 = crc_16_l_table[(a1[7] ^ v13 ^ HIBYTE(v11))];
    v15 = crc_16_l_table[(a1[8] ^ v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[(a1[9] ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(a3 ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    v20 = v19 ^ ~(v18 >> 8);
    *(_WORD *)(a1 + 13) = v19 ^ ~HIBYTE(crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))]);
    if (a2 >= 30)
    {
      bzero(v40, 0x800uLL);
      v21 = *a1;
      if ((v21 - 125) > 1)
      {
        v22 = 0;
      }
      else
      {
        v40[0] = 125;
        LOBYTE(v21) = v21 ^ 0x20;
        v22 = 1;
      }
      v23 = &v40[v22];
      *v23 = v21;
      *(_DWORD *)(v23 + 1) = 67113483;
      v24 = v22 + 5;
      if ((v10 - 125) <= 1)
      {
        v40[v24] = 125;
        LODWORD(v24) = v22 | 6;
        LOBYTE(v10) = v10 ^ 0x20;
      }
      v40[v24] = v10;
      v25 = v24 + 1;
      if ((v12 - 125) <= 1)
      {
        v40[v25] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      v40[v25] = v12;
      v26 = v25 + 1;
      v27 = a1[7];
      if ((v27 - 125) <= 1)
      {
        v40[v26] = 125;
        LODWORD(v26) = v25 + 2;
        LOBYTE(v27) = v27 ^ 0x20;
      }
      v40[v26] = v27;
      v28 = v26 + 1;
      v29 = a1[8];
      if ((v29 - 125) <= 1)
      {
        v40[v28] = 125;
        LOBYTE(v29) = v29 ^ 0x20;
        LODWORD(v28) = v26 + 2;
      }
      v40[v28] = v29;
      v30 = v28 + 1;
      v31 = a1[9];
      if ((v31 - 125) <= 1)
      {
        v40[v30] = 125;
        LOBYTE(v31) = v31 ^ 0x20;
        LODWORD(v30) = v28 + 2;
      }
      v32 = a4;
      v40[v30] = v31;
      v33 = v30 + 1;
      if ((a3 - 125) <= 1)
      {
        v40[v33] = 125;
        LOBYTE(a3) = a3 ^ 0x20;
        LODWORD(v33) = v30 + 2;
      }
      v40[v33] = a3;
      v34 = v33 + 1;
      if (a4 - 125 <= 1)
      {
        v40[v34] = 125;
        LODWORD(v34) = v33 + 2;
        v32 = a4 ^ 0x20;
      }
      v35 = ~(v19 ^ BYTE1(v18));
      v40[v34] = v32;
      v36 = v34 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        v40[v36] = 125;
        v9 = HIBYTE(a4) ^ 0x20;
        LODWORD(v36) = v34 + 2;
      }
      v37 = (unsigned __int16)(v19 ^ ~(unsigned __int16)(v18 >> 8)) >> 8;
      v40[v36] = v9;
      v38 = v36 + 1;
      if ((v35 - 125) <= 1)
      {
        v40[v38] = 125;
        LODWORD(v38) = v36 + 2;
        LOBYTE(v35) = v35 ^ 0x20;
      }
      v40[v38] = v35;
      v39 = v38 + 1;
      if (BYTE1(v20) - 125 <= 1)
      {
        v40[v39] = 125;
        v37 = BYTE1(v20) ^ 0x20;
        LODWORD(v39) = v38 + 2;
      }
      v40[v39] = v37;
      memcpy(a1, v40, v39 + 1);
      result = (v39 + 2);
      a1[v39 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_DO_ENH_XO_DC_CAL(char *a1, int a2, __int128 *a3)
{
  uint64_t result;
  __int128 v7;
  __int128 v8;
  int v9;
  int v10;
  char *v11;
  char v12;
  uint64_t v13;
  size_t v14;
  int v15;
  int v16;
  _BYTE __src[2048];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x33)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 1313611;
    a1[4] = -102;
    a1[8] = 12;
    v7 = *a3;
    v8 = a3[1];
    *(_OWORD *)(a1 + 40) = *(__int128 *)((char *)a3 + 30);
    *(_OWORD *)(a1 + 26) = v8;
    *(_OWORD *)(a1 + 10) = v7;
    v9 = 448;
    LOWORD(v10) = -1;
    v11 = a1;
    do
    {
      v12 = *v11++;
      v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
      v9 -= 8;
    }
    while ((_WORD)v9);
    *((_WORD *)a1 + 28) = ~(_WORD)v10;
    if (a2 >= 116)
    {
      bzero(__src, 0x800uLL);
      v13 = 0;
      LODWORD(v14) = 0;
      do
      {
        while (1)
        {
          v16 = a1[v13];
          if ((v16 - 125) > 1)
            break;
          v15 = v14 + 1;
          __src[(int)v14] = 125;
          __src[(int)v14 + 1] = v16 ^ 0x20;
          v14 = (int)v14 + 1 + 1;
          if (++v13 == 58)
            goto LABEL_11;
        }
        v15 = v14;
        __src[(int)v14] = v16;
        v14 = (int)v14 + 1;
        ++v13;
      }
      while (v13 != 58);
LABEL_11:
      memcpy(a1, __src, v14);
      result = (v15 + 2);
      a1[v14] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_DO_ENH_XO_FT_CURVE_CAL(char *a1, int a2, __int128 *a3)
{
  uint64_t result;
  __int128 v7;
  __int128 v8;
  int v9;
  int v10;
  char *v11;
  char v12;
  uint64_t v13;
  size_t v14;
  int v15;
  int v16;
  _BYTE __src[2048];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x33)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 1313611;
    a1[4] = -101;
    a1[8] = 12;
    v7 = *a3;
    v8 = a3[1];
    *(_OWORD *)(a1 + 40) = *(__int128 *)((char *)a3 + 30);
    *(_OWORD *)(a1 + 26) = v8;
    *(_OWORD *)(a1 + 10) = v7;
    v9 = 448;
    LOWORD(v10) = -1;
    v11 = a1;
    do
    {
      v12 = *v11++;
      v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
      v9 -= 8;
    }
    while ((_WORD)v9);
    *((_WORD *)a1 + 28) = ~(_WORD)v10;
    if (a2 >= 116)
    {
      bzero(__src, 0x800uLL);
      v13 = 0;
      LODWORD(v14) = 0;
      do
      {
        while (1)
        {
          v16 = a1[v13];
          if ((v16 - 125) > 1)
            break;
          v15 = v14 + 1;
          __src[(int)v14] = 125;
          __src[(int)v14 + 1] = v16 ^ 0x20;
          v14 = (int)v14 + 1 + 1;
          if (++v13 == 58)
            goto LABEL_11;
        }
        v15 = v14;
        __src[(int)v14] = v16;
        v14 = (int)v14 + 1;
        ++v13;
      }
      while (v13 != 58);
LABEL_11:
      memcpy(a1, __src, v14);
      result = (v15 + 2);
      a1[v14] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_PILOT_ACQ(char *a1, int a2, int a3, __int16 a4, int a5)
{
  uint64_t result;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned int v23;
  unsigned __int16 v24;
  int v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  int v62;
  int v63;
  uint64_t v64;
  int v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  _BYTE __src[2048];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 461643;
    *((_WORD *)a1 + 2) = 100;
    *(_DWORD *)(a1 + 10) = a3;
    *((_WORD *)a1 + 7) = a4;
    *((_DWORD *)a1 + 4) = a5;
    v11 = crc_16_l_table[a1[6] ^ 0x7CLL];
    v12 = crc_16_l_table[a1[7] ^ 0x35 ^ v11];
    v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
    v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
    v15 = crc_16_l_table[(a3 ^ v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[(BYTE1(a3) ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(BYTE2(a3) ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(HIBYTE(a3) ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[(a4 ^ v18 ^ HIBYTE(v17))];
    v20 = crc_16_l_table[(HIBYTE(a4) ^ v19 ^ HIBYTE(v18))];
    v21 = crc_16_l_table[(v20 ^ HIBYTE(v19) ^ a5)];
    v22 = crc_16_l_table[(a1[17] ^ v21 ^ HIBYTE(v20))];
    v23 = crc_16_l_table[(a1[18] ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(a1[19] ^ v23 ^ HIBYTE(v22))];
    *((_WORD *)a1 + 10) = v24 ^ ~HIBYTE(crc_16_l_table[(a1[18] ^ v22 ^ HIBYTE(v21))]);
    if (a2 >= 44)
    {
      bzero(__src, 0x800uLL);
      v25 = *a1;
      if ((v25 - 125) > 1)
      {
        v26 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v25) = v25 ^ 0x20;
        v26 = 1;
      }
      __src[v26] = v25;
      v27 = v26 + 1;
      v28 = a1[1];
      if ((v28 - 125) <= 1)
      {
        __src[v27] = 125;
        LODWORD(v27) = v26 | 2;
        LOBYTE(v28) = v28 ^ 0x20;
      }
      __src[v27] = v28;
      v29 = v27 + 1;
      v30 = a1[2];
      if ((v30 - 125) <= 1)
      {
        __src[v29] = 125;
        LOBYTE(v30) = v30 ^ 0x20;
        LODWORD(v29) = v27 + 2;
      }
      __src[v29] = v30;
      v31 = v29 + 1;
      v32 = a1[3];
      if ((v32 - 125) <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v29 + 2;
        LOBYTE(v32) = v32 ^ 0x20;
      }
      __src[v31] = v32;
      v33 = v31 + 1;
      v34 = a1[4];
      if ((v34 - 125) <= 1)
      {
        __src[v33] = 125;
        LOBYTE(v34) = v34 ^ 0x20;
        LODWORD(v33) = v31 + 2;
      }
      __src[v33] = v34;
      v35 = v33 + 1;
      v36 = a1[5];
      if ((v36 - 125) <= 1)
      {
        __src[v35] = 125;
        LODWORD(v35) = v33 + 2;
        LOBYTE(v36) = v36 ^ 0x20;
      }
      __src[v35] = v36;
      v37 = v35 + 1;
      v38 = a1[6];
      if ((v38 - 125) <= 1)
      {
        __src[v37] = 125;
        LOBYTE(v38) = v38 ^ 0x20;
        LODWORD(v37) = v35 + 2;
      }
      __src[v37] = v38;
      v39 = v37 + 1;
      v40 = a1[7];
      if ((v40 - 125) <= 1)
      {
        __src[v39] = 125;
        LODWORD(v39) = v37 + 2;
        LOBYTE(v40) = v40 ^ 0x20;
      }
      __src[v39] = v40;
      v41 = v39 + 1;
      v42 = a1[8];
      if ((v42 - 125) <= 1)
      {
        __src[v41] = 125;
        LOBYTE(v42) = v42 ^ 0x20;
        LODWORD(v41) = v39 + 2;
      }
      __src[v41] = v42;
      v43 = v41 + 1;
      v44 = a1[9];
      if ((v44 - 125) <= 1)
      {
        __src[v43] = 125;
        LODWORD(v43) = v41 + 2;
        LOBYTE(v44) = v44 ^ 0x20;
      }
      __src[v43] = v44;
      v45 = v43 + 1;
      v46 = a1[10];
      if ((v46 - 125) <= 1)
      {
        __src[v45] = 125;
        LOBYTE(v46) = v46 ^ 0x20;
        LODWORD(v45) = v43 + 2;
      }
      __src[v45] = v46;
      v47 = v45 + 1;
      v48 = a1[11];
      if ((v48 - 125) <= 1)
      {
        __src[v47] = 125;
        LODWORD(v47) = v45 + 2;
        LOBYTE(v48) = v48 ^ 0x20;
      }
      __src[v47] = v48;
      v49 = v47 + 1;
      v50 = a1[12];
      if ((v50 - 125) <= 1)
      {
        __src[v49] = 125;
        LOBYTE(v50) = v50 ^ 0x20;
        LODWORD(v49) = v47 + 2;
      }
      __src[v49] = v50;
      v51 = v49 + 1;
      v52 = a1[13];
      if ((v52 - 125) <= 1)
      {
        __src[v51] = 125;
        LODWORD(v51) = v49 + 2;
        LOBYTE(v52) = v52 ^ 0x20;
      }
      __src[v51] = v52;
      v53 = v51 + 1;
      v54 = a1[14];
      if ((v54 - 125) <= 1)
      {
        __src[v53] = 125;
        LOBYTE(v54) = v54 ^ 0x20;
        LODWORD(v53) = v51 + 2;
      }
      __src[v53] = v54;
      v55 = v53 + 1;
      v56 = a1[15];
      if ((v56 - 125) <= 1)
      {
        __src[v55] = 125;
        LODWORD(v55) = v53 + 2;
        LOBYTE(v56) = v56 ^ 0x20;
      }
      __src[v55] = v56;
      v57 = v55 + 1;
      v58 = a1[16];
      if ((v58 - 125) <= 1)
      {
        __src[v57] = 125;
        LOBYTE(v58) = v58 ^ 0x20;
        LODWORD(v57) = v55 + 2;
      }
      __src[v57] = v58;
      v59 = v57 + 1;
      v60 = a1[17];
      if ((v60 - 125) <= 1)
      {
        __src[v59] = 125;
        LODWORD(v59) = v57 + 2;
        LOBYTE(v60) = v60 ^ 0x20;
      }
      __src[v59] = v60;
      v61 = v59 + 1;
      v62 = a1[18];
      if ((v62 - 125) <= 1)
      {
        __src[v61] = 125;
        LOBYTE(v62) = v62 ^ 0x20;
        LODWORD(v61) = v59 + 2;
      }
      v63 = ~(v24 ^ BYTE1(v23));
      __src[v61] = v62;
      v64 = v61 + 1;
      v65 = a1[19];
      if ((v65 - 125) <= 1)
      {
        __src[v64] = 125;
        LOBYTE(v65) = v65 ^ 0x20;
        LODWORD(v64) = v61 + 2;
      }
      v66 = ((unsigned __int16)(v24 ^ ~(unsigned __int16)(v23 >> 8)) >> 8);
      __src[v64] = v65;
      v67 = v64 + 1;
      if ((v63 - 125) <= 1)
      {
        __src[v67] = 125;
        LOBYTE(v63) = v63 ^ 0x20;
        LODWORD(v67) = v64 + 2;
      }
      __src[v67] = v63;
      v68 = v67 + 1;
      if ((v66 - 125) <= 1)
      {
        __src[v68] = 125;
        LOBYTE(v66) = v66 ^ 0x20;
        LODWORD(v68) = v67 + 2;
      }
      __src[v68] = v66;
      memcpy(a1, __src, v68 + 1);
      result = (v68 + 2);
      a1[v68 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_DEMOD_SYNC(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned __int16 v6;
  int v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  unsigned int v10;
  unsigned __int16 v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int __src;
  char v25;
  _BYTE v26[2043];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x15)
    return result;
  bzero(a1, a2);
  *(_DWORD *)a1 = 461643;
  a1[4] = 101;
  v5 = a1[5];
  v6 = crc_16_l_table[v5 ^ 0xFD];
  v7 = a1[6];
  v8 = crc_16_l_table[(v7 ^ v6) ^ 0xCE];
  v9 = crc_16_l_table[(a1[7] ^ v8 ^ HIBYTE(v6))];
  v10 = crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))];
  v11 = crc_16_l_table[(a1[9] ^ v10 ^ HIBYTE(v9))];
  *((_WORD *)a1 + 5) = v11 ^ ~HIBYTE(crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))]);
  if (a2 < 24)
    return 0xFFFFFFFFLL;
  bzero(v26, 0x7FBuLL);
  __src = 461643;
  v25 = 101;
  if ((v5 - 125) <= 1)
  {
    v26[0] = 125;
    v12 = 6;
    v26[1] = v5 ^ 0x20;
    v13 = 7;
    if ((v7 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v12 = 5;
  v26[0] = v5;
  v13 = 6;
  if ((v7 - 125) <= 1)
  {
LABEL_9:
    *((_BYTE *)&__src + v13) = 125;
    LOBYTE(v7) = v7 ^ 0x20;
    LODWORD(v13) = v12 + 2;
  }
LABEL_10:
  *((_BYTE *)&__src + v13) = v7;
  v14 = v13 + 1;
  v15 = a1[7];
  if ((v15 - 125) <= 1)
  {
    *((_BYTE *)&__src + v14) = 125;
    LODWORD(v14) = v13 + 2;
    LOBYTE(v15) = v15 ^ 0x20;
  }
  *((_BYTE *)&__src + v14) = v15;
  v16 = v14 + 1;
  v17 = a1[8];
  if ((v17 - 125) <= 1)
  {
    *((_BYTE *)&__src + v16) = 125;
    LOBYTE(v17) = v17 ^ 0x20;
    LODWORD(v16) = v14 + 2;
  }
  v18 = ~(v11 ^ BYTE1(v10));
  *((_BYTE *)&__src + v16) = v17;
  v19 = v16 + 1;
  v20 = a1[9];
  if ((v20 - 125) <= 1)
  {
    *((_BYTE *)&__src + v19) = 125;
    LOBYTE(v20) = v20 ^ 0x20;
    LODWORD(v19) = v16 + 2;
  }
  v21 = ((unsigned __int16)(v11 ^ ~(unsigned __int16)(v10 >> 8)) >> 8);
  *((_BYTE *)&__src + v19) = v20;
  v22 = v19 + 1;
  if ((v18 - 125) <= 1)
  {
    *((_BYTE *)&__src + v22) = 125;
    LOBYTE(v18) = v18 ^ 0x20;
    LODWORD(v22) = v19 + 2;
  }
  *((_BYTE *)&__src + v22) = v18;
  v23 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    *((_BYTE *)&__src + v23) = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v23) = v22 + 2;
  }
  *((_BYTE *)&__src + v23) = v21;
  memcpy(a1, &__src, v23 + 1);
  result = (v23 + 2);
  a1[v23 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_DEMOD_FCH(char *a1, int a2, int a3, char a4, char a5, char a6, char a7, char a8, char a9, uint64_t a10, char a11, char a12, char a13, char a14)
{
  uint64_t result;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  unsigned __int16 v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  unsigned __int16 v37;
  unsigned __int16 v38;
  unsigned __int16 v39;
  unsigned __int16 v40;
  unsigned __int16 v41;
  unsigned int v42;
  uint64_t v43;
  size_t v44;
  int v45;
  int v46;
  _BYTE __src[2048];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 461643;
    *((_WORD *)a1 + 2) = 102;
    *(_DWORD *)(a1 + 10) = a3;
    a1[14] = a4;
    a1[15] = a5;
    a1[16] = a6;
    a1[17] = a7;
    a1[18] = a8;
    a1[19] = a9;
    *((_DWORD *)a1 + 5) = a10;
    a1[24] = a11;
    a1[25] = a12;
    a1[26] = a13;
    a1[27] = a14;
    v22 = crc_16_l_table[a1[6] ^ 0xCCLL];
    v23 = crc_16_l_table[(a1[7] ^ v22) ^ 6];
    v24 = crc_16_l_table[(a1[8] ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a1[9] ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a3 ^ v25 ^ HIBYTE(v24))];
    v27 = crc_16_l_table[(BYTE1(a3) ^ v26 ^ HIBYTE(v25))];
    v28 = crc_16_l_table[(BYTE2(a3) ^ v27 ^ HIBYTE(v26))];
    v29 = crc_16_l_table[(HIBYTE(a3) ^ v28 ^ HIBYTE(v27))];
    v30 = crc_16_l_table[(a4 ^ v29 ^ HIBYTE(v28))];
    v31 = crc_16_l_table[(a5 ^ v30 ^ HIBYTE(v29))];
    v32 = crc_16_l_table[(a6 ^ v31 ^ HIBYTE(v30))];
    v33 = crc_16_l_table[(a7 ^ v32 ^ HIBYTE(v31))];
    v34 = crc_16_l_table[(a8 ^ v33 ^ HIBYTE(v32))];
    v35 = crc_16_l_table[(a9 ^ v34 ^ HIBYTE(v33))];
    v36 = crc_16_l_table[(a10 ^ v35 ^ HIBYTE(v34))];
    v37 = crc_16_l_table[(a1[21] ^ v36 ^ HIBYTE(v35))];
    v38 = crc_16_l_table[(a1[22] ^ v37 ^ HIBYTE(v36))];
    v39 = crc_16_l_table[(a1[23] ^ v38 ^ HIBYTE(v37))];
    v40 = crc_16_l_table[(a11 ^ v39 ^ HIBYTE(v38))];
    v41 = crc_16_l_table[(a12 ^ v40 ^ HIBYTE(v39))];
    v42 = crc_16_l_table[(a13 ^ v41 ^ HIBYTE(v40))];
    *((_WORD *)a1 + 14) = crc_16_l_table[(a14 ^ v42 ^ HIBYTE(v41))] ^ ~(unsigned __int16)(v42 >> 8);
    if (a2 >= 60)
    {
      bzero(__src, 0x800uLL);
      v43 = 0;
      LODWORD(v44) = 0;
      do
      {
        while (1)
        {
          v46 = a1[v43];
          if ((v46 - 125) > 1)
            break;
          v45 = v44 + 1;
          __src[(int)v44] = 125;
          __src[(int)v44 + 1] = v46 ^ 0x20;
          v44 = (int)v44 + 1 + 1;
          if (++v43 == 30)
            goto LABEL_9;
        }
        v45 = v44;
        __src[(int)v44] = v46;
        v44 = (int)v44 + 1;
        ++v43;
      }
      while (v43 != 30);
LABEL_9:
      memcpy(a1, __src, v44);
      result = (v45 + 2);
      a1[v44] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_MOD_FCH(char *a1, int a2, int a3, char a4, int a5, char a6, __int16 a7, int a8)
{
  uint64_t result;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  unsigned __int16 v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  unsigned int v37;
  uint64_t v38;
  size_t v39;
  int v40;
  int v41;
  _BYTE __src[2048];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 461643;
    *((_WORD *)a1 + 2) = 104;
    *(_DWORD *)(a1 + 10) = a3;
    a1[14] = a4;
    *(_DWORD *)(a1 + 15) = a5;
    a1[19] = a6;
    *((_WORD *)a1 + 10) = a7;
    *((_DWORD *)a1 + 6) = a8;
    v17 = crc_16_l_table[a1[6] ^ 0xDCLL];
    v18 = crc_16_l_table[a1[7] ^ 0x9C ^ v17];
    v19 = crc_16_l_table[(a1[8] ^ v18 ^ HIBYTE(v17))];
    v20 = crc_16_l_table[(a1[9] ^ v19 ^ HIBYTE(v18))];
    v21 = crc_16_l_table[(a3 ^ v20 ^ HIBYTE(v19))];
    v22 = crc_16_l_table[(BYTE1(a3) ^ v21 ^ HIBYTE(v20))];
    v23 = crc_16_l_table[(BYTE2(a3) ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(HIBYTE(a3) ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a4 ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a5 ^ v25 ^ HIBYTE(v24))];
    v27 = crc_16_l_table[(BYTE1(a5) ^ v26 ^ HIBYTE(v25))];
    v28 = crc_16_l_table[(BYTE2(a5) ^ v27 ^ HIBYTE(v26))];
    v29 = crc_16_l_table[(HIBYTE(a5) ^ v28 ^ HIBYTE(v27))];
    v30 = crc_16_l_table[(a6 ^ v29 ^ HIBYTE(v28))];
    v31 = crc_16_l_table[(a7 ^ v30 ^ HIBYTE(v29))];
    v32 = crc_16_l_table[(HIBYTE(a7) ^ v31 ^ HIBYTE(v30))];
    v33 = crc_16_l_table[(a1[22] ^ v32 ^ HIBYTE(v31))];
    v34 = crc_16_l_table[(a1[23] ^ v33 ^ HIBYTE(v32))];
    v35 = crc_16_l_table[(a8 ^ v34 ^ HIBYTE(v33))];
    v36 = crc_16_l_table[(a1[25] ^ v35 ^ HIBYTE(v34))];
    v37 = crc_16_l_table[(a1[26] ^ v36 ^ HIBYTE(v35))];
    *((_WORD *)a1 + 14) = crc_16_l_table[(a1[27] ^ v37 ^ HIBYTE(v36))] ^ ~(unsigned __int16)(v37 >> 8);
    if (a2 >= 60)
    {
      bzero(__src, 0x800uLL);
      v38 = 0;
      LODWORD(v39) = 0;
      do
      {
        while (1)
        {
          v41 = a1[v38];
          if ((v41 - 125) > 1)
            break;
          v40 = v39 + 1;
          __src[(int)v39] = 125;
          __src[(int)v39 + 1] = v41 ^ 0x20;
          v39 = (int)v39 + 1 + 1;
          if (++v38 == 30)
            goto LABEL_9;
        }
        v40 = v39;
        __src[(int)v39] = v41;
        v39 = (int)v39 + 1;
        ++v38;
      }
      while (v38 != 30);
LABEL_9:
      memcpy(a1, __src, v39);
      result = (v40 + 2);
      a1[v39] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_FTM_FWD_HHO_SC(char *a1, int a2, int a3, __int16 a4, __int16 a5)
{
  uint64_t result;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned int v21;
  unsigned __int16 v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  int v56;
  int v57;
  uint64_t v58;
  int v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  _BYTE __src[2048];
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 461643;
    *((_WORD *)a1 + 2) = 128;
    *(_DWORD *)(a1 + 10) = a3;
    *((_WORD *)a1 + 7) = a4;
    *((_WORD *)a1 + 8) = a5;
    v11 = crc_16_l_table[a1[6] ^ 0x85];
    v12 = crc_16_l_table[(a1[7] ^ v11) ^ 0xBB];
    v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
    v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
    v15 = crc_16_l_table[(a3 ^ v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[(BYTE1(a3) ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(BYTE2(a3) ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(HIBYTE(a3) ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[(a4 ^ v18 ^ HIBYTE(v17))];
    v20 = crc_16_l_table[(HIBYTE(a4) ^ v19 ^ HIBYTE(v18))];
    v21 = crc_16_l_table[(v20 ^ HIBYTE(v19) ^ a5)];
    v22 = crc_16_l_table[(a1[17] ^ v21 ^ HIBYTE(v20))];
    *((_WORD *)a1 + 9) = v22 ^ ~HIBYTE(crc_16_l_table[(v20 ^ HIBYTE(v19) ^ a5)]);
    if (a2 >= 40)
    {
      bzero(__src, 0x800uLL);
      v23 = *a1;
      if ((v23 - 125) > 1)
      {
        v24 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v23) = v23 ^ 0x20;
        v24 = 1;
      }
      __src[v24] = v23;
      v25 = v24 + 1;
      v26 = a1[1];
      if ((v26 - 125) <= 1)
      {
        __src[v25] = 125;
        LODWORD(v25) = v24 | 2;
        LOBYTE(v26) = v26 ^ 0x20;
      }
      __src[v25] = v26;
      v27 = v25 + 1;
      v28 = a1[2];
      if ((v28 - 125) <= 1)
      {
        __src[v27] = 125;
        LOBYTE(v28) = v28 ^ 0x20;
        LODWORD(v27) = v25 + 2;
      }
      __src[v27] = v28;
      v29 = v27 + 1;
      v30 = a1[3];
      if ((v30 - 125) <= 1)
      {
        __src[v29] = 125;
        LODWORD(v29) = v27 + 2;
        LOBYTE(v30) = v30 ^ 0x20;
      }
      __src[v29] = v30;
      v31 = v29 + 1;
      v32 = a1[4];
      if ((v32 - 125) <= 1)
      {
        __src[v31] = 125;
        LOBYTE(v32) = v32 ^ 0x20;
        LODWORD(v31) = v29 + 2;
      }
      __src[v31] = v32;
      v33 = v31 + 1;
      v34 = a1[5];
      if ((v34 - 125) <= 1)
      {
        __src[v33] = 125;
        LODWORD(v33) = v31 + 2;
        LOBYTE(v34) = v34 ^ 0x20;
      }
      __src[v33] = v34;
      v35 = v33 + 1;
      v36 = a1[6];
      if ((v36 - 125) <= 1)
      {
        __src[v35] = 125;
        LOBYTE(v36) = v36 ^ 0x20;
        LODWORD(v35) = v33 + 2;
      }
      __src[v35] = v36;
      v37 = v35 + 1;
      v38 = a1[7];
      if ((v38 - 125) <= 1)
      {
        __src[v37] = 125;
        LODWORD(v37) = v35 + 2;
        LOBYTE(v38) = v38 ^ 0x20;
      }
      __src[v37] = v38;
      v39 = v37 + 1;
      v40 = a1[8];
      if ((v40 - 125) <= 1)
      {
        __src[v39] = 125;
        LOBYTE(v40) = v40 ^ 0x20;
        LODWORD(v39) = v37 + 2;
      }
      __src[v39] = v40;
      v41 = v39 + 1;
      v42 = a1[9];
      if ((v42 - 125) <= 1)
      {
        __src[v41] = 125;
        LODWORD(v41) = v39 + 2;
        LOBYTE(v42) = v42 ^ 0x20;
      }
      __src[v41] = v42;
      v43 = v41 + 1;
      v44 = a1[10];
      if ((v44 - 125) <= 1)
      {
        __src[v43] = 125;
        LOBYTE(v44) = v44 ^ 0x20;
        LODWORD(v43) = v41 + 2;
      }
      __src[v43] = v44;
      v45 = v43 + 1;
      v46 = a1[11];
      if ((v46 - 125) <= 1)
      {
        __src[v45] = 125;
        LODWORD(v45) = v43 + 2;
        LOBYTE(v46) = v46 ^ 0x20;
      }
      __src[v45] = v46;
      v47 = v45 + 1;
      v48 = a1[12];
      if ((v48 - 125) <= 1)
      {
        __src[v47] = 125;
        LOBYTE(v48) = v48 ^ 0x20;
        LODWORD(v47) = v45 + 2;
      }
      __src[v47] = v48;
      v49 = v47 + 1;
      v50 = a1[13];
      if ((v50 - 125) <= 1)
      {
        __src[v49] = 125;
        LODWORD(v49) = v47 + 2;
        LOBYTE(v50) = v50 ^ 0x20;
      }
      __src[v49] = v50;
      v51 = v49 + 1;
      v52 = a1[14];
      if ((v52 - 125) <= 1)
      {
        __src[v51] = 125;
        LOBYTE(v52) = v52 ^ 0x20;
        LODWORD(v51) = v49 + 2;
      }
      __src[v51] = v52;
      v53 = v51 + 1;
      v54 = a1[15];
      if ((v54 - 125) <= 1)
      {
        __src[v53] = 125;
        LODWORD(v53) = v51 + 2;
        LOBYTE(v54) = v54 ^ 0x20;
      }
      __src[v53] = v54;
      v55 = v53 + 1;
      v56 = a1[16];
      if ((v56 - 125) <= 1)
      {
        __src[v55] = 125;
        LOBYTE(v56) = v56 ^ 0x20;
        LODWORD(v55) = v53 + 2;
      }
      v57 = ~(v22 ^ BYTE1(v21));
      __src[v55] = v56;
      v58 = v55 + 1;
      v59 = a1[17];
      if ((v59 - 125) <= 1)
      {
        __src[v58] = 125;
        LOBYTE(v59) = v59 ^ 0x20;
        LODWORD(v58) = v55 + 2;
      }
      v60 = ((unsigned __int16)(v22 ^ ~(unsigned __int16)(v21 >> 8)) >> 8);
      __src[v58] = v59;
      v61 = v58 + 1;
      if ((v57 - 125) <= 1)
      {
        __src[v61] = 125;
        LOBYTE(v57) = v57 ^ 0x20;
        LODWORD(v61) = v58 + 2;
      }
      __src[v61] = v57;
      v62 = v61 + 1;
      if ((v60 - 125) <= 1)
      {
        __src[v62] = 125;
        LOBYTE(v60) = v60 ^ 0x20;
        LODWORD(v62) = v61 + 2;
      }
      __src[v62] = v60;
      memcpy(a1, __src, v62 + 1);
      result = (v62 + 2);
      a1[v62 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_CMD_RELEASE(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned __int16 v6;
  int v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  unsigned int v10;
  unsigned __int16 v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int __src;
  char v25;
  _BYTE v26[2043];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x33)
    return result;
  bzero(a1, a2);
  *(_DWORD *)a1 = 461643;
  a1[4] = 108;
  v5 = a1[5];
  v6 = crc_16_l_table[v5 ^ 0x3C];
  v7 = a1[6];
  v8 = crc_16_l_table[(v7 ^ v6) ^ 0x53];
  v9 = crc_16_l_table[(a1[7] ^ v8 ^ HIBYTE(v6))];
  v10 = crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))];
  v11 = crc_16_l_table[(a1[9] ^ v10 ^ HIBYTE(v9))];
  *((_WORD *)a1 + 5) = v11 ^ ~HIBYTE(crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))]);
  if (a2 < 24)
    return 0xFFFFFFFFLL;
  bzero(v26, 0x7FBuLL);
  __src = 461643;
  v25 = 108;
  if ((v5 - 125) <= 1)
  {
    v26[0] = 125;
    v12 = 6;
    v26[1] = v5 ^ 0x20;
    v13 = 7;
    if ((v7 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v12 = 5;
  v26[0] = v5;
  v13 = 6;
  if ((v7 - 125) <= 1)
  {
LABEL_9:
    *((_BYTE *)&__src + v13) = 125;
    LOBYTE(v7) = v7 ^ 0x20;
    LODWORD(v13) = v12 + 2;
  }
LABEL_10:
  *((_BYTE *)&__src + v13) = v7;
  v14 = v13 + 1;
  v15 = a1[7];
  if ((v15 - 125) <= 1)
  {
    *((_BYTE *)&__src + v14) = 125;
    LODWORD(v14) = v13 + 2;
    LOBYTE(v15) = v15 ^ 0x20;
  }
  *((_BYTE *)&__src + v14) = v15;
  v16 = v14 + 1;
  v17 = a1[8];
  if ((v17 - 125) <= 1)
  {
    *((_BYTE *)&__src + v16) = 125;
    LOBYTE(v17) = v17 ^ 0x20;
    LODWORD(v16) = v14 + 2;
  }
  v18 = ~(v11 ^ BYTE1(v10));
  *((_BYTE *)&__src + v16) = v17;
  v19 = v16 + 1;
  v20 = a1[9];
  if ((v20 - 125) <= 1)
  {
    *((_BYTE *)&__src + v19) = 125;
    LOBYTE(v20) = v20 ^ 0x20;
    LODWORD(v19) = v16 + 2;
  }
  v21 = ((unsigned __int16)(v11 ^ ~(unsigned __int16)(v10 >> 8)) >> 8);
  *((_BYTE *)&__src + v19) = v20;
  v22 = v19 + 1;
  if ((v18 - 125) <= 1)
  {
    *((_BYTE *)&__src + v22) = 125;
    LOBYTE(v18) = v18 ^ 0x20;
    LODWORD(v22) = v19 + 2;
  }
  *((_BYTE *)&__src + v22) = v18;
  v23 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    *((_BYTE *)&__src + v23) = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v23) = v22 + 2;
  }
  *((_BYTE *)&__src + v23) = v21;
  memcpy(a1, &__src, v23 + 1);
  result = (v23 + 2);
  a1[v23 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_PILOT_ACQ(char *a1, int a2, int a3, __int16 a4, int a5, int a6)
{
  uint64_t result;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned int v29;
  uint64_t v30;
  size_t v31;
  int v32;
  int v33;
  _BYTE __src[2048];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x23)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 113;
    *(_DWORD *)(a1 + 10) = a3;
    *((_WORD *)a1 + 7) = a4;
    *((_DWORD *)a1 + 4) = a5;
    *((_DWORD *)a1 + 5) = a6;
    v13 = crc_16_l_table[a1[6] ^ 0xACLL];
    v14 = crc_16_l_table[a1[7] ^ 0x6C ^ v13];
    v15 = crc_16_l_table[(a1[8] ^ v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[(a1[9] ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(a3 ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(BYTE1(a3) ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[(BYTE2(a3) ^ v18 ^ HIBYTE(v17))];
    v20 = crc_16_l_table[(HIBYTE(a3) ^ v19 ^ HIBYTE(v18))];
    v21 = crc_16_l_table[(a4 ^ v20 ^ HIBYTE(v19))];
    v22 = crc_16_l_table[(HIBYTE(a4) ^ v21 ^ HIBYTE(v20))];
    v23 = crc_16_l_table[(a5 ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(a1[17] ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a1[18] ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a1[19] ^ v25 ^ HIBYTE(v24))];
    v27 = crc_16_l_table[(a6 ^ v26 ^ HIBYTE(v25))];
    v28 = crc_16_l_table[(a1[21] ^ v27 ^ HIBYTE(v26))];
    v29 = crc_16_l_table[(a1[22] ^ v28 ^ HIBYTE(v27))];
    *((_WORD *)a1 + 12) = crc_16_l_table[(a1[23] ^ v29 ^ HIBYTE(v28))] ^ ~(unsigned __int16)(v29 >> 8);
    if (a2 >= 52)
    {
      bzero(__src, 0x800uLL);
      v30 = 0;
      LODWORD(v31) = 0;
      do
      {
        while (1)
        {
          v33 = a1[v30];
          if ((v33 - 125) > 1)
            break;
          v32 = v31 + 1;
          __src[(int)v31] = 125;
          __src[(int)v31 + 1] = v33 ^ 0x20;
          v31 = (int)v31 + 1 + 1;
          if (++v30 == 26)
            goto LABEL_9;
        }
        v32 = v31;
        __src[(int)v31] = v33;
        v31 = (int)v31 + 1;
        ++v30;
      }
      while (v30 != 26);
LABEL_9:
      memcpy(a1, __src, v31);
      result = (v32 + 2);
      a1[v31] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_SYS_TIME_ACQ(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  unsigned __int16 v5;
  unsigned int v6;
  unsigned __int16 v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int __src;
  __int16 v19;
  char v20;
  char v21[2041];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 114;
    a1[6] = 10;
    v5 = crc_16_l_table[a1[7] ^ 0x34];
    v6 = crc_16_l_table[a1[8] ^ 0x2F ^ v5];
    v7 = crc_16_l_table[(a1[9] ^ v6 ^ HIBYTE(v5))];
    *((_WORD *)a1 + 5) = v7 ^ ~HIBYTE(crc_16_l_table[a1[8] ^ 0x2F ^ v5]);
    if (a2 >= 24)
    {
      bzero(v21, 0x7F9uLL);
      __src = 527179;
      v19 = 114;
      v20 = 10;
      v8 = a1[7];
      if ((v8 - 125) > 1)
      {
        v9 = 7;
      }
      else
      {
        v21[0] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        v9 = 8;
      }
      *((_BYTE *)&__src + v9) = v8;
      v10 = v9 + 1;
      v11 = a1[8];
      if ((v11 - 125) <= 1)
      {
        *((_BYTE *)&__src + v10) = 125;
        LODWORD(v10) = v9 + 2;
        LOBYTE(v11) = v11 ^ 0x20;
      }
      v12 = ~(v7 ^ BYTE1(v6));
      *((_BYTE *)&__src + v10) = v11;
      v13 = v10 + 1;
      v14 = a1[9];
      if ((v14 - 125) <= 1)
      {
        *((_BYTE *)&__src + v13) = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v13) = v10 + 2;
      }
      v15 = ((unsigned __int16)(v7 ^ ~(unsigned __int16)(v6 >> 8)) >> 8);
      *((_BYTE *)&__src + v13) = v14;
      v16 = v13 + 1;
      if ((v12 - 125) <= 1)
      {
        *((_BYTE *)&__src + v16) = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v16) = v13 + 2;
      }
      *((_BYTE *)&__src + v16) = v12;
      v17 = v16 + 1;
      if ((v15 - 125) <= 1)
      {
        *((_BYTE *)&__src + v17) = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v17) = v16 + 2;
      }
      *((_BYTE *)&__src + v17) = v15;
      memcpy(a1, &__src, v17 + 1);
      result = (v17 + 2);
      a1[v17 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_DEMOD_CC_MAC_FTC(unsigned __int8 *a1, int a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8)
{
  uint64_t result;
  uint64_t v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  int v60;
  char v61;
  uint64_t v62;
  uint64_t v63;
  _BYTE __src[2048];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1B)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 115;
    a1[10] = a3;
    a1[11] = a4;
    a1[12] = a5;
    a1[13] = a6;
    a1[14] = a7;
    a1[15] = a8;
    v17 = a1[6];
    v18 = crc_16_l_table[v17 ^ 0x1C];
    v19 = crc_16_l_table[a1[7] ^ 0x5F ^ v18];
    v20 = crc_16_l_table[(a1[8] ^ v19 ^ HIBYTE(v18))];
    v21 = crc_16_l_table[(a1[9] ^ v20 ^ HIBYTE(v19))];
    v22 = crc_16_l_table[(a3 ^ v21 ^ HIBYTE(v20))];
    v23 = crc_16_l_table[(a4 ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(a5 ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a6 ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a7 ^ v25 ^ HIBYTE(v24))];
    v27 = crc_16_l_table[(v26 ^ HIBYTE(v25) ^ a8)];
    v28 = v27 ^ ~(v26 >> 8);
    *((_WORD *)a1 + 8) = v27 ^ ~(unsigned __int16)(v26 >> 8);
    if (a2 >= 36)
    {
      bzero(__src, 0x800uLL);
      v29 = *a1;
      if ((v29 - 125) > 1)
      {
        v30 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v29) = v29 ^ 0x20;
        v30 = 1;
      }
      __src[v30] = v29;
      v31 = v30 + 1;
      v32 = a1[1];
      if ((v32 - 125) <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v30 | 2;
        LOBYTE(v32) = v32 ^ 0x20;
      }
      __src[v31] = v32;
      v33 = v31 + 1;
      v34 = a1[2];
      if ((v34 - 125) <= 1)
      {
        __src[v33] = 125;
        LOBYTE(v34) = v34 ^ 0x20;
        LODWORD(v33) = v31 + 2;
      }
      __src[v33] = v34;
      v35 = v33 + 1;
      v36 = a1[3];
      if ((v36 - 125) <= 1)
      {
        __src[v35] = 125;
        LODWORD(v35) = v33 + 2;
        LOBYTE(v36) = v36 ^ 0x20;
      }
      __src[v35] = v36;
      v37 = v35 + 1;
      v38 = a1[4];
      if ((v38 - 125) <= 1)
      {
        __src[v37] = 125;
        LOBYTE(v38) = v38 ^ 0x20;
        LODWORD(v37) = v35 + 2;
      }
      __src[v37] = v38;
      v39 = v37 + 1;
      v40 = a1[5];
      if ((v40 - 125) <= 1)
      {
        __src[v39] = 125;
        LODWORD(v39) = v37 + 2;
        LOBYTE(v40) = v40 ^ 0x20;
      }
      __src[v39] = v40;
      v41 = v39 + 1;
      if ((v17 - 125) <= 1)
      {
        __src[v41] = 125;
        LOBYTE(v17) = v17 ^ 0x20;
        LODWORD(v41) = v39 + 2;
      }
      __src[v41] = v17;
      v42 = v41 + 1;
      v43 = a1[7];
      if ((v43 - 125) <= 1)
      {
        __src[v42] = 125;
        LODWORD(v42) = v41 + 2;
        LOBYTE(v43) = v43 ^ 0x20;
      }
      __src[v42] = v43;
      v44 = v42 + 1;
      v45 = a1[8];
      if ((v45 - 125) <= 1)
      {
        __src[v44] = 125;
        LOBYTE(v45) = v45 ^ 0x20;
        LODWORD(v44) = v42 + 2;
      }
      __src[v44] = v45;
      v46 = v44 + 1;
      v47 = a1[9];
      if ((v47 - 125) <= 1)
      {
        __src[v46] = 125;
        LODWORD(v46) = v44 + 2;
        LOBYTE(v47) = v47 ^ 0x20;
      }
      __src[v46] = v47;
      v48 = v46 + 1;
      v49 = a1[10];
      if ((v49 - 125) <= 1)
      {
        __src[v48] = 125;
        LOBYTE(v49) = v49 ^ 0x20;
        LODWORD(v48) = v46 + 2;
      }
      __src[v48] = v49;
      v50 = v48 + 1;
      v51 = a1[11];
      if ((v51 - 125) <= 1)
      {
        __src[v50] = 125;
        LODWORD(v50) = v48 + 2;
        LOBYTE(v51) = v51 ^ 0x20;
      }
      __src[v50] = v51;
      v52 = v50 + 1;
      v53 = a1[12];
      if ((v53 - 125) <= 1)
      {
        __src[v52] = 125;
        LOBYTE(v53) = v53 ^ 0x20;
        LODWORD(v52) = v50 + 2;
      }
      __src[v52] = v53;
      v54 = v52 + 1;
      v55 = a1[13];
      if ((v55 - 125) <= 1)
      {
        __src[v54] = 125;
        LODWORD(v54) = v52 + 2;
        LOBYTE(v55) = v55 ^ 0x20;
      }
      __src[v54] = v55;
      v56 = v54 + 1;
      v57 = a1[14];
      if ((v57 - 125) <= 1)
      {
        __src[v56] = 125;
        LOBYTE(v57) = v57 ^ 0x20;
        LODWORD(v56) = v54 + 2;
      }
      v58 = ~(v27 ^ BYTE1(v26));
      __src[v56] = v57;
      v59 = v56 + 1;
      v60 = a1[15];
      if ((v60 - 125) <= 1)
      {
        __src[v59] = 125;
        LOBYTE(v60) = v60 ^ 0x20;
        LODWORD(v59) = v56 + 2;
      }
      v61 = (unsigned __int16)(v27 ^ ~(unsigned __int16)(v26 >> 8)) >> 8;
      __src[v59] = v60;
      v62 = v59 + 1;
      if ((v58 - 125) <= 1)
      {
        __src[v62] = 125;
        LOBYTE(v58) = v58 ^ 0x20;
        LODWORD(v62) = v59 + 2;
      }
      __src[v62] = v58;
      v63 = v62 + 1;
      if (BYTE1(v28) - 125 <= 1)
      {
        __src[v63] = 125;
        v61 = BYTE1(v28) ^ 0x20;
        LODWORD(v63) = v62 + 2;
      }
      __src[v63] = v61;
      memcpy(a1, __src, v63 + 1);
      result = (v63 + 2);
      a1[v63 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_MOD_ACC(char *a1, int a2, int a3, int a4, int a5, int a6, int a7, char a8, char a9, char a10, char a11, char a12, char a13)
{
  uint64_t result;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  unsigned __int16 v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  unsigned __int16 v37;
  unsigned __int16 v38;
  unsigned __int16 v39;
  unsigned __int16 v40;
  unsigned __int16 v41;
  unsigned __int16 v42;
  unsigned __int16 v43;
  unsigned __int16 v44;
  unsigned __int16 v45;
  unsigned __int16 v46;
  unsigned __int16 v47;
  unsigned __int16 v48;
  unsigned int v49;
  uint64_t v50;
  size_t v51;
  int v52;
  int v53;
  _BYTE __src[2048];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x2F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 116;
    *(_DWORD *)(a1 + 10) = a3;
    *(_DWORD *)(a1 + 14) = a4;
    *(_DWORD *)(a1 + 18) = a5;
    *(_DWORD *)(a1 + 22) = a6;
    *(_DWORD *)(a1 + 26) = a7;
    a1[30] = a8;
    a1[31] = a9;
    a1[32] = a10;
    a1[33] = a11;
    a1[34] = a12;
    a1[35] = a13;
    v21 = crc_16_l_table[a1[6] ^ 0x14];
    v22 = crc_16_l_table[a1[7] ^ 0x12 ^ v21];
    v23 = crc_16_l_table[(a1[8] ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(a1[9] ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a1[10] ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a1[11] ^ v25 ^ HIBYTE(v24))];
    v27 = crc_16_l_table[(a1[12] ^ v26 ^ HIBYTE(v25))];
    v28 = crc_16_l_table[(a1[13] ^ v27 ^ HIBYTE(v26))];
    v29 = crc_16_l_table[(a1[14] ^ v28 ^ HIBYTE(v27))];
    v30 = crc_16_l_table[(a1[15] ^ v29 ^ HIBYTE(v28))];
    v31 = crc_16_l_table[(a1[16] ^ v30 ^ HIBYTE(v29))];
    v32 = crc_16_l_table[(HIBYTE(a4) ^ v31 ^ HIBYTE(v30))];
    v33 = crc_16_l_table[(a5 ^ v32 ^ HIBYTE(v31))];
    v34 = crc_16_l_table[(BYTE1(a5) ^ v33 ^ HIBYTE(v32))];
    v35 = crc_16_l_table[(BYTE2(a5) ^ v34 ^ HIBYTE(v33))];
    v36 = crc_16_l_table[(HIBYTE(a5) ^ v35 ^ HIBYTE(v34))];
    v37 = crc_16_l_table[(a6 ^ v36 ^ HIBYTE(v35))];
    v38 = crc_16_l_table[(BYTE1(a6) ^ v37 ^ HIBYTE(v36))];
    v39 = crc_16_l_table[(BYTE2(a6) ^ v38 ^ HIBYTE(v37))];
    v40 = crc_16_l_table[(HIBYTE(a6) ^ v39 ^ HIBYTE(v38))];
    v41 = crc_16_l_table[(a7 ^ v40 ^ HIBYTE(v39))];
    v42 = crc_16_l_table[(BYTE1(a7) ^ v41 ^ HIBYTE(v40))];
    v43 = crc_16_l_table[(BYTE2(a7) ^ v42 ^ HIBYTE(v41))];
    v44 = crc_16_l_table[(HIBYTE(a7) ^ v43 ^ HIBYTE(v42))];
    v45 = crc_16_l_table[(a8 ^ v44 ^ HIBYTE(v43))];
    v46 = crc_16_l_table[(a9 ^ v45 ^ HIBYTE(v44))];
    v47 = crc_16_l_table[(a10 ^ v46 ^ HIBYTE(v45))];
    v48 = crc_16_l_table[(a11 ^ v47 ^ HIBYTE(v46))];
    v49 = crc_16_l_table[(a12 ^ v48 ^ HIBYTE(v47))];
    *((_WORD *)a1 + 18) = crc_16_l_table[(v49 ^ HIBYTE(v48) ^ a13)] ^ ~(unsigned __int16)(v49 >> 8);
    if (a2 >= 76)
    {
      bzero(__src, 0x800uLL);
      v50 = 0;
      LODWORD(v51) = 0;
      do
      {
        while (1)
        {
          v53 = a1[v50];
          if ((v53 - 125) > 1)
            break;
          v52 = v51 + 1;
          __src[(int)v51] = 125;
          __src[(int)v51 + 1] = v53 ^ 0x20;
          v51 = (int)v51 + 1 + 1;
          if (++v50 == 38)
            goto LABEL_9;
        }
        v52 = v51;
        __src[(int)v51] = v53;
        v51 = (int)v51 + 1;
        ++v50;
      }
      while (v50 != 38);
LABEL_9:
      memcpy(a1, __src, v51);
      result = (v52 + 2);
      a1[v51] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_REV_A_CONF_MAC_FOR_FWD_CC_MAC_FTC(unsigned __int8 *a1, int a2, int a3, int a4)
{
  uint64_t result;
  uint64_t v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  int __src;
  __int16 v31;
  char v32[2042];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1B)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 124;
    a1[10] = a3;
    a1[11] = a4;
    v9 = a1[6];
    v10 = crc_16_l_table[v9 ^ 0xD4];
    v11 = crc_16_l_table[a1[7] ^ 0xDC ^ v10];
    v12 = crc_16_l_table[(a1[8] ^ v11 ^ HIBYTE(v10))];
    v13 = crc_16_l_table[(a1[9] ^ v12 ^ HIBYTE(v11))];
    v14 = crc_16_l_table[(a3 ^ v13 ^ HIBYTE(v12))];
    v15 = crc_16_l_table[(v14 ^ HIBYTE(v13)) ^ a4];
    v16 = v15 ^ ~(v14 >> 8);
    *((_WORD *)a1 + 6) = v15 ^ ~HIBYTE(crc_16_l_table[(a3 ^ v13 ^ HIBYTE(v12))]);
    if (a2 >= 28)
    {
      bzero(v32, 0x7FAuLL);
      __src = 527179;
      v31 = 124;
      if ((v9 - 125) > 1)
      {
        v17 = 6;
      }
      else
      {
        v32[0] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        v17 = 7;
      }
      *((_BYTE *)&__src + v17) = v9;
      v18 = v17 + 1;
      v19 = a1[7];
      if ((v19 - 125) <= 1)
      {
        *((_BYTE *)&__src + v18) = 125;
        LODWORD(v18) = v17 + 2;
        LOBYTE(v19) = v19 ^ 0x20;
      }
      *((_BYTE *)&__src + v18) = v19;
      v20 = v18 + 1;
      v21 = a1[8];
      if ((v21 - 125) <= 1)
      {
        *((_BYTE *)&__src + v20) = 125;
        LOBYTE(v21) = v21 ^ 0x20;
        LODWORD(v20) = v18 + 2;
      }
      *((_BYTE *)&__src + v20) = v21;
      v22 = v20 + 1;
      v23 = a1[9];
      if ((v23 - 125) <= 1)
      {
        *((_BYTE *)&__src + v22) = 125;
        LODWORD(v22) = v20 + 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      *((_BYTE *)&__src + v22) = v23;
      v24 = v22 + 1;
      if ((a3 - 125) <= 1)
      {
        *((_BYTE *)&__src + v24) = 125;
        LOBYTE(a3) = a3 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      v25 = ~(v15 ^ BYTE1(v14));
      *((_BYTE *)&__src + v24) = a3;
      v26 = v24 + 1;
      if ((a4 - 125) <= 1)
      {
        *((_BYTE *)&__src + v26) = 125;
        LOBYTE(a4) = a4 ^ 0x20;
        LODWORD(v26) = v24 + 2;
      }
      v27 = (unsigned __int16)(v15 ^ ~(unsigned __int16)(v14 >> 8)) >> 8;
      *((_BYTE *)&__src + v26) = a4;
      v28 = v26 + 1;
      if ((v25 - 125) <= 1)
      {
        *((_BYTE *)&__src + v28) = 125;
        LODWORD(v28) = v26 + 2;
        LOBYTE(v25) = v25 ^ 0x20;
      }
      *((_BYTE *)&__src + v28) = v25;
      v29 = v28 + 1;
      if (BYTE1(v16) - 125 <= 1)
      {
        *((_BYTE *)&__src + v29) = 125;
        v27 = BYTE1(v16) ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      *((_BYTE *)&__src + v29) = v27;
      memcpy(a1, &__src, v29 + 1);
      result = (v29 + 2);
      a1[v29 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_REV_A_MOD_ACC(char *a1, int a2, int a3, int a4, int a5, int a6, int a7, char a8, char a9, char a10, char a11, char a12, char a13, char a14, char a15, char a16, char a17, char a18)
{
  uint64_t result;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  unsigned __int16 v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  unsigned __int16 v37;
  unsigned __int16 v38;
  unsigned __int16 v39;
  unsigned __int16 v40;
  unsigned __int16 v41;
  unsigned __int16 v42;
  unsigned __int16 v43;
  unsigned __int16 v44;
  unsigned __int16 v45;
  unsigned __int16 v46;
  unsigned __int16 v47;
  unsigned __int16 v48;
  unsigned __int16 v49;
  unsigned __int16 v50;
  unsigned __int16 v51;
  unsigned __int16 v52;
  unsigned __int16 v53;
  unsigned __int16 v54;
  unsigned __int16 v55;
  unsigned __int16 v56;
  unsigned __int16 v57;
  unsigned __int16 v58;
  unsigned __int16 v59;
  unsigned __int16 v60;
  unsigned __int16 v61;
  unsigned __int16 v62;
  unsigned __int16 v63;
  unsigned __int16 v64;
  unsigned int v65;
  uint64_t v66;
  size_t v67;
  int v68;
  int v69;
  _BYTE __src[2048];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x35)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 125;
    *(_DWORD *)(a1 + 10) = a3;
    *(_DWORD *)(a1 + 14) = a4;
    *(_DWORD *)(a1 + 18) = a5;
    *(_DWORD *)(a1 + 22) = a6;
    *(_DWORD *)(a1 + 26) = a7;
    a1[30] = a8;
    a1[31] = a9;
    a1[32] = a10;
    a1[33] = a11;
    a1[34] = a12;
    a1[35] = a13;
    a1[36] = a14;
    a1[37] = a15;
    a1[38] = a16;
    a1[39] = a17;
    a1[40] = a18;
    v26 = crc_16_l_table[~*a1];
    v27 = crc_16_l_table[(a1[1] ^ ~(_BYTE)v26)];
    v28 = crc_16_l_table[(a1[2] ^ v27 ^ HIBYTE(v26))];
    v29 = crc_16_l_table[(a1[3] ^ v28 ^ HIBYTE(v27))];
    v30 = crc_16_l_table[(a1[4] ^ v29 ^ HIBYTE(v28))];
    v31 = crc_16_l_table[(a1[5] ^ v30 ^ HIBYTE(v29))];
    v32 = crc_16_l_table[(a1[6] ^ v31 ^ HIBYTE(v30))];
    v33 = crc_16_l_table[(a1[7] ^ v32 ^ HIBYTE(v31))];
    v34 = crc_16_l_table[(a1[8] ^ v33 ^ HIBYTE(v32))];
    v35 = crc_16_l_table[(a1[9] ^ v34 ^ HIBYTE(v33))];
    v36 = crc_16_l_table[(a1[10] ^ v35 ^ HIBYTE(v34))];
    v37 = crc_16_l_table[(a1[11] ^ v36 ^ HIBYTE(v35))];
    v38 = crc_16_l_table[(a1[12] ^ v37 ^ HIBYTE(v36))];
    v39 = crc_16_l_table[(a1[13] ^ v38 ^ HIBYTE(v37))];
    v40 = crc_16_l_table[(a1[14] ^ v39 ^ HIBYTE(v38))];
    v41 = crc_16_l_table[(a1[15] ^ v40 ^ HIBYTE(v39))];
    v42 = crc_16_l_table[(a1[16] ^ v41 ^ HIBYTE(v40))];
    v43 = crc_16_l_table[(a1[17] ^ v42 ^ HIBYTE(v41))];
    v44 = crc_16_l_table[(a1[18] ^ v43 ^ HIBYTE(v42))];
    v45 = crc_16_l_table[(a1[19] ^ v44 ^ HIBYTE(v43))];
    v46 = crc_16_l_table[(a1[20] ^ v45 ^ HIBYTE(v44))];
    v47 = crc_16_l_table[(a1[21] ^ v46 ^ HIBYTE(v45))];
    v48 = crc_16_l_table[(a6 ^ v47 ^ HIBYTE(v46))];
    v49 = crc_16_l_table[(BYTE1(a6) ^ v48 ^ HIBYTE(v47))];
    v50 = crc_16_l_table[(BYTE2(a6) ^ v49 ^ HIBYTE(v48))];
    v51 = crc_16_l_table[(HIBYTE(a6) ^ v50 ^ HIBYTE(v49))];
    v52 = crc_16_l_table[(a7 ^ v51 ^ HIBYTE(v50))];
    v53 = crc_16_l_table[(BYTE1(a7) ^ v52 ^ HIBYTE(v51))];
    v54 = crc_16_l_table[(BYTE2(a7) ^ v53 ^ HIBYTE(v52))];
    v55 = crc_16_l_table[(HIBYTE(a7) ^ v54 ^ HIBYTE(v53))];
    v56 = crc_16_l_table[(a8 ^ v55 ^ HIBYTE(v54))];
    v57 = crc_16_l_table[(a9 ^ v56 ^ HIBYTE(v55))];
    v58 = crc_16_l_table[(a10 ^ v57 ^ HIBYTE(v56))];
    v59 = crc_16_l_table[(a11 ^ v58 ^ HIBYTE(v57))];
    v60 = crc_16_l_table[(a12 ^ v59 ^ HIBYTE(v58))];
    v61 = crc_16_l_table[(a13 ^ v60 ^ HIBYTE(v59))];
    v62 = crc_16_l_table[(a14 ^ v61 ^ HIBYTE(v60))];
    v63 = crc_16_l_table[(a15 ^ v62 ^ HIBYTE(v61))];
    v64 = crc_16_l_table[(a16 ^ v63 ^ HIBYTE(v62))];
    v65 = crc_16_l_table[(a17 ^ v64 ^ HIBYTE(v63))];
    *(_WORD *)(a1 + 41) = crc_16_l_table[(v65 ^ HIBYTE(v64) ^ a18)] ^ ~(unsigned __int16)(v65 >> 8);
    if (a2 >= 86)
    {
      bzero(__src, 0x800uLL);
      v66 = 0;
      LODWORD(v67) = 0;
      do
      {
        while (1)
        {
          v69 = a1[v66];
          if ((v69 - 125) > 1)
            break;
          v68 = v67 + 1;
          __src[(int)v67] = 125;
          __src[(int)v67 + 1] = v69 ^ 0x20;
          v67 = (int)v67 + 1 + 1;
          if (++v66 == 43)
            goto LABEL_9;
        }
        v68 = v67;
        __src[(int)v67] = v69;
        v67 = (int)v67 + 1;
        ++v66;
      }
      while (v66 != 43);
LABEL_9:
      memcpy(a1, __src, v67);
      result = (v68 + 2);
      a1[v67] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_REV_A_DEMOD_FWD_WITH_NO_REV(unsigned __int8 *a1, int a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, char a9, char a10, char a11)
{
  uint64_t result;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  uint64_t v31;
  unsigned int v32;
  unsigned __int16 v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  int v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  _BYTE __src[2048];
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x35)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 127;
    a1[10] = a3;
    a1[11] = a4;
    a1[12] = a5;
    a1[13] = a6;
    a1[14] = a7;
    a1[15] = a8;
    a1[16] = a9;
    a1[17] = a10;
    a1[18] = a11;
    v20 = crc_16_l_table[a1[6] ^ 0xBCLL];
    v21 = crc_16_l_table[a1[7] ^ 0xF6 ^ v20];
    v22 = crc_16_l_table[(a1[8] ^ v21 ^ HIBYTE(v20))];
    v23 = crc_16_l_table[(a1[9] ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(a3 ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a4 ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a5 ^ v25 ^ HIBYTE(v24))];
    v27 = crc_16_l_table[(a6 ^ v26 ^ HIBYTE(v25))];
    v28 = crc_16_l_table[(a7 ^ v27 ^ HIBYTE(v26))];
    v29 = crc_16_l_table[(a8 ^ v28 ^ HIBYTE(v27))];
    v30 = crc_16_l_table[(a9 ^ v29 ^ HIBYTE(v28))];
    v31 = (a10 ^ v30 ^ HIBYTE(v29));
    v32 = crc_16_l_table[v31];
    v33 = crc_16_l_table[(v32 ^ HIBYTE(v30) ^ a11)];
    *(_WORD *)(a1 + 19) = v33 ^ ~HIBYTE(crc_16_l_table[v31]);
    if (a2 >= 42)
    {
      bzero(__src, 0x800uLL);
      v34 = *a1;
      if ((v34 - 125) > 1)
      {
        v35 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v34) = v34 ^ 0x20;
        v35 = 1;
      }
      __src[v35] = v34;
      v36 = v35 + 1;
      v37 = a1[1];
      if ((v37 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v35 | 2;
        LOBYTE(v37) = v37 ^ 0x20;
      }
      __src[v36] = v37;
      v38 = v36 + 1;
      v39 = a1[2];
      if ((v39 - 125) <= 1)
      {
        __src[v38] = 125;
        LOBYTE(v39) = v39 ^ 0x20;
        LODWORD(v38) = v36 + 2;
      }
      __src[v38] = v39;
      v40 = v38 + 1;
      v41 = a1[3];
      if ((v41 - 125) <= 1)
      {
        __src[v40] = 125;
        LODWORD(v40) = v38 + 2;
        LOBYTE(v41) = v41 ^ 0x20;
      }
      __src[v40] = v41;
      v42 = v40 + 1;
      v43 = a1[4];
      if ((v43 - 125) <= 1)
      {
        __src[v42] = 125;
        LOBYTE(v43) = v43 ^ 0x20;
        LODWORD(v42) = v40 + 2;
      }
      __src[v42] = v43;
      v44 = v42 + 1;
      v45 = a1[5];
      if ((v45 - 125) <= 1)
      {
        __src[v44] = 125;
        LODWORD(v44) = v42 + 2;
        LOBYTE(v45) = v45 ^ 0x20;
      }
      __src[v44] = v45;
      v46 = v44 + 1;
      v47 = a1[6];
      if ((v47 - 125) <= 1)
      {
        __src[v46] = 125;
        LOBYTE(v47) = v47 ^ 0x20;
        LODWORD(v46) = v44 + 2;
      }
      __src[v46] = v47;
      v48 = v46 + 1;
      v49 = a1[7];
      if ((v49 - 125) <= 1)
      {
        __src[v48] = 125;
        LODWORD(v48) = v46 + 2;
        LOBYTE(v49) = v49 ^ 0x20;
      }
      __src[v48] = v49;
      v50 = v48 + 1;
      v51 = a1[8];
      if ((v51 - 125) <= 1)
      {
        __src[v50] = 125;
        LOBYTE(v51) = v51 ^ 0x20;
        LODWORD(v50) = v48 + 2;
      }
      __src[v50] = v51;
      v52 = v50 + 1;
      v53 = a1[9];
      if ((v53 - 125) <= 1)
      {
        __src[v52] = 125;
        LODWORD(v52) = v50 + 2;
        LOBYTE(v53) = v53 ^ 0x20;
      }
      __src[v52] = v53;
      v54 = v52 + 1;
      v55 = a1[10];
      if ((v55 - 125) <= 1)
      {
        __src[v54] = 125;
        LOBYTE(v55) = v55 ^ 0x20;
        LODWORD(v54) = v52 + 2;
      }
      __src[v54] = v55;
      v56 = v54 + 1;
      v57 = a1[11];
      if ((v57 - 125) <= 1)
      {
        __src[v56] = 125;
        LODWORD(v56) = v54 + 2;
        LOBYTE(v57) = v57 ^ 0x20;
      }
      __src[v56] = v57;
      v58 = v56 + 1;
      v59 = a1[12];
      if ((v59 - 125) <= 1)
      {
        __src[v58] = 125;
        LOBYTE(v59) = v59 ^ 0x20;
        LODWORD(v58) = v56 + 2;
      }
      __src[v58] = v59;
      v60 = v58 + 1;
      v61 = a1[13];
      if ((v61 - 125) <= 1)
      {
        __src[v60] = 125;
        LODWORD(v60) = v58 + 2;
        LOBYTE(v61) = v61 ^ 0x20;
      }
      __src[v60] = v61;
      v62 = v60 + 1;
      v63 = a1[14];
      if ((v63 - 125) <= 1)
      {
        __src[v62] = 125;
        LOBYTE(v63) = v63 ^ 0x20;
        LODWORD(v62) = v60 + 2;
      }
      __src[v62] = v63;
      v64 = v62 + 1;
      v65 = a1[15];
      if ((v65 - 125) <= 1)
      {
        __src[v64] = 125;
        LODWORD(v64) = v62 + 2;
        LOBYTE(v65) = v65 ^ 0x20;
      }
      __src[v64] = v65;
      v66 = v64 + 1;
      v67 = a1[16];
      if ((v67 - 125) <= 1)
      {
        __src[v66] = 125;
        LODWORD(v66) = v64 + 2;
        LOBYTE(v67) = v67 ^ 0x20;
      }
      __src[v66] = v67;
      v68 = v66 + 1;
      v69 = a1[17];
      if ((v69 - 125) <= 1)
      {
        __src[v68] = 125;
        LOBYTE(v69) = v69 ^ 0x20;
        LODWORD(v68) = v66 + 2;
      }
      v70 = ~(v33 ^ BYTE1(v32));
      __src[v68] = v69;
      v71 = v68 + 1;
      v72 = a1[18];
      if ((v72 - 125) <= 1)
      {
        __src[v71] = 125;
        LOBYTE(v72) = v72 ^ 0x20;
        LODWORD(v71) = v68 + 2;
      }
      v73 = ((unsigned __int16)(v33 ^ ~(unsigned __int16)(v32 >> 8)) >> 8);
      __src[v71] = v72;
      v74 = v71 + 1;
      if ((v70 - 125) <= 1)
      {
        __src[v74] = 125;
        LOBYTE(v70) = v70 ^ 0x20;
        LODWORD(v74) = v71 + 2;
      }
      __src[v74] = v70;
      v75 = v74 + 1;
      if ((v73 - 125) <= 1)
      {
        __src[v75] = 125;
        LOBYTE(v73) = v73 ^ 0x20;
        LODWORD(v75) = v74 + 2;
      }
      __src[v75] = v73;
      memcpy(a1, __src, v75 + 1);
      result = (v75 + 2);
      a1[v75 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_DEMOD_FWD_WITH_NO_REV(unsigned __int8 *a1, int a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, char a9, char a10)
{
  uint64_t result;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned int v29;
  unsigned __int16 v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  int v64;
  int v65;
  uint64_t v66;
  int v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  _BYTE v71[2048];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x35)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 122;
    a1[10] = a3;
    a1[11] = a4;
    a1[12] = a5;
    a1[13] = a6;
    a1[14] = a7;
    a1[15] = a8;
    a1[16] = a9;
    a1[17] = a10;
    v19 = crc_16_l_table[a1[6] ^ 4];
    v20 = crc_16_l_table[(a1[7] ^ v19) ^ 0x88];
    v21 = crc_16_l_table[(a1[8] ^ v20 ^ HIBYTE(v19))];
    v22 = crc_16_l_table[(a1[9] ^ v21 ^ HIBYTE(v20))];
    v23 = crc_16_l_table[(a3 ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(a4 ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a5 ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a6 ^ v25 ^ HIBYTE(v24))];
    v27 = crc_16_l_table[(a7 ^ v26 ^ HIBYTE(v25))];
    v28 = crc_16_l_table[(a8 ^ v27 ^ HIBYTE(v26))];
    v29 = crc_16_l_table[(a9 ^ v28 ^ HIBYTE(v27))];
    v30 = crc_16_l_table[(v29 ^ HIBYTE(v28) ^ a10)];
    *((_WORD *)a1 + 9) = v30 ^ ~HIBYTE(crc_16_l_table[(a9 ^ v28 ^ HIBYTE(v27))]);
    if (a2 >= 40)
    {
      bzero(v71, 0x800uLL);
      v31 = *a1;
      if ((v31 - 125) > 1)
      {
        v32 = 0;
      }
      else
      {
        v71[0] = 125;
        LOBYTE(v31) = v31 ^ 0x20;
        v32 = 1;
      }
      v71[v32] = v31;
      v33 = v32 + 1;
      v34 = a1[1];
      if ((v34 - 125) <= 1)
      {
        v71[v33] = 125;
        LODWORD(v33) = v32 | 2;
        LOBYTE(v34) = v34 ^ 0x20;
      }
      v71[v33] = v34;
      v35 = v33 + 1;
      v36 = a1[2];
      if ((v36 - 125) <= 1)
      {
        v71[v35] = 125;
        LOBYTE(v36) = v36 ^ 0x20;
        LODWORD(v35) = v33 + 2;
      }
      v71[v35] = v36;
      v37 = v35 + 1;
      v38 = a1[3];
      if ((v38 - 125) <= 1)
      {
        v71[v37] = 125;
        LODWORD(v37) = v35 + 2;
        LOBYTE(v38) = v38 ^ 0x20;
      }
      v71[v37] = v38;
      v39 = v37 + 1;
      v40 = a1[4];
      if ((v40 - 125) <= 1)
      {
        v71[v39] = 125;
        LOBYTE(v40) = v40 ^ 0x20;
        LODWORD(v39) = v37 + 2;
      }
      v71[v39] = v40;
      v41 = v39 + 1;
      v42 = a1[5];
      if ((v42 - 125) <= 1)
      {
        v71[v41] = 125;
        LODWORD(v41) = v39 + 2;
        LOBYTE(v42) = v42 ^ 0x20;
      }
      v71[v41] = v42;
      v43 = v41 + 1;
      v44 = a1[6];
      if ((v44 - 125) <= 1)
      {
        v71[v43] = 125;
        LOBYTE(v44) = v44 ^ 0x20;
        LODWORD(v43) = v41 + 2;
      }
      v71[v43] = v44;
      v45 = v43 + 1;
      v46 = a1[7];
      if ((v46 - 125) <= 1)
      {
        v71[v45] = 125;
        LODWORD(v45) = v43 + 2;
        LOBYTE(v46) = v46 ^ 0x20;
      }
      v71[v45] = v46;
      v47 = v45 + 1;
      v48 = a1[8];
      if ((v48 - 125) <= 1)
      {
        v71[v47] = 125;
        LOBYTE(v48) = v48 ^ 0x20;
        LODWORD(v47) = v45 + 2;
      }
      v71[v47] = v48;
      v49 = v47 + 1;
      v50 = a1[9];
      if ((v50 - 125) <= 1)
      {
        v71[v49] = 125;
        LODWORD(v49) = v47 + 2;
        LOBYTE(v50) = v50 ^ 0x20;
      }
      v71[v49] = v50;
      v51 = v49 + 1;
      v52 = a1[10];
      if ((v52 - 125) <= 1)
      {
        v71[v51] = 125;
        LOBYTE(v52) = v52 ^ 0x20;
        LODWORD(v51) = v49 + 2;
      }
      v71[v51] = v52;
      v53 = v51 + 1;
      v54 = a1[11];
      if ((v54 - 125) <= 1)
      {
        v71[v53] = 125;
        LODWORD(v53) = v51 + 2;
        LOBYTE(v54) = v54 ^ 0x20;
      }
      v71[v53] = v54;
      v55 = v53 + 1;
      v56 = a1[12];
      if ((v56 - 125) <= 1)
      {
        v71[v55] = 125;
        LOBYTE(v56) = v56 ^ 0x20;
        LODWORD(v55) = v53 + 2;
      }
      v71[v55] = v56;
      v57 = v55 + 1;
      v58 = a1[13];
      if ((v58 - 125) <= 1)
      {
        v71[v57] = 125;
        LODWORD(v57) = v55 + 2;
        LOBYTE(v58) = v58 ^ 0x20;
      }
      v71[v57] = v58;
      v59 = v57 + 1;
      v60 = a1[14];
      if ((v60 - 125) <= 1)
      {
        v71[v59] = 125;
        LOBYTE(v60) = v60 ^ 0x20;
        LODWORD(v59) = v57 + 2;
      }
      v71[v59] = v60;
      v61 = v59 + 1;
      v62 = a1[15];
      if ((v62 - 125) <= 1)
      {
        v71[v61] = 125;
        LODWORD(v61) = v59 + 2;
        LOBYTE(v62) = v62 ^ 0x20;
      }
      v71[v61] = v62;
      v63 = v61 + 1;
      v64 = a1[16];
      if ((v64 - 125) <= 1)
      {
        v71[v63] = 125;
        LOBYTE(v64) = v64 ^ 0x20;
        LODWORD(v63) = v61 + 2;
      }
      v65 = ~(v30 ^ BYTE1(v29));
      v71[v63] = v64;
      v66 = v63 + 1;
      v67 = a1[17];
      if ((v67 - 125) <= 1)
      {
        v71[v66] = 125;
        LOBYTE(v67) = v67 ^ 0x20;
        LODWORD(v66) = v63 + 2;
      }
      v68 = ((unsigned __int16)(v30 ^ ~(unsigned __int16)(v29 >> 8)) >> 8);
      v71[v66] = v67;
      v69 = v66 + 1;
      if ((v65 - 125) <= 1)
      {
        v71[v69] = 125;
        LOBYTE(v65) = v65 ^ 0x20;
        LODWORD(v69) = v66 + 2;
      }
      v71[v69] = v65;
      v70 = v69 + 1;
      if ((v68 - 125) <= 1)
      {
        v71[v70] = 125;
        LOBYTE(v68) = v68 ^ 0x20;
        LODWORD(v70) = v69 + 2;
      }
      v71[v70] = v68;
      memcpy(a1, v71, v70 + 1);
      result = (v70 + 2);
      a1[v70 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_REV_A_MOD_TRA(char *a1, int a2, char a3, char a4, char a5, char a6, char a7, char a8, char a9, char a10, char a11, char a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,char a21,char a22,char a23,char a24,char a25,char a26,char a27,char a28,char a29,char a30)
{
  uint64_t result;
  int v38;
  int v39;
  char *v40;
  char v41;
  uint64_t v42;
  size_t v43;
  int v44;
  int v45;
  _BYTE __src[2048];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x3D)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 126;
    a1[6] = 42;
    a1[10] = a3;
    a1[11] = a4;
    a1[12] = a5;
    a1[13] = a6;
    a1[14] = a7;
    a1[15] = a8;
    a1[16] = a9;
    a1[17] = a10;
    a1[18] = a11;
    a1[19] = a12;
    a1[20] = a13;
    a1[21] = a14;
    *(_DWORD *)(a1 + 22) = a15;
    *(_DWORD *)(a1 + 26) = a16;
    *(_DWORD *)(a1 + 30) = a17;
    *(_DWORD *)(a1 + 34) = a18;
    *(_DWORD *)(a1 + 38) = a19;
    a1[42] = a20;
    a1[43] = a21;
    a1[44] = a22;
    a1[45] = a23;
    a1[46] = a24;
    a1[47] = a25;
    a1[48] = a26;
    a1[49] = a27;
    a1[50] = a28;
    a1[51] = a29;
    v38 = 424;
    a1[52] = a30;
    LOWORD(v39) = -1;
    v40 = a1;
    do
    {
      v41 = *v40++;
      v39 = crc_16_l_table[(v41 ^ v39)] ^ ((unsigned __int16)(v39 & 0xFF00) >> 8);
      v38 -= 8;
    }
    while ((_WORD)v38);
    *(_WORD *)(a1 + 53) = ~(_WORD)v39;
    if (a2 >= 110)
    {
      bzero(__src, 0x800uLL);
      v42 = 0;
      LODWORD(v43) = 0;
      do
      {
        while (1)
        {
          v45 = a1[v42];
          if ((v45 - 125) > 1)
            break;
          v44 = v43 + 1;
          __src[(int)v43] = 125;
          __src[(int)v43 + 1] = v45 ^ 0x20;
          v43 = (int)v43 + 1 + 1;
          if (++v42 == 55)
            goto LABEL_11;
        }
        v44 = v43;
        __src[(int)v43] = v45;
        v43 = (int)v43 + 1;
        ++v42;
      }
      while (v42 != 55);
LABEL_11:
      memcpy(a1, __src, v43);
      result = (v44 + 2);
      a1[v43] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_MOD_REVERSE_TRA(char *a1, int a2, char a3, char a4, char a5, char a6, char a7, char a8, char a9, char a10, char a11, char a12, char a13, char a14, char a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,char a25)
{
  uint64_t result;
  int v33;
  int v34;
  char *v35;
  char v36;
  uint64_t v37;
  size_t v38;
  int v39;
  int v40;
  _BYTE __src[2048];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x3B)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 117;
    a1[6] = 47;
    a1[10] = a3;
    a1[11] = a4;
    a1[12] = a5;
    a1[13] = a6;
    a1[14] = a7;
    a1[15] = a8;
    a1[16] = a9;
    a1[17] = a10;
    a1[18] = a11;
    a1[19] = a12;
    a1[20] = a13;
    a1[21] = a14;
    a1[22] = a15;
    a1[23] = a16;
    a1[24] = a17;
    a1[25] = a18;
    *(_DWORD *)(a1 + 26) = a19;
    *(_DWORD *)(a1 + 30) = a20;
    *(_DWORD *)(a1 + 34) = a21;
    *(_DWORD *)(a1 + 38) = a22;
    *(_DWORD *)(a1 + 42) = a23;
    a1[46] = a24;
    v33 = 384;
    a1[47] = a25;
    LOWORD(v34) = -1;
    v35 = a1;
    do
    {
      v36 = *v35++;
      v34 = crc_16_l_table[(v36 ^ v34)] ^ ((unsigned __int16)(v34 & 0xFF00) >> 8);
      v33 -= 8;
    }
    while ((_WORD)v33);
    *((_WORD *)a1 + 24) = ~(_WORD)v34;
    if (a2 >= 100)
    {
      bzero(__src, 0x800uLL);
      v37 = 0;
      LODWORD(v38) = 0;
      do
      {
        while (1)
        {
          v40 = a1[v37];
          if ((v40 - 125) > 1)
            break;
          v39 = v38 + 1;
          __src[(int)v38] = 125;
          __src[(int)v38 + 1] = v40 ^ 0x20;
          v38 = (int)v38 + 1 + 1;
          if (++v37 == 50)
            goto LABEL_11;
        }
        v39 = v38;
        __src[(int)v38] = v40;
        v38 = (int)v38 + 1;
        ++v37;
      }
      while (v37 != 50);
LABEL_11:
      memcpy(a1, __src, v38);
      result = (v39 + 2);
      a1[v38] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_CMD_RELEASE(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  unsigned int v8;
  unsigned __int16 v9;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int __src;
  char v23;
  char v24[2043];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x33)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    a1[4] = 118;
    a1[6] = 10;
    v5 = a1[5];
    v6 = crc_16_l_table[crc_16_l_table[v5 ^ 0x20] ^ 0xAC];
    v7 = crc_16_l_table[(a1[7] ^ v6 ^ HIBYTE(crc_16_l_table[v5 ^ 0x20]))];
    v8 = crc_16_l_table[(a1[8] ^ v7 ^ HIBYTE(v6))];
    v9 = crc_16_l_table[(a1[9] ^ v8 ^ HIBYTE(v7))];
    *((_WORD *)a1 + 5) = v9 ^ ~HIBYTE(crc_16_l_table[(a1[8] ^ v7 ^ HIBYTE(v6))]);
    if (a2 >= 24)
    {
      bzero(v24, 0x7FBuLL);
      __src = 527179;
      v23 = 118;
      if ((v5 - 125) > 1)
      {
        v10 = 5;
      }
      else
      {
        v24[0] = 125;
        v10 = 6;
        LOBYTE(v5) = v5 ^ 0x20;
      }
      v11 = (char *)&__src + v10;
      *v11 = v5;
      v11[1] = 10;
      v12 = v10 + 2;
      v13 = a1[7];
      if ((v13 - 125) <= 1)
      {
        *((_BYTE *)&__src + v12) = 125;
        LODWORD(v12) = v10 + 3;
        LOBYTE(v13) = v13 ^ 0x20;
      }
      *((_BYTE *)&__src + v12) = v13;
      v14 = v12 + 1;
      v15 = a1[8];
      if ((v15 - 125) <= 1)
      {
        *((_BYTE *)&__src + v14) = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v14) = v12 + 2;
      }
      v16 = ~(v9 ^ BYTE1(v8));
      *((_BYTE *)&__src + v14) = v15;
      v17 = v14 + 1;
      v18 = a1[9];
      if ((v18 - 125) <= 1)
      {
        *((_BYTE *)&__src + v17) = 125;
        LOBYTE(v18) = v18 ^ 0x20;
        LODWORD(v17) = v14 + 2;
      }
      v19 = ((unsigned __int16)(v9 ^ ~(unsigned __int16)(v8 >> 8)) >> 8);
      *((_BYTE *)&__src + v17) = v18;
      v20 = v17 + 1;
      if ((v16 - 125) <= 1)
      {
        *((_BYTE *)&__src + v20) = 125;
        LOBYTE(v16) = v16 ^ 0x20;
        LODWORD(v20) = v17 + 2;
      }
      *((_BYTE *)&__src + v20) = v16;
      v21 = v20 + 1;
      if ((v19 - 125) <= 1)
      {
        *((_BYTE *)&__src + v21) = 125;
        LOBYTE(v19) = v19 ^ 0x20;
        LODWORD(v21) = v20 + 2;
      }
      *((_BYTE *)&__src + v21) = v19;
      memcpy(a1, &__src, v21 + 1);
      result = (v21 + 2);
      a1[v21 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetPA_DCDC_Levels(unsigned __int8 *a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t result;
  int v9;
  int v10;
  char v11;
  char v12;
  int v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  _BYTE __src[2048];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x11)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    v9 = gModeId;
    a1[2] = gModeId;
    v10 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    *((_WORD *)a1 + 2) = 183;
    *((_WORD *)a1 + 3) = a3;
    v11 = HIBYTE(a3);
    *((_WORD *)a1 + 4) = a4;
    v12 = HIBYTE(a4);
    v13 = crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC];
    v14 = crc_16_l_table[crc_16_l_table[v13 ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0xB7] ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC])];
    v15 = crc_16_l_table[(v14 ^ HIBYTE(crc_16_l_table[v13 ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0xB7]) ^ a3)];
    v16 = crc_16_l_table[(HIBYTE(a3) ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(a4 ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v16 ^ HIBYTE(v15))] ^ (v16 >> 8)];
    *((_WORD *)a1 + 5) = v18 ^ ~HIBYTE(crc_16_l_table[(a4 ^ v16 ^ HIBYTE(v15))]);
    if (a2 >= 24)
    {
      v36 = v18 ^ ~(v17 >> 8);
      bzero(__src, 0x800uLL);
      v19 = *a1;
      if ((v19 - 125) > 1)
      {
        v20 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v19) = v19 ^ 0x20;
        v20 = 1;
      }
      __src[v20] = v19;
      v21 = v20 + 1;
      v22 = a1[1];
      if ((v22 - 125) <= 1)
      {
        __src[v21] = 125;
        LODWORD(v21) = v20 | 2;
        LOBYTE(v22) = v22 ^ 0x20;
      }
      __src[v21] = v22;
      v23 = v21 + 1;
      if ((v9 - 125) <= 1)
      {
        __src[v23] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v23) = v21 + 2;
      }
      v24 = a3;
      __src[v23] = v9;
      v25 = v23 + 1;
      if ((v10 - 125) <= 1)
      {
        __src[v25] = 125;
        LODWORD(v25) = v23 + 2;
        LOBYTE(v10) = v10 ^ 0x20;
      }
      v26 = &__src[v25];
      *v26 = v10;
      *(_WORD *)(v26 + 1) = 183;
      v27 = v25 + 3;
      if (a3 - 125 <= 1)
      {
        __src[v27] = 125;
        v24 = a3 ^ 0x20;
        LODWORD(v27) = v25 + 4;
      }
      v28 = a4;
      __src[v27] = v24;
      v29 = v27 + 1;
      if (HIBYTE(a3) - 125 <= 1)
      {
        __src[v29] = 125;
        LODWORD(v29) = v27 + 2;
        v11 = HIBYTE(a3) ^ 0x20;
      }
      __src[v29] = v11;
      v30 = v29 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v30] = 125;
        v28 = a4 ^ 0x20;
        LODWORD(v30) = v29 + 2;
      }
      v31 = ~(v18 ^ BYTE1(v17));
      __src[v30] = v28;
      v32 = v30 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v32] = 125;
        v12 = HIBYTE(a4) ^ 0x20;
        LODWORD(v32) = v30 + 2;
      }
      v33 = (unsigned __int16)(v18 ^ ~(unsigned __int16)(v17 >> 8)) >> 8;
      __src[v32] = v12;
      v34 = v32 + 1;
      if ((v31 - 125) <= 1)
      {
        __src[v34] = 125;
        LOBYTE(v31) = v31 ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      __src[v34] = v31;
      v35 = v34 + 1;
      if (BYTE1(v36) - 125 <= 1)
      {
        __src[v35] = 125;
        v33 = BYTE1(v36) ^ 0x20;
        LODWORD(v35) = v34 + 2;
      }
      __src[v35] = v33;
      memcpy(a1, __src, v35 + 1);
      result = (v35 + 2);
      a1[v35 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_TX_RX_FREQ_CAL_SWEEP(char *a1, int a2, char *a3)
{
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  int v24;
  char *v25;
  char v26;
  char *v27;
  uint64_t v28;
  int v29;
  unsigned __int8 *v30;
  char v31;
  int v32;
  _BYTE __src[2048];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x5D2)
    return result;
  bzero(a1, a2);
  *(_QWORD *)a1 = 0xA8008200140B4BLL;
  *((_WORD *)a1 + 4) = 12;
  a1[10] = *a3;
  a1[11] = a3[1];
  a1[12] = a3[2];
  a1[13] = a3[3];
  a1[14] = a3[4];
  a1[15] = a3[5];
  if (a3[2])
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = (uint64_t)&a3[2 * v8 + 6];
      v10 = &a1[v7];
      v10[16] = *(_WORD *)v9;
      v10[17] = *(_BYTE *)(v9 + 1);
      ++v8;
      v7 += 2;
    }
    while (v8 < a3[2]);
    LODWORD(v11) = v7 + 16;
    if (!a3[3])
      goto LABEL_26;
LABEL_9:
    v12 = 0;
    v11 = v11;
    v13 = ((v11 + 2) & 0x1FFFFFFFELL) - 1;
    v14 = v11 | 1;
    do
    {
      v15 = (uint64_t)&a3[2 * v12 + 38];
      a1[v11] = *(_WORD *)v15;
      a1[v14] = *(_BYTE *)(v15 + 1);
      v11 += 2;
      ++v12;
      v13 += 2;
      v14 += 2;
    }
    while (v12 < a3[3]);
    if (a3[3])
    {
      v16 = 0;
      do
      {
        v17 = (uint64_t)&a3[2 * v16 + 78];
        a1[v11] = *(_WORD *)v17;
        v11 += 2;
        a1[v13] = *(_BYTE *)(v17 + 1);
        ++v16;
        v13 += 2;
      }
      while (v16 < a3[3]);
      if (a3[3])
      {
        v18 = 0;
        v19 = &a1[v11];
        do
        {
          *v19++ = a3[v18++ + 118];
          LODWORD(v11) = v11 + 1;
        }
        while (v18 < a3[3]);
        if (a3[3])
        {
          v20 = 0;
          do
          {
            *v19++ = a3[v20++ + 138];
            LODWORD(v11) = v11 + 1;
          }
          while (v20 < a3[3]);
          if (a3[3])
          {
            v21 = 0;
            do
            {
              *v19++ = a3[v21++ + 158];
              LODWORD(v11) = v11 + 1;
            }
            while (v21 < a3[3]);
            if (a3[3])
            {
              v22 = 0;
              do
              {
                *v19++ = a3[v22++ + 178];
                LODWORD(v11) = v11 + 1;
              }
              while (v22 < a3[3]);
            }
          }
        }
      }
    }
    goto LABEL_26;
  }
  LODWORD(v11) = 16;
  if (a3[3])
    goto LABEL_9;
LABEL_26:
  v23 = 8 * v11;
  if (((8 * (_DWORD)v11) & 0xFFF8) != 0)
  {
    LOWORD(v24) = -1;
    v25 = a1;
    do
    {
      v26 = *v25++;
      v24 = crc_16_l_table[(v26 ^ v24)] ^ ((unsigned __int16)(v24 & 0xFF00) >> 8);
      v23 -= 8;
    }
    while ((_WORD)v23);
    *(_WORD *)&a1[(int)v11] = ~(_WORD)v24;
    result = 0xFFFFFFFFLL;
    if ((int)v11 > 1022)
      return result;
  }
  else
  {
    v27 = &a1[(int)v11];
    *v27 = 0;
    v27[1] = 0;
    result = 0xFFFFFFFFLL;
    if ((int)v11 > 1022)
      return result;
  }
  v28 = (v11 + 2);
  if (2 * (int)v28 <= a2)
  {
    bzero(__src, 0x800uLL);
    if ((int)v11 < -1)
    {
      v29 = 0;
    }
    else
    {
      v29 = 0;
      v30 = (unsigned __int8 *)a1;
      do
      {
        v32 = *v30++;
        v31 = v32;
        if ((v32 - 125) <= 1)
        {
          __src[v29] = 125;
          v31 ^= 0x20u;
          ++v29;
        }
        __src[v29++] = v31;
        --v28;
      }
      while (v28);
    }
    memcpy(a1, __src, v29);
    result = (v29 + 1);
    a1[v29] = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_TX_RX_FREQ_CAL_SWEEP_PARSE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  int8x16_t *v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  int v28;
  int8x16_t *v29;
  const char *v30;
  const char *v31;
  unsigned __int128 v33;
  uint64_t v38;
  uint64_t v39;
  int v40;
  const char *v41;
  int8x8_t v42;
  const char *v43;
  uint8x8_t v44;
  unsigned __int8 *v45;
  int v46;
  __int16 v47;

  v3 = *(unsigned __int8 *)(a3 + 2);
  v4 = *(unsigned __int8 *)(a3 + 3);
  if (*(_BYTE *)(a3 + 2))
    _ZF = v4 == 0;
  else
    _ZF = 1;
  if (!_ZF)
  {
    v6 = 0;
    v7 = 2 * v4;
    if ((2 * v4) <= 2)
      v8 = 2;
    else
      v8 = 2 * v4;
    v9 = ((v8 - 1) >> 1) + 1;
    v10 = 6 * v4 + (v7 + 2) * v3;
    v11 = v10 + 22;
    v12 = 2 * v4;
    v13 = (((v8 - 1) >> 1) + 1) & 0xF;
    if (((((v8 - 1) >> 1) + 1) & 0xF) == 0)
      v13 = 16;
    if (((((v8 - 1) >> 1) + 1) & 7) != 0)
      v14 = (((v8 - 1) >> 1) + 1) & 7;
    else
      v14 = 8;
    v15 = v9 - v14;
    v16 = 2 * (v9 - v14);
    v17 = v10 + 23;
    v18 = ~(((unint64_t)(v8 - 2) + 1) >> 1);
    v19 = v18 + v14;
    v20 = (int8x16_t *)(a3 + 838);
    v21 = v11;
    do
    {
      if (v8 >= 0x11)
      {
        v22 = 0;
        v24 = a3 + 838 + 40 * v6 - a1;
        if (v24 - (unint64_t)(v11 + v12 * (_DWORD)v6) < 0x20)
        {
          v23 = 0;
        }
        else
        {
          v25 = v24 - ((v11 | 1) + v12 * (_DWORD)v6);
          v23 = 0;
          if (v25 >= 0x20)
          {
            if (v8 >= 0x21)
            {
              v27 = v18 + v13;
              v28 = v17;
              v29 = v20;
              v30 = (const char *)(a1 + v21);
              do
              {
                v31 = (const char *)(a1 + v28);
                _Q0 = (unsigned __int128)vld2q_s8(v31);
                v33 = (unsigned __int128)vld2q_s8(v30);
                v30 += 32;
                __asm { SHLL2           V4.8H, V0.16B, #8 }
                *v29 = vorrq_s8((int8x16_t)vshll_n_s8(*(int8x8_t *)&_Q0, 8uLL), (int8x16_t)vmovl_u8(*(uint8x8_t *)&v33));
                v29[1] = vorrq_s8(_Q4, (int8x16_t)vmovl_high_u8((uint8x16_t)v33));
                v29 += 2;
                v28 += 32;
                v27 += 16;
              }
              while (v27);
              v26 = v9 - v13;
              v22 = 2 * (v9 - v13);
              v23 = v9 - v13;
              if (v13 < 9)
                goto LABEL_27;
            }
            else
            {
              v26 = 0;
            }
            v38 = 2 * v26;
            v39 = v19 + v26;
            v40 = v17 + 2 * v26;
            do
            {
              v41 = (const char *)(a1 + v40);
              v42 = (int8x8_t)*(_OWORD *)vld2_s8(v41).val;
              v43 = (const char *)(a1 + v21 + v38);
              v44 = (uint8x8_t)*(_OWORD *)vld2_s8(v43).val;
              *(int8x16_t *)((char *)v20 + v38) = vorrq_s8((int8x16_t)vshll_n_s8(v42, 8uLL), (int8x16_t)vmovl_u8(v44));
              v38 += 16;
              v40 += 16;
              v39 += 8;
            }
            while (v39);
            v22 = v16;
            v23 = v15;
          }
        }
      }
      else
      {
        v22 = 0;
        v23 = 0;
      }
LABEL_27:
      v45 = (unsigned __int8 *)(a1 + v22 + v21);
      v46 = v17 + v22;
      do
      {
        v47 = *v45;
        v45 += 2;
        v20->i16[v23] = v47 | (*(unsigned __int8 *)(a1 + v46) << 8);
        v46 += 2;
        ++v23;
      }
      while (v9 != v23);
      ++v6;
      v21 += v7;
      v20 = (int8x16_t *)((char *)v20 + 40);
      v17 += v7;
    }
    while (v6 != v3);
  }
  return 0;
}

uint64_t APPLIB_DIAG_Get_TX_Power_Channel(_DWORD *a1, int a2, __int16 a3)
{
  uint64_t result;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int __src;
  char v20[2044];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 9)
  {
    bzero(a1, a2);
    *a1 = 589131;
    v7 = a3;
    *((_WORD *)a1 + 2) = a3;
    v8 = HIBYTE(a3);
    v9 = crc_16_l_table[a3 ^ 8];
    v10 = crc_16_l_table[crc_16_l_table[a3 ^ 8] ^ HIBYTE(a3) ^ 0x68];
    v11 = v10 ^ ~(v9 >> 8);
    *((_BYTE *)a1 + 6) = v10 ^ ~(v9 >> 8);
    v12 = BYTE1(v11);
    *((_BYTE *)a1 + 7) = BYTE1(v11);
    if (a2 >= 0x10)
    {
      v13 = v10 ^ (v9 >> 8);
      bzero(v20, 0x7FCuLL);
      __src = 589131;
      if ((v7 - 125) > 1)
      {
        v14 = 4;
      }
      else
      {
        v20[0] = 125;
        LOBYTE(v7) = v7 ^ 0x20;
        v14 = 5;
      }
      v15 = ~(_BYTE)v13;
      v20[v14 - 4] = v7;
      v16 = v14 + 1;
      if ((v8 - 125) <= 1)
      {
        v20[v16 - 4] = 125;
        LODWORD(v16) = v14 | 2;
        LOBYTE(v8) = v8 ^ 0x20;
      }
      v20[v16 - 4] = v8;
      v17 = v16 + 1;
      if ((v15 - 125) <= 1)
      {
        v20[v17 - 4] = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v17) = v16 + 2;
      }
      v20[v17 - 4] = v15;
      v18 = v17 + 1;
      if ((v12 - 125) <= 1)
      {
        v20[v18 - 4] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v18) = v17 + 2;
      }
      v20[v18 - 4] = v12;
      memcpy(a1, &__src, v18 + 1);
      result = (v18 + 2);
      *((_BYTE *)a1 + v18 + 1) = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetPmicTherm(_DWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 64843;
    *((_WORD *)a1 + 2) = 22839;
    if (a2 >= 0xC)
    {
      *a1 = 64843;
      *((_WORD *)a1 + 2) = 22839;
      *((_BYTE *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_FTM_SET_REVERSE_LINK_POWER(char *a1, int a2, int a3, int a4)
{
  uint64_t result;
  uint64_t v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  _BYTE *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  char v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  _BYTE __src[2048];
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 461643;
    *((_WORD *)a1 + 2) = 140;
    *(_DWORD *)(a1 + 11) = a4;
    a1[10] = a3;
    v9 = a1[6];
    v10 = crc_16_l_table[v9 ^ 0x25];
    v11 = crc_16_l_table[a1[7] ^ 0x12 ^ v10];
    v12 = crc_16_l_table[(a1[8] ^ v11 ^ HIBYTE(v10))];
    v13 = crc_16_l_table[(a1[9] ^ v12 ^ HIBYTE(v11))];
    v14 = crc_16_l_table[(v13 ^ HIBYTE(v12)) ^ a3];
    v15 = crc_16_l_table[(a4 ^ v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[(a1[12] ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(a1[13] ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a1[14] ^ v17 ^ HIBYTE(v16))];
    v19 = v18 ^ ~(v17 >> 8);
    *(_WORD *)(a1 + 15) = v18 ^ ~HIBYTE(crc_16_l_table[(a1[13] ^ v16 ^ HIBYTE(v15))]);
    if (a2 >= 34)
    {
      bzero(__src, 0x800uLL);
      v20 = *a1;
      if ((v20 - 125) > 1)
      {
        v21 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v20) = v20 ^ 0x20;
        v21 = 1;
      }
      __src[v21] = v20;
      v22 = v21 + 1;
      v23 = a1[1];
      if ((v23 - 125) <= 1)
      {
        __src[v22] = 125;
        LODWORD(v22) = v21 | 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      __src[v22] = v23;
      v24 = v22 + 1;
      v25 = a1[2];
      if ((v25 - 125) <= 1)
      {
        __src[v24] = 125;
        LOBYTE(v25) = v25 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      __src[v24] = v25;
      v26 = v24 + 1;
      v27 = a1[3];
      if ((v27 - 125) <= 1)
      {
        __src[v26] = 125;
        LODWORD(v26) = v24 + 2;
        LOBYTE(v27) = v27 ^ 0x20;
      }
      __src[v26] = v27;
      v28 = v26 + 1;
      v29 = a1[4];
      if ((v29 - 125) <= 1)
      {
        __src[v28] = 125;
        LODWORD(v28) = v26 + 2;
        LOBYTE(v29) = v29 ^ 0x20;
      }
      v30 = &__src[v28];
      *v30 = v29;
      v30[1] = 0;
      v31 = v28 + 2;
      if ((v9 - 125) <= 1)
      {
        __src[v31] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v31) = v28 + 3;
      }
      __src[v31] = v9;
      v32 = v31 + 1;
      v33 = a1[7];
      if ((v33 - 125) <= 1)
      {
        __src[v32] = 125;
        LODWORD(v32) = v31 + 2;
        LOBYTE(v33) = v33 ^ 0x20;
      }
      __src[v32] = v33;
      v34 = v32 + 1;
      v35 = a1[8];
      if ((v35 - 125) <= 1)
      {
        __src[v34] = 125;
        LOBYTE(v35) = v35 ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      __src[v34] = v35;
      v36 = v34 + 1;
      v37 = a1[9];
      if ((v37 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v34 + 2;
        LOBYTE(v37) = v37 ^ 0x20;
      }
      v38 = a4;
      __src[v36] = v37;
      v39 = v36 + 1;
      if ((a3 - 125) <= 1)
      {
        __src[v39] = 125;
        LOBYTE(a3) = a3 ^ 0x20;
        LODWORD(v39) = v36 + 2;
      }
      v40 = BYTE1(a4);
      __src[v39] = a3;
      v41 = v39 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v41] = 125;
        v38 = a4 ^ 0x20;
        LODWORD(v41) = v39 + 2;
      }
      v42 = BYTE2(a4);
      __src[v41] = v38;
      v43 = v41 + 1;
      if (BYTE1(a4) - 125 <= 1)
      {
        __src[v43] = 125;
        LODWORD(v43) = v41 + 2;
        v40 = BYTE1(a4) ^ 0x20;
      }
      __src[v43] = v40;
      v44 = v43 + 1;
      if (BYTE2(a4) - 125 <= 1)
      {
        __src[v44] = 125;
        v42 = BYTE2(a4) ^ 0x20;
        LODWORD(v44) = v43 + 2;
      }
      v45 = ~(v18 ^ BYTE1(v17));
      __src[v44] = v42;
      v46 = v44 + 1;
      v47 = a1[14];
      if ((v47 - 125) <= 1)
      {
        __src[v46] = 125;
        LOBYTE(v47) = v47 ^ 0x20;
        LODWORD(v46) = v44 + 2;
      }
      v48 = (unsigned __int16)(v18 ^ ~(unsigned __int16)(v17 >> 8)) >> 8;
      __src[v46] = v47;
      v49 = v46 + 1;
      if ((v45 - 125) <= 1)
      {
        __src[v49] = 125;
        LOBYTE(v45) = v45 ^ 0x20;
        LODWORD(v49) = v46 + 2;
      }
      __src[v49] = v45;
      v50 = v49 + 1;
      if (BYTE1(v19) - 125 <= 1)
      {
        __src[v50] = 125;
        v48 = BYTE1(v19) ^ 0x20;
        LODWORD(v50) = v49 + 2;
      }
      __src[v50] = v48;
      memcpy(a1, __src, v50 + 1);
      result = (v50 + 2);
      a1[v50 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t ETLDiagCreateGUIDDB(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), unsigned __int16 *a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int16 v18;
  uint64_t FreeSpace;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int16 *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  uint64_t v38;
  const char *v39;
  const char *v40;
  uint64_t v42;
  _WORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _BYTE *v47;
  uint64_t v48;
  unsigned int v49;
  size_t v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  _BYTE *v70;
  unsigned int v71;
  uint64_t v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  _OWORD v81[2];
  uint64_t v82;
  _OWORD v83[2];
  uint64_t v84;
  __int16 v85;
  unsigned int v86;

  if (a1)
  {
    memset(v83, 0, sizeof(v83));
    v84 = 0;
    memset(v81, 0, sizeof(v81));
    v82 = 0;
    if (!HDLCFrameCreateUplink() || a2[2])
      goto LABEL_20;
    if (HDLCFrameGetFreeSpace() <= 7)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v12, v13, v14, v15, v16, v17, 8);
    }
    else
    {
      v18 = *a2;
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace >= 4)
      {
        LOWORD(v86) = 4736;
        HIWORD(v86) = v18;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (!HDLCFrameInjectUnsignedShort()
            || !HDLCFrameInjectUnsignedShort()
            || !ETLSendCommand(a1, (uint64_t)v83, a4)
            || !ETLSubsys2FindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v81, a4))
          {
            goto LABEL_20;
          }
          v86 = 0;
          v32 = (unsigned __int16 *)malloc(0x1CuLL);
          *a3 = v32;
          *(_QWORD *)v32 = 0;
          *((_QWORD *)v32 + 2) = 0;
          *((_DWORD *)v32 + 6) = 0;
          *((_QWORD *)v32 + 1) = 0;
          if (!ETLSubsys2ParseHeader((uint64_t *)v81, &v85, v32, (_DWORD *)v32 + 1, v32 + 4, &v86, v33, v34))goto LABEL_27;
          v35 = (uint64_t)*a3;
          if (**a3 != *a2)
            goto LABEL_27;
          v36 = v86;
          v37 = DWORD2(v81[0]);
          if (DWORD2(v81[0]) - v86 <= 5)
          {
            _ETLDebugPrint((uint64_t)"ETLDiagParseGetDBDataHeader", (uint64_t)"The required size (%u) is less than the payload length (%u)\n", v26, v27, v28, v29, v30, v31, 6);
LABEL_27:
            if (!(*a3)[7])
              goto LABEL_20;
            v39 = "ETLDiagParseGetDBData";
            v40 = "Failed to parse the header while getting GUID\x13.\x13\n";
            goto LABEL_19;
          }
          v42 = *(_QWORD *)&v81[0];
          v43 = (_WORD *)(*(_QWORD *)&v81[0] + v86);
          *(_WORD *)(v35 + 10) = *v43;
          v44 = (unsigned __int16)v43[1];
          *(_WORD *)(v35 + 12) = v44;
          v45 = (unsigned __int16)v43[2];
          *(_WORD *)(v35 + 14) = v45;
          if ((_DWORD)v44 != a2[1])
          {
            _ETLDebugPrint((uint64_t)"ETLDiagParseGetDBDataHeader", (uint64_t)"The request version (%u) is not matched with responded version (%u).\n", v26, v27, v28, v29, v30, v31, a2[1]);
            goto LABEL_27;
          }
          if ((_DWORD)v45)
          {
            _ETLDebugPrint((uint64_t)"ETLDiagParseGetDBData", (uint64_t)"The op code (%d) is not supported!\n", v26, v27, v28, v29, v30, v31, v45);
            goto LABEL_20;
          }
          if (v37 - (v36 + 6) <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLDiagParseOperationDataFileList", (uint64_t)"Request size (%u) is greater than the payload size (%u).\n", v26, v27, v28, v29, v30, v31, 2);
            goto LABEL_20;
          }
          v46 = v44;
          v47 = (_BYTE *)(v42 + v36 + 6);
          if ((_DWORD)v44 == 3)
          {
            *(_BYTE *)(v35 + 16) = *v47;
            v48 = v47[1];
            *(_BYTE *)(v35 + 17) = v48;
            v49 = 21;
          }
          else
          {
            if ((_DWORD)v44 != 1)
            {
              _ETLDebugPrint((uint64_t)"ETLDiagParseOperationDataFileList", (uint64_t)"Unknown version: %u\n", v26, v27, v28, v29, v30, v31, v44);
              goto LABEL_20;
            }
            *(_BYTE *)(v35 + 16) = *v47;
            v48 = v47[1];
            *(_BYTE *)(v35 + 17) = v48;
            v49 = 20;
          }
          v50 = v48 * (unint64_t)v49;
          v51 = malloc(v50);
          *(_QWORD *)(v35 + 18) = v51;
          if (v51)
          {
            bzero(v51, v50);
            _ETLDebugPrint((uint64_t)"ETLDiagParseOperationDataFileList", (uint64_t)"Response: Version: %u\n", v52, v53, v54, v55, v56, v57, v46);
            _ETLDebugPrint((uint64_t)"ETLDiagParseOperationDataFileList", (uint64_t)"Response: Number of Files: %u\n", v58, v59, v60, v61, v62, v63, v48);
            if ((_DWORD)v48)
            {
              v70 = v47 + 2;
              if ((_DWORD)v46 == 3)
                v71 = 21;
              else
                v71 = 20;
              if ((_DWORD)v46 == 1)
              {
                v76 = 0;
                v77 = -8 - v36;
                v38 = 1;
                while (1)
                {
                  v74 = v77 + DWORD2(v81[0]);
                  if (v74 < v71)
                    goto LABEL_56;
                  v78 = *(_QWORD *)(v35 + 18) + v76;
                  *(_DWORD *)v78 = *(_DWORD *)&v70[v76];
                  *(_WORD *)(v78 + 4) = *(_WORD *)&v70[v76 + 4];
                  *(_WORD *)(v78 + 6) = *(_WORD *)&v70[v76 + 6];
                  *(_QWORD *)(v78 + 8) = *(_QWORD *)&v70[v76 + 8];
                  *(_DWORD *)(*(_QWORD *)(v35 + 18) + 16) = *(_DWORD *)&v70[v76 + 16];
                  v77 -= v71;
                  v76 += 20;
                  if (20 * v48 == v76)
                    goto LABEL_21;
                }
              }
              if ((_DWORD)v46 == 3)
              {
                v72 = 0;
                v73 = -8 - v36;
                v38 = 1;
                while (1)
                {
                  v74 = v73 + DWORD2(v81[0]);
                  if (v74 < v71)
                    goto LABEL_56;
                  v75 = *(_QWORD *)(v35 + 18) + v72;
                  *(_DWORD *)v75 = *(_DWORD *)&v70[v72];
                  *(_WORD *)(v75 + 4) = *(_WORD *)&v70[v72 + 4];
                  *(_WORD *)(v75 + 6) = *(_WORD *)&v70[v72 + 6];
                  *(_QWORD *)(v75 + 8) = *(_QWORD *)&v70[v72 + 8];
                  *(_DWORD *)(*(_QWORD *)(v35 + 18) + 16) = *(_DWORD *)&v70[v72 + 16];
                  *(_BYTE *)(*(_QWORD *)(v35 + 18) + 20) = v70[v72 + 20];
                  v73 -= v71;
                  v72 += 21;
                  if (21 * v48 == v72)
                    goto LABEL_21;
                }
              }
              v74 = DWORD2(v81[0]) - (v36 + 8);
              if (v74 < v71)
              {
LABEL_56:
                _ETLDebugPrint((uint64_t)"ETLDiagParseOperationDataFileList", (uint64_t)"Insufficient payload length( %u). Needed %u bytes more\n", v64, v65, v66, v67, v68, v69, v74);
                goto LABEL_20;
              }
              v79 = 0;
              while (++v79 < v48)
              {
                v74 = v74 - v71;
                if (v74 < v71)
                  goto LABEL_56;
              }
            }
            v38 = 1;
            goto LABEL_21;
          }
          v39 = "ETLDiagParseOperationDataFileList";
          v40 = "Failed to allocate memory for file info.\n";
        }
        else
        {
          v39 = "ETLSubsysAddHeaderInternal";
          v40 = "Failed to inject\n";
        }
LABEL_19:
        _ETLDebugPrint((uint64_t)v39, (uint64_t)v40, v26, v27, v28, v29, v30, v31, v80);
        goto LABEL_20;
      }
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v20, v21, v22, v23, v24, v25, FreeSpace);
    }
LABEL_20:
    v38 = 0;
LABEL_21:
    HDLCFrameFree();
    HDLCFrameFree();
    return v38;
  }
  _ETLDebugPrint((uint64_t)"ETLDiagCreateGUIDDB", (uint64_t)"transport cannot be NULL\n", (uint64_t)a3, a4, a5, a6, a7, a8, v80);
  return 0;
}

uint64_t ETLDiagReleaseGUIDDB(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 *v8;
  int v10;
  void *v11;

  v8 = (unsigned __int16 *)*a1;
  if (*a1)
  {
    v10 = v8[6];
    if (v10 == 3 || v10 == 1)
    {
      v11 = *(void **)(v8 + 9);
      if (v11)
        free(v11);
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLDiagReleaseGUIDDB", (uint64_t)"Warning: Version (%u) is not supported to free file list!\n", a3, a4, a5, a6, a7, a8, v8[6]);
    }
    free(*a1);
    *a1 = 0;
  }
  return 1;
}

const char *ETLDiagGetSubsysCmdString(int a1)
{
  if (a1 <= 3599)
  {
    if (a1 == 527)
      return "APPS";
    if (a1 == 2070)
      return "MPSS";
  }
  else
  {
    switch(a1)
    {
      case 3600:
        return "ADSP";
      case 5151:
        return "WCNSS";
      case 6680:
        return "SLPI";
    }
  }
  return (const char *)&unk_1DAD155B3;
}

void ETLFirmwareVersion::ETLFirmwareVersion(ETLFirmwareVersion *this)
{
  *(_QWORD *)this = off_1EA1F1BC0;
  *((_BYTE *)this + 31) = 7;
  strcpy((char *)this + 8, "Phoenix");
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0xFFFFFFFF00000000;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
}

{
  *(_QWORD *)this = off_1EA1F1BC0;
  *((_BYTE *)this + 31) = 7;
  strcpy((char *)this + 8, "Phoenix");
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0xFFFFFFFF00000000;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
}

void ETLFirmwareVersion::~ETLFirmwareVersion(void **this)
{
  *this = off_1EA1F1BC0;
  if (*((char *)this + 95) < 0)
  {
    operator delete(this[9]);
    if ((*((char *)this + 71) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 31) & 0x80000000) == 0)
        return;
LABEL_7:
      operator delete(this[1]);
      return;
    }
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[6]);
  if (*((char *)this + 31) < 0)
    goto LABEL_7;
}

{
  *this = off_1EA1F1BC0;
  if (*((char *)this + 95) < 0)
  {
    operator delete(this[9]);
    if ((*((char *)this + 71) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 31) & 0x80000000) == 0)
        return;
LABEL_7:
      operator delete(this[1]);
      return;
    }
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[6]);
  if (*((char *)this + 31) < 0)
    goto LABEL_7;
}

{
  *this = off_1EA1F1BC0;
  if ((*((char *)this + 95) & 0x80000000) == 0)
  {
    if ((*((char *)this + 71) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_7:
    operator delete(this[6]);
    if ((*((char *)this + 31) & 0x80000000) == 0)
      goto LABEL_4;
LABEL_8:
    operator delete(this[1]);
    operator delete(this);
    return;
  }
  operator delete(this[9]);
  if (*((char *)this + 71) < 0)
    goto LABEL_7;
LABEL_3:
  if (*((char *)this + 31) < 0)
    goto LABEL_8;
LABEL_4:
  operator delete(this);
}

BOOL ETLFirmwareVersion::initCommon(uint64_t a1)
{
  void **v2;
  void **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unint64_t v10;
  char v11;
  __int128 v12;
  void *v13;
  size_t v14;
  void **v15;
  char v16;
  __int128 v17;
  char *v18;
  size_t v19;
  void **v20;
  void **v21;
  unint64_t v22;
  char v23;
  __int128 v24;
  _BOOL8 v25;
  void *v27;
  size_t v28;
  _QWORD *v29;
  char **v30;
  int v31;
  size_t v32;
  char *v33;
  _BYTE *v34;
  BOOL v35;
  const char *v36;
  int v37;
  void **v38;
  void **v39;
  void **v40;
  int v41;
  size_t v42;
  void *v43;
  _BYTE *v44;
  BOOL v45;
  const char *v46;
  int v47;
  _QWORD *v48;
  char **v49;
  int v50;
  size_t v51;
  char *v52;
  _BYTE *v53;
  const char *v54;
  int v55;
  _QWORD *v56;
  char **v57;
  int v58;
  size_t v59;
  char *v60;
  _BYTE *v61;
  const char *v62;
  int v63;
  void **v64;
  void **v65;
  void *__p[3];
  void *__dst[2];
  uint64_t v68;
  char *__endptr;

  __dst[0] = 0;
  __dst[1] = 0;
  v68 = 0;
  memset(__p, 170, sizeof(__p));
  ctu::tokenize();
  v3 = (void **)__p[0];
  v2 = (void **)__p[1];
  if (0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3) < 2)
    goto LABEL_2;
  v4 = *((unsigned __int8 *)__p[0] + 23);
  if ((v4 & 0x80u) == 0)
    v5 = *((unsigned __int8 *)__p[0] + 23);
  else
    v5 = *((_QWORD *)__p[0] + 1);
  v6 = *(unsigned __int8 *)(a1 + 31);
  v7 = (char)v6;
  if ((v6 & 0x80u) != 0)
    v6 = *(_QWORD *)(a1 + 16);
  if (v5 != v6)
    goto LABEL_20;
  if (v7 >= 0)
    v8 = (unsigned __int8 *)(a1 + 8);
  else
    v8 = *(unsigned __int8 **)(a1 + 8);
  if ((v4 & 0x80) != 0)
  {
    if (!memcmp(*(const void **)__p[0], v8, *((_QWORD *)__p[0] + 1)))
      goto LABEL_25;
LABEL_20:
    if (__p[1] == __p[0])
      goto LABEL_92;
    do
    {
      if (*((char *)v2 - 1) < 0)
        operator delete(*(v2 - 3));
      v2 -= 3;
    }
    while (v2 != __p[0]);
LABEL_91:
    v2 = (void **)__p[0];
LABEL_92:
    __p[1] = v3;
    operator delete(v2);
    goto LABEL_93;
  }
  if (*((_BYTE *)__p[0] + 23))
  {
    v9 = (unsigned __int8 *)__p[0];
    while (*v9 == *v8)
    {
      ++v9;
      ++v8;
      if (!--v4)
        goto LABEL_25;
    }
LABEL_2:
    if (!__p[0])
      goto LABEL_93;
    goto LABEL_20;
  }
LABEL_25:
  if (__dst != (void **)((char *)__p[0] + 24))
  {
    if ((*((char *)__p[0] + 47) & 0x80000000) == 0)
    {
      *(_OWORD *)__dst = *(_OWORD *)((char *)__p[0] + 24);
      v68 = *((_QWORD *)__p[0] + 5);
      if (__p[1] == __p[0])
        goto LABEL_37;
      do
      {
LABEL_34:
        if (*((char *)v2 - 1) < 0)
          operator delete(*(v2 - 3));
        v2 -= 3;
      }
      while (v2 != v3);
      v2 = (void **)__p[0];
      goto LABEL_37;
    }
    std::string::__assign_no_alias<true>(__dst, *((void **)__p[0] + 3), *((_QWORD *)__p[0] + 4));
    v3 = (void **)__p[0];
  }
  if (!v3)
    goto LABEL_38;
  v2 = (void **)__p[1];
  if (__p[1] != v3)
    goto LABEL_34;
LABEL_37:
  __p[1] = v3;
  operator delete(v2);
LABEL_38:
  memset(__p, 170, sizeof(__p));
  ctu::tokenize();
  v3 = (void **)__p[0];
  v2 = (void **)__p[1];
  v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
  if (v10 != 1)
  {
    if (v10 != 2)
    {
      if (__p[0])
      {
        if (__p[1] == __p[0])
          goto LABEL_92;
        do
        {
          if (*((char *)v2 - 1) < 0)
            operator delete(*(v2 - 3));
          v2 -= 3;
        }
        while (v2 != __p[0]);
        goto LABEL_91;
      }
      goto LABEL_93;
    }
    if (__dst != __p[0])
    {
      v11 = *((_BYTE *)__p[0] + 23);
      if (SHIBYTE(v68) < 0)
      {
        if (v11 >= 0)
          v13 = __p[0];
        else
          v13 = *(void **)__p[0];
        if (v11 >= 0)
          v14 = *((unsigned __int8 *)__p[0] + 23);
        else
          v14 = *((_QWORD *)__p[0] + 1);
        std::string::__assign_no_alias<false>(__dst, v13, v14);
      }
      else if ((*((_BYTE *)__p[0] + 23) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(__dst, *(void **)__p[0], *((_QWORD *)__p[0] + 1));
      }
      else
      {
        v12 = *(_OWORD *)__p[0];
        v68 = *((_QWORD *)__p[0] + 2);
        *(_OWORD *)__dst = v12;
      }
    }
    v3 = (void **)__p[0];
    v15 = (void **)(a1 + 48);
    if ((void *)(a1 + 48) != (char *)__p[0] + 24)
    {
      v16 = *((_BYTE *)__p[0] + 47);
      if (*(char *)(a1 + 71) < 0)
      {
        if (v16 >= 0)
          v18 = (char *)__p[0] + 24;
        else
          v18 = (char *)*((_QWORD *)__p[0] + 3);
        if (v16 >= 0)
          v19 = *((unsigned __int8 *)__p[0] + 47);
        else
          v19 = *((_QWORD *)__p[0] + 4);
        std::string::__assign_no_alias<false>(v15, v18, v19);
      }
      else if ((*((_BYTE *)__p[0] + 47) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(v15, *((void **)__p[0] + 3), *((_QWORD *)__p[0] + 4));
      }
      else
      {
        v17 = *(_OWORD *)((char *)__p[0] + 24);
        *(_QWORD *)(a1 + 64) = *((_QWORD *)__p[0] + 5);
        *(_OWORD *)v15 = v17;
      }
      v3 = (void **)__p[0];
    }
  }
  if (v3)
  {
    v20 = (void **)__p[1];
    v21 = v3;
    if (__p[1] != v3)
    {
      do
      {
        if (*((char *)v20 - 1) < 0)
          operator delete(*(v20 - 3));
        v20 -= 3;
      }
      while (v20 != v3);
      v21 = (void **)__p[0];
    }
    __p[1] = v3;
    operator delete(v21);
  }
  memset(__p, 170, sizeof(__p));
  ctu::tokenize();
  v3 = (void **)__p[0];
  v2 = (void **)__p[1];
  v22 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
  if (v22 == 1)
    goto LABEL_125;
  if (v22 != 2)
  {
    if (__p[0])
    {
      if (__p[1] == __p[0])
        goto LABEL_92;
      do
      {
        if (*((char *)v2 - 1) < 0)
          operator delete(*(v2 - 3));
        v2 -= 3;
      }
      while (v2 != __p[0]);
      goto LABEL_91;
    }
LABEL_93:
    v25 = 0;
    goto LABEL_94;
  }
  if (__dst != __p[0])
  {
    v23 = *((_BYTE *)__p[0] + 23);
    if (SHIBYTE(v68) < 0)
    {
      if (v23 >= 0)
        v27 = __p[0];
      else
        v27 = *(void **)__p[0];
      if (v23 >= 0)
        v28 = *((unsigned __int8 *)__p[0] + 23);
      else
        v28 = *((_QWORD *)__p[0] + 1);
      std::string::__assign_no_alias<false>(__dst, v27, v28);
    }
    else if ((*((_BYTE *)__p[0] + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(__dst, *(void **)__p[0], *((_QWORD *)__p[0] + 1));
    }
    else
    {
      v24 = *(_OWORD *)__p[0];
      v68 = *((_QWORD *)__p[0] + 2);
      *(_OWORD *)__dst = v24;
    }
  }
  *(_DWORD *)(a1 + 44) = 0;
  v29 = __p[0];
  v30 = (char **)((char *)__p[0] + 24);
  __endptr = 0;
  v31 = *((char *)__p[0] + 47);
  if (v31 >= 0)
    v32 = *((unsigned __int8 *)__p[0] + 47);
  else
    v32 = *((_QWORD *)__p[0] + 4);
  if (!v32
    || (v31 >= 0 ? (v33 = (char *)__p[0] + 24) : (v33 = *v30),
        (v34 = memchr(v33, 45, v32)) != 0 ? (v35 = v34 - v33 == -1) : (v35 = 1),
        v35))
  {
    *__error() = 0;
    v36 = *((char *)v29 + 47) >= 0 ? (const char *)v30 : (const char *)v29[3];
    v37 = strtoul(v36, &__endptr, 10);
    if (!*__error() && __endptr && !*__endptr)
      *(_DWORD *)(a1 + 44) = v37;
  }
  v3 = (void **)__p[0];
LABEL_125:
  if (v3)
  {
    v38 = (void **)__p[1];
    v39 = v3;
    if (__p[1] != v3)
    {
      do
      {
        if (*((char *)v38 - 1) < 0)
          operator delete(*(v38 - 3));
        v38 -= 3;
      }
      while (v38 != v3);
      v39 = (void **)__p[0];
    }
    __p[1] = v3;
    operator delete(v39);
  }
  memset(__p, 170, sizeof(__p));
  ctu::tokenize();
  v40 = (void **)__p[0];
  v25 = (void *)((char *)__p[1] - (char *)__p[0]) == (void *)72;
  if ((void *)((char *)__p[1] - (char *)__p[0]) == (void *)72)
  {
    *(_DWORD *)(a1 + 32) = 0;
    __endptr = 0;
    v41 = *((char *)v40 + 23);
    if (v41 >= 0)
      v42 = *((unsigned __int8 *)v40 + 23);
    else
      v42 = (size_t)v40[1];
    if (!v42
      || (v41 >= 0 ? (v43 = v40) : (v43 = *v40),
          (v44 = memchr(v43, 45, v42)) != 0 ? (v45 = v44 - (_BYTE *)v43 == -1) : (v45 = 1),
          v45))
    {
      *__error() = 0;
      v46 = *((char *)v40 + 23) >= 0 ? (const char *)v40 : (const char *)*v40;
      v47 = strtoul(v46, &__endptr, 10);
      if (!*__error() && __endptr && !*__endptr)
        *(_DWORD *)(a1 + 32) = v47;
    }
    *(_DWORD *)(a1 + 36) = 0;
    v48 = __p[0];
    v49 = (char **)((char *)__p[0] + 24);
    __endptr = 0;
    v50 = *((char *)__p[0] + 47);
    if (v50 >= 0)
      v51 = *((unsigned __int8 *)__p[0] + 47);
    else
      v51 = *((_QWORD *)__p[0] + 4);
    if (!v51
      || (v50 >= 0 ? (v52 = (char *)__p[0] + 24) : (v52 = *v49), (v53 = memchr(v52, 45, v51)) == 0 || v53 - v52 == -1))
    {
      *__error() = 0;
      v54 = *((char *)v48 + 47) >= 0 ? (const char *)v49 : (const char *)v48[3];
      v55 = strtoul(v54, &__endptr, 10);
      if (!*__error() && __endptr && !*__endptr)
        *(_DWORD *)(a1 + 36) = v55;
    }
    *(_DWORD *)(a1 + 40) = 0;
    v56 = __p[0];
    v57 = (char **)((char *)__p[0] + 48);
    __endptr = 0;
    v58 = *((char *)__p[0] + 71);
    if (v58 >= 0)
      v59 = *((unsigned __int8 *)__p[0] + 71);
    else
      v59 = *((_QWORD *)__p[0] + 7);
    if (!v59
      || (v58 >= 0 ? (v60 = (char *)__p[0] + 48) : (v60 = *v57), (v61 = memchr(v60, 45, v59)) == 0 || v61 - v60 == -1))
    {
      *__error() = 0;
      v62 = *((char *)v56 + 71) >= 0 ? (const char *)v57 : (const char *)v56[6];
      v63 = strtoul(v62, &__endptr, 10);
      if (!*__error() && __endptr && !*__endptr)
        *(_DWORD *)(a1 + 40) = v63;
    }
    v40 = (void **)__p[0];
  }
  if (v40)
  {
    v64 = (void **)__p[1];
    v65 = v40;
    if (__p[1] != v40)
    {
      do
      {
        if (*((char *)v64 - 1) < 0)
          operator delete(*(v64 - 3));
        v64 -= 3;
      }
      while (v64 != v40);
      v65 = (void **)__p[0];
    }
    __p[1] = v40;
    operator delete(v65);
  }
LABEL_94:
  if (SHIBYTE(v68) < 0)
    operator delete(__dst[0]);
  return v25;
}

void sub_1DACE5AC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  std::vector<std::string>::~vector[abi:ne180100](&a10);
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void **std::vector<std::string>::~vector[abi:ne180100](void **a1)
{
  void **v2;
  void **v3;
  void *v4;

  v2 = (void **)*a1;
  if (*a1)
  {
    v3 = (void **)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 1) < 0)
          operator delete(*(v3 - 3));
        v3 -= 3;
      }
      while (v3 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

BOOL ETLFirmwareVersion::initWithVersionString(uint64_t a1, uint64_t a2)
{
  char v4;
  void *v5;
  const std::string::value_type *v6;
  int v7;
  char *v8;
  int64_t v9;
  int64_t v10;
  unint64_t v11;
  std::string *p_dst;
  std::string::value_type *v13;
  const std::string::value_type *v14;
  int v15;
  int64_t v16;
  int64_t v17;
  const std::string::value_type *v18;
  const std::string::value_type *v19;
  uint64_t v20;
  uint64_t v21;
  std::string *v22;
  void *v23;
  char v24;
  int v25;
  size_t v26;
  unint64_t v27;
  std::string::value_type *v28;
  void **v29;
  _BOOL8 inited;
  uint64_t v32;
  uint64_t v33;
  _OWORD *v34;
  const void *v35;
  const std::string::value_type *__s;
  std::string __dst;
  void *__p[3];
  _QWORD v39[3];

  v39[2] = *MEMORY[0x1E0C80C00];
  memset(__p, 0, sizeof(__p));
  v4 = *(_BYTE *)(a2 + 23);
  v5 = *(void **)a2;
  if (v4 >= 0)
    v6 = (const std::string::value_type *)a2;
  else
    v6 = *(const std::string::value_type **)a2;
  __s = v6;
  v7 = *(char *)(a1 + 31);
  if (v7 >= 0)
    v8 = (char *)(a1 + 8);
  else
    v8 = *(char **)(a1 + 8);
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a1 + 31);
  else
    v9 = *(_QWORD *)(a1 + 16);
  if (v9)
  {
    if (v4 >= 0)
      v10 = *(unsigned __int8 *)(a2 + 23);
    else
      v10 = *(_QWORD *)(a2 + 8);
    if (v10 >= v9)
    {
      v13 = (std::string::value_type *)v6;
      v14 = &v6[v10];
      v15 = *v8;
      v16 = v10;
      do
      {
        v17 = v16 - v9;
        if (v17 == -1)
          break;
        v18 = (const std::string::value_type *)memchr(v13, v15, v17 + 1);
        if (!v18)
          break;
        v19 = v18;
        if (!memcmp(v18, v8, v9))
        {
          if (v19 == v14 || v19 != __s)
            break;
          goto LABEL_33;
        }
        v13 = (std::string::value_type *)(v19 + 1);
        v16 = v14 - (v19 + 1);
      }
      while (v16 >= v9);
    }
    v11 = v9 + 1;
    if ((unint64_t)(v9 + 1) > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    if (v11 > 0x16)
    {
      v20 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17)
        v20 = v11 | 7;
      v21 = v20 + 1;
      p_dst = (std::string *)operator new(v20 + 1);
      __dst.__r_.__value_.__l.__size_ = v9 + 1;
      __dst.__r_.__value_.__r.__words[2] = v21 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v9 + 1;
    }
    memmove(p_dst, v8, v9);
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v9) = 32;
    v22 = std::string::append(&__dst, __s, v10);
    v23 = (void *)v22->__r_.__value_.__r.__words[0];
    v39[0] = v22->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)v39 + 7) = *(std::string::size_type *)((char *)&v22->__r_.__value_.__r.__words[1] + 7);
    v24 = HIBYTE(v22->__r_.__value_.__r.__words[2]);
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
    __p[0] = v23;
    __p[1] = (void *)v39[0];
    *(void **)((char *)&__p[1] + 7) = *(void **)((char *)v39 + 7);
    HIBYTE(__p[2]) = v24;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__dst.__r_.__value_.__l.__data_);
  }
  else
  {
LABEL_33:
    if (__p != (void **)a2)
    {
      if (v4 < 0)
      {
        std::string::__assign_no_alias<true>(__p, v5, *(_QWORD *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)__p = *(_OWORD *)a2;
        __p[2] = *(void **)(a2 + 16);
      }
    }
  }
  v25 = *(char *)(a2 + 23);
  if (v25 >= 0)
    v26 = *(unsigned __int8 *)(a2 + 23);
  else
    v26 = *(_QWORD *)(a2 + 8);
  v27 = v26 + 16;
  memset(&__dst, 170, sizeof(__dst));
  if (v26 + 16 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v27 >= 0x17)
  {
    v32 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v27 | 7) != 0x17)
      v32 = v27 | 7;
    v33 = v32 + 1;
    v34 = operator new(v32 + 1);
    __dst.__r_.__value_.__l.__size_ = v26 + 16;
    __dst.__r_.__value_.__r.__words[2] = v33 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
    *v34 = *(_OWORD *)"Version String: ";
    v28 = (std::string::value_type *)(v34 + 1);
  }
  else
  {
    v28 = &__dst.__r_.__value_.__s.__data_[16];
    __dst.__r_.__value_.__r.__words[2] = 0;
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v26 + 16;
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)"Version String: ";
    if (!v26)
    {
      __dst.__r_.__value_.__s.__data_[16] = 0;
      v29 = (void **)(a1 + 72);
      if ((*(char *)(a1 + 95) & 0x80000000) == 0)
        goto LABEL_44;
      goto LABEL_54;
    }
  }
  if (v25 >= 0)
    v35 = (const void *)a2;
  else
    v35 = *(const void **)a2;
  memmove(v28, v35, v26);
  v28[v26] = 0;
  v29 = (void **)(a1 + 72);
  if ((*(char *)(a1 + 95) & 0x80000000) == 0)
    goto LABEL_44;
LABEL_54:
  operator delete(*v29);
LABEL_44:
  *(std::string *)v29 = __dst;
  inited = ETLFirmwareVersion::initCommon(a1);
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  return inited;
}

void sub_1DACE5EF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0)
  {
    operator delete(__p);
    if ((a23 & 0x80000000) == 0)
LABEL_3:
      _Unwind_Resume(exception_object);
  }
  else if ((a23 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a18);
  _Unwind_Resume(exception_object);
}

BOOL ETLFirmwareVersion::initWithFolderName(uint64_t a1, const void **a2)
{
  int v2;
  size_t v3;
  unint64_t v4;
  char *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  const void *v13;
  __int128 v14;
  unint64_t v15;

  v2 = *((char *)a2 + 23);
  if (v2 >= 0)
    v3 = *((unsigned __int8 *)a2 + 23);
  else
    v3 = (size_t)a2[1];
  v4 = v3 + 8;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v15 = 0xAAAAAAAAAAAAAAAALL;
  if (v3 + 8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v4 >= 0x17)
  {
    v10 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v10 = v4 | 7;
    v11 = v10 + 1;
    v12 = operator new(v10 + 1);
    *v12 = 0x203A7265646C6F46;
    v7 = (char *)(v12 + 1);
    *((_QWORD *)&v14 + 1) = v3 + 8;
    v15 = v11 | 0x8000000000000000;
    *(_QWORD *)&v14 = v12;
  }
  else
  {
    v7 = (char *)&v14 + 8;
    v15 = 0;
    HIBYTE(v15) = v3 + 8;
    v14 = 0x203A7265646C6F46uLL;
    if (!v3)
    {
      BYTE8(v14) = 0;
      v8 = a1 + 72;
      if ((*(char *)(a1 + 95) & 0x80000000) == 0)
        goto LABEL_8;
LABEL_16:
      operator delete(*(void **)v8);
      goto LABEL_8;
    }
  }
  if (v2 >= 0)
    v13 = a2;
  else
    v13 = *a2;
  memmove(v7, v13, v3);
  v7[v3] = 0;
  v8 = a1 + 72;
  if (*(char *)(a1 + 95) < 0)
    goto LABEL_16;
LABEL_8:
  *(_OWORD *)v8 = v14;
  *(_QWORD *)(v8 + 16) = v15;
  return ETLFirmwareVersion::initCommon(a1);
}

BOOL ETLFirmwareVersion::isNewerThan(ETLFirmwareVersion *this, const ETLFirmwareVersion *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  v2 = *((_DWORD *)this + 8);
  v3 = *((_DWORD *)a2 + 8);
  if (v2 < v3)
    return 0;
  if (v2 > v3)
    return 1;
  v5 = *((_DWORD *)this + 9);
  v6 = *((_DWORD *)a2 + 9);
  if (v5 < v6)
    return 0;
  if (v5 > v6)
    return 1;
  v7 = *((_DWORD *)this + 10);
  v8 = *((_DWORD *)a2 + 10);
  if (v7 < v8)
    return 0;
  return v7 > v8 || *((_DWORD *)this + 11) > *((_DWORD *)a2 + 11);
}

BOOL ETLFirmwareVersion::equals(ETLFirmwareVersion *this, const ETLFirmwareVersion *a2)
{
  return *((_DWORD *)this + 8) == *((_DWORD *)a2 + 8)
      && *((_DWORD *)this + 9) == *((_DWORD *)a2 + 9)
      && *((_DWORD *)this + 10) == *((_DWORD *)a2 + 10)
      && *((_DWORD *)this + 11) == *((_DWORD *)a2 + 11);
}

uint64_t ETLFirmwareVersion::getAsString@<X0>(ETLFirmwareVersion *this@<X0>, std::string *a2@<X8>)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  char *v10;
  const std::locale::facet *v11;
  int v12;
  size_t v13;
  unint64_t v14;
  std::string *p_dst;
  char v16;
  std::string::size_type v17;
  std::string *p_p;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  const void *v23;
  uint64_t v24;
  uint64_t v25;
  std::string *v26;
  std::string::size_type size;
  std::string *v28;
  __int128 v29;
  size_t v30;
  size_t v31;
  unint64_t v32;
  std::string::value_type *v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE *v36;
  char *v37;
  std::string *v38;
  std::string::size_type v39;
  size_t v40;
  size_t v41;
  unint64_t v42;
  std::string::value_type *v43;
  uint64_t v44;
  uint64_t v45;
  _DWORD *v46;
  char *v47;
  std::string *v48;
  __int128 v49;
  std::string *v50;
  std::string::size_type v51;
  std::string __p;
  std::string __dst;
  uint64_t v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  void *v60[2];
  __int128 v61;
  unint64_t v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62 = 0xAAAAAAAAAAAAAAAALL;
  v72 = v4;
  v71 = v4;
  v70 = v4;
  v69 = v4;
  v68 = v4;
  v67 = v4;
  v66 = v4;
  v65 = v4;
  v64 = v4;
  v61 = v4;
  v59 = v4;
  *(_OWORD *)v60 = v4;
  v57 = v4;
  v58 = v4;
  v56 = v4;
  v5 = MEMORY[0x1E0DE4FE0];
  v6 = MEMORY[0x1E0DE4FE0] + 64;
  v63 = MEMORY[0x1E0DE4FE0] + 64;
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v55 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  *(uint64_t *)((char *)&v55 + *(_QWORD *)(v55 - 24)) = v7;
  v8 = (std::ios_base *)((char *)&v55 + *(_QWORD *)(v55 - 24));
  std::ios_base::init(v8, &v56);
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v55 = v5 + 24;
  v63 = v6;
  std::streambuf::basic_streambuf();
  *(_QWORD *)&v56 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)v60 = 0u;
  v61 = 0u;
  LODWORD(v62) = 16;
  v9 = v55;
  v10 = (char *)&v55 + *(_QWORD *)(v55 - 24);
  if (*((_DWORD *)v10 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)&v55 + *(_QWORD *)(v55 - 24)));
    v11 = std::locale::use_facet((const std::locale *)&__dst, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
    std::locale::~locale((std::locale *)&__dst);
    v9 = v55;
  }
  *((_DWORD *)v10 + 36) = 48;
  *(_QWORD *)((char *)&v57 + *(_QWORD *)(v9 - 24)) = 2;
  std::ostream::operator<<();
  *(_QWORD *)((char *)&v57 + *(_QWORD *)(v55 - 24)) = 1;
  __dst.__r_.__value_.__s.__data_[0] = 46;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)&__dst);
  *(_QWORD *)((char *)&v57 + *(_QWORD *)(v55 - 24)) = 2;
  std::ostream::operator<<();
  *(_QWORD *)((char *)&v57 + *(_QWORD *)(v55 - 24)) = 1;
  __dst.__r_.__value_.__s.__data_[0] = 46;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)&__dst);
  *(_QWORD *)((char *)&v57 + *(_QWORD *)(v55 - 24)) = 2;
  std::ostream::operator<<();
  *(_QWORD *)((char *)&v57 + *(_QWORD *)(v55 - 24)) = 1;
  if (*((_DWORD *)this + 11) != -1)
  {
    __dst.__r_.__value_.__s.__data_[0] = 45;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)&__dst);
    std::ostream::operator<<();
  }
  memset(a2, 170, sizeof(std::string));
  v12 = *((char *)this + 31);
  if (v12 >= 0)
    v13 = *((unsigned __int8 *)this + 31);
  else
    v13 = *((_QWORD *)this + 2);
  v14 = v13 + 1;
  memset(&__dst, 170, sizeof(__dst));
  if (v13 + 1 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v14 >= 0x17)
  {
    v19 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17)
      v19 = v14 | 7;
    v20 = v19 + 1;
    p_dst = (std::string *)operator new(v19 + 1);
    __dst.__r_.__value_.__l.__size_ = v13 + 1;
    __dst.__r_.__value_.__r.__words[2] = v20 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v13 + 1;
    if (!v13)
    {
      LOWORD(__dst.__r_.__value_.__l.__data_) = 32;
      v16 = v62;
      if ((v62 & 0x10) == 0)
        goto LABEL_12;
LABEL_21:
      v22 = *((_QWORD *)&v61 + 1);
      if (*((_QWORD *)&v61 + 1) < (unint64_t)v59)
      {
        *((_QWORD *)&v61 + 1) = v59;
        v22 = v59;
      }
      v23 = (const void *)*((_QWORD *)&v58 + 1);
      v17 = v22 - *((_QWORD *)&v58 + 1);
      if ((unint64_t)(v22 - *((_QWORD *)&v58 + 1)) > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_70;
      goto LABEL_24;
    }
  }
  if (v12 >= 0)
    v21 = (char *)this + 8;
  else
    v21 = (char *)*((_QWORD *)this + 1);
  memmove(p_dst, v21, v13);
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v13) = 32;
  v16 = v62;
  if ((v62 & 0x10) != 0)
    goto LABEL_21;
LABEL_12:
  if ((v16 & 8) == 0)
  {
    v17 = 0;
    *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
    p_p = &__p;
    goto LABEL_31;
  }
  v23 = (const void *)v57;
  v17 = v58 - v57;
  if ((_QWORD)v58 - (_QWORD)v57 > 0x7FFFFFFFFFFFFFF7uLL)
LABEL_70:
    std::string::__throw_length_error[abi:ne180100]();
LABEL_24:
  if (v17 >= 0x17)
  {
    v24 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17)
      v24 = v17 | 7;
    v25 = v24 + 1;
    p_p = (std::string *)operator new(v24 + 1);
    __p.__r_.__value_.__l.__size_ = v17;
    __p.__r_.__value_.__r.__words[2] = v25 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    goto LABEL_30;
  }
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = v17;
  p_p = &__p;
  if (v17)
LABEL_30:
    memmove(p_p, v23, v17);
LABEL_31:
  p_p->__r_.__value_.__s.__data_[v17] = 0;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v26 = &__p;
  else
    v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v28 = std::string::append(&__dst, (const std::string::value_type *)v26, size);
  v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  a2->__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_39:
      v30 = *((unsigned __int8 *)this + 71);
      if ((*((char *)this + 71) & 0x80000000) == 0)
        goto LABEL_40;
LABEL_44:
      if (!*((_QWORD *)this + 7))
        goto LABEL_66;
      goto LABEL_45;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_39;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  v30 = *((unsigned __int8 *)this + 71);
  if (*((char *)this + 71) < 0)
    goto LABEL_44;
LABEL_40:
  if (!v30)
    goto LABEL_66;
LABEL_45:
  if ((v30 & 0x80u) == 0)
    v31 = v30;
  else
    v31 = *((_QWORD *)this + 7);
  v32 = v31 + 1;
  memset(&__dst, 170, sizeof(__dst));
  if (v31 + 1 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v32 >= 0x17)
  {
    v34 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v32 | 7) != 0x17)
      v34 = v32 | 7;
    v35 = v34 + 1;
    v36 = operator new(v34 + 1);
    __dst.__r_.__value_.__l.__size_ = v31 + 1;
    __dst.__r_.__value_.__r.__words[2] = v35 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
    *v36 = 95;
    v33 = v36 + 1;
  }
  else
  {
    __dst.__r_.__value_.__r.__words[2] = 0;
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v31 + 1;
    v33 = &__dst.__r_.__value_.__s.__data_[1];
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0x5FuLL;
    if (!v31)
      goto LABEL_59;
  }
  if ((v30 & 0x80u) == 0)
    v37 = (char *)this + 48;
  else
    v37 = (char *)*((_QWORD *)this + 6);
  memmove(v33, v37, v31);
LABEL_59:
  v33[v31] = 0;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v38 = &__dst;
  else
    v38 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v39 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  else
    v39 = __dst.__r_.__value_.__l.__size_;
  std::string::append(a2, (const std::string::value_type *)v38, v39);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_66:
    v40 = *((unsigned __int8 *)this + 95);
    if ((*((char *)this + 95) & 0x80000000) == 0)
      goto LABEL_67;
LABEL_72:
    if (!*((_QWORD *)this + 10))
      goto LABEL_95;
    goto LABEL_73;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  v40 = *((unsigned __int8 *)this + 95);
  if (*((char *)this + 95) < 0)
    goto LABEL_72;
LABEL_67:
  if (!v40)
    goto LABEL_95;
LABEL_73:
  if ((v40 & 0x80u) == 0)
    v41 = v40;
  else
    v41 = *((_QWORD *)this + 10);
  v42 = v41 + 7;
  if (v41 + 7 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v42 >= 0x17)
  {
    v44 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v42 | 7) != 0x17)
      v44 = v42 | 7;
    v45 = v44 + 1;
    v46 = operator new(v44 + 1);
    __p.__r_.__value_.__l.__size_ = v41 + 7;
    __p.__r_.__value_.__r.__words[2] = v45 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v46;
    *v46 = 1919295528;
    v43 = (char *)v46 + 7;
    *(_DWORD *)((char *)v46 + 3) = 544042866;
    goto LABEL_83;
  }
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = v41 + 7;
  v43 = &__p.__r_.__value_.__s.__data_[7];
  strcpy((char *)&__p, "( from ");
  if (v41)
  {
LABEL_83:
    if ((v40 & 0x80u) == 0)
      v47 = (char *)this + 72;
    else
      v47 = (char *)*((_QWORD *)this + 9);
    memmove(v43, v47, v41);
  }
  v43[v41] = 0;
  v48 = std::string::append(&__p, ")", 2uLL);
  v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v49;
  v48->__r_.__value_.__l.__size_ = 0;
  v48->__r_.__value_.__r.__words[2] = 0;
  v48->__r_.__value_.__r.__words[0] = 0;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v50 = &__dst;
  else
    v50 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v51 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  else
    v51 = __dst.__r_.__value_.__l.__size_;
  std::string::append(a2, (const std::string::value_type *)v50, v51);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_95;
  }
  else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_95;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_95:
  v55 = *MEMORY[0x1E0DE4F60];
  *(uint64_t *)((char *)&v55 + *(_QWORD *)(v55 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  *(_QWORD *)&v56 = MEMORY[0x1E0DE4FB8] + 16;
  if (SBYTE7(v61) < 0)
    operator delete(v60[0]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1DF0A6634](&v63);
}

void sub_1DACE686C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  uint64_t v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  if (*(char *)(v22 + 23) < 0)
  {
    operator delete(*(void **)v22);
    std::ostringstream::~ostringstream((uint64_t)&a22);
    _Unwind_Resume(a1);
  }
  std::ostringstream::~ostringstream((uint64_t)&a22);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F60];
  v3 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1DF0A6634](a1 + 112);
  return a1;
}

_BYTE *ETLFirmwareVersion::createWithVersionString(uint64_t a1)
{
  _BYTE *v2;

  v2 = operator new(0x60uLL);
  *(_QWORD *)v2 = off_1EA1F1BC0;
  v2[31] = 7;
  strcpy(v2 + 8, "Phoenix");
  *((_QWORD *)v2 + 4) = 0;
  *((_QWORD *)v2 + 5) = 0xFFFFFFFF00000000;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  if (!ETLFirmwareVersion::initWithVersionString((uint64_t)v2, a1))
  {
    (*(void (**)(_BYTE *))(*(_QWORD *)v2 + 8))(v2);
    return 0;
  }
  return v2;
}

_BYTE *ETLFirmwareVersion::createWithFolderName(const void **a1)
{
  _BYTE *v2;

  v2 = operator new(0x60uLL);
  *(_QWORD *)v2 = off_1EA1F1BC0;
  v2[31] = 7;
  strcpy(v2 + 8, "Phoenix");
  *((_QWORD *)v2 + 4) = 0;
  *((_QWORD *)v2 + 5) = 0xFFFFFFFF00000000;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  if (!ETLFirmwareVersion::initWithFolderName((uint64_t)v2, a1))
  {
    (*(void (**)(_BYTE *))(*(_QWORD *)v2 + 8))(v2);
    return 0;
  }
  return v2;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]();
}

void std::__throw_length_error[abi:ne180100]()
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception);
  __cxa_throw(exception, (struct type_info *)off_1EA1F1A70, MEMORY[0x1E0DE42D0]);
}

void sub_1DACE6B8C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, "basic_string");
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

_QWORD *std::string::__assign_no_alias<true>(_QWORD *__dst, void *__src, size_t __len)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len > 0x16)
  {
    if (__len - 0x7FFFFFFFFFFFFFF7 <= 0x800000000000001ELL)
      std::string::__throw_length_error[abi:ne180100]();
    v7 = 44;
    if (__len > 0x2C)
      v7 = __len;
    v8 = (v7 | 7) + 1;
    v6 = operator new(v8);
    memcpy(v6, __src, __len);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v6 = __dst;
    if (__len)
    {
      memmove(__dst, __src, __len);
      v6 = __dst;
    }
  }
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

void **std::string::__assign_no_alias<false>(void **a1, void *__src, size_t __len)
{
  unint64_t v6;
  uint64_t v7;
  void *v8;
  size_t v9;
  unint64_t v10;
  void *v11;
  unint64_t v13;
  uint64_t v14;

  v6 = (unint64_t)a1[2];
  v7 = v6 & 0x7FFFFFFFFFFFFFFFLL;
  if ((v6 & 0x7FFFFFFFFFFFFFFFLL) > __len)
  {
    v8 = *a1;
    a1[1] = (void *)__len;
    if (__len)
      memmove(v8, __src, __len);
    goto LABEL_12;
  }
  v9 = 0x7FFFFFFFFFFFFFF7;
  if (0x7FFFFFFFFFFFFFF7 - v7 < __len - v7 + 1)
    std::string::__throw_length_error[abi:ne180100]();
  v10 = v7 - 1;
  v11 = a1;
  if ((v6 & 0x8000000000000000) == 0)
  {
    if (v10 > 0x3FFFFFFFFFFFFFF2)
      goto LABEL_7;
LABEL_14:
    v13 = 2 * v10;
    if (__len > 2 * v10)
      v13 = __len;
    v14 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v14 = v13 | 7;
    if (v13 >= 0x17)
      v9 = v14 + 1;
    else
      v9 = 23;
    v8 = operator new(v9);
    if (!__len)
      goto LABEL_9;
    goto LABEL_8;
  }
  v11 = *a1;
  if (v10 <= 0x3FFFFFFFFFFFFFF2)
    goto LABEL_14;
LABEL_7:
  v8 = operator new(0x7FFFFFFFFFFFFFF7uLL);
  if (__len)
LABEL_8:
    memcpy(v8, __src, __len);
LABEL_9:
  if (v10 != 22)
    operator delete(v11);
  a1[1] = (void *)__len;
  a1[2] = (void *)(v9 | 0x8000000000000000);
  *a1 = v8;
LABEL_12:
  *((_BYTE *)v8 + __len) = 0;
  return a1;
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2)
{
  char *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  const std::locale::facet *v9;
  uint64_t v10;
  BOOL v11;
  size_t v12;
  size_t v13;
  std::locale::__imp *v14;
  uint64_t v15;
  uint64_t v16;
  void *locale;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v22[2];
  std::locale __b[3];

  v22[0] = 0xAAAAAAAAAAAAAAAALL;
  v22[1] = 0xAAAAAAAAAAAAAAAALL;
  MEMORY[0x1DF0A658C](v22, a1);
  if (LOBYTE(v22[0]))
  {
    v4 = (char *)a1 + *(_QWORD *)(*a1 - 24);
    v5 = *((_QWORD *)v4 + 5);
    v6 = *((_DWORD *)v4 + 2);
    v7 = *((_DWORD *)v4 + 36);
    if (v7 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v9 = std::locale::use_facet(__b, MEMORY[0x1E0DE4A90]);
      v7 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 32);
      std::locale::~locale(__b);
      *((_DWORD *)v4 + 36) = v7;
      if ((v6 & 0xB0) == 0x20)
        v8 = a2 + 1;
      else
        v8 = a2;
      if (!v5)
        goto LABEL_34;
    }
    else
    {
      if ((*((_DWORD *)v4 + 2) & 0xB0) == 0x20)
        v8 = a2 + 1;
      else
        v8 = a2;
      if (!v5)
        goto LABEL_34;
    }
    v10 = *((_QWORD *)v4 + 3);
    v11 = v10 <= 1;
    v12 = v10 - 1;
    if (v11)
      v13 = 0;
    else
      v13 = v12;
    if (v8 - a2 < 1
      || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 96))(v5, a2, v8 - a2) == v8 - a2)
    {
      if ((uint64_t)v13 >= 1)
      {
        memset(__b, 170, sizeof(__b));
        if (v13 >= 0x7FFFFFFFFFFFFFF8)
          std::string::__throw_length_error[abi:ne180100]();
        if (v13 >= 0x17)
        {
          v15 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v13 | 7) != 0x17)
            v15 = v13 | 7;
          v16 = v15 + 1;
          v14 = (std::locale::__imp *)operator new(v15 + 1);
          __b[1].__locale_ = (std::locale::__imp *)v13;
          __b[2].__locale_ = (std::locale::__imp *)(v16 | 0x8000000000000000);
          __b[0].__locale_ = v14;
        }
        else
        {
          HIBYTE(__b[2].__locale_) = v13;
          v14 = (std::locale::__imp *)__b;
        }
        memset(v14, v7, v13);
        *((_BYTE *)v14 + v13) = 0;
        if (SHIBYTE(__b[2].__locale_) >= 0)
          locale = __b;
        else
          locale = __b[0].__locale_;
        v18 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(_QWORD *)v5 + 96))(v5, locale, v13);
        v19 = v18;
        if (SHIBYTE(__b[2].__locale_) < 0)
        {
          operator delete(__b[0].__locale_);
          if (v19 != v13)
            goto LABEL_34;
        }
        else if (v18 != v13)
        {
          goto LABEL_34;
        }
      }
      v20 = a2 + 1 - v8;
      if (v20 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 96))(v5, v8, v20) == v20)
      {
        *((_QWORD *)v4 + 3) = 0;
        goto LABEL_35;
      }
    }
LABEL_34:
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
LABEL_35:
  MEMORY[0x1DF0A6598](v22);
  return a1;
}

void sub_1DACE7030(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _QWORD *v17;

  if (a17 < 0)
    operator delete(__p);
  MEMORY[0x1DF0A6598](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(_QWORD *)(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1DACE7004);
}

void sub_1DACE7090(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t ETLRouterSequenceGetLast(uint64_t a1)
{
  uint64_t v1;

  do
  {
    v1 = a1;
    a1 = *(_QWORD *)(a1 + 8);
  }
  while (a1);
  return v1;
}

uint64_t ETLRouterCreateRouterSequenceCommand(uint64_t a1, uint64_t a2)
{
  uint64_t FreeSpace;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v4, v5, v6, v7, v8, v9, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v10, v11, v12, v13, v14, v15, v33);
    return 0;
  }
  if (*(_DWORD *)a2)
    return 0;
  v17 = *(int **)(a2 + 8);
  if (!v17)
    return 1;
  while (2)
  {
    if (HDLCFrameGetFreeSpace() <= 2)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v18, v19, v20, v21, v22, v23, 3);
      result = 0;
      v24 = *v17;
      v25 = *v17 - 2;
      if (v25 > 3)
      {
LABEL_19:
        if (v24 != 255)
          return 0;
        if (!(_DWORD)result)
          return result;
        result = HDLCFrameInjectUnsignedShort();
        if (!(_DWORD)result)
          return result;
        if (HDLCFrameGetFreeSpace() <= 3)
          goto LABEL_43;
        result = HDLCFrameInjectUnsignedChar();
        if (!(_DWORD)result)
          return result;
        result = HDLCFrameInjectUnsignedChar();
        if (!(_DWORD)result)
          return result;
LABEL_29:
        result = HDLCFrameInjectUnsignedShort();
        goto LABEL_30;
      }
    }
    else
    {
      result = HDLCFrameInjectUnsignedChar();
      v24 = *v17;
      v25 = *v17 - 2;
    }
    switch(v25)
    {
      case 0u:
      case 2u:
        if (!(_DWORD)result)
          return result;
        result = HDLCFrameInjectUnsignedShort();
        if (!(_DWORD)result)
          return result;
        if (HDLCFrameGetFreeSpace() <= 3)
          goto LABEL_43;
        result = HDLCFrameInjectUnsignedShort();
        if ((_DWORD)result)
          goto LABEL_29;
        return result;
      case 1u:
        if (!(_DWORD)result)
          return result;
        result = HDLCFrameInjectUnsignedShort();
        if (!(_DWORD)result)
          return result;
        if (HDLCFrameGetFreeSpace() > 1)
          goto LABEL_29;
        v32 = 2;
        goto LABEL_45;
      case 3u:
        if (v17[4])
        {
          if (!(_DWORD)result)
            return result;
          result = HDLCFrameInjectUnsignedShort();
          if (!(_DWORD)result)
            return result;
          if (HDLCFrameGetFreeSpace() <= 3)
          {
LABEL_43:
            v32 = 4;
            goto LABEL_45;
          }
          result = HDLCFrameInjectUnsignedInt();
LABEL_30:
          v17 = (int *)*((_QWORD *)v17 + 1);
          if (!v17 || (result & 1) == 0)
            return result;
          continue;
        }
        if (!(_DWORD)result)
          return result;
        result = HDLCFrameInjectUnsignedShort();
        if (!(_DWORD)result)
          return result;
        if (HDLCFrameGetFreeSpace())
        {
          result = HDLCFrameInjectUnsignedChar();
          goto LABEL_30;
        }
        v32 = 1;
LABEL_45:
        _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v26, v27, v28, v29, v30, v31, v32);
        return 0;
      default:
        goto LABEL_19;
    }
  }
}

uint64_t ETLRouterParseRouterSequenceResponse(int **a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  _BOOL8 v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v9 = *((_DWORD *)a1 + 2);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_11:
    v13 = 0;
    *a2 = 1;
    return v13;
  }
  v10 = *a1;
  v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_11;
  }
  if (BYTE1(v11) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_11;
  }
  v12 = HIWORD(v11);
  if ((_DWORD)v12 != 49)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_11;
  }
  if (v9 == 4)
    return 1;
  if (*((unsigned __int8 *)v10 + 4) == 255)
  {
    v13 = v9 - 11 < 0xFFFFFFFC;
    v15 = *((unsigned __int8 *)v10 + 7);
    __memcpy_chk();
    *a2 = 0;
    _ETLDebugPrint((uint64_t)"ETLRouterParseVersionPayload", (uint64_t)"Got version %u.%u.%u, notes '%s'\n", v16, v17, v18, v19, v20, v21, v15);
  }
  else
  {
    *a2 = 0;
    return 1;
  }
  return v13;
}

uint64_t ETLRouterSendRouterSequence(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, int a3, _DWORD *a4, uint64_t a5)
{
  void *v10;
  void *v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD v22[2];
  uint64_t v23;
  _OWORD v24[2];
  uint64_t v25;
  int v26;

  memset(v24, 0, sizeof(v24));
  v25 = 0;
  memset(v22, 0, sizeof(v22));
  v23 = 0;
  *a4 = 1;
  if (HDLCFrameCreateUplink()
    && ETLRouterCreateRouterSequenceCommand((uint64_t)v24, a2)
    && (v10 = malloc((2 * DWORD2(v24[0]) + 32))) != 0)
  {
    v11 = v10;
    v12 = HDLCFrameEncode();
    if ((_DWORD)v12)
    {
      v13 = -1431655766;
      v26 = -1431655766;
      if ((_ETLDebugFlags & 2) != 0)
        ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
      if (*a1)
      {
        v14 = (*a1)(a1, v11, v12, &v26, 1, a5, 0);
        v13 = v26;
      }
      else
      {
        v14 = 0;
      }
      if (v13 == (_DWORD)v12)
        v12 = v14;
      else
        v12 = 0;
    }
    free(v11);
    if (!a3)
      goto LABEL_21;
  }
  else
  {
    v12 = 0;
    if (!a3)
    {
LABEL_21:
      *a4 = 0;
      goto LABEL_22;
    }
  }
  if ((_DWORD)v12)
  {
    LOBYTE(v26) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v12 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v22, (uint64_t)&_ETLResponseRingBuffer, &v26, a5)&& v26 == 75)
    {
      v12 = ETLRouterParseRouterSequenceResponse((int **)v22, a4, v15, v16, v17, v18, v19, v20);
    }
  }
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return v12;
}

unint64_t ETLRouterGetVersion(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), unsigned __int8 *a2, _DWORD *a3, uint64_t a4)
{
  unsigned int v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD v33[3];
  _QWORD v34[2];
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  int v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v34[0] = 0;
  v34[1] = 0;
  v8 = *(_DWORD *)a2;
  v33[1] = 0;
  v33[0] = 255;
  v33[2] = v8;
  v9 = v34;
  do
  {
    v10 = v9;
    v9 = (_QWORD *)v9[1];
  }
  while (v9);
  v10[1] = v33;
  v35 = 0u;
  v36 = 0u;
  v37 = 0;
  v39 = 0u;
  v40 = 0u;
  v41 = 0;
  *a3 = 1;
  if (!HDLCFrameCreateUplink()
    || !ETLRouterCreateRouterSequenceCommand((uint64_t)&v35, (uint64_t)v34))
  {
    goto LABEL_13;
  }
  v11 = (unint64_t)malloc((2 * DWORD2(v35) + 32));
  if (!v11)
  {
    *a3 = 0;
    HDLCFrameFree();
    HDLCFrameFree();
    return v11;
  }
  v12 = HDLCFrameEncode();
  if (!(_DWORD)v12)
  {
    free((void *)v11);
LABEL_13:
    *a3 = 0;
    HDLCFrameFree();
    HDLCFrameFree();
    return 0;
  }
  v13 = v12;
  v14 = -1431655766;
  v38 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
  if (*a1)
  {
    v15 = (*a1)(a1, (void *)v11, v13, &v38, 1, a4, 0);
    v14 = v38;
  }
  else
  {
    v15 = 0;
  }
  free((void *)v11);
  *a3 = 0;
  HDLCFrameFree();
  HDLCFrameFree();
  v11 = 0;
  if (v15 && v14 == (_DWORD)v13)
  {
    v37 = 0;
    v35 = 0u;
    v36 = 0u;
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v11 = 0;
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)&v35, (uint64_t)&_ETLResponseRingBuffer, &v39, a4)|| v39 != 75)
    {
      goto LABEL_34;
    }
    v23 = DWORD2(v35);
    if (DWORD2(v35) < 4)
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v17, v18, v19, v20, v21, v22, DWORD2(v35));
    }
    else
    {
      v24 = v35;
      v25 = *(_DWORD *)v35;
      if (*(_DWORD *)v35 == 75)
      {
        if (BYTE1(v25) == 253)
        {
          v26 = HIWORD(v25);
          if ((_DWORD)v26 == 49)
          {
            *a3 = 1;
            if (v23 != 4 && *(unsigned __int8 *)(v24 + 4) == 255)
            {
              v11 = (v23 - 11) < 0xFFFFFFFC;
              v39 = 0u;
              v40 = 0u;
              *a2 = *(_BYTE *)(v24 + 7);
              a2[1] = *(_BYTE *)(v24 + 8);
              *((_WORD *)a2 + 1) = *(_WORD *)(v24 + 9);
              __memcpy_chk();
              *a3 = 0;
              _ETLDebugPrint((uint64_t)"ETLRouterParseVersionPayload", (uint64_t)"Got version %u.%u.%u, notes '%s'\n", v27, v28, v29, v30, v31, v32, *a2);
            }
            else
            {
              v11 = 0;
            }
            goto LABEL_34;
          }
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v17, v18, v19, v20, v21, v22, v26);
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v17, v18, v19, v20, v21, v22, BYTE1(v25));
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v17, v18, v19, v20, v21, v22, *(_DWORD *)v35);
      }
    }
    v11 = 0;
    *a3 = 1;
LABEL_34:
    HDLCFrameFree();
  }
  return v11;
}

double ETLDebugSetDefaults()
{
  double result;

  result = *(double *)&gDelegateDefault;
  gDelegate = gDelegateDefault;
  _ETLDebugFlags = 3;
  return result;
}

uint64_t ETLDebugSetFlags(uint64_t result)
{
  _ETLDebugFlags = result;
  return result;
}

uint64_t ETLDebugAddFlags(uint64_t result)
{
  _ETLDebugFlags |= result;
  return result;
}

uint64_t ETLDebugRemoveFlags(unsigned int a1)
{
  uint64_t v1;

  v1 = _ETLDebugFlags & a1;
  _ETLDebugFlags &= ~a1;
  return v1;
}

uint64_t _ETLDebugPrint(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if ((_ETLDebugFlags & 1) != 0)
    return gDelegate(result, a2, &a9);
  return result;
}

uint64_t _ETLDebugPrintBinary(uint64_t a1, int a2)
{
  uint64_t result;

  if (a2 == 3 || (_ETLDebugFlags & 2) != 0)
    return ((uint64_t (*)(void))*(&gDelegate + 1))();
  return result;
}

uint64_t APPLIB_DIAG_SEND_SMS(_OWORD *a1, int a2, unsigned int a3, int a4, uint64_t a5)
{
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  char *v11;
  char v12;
  uint64_t v13;
  int v14;
  int v15;
  char *v16;
  char v17;
  uint64_t result;
  int v19;
  uint64_t v20;
  unsigned __int8 *v21;
  char v22;
  int v23;
  __int128 *v24;
  _OWORD *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  _BYTE __src[2048];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)((char *)a1 + 204) = 0u;
  a1[11] = 0u;
  a1[12] = 0u;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  *(_DWORD *)a1 = 130123;
  *((_BYTE *)a1 + 4) = a2;
  if (a2 >= 1)
  {
    v7 = a2 + 1;
    do
    {
      *((_BYTE *)a1 + (v7-- - 2) + 5) = a3 % 0xA;
      a3 /= 0xAu;
    }
    while (v7 > 1);
  }
  *((_BYTE *)a1 + 20) = a4;
  if (a4 >= 1)
  {
    if (a4 < 8 || (unint64_t)a1 - a5 + 21 < 0x20)
    {
      v8 = 0;
      goto LABEL_8;
    }
    if (a4 >= 0x20)
    {
      v8 = a4 & 0xFFFFFFE0;
      v24 = (__int128 *)(a5 + 16);
      v25 = (_OWORD *)((char *)a1 + 37);
      v26 = v8;
      do
      {
        v27 = *v24;
        *(v25 - 1) = *(v24 - 1);
        *v25 = v27;
        v24 += 2;
        v25 += 2;
        v26 -= 32;
      }
      while (v26);
      if (v8 == a4)
        goto LABEL_10;
      if ((a4 & 0x18) == 0)
      {
LABEL_8:
        v9 = a4 - v8;
        v10 = (char *)a1 + v8 + 21;
        v11 = (char *)(a5 + v8);
        do
        {
          v12 = *v11++;
          *v10++ = v12;
          --v9;
        }
        while (v9);
        goto LABEL_10;
      }
    }
    else
    {
      v8 = 0;
    }
    v28 = v8;
    v8 = a4 & 0xFFFFFFF8;
    v29 = (uint64_t *)(a5 + v28);
    v30 = (_QWORD *)((char *)a1 + v28 + 21);
    v31 = v28 - v8;
    do
    {
      v32 = *v29++;
      *v30++ = v32;
      v31 += 8;
    }
    while (v31);
    if (v8 != a4)
      goto LABEL_8;
  }
LABEL_10:
  v13 = a4 + 21;
  v14 = 8 * v13;
  if (((8 * (_DWORD)v13) & 0xFFF8) != 0)
  {
    LOWORD(v15) = -1;
    v16 = (char *)a1;
    do
    {
      v17 = *v16++;
      v15 = crc_16_l_table[(v17 ^ v15)] ^ ((unsigned __int16)(v15 & 0xFF00) >> 8);
      v14 -= 8;
    }
    while ((_WORD)v14);
    *((_BYTE *)a1 + v13) = ~(_BYTE)v15;
    *((_BYTE *)a1 + a4 + 22) = (unsigned __int16)~(_WORD)v15 >> 8;
    if (a4 > 233)
      return 0xFFFFFFFFLL;
  }
  else
  {
    *((_BYTE *)a1 + v13) = 0;
    *((_BYTE *)a1 + a4 + 22) = 0;
    if (a4 > 233)
      return 0xFFFFFFFFLL;
  }
  bzero(__src, 0x800uLL);
  if (a4 < -22)
  {
    v19 = 0;
  }
  else
  {
    v19 = 0;
    v20 = (a4 + 23);
    v21 = (unsigned __int8 *)a1;
    do
    {
      v23 = *v21++;
      v22 = v23;
      if ((v23 - 125) <= 1)
      {
        __src[v19] = 125;
        v22 ^= 0x20u;
        ++v19;
      }
      __src[v19++] = v22;
      --v20;
    }
    while (v20);
  }
  memcpy(a1, __src, v19);
  result = (v19 + 1);
  *((_BYTE *)a1 + v19) = 126;
  return result;
}

uint64_t APPLIB_DIAG_ENABLE_MT_SMS_STORE(_BYTE *a1, unsigned __int8 a2)
{
  int v3;
  __int16 v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int __src;
  _BYTE v12[2044];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a1 = 195659;
  v3 = a2;
  a1[4] = a2;
  v4 = crc_16_l_table[a2 ^ 0xA4] ^ 0xFF30;
  v5 = crc_16_l_table[a2 ^ 0xA4] ^ 0x30;
  a1[5] = crc_16_l_table[a2 ^ 0xA4] ^ 0x30;
  v6 = HIBYTE(v4);
  a1[6] = HIBYTE(v4);
  bzero(v12, 0x7FCuLL);
  __src = 195659;
  if ((v3 - 125) > 1)
  {
    v7 = 4;
    v12[0] = v3;
    v8 = 5;
    if ((v5 - 125) > 1)
      goto LABEL_6;
    goto LABEL_5;
  }
  v12[0] = 125;
  v7 = 5;
  v12[1] = v3 ^ 0x20;
  v8 = 6;
  if ((v5 - 125) <= 1)
  {
LABEL_5:
    v12[v8 - 4] = 125;
    LODWORD(v8) = v7 | 2;
    LOBYTE(v5) = v5 ^ 0x20;
  }
LABEL_6:
  v12[v8 - 4] = v5;
  v9 = v8 + 1;
  if ((v6 - 125) <= 1)
  {
    v12[v9 - 4] = 125;
    LOBYTE(v6) = v6 ^ 0x20;
    LODWORD(v9) = v8 + 2;
  }
  v12[v9 - 4] = v6;
  memcpy(a1, &__src, v9 + 1);
  a1[v9 + 1] = 126;
  return (v9 + 2);
}

uint64_t APPLIB_DIAG_RECV_MT_SMS(uint64_t a1)
{
  *(_DWORD *)a1 = 261195;
  *(_WORD *)(a1 + 4) = 10627;
  *(_BYTE *)(a1 + 6) = 126;
  return 7;
}

uint64_t ETLMaverickAddDataCommandHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickParseDataResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  v8 = *a2;
  v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v10 = *(_DWORD *)(*(_QWORD *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == 100)
      {
        if (HIWORD(v10) == (_DWORD)a3)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickAddBSPCommandHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickParseBSPResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  v8 = *a2;
  v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v10 = *(_DWORD *)(*(_QWORD *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == 253)
      {
        if (HIWORD(v10) == (_DWORD)a3)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickAddBSPExtCommandGetHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
LABEL_7:
    _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Failed on creating BSP Command Heder\n", v20, v21, v22, v23, v24, v25, v27);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v26);
    goto LABEL_7;
  }
  if (HDLCFrameGetFreeSpace())
  {
    HDLCFrameInjectUnsignedChar();
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
    return 0;
  }
}

uint64_t ETLMaverickAddBSPExtCommandSetHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
LABEL_7:
    _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Failed on creating BSP Command Heder\n", v20, v21, v22, v23, v24, v25, v27);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v26);
    goto LABEL_7;
  }
  if (HDLCFrameGetFreeSpace() > 1)
  {
    HDLCFrameInjectUnsignedChar();
    HDLCFrameInjectUnsignedChar();
    return 1;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
  return 0;
}

uint64_t ETLMaverickAddRFCommandHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickParseRFResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  v8 = *a2;
  v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v10 = *(_DWORD *)(*(_QWORD *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == 251)
      {
        if (HIWORD(v10) == (_DWORD)a3)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickAddFACTORYCommandHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickParseFACTORYResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  v8 = *a2;
  v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v10 = *(_DWORD *)(*(_QWORD *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == 254)
      {
        if (HIWORD(v10) == (_DWORD)a3)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickAddCDMACommandHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickParseCDMAResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  v8 = *a2;
  v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v10 = *(_DWORD *)(*(_QWORD *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == 252)
      {
        if (HIWORD(v10) == (_DWORD)a3)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateAPWakeCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickCreateAPWakeCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      HDLCFrameInjectUnsignedShort();
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseAPWakeResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;

  v8 = a1[2];
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    v9 = **(_DWORD **)a1;
    if (v9 == 75)
    {
      if (BYTE1(v9) == 253)
      {
        v10 = HIWORD(v9);
        if ((_DWORD)v10 == 13)
        {
          if (v8 - 4 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseAPWakeResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 2);
            return 0;
          }
          else if (*(_WORD *)(*(_QWORD *)a1 + 4))
          {
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseAPWakeResponse", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, 0);
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateTxModeSwitchCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickCreateTxModeSwitchCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      HDLCFrameInjectUnsignedShort();
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseTxModeSwitchResponse(int **a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_15:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseTxModeSwitchResponse", (uint64_t)"Failed to parse BSP header from response\n", v16, v17, v18, v19, v20, v21, v22);
    return 0;
  }
  v10 = *a1;
  v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_15;
  }
  if (BYTE1(v11) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_15;
  }
  v12 = HIWORD(v11);
  if ((_DWORD)v12 != 6)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_15;
  }
  if (v9 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseTxModeSwitchResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  else if (*((_WORD *)v10 + 2) == 1)
  {
    v13 = *((unsigned __int16 *)v10 + 3);
    v14 = a2 - 3;
    if (a2 <= 2)
      v14 = a2;
    if ((_DWORD)v13 == v14)
    {
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickParseTxModeSwitchResponse", (uint64_t)"Mode doesn't match %u, expected %u\n", a3, a4, a5, a6, a7, a8, v13);
      return 0;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseTxModeSwitchResponse", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 2));
    return 0;
  }
}

uint64_t ETLMaverickAddRSSICommandHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      HDLCFrameInjectUnsignedShort();
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickCreateStartRSSICommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
  }
  else
  {
    if ((HDLCFrameInject() & 1) != 0)
    {
      if (HDLCFrameGetFreeSpace() <= 1)
      {
        v16 = 2;
      }
      else
      {
        HDLCFrameInjectUnsignedShort();
        if (HDLCFrameGetFreeSpace() > 5)
        {
          HDLCFrameInjectUnsignedShort();
          HDLCFrameInjectUnsignedShort();
          return HDLCFrameInjectUnsignedShort();
        }
        v16 = 6;
      }
      v17 = v16;
      v14 = "ETLRequireFreeSpace";
      v15 = "Need %u bytes free space, but only have %u\n";
    }
    else
    {
      v14 = "ETLSubsysAddHeaderInternal";
      v15 = "Failed to inject\n";
    }
    _ETLDebugPrint((uint64_t)v14, (uint64_t)v15, v7, v8, v9, v10, v11, v12, v17);
  }
  return 0;
}

uint64_t ETLMaverickCreateStopRSSICommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      v20 = 2;
    }
    else
    {
      HDLCFrameInjectUnsignedShort();
      if (HDLCFrameGetFreeSpace() > 5)
      {
        HDLCFrameInjectUnsignedShort();
        HDLCFrameInjectUnsignedShort();
        return HDLCFrameInjectUnsignedShort();
      }
      v20 = 6;
    }
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, v20);
    return 0;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v21);
    return 0;
  }
}

uint64_t ETLMaverickCreateReportRSSICommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      v20 = 2;
    }
    else
    {
      HDLCFrameInjectUnsignedShort();
      if (HDLCFrameGetFreeSpace() > 5)
      {
        HDLCFrameInjectUnsignedShort();
        HDLCFrameInjectUnsignedShort();
        return HDLCFrameInjectUnsignedShort();
      }
      v20 = 6;
    }
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, v20);
    return 0;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v21);
    return 0;
  }
}

uint64_t ETLMaverickParseRSSICommandResponse(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v8 = *a2;
  v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v10 = *(_DWORD *)(*(_QWORD *)a1 + v8);
    if (v10 == 75)
    {
      v11 = v8 + 4;
      *a2 = v11;
      if (BYTE1(v10) == 253)
      {
        v12 = HIWORD(v10);
        if ((_DWORD)v12 == 15)
        {
          v13 = *(_DWORD *)(a1 + 8) - v11;
          if (v13 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseRSSICommandResponse", (uint64_t)"Only have %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v13);
            return 0;
          }
          else
          {
            v14 = *(unsigned __int16 *)(*(_QWORD *)a1 + v11);
            if ((_DWORD)v14 == (_DWORD)a3)
            {
              return 1;
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseRSSICommandResponse", (uint64_t)"Returned subcommand 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v14);
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickParseStartRSSIResponse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;

  v9 = 0;
  return ETLMaverickParseRSSICommandResponse(a1, &v9, 1, a4, a5, a6, a7, a8);
}

uint64_t ETLMaverickParseStopRSSIResponse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;

  v9 = 0;
  return ETLMaverickParseRSSICommandResponse(a1, &v9, 1, a4, a5, a6, a7, a8);
}

uint64_t ETLMaverickCreateGetTxPowerExtCommand(capabilities::etl *a1, unsigned int a2)
{
  int v3;
  uint64_t FreeSpace;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;

  v3 = capabilities::etl::maverickTxPowerUsesRFSubsys(a1);
  FreeSpace = HDLCFrameGetFreeSpace();
  if (!v3)
  {
    if (FreeSpace >= 4)
    {
      if (!HDLCFrameInject())
        goto LABEL_4;
      goto LABEL_7;
    }
LABEL_10:
    v19 = FreeSpace;
    v11 = "Free space %u not enough for %zu\n";
    goto LABEL_11;
  }
  if (FreeSpace < 4)
    goto LABEL_10;
  if (!HDLCFrameInject())
  {
LABEL_4:
    v11 = "Failed to inject\n";
LABEL_11:
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)v11, v5, v6, v7, v8, v9, v10, v19);
    return 0;
  }
LABEL_7:
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetTxPowerExtCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v12, v13, v14, v15, v16, v17, 2);
    return 0;
  }
  if (a2 > 7)
    return 0;
  HDLCFrameInjectUnsignedShort();
  return 1;
}

uint64_t ETLMaverickParseGetTxPowerExtResponse(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;

  *(_QWORD *)a3 = 0;
  v5 = capabilities::etl::maverickTxPowerUsesRFSubsys((capabilities::etl *)a1);
  v12 = a1[2];
  if (v5)
  {
    if (v12 >= 4)
    {
      v13 = *(unsigned int **)a1;
      v14 = **(_DWORD **)a1;
      v15 = v14;
      if (v14 == 75)
      {
        v16 = BYTE1(v14);
        if (BYTE1(v14) == 251)
        {
          v17 = HIWORD(v14);
          if ((_DWORD)v17 != 16)
            goto LABEL_17;
          goto LABEL_11;
        }
LABEL_16:
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v6, v7, v8, v9, v10, v11, v16);
        return 0;
      }
LABEL_15:
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v6, v7, v8, v9, v10, v11, v15);
      return 0;
    }
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v6, v7, v8, v9, v10, v11, a1[2]);
    return 0;
  }
  if (v12 < 4)
    goto LABEL_14;
  v13 = *(unsigned int **)a1;
  v18 = **(_DWORD **)a1;
  v15 = v18;
  if (v18 != 75)
    goto LABEL_15;
  v16 = BYTE1(v18);
  if (BYTE1(v18) != 253)
    goto LABEL_16;
  v17 = HIWORD(v18);
  if ((_DWORD)v17 != 8)
  {
LABEL_17:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v6, v7, v8, v9, v10, v11, v17);
    return 0;
  }
LABEL_11:
  if (v12 - 4 <= 9)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxPowerExtResponse", (uint64_t)"response requires %u bytes, got %u\n", v6, v7, v8, v9, v10, v11, 10);
    return 0;
  }
  else if (*((_WORD *)v13 + 2))
  {
    *(_WORD *)a3 = *((_WORD *)v13 + 3);
    *(_WORD *)(a3 + 2) = *((_WORD *)v13 + 4);
    *(_WORD *)(a3 + 4) = *((_WORD *)v13 + 5);
    *(_WORD *)(a3 + 6) = *((_WORD *)v13 + 6);
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxPowerExtResponse", (uint64_t)"Status was %u\n", v6, v7, v8, v9, v10, v11, 0);
    return 0;
  }
}

uint64_t ETLMaverickCreateGetTxPowerCapCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetTxPowerCapCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      HDLCFrameInjectUnsignedShort();
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseGetTxPowerCapResponse(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _WORD *v10;
  unsigned int v11;
  uint64_t v12;

  *(_WORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = 0;
  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        v12 = HIWORD(v11);
        if ((_DWORD)v12 == 23)
        {
          if (v9 <= 7)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxPowerCapResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 8);
            return 0;
          }
          else if (v10[2])
          {
            *(_WORD *)a2 = v10[3];
            *(_WORD *)(a2 + 2) = v10[4];
            *(_WORD *)(a2 + 4) = v10[5];
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxPowerCapResponse", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, 0);
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateGetMaxTxPowerCommand(capabilities::etl *a1)
{
  int v1;
  uint64_t FreeSpace;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;

  v1 = capabilities::etl::maverickTxPowerUsesRFSubsys(a1);
  FreeSpace = HDLCFrameGetFreeSpace();
  if (v1)
  {
    if (FreeSpace >= 4)
    {
      v15 = HDLCFrameInject();
      if ((v15 & 1) != 0)
        return v15;
      goto LABEL_7;
    }
  }
  else if (FreeSpace >= 4)
  {
    v15 = HDLCFrameInject();
    if ((v15 & 1) != 0)
      return v15;
LABEL_7:
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v9, v10, v11, v12, v13, v14, v17);
    return v15;
  }
  _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v3, v4, v5, v6, v7, v8, FreeSpace);
  return 0;
}

uint64_t ETLMaverickParseGetMaxTxPowerResponse(capabilities::etl *a1, _WORD *a2, _WORD *a3)
{
  capabilities::etl *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t result;

  v6 = (capabilities::etl *)capabilities::etl::maverickTxPowerUsesRFSubsys(a1);
  v13 = *((_DWORD *)a1 + 2);
  if ((_DWORD)v6)
  {
    if (v13 >= 4)
    {
      v14 = *(unsigned int **)a1;
      v15 = *v14;
      v16 = *v14;
      if ((_DWORD)v16 == 75)
      {
        v17 = BYTE1(v15);
        if (BYTE1(v15) == 251)
        {
          v18 = HIWORD(v15);
          if ((_DWORD)v18 != 20)
            goto LABEL_20;
          goto LABEL_11;
        }
        goto LABEL_19;
      }
      goto LABEL_18;
    }
LABEL_17:
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v7, v8, v9, v10, v11, v12, *((unsigned int *)a1 + 2));
    return 0;
  }
  if (v13 < 4)
    goto LABEL_17;
  v14 = *(unsigned int **)a1;
  v19 = *v14;
  v16 = *v14;
  if ((_DWORD)v16 != 75)
  {
LABEL_18:
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v7, v8, v9, v10, v11, v12, v16);
    return 0;
  }
  v17 = BYTE1(v19);
  if (BYTE1(v19) != 253)
  {
LABEL_19:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v7, v8, v9, v10, v11, v12, v17);
    return 0;
  }
  v18 = HIWORD(v19);
  if ((_DWORD)v18 != 39)
  {
LABEL_20:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v7, v8, v9, v10, v11, v12, v18);
    return 0;
  }
LABEL_11:
  v20 = v13 - 4;
  if (capabilities::etl::maverickTxPowerUsesRFSubsys(v6))
  {
    if (v20 > 5)
    {
      if (*((_WORD *)v14 + 2))
      {
        result = 0;
        if (a2 && a3)
        {
          *a3 = *((_WORD *)v14 + 3);
          *a2 = *((_WORD *)v14 + 4);
          return 1;
        }
        return result;
      }
LABEL_28:
      _ETLDebugPrint((uint64_t)"ETLMaverickParseGetMaxTxPowerResponse", (uint64_t)"Status was %u\n", v21, v22, v23, v24, v25, v26, 0);
      return 0;
    }
LABEL_27:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetMaxTxPowerResponse", (uint64_t)"response requires %u bytes, got %u\n", v21, v22, v23, v24, v25, v26, 6);
    return 0;
  }
  if (v20 <= 5)
    goto LABEL_27;
  if (!*((_WORD *)v14 + 2))
    goto LABEL_28;
  result = 0;
  if (a2 && a3)
  {
    *a2 = *((_WORD *)v14 + 3);
    *a3 = *((_WORD *)v14 + 4);
    return 1;
  }
  return result;
}

uint64_t ETLMaverickCreateSetAutoAnswerCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v14;
  const char *v15;
  uint64_t v16;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
  }
  else
  {
    if ((HDLCFrameInject() & 1) != 0)
    {
      if (HDLCFrameGetFreeSpace() > 1)
      {
        HDLCFrameInjectUnsignedChar();
        HDLCFrameInjectUnsignedChar();
        return 1;
      }
      v16 = 2;
      v14 = "ETLMaverickCreateSetAutoAnswerCommand";
      v15 = "Not enough room, need %zu, have %u\n";
    }
    else
    {
      v14 = "ETLSubsysAddHeaderInternal";
      v15 = "Failed to inject\n";
    }
    _ETLDebugPrint((uint64_t)v14, (uint64_t)v15, v7, v8, v9, v10, v11, v12, v16);
  }
  return 0;
}

BOOL ETLMaverickParseSetAutoAnswerResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;

  v8 = a1[2];
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        v11 = HIWORD(v10);
        if ((_DWORD)v11 == 40)
        {
          if (v9 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSetAutoAnswerResponse", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else
          {
            return *(_WORD *)(*(_QWORD *)a1 + 4) != 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateWriteDefaultNVsCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickParseWriteDefaultNVsResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;

  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v8 = **a1;
    if (v8 == 75)
    {
      if (BYTE1(v8) == 253)
      {
        v9 = HIWORD(v8);
        if ((_DWORD)v9 == 25)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v9);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v8));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateWriteFactoryDefaultNVsCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickParseWriteFactoryDefaultNVsResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;

  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v8 = **a1;
    if (v8 == 75)
    {
      if (BYTE1(v8) == 254)
      {
        v9 = HIWORD(v8);
        if ((_DWORD)v9 == 27)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v9);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v8));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateWriteFactoryFATPDefaultNVsCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickParseWriteFactoryFATPDefaultNVsResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;

  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v8 = **a1;
    if (v8 == 75)
    {
      if (BYTE1(v8) == 254)
      {
        v9 = HIWORD(v8);
        if ((_DWORD)v9 == 39)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v9);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v8));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateIsSimPresentCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickParseIsSimPresentResponse(int **a1, BOOL *a2, BOOL *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIsSimPresentResponse", (uint64_t)"failed parsing factory response from frame\n", v14, v15, v16, v17, v18, v19, v21);
    return 0;
  }
  v10 = *a1;
  v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_12;
  }
  if (BYTE1(v11) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_12;
  }
  v12 = HIWORD(v11);
  if ((_DWORD)v12 != 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_12;
  }
  if (v9 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIsSimPresentResponse", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 6);
    return 0;
  }
  else if (*((_WORD *)v10 + 2))
  {
    *a3 = *((_WORD *)v10 + 3) != 0;
    *a2 = *((unsigned __int16 *)v10 + 4) != 0;
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIsSimPresentResponse", (uint64_t)"SIM Command failed\n", (uint64_t)a3, a4, a5, a6, a7, a8, v20);
    return 0;
  }
}

BOOL ETLMaverickParseGetTxAntenna(uint64_t a1, unsigned int *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unsigned int v14;
  _BOOL8 result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v8 = *a3;
  v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxAntenna", (uint64_t)"failed parsing BSP response from frame\n", v16, v17, v18, v19, v20, v21, v22);
    return 0;
  }
  v10 = *(_DWORD *)(*(_QWORD *)a1 + v8);
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v10);
    goto LABEL_12;
  }
  v11 = v8 + 4;
  *a3 = v8 + 4;
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v10));
    goto LABEL_12;
  }
  v12 = HIWORD(v10);
  if ((_DWORD)v12 != 24)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_12;
  }
  if (*(_DWORD *)(a1 + 8) - v11 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxAntenna", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  else
  {
    v13 = (unsigned __int16 *)(*(_QWORD *)a1 + v11);
    if (*v13 == 1)
    {
      v14 = v13[1];
      result = v14 < 5;
      *a2 = v14;
      *a3 = v8 + 8;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxAntenna", (uint64_t)"status = %d\n", (uint64_t)a3, a4, a5, a6, a7, a8, *v13);
      return 0;
    }
  }
  return result;
}

uint64_t ETLMaverickCreateGetGPIOCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetGPIOCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

BOOL ETLMaverickParseGetGPIOResponse(int **a1, int a2, BOOL *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOResponse", (uint64_t)"failed parsing factory response from frame\n", v15, v16, v17, v18, v19, v20, v22);
    return 0;
  }
  v10 = *a1;
  v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_12;
  }
  if (BYTE1(v11) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_12;
  }
  v12 = HIWORD(v11);
  if ((_DWORD)v12 != 19)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_12;
  }
  if (v9 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOResponse", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 6);
    return 0;
  }
  else if (*((_WORD *)v10 + 2))
  {
    v13 = *((unsigned __int16 *)v10 + 3);
    *a3 = *((unsigned __int16 *)v10 + 4) != 0;
    return v13 == a2;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOResponse", (uint64_t)"Get GPIO Status Command failed\n", (uint64_t)a3, a4, a5, a6, a7, a8, v21);
    return 0;
  }
}

uint64_t ETLMaverickCreateSetGPIOCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v14;
  const char *v15;
  uint64_t v16;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    v14 = "ETLSubsysAddHeaderInternal";
    v15 = "Failed to inject\n";
LABEL_9:
    _ETLDebugPrint((uint64_t)v14, (uint64_t)v15, v7, v8, v9, v10, v11, v12, v16);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    v16 = 4;
    v14 = "ETLMaverickCreateSetGPIOCommand";
    v15 = "Not enough room, need %zu, have %u\n";
    goto LABEL_9;
  }
  if (HDLCFrameInjectUnsignedShort())
    return HDLCFrameInjectUnsignedShort();
  return 0;
}

BOOL ETLMaverickParseSetGPIOResponse(int **a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOResponse", (uint64_t)"failed parsing factory response from frame\n", v14, v15, v16, v17, v18, v19, v21);
    return 0;
  }
  v10 = *a1;
  v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_12;
  }
  if (BYTE1(v11) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_12;
  }
  v12 = HIWORD(v11);
  if ((_DWORD)v12 != 20)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_12;
  }
  if (v9 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOResponse", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 6);
    return 0;
  }
  else if (*((_WORD *)v10 + 2))
  {
    return *((unsigned __int16 *)v10 + 3) == a2;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOResponse", (uint64_t)"Set GPIO State Command failed\n", a3, a4, a5, a6, a7, a8, v20);
    return 0;
  }
}

uint64_t ETLMaverickCreateBackupBoardSNCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

BOOL ETLMaverickParseBackupBoardSNResponse(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 254)
      {
        v12 = HIWORD(v11);
        if ((_DWORD)v12 == 12)
        {
          if (v9 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLCheckPayloadLength", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else if (*((_WORD *)v10 + 2) == 20)
          {
            return *((_WORD *)v10 + 3) == 0;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseBackupBoardSNResponse", (uint64_t)"Backup Board SN response does not match MAV_SEC_BKP_BOARD_SN [%d]. Received [%d]\n", a3, a4, a5, a6, a7, a8, 20);
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateAnntennaSKU(int *a1, unsigned __int8 a2, int a3)
{
  int v3;
  int v4;

  if ((a2 & ((a3 - 1) < 2)) == 1)
  {
    if (a3 == 1)
      v3 = 3;
    else
      v3 = 4;
    if (a3 == 1)
      v4 = 1;
    else
      v4 = 2;
    if ((a2 & 2) == 0)
      v3 = v4;
    *a1 = v3;
  }
  return a2 & ((a3 - 1) < 2);
}

uint64_t ETLMaverickCreateSetAntennaSKUCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseSetAntennaSKUResponse(int **a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
  }
  else
  {
    v10 = *a1;
    v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        v12 = HIWORD(v11);
        if ((_DWORD)v12 == 38)
        {
          if (v9 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSetAntennaSKUResponse", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
          }
          else if (*((_WORD *)v10 + 2) == 1)
          {
            if (*((unsigned __int16 *)v10 + 3) == a2)
              return 1;
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSetAntennaSKUResponse", (uint64_t)"Received SKU %u mismatches sent %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 3));
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    }
  }
  return 0;
}

uint64_t ETLMaverickCreateSetIMEISwVersionCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace())
    {
      return HDLCFrameInjectUnsignedChar();
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 1);
      return 0;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseIMEISwVersionResponse(int **a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        v12 = HIWORD(v11);
        if ((_DWORD)v12 == (_DWORD)a3)
        {
          if (v9 <= 2)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEISwVersionResponse", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*((_WORD *)v10 + 2) == 1)
          {
            *a2 = *((_BYTE *)v10 + 6);
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEISwVersionResponse", (uint64_t)"Received response with failure status [%d]\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 2));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateGetHWConfigIDCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickParseGetHWConfigIDResponse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v8 = *(_DWORD *)(a1 + 8);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a1 + 8));
LABEL_15:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetHWConfigIDResponse", (uint64_t)"failed parsing factory response from frame\n", v13, v14, v15, v16, v17, v18, v20);
    return 0;
  }
  v10 = *(unsigned int **)a1;
  v11 = **(_DWORD **)a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_15;
  }
  if (BYTE1(v11) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_15;
  }
  if (v11 >= 0x10000)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v11));
    goto LABEL_15;
  }
  if (v9 <= 0x17)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetHWConfigIDResponse", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 24);
    return 0;
  }
  else if (*((_WORD *)v10 + 2))
  {
    if (a2)
    {
      *(_DWORD *)a2 = *(unsigned int *)((char *)v10 + 6);
      *(_WORD *)(a2 + 4) = *((_WORD *)v10 + 5);
      *(_WORD *)(a2 + 6) = *((_WORD *)v10 + 6);
      *(_WORD *)(a2 + 8) = *((_WORD *)v10 + 7);
      *(_WORD *)(a2 + 10) = *((_WORD *)v10 + 8);
      *(_WORD *)(a2 + 12) = *((_WORD *)v10 + 9);
      *(_WORD *)(a2 + 14) = *((_WORD *)v10 + 10);
      if (v9 < 0x1A)
        *(_WORD *)(a2 + 22) = -1;
      else
        *(_WORD *)(a2 + 22) = *((_WORD *)v10 + 14);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetHWConfigIDResponse", (uint64_t)"Get HW Config ID Command failed\n", a3, a4, a5, a6, a7, a8, v19);
    return 0;
  }
}

uint64_t ETLMaverickCreateCalibrationCheckCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickCreateCalibrationCheckCommandV2()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLMaverickParseCalibrationCheckResonse(capabilities::radio *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseCalibrationCheckResonse", (uint64_t)"Parsing BSP Response Header failed.\n", v19, v20, v21, v22, v23, v24, v25);
    return 0;
  }
  v9 = **(_DWORD **)a1;
  if (v9 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_14;
  }
  if (BYTE1(v9) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
    goto LABEL_14;
  }
  v10 = HIWORD(v9);
  if ((_DWORD)v10 != 48)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
    goto LABEL_14;
  }
  if (capabilities::radio::mavLegacy(a1))
    v17 = 46;
  else
    v17 = 4;
  if (*((_DWORD *)a1 + 2) - 4 >= v17)
  {
    memcpy(a2, (const void *)(*(_QWORD *)a1 + 4), v17);
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseCalibrationCheckResonse", (uint64_t)"Received response has only %u bytes, need %u\n", v17, v12, v13, v14, v15, v16, (*((_DWORD *)a1 + 2) - 4));
    return 0;
  }
}

uint64_t ETLMaverickParseCalibrationCheckResponseV2(capabilities::radio *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseCalibrationCheckResponseV2", (uint64_t)"Parsing RF Response Header failed.\n", v18, v19, v20, v21, v22, v23, v24);
    return 0;
  }
  v9 = **(_DWORD **)a1;
  if (v9 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_14;
  }
  if (BYTE1(v9) != 251)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
    goto LABEL_14;
  }
  if ((_DWORD)a3 != HIWORD(v9))
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v9));
    goto LABEL_14;
  }
  if (capabilities::radio::mavLegacy(a1))
    v16 = 46;
  else
    v16 = 4;
  if (*((_DWORD *)a1 + 2) - 4 >= v16)
  {
    memcpy(a2, (const void *)(*(_QWORD *)a1 + 4), v16);
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseCalibrationCheckResponseV2", (uint64_t)"Received response has only %u bytes, need %u\n", v16, v11, v12, v13, v14, v15, (*((_DWORD *)a1 + 2) - 4));
    return 0;
  }
}

uint64_t ETLMaverickStartRSSI(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD v28[2];
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  unsigned int v33;

  v30 = 0u;
  v31 = 0u;
  v32 = 0;
  memset(v28, 0, sizeof(v28));
  v29 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickStartRSSI", (uint64_t)"Failed to create command frame\n", v7, v8, v9, v10, v11, v12, *(uint64_t *)&v28[0]);
LABEL_19:
    v26 = 0;
    goto LABEL_20;
  }
  if (!ETLMaverickCreateStartRSSICommand())
    goto LABEL_19;
  v13 = malloc((2 * DWORD2(v30) + 32));
  if (!v13)
    goto LABEL_19;
  v14 = v13;
  v15 = HDLCFrameEncode();
  if (!(_DWORD)v15)
    goto LABEL_21;
  v16 = v15;
  v33 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v14, v15);
  if (!*a1)
  {
LABEL_21:
    free(v14);
    goto LABEL_19;
  }
  v17 = ((uint64_t (*)(_QWORD *, void *, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v14, v16, &v33, 1, a5, 0);
  v18 = v33;
  free(v14);
  if (v17)
    v19 = v18 == (_DWORD)v16;
  else
    v19 = 0;
  if (!v19)
    goto LABEL_19;
  LOBYTE(v33) = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v20 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v28, (uint64_t)&_ETLResponseRingBuffer, &v33, a5);
  v26 = 0;
  if (v20 && v33 == 75)
  {
    v33 = 0;
    v26 = ETLMaverickParseRSSICommandResponse((uint64_t)v28, &v33, 1, v21, v22, v23, v24, v25);
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v26;
}

uint64_t ETLMaverickStopRSSI(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v25[2];
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  unsigned int v30;

  v27 = 0u;
  v28 = 0u;
  v29 = 0;
  memset(v25, 0, sizeof(v25));
  v26 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickStopRSSI", (uint64_t)"Failed to create command frame\n", v4, v5, v6, v7, v8, v9, *(uint64_t *)&v25[0]);
LABEL_19:
    v23 = 0;
    goto LABEL_20;
  }
  if (!ETLMaverickCreateStopRSSICommand())
    goto LABEL_19;
  v10 = malloc((2 * DWORD2(v27) + 32));
  if (!v10)
    goto LABEL_19;
  v11 = v10;
  v12 = HDLCFrameEncode();
  if (!(_DWORD)v12)
    goto LABEL_21;
  v13 = v12;
  v30 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
  if (!*a1)
  {
LABEL_21:
    free(v11);
    goto LABEL_19;
  }
  v14 = ((uint64_t (*)(_QWORD *, void *, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v11, v13, &v30, 1, a2, 0);
  v15 = v30;
  free(v11);
  if (v14)
    v16 = v15 == (_DWORD)v13;
  else
    v16 = 0;
  if (!v16)
    goto LABEL_19;
  LOBYTE(v30) = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v17 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &v30, a2);
  v23 = 0;
  if (v17 && v30 == 75)
  {
    v30 = 0;
    v23 = ETLMaverickParseRSSICommandResponse((uint64_t)v25, &v30, 1, v18, v19, v20, v21, v22);
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v23;
}

uint64_t ETLMaverickReportRSSI(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v25[2];
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  unsigned int v30;
  int v31;

  v30 = 0;
  v27 = 0u;
  v28 = 0u;
  v29 = 0;
  memset(v25, 0, sizeof(v25));
  v26 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickReportRSSI", (uint64_t)"Failed to create command frame\n", v4, v5, v6, v7, v8, v9, *(uint64_t *)&v25[0]);
LABEL_19:
    v23 = 0;
    goto LABEL_20;
  }
  if (!ETLMaverickCreateReportRSSICommand())
    goto LABEL_19;
  v10 = malloc((2 * DWORD2(v27) + 32));
  if (!v10)
    goto LABEL_19;
  v11 = v10;
  v12 = HDLCFrameEncode();
  if (!(_DWORD)v12)
    goto LABEL_21;
  v13 = v12;
  v31 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
  if (!*a1)
  {
LABEL_21:
    free(v11);
    goto LABEL_19;
  }
  v14 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v11, v13, &v31, 1, a2, 0);
  v15 = v31;
  free(v11);
  if (v14)
    v16 = v15 == (_DWORD)v13;
  else
    v16 = 0;
  if (!v16)
    goto LABEL_19;
  LOBYTE(v31) = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v17 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &v31, a2);
  v23 = 0;
  if (v17 && v31 == 75)
    v23 = ETLMaverickParseRSSICommandResponse((uint64_t)v25, &v30, 1, v18, v19, v20, v21, v22);
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v23;
}

void *ETLMaverickSetAPWake(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v30 = "ETLMaverickSetAPWake";
    v31 = "Failed to create command frame\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v5, v6, v7, v8, v9, v10, v33);
    goto LABEL_22;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
LABEL_22:
    v18 = 0;
    goto LABEL_23;
  }
  v39 = 916811;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v30 = "ETLSubsysAddHeaderInternal";
    v31 = "Failed to inject\n";
    goto LABEL_21;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v33 = 2;
    v30 = "ETLMaverickCreateAPWakeCommand";
    v31 = "Not enough room, need %zu, have %u\n";
    goto LABEL_21;
  }
  HDLCFrameInjectUnsignedShort();
  v18 = malloc((2 * DWORD2(v36) + 32));
  if (!v18)
    goto LABEL_23;
  v19 = HDLCFrameEncode();
  if (!(_DWORD)v19)
    goto LABEL_24;
  v20 = v19;
  v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
  if (!*a1)
  {
LABEL_24:
    free(v18);
    goto LABEL_22;
  }
  v21 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v18, v20, &v39, 1, a3, 0);
  v22 = v39;
  free(v18);
  v18 = 0;
  if (v21 && v22 == (_DWORD)v20)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v18 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      v18 = (void *)ETLMaverickParseAPWakeResponse((unsigned int *)v34, v23, v24, v25, v26, v27, v28, v29);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return v18;
}

uint64_t ETLMaverickEnterEmergencyDownloadMode(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v30 = "ETLMaverickEnterEmergencyDownloadMode";
    v31 = "Failed to create command frame\n";
LABEL_23:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v4, v5, v6, v7, v8, v9, v33);
    goto LABEL_24;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_24;
  }
  v39 = 982347;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v30 = "ETLSubsysAddHeaderInternal";
    v31 = "Failed to inject\n";
    goto LABEL_23;
  }
  v17 = (uint64_t)malloc((2 * DWORD2(v36) + 32));
  if (v17)
  {
    v18 = HDLCFrameEncode();
    if (!(_DWORD)v18)
      goto LABEL_26;
    v19 = v18;
    v39 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
    if (!*a1)
    {
LABEL_26:
      free((void *)v17);
      goto LABEL_24;
    }
    v20 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v17, v19, &v39, 1, a2, 0);
    v21 = v39;
    free((void *)v17);
    v17 = 0;
    if (v20)
    {
      if (v21 == (_DWORD)v19)
      {
        LOBYTE(v39) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v17 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2))
        {
          if (v39 == 75)
          {
            if (DWORD2(v34[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v22, v23, v24, v25, v26, v27, DWORD2(v34[0]));
            }
            else
            {
              v28 = **(_DWORD **)&v34[0];
              if (**(_DWORD **)&v34[0] == 75)
              {
                if (BYTE1(v28) == 253)
                {
                  v29 = HIWORD(v28);
                  if ((_DWORD)v29 == 14)
                  {
                    v17 = 1;
                    goto LABEL_25;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, v29);
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, BYTE1(v28));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, **(_DWORD **)&v34[0]);
              }
            }
LABEL_24:
            v17 = 0;
          }
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

void *ETLMaverickGetTxPower(_QWORD *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Uplink;
  int v13;
  uint64_t FreeSpace;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  void *TxPowerExtResponse;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  _OWORD v37[2];
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  int v42;

  v39 = 0u;
  v40 = 0u;
  v41 = 0;
  memset(v37, 0, sizeof(v37));
  v38 = 0;
  if (!a3 || (Uplink = HDLCFrameCreateUplink(), (Uplink & 1) == 0))
  {
    v21 = "ETLMaverickGetTxPower";
    v22 = "Failed to create command frame\n";
    goto LABEL_8;
  }
  v13 = capabilities::etl::maverickTxPowerUsesRFSubsys((capabilities::etl *)Uplink);
  FreeSpace = HDLCFrameGetFreeSpace();
  if (!v13)
  {
    if (FreeSpace >= 4)
    {
      v42 = 589131;
      if (!HDLCFrameInject())
        goto LABEL_6;
      goto LABEL_13;
    }
LABEL_24:
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v15, v16, v17, v18, v19, v20, FreeSpace);
    goto LABEL_9;
  }
  if (FreeSpace < 4)
    goto LABEL_24;
  v42 = 1112907;
  if (!HDLCFrameInject())
  {
LABEL_6:
    v21 = "ETLSubsysAddHeaderInternal";
    v22 = "Failed to inject\n";
LABEL_8:
    _ETLDebugPrint((uint64_t)v21, (uint64_t)v22, a3, a4, a5, a6, a7, a8, v36);
    goto LABEL_9;
  }
LABEL_13:
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetTxPowerExtCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v25, v26, v27, v28, v29, v30, 2);
    goto LABEL_9;
  }
  if (a2 > 7)
  {
LABEL_9:
    TxPowerExtResponse = 0;
    goto LABEL_10;
  }
  HDLCFrameInjectUnsignedShort();
  TxPowerExtResponse = malloc((2 * DWORD2(v39) + 32));
  if (!TxPowerExtResponse)
    goto LABEL_10;
  v31 = HDLCFrameEncode();
  if (!(_DWORD)v31)
    goto LABEL_26;
  v32 = v31;
  v42 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, TxPowerExtResponse, v31);
  if (!*a1)
  {
LABEL_26:
    free(TxPowerExtResponse);
    goto LABEL_9;
  }
  v33 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, TxPowerExtResponse, v32, &v42, 1, a4, 0);
  v34 = v42;
  free(TxPowerExtResponse);
  TxPowerExtResponse = 0;
  if (v33 && v34 == (_DWORD)v32)
  {
    if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v37, a4))
    {
      TxPowerExtResponse = (void *)ETLMaverickParseGetTxPowerExtResponse((unsigned int *)v37, v35, a3);
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_10:
  HDLCFrameFree();
  HDLCFrameFree();
  return TxPowerExtResponse;
}

void *ETLMaverickGetTxPowerCap(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *TxPowerCapResponse;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  const char *v36;
  uint64_t v38;
  _OWORD v39[2];
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  int v44;

  v41 = 0u;
  v42 = 0u;
  v43 = 0;
  memset(v39, 0, sizeof(v39));
  v40 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    v35 = "ETLMaverickGetTxPowerCap";
    v36 = "Failed to create command frame\n";
LABEL_19:
    _ETLDebugPrint((uint64_t)v35, (uint64_t)v36, a3, a4, a5, a6, a7, a8, v38);
LABEL_20:
    TxPowerCapResponse = 0;
    goto LABEL_21;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_20;
  }
  v44 = 1572171;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v35 = "ETLSubsysAddHeaderInternal";
    v36 = "Failed to inject\n";
    goto LABEL_19;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetTxPowerCapCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v18, v19, v20, v21, v22, v23, 2);
    goto LABEL_20;
  }
  HDLCFrameInjectUnsignedShort();
  TxPowerCapResponse = malloc((2 * DWORD2(v41) + 32));
  if (!TxPowerCapResponse)
    goto LABEL_21;
  v25 = HDLCFrameEncode();
  if (!(_DWORD)v25)
    goto LABEL_25;
  v26 = v25;
  v44 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, TxPowerCapResponse, v25);
  if (!*a1)
  {
LABEL_25:
    free(TxPowerCapResponse);
    goto LABEL_20;
  }
  v27 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, TxPowerCapResponse, v26, &v44, 1, a3, 0);
  v28 = v44;
  free(TxPowerCapResponse);
  TxPowerCapResponse = 0;
  if (v27 && v28 == (_DWORD)v26)
  {
    LOBYTE(v44) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    TxPowerCapResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v39, (uint64_t)&_ETLResponseRingBuffer, &v44, a3)&& v44 == 75)
    {
      TxPowerCapResponse = (void *)ETLMaverickParseGetTxPowerCapResponse((int **)v39, a2, v29, v30, v31, v32, v33, v34);
    }
  }
LABEL_21:
  HDLCFrameFree();
  HDLCFrameFree();
  return TxPowerCapResponse;
}

uint64_t ETLMaverickWriteFATPDefaultNVs(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v30 = "ETLMaverickWriteFATPDefaultNVs";
    v31 = "Failed to create command frame\n";
LABEL_23:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v4, v5, v6, v7, v8, v9, v33);
    goto LABEL_24;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_24;
  }
  v39 = 2621003;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v30 = "ETLSubsysAddHeaderInternal";
    v31 = "Failed to inject\n";
    goto LABEL_23;
  }
  v17 = (uint64_t)malloc((2 * DWORD2(v36) + 32));
  if (v17)
  {
    v18 = HDLCFrameEncode();
    if (!(_DWORD)v18)
      goto LABEL_26;
    v19 = v18;
    v39 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
    if (!*a1)
    {
LABEL_26:
      free((void *)v17);
      goto LABEL_24;
    }
    v20 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v17, v19, &v39, 1, a2, 0);
    v21 = v39;
    free((void *)v17);
    v17 = 0;
    if (v20)
    {
      if (v21 == (_DWORD)v19)
      {
        LOBYTE(v39) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v17 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2))
        {
          if (v39 == 75)
          {
            if (DWORD2(v34[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v22, v23, v24, v25, v26, v27, DWORD2(v34[0]));
            }
            else
            {
              v28 = **(_DWORD **)&v34[0];
              if (**(_DWORD **)&v34[0] == 75)
              {
                if (BYTE1(v28) == 254)
                {
                  v29 = HIWORD(v28);
                  if ((_DWORD)v29 == 39)
                  {
                    v17 = 1;
                    goto LABEL_25;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, v29);
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, BYTE1(v28));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, **(_DWORD **)&v34[0]);
              }
            }
LABEL_24:
            v17 = 0;
          }
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

uint64_t ETLMaverickWriteDefaultNVs(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v30 = "ETLMaverickWriteDefaultNVs";
    v31 = "Failed to create command frame\n";
LABEL_23:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v4, v5, v6, v7, v8, v9, v33);
    goto LABEL_24;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_24;
  }
  v39 = 1703243;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v30 = "ETLSubsysAddHeaderInternal";
    v31 = "Failed to inject\n";
    goto LABEL_23;
  }
  v17 = (uint64_t)malloc((2 * DWORD2(v36) + 32));
  if (v17)
  {
    v18 = HDLCFrameEncode();
    if (!(_DWORD)v18)
      goto LABEL_26;
    v19 = v18;
    v39 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
    if (!*a1)
    {
LABEL_26:
      free((void *)v17);
      goto LABEL_24;
    }
    v20 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v17, v19, &v39, 1, a2, 0);
    v21 = v39;
    free((void *)v17);
    v17 = 0;
    if (v20)
    {
      if (v21 == (_DWORD)v19)
      {
        LOBYTE(v39) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v17 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2))
        {
          if (v39 == 75)
          {
            if (DWORD2(v34[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v22, v23, v24, v25, v26, v27, DWORD2(v34[0]));
            }
            else
            {
              v28 = **(_DWORD **)&v34[0];
              if (**(_DWORD **)&v34[0] == 75)
              {
                if (BYTE1(v28) == 253)
                {
                  v29 = HIWORD(v28);
                  if ((_DWORD)v29 == 25)
                  {
                    v17 = 1;
                    goto LABEL_25;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, v29);
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, BYTE1(v28));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, **(_DWORD **)&v34[0]);
              }
            }
LABEL_24:
            v17 = 0;
          }
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

uint64_t ETLMaverickWriteFactoryDefaultNVs(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v30 = "ETLMaverickWriteFactoryDefaultNVs";
    v31 = "Failed to create command frame\n";
LABEL_23:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v4, v5, v6, v7, v8, v9, v33);
    goto LABEL_24;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_24;
  }
  v39 = 1834571;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v30 = "ETLSubsysAddHeaderInternal";
    v31 = "Failed to inject\n";
    goto LABEL_23;
  }
  v17 = (uint64_t)malloc((2 * DWORD2(v36) + 32));
  if (v17)
  {
    v18 = HDLCFrameEncode();
    if (!(_DWORD)v18)
      goto LABEL_26;
    v19 = v18;
    v39 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
    if (!*a1)
    {
LABEL_26:
      free((void *)v17);
      goto LABEL_24;
    }
    v20 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v17, v19, &v39, 1, a2, 0);
    v21 = v39;
    free((void *)v17);
    v17 = 0;
    if (v20)
    {
      if (v21 == (_DWORD)v19)
      {
        LOBYTE(v39) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v17 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2))
        {
          if (v39 == 75)
          {
            if (DWORD2(v34[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v22, v23, v24, v25, v26, v27, DWORD2(v34[0]));
            }
            else
            {
              v28 = **(_DWORD **)&v34[0];
              if (**(_DWORD **)&v34[0] == 75)
              {
                if (BYTE1(v28) == 254)
                {
                  v29 = HIWORD(v28);
                  if ((_DWORD)v29 == 27)
                  {
                    v17 = 1;
                    goto LABEL_25;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, v29);
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, BYTE1(v28));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, **(_DWORD **)&v34[0]);
              }
            }
LABEL_24:
            v17 = 0;
          }
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

void *ETLMaverickIsSimPresentExt(_QWORD *a1, BOOL *a2, BOOL *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t FreeSpace;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *IsSimPresentResponse;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  const char *v33;
  uint64_t v35;
  _OWORD v36[2];
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  int v41;

  v38 = 0u;
  v39 = 0u;
  v40 = 0;
  memset(v36, 0, sizeof(v36));
  v37 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v32 = "ETLMaverickIsSimPresentExt";
    v33 = "Failed to create command frame\n";
LABEL_20:
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v9, v10, v11, v12, v13, v14, v35);
    goto LABEL_21;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v16, v17, v18, v19, v20, v21, FreeSpace);
    goto LABEL_21;
  }
  v41 = 130635;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v32 = "ETLSubsysAddHeaderInternal";
    v33 = "Failed to inject\n";
    goto LABEL_20;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_21:
    IsSimPresentResponse = 0;
    goto LABEL_22;
  }
  IsSimPresentResponse = malloc((2 * DWORD2(v38) + 32));
  if (!IsSimPresentResponse)
    goto LABEL_22;
  v23 = HDLCFrameEncode();
  if (!(_DWORD)v23)
    goto LABEL_23;
  v24 = v23;
  v41 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, IsSimPresentResponse, v23);
  if (!*a1)
  {
LABEL_23:
    free(IsSimPresentResponse);
    goto LABEL_21;
  }
  v25 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, IsSimPresentResponse, v24, &v41, 1, a5, 0);
  v26 = v41;
  free(IsSimPresentResponse);
  IsSimPresentResponse = 0;
  if (v25 && v26 == (_DWORD)v24)
  {
    LOBYTE(v41) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    IsSimPresentResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v41, a5)&& v41 == 75)
    {
      IsSimPresentResponse = (void *)ETLMaverickParseIsSimPresentResponse((int **)v36, a2, a3, v27, v28, v29, v30, v31);
    }
  }
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return IsSimPresentResponse;
}

void *ETLMaverickSetTxAntenna(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v30 = "ETLMaverickSetTxAntenna";
    v31 = "Failed to create command frame\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v6, v7, v8, v9, v10, v11, v33);
    goto LABEL_22;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
LABEL_22:
    v19 = 0;
    goto LABEL_23;
  }
  v39 = 458059;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v30 = "ETLSubsysAddHeaderInternal";
    v31 = "Failed to inject\n";
    goto LABEL_21;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v33 = 2;
    v30 = "ETLMaverickCreateTxModeSwitchCommand";
    v31 = "Not enough room, need %zu, have %u\n";
    goto LABEL_21;
  }
  HDLCFrameInjectUnsignedShort();
  v19 = malloc((2 * DWORD2(v36) + 32));
  if (!v19)
    goto LABEL_23;
  v20 = HDLCFrameEncode();
  if (!(_DWORD)v20)
    goto LABEL_24;
  v21 = v20;
  v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
  if (!*a1)
  {
LABEL_24:
    free(v19);
    goto LABEL_22;
  }
  v22 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v19, v21, &v39, 1, a3, 0);
  v23 = v39;
  free(v19);
  v19 = 0;
  if (v22 && v23 == (_DWORD)v21)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v19 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      v19 = (void *)ETLMaverickParseTxModeSwitchResponse((int **)v34, a2, v24, v25, v26, v27, v28, v29);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return v19;
}

void *ETLMaverickGetTxAntenna(_QWORD *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *TxAntenna;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  uint64_t v31;
  _OWORD v32[2];
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  int v37;
  int v38;

  v37 = 0;
  v34 = 0u;
  v35 = 0u;
  v36 = 0;
  memset(v32, 0, sizeof(v32));
  v33 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    v28 = "ETLMaverickGetTxAntenna";
    v29 = "Failed to create command frame\n";
LABEL_18:
    _ETLDebugPrint((uint64_t)v28, (uint64_t)v29, a3, a4, a5, a6, a7, a8, v31);
LABEL_19:
    TxAntenna = 0;
    goto LABEL_20;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_19;
  }
  v38 = 1637707;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v28 = "ETLSubsysAddHeaderInternal";
    v29 = "Failed to inject\n";
    goto LABEL_18;
  }
  TxAntenna = malloc((2 * DWORD2(v34) + 32));
  if (!TxAntenna)
    goto LABEL_20;
  v19 = HDLCFrameEncode();
  if (!(_DWORD)v19)
    goto LABEL_23;
  v20 = v19;
  v38 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, TxAntenna, v19);
  if (!*a1)
  {
LABEL_23:
    free(TxAntenna);
    goto LABEL_19;
  }
  v21 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, TxAntenna, v20, &v38, 1, a3, 0);
  v22 = v38;
  free(TxAntenna);
  TxAntenna = 0;
  if (v21 && v22 == (_DWORD)v20)
  {
    LOBYTE(v38) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    TxAntenna = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v32, (uint64_t)&_ETLResponseRingBuffer, &v38, a3)&& v38 == 75)
    {
      TxAntenna = (void *)ETLMaverickParseGetTxAntenna((uint64_t)v32, a2, &v37, v23, v24, v25, v26, v27);
    }
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return TxAntenna;
}

void *ETLMaverickGetGPIOState(_QWORD *a1, int a2, BOOL *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *GPIOResponse;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  const char *v36;
  uint64_t v38;
  _OWORD v39[2];
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  int v44;

  v41 = 0u;
  v42 = 0u;
  v43 = 0;
  memset(v39, 0, sizeof(v39));
  v40 = 0;
  if (!a3 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    v35 = "ETLMaverickGetGPIOState";
    v36 = "Failed to create command frame\n";
LABEL_17:
    _ETLDebugPrint((uint64_t)v35, (uint64_t)v36, (uint64_t)a3, a4, a5, a6, a7, a8, v38);
    goto LABEL_18;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_18;
  }
  v44 = 1310283;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v35 = "ETLSubsysAddHeaderInternal";
    v36 = "Failed to inject\n";
    goto LABEL_17;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetGPIOCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v19, v20, v21, v22, v23, v24, 2);
    goto LABEL_18;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_18:
    GPIOResponse = 0;
    goto LABEL_19;
  }
  GPIOResponse = malloc((2 * DWORD2(v41) + 32));
  if (GPIOResponse)
  {
    v26 = HDLCFrameEncode();
    if (!(_DWORD)v26)
      goto LABEL_23;
    v27 = v26;
    v44 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, GPIOResponse, v26);
    if (!*a1)
    {
LABEL_23:
      free(GPIOResponse);
      goto LABEL_18;
    }
    v28 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, GPIOResponse, v27, &v44, 1, a4, 0);
    v29 = v44;
    free(GPIOResponse);
    GPIOResponse = 0;
    if (v28)
    {
      if (v29 == (_DWORD)v27)
      {
        if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v39, a4))
        {
          GPIOResponse = (void *)ETLMaverickParseGetGPIOResponse((int **)v39, a2, a3, v30, v31, v32, v33, v34);
          goto LABEL_19;
        }
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  HDLCFrameFree();
  HDLCFrameFree();
  return GPIOResponse;
}

void *ETLMaverickSetGPIOState(_QWORD *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t FreeSpace;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  const char *v32;
  uint64_t v34;
  _OWORD v35[2];
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  int v40;

  v37 = 0u;
  v38 = 0u;
  v39 = 0;
  memset(v35, 0, sizeof(v35));
  v36 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v31 = "ETLMaverickSetGPIOState";
    v32 = "Failed to create command frame\n";
LABEL_20:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v7, v8, v9, v10, v11, v12, v34);
    goto LABEL_21;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
    goto LABEL_21;
  }
  v40 = 1375819;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v31 = "ETLSubsysAddHeaderInternal";
    v32 = "Failed to inject\n";
    goto LABEL_20;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    v34 = 4;
    v31 = "ETLMaverickCreateSetGPIOCommand";
    v32 = "Not enough room, need %zu, have %u\n";
    goto LABEL_20;
  }
  if (!HDLCFrameInjectUnsignedShort() || !HDLCFrameInjectUnsignedShort())
    goto LABEL_21;
  v20 = malloc((2 * DWORD2(v37) + 32));
  if (v20)
  {
    v21 = HDLCFrameEncode();
    if (!(_DWORD)v21)
      goto LABEL_23;
    v22 = v21;
    v40 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v20, v21);
    if (!*a1)
    {
LABEL_23:
      free(v20);
      goto LABEL_21;
    }
    v23 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v20, v22, &v40, 1, a4, 0);
    v24 = v40;
    free(v20);
    v20 = 0;
    if (v23)
    {
      if (v24 == (_DWORD)v22)
      {
        if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v35, a4))
        {
          v20 = (void *)ETLMaverickParseSetGPIOResponse((int **)v35, a2, v25, v26, v27, v28, v29, v30);
          goto LABEL_22;
        }
LABEL_21:
        v20 = 0;
      }
    }
  }
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return v20;
}

void *ETLMaverickBackupBoardSN(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  uint64_t v32;
  _OWORD v33[2];
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  int v38;

  v35 = 0u;
  v36 = 0u;
  v37 = 0;
  memset(v33, 0, sizeof(v33));
  v34 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v29 = "ETLMaverickBackupBoardSN";
    v30 = "Failed to create command frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v29, (uint64_t)v30, v4, v5, v6, v7, v8, v9, v32);
    goto LABEL_23;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_23;
  }
  v38 = 851531;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v29 = "ETLSubsysAddHeaderInternal";
    v30 = "Failed to inject\n";
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v32 = 2;
    v29 = "ETLRequireFreeSpace";
    v30 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_23:
    v17 = 0;
    goto LABEL_24;
  }
  v17 = malloc((2 * DWORD2(v35) + 32));
  if (!v17)
    goto LABEL_24;
  v18 = HDLCFrameEncode();
  if (!(_DWORD)v18)
    goto LABEL_25;
  v19 = v18;
  v38 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
  if (!*a1)
  {
LABEL_25:
    free(v17);
    goto LABEL_23;
  }
  v20 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v17, v19, &v38, 1, a2, 0);
  v21 = v38;
  free(v17);
  v17 = 0;
  if (v20 && v21 == (_DWORD)v19)
  {
    LOBYTE(v38) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v17 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v33, (uint64_t)&_ETLResponseRingBuffer, &v38, a2)&& v38 == 75)
    {
      v17 = (void *)ETLMaverickParseBackupBoardSNResponse((int **)v33, v22, v23, v24, v25, v26, v27, v28);
    }
  }
LABEL_24:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

uint64_t ETLMaverickBackupOrRestoreBBData(uint64_t (**a1)(_QWORD, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD), int a2, uint64_t a3)
{
  uint64_t v3;
  __int16 v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t FreeSpace;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int16 v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  const char *v32;
  const char *v33;
  uint64_t v35;
  _OWORD v36[2];
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  int v41;

  if (a2 <= 13)
  {
    v5 = a2;
    v38 = 0u;
    v39 = 0u;
    v40 = 0;
    memset(v36, 0, sizeof(v36));
    v37 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
        goto LABEL_26;
      }
      v20 = v5 + 21;
      LOWORD(v41) = -437;
      HIWORD(v41) = v5 + 21;
      if ((HDLCFrameInject() & 1) != 0)
      {
        v3 = (uint64_t)malloc((2 * DWORD2(v38) + 32));
        if (!v3)
        {
LABEL_27:
          HDLCFrameFree();
          HDLCFrameFree();
          return v3;
        }
        v21 = HDLCFrameEncode();
        if (!(_DWORD)v21)
          goto LABEL_29;
        v22 = v21;
        v41 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0)
          ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v3, v21);
        if (*a1)
        {
          v23 = (*a1)(a1, v3, v22, &v41, 1, a3, 0);
          v24 = v41;
          free((void *)v3);
          v3 = 0;
          if (!v23 || v24 != (_DWORD)v22)
            goto LABEL_27;
          LOBYTE(v41) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v3 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v41, a3)|| v41 != 75)
          {
            goto LABEL_27;
          }
          if (DWORD2(v36[0]) < 4)
          {
            _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v25, v26, v27, v28, v29, v30, DWORD2(v36[0]));
          }
          else
          {
            v31 = **(_DWORD **)&v36[0];
            if (**(_DWORD **)&v36[0] == 75)
            {
              if (BYTE1(v31) == 254)
              {
                if (v20 == HIWORD(v31))
                {
                  v3 = 1;
                  goto LABEL_27;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v25, v26, v27, v28, v29, v30, HIWORD(v31));
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v25, v26, v27, v28, v29, v30, BYTE1(v31));
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v25, v26, v27, v28, v29, v30, **(_DWORD **)&v36[0]);
            }
          }
        }
        else
        {
LABEL_29:
          free((void *)v3);
        }
LABEL_26:
        v3 = 0;
        goto LABEL_27;
      }
      v32 = "ETLSubsysAddHeaderInternal";
      v33 = "Failed to inject\n";
    }
    else
    {
      v32 = "ETLMaverickBackupOrRestoreBBData";
      v33 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v7, v8, v9, v10, v11, v12, v35);
    goto LABEL_26;
  }
  return 0;
}

void *ETLMaverickSetAntennaSKU(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v30 = "ETLMaverickSetAntennaSKU";
    v31 = "Failed to create command frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v6, v7, v8, v9, v10, v11, v33);
    goto LABEL_23;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_23;
  }
  v39 = 2555211;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v30 = "ETLSubsysAddHeaderInternal";
    v31 = "Failed to inject\n";
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v33 = 2;
    v30 = "ETLRequireFreeSpace";
    v31 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_23:
    v19 = 0;
    goto LABEL_24;
  }
  v19 = malloc((2 * DWORD2(v36) + 32));
  if (!v19)
    goto LABEL_24;
  v20 = HDLCFrameEncode();
  if (!(_DWORD)v20)
    goto LABEL_25;
  v21 = v20;
  v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
  if (!*a1)
  {
LABEL_25:
    free(v19);
    goto LABEL_23;
  }
  v22 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v19, v21, &v39, 1, a3, 0);
  v23 = v39;
  free(v19);
  v19 = 0;
  if (v22 && v23 == (_DWORD)v21)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v19 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      v19 = (void *)ETLMaverickParseSetAntennaSKUResponse((int **)v34, a2, v24, v25, v26, v27, v28, v29);
    }
  }
LABEL_24:
  HDLCFrameFree();
  HDLCFrameFree();
  return v19;
}

uint64_t ETLMaverickSetIMEISwVersion(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  const char *v36;
  uint64_t v38;
  _OWORD v39[2];
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  int v44;

  v41 = 0u;
  v42 = 0u;
  v43 = 0;
  memset(v39, 0, sizeof(v39));
  v40 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v35 = "ETLMaverickSetIMEISwVersion";
    v36 = "Failed to create command frame\n";
LABEL_24:
    _ETLDebugPrint((uint64_t)v35, (uint64_t)v36, v6, v7, v8, v9, v10, v11, v38);
    goto LABEL_25;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_25;
  }
  v44 = 2489675;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v35 = "ETLSubsysAddHeaderInternal";
    v36 = "Failed to inject\n";
    goto LABEL_24;
  }
  if (!HDLCFrameGetFreeSpace())
  {
    v38 = 1;
    v35 = "ETLRequireFreeSpace";
    v36 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_24;
  }
  if (!HDLCFrameInjectUnsignedChar())
    goto LABEL_25;
  v19 = (uint64_t)malloc((2 * DWORD2(v41) + 32));
  if (v19)
  {
    v20 = HDLCFrameEncode();
    if (!(_DWORD)v20)
      goto LABEL_27;
    v21 = v20;
    v44 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
    if (!*a1)
    {
LABEL_27:
      free((void *)v19);
      goto LABEL_25;
    }
    v22 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v19, v21, &v44, 1, a3, 0);
    v23 = v44;
    free((void *)v19);
    v19 = 0;
    if (v22)
    {
      if (v23 == (_DWORD)v21)
      {
        LOBYTE(v44) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v19 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v39, (uint64_t)&_ETLResponseRingBuffer, &v44, a3))
        {
          if (v44 == 75)
          {
            LOBYTE(v44) = -86;
            if (ETLMaverickParseIMEISwVersionResponse((int **)v39, &v44, 37, v24, v25, v26, v27, v28))
            {
              if (v44 == a2)
              {
                v19 = 1;
                goto LABEL_26;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickSetIMEISwVersion", (uint64_t)"Received SVN %u mismatches sent %u\n", v29, v30, v31, v32, v33, v34, v44);
            }
LABEL_25:
            v19 = 0;
          }
        }
      }
    }
  }
LABEL_26:
  HDLCFrameFree();
  HDLCFrameFree();
  return v19;
}

void *ETLMaverickGetIMEISwVersion(_QWORD *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  uint64_t v31;
  _OWORD v32[2];
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  int v37;

  v34 = 0u;
  v35 = 0u;
  v36 = 0;
  memset(v32, 0, sizeof(v32));
  v33 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    v28 = "ETLMaverickGetIMEISwVersion";
    v29 = "Failed to create command frame\n";
LABEL_18:
    _ETLDebugPrint((uint64_t)v28, (uint64_t)v29, a3, a4, a5, a6, a7, a8, v31);
LABEL_19:
    v18 = 0;
    goto LABEL_20;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_19;
  }
  v37 = 2424139;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v28 = "ETLSubsysAddHeaderInternal";
    v29 = "Failed to inject\n";
    goto LABEL_18;
  }
  v18 = malloc((2 * DWORD2(v34) + 32));
  if (!v18)
    goto LABEL_20;
  v19 = HDLCFrameEncode();
  if (!(_DWORD)v19)
    goto LABEL_23;
  v20 = v19;
  v37 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
  if (!*a1)
  {
LABEL_23:
    free(v18);
    goto LABEL_19;
  }
  v21 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v18, v20, &v37, 1, a3, 0);
  v22 = v37;
  free(v18);
  v18 = 0;
  if (v21 && v22 == (_DWORD)v20)
  {
    LOBYTE(v37) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v18 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v32, (uint64_t)&_ETLResponseRingBuffer, &v37, a3)&& v37 == 75)
    {
      v18 = (void *)ETLMaverickParseIMEISwVersionResponse((int **)v32, a2, 36, v23, v24, v25, v26, v27);
    }
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v18;
}

uint64_t ETLMaverickGetHWType(_QWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  _QWORD v10[3];

  memset(v10, 170, sizeof(v10));
  if (!a2)
    return 0;
  result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    *a2 = v10[0];
    return 1;
  }
  return result;
}

void *ETLMaverickGetHWInfo(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *HWConfigIDResponse;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  uint64_t v32;
  _OWORD v33[2];
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  int v38;

  v35 = 0u;
  v36 = 0u;
  v37 = 0;
  memset(v33, 0, sizeof(v33));
  v34 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    v29 = "ETLMaverickGetHWInfo";
    v30 = "Failed to create command frame\n";
LABEL_18:
    _ETLDebugPrint((uint64_t)v29, (uint64_t)v30, a3, a4, a5, a6, a7, a8, v32);
LABEL_19:
    HWConfigIDResponse = 0;
    goto LABEL_20;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_19;
  }
  v38 = 65099;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v29 = "ETLSubsysAddHeaderInternal";
    v30 = "Failed to inject\n";
    goto LABEL_18;
  }
  HWConfigIDResponse = malloc((2 * DWORD2(v35) + 32));
  if (!HWConfigIDResponse)
    goto LABEL_20;
  v19 = HDLCFrameEncode();
  if (!(_DWORD)v19)
    goto LABEL_23;
  v20 = v19;
  v38 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, HWConfigIDResponse, v19);
  if (!*a1)
  {
LABEL_23:
    free(HWConfigIDResponse);
    goto LABEL_19;
  }
  v21 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, HWConfigIDResponse, v20, &v38, 1, a3, 0);
  v22 = v38;
  free(HWConfigIDResponse);
  HWConfigIDResponse = 0;
  if (v21 && v22 == (_DWORD)v20)
  {
    LOBYTE(v38) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    HWConfigIDResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v33, (uint64_t)&_ETLResponseRingBuffer, &v38, a3)&& v38 == 75)
    {
      HWConfigIDResponse = (void *)ETLMaverickParseGetHWConfigIDResponse((uint64_t)v33, a2, v23, v24, v25, v26, v27, v28);
    }
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return HWConfigIDResponse;
}

uint64_t ETLMaverickGetHWRev(_QWORD *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  _QWORD v10[3];

  memset(v10, 170, sizeof(v10));
  if (!a2)
    return 0;
  result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    *a2 = WORD2(v10[0]);
    return 1;
  }
  return result;
}

uint64_t ETLMaverickGetHWConfigId(_QWORD *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  _QWORD v10[3];

  memset(v10, 170, sizeof(v10));
  if (!a2)
    return 0;
  result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    *a2 = HIWORD(v10[0]);
    return 1;
  }
  return result;
}

uint64_t ETLMaverickGetPAConfig(_QWORD *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  _QWORD v10[3];

  memset(v10, 170, sizeof(v10));
  if (!a2)
    return 0;
  result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    *a2 = v10[1];
    return 1;
  }
  return result;
}

uint64_t ETLMaverickGetAntennaTunerID(_QWORD *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  _QWORD v10[3];

  memset(v10, 170, sizeof(v10));
  if (!a2)
    return 0;
  result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    *a2 = WORD1(v10[1]);
    return 1;
  }
  return result;
}

uint64_t ETLMaverickGetSKU(_QWORD *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  _QWORD v10[3];

  memset(v10, 170, sizeof(v10));
  if (!a2)
    return 0;
  result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    *a2 = HIWORD(v10[2]);
    return 1;
  }
  return result;
}

void *ETLMaverickGetMaxTxPower(_QWORD *a1, _WORD *a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Uplink;
  int v13;
  uint64_t FreeSpace;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  void *MaxTxPowerResponse;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  _OWORD v30[2];
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  int v35;

  v32 = 0u;
  v33 = 0u;
  v34 = 0;
  memset(v30, 0, sizeof(v30));
  v31 = 0;
  if (!a2 || !a3 || (Uplink = HDLCFrameCreateUplink(), (Uplink & 1) == 0))
  {
    v21 = "ETLMaverickGetMaxTxPower";
    v22 = "Failed to create command frame\n";
    goto LABEL_9;
  }
  v13 = capabilities::etl::maverickTxPowerUsesRFSubsys((capabilities::etl *)Uplink);
  FreeSpace = HDLCFrameGetFreeSpace();
  if (!v13)
  {
    if (FreeSpace >= 4)
    {
      v35 = 2620747;
      if (!HDLCFrameInject())
        goto LABEL_7;
      goto LABEL_14;
    }
LABEL_26:
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v15, v16, v17, v18, v19, v20, FreeSpace);
    goto LABEL_10;
  }
  if (FreeSpace < 4)
    goto LABEL_26;
  v35 = 1375051;
  if (!HDLCFrameInject())
  {
LABEL_7:
    v21 = "ETLSubsysAddHeaderInternal";
    v22 = "Failed to inject\n";
LABEL_9:
    _ETLDebugPrint((uint64_t)v21, (uint64_t)v22, (uint64_t)a3, a4, a5, a6, a7, a8, v29);
LABEL_10:
    MaxTxPowerResponse = 0;
    goto LABEL_11;
  }
LABEL_14:
  MaxTxPowerResponse = malloc((2 * DWORD2(v32) + 32));
  if (!MaxTxPowerResponse)
    goto LABEL_11;
  v25 = HDLCFrameEncode();
  if (!(_DWORD)v25)
    goto LABEL_27;
  v26 = v25;
  v35 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, MaxTxPowerResponse, v25);
  if (!*a1)
  {
LABEL_27:
    free(MaxTxPowerResponse);
    goto LABEL_10;
  }
  v27 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, MaxTxPowerResponse, v26, &v35, 1, a4, 0);
  v28 = v35;
  free(MaxTxPowerResponse);
  MaxTxPowerResponse = 0;
  if (v27 && v28 == (_DWORD)v26)
  {
    LOBYTE(v35) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    MaxTxPowerResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v30, (uint64_t)&_ETLResponseRingBuffer, &v35, a4)&& v35 == 75)
    {
      MaxTxPowerResponse = (void *)ETLMaverickParseGetMaxTxPowerResponse((capabilities::etl *)v30, a2, a3);
    }
  }
LABEL_11:
  HDLCFrameFree();
  HDLCFrameFree();
  return MaxTxPowerResponse;
}

void *ETLMaverickSetAutoAnswer(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  const char *v32;
  uint64_t v34;
  _OWORD v35[2];
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  int v40;

  v37 = 0u;
  v38 = 0u;
  v39 = 0;
  memset(v35, 0, sizeof(v35));
  v36 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v31 = "ETLMaverickSetAutoAnswer";
    v32 = "Failed to create command frame\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v6, v7, v8, v9, v10, v11, v34);
    goto LABEL_22;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
LABEL_22:
    v19 = 0;
    goto LABEL_23;
  }
  v40 = 2686283;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v31 = "ETLSubsysAddHeaderInternal";
    v32 = "Failed to inject\n";
    goto LABEL_21;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v34 = 2;
    v31 = "ETLMaverickCreateSetAutoAnswerCommand";
    v32 = "Not enough room, need %zu, have %u\n";
    goto LABEL_21;
  }
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  v19 = malloc((2 * DWORD2(v37) + 32));
  if (!v19)
    goto LABEL_23;
  v20 = HDLCFrameEncode();
  if (!(_DWORD)v20)
    goto LABEL_24;
  v21 = v20;
  v40 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
  if (!*a1)
  {
LABEL_24:
    free(v19);
    goto LABEL_22;
  }
  v22 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v19, v21, &v40, 1, a4, 0);
  v23 = v40;
  free(v19);
  v19 = 0;
  if (v22 && v23 == (_DWORD)v21)
  {
    LOBYTE(v40) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v19 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v35, (uint64_t)&_ETLResponseRingBuffer, &v40, a4)&& v40 == 75)
    {
      v19 = (void *)ETLMaverickParseSetAutoAnswerResponse((unsigned int *)v35, v24, v25, v26, v27, v28, v29, v30);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return v19;
}

void *ETLMaverickCheckCalibration(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  const char *v36;
  uint64_t v38;
  _OWORD v39[2];
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  int v44;

  if (a2)
  {
    v43 = 0;
    v41 = 0u;
    v42 = 0u;
    memset(v39, 0, sizeof(v39));
    v40 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
        goto LABEL_22;
      }
      v44 = 3210571;
      if ((HDLCFrameInject() & 1) != 0)
      {
        v24 = malloc((2 * DWORD2(v41) + 32));
        if (!v24)
        {
LABEL_23:
          HDLCFrameFree();
          HDLCFrameFree();
          return v24;
        }
        v25 = HDLCFrameEncode();
        if ((_DWORD)v25)
        {
          v26 = v25;
          v44 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v24, v25);
          if (*a1)
          {
            v27 = (*a1)(a1, v24, v26, &v44, 1, a3, 0);
            v28 = v44;
            free(v24);
            v24 = 0;
            if (v27 && v28 == (_DWORD)v26)
            {
              LOBYTE(v44) = 75;
              if (!_ETLResponseRingBuffer)
                TelephonyUtilRingBufferInitialize();
              v24 = 0;
              if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v39, (uint64_t)&_ETLResponseRingBuffer, &v44, a3)&& v44 == 75)
              {
                v24 = (void *)ETLMaverickParseCalibrationCheckResonse((capabilities::radio *)v39, a2, v29, v30, v31, v32, v33, v34);
              }
            }
            goto LABEL_23;
          }
        }
        free(v24);
LABEL_22:
        v24 = 0;
        goto LABEL_23;
      }
      v35 = "ETLSubsysAddHeaderInternal";
      v36 = "Failed to inject\n";
    }
    else
    {
      v35 = "ETLMaverickCheckCalibration";
      v36 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v35, (uint64_t)v36, v11, v12, v13, v14, v15, v16, v38);
    goto LABEL_22;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickCheckCalibration", (uint64_t)"Calibration status pointer is NULL, skipping calibration check\n", a3, a4, a5, a6, a7, a8, v38);
  return 0;
}

void *ETLMaverickCheckCalibrationV2(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t FreeSpace;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  const char *v36;
  uint64_t v38;
  _OWORD v39[2];
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  int v44;

  if (a2)
  {
    v43 = 0;
    v41 = 0u;
    v42 = 0u;
    memset(v39, 0, sizeof(v39));
    v40 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v19, v20, v21, v22, v23, v24, FreeSpace);
        goto LABEL_22;
      }
      LOWORD(v44) = -1205;
      HIWORD(v44) = a4;
      if ((HDLCFrameInject() & 1) != 0)
      {
        v25 = malloc((2 * DWORD2(v41) + 32));
        if (!v25)
        {
LABEL_23:
          HDLCFrameFree();
          HDLCFrameFree();
          return v25;
        }
        v26 = HDLCFrameEncode();
        if ((_DWORD)v26)
        {
          v27 = v26;
          v44 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v25, v26);
          if (*a1)
          {
            v28 = (*a1)(a1, v25, v27, &v44, 1, a3, 0);
            v29 = v44;
            free(v25);
            v25 = 0;
            if (v28 && v29 == (_DWORD)v27)
            {
              LOBYTE(v44) = 75;
              if (!_ETLResponseRingBuffer)
                TelephonyUtilRingBufferInitialize();
              v25 = 0;
              if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v39, (uint64_t)&_ETLResponseRingBuffer, &v44, a3)&& v44 == 75)
              {
                v25 = (void *)ETLMaverickParseCalibrationCheckResponseV2((capabilities::radio *)v39, a2, a4, v30, v31, v32, v33, v34);
              }
            }
            goto LABEL_23;
          }
        }
        free(v25);
LABEL_22:
        v25 = 0;
        goto LABEL_23;
      }
      v35 = "ETLSubsysAddHeaderInternal";
      v36 = "Failed to inject\n";
    }
    else
    {
      v35 = "ETLMaverickCheckCalibrationV2";
      v36 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v35, (uint64_t)v36, v12, v13, v14, v15, v16, v17, v38);
    goto LABEL_22;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickCheckCalibrationV2", (uint64_t)"Calibration status pointer is NULL, skipping calibration check\n", a3, a4, a5, a6, a7, a8, v38);
  return 0;
}

uint64_t ETLMaverickParseICCIDResponse(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        v12 = HIWORD(v11);
        if ((_DWORD)v12 == (_DWORD)a3)
        {
          if (v9 <= 0xB)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseICCIDResponse", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*((_WORD *)v10 + 2) == 1)
          {
            v13 = *(_QWORD *)((char *)v10 + 6);
            *(_WORD *)(a2 + 8) = *((_WORD *)v10 + 7);
            *(_QWORD *)a2 = v13;
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseICCIDResponse", (uint64_t)"Received response with failure status [%d]\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 2));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickParseIMEIResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;

  if (!a1 || !a2)
    goto LABEL_16;
  v10 = a1[2];
  v11 = v10 - 4;
  if (v10 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
LABEL_16:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEIResponse", (uint64_t)"status: %d, success: %s, offset:%d\n", a3, a4, a5, a6, a7, a8, 0);
    return 0;
  }
  v12 = *(unsigned int **)a1;
  v13 = **(_DWORD **)a1;
  if (v13 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_16;
  }
  if (BYTE1(v13) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v13));
    goto LABEL_16;
  }
  v14 = HIWORD(v13);
  if ((_DWORD)v14 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v14);
    goto LABEL_16;
  }
  if (v11 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
    goto LABEL_16;
  }
  v15 = *((unsigned __int16 *)v12 + 2);
  if ((_DWORD)v15 != 34)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v15);
    goto LABEL_16;
  }
  v16 = *((unsigned __int16 *)v12 + 3);
  _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEIResponse", (uint64_t)"status: %d, success: %s, offset:%d\n", a3, a4, a5, a6, a7, a8, v16);
  if ((_DWORD)v16)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEIResponse", (uint64_t)"status is %d\n", v17, v18, v19, v20, v21, v22, v16);
    return 0;
  }
  if (a1[2] - 8 < 0xA)
    return 0;
  if (!*(_BYTE *)(*(_QWORD *)a1 + 9))
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEIResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v17, v18, v19, v20, v21, v22, a1[2] - 8);
    return 0;
  }
  v24 = *(_QWORD *)(*(_QWORD *)a1 + 9);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(*(_QWORD *)a1 + 17);
  *(_QWORD *)a2 = v24;
  return 1;
}

void *ETLMaverickGetICCIDExt(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  uint64_t v31;
  _OWORD v32[2];
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  int v37;

  v34 = 0u;
  v35 = 0u;
  v36 = 0;
  memset(v32, 0, sizeof(v32));
  v33 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    v28 = "ETLMaverickGetICCIDExt";
    v29 = "Failed to create command frame\n";
LABEL_19:
    _ETLDebugPrint((uint64_t)v28, (uint64_t)v29, a3, a4, a5, a6, a7, a8, v31);
    goto LABEL_20;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_20;
  }
  v37 = 5438795;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v28 = "ETLSubsysAddHeaderInternal";
    v29 = "Failed to inject\n";
    goto LABEL_19;
  }
  if (!HDLCFrameInjectUnsignedChar())
  {
LABEL_20:
    v18 = 0;
    goto LABEL_21;
  }
  v18 = malloc((2 * DWORD2(v34) + 32));
  if (!v18)
    goto LABEL_21;
  v19 = HDLCFrameEncode();
  if (!(_DWORD)v19)
    goto LABEL_24;
  v20 = v19;
  v37 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
  if (!*a1)
  {
LABEL_24:
    free(v18);
    goto LABEL_20;
  }
  v21 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v18, v20, &v37, 1, a4, 0);
  v22 = v37;
  free(v18);
  v18 = 0;
  if (v21 && v22 == (_DWORD)v20)
  {
    LOBYTE(v37) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v18 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v32, (uint64_t)&_ETLResponseRingBuffer, &v37, a4)&& v37 == 75)
    {
      v18 = (void *)ETLMaverickParseICCIDResponse((int **)v32, a2, 82, v23, v24, v25, v26, v27);
    }
  }
LABEL_21:
  HDLCFrameFree();
  HDLCFrameFree();
  return v18;
}

void *ETLMaverickGetIMEI(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  _OWORD v24[2];
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  int v29;

  if (a2)
  {
    v28 = 0;
    v26 = 0u;
    v27 = 0u;
    memset(v24, 0, sizeof(v24));
    v25 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      if (ETLMaverickAddSecurityCommandHeader() && HDLCFrameInjectUnsignedChar())
      {
        v11 = malloc((2 * DWORD2(v26) + 32));
        if (!v11)
        {
LABEL_22:
          HDLCFrameFree();
          HDLCFrameFree();
          return v11;
        }
        v12 = HDLCFrameEncode();
        if ((_DWORD)v12)
        {
          v13 = v12;
          v29 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
          if (*a1)
          {
            v14 = (*a1)(a1, v11, v13, &v29, 1, a4, 0);
            v15 = v29;
            free(v11);
            v11 = 0;
            if (v14 && v15 == (_DWORD)v13)
            {
              LOBYTE(v29) = 75;
              if (!_ETLResponseRingBuffer)
                TelephonyUtilRingBufferInitialize();
              v11 = 0;
              if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v24, (uint64_t)&_ETLResponseRingBuffer, &v29, a4)&& v29 == 75)
              {
                v11 = (void *)ETLMaverickParseIMEIResponse((unsigned int *)v24, a2, v16, v17, v18, v19, v20, v21);
              }
            }
            goto LABEL_22;
          }
        }
        free(v11);
      }
      v11 = 0;
      goto LABEL_22;
    }
    v22 = "Failed to create command frame\n";
  }
  else
  {
    v22 = "imei is null\n";
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetIMEI", (uint64_t)v22, a3, a4, a5, a6, a7, a8, *(uint64_t *)&v24[0]);
  return 0;
}

uint64_t ETLMaverickGetFactoryCalibrationStatus(_QWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  const char *v31;
  const char *v32;
  uint64_t v34;
  _OWORD v35[2];
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  int v40;

  v37 = 0u;
  v38 = 0u;
  v39 = 0;
  memset(v35, 0, sizeof(v35));
  v36 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    v31 = "ETLMaverickGetFactoryCalibrationStatus";
    v32 = "Failed to create command frame\n";
LABEL_24:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, a3, a4, a5, a6, a7, a8, v34);
    goto LABEL_25;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_25;
  }
  v40 = 3734347;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v31 = "ETLSubsysAddHeaderInternal";
    v32 = "Failed to inject\n";
    goto LABEL_24;
  }
  v18 = (uint64_t)malloc((2 * DWORD2(v37) + 32));
  if (v18)
  {
    v19 = HDLCFrameEncode();
    if (!(_DWORD)v19)
      goto LABEL_29;
    v20 = v19;
    v40 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
    if (!*a1)
    {
LABEL_29:
      free((void *)v18);
      goto LABEL_25;
    }
    v21 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v18, v20, &v40, 1, a3, 0);
    v22 = v40;
    free((void *)v18);
    v18 = 0;
    if (v21)
    {
      if (v22 == (_DWORD)v20)
      {
        LOBYTE(v40) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v18 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v35, (uint64_t)&_ETLResponseRingBuffer, &v40, a3))
        {
          if (v40 == 75)
          {
            if (DWORD2(v35[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v23, v24, v25, v26, v27, v28, DWORD2(v35[0]));
            }
            else
            {
              v29 = **(_DWORD **)&v35[0];
              if (**(_DWORD **)&v35[0] == 75)
              {
                if (BYTE1(v29) == 251)
                {
                  v30 = HIWORD(v29);
                  if ((_DWORD)v30 == 56)
                  {
                    if ((DWORD2(v35[0]) - 4) <= 3)
                    {
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseGetFactoryCalibrationStatus", (uint64_t)"Received response has only %u bytes, need %u\n", v23, v24, v25, v26, v27, v28, (DWORD2(v35[0]) - 4));
                    }
                    else
                    {
                      if (*(_WORD *)(*(_QWORD *)&v35[0] + 4) == 1)
                      {
                        *a2 = *(unsigned __int16 *)(*(_QWORD *)&v35[0] + 6);
                        v18 = 1;
                        goto LABEL_26;
                      }
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseGetFactoryCalibrationStatus", (uint64_t)"Received response with failure status [%d]\n", v23, v24, v25, v26, v27, v28, *(unsigned __int16 *)(*(_QWORD *)&v35[0] + 4));
                    }
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v23, v24, v25, v26, v27, v28, v30);
                  }
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v23, v24, v25, v26, v27, v28, BYTE1(v29));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v23, v24, v25, v26, v27, v28, **(_DWORD **)&v35[0]);
              }
            }
LABEL_25:
            v18 = 0;
          }
        }
      }
    }
  }
LABEL_26:
  HDLCFrameFree();
  HDLCFrameFree();
  return v18;
}

uint64_t ETLMaverickGetRAT(_QWORD *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  const char *v49;
  uint64_t v51;
  _OWORD v52[2];
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  unsigned int v57;

  if (a1 && a2)
  {
    v54 = 0u;
    v55 = 0u;
    v56 = 0;
    memset(v52, 0, sizeof(v52));
    v53 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        v57 = 4521291;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (!HDLCFrameGetFreeSpace())
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          v36 = (uint64_t)malloc((2 * DWORD2(v54) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          v37 = HDLCFrameEncode();
          if (!(_DWORD)v37)
            goto LABEL_31;
          v38 = v37;
          v57 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          v39 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v36, v38, &v57, 1, a3, 0);
          v40 = v57;
          free((void *)v36);
          v36 = 0;
          if (!v39 || v40 != (_DWORD)v38)
            goto LABEL_28;
          LOBYTE(v57) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v52, (uint64_t)&_ETLResponseRingBuffer, &v57, a3)|| v57 != 75)
          {
            goto LABEL_28;
          }
          v57 = 0;
          if ((ETLMaverickParseBSPExtResponse((uint64_t)v52, &v57, v41, v42, v43, v44, v45, v46) & 1) != 0)
          {
            v47 = DWORD2(v52[0]) - v57;
            if (v47 > 1)
            {
              *a2 = *(_WORD *)(*(_QWORD *)&v52[0] + v57);
              v36 = 1;
              goto LABEL_28;
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetRATSelectionResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v11, v12, v13, v14, v15, v16, v47);
LABEL_27:
            v36 = 0;
            goto LABEL_28;
          }
          v48 = "ETLMaverickParseGetRATSelectionResponse";
          v49 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v48, (uint64_t)v49, v11, v12, v13, v14, v15, v16, v51);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v51);
      }
      v48 = "ETLMaverickAddBSPExtCommandGetHeader";
      v49 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    v48 = "ETLMaverickGetRAT";
    v49 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetRAT", (uint64_t)"Transport or ratSelection memory cannot be NULL\n", a3, a4, a5, a6, a7, a8, v51);
  return 0;
}

uint64_t ETLMaverickSetRAT(_QWORD *a1, unsigned __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  const char *v50;
  uint64_t v52;
  _OWORD v53[2];
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  unsigned int v58;

  if (a1)
  {
    v55 = 0u;
    v56 = 0u;
    v57 = 0;
    memset(v53, 0, sizeof(v53));
    v54 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        v58 = 4521291;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameGetFreeSpace() <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          v36 = (uint64_t)malloc((2 * DWORD2(v55) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          v37 = HDLCFrameEncode();
          if (!(_DWORD)v37)
            goto LABEL_31;
          v38 = v37;
          v58 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          v39 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v36, v38, &v58, 1, a3, 0);
          v40 = v58;
          free((void *)v36);
          v36 = 0;
          if (!v39 || v40 != (_DWORD)v38)
            goto LABEL_28;
          LOBYTE(v58) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v53, (uint64_t)&_ETLResponseRingBuffer, &v58, a3)|| v58 != 75)
          {
            goto LABEL_28;
          }
          v58 = 0;
          if ((ETLMaverickParseBSPExtResponse((uint64_t)v53, &v58, v41, v42, v43, v44, v45, v46) & 1) != 0)
          {
            v47 = DWORD2(v53[0]) - v58;
            if (v47 <= 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetRATSelectionResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
            }
            else
            {
              v48 = *(unsigned __int16 *)(*(_QWORD *)&v53[0] + v58);
              if ((_DWORD)v48 == a2)
              {
                v36 = 1;
                goto LABEL_28;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetRATSelectionResponse", (uint64_t)"Received rat selection %d doesn't match with %d\n", v11, v12, v13, v14, v15, v16, v48);
            }
LABEL_27:
            v36 = 0;
            goto LABEL_28;
          }
          v49 = "ETLMaverickParseSetRATSelectionResponse";
          v50 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v49, (uint64_t)v50, v11, v12, v13, v14, v15, v16, v52);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v52);
      }
      v49 = "ETLMaverickAddBSPExtCommandSetHeader";
      v50 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    v49 = "ETLMaverickSetRAT";
    v50 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetRAT", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v52);
  return 0;
}

uint64_t ETLMaverickGetBBMode(_QWORD *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  const char *v49;
  uint64_t v51;
  _OWORD v52[2];
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  unsigned int v57;

  if (a1 && a2)
  {
    v54 = 0u;
    v55 = 0u;
    v56 = 0;
    memset(v52, 0, sizeof(v52));
    v53 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        v57 = 4521291;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (!HDLCFrameGetFreeSpace())
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          v36 = (uint64_t)malloc((2 * DWORD2(v54) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          v37 = HDLCFrameEncode();
          if (!(_DWORD)v37)
            goto LABEL_31;
          v38 = v37;
          v57 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          v39 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v36, v38, &v57, 1, a3, 0);
          v40 = v57;
          free((void *)v36);
          v36 = 0;
          if (!v39 || v40 != (_DWORD)v38)
            goto LABEL_28;
          LOBYTE(v57) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v52, (uint64_t)&_ETLResponseRingBuffer, &v57, a3)|| v57 != 75)
          {
            goto LABEL_28;
          }
          v57 = 0;
          if ((ETLMaverickParseBSPExtResponse((uint64_t)v52, &v57, v41, v42, v43, v44, v45, v46) & 1) != 0)
          {
            v47 = DWORD2(v52[0]) - v57;
            if (v47 > 1)
            {
              *a2 = *(_WORD *)(*(_QWORD *)&v52[0] + v57);
              v36 = 1;
              goto LABEL_28;
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetBBModeResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
LABEL_27:
            v36 = 0;
            goto LABEL_28;
          }
          v48 = "ETLMaverickParseGetBBModeResponse";
          v49 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v48, (uint64_t)v49, v11, v12, v13, v14, v15, v16, v51);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v51);
      }
      v48 = "ETLMaverickAddBSPExtCommandGetHeader";
      v49 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    v48 = "ETLMaverickGetBBMode";
    v49 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetBBMode", (uint64_t)"Transport or mode memory cannot be NULL\n", a3, a4, a5, a6, a7, a8, v51);
  return 0;
}

uint64_t ETLMaverickSetBBMode(_QWORD *a1, unsigned __int8 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  const char *v50;
  uint64_t v52;
  _OWORD v53[2];
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  unsigned int v58;

  if (a1)
  {
    v55 = 0u;
    v56 = 0u;
    v57 = 0;
    memset(v53, 0, sizeof(v53));
    v54 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        v58 = 4521291;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameGetFreeSpace() <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          v36 = (uint64_t)malloc((2 * DWORD2(v55) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          v37 = HDLCFrameEncode();
          if (!(_DWORD)v37)
            goto LABEL_31;
          v38 = v37;
          v58 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          v39 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v36, v38, &v58, 1, a3, 0);
          v40 = v58;
          free((void *)v36);
          v36 = 0;
          if (!v39 || v40 != (_DWORD)v38)
            goto LABEL_28;
          LOBYTE(v58) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v53, (uint64_t)&_ETLResponseRingBuffer, &v58, a3)|| v58 != 75)
          {
            goto LABEL_28;
          }
          v58 = 0;
          if ((ETLMaverickParseBSPExtResponse((uint64_t)v53, &v58, v41, v42, v43, v44, v45, v46) & 1) != 0)
          {
            v47 = DWORD2(v53[0]) - v58;
            if (v47 <= 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBBModeResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
            }
            else
            {
              v48 = *(unsigned __int8 *)(*(_QWORD *)&v53[0] + v58);
              if (a2 == (_DWORD)v48)
              {
                v36 = 1;
                goto LABEL_28;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBBModeResponse", (uint64_t)"Received mode %d doesn't match with %d\n", v11, v12, v13, v14, v15, v16, v48);
            }
LABEL_27:
            v36 = 0;
            goto LABEL_28;
          }
          v49 = "ETLMaverickParseSetBBModeResponse";
          v50 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v49, (uint64_t)v50, v11, v12, v13, v14, v15, v16, v52);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v52);
      }
      v49 = "ETLMaverickAddBSPExtCommandSetHeader";
      v50 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    v49 = "ETLMaverickSetBBMode";
    v50 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetBBMode", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v52);
  return 0;
}

uint64_t ETLMaverickGetAutoAnswerBSP(_QWORD *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  const char *v49;
  uint64_t v51;
  _OWORD v52[2];
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  unsigned int v57;

  if (a1 && a2)
  {
    v54 = 0u;
    v55 = 0u;
    v56 = 0;
    memset(v52, 0, sizeof(v52));
    v53 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        v57 = 4521291;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (!HDLCFrameGetFreeSpace())
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          v36 = (uint64_t)malloc((2 * DWORD2(v54) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          v37 = HDLCFrameEncode();
          if (!(_DWORD)v37)
            goto LABEL_31;
          v38 = v37;
          v57 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          v39 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v36, v38, &v57, 1, a3, 0);
          v40 = v57;
          free((void *)v36);
          v36 = 0;
          if (!v39 || v40 != (_DWORD)v38)
            goto LABEL_28;
          LOBYTE(v57) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v52, (uint64_t)&_ETLResponseRingBuffer, &v57, a3)|| v57 != 75)
          {
            goto LABEL_28;
          }
          v57 = 0;
          if ((ETLMaverickParseBSPExtResponse((uint64_t)v52, &v57, v41, v42, v43, v44, v45, v46) & 1) != 0)
          {
            v47 = DWORD2(v52[0]) - v57;
            if (v47 > 1)
            {
              *a2 = *(_WORD *)(*(_QWORD *)&v52[0] + v57);
              v36 = 1;
              goto LABEL_28;
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetAutoAnswerResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
LABEL_27:
            v36 = 0;
            goto LABEL_28;
          }
          v48 = "ETLMaverickParseGetAutoAnswerResponse";
          v49 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v48, (uint64_t)v49, v11, v12, v13, v14, v15, v16, v51);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v51);
      }
      v48 = "ETLMaverickAddBSPExtCommandGetHeader";
      v49 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    v48 = "ETLMaverickGetAutoAnswerBSP";
    v49 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetAutoAnswerBSP", (uint64_t)"Transport or autoAnswer memory cannot be NULL\n", a3, a4, a5, a6, a7, a8, v51);
  return 0;
}

uint64_t ETLMaverickSetAutoAnswerBSP(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  const char *v49;
  uint64_t v51;
  _OWORD v52[2];
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  unsigned int v57;

  if (a1)
  {
    v54 = 0u;
    v55 = 0u;
    v56 = 0;
    memset(v52, 0, sizeof(v52));
    v53 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        v57 = 4521291;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameGetFreeSpace() <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          v36 = (uint64_t)malloc((2 * DWORD2(v54) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          v37 = HDLCFrameEncode();
          if (!(_DWORD)v37)
            goto LABEL_31;
          v38 = v37;
          v57 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          v39 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v36, v38, &v57, 1, a3, 0);
          v40 = v57;
          free((void *)v36);
          v36 = 0;
          if (!v39 || v40 != (_DWORD)v38)
            goto LABEL_28;
          LOBYTE(v57) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v52, (uint64_t)&_ETLResponseRingBuffer, &v57, a3)|| v57 != 75)
          {
            goto LABEL_28;
          }
          v57 = 0;
          if ((ETLMaverickParseBSPExtResponse((uint64_t)v52, &v57, v41, v42, v43, v44, v45, v46) & 1) != 0)
          {
            v47 = DWORD2(v52[0]) - v57;
            if (v47 <= 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetAutoAnswerBSPResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
            }
            else
            {
              if (*(unsigned __int16 *)(*(_QWORD *)&v52[0] + v57) == a2)
              {
                v36 = 1;
                goto LABEL_28;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetAutoAnswerBSPResponse", (uint64_t)"Received mode %d doesn't match with %d\n", v11, v12, v13, v14, v15, v16, *(unsigned __int16 *)(*(_QWORD *)&v52[0] + v57));
            }
LABEL_27:
            v36 = 0;
            goto LABEL_28;
          }
          v48 = "ETLMaverickParseSetAutoAnswerBSPResponse";
          v49 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v48, (uint64_t)v49, v11, v12, v13, v14, v15, v16, v51);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v51);
      }
      v48 = "ETLMaverickAddBSPExtCommandSetHeader";
      v49 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    v48 = "ETLMaverickSetAutoAnswerBSP";
    v49 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetAutoAnswerBSP", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v51);
  return 0;
}

uint64_t ETLMaverickGetNasSec(_QWORD *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE *v48;
  const char *v49;
  const char *v50;
  uint64_t v52;
  _OWORD v53[2];
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  unsigned int v58;

  if (a1 && a2)
  {
    v55 = 0u;
    v56 = 0u;
    v57 = 0;
    memset(v53, 0, sizeof(v53));
    v54 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        v58 = 4521291;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (!HDLCFrameGetFreeSpace())
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_28;
          }
          HDLCFrameInjectUnsignedChar();
          v36 = (uint64_t)malloc((2 * DWORD2(v55) + 32));
          if (!v36)
          {
LABEL_29:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          v37 = HDLCFrameEncode();
          if (!(_DWORD)v37)
            goto LABEL_32;
          v38 = v37;
          v58 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          if (!*a1)
          {
LABEL_32:
            free((void *)v36);
            goto LABEL_28;
          }
          v39 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v36, v38, &v58, 1, a3, 0);
          v40 = v58;
          free((void *)v36);
          v36 = 0;
          if (!v39 || v40 != (_DWORD)v38)
            goto LABEL_29;
          LOBYTE(v58) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v53, (uint64_t)&_ETLResponseRingBuffer, &v58, a3)|| v58 != 75)
          {
            goto LABEL_29;
          }
          v58 = 0;
          if ((ETLMaverickParseBSPExtResponse((uint64_t)v53, &v58, v41, v42, v43, v44, v45, v46) & 1) != 0)
          {
            v47 = DWORD2(v53[0]) - v58;
            if (v47 <= 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseGetNasSecResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
            }
            else
            {
              v48 = (_BYTE *)(*(_QWORD *)&v53[0] + v58);
              if (*v48 == 10)
              {
                *a2 = v48[1];
                v36 = 1;
                goto LABEL_29;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseGetNasSecResponse", (uint64_t)"Expected NAS Sec ID, %u, does not match with read ID, %u\n", v11, v12, v13, v14, v15, v16, 11);
            }
LABEL_28:
            v36 = 0;
            goto LABEL_29;
          }
          v49 = "ETLMaverickParseGetNasSecResponse";
          v50 = "Failed on parsing BSP Ext Response.\n";
LABEL_27:
          _ETLDebugPrint((uint64_t)v49, (uint64_t)v50, v11, v12, v13, v14, v15, v16, v52);
          goto LABEL_28;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v52);
      }
      v49 = "ETLMaverickAddBSPExtCommandGetHeader";
      v50 = "Failed on creating BSP Command Heder\n";
      goto LABEL_27;
    }
    v49 = "ETLMaverickGetNasSec";
    v50 = "Failed to create command frame\n";
    goto LABEL_27;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetNasSec", (uint64_t)"Transport or nasStatus memory cannot be NULL\n", a3, a4, a5, a6, a7, a8, v52);
  return 0;
}

uint64_t ETLMaverickSetNasSec(_QWORD *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE *v48;
  const char *v49;
  const char *v50;
  uint64_t v52;
  _OWORD v53[2];
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  unsigned int v58;

  if (a1)
  {
    v55 = 0u;
    v56 = 0u;
    v57 = 0;
    memset(v53, 0, sizeof(v53));
    v54 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        v58 = 4521291;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameGetFreeSpace() <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_28;
          }
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          v36 = (uint64_t)malloc((2 * DWORD2(v55) + 32));
          if (!v36)
          {
LABEL_29:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          v37 = HDLCFrameEncode();
          if (!(_DWORD)v37)
            goto LABEL_32;
          v38 = v37;
          v58 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          if (!*a1)
          {
LABEL_32:
            free((void *)v36);
            goto LABEL_28;
          }
          v39 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v36, v38, &v58, 1, a3, 0);
          v40 = v58;
          free((void *)v36);
          v36 = 0;
          if (!v39 || v40 != (_DWORD)v38)
            goto LABEL_29;
          LOBYTE(v58) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v53, (uint64_t)&_ETLResponseRingBuffer, &v58, a3)|| v58 != 75)
          {
            goto LABEL_29;
          }
          v58 = 0;
          if ((ETLMaverickParseBSPExtResponse((uint64_t)v53, &v58, v41, v42, v43, v44, v45, v46) & 1) != 0)
          {
            v47 = DWORD2(v53[0]) - v58;
            if (v47 <= 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetNasSecResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
            }
            else
            {
              v48 = (_BYTE *)(*(_QWORD *)&v53[0] + v58);
              if (*v48 == 11)
              {
                if (v48[1] == a2)
                {
                  v36 = 1;
                  goto LABEL_29;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetNasSecResponse", (uint64_t)"Expected NAS Sec status, %u, does not match with read status, %u\n", v11, v12, v13, v14, v15, v16, a2);
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetNasSecResponse", (uint64_t)"Expected NAS Sec ID, %u, does not match with read ID, %u\n", v11, v12, v13, v14, v15, v16, 11);
              }
            }
LABEL_28:
            v36 = 0;
            goto LABEL_29;
          }
          v49 = "ETLMaverickParseSetNasSecResponse";
          v50 = "Failed on parsing BSP Ext Response.\n";
LABEL_27:
          _ETLDebugPrint((uint64_t)v49, (uint64_t)v50, v11, v12, v13, v14, v15, v16, v52);
          goto LABEL_28;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v52);
      }
      v49 = "ETLMaverickAddBSPExtCommandSetHeader";
      v50 = "Failed on creating BSP Command Heder\n";
      goto LABEL_27;
    }
    v49 = "ETLMaverickSetNasSec";
    v50 = "Failed to create command frame\n";
    goto LABEL_27;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetNasSec", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v52);
  return 0;
}

uint64_t ETLMaverickGetBandlock(_QWORD *a1, _WORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t FreeSpace;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  const char *v51;
  uint64_t v53;
  _OWORD v54[2];
  uint64_t v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  unsigned int v59;

  if (a2 && a1 && a3)
  {
    v56 = 0u;
    v57 = 0u;
    v58 = 0;
    memset(v54, 0, sizeof(v54));
    v55 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v19, v20, v21, v22, v23, v24, FreeSpace);
      }
      else
      {
        v59 = 4521291;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (!HDLCFrameGetFreeSpace())
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v31, v32, v33, v34, v35, v36, 2);
            goto LABEL_28;
          }
          HDLCFrameInjectUnsignedChar();
          v37 = (uint64_t)malloc((2 * DWORD2(v56) + 32));
          if (!v37)
          {
LABEL_29:
            HDLCFrameFree();
            HDLCFrameFree();
            return v37;
          }
          v38 = HDLCFrameEncode();
          if (!(_DWORD)v38)
            goto LABEL_32;
          v39 = v38;
          v59 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v37, v38);
          if (!*a1)
          {
LABEL_32:
            free((void *)v37);
            goto LABEL_28;
          }
          v40 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v37, v39, &v59, 1, a4, 0);
          v41 = v59;
          free((void *)v37);
          v37 = 0;
          if (!v40 || v41 != (_DWORD)v39)
            goto LABEL_29;
          LOBYTE(v59) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v37 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v54, (uint64_t)&_ETLResponseRingBuffer, &v59, a4)|| v59 != 75)
          {
            goto LABEL_29;
          }
          v59 = 0;
          if ((ETLMaverickParseBSPExtResponse((uint64_t)v54, &v59, v42, v43, v44, v45, v46, v47) & 1) != 0)
          {
            v48 = DWORD2(v54[0]) - v59;
            if (v48 > 0x19)
            {
              v49 = *(_QWORD *)&v54[0] + v59;
              *a2 = *(_WORD *)v49;
              *a3 = *(_QWORD *)(v49 + 2);
              a3[1] = *(_QWORD *)(v49 + 10);
              a3[2] = *(_QWORD *)(v49 + 18);
              v37 = 1;
              goto LABEL_29;
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetBandLockResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v12, v13, v14, v15, v16, v17, v48);
LABEL_28:
            v37 = 0;
            goto LABEL_29;
          }
          v50 = "ETLMaverickParseGetBandLockResponse";
          v51 = "Failed on parsing BSP Ext Response.\n";
LABEL_27:
          _ETLDebugPrint((uint64_t)v50, (uint64_t)v51, v12, v13, v14, v15, v16, v17, v53);
          goto LABEL_28;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v25, v26, v27, v28, v29, v30, v53);
      }
      v50 = "ETLMaverickAddBSPExtCommandGetHeader";
      v51 = "Failed on creating BSP Command Heder\n";
      goto LABEL_27;
    }
    v50 = "ETLMaverickGetBandlock";
    v51 = "Failed to create command frame\n";
    goto LABEL_27;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetBandlock", (uint64_t)"Transport or bandLock or errorCode memory cannot be NULL\n", (uint64_t)a3, a4, a5, a6, a7, a8, v53);
  return 0;
}

uint64_t ETLMaverickSetBandlock(uint64_t (**a1)(_QWORD, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, _QWORD), _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t FreeSpace;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const char *v58;
  const char *v59;
  const char *v61;
  BOOL v62;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  __int128 v101;
  uint64_t v102;
  _OWORD v103[2];
  uint64_t v104;
  __int128 v105;
  __int128 v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unsigned int v111;

  if (a1)
  {
    v105 = 0u;
    v106 = 0u;
    v107 = 0;
    memset(v103, 0, sizeof(v103));
    v104 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v19, v20, v21, v22, v23, v24, FreeSpace);
      }
      else
      {
        LODWORD(v108) = 4521291;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameGetFreeSpace() <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickSetBandlockCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v31, v32, v33, v34, v35, v36, 2);
          }
          else
          {
            HDLCFrameInjectUnsignedChar();
            HDLCFrameInject();
            v37 = (uint64_t)malloc((2 * DWORD2(v105) + 32));
            if (!v37)
            {
LABEL_27:
              HDLCFrameFree();
              HDLCFrameFree();
              return v37;
            }
            v38 = HDLCFrameEncode();
            if ((_DWORD)v38)
            {
              v39 = v38;
              LODWORD(v108) = -1431655766;
              if ((_ETLDebugFlags & 2) != 0)
                ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v37, v38);
              if (*a1)
              {
                v40 = (*a1)(a1, v37, v39, &v108, 1, a4, 0);
                v41 = v108;
                free((void *)v37);
                v37 = 0;
                if (!v40 || v41 != (_DWORD)v39)
                  goto LABEL_27;
                LOBYTE(v108) = 75;
                if (!_ETLResponseRingBuffer)
                  TelephonyUtilRingBufferInitialize();
                v37 = 0;
                if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v103, (uint64_t)&_ETLResponseRingBuffer, &v108, a4)|| v108 != 75)
                {
                  goto LABEL_27;
                }
                v101 = *(_OWORD *)a3;
                v102 = *(_QWORD *)(a3 + 16);
                v108 = 0;
                v109 = 0;
                v110 = 0;
                v111 = 0;
                if ((ETLMaverickParseBSPExtResponse((uint64_t)v103, &v111, v42, v43, v44, v45, v46, v47) & 1) != 0)
                {
                  if (DWORD2(v103[0]) - v111 > 0x19)
                  {
                    v54 = *(_QWORD *)&v103[0] + v111;
                    *a2 = *(_WORD *)v54;
                    v55 = *(_QWORD *)(v54 + 2);
                    v108 = v55;
                    v56 = *(_QWORD *)(v54 + 10);
                    v109 = v56;
                    v57 = *(_QWORD *)(v54 + 18);
                    v110 = v57;
                    goto LABEL_34;
                  }
                  v100 = DWORD2(v103[0]) - v111;
                  v61 = "Received response has only %u bytes, need %u\n";
                }
                else
                {
                  v61 = "Failed on parsing BSP Ext Response.\n";
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseGetBandLockResponse", (uint64_t)v61, v48, v49, v50, v51, v52, v53, v100);
                v57 = 0;
                v56 = 0;
                v55 = 0;
LABEL_34:
                if (!*a2)
                {
                  v62 = v108 == (_QWORD)v101 && v109 == *((_QWORD *)&v101 + 1);
                  if (v62 && v110 == v102)
                  {
                    v37 = 1;
                    goto LABEL_27;
                  }
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"Expected locked band values are different read back locked band values.\n", v48, v49, v50, v51, v52, v53, v100);
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tExpected GWC: 0x%016llx\n", v64, v65, v66, v67, v68, v69, v101);
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tExpected LTE: 0x%016llx\n", v70, v71, v72, v73, v74, v75, *((uint64_t *)&v101 + 1));
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tExpected TDS: 0x%016llx\n", v76, v77, v78, v79, v80, v81, v102);
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tRead back GWC: 0x%016llx\n", v82, v83, v84, v85, v86, v87, v55);
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tRead back LTE: 0x%016llx\n", v88, v89, v90, v91, v92, v93, v56);
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tRead back TDS: 0x%016llx\n", v94, v95, v96, v97, v98, v99, v57);
                goto LABEL_26;
              }
            }
            free((void *)v37);
          }
LABEL_26:
          v37 = 0;
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v25, v26, v27, v28, v29, v30, v100);
      }
      v58 = "ETLMaverickSetBandlockCommand";
      v59 = "Failed on creating BSP Command Heder\n";
    }
    else
    {
      v58 = "ETLMaverickSetBandlock";
      v59 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v58, (uint64_t)v59, v12, v13, v14, v15, v16, v17, v100);
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetBandlock", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v100);
  return 0;
}

uint64_t ETLMaverickGetBandSupport(_QWORD *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t FreeSpace;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  const char *v44;
  const char *v45;
  uint64_t v47;
  _OWORD v48[2];
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  int v53;

  if (a1)
  {
    v50 = 0u;
    v51 = 0u;
    v52 = 0;
    memset(v48, 0, sizeof(v48));
    v49 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v20, v21, v22, v23, v24, v25, FreeSpace);
        goto LABEL_30;
      }
      v53 = 3210059;
      if ((HDLCFrameInject() & 1) != 0)
      {
        v26 = (uint64_t)malloc((2 * DWORD2(v50) + 32));
        if (!v26)
        {
LABEL_31:
          HDLCFrameFree();
          HDLCFrameFree();
          return v26;
        }
        v27 = HDLCFrameEncode();
        if (!(_DWORD)v27)
          goto LABEL_33;
        v28 = v27;
        v53 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0)
          ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v26, v27);
        if (!*a1)
        {
LABEL_33:
          free((void *)v26);
          goto LABEL_30;
        }
        v29 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v26, v28, &v53, 1, a5, 0);
        v30 = v53;
        free((void *)v26);
        v26 = 0;
        if (!v29 || v30 != (_DWORD)v28)
          goto LABEL_31;
        LOBYTE(v53) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v26 = 0;
        if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v48, (uint64_t)&_ETLResponseRingBuffer, &v53, a5)|| v53 != 75)
        {
          goto LABEL_31;
        }
        v37 = (DWORD2(v48[0]) - 4);
        if (DWORD2(v48[0]) < 4)
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v31, v32, v33, v34, v35, v36, DWORD2(v48[0]));
        }
        else
        {
          v38 = *(_QWORD *)&v48[0];
          v39 = **(_DWORD **)&v48[0];
          if (**(_DWORD **)&v48[0] == 75)
          {
            if (BYTE1(v39) == 251)
            {
              v40 = HIWORD(v39);
              if ((_DWORD)v40 == 48)
              {
                if (v37 > 1)
                {
                  v41 = *(unsigned __int16 *)(*(_QWORD *)&v48[0] + 4);
                  *a2 = v41;
                  if ((_DWORD)v41 != 1)
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetBandSupportResponse", (uint64_t)"Error Code Returned: %d\n", v31, v32, v33, v34, v35, v36, v41);
                  if (v37 > 0x2D)
                  {
                    v42 = *(_OWORD *)(v38 + 6);
                    *(_QWORD *)(a3 + 14) = *(_QWORD *)(v38 + 20);
                    *(_OWORD *)a3 = v42;
                    v43 = *(_OWORD *)(v38 + 28);
                    *(_QWORD *)(a4 + 14) = *(_QWORD *)(v38 + 42);
                    *(_OWORD *)a4 = v43;
                    v26 = 1;
                    goto LABEL_31;
                  }
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseGetBandSupportResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v31, v32, v33, v34, v35, v36, v37);
LABEL_30:
                v26 = 0;
                goto LABEL_31;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v31, v32, v33, v34, v35, v36, v40);
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v31, v32, v33, v34, v35, v36, BYTE1(v39));
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v31, v32, v33, v34, v35, v36, **(_DWORD **)&v48[0]);
          }
        }
        v44 = "ETLMaverickParseGetBandSupportResponse";
        v45 = "Failed on parsing BSP Ext Response.\n";
      }
      else
      {
        v44 = "ETLSubsysAddHeaderInternal";
        v45 = "Failed to inject\n";
      }
    }
    else
    {
      v44 = "ETLMaverickGetBandSupport";
      v45 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v44, (uint64_t)v45, v13, v14, v15, v16, v17, v18, v47);
    goto LABEL_30;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetBandSupport", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v47);
  return 0;
}

void *ETLMaverickGetGPIOExt(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, _BYTE *a3, _BYTE *a4, _BYTE *a5, _BYTE *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t FreeSpace;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *GPIOExtResponse;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  const char *v35;
  uint64_t v37;
  int v38;
  _OWORD v39[2];
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  int v44;

  if (a1 && a3 && a4 && a5 && a6)
  {
    v41 = 0u;
    v42 = 0u;
    v43 = 0;
    memset(v39, 0, sizeof(v39));
    v40 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v22, v23, v24, v25, v26, v27, FreeSpace);
        goto LABEL_27;
      }
      v44 = 3013963;
      if ((HDLCFrameInject() & 1) != 0)
      {
        if (HDLCFrameInjectUnsignedShort())
        {
          GPIOExtResponse = malloc((2 * DWORD2(v41) + 32));
          if (!GPIOExtResponse)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return GPIOExtResponse;
          }
          v29 = HDLCFrameEncode();
          if ((_DWORD)v29)
          {
            v30 = v29;
            v44 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0)
              ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, GPIOExtResponse, v29);
            if (*a1)
            {
              v31 = (*a1)(a1, GPIOExtResponse, v30, &v44, 1, a7, 0);
              v38 = v44;
              free(GPIOExtResponse);
              GPIOExtResponse = 0;
              if (v31 && v38 == (_DWORD)v30)
              {
                LOBYTE(v44) = 75;
                if (!_ETLResponseRingBuffer)
                  TelephonyUtilRingBufferInitialize();
                GPIOExtResponse = 0;
                if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v39, (uint64_t)&_ETLResponseRingBuffer, &v44, a7)&& v44 == 75)
                {
                  GPIOExtResponse = (void *)ETLMaverickParseGetGPIOExtResponse((int **)v39, a2, a3, a4, a5, a6, v32, v33);
                }
              }
              goto LABEL_28;
            }
          }
          free(GPIOExtResponse);
        }
LABEL_27:
        GPIOExtResponse = 0;
        goto LABEL_28;
      }
      v34 = "ETLSubsysAddHeaderInternal";
      v35 = "Failed to inject\n";
    }
    else
    {
      v34 = "ETLMaverickGetGPIOExt";
      v35 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v34, (uint64_t)v35, v15, v16, v17, v18, v19, v20, v37);
    goto LABEL_27;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetGPIOExt", (uint64_t)"Transport, gpioState, direction, value, or function memory cannot be NULL\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v37);
  return 0;
}

uint64_t ETLMaverickParseGetGPIOExtResponse(int **a1, uint64_t a2, _BYTE *a3, _BYTE *a4, _BYTE *a5, _BYTE *a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_13:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOExtResponse", (uint64_t)"Failed to parse BSP response header\n", v14, v15, v16, v17, v18, v19, v20);
    return 0;
  }
  v10 = *a1;
  v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, **a1);
    goto LABEL_13;
  }
  if (BYTE1(v11) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, BYTE1(v11));
    goto LABEL_13;
  }
  v12 = HIWORD(v11);
  if ((_DWORD)v12 != 45)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v12);
    goto LABEL_13;
  }
  if (v9 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOExtResponse", (uint64_t)"Received response has only %u bytes, need %u\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v9);
    return 0;
  }
  else if (*((_WORD *)v10 + 2) == 1)
  {
    if (*((unsigned __int16 *)v10 + 3) == (_DWORD)a2)
    {
      *a3 = *((_BYTE *)v10 + 8);
      *a4 = *((_BYTE *)v10 + 9);
      *a5 = *((_BYTE *)v10 + 10);
      *a6 = *((_BYTE *)v10 + 11);
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOExtResponse", (uint64_t)"Expected gpio id, %u, but got %u\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, a2);
      return 0;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOExtResponse", (uint64_t)"Received response with failure status [%d]\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *((unsigned __int16 *)v10 + 2));
    return 0;
  }
}

uint64_t ETLMaverickSetGPIOExt(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t FreeSpace;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  const char *v32;
  uint64_t v34;
  _OWORD v35[2];
  uint64_t v36;
  _OWORD v37[2];
  uint64_t v38;
  int v39;

  if (a1)
  {
    memset(v37, 0, sizeof(v37));
    v38 = 0;
    memset(v35, 0, sizeof(v35));
    v36 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
        goto LABEL_17;
      }
      v39 = 3079499;
      if ((HDLCFrameInject() & 1) != 0)
      {
        if (HDLCFrameInjectUnsignedShort()
          && HDLCFrameInjectUnsignedChar()
          && HDLCFrameInjectUnsignedChar()
          && HDLCFrameInjectUnsignedChar()
          && ETLSendCommand(a1, (uint64_t)v37, a6)
          && ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v35, a6))
        {
          v30 = ETLMaverickParseSetGPIOExtResponse((unsigned int *)v35, v23, v24, v25, v26, v27, v28, v29);
LABEL_18:
          HDLCFrameFree();
          HDLCFrameFree();
          return v30;
        }
LABEL_17:
        v30 = 0;
        goto LABEL_18;
      }
      v31 = "ETLSubsysAddHeaderInternal";
      v32 = "Failed to inject\n";
    }
    else
    {
      v31 = "ETLMaverickSetGPIOExt";
      v32 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v10, v11, v12, v13, v14, v15, v34);
    goto LABEL_17;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetGPIOExt", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v34);
  return 0;
}

uint64_t ETLMaverickParseSetGPIOExtResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v8 = a1[2];
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOExtResponse", (uint64_t)"Failed to parse BSP response header\n", v13, v14, v15, v16, v17, v18, v19);
    return 0;
  }
  v10 = **(_DWORD **)a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_12;
  }
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    goto LABEL_12;
  }
  v11 = HIWORD(v10);
  if ((_DWORD)v11 != 46)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
    goto LABEL_12;
  }
  if (v9 <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOExtResponse", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else if (*(_WORD *)(*(_QWORD *)a1 + 4) == 1)
  {
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOExtResponse", (uint64_t)"Received response with failure status [%d]\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(_QWORD *)a1 + 4));
    return 0;
  }
}

uint64_t ETLMaverickLoopbackMode(_QWORD *a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  const char *v47;
  uint64_t v49;
  _OWORD v50[2];
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  unsigned __int16 v55;
  unsigned __int16 v56;
  unsigned int v57;

  if (a1)
  {
    v52 = 0u;
    v53 = 0u;
    v54 = 0;
    memset(v50, 0, sizeof(v50));
    v51 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        v57 = 4128075;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameGetFreeSpace() <= 4)
          {
            _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v30, v31, v32, v33, v34, v35, 5);
            v46 = "ETLMaverickAddLoopbackModeHeader";
            v47 = "There is no more free spaces.\n";
          }
          else
          {
            HDLCFrameInjectUnsignedInt();
            HDLCFrameInjectUnsignedChar();
            if (a2 == 3)
            {
              HDLCFrameInjectUnsignedChar();
              HDLCFrameInjectUnsignedChar();
              HDLCFrameInjectUnsignedChar();
              HDLCFrameInjectUnsignedInt();
            }
            v36 = (uint64_t)malloc((2 * DWORD2(v52) + 32));
            if (!v36)
              goto LABEL_32;
            v37 = HDLCFrameEncode();
            if (!(_DWORD)v37)
              goto LABEL_35;
            v38 = v37;
            v57 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0)
              ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
            if (!*a1)
            {
LABEL_35:
              free((void *)v36);
              goto LABEL_31;
            }
            v39 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v36, v38, &v57, 1, a5, 0);
            v40 = v57;
            free((void *)v36);
            v36 = 0;
            if (!v39 || v40 != (_DWORD)v38)
              goto LABEL_32;
            LOBYTE(v57) = 75;
            if (!_ETLResponseRingBuffer)
              TelephonyUtilRingBufferInitialize();
            v36 = 0;
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v50, (uint64_t)&_ETLResponseRingBuffer, &v57, a5)|| v57 != 75)
            {
              goto LABEL_32;
            }
            v57 = 0;
            v56 = -21846;
            v55 = -21846;
            if (ETLSubsysParseHeader((uint64_t)v50, &v56, &v55, &v57, v41, v42, v43, v44))
            {
              if (v56 == 253)
              {
                if (v55 == 62)
                {
                  v45 = DWORD2(v50[0]) - v57;
                  if (v45 <= 1)
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseResponseLoopbackMode", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v11, v12, v13, v14, v15, v16, v45);
                  }
                  else
                  {
                    if (*(_WORD *)(*(_QWORD *)&v50[0] + v57) == 1)
                    {
                      v36 = 1;
LABEL_32:
                      HDLCFrameFree();
                      HDLCFrameFree();
                      return v36;
                    }
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseResponseLoopbackMode", (uint64_t)"Received response with failure status [%d]\n", v11, v12, v13, v14, v15, v16, *(unsigned __int16 *)(*(_QWORD *)&v50[0] + v57));
                  }
LABEL_31:
                  v36 = 0;
                  goto LABEL_32;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, v55);
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, v56);
              }
            }
            v46 = "ETLMaverickParseResponseLoopbackMode";
            v47 = "Failed to parse BSP response header\n";
          }
LABEL_30:
          _ETLDebugPrint((uint64_t)v46, (uint64_t)v47, v11, v12, v13, v14, v15, v16, v49);
          goto LABEL_31;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v49);
      }
      v46 = "ETLMaverickAddLoopbackModeHeader";
      v47 = "Failed to create command header\n";
      goto LABEL_30;
    }
    v46 = "ETLMaverickLoopbackMode";
    v47 = "Failed to create command frame\n";
    goto LABEL_30;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickLoopbackMode", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v49);
  return 0;
}

uint64_t ETLMaverickMHILoopbackMode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t FreeSpace;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  const char *v50;
  uint64_t v52;
  _OWORD v53[2];
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  unsigned __int16 v60;
  int v61;

  if (a1)
  {
    v9 = a3;
    v55 = 0u;
    v56 = 0u;
    v57 = 0;
    memset(v53, 0, sizeof(v53));
    v54 = 0;
    if ((HDLCFrameCreateUplink() & 1) == 0)
    {
      v49 = "ETLMaverickMHILoopbackMode";
      v50 = "Failed to create command frame\n";
      goto LABEL_30;
    }
    v58 = a2;
    v59 = v9;
    FreeSpace = HDLCFrameGetFreeSpace();
    if (FreeSpace < 4)
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v19, v20, v21, v22, v23, v24, FreeSpace);
    }
    else
    {
      v61 = 5176651;
      if ((HDLCFrameInject() & 1) != 0)
      {
        if (HDLCFrameGetFreeSpace() > 0xC)
        {
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInject();
          v37 = (uint64_t)malloc((2 * DWORD2(v55) + 32));
          if (!v37)
          {
LABEL_32:
            HDLCFrameFree();
            HDLCFrameFree();
            return v37;
          }
          v38 = HDLCFrameEncode();
          if (!(_DWORD)v38)
            goto LABEL_35;
          v39 = v38;
          LODWORD(v58) = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v37, v38);
          if (!*a1)
          {
LABEL_35:
            free((void *)v37);
            goto LABEL_31;
          }
          v40 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, _QWORD))*a1)(a1, v37, v39, &v58, 1, a4, 0);
          v41 = v58;
          free((void *)v37);
          v37 = 0;
          if (!v40 || v41 != (_DWORD)v39)
            goto LABEL_32;
          LOBYTE(v58) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v37 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v53, (uint64_t)&_ETLResponseRingBuffer, &v58, a4)|| v58 != 75)
          {
            goto LABEL_32;
          }
          LODWORD(v58) = 0;
          LOWORD(v61) = -21846;
          v60 = -21846;
          if (ETLSubsysParseHeader((uint64_t)v53, &v61, &v60, &v58, v42, v43, v44, v45))
          {
            if ((unsigned __int16)v61 == 253)
            {
              if (v60 == 78)
              {
                v46 = (DWORD2(v53[0]) - v58);
                if (v46 <= 4)
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseResponseMHILoopbackMode", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v12, v13, v14, v15, v16, v17, v46);
                }
                else
                {
                  v47 = *(_QWORD *)&v53[0] + v58;
                  v48 = *(unsigned int *)(v47 + 1);
                  v37 = 1;
                  if (!(_DWORD)v48 || !*(_BYTE *)v47)
                    goto LABEL_32;
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseResponseMHILoopbackMode", (uint64_t)"Received response with failure status [%d]\n", v12, v13, v14, v15, v16, v17, v48);
                }
                goto LABEL_31;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v12, v13, v14, v15, v16, v17, v60);
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v12, v13, v14, v15, v16, v17, (unsigned __int16)v61);
            }
          }
          v49 = "ETLMaverickParseResponseMHILoopbackMode";
          v50 = "Failed to parse BSP response header\n";
LABEL_30:
          _ETLDebugPrint((uint64_t)v49, (uint64_t)v50, v12, v13, v14, v15, v16, v17, v52);
LABEL_31:
          v37 = 0;
          goto LABEL_32;
        }
        _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v31, v32, v33, v34, v35, v36, 13);
        v50 = "There is no more free spaces.\n";
LABEL_29:
        v49 = "ETLMaverickAddMHILoopbackModeHeader";
        goto LABEL_30;
      }
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v25, v26, v27, v28, v29, v30, v52);
    }
    v50 = "Failed to create command header\n";
    goto LABEL_29;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickMHILoopbackMode", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v52);
  return 0;
}

uint64_t ETLMaverickRFSelfTestTrigger(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t FreeSpace;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const char *v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD v66[2];
  uint64_t v67;
  _OWORD v68[2];
  uint64_t v69;
  unsigned __int16 v70;
  unsigned __int16 v71;
  unsigned int v72;

  if (!a1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickRFSelfTestTrigger", (uint64_t)"Transport parameter is NULL\n", a3, a4, a5, a6, a7, a8, v64);
    return 0;
  }
  if (!a2)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickRFSelfTestTrigger", (uint64_t)"Trigger info parameter is NULL\n", a3, a4, a5, a6, a7, a8, v64);
    return 0;
  }
  v69 = 0;
  memset(v68, 0, sizeof(v68));
  memset(v66, 0, sizeof(v66));
  v67 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v55 = "ETLMaverickRFSelfTestTrigger";
    v56 = "Failed to create command frame\n";
LABEL_25:
    _ETLDebugPrint((uint64_t)v55, (uint64_t)v56, v10, v11, v12, v13, v14, v15, v64);
    goto LABEL_26;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
LABEL_23:
    _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSubCommandHeader", (uint64_t)"Failed on creating RF Command Header\n", v57, v58, v59, v60, v61, v62, v65);
LABEL_24:
    v55 = "ETLMaverickAddRFSelfTestTriggerInfo";
    v56 = "Failed on creating RF Sub Command Header\n";
    goto LABEL_25;
  }
  v72 = 4455243;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v23, v24, v25, v26, v27, v28, v64);
    goto LABEL_23;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSubCommandHeader", (uint64_t)"Not enough room, need %zu, have %zu\n", v29, v30, v31, v32, v33, v34, 2);
    goto LABEL_24;
  }
  HDLCFrameInjectUnsignedShort();
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    v63 = 4;
LABEL_31:
    _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSelfTestTriggerInfo", (uint64_t)"Not enough room, need %zu, have %zu\n", v35, v36, v37, v38, v39, v40, v63);
    goto LABEL_26;
  }
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  if (HDLCFrameGetFreeSpace() <= 0x103)
  {
    v63 = 260;
    goto LABEL_31;
  }
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  v41 = 0;
  if (ETLSendCommand(a1, (uint64_t)v68, a3))
  {
    if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v66, a3))
    {
      v72 = 0;
      v71 = -21846;
      v70 = -21846;
      if (ETLSubsysParseHeader((uint64_t)v66, &v71, &v70, &v72, v42, v43, v44, v45))
      {
        if (v71 == 251)
        {
          if (v70 == 67)
          {
            v52 = DWORD2(v66[0]) - v72;
            if (v52 <= 3)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestTriggerResponse", (uint64_t)"Received response has only %zu bytes, need %zu\n", v46, v47, v48, v49, v50, v51, v52);
            }
            else if (*(_WORD *)(*(_QWORD *)&v66[0] + v72) == 11)
            {
              v53 = *(unsigned __int16 *)(*(_QWORD *)&v66[0] + v72 + 2);
              if ((_DWORD)v53 == 1)
              {
                v41 = 1;
                goto LABEL_27;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestTriggerResponse", (uint64_t)"Received response with failure status [%d]\n", v46, v47, v48, v49, v50, v51, v53);
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v46, v47, v48, v49, v50, v51, v70);
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v46, v47, v48, v49, v50, v51, v71);
        }
      }
    }
LABEL_26:
    v41 = 0;
  }
LABEL_27:
  HDLCFrameFree();
  HDLCFrameFree();
  return v41;
}

uint64_t ETLMaverickRFSelfTestResult(uint64_t (**a1)(_QWORD, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD), _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _WORD *v64;
  const char *v65;
  const char *v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v75;
  uint64_t v76;
  _OWORD v77[2];
  uint64_t v78;
  __int128 v79;
  __int128 v80;
  uint64_t v81;
  unsigned __int16 v82;
  unsigned __int16 v83;
  unsigned int v84;

  if (a1)
  {
    if (a2)
    {
      v81 = 0;
      v79 = 0u;
      v80 = 0u;
      memset(v77, 0, sizeof(v77));
      v78 = 0;
      if ((HDLCFrameCreateUplink() & 1) == 0)
      {
        v66 = "ETLMaverickRFSelfTestResult";
        v67 = "Failed to create command frame\n";
LABEL_33:
        _ETLDebugPrint((uint64_t)v66, (uint64_t)v67, v11, v12, v13, v14, v15, v16, v75);
        goto LABEL_34;
      }
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        v84 = 4455243;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameGetFreeSpace() > 1)
          {
            HDLCFrameInjectUnsignedShort();
            if (HDLCFrameGetFreeSpace() <= 3)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSelfTestResultHeader", (uint64_t)"Not enough room, need %zu, have %zu\n", v36, v37, v38, v39, v40, v41, 4);
            }
            else
            {
              HDLCFrameInjectUnsignedShort();
              HDLCFrameInjectUnsignedShort();
              v42 = (uint64_t)malloc((2 * DWORD2(v79) + 32));
              if (!v42)
              {
LABEL_35:
                HDLCFrameFree();
                HDLCFrameFree();
                return v42;
              }
              v43 = HDLCFrameEncode();
              if (!(_DWORD)v43)
                goto LABEL_39;
              v44 = v43;
              v84 = -1431655766;
              if ((_ETLDebugFlags & 2) != 0)
                ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v42, v43);
              if (*a1)
              {
                v45 = (*a1)(a1, v42, v44, &v84, 1, a3, 0);
                v46 = v84;
                free((void *)v42);
                v42 = 0;
                if (!v45 || v46 != (_DWORD)v44)
                  goto LABEL_35;
                if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v77, a3))
                {
                  v84 = 0;
                  v83 = -21846;
                  v82 = -21846;
                  if (ETLSubsysParseHeader((uint64_t)v77, &v83, &v82, &v84, v47, v48, v49, v50))
                  {
                    if (v83 == 251)
                    {
                      if (v82 == 67)
                      {
                        v57 = v84;
                        v58 = DWORD2(v77[0]) - v84;
                        v59 = v84 + 6;
                        v84 += 6;
                        if (v58 <= 5)
                        {
                          _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestResultResponse", (uint64_t)"Received response has only %zu bytes, need %zu\n", v51, v52, v53, v54, v55, v56, v58);
                        }
                        else
                        {
                          v60 = *(_QWORD *)&v77[0] + v57;
                          v61 = *(unsigned __int16 *)(*(_QWORD *)&v77[0] + v57);
                          if ((_DWORD)v61 == 21)
                          {
                            if (*(_WORD *)(v60 + 4) == 100)
                            {
                              v62 = *(unsigned __int16 *)(v60 + 2);
                              if ((_DWORD)v62 == 1)
                              {
                                v63 = DWORD2(v77[0]) - v59;
                                if (v63 > 0x205)
                                {
                                  v64 = (_WORD *)(*(_QWORD *)&v77[0] + v59);
                                  *a2 = *v64;
                                  a2[1] = v64[1];
                                  a2[2] = v64[2];
                                  a2[3] = v64[3];
                                  a2[4] = v64[4];
                                  a2[5] = v64[5];
                                  a2[6] = v64[6];
                                  a2[7] = v64[7];
                                  a2[8] = v64[8];
                                  a2[9] = v64[9];
                                  a2[10] = v64[10];
                                  a2[11] = v64[11];
                                  a2[12] = v64[12];
                                  a2[13] = v64[13];
                                  a2[14] = v64[14];
                                  a2[15] = v64[15];
                                  a2[16] = v64[16];
                                  a2[17] = v64[17];
                                  a2[18] = v64[18];
                                  a2[19] = v64[19];
                                  a2[20] = v64[20];
                                  a2[21] = v64[21];
                                  a2[22] = v64[22];
                                  a2[23] = v64[23];
                                  a2[24] = v64[24];
                                  a2[25] = v64[25];
                                  a2[26] = v64[26];
                                  a2[27] = v64[27];
                                  a2[28] = v64[28];
                                  a2[29] = v64[29];
                                  a2[30] = v64[30];
                                  a2[31] = v64[31];
                                  a2[32] = v64[32];
                                  a2[33] = v64[33];
                                  a2[34] = v64[34];
                                  a2[35] = v64[35];
                                  a2[36] = v64[36];
                                  a2[37] = v64[37];
                                  a2[38] = v64[38];
                                  a2[39] = v64[39];
                                  a2[40] = v64[40];
                                  a2[41] = v64[41];
                                  a2[42] = v64[42];
                                  a2[43] = v64[43];
                                  a2[44] = v64[44];
                                  a2[45] = v64[45];
                                  a2[46] = v64[46];
                                  a2[47] = v64[47];
                                  a2[48] = v64[48];
                                  a2[49] = v64[49];
                                  a2[50] = v64[50];
                                  a2[51] = v64[51];
                                  a2[52] = v64[52];
                                  a2[53] = v64[53];
                                  a2[54] = v64[54];
                                  a2[55] = v64[55];
                                  a2[56] = v64[56];
                                  a2[57] = v64[57];
                                  a2[58] = v64[58];
                                  a2[59] = v64[59];
                                  a2[60] = v64[60];
                                  a2[61] = v64[61];
                                  a2[62] = v64[62];
                                  a2[63] = v64[63];
                                  a2[64] = v64[64];
                                  a2[65] = v64[65];
                                  a2[66] = v64[66];
                                  a2[67] = v64[67];
                                  a2[68] = v64[68];
                                  a2[69] = v64[69];
                                  a2[70] = v64[70];
                                  a2[71] = v64[71];
                                  a2[72] = v64[72];
                                  a2[73] = v64[73];
                                  a2[74] = v64[74];
                                  a2[75] = v64[75];
                                  a2[76] = v64[76];
                                  a2[77] = v64[77];
                                  a2[78] = v64[78];
                                  a2[79] = v64[79];
                                  a2[80] = v64[80];
                                  a2[81] = v64[81];
                                  a2[82] = v64[82];
                                  a2[83] = v64[83];
                                  a2[84] = v64[84];
                                  a2[85] = v64[85];
                                  a2[86] = v64[86];
                                  a2[87] = v64[87];
                                  a2[88] = v64[88];
                                  a2[89] = v64[89];
                                  a2[90] = v64[90];
                                  a2[91] = v64[91];
                                  a2[92] = v64[92];
                                  a2[93] = v64[93];
                                  a2[94] = v64[94];
                                  a2[95] = v64[95];
                                  a2[96] = v64[96];
                                  a2[97] = v64[97];
                                  a2[98] = v64[98];
                                  a2[99] = v64[99];
                                  a2[100] = v64[100];
                                  a2[101] = v64[101];
                                  a2[102] = v64[102];
                                  a2[103] = v64[103];
                                  a2[104] = v64[104];
                                  a2[105] = v64[105];
                                  a2[106] = v64[106];
                                  a2[107] = v64[107];
                                  a2[108] = v64[108];
                                  a2[109] = v64[109];
                                  a2[110] = v64[110];
                                  a2[111] = v64[111];
                                  a2[112] = v64[112];
                                  a2[113] = v64[113];
                                  a2[114] = v64[114];
                                  a2[115] = v64[115];
                                  a2[116] = v64[116];
                                  a2[117] = v64[117];
                                  a2[118] = v64[118];
                                  a2[119] = v64[119];
                                  a2[120] = v64[120];
                                  a2[121] = v64[121];
                                  a2[122] = v64[122];
                                  a2[123] = v64[123];
                                  a2[124] = v64[124];
                                  a2[125] = v64[125];
                                  a2[126] = v64[126];
                                  a2[127] = v64[127];
                                  a2[128] = v64[128];
                                  a2[129] = v64[129];
                                  a2[130] = v64[130];
                                  a2[131] = v64[131];
                                  a2[132] = v64[132];
                                  a2[133] = v64[133];
                                  a2[134] = v64[134];
                                  a2[135] = v64[135];
                                  a2[136] = v64[136];
                                  a2[137] = v64[137];
                                  a2[138] = v64[138];
                                  a2[139] = v64[139];
                                  a2[140] = v64[140];
                                  a2[141] = v64[141];
                                  a2[142] = v64[142];
                                  a2[143] = v64[143];
                                  a2[144] = v64[144];
                                  a2[145] = v64[145];
                                  a2[146] = v64[146];
                                  a2[147] = v64[147];
                                  a2[148] = v64[148];
                                  a2[149] = v64[149];
                                  a2[150] = v64[150];
                                  a2[151] = v64[151];
                                  a2[152] = v64[152];
                                  a2[153] = v64[153];
                                  a2[154] = v64[154];
                                  a2[155] = v64[155];
                                  a2[156] = v64[156];
                                  a2[157] = v64[157];
                                  a2[158] = v64[158];
                                  a2[159] = v64[159];
                                  a2[160] = v64[160];
                                  a2[161] = v64[161];
                                  a2[162] = v64[162];
                                  a2[163] = v64[163];
                                  a2[164] = v64[164];
                                  a2[165] = v64[165];
                                  a2[166] = v64[166];
                                  a2[167] = v64[167];
                                  a2[168] = v64[168];
                                  a2[169] = v64[169];
                                  a2[170] = v64[170];
                                  a2[171] = v64[171];
                                  a2[172] = v64[172];
                                  a2[173] = v64[173];
                                  a2[174] = v64[174];
                                  a2[175] = v64[175];
                                  a2[176] = v64[176];
                                  a2[177] = v64[177];
                                  a2[178] = v64[178];
                                  a2[179] = v64[179];
                                  a2[180] = v64[180];
                                  a2[181] = v64[181];
                                  a2[182] = v64[182];
                                  a2[183] = v64[183];
                                  a2[184] = v64[184];
                                  a2[185] = v64[185];
                                  a2[186] = v64[186];
                                  a2[187] = v64[187];
                                  a2[188] = v64[188];
                                  a2[189] = v64[189];
                                  a2[190] = v64[190];
                                  a2[191] = v64[191];
                                  a2[192] = v64[192];
                                  a2[193] = v64[193];
                                  a2[194] = v64[194];
                                  a2[195] = v64[195];
                                  a2[196] = v64[196];
                                  a2[197] = v64[197];
                                  a2[198] = v64[198];
                                  a2[199] = v64[199];
                                  a2[200] = v64[200];
                                  a2[201] = v64[201];
                                  a2[202] = v64[202];
                                  a2[203] = v64[203];
                                  a2[204] = v64[204];
                                  a2[205] = v64[205];
                                  a2[206] = v64[206];
                                  a2[207] = v64[207];
                                  a2[208] = v64[208];
                                  a2[209] = v64[209];
                                  a2[210] = v64[210];
                                  a2[211] = v64[211];
                                  a2[212] = v64[212];
                                  a2[213] = v64[213];
                                  a2[214] = v64[214];
                                  a2[215] = v64[215];
                                  a2[216] = v64[216];
                                  a2[217] = v64[217];
                                  a2[218] = v64[218];
                                  a2[219] = v64[219];
                                  a2[220] = v64[220];
                                  a2[221] = v64[221];
                                  a2[222] = v64[222];
                                  a2[223] = v64[223];
                                  a2[224] = v64[224];
                                  a2[225] = v64[225];
                                  a2[226] = v64[226];
                                  a2[227] = v64[227];
                                  a2[228] = v64[228];
                                  a2[229] = v64[229];
                                  a2[230] = v64[230];
                                  a2[231] = v64[231];
                                  a2[232] = v64[232];
                                  a2[233] = v64[233];
                                  a2[234] = v64[234];
                                  a2[235] = v64[235];
                                  a2[236] = v64[236];
                                  a2[237] = v64[237];
                                  a2[238] = v64[238];
                                  a2[239] = v64[239];
                                  a2[240] = v64[240];
                                  a2[241] = v64[241];
                                  a2[242] = v64[242];
                                  a2[243] = v64[243];
                                  a2[244] = v64[244];
                                  a2[245] = v64[245];
                                  a2[246] = v64[246];
                                  a2[247] = v64[247];
                                  a2[248] = v64[248];
                                  a2[249] = v64[249];
                                  a2[250] = v64[250];
                                  a2[251] = v64[251];
                                  a2[252] = v64[252];
                                  a2[253] = v64[253];
                                  a2[254] = v64[254];
                                  a2[255] = v64[255];
                                  a2[256] = v64[256];
                                  a2[257] = v64[257];
                                  a2[258] = v64[258];
                                  v42 = 1;
                                  goto LABEL_35;
                                }
                                _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestResultResponse", (uint64_t)"Received result has only %zu bytes, need %zu\n", v51, v52, v53, v54, v55, v56, v63);
                              }
                              else
                              {
                                _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestResultResponse", (uint64_t)"Received response with failure status [%d]\n", v51, v52, v53, v54, v55, v56, v62);
                              }
                            }
                            else
                            {
                              _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestResultResponse", (uint64_t)"Received response with progress in-complete [%d %%]\n", v51, v52, v53, v54, v55, v56, *(unsigned __int16 *)(v60 + 4));
                            }
                          }
                          else
                          {
                            _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestResultResponse", (uint64_t)"Received response with invalid sub-command code [%d]\n", v51, v52, v53, v54, v55, v56, v61);
                          }
                        }
                      }
                      else
                      {
                        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v51, v52, v53, v54, v55, v56, v82);
                      }
                    }
                    else
                    {
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v51, v52, v53, v54, v55, v56, v83);
                    }
                  }
                }
              }
              else
              {
LABEL_39:
                free((void *)v42);
              }
            }
LABEL_34:
            v42 = 0;
            goto LABEL_35;
          }
          _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSubCommandHeader", (uint64_t)"Not enough room, need %zu, have %zu\n", v30, v31, v32, v33, v34, v35, 2);
          goto LABEL_32;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v75);
      }
      _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSubCommandHeader", (uint64_t)"Failed on creating RF Command Header\n", v68, v69, v70, v71, v72, v73, v76);
LABEL_32:
      v66 = "ETLMaverickAddRFSelfTestResultHeader";
      v67 = "Failed on creating RF Sub Command Header\n";
      goto LABEL_33;
    }
    v65 = "Result info parameter is NULL\n";
  }
  else
  {
    v65 = "Transport parameter is NULL\n";
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickRFSelfTestResult", (uint64_t)v65, a3, a4, a5, a6, a7, a8, v75);
  return 0;
}

uint64_t ETLMaverickGetBasebandInitStatusEx(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), _DWORD *a2, uint64_t a3, int a4)
{
  uint64_t inited;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t FreeSpace;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  void *v23;
  uint64_t v24;
  int v25;
  int v26;
  const char *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  _OWORD v37[2];
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  int v42;

  inited = 0;
  if (a1 && a2)
  {
    v39 = 0u;
    v40 = 0u;
    v41 = 0;
    memset(v37, 0, sizeof(v37));
    v38 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v16, v17, v18, v19, v20, v21, FreeSpace);
        goto LABEL_16;
      }
      v42 = 5373259;
      if ((HDLCFrameInject() & 1) != 0)
      {
        v22 = malloc((2 * DWORD2(v39) + 32));
        if (v22)
        {
          v23 = v22;
          v24 = HDLCFrameEncode();
          if ((_DWORD)v24)
          {
            v25 = -1431655766;
            v42 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0)
              ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v23, v24);
            if (*a1)
            {
              v26 = (*a1)(a1, v23, v24, &v42, 1, a3, 0);
              v25 = v42;
            }
            else
            {
              v26 = 0;
            }
            if (v25 == (_DWORD)v24)
              LODWORD(v24) = v26;
            else
              LODWORD(v24) = 0;
          }
          free(v23);
          if (!a4)
          {
LABEL_29:
            if ((_DWORD)v24)
            {
              LOBYTE(v42) = 75;
              if (!_ETLResponseRingBuffer)
                TelephonyUtilRingBufferInitialize();
              inited = 0;
              if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v37, (uint64_t)&_ETLResponseRingBuffer, &v42, a3)|| v42 != 75)
              {
                goto LABEL_36;
              }
              goto LABEL_34;
            }
            goto LABEL_35;
          }
LABEL_17:
          inited = 0;
          LOBYTE(v42) = 75;
          *a2 = 0;
          if ((_DWORD)v24)
          {
            if (!_ETLResponseRingBuffer)
              TelephonyUtilRingBufferInitialize();
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v37, (uint64_t)&_ETLResponseRingBuffer, &v42, a3))goto LABEL_35;
            if (v42 == 75)
            {
LABEL_34:
              inited = ETLMaverickParseParseBasebandInitStatusResponse((unsigned int *)v37, a2, v29, v30, v31, v32, v33, v34);
              goto LABEL_36;
            }
            if (v42 != 19)
            {
LABEL_35:
              inited = 0;
              goto LABEL_36;
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickGetBasebandInitStatusEx", (uint64_t)"BB Init status handler is not regisered yet. Treat it as not done\n", v29, v30, v31, v32, v33, v34, v36);
            inited = 1;
          }
LABEL_36:
          HDLCFrameFree();
          HDLCFrameFree();
          return inited;
        }
LABEL_16:
        LODWORD(v24) = 0;
        if (!a4)
          goto LABEL_29;
        goto LABEL_17;
      }
      v27 = "ETLSubsysAddHeaderInternal";
      v28 = "Failed to inject\n";
    }
    else
    {
      v27 = "ETLMaverickGetBasebandInitStatusEx";
      v28 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v27, (uint64_t)v28, v9, v10, v11, v12, v13, v14, v36);
    goto LABEL_16;
  }
  return inited;
}

uint64_t ETLMaverickParseParseBasebandInitStatusResponse(unsigned int *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v8 = a1[2];
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
LABEL_11:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseParseBasebandInitStatusResponse", (uint64_t)"Failed on parsing BSP Response.\n", v13, v14, v15, v16, v17, v18, v19);
    return 0;
  }
  v10 = **(_DWORD **)a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_11;
  }
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    goto LABEL_11;
  }
  v11 = HIWORD(v10);
  if ((_DWORD)v11 != 81)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
    goto LABEL_11;
  }
  if (v9 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseParseBasebandInitStatusResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    *a2 = *(_DWORD *)(*(_QWORD *)a1 + 4);
    return 1;
  }
}

uint64_t ETLMaverickGetBasebandInitStatus(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), _DWORD *a2, uint64_t a3)
{
  return ETLMaverickGetBasebandInitStatusEx(a1, a2, a3, 0);
}

unint64_t ETLMaverickIPALoopback(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t FreeSpace;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  const char *v46;
  uint64_t v48;
  _OWORD v49[2];
  uint64_t v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  unsigned __int16 v54;
  unsigned __int16 v55;
  unsigned int v56;

  if (a1)
  {
    v51 = 0u;
    v52 = 0u;
    v53 = 0;
    memset(v49, 0, sizeof(v49));
    v50 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
      }
      else
      {
        v56 = 5307723;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameGetFreeSpace() <= 0xC)
          {
            _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v29, v30, v31, v32, v33, v34, 13);
            v45 = "ETLMaverickAddIPALoopbackHeader";
            v46 = "There is no more free spaces.\n";
          }
          else
          {
            HDLCFrameInjectUnsignedChar();
            HDLCFrameInjectUnsignedInt();
            HDLCFrameInjectUnsignedInt();
            HDLCFrameInjectUnsignedInt();
            v35 = (unint64_t)malloc((2 * DWORD2(v51) + 32));
            if (!v35)
            {
LABEL_29:
              HDLCFrameFree();
              HDLCFrameFree();
              return v35;
            }
            v36 = HDLCFrameEncode();
            if (!(_DWORD)v36)
              goto LABEL_32;
            v37 = v36;
            v56 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0)
              ((void (*)(const char *, _QWORD, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v35, v36);
            if (!*a1)
            {
LABEL_32:
              free((void *)v35);
              goto LABEL_28;
            }
            v38 = ((uint64_t (*)(_QWORD *, unint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v35, v37, &v56, 1, a5, 0);
            v39 = v56;
            free((void *)v35);
            v35 = 0;
            if (!v38 || v39 != (_DWORD)v37)
              goto LABEL_29;
            LOBYTE(v56) = 75;
            if (!_ETLResponseRingBuffer)
              TelephonyUtilRingBufferInitialize();
            v35 = 0;
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v49, (uint64_t)&_ETLResponseRingBuffer, &v56, a5)|| v56 != 75)
            {
              goto LABEL_29;
            }
            v56 = 0;
            v55 = -21846;
            v54 = -21846;
            if (ETLSubsysParseHeader((uint64_t)v49, &v55, &v54, &v56, v40, v41, v42, v43))
            {
              if (v55 == 253)
              {
                if (v54 == 80)
                {
                  v44 = DWORD2(v49[0]) - v56;
                  if (v44 > 4)
                  {
                    v35 = (*(unsigned __int8 *)(*(_QWORD *)&v49[0] + v56) | *(_DWORD *)(*(_QWORD *)&v49[0] + v56 + 1)) == 0;
                    goto LABEL_29;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseIPALoopbackResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v10, v11, v12, v13, v14, v15, v44);
LABEL_28:
                  v35 = 0;
                  goto LABEL_29;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v10, v11, v12, v13, v14, v15, v54);
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v10, v11, v12, v13, v14, v15, v55);
              }
            }
            v45 = "ETLMaverickParseIPALoopbackResponse";
            v46 = "Failed on parsing BSP Response.\n";
          }
LABEL_27:
          _ETLDebugPrint((uint64_t)v45, (uint64_t)v46, v10, v11, v12, v13, v14, v15, v48);
          goto LABEL_28;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v23, v24, v25, v26, v27, v28, v48);
      }
      v45 = "ETLMaverickAddIPALoopbackHeader";
      v46 = "Failed to create command header\n";
      goto LABEL_27;
    }
    v45 = "ETLMaverickIPALoopback";
    v46 = "Failed to create command frame\n";
    goto LABEL_27;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickIPALoopback", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v48);
  return 0;
}

uint64_t ETLMaverickIPALoopbackV2(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  capabilities::etl *v29;
  int MaverickIPALoopbackV2ParametersType;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  const char *v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _OWORD v61[2];
  uint64_t v62;
  _OWORD v63[2];
  uint64_t v64;
  _DWORD v65[3];
  unsigned __int16 v66;
  unsigned __int16 v67;

  if (!a1)
  {
    v38 = "Transport cannot be NULL\n";
LABEL_11:
    _ETLDebugPrint((uint64_t)"ETLMaverickIPALoopbackV2", (uint64_t)v38, a3, a4, a5, a6, a7, a8, v59);
    return 0;
  }
  memset(v63, 0, sizeof(v63));
  v64 = 0;
  memset(v61, 0, sizeof(v61));
  v62 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v38 = "Failed to create command frame\n";
    goto LABEL_11;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLMaverickAddDataSubCommandHeader", (uint64_t)"Failed on creating Data Command Header\n", v40, v41, v42, v43, v44, v45, v60);
LABEL_15:
    v46 = "ETLMaverickAddIPALoopbackV2Header";
    v47 = "Failed to create command header with subcommand\n";
    goto LABEL_16;
  }
  v65[0] = 268461131;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v59);
    goto LABEL_14;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickAddDataSubCommandHeader", (uint64_t)"Not enough room, need %zu, have %zu\n", v23, v24, v25, v26, v27, v28, 2);
    goto LABEL_15;
  }
  v29 = (capabilities::etl *)HDLCFrameInjectUnsignedShort();
  MaverickIPALoopbackV2ParametersType = capabilities::etl::getMaverickIPALoopbackV2ParametersType(v29);
  if (MaverickIPALoopbackV2ParametersType)
  {
    if (MaverickIPALoopbackV2ParametersType == 1)
    {
      v37 = 23;
      goto LABEL_21;
    }
    v47 = "Invalid radio for IPA Loopback V2 Header";
    v46 = "ETLMaverickAddIPALoopbackV2Header";
LABEL_16:
    _ETLDebugPrint((uint64_t)v46, (uint64_t)v47, v31, v32, v33, v34, v35, v36, v59);
    goto LABEL_17;
  }
  v37 = 14;
LABEL_21:
  v65[0] = 1;
  v65[1] = v37;
  v65[2] = 1;
  if (HDLCFrameGetFreeSpace() <= 0xB)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v49, v50, v51, v52, v53, v54, 12);
    v47 = "There is no more free space\n";
    v46 = "ETLMaverickAddIPALoopbackV2Header";
    goto LABEL_16;
  }
  if (!HDLCFrameInject()
    || !ETLSendCommand(a1, (uint64_t)v63, a2)
    || !ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v61, a2))
  {
    goto LABEL_17;
  }
  v65[0] = 0;
  v67 = -21846;
  v66 = -21846;
  if (!ETLSubsysParseHeader((uint64_t)v61, &v67, &v66, v65, v55, v56, v57, v58))
    goto LABEL_34;
  if (v67 != 100)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v31, v32, v33, v34, v35, v36, v67);
LABEL_34:
    v46 = "ETLMaverickParseIPALoopbackV2Response";
    v47 = "Failed on parsing Data Response.\n";
    goto LABEL_16;
  }
  if (v66 != 4096)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v31, v32, v33, v34, v35, v36, v66);
    goto LABEL_34;
  }
  if ((DWORD2(v61[0]) - v65[0]) > 4)
  {
    v48 = 1;
    goto LABEL_18;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickParseIPALoopbackV2Response", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v31, v32, v33, v34, v35, v36, (DWORD2(v61[0]) - v65[0]));
LABEL_17:
  v48 = 0;
LABEL_18:
  HDLCFrameFree();
  HDLCFrameFree();
  return v48;
}

const char *ETLMaverickAPWakeReasonToString(int a1)
{
  const char *v1;

  v1 = "Invalid";
  if (a1 == 2)
    v1 = "Forced";
  if (a1 == 1)
    return "Data Activity";
  else
    return v1;
}

uint64_t ETLMaverickMHIPeriodicRemoteWake(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t FreeSpace;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  const char *v47;
  uint64_t v49;
  _OWORD v50[2];
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  unsigned __int16 v55;
  unsigned __int16 v56;
  unsigned int v57;

  if (a1)
  {
    v52 = 0u;
    v53 = 0u;
    v54 = 0;
    memset(v50, 0, sizeof(v50));
    v51 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
      }
      else
      {
        v57 = 5176651;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameGetFreeSpace() <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v29, v30, v31, v32, v33, v34, 4);
            v46 = "ETLMaverickAddMHIPeriodicRemoteWakeHeader";
            v47 = "There is no more free space.\n";
          }
          else
          {
            HDLCFrameInjectUnsignedChar();
            HDLCFrameInjectUnsignedChar();
            HDLCFrameInjectUnsignedShort();
            v35 = (uint64_t)malloc((2 * DWORD2(v52) + 32));
            if (!v35)
            {
LABEL_31:
              HDLCFrameFree();
              HDLCFrameFree();
              return v35;
            }
            v36 = HDLCFrameEncode();
            if (!(_DWORD)v36)
              goto LABEL_34;
            v37 = v36;
            v57 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0)
              ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v35, v36);
            if (!*a1)
            {
LABEL_34:
              free((void *)v35);
              goto LABEL_30;
            }
            v38 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v35, v37, &v57, 1, a4, 0);
            v39 = v57;
            free((void *)v35);
            v35 = 0;
            if (!v38 || v39 != (_DWORD)v37)
              goto LABEL_31;
            LOBYTE(v57) = 75;
            if (!_ETLResponseRingBuffer)
              TelephonyUtilRingBufferInitialize();
            v35 = 0;
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v50, (uint64_t)&_ETLResponseRingBuffer, &v57, a4)|| v57 != 75)
            {
              goto LABEL_31;
            }
            v57 = 0;
            v56 = -21846;
            v55 = -21846;
            if (ETLSubsysParseHeader((uint64_t)v50, &v56, &v55, &v57, v40, v41, v42, v43))
            {
              if (v56 == 253)
              {
                if (v55 == 78)
                {
                  v44 = DWORD2(v50[0]) - v57;
                  if (v44 <= 4)
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v10, v11, v12, v13, v14, v15, v44);
                  }
                  else
                  {
                    v45 = *(unsigned int *)(*(_QWORD *)&v50[0] + v57 + 1);
                    if ((_DWORD)v45 == 1 && *(_BYTE *)(*(_QWORD *)&v50[0] + v57) == 2)
                    {
                      v35 = 1;
                      goto LABEL_31;
                    }
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponse", (uint64_t)"Received response with failure status [%u] and command type [%u]\n", v10, v11, v12, v13, v14, v15, v45);
                  }
LABEL_30:
                  v35 = 0;
                  goto LABEL_31;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v10, v11, v12, v13, v14, v15, v55);
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v10, v11, v12, v13, v14, v15, v56);
              }
            }
            v46 = "ETLMaverickParseMHIPeriodicRemoteWakeResponse";
            v47 = "Failed to parse BSP response header\n";
          }
LABEL_29:
          _ETLDebugPrint((uint64_t)v46, (uint64_t)v47, v10, v11, v12, v13, v14, v15, v49);
          goto LABEL_30;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v23, v24, v25, v26, v27, v28, v49);
      }
      v46 = "ETLMaverickAddMHIPeriodicRemoteWakeHeader";
      v47 = "Failed to create command header\n";
      goto LABEL_29;
    }
    v46 = "ETLMaverickMHIPeriodicRemoteWake";
    v47 = "Failed to create command frame\n";
    goto LABEL_29;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickMHIPeriodicRemoteWake", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v49);
  return 0;
}

uint64_t ETLMaverickMHIPeriodicRemoteWakeV2(_QWORD *a1, unsigned __int8 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  const char *v47;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  const char *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  _OWORD v82[2];
  uint64_t v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;
  unsigned __int16 v87;
  unsigned __int16 v88;
  unsigned int v89;

  if (a1)
  {
    v84 = 0u;
    v85 = 0u;
    v86 = 0;
    memset(v82, 0, sizeof(v82));
    v83 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        v89 = 916811;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameGetFreeSpace() <= 5)
          {
            _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v30, v31, v32, v33, v34, v35, 6);
            v46 = "ETLMaverickAddMHIPeriodicRemoteWakeHeaderV2";
            v47 = "There is no more free space.\n";
          }
          else
          {
            HDLCFrameInjectUnsignedShort();
            HDLCFrameInjectUnsignedInt();
            v36 = (uint64_t)malloc((2 * DWORD2(v84) + 32));
            if (!v36)
            {
LABEL_30:
              HDLCFrameFree();
              HDLCFrameFree();
              return v36;
            }
            v37 = HDLCFrameEncode();
            if (!(_DWORD)v37)
              goto LABEL_33;
            v38 = v37;
            v89 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0)
              ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
            if (!*a1)
            {
LABEL_33:
              free((void *)v36);
              goto LABEL_29;
            }
            v39 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v36, v38, &v89, 1, a4, 0);
            v40 = v89;
            free((void *)v36);
            v36 = 0;
            if (!v39 || v40 != (_DWORD)v38)
              goto LABEL_30;
            LOBYTE(v89) = 75;
            if (!_ETLResponseRingBuffer)
              TelephonyUtilRingBufferInitialize();
            v36 = 0;
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v82, (uint64_t)&_ETLResponseRingBuffer, &v89, a4)|| v89 != 75)
            {
              goto LABEL_30;
            }
            v89 = 0;
            v88 = -21846;
            v87 = -21846;
            if (ETLSubsysParseHeader((uint64_t)v82, &v88, &v87, &v89, v41, v42, v43, v44))
            {
              if (v88 == 253)
              {
                if (v87 == 13)
                {
                  v45 = DWORD2(v82[0]) - v89;
                  if (v45 <= 0x15)
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v11, v12, v13, v14, v15, v16, v45);
                  }
                  else
                  {
                    if (!*(_BYTE *)(*(_QWORD *)&v82[0] + v89))
                    {
                      v49 = *(unsigned int *)(*(_QWORD *)&v82[0] + v89 + 2);
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Status: %s\n", v11, v12, v13, v14, v15, v16, (uint64_t)"success");
                      if (a2 == 1)
                      {
                        v62 = "Invalid";
                        if ((_DWORD)v49 == 2)
                          v62 = "Forced";
                        if ((_DWORD)v49 == 1)
                          v62 = "Data Activity";
                        _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Wakeup reason: %s\n", v50, v51, v52, v53, v54, v55, (uint64_t)v62);
                      }
                      else if (a2)
                      {
                        _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Invalid subCMD: %u\n", v50, v51, v52, v53, v54, v55, a2);
                      }
                      else
                      {
                        _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Delay: %u ms\n", v50, v51, v52, v53, v54, v55, v49);
                      }
                      v36 = 1;
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"MHI channel %d mask: %u\n", v56, v57, v58, v59, v60, v61, 1);
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"MHI channel %d mask: %u\n", v63, v64, v65, v66, v67, v68, 2);
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"MHI channel %d mask: %u\n", v69, v70, v71, v72, v73, v74, 3);
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"MHI channel %d mask: %u\n", v75, v76, v77, v78, v79, v80, 4);
                      goto LABEL_30;
                    }
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Received response with failure status [%u]\n", v11, v12, v13, v14, v15, v16, *(unsigned __int8 *)(*(_QWORD *)&v82[0] + v89));
                  }
                  goto LABEL_29;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, v87);
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, v88);
              }
            }
            v46 = "ETLMaverickParseMHIPeriodicRemoteWakeResponseV2";
            v47 = "Failed to parse BSP response header\n";
          }
LABEL_28:
          _ETLDebugPrint((uint64_t)v46, (uint64_t)v47, v11, v12, v13, v14, v15, v16, v81);
LABEL_29:
          v36 = 0;
          goto LABEL_30;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v81);
      }
      v46 = "ETLMaverickAddMHIPeriodicRemoteWakeHeaderV2";
      v47 = "Failed to create command header\n";
      goto LABEL_28;
    }
    v46 = "ETLMaverickMHIPeriodicRemoteWakeV2";
    v47 = "Failed to create command frame\n";
    goto LABEL_28;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickMHIPeriodicRemoteWakeV2", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v81);
  return 0;
}

uint64_t ETLMaverickADPLEnable(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int8 *v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v39;
  _OWORD v40[2];
  uint64_t v41;
  _OWORD v42[2];
  uint64_t v43;
  unsigned __int16 v44;
  unsigned __int16 v45;
  unsigned int v46;

  if (!a1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickADPLEnable", (uint64_t)"transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v39);
    return 0;
  }
  memset(v42, 0, sizeof(v42));
  v43 = 0;
  memset(v40, 0, sizeof(v40));
  v41 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_21;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_21;
  }
  v46 = 1073767499;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v39);
    goto LABEL_21;
  }
  if (!HDLCFrameInjectUnsignedChar())
  {
LABEL_21:
    v23 = 0;
    goto LABEL_22;
  }
  v23 = 0;
  if (HDLCFrameInjectUnsignedChar())
  {
    if (!HDLCFrameInjectUnsignedShort()
      || !HDLCFrameInjectUnsignedInt()
      || !ETLSendCommand(a1, (uint64_t)v42, a3)
      || !ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v40, a3))
    {
      goto LABEL_21;
    }
    v46 = 0;
    v45 = -21846;
    v44 = -21846;
    if (ETLSubsysParseHeader((uint64_t)v40, &v45, &v44, &v46, v24, v25, v26, v27))
    {
      if (v45 == 100)
      {
        if (v44 == 0x4000)
        {
          v34 = DWORD2(v40[0]) - v46;
          if (v34 > 1)
          {
            v35 = (unsigned __int8 *)(*(_QWORD *)&v40[0] + v46);
            v36 = *v35;
            if ((_DWORD)v36 == 4)
            {
              v37 = v35[1];
              if (v37 == 1)
              {
                v23 = 1;
                goto LABEL_22;
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickADPLParseResponse", (uint64_t)"Received response with version [%u] while expecting [%u]\n", v28, v29, v30, v31, v32, v33, v36);
              v37 = v35[1];
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickADPLParseResponse", (uint64_t)"Received response with failure status [%u]\n", v28, v29, v30, v31, v32, v33, v37);
            goto LABEL_21;
          }
LABEL_26:
          _ETLDebugPrint((uint64_t)"ETLMaverickADPLParseResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v28, v29, v30, v31, v32, v33, v34);
          goto LABEL_21;
        }
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v28, v29, v30, v31, v32, v33, v44);
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v28, v29, v30, v31, v32, v33, v45);
      }
    }
    v34 = DWORD2(v40[0]) - v46;
    goto LABEL_26;
  }
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return v23;
}

uint64_t ETLMaverickGetResetProperties(uint64_t (**a1)(_QWORD, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  int v40;
  uint64_t v41;
  _OWORD v42[2];
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  int v47;

  if (a1)
  {
    v44 = 0u;
    v45 = 0u;
    v46 = 0;
    memset(v42, 0, sizeof(v42));
    v43 = 0;
    if (HDLCFrameCreateUplink())
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
      }
      else
      {
        v47 = 9436491;
        if ((HDLCFrameInject() & 1) != 0)
        {
          v24 = (uint64_t)malloc((2 * DWORD2(v44) + 32));
          if (!v24)
          {
LABEL_26:
            HDLCFrameFree();
            HDLCFrameFree();
            return v24;
          }
          v25 = HDLCFrameEncode();
          if ((_DWORD)v25)
          {
            v26 = v25;
            v47 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0)
              ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v24, v25);
            if (*a1)
            {
              v27 = (*a1)(a1, v24, v26, &v47, 1, a3, 0);
              v28 = v47;
              free((void *)v24);
              v24 = 0;
              if (!v27 || v28 != (_DWORD)v26)
                goto LABEL_26;
              LOBYTE(v47) = 75;
              if (!_ETLResponseRingBuffer)
                TelephonyUtilRingBufferInitialize();
              v24 = 0;
              if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v42, (uint64_t)&_ETLResponseRingBuffer, &v47, a3)|| v47 != 75)
              {
                goto LABEL_26;
              }
              v35 = (DWORD2(v42[0]) - 4);
              if (DWORD2(v42[0]) < 4)
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v29, v30, v31, v32, v33, v34, DWORD2(v42[0]));
              }
              else
              {
                v36 = *(_QWORD *)&v42[0];
                v37 = **(_DWORD **)&v42[0];
                if (**(_DWORD **)&v42[0] == 75)
                {
                  if (BYTE1(v37) == 253)
                  {
                    v38 = HIWORD(v37);
                    if ((_DWORD)v38 == 143)
                    {
                      if (v35 > 6)
                      {
                        *(_BYTE *)a2 = *(_BYTE *)(*(_QWORD *)&v42[0] + 4);
                        *(_WORD *)(a2 + 2) = *(_WORD *)(v36 + 5);
                        *(_DWORD *)(a2 + 4) = *(_DWORD *)(v36 + 7);
                        v24 = 1;
                        goto LABEL_26;
                      }
                      goto LABEL_33;
                    }
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v29, v30, v31, v32, v33, v34, v38);
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v29, v30, v31, v32, v33, v34, BYTE1(v37));
                  }
                  v40 = -4;
LABEL_32:
                  v35 = (DWORD2(v42[0]) + v40);
LABEL_33:
                  _ETLDebugPrint((uint64_t)"ETLMaverickGetResetPropertiesParseResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v29, v30, v31, v32, v33, v34, v35);
                  goto LABEL_25;
                }
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v29, v30, v31, v32, v33, v34, **(_DWORD **)&v42[0]);
              }
              v40 = 0;
              goto LABEL_32;
            }
          }
          free((void *)v24);
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v18, v19, v20, v21, v22, v23, v41);
        }
      }
    }
LABEL_25:
    v24 = 0;
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetResetProperties", (uint64_t)"transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v41);
  return 0;
}

uint64_t ETLMaverickQDSSEnable(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;
  unsigned __int16 v64;
  unsigned __int16 v65;
  int v66;

  if (a1)
  {
    v61 = 0u;
    v62 = 0u;
    v63 = 0;
    v58 = 0u;
    v59 = 0u;
    v60 = 0;
    if (HDLCFrameCreateUplink())
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
      }
      else
      {
        v66 = 16865867;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (!HDLCFrameInjectUnsignedChar())
            goto LABEL_38;
          v23 = malloc((2 * DWORD2(v61) + 32));
          if (!v23)
            goto LABEL_38;
          v24 = v23;
          v25 = HDLCFrameEncode();
          if (!(_DWORD)v25)
            goto LABEL_40;
          v26 = v25;
          v66 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v24, v25);
          if (*a1)
          {
            v27 = (*a1)(a1, v24, v26, &v66, 1, a3, 0);
            v28 = v66;
            free(v24);
            if (!v27 || v28 != (_DWORD)v26)
              goto LABEL_38;
            LOBYTE(v66) = 75;
            if (!_ETLResponseRingBuffer)
              TelephonyUtilRingBufferInitialize();
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)&v58, (uint64_t)&_ETLResponseRingBuffer, &v66, a3))goto LABEL_38;
            if (v66 != 75)
              goto LABEL_38;
            v66 = 0;
            v65 = -21846;
            v64 = -21846;
            if (!ETLSubsysParseHeader((uint64_t)&v58, &v65, &v64, &v66, v29, v30, v31, v32))
              goto LABEL_38;
            v39 = v65;
            if (v65 == 90)
            {
              v40 = v64;
              if (v64 != 257)
              {
LABEL_42:
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v33, v34, v35, v36, v37, v38, v40);
                goto LABEL_38;
              }
              HDLCFrameFree();
              HDLCFrameFree();
              v61 = 0u;
              v62 = 0u;
              v63 = 0;
              v58 = 0u;
              v59 = 0u;
              v60 = 0;
              if (!HDLCFrameCreateUplink())
                goto LABEL_38;
              if (!ETLMaverickQDSSBuildCommand())
                goto LABEL_38;
              if (!ETLSendCommand(a1, (uint64_t)&v61, a3))
                goto LABEL_38;
              if (!ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)&v58, a3))
                goto LABEL_38;
              v66 = 0;
              v65 = -21846;
              v64 = -21846;
              if (!ETLSubsysParseHeader((uint64_t)&v58, &v65, &v64, &v66, v41, v42, v43, v44))
                goto LABEL_38;
              v39 = v65;
              if (v65 == 18)
              {
                v40 = v64;
                if (v64 == 548)
                {
                  HDLCFrameFree();
                  HDLCFrameFree();
                  v61 = 0u;
                  v62 = 0u;
                  v63 = 0;
                  v58 = 0u;
                  v59 = 0u;
                  v60 = 0;
                  if (HDLCFrameCreateUplink()
                    && ETLMaverickQDSSBuildCommand()
                    && ETLSendCommand(a1, (uint64_t)&v61, a3)
                    && ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)&v58, a3))
                  {
                    v66 = 0;
                    v65 = -21846;
                    v64 = -21846;
                    v55 = 0;
                    if (!ETLSubsysParseHeader((uint64_t)&v58, &v65, &v64, &v66, v45, v46, v47, v48))
                    {
LABEL_48:
                      HDLCFrameFree();
                      HDLCFrameFree();
                      return v55;
                    }
                    if (v65 == 18)
                    {
                      if (v64 == 548)
                      {
                        v55 = 1;
                        goto LABEL_48;
                      }
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v49, v50, v51, v52, v53, v54, v64);
                    }
                    else
                    {
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v49, v50, v51, v52, v53, v54, v65);
                    }
                  }
                  v55 = 0;
                  goto LABEL_48;
                }
                goto LABEL_42;
              }
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v33, v34, v35, v36, v37, v38, v39);
          }
          else
          {
LABEL_40:
            free(v24);
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v57);
        }
      }
    }
LABEL_38:
    HDLCFrameFree();
    HDLCFrameFree();
    return 0;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickQDSSEnable", (uint64_t)"transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v57);
  return 1;
}

uint64_t ETLMaverickQDSSBuildCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameInjectUnsignedChar()
      && HDLCFrameInjectUnsignedChar()
      && HDLCFrameInjectUnsignedChar()
      && HDLCFrameInjectUnsignedChar()
      && HDLCFrameInjectUnsignedChar()
      && HDLCFrameInjectUnsignedChar()
      && HDLCFrameInjectUnsignedChar()
      && HDLCFrameInjectUnsignedChar()
      && HDLCFrameInjectUnsignedChar())
    {
      return HDLCFrameInjectUnsignedChar();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v14);
  }
  return 0;
}

uint64_t ETLMaverickSetFlags(_QWORD *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t FreeSpace;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  const char *v38;
  const char *v39;
  uint64_t v41;
  uint64_t v42;
  _OWORD v43[2];
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  unsigned __int16 v48;
  unsigned __int16 v49;
  unsigned int v50;

  if (a1)
  {
    *a4 = 0;
    _ETLDebugPrint((uint64_t)"ETLMaverickSetFlags", (uint64_t)"Setting enabled to 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, a2);
    v47 = 0;
    v45 = 0u;
    v46 = 0u;
    memset(v43, 0, sizeof(v43));
    v44 = 0;
    v12 = 0;
    if (!HDLCFrameCreateUplink())
    {
LABEL_26:
      HDLCFrameFree();
      HDLCFrameFree();
      return v12;
    }
    FreeSpace = HDLCFrameGetFreeSpace();
    if (FreeSpace >= 4)
    {
      v50 = 7994699;
      if ((HDLCFrameInject() & 1) != 0)
      {
        if (HDLCFrameGetFreeSpace() <= 1)
        {
          v42 = 2;
          v38 = "ETLMaverickCreateSetFlagsCommand";
          v39 = "Not enough room, need %zu, have %u\n";
        }
        else
        {
          if (!HDLCFrameInjectUnsignedInt())
            goto LABEL_25;
          v26 = malloc((2 * DWORD2(v45) + 32));
          if (!v26)
            goto LABEL_25;
          v27 = v26;
          v28 = HDLCFrameEncode();
          if (!(_DWORD)v28)
            goto LABEL_28;
          v29 = v28;
          v50 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v27, v28);
          if (!*a1)
          {
LABEL_28:
            free(v27);
            goto LABEL_25;
          }
          v30 = ((uint64_t (*)(_QWORD *, void *, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v27, v29, &v50, 1, a5, 0);
          v31 = v50;
          free(v27);
          v12 = 0;
          if (!v30 || v31 != (_DWORD)v29)
            goto LABEL_26;
          if (!ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v43, a5))
            goto LABEL_25;
          v50 = 0;
          v49 = -21846;
          v48 = -21846;
          if (ETLSubsysParseHeader((uint64_t)v43, &v49, &v48, &v50, v32, v33, v34, v35))
          {
            if (v49 == 253)
            {
              if (v48 == 121)
              {
                *a4 = 0;
                v36 = DWORD2(v43[0]) - v50;
                if (v36 > 7)
                {
                  v37 = (_DWORD *)(*(_QWORD *)&v43[0] + v50);
                  *a3 = *v37;
                  *a4 = v37[1];
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSetFlagsResponse", (uint64_t)"Received response w/ flag [%u] and version [%u]\n", v20, v21, v22, v23, v24, v25, *a3);
                  v12 = 1;
                  goto LABEL_26;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetFlagsResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v20, v21, v22, v23, v24, v25, v36);
LABEL_25:
                v12 = 0;
                goto LABEL_26;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v20, v21, v22, v23, v24, v25, v48);
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v20, v21, v22, v23, v24, v25, v49);
            }
          }
          v38 = "ETLMaverickParseSetFlagsResponse";
          v39 = "Failed to parse BSP response header\n";
        }
      }
      else
      {
        v38 = "ETLSubsysAddHeaderInternal";
        v39 = "Failed to inject\n";
      }
      _ETLDebugPrint((uint64_t)v38, (uint64_t)v39, v20, v21, v22, v23, v24, v25, v42);
      goto LABEL_25;
    }
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
    goto LABEL_25;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetFlags", (uint64_t)"transport cannot be NULL\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v41);
  return 0;
}

uint64_t ETLMaverickParseCSNResponse(unsigned int *a1, _DWORD *a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t result;

  *a2 = 0;
  *a3 = 0;
  v8 = a1[2];
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        v11 = HIWORD(v10);
        if ((_DWORD)v11 == (_DWORD)a4)
        {
          if (v9 <= 0x11)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseCSNResponse", (uint64_t)"Received response has only %u bytes, need %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else
          {
            v12 = *(unsigned __int8 *)(*(_QWORD *)a1 + 4);
            *a3 = v12;
            switch(v12)
            {
              case 3:
                result = 1;
                *a2 = 1;
                break;
              case 2:
                return 1;
              case 1:
                *a2 = 2;
                return 1;
              default:
                return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
  return result;
}

uint64_t ETLMaverickGetCardType(_QWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  char v32;
  void *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t (*v37)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD);
  int v38;
  int v39;
  BOOL v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  _OWORD v47[2];
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  int v52;

  v49 = 0u;
  v50 = 0u;
  v51 = 0;
  memset(v47, 0, sizeof(v47));
  v48 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    v29 = "ETLMaverickGetCardType";
    v30 = "Failed to create command frame\n";
LABEL_20:
    _ETLDebugPrint((uint64_t)v29, (uint64_t)v30, a3, a4, a5, a6, a7, a8, v45);
LABEL_21:
    v24 = 0;
    goto LABEL_22;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_21;
  }
  v52 = 5504331;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v29 = "ETLSubsysAddHeaderInternal";
    v30 = "Failed to inject\n";
    goto LABEL_20;
  }
  v46 = -86;
  if (!HDLCFrameInjectUnsignedChar())
    goto LABEL_21;
  v18 = malloc((2 * DWORD2(v49) + 32));
  if (!v18)
    goto LABEL_21;
  v19 = v18;
  v20 = HDLCFrameEncode();
  if (!(_DWORD)v20)
    goto LABEL_44;
  v21 = v20;
  v52 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
  if (!*a1)
  {
LABEL_44:
    free(v19);
    goto LABEL_21;
  }
  v22 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v19, v21, &v52, 1, a4, 0);
  v23 = v52;
  free(v19);
  v24 = 0;
  if (v22 && v23 == (_DWORD)v21)
  {
    LOBYTE(v52) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v24 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v47, (uint64_t)&_ETLResponseRingBuffer, &v52, a4))
    {
      if (v52 == 75)
      {
        v24 = ETLMaverickParseCSNResponse((unsigned int *)v47, a2, &v46, 83, v25, v26, v27, v28);
        if (v46 == 2)
        {
          while (1)
          {
            while (1)
            {
              do
              {
                do
                {
                  v32 = v24;
                  usleep(0x186A0u);
                  LOBYTE(v24) = 0;
                }
                while ((v32 & 1) == 0);
                v33 = malloc((2 * DWORD2(v49) + 32));
                LOBYTE(v24) = 0;
              }
              while (!v33);
              v34 = v33;
              v35 = HDLCFrameEncode();
              if ((_DWORD)v35)
                break;
LABEL_23:
              free(v34);
              LOBYTE(v24) = 0;
            }
            v36 = v35;
            v52 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0)
            {
              ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v34, v35);
              v37 = (uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1;
              if (!*a1)
                goto LABEL_23;
            }
            else
            {
              v37 = (uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1;
              if (!*a1)
                goto LABEL_23;
            }
            v38 = v37(a1, v34, v36, &v52, 1, a4, 0);
            v39 = v52;
            free(v34);
            LOBYTE(v24) = 0;
            if (v38)
              v40 = v39 == (_DWORD)v36;
            else
              v40 = 0;
            if (v40)
            {
              LOBYTE(v52) = 75;
              if (!_ETLResponseRingBuffer)
                TelephonyUtilRingBufferInitialize();
              LOBYTE(v24) = 0;
              if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v47, (uint64_t)&_ETLResponseRingBuffer, &v52, a4))
              {
                if (v52 == 75)
                {
                  v24 = ETLMaverickParseCSNResponse((unsigned int *)v47, a2, &v46, 83, v41, v42, v43, v44);
                  if (v46 != 2)
                    break;
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return v24;
}

uint64_t ETLMaverickParseBSPExtResponse(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v8 = *a2;
  v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseBSPExtResponse", (uint64_t)"Failed to parse BSP response header\n", v15, v16, v17, v18, v19, v20, v21);
    return 0;
  }
  v10 = *(_DWORD *)(*(_QWORD *)a1 + v8);
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
    goto LABEL_12;
  }
  v11 = v8 + 4;
  *a2 = v8 + 4;
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    goto LABEL_12;
  }
  v12 = HIWORD(v10);
  if ((_DWORD)v12 != 68)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_12;
  }
  if (*(_DWORD *)(a1 + 8) - v11 <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseBSPExtResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", a3, a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 8) - v11);
    return 0;
  }
  else
  {
    v13 = *(unsigned __int16 *)(*(_QWORD *)a1 + v11);
    if ((_DWORD)v13 == 1)
    {
      *a2 = v8 + 6;
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickParseBSPExtResponse", (uint64_t)"Received response with failure status [%d]\n", a3, a4, a5, a6, a7, a8, v13);
      return 0;
    }
  }
}

uint64_t ETLCDMAMakeMEID(_DWORD *a1, int *a2)
{
  BOOL v2;
  uint64_t v3;
  int v4;

  if (a1)
    v2 = a2 == 0;
  else
    v2 = 1;
  v3 = !v2;
  if (!v2)
  {
    v4 = *a2;
    *(_DWORD *)((char *)a1 + 3) = *(int *)((char *)a2 + 3);
    *a1 = v4;
  }
  return v3;
}

uint64_t ETLCDMAMakeMEIDFromString(_BYTE *a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;

  v9 = 0;
  if (a1 && __s && (v9 = strlen(__s), v9 == 14))
  {
    v10 = TelephonyUtilDecodeHexWithDefault();
    v11 = TelephonyUtilDecodeHexWithDefault();
    if (((v11 | (16 * v10)) & 0x80000000) == 0)
    {
      *a1 = v11 | (16 * v10);
      v12 = TelephonyUtilDecodeHexWithDefault();
      v13 = TelephonyUtilDecodeHexWithDefault();
      if (((v13 | (16 * v12)) & 0x80000000) == 0)
      {
        a1[1] = v13 | (16 * v12);
        v14 = TelephonyUtilDecodeHexWithDefault();
        v15 = TelephonyUtilDecodeHexWithDefault();
        if (((v15 | (16 * v14)) & 0x80000000) == 0)
        {
          a1[2] = v15 | (16 * v14);
          v16 = TelephonyUtilDecodeHexWithDefault();
          v17 = TelephonyUtilDecodeHexWithDefault();
          if (((v17 | (16 * v16)) & 0x80000000) == 0)
          {
            a1[3] = v17 | (16 * v16);
            v18 = TelephonyUtilDecodeHexWithDefault();
            v19 = TelephonyUtilDecodeHexWithDefault();
            if (((v19 | (16 * v18)) & 0x80000000) == 0)
            {
              a1[4] = v19 | (16 * v18);
              v20 = TelephonyUtilDecodeHexWithDefault();
              v21 = TelephonyUtilDecodeHexWithDefault();
              if (((v21 | (16 * v20)) & 0x80000000) == 0)
              {
                a1[5] = v21 | (16 * v20);
                v22 = TelephonyUtilDecodeHexWithDefault();
                v23 = TelephonyUtilDecodeHexWithDefault() | (16 * v22);
                if ((v23 & 0x80000000) == 0)
                {
                  a1[6] = v23;
                  return 1;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLCDMAMakeMEIDFromString", (uint64_t)"MEID length is %zu, expected %u\n", a3, a4, a5, a6, a7, a8, v9);
  }
  return 0;
}

uint64_t ETLCDMAMakeStringFromMEID(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8;
  uint64_t v10;

  if (a1)
    v8 = a3 == 0;
  else
    v8 = 1;
  v10 = !v8 && a2 > 0xE;
  if ((_DWORD)v10 == 1)
  {
    TelephonyUtilEncodeHex();
    *a1 = -86;
    a1[1] = -86;
    TelephonyUtilEncodeHex();
    a1[2] = -86;
    a1[3] = -86;
    TelephonyUtilEncodeHex();
    a1[4] = -86;
    a1[5] = -86;
    TelephonyUtilEncodeHex();
    a1[6] = -86;
    a1[7] = -86;
    TelephonyUtilEncodeHex();
    a1[8] = -86;
    a1[9] = -86;
    TelephonyUtilEncodeHex();
    a1[10] = -86;
    a1[11] = -86;
    TelephonyUtilEncodeHex();
    a1[12] = -86;
    a1[13] = -86;
    a1[14] = 0;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLCDMAMakeStringFromMEID", (uint64_t)"buffer capacity is %u, need %u\n", a3, a4, a5, a6, a7, a8, a2);
  }
  return v10;
}

uint64_t ETLCDMAMakeStringFromMEIDRegular(uint64_t a1, unsigned int a2, uint64_t a3)
{
  BOOL v3;
  uint64_t v5;

  if (a1)
    v3 = a3 == 0;
  else
    v3 = 1;
  v5 = !v3 && a2 > 0xE;
  if ((_DWORD)v5 == 1)
    TelephonyUtilBinToHex();
  return v5;
}

uint64_t ETLCDMAGetMEID(uint64_t (**a1)(_QWORD, void *, uint64_t, _OWORD *, uint64_t, uint64_t, _QWORD), _DWORD *a2, uint64_t a3)
{
  uint64_t result;
  int v5;
  unsigned int v6;
  _OWORD v7[8];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v5 = -1431655766;
  v6 = -1431655766;
  memset(v7, 0, sizeof(v7));
  result = (uint64_t)ETLNVRead(a1, 1943, v7, 128, &v6, &v5, a3);
  if ((_DWORD)result)
  {
    if (v5 != 5 && v5 || v6 < 7)
    {
      return 0;
    }
    else
    {
      *a2 = v7[0];
      *(_DWORD *)((char *)a2 + 3) = *(_DWORD *)((char *)v7 + 3);
      return 1;
    }
  }
  return result;
}

BOOL ETLCDMAIsValidMEID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char __s2[16];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  memset(__s2, 170, 15);
  ETLCDMAMakeStringFromMEID(__s2, 15, a1, a4, a5, a6, a7, a8);
  return strncmp((const char *)kDefaultMEID, __s2, 0xEuLL) != 0;
}

uint64_t ETLCDMASetMEID(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3)
{
  int v4;

  return ETLNVWriteWithStatus(a1, 1943, a2, 7u, &v4, a3);
}

uint64_t APPLIB_API_MAV_DeAssertResetDetect(void *a1, unsigned int a2)
{
  return APPLIB_API_SUBSYS_SendCommand(a1, a2, 253, 7, 0, 0);
}

uint64_t APPLIB_API_MAV_PowerDown(void *a1, unsigned int a2)
{
  return APPLIB_API_SUBSYS_SendCommand(a1, a2, 253, 9, 0, 0);
}

uint64_t APPLIB_API_MAV_SetCoreDumpMode(void *a1, unsigned int a2, __int16 a3)
{
  __int16 v4;

  v4 = a3;
  return APPLIB_API_SUBSYS_SendCommand(a1, a2, 253, 10, (uint64_t)&v4, 2);
}

uint64_t APPLIB_API_MAV_SendFuseCommand(void *a1, unsigned int a2, __int16 a3, __int16 a4, int *a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  _WORD v9[2];
  int v10;
  uint64_t v11;
  uint64_t v12;

  if (a6 != 4)
    return 0xFFFFFFFFLL;
  v11 = v6;
  v12 = v7;
  v9[0] = a4;
  v9[1] = a3;
  v10 = *a5;
  return APPLIB_API_SUBSYS_SendCommand(a1, a2, 253, 11, (uint64_t)v9, 8);
}

uint64_t APPLIB_API_MAV_ParseFuseResponse(uint64_t a1, unsigned int a2, _WORD *a3, _DWORD *a4)
{
  uint64_t result;

  if (a2 < 4)
    return 0;
  result = 0;
  if (*(_BYTE *)a1 == 75 && *(unsigned __int8 *)(a1 + 1) == 253)
  {
    if (*(_WORD *)(a1 + 2) == 11)
    {
      *a3 = *(_WORD *)(a1 + 4);
      *a4 = *(_DWORD *)(a1 + 6);
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t APPLIB_API_MAV_SendAPWakeCommand(void *a1, unsigned int a2, __int16 a3)
{
  __int16 v4;

  v4 = a3;
  return APPLIB_API_SUBSYS_SendCommand(a1, a2, 253, 13, (uint64_t)&v4, 2);
}

uint64_t APPLIB_API_MAV_ParseAPWakeResponse(uint64_t a1, unsigned int a2, uint64_t a3, _WORD *a4)
{
  uint64_t result;

  *a4 = -1;
  if (a2 < 4)
    return 0;
  result = 0;
  if (*(_BYTE *)a1 == 75 && *(unsigned __int8 *)(a1 + 1) == 253)
  {
    if (*(_WORD *)(a1 + 2) == 13)
    {
      *a4 = *(_WORD *)(a1 + 6);
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t APPLIB_DIAG_CreateFile(char *a1, int a2, const void *a3, int a4)
{
  uint64_t result;
  unsigned __int16 v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  unsigned __int16 v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  unsigned __int16 v37;
  unsigned __int16 v38;
  unsigned int v39;
  uint64_t v40;
  size_t v41;
  int v42;
  int v43;
  _BYTE __src[2048];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a4 <= 32 && a4 + 7 <= a2)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 523851;
    memcpy(a1 + 4, a3, a4);
    v9 = crc_16_l_table[a1[4] ^ 0xA4];
    v10 = crc_16_l_table[(a1[5] ^ v9) ^ 4];
    v11 = crc_16_l_table[(a1[6] ^ v10 ^ HIBYTE(v9))];
    v12 = crc_16_l_table[(a1[7] ^ v11 ^ HIBYTE(v10))];
    v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
    v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
    v15 = crc_16_l_table[(a1[10] ^ v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[(a1[11] ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(a1[12] ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a1[13] ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[(a1[14] ^ v18 ^ HIBYTE(v17))];
    v20 = crc_16_l_table[(a1[15] ^ v19 ^ HIBYTE(v18))];
    v21 = crc_16_l_table[(a1[16] ^ v20 ^ HIBYTE(v19))];
    v22 = crc_16_l_table[(a1[17] ^ v21 ^ HIBYTE(v20))];
    v23 = crc_16_l_table[(a1[18] ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(a1[19] ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a1[20] ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a1[21] ^ v25 ^ HIBYTE(v24))];
    v27 = crc_16_l_table[(a1[22] ^ v26 ^ HIBYTE(v25))];
    v28 = crc_16_l_table[(a1[23] ^ v27 ^ HIBYTE(v26))];
    v29 = crc_16_l_table[(a1[24] ^ v28 ^ HIBYTE(v27))];
    v30 = crc_16_l_table[(a1[25] ^ v29 ^ HIBYTE(v28))];
    v31 = crc_16_l_table[(a1[26] ^ v30 ^ HIBYTE(v29))];
    v32 = crc_16_l_table[(a1[27] ^ v31 ^ HIBYTE(v30))];
    v33 = crc_16_l_table[(a1[28] ^ v32 ^ HIBYTE(v31))];
    v34 = crc_16_l_table[(a1[29] ^ v33 ^ HIBYTE(v32))];
    v35 = crc_16_l_table[(a1[30] ^ v34 ^ HIBYTE(v33))];
    v36 = crc_16_l_table[(a1[31] ^ v35 ^ HIBYTE(v34))];
    v37 = crc_16_l_table[(a1[32] ^ v36 ^ HIBYTE(v35))];
    v38 = crc_16_l_table[(a1[33] ^ v37 ^ HIBYTE(v36))];
    v39 = crc_16_l_table[(a1[34] ^ v38 ^ HIBYTE(v37))];
    *((_WORD *)a1 + 18) = crc_16_l_table[(a1[35] ^ v39 ^ HIBYTE(v38))] ^ ~(unsigned __int16)(v39 >> 8);
    if (a2 >= 76)
    {
      bzero(__src, 0x800uLL);
      v40 = 0;
      LODWORD(v41) = 0;
      do
      {
        while (1)
        {
          v43 = a1[v40];
          if ((v43 - 125) > 1)
            break;
          v42 = v41 + 1;
          __src[(int)v41] = 125;
          __src[(int)v41 + 1] = v43 ^ 0x20;
          v41 = (int)v41 + 1 + 1;
          if (++v40 == 38)
            goto LABEL_10;
        }
        v42 = v41;
        __src[(int)v41] = v43;
        v41 = (int)v41 + 1;
        ++v40;
      }
      while (v40 != 38);
LABEL_10:
      memcpy(a1, __src, v41);
      result = (v42 + 2);
      a1[v41] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetFileInfo(char *a1, int a2, const void *a3, int a4)
{
  uint64_t result;
  unsigned __int16 v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  unsigned __int16 v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  unsigned __int16 v37;
  unsigned __int16 v38;
  unsigned int v39;
  uint64_t v40;
  size_t v41;
  int v42;
  int v43;
  _BYTE __src[2048];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a4 <= 32 && a4 + 7 <= a2)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 785995;
    memcpy(a1 + 4, a3, a4);
    v9 = crc_16_l_table[a1[4] ^ 4];
    v10 = crc_16_l_table[a1[5] ^ 0xAD ^ v9];
    v11 = crc_16_l_table[(a1[6] ^ v10 ^ HIBYTE(v9))];
    v12 = crc_16_l_table[(a1[7] ^ v11 ^ HIBYTE(v10))];
    v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
    v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
    v15 = crc_16_l_table[(a1[10] ^ v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[(a1[11] ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(a1[12] ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a1[13] ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[(a1[14] ^ v18 ^ HIBYTE(v17))];
    v20 = crc_16_l_table[(a1[15] ^ v19 ^ HIBYTE(v18))];
    v21 = crc_16_l_table[(a1[16] ^ v20 ^ HIBYTE(v19))];
    v22 = crc_16_l_table[(a1[17] ^ v21 ^ HIBYTE(v20))];
    v23 = crc_16_l_table[(a1[18] ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(a1[19] ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a1[20] ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a1[21] ^ v25 ^ HIBYTE(v24))];
    v27 = crc_16_l_table[(a1[22] ^ v26 ^ HIBYTE(v25))];
    v28 = crc_16_l_table[(a1[23] ^ v27 ^ HIBYTE(v26))];
    v29 = crc_16_l_table[(a1[24] ^ v28 ^ HIBYTE(v27))];
    v30 = crc_16_l_table[(a1[25] ^ v29 ^ HIBYTE(v28))];
    v31 = crc_16_l_table[(a1[26] ^ v30 ^ HIBYTE(v29))];
    v32 = crc_16_l_table[(a1[27] ^ v31 ^ HIBYTE(v30))];
    v33 = crc_16_l_table[(a1[28] ^ v32 ^ HIBYTE(v31))];
    v34 = crc_16_l_table[(a1[29] ^ v33 ^ HIBYTE(v32))];
    v35 = crc_16_l_table[(a1[30] ^ v34 ^ HIBYTE(v33))];
    v36 = crc_16_l_table[(a1[31] ^ v35 ^ HIBYTE(v34))];
    v37 = crc_16_l_table[(a1[32] ^ v36 ^ HIBYTE(v35))];
    v38 = crc_16_l_table[(a1[33] ^ v37 ^ HIBYTE(v36))];
    v39 = crc_16_l_table[(a1[34] ^ v38 ^ HIBYTE(v37))];
    *((_WORD *)a1 + 18) = crc_16_l_table[(a1[35] ^ v39 ^ HIBYTE(v38))] ^ ~(unsigned __int16)(v39 >> 8);
    if (a2 >= 76)
    {
      bzero(__src, 0x800uLL);
      v40 = 0;
      LODWORD(v41) = 0;
      do
      {
        while (1)
        {
          v43 = a1[v40];
          if ((v43 - 125) > 1)
            break;
          v42 = v41 + 1;
          __src[(int)v41] = 125;
          __src[(int)v41 + 1] = v43 ^ 0x20;
          v41 = (int)v41 + 1 + 1;
          if (++v40 == 38)
            goto LABEL_10;
        }
        v42 = v41;
        __src[(int)v41] = v43;
        v41 = (int)v41 + 1;
        ++v40;
      }
      while (v40 != 38);
LABEL_10:
      memcpy(a1, __src, v41);
      result = (v42 + 2);
      a1[v41] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_DeleteFile(char *a1, int a2, const void *a3, int a4)
{
  uint64_t result;
  unsigned __int16 v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  unsigned __int16 v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  unsigned __int16 v37;
  unsigned __int16 v38;
  unsigned int v39;
  uint64_t v40;
  size_t v41;
  int v42;
  int v43;
  _BYTE __src[2048];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a4 <= 32 && a4 + 7 <= a2)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 589387;
    memcpy(a1 + 4, a3, a4);
    v9 = crc_16_l_table[a1[4] ^ 0x6CLL];
    v10 = crc_16_l_table[(a1[5] ^ v9) ^ 0x87];
    v11 = crc_16_l_table[(a1[6] ^ v10 ^ HIBYTE(v9))];
    v12 = crc_16_l_table[(a1[7] ^ v11 ^ HIBYTE(v10))];
    v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
    v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
    v15 = crc_16_l_table[(a1[10] ^ v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[(a1[11] ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(a1[12] ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a1[13] ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[(a1[14] ^ v18 ^ HIBYTE(v17))];
    v20 = crc_16_l_table[(a1[15] ^ v19 ^ HIBYTE(v18))];
    v21 = crc_16_l_table[(a1[16] ^ v20 ^ HIBYTE(v19))];
    v22 = crc_16_l_table[(a1[17] ^ v21 ^ HIBYTE(v20))];
    v23 = crc_16_l_table[(a1[18] ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(a1[19] ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a1[20] ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a1[21] ^ v25 ^ HIBYTE(v24))];
    v27 = crc_16_l_table[(a1[22] ^ v26 ^ HIBYTE(v25))];
    v28 = crc_16_l_table[(a1[23] ^ v27 ^ HIBYTE(v26))];
    v29 = crc_16_l_table[(a1[24] ^ v28 ^ HIBYTE(v27))];
    v30 = crc_16_l_table[(a1[25] ^ v29 ^ HIBYTE(v28))];
    v31 = crc_16_l_table[(a1[26] ^ v30 ^ HIBYTE(v29))];
    v32 = crc_16_l_table[(a1[27] ^ v31 ^ HIBYTE(v30))];
    v33 = crc_16_l_table[(a1[28] ^ v32 ^ HIBYTE(v31))];
    v34 = crc_16_l_table[(a1[29] ^ v33 ^ HIBYTE(v32))];
    v35 = crc_16_l_table[(a1[30] ^ v34 ^ HIBYTE(v33))];
    v36 = crc_16_l_table[(a1[31] ^ v35 ^ HIBYTE(v34))];
    v37 = crc_16_l_table[(a1[32] ^ v36 ^ HIBYTE(v35))];
    v38 = crc_16_l_table[(a1[33] ^ v37 ^ HIBYTE(v36))];
    v39 = crc_16_l_table[(a1[34] ^ v38 ^ HIBYTE(v37))];
    *((_WORD *)a1 + 18) = crc_16_l_table[(a1[35] ^ v39 ^ HIBYTE(v38))] ^ ~(unsigned __int16)(v39 >> 8);
    if (a2 >= 76)
    {
      bzero(__src, 0x800uLL);
      v40 = 0;
      LODWORD(v41) = 0;
      do
      {
        while (1)
        {
          v43 = a1[v40];
          if ((v43 - 125) > 1)
            break;
          v42 = v41 + 1;
          __src[(int)v41] = 125;
          __src[(int)v41 + 1] = v43 ^ 0x20;
          v41 = (int)v41 + 1 + 1;
          if (++v40 == 38)
            goto LABEL_10;
        }
        v42 = v41;
        __src[(int)v41] = v43;
        v41 = (int)v41 + 1;
        ++v40;
      }
      while (v40 != 38);
LABEL_10:
      memcpy(a1, __src, v41);
      result = (v42 + 2);
      a1[v41] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_WriteFile(char *a1, int a2, const void *a3, int a4, int a5, _OWORD *a6)
{
  uint64_t result;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  int v19;
  int v20;
  char *v21;
  char v22;
  uint64_t v23;
  size_t v24;
  int v25;
  int v26;
  _BYTE __src[2048];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a4 <= 32 && a4 + 135 <= a2)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 720459;
    *((_DWORD *)a1 + 1) = a5;
    memcpy(a1 + 8, a3, a4);
    v13 = a6[2];
    v14 = a6[3];
    v15 = a6[1];
    *(_OWORD *)(a1 + 40) = *a6;
    *(_OWORD *)(a1 + 88) = v14;
    *(_OWORD *)(a1 + 72) = v13;
    *(_OWORD *)(a1 + 56) = v15;
    v16 = a6[6];
    v17 = a6[7];
    v18 = a6[5];
    *(_OWORD *)(a1 + 104) = a6[4];
    *(_OWORD *)(a1 + 152) = v17;
    *(_OWORD *)(a1 + 136) = v16;
    *(_OWORD *)(a1 + 120) = v18;
    v19 = 1344;
    LOWORD(v20) = -1;
    v21 = a1;
    do
    {
      v22 = *v21++;
      v20 = crc_16_l_table[(v22 ^ v20)] ^ ((unsigned __int16)(v20 & 0xFF00) >> 8);
      v19 -= 8;
    }
    while ((_WORD)v19);
    *((_WORD *)a1 + 84) = ~(_WORD)v20;
    if (a2 >= 340)
    {
      bzero(__src, 0x800uLL);
      v23 = 0;
      LODWORD(v24) = 0;
      do
      {
        while (1)
        {
          v26 = a1[v23];
          if ((v26 - 125) > 1)
            break;
          v25 = v24 + 1;
          __src[(int)v24] = 125;
          __src[(int)v24 + 1] = v26 ^ 0x20;
          v24 = (int)v24 + 1 + 1;
          if (++v23 == 170)
            goto LABEL_12;
        }
        v25 = v24;
        __src[(int)v24] = v26;
        v24 = (int)v24 + 1;
        ++v23;
      }
      while (v23 != 170);
LABEL_12:
      memcpy(a1, __src, v24);
      result = (v25 + 2);
      a1[v24] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadFile(char *a1, int a2, const void *a3, int a4, int a5)
{
  uint64_t result;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  unsigned __int16 v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  unsigned __int16 v37;
  unsigned __int16 v38;
  unsigned __int16 v39;
  unsigned __int16 v40;
  unsigned __int16 v41;
  unsigned __int16 v42;
  unsigned __int16 v43;
  unsigned __int16 v44;
  unsigned int v45;
  uint64_t v46;
  size_t v47;
  int v48;
  int v49;
  _BYTE __src[2048];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a4 <= 32 && a4 + 135 <= a2)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 654923;
    *((_DWORD *)a1 + 1) = a5;
    memcpy(a1 + 8, a3, a4);
    v11 = crc_16_l_table[a5 ^ 0xB4];
    v12 = crc_16_l_table[(v11 ^ BYTE1(a5)) ^ 0x9E];
    v13 = crc_16_l_table[(v12 ^ HIBYTE(v11) ^ BYTE2(a5))];
    v14 = crc_16_l_table[(a1[7] ^ v13 ^ HIBYTE(v12))];
    v15 = crc_16_l_table[(a1[8] ^ v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[(a1[9] ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(a1[10] ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(a1[11] ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[(a1[12] ^ v18 ^ HIBYTE(v17))];
    v20 = crc_16_l_table[(a1[13] ^ v19 ^ HIBYTE(v18))];
    v21 = crc_16_l_table[(a1[14] ^ v20 ^ HIBYTE(v19))];
    v22 = crc_16_l_table[(a1[15] ^ v21 ^ HIBYTE(v20))];
    v23 = crc_16_l_table[(a1[16] ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(a1[17] ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a1[18] ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a1[19] ^ v25 ^ HIBYTE(v24))];
    v27 = crc_16_l_table[(a1[20] ^ v26 ^ HIBYTE(v25))];
    v28 = crc_16_l_table[(a1[21] ^ v27 ^ HIBYTE(v26))];
    v29 = crc_16_l_table[(a1[22] ^ v28 ^ HIBYTE(v27))];
    v30 = crc_16_l_table[(a1[23] ^ v29 ^ HIBYTE(v28))];
    v31 = crc_16_l_table[(a1[24] ^ v30 ^ HIBYTE(v29))];
    v32 = crc_16_l_table[(a1[25] ^ v31 ^ HIBYTE(v30))];
    v33 = crc_16_l_table[(a1[26] ^ v32 ^ HIBYTE(v31))];
    v34 = crc_16_l_table[(a1[27] ^ v33 ^ HIBYTE(v32))];
    v35 = crc_16_l_table[(a1[28] ^ v34 ^ HIBYTE(v33))];
    v36 = crc_16_l_table[(a1[29] ^ v35 ^ HIBYTE(v34))];
    v37 = crc_16_l_table[(a1[30] ^ v36 ^ HIBYTE(v35))];
    v38 = crc_16_l_table[(a1[31] ^ v37 ^ HIBYTE(v36))];
    v39 = crc_16_l_table[(a1[32] ^ v38 ^ HIBYTE(v37))];
    v40 = crc_16_l_table[(a1[33] ^ v39 ^ HIBYTE(v38))];
    v41 = crc_16_l_table[(a1[34] ^ v40 ^ HIBYTE(v39))];
    v42 = crc_16_l_table[(a1[35] ^ v41 ^ HIBYTE(v40))];
    v43 = crc_16_l_table[(a1[36] ^ v42 ^ HIBYTE(v41))];
    v44 = crc_16_l_table[(a1[37] ^ v43 ^ HIBYTE(v42))];
    v45 = crc_16_l_table[(a1[38] ^ v44 ^ HIBYTE(v43))];
    *((_WORD *)a1 + 20) = crc_16_l_table[(a1[39] ^ v45 ^ HIBYTE(v44))] ^ ~(unsigned __int16)(v45 >> 8);
    if (a2 >= 84)
    {
      bzero(__src, 0x800uLL);
      v46 = 0;
      LODWORD(v47) = 0;
      do
      {
        while (1)
        {
          v49 = a1[v46];
          if ((v49 - 125) > 1)
            break;
          v48 = v47 + 1;
          __src[(int)v47] = 125;
          __src[(int)v47 + 1] = v49 ^ 0x20;
          v47 = (int)v47 + 1 + 1;
          if (++v46 == 42)
            goto LABEL_10;
        }
        v48 = v47;
        __src[(int)v47] = v49;
        v47 = (int)v47 + 1;
        ++v46;
      }
      while (v46 != 42);
LABEL_10:
      memcpy(a1, __src, v47);
      result = (v48 + 2);
      a1[v47] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadICCID_EFS_File(_QWORD *a1, int a2)
{
  size_t v3;
  unsigned __int16 v4;
  unsigned __int16 v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  unsigned __int16 v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  unsigned int v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t result;
  _BYTE __src[2048];
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (a2 < 512)
    return 0xFFFFFFFFLL;
  v3 = a2;
  bzero(a1, a2);
  if (!a1)
    return 0xFFFFFFFFLL;
  bzero(a1, v3);
  *(_OWORD *)(a1 + 1) = *(_OWORD *)"sim.txt";
  *a1 = 654923;
  *(_OWORD *)(a1 + 3) = unk_1DAD14EB8;
  v4 = crc_16_l_table[*((_BYTE *)a1 + 8) ^ 0x6A ^ LOBYTE(crc_16_l_table[110])];
  v5 = crc_16_l_table[(*((_BYTE *)a1 + 9) ^ v4 ^ HIBYTE(crc_16_l_table[110]))];
  v6 = crc_16_l_table[(*((_BYTE *)a1 + 10) ^ v5 ^ HIBYTE(v4))];
  v7 = crc_16_l_table[(*((_BYTE *)a1 + 11) ^ v6 ^ HIBYTE(v5))];
  v8 = crc_16_l_table[(*((_BYTE *)a1 + 12) ^ v7 ^ HIBYTE(v6))];
  v9 = crc_16_l_table[(*((_BYTE *)a1 + 13) ^ v8 ^ HIBYTE(v7))];
  v10 = crc_16_l_table[(*((_BYTE *)a1 + 14) ^ v9 ^ HIBYTE(v8))];
  v11 = crc_16_l_table[(*((_BYTE *)a1 + 15) ^ v10 ^ HIBYTE(v9))];
  v12 = crc_16_l_table[(*((_BYTE *)a1 + 16) ^ v11 ^ HIBYTE(v10))];
  v13 = crc_16_l_table[(*((_BYTE *)a1 + 17) ^ v12 ^ HIBYTE(v11))];
  v14 = crc_16_l_table[(*((_BYTE *)a1 + 18) ^ v13 ^ HIBYTE(v12))];
  v15 = crc_16_l_table[(*((_BYTE *)a1 + 19) ^ v14 ^ HIBYTE(v13))];
  v16 = crc_16_l_table[(*((_BYTE *)a1 + 20) ^ v15 ^ HIBYTE(v14))];
  v17 = crc_16_l_table[(*((_BYTE *)a1 + 21) ^ v16 ^ HIBYTE(v15))];
  v18 = crc_16_l_table[(*((_BYTE *)a1 + 22) ^ v17 ^ HIBYTE(v16))];
  v19 = crc_16_l_table[(*((_BYTE *)a1 + 23) ^ v18 ^ HIBYTE(v17))];
  v20 = crc_16_l_table[(*((_BYTE *)a1 + 24) ^ v19 ^ HIBYTE(v18))];
  v21 = crc_16_l_table[(*((_BYTE *)a1 + 25) ^ v20 ^ HIBYTE(v19))];
  v22 = crc_16_l_table[(*((_BYTE *)a1 + 26) ^ v21 ^ HIBYTE(v20))];
  v23 = crc_16_l_table[(*((_BYTE *)a1 + 27) ^ v22 ^ HIBYTE(v21))];
  v24 = crc_16_l_table[(*((_BYTE *)a1 + 28) ^ v23 ^ HIBYTE(v22))];
  v25 = crc_16_l_table[(*((_BYTE *)a1 + 29) ^ v24 ^ HIBYTE(v23))];
  v26 = crc_16_l_table[(*((_BYTE *)a1 + 30) ^ v25 ^ HIBYTE(v24))];
  v27 = crc_16_l_table[(*((_BYTE *)a1 + 31) ^ v26 ^ HIBYTE(v25))];
  v28 = crc_16_l_table[(*((_BYTE *)a1 + 32) ^ v27 ^ HIBYTE(v26))];
  v29 = crc_16_l_table[(*((_BYTE *)a1 + 33) ^ v28 ^ HIBYTE(v27))];
  v30 = crc_16_l_table[(*((_BYTE *)a1 + 34) ^ v29 ^ HIBYTE(v28))];
  v31 = crc_16_l_table[(*((_BYTE *)a1 + 35) ^ v30 ^ HIBYTE(v29))];
  v32 = crc_16_l_table[(*((_BYTE *)a1 + 36) ^ v31 ^ HIBYTE(v30))];
  v33 = crc_16_l_table[(*((_BYTE *)a1 + 37) ^ v32 ^ HIBYTE(v31))];
  v34 = crc_16_l_table[(*((_BYTE *)a1 + 38) ^ v33 ^ HIBYTE(v32))];
  *((_WORD *)a1 + 20) = crc_16_l_table[(*((_BYTE *)a1 + 39) ^ v34 ^ HIBYTE(v33))] ^ ~(unsigned __int16)(v34 >> 8);
  bzero(__src, 0x800uLL);
  v35 = 0;
  LODWORD(v3) = 0;
  do
  {
    while (1)
    {
      v37 = *((unsigned __int8 *)a1 + v35);
      if ((v37 - 125) > 1)
        break;
      v36 = v3 + 1;
      __src[(int)v3] = 125;
      __src[(int)v3 + 1] = v37 ^ 0x20;
      v3 = (int)v3 + 1 + 1;
      if (++v35 == 42)
        goto LABEL_7;
    }
    v36 = v3;
    __src[(int)v3] = v37;
    v3 = (int)v3 + 1;
    ++v35;
  }
  while (v35 != 42);
LABEL_7:
  memcpy(a1, __src, v3);
  result = (v36 + 2);
  *((_BYTE *)a1 + v3) = 126;
  return result;
}

uint64_t ETLMaverickAddSecurityCommandHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseSecurityResponseHeader(uint64_t a1, int a2, _WORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int16 *v20;

  result = ETLMaverickParseBSPResponseHeader(a1, a4, 12, (uint64_t)a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    v19 = *a4;
    if ((*(_DWORD *)(a1 + 8) - v19) <= 3)
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", v13, v14, v15, v16, v17, v18, 4);
    }
    else
    {
      v20 = (unsigned __int16 *)(*(_QWORD *)a1 + v19);
      if (*v20 == a2)
      {
        *a3 = v20[1];
        *a4 = v19 + 4;
        return 1;
      }
      _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", v13, v14, v15, v16, v17, v18, *v20);
    }
    return 0;
  }
  return result;
}

uint64_t ETLMaverickSecurityCreateCheckCalibrationBackupCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseCheckCalibrationBackupResponse(int **a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        v12 = HIWORD(v11);
        if ((_DWORD)v12 == 12)
        {
          if (v9 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else
          {
            v13 = *((unsigned __int16 *)v10 + 2);
            if ((_DWORD)v13 == 13)
            {
              *a2 = *((_WORD *)v10 + 3);
              return 1;
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v13);
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateNVBackupCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseNVBackupResponse(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        v12 = HIWORD(v11);
        if ((_DWORD)v12 == 12)
        {
          if (v9 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else
          {
            v13 = *((unsigned __int16 *)v10 + 2);
            if ((_DWORD)v13 == 7)
            {
              if (*((_WORD *)v10 + 3))
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseNVBackupResponse", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 3));
                return 0;
              }
              else
              {
                return 1;
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v13);
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateNVRestoreCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseNVRestoreResponse(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        v12 = HIWORD(v11);
        if ((_DWORD)v12 == 12)
        {
          if (v9 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else
          {
            v13 = *((unsigned __int16 *)v10 + 2);
            if ((_DWORD)v13 == 8)
            {
              if (*((_WORD *)v10 + 3))
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickExpectStatus", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 3));
                return 0;
              }
              else
              {
                return 1;
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v13);
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickSecurityCreateReadSerialNumberAndChipIDCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseReadSerialNumberAndChipIDResponse(int **a1, _DWORD *a2, _DWORD *a3, uint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  _DWORD *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v13;

  v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  v9 = *a1;
  v10 = **a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, **a1);
    return 0;
  }
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, BYTE1(v10));
    return 0;
  }
  v11 = HIWORD(v10);
  if ((_DWORD)v11 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, v11);
    return 0;
  }
  if (v8 - 4 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, 4);
    return 0;
  }
  if (*((_WORD *)v9 + 2) != 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, *((unsigned __int16 *)v9 + 2));
    return 0;
  }
  if (*((_WORD *)v9 + 3))
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickExpectStatus", (uint64_t)"Status was %u\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, *((unsigned __int16 *)v9 + 3));
    return 0;
  }
  v13 = v8 - 8;
  if (v13 <= 7)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickSecurityParseReadSerialNumberAndChipIDResponse", (uint64_t)"Only have %u bytes, need %u\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, v13);
  }
  else if (a4 >= 4)
  {
    *a2 = v9[2];
    *a3 = 32;
    *a5 = v9[3];
    return 1;
  }
  return 0;
}

uint64_t ETLMaverickSecurityCreateGetFusingStatusCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseGetFusingStatusResponse(int **a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  _DWORD *v9;
  unsigned int v10;
  uint64_t v11;

  v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v9 = *a1;
    v10 = **a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        v11 = HIWORD(v10);
        if ((_DWORD)v11 == 12)
        {
          if (v8 - 4 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else if (*((_WORD *)v9 + 2) == 17)
          {
            if (*((_WORD *)v9 + 3))
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickExpectStatus", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 3));
              return 0;
            }
            else if ((v8 & 0xFFFFFFFC) == 8 || v9[2] != 4)
            {
              return 0;
            }
            else
            {
              *a2 = v9[3];
              return 1;
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 2));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickSecurityCreateReadPublicKeyHashCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseReadPublicKeyHashResponse(int **a1, void *__dst, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  _DWORD *v9;
  unsigned int v10;
  uint64_t v11;
  size_t v13;

  v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, (uint64_t)a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v9 = *a1;
    v10 = **a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        v11 = HIWORD(v10);
        if ((_DWORD)v11 == 12)
        {
          if (v8 - 4 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, (uint64_t)a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else if (*((_WORD *)v9 + 2) == 16)
          {
            if (*((_WORD *)v9 + 3))
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickExpectStatus", (uint64_t)"Status was %u\n", a3, (uint64_t)a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 3));
              return 0;
            }
            else
            {
              if ((v8 & 0xFFFFFFFC) == 8)
                return 0;
              v13 = v9[2];
              *a4 = v13;
              if ((int)v13 - 1 >= a3)
              {
                return 0;
              }
              else
              {
                memcpy(__dst, v9 + 3, v13);
                return 1;
              }
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, (uint64_t)a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 2));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickSecurityCreateReadNonceCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseReadNonceResponse(_DWORD **a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned __int16 *v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v13;
  size_t v16;

  v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  v9 = (unsigned __int16 *)*a1;
  v10 = **a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
    return 0;
  }
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v10));
    return 0;
  }
  v11 = HIWORD(v10);
  if ((_DWORD)v11 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v11);
    return 0;
  }
  if (v8 - 4 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  if (v9[2] != 2)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9[2]);
    return 0;
  }
  if (v9[3])
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickExpectStatus", (uint64_t)"Status was %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9[3]);
    return 0;
  }
  v13 = a4;
  v16 = v8 - 8;
  _ETLDebugPrint((uint64_t)"ETLMaverickSecurityParseReadNonceResponse", (uint64_t)"Nonce is %u bytes\n", (uint64_t)a3, a4, a5, a6, a7, a8, v16);
  if (v16 > v13)
    return 0;
  memcpy(a2, v9 + 4, v16);
  *a3 = 8 * v16;
  return 1;
}

uint64_t ETLMaverickSecurityCreateReadManifestStatusCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseReadManifestStatusResponse(int **a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v19;
  size_t v20;
  _WORD *v21;
  _WORD *v22;

  v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  v10 = *a1;
  v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    return 0;
  }
  if (BYTE1(v11) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
    return 0;
  }
  v12 = HIWORD(v11);
  if ((_DWORD)v12 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    return 0;
  }
  if (v8 - 4 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  v13 = *((unsigned __int16 *)v10 + 2);
  if ((_DWORD)v13 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v13);
    return 0;
  }
  v15 = *a2;
  v16 = 2 * *a2 + 6;
  v17 = v8 - 8;
  if (v16 - 2 > v17)
    return 0;
  if (v17 >= v16)
  {
    if (*((_WORD *)v10 + 3))
      return 0;
    v19 = 8;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickSecurityParseReadManifestStatusResponse", (uint64_t)"Manifest response size %u is small %u, ignoring status check\n", a3, a4, a5, a6, a7, a8, v17);
    v10 = *a1;
    v19 = 6;
  }
  v20 = v15;
  v21 = (_WORD *)((char *)v10 + v19);
  *((_WORD *)a2 + 4) = *v21;
  *((_WORD *)a2 + 5) = v21[1];
  *((_WORD *)a2 + 6) = v21[2];
  v22 = v21 + 3;
  memcpy((void *)a2[2], v21 + 3, v20);
  memcpy((void *)a2[3], (char *)v22 + v20, v20);
  return 1;
}

uint64_t ETLMaverickSecurityCreateReadCarrierIDCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseReadCarrierIDResponse(int **a1, _BYTE *__dst, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  size_t v13;
  uint64_t result;

  if (a1 && __dst)
  {
    v9 = *((_DWORD *)a1 + 2);
    if (v9 < 4)
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    }
    else
    {
      v10 = *a1;
      v11 = **a1;
      if (v11 == 75)
      {
        if (BYTE1(v11) == 253)
        {
          v12 = HIWORD(v11);
          if ((_DWORD)v12 == 12)
          {
            if (v9 - 4 <= 3)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            }
            else if (*((_WORD *)v10 + 2) == 23)
            {
              if (*((_WORD *)v10 + 3) == 6)
              {
LABEL_25:
                result = 1;
                __dst[7] = 0;
                return result;
              }
              if (!*((_WORD *)v10 + 3) && (v9 & 0xFFFFFFFC) != 8)
              {
                v13 = v10[2];
                if ((_DWORD)v13)
                {
                  if (v13 <= 7)
                  {
                    memcpy(__dst, v10 + 3, v13);
                    result = 1;
                    __dst[7] = 1;
                    return result;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickSecurityParseReadCarrierIDResponse", (uint64_t)"received carrier id length %u larger than expected %u\n", v13, a4, a5, a6, a7, a8, v10[2]);
                  goto LABEL_24;
                }
                goto LABEL_25;
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 2));
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      }
    }
LABEL_24:
    result = 0;
    __dst[7] = 0;
    return result;
  }
  result = 0;
  if (__dst)
    __dst[7] = 0;
  return result;
}

uint64_t ETLMaverickNVBackup(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  const char *v31;
  const char *v32;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v31 = "ETLMaverickNVBackup";
    v32 = "Failed to create uplink frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v4, v5, v6, v7, v8, v9, v33);
    return 0;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    return 0;
  }
  v39 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v31 = "ETLSubsysAddHeaderInternal";
    v32 = "Failed to inject\n";
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v33 = 2;
    v31 = "ETLRequireFreeSpace";
    v32 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  result = HDLCFrameInjectUnsignedShort();
  if ((_DWORD)result)
  {
    result = (uint64_t)malloc((2 * DWORD2(v36) + 32));
    if (result)
    {
      v18 = (void *)result;
      v19 = HDLCFrameEncode();
      if (!(_DWORD)v19)
        goto LABEL_25;
      v20 = v19;
      v39 = -1431655766;
      if ((_ETLDebugFlags & 2) != 0)
        ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
      if (*a1)
      {
        v21 = (*a1)(a1, v18, v20, &v39, 1, a2, 0);
        v22 = v39;
        free(v18);
        result = 0;
        if (v21 && v22 == (_DWORD)v20)
        {
          LOBYTE(v39) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v30 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2);
          result = 0;
          if (v30)
          {
            if (v39 == 75)
              return ETLMaverickParseNVBackupResponse((int **)v34, v23, v24, v25, v26, v27, v28, v29);
          }
        }
      }
      else
      {
LABEL_25:
        free(v18);
        return 0;
      }
    }
  }
  return result;
}

uint64_t ETLMaverickNVRestore(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  const char *v31;
  const char *v32;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v31 = "ETLMaverickNVRestore";
    v32 = "Failed to create uplink frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v4, v5, v6, v7, v8, v9, v33);
    return 0;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    return 0;
  }
  v39 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v31 = "ETLSubsysAddHeaderInternal";
    v32 = "Failed to inject\n";
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v33 = 2;
    v31 = "ETLRequireFreeSpace";
    v32 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  result = HDLCFrameInjectUnsignedShort();
  if ((_DWORD)result)
  {
    result = (uint64_t)malloc((2 * DWORD2(v36) + 32));
    if (result)
    {
      v18 = (void *)result;
      v19 = HDLCFrameEncode();
      if (!(_DWORD)v19)
        goto LABEL_25;
      v20 = v19;
      v39 = -1431655766;
      if ((_ETLDebugFlags & 2) != 0)
        ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
      if (*a1)
      {
        v21 = (*a1)(a1, v18, v20, &v39, 1, a2, 0);
        v22 = v39;
        free(v18);
        result = 0;
        if (v21 && v22 == (_DWORD)v20)
        {
          LOBYTE(v39) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v30 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2);
          result = 0;
          if (v30)
          {
            if (v39 == 75)
              return ETLMaverickParseNVRestoreResponse((int **)v34, v23, v24, v25, v26, v27, v28, v29);
          }
        }
      }
      else
      {
LABEL_25:
        free(v18);
        return 0;
      }
    }
  }
  return result;
}

void *ETLMaverickReadSerialNumberAndChipID(_QWORD *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, _DWORD *a5, uint64_t a6)
{
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *SerialNumberAndChipIDResponse;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  const char *v34;
  uint64_t v36;
  _OWORD v37[2];
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  int v42;

  v39 = 0u;
  v40 = 0u;
  v41 = 0;
  memset(v37, 0, sizeof(v37));
  v38 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_22;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_22;
  }
  v42 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v33 = "ETLSubsysAddHeaderInternal";
    v34 = "Failed to inject\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v33, (uint64_t)v34, v19, v20, v21, v22, v23, v24, v36);
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v36 = 2;
    v33 = "ETLRequireFreeSpace";
    v34 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_21;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_22:
    SerialNumberAndChipIDResponse = 0;
    goto LABEL_23;
  }
  SerialNumberAndChipIDResponse = malloc((2 * DWORD2(v39) + 32));
  if (!SerialNumberAndChipIDResponse)
    goto LABEL_23;
  v26 = HDLCFrameEncode();
  if (!(_DWORD)v26)
    goto LABEL_24;
  v27 = v26;
  v42 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, SerialNumberAndChipIDResponse, v26);
  if (!*a1)
  {
LABEL_24:
    free(SerialNumberAndChipIDResponse);
    goto LABEL_22;
  }
  v28 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, SerialNumberAndChipIDResponse, v27, &v42, 1, a6, 0);
  v29 = v42;
  free(SerialNumberAndChipIDResponse);
  SerialNumberAndChipIDResponse = 0;
  if (v28 && v29 == (_DWORD)v27)
  {
    LOBYTE(v42) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    SerialNumberAndChipIDResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v37, (uint64_t)&_ETLResponseRingBuffer, &v42, a6)&& v42 == 75)
    {
      SerialNumberAndChipIDResponse = (void *)ETLMaverickSecurityParseReadSerialNumberAndChipIDResponse((int **)v37, a2, a3, a4, a5, v30, v31, v32);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return SerialNumberAndChipIDResponse;
}

void *ETLMaverickReadPublicKeyHash(_QWORD *a1, void *a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *PublicKeyHashResponse;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  const char *v33;
  uint64_t v35;
  _OWORD v36[2];
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  int v41;

  v38 = 0u;
  v39 = 0u;
  v40 = 0;
  memset(v36, 0, sizeof(v36));
  v37 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_22;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_22;
  }
  v41 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v32 = "ETLSubsysAddHeaderInternal";
    v33 = "Failed to inject\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v17, v18, v19, v20, v21, v22, v35);
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v35 = 2;
    v32 = "ETLRequireFreeSpace";
    v33 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_21;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_22:
    PublicKeyHashResponse = 0;
    goto LABEL_23;
  }
  PublicKeyHashResponse = malloc((2 * DWORD2(v38) + 32));
  if (!PublicKeyHashResponse)
    goto LABEL_23;
  v24 = HDLCFrameEncode();
  if (!(_DWORD)v24)
    goto LABEL_24;
  v25 = v24;
  v41 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, PublicKeyHashResponse, v24);
  if (!*a1)
  {
LABEL_24:
    free(PublicKeyHashResponse);
    goto LABEL_22;
  }
  v26 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, PublicKeyHashResponse, v25, &v41, 1, a5, 0);
  v27 = v41;
  free(PublicKeyHashResponse);
  PublicKeyHashResponse = 0;
  if (v26 && v27 == (_DWORD)v25)
  {
    LOBYTE(v41) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    PublicKeyHashResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v41, a5)&& v41 == 75)
    {
      PublicKeyHashResponse = (void *)ETLMaverickSecurityParseReadPublicKeyHashResponse((int **)v36, a2, a3, a4, v28, v29, v30, v31);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return PublicKeyHashResponse;
}

void *ETLMaverickGetFusingStatus(_QWORD *a1, _DWORD *a2, uint64_t a3)
{
  uint64_t FreeSpace;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *FusingStatusResponse;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_22;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v7, v8, v9, v10, v11, v12, FreeSpace);
    goto LABEL_22;
  }
  v39 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v30 = "ETLSubsysAddHeaderInternal";
    v31 = "Failed to inject\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v13, v14, v15, v16, v17, v18, v33);
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v33 = 2;
    v30 = "ETLRequireFreeSpace";
    v31 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_21;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_22:
    FusingStatusResponse = 0;
    goto LABEL_23;
  }
  FusingStatusResponse = malloc((2 * DWORD2(v36) + 32));
  if (!FusingStatusResponse)
    goto LABEL_23;
  v20 = HDLCFrameEncode();
  if (!(_DWORD)v20)
    goto LABEL_24;
  v21 = v20;
  v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, FusingStatusResponse, v20);
  if (!*a1)
  {
LABEL_24:
    free(FusingStatusResponse);
    goto LABEL_22;
  }
  v22 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, FusingStatusResponse, v21, &v39, 1, a3, 0);
  v23 = v39;
  free(FusingStatusResponse);
  FusingStatusResponse = 0;
  if (v22 && v23 == (_DWORD)v21)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    FusingStatusResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      FusingStatusResponse = (void *)ETLMaverickSecurityParseGetFusingStatusResponse((int **)v34, a2, v24, v25, v26, v27, v28, v29);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return FusingStatusResponse;
}

void *ETLMaverickReadNonce(_QWORD *a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *NonceResponse;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  const char *v33;
  uint64_t v35;
  _OWORD v36[2];
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  int v41;

  v38 = 0u;
  v39 = 0u;
  v40 = 0;
  memset(v36, 0, sizeof(v36));
  v37 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_22;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_22;
  }
  v41 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v32 = "ETLSubsysAddHeaderInternal";
    v33 = "Failed to inject\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v17, v18, v19, v20, v21, v22, v35);
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v35 = 2;
    v32 = "ETLRequireFreeSpace";
    v33 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_21;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_22:
    NonceResponse = 0;
    goto LABEL_23;
  }
  NonceResponse = malloc((2 * DWORD2(v38) + 32));
  if (!NonceResponse)
    goto LABEL_23;
  v24 = HDLCFrameEncode();
  if (!(_DWORD)v24)
    goto LABEL_24;
  v25 = v24;
  v41 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, NonceResponse, v24);
  if (!*a1)
  {
LABEL_24:
    free(NonceResponse);
    goto LABEL_22;
  }
  v26 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, NonceResponse, v25, &v41, 1, a5, 0);
  v27 = v41;
  free(NonceResponse);
  NonceResponse = 0;
  if (v26 && v27 == (_DWORD)v25)
  {
    LOBYTE(v41) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    NonceResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v41, a5)&& v41 == 75)
    {
      NonceResponse = (void *)ETLMaverickSecurityParseReadNonceResponse((_DWORD **)v36, a2, a3, a4, v28, v29, v30, v31);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return NonceResponse;
}

uint64_t ETLMaverickManifestStatusGetHashSize(capabilities::etl *a1)
{
  if (capabilities::etl::getMavSHAHashLenType(a1))
    return 48;
  else
    return 32;
}

uint64_t ETLMaverickManifestStatusInit(size_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  void *v19;

  if (a1)
  {
    if (capabilities::etl::getMavSHAHashLenType((capabilities::etl *)a1))
      v9 = 48;
    else
      v9 = 32;
    *a1 = v9;
    a1[1] = 0;
    v10 = malloc(v9);
    a1[3] = (size_t)v10;
    v11 = malloc(v9);
    a1[2] = (size_t)v11;
    if (v10 && v11)
    {
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickManifestStatusInit", (uint64_t)"failed allocating data for ckey hash = %p and skey hash = %p\n", v12, v13, v14, v15, v16, v17, (uint64_t)v10);
      v19 = (void *)a1[3];
      if (v19)
      {
        free(v19);
        a1[3] = 0;
      }
      result = a1[2];
      if (result)
      {
        free((void *)result);
        result = 0;
        a1[2] = 0;
      }
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickManifestStatusInit", (uint64_t)"invalid manifest status to initialize, manifest_status = %p\n", a3, a4, a5, a6, a7, a8, 0);
    return 0;
  }
  return result;
}

BOOL ETLMaverickManifestStatusFree(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  void *v10;

  if (a1)
  {
    v9 = *(void **)(a1 + 24);
    if (v9)
    {
      free(v9);
      *(_QWORD *)(a1 + 24) = 0;
    }
    v10 = *(void **)(a1 + 16);
    if (v10)
    {
      free(v10);
      *(_QWORD *)(a1 + 16) = 0;
    }
    return a1 != 0;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickManifestStatusFree", (uint64_t)"invalid manifest status to initialize, manifest_status = %p\n", a3, a4, a5, a6, a7, a8, 0);
    return 0;
  }
}

void *ETLMaverickGetManifestStatus(_QWORD *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *ManifestStatusResponse;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v36 = 0u;
  v37 = 0u;
  v38 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v30 = "ETLMaverickGetManifestStatus";
    v31 = "Failed to create command frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v6, v7, v8, v9, v10, v11, v33);
    goto LABEL_23;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_23;
  }
  v39 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v30 = "ETLSubsysAddHeaderInternal";
    v31 = "Failed to inject\n";
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v33 = 2;
    v30 = "ETLRequireFreeSpace";
    v31 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_23:
    ManifestStatusResponse = 0;
    goto LABEL_24;
  }
  ManifestStatusResponse = malloc((2 * DWORD2(v36) + 32));
  if (!ManifestStatusResponse)
    goto LABEL_24;
  v20 = HDLCFrameEncode();
  if (!(_DWORD)v20)
    goto LABEL_25;
  v21 = v20;
  v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, ManifestStatusResponse, v20);
  if (!*a1)
  {
LABEL_25:
    free(ManifestStatusResponse);
    goto LABEL_23;
  }
  v22 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, ManifestStatusResponse, v21, &v39, 1, a3, 0);
  v23 = v39;
  free(ManifestStatusResponse);
  ManifestStatusResponse = 0;
  if (v22 && v23 == (_DWORD)v21)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    ManifestStatusResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      ManifestStatusResponse = (void *)ETLMaverickSecurityParseReadManifestStatusResponse((int **)v34, a2, v24, v25, v26, v27, v28, v29);
    }
  }
LABEL_24:
  HDLCFrameFree();
  HDLCFrameFree();
  return ManifestStatusResponse;
}

uint64_t ETLMaverickGetCarrierID(_QWORD *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t CarrierIDResponse;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  const char *v42;
  uint64_t v44;
  _OWORD v45[2];
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  int v50;

  v47 = 0u;
  v48 = 0u;
  v49 = 0;
  memset(v45, 0, sizeof(v45));
  v46 = 0;
  if (!a2)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickGetCarrierID", (uint64_t)"Invalid arguments\n", a3, a4, a5, a6, a7, a8, v44);
    goto LABEL_20;
  }
  a2[7] = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
LABEL_20:
    v41 = "ETLMaverickGetCarrierID";
    v42 = "Failed to create command frame\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v41, (uint64_t)v42, v11, v12, v13, v14, v15, v16, v44);
    goto LABEL_22;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
    goto LABEL_22;
  }
  v50 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v41 = "ETLSubsysAddHeaderInternal";
    v42 = "Failed to inject\n";
    goto LABEL_21;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v24, v25, v26, v27, v28, v29, 2);
    goto LABEL_22;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_22:
    CarrierIDResponse = 0;
    goto LABEL_23;
  }
  CarrierIDResponse = (uint64_t)malloc((2 * DWORD2(v47) + 32));
  if (!CarrierIDResponse)
    goto LABEL_23;
  v31 = HDLCFrameEncode();
  if (!(_DWORD)v31)
    goto LABEL_27;
  v32 = v31;
  v50 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, CarrierIDResponse, v31);
  if (!*a1)
  {
LABEL_27:
    free((void *)CarrierIDResponse);
    goto LABEL_22;
  }
  v33 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, CarrierIDResponse, v32, &v50, 1, a3, 0);
  v34 = v50;
  free((void *)CarrierIDResponse);
  CarrierIDResponse = 0;
  if (v33 && v34 == (_DWORD)v32)
  {
    LOBYTE(v50) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v45, (uint64_t)&_ETLResponseRingBuffer, &v50, a3)&& v50 == 75)
    {
      CarrierIDResponse = ETLMaverickSecurityParseReadCarrierIDResponse((int **)v45, a2, v35, v36, v37, v38, v39, v40);
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickGetCarrierID", (uint64_t)"Command not implemented\n", v35, v36, v37, v38, v39, v40, v44);
      a2[7] = 0;
      CarrierIDResponse = 1;
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return CarrierIDResponse;
}

uint64_t ETLMaverickCheckCalibrationBackup(_QWORD *a1, _WORD *a2, uint64_t a3)
{
  uint64_t FreeSpace;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  const char *v37;
  uint64_t v39;
  _OWORD v40[2];
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  unsigned int v45;

  *a2 = -1;
  v42 = 0u;
  v43 = 0u;
  v44 = 0;
  memset(v40, 0, sizeof(v40));
  v41 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_25;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v7, v8, v9, v10, v11, v12, FreeSpace);
    goto LABEL_25;
  }
  v45 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v36 = "ETLSubsysAddHeaderInternal";
    v37 = "Failed to inject\n";
LABEL_24:
    _ETLDebugPrint((uint64_t)v36, (uint64_t)v37, v13, v14, v15, v16, v17, v18, v39);
    goto LABEL_25;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v39 = 2;
    v36 = "ETLRequireFreeSpace";
    v37 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_24;
  }
  if (!HDLCFrameInjectUnsignedShort())
    goto LABEL_25;
  v19 = (uint64_t)malloc((2 * DWORD2(v42) + 32));
  if (v19)
  {
    v20 = HDLCFrameEncode();
    if (!(_DWORD)v20)
      goto LABEL_27;
    v21 = v20;
    v45 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
    if (!*a1)
    {
LABEL_27:
      free((void *)v19);
      goto LABEL_25;
    }
    v22 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v19, v21, &v45, 1, a3, 0);
    v23 = v45;
    free((void *)v19);
    v19 = 0;
    if (v22)
    {
      if (v23 == (_DWORD)v21)
      {
        LOBYTE(v45) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v19 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v40, (uint64_t)&_ETLResponseRingBuffer, &v45, a3))
        {
          if (v45 == 75)
          {
            v45 = 0;
            v19 = 0;
            if (ETLMaverickParseBSPResponseHeader((uint64_t)v40, &v45, 12, v24, v25, v26, v27, v28))
            {
              if (DWORD2(v40[0]) - v45 <= 3)
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", v29, v30, v31, v32, v33, v34, 4);
              }
              else
              {
                v35 = *(unsigned __int16 *)(*(_QWORD *)&v40[0] + v45);
                if ((_DWORD)v35 == 13)
                {
                  *a2 = *(_WORD *)(*(_QWORD *)&v40[0] + v45 + 2);
                  v19 = 1;
                  goto LABEL_26;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", v29, v30, v31, v32, v33, v34, v35);
              }
LABEL_25:
              v19 = 0;
            }
          }
        }
      }
    }
  }
LABEL_26:
  HDLCFrameFree();
  HDLCFrameFree();
  return v19;
}

uint64_t ETLFTMRFCallResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int *v13;

  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
  }
  else
  {
    v10 = **a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 11)
      {
        v11 = HIWORD(v10);
        if ((_DWORD)v11 != 251)
          _ETLDebugPrint((uint64_t)"ETLFTMRFCallResponse", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLFTMRFCallResponse", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
      }
      v12 = 1;
      if ((*((_DWORD *)a1 + 2) - 4) <= 3)
        goto LABEL_15;
      goto LABEL_9;
    }
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
  }
  v12 = 0;
  if (*((_DWORD *)a1 + 2) <= 3u)
  {
LABEL_15:
    _ETLDebugPrint((uint64_t)"ETLFTMRFCallResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
LABEL_9:
  v13 = &(*a1)[v12];
  if (*(unsigned __int16 *)v13 == (_DWORD)a2)
  {
    if (*((_WORD *)v13 + 1) == 1)
    {
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLFTMRFCallResponse", (uint64_t)"Call got failed. The status returns %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v13 + 1));
      return 0;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFTMRFCallResponse", (uint64_t)"Expect Maverick CMD code %u is not matched with gottne %u\n", a3, a4, a5, a6, a7, a8, a2);
    return 0;
  }
}

uint64_t ETLFTMRFCallSetup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t FreeSpace;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  if (!a1)
  {
    _ETLDebugPrint((uint64_t)"ETLFTMRFCallSetup", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v34);
    return 0;
  }
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v29 = "ETLFTMRFCallSetup";
    v30 = "Failed to create command frame\n";
LABEL_20:
    _ETLDebugPrint((uint64_t)v29, (uint64_t)v30, v9, v10, v11, v12, v13, v14, v34);
    goto LABEL_21;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v16, v17, v18, v19, v20, v21, FreeSpace);
    goto LABEL_21;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    v29 = "ETLSubsysAddHeaderInternal";
    v30 = "Failed to inject\n";
    goto LABEL_20;
  }
  if (HDLCFrameGetFreeSpace() <= 0xB)
  {
    v34 = 12;
LABEL_19:
    v29 = "ETLFTMCreateRFCallSetup";
    v30 = "Not enough room, need %u, have %u\n";
    goto LABEL_20;
  }
  if (!HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort())
  {
    goto LABEL_21;
  }
  if (a2 < 7 && ((0x6Du >> a2) & 1) != 0)
  {
    v31 = 4 * (int)a2;
    v32 = *(unsigned int *)((char *)&unk_1DAD14ECC + v31);
    v33 = *(unsigned int *)((char *)&unk_1DAD14EE8 + v31);
    if (!HDLCFrameInjectUnsignedShort())
      goto LABEL_21;
    if (HDLCFrameGetFreeSpace() >= v32)
      __asm { BR              X9 }
    v34 = v32;
    goto LABEL_19;
  }
  _ETLDebugPrint((uint64_t)"ETLFTMCreateRFCallSetup", (uint64_t)"The technology cannot be interpreted %u\n", v22, v23, v24, v25, v26, v27, a2);
LABEL_21:
  HDLCFrameFree();
  HDLCFrameFree();
  return 0;
}

void sub_1DACFC438(uint64_t a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t (**v3)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD);
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v10 = va_arg(va1, unsigned __int8 *);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  if (HDLCFrameInjectUnsignedShort() && HDLCFrameInjectUnsignedShort())
  {
    if (!HDLCFrameInjectUnsignedShort())
LABEL_18:
      JUMPOUT(0x1DACFC3B4);
    if (HDLCFrameInjectUnsignedShort()
      && HDLCFrameInjectUnsignedShort()
      && (HDLCFrameInjectUnsignedShort() & 1) != 0
      && ETLSendCommand(v3, (uint64_t)va1, v2)
      && ETLSubsysFindMatchingResponse((uint64_t)v3, (unsigned __int8 **)va, v2))
    {
      ETLFTMRFCallResponse((unsigned int **)va, 82, v4, v5, v6, v7, v8, v9);
      goto LABEL_18;
    }
  }
  JUMPOUT(0x1DACFC3B0);
}

uint64_t ETLFTMRFCallExit(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t FreeSpace;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v31;
  const char *v32;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  _OWORD v36[2];
  uint64_t v37;
  int v38;

  if (!a1)
  {
    _ETLDebugPrint((uint64_t)"ETLFTMRFCallExit", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v33);
    return 0;
  }
  memset(v36, 0, sizeof(v36));
  v37 = 0;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v31 = "ETLFTMRFCallExit";
    v32 = "Failed to create command frame\n";
LABEL_16:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v10, v11, v12, v13, v14, v15, v33);
    goto LABEL_17;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
LABEL_17:
    v29 = 0;
    goto LABEL_18;
  }
  v38 = 16452427;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v31 = "ETLSubsysAddHeaderInternal";
    v32 = "Failed to inject\n";
    goto LABEL_16;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    v33 = 4;
    v31 = "ETLFTMCreateRFCallExit";
    v32 = "Not enough room, need %u, have %u\n";
    goto LABEL_16;
  }
  if (!HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !ETLSendCommand(a1, (uint64_t)v36, a3)
    || !ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v34, a3))
  {
    goto LABEL_17;
  }
  v29 = ETLFTMRFCallResponse((unsigned int **)v34, 83, v23, v24, v25, v26, v27, v28);
LABEL_18:
  HDLCFrameFree();
  HDLCFrameFree();
  return v29;
}

uint64_t ETLFTMFEMCommonDispatchResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  unsigned int v12;
  int *v14;

  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
  }
  else
  {
    v10 = **a1;
    if (v10 == 75)
    {
      if (HIWORD(v10) != 20 || BYTE1(v10) != 11)
        _ETLDebugPrint((uint64_t)"ETLFTMFEMCommonDispatchResponse", (uint64_t)"Received subsys 0x%x command code 0x%x doesn't match expected subsys 0x%x command code 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
      v12 = 1;
      if ((*((_DWORD *)a1 + 2) - 4) <= 9)
        goto LABEL_9;
      goto LABEL_13;
    }
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
  }
  v12 = 0;
  if (*((_DWORD *)a1 + 2) <= 9u)
  {
LABEL_9:
    _ETLDebugPrint((uint64_t)"ETLFTMFEMCommonDispatchResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 10);
    return 0;
  }
LABEL_13:
  v14 = (int *)&(*a1)[v12];
  if (*(_WORD *)v14 == 1005)
  {
    *(_WORD *)(a2 + 4) = *(_WORD *)((char *)v14 + 7);
    *(_DWORD *)a2 = *((unsigned __int8 *)v14 + 9);
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFTMFEMCommonDispatchResponse", (uint64_t)"Expect Maverick CMD code %u is not matched with gottne %u\n", a3, a4, a5, a6, a7, a8, 1005);
    return 0;
  }
}

const char *ETLFTMRfcInitStatusAsString(unsigned int a1)
{
  if (a1 > 3)
    return "Unknown";
  else
    return off_1EA1F1BF8[a1];
}

uint64_t ETLFTMGetFEMCommonInfo(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v32;
  const char *v33;
  uint64_t v34;
  _OWORD v35[2];
  uint64_t v36;
  _OWORD v37[2];
  uint64_t v38;
  int v39;

  if (!a1)
  {
    _ETLDebugPrint((uint64_t)"ETLFTMGetFEMCommonInfo", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v34);
    return 0;
  }
  memset(v37, 0, sizeof(v37));
  v38 = 0;
  memset(v35, 0, sizeof(v35));
  v36 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v32 = "ETLFTMGetFEMCommonInfo";
    v33 = "Failed to create command frame\n";
LABEL_19:
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v11, v12, v13, v14, v15, v16, v34);
    goto LABEL_20;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
LABEL_20:
    v24 = 0;
    goto LABEL_21;
  }
  v39 = 1313611;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v32 = "ETLSubsysAddHeaderInternal";
    v33 = "Failed to inject\n";
    goto LABEL_19;
  }
  if (HDLCFrameGetFreeSpace() <= 7)
  {
    v34 = 8;
    v32 = "ETLFTMCreateFEMCommonDispatch";
    v33 = "Not enough room, need %u, have %u\n";
    goto LABEL_19;
  }
  if (!HDLCFrameInjectUnsignedShort() || !HDLCFrameInjectUnsignedShort())
    goto LABEL_20;
  v24 = 0;
  if (!HDLCFrameInjectUnsignedShort())
    goto LABEL_21;
  v24 = 0;
  if (!HDLCFrameInjectUnsignedChar())
    goto LABEL_21;
  v24 = 0;
  if (!HDLCFrameInjectUnsignedChar())
    goto LABEL_21;
  if (!ETLSendCommand(a1, (uint64_t)v37, a3)
    || !ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v35, a3))
  {
    goto LABEL_20;
  }
  v24 = ETLFTMFEMCommonDispatchResponse((unsigned int **)v35, a2, v25, v26, v27, v28, v29, v30);
LABEL_21:
  HDLCFrameFree();
  HDLCFrameFree();
  return v24;
}

uint64_t ETLUCalTxCreateCommand(uint64_t a1, int a2)
{
  uint64_t FreeSpace;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t result;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v4, v5, v6, v7, v8, v9, FreeSpace);
LABEL_10:
    _ETLDebugPrint((uint64_t)"ETLUCalTxCreateCommand", (uint64_t)"Failed to add command header\n", v24, v25, v26, v27, v28, v29, v32);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v10, v11, v12, v13, v14, v15, v31);
    goto LABEL_10;
  }
  v16 = HDLCFrameGetFreeSpace();
  if (a2)
  {
    if (a2 != 1)
      _ETLDebugPrint((uint64_t)"ETLUCalTxCreateCommand", (uint64_t)"Wrong to arrive here\n", v17, v18, v19, v20, v21, v22, v31);
    return HDLCFrameInjectUnsignedShort() & 1;
  }
  if (v16 <= 9)
  {
    _ETLDebugPrint((uint64_t)"ETLUCalTxCreateCommand", (uint64_t)"Remaining %u not enough %u\n", v17, v18, v19, v20, v21, v22, v16);
    return 0;
  }
  v30 = HDLCFrameInjectUnsignedShort();
  result = 0;
  if (v30)
    return HDLCFrameInject();
  return result;
}

uint64_t ETLUCalTxParseResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;

  v8 = a1[2];
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        v11 = HIWORD(v10);
        if ((_DWORD)v11 == 26)
        {
          if (v9 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLUCalTxParseResponseWithStatus", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*(_WORD *)(*(_QWORD *)a1 + 4) == 1)
          {
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLUCalTxParseResponseWithStatus", (uint64_t)"Status returned was %u, expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(_QWORD *)a1 + 4));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLUCalTxOperation(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  _OWORD v37[2];
  uint64_t v38;
  _OWORD v39[2];
  uint64_t v40;
  int v41;

  if (a5)
    *a5 = 0;
  v40 = 0;
  memset(v39, 0, sizeof(v39));
  memset(v37, 0, sizeof(v37));
  v38 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLUCalTxOperation", (uint64_t)"Faild to create uplink frame\n", v9, v10, v11, v12, v13, v14, v36);
    goto LABEL_26;
  }
  if (!ETLUCalTxCreateCommand((uint64_t)v39, a2))
  {
LABEL_26:
    v15 = 0;
    goto LABEL_27;
  }
  v15 = (uint64_t)malloc((2 * DWORD2(v39[0]) + 32));
  if (v15)
  {
    v16 = HDLCFrameEncode();
    if (!(_DWORD)v16)
      goto LABEL_28;
    v17 = v16;
    v41 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v15, v16);
    if (!*a1)
    {
LABEL_28:
      free((void *)v15);
      goto LABEL_26;
    }
    v18 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v15, v17, &v41, 1, a4, 0);
    v19 = v41;
    free((void *)v15);
    v15 = 0;
    if (v18)
    {
      if (v19 == (_DWORD)v17)
      {
        LOBYTE(v41) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v15 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v37, (uint64_t)&_ETLResponseRingBuffer, &v41, a4))
        {
          if (v41 == 75)
          {
            _ETLDebugPrint((uint64_t)"ETLUCalTxOperation", (uint64_t)"Read done\n", v20, v21, v22, v23, v24, v25, v36);
            if (DWORD2(v37[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v26, v27, v28, v29, v30, v31, DWORD2(v37[0]));
            }
            else
            {
              v32 = **(_DWORD **)&v37[0];
              if (**(_DWORD **)&v37[0] == 75)
              {
                if (BYTE1(v32) == 253)
                {
                  v33 = HIWORD(v32);
                  if ((_DWORD)v33 == 26)
                  {
                    if ((DWORD2(v37[0]) - 4) <= 1)
                    {
                      _ETLDebugPrint((uint64_t)"ETLUCalTxParseResponseWithStatus", (uint64_t)"Payload length %u less than needed %u\n", v26, v27, v28, v29, v30, v31, (DWORD2(v37[0]) - 4));
                    }
                    else
                    {
                      v34 = *(unsigned __int16 *)(*(_QWORD *)&v37[0] + 4);
                      if (a5)
                        *a5 = v34;
                      if ((_DWORD)v34 == 1)
                      {
                        v15 = 1;
                        goto LABEL_27;
                      }
                      _ETLDebugPrint((uint64_t)"ETLUCalTxParseResponseWithStatus", (uint64_t)"Status returned was %u, expected %u\n", v26, v27, v28, v29, v30, v31, v34);
                    }
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v26, v27, v28, v29, v30, v31, v33);
                  }
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v26, v27, v28, v29, v30, v31, BYTE1(v32));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v26, v27, v28, v29, v30, v31, **(_DWORD **)&v37[0]);
              }
            }
            goto LABEL_26;
          }
        }
      }
    }
  }
LABEL_27:
  HDLCFrameFree();
  HDLCFrameFree();
  return v15;
}

uint64_t ETLUCalTxStart(_QWORD *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  return ETLUCalTxOperation(a1, 0, a2, a3, a4);
}

uint64_t ETLUCalTxStop(_QWORD *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  return ETLUCalTxOperation(a1, 1, a2, a3, a4);
}

uint64_t ETLGCalTxControl(_QWORD *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  return ETLUCalTxOperation(a1, 5, a2, a3, a4);
}

uint64_t ETLCalGetSKU(uint64_t (**a1)(_QWORD, void *, uint64_t, _OWORD *, uint64_t, uint64_t, _QWORD), _DWORD *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v5;
  BOOL v6;
  int v8;
  unsigned int v9;
  _OWORD v10[16];
  uint64_t v11;

  v3 = 0;
  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      v8 = 4;
      v9 = 0;
      memset(v10, 0, sizeof(v10));
      v5 = ETLNVRead(a1, 50020, v10, 256, &v9, &v8, a3);
      v3 = 0;
      if (v5)
      {
        if (v8)
          v6 = v8 == 5;
        else
          v6 = 1;
        v3 = v6;
        if (v6 && v9 >= 3)
        {
          *a2 = LOWORD(v10[0]);
          return 1;
        }
      }
    }
  }
  return v3;
}

uint64_t ETLCalGetUmtsBand4Status(uint64_t (**a1)(_QWORD, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD), BOOL *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t FreeSpace;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  const char *v38;
  uint64_t v40;
  _OWORD v41[2];
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  int v46;

  v3 = 0;
  if (a1 && a2)
  {
    v45 = 0;
    v43 = 0u;
    v44 = 0u;
    memset(v41, 0, sizeof(v41));
    v42 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
      }
      else
      {
        v46 = 3472715;
        if ((HDLCFrameInject() & 1) != 0)
        {
          v3 = (uint64_t)malloc((2 * DWORD2(v43) + 32));
          if (!v3)
          {
LABEL_29:
            HDLCFrameFree();
            HDLCFrameFree();
            return v3;
          }
          v26 = HDLCFrameEncode();
          if (!(_DWORD)v26)
            goto LABEL_31;
          v27 = v26;
          v46 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v3, v26);
          if (*a1)
          {
            v28 = (*a1)(a1, v3, v27, &v46, 1, a3, 0);
            v29 = v46;
            free((void *)v3);
            v3 = 0;
            if (!v28 || v29 != (_DWORD)v27)
              goto LABEL_29;
            LOBYTE(v46) = 75;
            if (!_ETLResponseRingBuffer)
              TelephonyUtilRingBufferInitialize();
            v3 = 0;
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v41, (uint64_t)&_ETLResponseRingBuffer, &v46, a3)|| v46 != 75)
            {
              goto LABEL_29;
            }
            if (DWORD2(v41[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v30, v31, v32, v33, v34, v35, DWORD2(v41[0]));
            }
            else
            {
              v36 = **(_DWORD **)&v41[0];
              if (**(_DWORD **)&v41[0] == 75)
              {
                if (BYTE1(v36) == 253)
                {
                  v37 = HIWORD(v36);
                  if ((_DWORD)v37 == 52)
                  {
                    if ((DWORD2(v41[0]) - 4) > 1)
                    {
                      *a2 = *(_WORD *)(*(_QWORD *)&v41[0] + 4) != 0;
                      v3 = 1;
                      goto LABEL_29;
                    }
                    _ETLDebugPrint((uint64_t)"ETLCalGetUmtsBand4Status", (uint64_t)"Payload length %u less than needed %u\n", v30, v31, v32, v33, v34, v35, (DWORD2(v41[0]) - 4));
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, v37);
                  }
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, BYTE1(v36));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, **(_DWORD **)&v41[0]);
              }
            }
          }
          else
          {
LABEL_31:
            free((void *)v3);
          }
LABEL_28:
          v3 = 0;
          goto LABEL_29;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v20, v21, v22, v23, v24, v25, v40);
      }
      v38 = "Failed to add command header\n";
    }
    else
    {
      v38 = "Failed to create uplink frame\n";
    }
    _ETLDebugPrint((uint64_t)"ETLCalGetUmtsBand4Status", (uint64_t)v38, v7, v8, v9, v10, v11, v12, v40);
    goto LABEL_28;
  }
  return v3;
}

BOOL ETLPM_GetVREGLevel(_QWORD *a1, char a2, int *a3, unsigned int a4)
{
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL8 v10;
  __int128 v11;
  int v12;
  int v14;
  __int128 v15;
  __int128 v16;
  unint64_t v17;
  int v18;
  char v19;
  __int16 v20;
  _OWORD v21[32];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v14 = -1431655766;
  v20 = -21846;
  memset(v21, 0, sizeof(v21));
  v18 = 271435;
  v19 = a2;
  v17 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v15 = v7;
  v16 = v7;
  if (!HDLCFrameCreateUplink())
    return 0;
  HDLCFrameInject();
  v8 = HDLCFrameEncode();
  if (!(_DWORD)v8)
    return 0;
  v9 = v8;
  if ((int)v8 < 1)
    return 0;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(void *, _QWORD, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1DAD155B3, 0, v21, v8);
  if (!*a1)
    return 0;
  v10 = 0;
  if (!((unsigned int (*)(_QWORD *, _OWORD *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v21, v9, &v14, 1, 1000, 0)|| v14 != (_DWORD)v9)
  {
    return v10;
  }
  v17 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v15 = v11;
  v16 = v11;
  LOBYTE(v18) = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)&v15, (uint64_t)&_ETLResponseRingBuffer, &v18, a4))return 0;
  if (v18 == 75)
  {
    v10 = (DWORD2(v15) - 4) < 0xFFFFFFFD;
    if ((DWORD2(v15) - 4) > 0xFFFFFFFC)
      v12 = 43690;
    else
      v12 = *(unsigned __int16 *)(v15 + 5);
    *a3 = v12;
  }
  else
  {
    v10 = 0;
  }
  HDLCFrameFree();
  return v10;
}

uint64_t ETLCMCreateGetModeCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLCMParseGetModeResponse(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _OWORD *v10;
  __int128 v11;
  __int128 v12;

  v8 = *(_DWORD *)(a1 + 8);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a1 + 8));
    return 0;
  }
  v10 = *(_OWORD **)a1;
  if (**(_DWORD **)a1 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    return 0;
  }
  if ((**(_DWORD **)a1 & 0xFFFFFF00) != 0xF00)
    return 0;
  if (v9 <= 0x2B)
  {
    _ETLDebugPrint((uint64_t)"ETLCMParseGetModeResponse", (uint64_t)"Need %u bytes, only have %u\n", a3, a4, a5, a6, a7, a8, 44);
    return 0;
  }
  else
  {
    v11 = *(_OWORD *)((char *)v10 + 4);
    v12 = *(_OWORD *)((char *)v10 + 20);
    *(_OWORD *)((char *)a2 + 28) = v10[2];
    *a2 = v11;
    a2[1] = v12;
    return 1;
  }
}

uint64_t ETLCMGetMode(uint64_t (**a1)(_QWORD, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD), _OWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  const char *v32;
  const char *v33;
  uint64_t v35;
  _OWORD v36[2];
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  int v41;

  if (a1)
  {
    v38 = 0u;
    v39 = 0u;
    v40 = 0;
    memset(v36, 0, sizeof(v36));
    v37 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
        goto LABEL_26;
      }
      v41 = 3915;
      if ((HDLCFrameInject() & 1) != 0)
      {
        v19 = (uint64_t)malloc((2 * DWORD2(v38) + 32));
        if (!v19)
        {
LABEL_27:
          HDLCFrameFree();
          HDLCFrameFree();
          return v19;
        }
        v20 = HDLCFrameEncode();
        if (!(_DWORD)v20)
          goto LABEL_29;
        v21 = v20;
        v41 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0)
          ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
        if (*a1)
        {
          v22 = (*a1)(a1, v19, v21, &v41, 1, a3, 0);
          v23 = v41;
          free((void *)v19);
          v19 = 0;
          if (!v22 || v23 != (_DWORD)v21)
            goto LABEL_27;
          LOBYTE(v41) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v19 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v41, a3)|| v41 != 75)
          {
            goto LABEL_27;
          }
          if (DWORD2(v36[0]) < 4)
          {
            _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v24, v25, v26, v27, v28, v29, DWORD2(v36[0]));
          }
          else if (**(_DWORD **)&v36[0] == 75)
          {
            if ((**(_DWORD **)&v36[0] & 0xFFFFFF00) == 0xF00)
            {
              if ((DWORD2(v36[0]) - 4) > 0x2B)
              {
                v30 = *(_OWORD *)(*(_QWORD *)&v36[0] + 4);
                v31 = *(_OWORD *)(*(_QWORD *)&v36[0] + 20);
                *(_OWORD *)((char *)a2 + 28) = *(_OWORD *)(*(_QWORD *)&v36[0] + 32);
                *a2 = v30;
                a2[1] = v31;
                v19 = 1;
                goto LABEL_27;
              }
              _ETLDebugPrint((uint64_t)"ETLCMParseGetModeResponse", (uint64_t)"Need %u bytes, only have %u\n", v24, v25, v26, v27, v28, v29, 44);
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v24, v25, v26, v27, v28, v29, **(_DWORD **)&v36[0]);
          }
        }
        else
        {
LABEL_29:
          free((void *)v19);
        }
LABEL_26:
        v19 = 0;
        goto LABEL_27;
      }
      v32 = "ETLSubsysAddHeaderInternal";
      v33 = "Failed to inject\n";
    }
    else
    {
      v32 = "ETLCMGetMode";
      v33 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v6, v7, v8, v9, v10, v11, v35);
    goto LABEL_26;
  }
  return 0;
}

uint64_t ETLEVENTCreateSetMaskCommand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v8 = a3;
  _ETLDebugPrint((uint64_t)"ETLEVENTCreateSetMaskCommand", (uint64_t)"Setting masks of %u bits\n", a3, a4, a5, a6, a7, a8, a3);
  if (v8 > 0x1000)
    return 0;
  v9 = (v8 + 7) >> 3;
  if (HDLCFrameGetFreeSpace() < v9 + 7)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v10, v11, v12, v13, v14, v15, v9 + 7);
    return 0;
  }
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInject();
  return HDLCFrameInjectUnsignedChar();
}

uint64_t ETLEVENTParseSetMaskResponse(unsigned __int8 **a1, _DWORD *a2, void *__dst, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  int v10;
  unsigned int v12;

  v8 = *((_DWORD *)a1 + 2);
  if (v8 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Response has %u bytes, need %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v9 = (uint64_t)*a1;
    if (**a1 == 130)
    {
      v10 = *(unsigned __int8 *)(v9 + 1);
      *a2 = v10;
      if (v10)
      {
        return 0;
      }
      else
      {
        v12 = *(unsigned __int16 *)(v9 + 4);
        *a4 = v12;
        if (v12 > 0x1000 || (v12 + 7) >> 3 > v8 - 6)
        {
          _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Need %u bytes for mask of %u bits, only have %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, (v12 + 7) >> 3);
          return 0;
        }
        else
        {
          memcpy(__dst, (const void *)(v9 + 6), (v12 + 7) >> 3);
          return 1;
        }
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLExpectResponseCode", (uint64_t)"Received response code is %u, expected %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLEVENTCreateGetMaskCommand()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (HDLCFrameGetFreeSpace() <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 4);
    return 0;
  }
  else
  {
    HDLCFrameInjectUnsignedChar();
    HDLCFrameInjectUnsignedChar();
    return HDLCFrameInjectUnsignedShort();
  }
}

uint64_t ETLEVENTParseGetMaskResponse(unsigned __int8 **a1, _DWORD *a2, void *__dst, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  int v10;
  unsigned int v12;

  v8 = *((_DWORD *)a1 + 2);
  if (v8 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Response has %u bytes, need %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v9 = (uint64_t)*a1;
    if (**a1 == 129)
    {
      v10 = *(unsigned __int8 *)(v9 + 1);
      *a2 = v10;
      if (v10)
      {
        return 0;
      }
      else
      {
        v12 = *(unsigned __int16 *)(v9 + 4);
        *a4 = v12;
        if (v12 > 0x1000 || (v12 + 7) >> 3 > v8 - 6)
        {
          _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Need %u bytes for mask of %u bits, only have %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, (v12 + 7) >> 3);
          return 0;
        }
        else
        {
          memcpy(__dst, (const void *)(v9 + 6), (v12 + 7) >> 3);
          return 1;
        }
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLExpectResponseCode", (uint64_t)"Received response code is %u, expected %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLEVENTCreateEnableCommand()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 2);
    return 0;
  }
  else
  {
    HDLCFrameInjectUnsignedChar();
    return HDLCFrameInjectUnsignedChar();
  }
}

uint64_t ETLEVENTParseEnableResponse()
{
  return 1;
}

unint64_t ETLEVENTSetMask(_QWORD *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v29;
  char v30;
  _OWORD v31[2];
  uint64_t v32;
  _OWORD v33[2];
  uint64_t v34;
  int v35;
  _OWORD __s2[32];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v30 = -126;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __s2[30] = v8;
  __s2[31] = v8;
  __s2[28] = v8;
  __s2[29] = v8;
  __s2[26] = v8;
  __s2[27] = v8;
  __s2[24] = v8;
  __s2[25] = v8;
  __s2[22] = v8;
  __s2[23] = v8;
  __s2[20] = v8;
  __s2[21] = v8;
  __s2[18] = v8;
  __s2[19] = v8;
  __s2[16] = v8;
  __s2[17] = v8;
  __s2[14] = v8;
  __s2[15] = v8;
  __s2[12] = v8;
  __s2[13] = v8;
  __s2[10] = v8;
  __s2[11] = v8;
  __s2[8] = v8;
  __s2[9] = v8;
  __s2[6] = v8;
  __s2[7] = v8;
  __s2[4] = v8;
  __s2[5] = v8;
  __s2[2] = v8;
  __s2[3] = v8;
  __s2[0] = v8;
  __s2[1] = v8;
  v34 = 0;
  memset(v33, 0, sizeof(v33));
  memset(v31, 0, sizeof(v31));
  v32 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLEVENTSetMask", (uint64_t)"Failed to create command frame\n", v9, v10, v11, v12, v13, v14, v29);
    goto LABEL_25;
  }
  if (!ETLEVENTCreateSetMaskCommand((uint64_t)v33, (uint64_t)a2, a3, v10, v11, v12, v13, v14))
  {
LABEL_25:
    v15 = 0;
    goto LABEL_26;
  }
  v15 = (unint64_t)malloc((2 * DWORD2(v33[0]) + 32));
  if (!v15)
    goto LABEL_26;
  v16 = HDLCFrameEncode();
  if (!(_DWORD)v16)
    goto LABEL_27;
  v17 = v16;
  v35 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v15, v16);
  if (!*a1)
  {
LABEL_27:
    free((void *)v15);
    goto LABEL_25;
  }
  v18 = ((uint64_t (*)(_QWORD *, unint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v15, v17, &v35, 1, a4, 0);
  v19 = v35;
  free((void *)v15);
  v15 = 0;
  if (v18 && v19 == (_DWORD)v17)
  {
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v31, (uint64_t)&_ETLResponseRingBuffer, &v30, a4))
    {
      if (DWORD2(v31[0]) <= 5)
      {
        _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Response has %u bytes, need %u\n", v20, v21, v22, v23, v24, v25, DWORD2(v31[0]));
      }
      else if (**(_BYTE **)&v31[0] == 130)
      {
        if (!*(_BYTE *)(*(_QWORD *)&v31[0] + 1))
        {
          LODWORD(v26) = *(unsigned __int16 *)(*(_QWORD *)&v31[0] + 4);
          v27 = (v26 + 7) >> 3;
          if (v26 > 0x1000 || v27 > DWORD2(v31[0]) - 6)
          {
            _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Need %u bytes for mask of %u bits, only have %u\n", v27, v21, v22, v23, v24, v25, (v26 + 7) >> 3);
          }
          else
          {
            __memcpy_chk();
            if (v26 >= a3)
              v26 = a3;
            else
              v26 = v26;
            if (!memcmp(a2, __s2, v26 >> 3))
            {
              v15 = (v26 & 7) == 0
                 || ((*((unsigned __int8 *)__s2 + (v26 >> 3)) ^ a2[v26 >> 3]) & ~(-1 << (v26 & 7))) == 0;
              goto LABEL_26;
            }
          }
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLExpectResponseCode", (uint64_t)"Received response code is %u, expected %u\n", v20, v21, v22, v23, v24, v25, **(_BYTE **)&v31[0]);
      }
    }
    goto LABEL_25;
  }
LABEL_26:
  HDLCFrameFree();
  HDLCFrameFree();
  return v15;
}

uint64_t ETLEVENTGetMask(_QWORD *a1, void *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  size_t v29;
  const char *v30;
  const char *v31;
  uint64_t v33;
  char v34;
  _OWORD v35[2];
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  int v40;

  v34 = -127;
  v37 = 0u;
  v38 = 0u;
  v39 = 0;
  memset(v35, 0, sizeof(v35));
  v36 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v30 = "ETLEVENTGetMask";
    v31 = "Failed to create command frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v8, v9, v10, v11, v12, v13, v33);
    goto LABEL_23;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    v33 = 4;
    v30 = "ETLRequireFreeSpace";
    v31 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  v14 = 0;
  if (HDLCFrameInjectUnsignedShort())
  {
    v14 = (uint64_t)malloc((2 * DWORD2(v37) + 32));
    if (v14)
    {
      v15 = HDLCFrameEncode();
      if (!(_DWORD)v15)
        goto LABEL_25;
      v16 = v15;
      v40 = -1431655766;
      if ((_ETLDebugFlags & 2) != 0)
        ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v14, v15);
      if (!*a1)
      {
LABEL_25:
        free((void *)v14);
        goto LABEL_23;
      }
      v17 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v14, v16, &v40, 1, a4, 0);
      v18 = v40;
      free((void *)v14);
      v14 = 0;
      if (v17)
      {
        if (v18 == (_DWORD)v16)
        {
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v35, (uint64_t)&_ETLResponseRingBuffer, &v34, a4))
          {
            v25 = DWORD2(v35[0]);
            if (DWORD2(v35[0]) <= 5)
            {
              _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Response has %u bytes, need %u\n", v19, v20, v21, v22, v23, v24, DWORD2(v35[0]));
            }
            else
            {
              v26 = *(_QWORD *)&v35[0];
              if (**(_BYTE **)&v35[0] == 129)
              {
                if (!*(_BYTE *)(*(_QWORD *)&v35[0] + 1))
                {
                  v27 = *(unsigned __int16 *)(*(_QWORD *)&v35[0] + 4);
                  *a3 = v27;
                  v28 = v25 - 6;
                  v29 = (v27 + 7) >> 3;
                  if (v27 <= 0x1000 && v29 <= v28)
                  {
                    memcpy(a2, (const void *)(v26 + 6), v29);
                    v14 = 1;
                    goto LABEL_24;
                  }
                  _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Need %u bytes for mask of %u bits, only have %u\n", v29, v20, v21, v22, v23, v24, (v27 + 7) >> 3);
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLExpectResponseCode", (uint64_t)"Received response code is %u, expected %u\n", v19, v20, v21, v22, v23, v24, **(_BYTE **)&v35[0]);
              }
            }
          }
LABEL_23:
          v14 = 0;
        }
      }
    }
  }
LABEL_24:
  HDLCFrameFree();
  HDLCFrameFree();
  return v14;
}

void *ETLEVENTEnable(_QWORD *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  const char *v21;
  const char *v22;
  uint64_t v24;
  char v25;
  _OWORD v26[2];
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  int v31;

  v25 = 96;
  _ETLDebugPrint((uint64_t)"ETLEVENTEnable", (uint64_t)"enable = %u\n", a3, a4, a5, a6, a7, a8, a2);
  v30 = 0;
  v28 = 0u;
  v29 = 0u;
  memset(v26, 0, sizeof(v26));
  v27 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v21 = "ETLEVENTEnable";
    v22 = "Failed to create command frame\n";
LABEL_16:
    _ETLDebugPrint((uint64_t)v21, (uint64_t)v22, v10, v11, v12, v13, v14, v15, v24);
    goto LABEL_17;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v24 = 2;
    v21 = "ETLRequireFreeSpace";
    v22 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_16;
  }
  HDLCFrameInjectUnsignedChar();
  if (!HDLCFrameInjectUnsignedChar())
  {
LABEL_17:
    v16 = 0;
    goto LABEL_18;
  }
  v16 = malloc((2 * DWORD2(v28) + 32));
  if (!v16)
    goto LABEL_18;
  v17 = HDLCFrameEncode();
  if (!(_DWORD)v17)
    goto LABEL_19;
  v18 = v17;
  v31 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
  if (!*a1)
  {
LABEL_19:
    free(v16);
    goto LABEL_17;
  }
  v19 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v16, v18, &v31, 1, a3, 0);
  v20 = v31;
  free(v16);
  v16 = 0;
  if (v19 && v20 == (_DWORD)v18)
  {
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v16 = (void *)ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v26, (uint64_t)&_ETLResponseRingBuffer, &v25, a3);
  }
LABEL_18:
  HDLCFrameFree();
  HDLCFrameFree();
  return v16;
}

uint64_t ETLEVENTGetRangeSize(unsigned __int16 *a1)
{
  return a1[1] - *a1 + 1;
}

uint64_t ETLEVENTProcessEvent(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, unsigned int a5, _DWORD *a6)
{
  uint64_t result;
  unsigned int v7;
  int v8;
  int v9;

  result = 0;
  *a3 = 0;
  *a6 = 0;
  v7 = a5 - 2;
  if (a5 >= 2)
  {
    v8 = *(char *)(a4 + 1);
    *a6 = 2;
    if (v8 < 0)
    {
      if (v7 >= 2)
      {
        v9 = 2;
LABEL_7:
        *a6 = v9 + 2;
        __asm { BR              X2 }
      }
    }
    else if (v7 >= 8)
    {
      v9 = 8;
      goto LABEL_7;
    }
    result = 0;
    *a6 = 0;
  }
  return result;
}

uint64_t ETLEVENTProcessEventItem(unsigned __int8 *a1, unsigned int a2, _DWORD *a3, _WORD *a4, uint64_t a5, uint64_t a6)
{
  return ETLEVENTProcessEventItemTSLength(a1, a2, a3, a4, a5, a6, 0);
}

uint64_t ETLEVENTProcessEventItemTSLength(unsigned __int8 *a1, unsigned int a2, _DWORD *a3, _WORD *a4, uint64_t a5, uint64_t a6, unsigned int *a7)
{
  unsigned int v7;
  unsigned int v8;
  _QWORD *v9;
  int v10;

  *a3 = 0;
  v7 = a2 - 2;
  if (a2 < 2)
    return 0;
  v8 = a1[1];
  *a4 = (*a1 | (unsigned __int16)((_WORD)v8 << 8)) & 0xFFF;
  if (a7)
  {
    *a7 = v8 >> 7;
    *a3 += 2;
    v9 = a1 + 2;
    if ((v8 & 0x80) == 0)
      goto LABEL_4;
LABEL_7:
    if (v7 >= 2)
    {
      *(_BYTE *)(a6 + 1) = a1[2];
      *(_BYTE *)(a6 + 2) = a1[3];
      v10 = 2;
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  *a3 = 2;
  v9 = a1 + 2;
  if ((v8 & 0x80) != 0)
    goto LABEL_7;
LABEL_4:
  if (v7 >= 8)
  {
    *(_QWORD *)a6 = *v9;
    v10 = 8;
LABEL_10:
    *a3 += v10;
    return ((uint64_t (*)(void))((char *)&loc_1DACFEA44 + 4 * byte_1DAD14F08[(v8 >> 5) & 3]))();
  }
LABEL_8:
  *a3 = 0;
  return 0;
}

uint64_t ETLEVENTProcessHeader(uint64_t a1, unsigned int a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result;

  result = 0;
  *a3 = 0;
  *a4 = 0;
  if (a2 >= 3)
  {
    if (*(_BYTE *)a1 == 96)
    {
      *a3 = *(unsigned __int16 *)(a1 + 1);
      *a4 = 3;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ETLEVENTParseReport(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  unsigned int v8;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;

  result = 0;
  *a5 = 0;
  if (a4 >= 3)
  {
    if (*(_BYTE *)a3 == 96)
    {
      v8 = *(unsigned __int16 *)(a3 + 1);
      *a5 = 3;
      if (v8)
      {
        v10 = a3 + 3;
        while (1)
        {
          v12 = -1431655766;
          v13 = -1431655766;
          if ((ETLEVENTProcessEvent(a1, a2, &v12, v10, v8, &v13) & 1) == 0)
            break;
          v11 = v13;
          v10 += v13;
          *a5 += v13;
          a1 += v12;
          a2 = a2 - v12;
          v8 -= v11;
          if (!v8)
            return 1;
        }
        result = 0;
        *a5 = 0;
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

char *ETLEVENTParseEventReport(uint64_t a1, _QWORD *a2)
{
  _BYTE *v2;
  unsigned int v3;
  char *result;
  _BYTE *v6;
  int v7;
  unsigned int v8;
  int v9;

  v2 = *(_BYTE **)a1;
  v3 = *(_DWORD *)(a1 + 8);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (v3 >= 3 && *v2 == 96 && *(unsigned __int16 *)(v2 + 1) + 3 == v3)
  {
    result = (char *)malloc(0x28uLL);
    if (!result)
      return result;
    v6 = *(_BYTE **)a1;
    v7 = *(_DWORD *)(a1 + 8);
    *(_OWORD *)result = 0u;
    *((_OWORD *)result + 1) = 0u;
    *((_QWORD *)result + 4) = 0;
    v8 = v7 + 1;
    if ((v7 + 1) <= 0xFFFFFFFD)
    {
      v9 = (char)v6[4];
      *(_WORD *)result = (v6[3] | (unsigned __int16)((char)v6[4] << 8)) & 0xFFF;
      if (v9 < 0)
      {
        if (v8 >= 2)
        {
          result[3] = v6[5];
          result[4] = v6[6];
LABEL_11:
          __asm { BR              X13 }
        }
      }
      else if (v8 >= 8)
      {
        *(_QWORD *)(result + 2) = *(_QWORD *)(v6 + 5);
        goto LABEL_11;
      }
    }
    free(result);
  }
  return 0;
}

BOOL ETLEVENTReportFree(uint64_t *a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;

  v2 = *a1;
  if (!*a1)
  {
    v3 = 0;
    v5 = *((_DWORD *)a1 + 4);
    if (v5)
      return v3 == v5;
    goto LABEL_5;
  }
  v3 = 0;
  do
  {
    v4 = *(_QWORD *)(v2 + 32);
    free(*(void **)(v2 + 16));
    free((void *)v2);
    ++v3;
    v2 = v4;
  }
  while (v4);
  v5 = *((_DWORD *)a1 + 4);
  if (v3 == v5)
  {
LABEL_5:
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return v3 == v5;
}

uint64_t ETLPRLReadStatusIsSuccess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  v8 = 1;
  if ((_DWORD)a1 && (_DWORD)a1 != 2)
  {
    if ((_DWORD)a1 == 1)
      _ETLDebugPrint((uint64_t)"ETLPRLReadStatusIsSuccess", (uint64_t)"PRL Read status kStatusPRLNVReadFail [%u]\n", a3, a4, a5, a6, a7, a8, 1);
    else
      _ETLDebugPrint((uint64_t)"ETLPRLReadStatusIsSuccess", (uint64_t)"PRL Read status Invalid [%u]\n", a3, a4, a5, a6, a7, a8, a1);
    return 0;
  }
  return v8;
}

uint64_t ETLPRLWriteStatusIsSuccess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 < 2)
    return 1;
  if ((_DWORD)a1 == 3)
  {
    _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status kStatusPRLWriteOverflow [%u]\n", a3, a4, a5, a6, a7, a8, 3);
    return 0;
  }
  else
  {
    if ((_DWORD)a1 == 2)
      _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status kStatusPRLWriteOutOfSeq [%u]\n", a3, a4, a5, a6, a7, a8, 2);
    else
      _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status Invalid [%u]\n", a3, a4, a5, a6, a7, a8, a1);
    return 0;
  }
}

uint64_t ETLPRLCreateReadCommand()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (HDLCFrameGetFreeSpace() <= 2)
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 3);
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  return HDLCFrameInjectUnsignedChar();
}

uint64_t ETLPRLParseReadResponse(uint64_t *a1, unsigned int a2, void *__dst, uint64_t a4, unsigned int *a5, _BYTE *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v9;
  BOOL v10;
  unsigned int v11;
  unsigned int v12;
  const char *v13;
  uint64_t v16;

  *a5 = 0;
  *a6 = 0;
  if (*((_DWORD *)a1 + 2) <= 7u)
  {
    _ETLDebugPrint((uint64_t)"ETLPRLParseReadResponse", (uint64_t)"PRL Read Response size [%u] bytes not enough, need atleast [%u] bytes\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  v8 = *a1;
  if (!*a1)
  {
    v13 = "PRL Get payload failed\n";
LABEL_19:
    _ETLDebugPrint((uint64_t)"ETLPRLParseReadResponse", (uint64_t)v13, (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v16);
    return 0;
  }
  v9 = *(unsigned __int8 *)(v8 + 1);
  if (*(_BYTE *)(v8 + 1))
    v10 = v9 == 2;
  else
    v10 = 1;
  if (!v10)
  {
    if (v9 == 1)
      _ETLDebugPrint((uint64_t)"ETLPRLReadStatusIsSuccess", (uint64_t)"PRL Read status kStatusPRLNVReadFail [%u]\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, 1);
    else
      _ETLDebugPrint((uint64_t)"ETLPRLReadStatusIsSuccess", (uint64_t)"PRL Read status Invalid [%u]\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *(unsigned __int8 *)(v8 + 1));
    v16 = *(unsigned __int16 *)(v8 + 2);
    v13 = "PRL NV Read Status [%u]\n";
    goto LABEL_19;
  }
  if (*(unsigned __int8 *)(v8 + 4) != a2)
  {
    _ETLDebugPrint((uint64_t)"ETLPRLParseReadResponse", (uint64_t)"Sequence number out of order Expected[%u] Received[%u]\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, a2);
    return 0;
  }
  *a6 = *(_BYTE *)(v8 + 5);
  v11 = *(unsigned __int16 *)(v8 + 6);
  if (*(_WORD *)(v8 + 6))
  {
    v12 = v11 >> 3;
    if (v11 >> 3 > a4)
    {
      _ETLDebugPrint((uint64_t)"ETLPRLParseReadResponse", (uint64_t)"PRL Read Destination Buffer not sufficient. Passed[%u] Required[%u]\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, a4);
      return 0;
    }
    memcpy(__dst, (const void *)(v8 + 8), v11 >> 3);
    *a5 = v12;
  }
  return 1;
}

uint64_t ETLPRLCreateWriteCommand(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = (a3 + 6);
  if (HDLCFrameGetFreeSpace() < v3)
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v4, v5, v6, v7, v8, v9, v3);
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedShort();
  return HDLCFrameInject();
}

uint64_t ETLPRLParseWriteResponse(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;

  if (*((_DWORD *)a1 + 2) <= 3u)
  {
    _ETLDebugPrint((uint64_t)"ETLPRLParseWriteResponse", (uint64_t)"PRL Write Response size [%u] bytes not enough, need atleast [%u] bytes\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v8 = *a1;
    if (*a1)
    {
      v9 = *(unsigned __int8 *)(v8 + 1);
      if (v9 < 2)
      {
        return 1;
      }
      else
      {
        if (v9 == 3)
        {
          _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status kStatusPRLWriteOverflow [%u]\n", a3, a4, a5, a6, a7, a8, 3);
        }
        else if (v9 == 2)
        {
          _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status kStatusPRLWriteOutOfSeq [%u]\n", a3, a4, a5, a6, a7, a8, 2);
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status Invalid [%u]\n", a3, a4, a5, a6, a7, a8, *(unsigned __int8 *)(v8 + 1));
        }
        _ETLDebugPrint((uint64_t)"ETLPRLParseWriteResponse", (uint64_t)"PRL NV Write Status [%u]\n", v10, v11, v12, v13, v14, v15, *(unsigned __int16 *)(v8 + 2));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLPRLParseWriteResponse", (uint64_t)"PRL Get payload failed\n", a3, a4, a5, a6, a7, a8, v17);
      return 0;
    }
  }
}

uint64_t ETLPRLRead(_QWORD *a1, char *a2, unsigned int a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v5;
  unsigned __int8 v8;
  __int128 v9;
  unint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v34;
  char *__dst;
  unsigned int v37;
  unsigned int v38;
  __int128 v39;
  __int128 v40;
  unint64_t v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  unsigned __int8 v45;
  int v46;

  v5 = 0;
  if (a1 && a2 && a3 && a4)
  {
    __dst = a2;
    v37 = a3;
    v38 = 0;
    v8 = 0;
    v45 = 1;
    v41 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v10 = 0x1F028E000uLL;
    v39 = v9;
    v40 = v9;
    *a4 = 0;
    v11 = 0uLL;
    while (1)
    {
      v44 = 0;
      v42 = v11;
      v43 = v11;
      if ((HDLCFrameCreateUplink() & 1) == 0)
        break;
      v41 = 0;
      v39 = 0u;
      v40 = 0u;
      if (HDLCFrameGetFreeSpace() <= 2)
        _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v18, v19, v20, v21, v22, v23, 3);
      HDLCFrameInjectUnsignedChar();
      HDLCFrameInjectUnsignedChar();
      if (!HDLCFrameInjectUnsignedChar())
      {
        v5 = 0;
        HDLCFrameFree();
        HDLCFrameFree();
        return v5;
      }
      v5 = (uint64_t)malloc((2 * DWORD2(v42) + 32));
      if (!v5)
        goto LABEL_24;
      v24 = HDLCFrameEncode();
      if (!(_DWORD)v24)
        goto LABEL_23;
      v25 = v24;
      v46 = -1431655766;
      if ((*(_BYTE *)(v10 + 464) & 2) != 0)
        ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v5, v24);
      if (!*a1)
      {
LABEL_23:
        free((void *)v5);
        v5 = 0;
LABEL_24:
        HDLCFrameFree();
        HDLCFrameFree();
        return v5;
      }
      v26 = v10;
      v27 = a5;
      v28 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v5, v25, &v46, 1, a5, 0);
      v29 = v46;
      free((void *)v5);
      v5 = 0;
      if (v28 && v29 == (_DWORD)v25)
      {
        LOBYTE(v46) = 73;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        a5 = v27;
        v10 = v26;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)&v39, (uint64_t)&_ETLResponseRingBuffer, &v46, v27)&& ETLPRLParseReadResponse((uint64_t *)&v39, v8, __dst, v37, &v38, &v45, v30, v31))
        {
          __dst += v38;
          v37 -= v38;
          *a4 += v38;
          ++v8;
          v5 = 1;
        }
        else
        {
          v5 = 0;
        }
      }
      else
      {
        a5 = v27;
        v10 = v26;
      }
      HDLCFrameFree();
      v32 = v45;
      HDLCFrameFree();
      if ((_DWORD)v5)
      {
        v11 = 0uLL;
        if (v32)
          continue;
      }
      return v5;
    }
    _ETLDebugPrint((uint64_t)"ETLPRLRead", (uint64_t)"Failed to create command frame\n", v12, v13, v14, v15, v16, v17, v34);
    HDLCFrameFree();
    return 0;
  }
  return v5;
}

void *ETLPRLWrite(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  void *v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t (**v8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  int v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t (*v28)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD);
  uint64_t (**v29)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v30;
  int v31;
  int v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  uint64_t v43;
  __int128 v45;
  __int128 v46;
  unint64_t v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  int v51;

  v4 = 0;
  if (a1)
  {
    v5 = a2;
    if (a2)
    {
      v6 = a3;
      if (a3)
      {
        v8 = (uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a1;
        v9 = 0;
        v47 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v45 = v10;
        v46 = v10;
        v11 = 0uLL;
        while (1)
        {
          v50 = 0;
          v48 = v11;
          v49 = v11;
          if ((HDLCFrameCreateUplink() & 1) == 0)
            break;
          v47 = 0;
          v45 = 0u;
          v46 = 0u;
          if (v6 >= 0x78)
            v18 = 120;
          else
            v18 = v6;
          if (v6 <= 0x78)
            v19 = v6;
          else
            v19 = v6 - 120;
          if (HDLCFrameGetFreeSpace() < v18 + 6)
            _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v20, v21, v22, v23, v24, v25, v18 + 6);
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedShort();
          v4 = 0;
          if (!HDLCFrameInject())
            goto LABEL_30;
          v4 = malloc((2 * DWORD2(v48) + 32));
          if (!v4)
            goto LABEL_30;
          v26 = HDLCFrameEncode();
          if (!(_DWORD)v26)
            goto LABEL_28;
          v27 = v26;
          v51 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v4, v26);
          v28 = (uint64_t (*)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*v8;
          if (!*v8)
          {
LABEL_28:
            free(v4);
LABEL_29:
            v4 = 0;
LABEL_30:
            HDLCFrameFree();
            HDLCFrameFree();
            return v4;
          }
          v29 = v8;
          v30 = a4;
          v31 = v28(v29, v4, v27, &v51, 1, a4, 0);
          v32 = v51;
          free(v4);
          v4 = 0;
          if (!v31)
            goto LABEL_30;
          v33 = v32 == (_DWORD)v27;
          a4 = v30;
          v8 = (uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a1;
          if (!v33)
            goto LABEL_30;
          LOBYTE(v51) = 72;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          if (!ETLFindMatchingResponseUsingBuffer(a1, (unsigned __int8 **)&v45, (uint64_t)&_ETLResponseRingBuffer, &v51, a4))goto LABEL_29;
          v4 = (void *)ETLPRLParseWriteResponse((uint64_t *)&v45, v34, v35, v36, v37, v38, v39, v40);
          HDLCFrameFree();
          HDLCFrameFree();
          if ((_DWORD)v4)
          {
            ++v9;
            v5 += v18;
            v41 = v6 > 0x78;
            v6 = v19;
            v11 = 0uLL;
            if (v41)
              continue;
          }
          return v4;
        }
        _ETLDebugPrint((uint64_t)"ETLPRLWrite", (uint64_t)"Failed to create command frame\n", v12, v13, v14, v15, v16, v17, v43);
        HDLCFrameFree();
        return 0;
      }
    }
  }
  return v4;
}

uint64_t ETLFusingCreateReadQfpromFuseCommand()
{
  return ETLFusingCreateQfpromFusingCommand();
}

uint64_t ETLFusingCreateQfpromFusingCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v15;
  const char *v16;
  uint64_t v17;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    v15 = "ETLSubsysAddHeaderInternal";
    v16 = "Failed to inject\n";
LABEL_11:
    _ETLDebugPrint((uint64_t)v15, (uint64_t)v16, v7, v8, v9, v10, v11, v12, v17);
    return 0;
  }
  v13 = HDLCFrameGetFreeSpace();
  if (v13 <= 0x23)
  {
    v17 = v13;
    v15 = "ETLFusingCreateQfpromFusingCommand";
    v16 = "Remaining %u not enough %u\n";
    goto LABEL_11;
  }
  if (HDLCFrameInjectUnsignedShort()
    && HDLCFrameInjectUnsignedChar()
    && HDLCFrameInjectUnsignedChar())
  {
    return HDLCFrameInject();
  }
  return 0;
}

uint64_t ETLFusingCreateWriteQfpromFuseCommand()
{
  return ETLFusingCreateQfpromFusingCommand();
}

uint64_t ETLFusingCreateVerifyQfpromFuseCommand()
{
  return ETLFusingCreateQfpromFusingCommand();
}

uint64_t ETLFusingParseReadQfpromFuseResponse(int **a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        v12 = HIWORD(v11);
        if ((_DWORD)v12 == 11)
        {
          if (v9 <= 0x21)
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else
          {
            v13 = v10[1];
            v14 = *(_OWORD *)(v10 + 6);
            *a3 = *(_OWORD *)(v10 + 2);
            a3[1] = v14;
            if ((_DWORD)v13)
            {
              _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v13);
              return 0;
            }
            else
            {
              return 1;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLFusingParseWriteQfpromFuseResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;

  v8 = a1[2];
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        v11 = HIWORD(v10);
        if ((_DWORD)v11 == 11)
        {
          if (v9 <= 0x21)
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*(_DWORD *)(*(_QWORD *)a1 + 4))
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned int *)(*(_QWORD *)a1 + 4));
            return 0;
          }
          else
          {
            return 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLFusingParseVerifyQfpromFuseResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;

  v8 = a1[2];
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        v11 = HIWORD(v10);
        if ((_DWORD)v11 == 11)
        {
          if (v9 <= 0x21)
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*(_DWORD *)(*(_QWORD *)a1 + 4))
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned int *)(*(_QWORD *)a1 + 4));
            return 0;
          }
          else
          {
            return 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLFusingProgramQfpromFuse(_QWORD *a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v13;
  unsigned int v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __int128 v49;
  __int128 v50;
  _QWORD v51[4];
  _OWORD v52[2];
  __int128 __dst;
  __int128 v54;
  _BYTE __b[1024];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __dst = v13;
  v54 = v13;
  v52[0] = v13;
  v52[1] = v13;
  v51[3] = 0xAAAAAAAAAAAAAAAALL;
  memset((char *)v51 + 1, 170, 24);
  if (a5 > 0x1F)
  {
    v15 = a4[1];
    __dst = *a4;
    v54 = v15;
  }
  else
  {
    v14 = a5;
    _ETLDebugPrint((uint64_t)"ETLFusingProgramQfpromFuse", (uint64_t)"Data length needed %u  provided %u - padding the rest with zeroes\n", a3, (uint64_t)a4, a5, a6, a7, a8, 32);
    memcpy(&__dst, a4, v14);
    bzero((char *)&__dst + v14, 32 - v14);
  }
  memset(__b, 170, sizeof(__b));
  TelephonyUtilLogBinaryToBuffer();
  _ETLDebugPrint((uint64_t)"ETLFusingShowQfpromFuse", (uint64_t)"%s fuse %u, value: \t%s\n", v16, v17, v18, v19, v20, v21, (uint64_t)"Programming");
  *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v49 = v22;
  v50 = v22;
  if ((ETLFusingPerformQfpromFusingOperation(a1, a2, 0, 0, (uint64_t)v52, &v49, a6) & 1) != 0)
  {
    memset(__b, 170, sizeof(__b));
    TelephonyUtilLogBinaryToBuffer();
    _ETLDebugPrint((uint64_t)"ETLFusingShowQfpromFuse", (uint64_t)"%s fuse %u, value: \t%s\n", v29, v30, v31, v32, v33, v34, (uint64_t)"Read back");
    v41 = __dst;
    LOBYTE(v51[0]) = __dst & ~(_BYTE)v49;
    if ((v49 | __dst) == __dst)
    {
      v41 = BYTE1(__dst);
      BYTE1(v51[0]) = BYTE1(__dst) & ~BYTE1(v49);
      if ((BYTE1(v49) | BYTE1(__dst)) == BYTE1(__dst))
      {
        v41 = BYTE2(__dst);
        BYTE2(v51[0]) = BYTE2(__dst) & ~BYTE2(v49);
        if ((BYTE2(v49) | BYTE2(__dst)) == BYTE2(__dst))
        {
          v41 = BYTE3(__dst);
          BYTE3(v51[0]) = BYTE3(__dst) & ~BYTE3(v49);
          if ((BYTE3(v49) | BYTE3(__dst)) == BYTE3(__dst))
          {
            v41 = BYTE4(__dst);
            BYTE4(v51[0]) = BYTE4(__dst) & ~BYTE4(v49);
            if ((BYTE4(v49) | BYTE4(__dst)) == BYTE4(__dst))
            {
              v41 = BYTE5(__dst);
              BYTE5(v51[0]) = BYTE5(__dst) & ~BYTE5(v49);
              if ((BYTE5(v49) | BYTE5(__dst)) == BYTE5(__dst))
              {
                v41 = BYTE6(__dst);
                BYTE6(v51[0]) = BYTE6(__dst) & ~BYTE6(v49);
                if ((BYTE6(v49) | BYTE6(__dst)) == BYTE6(__dst))
                {
                  v41 = BYTE7(__dst);
                  HIBYTE(v51[0]) = BYTE7(__dst) & ~BYTE7(v49);
                  if ((BYTE7(v49) | BYTE7(__dst)) == BYTE7(__dst))
                  {
                    v41 = BYTE8(__dst);
                    LOBYTE(v51[1]) = BYTE8(__dst) & ~BYTE8(v49);
                    if ((BYTE8(v49) | BYTE8(__dst)) == BYTE8(__dst))
                    {
                      v41 = BYTE9(__dst);
                      BYTE1(v51[1]) = BYTE9(__dst) & ~BYTE9(v49);
                      if ((BYTE9(v49) | BYTE9(__dst)) == BYTE9(__dst))
                      {
                        v41 = BYTE10(__dst);
                        BYTE2(v51[1]) = BYTE10(__dst) & ~BYTE10(v49);
                        if ((BYTE10(v49) | BYTE10(__dst)) == BYTE10(__dst))
                        {
                          v41 = BYTE11(__dst);
                          BYTE3(v51[1]) = BYTE11(__dst) & ~BYTE11(v49);
                          if ((BYTE11(v49) | BYTE11(__dst)) == BYTE11(__dst))
                          {
                            v41 = BYTE12(__dst);
                            BYTE4(v51[1]) = BYTE12(__dst) & ~BYTE12(v49);
                            if ((BYTE12(v49) | BYTE12(__dst)) == BYTE12(__dst))
                            {
                              v41 = BYTE13(__dst);
                              BYTE5(v51[1]) = BYTE13(__dst) & ~BYTE13(v49);
                              if ((BYTE13(v49) | BYTE13(__dst)) == BYTE13(__dst))
                              {
                                v41 = BYTE14(__dst);
                                BYTE6(v51[1]) = BYTE14(__dst) & ~BYTE14(v49);
                                if ((BYTE14(v49) | BYTE14(__dst)) == BYTE14(__dst))
                                {
                                  v41 = HIBYTE(__dst);
                                  HIBYTE(v51[1]) = HIBYTE(__dst) & ~HIBYTE(v49);
                                  if ((HIBYTE(v49) | HIBYTE(__dst)) == HIBYTE(__dst))
                                  {
                                    v41 = v54;
                                    LOBYTE(v51[2]) = v54 & ~(_BYTE)v50;
                                    if ((v50 | v54) == v54)
                                    {
                                      v41 = BYTE1(v54);
                                      BYTE1(v51[2]) = BYTE1(v54) & ~BYTE1(v50);
                                      if ((BYTE1(v50) | BYTE1(v54)) == BYTE1(v54))
                                      {
                                        v41 = BYTE2(v54);
                                        BYTE2(v51[2]) = BYTE2(v54) & ~BYTE2(v50);
                                        if ((BYTE2(v50) | BYTE2(v54)) == BYTE2(v54))
                                        {
                                          v41 = BYTE3(v54);
                                          BYTE3(v51[2]) = BYTE3(v54) & ~BYTE3(v50);
                                          if ((BYTE3(v50) | BYTE3(v54)) == BYTE3(v54))
                                          {
                                            v41 = BYTE4(v54);
                                            BYTE4(v51[2]) = BYTE4(v54) & ~BYTE4(v50);
                                            if ((BYTE4(v50) | BYTE4(v54)) == BYTE4(v54))
                                            {
                                              v41 = BYTE5(v54);
                                              BYTE5(v51[2]) = BYTE5(v54) & ~BYTE5(v50);
                                              if ((BYTE5(v50) | BYTE5(v54)) == BYTE5(v54))
                                              {
                                                v41 = BYTE6(v54);
                                                BYTE6(v51[2]) = BYTE6(v54) & ~BYTE6(v50);
                                                if ((BYTE6(v50) | BYTE6(v54)) == BYTE6(v54))
                                                {
                                                  v41 = BYTE7(v54);
                                                  HIBYTE(v51[2]) = BYTE7(v54) & ~BYTE7(v50);
                                                  if ((BYTE7(v50) | BYTE7(v54)) == BYTE7(v54))
                                                  {
                                                    v41 = BYTE8(v54);
                                                    LOBYTE(v51[3]) = BYTE8(v54) & ~BYTE8(v50);
                                                    if ((BYTE8(v50) | BYTE8(v54)) == BYTE8(v54))
                                                    {
                                                      v41 = BYTE9(v54);
                                                      BYTE1(v51[3]) = BYTE9(v54) & ~BYTE9(v50);
                                                      if ((BYTE9(v50) | BYTE9(v54)) == BYTE9(v54))
                                                      {
                                                        v41 = BYTE10(v54);
                                                        BYTE2(v51[3]) = BYTE10(v54) & ~BYTE10(v50);
                                                        if ((BYTE10(v50) | BYTE10(v54)) == BYTE10(v54))
                                                        {
                                                          v41 = BYTE11(v54);
                                                          BYTE3(v51[3]) = BYTE11(v54) & ~BYTE11(v50);
                                                          if ((BYTE11(v50) | BYTE11(v54)) == BYTE11(v54))
                                                          {
                                                            v41 = BYTE12(v54);
                                                            BYTE4(v51[3]) = BYTE12(v54) & ~BYTE12(v50);
                                                            if ((BYTE12(v50) | BYTE12(v54)) == BYTE12(v54))
                                                            {
                                                              v41 = BYTE13(v54);
                                                              BYTE5(v51[3]) = BYTE13(v54) & ~BYTE13(v50);
                                                              if ((BYTE13(v50) | BYTE13(v54)) == BYTE13(v54))
                                                              {
                                                                v41 = BYTE14(v54);
                                                                BYTE6(v51[3]) = BYTE14(v54) & ~BYTE14(v50);
                                                                if ((BYTE14(v50) | BYTE14(v54)) == BYTE14(v54))
                                                                {
                                                                  v41 = HIBYTE(v54);
                                                                  HIBYTE(v51[3]) = HIBYTE(v54) & ~HIBYTE(v50);
                                                                  if ((HIBYTE(v50) | HIBYTE(v54)) == HIBYTE(v54))
                                                                  {
                                                                    memset(__b, 170, sizeof(__b));
                                                                    TelephonyUtilLogBinaryToBuffer();
                                                                    _ETLDebugPrint((uint64_t)"ETLFusingShowQfpromFuse", (uint64_t)"%s fuse %u, value: \t%s\n", v42, v43, v44, v45, v46, v47, (uint64_t)"Final write value for Programming");
                                                                    return ETLFusingPerformQfpromFusingOperation(a1, a2, 1, a3, (uint64_t)v51, v52, a6);
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    _ETLDebugPrint((uint64_t)"ETLFusingProgramQfpromFuse", (uint64_t)"Mismatch, expected to write %02x, final value on device will be %02x\n", v35, v36, v37, v38, v39, v40, v41);
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFusingProgramQfpromFuse", (uint64_t)"Failed to read the fuse %u\n", v23, v24, v25, v26, v27, v28, a2);
  }
  return 0;
}

uint64_t ETLFusingPerformQfpromFusingOperation(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, _OWORD *a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int *v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  _OWORD v40[2];
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  _OWORD v45[2];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v42 = 0u;
  v43 = 0u;
  v44 = 0;
  memset(v40, 0, sizeof(v40));
  v41 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLFusingPerformQfpromFusingOperation", (uint64_t)"Faild to create uplink frame\n", v11, v12, v13, v14, v15, v16, v39);
    goto LABEL_8;
  }
  if (!a3)
  {
    memset(v45, 0, sizeof(v45));
    v17 = 0;
    if (!ETLFusingCreateQfpromFusingCommand())
      goto LABEL_9;
    goto LABEL_13;
  }
  if (a3 == 2)
  {
    if ((ETLFusingCreateQfpromFusingCommand() & 1) != 0)
      goto LABEL_13;
LABEL_8:
    v17 = 0;
    goto LABEL_9;
  }
  if (a3 == 1 && (ETLFusingCreateQfpromFusingCommand() & 1) == 0)
    goto LABEL_8;
LABEL_13:
  v17 = (uint64_t)malloc((2 * DWORD2(v42) + 32));
  if (!v17)
    goto LABEL_9;
  v19 = HDLCFrameEncode();
  if (!(_DWORD)v19)
    goto LABEL_31;
  v20 = v19;
  LODWORD(v45[0]) = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v19);
  if (!*a1)
  {
LABEL_31:
    free((void *)v17);
    goto LABEL_8;
  }
  v21 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, _QWORD))*a1)(a1, v17, v20, v45, 1, a7, 0);
  v22 = v45[0];
  free((void *)v17);
  v17 = 0;
  if (!v21 || v22 != (_DWORD)v20)
    goto LABEL_9;
  LOBYTE(v45[0]) = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v17 = 0;
  if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v40, (uint64_t)&_ETLResponseRingBuffer, v45, a7)|| LOBYTE(v45[0]) != 75)
  {
    goto LABEL_9;
  }
  if (a3 == 2)
  {
    LODWORD(v45[0]) = 0;
    v17 = 0;
    if (!ETLMaverickParseBSPResponseHeader((uint64_t)v40, v45, 11, v23, v24, v25, v26, v27))
      goto LABEL_9;
    v38 = LODWORD(v45[0]);
    v34 = (DWORD2(v40[0]) - LODWORD(v45[0]));
    if (v34 <= 0x21)
      goto LABEL_38;
    goto LABEL_34;
  }
  if (a3 == 1)
  {
    LODWORD(v45[0]) = 0;
    v17 = 0;
    if (!ETLMaverickParseBSPResponseHeader((uint64_t)v40, v45, 11, v23, v24, v25, v26, v27))
      goto LABEL_9;
    v38 = LODWORD(v45[0]);
    v34 = (DWORD2(v40[0]) - LODWORD(v45[0]));
    if (v34 <= 0x21)
      goto LABEL_38;
LABEL_34:
    v36 = *(unsigned int *)(*(_QWORD *)&v40[0] + v38);
    if (!(_DWORD)v36)
      goto LABEL_30;
LABEL_35:
    _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", v28, v29, v30, v31, v32, v33, v36);
    goto LABEL_8;
  }
  if (a3)
  {
LABEL_30:
    v17 = 1;
    goto LABEL_9;
  }
  LODWORD(v45[0]) = 0;
  v17 = 0;
  if (ETLMaverickParseBSPResponseHeader((uint64_t)v40, v45, 11, v23, v24, v25, v26, v27))
  {
    v34 = (DWORD2(v40[0]) - LODWORD(v45[0]));
    if (v34 > 0x21)
    {
      v35 = (unsigned int *)(*(_QWORD *)&v40[0] + LODWORD(v45[0]));
      v36 = *v35;
      v37 = *(_OWORD *)(v35 + 5);
      *a6 = *(_OWORD *)(v35 + 1);
      a6[1] = v37;
      if (!(_DWORD)v36)
        goto LABEL_30;
      goto LABEL_35;
    }
LABEL_38:
    _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", v28, v29, v30, v31, v32, v33, v34);
    goto LABEL_8;
  }
LABEL_9:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

uint64_t ETLFusingReadQfpromFuse(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v8;
  uint64_t v9;
  _QWORD *v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v24;
  __int128 v25;
  _QWORD v26[134];

  v26[133] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v26 = v8;
  *(_OWORD *)&v26[2] = v8;
  *a5 = 0;
  if (a4 > 0x1F)
  {
    v12 = (_QWORD *)MEMORY[0x1E0C80A78](a1, a2, a3, a4);
    v24 = v13;
    v25 = v13;
    v9 = ETLFusingPerformQfpromFusingOperation(v12, v14, 0, 0, (uint64_t)v26, &v24, v15);
    if ((_DWORD)v9)
    {
      *a5 = 32;
      v16 = v25;
      *a3 = v24;
      a3[1] = v16;
      memset(&v26[5], 170, 0x400uLL);
      TelephonyUtilLogBinaryToBuffer();
      _ETLDebugPrint((uint64_t)"ETLFusingShowQfpromFuse", (uint64_t)"%s fuse %u, value: \t%s\n", v17, v18, v19, v20, v21, v22, (uint64_t)"Read back");
    }
  }
  else
  {
    *((_QWORD *)&v25 + 1) = 32;
    _ETLDebugPrint((uint64_t)"ETLFusingReadQfpromFuse", (uint64_t)"Data capacity %u less than required %u\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, a4);
    return 0;
  }
  return v9;
}

uint64_t ETLFusingVerifyQfpromFuse(_QWORD *a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v13;
  unsigned int v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 __dst;
  __int128 v24;
  _OWORD __b[64];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __dst = v13;
  v24 = v13;
  if (a5 > 0x1F)
  {
    v15 = a4[1];
    __dst = *a4;
    v24 = v15;
  }
  else
  {
    v14 = a5;
    _ETLDebugPrint((uint64_t)"ETLFusingVerifyQfpromFuse", (uint64_t)"Data length needed %u  provided %u - padding the rest with zeroes\n", a3, (uint64_t)a4, a5, a6, a7, a8, 32);
    memcpy(&__dst, a4, v14);
    bzero((char *)&__dst + v14, 32 - v14);
  }
  memset(__b, 170, sizeof(__b));
  TelephonyUtilLogBinaryToBuffer();
  _ETLDebugPrint((uint64_t)"ETLFusingShowQfpromFuse", (uint64_t)"%s fuse %u, value: \t%s\n", v16, v17, v18, v19, v20, v21, (uint64_t)"Verifying");
  return ETLFusingPerformQfpromFusingOperation(a1, a2, 2, a3, (uint64_t)&__dst, __b, a6);
}

uint64_t ETLProvisionAddSecurityCommandHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLProvisionParseSecurityResponseHeader(uint64_t a1, int a2, _WORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int16 *v20;

  result = ETLMaverickParseFACTORYResponseHeader(a1, a4, 12, (uint64_t)a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    v19 = *a4;
    if ((*(_DWORD *)(a1 + 8) - v19) <= 3)
    {
      _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", v13, v14, v15, v16, v17, v18, 4);
    }
    else
    {
      v20 = (unsigned __int16 *)(*(_QWORD *)a1 + v19);
      if (*v20 == a2)
      {
        *a3 = v20[1];
        *a4 = v19 + 4;
        return 1;
      }
      _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", v13, v14, v15, v16, v17, v18, *v20);
    }
    return 0;
  }
  return result;
}

const char *ETLProvisionGetStateAsString(unsigned int a1)
{
  if (a1 > 4)
    return "???";
  else
    return off_1EA1F1C18[a1];
}

uint64_t ETLProvisionParseStatus(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  unsigned int v11;
  int v12;
  int v13;

  _ETLDebugPrint((uint64_t)"ETLProvisionParseStatus", (uint64_t)"Provisioning manifest status %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(a1 + 8));
  v10 = *(unsigned __int16 *)(a1 + 8);
  v11 = v10 - 28;
  if (v10 == 6)
    v12 = 2;
  else
    v12 = 1;
  if (*(_WORD *)(a1 + 8))
    v13 = v12;
  else
    v13 = 0;
  if (v11 < 2)
    v13 = 3;
  *(_DWORD *)(a2 + 4) = v13;
  return 1;
}

uint64_t ETLProvisionCreateStartProvisionCommand(uint64_t a1, uint64_t a2)
{
  uint64_t FreeSpace;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  const char *v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v4, v5, v6, v7, v8, v9, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    v17 = "ETLSubsysAddHeaderInternal";
    v18 = "Failed to inject\n";
LABEL_11:
    _ETLDebugPrint((uint64_t)v17, (uint64_t)v18, v10, v11, v12, v13, v14, v15, v20);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v20 = 2;
    goto LABEL_10;
  }
  if (!HDLCFrameInjectUnsignedShort())
    return 0;
  v16 = (*(_DWORD *)(a2 + 8) + 2);
  if (HDLCFrameGetFreeSpace() < v16)
  {
    v20 = v16;
LABEL_10:
    v17 = "ETLRequireFreeSpace";
    v18 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_11;
  }
  if (!HDLCFrameInjectUnsignedShort())
    return 0;
  return HDLCFrameInject();
}

uint64_t ETLProvisionParseStartProvisionResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  size_t v14;

  v8 = a1[2];
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  v9 = *(unsigned int **)a1;
  v10 = **(_DWORD **)a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    return 0;
  }
  if (BYTE1(v10) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    return 0;
  }
  v11 = HIWORD(v10);
  if ((_DWORD)v11 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
    return 0;
  }
  if (v8 - 4 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  v12 = *((unsigned __int16 *)v9 + 2);
  if (*((_WORD *)v9 + 2))
  {
    _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 2));
    return 0;
  }
  if (v8 - 28 > 0xFFFFFFEB || *((_WORD *)v9 + 3))
    return v12;
  v14 = v9[6];
  *(_OWORD *)a2 = *(_OWORD *)(v9 + 2);
  *(_DWORD *)(a2 + 16) = v14;
  if (v14 > 0x100 || a1[2] - 28 < v14)
    return 0;
  memcpy((void *)(a2 + 20), (const void *)(*(_QWORD *)a1 + 28), v14);
  return 1;
}

uint64_t ETLProvisionCreateFinishProvisionCommand(uint64_t a1, uint64_t a2)
{
  uint64_t FreeSpace;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  const char *v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v4, v5, v6, v7, v8, v9, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    v17 = "ETLSubsysAddHeaderInternal";
    v18 = "Failed to inject\n";
LABEL_11:
    _ETLDebugPrint((uint64_t)v17, (uint64_t)v18, v10, v11, v12, v13, v14, v15, v20);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v20 = 2;
    goto LABEL_10;
  }
  if (!HDLCFrameInjectUnsignedShort())
    return 0;
  v16 = (*(_DWORD *)(a2 + 8) + 2);
  if (HDLCFrameGetFreeSpace() < v16)
  {
    v20 = v16;
LABEL_10:
    v17 = "ETLRequireFreeSpace";
    v18 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_11;
  }
  if (!HDLCFrameInjectUnsignedShort())
    return 0;
  return HDLCFrameInject();
}

uint64_t ETLProvisionParseFinishProvisionResponse(int **a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  _DWORD *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t result;
  int v13;

  v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  v9 = *a1;
  v10 = **a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    return 0;
  }
  if (BYTE1(v10) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    return 0;
  }
  v11 = HIWORD(v10);
  if ((_DWORD)v11 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
    return 0;
  }
  if (v8 - 4 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  if (*((_WORD *)v9 + 2) != 1)
  {
    _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 2));
    return 0;
  }
  result = 0;
  if (v8 - 15 <= 0xFFFFFFF8 && !*((_WORD *)v9 + 3))
  {
    v13 = v9[2];
    *(_DWORD *)((char *)a2 + 3) = *(_DWORD *)((char *)v9 + 11);
    *a2 = v13;
    return 1;
  }
  return result;
}

uint64_t ETLProvisionGetStatus(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  int v12;
  BOOL v13;
  BOOL v14;
  BOOL v15;
  int v16;
  _OWORD v18[2];

  memset(v18, 0, sizeof(v18));
  *(_QWORD *)a2 = 0;
  if (ETLMaverickGetManifestStatus(a1, (uint64_t *)v18, a3))
  {
    v10 = WORD4(v18[0]);
    _ETLDebugPrint((uint64_t)"ETLProvisionParseStatus", (uint64_t)"Provisioning manifest status %u\n", v4, v5, v6, v7, v8, v9, WORD4(v18[0]));
    v11 = v10 - 28;
    if (v10 == 6)
      v12 = 2;
    else
      v12 = 1;
    if (v10)
      v13 = v10 != 6;
    else
      v13 = 0;
    if (!v10)
      v12 = 0;
    v14 = v11 >= 2;
    v15 = v11 >= 2 && v13;
    if (v14)
      v16 = v12;
    else
      v16 = 3;
    *(_DWORD *)(a2 + 4) = v16;
    *(_BYTE *)a2 = v15;
    return 1;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = 4;
    return 1;
  }
}

uint64_t ETLProvisionStart(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t started;
  _OWORD v24[2];
  uint64_t v25;
  _OWORD v26[2];
  uint64_t v27;
  int v28;

  memset(v26, 0, sizeof(v26));
  v27 = 0;
  memset(v24, 0, sizeof(v24));
  v25 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_19;
  if (!ETLProvisionCreateStartProvisionCommand((uint64_t)v26, a2))
    goto LABEL_19;
  v8 = malloc((2 * DWORD2(v26[0]) + 32));
  if (!v8)
    goto LABEL_19;
  v9 = v8;
  v10 = HDLCFrameEncode();
  if (!(_DWORD)v10)
    goto LABEL_18;
  v11 = v10;
  v28 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v9, v10);
  if (!*a1)
  {
LABEL_18:
    free(v9);
LABEL_19:
    started = 0;
    goto LABEL_20;
  }
  v12 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v9, v11, &v28, 1, a4, 0);
  v13 = v28;
  free(v9);
  if (v12)
    v14 = v13 == (_DWORD)v11;
  else
    v14 = 0;
  if (!v14)
    goto LABEL_19;
  LOBYTE(v28) = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v15 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v24, (uint64_t)&_ETLResponseRingBuffer, &v28, a4);
  started = 0;
  if (v15 && v28 == 75)
    started = ETLProvisionParseStartProvisionResponse((unsigned int *)v24, a3, v16, v17, v18, v19, v20, v21);
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return started;
}

uint64_t ETLProvisionFinish(_QWORD *a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v25[2];
  uint64_t v26;
  _OWORD v27[2];
  uint64_t v28;
  int v29;

  memset(v27, 0, sizeof(v27));
  v28 = 0;
  memset(v25, 0, sizeof(v25));
  v26 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_19;
  if (!ETLProvisionCreateFinishProvisionCommand((uint64_t)v27, a2))
    goto LABEL_19;
  v8 = malloc((2 * DWORD2(v27[0]) + 32));
  if (!v8)
    goto LABEL_19;
  v9 = v8;
  v10 = HDLCFrameEncode();
  if (!(_DWORD)v10)
    goto LABEL_18;
  v11 = v10;
  v29 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v9, v10);
  if (!*a1)
  {
LABEL_18:
    free(v9);
LABEL_19:
    v23 = 0;
    goto LABEL_20;
  }
  v12 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v9, v11, &v29, 1, a4, 0);
  v13 = v29;
  free(v9);
  if (v12)
    v14 = v13 == (_DWORD)v11;
  else
    v14 = 0;
  if (!v14)
    goto LABEL_19;
  v15 = 3 * a4;
  LOBYTE(v29) = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v16 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &v29, v15);
  v23 = 0;
  if (v16 && v29 == 75)
    v23 = ETLProvisionParseFinishProvisionResponse((int **)v25, a3, v17, v18, v19, v20, v21, v22);
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v23;
}

uint64_t ETLEFS2PrintError(uint64_t __errnum)
{
  uint64_t v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char __strerrbuf[16];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _BYTE v23[31];
  uint64_t v24;

  v1 = __errnum;
  v24 = *MEMORY[0x1E0C80C00];
  v22 = 0u;
  memset(v23, 0, sizeof(v23));
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  *(_OWORD *)__strerrbuf = 0u;
  if ((int)__errnum >= 0x8000)
  {
    if ((int)__errnum <= 32769)
    {
      if ((_DWORD)__errnum == 0x8000)
        v2 = "End of file. Internal error.";
      else
        v2 = "Untranslated SFAT error code.";
      goto LABEL_26;
    }
    switch((_DWORD)__errnum)
    {
      case 0x8002:
        v2 = "Untranslated HFAT error code.";
        goto LABEL_26;
      case 0xFFFF:
        v2 = "Internal Error";
        goto LABEL_26;
      case 0x10000:
        v2 = "File has no number to EFS file mapping";
        goto LABEL_26;
    }
  }
  else
  {
    if ((int)__errnum > 121)
    {
      switch((int)__errnum)
      {
        case 301:
          v2 = "No media present.";
          goto LABEL_26;
        case 302:
          v2 = "Bad formatted media.";
          goto LABEL_26;
        case 303:
          v2 = "Not an EFS2 item file.";
          goto LABEL_26;
        case 304:
          v2 = "Rollback failed while backing orig file.";
          goto LABEL_26;
        default:
          if ((_DWORD)__errnum != 122)
            goto LABEL_19;
          v2 = "Writing beyong quota.";
          break;
      }
      goto LABEL_26;
    }
    switch((_DWORD)__errnum)
    {
      case 0:
        return __errnum;
      case 0x22:
        v2 = "Parameter out of range.";
        goto LABEL_26;
      case 0x74:
        v2 = "Stale remote file handle.";
LABEL_26:
        strncpy(__strerrbuf, v2, 0xFEuLL);
        goto LABEL_27;
    }
  }
LABEL_19:
  strerror_r(__errnum, __strerrbuf, 0xFEuLL);
LABEL_27:
  fprintf((FILE *)*MEMORY[0x1E0C80C10], "Error: [%d] ETL EFS - %s\n", v1, __strerrbuf);
  return _ETLDebugPrint((uint64_t)"ETLEFS2PrintError", (uint64_t)"Error: [%d] ETL EFS - %s\n", v3, v4, v5, v6, v7, v8, v1);
}

uint64_t ETLEFS2CreatePutCommand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, unsigned int a7)
{
  uint64_t FreeSpace;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;

  if (a7 > 0x7C00)
    return 0;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v10, v11, v12, v13, v14, v15, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v16, v17, v18, v19, v20, v21, v30);
    return 0;
  }
  v22 = a7 + strlen(a5) + 1 + 6;
  if (HDLCFrameGetFreeSpace() < v22)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v23, v24, v25, v26, v27, v28, v22);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInject())
  {
    return 0;
  }
  return HDLCFrameInject();
}

BOOL ETLEFS2ParsePutResponse(int **a1, int a2, _WORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  int v15;

  *a4 = 0xFFFF;
  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  v10 = *a1;
  v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, **a1);
    return 0;
  }
  v12 = HIWORD(v11);
  v13 = BYTE1(v11);
  if (a2)
    v14 = 62;
  else
    v14 = 19;
  if (v13 != (_DWORD)v14)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Subsys mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v14);
    goto LABEL_13;
  }
  if (v12 != 38)
  {
LABEL_13:
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Command code mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 38);
    return 0;
  }
  if (v9 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParsePutResponse", (uint64_t)"Needed %u bytes, available %u\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 6);
    return 0;
  }
  else
  {
    *a3 = *((_WORD *)v10 + 2);
    v15 = *(_DWORD *)((char *)v10 + 6);
    *a4 = v15;
    return v15 == 0;
  }
}

uint64_t ETLEFS2CreateGetCommand(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, unsigned int a6)
{
  int v7;
  uint64_t FreeSpace;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;

  if (a6 >= 0x7C00)
    v7 = 31744;
  else
    v7 = a6;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v9, v10, v11, v12, v13, v14, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v15, v16, v17, v18, v19, v20, v29);
    return 0;
  }
  v21 = v7 + strlen(a4) + 1 + 6;
  if (HDLCFrameGetFreeSpace() < v21)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v22, v23, v24, v25, v26, v27, v21);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedShort())
  {
    return 0;
  }
  return HDLCFrameInject();
}

uint64_t ETLEFS2CreateStatCommand(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t FreeSpace;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v5, v6, v7, v8, v9, v10, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v11, v12, v13, v14, v15, v16, v25);
    return 0;
  }
  v17 = strlen(a3) + 1;
  if (HDLCFrameGetFreeSpace() < v17)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v18, v19, v20, v21, v22, v23, v17);
    return 0;
  }
  return HDLCFrameInject();
}

uint64_t ETLEFS2ParseGetResponse(int **a1, int a2, void *__dst, uint64_t a4, _WORD *a5, _DWORD *a6, _DWORD *a7, uint64_t a8)
{
  unsigned int v8;
  _DWORD *v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  size_t v15;

  *a6 = 0xFFFF;
  v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  v9 = *a1;
  v10 = **a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, **a1);
    return 0;
  }
  v11 = HIWORD(v10);
  v12 = BYTE1(v10);
  if (a2)
    v13 = 62;
  else
    v13 = 19;
  if (v12 != (_DWORD)v13)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Subsys mismatch, expected 0x%x, got 0x%x\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, v13);
    goto LABEL_14;
  }
  if (v11 != 39)
  {
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Command code mismatch, expected 0x%x, got 0x%x\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, 39);
    return 0;
  }
  if (v8 - 4 <= 9)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseGetResponse", (uint64_t)"Needed %u bytes, available %u\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, 10);
    return 0;
  }
  else
  {
    *a7 = v9[1];
    *a6 = v9[2];
    *a5 = *((_WORD *)v9 + 6);
    if (*a6)
    {
      return 0;
    }
    else
    {
      v15 = v8 - 14;
      if (v15 <= a4)
      {
        memcpy(__dst, (char *)v9 + 14, v15);
        return 1;
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLEFS2ParseGetResponse", (uint64_t)"Capacity %u is not enough for response of size %u\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, a4);
        return 0;
      }
    }
  }
}

uint64_t ETLEFS2ParseStatResponse(int **a1, int a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  int v15;

  *a3 = 0xFFFF;
  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  v10 = *a1;
  v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, **a1);
    return 0;
  }
  v12 = HIWORD(v11);
  v13 = BYTE1(v11);
  if (a2)
    v14 = 62;
  else
    v14 = 19;
  if (v13 != (_DWORD)v14)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Subsys mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v14);
    goto LABEL_14;
  }
  if (v12 != 15)
  {
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Command code mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 15);
    return 0;
  }
  if (v9 <= 0x1B)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseStatResponse", (uint64_t)"Needed %u bytes, available %u\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 28);
    return 0;
  }
  else
  {
    v15 = v10[1];
    *a3 = v15;
    if (v15)
    {
      return 0;
    }
    else
    {
      *a4 = v10[3];
      return 1;
    }
  }
}

uint64_t ETLEFS2SelectorFromString(const char *a1, _DWORD *a2)
{
  if (!strcmp(a1, "prim") || !strcmp(a1, "primary"))
  {
    *a2 = 0;
    return 1;
  }
  else if (!strcmp(a1, "alt") || !strcmp(a1, "alternate"))
  {
    *a2 = 1;
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t ETLEFS2CreateSyncNoWaitCommand(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const char *v37;
  uint64_t v38;

  if (!a1 || !a3)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2CreateSyncNoWaitCommand", (uint64_t)"invalid arguments:  frame = %p, path = %p\n", (uint64_t)a3, a4, a5, a6, a7, a8, a1);
    return 0;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    v38 = FreeSpace;
    v16 = "Free space %u not enough for %zu\n";
  }
  else
  {
    if ((HDLCFrameInject() & 1) != 0)
      goto LABEL_9;
    v16 = "Failed to inject\n";
  }
  _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)v16, v10, v11, v12, v13, v14, v15, v38);
LABEL_9:
  v17 = strlen(a3) + 3;
  if (HDLCFrameGetFreeSpace() >= v17)
  {
    if ((HDLCFrameInjectUnsignedShort() & 1) != 0)
    {
      if ((HDLCFrameInject() & 1) != 0)
        return 1;
      v37 = "failed adding path to HDLC frame\n";
    }
    else
    {
      v37 = "failed adding sequenceNumber to HDLC frame\n";
    }
    _ETLDebugPrint((uint64_t)"ETLEFS2CreateSyncNoWaitCommand", (uint64_t)v37, v30, v31, v32, v33, v34, v35, v38);
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v18, v19, v20, v21, v22, v23, v17);
    _ETLDebugPrint((uint64_t)"ETLEFS2CreateSyncNoWaitCommand", (uint64_t)"Needed %u bytes, but not enough free space\n", v24, v25, v26, v27, v28, v29, v17);
  }
  return 0;
}

uint64_t ETLEFS2ParseSyncNoWaitResponse(uint64_t a1, _WORD *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  int v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  *a4 = 0xFFFF;
  if (!a1 || !a2 || !a3)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseSyncNoWaitResponse", (uint64_t)"invalid arguments:  frame = %p, sequenceNumber = %p, syncToken = %p, resposneErrno = %p\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, a1);
    return 0;
  }
  v8 = *(_DWORD *)(a1 + 8);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, *(unsigned int *)(a1 + 8));
LABEL_23:
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseSyncNoWaitResponse", (uint64_t)"failed parsing header\n", v16, v17, v18, v19, v20, v21, v22);
    return 0;
  }
  v10 = *(unsigned int **)a1;
  v11 = **(_DWORD **)a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_23;
  }
  if (BYTE1(v11) != 19)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Subsys mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 19);
    goto LABEL_22;
  }
  if (HIWORD(v11) != 48)
  {
LABEL_22:
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Command code mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 48);
    goto LABEL_23;
  }
  if (v9 <= 9)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseSyncNoWaitResponse", (uint64_t)"needed %u bytes, available %u\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 10);
    return 0;
  }
  *a2 = *((_WORD *)v10 + 2);
  *a3 = *(unsigned int *)((char *)v10 + 6);
  v12 = *(unsigned int *)((char *)v10 + 10);
  *a4 = v12;
  if (v12)
    v13 = v12 == 306;
  else
    v13 = 1;
  v14 = v13;
  if (v12 && v12 != 306)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseSyncNoWaitResponse", (uint64_t)"sync was not successful, errno %u\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 0);
    return v14;
  }
  return v14;
}

uint64_t ETLEFS2SyncNoWait(_QWORD *a1, uint64_t a2, const char *a3, _DWORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  const char *v27;
  uint64_t v29;
  unsigned __int16 v30;
  _OWORD v31[2];
  uint64_t v32;
  _OWORD v33[2];
  uint64_t v34;
  int v35;

  v30 = 0;
  memset(v33, 0, sizeof(v33));
  v34 = 0;
  memset(v31, 0, sizeof(v31));
  v32 = 0;
  if (!a1 || !a3 || !a4 || !a5)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2SyncNoWait", (uint64_t)"invalid arguments:  transport = %p, path = %p, syncToken = %p, responseErrno = %p\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, (uint64_t)a1);
LABEL_27:
    v26 = 0;
    goto LABEL_28;
  }
  *a5 = 0xFFFF;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v27 = "Failed to create command frame\n";
LABEL_26:
    _ETLDebugPrint((uint64_t)"ETLEFS2SyncNoWait", (uint64_t)v27, v14, v15, v16, v17, v18, v19, v29);
    goto LABEL_27;
  }
  if ((ETLEFS2CreateSyncNoWaitCommand((uint64_t)v33, a2, a3, v15, v16, v17, v18, v19) & 1) == 0)
  {
    v27 = "failed to create EFS sync command\n";
    goto LABEL_26;
  }
  v20 = malloc((2 * DWORD2(v33[0]) + 32));
  if (!v20)
  {
LABEL_25:
    v27 = "failed to send EFS sync command\n";
    goto LABEL_26;
  }
  v21 = v20;
  v22 = HDLCFrameEncode();
  if (!(_DWORD)v22)
    goto LABEL_24;
  v23 = v22;
  v35 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v21, v22);
  if (!*a1)
  {
LABEL_24:
    free(v21);
    goto LABEL_25;
  }
  v24 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v21, v23, &v35, 1, a6, 0);
  v25 = v35;
  free(v21);
  if (!v24 || v25 != (_DWORD)v23)
    goto LABEL_25;
  LOBYTE(v35) = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v31, (uint64_t)&_ETLResponseRingBuffer, &v35, a6)|| v35 != 75)
  {
    v27 = "failed to find EFS sync command response\n";
    goto LABEL_26;
  }
  if ((ETLEFS2ParseSyncNoWaitResponse((uint64_t)v31, &v30, a4, a5, v16, v17, v18, v19) & 1) == 0)
  {
    v27 = "failed parsing EFS sync response\n";
    goto LABEL_26;
  }
  if (v30 != (_DWORD)a2)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2SyncNoWait", (uint64_t)"sequence number out of order, got %u, sent %u\n", v14, v15, v16, v17, v18, v19, v30);
    goto LABEL_27;
  }
  v26 = 1;
LABEL_28:
  HDLCFrameFree();
  HDLCFrameFree();
  return v26;
}

uint64_t ETLEFS2Put(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, char *__s, uint64_t a6, unsigned int a7, _DWORD *a8, unsigned int a9)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v39;
  _OWORD v40[2];
  uint64_t v41;
  _OWORD v42[2];
  uint64_t v43;
  int v44;

  memset(v42, 0, sizeof(v42));
  v43 = 0;
  memset(v40, 0, sizeof(v40));
  v41 = 0;
  *a8 = 0xFFFF;
  strlen(__s);
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2Put", (uint64_t)"Failed to create command frame\n", v17, v18, v19, v20, v21, v22, v39);
    goto LABEL_19;
  }
  if (!ETLEFS2CreatePutCommand((uint64_t)v42, a2, a3, a4, __s, a6, a7))
    goto LABEL_19;
  v23 = (uint64_t)malloc((2 * DWORD2(v42[0]) + 32));
  if (!v23)
    goto LABEL_20;
  v24 = HDLCFrameEncode();
  if (!(_DWORD)v24)
    goto LABEL_21;
  v25 = v24;
  v44 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v23, v24);
  if (!*a1)
  {
LABEL_21:
    free((void *)v23);
    goto LABEL_19;
  }
  v26 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, _QWORD, _QWORD))*a1)(a1, v23, v25, &v44, 1, a9, 0);
  v27 = v44;
  free((void *)v23);
  v23 = 0;
  if (!v26 || v27 != (_DWORD)v25)
    goto LABEL_20;
  LOBYTE(v44) = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v23 = 0;
  if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v40, (uint64_t)&_ETLResponseRingBuffer, &v44, a9)|| v44 != 75)
  {
    goto LABEL_20;
  }
  LOWORD(v44) = -21846;
  if (!ETLEFS2ParsePutResponse((int **)v40, a2, &v44, a8, v28, v29, v30, v31))
  {
LABEL_19:
    v23 = 0;
    goto LABEL_20;
  }
  v23 = 1;
  if ((unsigned __int16)v44 != (_DWORD)a4 && (_DWORD)a4 + 1 != (unsigned __int16)v44)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2Put", (uint64_t)"Sequence number out of order, got %u, sent %u\n", v32, v33, v34, v35, v36, v37, (unsigned __int16)v44);
    goto LABEL_19;
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v23;
}

uint64_t ETLEFS2Get(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, char *__s, void *a5, unsigned int a6, unsigned int *a7, unsigned int *a8, unsigned int a9)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  size_t v44;
  uint64_t v45;
  int v46;
  int v47;
  void *v48;
  void *__src;
  _OWORD v50[2];
  uint64_t v51;
  _OWORD v52[2];
  uint64_t v53;
  unsigned int v54;
  int v55;

  v54 = 0;
  if ((ETLEFS2GetSize(a1, a2, __s, &v54, a7, a9) & 1) != 0)
  {
    v23 = v54;
    if (v54)
    {
      memset(v52, 0, sizeof(v52));
      v53 = 0;
      memset(v50, 0, sizeof(v50));
      v51 = 0;
      *a7 = 0xFFFF;
      strlen(__s);
      if ((HDLCFrameCreateUplink() & 1) == 0)
        _ETLDebugPrint((uint64_t)"ETLEFS2Get", (uint64_t)"Failed to create command frame\n", v24, v25, v26, v27, v28, v29, v45);
      v30 = calloc(v23, 1uLL);
      if (!v30)
      {
        v32 = 0;
LABEL_29:
        HDLCFrameFree();
        HDLCFrameFree();
        return v32;
      }
      __src = v30;
      if (ETLEFS2CreateGetCommand((uint64_t)v52, a2, a3, __s, v31, v23))
      {
        v48 = a5;
        v32 = (uint64_t)malloc((2 * DWORD2(v52[0]) + 32));
        if (!v32)
        {
LABEL_28:
          free(__src);
          goto LABEL_29;
        }
        v33 = HDLCFrameEncode();
        if (!(_DWORD)v33)
          goto LABEL_26;
        v34 = v33;
        v55 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0)
          ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v32, v33);
        if (*a1)
        {
          v47 = v34;
          v35 = (*a1)(a1, (void *)v32, v34, &v55, 1, a9, 0);
          v46 = v55;
          free((void *)v32);
          v32 = 0;
          if (!v35 || v46 != v47)
            goto LABEL_28;
          LOBYTE(v55) = 75;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          v32 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v50, (uint64_t)&_ETLResponseRingBuffer, &v55, a9)|| v55 != 75)
          {
            goto LABEL_28;
          }
          LOWORD(v55) = -21846;
          if (ETLEFS2ParseGetResponse((int **)v50, a2, __src, v23, &v55, a7, a8, v36))
          {
            if ((unsigned __int16)v55 == (_DWORD)a3 || (_DWORD)a3 + 1 == (unsigned __int16)v55)
            {
              if (*a8 >= a6)
                v44 = a6;
              else
                v44 = *a8;
              *a8 = v44;
              memcpy(v48, __src, v44);
              v32 = 1;
              goto LABEL_28;
            }
            _ETLDebugPrint((uint64_t)"ETLEFS2Get", (uint64_t)"Sequence number out of order, got %u, sent %u\n", v37, v38, v39, v40, v41, v42, (unsigned __int16)v55);
          }
        }
        else
        {
LABEL_26:
          free((void *)v32);
        }
      }
      v32 = 0;
      goto LABEL_28;
    }
    _ETLDebugPrint((uint64_t)"ETLEFS2Get", (uint64_t)"NV file size is ZERO\n", v17, v18, v19, v20, v21, v22, v45);
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2Get", (uint64_t)"Failed to get size of NV item. Error [%d]\n", v17, v18, v19, v20, v21, v22, *a7);
  }
  return 0;
}

uint64_t ETLEFS2GetSize(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), int a2, char *__s, _DWORD *a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t FreeSpace;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  const char *v40;
  uint64_t v41;
  void *v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  _OWORD v50[2];
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  int v55;

  v52 = 0u;
  v53 = 0u;
  v54 = 0;
  memset(v50, 0, sizeof(v50));
  v51 = 0;
  *a5 = 0xFFFF;
  strlen(__s);
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v39 = "ETLEFS2GetSize";
    v40 = "Failed to create command frame\n";
LABEL_12:
    _ETLDebugPrint((uint64_t)v39, (uint64_t)v40, v12, v13, v14, v15, v16, v17, v49);
    goto LABEL_13;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v19, v20, v21, v22, v23, v24, FreeSpace);
    goto LABEL_13;
  }
  LOBYTE(v55) = 75;
  if (a2)
    v25 = 62;
  else
    v25 = 19;
  BYTE1(v55) = v25;
  HIWORD(v55) = 15;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v39 = "ETLSubsysAddHeaderInternal";
    v40 = "Failed to inject\n";
    goto LABEL_12;
  }
  v26 = strlen(__s) + 1;
  if (HDLCFrameGetFreeSpace() >= v26)
  {
    if (HDLCFrameInject())
    {
      v43 = malloc((2 * DWORD2(v52) + 32));
      if (v43)
      {
        v44 = v43;
        v45 = HDLCFrameEncode();
        if (!(_DWORD)v45)
          goto LABEL_29;
        v46 = v45;
        v55 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0)
          ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v44, v45);
        if (*a1)
        {
          v47 = (*a1)(a1, v44, v46, &v55, 1, a6, 0);
          v48 = v55;
          free(v44);
          if (v47 && v48 == (_DWORD)v46)
          {
            LOBYTE(v55) = 75;
            if (!_ETLResponseRingBuffer)
              TelephonyUtilRingBufferInitialize();
            if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v50, (uint64_t)&_ETLResponseRingBuffer, &v55, a6)&& v55 == 75&& ETLEFS2ParseStatResponse((int **)v50, a2, a5, a4, v35, v36, v37, v38))
            {
              _ETLDebugPrint((uint64_t)"ETLEFS2GetSize", (uint64_t)"NV item [%s] is of size [%d]\n", v33, v34, v35, v36, v37, v38, (uint64_t)__s);
              v41 = 1;
              goto LABEL_14;
            }
          }
        }
        else
        {
LABEL_29:
          free(v44);
        }
      }
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v27, v28, v29, v30, v31, v32, v26);
  }
LABEL_13:
  _ETLDebugPrint((uint64_t)"ETLEFS2GetSize", (uint64_t)"Failed to get size of NV item [%s]\n", v33, v34, v35, v36, v37, v38, (uint64_t)__s);
  v41 = 0;
LABEL_14:
  HDLCFrameFree();
  HDLCFrameFree();
  return v41;
}

uint64_t APPLIB_DIAG_AUDIO_PCM_14Bit_Start_Loopback(char *a1, int a2)
{
  int v3;
  __int16 v4;

  v3 = 458315;
  v4 = 1;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_PCM_14Bit_Stop_Loopback(char *a1, int a2)
{
  int v3;
  __int16 v4;

  v3 = 458315;
  v4 = 2;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_PCM_16Bit_Start_Loopback(char *a1, int a2)
{
  int v3;
  __int16 v4;

  v3 = 458315;
  v4 = 3;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_PCM_16Bit_Stop_Loopback(char *a1, int a2)
{
  int v3;
  __int16 v4;

  v3 = 458315;
  v4 = 4;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_I2S_Start_Loopback(char *a1, int a2)
{
  int v3;
  __int16 v4;

  v3 = 458315;
  v4 = 5;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_I2S_Stop_Loopback(char *a1, int a2)
{
  int v3;
  __int16 v4;

  v3 = 458315;
  v4 = 6;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_PCM_I2S_PASSTHROUGH_Start(char *a1, int a2)
{
  int v3;
  __int16 v4;

  v3 = 458315;
  v4 = 7;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_PCM_I2S_PASSTHROUGH_Stop(char *a1, int a2)
{
  int v3;
  __int16 v4;

  v3 = 458315;
  v4 = 8;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_I2S_PCM_PASSTHROUGH_Start(char *a1, int a2)
{
  int v3;
  __int16 v4;

  v3 = 458315;
  v4 = 9;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_I2S_PCM_PASSTHROUGH_Stop(char *a1, int a2)
{
  int v3;
  __int16 v4;

  v3 = 458315;
  v4 = 10;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

BOOL ETLDecompressCheck(unsigned __int8 **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 2) > 6u)
    return **a1 == 155;
  _ETLDebugPrint((uint64_t)"ETLDecompressCheck", (uint64_t)"Error: Given frame size(%u) is less than the decompress header(%u)!\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
  return 0;
}

uint64_t ETLDecompress(uint64_t *a1, char *__dst, unint64_t a3, uint64_t *a4, BOOL *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const char *v9;
  uint64_t v12;
  uint64_t v13;

  *a4 = 0;
  v8 = *a1;
  *a5 = *(_BYTE *)(*a1 + 3) != 0;
  if (*(_BYTE *)(v8 + 4))
  {
    v9 = "Error: ZIP compress type is not supported yet.\n";
LABEL_3:
    _ETLDebugPrint((uint64_t)"ETLDecompress", (uint64_t)v9, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v13);
    return 0;
  }
  v12 = lz4_decode(__dst, a3, (unsigned __int8 *)(v8 + 7), *(unsigned __int16 *)(v8 + 1));
  *a4 = v12;
  if (!v12)
  {
    v9 = "Error: Decoded size is none.\n";
    goto LABEL_3;
  }
  return 1;
}

uint64_t ETLDecompressProcessNonHDLCData(uint64_t a1, unint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;

  if (a2 > 3)
  {
    if (*(_BYTE *)a1 == 126)
    {
      if (*(_BYTE *)(a1 + 1) == 126)
      {
        _ETLDebugPrint((uint64_t)"ETLDecompressProcessNonHDLCData", (uint64_t)"Error: Consecutive data should not contain the flag (0x%x).\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, 126);
        return 0;
      }
      else
      {
        v9 = *(unsigned __int16 *)(a1 + 2);
        *a4 = v9;
        *a3 = a1 + 4;
        *a5 = v9 + 5;
        return 1;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLDecompressProcessNonHDLCData", (uint64_t)"Error: Non HDLC Compressed Data expect start code of (0x%x), but it contains 0x%x.\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, 126);
      return 0;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLDecompressProcessNonHDLCData", (uint64_t)"Error: Given buffer size is less than the size of the header\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v10);
    return 0;
  }
}

uint64_t ETLSubsysAddHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLSubsysParseHeader(uint64_t a1, _WORD *a2, _WORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;

  v8 = *a4;
  v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v10 = *(_DWORD *)(*(_QWORD *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = BYTE1(v10);
      *a3 = HIWORD(v10);
      *a4 = v8 + 4;
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLSubsys2AddHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLSubsys2ParseHeader(uint64_t *a1, _WORD *a2, _WORD *a3, _DWORD *a4, _WORD *a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;

  v8 = *a6;
  v9 = (*((_DWORD *)a1 + 2) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = *(_DWORD *)(*a1 + v8);
    if (v11 == 128)
    {
      *a2 = BYTE1(v11);
      *a3 = HIWORD(v11);
      *a6 = v8 + 4;
      if ((*((_DWORD *)a1 + 2) - (v8 + 4)) <= 5)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsys2ParseHeader", (uint64_t)"Need %u bytes, only have %u\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, 6);
        return 0;
      }
      else
      {
        v12 = v10 + (v8 + 4);
        *a6 = v8 + 10;
        *a4 = *(_DWORD *)v12;
        *a5 = *(_WORD *)(v12 + 4);
        return 1;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v11);
      return 0;
    }
  }
}

uint64_t ETLSubsysFindMatchingResponse(uint64_t a1, unsigned __int8 **a2, unsigned int a3)
{
  uint64_t result;
  char v7;

  v7 = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  LODWORD(result) = ETLFindMatchingResponseUsingBuffer(a1, a2, (uint64_t)&_ETLResponseRingBuffer, &v7, a3);
  if (v7 == 75)
    return result;
  else
    return 0;
}

uint64_t ETLSubsys2FindMatchingResponse(uint64_t a1, unsigned __int8 **a2, unsigned int a3)
{
  uint64_t result;
  unsigned __int8 v7;

  v7 = 0x80;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  LODWORD(result) = ETLFindMatchingResponseUsingBuffer(a1, a2, (uint64_t)&_ETLResponseRingBuffer, &v7, a3);
  if (v7 == 128)
    return result;
  else
    return 0;
}

BOOL ETLHDLCFrameCheckFreeSpace(uint64_t a1, unsigned int a2)
{
  uint64_t FreeSpace;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  FreeSpace = HDLCFrameGetFreeSpace();
  v10 = FreeSpace;
  if (FreeSpace < a2)
    _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckFreeSpace", (uint64_t)"Remaining %u not enough %u\n", v4, v5, v6, v7, v8, v9, FreeSpace);
  return v10 >= a2;
}

BOOL ETLHDLCFrameCheckRemainedSize(uint64_t a1, unsigned int a2, _QWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unsigned int v10;

  v9 = *a4;
  v10 = *(_DWORD *)(a1 + 8) - v9;
  if (v10 < a2)
  {
    _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (*(_DWORD *)(a1 + 8) - v9));
    return v10 >= a2;
  }
  else
  {
    *a3 = *(_QWORD *)a1 + v9;
    *a4 = v9 + a2;
    return v10 >= a2;
  }
}

uint64_t ETLFrameCreateDownlink()
{
  return HDLCFrameCreateDownlink();
}

uint64_t ETLFrameCreateUplink()
{
  return HDLCFrameCreateUplink();
}

uint64_t ETLFrameEncode()
{
  return HDLCFrameEncode();
}

uint64_t ETLFrameEncodeAndCache()
{
  return HDLCFrameEncodeAndCache();
}

uint64_t ETLFrameReadFromTransport(uint64_t a1, uint64_t a2)
{
  char Downlink;

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  while (1)
  {
    while (TelephonyUtilRingBufferGetSize())
    {
      TelephonyUtilRingBufferGetSize();
      Downlink = HDLCFrameCreateDownlink();
      TelephonyUtilRingBufferSkip();
      if ((Downlink & 1) != 0)
        return 1;
    }
    if ((int)TelephonyUtilRingBufferInsertTransport() < 1)
      break;
    TelephonyUtilRingBufferLinearize();
  }
  return 0;
}

uint64_t APPLIB_LOG_DISABLE(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned __int16 v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  char v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char __src;
  char v25[2047];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x10)
  {
    bzero(a1, a2);
    *a1 = 115;
    *((_DWORD *)a1 + 1) = 0;
    v5 = a1[1];
    v6 = crc_16_l_table[v5 ^ 0x9B];
    v7 = a1[2];
    v8 = crc_16_l_table[(v7 ^ v6) ^ 0x4E];
    v9 = a1[3];
    v10 = crc_16_l_table[(v9 ^ v8 ^ HIBYTE(v6))];
    v11 = crc_16_l_table[v10 ^ (v8 >> 8)];
    v12 = crc_16_l_table[v11 ^ (v10 >> 8)];
    v13 = crc_16_l_table[v12 ^ (v11 >> 8)];
    v14 = crc_16_l_table[crc_16_l_table[v12 ^ (v11 >> 8)] ^ (v12 >> 8)];
    v15 = v14 ^ ~(v13 >> 8);
    *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[v12 ^ (v11 >> 8)]);
    if (a2 >= 20)
    {
      bzero(v25, 0x7FFuLL);
      __src = 115;
      if ((v5 - 125) > 1)
      {
        v16 = 1;
      }
      else
      {
        v25[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        v16 = 2;
      }
      v25[v16 - 1] = v5;
      v17 = v16 + 1;
      if ((v7 - 125) <= 1)
      {
        v25[v17 - 1] = 125;
        LODWORD(v17) = v16 + 2;
        LOBYTE(v7) = v7 ^ 0x20;
      }
      v18 = ~(v14 ^ BYTE1(v13));
      v25[v17 - 1] = v7;
      v19 = v17 + 1;
      if ((v9 - 125) <= 1)
      {
        v25[v19 - 1] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v19) = v17 + 2;
      }
      v20 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
      v21 = &v25[v19 - 1];
      *v21 = v9;
      *(_DWORD *)(v21 + 1) = 0;
      v22 = v19 + 5;
      if ((v18 - 125) <= 1)
      {
        v25[v22 - 1] = 125;
        LOBYTE(v18) = v18 ^ 0x20;
        LODWORD(v22) = v19 + 6;
      }
      v25[v22 - 1] = v18;
      v23 = v22 + 1;
      if (BYTE1(v15) - 125 <= 1)
      {
        v25[v23 - 1] = 125;
        v20 = BYTE1(v15) ^ 0x20;
        LODWORD(v23) = v22 + 2;
      }
      v25[v23 - 1] = v20;
      memcpy(a1, &__src, v23 + 1);
      result = (v23 + 2);
      a1[v23 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_FTM_LOG_ENABLE(unsigned __int8 *a1, int a2, __int16 a3, int a4, int a5)
{
  uint64_t result;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned int v25;
  unsigned __int16 v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  int v64;
  int v65;
  uint64_t v66;
  int v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  _BYTE __src[2048];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 592715;
    *((_WORD *)a1 + 5) = a3;
    *((_DWORD *)a1 + 3) = a4;
    *((_DWORD *)a1 + 4) = a5;
    v11 = crc_16_l_table[a1[4] ^ 0x3DLL];
    v12 = crc_16_l_table[a1[5] ^ 0x2B ^ v11];
    v13 = crc_16_l_table[(a1[6] ^ v12 ^ HIBYTE(v11))];
    v14 = crc_16_l_table[(a1[7] ^ v13 ^ HIBYTE(v12))];
    v15 = crc_16_l_table[(a1[8] ^ v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[(a1[9] ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(a3 ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(HIBYTE(a3) ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[(a4 ^ v18 ^ HIBYTE(v17))];
    v20 = crc_16_l_table[(a1[13] ^ v19 ^ HIBYTE(v18))];
    v21 = crc_16_l_table[(a1[14] ^ v20 ^ HIBYTE(v19))];
    v22 = crc_16_l_table[(a1[15] ^ v21 ^ HIBYTE(v20))];
    v23 = crc_16_l_table[(a5 ^ v22 ^ HIBYTE(v21))];
    v24 = crc_16_l_table[(a1[17] ^ v23 ^ HIBYTE(v22))];
    v25 = crc_16_l_table[(a1[18] ^ v24 ^ HIBYTE(v23))];
    v26 = crc_16_l_table[(a1[19] ^ v25 ^ HIBYTE(v24))];
    *((_WORD *)a1 + 10) = v26 ^ ~HIBYTE(crc_16_l_table[(a1[18] ^ v24 ^ HIBYTE(v23))]);
    if (a2 >= 44)
    {
      bzero(__src, 0x800uLL);
      v27 = *a1;
      if ((v27 - 125) > 1)
      {
        v28 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v27) = v27 ^ 0x20;
        v28 = 1;
      }
      __src[v28] = v27;
      v29 = v28 + 1;
      v30 = a1[1];
      if ((v30 - 125) <= 1)
      {
        __src[v29] = 125;
        LODWORD(v29) = v28 | 2;
        LOBYTE(v30) = v30 ^ 0x20;
      }
      __src[v29] = v30;
      v31 = v29 + 1;
      v32 = a1[2];
      if ((v32 - 125) <= 1)
      {
        __src[v31] = 125;
        LOBYTE(v32) = v32 ^ 0x20;
        LODWORD(v31) = v29 + 2;
      }
      __src[v31] = v32;
      v33 = v31 + 1;
      v34 = a1[3];
      if ((v34 - 125) <= 1)
      {
        __src[v33] = 125;
        LODWORD(v33) = v31 + 2;
        LOBYTE(v34) = v34 ^ 0x20;
      }
      __src[v33] = v34;
      v35 = v33 + 1;
      v36 = a1[4];
      if ((v36 - 125) <= 1)
      {
        __src[v35] = 125;
        LOBYTE(v36) = v36 ^ 0x20;
        LODWORD(v35) = v33 + 2;
      }
      __src[v35] = v36;
      v37 = v35 + 1;
      v38 = a1[5];
      if ((v38 - 125) <= 1)
      {
        __src[v37] = 125;
        LODWORD(v37) = v35 + 2;
        LOBYTE(v38) = v38 ^ 0x20;
      }
      __src[v37] = v38;
      v39 = v37 + 1;
      v40 = a1[6];
      if ((v40 - 125) <= 1)
      {
        __src[v39] = 125;
        LOBYTE(v40) = v40 ^ 0x20;
        LODWORD(v39) = v37 + 2;
      }
      __src[v39] = v40;
      v41 = v39 + 1;
      v42 = a1[7];
      if ((v42 - 125) <= 1)
      {
        __src[v41] = 125;
        LODWORD(v41) = v39 + 2;
        LOBYTE(v42) = v42 ^ 0x20;
      }
      __src[v41] = v42;
      v43 = v41 + 1;
      v44 = a1[8];
      if ((v44 - 125) <= 1)
      {
        __src[v43] = 125;
        LOBYTE(v44) = v44 ^ 0x20;
        LODWORD(v43) = v41 + 2;
      }
      __src[v43] = v44;
      v45 = v43 + 1;
      v46 = a1[9];
      if ((v46 - 125) <= 1)
      {
        __src[v45] = 125;
        LODWORD(v45) = v43 + 2;
        LOBYTE(v46) = v46 ^ 0x20;
      }
      __src[v45] = v46;
      v47 = v45 + 1;
      v48 = a1[10];
      if ((v48 - 125) <= 1)
      {
        __src[v47] = 125;
        LOBYTE(v48) = v48 ^ 0x20;
        LODWORD(v47) = v45 + 2;
      }
      __src[v47] = v48;
      v49 = v47 + 1;
      v50 = a1[11];
      if ((v50 - 125) <= 1)
      {
        __src[v49] = 125;
        LODWORD(v49) = v47 + 2;
        LOBYTE(v50) = v50 ^ 0x20;
      }
      __src[v49] = v50;
      v51 = v49 + 1;
      v52 = a1[12];
      if ((v52 - 125) <= 1)
      {
        __src[v51] = 125;
        LOBYTE(v52) = v52 ^ 0x20;
        LODWORD(v51) = v49 + 2;
      }
      __src[v51] = v52;
      v53 = v51 + 1;
      v54 = a1[13];
      if ((v54 - 125) <= 1)
      {
        __src[v53] = 125;
        LODWORD(v53) = v51 + 2;
        LOBYTE(v54) = v54 ^ 0x20;
      }
      __src[v53] = v54;
      v55 = v53 + 1;
      v56 = a1[14];
      if ((v56 - 125) <= 1)
      {
        __src[v55] = 125;
        LOBYTE(v56) = v56 ^ 0x20;
        LODWORD(v55) = v53 + 2;
      }
      __src[v55] = v56;
      v57 = v55 + 1;
      v58 = a1[15];
      if ((v58 - 125) <= 1)
      {
        __src[v57] = 125;
        LODWORD(v57) = v55 + 2;
        LOBYTE(v58) = v58 ^ 0x20;
      }
      __src[v57] = v58;
      v59 = v57 + 1;
      v60 = a1[16];
      if ((v60 - 125) <= 1)
      {
        __src[v59] = 125;
        LOBYTE(v60) = v60 ^ 0x20;
        LODWORD(v59) = v57 + 2;
      }
      __src[v59] = v60;
      v61 = v59 + 1;
      v62 = a1[17];
      if ((v62 - 125) <= 1)
      {
        __src[v61] = 125;
        LODWORD(v61) = v59 + 2;
        LOBYTE(v62) = v62 ^ 0x20;
      }
      __src[v61] = v62;
      v63 = v61 + 1;
      v64 = a1[18];
      if ((v64 - 125) <= 1)
      {
        __src[v63] = 125;
        LOBYTE(v64) = v64 ^ 0x20;
        LODWORD(v63) = v61 + 2;
      }
      v65 = ~(v26 ^ BYTE1(v25));
      __src[v63] = v64;
      v66 = v63 + 1;
      v67 = a1[19];
      if ((v67 - 125) <= 1)
      {
        __src[v66] = 125;
        LOBYTE(v67) = v67 ^ 0x20;
        LODWORD(v66) = v63 + 2;
      }
      v68 = ((unsigned __int16)(v26 ^ ~(unsigned __int16)(v25 >> 8)) >> 8);
      __src[v66] = v67;
      v69 = v66 + 1;
      if ((v65 - 125) <= 1)
      {
        __src[v69] = 125;
        LOBYTE(v65) = v65 ^ 0x20;
        LODWORD(v69) = v66 + 2;
      }
      __src[v69] = v65;
      v70 = v69 + 1;
      if ((v68 - 125) <= 1)
      {
        __src[v70] = 125;
        LOBYTE(v68) = v68 ^ 0x20;
        LODWORD(v70) = v69 + 2;
      }
      __src[v70] = v68;
      memcpy(a1, __src, v70 + 1);
      result = (v70 + 2);
      a1[v70 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_FTM_LOG_DISABLE(unsigned __int8 *a1, int a2, __int16 a3)
{
  uint64_t result;
  char v7;
  uint64_t v8;
  unsigned __int16 v9;
  int v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  char v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  int __src;
  char v34;
  _BYTE v35[2043];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x1F)
    return result;
  bzero(a1, a2);
  *(_DWORD *)a1 = 592715;
  a1[4] = 1;
  *((_WORD *)a1 + 5) = a3;
  v7 = HIBYTE(a3);
  v8 = a1[5];
  v9 = crc_16_l_table[v8 ^ 0xC4];
  v10 = a1[6];
  v11 = crc_16_l_table[(v10 ^ v9) ^ 0xFB];
  v12 = crc_16_l_table[(a1[7] ^ v11 ^ HIBYTE(v9))];
  v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
  v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
  v15 = crc_16_l_table[(a3 ^ v14 ^ HIBYTE(v13))];
  v16 = crc_16_l_table[HIBYTE(a3) ^ crc_16_l_table[(a3 ^ v14 ^ HIBYTE(v13))] ^ (v14 >> 8)];
  v17 = v16 ^ ~(v15 >> 8);
  *((_WORD *)a1 + 6) = v16 ^ ~HIBYTE(crc_16_l_table[(a3 ^ v14 ^ HIBYTE(v13))]);
  if (a2 < 28)
    return 0xFFFFFFFFLL;
  bzero(v35, 0x7FBuLL);
  __src = 592715;
  v34 = 1;
  if ((v8 - 125) <= 1)
  {
    v35[0] = 125;
    v18 = 6;
    v35[1] = v8 ^ 0x20;
    v19 = 7;
    if ((v10 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v18 = 5;
  v35[0] = v8;
  v19 = 6;
  if ((v10 - 125) <= 1)
  {
LABEL_9:
    *((_BYTE *)&__src + v19) = 125;
    LODWORD(v19) = v18 + 2;
    LOBYTE(v10) = v10 ^ 0x20;
  }
LABEL_10:
  *((_BYTE *)&__src + v19) = v10;
  v20 = v19 + 1;
  v21 = a1[7];
  if ((v21 - 125) <= 1)
  {
    *((_BYTE *)&__src + v20) = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v20) = v19 + 2;
  }
  *((_BYTE *)&__src + v20) = v21;
  v22 = v20 + 1;
  v23 = a1[8];
  if ((v23 - 125) <= 1)
  {
    *((_BYTE *)&__src + v22) = 125;
    LOBYTE(v23) = v23 ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  v24 = a3;
  *((_BYTE *)&__src + v22) = v23;
  v25 = v22 + 1;
  v26 = a1[9];
  if ((v26 - 125) <= 1)
  {
    *((_BYTE *)&__src + v25) = 125;
    LOBYTE(v26) = v26 ^ 0x20;
    LODWORD(v25) = v22 + 2;
  }
  *((_BYTE *)&__src + v25) = v26;
  v27 = v25 + 1;
  if (a3 - 125 <= 1)
  {
    *((_BYTE *)&__src + v27) = 125;
    v24 = a3 ^ 0x20;
    LODWORD(v27) = v25 + 2;
  }
  v28 = ~(v16 ^ BYTE1(v15));
  *((_BYTE *)&__src + v27) = v24;
  v29 = v27 + 1;
  if (HIBYTE(a3) - 125 <= 1)
  {
    *((_BYTE *)&__src + v29) = 125;
    v7 = HIBYTE(a3) ^ 0x20;
    LODWORD(v29) = v27 + 2;
  }
  v30 = (unsigned __int16)(v16 ^ ~(unsigned __int16)(v15 >> 8)) >> 8;
  *((_BYTE *)&__src + v29) = v7;
  v31 = v29 + 1;
  if ((v28 - 125) <= 1)
  {
    *((_BYTE *)&__src + v31) = 125;
    LOBYTE(v28) = v28 ^ 0x20;
    LODWORD(v31) = v29 + 2;
  }
  *((_BYTE *)&__src + v31) = v28;
  v32 = v31 + 1;
  if (BYTE1(v17) - 125 <= 1)
  {
    *((_BYTE *)&__src + v32) = 125;
    v30 = BYTE1(v17) ^ 0x20;
    LODWORD(v32) = v31 + 2;
  }
  *((_BYTE *)&__src + v32) = v30;
  memcpy(a1, &__src, v32 + 1);
  result = (v32 + 2);
  a1[v32 + 1] = 126;
  return result;
}

uint64_t APPLIB_LOG_GetIds(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned __int16 v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  char v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char __src;
  char v25[2047];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x10)
  {
    bzero(a1, a2);
    *a1 = 115;
    *((_DWORD *)a1 + 1) = 1;
    v5 = a1[1];
    v6 = crc_16_l_table[v5 ^ 0x9B];
    v7 = a1[2];
    v8 = crc_16_l_table[(v7 ^ v6) ^ 0x4E];
    v9 = a1[3];
    v10 = crc_16_l_table[(v9 ^ v8 ^ HIBYTE(v6))];
    v11 = crc_16_l_table[v10 ^ (v8 >> 8) ^ 1];
    v12 = crc_16_l_table[v11 ^ (v10 >> 8)];
    v13 = crc_16_l_table[v12 ^ (v11 >> 8)];
    v14 = crc_16_l_table[crc_16_l_table[v12 ^ (v11 >> 8)] ^ (v12 >> 8)];
    v15 = v14 ^ ~(v13 >> 8);
    *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[v12 ^ (v11 >> 8)]);
    if (a2 >= 20)
    {
      bzero(v25, 0x7FFuLL);
      __src = 115;
      if ((v5 - 125) > 1)
      {
        v16 = 1;
      }
      else
      {
        v25[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        v16 = 2;
      }
      v25[v16 - 1] = v5;
      v17 = v16 + 1;
      if ((v7 - 125) <= 1)
      {
        v25[v17 - 1] = 125;
        LODWORD(v17) = v16 + 2;
        LOBYTE(v7) = v7 ^ 0x20;
      }
      v18 = ~(v14 ^ BYTE1(v13));
      v25[v17 - 1] = v7;
      v19 = v17 + 1;
      if ((v9 - 125) <= 1)
      {
        v25[v19 - 1] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v19) = v17 + 2;
      }
      v20 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
      v21 = &v25[v19 - 1];
      *v21 = v9;
      *(_DWORD *)(v21 + 1) = 1;
      v22 = v19 + 5;
      if ((v18 - 125) <= 1)
      {
        v25[v22 - 1] = 125;
        LOBYTE(v18) = v18 ^ 0x20;
        LODWORD(v22) = v19 + 6;
      }
      v25[v22 - 1] = v18;
      v23 = v22 + 1;
      if (BYTE1(v15) - 125 <= 1)
      {
        v25[v23 - 1] = 125;
        v20 = BYTE1(v15) ^ 0x20;
        LODWORD(v23) = v22 + 2;
      }
      v25[v23 - 1] = v20;
      memcpy(a1, &__src, v23 + 1);
      result = (v23 + 2);
      a1[v23 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_LOG_GetMasks(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned __int16 v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  char v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char __src;
  char v25[2047];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x10)
  {
    bzero(a1, a2);
    *a1 = 115;
    *((_DWORD *)a1 + 1) = 4;
    v5 = a1[1];
    v6 = crc_16_l_table[v5 ^ 0x9B];
    v7 = a1[2];
    v8 = crc_16_l_table[(v7 ^ v6) ^ 0x4E];
    v9 = a1[3];
    v10 = crc_16_l_table[(v9 ^ v8 ^ HIBYTE(v6))];
    v11 = crc_16_l_table[v10 ^ (v8 >> 8) ^ 4];
    v12 = crc_16_l_table[v11 ^ (v10 >> 8)];
    v13 = crc_16_l_table[v12 ^ (v11 >> 8)];
    v14 = crc_16_l_table[crc_16_l_table[v12 ^ (v11 >> 8)] ^ (v12 >> 8)];
    v15 = v14 ^ ~(v13 >> 8);
    *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[v12 ^ (v11 >> 8)]);
    if (a2 >= 20)
    {
      bzero(v25, 0x7FFuLL);
      __src = 115;
      if ((v5 - 125) > 1)
      {
        v16 = 1;
      }
      else
      {
        v25[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        v16 = 2;
      }
      v25[v16 - 1] = v5;
      v17 = v16 + 1;
      if ((v7 - 125) <= 1)
      {
        v25[v17 - 1] = 125;
        LODWORD(v17) = v16 + 2;
        LOBYTE(v7) = v7 ^ 0x20;
      }
      v18 = ~(v14 ^ BYTE1(v13));
      v25[v17 - 1] = v7;
      v19 = v17 + 1;
      if ((v9 - 125) <= 1)
      {
        v25[v19 - 1] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v19) = v17 + 2;
      }
      v20 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
      v21 = &v25[v19 - 1];
      *v21 = v9;
      *(_DWORD *)(v21 + 1) = 4;
      v22 = v19 + 5;
      if ((v18 - 125) <= 1)
      {
        v25[v22 - 1] = 125;
        LOBYTE(v18) = v18 ^ 0x20;
        LODWORD(v22) = v19 + 6;
      }
      v25[v22 - 1] = v18;
      v23 = v22 + 1;
      if (BYTE1(v15) - 125 <= 1)
      {
        v25[v23 - 1] = 125;
        v20 = BYTE1(v15) ^ 0x20;
        LODWORD(v23) = v22 + 2;
      }
      v25[v23 - 1] = v20;
      memcpy(a1, &__src, v23 + 1);
      result = (v23 + 2);
      a1[v23 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_LOG_SetMasks(char *a1, int a2, unsigned int a3, unint64_t a4)
{
  uint64_t result;
  int v9;
  int v10;
  char *v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  int v17;
  int v18;
  _BYTE __src[2048];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x10)
  {
    bzero(a1, a2);
    *a1 = 115;
    *((_DWORD *)a1 + 1) = 3;
    *((_DWORD *)a1 + 2) = a4 >> 12;
    *((_DWORD *)a1 + 3) = a3;
    if (a3 >= 8)
    {
      v13 = a3 >> 3;
      v14 = (a4 >> 3) & 0x1FF;
      do
      {
        if (!v14)
          a1[((a4 >> 3) & 0x1FF) + 16] = 1 << (a4 & 7);
        --v14;
        --v13;
      }
      while (v13);
    }
    v9 = 1336;
    LOWORD(v10) = -1;
    v11 = a1;
    do
    {
      v12 = *v11++;
      v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
      v9 -= 8;
    }
    while ((_WORD)v9);
    *(_WORD *)(a1 + 167) = ~(_WORD)v10;
    if (a2 >= 338)
    {
      bzero(__src, 0x800uLL);
      v15 = 0;
      LODWORD(v16) = 0;
      do
      {
        while (1)
        {
          v18 = a1[v15];
          if ((v18 - 125) > 1)
            break;
          v17 = v16 + 1;
          __src[(int)v16] = 125;
          __src[(int)v16 + 1] = v18 ^ 0x20;
          v16 = (int)v16 + 1 + 1;
          if (++v15 == 169)
            goto LABEL_16;
        }
        v17 = v16;
        __src[(int)v16] = v18;
        v16 = (int)v16 + 1;
        ++v15;
      }
      while (v15 != 169);
LABEL_16:
      memcpy(a1, __src, v16);
      result = (v17 + 2);
      a1[v16] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_LOG_SetMultipleLogMasks(unsigned __int8 *a1, int a2, int a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  char *v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  size_t v27;
  int v28;
  int v29;
  _BYTE __src[2048];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x10)
  {
    bzero(a1, a2);
    *a1 = 115;
    *((_DWORD *)a1 + 1) = 3;
    *((_DWORD *)a1 + 2) = a3;
    *((_DWORD *)a1 + 3) = a4;
    LODWORD(v13) = a4 >> 3;
    if ((a4 & 7) != 0)
      v13 = (v13 + 1);
    else
      v13 = v13;
    if (a5 && (_DWORD)v13)
    {
      v14 = 0;
      do
      {
        v15 = *(unsigned __int16 *)(a6 + 2 * v14);
        v16 = (v15 >> 3) & 0x1FF;
        v17 = 1 << (v15 & 7);
        v18 = v16;
        v19 = v13;
        do
        {
          if (!v18)
            a1[v16 + 16] |= v17;
          --v18;
          --v19;
        }
        while (v19);
        ++v14;
      }
      while (v14 != a5);
    }
    v20 = v13 + 16;
    v21 = 8 * (v13 + 16);
    if (8 * ((_WORD)v13 + 16))
    {
      LOWORD(v22) = -1;
      v23 = (char *)a1;
      do
      {
        v24 = *v23++;
        v22 = crc_16_l_table[(v24 ^ v22)] ^ ((unsigned __int16)(v22 & 0xFF00) >> 8);
        v21 -= 8;
      }
      while ((_WORD)v21);
      a1[v20] = ~(_BYTE)v22;
      a1[v13 + 17] = (unsigned __int16)~(_WORD)v22 >> 8;
      result = 0xFFFFFFFFLL;
      if (v13 > 0x3EE)
        return result;
    }
    else
    {
      a1[v20] = 0;
      a1[v13 + 17] = 0;
      result = 0xFFFFFFFFLL;
      if (v13 > 0x3EE)
        return result;
    }
    v25 = (v13 + 18);
    if (2 * (int)v25 <= a2)
    {
      bzero(__src, 0x800uLL);
      v26 = 0;
      LODWORD(v27) = 0;
      do
      {
        while (1)
        {
          v29 = a1[v26];
          if ((v29 - 125) > 1)
            break;
          v28 = v27 + 1;
          __src[(int)v27] = 125;
          __src[(int)v27 + 1] = v29 ^ 0x20;
          v27 = (int)v27 + 1 + 1;
          if (v25 == ++v26)
            goto LABEL_25;
        }
        v28 = v27;
        __src[(int)v27] = v29;
        v27 = (int)v27 + 1;
        ++v26;
      }
      while (v25 != v26);
LABEL_25:
      memcpy(a1, __src, v27);
      result = (v28 + 2);
      a1[v27] = 126;
    }
  }
  return result;
}

uint64_t APPLIB_ParseRDALog(uint64_t a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;

  if ((*(_WORD *)(a1 + 16) & 0x1C0) != 0)
    v1 = (((*(_WORD *)(a1 + 16) & 0x38) != 0) | (4 * ((*(_WORD *)(a1 + 16) & 7) != 0))) + 1;
  else
    v1 = ((*(_WORD *)(a1 + 16) & 0x38) != 0) | (4 * ((*(_WORD *)(a1 + 16) & 7) != 0));
  v2 = *(unsigned __int8 *)(a1 + 19);
  if (v1 > v2 || (*(_BYTE *)(a1 + 18) & 2) == 0)
    return 0;
  v3 = v2 / v1;
  if (v3 <= 1)
    v3 = 1;
  v4 = 0;
  v5 = 0;
  if ((*(_BYTE *)(a1 + 18) & 8) != 0)
  {
    if ((*(_BYTE *)(a1 + 18) & 4) != 0)
    {
      v11 = a1 + 20;
      do
      {
        v12 = *(char *)(v11 + 10);
        if (v12 <= 4)
        {
          v4 += dword_1DAD14F50[v12];
          v5 += *(unsigned __int16 *)(v11 + qword_1DAD14F28[v12]);
        }
        v11 += 98;
        --v3;
      }
      while (v3);
    }
    else
    {
      v9 = a1 + 20;
      do
      {
        v10 = *(char *)(v9 + 10);
        if (v10 <= 4)
        {
          v4 += dword_1DAD14F50[v10];
          v5 += *(unsigned __int16 *)(v9 + qword_1DAD14F28[v10]);
        }
        v9 += 72;
        --v3;
      }
      while (v3);
    }
  }
  else
  {
    v6 = 74;
    if ((*(_BYTE *)(a1 + 18) & 4) == 0)
      v6 = 48;
    v7 = a1 + 20;
    do
    {
      v8 = *(char *)(v7 + 10);
      if (v8 <= 4)
      {
        v4 += dword_1DAD14F50[v8];
        v5 += *(unsigned __int16 *)(v7 + qword_1DAD14F28[v8]);
      }
      v7 += v6;
      --v3;
    }
    while (v3);
  }
  if (v4)
    return v5 / v4;
  else
    return 0;
}

uint64_t ETLFusingCreateReadFuseCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v15;
  const char *v16;
  uint64_t v17;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    v15 = "ETLSubsysAddHeaderInternal";
    v16 = "Failed to inject\n";
LABEL_10:
    _ETLDebugPrint((uint64_t)v15, (uint64_t)v16, v7, v8, v9, v10, v11, v12, v17);
    return 0;
  }
  v13 = HDLCFrameGetFreeSpace();
  if (v13 <= 7)
  {
    v17 = v13;
    v15 = "ETLFusingCreateFusingCommand";
    v16 = "Remaining %u not enough %u\n";
    goto LABEL_10;
  }
  if (HDLCFrameInjectUnsignedShort() && HDLCFrameInjectUnsignedShort())
    return HDLCFrameInjectUnsignedInt();
  return 0;
}

uint64_t ETLFusingCreateWriteFuseCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v15;
  const char *v16;
  uint64_t v17;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    v15 = "ETLSubsysAddHeaderInternal";
    v16 = "Failed to inject\n";
LABEL_10:
    _ETLDebugPrint((uint64_t)v15, (uint64_t)v16, v7, v8, v9, v10, v11, v12, v17);
    return 0;
  }
  v13 = HDLCFrameGetFreeSpace();
  if (v13 <= 7)
  {
    v17 = v13;
    v15 = "ETLFusingCreateFusingCommand";
    v16 = "Remaining %u not enough %u\n";
    goto LABEL_10;
  }
  if (HDLCFrameInjectUnsignedShort() && HDLCFrameInjectUnsignedShort())
    return HDLCFrameInjectUnsignedInt();
  return 0;
}

uint64_t ETLFusingParseReadFuseResponse(int **a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    v10 = *a1;
    v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        v12 = HIWORD(v11);
        if ((_DWORD)v12 == 11)
        {
          if (v9 <= 5)
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else
          {
            v13 = *((unsigned __int16 *)v10 + 2);
            *a3 = *(_DWORD *)((char *)v10 + 6);
            if ((_DWORD)v13 == 1)
            {
              return 1;
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v13);
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLFusingParseWriteFuseResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;

  v8 = a1[2];
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        v11 = HIWORD(v10);
        if ((_DWORD)v11 == 11)
        {
          if (v9 <= 5)
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*(_WORD *)(*(_QWORD *)a1 + 4) == 1)
          {
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(_QWORD *)a1 + 4));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLFusingProgramFuse(_QWORD *a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v33;
  int v34;

  v12 = *a3;
  _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Programming fuse %u, value %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, a2);
  if ((_DWORD)a4 == 4)
  {
    v33 = -1431655766;
    if ((ETLFusingPerformFusingOperation(a1, a2, 0, 0, &v33, a5) & 1) != 0)
    {
      v25 = v33;
      _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Read back fuse %u, value %u\n", v19, v20, v21, v22, v23, v24, a2);
      if ((v25 | v12) == (_DWORD)v12)
      {
        _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Programming fuse %u, final write value %u\n", v26, v27, v28, v29, v30, v31, a2);
        return ETLFusingPerformFusingOperation(a1, a2, 1, v12 & ~v25, &v34, a5);
      }
      _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Mismatch, expected to be written %u, final value on device will be %u\n", v26, v27, v28, v29, v30, v31, v12);
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Failed to read the fuse %u\n", v19, v20, v21, v22, v23, v24, a2);
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Data length %u is not %zu\n", v13, v14, v15, v16, v17, v18, a4);
  }
  return 0;
}

uint64_t ETLFusingPerformFusingOperation(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t FreeSpace;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned __int16 *v43;
  uint64_t v44;
  uint64_t v46;
  _OWORD v47[2];
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  unsigned int v52;

  v49 = 0u;
  v50 = 0u;
  v51 = 0;
  memset(v47, 0, sizeof(v47));
  v48 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v25 = "ETLFusingPerformFusingOperation";
    v26 = "Faild to create uplink frame\n";
LABEL_39:
    _ETLDebugPrint((uint64_t)v25, (uint64_t)v26, v10, v11, v12, v13, v14, v15, v46);
    goto LABEL_40;
  }
  if (a3 != 1)
  {
    if (a3)
      goto LABEL_18;
    FreeSpace = HDLCFrameGetFreeSpace();
    if (FreeSpace >= 4)
    {
      v52 = 785739;
      if ((HDLCFrameInject() & 1) != 0)
      {
        v23 = HDLCFrameGetFreeSpace();
        if (v23 > 7)
        {
          if (HDLCFrameInjectUnsignedShort())
          {
            v24 = 0;
            if (!HDLCFrameInjectUnsignedShort())
              goto LABEL_41;
            v24 = 0;
            if ((HDLCFrameInjectUnsignedInt() & 1) == 0)
              goto LABEL_41;
            goto LABEL_18;
          }
LABEL_40:
          v24 = 0;
          goto LABEL_41;
        }
        goto LABEL_38;
      }
      goto LABEL_36;
    }
LABEL_35:
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
    goto LABEL_40;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
    goto LABEL_35;
  v52 = 785739;
  if ((HDLCFrameInject() & 1) == 0)
  {
LABEL_36:
    v25 = "ETLSubsysAddHeaderInternal";
    v26 = "Failed to inject\n";
    goto LABEL_39;
  }
  v23 = HDLCFrameGetFreeSpace();
  if (v23 <= 7)
  {
LABEL_38:
    v46 = v23;
    v25 = "ETLFusingCreateFusingCommand";
    v26 = "Remaining %u not enough %u\n";
    goto LABEL_39;
  }
  if (!HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedInt())
  {
    goto LABEL_40;
  }
LABEL_18:
  v24 = (uint64_t)malloc((2 * DWORD2(v49) + 32));
  if (!v24)
    goto LABEL_41;
  v27 = HDLCFrameEncode();
  if (!(_DWORD)v27)
    goto LABEL_37;
  v28 = v27;
  v52 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v24, v27);
  if (!*a1)
  {
LABEL_37:
    free((void *)v24);
    goto LABEL_40;
  }
  v29 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v24, v28, &v52, 1, a6, 0);
  v30 = v52;
  free((void *)v24);
  v24 = 0;
  if (v29 && v30 == (_DWORD)v28)
  {
    LOBYTE(v52) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v24 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v47, (uint64_t)&_ETLResponseRingBuffer, &v52, a6))
    {
      if (v52 == 75)
      {
        if (a3 == 1)
        {
          v52 = 0;
          v24 = 0;
          if (!ETLMaverickParseBSPResponseHeader((uint64_t)v47, &v52, 11, v31, v32, v33, v34, v35))
            goto LABEL_41;
          v42 = DWORD2(v47[0]) - v52;
          if (v42 > 5)
          {
            v44 = *(unsigned __int16 *)(*(_QWORD *)&v47[0] + v52);
            if ((_DWORD)v44 == 1)
              goto LABEL_34;
LABEL_45:
            _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", v36, v37, v38, v39, v40, v41, v44);
            goto LABEL_40;
          }
        }
        else
        {
          if (a3)
          {
LABEL_34:
            v24 = 1;
            goto LABEL_41;
          }
          v52 = 0;
          v24 = 0;
          if (!ETLMaverickParseBSPResponseHeader((uint64_t)v47, &v52, 11, v31, v32, v33, v34, v35))
            goto LABEL_41;
          v42 = DWORD2(v47[0]) - v52;
          if (v42 > 5)
          {
            v43 = (unsigned __int16 *)(*(_QWORD *)&v47[0] + v52);
            v44 = *v43;
            *a5 = *(_DWORD *)(v43 + 1);
            if ((_DWORD)v44 == 1)
              goto LABEL_34;
            goto LABEL_45;
          }
        }
        _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", v36, v37, v38, v39, v40, v41, v42);
        goto LABEL_40;
      }
    }
  }
LABEL_41:
  HDLCFrameFree();
  HDLCFrameFree();
  return v24;
}

uint64_t ETLFusingReadFuse(_QWORD *a1, uint64_t a2, int *a3, uint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;

  *a5 = 0;
  if (a4 > 3)
  {
    v19 = -1431655766;
    v18 = ETLFusingPerformFusingOperation(a1, a2, 0, 0, &v19, a6);
    result = 0;
    if (v18)
    {
      *a5 = 4;
      *a3 = v19;
      _ETLDebugPrint((uint64_t)"ETLFusingReadFuse", (uint64_t)"Read back fuse %u, value %u\n", v12, v13, v14, v15, v16, v17, a2);
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFusingReadFuse", (uint64_t)"Data capacity %u less than reequired %zu\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, a4);
    return 0;
  }
  return result;
}

uint64_t ETLFusingProgramTriggerM20(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _WORD *v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t result;
  const char *v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  _OWORD v46[2];
  uint64_t v47;
  _OWORD v48[2];
  uint64_t v49;
  int v50;
  unsigned int v51;

  if (!a1 || !a2)
  {
    _ETLDebugPrint((uint64_t)"ETLFusingProgramTriggerM20", (uint64_t)"Transport (%p) and Status (%p) should not be NULL \n", a3, a4, a5, a6, a7, a8, (uint64_t)a1);
    return 0;
  }
  memset(v48, 0, sizeof(v48));
  v49 = 0;
  memset(v46, 0, sizeof(v46));
  v47 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v42 = "ETLFusingProgramTriggerM20";
    v43 = "Faild to create uplink frame\n";
LABEL_24:
    _ETLDebugPrint((uint64_t)v42, (uint64_t)v43, v11, v12, v13, v14, v15, v16, v45);
    goto LABEL_25;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
LABEL_25:
    v25 = 0;
LABEL_26:
    HDLCFrameFree();
    HDLCFrameFree();
    return v25;
  }
  v51 = 1575755;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v42 = "ETLSubsysAddHeaderInternal";
    v43 = "Failed to inject\n";
    goto LABEL_24;
  }
  v24 = HDLCFrameGetFreeSpace();
  if (v24 <= 7)
  {
    v45 = v24;
    v42 = "ETLHDLCFrameCheckFreeSpace";
    v43 = "Remaining %u not enough %u\n";
    goto LABEL_24;
  }
  if (!HDLCFrameInjectUnsignedShort())
    goto LABEL_25;
  v25 = 0;
  if (!HDLCFrameInjectUnsignedShort())
    goto LABEL_26;
  v25 = 0;
  if (!HDLCFrameInjectUnsignedShort())
    goto LABEL_26;
  v25 = 0;
  if (!HDLCFrameInjectUnsignedShort())
    goto LABEL_26;
  if (!ETLSendCommand(a1, (uint64_t)v48, a3)
    || !ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v46, a3))
  {
    goto LABEL_25;
  }
  v50 = 0;
  v51 = 0;
  ETLSubsysParseHeader((uint64_t)v46, (_WORD *)&v50 + 1, &v50, &v51, v26, v27, v28, v29);
  if (HIWORD(v50) != 11)
  {
    _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponseM20", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, HIWORD(v50));
    v36 = (unsigned __int16)v50;
    goto LABEL_34;
  }
  v36 = (unsigned __int16)v50;
  if ((unsigned __int16)v50 != 24)
  {
LABEL_34:
    _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponseM20", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, v36);
    __break(1u);
    goto LABEL_35;
  }
  v37 = DWORD2(v46[0]) - v51;
  if (v37 > 7)
  {
    v38 = (_WORD *)(*(_QWORD *)&v46[0] + v51);
    if (*v38 == 3)
    {
      v39 = DWORD2(v46[0]) - (v51 + 8);
      if (v39 > 3)
      {
        v38 = (_WORD *)(*(_QWORD *)&v46[0] + v51 + 8);
        v40 = 1;
        goto LABEL_30;
      }
      _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", v30, v31, v32, v33, v34, v35, v39);
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponseM20", (uint64_t)"Received Secboot provisioning trigger code 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, *(unsigned __int16 *)(*(_QWORD *)&v46[0] + v51));
    }
    v40 = 0;
LABEL_30:
    v44 = *(unsigned int *)v38;
    *a2 = v44;
    if ((_DWORD)v44)
    {
      _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponseM20", (uint64_t)"Received status 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, v44);
      v25 = 0;
    }
    else
    {
      v25 = v40;
    }
    goto LABEL_26;
  }
LABEL_35:
  result = _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", v30, v31, v32, v33, v34, v35, v37);
  __break(1u);
  return result;
}

unint64_t ETLFusingGetFusedData(capabilities::radio *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeSpace;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  const char *v40;
  uint64_t v42;
  _OWORD v43[2];
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  int v48;

  if (a1 && a2)
  {
    capabilities::radio::mav20Plus(a1);
    v45 = 0u;
    v46 = 0u;
    v47 = 0;
    memset(v43, 0, sizeof(v43));
    v44 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
LABEL_35:
        v24 = 0;
        goto LABEL_36;
      }
      v48 = 8781131;
      if ((HDLCFrameInject() & 1) != 0)
      {
        v24 = (unint64_t)malloc((2 * DWORD2(v45) + 32));
        if (!v24)
          goto LABEL_36;
        v25 = HDLCFrameEncode();
        if (!(_DWORD)v25)
          goto LABEL_38;
        v26 = v25;
        v48 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0)
          ((void (*)(const char *, _QWORD, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v24, v25);
        if (!*(_QWORD *)a1)
        {
LABEL_38:
          free((void *)v24);
          goto LABEL_35;
        }
        v27 = (*(uint64_t (**)(capabilities::radio *, unint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))a1)(a1, v24, v26, &v48, 1, a3, 0);
        v28 = v48;
        free((void *)v24);
        v24 = 0;
        if (!v27 || v28 != (_DWORD)v26)
          goto LABEL_36;
        LOBYTE(v48) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v24 = 0;
        if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v43, (uint64_t)&_ETLResponseRingBuffer, &v48, a3)|| v48 != 75)
        {
          goto LABEL_36;
        }
        v29 = (DWORD2(v43[0]) - 4);
        if (DWORD2(v43[0]) < 4)
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v11, v12, v13, v14, v15, v16, DWORD2(v43[0]));
        }
        else
        {
          v30 = **(_DWORD **)&v43[0];
          if (**(_DWORD **)&v43[0] == 75)
          {
            v31 = BYTE1(v30);
            if (BYTE1(v30) == 253)
            {
              if (HIWORD(v30) != 133)
              {
                _ETLDebugPrint((uint64_t)"ETLFusingParseGetFusedData", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, HIWORD(v30));
                goto LABEL_35;
              }
              *(_DWORD *)(a2 + 44) = 0;
              if (v29 >= 4)
              {
                v32 = 0;
                v33 = 12;
                v34 = -12;
                while (1)
                {
                  if (v32 >= *(_DWORD *)(a2 + 8) - 1)
                    goto LABEL_47;
                  *(_DWORD *)(*(_QWORD *)a2 + 4 * v32) = *(_DWORD *)(*(_QWORD *)&v43[0] + (v33 - 8));
                  v35 = *(unsigned int *)(a2 + 44);
                  if (v35 >= *(_DWORD *)(a2 + 24) - 1)
                    goto LABEL_47;
                  v36 = (v34 + DWORD2(v43[0]) + 4);
                  if (v36 <= 3)
                  {
                    _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", v11, v12, v13, v14, v15, v16, v36);
LABEL_47:
                    v42 = (v33 - 4);
                    goto LABEL_51;
                  }
                  *(_DWORD *)(*(_QWORD *)(a2 + 16) + 4 * v35) = *(_DWORD *)(*(_QWORD *)&v43[0] + (v33 - 4));
                  v37 = *(unsigned int *)(a2 + 44);
                  if (v37 >= *(_DWORD *)(a2 + 40) - 1)
                    goto LABEL_50;
                  v38 = (v34 + DWORD2(v43[0]));
                  if (v38 <= 3)
                    break;
                  *(_DWORD *)(*(_QWORD *)(a2 + 32) + 4 * v37) = *(_DWORD *)(*(_QWORD *)&v43[0] + v33);
                  v32 = *(_DWORD *)(a2 + 44) + 1;
                  *(_DWORD *)(a2 + 44) = v32;
                  v33 = (v33 + 12);
                  v34 -= 12;
                  v29 = (DWORD2(v43[0]) + v34 + 8);
                  if (v29 <= 3)
                    goto LABEL_29;
                }
                _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", v11, v12, v13, v14, v15, v16, v38);
LABEL_50:
                v42 = v33;
LABEL_51:
                v39 = "ETLFusingParseGetFusedData";
                v40 = "Failed to fill address at offset: %d, totalNumber: %d, maxNumberOfAddress: %d\n";
                goto LABEL_34;
              }
LABEL_29:
              _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", v11, v12, v13, v14, v15, v16, v29);
              v24 = *(_DWORD *)(a2 + 44) != 0;
LABEL_36:
              HDLCFrameFree();
              HDLCFrameFree();
              return v24;
            }
LABEL_42:
            _ETLDebugPrint((uint64_t)"ETLFusingParseGetFusedData", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, v31);
            goto LABEL_35;
          }
          _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, **(_DWORD **)&v43[0]);
        }
        v31 = 0;
        goto LABEL_42;
      }
      v39 = "ETLSubsysAddHeaderInternal";
      v40 = "Failed to inject\n";
    }
    else
    {
      v39 = "ETLFusingGetFusedData";
      v40 = "Faild to create uplink frame\n";
    }
LABEL_34:
    _ETLDebugPrint((uint64_t)v39, (uint64_t)v40, v11, v12, v13, v14, v15, v16, v42);
    goto LABEL_35;
  }
  _ETLDebugPrint((uint64_t)"ETLFusingGetFusedData", (uint64_t)"Transport (%p) or paraemter (%p) should not be NULL \n", a3, a4, a5, a6, a7, a8, (uint64_t)a1);
  return 0;
}

uint64_t ETLFusingGetSecureState(capabilities::radio *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t FreeSpace;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *SecureState;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  const char *v42;
  uint64_t v44;
  _OWORD v45[2];
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  int v50;

  if (a1 && a2)
  {
    if ((capabilities::radio::mav20Plus(a1) & 1) != 0)
    {
      v47 = 0u;
      v48 = 0u;
      v49 = 0;
      memset(v45, 0, sizeof(v45));
      v46 = 0;
      if ((HDLCFrameCreateUplink() & 1) != 0)
      {
        FreeSpace = HDLCFrameGetFreeSpace();
        if (FreeSpace < 4)
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v24, v25, v26, v27, v28, v29, FreeSpace);
          goto LABEL_25;
        }
        v50 = 9502027;
        if ((HDLCFrameInject() & 1) != 0)
        {
          SecureState = malloc((2 * DWORD2(v47) + 32));
          if (!SecureState)
          {
LABEL_26:
            HDLCFrameFree();
            HDLCFrameFree();
            return (uint64_t)SecureState;
          }
          v31 = HDLCFrameEncode();
          if ((_DWORD)v31)
          {
            v32 = v31;
            v50 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0)
              ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, SecureState, v31);
            if (*(_QWORD *)a1)
            {
              v33 = (*(uint64_t (**)(capabilities::radio *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))a1)(a1, SecureState, v32, &v50, 1, a3, 0);
              v34 = v50;
              free(SecureState);
              SecureState = 0;
              if (v33 && v34 == (_DWORD)v32)
              {
                LOBYTE(v50) = 75;
                if (!_ETLResponseRingBuffer)
                  TelephonyUtilRingBufferInitialize();
                SecureState = 0;
                if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v45, (uint64_t)&_ETLResponseRingBuffer, &v50, a3)&& v50 == 75)
                {
                  SecureState = (void *)ETLFusingParseGetSecureState((int **)v45, a2, v35, v36, v37, v38, v39, v40);
                }
              }
              goto LABEL_26;
            }
          }
          free(SecureState);
LABEL_25:
          SecureState = 0;
          goto LABEL_26;
        }
        v41 = "ETLSubsysAddHeaderInternal";
        v42 = "Failed to inject\n";
      }
      else
      {
        v41 = "ETLFusingGetSecureState";
        v42 = "Faild to create uplink frame\n";
      }
      _ETLDebugPrint((uint64_t)v41, (uint64_t)v42, v17, v18, v19, v20, v21, v22, v44);
      goto LABEL_25;
    }
    _ETLDebugPrint((uint64_t)"ETLFusingGetSecureState", (uint64_t)"This does does not support secure state command\n", v11, v12, v13, v14, v15, v16, v44);
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFusingGetSecureState", (uint64_t)"Transport (%p) and Status (%p) should not be NULL\n", a3, a4, a5, a6, a7, a8, (uint64_t)a1);
    return 0;
  }
}

uint64_t ETLFusingParseGetSecureState(int **a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v15;
  uint64_t result;
  uint64_t v17;

  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_16:
    v12 = 0;
    v13 = 0;
    goto LABEL_17;
  }
  v10 = *a1;
  v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_16;
  }
  v12 = HIWORD(v11);
  v13 = BYTE1(v11);
  if (BYTE1(v11) != 253)
  {
LABEL_17:
    _ETLDebugPrint((uint64_t)"ETLFusingParseGetSecureState", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v13);
    goto LABEL_18;
  }
  if ((_DWORD)v12 != 144)
  {
LABEL_18:
    _ETLDebugPrint((uint64_t)"ETLFusingParseGetSecureState", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    __break(1u);
    goto LABEL_19;
  }
  if (v9 <= 3)
  {
LABEL_19:
    result = _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
    __break(1u);
    return result;
  }
  v15 = v10 + 1;
  if ((unsigned __int16)v10[1])
  {
    _ETLDebugPrint((uint64_t)"ETLFusingParseGetSecureState", (uint64_t)"Received Secboot provisioning trigger code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, (unsigned __int16)v10[1]);
    goto LABEL_10;
  }
  if (v10[1])
  {
LABEL_10:
    result = 0;
    *a2 = *v15;
    return result;
  }
  v17 = v8 - 8;
  if (v17 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v17);
    goto LABEL_10;
  }
  result = 1;
  *a2 = v10[2];
  return result;
}

uint64_t ETLDesenseCreateCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
LABEL_10:
    _ETLDebugPrint((uint64_t)"ETLDesenseCreateCommand", (uint64_t)"Failed to add command header\n", v21, v22, v23, v24, v25, v26, v28);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v27);
    goto LABEL_10;
  }
  v13 = HDLCFrameGetFreeSpace();
  if (v13 <= 7)
  {
    _ETLDebugPrint((uint64_t)"ETLDesenseCreateCommand", (uint64_t)"Remaining %u not enough %u\n", v14, v15, v16, v17, v18, v19, v13);
  }
  else if (HDLCFrameInjectUnsignedShort()
         && HDLCFrameInjectUnsignedShort()
         && HDLCFrameInjectUnsignedShort())
  {
    return HDLCFrameInjectUnsignedShort();
  }
  return 0;
}

uint64_t ETLDesenseParseResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;

  v8 = a1[2];
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        v11 = HIWORD(v10);
        if ((_DWORD)v11 == 15)
        {
          if (v9 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLDesenseParseResponseWithStatus", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*(_WORD *)(*(_QWORD *)a1 + 4) == 1)
          {
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLDesenseParseResponseWithStatus", (uint64_t)"Status returned was %u, expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(_QWORD *)a1 + 4));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLDesenseOperation(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  _OWORD v38[2];
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  int v43;

  if (a7)
    *a7 = 0;
  v42 = 0;
  v40 = 0u;
  v41 = 0u;
  memset(v38, 0, sizeof(v38));
  v39 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLDesenseOperation", (uint64_t)"Faild to create uplink frame\n", v10, v11, v12, v13, v14, v15, v37);
    goto LABEL_26;
  }
  if (!ETLDesenseCreateCommand())
  {
LABEL_26:
    v16 = 0;
    goto LABEL_27;
  }
  v16 = (uint64_t)malloc((2 * DWORD2(v40) + 32));
  if (v16)
  {
    v17 = HDLCFrameEncode();
    if (!(_DWORD)v17)
      goto LABEL_28;
    v18 = v17;
    v43 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    if (!*a1)
    {
LABEL_28:
      free((void *)v16);
      goto LABEL_26;
    }
    v19 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v16, v18, &v43, 1, a6, 0);
    v20 = v43;
    free((void *)v16);
    v16 = 0;
    if (v19)
    {
      if (v20 == (_DWORD)v18)
      {
        LOBYTE(v43) = 75;
        if (!_ETLResponseRingBuffer)
          TelephonyUtilRingBufferInitialize();
        v16 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v38, (uint64_t)&_ETLResponseRingBuffer, &v43, a6))
        {
          if (v43 == 75)
          {
            _ETLDebugPrint((uint64_t)"ETLDesenseOperation", (uint64_t)"Read done\n", v21, v22, v23, v24, v25, v26, v37);
            if (DWORD2(v38[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v27, v28, v29, v30, v31, v32, DWORD2(v38[0]));
            }
            else
            {
              v33 = **(_DWORD **)&v38[0];
              if (**(_DWORD **)&v38[0] == 75)
              {
                if (BYTE1(v33) == 253)
                {
                  v34 = HIWORD(v33);
                  if ((_DWORD)v34 == 15)
                  {
                    if ((DWORD2(v38[0]) - 4) <= 1)
                    {
                      _ETLDebugPrint((uint64_t)"ETLDesenseParseResponseWithStatus", (uint64_t)"Payload length %u less than needed %u\n", v27, v28, v29, v30, v31, v32, (DWORD2(v38[0]) - 4));
                    }
                    else
                    {
                      v35 = *(unsigned __int16 *)(*(_QWORD *)&v38[0] + 4);
                      if (a7)
                        *a7 = v35;
                      if ((_DWORD)v35 == 1)
                      {
                        v16 = 1;
                        goto LABEL_27;
                      }
                      _ETLDebugPrint((uint64_t)"ETLDesenseParseResponseWithStatus", (uint64_t)"Status returned was %u, expected %u\n", v27, v28, v29, v30, v31, v32, v35);
                    }
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v27, v28, v29, v30, v31, v32, v34);
                  }
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v27, v28, v29, v30, v31, v32, BYTE1(v33));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v27, v28, v29, v30, v31, v32, **(_DWORD **)&v38[0]);
              }
            }
            goto LABEL_26;
          }
        }
      }
    }
  }
LABEL_27:
  HDLCFrameFree();
  HDLCFrameFree();
  return v16;
}

uint64_t ETLDesenseStart(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  return ETLDesenseOperation(a1, 6, a2, a3, a4, a5, a6);
}

uint64_t ETLDesenseStop(_QWORD *a1, uint64_t a2, _DWORD *a3)
{
  return ETLDesenseOperation(a1, 7, 0, 0, 0, a2, a3);
}

uint64_t ETLDesenseReset(_QWORD *a1, uint64_t a2, _DWORD *a3)
{
  return ETLDesenseOperation(a1, 8, 0, 0, 0, a2, a3);
}

uint64_t ETLDesenseReport(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  return ETLDesenseOperation(a1, 5, a2, a3, 0, a4, a5);
}

uint64_t ETLLOGParseLogRecord(_QWORD *a1, _DWORD *a2, _QWORD *a3, _WORD *a4, unsigned __int16 *a5, uint64_t a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v9;

  if (a6 < 0xC)
    return 0;
  v9 = *a5;
  *a7 = v9;
  if (v9 <= a6 && v9 > 0xB)
  {
    if (a1)
      *a1 = a5 + 6;
    if (a2)
      *a2 = v9 - 12;
    if (a3)
      *a3 = *(_QWORD *)(a5 + 2);
    if (a4)
      *a4 = a5[1];
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLLOGParseLogRecord", (uint64_t)"Packet length is (%u), source buffer length is (%u), LOG header size should be (%u), skipping.\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, (uint64_t)a7, a8, v9);
    return 0;
  }
}

uint64_t ETLLOGParseLogHeader(uint64_t a1, unsigned int *a2, _QWORD *a3, _WORD *a4, uint64_t a5, unsigned int a6, _DWORD *a7)
{
  uint64_t result;
  unsigned int v8;

  result = 0;
  *a7 = 0;
  if (a6 >= 4)
  {
    if (*(_BYTE *)a5 == 16 && (v8 = *(unsigned __int16 *)(a5 + 2), *a2 = v8, v8 <= a6) && (*a7 = 4, a6 - 4 >= 0xC))
    {
      *a4 = *(_WORD *)(a5 + 6);
      *a3 = *(_QWORD *)(a5 + 8);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ETLLOGParseLog(char *__str, size_t __size, uint64_t a3, unsigned int a4, _DWORD *a5)
{
  unsigned int v5;
  unint64_t v6;
  int v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  *a5 = 0;
  if (a4 < 4 || *(_BYTE *)a3 != 16)
  {
    v6 = 0;
    v7 = 0;
    v5 = 0;
    goto LABEL_6;
  }
  v5 = *(unsigned __int16 *)(a3 + 2);
  if (v5 > a4)
  {
    v6 = 0;
    v7 = 0;
LABEL_6:
    v8 = 0;
    goto LABEL_7;
  }
  v7 = 4;
  *a5 = 4;
  if (a4 - 4 < 0xC)
  {
    v6 = 0;
    goto LABEL_6;
  }
  v8 = *(unsigned __int16 *)(a3 + 6);
  v6 = *(_QWORD *)(a3 + 8);
LABEL_7:
  *a5 = v5 + v7;
  v9 = 5 * (v6 >> 16)
     + ((unsigned __int16)(((43685 * (unsigned __int16)v6) >> 16)
                                       + ((unsigned __int16)((v6 - ((43685 * (unsigned __int16)v6) >> 16)) & 0xFFFE) >> 1)) >> 13)
     + 2;
  v10 = v9 >> 2;
  v11 = ((v9 * (unsigned __int128)0x10624DD2F1A9FCuLL) >> 64) + 315964800;
  if (__size >= snprintf(__str, __size, "[%02u:%02u:%02u:%06u: %04x] LOG 0x%02x: ", ((v11 * (unsigned __int128)0x123456789ABCE0uLL) >> 64) % 0x18, v11 / 0x3C- 60* ((unint64_t)((v11 / 0x3C * (unsigned __int128)0x888888888888889uLL) >> 64) >> 1), v11 % 0x3C, 1000* (v10 - 1000 * ((v10 * (unsigned __int128)0x4189374BC6A7F0uLL) >> 64)), v8, v5))TelephonyUtilBinToHex();
  return 1;
}

uint64_t ETLGSMAddCommandHeader()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    v13 = HDLCFrameInject();
    if ((v13 & 1) == 0)
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    return v13;
  }
}

uint64_t ETLGSMParseSubsysResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  v8 = *a2;
  v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v10 = *(_DWORD *)(*(_QWORD *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == (_DWORD)a3)
      {
        if (HIWORD(v10) == (_DWORD)a4)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLGSMParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLGSMParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLGSMParseGetIMEI(uint64_t *a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v8 = *a3;
  v9 = (*((_DWORD *)a1 + 2) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
LABEL_11:
    _ETLDebugPrint((uint64_t)"ETLGSMParseGetIMEI", (uint64_t)"failed parsing GSM response from frame\n", v17, v18, v19, v20, v21, v22, v23);
    return 0;
  }
  v10 = *a1;
  v11 = *(_DWORD *)(*a1 + v8);
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, *(_DWORD *)(*a1 + v8));
    goto LABEL_11;
  }
  v12 = v8 + 4;
  *a3 = v12;
  if (BYTE1(v11) != 8)
  {
    _ETLDebugPrint((uint64_t)"ETLGSMParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_11;
  }
  v13 = HIWORD(v11);
  if ((_DWORD)v13 != 1)
  {
    _ETLDebugPrint((uint64_t)"ETLGSMParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v13);
    goto LABEL_11;
  }
  if (*((_DWORD *)a1 + 2) - v12 <= 8)
  {
    _ETLDebugPrint((uint64_t)"ETLGSMParseGetIMEI", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 9);
    return 0;
  }
  else
  {
    v14 = (uint64_t *)(v10 + v12);
    v15 = *v14;
    *(_BYTE *)(a2 + 8) = *((_BYTE *)v14 + 8);
    *(_QWORD *)a2 = v15;
    return 1;
  }
}

uint64_t ETLGSMMakeIMEIFromString(uint64_t a1, char *__s)
{
  uint64_t result;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  unsigned int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  unsigned int v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  unsigned int v46;
  int v47;
  int v48;
  unsigned int v49;
  int v50;
  int v51;
  unsigned int v52;
  int v53;
  int v54;
  unsigned int v55;
  int v56;

  result = 0;
  if (!a1 || !__s)
    return result;
  v5 = strlen(__s);
  if (v5 != 15)
  {
    _ETLDebugPrint((uint64_t)"ETLGSMMakeIMEIFromString", (uint64_t)"Length %zu is unrecognized\n", v6, v7, v8, v9, v10, v11, v5);
    return 0;
  }
  v12 = *__s;
  v13 = v12 - 58;
  v14 = v12 - 48;
  if (v13 < 0xFFFFFFF6)
    v14 = -1;
  if (v14 < 0)
    return 0;
  result = 0;
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)a1 = 8;
  *(_BYTE *)(a1 + 1) = (16 * v14) | 0xA;
  v15 = __s[1];
  v16 = v15 - 58;
  v17 = v15 - 48;
  if (v16 < 0xFFFFFFF6)
    v17 = -1;
  v18 = __s[2];
  v19 = v18 - 58;
  v20 = v18 - 48;
  if (v19 < 0xFFFFFFF6)
    v20 = -1;
  if ((v17 & 0x80000000) == 0 && (v20 & 0x80000000) == 0)
  {
    result = 0;
    *(_BYTE *)(a1 + 2) = v17 | (16 * v20);
    v21 = __s[3];
    v22 = v21 - 58;
    v23 = v21 - 48;
    if (v22 < 0xFFFFFFF6)
      v23 = -1;
    v24 = __s[4];
    v25 = v24 - 58;
    v26 = v24 - 48;
    if (v25 < 0xFFFFFFF6)
      v26 = -1;
    if ((v23 & 0x80000000) == 0 && (v26 & 0x80000000) == 0)
    {
      result = 0;
      *(_BYTE *)(a1 + 3) = v23 | (16 * v26);
      v27 = __s[5];
      v28 = v27 - 58;
      v29 = v27 - 48;
      if (v28 < 0xFFFFFFF6)
        v29 = -1;
      v30 = __s[6];
      v31 = v30 - 58;
      v32 = v30 - 48;
      if (v31 < 0xFFFFFFF6)
        v32 = -1;
      if ((v29 & 0x80000000) == 0 && (v32 & 0x80000000) == 0)
      {
        result = 0;
        *(_BYTE *)(a1 + 4) = v29 | (16 * v32);
        v33 = __s[7];
        v34 = v33 - 58;
        v35 = v33 - 48;
        if (v34 < 0xFFFFFFF6)
          v35 = -1;
        v36 = __s[8];
        v37 = v36 - 58;
        v38 = v36 - 48;
        if (v37 < 0xFFFFFFF6)
          v38 = -1;
        if ((v35 & 0x80000000) == 0 && (v38 & 0x80000000) == 0)
        {
          result = 0;
          *(_BYTE *)(a1 + 5) = v35 | (16 * v38);
          v39 = __s[9];
          v40 = v39 - 58;
          v41 = v39 - 48;
          if (v40 < 0xFFFFFFF6)
            v41 = -1;
          v42 = __s[10];
          v43 = v42 - 58;
          v44 = v42 - 48;
          if (v43 < 0xFFFFFFF6)
            v44 = -1;
          if ((v41 & 0x80000000) == 0 && (v44 & 0x80000000) == 0)
          {
            result = 0;
            *(_BYTE *)(a1 + 6) = v41 | (16 * v44);
            v45 = __s[11];
            v46 = v45 - 58;
            v47 = v45 - 48;
            if (v46 < 0xFFFFFFF6)
              v47 = -1;
            v48 = __s[12];
            v49 = v48 - 58;
            v50 = v48 - 48;
            if (v49 < 0xFFFFFFF6)
              v50 = -1;
            if ((v47 & 0x80000000) == 0 && (v50 & 0x80000000) == 0)
            {
              result = 0;
              *(_BYTE *)(a1 + 7) = v47 | (16 * v50);
              v51 = __s[13];
              v52 = v51 - 58;
              v53 = v51 - 48;
              if (v52 < 0xFFFFFFF6)
                v53 = -1;
              v54 = __s[14];
              v55 = v54 - 58;
              v56 = v54 - 48;
              if (v55 < 0xFFFFFFF6)
                v56 = -1;
              if ((v53 & 0x80000000) == 0 && (v56 & 0x80000000) == 0)
              {
                *(_BYTE *)(a1 + 8) = v53 | (16 * v56);
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t ETLGSMMakeStringFromIMEI(_BYTE *a1, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  v8 = 0;
  if (a1 && a3)
  {
    if (a2 < 0x10)
    {
      _ETLDebugPrint((uint64_t)"ETLGSMMakeStringFromIMEI", (uint64_t)"buffer capacity is %u, need %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, a2);
      return 0;
    }
    else
    {
      *a1 = (a3[1] >> 4) | 0x30;
      a1[1] = a3[2] & 0xF | 0x30;
      a1[2] = (a3[2] >> 4) | 0x30;
      a1[3] = a3[3] & 0xF | 0x30;
      a1[4] = (a3[3] >> 4) | 0x30;
      a1[5] = a3[4] & 0xF | 0x30;
      a1[6] = (a3[4] >> 4) | 0x30;
      a1[7] = a3[5] & 0xF | 0x30;
      a1[8] = (a3[5] >> 4) | 0x30;
      a1[9] = a3[6] & 0xF | 0x30;
      a1[10] = (a3[6] >> 4) | 0x30;
      a1[11] = a3[7] & 0xF | 0x30;
      a1[12] = (a3[7] >> 4) | 0x30;
      a1[13] = a3[8] & 0xF | 0x30;
      a1[14] = (a3[8] >> 4) | 0x30;
      a1[15] = 0;
      return 1;
    }
  }
  return v8;
}

void *ETLGSMGetIMEI(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *IMEI;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  uint64_t v32;
  _OWORD v33[2];
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  unsigned int v38;
  int v39;

  v38 = 0;
  v35 = 0u;
  v36 = 0u;
  v37 = 0;
  memset(v33, 0, sizeof(v33));
  v34 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v29 = "ETLGSMGetIMEI";
    v30 = "Failed to create command frame\n";
LABEL_19:
    _ETLDebugPrint((uint64_t)v29, (uint64_t)v30, v6, v7, v8, v9, v10, v11, v32);
    goto LABEL_20;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
LABEL_20:
    IMEI = 0;
    goto LABEL_21;
  }
  v39 = 67659;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v29 = "ETLSubsysAddHeaderInternal";
    v30 = "Failed to inject\n";
    goto LABEL_19;
  }
  IMEI = malloc((2 * DWORD2(v35) + 32));
  if (!IMEI)
    goto LABEL_21;
  v20 = HDLCFrameEncode();
  if (!(_DWORD)v20)
    goto LABEL_22;
  v21 = v20;
  v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, IMEI, v20);
  if (!*a1)
  {
LABEL_22:
    free(IMEI);
    goto LABEL_20;
  }
  v22 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, IMEI, v21, &v39, 1, a3, 0);
  v23 = v39;
  free(IMEI);
  IMEI = 0;
  if (v22 && v23 == (_DWORD)v21)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    IMEI = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v33, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      IMEI = (void *)ETLGSMParseGetIMEI((uint64_t *)v33, a2, &v38, v24, v25, v26, v27, v28);
    }
  }
LABEL_21:
  HDLCFrameFree();
  HDLCFrameFree();
  return IMEI;
}

uint64_t ETLGSMIsValidIMEI(_BYTE *a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t result;
  char __s2[16];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  memset(__s2, 170, sizeof(__s2));
  if (a1)
  {
    __s2[0] = (a1[1] >> 4) | 0x30;
    v1 = a1[2];
    __s2[1] = v1 & 0xF | 0x30;
    __s2[2] = (v1 >> 4) | 0x30;
    v2 = a1[3];
    __s2[3] = v2 & 0xF | 0x30;
    __s2[4] = (v2 >> 4) | 0x30;
    v3 = a1[4];
    __s2[5] = v3 & 0xF | 0x30;
    __s2[6] = (v3 >> 4) | 0x30;
    v4 = a1[5];
    __s2[7] = v4 & 0xF | 0x30;
    __s2[8] = (v4 >> 4) | 0x30;
    v5 = a1[6];
    __s2[9] = v5 & 0xF | 0x30;
    __s2[10] = (v5 >> 4) | 0x30;
    v6 = a1[7];
    __s2[11] = v6 & 0xF | 0x30;
    __s2[12] = (v6 >> 4) | 0x30;
    v7 = a1[8];
    __s2[13] = v7 & 0xF | 0x30;
    *(_WORD *)&__s2[14] = (v7 >> 4) | 0x30;
  }
  result = strncmp((const char *)kDefaultIMEIs, __s2, 0xFuLL);
  if ((_DWORD)result)
    return strncmp((const char *)qword_1F028E1E8, __s2, 0xFuLL) != 0;
  return result;
}

uint64_t ETLGSMSetIMEI(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3)
{
  int v4;

  return ETLNVWriteWithStatus(a1, 550, a2, 9u, &v4, a3);
}

BOOL ETLLOGGetItemIDAndEquipIDFromCode(unsigned int a1, unsigned int *a2, unsigned int *a3)
{
  if (a1 >> 13 <= 6)
  {
    *a2 = a1 >> 12;
    *a3 = a1 & 0xFFF;
  }
  return a1 < 0xE000;
}

uint64_t ETLLOGGetCode(int a1, int a2)
{
  return (a2 + (a1 << 12));
}

unint64_t ETLLOGDisable(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  _OWORD v16[2];
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;

  v18 = 0u;
  v19 = 0u;
  v20 = 0;
  memset(v16, 0, sizeof(v16));
  v17 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_20;
  if (HDLCFrameGetFreeSpace() <= 7)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v4, v5, v6, v7, v8, v9, 8);
    goto LABEL_20;
  }
  v21 = 115;
  if (!HDLCFrameInject())
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
  v10 = (unint64_t)malloc((2 * DWORD2(v18) + 32));
  if (!v10)
    goto LABEL_21;
  v11 = HDLCFrameEncode();
  if (!(_DWORD)v11)
    goto LABEL_22;
  v12 = v11;
  LODWORD(v21) = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v10, v11);
  if (!*a1)
  {
LABEL_22:
    free((void *)v10);
    goto LABEL_20;
  }
  v13 = ((uint64_t (*)(_QWORD *, unint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, _QWORD))*a1)(a1, v10, v12, &v21, 1, a2, 0);
  v14 = v21;
  free((void *)v10);
  v10 = 0;
  if (v13 && v14 == (_DWORD)v12)
  {
    LOBYTE(v21) = 115;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v10 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v16, (uint64_t)&_ETLResponseRingBuffer, &v21, a2))
    {
      if (**(_BYTE **)&v16[0] == 115 && DWORD2(v16[0]) >= 8)
      {
        v10 = 0;
        if (!*(_DWORD *)(*(_QWORD *)&v16[0] + 4) && (DWORD2(v16[0]) & 0xFFFFFFFC) != 8)
          v10 = *(_DWORD *)(*(_QWORD *)&v16[0] + 8) == 0;
      }
    }
  }
LABEL_21:
  HDLCFrameFree();
  HDLCFrameFree();
  return v10;
}

uint64_t ETLLOGGetIDs(_QWORD *a1, void *a2, int a3, unsigned int *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  size_t v21;
  _OWORD v23[2];
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;

  v25 = 0u;
  v26 = 0u;
  v27 = 0;
  memset(v23, 0, sizeof(v23));
  v24 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_24;
  if (HDLCFrameGetFreeSpace() <= 7)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v10, v11, v12, v13, v14, v15, 8);
    goto LABEL_24;
  }
  v28 = 0x100000073;
  if (!HDLCFrameInject())
  {
LABEL_24:
    v16 = 0;
    goto LABEL_25;
  }
  v16 = (uint64_t)malloc((2 * DWORD2(v25) + 32));
  if (!v16)
    goto LABEL_25;
  v17 = HDLCFrameEncode();
  if (!(_DWORD)v17)
    goto LABEL_26;
  v18 = v17;
  LODWORD(v28) = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
  if (!*a1)
  {
LABEL_26:
    free((void *)v16);
    goto LABEL_24;
  }
  v19 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, _QWORD))*a1)(a1, v16, v18, &v28, 1, a5, 0);
  v20 = v28;
  free((void *)v16);
  v16 = 0;
  if (v19 && v20 == (_DWORD)v18)
  {
    LOBYTE(v28) = 115;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v16 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v23, (uint64_t)&_ETLResponseRingBuffer, &v28, a5))
    {
      if (**(_BYTE **)&v23[0] == 115 && DWORD2(v23[0]) >= 8)
      {
        v16 = 0;
        if (*(_DWORD *)(*(_QWORD *)&v23[0] + 4) == 1 && (DWORD2(v23[0]) & 0xFFFFFFFC) != 8)
        {
          if (!(*(_DWORD *)(*(_QWORD *)&v23[0] + 8) | BYTE8(v23[0]) & 3))
          {
            if (4 * a3 >= (DWORD2(v23[0]) - 12))
              v21 = (DWORD2(v23[0]) - 12);
            else
              v21 = (4 * a3);
            memcpy(a2, (const void *)(*(_QWORD *)&v23[0] + 12), v21);
            *a4 = v21 >> 2;
            v16 = 1;
            goto LABEL_25;
          }
          goto LABEL_24;
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v16;
}

uint64_t ETLLOGSetMask(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  _OWORD v45[2];
  uint64_t v46;
  _OWORD v47[2];
  uint64_t v48;
  uint64_t v49;

  v9 = a4;
  v13 = (a4 + 7) >> 3;
  _ETLDebugPrint((uint64_t)"ETLLOGSetMask", (uint64_t)"Set Mask for id %u, bits = %u (%u bytes)\n", (uint64_t)a3, a4, a5, a6, a7, a8, a2);
  memset(v47, 0, sizeof(v47));
  v48 = 0;
  memset(v45, 0, sizeof(v45));
  v46 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_11;
  if (HDLCFrameGetFreeSpace() <= 7)
  {
    v44 = 8;
    goto LABEL_9;
  }
  v49 = 0x300000073;
  if (HDLCFrameInject())
  {
    if (v9 > 0x1000)
    {
      _ETLDebugPrint((uint64_t)"ETLLOGCreateSetMaskCommand", (uint64_t)"Bits %u too large\n", v14, v15, v16, v17, v18, v19, v9);
      goto LABEL_11;
    }
    if (!(_DWORD)v9)
    {
      v20 = "ETLLOGCreateSetMaskCommand";
      v21 = "Bits must be nonzero\n";
      goto LABEL_10;
    }
    if (HDLCFrameGetFreeSpace() < (int)v13 + 8)
    {
      v44 = (v13 + 8);
LABEL_9:
      v20 = "ETLRequireFreeSpace";
      v21 = "Need %u bytes free space, but only have %u\n";
LABEL_10:
      _ETLDebugPrint((uint64_t)v20, (uint64_t)v21, v14, v15, v16, v17, v18, v19, v44);
      goto LABEL_11;
    }
    if (!HDLCFrameInjectUnsignedInt())
      goto LABEL_11;
    if (!HDLCFrameInjectUnsignedInt())
      goto LABEL_11;
    if (!HDLCFrameInject())
      goto LABEL_11;
    if (!ETLSendCommand(a1, (uint64_t)v47, a5))
      goto LABEL_11;
    LOBYTE(v49) = 115;
    if (!ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v45, &v49, a5))
      goto LABEL_11;
    v30 = *(_QWORD *)&v45[0];
    if (**(_BYTE **)&v45[0] == 115
      && DWORD2(v45[0]) >= 8
      && *(_DWORD *)(*(_QWORD *)&v45[0] + 4) == 3
      && (DWORD2(v45[0]) & 0xFFFFFFFC) != 8
      && !*(_DWORD *)(*(_QWORD *)&v45[0] + 8))
    {
      if ((DWORD2(v45[0]) - 12) >= 4)
      {
        if (*(_DWORD *)(*(_QWORD *)&v45[0] + 12) == (_DWORD)a2)
        {
          if ((DWORD2(v45[0]) - 16) >= 4)
          {
            v31 = *(_DWORD *)(*(_QWORD *)&v45[0] + 16);
            v32 = DWORD2(v45[0]) - 20;
            if (v31 >= v9)
            {
              v33 = v13;
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"Warning: response bits %u is less than request %u\n", v24, v25, v26, v27, v28, v29, *(unsigned int *)(*(_QWORD *)&v45[0] + 16));
              v33 = (v31 + 7) >> 3;
              LODWORD(v9) = v31;
            }
            if (v33 <= v32)
            {
              v34 = (unsigned __int8 *)(v30 + 20);
              v35 = (unint64_t)v9 >> 3;
              v36 = memcmp(v34, a3, v35);
              v43 = (a3[v35] ^ v34[v35]) & ~(-1 << (v9 & 7));
              if (!(v36 | v43))
              {
                v22 = 1;
                goto LABEL_12;
              }
              _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"Error: Mask response mismatch\n", v37, v38, v39, v40, v41, v42, v44);
              if (v43)
                _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"Error: Mask[%u]: 0x%x, and Received Mask[%u]: 0x%x\n", v24, v25, v26, v27, v28, v29, v35);
              if ((_ETLDebugFlags & 2) != 0)
              {
                ((void (*)(const char *, uint64_t, unsigned __int8 *, uint64_t))*(&gDelegate + 1))("Sent:", 2, a3, v13);
                if ((_ETLDebugFlags & 2) != 0)
                  ((void (*)(const char *, uint64_t, unsigned __int8 *, uint64_t))*(&gDelegate + 1))("Received:", 2, v34, v33);
              }
              goto LABEL_32;
            }
            v13 = v33;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"ID mismatch. Requested %u, response %u\n", v24, v25, v26, v27, v28, v29, a2);
        }
      }
      _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"Error: Received Mask bits upto %u bytes, but the actual payload has %u bytes.\n", v24, v25, v26, v27, v28, v29, v13);
    }
LABEL_32:
    _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"Failed on ID %u\n", v24, v25, v26, v27, v28, v29, a2);
  }
LABEL_11:
  v22 = 0;
LABEL_12:
  HDLCFrameFree();
  HDLCFrameFree();
  return v22;
}

uint64_t ETLLOGSetMaskWithRetry(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(uint64_t);
  uint64_t v23;

  if (!(_DWORD)a6)
    return 0;
  v8 = a6;
  do
  {
    v14 = ETLLOGSetMask((uint64_t (**)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))a1, a2, a3, a4, a5, a6, a7, a8);
    if ((v14 & 1) != 0)
      break;
    TelephonyUtilRingBufferReset();
    v21 = *(void (**)(uint64_t))(a1 + 24);
    if (v21)
      v21(a1);
    _ETLDebugPrint((uint64_t)"ETLLOGSetMaskWithRetry", (uint64_t)"Trying again\n", v15, v16, v17, v18, v19, v20, v23);
    --v8;
  }
  while (v8);
  return v14;
}

uint64_t ETLLOGClearAllMasksWithRetry(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  __int128 v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(_QWORD *);
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  _OWORD v32[32];
  _OWORD v33[4];
  uint64_t v34;

  v8 = a3;
  v34 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v33[2] = v11;
  v33[3] = v11;
  v33[0] = v11;
  v33[1] = v11;
  v31 = -1431655766;
  _ETLDebugPrint((uint64_t)"ETLLOGClearAllMasksWithRetry", (uint64_t)"Clearing All Masks\n", a3, a4, a5, a6, a7, a8, v29);
  result = ETLLOGGetIDs(a1, v33, 16, &v31, a2);
  if ((_DWORD)result)
  {
    memset(v32, 0, sizeof(v32));
    if (v8)
    {
      v16 = 0;
      v17 = v31 - 1;
      if (v31 - 1 >= 0xD)
        v17 = 13;
      v30 = (v17 + 1);
      while (2)
      {
        v18 = *((_DWORD *)v33 + v16);
        if (v18 >= 0x1000)
          v19 = 4096;
        else
          v19 = *((_DWORD *)v33 + v16);
        if (v18)
          v20 = v19;
        else
          v20 = 4096;
        v21 = v8;
        while ((ETLLOGSetMask((uint64_t (**)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))a1, v16, (unsigned __int8 *)v32, v20, a2, v13, v14, v15) & 1) == 0)
        {
          if (v21 >= 2)
          {
            TelephonyUtilRingBufferReset();
            v28 = (void (*)(_QWORD *))a1[3];
            if (v28)
              v28(a1);
            _ETLDebugPrint((uint64_t)"ETLLOGClearAllMasksWithRetry", (uint64_t)"Trying again\n", v22, v23, v24, v25, v26, v27, v30);
          }
          if (!--v21)
            return 0;
        }
        if (++v16 != v30)
          continue;
        break;
      }
    }
    return 1;
  }
  return result;
}

uint64_t ETLLOGClearAllEnabledMasksWithRetry(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(_QWORD *);
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  _OWORD v36[32];
  _OWORD v37[4];
  uint64_t v38;

  v34 = a5;
  v38 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v37[2] = v12;
  v37[3] = v12;
  v37[0] = v12;
  v37[1] = v12;
  v35 = -1431655766;
  _ETLDebugPrint((uint64_t)"ETLLOGClearAllEnabledMasksWithRetry", (uint64_t)"Clearing All Masks\n", a3, a4, a5, a6, a7, a8, v31);
  result = ETLLOGGetIDs(a1, v37, 16, &v35, a4);
  if ((_DWORD)result)
  {
    v17 = v35 - 1;
    if (v35 - 1 >= 0xD)
      v17 = 13;
    v33 = v17;
    memset(v36, 0, sizeof(v36));
    if (a2 && v34)
    {
      v18 = 0;
      do
      {
        v19 = *(unsigned int *)(a3 + 4 * v18);
        if (v19 <= v33)
        {
          v20 = *((_DWORD *)v37 + v19);
          if (v20 >= 0x1000)
            v21 = 4096;
          else
            v21 = *((_DWORD *)v37 + v19);
          if (v20)
            v22 = v21;
          else
            v22 = 4096;
          v23 = v34;
          while ((ETLLOGSetMask((uint64_t (**)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))a1, v19, (unsigned __int8 *)v36, v22, a4, v14, v15, v16) & 1) == 0)
          {
            if (v23 >= 2)
            {
              TelephonyUtilRingBufferReset();
              v30 = (void (*)(_QWORD *))a1[3];
              if (v30)
                v30(a1);
              _ETLDebugPrint((uint64_t)"ETLLOGClearAllEnabledMasksWithRetry", (uint64_t)"Trying again\n", v24, v25, v26, v27, v28, v29, v32);
            }
            if (!--v23)
              return 0;
          }
        }
        ++v18;
      }
      while (v18 != a2);
    }
    return 1;
  }
  return result;
}

const char *ETLLOGEquipIDAsString(unsigned int a1)
{
  if (a1 <= 0xD)
    return off_1EA1F1C40[a1];
  else
    return "Unknown";
}

uint64_t APPLIB_DIAG_PM_ReadVRegLevel(void *a1, unsigned int a2)
{
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  bzero(a1, a2);
  if (!HDLCFrameCreateUplink())
    return 0xFFFFFFFFLL;
  HDLCFrameInject();
  LODWORD(result) = HDLCFrameEncode();
  if ((_DWORD)result)
    return result;
  else
    return 0xFFFFFFFFLL;
}

uint64_t APPLIB_DIAG_PM_ParseReadVRegLevelResponse(uint64_t a1, unsigned int a2, _BYTE *a3, _WORD *a4)
{
  uint64_t result;

  if (a2 < 3)
    return 0xFFFFFFFFLL;
  result = 0;
  *a3 = *(_BYTE *)(a1 + 3);
  *a4 = *(_WORD *)(a1 + 4);
  return result;
}

uint64_t ETLHSICParseCommandHeader(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = ETLMaverickParseFACTORYResponseHeader(a1, a2, 48, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    v18 = *a2;
    if ((*(_DWORD *)(a1 + 8) - v18) <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLHSICParseCommandHeader", (uint64_t)"Need %u bytes, but only have %u\n", v12, v13, v14, v15, v16, v17, 2);
      return 0;
    }
    else
    {
      v19 = *(unsigned __int16 *)(*(_QWORD *)a1 + v18);
      *a3 = v19;
      if ((_DWORD)v19)
        _ETLDebugPrint((uint64_t)"ETLHSICParseCommandHeader", (uint64_t)"Command status was %u\n", v12, v13, v14, v15, v16, v17, v19);
      return 1;
    }
  }
  return result;
}

uint64_t ETLHSICCreateEchoCommand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t FreeSpace;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v22;
  const char *v23;
  uint64_t v24;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v9, v10, v11, v12, v13, v14, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    v22 = "ETLSubsysAddHeaderInternal";
    v23 = "Failed to inject\n";
LABEL_14:
    _ETLDebugPrint((uint64_t)v22, (uint64_t)v23, v15, v16, v17, v18, v19, v20, v24);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 0xB)
  {
    v24 = 12;
    v22 = "ETLRequireFreeSpace";
    v23 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_14;
  }
  if (HDLCFrameInjectUnsignedShort()
    && HDLCFrameInjectUnsignedShort()
    && HDLCFrameInjectUnsignedInt()
    && HDLCFrameInjectUnsignedInt()
    && ETLRequireFreeSpace(a1, (a6 + 2))
    && HDLCFrameInjectUnsignedShort())
  {
    return HDLCFrameInject();
  }
  return 0;
}

uint64_t ETLHSICParseEchoCommand(unsigned int *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;

  v8 = a1[2];
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    v9 = **(_DWORD **)a1;
    if (v9 == 75)
    {
      if (BYTE1(v9) == 254)
      {
        v10 = HIWORD(v9);
        if ((_DWORD)v10 == 48)
        {
          if (v8 - 4 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLHSICParseCommandHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 2);
            return 0;
          }
          else
          {
            v11 = *(unsigned __int16 *)(*(_QWORD *)a1 + 4);
            *a2 = v11;
            if ((_DWORD)v11)
              _ETLDebugPrint((uint64_t)"ETLHSICParseCommandHeader", (uint64_t)"Command status was %u\n", a3, a4, a5, a6, a7, a8, v11);
            return 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLUARTCreateSetInactivityTimerCommand()
{
  uint64_t FreeSpace;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if ((HDLCFrameInject() & 1) != 0)
  {
    if (HDLCFrameGetFreeSpace() <= 3)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 4);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedInt();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

BOOL ETLUARTParseSetInactivityTimerResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;

  v8 = a1[2];
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    v9 = **(_DWORD **)a1;
    if (v9 == 75)
    {
      if (BYTE1(v9) == 253)
      {
        v10 = HIWORD(v9);
        if ((_DWORD)v10 == 44)
        {
          if (v8 == 4)
          {
            _ETLDebugPrint((uint64_t)"ETLUARTParseSetInactivityTimerResponse", (uint64_t)"Only have %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, 0);
            return 0;
          }
          else
          {
            return *(_BYTE *)(*(_QWORD *)a1 + 4) == 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

unint64_t ETLUARTSetInactivityTimer(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  const char *v35;
  uint64_t v37;
  _OWORD v38[2];
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  unsigned int v43;

  v40 = 0u;
  v41 = 0u;
  v42 = 0;
  memset(v38, 0, sizeof(v38));
  v39 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    v34 = "ETLUARTSetInactivityTimer";
    v35 = "Failed to create command frame\n";
LABEL_24:
    _ETLDebugPrint((uint64_t)v34, (uint64_t)v35, v5, v6, v7, v8, v9, v10, v37);
    goto LABEL_25;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_25;
  }
  v43 = 2948427;
  if ((HDLCFrameInject() & 1) == 0)
  {
    v34 = "ETLSubsysAddHeaderInternal";
    v35 = "Failed to inject\n";
    goto LABEL_24;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    v37 = 4;
    v34 = "ETLRequireFreeSpace";
    v35 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_24;
  }
  if (!HDLCFrameInjectUnsignedInt())
  {
LABEL_25:
    v18 = 0;
    goto LABEL_26;
  }
  v18 = (unint64_t)malloc((2 * DWORD2(v40) + 32));
  if (!v18)
    goto LABEL_26;
  v19 = HDLCFrameEncode();
  if (!(_DWORD)v19)
    goto LABEL_27;
  v20 = v19;
  v43 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
  if (!*a1)
  {
LABEL_27:
    free((void *)v18);
    goto LABEL_25;
  }
  v21 = ((uint64_t (*)(_QWORD *, unint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v18, v20, &v43, 1, a3, 0);
  v22 = v43;
  free((void *)v18);
  v18 = 0;
  if (v21 && v22 == (_DWORD)v20)
  {
    LOBYTE(v43) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    v18 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v38, (uint64_t)&_ETLResponseRingBuffer, &v43, a3))
    {
      if (v43 == 75)
      {
        v43 = 0;
        v18 = 0;
        if (ETLMaverickParseBSPResponseHeader((uint64_t)v38, &v43, 44, v23, v24, v25, v26, v27))
        {
          if (DWORD2(v38[0]) != v43)
          {
            v18 = *(unsigned __int8 *)(*(_QWORD *)&v38[0] + v43) == 1;
            goto LABEL_26;
          }
          _ETLDebugPrint((uint64_t)"ETLUARTParseSetInactivityTimerResponse", (uint64_t)"Only have %u bytes, need %u\n", v28, v29, v30, v31, v32, v33, 0);
          goto LABEL_25;
        }
      }
    }
  }
LABEL_26:
  HDLCFrameFree();
  HDLCFrameFree();
  return v18;
}

uint64_t ETLMESSAGEGetSubsystemRangeSize(unsigned __int16 *a1)
{
  return a1[1] - *a1 + 1;
}

uint64_t ETLMESSAGEGetSubsystemIDRanges(_QWORD *a1, unsigned int a2, void *a3, unsigned int *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  size_t v21;
  const char *v22;
  const char *v23;
  uint64_t v25;
  _OWORD v26[2];
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  int v31;

  v28 = 0u;
  v29 = 0u;
  v30 = 0;
  memset(v26, 0, sizeof(v26));
  v27 = 0;
  *a4 = 0;
  v10 = 0;
  if (HDLCFrameCreateUplink())
  {
    LOWORD(v31) = 381;
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      v25 = 2;
      v22 = "ETLRequireFreeSpace";
      v23 = "Need %u bytes free space, but only have %u\n";
      goto LABEL_23;
    }
    if (!HDLCFrameInject())
      goto LABEL_24;
    v10 = (uint64_t)malloc((2 * DWORD2(v28) + 32));
    if (v10)
    {
      v17 = HDLCFrameEncode();
      if (!(_DWORD)v17)
        goto LABEL_26;
      v18 = v17;
      v31 = -1431655766;
      if ((_ETLDebugFlags & 2) != 0)
        ((void (*)(const char *, _QWORD, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v10, v17);
      if (!*a1)
      {
LABEL_26:
        free((void *)v10);
        goto LABEL_24;
      }
      v19 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v10, v18, &v31, 1, a5, 0);
      v20 = v31;
      free((void *)v10);
      v10 = 0;
      if (v19)
      {
        if (v20 == (_DWORD)v18)
        {
          LOBYTE(v31) = 125;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          if ((ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v26, (uint64_t)&_ETLResponseRingBuffer, &v31, a5) & 1) != 0)
          {
            if (DWORD2(v26[0]) >= 2)
            {
              if (*(_BYTE *)(*(_QWORD *)&v26[0] + 1) == 1)
              {
                if ((DWORD2(v26[0]) - 8) <= 0xFFFFFFF9)
                {
                  if (*(_BYTE *)(*(_QWORD *)&v26[0] + 2) == 1)
                  {
                    if (*(_DWORD *)(*(_QWORD *)&v26[0] + 4) < a2)
                      a2 = *(_DWORD *)(*(_QWORD *)&v26[0] + 4);
                    v21 = 4 * a2;
                    if (DWORD2(v26[0]) - 8 >= v21)
                    {
                      memcpy(a3, (const void *)(*(_QWORD *)&v26[0] + 8), v21);
                      *a4 = a2;
                      v10 = 1;
                      goto LABEL_25;
                    }
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseGetSubsystemIDRangesResponse", (uint64_t)"Status was %u\n", v11, v12, v13, v14, v15, v16, *(unsigned __int8 *)(*(_QWORD *)&v26[0] + 2));
                  }
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMESSAGEParseGetSubsystemIDRangesResponse", (uint64_t)"Response subcommand %u mismatches expected %u\n", v11, v12, v13, v14, v15, v16, *(unsigned __int8 *)(*(_QWORD *)&v26[0] + 1));
              }
            }
LABEL_24:
            v10 = 0;
            goto LABEL_25;
          }
          v22 = "ETLMESSAGEFindMatchingResponse";
          v23 = "Failed to find matching response\n";
LABEL_23:
          _ETLDebugPrint((uint64_t)v22, (uint64_t)v23, v11, v12, v13, v14, v15, v16, v25);
          goto LABEL_24;
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v10;
}

uint64_t ETLMESSAGEGetSubsystemMasksWithRetry(_QWORD *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  char v33;
  BOOL v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  const char *v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void (*v46)(_QWORD *);
  int v47;
  int v48;
  int v49;
  uint64_t result;
  int v51;
  uint64_t v52;
  int v53;
  unsigned int v54;
  _DWORD *v55;
  unsigned int v56;
  void *__dst;
  unsigned int v59;
  unsigned __int16 v61;
  unsigned __int16 v62;
  _OWORD v63[2];
  uint64_t v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;
  _DWORD v68[3];

  v8 = a6;
  v9 = *a2;
  v10 = a2[1] - v9 + 1;
  v61 = *a2;
  *a6 = 0;
  if ((_DWORD)a8)
  {
    v11 = a8;
    v12 = a3;
    v54 = a7;
    v56 = a8;
    while (1)
    {
      v59 = a4;
      __dst = (void *)a5;
      if (v10 >= 0x3D)
        v14 = 61;
      else
        v14 = v10;
      v62 = v9 + v14 - 1;
      _ETLDebugPrint((uint64_t)"ETLMESSAGEGetSubsystemMasksWithRetry", (uint64_t)"Partition Range to 0x%08X, max 0x%x\n", a3, a4, a5, (uint64_t)a6, a7, a8, (unsigned __int16)v9 | (v62 << 16));
      while (1)
      {
        v65 = 0u;
        v66 = 0u;
        v67 = 0;
        memset(v63, 0, sizeof(v63));
        v64 = 0;
        if (!HDLCFrameCreateUplink())
          goto LABEL_36;
        if (v12)
        {
          if (v12 != 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMESSAGEGetSubcommandTypeForMaskType", (uint64_t)"Invald mask type %u\n", v15, v16, v17, v18, v19, v20, a3);
            goto LABEL_36;
          }
          v21 = 3;
        }
        else
        {
          v21 = 2;
        }
        LOBYTE(v68[0]) = 125;
        BYTE1(v68[0]) = v21;
        if (HDLCFrameGetFreeSpace() <= 1)
        {
          v37 = 2;
          goto LABEL_34;
        }
        if (!HDLCFrameInject())
          goto LABEL_36;
        if (HDLCFrameGetFreeSpace() <= 3)
        {
          v37 = 4;
LABEL_34:
          v52 = v37;
          v38 = "ETLRequireFreeSpace";
          v39 = "Need %u bytes free space, but only have %u\n";
LABEL_35:
          _ETLDebugPrint((uint64_t)v38, (uint64_t)v39, v22, v23, v24, v25, v26, v27, v52);
LABEL_36:
          LODWORD(v28) = 0;
          v33 = 0;
          goto LABEL_37;
        }
        if (!HDLCFrameInject())
          goto LABEL_36;
        v55 = v8;
        v28 = malloc((2 * DWORD2(v65) + 32));
        if (!v28)
          goto LABEL_43;
        v29 = HDLCFrameEncode();
        if (!(_DWORD)v29)
          goto LABEL_42;
        v30 = v29;
        v68[0] = -1431655766;
        if ((_ETLDebugFlags & 2) != 0)
          ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v28, v29);
        if (!*a1)
        {
LABEL_42:
          free(v28);
          LODWORD(v28) = 0;
LABEL_43:
          v33 = 0;
          v8 = v55;
          goto LABEL_37;
        }
        v53 = ((uint64_t (*)(_QWORD *, void *, uint64_t, _DWORD *, uint64_t, _QWORD, _QWORD))*a1)(a1, v28, v30, v68, 1, v54, 0);
        v31 = v68[0];
        free(v28);
        LODWORD(v28) = 0;
        if (v53)
        {
          v32 = v31;
          v33 = 0;
          v34 = v32 == (_DWORD)v30;
          v8 = v55;
          if (v34)
          {
            LOBYTE(v68[0]) = 125;
            if (!_ETLResponseRingBuffer)
              TelephonyUtilRingBufferInitialize();
            if ((ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v63, (uint64_t)&_ETLResponseRingBuffer, v68, v54) & 1) == 0)
            {
              v38 = "ETLMESSAGEFindMatchingResponse";
              v39 = "Failed to find matching response\n";
              goto LABEL_35;
            }
            if (DWORD2(v63[0]) < 2)
              goto LABEL_36;
            v35 = *(unsigned __int8 *)(*(_QWORD *)&v63[0] + 1);
            if (v12)
              v36 = 3;
            else
              v36 = 2;
            if (v36 != (_DWORD)v35)
            {
              _ETLDebugPrint((uint64_t)"ETLMESSAGEParseGetSubsystemMasksResponse", (uint64_t)"Response subcommand 0x%x mismatches expected 0x%x\n", v22, v23, v24, v25, v26, v27, v35);
              goto LABEL_36;
            }
            if ((DWORD2(v63[0]) - 8) > 0xFFFFFFF9)
              goto LABEL_36;
            if (*(_BYTE *)(*(_QWORD *)&v63[0] + 6) != 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMESSAGEParseGetSubsystemMasksResponse", (uint64_t)"Status was %u\n", v22, v23, v24, v25, v26, v27, *(unsigned __int8 *)(*(_QWORD *)&v63[0] + 6));
              goto LABEL_36;
            }
            v47 = *(unsigned __int16 *)(*(_QWORD *)&v63[0] + 2);
            v48 = *(unsigned __int16 *)(*(_QWORD *)&v63[0] + 4);
            if (v62 != v48 || v61 != v47)
            {
              _ETLDebugPrint((uint64_t)"ETLMESSAGEParseGetSubsystemMasksResponse", (uint64_t)"Returned range 0x%x didn't match requested 0x%x\n", v22, v23, v24, v25, v26, v27, v47 | (v48 << 16));
              goto LABEL_36;
            }
            v49 = v48 - v47;
            if (v49 + 1 < v59)
              LODWORD(v28) = v49 + 1;
            else
              LODWORD(v28) = v59;
            if (DWORD2(v63[0]) - 8 < (4 * (_DWORD)v28))
              goto LABEL_36;
            memcpy(__dst, (const void *)(*(_QWORD *)&v63[0] + 8), (4 * (_DWORD)v28));
            v33 = 1;
          }
        }
        else
        {
          v33 = 0;
          v8 = v55;
        }
LABEL_37:
        HDLCFrameFree();
        HDLCFrameFree();
        if ((v33 & 1) != 0)
          break;
        if (v11 >= 2)
        {
          TelephonyUtilRingBufferReset();
          v46 = (void (*)(_QWORD *))a1[3];
          if (v46)
            v46(a1);
          _ETLDebugPrint((uint64_t)"ETLMESSAGEGetSubsystemMasksWithRetry", (uint64_t)"Trying again\n", v40, v41, v42, v43, v44, v45, v52);
        }
        if (!--v11)
          goto LABEL_67;
      }
      if ((_DWORD)v28)
      {
        *v8 += (_DWORD)v28;
        a5 = (uint64_t)__dst + 4 * v28;
        a4 = v59 - v28;
        v10 -= v28;
        LOWORD(v9) = v61 + (_WORD)v28;
        v61 = v9;
        v11 = v56;
        if (a2[1] >= (unsigned __int16)v9)
          continue;
      }
      return 1;
    }
  }
  if (v10 >= 0x3D)
    v51 = 61;
  else
    v51 = v10;
  _ETLDebugPrint((uint64_t)"ETLMESSAGEGetSubsystemMasksWithRetry", (uint64_t)"Partition Range to 0x%08X, max 0x%x\n", a3, a4, a5, (uint64_t)a6, a7, a8, (v9 | ((v9 + v51) << 16)) - 0x10000);
LABEL_67:
  result = 0;
  *v8 = 0;
  return result;
}

uint64_t ETLMESSAGESetSubsystemRuntimeMasksWithRetry(_QWORD *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unsigned int v9;
  unsigned int v10;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(_QWORD *);
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  uint64_t result;
  uint64_t v37;
  int v38;
  int v39;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  unsigned __int16 v46;
  unsigned __int16 v47;
  _OWORD v48[2];
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  _DWORD v53[3];

  v8 = *a2;
  v9 = a2[1] - v8 + 1;
  v46 = *a2;
  if (!(_DWORD)a5)
  {
    if (v9 >= 0x3D)
      v9 = 61;
    _ETLDebugPrint((uint64_t)"ETLMESSAGESetSubsystemRuntimeMasksWithRetry", (uint64_t)"Partition Range to 0x%08X, max 0x%x\n", a3, a4, a5, a6, a7, a8, (v8 | ((v8 + v9) << 16)) - 0x10000);
    return 0;
  }
  v10 = a5;
  v45 = a3;
  v44 = a4;
  v41 = a5;
  do
  {
    if (v9 >= 0x3D)
      v12 = 61;
    else
      v12 = v9;
    v42 = v9;
    v43 = v12;
    v47 = v8 + v12 - 1;
    _ETLDebugPrint((uint64_t)"ETLMESSAGESetSubsystemRuntimeMasksWithRetry", (uint64_t)"Partition Range to 0x%08X, max 0x%x\n", a3, a4, a5, a6, a7, a8, (unsigned __int16)v8 | (v47 << 16));
    while (1)
    {
      v50 = 0u;
      v51 = 0u;
      v52 = 0;
      memset(v48, 0, sizeof(v48));
      v49 = 0;
      if (HDLCFrameCreateUplink())
      {
        LOWORD(v53[0]) = 1149;
        if (HDLCFrameGetFreeSpace() <= 1)
        {
          v37 = 2;
          goto LABEL_15;
        }
        if (HDLCFrameInject())
        {
          v19 = 4 * (v47 - v46 + 1);
          if (HDLCFrameGetFreeSpace() < v19 + 4)
          {
            v37 = (v19 + 4);
LABEL_15:
            v20 = "ETLRequireFreeSpace";
            v21 = "Need %u bytes free space, but only have %u\n";
LABEL_16:
            _ETLDebugPrint((uint64_t)v20, (uint64_t)v21, v13, v14, v15, v16, v17, v18, v37);
            goto LABEL_17;
          }
          if (!HDLCFrameInject())
            goto LABEL_17;
          if (!HDLCFrameInjectUnsignedShort())
            goto LABEL_17;
          if (!HDLCFrameInject())
            goto LABEL_17;
          v29 = malloc((2 * DWORD2(v50) + 32));
          if (!v29)
            goto LABEL_17;
          v30 = v29;
          v31 = HDLCFrameEncode();
          if (!(_DWORD)v31)
            goto LABEL_38;
          v32 = v31;
          v53[0] = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v30, v31);
          if (!*a1)
          {
LABEL_38:
            free(v30);
            goto LABEL_17;
          }
          v33 = ((uint64_t (*)(_QWORD *, void *, uint64_t, _DWORD *, uint64_t, _QWORD, _QWORD))*a1)(a1, v30, v32, v53, 1, v44, 0);
          v38 = v53[0];
          v39 = v33;
          free(v30);
          if (!v39 || v38 != (_DWORD)v32)
            goto LABEL_17;
          LOBYTE(v53[0]) = 125;
          if (!_ETLResponseRingBuffer)
            TelephonyUtilRingBufferInitialize();
          if ((ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v48, (uint64_t)&_ETLResponseRingBuffer, v53, v44) & 1) == 0)
          {
            v20 = "ETLMESSAGEFindMatchingResponse";
            v21 = "Failed to find matching response\n";
            goto LABEL_16;
          }
          if (DWORD2(v48[0]) >= 2)
          {
            if (*(_BYTE *)(*(_QWORD *)&v48[0] + 1) != 4)
            {
              _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetSubsystemRunTimeMasksResponse", (uint64_t)"Response subcommand 0x%x mismatches expected 0x%x\n", v13, v14, v15, v16, v17, v18, *(unsigned __int8 *)(*(_QWORD *)&v48[0] + 1));
              goto LABEL_17;
            }
            if ((DWORD2(v48[0]) - 8) <= 0xFFFFFFF9)
              break;
          }
        }
      }
LABEL_17:
      HDLCFrameFree();
      HDLCFrameFree();
      if (v10 >= 2)
      {
        TelephonyUtilRingBufferReset();
        v28 = (void (*)(_QWORD *))a1[3];
        if (v28)
          v28(a1);
        _ETLDebugPrint((uint64_t)"ETLMESSAGESetSubsystemRuntimeMasksWithRetry", (uint64_t)"Trying again\n", v22, v23, v24, v25, v26, v27, v37);
      }
      if (!--v10)
        return 0;
    }
    if (*(_BYTE *)(*(_QWORD *)&v48[0] + 6) != 1)
    {
      _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetSubsystemRunTimeMasksResponse", (uint64_t)"Status was %u\n", v13, v14, v15, v16, v17, v18, *(unsigned __int8 *)(*(_QWORD *)&v48[0] + 6));
      goto LABEL_17;
    }
    v34 = *(unsigned __int16 *)(*(_QWORD *)&v48[0] + 2);
    v35 = *(unsigned __int16 *)(*(_QWORD *)&v48[0] + 4);
    if (v47 != v35 || v46 != v34)
      _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetSubsystemRunTimeMasksResponse", (uint64_t)"Returned range 0x%x didn't match requested 0x%x\n", v13, v14, v15, v16, v17, v18, v34 | (v35 << 16));
    HDLCFrameFree();
    HDLCFrameFree();
    if (!v43)
      return 1;
    v45 += 4 * v43;
    v9 = v42 - v43;
    LOWORD(v8) = v46 + v43;
    v46 = v8;
    result = 1;
    v10 = v41;
  }
  while (a2[1] >= (unsigned __int16)v8);
  return result;
}

uint64_t ETLMESSAGESetAllSubsystemRunTimeMasks(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  const char *v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  _OWORD v29[2];
  uint64_t v30;
  _OWORD v31[2];
  uint64_t v32;
  __int16 v33;

  _ETLDebugPrint((uint64_t)"ETLMESSAGESetAllSubsystemRunTimeMasks", (uint64_t)"to 0x%x\n", a3, a4, a5, a6, a7, a8, a2);
  memset(v31, 0, sizeof(v31));
  v32 = 0;
  memset(v29, 0, sizeof(v29));
  v30 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_11;
  v33 = 1405;
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v24 = 2;
LABEL_9:
    v28 = v24;
    v25 = "ETLRequireFreeSpace";
    v26 = "Need %u bytes free space, but only have %u\n";
LABEL_10:
    _ETLDebugPrint((uint64_t)v25, (uint64_t)v26, v11, v12, v13, v14, v15, v16, v28);
    goto LABEL_11;
  }
  if (!HDLCFrameInject())
    goto LABEL_11;
  if (HDLCFrameGetFreeSpace() <= 5)
  {
    v24 = 6;
    goto LABEL_9;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
    HDLCFrameFree();
    HDLCFrameFree();
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMESSAGESetAllSubsystemRunTimeMasks", (uint64_t)"Failed to set masks to 0x%x\n", v17, v18, v19, v20, v21, v22, a2);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedInt() || !ETLSendCommand(a1, (uint64_t)v31, a3))
    goto LABEL_11;
  LOBYTE(v33) = 125;
  if ((ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v29, &v33, a3) & 1) == 0)
  {
    v25 = "ETLMESSAGEFindMatchingResponse";
    v26 = "Failed to find matching response\n";
    goto LABEL_10;
  }
  if (DWORD2(v29[0]) < 2)
    goto LABEL_11;
  if (*(_BYTE *)(*(_QWORD *)&v29[0] + 1) != 5)
  {
    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetAllSubsystemRunTimeMasksResponse", (uint64_t)"Response subcommand 0x%x mismatches expected 0x%x\n", v11, v12, v13, v14, v15, v16, *(unsigned __int8 *)(*(_QWORD *)&v29[0] + 1));
    goto LABEL_11;
  }
  if ((DWORD2(v29[0]) - 8) > 0xFFFFFFF9)
  {
LABEL_11:
    HDLCFrameFree();
    HDLCFrameFree();
    goto LABEL_12;
  }
  if (*(_BYTE *)(*(_QWORD *)&v29[0] + 2) != 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetAllSubsystemRunTimeMasksResponse", (uint64_t)"Status was %u\n", v11, v12, v13, v14, v15, v16, *(unsigned __int8 *)(*(_QWORD *)&v29[0] + 2));
    goto LABEL_11;
  }
  v27 = *(unsigned int *)(*(_QWORD *)&v29[0] + 4);
  if ((_DWORD)v27 != (_DWORD)a2)
    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetAllSubsystemRunTimeMasksResponse", (uint64_t)"Returned mask %u doesn't match requested %u\n", v11, v12, v13, v14, v15, v16, v27);
  HDLCFrameFree();
  HDLCFrameFree();
  return 1;
}

uint64_t ETLMESSAGESetFlags(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  uint64_t v24;
  _OWORD v25[2];
  uint64_t v26;
  _OWORD v27[2];
  uint64_t v28;
  __int16 v29;

  *a4 = 0;
  _ETLDebugPrint((uint64_t)"ETLMESSAGESetFlags", (uint64_t)"Setting enabled to 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, a2);
  v28 = 0;
  memset(v27, 0, sizeof(v27));
  memset(v25, 0, sizeof(v25));
  v26 = 0;
  v12 = 0;
  if (!HDLCFrameCreateUplink())
    goto LABEL_20;
  v29 = 1661;
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    v20 = 2;
LABEL_17:
    v24 = v20;
    v21 = "ETLRequireFreeSpace";
    v22 = "Need %u bytes free space, but only have %u\n";
LABEL_18:
    _ETLDebugPrint((uint64_t)v21, (uint64_t)v22, v13, v14, v15, v16, v17, v18, v24);
    goto LABEL_19;
  }
  if (!HDLCFrameInject())
    goto LABEL_19;
  if (HDLCFrameGetFreeSpace() <= 5)
  {
    v20 = 6;
    goto LABEL_17;
  }
  v12 = 0;
  if (!HDLCFrameInjectUnsignedShort())
    goto LABEL_20;
  if (!HDLCFrameInjectUnsignedInt() || !ETLSendCommand(a1, (uint64_t)v27, a5))
    goto LABEL_19;
  LOBYTE(v29) = 125;
  if ((ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v25, &v29, a5) & 1) == 0)
  {
    v21 = "ETLMESSAGEFindMatchingResponse";
    v22 = "Failed to find matching response\n";
    goto LABEL_18;
  }
  v12 = 0;
  *a4 = 0;
  v19 = DWORD2(v25[0]);
  if (DWORD2(v25[0]) < 2)
    goto LABEL_20;
  if (*(_BYTE *)(*(_QWORD *)&v25[0] + 1) != 6)
  {
    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetFlagsResponse", (uint64_t)"Response subcommand 0x%x mismatches expected 0x%x\n", v13, v14, v15, v16, v17, v18, *(unsigned __int8 *)(*(_QWORD *)&v25[0] + 1));
    goto LABEL_19;
  }
  if ((DWORD2(v25[0]) - 8) > 0xFFFFFFF9)
  {
LABEL_19:
    v12 = 0;
    goto LABEL_20;
  }
  if (*(_BYTE *)(*(_QWORD *)&v25[0] + 2) != 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetFlagsResponse", (uint64_t)"Status was %u\n", v13, v14, v15, v16, v17, v18, *(unsigned __int8 *)(*(_QWORD *)&v25[0] + 2));
    goto LABEL_19;
  }
  *a3 = *(_DWORD *)(*(_QWORD *)&v25[0] + 4);
  if ((v19 - 12) <= 0xFFFFFFFB)
    *a4 = 0;
  v12 = 1;
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v12;
}

uint64_t ETLMESSAGESetEnabled(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t result;
  int v10;
  int v11;

  v8 = a2;
  v11 = 0;
  LODWORD(result) = ETLMESSAGESetFlags(a1, a2, &v11, &v10, a3, a6, a7, a8);
  if (v11 == v8)
    return result;
  else
    return 0;
}

uint64_t APPLIB_DIAG_GetRevision(_WORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = 30720;
    *((_BYTE *)a1 + 2) = -16;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2129688576;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t DetectAndFixSpecialCharacters(unsigned __int8 *a1, int a2, int a3)
{
  uint64_t result;
  int v6;
  unsigned __int8 *v7;
  uint64_t v8;
  char v9;
  int v10;
  _BYTE __src[2048];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a3 <= 1024 && 2 * a3 <= a2)
  {
    bzero(__src, 0x800uLL);
    if (a3 < 1)
    {
      v6 = 0;
    }
    else
    {
      v6 = 0;
      v7 = a1;
      v8 = a3;
      do
      {
        v10 = *v7++;
        v9 = v10;
        if ((v10 - 125) <= 1)
        {
          __src[v6] = 125;
          v9 ^= 0x20u;
          ++v6;
        }
        __src[v6++] = v9;
        --v8;
      }
      while (v8);
    }
    memcpy(a1, __src, v6);
    result = (v6 + 1);
    a1[v6] = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_PingBaseBand(_WORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = 11387;
    *((_BYTE *)a1 + 2) = 61;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2117938299;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetBaseBandRevision(_WORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = -27780;
    *((_BYTE *)a1 + 2) = 73;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2118751100;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_SetDownloadMode(_WORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = -24262;
    *((_BYTE *)a1 + 2) = 110;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2121179450;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_NvItemRead(char *a1, int a2, __int16 a3)
{
  uint64_t result;
  int v5;
  int v6;
  char *v7;
  char v8;
  uint64_t v9;
  size_t v10;
  int v11;
  int v12;
  _BYTE __src[2048];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 140)
  {
    *(_OWORD *)(a1 + 124) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *a1 = 38;
    *(_WORD *)(a1 + 1) = a3;
    v5 = 1064;
    LOWORD(v6) = -1;
    v7 = a1;
    do
    {
      v8 = *v7++;
      v6 = crc_16_l_table[(v8 ^ v6)] ^ ((unsigned __int16)(v6 & 0xFF00) >> 8);
      v5 -= 8;
    }
    while ((_WORD)v5);
    *(_WORD *)(a1 + 133) = ~(_WORD)v6;
    if (a2 >= 0x10E)
    {
      bzero(__src, 0x800uLL);
      v9 = 0;
      LODWORD(v10) = 0;
      do
      {
        while (1)
        {
          v12 = a1[v9];
          if ((v12 - 125) > 1)
            break;
          v11 = v10 + 1;
          __src[(int)v10] = 125;
          __src[(int)v10 + 1] = v12 ^ 0x20;
          v10 = (int)v10 + 1 + 1;
          if (++v9 == 135)
            goto LABEL_11;
        }
        v11 = v10;
        __src[(int)v10] = v12;
        v10 = (int)v10 + 1;
        ++v9;
      }
      while (v9 != 135);
LABEL_11:
      memcpy(a1, __src, v10);
      result = (v11 + 2);
      a1[v10] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_NvItemWrite(char *a1, int a2, __int16 a3, void *__src, int a5)
{
  uint64_t result;
  int v8;
  int v9;
  char *v10;
  char v11;
  uint64_t v12;
  size_t v13;
  int v14;
  int v15;
  _BYTE __srca[2048];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 140 && __src && a5 <= 128)
  {
    *(_OWORD *)(a1 + 124) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *a1 = 39;
    *(_WORD *)(a1 + 1) = a3;
    memcpy(a1 + 3, __src, a5);
    v8 = 1064;
    LOWORD(v9) = -1;
    v10 = a1;
    do
    {
      v11 = *v10++;
      v9 = crc_16_l_table[(v11 ^ v9)] ^ ((unsigned __int16)(v9 & 0xFF00) >> 8);
      v8 -= 8;
    }
    while ((_WORD)v8);
    *(_WORD *)(a1 + 133) = ~(_WORD)v9;
    if (a2 >= 0x10E)
    {
      bzero(__srca, 0x800uLL);
      v12 = 0;
      LODWORD(v13) = 0;
      do
      {
        while (1)
        {
          v15 = a1[v12];
          if ((v15 - 125) > 1)
            break;
          v14 = v13 + 1;
          __srca[(int)v13] = 125;
          __srca[(int)v13 + 1] = v15 ^ 0x20;
          v13 = (int)v13 + 1 + 1;
          if (++v12 == 135)
            goto LABEL_13;
        }
        v14 = v13;
        __srca[(int)v13] = v15;
        v13 = (int)v13 + 1;
        ++v12;
      }
      while (v12 != 135);
LABEL_13:
      memcpy(a1, __srca, v13);
      result = (v14 + 2);
      a1[v13] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTMNvItemRead(char *a1, int a2, unsigned int a3)
{
  uint64_t result;
  unsigned __int16 v5;
  unsigned __int16 v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t __src;
  __int16 v21;
  char v22[2038];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2 >= 19)
    {
      *(_QWORD *)a1 = 0;
      *((_QWORD *)a1 + 1) = 0;
      *(_DWORD *)(a1 + 15) = 0;
      *(_WORD *)a1 = 2891;
      *(_QWORD *)(a1 + 2) = 0x900000025C0024;
      *((_WORD *)a1 + 5) = a3;
      v5 = crc_16_l_table[a1[7] ^ 0x5FLL];
      v6 = crc_16_l_table[a1[8] ^ 0xB7 ^ v5];
      v7 = crc_16_l_table[(a1[9] ^ v6 ^ HIBYTE(v5))];
      v8 = crc_16_l_table[(v7 ^ HIBYTE(v6) ^ a3)];
      v9 = a3 >> 8;
      v10 = crc_16_l_table[(a3 >> 8) ^ crc_16_l_table[(v7 ^ HIBYTE(v6) ^ a3)] ^ (v7 >> 8)];
      v11 = v10 ^ ~(v8 >> 8);
      *((_WORD *)a1 + 6) = v10 ^ ~(unsigned __int16)(v8 >> 8);
      if (a2 >= 0x1C)
      {
        v12 = a3;
        v13 = v10 ^ (v8 >> 8);
        bzero(v22, 0x7F6uLL);
        __src = 0x25C00240B4BLL;
        v21 = 144;
        if ((v12 - 125) > 1)
        {
          v14 = 10;
        }
        else
        {
          v22[0] = 125;
          LOBYTE(v12) = v12 ^ 0x20;
          v14 = 11;
        }
        v15 = ~(_BYTE)v13;
        *((_BYTE *)&__src + v14) = v12;
        v16 = v14 + 1;
        if (v9 - 125 <= 1)
        {
          *((_BYTE *)&__src + v16) = 125;
          LOBYTE(v9) = v9 ^ 0x20;
          LODWORD(v16) = v14 + 2;
        }
        v17 = BYTE1(v11);
        *((_BYTE *)&__src + v16) = v9;
        v18 = v16 + 1;
        if ((v15 - 125) <= 1)
        {
          *((_BYTE *)&__src + v18) = 125;
          LOBYTE(v15) = v15 ^ 0x20;
          LODWORD(v18) = v16 + 2;
        }
        *((_BYTE *)&__src + v18) = v15;
        v19 = v18 + 1;
        if ((v17 - 125) <= 1)
        {
          *((_BYTE *)&__src + v19) = 125;
          LOBYTE(v17) = v17 ^ 0x20;
          LODWORD(v19) = v18 + 2;
        }
        *((_BYTE *)&__src + v19) = v17;
        memcpy(a1, &__src, v19 + 1);
        result = (v19 + 2);
        a1[v19 + 1] = 126;
      }
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTMNvItemWrite(_QWORD *a1, int a2, __int16 a3, void *__src, int a5)
{
  uint64_t result;
  int v10;
  int v11;
  char *v12;
  char v13;
  char v14;
  char v15;
  uint64_t v16;
  int v17;
  unsigned __int8 *v18;
  char v19;
  int v20;
  _BYTE __srca[2048];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 - a5 >= 21)
  {
    *a1 = 0;
    a1[1] = 0;
    *(_QWORD *)((char *)a1 + 13) = 0;
    *(_WORD *)a1 = 2891;
    *(_QWORD *)((char *)a1 + 2) = 0xE0000025D0024;
    *((_WORD *)a1 + 5) = a3;
    *((_WORD *)a1 + 6) = a5;
    memcpy((char *)a1 + 14, __src, a5);
    v10 = 8 * (a5 + 14);
    if (8 * ((_WORD)a5 + 14))
    {
      LOWORD(v11) = -1;
      v12 = (char *)a1;
      do
      {
        v13 = *v12++;
        v11 = crc_16_l_table[(v13 ^ v11)] ^ ((unsigned __int16)(v11 & 0xFF00) >> 8);
        v10 -= 8;
      }
      while ((_WORD)v10);
      v14 = ~(_BYTE)v11;
      v15 = (unsigned __int16)~(_WORD)v11 >> 8;
    }
    else
    {
      v14 = 0;
      v15 = 0;
    }
    *((_BYTE *)a1 + a5 + 14) = v14;
    *((_BYTE *)a1 + a5 + 15) = v15;
    v16 = (a5 + 16);
    result = 0xFFFFFFFFLL;
    if ((int)v16 <= 1024 && 2 * (int)v16 <= a2)
    {
      bzero(__srca, 0x800uLL);
      if ((int)v16 < 1)
      {
        v17 = 0;
      }
      else
      {
        v17 = 0;
        v18 = (unsigned __int8 *)a1;
        do
        {
          v20 = *v18++;
          v19 = v20;
          if ((v20 - 125) <= 1)
          {
            __srca[v17] = 125;
            v19 ^= 0x20u;
            ++v17;
          }
          __srca[v17++] = v19;
          --v16;
        }
        while (v16);
      }
      memcpy(a1, __srca, v17);
      result = (v17 + 1);
      *((_BYTE *)a1 + v17) = 126;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ModeChange(_WORD *a1, int a2, unsigned int a3)
{
  uint64_t result;
  int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char __src;
  char v18[2047];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 10)
  {
    *(_QWORD *)a1 = 0;
    a1[4] = 0;
    *(_BYTE *)a1 = 41;
    v5 = a3;
    *((_BYTE *)a1 + 1) = a3;
    v6 = a3 >> 8;
    *((_BYTE *)a1 + 2) = BYTE1(a3);
    v7 = crc_16_l_table[a3 ^ 0x44];
    v8 = crc_16_l_table[crc_16_l_table[a3 ^ 0x44] ^ (a3 >> 8) ^ 0xB3];
    v9 = v8 ^ (v7 >> 8);
    v10 = v8 ^ ~(v7 >> 8);
    *((_BYTE *)a1 + 3) = v10;
    v11 = BYTE1(v10);
    *((_BYTE *)a1 + 4) = BYTE1(v10);
    bzero(v18, 0x7FFuLL);
    __src = 41;
    if ((v5 - 125) > 1)
    {
      v12 = 1;
    }
    else
    {
      v18[0] = 125;
      LOBYTE(v5) = v5 ^ 0x20;
      v12 = 2;
    }
    v13 = ~(_BYTE)v9;
    v18[v12 - 1] = v5;
    v14 = v12 + 1;
    if (v6 - 125 <= 1)
    {
      v18[v14 - 1] = 125;
      LODWORD(v14) = v12 + 2;
      LOBYTE(v6) = v6 ^ 0x20;
    }
    v18[v14 - 1] = v6;
    v15 = v14 + 1;
    if ((v13 - 125) <= 1)
    {
      v18[v15 - 1] = 125;
      LOBYTE(v13) = v13 ^ 0x20;
      LODWORD(v15) = v14 + 2;
    }
    v18[v15 - 1] = v13;
    v16 = v15 + 1;
    if ((v11 - 125) <= 1)
    {
      v18[v16 - 1] = 125;
      LOBYTE(v11) = v11 ^ 0x20;
      LODWORD(v16) = v15 + 2;
    }
    v18[v16 - 1] = v11;
    memcpy(a1, &__src, v16 + 1);
    result = (v16 + 2);
    *((_BYTE *)a1 + v16 + 1) = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_GetStatus(_WORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = 5132;
    *((_BYTE *)a1 + 2) = 58;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2117735436;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetDeviceID(_DWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 65099;
    *((_WORD *)a1 + 2) = -18861;
    if (a2 >= 0xC)
    {
      *a1 = 65099;
      *((_WORD *)a1 + 2) = -18861;
      *((_BYTE *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_DetectSim(_DWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 130635;
    *((_WORD *)a1 + 2) = -20597;
    if (a2 >= 0xC)
    {
      *a1 = 130635;
      *((_WORD *)a1 + 2) = -20597;
      *((_BYTE *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t DetectAndStripSpecialCharacters(_BYTE *a1, int a2, int a3)
{
  uint64_t v3;
  int v6;
  uint64_t v7;
  int v8;
  _BYTE __src[2048];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = 0xFFFFFFFFLL;
  if (a3 <= 2048 && a3 <= a2)
  {
    bzero(__src, 0x800uLL);
    if (a3 < 1)
    {
      v3 = 0;
    }
    else
    {
      v3 = 0;
      v6 = 0;
      do
      {
        v7 = v6;
        v8 = a1[v6];
        if (v8 == 125)
        {
          ++v6;
          LOBYTE(v8) = a1[v7 + 1] ^ 0x20;
        }
        __src[v3++] = v8;
        ++v6;
      }
      while (v6 < a3);
    }
    bzero(a1, a3);
    memcpy(a1, __src, v3);
  }
  return v3;
}

uint64_t APPLIB_DIAG_SendRawRequest(char *a1, int a2, const void *a3, int a4)
{
  uint64_t result;
  int v9;
  int v10;
  char *v11;
  char v12;
  char *v13;
  uint64_t v14;
  int v15;
  unsigned __int8 *v16;
  char v17;
  int v18;
  _BYTE __src[2048];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0xFFFFFFFFLL;
  result = 0xFFFFFFFFLL;
  if (a3 && a4 + 7 <= a2)
  {
    bzero(a1, a4 + 7);
    memcpy(a1, a3, a4);
    v9 = 8 * a4;
    if (((8 * a4) & 0xFFF8) != 0)
    {
      LOWORD(v10) = -1;
      v11 = a1;
      do
      {
        v12 = *v11++;
        v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
        v9 -= 8;
      }
      while ((_WORD)v9);
      *(_WORD *)&a1[a4] = ~(_WORD)v10;
      result = 0xFFFFFFFFLL;
      if (a4 > 1022)
        return result;
    }
    else
    {
      v13 = &a1[a4];
      *v13 = 0;
      v13[1] = 0;
      result = 0xFFFFFFFFLL;
      if (a4 > 1022)
        return result;
    }
    v14 = (a4 + 2);
    if (2 * (int)v14 <= a2)
    {
      bzero(__src, 0x800uLL);
      if (a4 < -1)
      {
        v15 = 0;
      }
      else
      {
        v15 = 0;
        v16 = (unsigned __int8 *)a1;
        do
        {
          v18 = *v16++;
          v17 = v18;
          if ((v18 - 125) <= 1)
          {
            __src[v15] = 125;
            v17 ^= 0x20u;
            ++v15;
          }
          __src[v15++] = v17;
          --v14;
        }
        while (v14);
      }
      memcpy(a1, __src, v15);
      result = (v15 + 1);
      a1[v15] = 126;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_SetOneRx(_DWORD *a1, int a2, __int16 a3)
{
  uint64_t result;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int __src;
  char v20[2044];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 9)
  {
    bzero(a1, a2);
    *a1 = 195915;
    v7 = a3;
    *((_WORD *)a1 + 2) = a3;
    v8 = HIBYTE(a3);
    v9 = crc_16_l_table[a3 ^ 0x78];
    v10 = crc_16_l_table[crc_16_l_table[a3 ^ 0x78] ^ HIBYTE(a3) ^ 0x95];
    v11 = v10 ^ ~(v9 >> 8);
    *((_BYTE *)a1 + 6) = v10 ^ ~(v9 >> 8);
    v12 = BYTE1(v11);
    *((_BYTE *)a1 + 7) = BYTE1(v11);
    if (a2 >= 0x10)
    {
      v13 = v10 ^ (v9 >> 8);
      bzero(v20, 0x7FCuLL);
      __src = 195915;
      if ((v7 - 125) > 1)
      {
        v14 = 4;
      }
      else
      {
        v20[0] = 125;
        LOBYTE(v7) = v7 ^ 0x20;
        v14 = 5;
      }
      v15 = ~(_BYTE)v13;
      v20[v14 - 4] = v7;
      v16 = v14 + 1;
      if ((v8 - 125) <= 1)
      {
        v20[v16 - 4] = 125;
        LODWORD(v16) = v14 | 2;
        LOBYTE(v8) = v8 ^ 0x20;
      }
      v20[v16 - 4] = v8;
      v17 = v16 + 1;
      if ((v15 - 125) <= 1)
      {
        v20[v17 - 4] = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v17) = v16 + 2;
      }
      v20[v17 - 4] = v15;
      v18 = v17 + 1;
      if ((v12 - 125) <= 1)
      {
        v20[v18 - 4] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v18) = v17 + 2;
      }
      v20[v18 - 4] = v12;
      memcpy(a1, &__src, v18 + 1);
      result = (v18 + 2);
      *((_BYTE *)a1 + v18 + 1) = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_Get_RSSI_Channel(_DWORD *a1, int a2, __int16 a3)
{
  uint64_t result;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int __src;
  char v20[2044];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 9)
  {
    bzero(a1, a2);
    *a1 = 261451;
    v7 = a3;
    *((_WORD *)a1 + 2) = a3;
    v8 = HIBYTE(a3);
    v9 = crc_16_l_table[a3 ^ 0xA0];
    v10 = crc_16_l_table[crc_16_l_table[a3 ^ 0xA0] ^ HIBYTE(a3) ^ 0x8C];
    v11 = v10 ^ ~(v9 >> 8);
    *((_BYTE *)a1 + 6) = v10 ^ ~(v9 >> 8);
    v12 = BYTE1(v11);
    *((_BYTE *)a1 + 7) = BYTE1(v11);
    if (a2 >= 0x10)
    {
      v13 = v10 ^ (v9 >> 8);
      bzero(v20, 0x7FCuLL);
      __src = 261451;
      if ((v7 - 125) > 1)
      {
        v14 = 4;
      }
      else
      {
        v20[0] = 125;
        LOBYTE(v7) = v7 ^ 0x20;
        v14 = 5;
      }
      v15 = ~(_BYTE)v13;
      v20[v14 - 4] = v7;
      v16 = v14 + 1;
      if ((v8 - 125) <= 1)
      {
        v20[v16 - 4] = 125;
        LODWORD(v16) = v14 | 2;
        LOBYTE(v8) = v8 ^ 0x20;
      }
      v20[v16 - 4] = v8;
      v17 = v16 + 1;
      if ((v15 - 125) <= 1)
      {
        v20[v17 - 4] = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v17) = v16 + 2;
      }
      v20[v17 - 4] = v15;
      v18 = v17 + 1;
      if ((v12 - 125) <= 1)
      {
        v20[v18 - 4] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v18) = v17 + 2;
      }
      v20[v18 - 4] = v12;
      memcpy(a1, &__src, v18 + 1);
      result = (v18 + 2);
      *((_BYTE *)a1 + v18 + 1) = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_Get_OneRxConfig(_DWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 7)
  {
    bzero(a1, a2);
    *a1 = 326987;
    *((_WORD *)a1 + 2) = 15959;
    if (a2 >= 0xC)
    {
      *a1 = 326987;
      *((_WORD *)a1 + 2) = 15959;
      *((_BYTE *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_Release_BB_RESET_DET_N(_DWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 523595;
    *((_WORD *)a1 + 2) = 5183;
    if (a2 >= 0xC)
    {
      *a1 = 523595;
      *((_WORD *)a1 + 2) = 5183;
      *((_BYTE *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_PowerDown_BaseBand(_DWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 654667;
    *((_WORD *)a1 + 2) = -29137;
    if (a2 >= 0xC)
    {
      *a1 = 654667;
      *((_WORD *)a1 + 2) = -29137;
      *((_BYTE *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_EDLOAD(_DWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 982347;
    *((_WORD *)a1 + 2) = -15577;
    if (a2 >= 0xC)
    {
      *a1 = 982347;
      *((_WORD *)a1 + 2) = -15577;
      *((_BYTE *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t ETLNVCreateReadCommand()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  if (HDLCFrameGetFreeSpace() <= 0x84)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 133);
    return 0;
  }
  else
  {
    HDLCFrameInjectUnsignedChar();
    result = HDLCFrameInjectUnsignedShort();
    if ((_DWORD)result)
    {
      HDLCFrameInject();
      return HDLCFrameInjectUnsignedShort();
    }
  }
  return result;
}

uint64_t ETLNVParseReadResponse(_DWORD *a1, int a2, _DWORD *a3, _OWORD *a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v8 = a1[2];
  *a6 = 0;
  if (v8 <= 0x84)
  {
    _ETLDebugPrint((uint64_t)"ETLNVParseReadResponse", (uint64_t)"Response size %u not enough, need %u\n", (uint64_t)a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8, 133);
    return 0;
  }
  else
  {
    v9 = *(_QWORD *)a1;
    if (*(unsigned __int16 *)(*(_QWORD *)a1 + 1) == a2)
    {
      if (a5 <= 0x7F)
      {
        _ETLDebugPrint((uint64_t)"ETLNVParseReadResponse", (uint64_t)"Provided buffer has capacity %u, need %u\n", (uint64_t)a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8, a5);
        return 0;
      }
      else
      {
        v10 = *(_OWORD *)(v9 + 3);
        v11 = *(_OWORD *)(v9 + 19);
        v12 = *(_OWORD *)(v9 + 51);
        a4[2] = *(_OWORD *)(v9 + 35);
        a4[3] = v12;
        *a4 = v10;
        a4[1] = v11;
        v13 = *(_OWORD *)(v9 + 67);
        v14 = *(_OWORD *)(v9 + 83);
        v15 = *(_OWORD *)(v9 + 115);
        a4[6] = *(_OWORD *)(v9 + 99);
        a4[7] = v15;
        a4[4] = v13;
        a4[5] = v14;
        *a6 = 128;
        v16 = *(unsigned __int16 *)(v9 + 131);
        if ((_DWORD)v16)
        {
          if ((_DWORD)v16 == 5)
          {
            *a3 = 5;
            return 1;
          }
          else
          {
            *a3 = v16;
            _ETLDebugPrint((uint64_t)"ETLNVParseReadResponse", (uint64_t)"Return code was %u\n", (uint64_t)a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8, v16);
            return 0;
          }
        }
        else
        {
          *a3 = 0;
          return 1;
        }
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLNVParseReadResponse", (uint64_t)"Returned item number %u mismatches expected %u\n", (uint64_t)a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8, *(unsigned __int16 *)(*(_QWORD *)a1 + 1));
      return 0;
    }
  }
}

uint64_t ETLNVCreateWriteCommand(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  if (a4 > 0x80)
    return 0;
  if (HDLCFrameGetFreeSpace() <= 0x87)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v4, v5, v6, v7, v8, v9, 136);
    return 0;
  }
  else
  {
    HDLCFrameInjectUnsignedChar();
    HDLCFrameInjectUnsignedShort();
    result = HDLCFrameInject();
    if ((_DWORD)result)
    {
      HDLCFrameInject();
      return HDLCFrameInjectUnsignedShort();
    }
  }
  return result;
}

uint64_t ETLNVParseWriteResponseWithStatus(_DWORD *a1, int a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;

  if (a1[2] <= 2u)
  {
    _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Response size %u not enough, need %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 3);
    return 0;
  }
  else
  {
    v9 = *(_QWORD *)a1;
    if (*(unsigned __int16 *)(*(_QWORD *)a1 + 1) != a2)
      _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Returned item number %u mismatches expected %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(_QWORD *)a1 + 1));
    v10 = *(unsigned __int16 *)(v9 + 131);
    *a3 = v10;
    if ((_DWORD)v10)
    {
      _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"NV write response indicates failure with status code %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
    else
    {
      return 1;
    }
  }
}

uint64_t ETLNVParseWriteResponse(_DWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (a1[2] <= 2u)
  {
    _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Response size %u not enough, need %u\n", a3, a4, a5, a6, a7, a8, 3);
    return 0;
  }
  else
  {
    v8 = *(_QWORD *)a1;
    if (*(unsigned __int16 *)(*(_QWORD *)a1 + 1) != a2)
      _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Returned item number %u mismatches expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(_QWORD *)a1 + 1));
    if (*(_WORD *)(v8 + 131))
    {
      _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"NV write response indicates failure with status code %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(v8 + 131));
      return 0;
    }
    else
    {
      return 1;
    }
  }
}

void *ETLNVRead(uint64_t (**a1)(_QWORD, void *, uint64_t, _OWORD *, uint64_t, uint64_t, _QWORD), int a2, _OWORD *a3, uint64_t a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  void *Response;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  const char *v27;
  uint64_t v29;
  int v30;
  _OWORD v31[2];
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  _OWORD v36[8];
  uint64_t v37;

  Response = 0;
  v37 = *MEMORY[0x1E0C80C00];
  if (a1 && a3 && a6)
  {
    v33 = 0u;
    v34 = 0u;
    v35 = 0;
    memset(v31, 0, sizeof(v31));
    v32 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      if (HDLCFrameGetFreeSpace() > 0x84)
      {
        HDLCFrameInjectUnsignedChar();
        if (HDLCFrameInjectUnsignedShort())
        {
          memset(v36, 0, sizeof(v36));
          HDLCFrameInject();
          Response = 0;
          if (!HDLCFrameInjectUnsignedShort())
            goto LABEL_21;
          Response = malloc((2 * DWORD2(v33) + 32));
          if (!Response)
            goto LABEL_21;
          v21 = HDLCFrameEncode();
          if (!(_DWORD)v21)
            goto LABEL_23;
          v22 = v21;
          LODWORD(v36[0]) = -1431655766;
          if ((_ETLDebugFlags & 2) != 0)
            ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, Response, v21);
          if (*a1)
          {
            v23 = (*a1)(a1, Response, v22, v36, 1, a7, 0);
            v30 = v36[0];
            free(Response);
            Response = 0;
            if (!v23 || v30 != (_DWORD)v22)
              goto LABEL_21;
            LOBYTE(v36[0]) = 38;
            if (ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v31, v36, a7))
            {
              Response = (void *)ETLNVParseReadResponse(v31, a2, a6, a3, a4, a5, v24, v25);
LABEL_21:
              HDLCFrameFree();
              HDLCFrameFree();
              return Response;
            }
          }
          else
          {
LABEL_23:
            free(Response);
          }
        }
LABEL_20:
        Response = 0;
        goto LABEL_21;
      }
      v29 = 133;
      v26 = "ETLRequireFreeSpace";
      v27 = "Need %u bytes free space, but only have %u\n";
    }
    else
    {
      v26 = "ETLNVRead";
      v27 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v26, (uint64_t)v27, v15, v16, v17, v18, v19, v20, v29);
    goto LABEL_20;
  }
  return Response;
}

uint64_t ETLNVWrite(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), int a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  int v6;

  return ETLNVWriteWithStatus(a1, a2, a3, a4, &v6, a5);
}

uint64_t ETLNVWriteWithStatus(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), int a2, uint64_t a3, unsigned int a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  _OWORD v36[2];
  uint64_t v37;
  _OWORD v38[8];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    memset(v36, 0, sizeof(v36));
    v37 = 0;
    memset(v34, 0, sizeof(v34));
    v35 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      if (a4 <= 0x80)
      {
        if (HDLCFrameGetFreeSpace() <= 0x87)
        {
          _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v17, v18, v19, v20, v21, v22, 136);
        }
        else
        {
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedShort();
          if (HDLCFrameInject())
          {
            memset(v38, 0, sizeof(v38));
            HDLCFrameInject();
            v23 = 0;
            if (!HDLCFrameInjectUnsignedShort())
            {
LABEL_18:
              HDLCFrameFree();
              HDLCFrameFree();
              return v23;
            }
            if (ETLSendCommand(a1, (uint64_t)v36, a6))
            {
              LOBYTE(v38[0]) = 39;
              v23 = 0;
              if (!ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v34, v38, a6)
                || LOBYTE(v38[0]) != 39)
              {
                goto LABEL_18;
              }
              if (DWORD2(v34[0]) <= 2)
              {
                _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Response size %u not enough, need %u\n", v24, v25, v26, v27, v28, v29, 3);
              }
              else
              {
                v30 = *(_QWORD *)&v34[0];
                if (*(unsigned __int16 *)(*(_QWORD *)&v34[0] + 1) != a2)
                  _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Returned item number %u mismatches expected %u\n", v24, v25, v26, v27, v28, v29, *(unsigned __int16 *)(*(_QWORD *)&v34[0] + 1));
                v31 = *(unsigned __int16 *)(v30 + 131);
                *a5 = v31;
                if (!(_DWORD)v31)
                {
                  v23 = 1;
                  goto LABEL_18;
                }
                _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"NV write response indicates failure with status code %u\n", v24, v25, v26, v27, v28, v29, v31);
              }
            }
          }
        }
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLNVWriteWithStatus", (uint64_t)"Failed to create command frame\n", v11, v12, v13, v14, v15, v16, v33);
    }
    v23 = 0;
    goto LABEL_18;
  }
  return 0;
}

void *ETLMaverickNVReadFactory(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, void *a3, uint64_t a4, _WORD *a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v37;
  _OWORD v38[2];
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  int v43;

  if (!a1 || !a3 || !a5 || !a6)
  {
    v35 = "Transport, destBuffer, amountRead, or status memory cannot be NULL\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)"ETLMaverickNVReadFactory", (uint64_t)v35, (uint64_t)a3, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v37);
    return 0;
  }
  if (a4 > 0x7F)
  {
    v40 = 0u;
    v41 = 0u;
    v42 = 0;
    memset(v38, 0, sizeof(v38));
    v39 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v15, v16, v17, v18, v19, v20, FreeSpace);
      }
      else
      {
        v43 = 1900107;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameInjectUnsignedInt())
          {
            v27 = malloc((2 * DWORD2(v40) + 32));
            if (!v27)
            {
LABEL_28:
              HDLCFrameFree();
              HDLCFrameFree();
              return v27;
            }
            v28 = HDLCFrameEncode();
            if (!(_DWORD)v28)
              goto LABEL_29;
            v29 = v28;
            v43 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0)
              ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v27, v28);
            if (*a1)
            {
              v30 = (*a1)(a1, v27, v29, &v43, 1, a7, 0);
              v31 = v43;
              free(v27);
              v27 = 0;
              if (!v30 || v31 != (_DWORD)v29)
                goto LABEL_28;
              if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v38, a7))
              {
                v27 = (void *)ETLMaverickParseNVReadFactory((_DWORD **)v38, a3, a4, a5, a6, v32, v33, v34);
                goto LABEL_28;
              }
            }
            else
            {
LABEL_29:
              free(v27);
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v21, v22, v23, v24, v25, v26, v37);
        }
      }
      v27 = 0;
      goto LABEL_28;
    }
    v35 = "Failed to create command frame\n";
    goto LABEL_22;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickNVReadFactory", (uint64_t)"Buffer size (%u) should be more than %u\n", (uint64_t)a3, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, a4);
  return 0;
}

uint64_t ETLMaverickParseNVReadFactory(_DWORD **a1, void *__dst, uint64_t a3, _WORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned __int16 *v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  size_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  *a4 = 0;
  *a5 = 4;
  v8 = *((_DWORD *)a1 + 2);
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseNVReadFactory", (uint64_t)"Failed on parsing Factory Response Header.\n", v16, v17, v18, v19, v20, v21, v23);
    return 0;
  }
  v10 = (unsigned __int16 *)*a1;
  v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, **a1);
    goto LABEL_14;
  }
  if (BYTE1(v11) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_14;
  }
  v12 = HIWORD(v11);
  if ((_DWORD)v12 != 28)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v12);
    goto LABEL_14;
  }
  if (v9 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseNVReadFactory", (uint64_t)"Received response has only %u bytes, need %u\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    v13 = v10[2];
    if (v13 != 5 && v10[2])
    {
      *a5 = v13;
      _ETLDebugPrint((uint64_t)"ETLMaverickParseNVReadFactory", (uint64_t)"Failed on NV Read via Factory command.\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v22);
      return 0;
    }
    else
    {
      *a5 = v13;
      v14 = v10[3];
      *a4 = v14;
      if (v14 <= a3)
      {
        memcpy(__dst, v10 + 4, v14);
        return 1;
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseNVReadFactory", (uint64_t)"Read amount, %u, is greater than the destination buffer size (%u)\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v14);
        return 0;
      }
    }
  }
}

uint64_t ETLMaverickNVWriteFactory(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;
  _OWORD v36[2];
  uint64_t v37;
  int v38;

  if (!a1 || !a3)
  {
    v31 = "Transport or srcBuffer cannot be NULL\n";
LABEL_15:
    _ETLDebugPrint((uint64_t)"ETLMaverickNVWriteFactory", (uint64_t)v31, a3, a4, a5, a6, a7, a8, v33);
    return 0;
  }
  if (a4 < 0x2000)
  {
    memset(v36, 0, sizeof(v36));
    v37 = 0;
    memset(v34, 0, sizeof(v34));
    v35 = 0;
    if ((HDLCFrameCreateUplink() & 1) != 0)
    {
      FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
      }
      else
      {
        v38 = 1965643;
        if ((HDLCFrameInject() & 1) != 0)
        {
          if (HDLCFrameInjectUnsignedInt()
            && HDLCFrameInject()
            && ETLSendCommand(a1, (uint64_t)v36, a5)
            && ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v34, a5))
          {
            v30 = ETLMaverickParseNVWriteFactory((unsigned int *)v34, v23, v24, v25, v26, v27, v28, v29);
LABEL_21:
            HDLCFrameFree();
            HDLCFrameFree();
            return v30;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v33);
        }
      }
      v30 = 0;
      goto LABEL_21;
    }
    v31 = "Failed to create command frame\n";
    goto LABEL_15;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickNVWriteFactory", (uint64_t)"Buffer size (%u) should be less than %u\n", a3, a4, a5, a6, a7, a8, a4);
  return 0;
}

uint64_t ETLMaverickParseNVWriteFactory(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v8 = a1[2];
  v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseNVWriteFactory", (uint64_t)"Failed on parsing Factory Response Header.\n", v13, v14, v15, v16, v17, v18, v20);
    return 0;
  }
  v10 = **(_DWORD **)a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_12;
  }
  if (BYTE1(v10) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    goto LABEL_12;
  }
  v11 = HIWORD(v10);
  if ((_DWORD)v11 != 29)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
    goto LABEL_12;
  }
  if (v9 <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseNVWriteFactory", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else if (*(unsigned __int16 *)(*(_QWORD *)a1 + 4) >= 2u)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseNVWriteFactory", (uint64_t)"Failed on writing NV via Factory command\n", a3, a4, a5, a6, a7, a8, v19);
    return 0;
  }
  else
  {
    return 1;
  }
}

double ETLPingParametersInit(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = xmmword_1DAD14FC0;
  *(_QWORD *)(a1 + 32) = &__block_literal_global;
  *(_QWORD *)(a1 + 40) = &__block_literal_global_3;
  return result;
}

uint64_t _block_invoke()
{
  return 1;
}

uint64_t ETLPing(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2)
{
  int v4;
  const void *v5;
  unsigned int v6;
  size_t v7;
  _DWORD *v8;
  _DWORD *v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v14;
  uint64_t v15;

  if (!*(_DWORD *)(a2 + 8))
  {
LABEL_5:
    v14 = 0;
    v15 = 0;
    v5 = *(const void **)(a2 + 16);
    if (v5 && (v6 = *(_DWORD *)(a2 + 24)) != 0)
    {
      if (*(_BYTE *)(a2 + 28))
        v7 = v6 + 4;
      else
        v7 = v6;
      v8 = malloc(v7);
    }
    else
    {
      if (!*(_BYTE *)(a2 + 28))
      {
        if (*(_DWORD *)a2)
        {
          v10 = (unsigned int *)(a2 + 4);
LABEL_24:
          v11 = 0;
          while (1)
          {
            if (!ETLBBSendEcho(a1, (uint64_t)&v14))
            {
LABEL_29:
              v8 = 0;
              v12 = 0;
              goto LABEL_36;
            }
            if ((ETLBBCheckEchoResponse((uint64_t)a1, (uint64_t)&v14, 1, *v10) & 1) != 0)
              break;
            if ((*(unsigned int (**)(_QWORD, uint64_t))(*(_QWORD *)(a2 + 32) + 16))(*(_QWORD *)(a2 + 32), v11))
            {
              v11 = (v11 + 1);
              if (v11 < *(_DWORD *)a2)
                continue;
            }
            goto LABEL_29;
          }
          v8 = 0;
LABEL_34:
          (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a2 + 40) + 16))(*(_QWORD *)(a2 + 40), v11);
          goto LABEL_35;
        }
        v8 = 0;
        goto LABEL_35;
      }
      v6 = *(_DWORD *)(a2 + 24);
      LODWORD(v7) = v6 + 4;
      v9 = malloc(v6 + 4);
      v8 = v9;
      if (!v6)
      {
        v14 = v9;
        LODWORD(v15) = 4;
        if (*(_DWORD *)a2)
        {
LABEL_14:
          v10 = (unsigned int *)(a2 + 4);
          if (v8)
          {
            v11 = 0;
            do
            {
              *v8 = v11;
              if (!ETLBBSendEcho(a1, (uint64_t)&v14))
                break;
              if (ETLBBCheckEchoResponse((uint64_t)a1, (uint64_t)&v14, 1, *v10))
                goto LABEL_34;
              if (!(*(unsigned int (**)(_QWORD, uint64_t))(*(_QWORD *)(a2 + 32) + 16))(*(_QWORD *)(a2 + 32), v11))break;
              v11 = (v11 + 1);
            }
            while (v11 < *(_DWORD *)a2);
            v12 = 0;
            goto LABEL_36;
          }
          goto LABEL_24;
        }
LABEL_35:
        v12 = 1;
LABEL_36:
        free(v8);
        return v12;
      }
    }
    memcpy(v8 + 1, v5, v6);
    v14 = v8;
    LODWORD(v15) = v7;
    if (*(_DWORD *)a2)
      goto LABEL_14;
    goto LABEL_35;
  }
  v4 = 0;
  while (ETLBBPing(a1))
  {
    usleep(1000 * *(_DWORD *)(a2 + 12));
    if (++v4 >= *(_DWORD *)(a2 + 8))
      goto LABEL_5;
  }
  return 0;
}

_QWORD *ETLTimestampGetTimeval(_QWORD *result, uint64_t a2)
{
  unsigned int v2;
  unint64_t v3;

  v2 = (43685 * (unsigned __int16)*result) >> 16;
  v3 = 5 * (*result >> 16)
     + ((unsigned __int16)(v2 + ((unsigned __int16)((*result - v2) & 0xFFFE) >> 1)) >> 13)
     + 2;
  *(_QWORD *)a2 = ((v3 * (unsigned __int128)0x10624DD2F1A9FCuLL) >> 64) + 315964800;
  *(_DWORD *)(a2 + 8) = 1000 * ((v3 >> 2) - 1000 * (((v3 >> 2) * (unsigned __int128)0x4189374BC6A7F0uLL) >> 64));
  return result;
}

uint64_t ETLTimestampFromTimeval(uint64_t result, _QWORD *a2)
{
  if (result)
  {
    if (a2)
      *a2 = ((unsigned __int16)(-25600 * (*(_DWORD *)(result + 8) % 1250)) | (unint64_t)((800
                                                                                               * *(_QWORD *)result
                                                                                               + *(_DWORD *)(result + 8)
                                                                                               / 1250) << 16))
          - 16565655306240000;
  }
  return result;
}

uint64_t ETLTimestampGetHoursMinutesSeconds(uint64_t result, int *a2, int *a3, _DWORD *a4)
{
  *a4 = result % 60;
  *a3 = (int)(result / 60) % 60;
  *a2 = (int)(result / 3600) % 24;
  return result;
}

uint64_t ETLTimestampsEqual(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;
  int v6;

  v2 = bswap64(*a1);
  v3 = bswap64(*a2);
  v4 = v2 >= v3;
  v5 = v2 > v3;
  v6 = !v4;
  return (v5 - v6);
}

uint64_t eUICC::GetVinylType::Perform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  std::chrono::steady_clock::time_point v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int rep;
  BOOL v37;
  size_t v38;
  int v39;
  const char *v40;
  uint64_t v42;
  uint64_t v43;
  int v44;
  void *__src[2];
  __int128 v46;
  uint64_t v47;
  std::chrono::nanoseconds __ns;

  HIDWORD(v43) = -1431655766;
  v44 = -1431655766;
  v8 = *(_QWORD **)a1;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v43) = 22;
    v40 = "transport";
LABEL_31:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a3, a4, a5, a6, a7, a8, (uint64_t)v40);
    goto LABEL_32;
  }
  if (!HDLCFrameCreateUplink())
    goto LABEL_30;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_30;
  }
  LODWORD(__src[0]) = 8453451;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v42);
    goto LABEL_30;
  }
  if ((HDLCFrameInjectUnsignedChar() & 1) == 0)
  {
LABEL_30:
    LODWORD(v43) = 12;
    v40 = "success";
    goto LABEL_31;
  }
  v23 = *(unsigned int *)(a1 + 12);
  v24.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v47 = 0;
  *(_OWORD *)__src = 0u;
  v46 = 0u;
  HIDWORD(v43) = 0;
  LOWORD(v44) = 0;
  while (1)
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    v25 = malloc(0x20uLL);
    if (!v25)
      goto LABEL_34;
    v32 = v25;
    v33 = HDLCFrameEncode();
    if (!(_DWORD)v33)
      goto LABEL_33;
    v34 = v33;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v32, v33);
    if (!*v8)
    {
LABEL_33:
      free(v32);
LABEL_34:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v26, v27, v28, v29, v30, v31, (uint64_t)"success");
      v39 = 5;
      goto LABEL_35;
    }
    v35 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*v8)(v8, v32, v34, &__ns, 1, v23, 0);
    rep = __ns.__rep_;
    free(v32);
    if (v35)
      v37 = rep == (_DWORD)v34;
    else
      v37 = 0;
    if (!v37)
      goto LABEL_34;
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v8, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, v23)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_34;
    }
    v38 = LODWORD(__src[1]) >= 6 ? 6 : LODWORD(__src[1]);
    memcpy((char *)&v43 + 4, __src[0], v38);
    if (v44 != 2)
      break;
    if (std::chrono::steady_clock::now().__d_.__rep_ - v24.__d_.__rep_ > 1000000 * v23)
    {
      v39 = 60;
      goto LABEL_35;
    }
  }
  v39 = 0;
LABEL_35:
  HDLCFrameFree();
  LODWORD(v43) = v39;
LABEL_32:
  HDLCFrameFree();
  return v43;
}

uint64_t eUICC::GetData::Perform@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>)
{
  __int128 v9;
  _OWORD *v10;
  _QWORD *v11;
  uint64_t FreeSpace;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  std::chrono::steady_clock::time_point v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int rep;
  BOOL v40;
  size_t v41;
  int v42;
  const char *v43;
  uint64_t v45;
  void *__src[2];
  __int128 v47;
  uint64_t v48;
  std::chrono::nanoseconds __ns;

  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)(a8 + 4) = v9;
  v10 = (_OWORD *)(a8 + 4);
  *(_OWORD *)(a8 + 244) = v9;
  *(_OWORD *)(a8 + 228) = v9;
  *(_OWORD *)(a8 + 212) = v9;
  *(_OWORD *)(a8 + 196) = v9;
  *(_OWORD *)(a8 + 180) = v9;
  *(_OWORD *)(a8 + 164) = v9;
  *(_OWORD *)(a8 + 148) = v9;
  *(_OWORD *)(a8 + 132) = v9;
  *(_OWORD *)(a8 + 116) = v9;
  *(_OWORD *)(a8 + 100) = v9;
  *(_OWORD *)(a8 + 84) = v9;
  *(_OWORD *)(a8 + 68) = v9;
  *(_OWORD *)(a8 + 52) = v9;
  *(_OWORD *)(a8 + 36) = v9;
  *(_OWORD *)(a8 + 20) = v9;
  *(_DWORD *)a8 = -1;
  v11 = *(_QWORD **)a1;
  if (!*(_QWORD *)a1)
  {
    *(_DWORD *)a8 = 22;
    v43 = "transport";
LABEL_31:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a2, a3, a4, a5, a6, a7, (uint64_t)v43);
    return HDLCFrameFree();
  }
  if (!HDLCFrameCreateUplink())
    goto LABEL_30;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
    goto LABEL_30;
  }
  LODWORD(__src[0]) = 5700939;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v20, v21, v22, v23, v24, v25, v45);
    goto LABEL_30;
  }
  if ((HDLCFrameInjectUnsignedChar() & 1) == 0)
  {
LABEL_30:
    *(_DWORD *)a8 = 12;
    v43 = "success";
    goto LABEL_31;
  }
  v26 = *(unsigned int *)(a1 + 12);
  v27.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v48 = 0;
  *(_OWORD *)__src = 0u;
  v47 = 0u;
  *v10 = 0u;
  v10[1] = 0u;
  v10[2] = 0u;
  v10[3] = 0u;
  v10[4] = 0u;
  v10[5] = 0u;
  v10[6] = 0u;
  v10[7] = 0u;
  v10[8] = 0u;
  v10[9] = 0u;
  v10[10] = 0u;
  v10[11] = 0u;
  v10[12] = 0u;
  v10[13] = 0u;
  v10[14] = 0u;
  *(_OWORD *)((char *)v10 + 238) = 0u;
  while (1)
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    v28 = malloc(0x20uLL);
    if (!v28)
      goto LABEL_34;
    v35 = v28;
    v36 = HDLCFrameEncode();
    if (!(_DWORD)v36)
      goto LABEL_33;
    v37 = v36;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v35, v36);
    if (!*v11)
    {
LABEL_33:
      free(v35);
LABEL_34:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v29, v30, v31, v32, v33, v34, (uint64_t)"success");
      v42 = 5;
      goto LABEL_35;
    }
    v38 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*v11)(v11, v35, v37, &__ns, 1, v26, 0);
    rep = __ns.__rep_;
    free(v35);
    if (v38)
      v40 = rep == (_DWORD)v37;
    else
      v40 = 0;
    if (!v40)
      goto LABEL_34;
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v11, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, v26)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_34;
    }
    v41 = LODWORD(__src[1]) >= 0xFE ? 254 : LODWORD(__src[1]);
    memcpy(v10, __src[0], v41);
    if (*(_BYTE *)(a8 + 8) != 2)
      break;
    if (std::chrono::steady_clock::now().__d_.__rep_ - v27.__d_.__rep_ > 1000000 * v26)
    {
      v42 = 60;
      goto LABEL_35;
    }
  }
  v42 = 0;
LABEL_35:
  HDLCFrameFree();
  *(_DWORD *)a8 = v42;
  return HDLCFrameFree();
}

uint64_t eUICC::SwitchMode::Perform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t FreeSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v25;
  _OWORD v26[2];
  uint64_t v27;
  _OWORD v28[2];
  uint64_t v29;
  _QWORD v30[2];
  int v31;

  v30[0] = 0xAAAAAAAAFFFFFFFFLL;
  v30[1] = 0xAAAAAAAAAAAAAAAALL;
  v29 = 0;
  memset(v28, 0, sizeof(v28));
  v27 = 0;
  memset(v26, 0, sizeof(v26));
  v8 = *(_QWORD **)a1;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v30[0]) = 22;
    v23 = "transport";
LABEL_21:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a3, a4, a5, a6, a7, a8, (uint64_t)v23);
    goto LABEL_22;
  }
  if (!HDLCFrameCreateUplink())
    goto LABEL_19;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
LABEL_19:
    LODWORD(v30[0]) = 12;
LABEL_20:
    v23 = "success";
    goto LABEL_21;
  }
  v31 = 5766475;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v25);
    goto LABEL_19;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || (HDLCFrameInjectUnsignedChar() & 1) == 0)
  {
    goto LABEL_19;
  }
  if (!ETLSendCommand((uint64_t (**)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))v8, (uint64_t)v28, *(unsigned int *)(a1 + 12))|| (ETLSubsysFindMatchingResponse((uint64_t)v8, (unsigned __int8 **)v26, *(_DWORD *)(a1 + 12)) & 1) == 0)
  {
    LODWORD(v30[0]) = 5;
    goto LABEL_20;
  }
  if (DWORD2(v26[0]) != 8)
  {
    LODWORD(v30[0]) = 40;
    v23 = "sizeof(result) == HDLCFrameGetPayloadLength( &rsp)";
    goto LABEL_21;
  }
  if (*(_BYTE *)(*(_QWORD *)&v26[0] + 4) != 1)
  {
    LODWORD(v30[0]) = -4;
    v23 = "VinylError::kStatusSuccess == result.cmd_ack_status";
    goto LABEL_21;
  }
  HDLCFrameFree();
  if (!HDLCFrameCreateUplink()
    || !ETLMaverickAddBSPCommandHeader()
    || (HDLCFrameInjectUnsignedShort() & 1) == 0)
  {
    LODWORD(v30[0]) = 12;
    goto LABEL_20;
  }
  LODWORD(v30[0]) = eUICC::PollResult<eUICC::SwitchMode::Response::{unnamed type#1}>((uint64_t)v28, (uint64_t)v30 + 4, v8, *(unsigned int *)(a1 + 12));
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return v30[0];
}

uint64_t eUICC::PollResult<eUICC::SwitchMode::Response::{unnamed type#1}>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  std::chrono::steady_clock::time_point v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int rep;
  BOOL v21;
  int v22;
  uint64_t v23;
  _OWORD v25[2];
  uint64_t v26;
  std::chrono::nanoseconds __ns;

  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v26 = 0;
  memset(v25, 0, sizeof(v25));
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9)
      goto LABEL_22;
    v16 = v9;
    v17 = HDLCFrameEncode();
    if (!(_DWORD)v17)
      goto LABEL_21;
    v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    if (!*a3)
    {
LABEL_21:
      free(v16);
LABEL_22:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      v23 = 5;
      goto LABEL_23;
    }
    v19 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    rep = __ns.__rep_;
    free(v16);
    if (v19)
      v21 = rep == (_DWORD)v18;
    else
      v21 = 0;
    if (!v21)
      goto LABEL_22;
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_22;
    }
    if (DWORD2(v25[0]) < 0xC)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, DWORD2(v25[0]));
    }
    else
    {
      v22 = *(_DWORD *)(*(_QWORD *)&v25[0] + 8);
      *(_QWORD *)a2 = **(_QWORD **)&v25[0];
      *(_DWORD *)(a2 + 8) = v22;
      if (v22 != 2)
      {
        v23 = 0;
        goto LABEL_23;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  v23 = 60;
LABEL_23:
  HDLCFrameFree();
  return v23;
}

uint64_t eUICC::InstallTicket::Perform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t FreeSpace;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unsigned int v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int rep;
  BOOL v61;
  uint64_t v62;
  const char *v63;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  unint64_t v74;
  std::chrono::steady_clock::time_point v75;
  _OWORD v76[2];
  uint64_t v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;
  _OWORD v81[2];
  uint64_t v82;
  std::chrono::nanoseconds __ns;

  v80 = 0;
  v78 = 0u;
  v79 = 0u;
  v77 = 0;
  memset(v76, 0, sizeof(v76));
  v8 = *(_QWORD **)a1;
  v9 = *(_QWORD *)(a1 + 24);
  if (v9 % 0x5DC)
    v10 = v9 / 0x5DC + 1;
  else
    v10 = v9 / 0x5DC;
  if (!v8)
  {
    v14 = 2863311530;
    v63 = "transport";
    goto LABEL_57;
  }
  if (!*(_QWORD *)(a1 + 16) || !v9 || !v10)
  {
    v14 = 2863311530;
    v63 = "request.data && request.data_len && segment_count";
LABEL_57:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a3, a4, a5, a6, a7, a8, (uint64_t)v63);
    v62 = 22;
    goto LABEL_58;
  }
  v12 = 0;
  v13 = (unsigned __int16)v10;
  v14 = 2863311530;
  while (2)
  {
    if (!HDLCFrameCreateUplink())
      goto LABEL_68;
    FreeSpace = HDLCFrameGetFreeSpace();
    if (FreeSpace < 4)
      goto LABEL_71;
    LODWORD(v81[0]) = 5897547;
    if ((HDLCFrameInject() & 1) == 0)
    {
LABEL_67:
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v28, v29, v30, v31, v32, v33, v71);
LABEL_68:
      _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v15, v16, v17, v18, v19, v20, (uint64_t)"success");
      v62 = 12;
      break;
    }
    if (!HDLCFrameInjectUnsignedChar()
      || !HDLCFrameInjectUnsignedShort()
      || !HDLCFrameInjectUnsignedShort()
      || !HDLCFrameInjectUnsignedShort()
      || (HDLCFrameInject() & 1) == 0)
    {
      goto LABEL_68;
    }
    v72 = v13;
    v73 = v12;
    v74 = v10;
    v34 = *(unsigned int *)(a1 + 32);
    v35 = malloc((2 * DWORD2(v78) + 32));
    if (!v35)
    {
LABEL_64:
      _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v36, v37, v38, v39, v40, v41, (uint64_t)"success");
      v62 = 5;
      break;
    }
    v42 = v35;
    v43 = HDLCFrameEncode();
    if (!(_DWORD)v43)
      goto LABEL_63;
    v44 = v43;
    LODWORD(v81[0]) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v42, v43);
    if (!*v8)
    {
LABEL_63:
      free(v42);
      goto LABEL_64;
    }
    v45 = ((uint64_t (*)(_QWORD *, void *, uint64_t, _OWORD *, uint64_t, uint64_t, _QWORD))*v8)(v8, v42, v44, v81, 1, v34, 0);
    v46 = v81[0];
    free(v42);
    if (!v45 || v46 != (_DWORD)v44)
      goto LABEL_64;
    v47 = *(_DWORD *)(a1 + 32);
    LOBYTE(v81[0]) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v8, (unsigned __int8 **)v76, (uint64_t)&_ETLResponseRingBuffer, v81, v47)|| LOBYTE(v81[0]) != 75)
    {
      goto LABEL_64;
    }
    if (DWORD2(v76[0]) != 6)
    {
      _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v36, v37, v38, v39, v40, v41, (uint64_t)"sizeof( result) == HDLCFrameGetPayloadLength( &rsp)");
      v62 = 40;
      break;
    }
    if (*(_BYTE *)(*(_QWORD *)&v76[0] + 4) != 1)
    {
      _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v36, v37, v38, v39, v40, v41, (uint64_t)"VinylError::kStatusSuccess == result.cmd_ack_status");
      v62 = 4294967286;
      break;
    }
    HDLCFrameFree();
    if (!HDLCFrameCreateUplink())
      goto LABEL_68;
    FreeSpace = HDLCFrameGetFreeSpace();
    if (FreeSpace < 4)
    {
LABEL_71:
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v22, v23, v24, v25, v26, v27, FreeSpace);
      goto LABEL_68;
    }
    LODWORD(v81[0]) = 4980043;
    if ((HDLCFrameInject() & 1) == 0)
      goto LABEL_67;
    if ((HDLCFrameInjectUnsignedShort() & 1) == 0)
      goto LABEL_68;
    v48 = *(unsigned int *)(a1 + 32);
    v75.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
    v14 = 0;
    v82 = 0;
    memset(v81, 0, sizeof(v81));
    while (1)
    {
      __ns.__rep_ = 100000000;
      std::this_thread::sleep_for (&__ns);
      v49 = malloc((2 * DWORD2(v78) + 32));
      if (!v49)
        goto LABEL_60;
      v56 = v49;
      v57 = HDLCFrameEncode();
      if (!(_DWORD)v57)
        goto LABEL_59;
      v58 = v57;
      LODWORD(__ns.__rep_) = -1431655766;
      if ((_ETLDebugFlags & 2) != 0)
        ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v56, v57);
      if (!*v8)
      {
LABEL_59:
        free(v56);
LABEL_60:
        _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v50, v51, v52, v53, v54, v55, (uint64_t)"success");
        v62 = 5;
LABEL_61:
        HDLCFrameFree();
        _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v65, v66, v67, v68, v69, v70, (uint64_t)"0 == response.error");
        goto LABEL_58;
      }
      v59 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*v8)(v8, v56, v58, &__ns, 1, v48, 0);
      rep = __ns.__rep_;
      free(v56);
      if (v59)
        v61 = rep == (_DWORD)v58;
      else
        v61 = 0;
      if (!v61)
        goto LABEL_60;
      LOBYTE(__ns.__rep_) = 75;
      if (!_ETLResponseRingBuffer)
        TelephonyUtilRingBufferInitialize();
      if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v8, (unsigned __int8 **)v81, (uint64_t)&_ETLResponseRingBuffer, &__ns, v48)|| LOBYTE(__ns.__rep_) != 75)
      {
        goto LABEL_60;
      }
      if (DWORD2(v81[0]) >= 0xB)
        break;
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v50, v51, v52, v53, v54, v55, DWORD2(v81[0]));
LABEL_36:
      if (std::chrono::steady_clock::now().__d_.__rep_ - v75.__d_.__rep_ > 1000000 * v48)
      {
        v62 = 60;
        goto LABEL_61;
      }
    }
    v14 = **(_DWORD **)&v81[0];
    if (((*(unsigned int *)(*(_QWORD *)&v81[0] + 4) | ((unint64_t)(*(unsigned __int16 *)(*(_QWORD *)&v81[0]
                                                                                                 + 8) | (*(unsigned __int8 *)(*(_QWORD *)&v81[0] + 10) << 16)) << 32)) & 0xFF00000000) == 0x200000000)
      goto LABEL_36;
    HDLCFrameFree();
    v62 = 0;
    v10 = v74;
    v12 = v73 + 1;
    v13 = v72;
    if (v73 + 1 != v74)
      continue;
    break;
  }
LABEL_58:
  HDLCFrameFree();
  return v62 | (v14 << 32);
}

uint64_t eUICC::StreamAPDU::Perform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  _QWORD *v9;
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  BOOL v27;
  const char *v28;
  uint64_t v30;
  _OWORD v31[2];
  uint64_t v32;
  _OWORD v33[2];
  uint64_t v34;
  _QWORD v35[2];
  int v36;

  v35[0] = 0xAAAAAAAAFFFFFFFFLL;
  v35[1] = 0xAAAAAAAAAAAAAAAALL;
  v34 = 0;
  memset(v33, 0, sizeof(v33));
  v32 = 0;
  memset(v31, 0, sizeof(v31));
  v8 = _ETLDebugFlags & 2;
  _ETLDebugFlags &= ~2u;
  v9 = *(_QWORD **)a1;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v35[0]) = 22;
    v28 = "transport";
LABEL_34:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a3, a4, a5, a6, a7, a8, (uint64_t)v28);
    goto LABEL_35;
  }
  if (!HDLCFrameCreateUplink())
    goto LABEL_32;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
LABEL_32:
    LODWORD(v35[0]) = 12;
LABEL_33:
    v28 = "success";
    goto LABEL_34;
  }
  v36 = 5832011;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v18, v19, v20, v21, v22, v23, v30);
    goto LABEL_32;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort())
  {
    goto LABEL_32;
  }
  v24 = HDLCFrameInjectUnsignedChar();
  if (v24 && *(_BYTE *)(a1 + 14))
  {
    v25 = 0;
    v26 = 1;
    while (*(_QWORD *)(a1 + 24) >= v26 - 1)
    {
      if (!HDLCFrameInjectUnsignedChar()
        || !HDLCFrameInject()
        || !HDLCFrameInjectUnsignedChar())
      {
        goto LABEL_32;
      }
      v24 = HDLCFrameInject();
      v25 += 32;
      if (v24)
        v27 = v26 >= *(unsigned __int8 *)(a1 + 14);
      else
        v27 = 1;
      ++v26;
      if (v27)
        goto LABEL_20;
    }
    LODWORD(v35[0]) = 22;
    v28 = "i <= request.apdu_payload.apdu_data_size";
    goto LABEL_34;
  }
LABEL_20:
  if ((v24 & 1) == 0)
    goto LABEL_32;
  if ((ETLSendCommand((uint64_t (**)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))v9, (uint64_t)v33, *(unsigned int *)(a1 + 32)) & 1) == 0)
  {
    LODWORD(v35[0]) = 5;
    goto LABEL_33;
  }
  _ETLDebugFlags |= v8;
  if ((ETLSubsysFindMatchingResponse((uint64_t)v9, (unsigned __int8 **)v31, *(_DWORD *)(a1 + 32)) & 1) == 0)
  {
    LODWORD(v35[0]) = 5;
    goto LABEL_33;
  }
  if (DWORD2(v31[0]) != 6)
  {
    LODWORD(v35[0]) = 40;
    v28 = "sizeof( result) == HDLCFrameGetPayloadLength( &rsp)";
    goto LABEL_34;
  }
  if (*(_BYTE *)(*(_QWORD *)&v31[0] + 4) != 1)
  {
    LODWORD(v35[0]) = -10;
    v28 = "VinylError::kStatusSuccess == result.cmd_ack_status";
    goto LABEL_34;
  }
  HDLCFrameFree();
  if (!HDLCFrameCreateUplink()
    || !ETLMaverickAddBSPCommandHeader()
    || (HDLCFrameInjectUnsignedShort() & 1) == 0)
  {
    LODWORD(v35[0]) = 12;
    goto LABEL_33;
  }
  LODWORD(v35[0]) = eUICC::PollResult<eUICC::StreamAPDU::Response::{unnamed type#1}>((uint64_t)v33, (uint64_t)v35 + 4, v9, *(unsigned int *)(a1 + 32));
LABEL_35:
  _ETLDebugFlags |= v8;
  HDLCFrameFree();
  return v35[0];
}

uint64_t eUICC::PollResult<eUICC::StreamAPDU::Response::{unnamed type#1}>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  std::chrono::steady_clock::time_point v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int rep;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v25[2];
  uint64_t v26;
  std::chrono::nanoseconds __ns;

  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v26 = 0;
  memset(v25, 0, sizeof(v25));
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 7) = 0;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9)
      goto LABEL_22;
    v16 = v9;
    v17 = HDLCFrameEncode();
    if (!(_DWORD)v17)
      goto LABEL_21;
    v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    if (!*a3)
    {
LABEL_21:
      free(v16);
LABEL_22:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      v23 = 5;
      goto LABEL_23;
    }
    v19 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    rep = __ns.__rep_;
    free(v16);
    if (v19)
      v21 = rep == (_DWORD)v18;
    else
      v21 = 0;
    if (!v21)
      goto LABEL_22;
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_22;
    }
    if (DWORD2(v25[0]) < 0xB)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, DWORD2(v25[0]));
    }
    else
    {
      v22 = **(_QWORD **)&v25[0];
      *(_DWORD *)(a2 + 7) = *(_DWORD *)(*(_QWORD *)&v25[0] + 7);
      *(_QWORD *)a2 = v22;
      if (*(_BYTE *)(a2 + 8) != 2)
      {
        v23 = 0;
        goto LABEL_23;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  v23 = 60;
LABEL_23:
  HDLCFrameFree();
  return v23;
}

uint64_t eUICC::InitPersoSession::Perform@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _OWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t FreeSpace;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  int v27;
  uint64_t v29;
  _OWORD v30[2];
  uint64_t v31;
  int v32;

  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  v4 = operator new(0x90uLL);
  *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  *(_DWORD *)v4 = -1;
  *a2 = v4;
  v5 = operator new(0x20uLL);
  *v5 = off_1EA1F1D40;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a2[1] = v5;
  v31 = 0;
  memset(v30, 0, sizeof(v30));
  v12 = *(_QWORD **)a1;
  if (!*(_QWORD *)a1)
  {
    v26 = "transport";
    v27 = 22;
LABEL_15:
    *(_DWORD *)v4 = v27;
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v6, v7, v8, v9, v10, v11, (uint64_t)v26);
    return HDLCFrameFree();
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_14:
    v26 = "success";
    v27 = 12;
    goto LABEL_15;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
    goto LABEL_14;
  }
  v32 = 5963083;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v20, v21, v22, v23, v24, v25, v29);
    goto LABEL_14;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || (HDLCFrameInject() & 1) == 0)
  {
    goto LABEL_14;
  }
  *(_DWORD *)v4 = eUICC::PollResult<eUICC::InitPersoSession::Response::contents>((uint64_t)v30, (_OWORD *)((char *)v4 + 4), v12, *(unsigned int *)(a1 + 28));
  return HDLCFrameFree();
}

void sub_1DAD0E4E0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DAD0E4F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t eUICC::PollResult<eUICC::InitPersoSession::Response::contents>(uint64_t a1, _OWORD *a2, _QWORD *a3, uint64_t a4)
{
  std::chrono::steady_clock::time_point v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int rep;
  BOOL v21;
  size_t v22;
  uint64_t v23;
  void *__src[2];
  __int128 v26;
  uint64_t v27;
  std::chrono::nanoseconds __ns;

  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v27 = 0;
  *(_OWORD *)__src = 0u;
  v26 = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[6] = 0u;
  a2[7] = 0u;
  *(_OWORD *)((char *)a2 + 121) = 0u;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9)
      goto LABEL_25;
    v16 = v9;
    v17 = HDLCFrameEncode();
    if (!(_DWORD)v17)
      goto LABEL_24;
    v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    if (!*a3)
    {
LABEL_24:
      free(v16);
LABEL_25:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      v23 = 5;
      goto LABEL_26;
    }
    v19 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    rep = __ns.__rep_;
    free(v16);
    if (v19)
      v21 = rep == (_DWORD)v18;
    else
      v21 = 0;
    if (!v21)
      goto LABEL_25;
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_25;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 0x89)
        v22 = 137;
      else
        v22 = LODWORD(__src[1]);
      memcpy(a2, __src[0], v22);
      if (*((_BYTE *)a2 + 4) != 2)
      {
        v23 = 0;
        goto LABEL_26;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  v23 = 60;
LABEL_26:
  HDLCFrameFree();
  return v23;
}

uint64_t std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](uint64_t result)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v1 = result;
  v2 = *(std::__shared_weak_count **)(result + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
      return v1;
    }
  }
  return result;
}

uint64_t eUICC::AuthPersoSession::Perform@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _BYTE *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _QWORD *v13;
  uint64_t FreeSpace;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  int v28;
  uint64_t v30;
  _OWORD v31[2];
  uint64_t v32;
  int v33;

  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  v4 = operator new(0x210uLL);
  bzero(v4, 0x210uLL);
  *(_DWORD *)v4 = -1;
  *a2 = v4;
  v5 = operator new(0x20uLL);
  *v5 = off_1EA1F1D90;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a2[1] = v5;
  v12 = _ETLDebugFlags & 2;
  _ETLDebugFlags &= ~2u;
  v32 = 0;
  memset(v31, 0, sizeof(v31));
  v13 = *(_QWORD **)a1;
  if (!*(_QWORD *)a1)
  {
    v27 = "transport";
    v28 = 22;
LABEL_15:
    *(_DWORD *)v4 = v28;
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v6, v7, v8, v9, v10, v11, (uint64_t)v27);
    goto LABEL_16;
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_14:
    v27 = "success";
    v28 = 12;
    goto LABEL_15;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v15, v16, v17, v18, v19, v20, FreeSpace);
    goto LABEL_14;
  }
  v33 = 6028619;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v21, v22, v23, v24, v25, v26, v30);
    goto LABEL_14;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || (HDLCFrameInject() & 1) == 0)
  {
    goto LABEL_14;
  }
  _ETLDebugFlags |= v12;
  *(_DWORD *)v4 = eUICC::PollResult<eUICC::AuthPersoSession::Response::contents>((uint64_t)v31, v4 + 4, v13, *(unsigned int *)(a1 + 2064));
LABEL_16:
  _ETLDebugFlags |= v12;
  return HDLCFrameFree();
}

void sub_1DAD0E9BC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DAD0E9D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t eUICC::PollResult<eUICC::AuthPersoSession::Response::contents>(uint64_t a1, _BYTE *a2, _QWORD *a3, uint64_t a4)
{
  std::chrono::steady_clock::time_point v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int rep;
  BOOL v21;
  size_t v22;
  uint64_t v23;
  void *__src[2];
  __int128 v26;
  uint64_t v27;
  std::chrono::nanoseconds __ns;

  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v27 = 0;
  *(_OWORD *)__src = 0u;
  v26 = 0u;
  bzero(a2, 0x209uLL);
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9)
      goto LABEL_25;
    v16 = v9;
    v17 = HDLCFrameEncode();
    if (!(_DWORD)v17)
      goto LABEL_24;
    v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    if (!*a3)
    {
LABEL_24:
      free(v16);
LABEL_25:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      v23 = 5;
      goto LABEL_26;
    }
    v19 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    rep = __ns.__rep_;
    free(v16);
    if (v19)
      v21 = rep == (_DWORD)v18;
    else
      v21 = 0;
    if (!v21)
      goto LABEL_25;
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_25;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 0x209)
        v22 = 521;
      else
        v22 = LODWORD(__src[1]);
      memcpy(a2, __src[0], v22);
      if (a2[4] != 2)
      {
        v23 = 0;
        goto LABEL_26;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  v23 = 60;
LABEL_26:
  HDLCFrameFree();
  return v23;
}

uint64_t eUICC::FinalizePersoSession::Perform@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _DWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t FreeSpace;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  int v27;
  uint64_t v29;
  _OWORD v30[2];
  uint64_t v31;
  int v32;

  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  v4 = operator new(0xCuLL);
  *(_QWORD *)v4 = 0;
  v4[2] = 0;
  *v4 = -1;
  *a2 = v4;
  v5 = operator new(0x20uLL);
  *v5 = off_1EA1F1DE0;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a2[1] = v5;
  v31 = 0;
  memset(v30, 0, sizeof(v30));
  v12 = *(_QWORD **)a1;
  if (!*(_QWORD *)a1)
  {
    v26 = "transport";
    v27 = 22;
LABEL_15:
    *v4 = v27;
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v6, v7, v8, v9, v10, v11, (uint64_t)v26);
    return HDLCFrameFree();
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_14:
    v26 = "success";
    v27 = 12;
    goto LABEL_15;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
    goto LABEL_14;
  }
  v32 = 6094155;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v20, v21, v22, v23, v24, v25, v29);
    goto LABEL_14;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || (HDLCFrameInject() & 1) == 0)
  {
    goto LABEL_14;
  }
  *v4 = eUICC::PollResult<eUICC::FinalizePersoSession::Response::contents>((uint64_t)v30, (_BYTE *)v4 + 4, v12, *(unsigned int *)(a1 + 272));
  return HDLCFrameFree();
}

void sub_1DAD0EDF4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DAD0EE08(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t eUICC::PollResult<eUICC::FinalizePersoSession::Response::contents>(uint64_t a1, _BYTE *a2, _QWORD *a3, uint64_t a4)
{
  std::chrono::steady_clock::time_point v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int rep;
  BOOL v21;
  size_t v22;
  uint64_t v23;
  void *__src[2];
  __int128 v26;
  uint64_t v27;
  std::chrono::nanoseconds __ns;

  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v27 = 0;
  *(_OWORD *)__src = 0u;
  v26 = 0u;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 3) = 0;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9)
      goto LABEL_25;
    v16 = v9;
    v17 = HDLCFrameEncode();
    if (!(_DWORD)v17)
      goto LABEL_24;
    v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    if (!*a3)
    {
LABEL_24:
      free(v16);
LABEL_25:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      v23 = 5;
      goto LABEL_26;
    }
    v19 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    rep = __ns.__rep_;
    free(v16);
    if (v19)
      v21 = rep == (_DWORD)v18;
    else
      v21 = 0;
    if (!v21)
      goto LABEL_25;
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_25;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 7)
        v22 = 7;
      else
        v22 = LODWORD(__src[1]);
      memcpy(a2, __src[0], v22);
      if (a2[4] != 2)
      {
        v23 = 0;
        goto LABEL_26;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  v23 = 60;
LABEL_26:
  HDLCFrameFree();
  return v23;
}

uint64_t eUICC::ValidatePerso::Perform@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _BYTE *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _QWORD *v13;
  uint64_t FreeSpace;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  int v28;
  uint64_t v30;
  _OWORD v31[2];
  uint64_t v32;
  int v33;

  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  v4 = operator new(0x1780uLL);
  bzero(v4, 0x1780uLL);
  *(_DWORD *)v4 = -1;
  *a2 = v4;
  v5 = operator new(0x20uLL);
  *v5 = off_1EA1F1E30;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a2[1] = v5;
  v12 = _ETLDebugFlags & 2;
  _ETLDebugFlags &= ~2u;
  v32 = 0;
  memset(v31, 0, sizeof(v31));
  v13 = *(_QWORD **)a1;
  if (!*(_QWORD *)a1)
  {
    v27 = "transport";
    v28 = 22;
LABEL_13:
    *(_DWORD *)v4 = v28;
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v6, v7, v8, v9, v10, v11, (uint64_t)v27);
    goto LABEL_14;
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_12:
    v27 = "success";
    v28 = 12;
    goto LABEL_13;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v15, v16, v17, v18, v19, v20, FreeSpace);
    goto LABEL_12;
  }
  v33 = 6356299;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v21, v22, v23, v24, v25, v26, v30);
    goto LABEL_12;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || (HDLCFrameInject() & 1) == 0)
  {
    goto LABEL_12;
  }
  _ETLDebugFlags |= v12;
  *(_DWORD *)v4 = eUICC::PollResult<eUICC::ValidatePerso::Response::contents>((uint64_t)v31, v4 + 4, v13, *(unsigned int *)(a1 + 80));
LABEL_14:
  _ETLDebugFlags |= v12;
  return HDLCFrameFree();
}

void sub_1DAD0F23C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DAD0F250(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t eUICC::PollResult<eUICC::ValidatePerso::Response::contents>(uint64_t a1, _BYTE *a2, _QWORD *a3, uint64_t a4)
{
  std::chrono::steady_clock::time_point v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int rep;
  BOOL v21;
  size_t v22;
  uint64_t v23;
  void *__src[2];
  __int128 v26;
  uint64_t v27;
  std::chrono::nanoseconds __ns;

  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v27 = 0;
  *(_OWORD *)__src = 0u;
  v26 = 0u;
  bzero(a2, 0x1779uLL);
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9)
      goto LABEL_25;
    v16 = v9;
    v17 = HDLCFrameEncode();
    if (!(_DWORD)v17)
      goto LABEL_24;
    v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    if (!*a3)
    {
LABEL_24:
      free(v16);
LABEL_25:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      v23 = 5;
      goto LABEL_26;
    }
    v19 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    rep = __ns.__rep_;
    free(v16);
    if (v19)
      v21 = rep == (_DWORD)v18;
    else
      v21 = 0;
    if (!v21)
      goto LABEL_25;
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_25;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 0x1779)
        v22 = 6009;
      else
        v22 = LODWORD(__src[1]);
      memcpy(a2, __src[0], v22);
      if (a2[4] != 2)
      {
        v23 = 0;
        goto LABEL_26;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  v23 = 60;
LABEL_26:
  HDLCFrameFree();
  return v23;
}

uint64_t eUICC::DeleteProfile::Perform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  _QWORD *v9;
  uint64_t FreeSpace;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  std::chrono::steady_clock::time_point v25;
  const char *v26;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int rep;
  BOOL v40;
  size_t v41;
  int v42;
  uint64_t v43;
  _BYTE v44[12];
  void *__src[2];
  __int128 v46;
  uint64_t v47;
  std::chrono::nanoseconds __ns;

  *(_DWORD *)&v44[4] = -1431655766;
  *(_DWORD *)&v44[8] = -1431655766;
  v8 = _ETLDebugFlags & 2;
  _ETLDebugFlags &= ~2u;
  v9 = *(_QWORD **)a1;
  if (!*(_QWORD *)a1)
  {
    *(_DWORD *)v44 = 22;
    v26 = "transport";
LABEL_12:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a3, a4, a5, a6, a7, a8, (uint64_t)v26);
    goto LABEL_13;
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_11:
    *(_DWORD *)v44 = 12;
    v26 = "success";
    goto LABEL_12;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_11;
  }
  LODWORD(__src[0]) = 7011659;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v18, v19, v20, v21, v22, v23, v43);
    goto LABEL_11;
  }
  if (!HDLCFrameInjectUnsignedChar() || (HDLCFrameInjectUnsignedChar() & 1) == 0)
    goto LABEL_11;
  _ETLDebugFlags |= v8;
  v24 = *(unsigned int *)(a1 + 12);
  v25.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v47 = 0;
  *(_OWORD *)__src = 0u;
  v46 = 0u;
  *(_DWORD *)&v44[4] = 0;
  *(_DWORD *)&v44[7] = 0;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    v28 = malloc(0x20uLL);
    if (!v28)
      goto LABEL_37;
    v35 = v28;
    v36 = HDLCFrameEncode();
    if (!(_DWORD)v36)
      goto LABEL_36;
    v37 = v36;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v35, v36);
    if (!*v9)
    {
LABEL_36:
      free(v35);
LABEL_37:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v29, v30, v31, v32, v33, v34, (uint64_t)"success");
      v42 = 5;
      goto LABEL_38;
    }
    v38 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*v9)(v9, v35, v37, &__ns, 1, v24, 0);
    rep = __ns.__rep_;
    free(v35);
    if (v38)
      v40 = rep == (_DWORD)v37;
    else
      v40 = 0;
    if (!v40)
      goto LABEL_37;
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v9, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, v24)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_37;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v29, v30, v31, v32, v33, v34, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 7)
        v41 = 7;
      else
        v41 = LODWORD(__src[1]);
      memcpy(&v44[4], __src[0], v41);
      if (v44[8] != 2)
      {
        v42 = 0;
        goto LABEL_38;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v25.__d_.__rep_ <= 1000000 * v24);
  v42 = 60;
LABEL_38:
  HDLCFrameFree();
  *(_DWORD *)v44 = v42;
LABEL_13:
  _ETLDebugFlags |= v8;
  HDLCFrameFree();
  return *(_QWORD *)v44;
}

uint64_t eUICC::GetCSN::Perform@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t FreeSpace;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  std::chrono::steady_clock::time_point v28;
  int v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  BOOL v42;
  size_t v43;
  int v44;
  uint64_t v46;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep;
  void *__src[2];
  __int128 v49;
  uint64_t v50;
  std::chrono::nanoseconds __ns;

  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  v4 = operator new(0x1CuLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = 0;
  *((_DWORD *)v4 + 6) = 0;
  *(_DWORD *)v4 = -1;
  *a2 = v4;
  v5 = operator new(0x20uLL);
  *v5 = off_1EA1F1E80;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a2[1] = v5;
  v12 = *(_QWORD **)a1;
  if (!*(_QWORD *)a1)
  {
    v26 = "transport";
    v29 = 22;
LABEL_34:
    *(_DWORD *)v4 = v29;
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v6, v7, v8, v9, v10, v11, (uint64_t)v26);
    return HDLCFrameFree();
  }
  if (!HDLCFrameCreateUplink())
    goto LABEL_32;
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
LABEL_32:
    v26 = "success";
LABEL_33:
    v29 = 12;
    goto LABEL_34;
  }
  LODWORD(__src[0]) = 5504331;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v20, v21, v22, v23, v24, v25, v46);
    goto LABEL_32;
  }
  v26 = "success";
  if ((HDLCFrameInjectUnsignedChar() & 1) == 0)
    goto LABEL_33;
  v27 = *(unsigned int *)(a1 + 12);
  v28.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  *(_QWORD *)((char *)v4 + 4) = 0;
  v50 = 0;
  rep = v28.__d_.__rep_;
  *(_OWORD *)__src = 0u;
  v49 = 0u;
  *(_QWORD *)((char *)v4 + 12) = 0;
  *(_QWORD *)((char *)v4 + 18) = 0;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    v30 = malloc(0x20uLL);
    if (!v30)
      goto LABEL_38;
    v37 = v30;
    v38 = HDLCFrameEncode();
    if (!(_DWORD)v38)
      goto LABEL_37;
    v39 = v38;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v37, v38);
    if (!*v12)
    {
LABEL_37:
      free(v37);
LABEL_38:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v31, v32, v33, v34, v35, v36, (uint64_t)"success");
      v44 = 5;
      goto LABEL_39;
    }
    v40 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*v12)(v12, v37, v39, &__ns, 1, v27, 0);
    v41 = __ns.__rep_;
    free(v37);
    if (v40)
      v42 = v41 == (_DWORD)v39;
    else
      v42 = 0;
    if (!v42)
      goto LABEL_38;
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v12, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, v27)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_38;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v31, v32, v33, v34, v35, v36, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 0x16)
        v43 = 22;
      else
        v43 = LODWORD(__src[1]);
      memcpy((char *)v4 + 4, __src[0], v43);
      if (*((_BYTE *)v4 + 8) != 2)
      {
        v44 = 0;
        goto LABEL_39;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - rep <= 1000000 * v27);
  v44 = 60;
LABEL_39:
  HDLCFrameFree();
  *(_DWORD *)v4 = v44;
  return HDLCFrameFree();
}

void sub_1DAD0FBF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1DAD0FC04(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DAD0FC18(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t eUICC::StoreData::Perform@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t FreeSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v27;
  _OWORD v28[2];
  uint64_t v29;
  _OWORD v30[2];
  uint64_t v31;
  int v32;

  v4 = a2 + 1;
  memset(a2 + 1, 170, 0x1780uLL);
  *a2 = -1;
  v31 = 0;
  memset(v30, 0, sizeof(v30));
  v29 = 0;
  memset(v28, 0, sizeof(v28));
  v11 = *(_QWORD **)a1;
  if (!*(_QWORD *)a1)
  {
    *a2 = 22;
    v25 = "transport";
    goto LABEL_24;
  }
  if (!*(_QWORD *)(a1 + 16) || (unint64_t)(*(_QWORD *)(a1 + 24) - 1) >= 0x7FFF)
  {
    *a2 = 22;
    v25 = "request.data && request.data_len && (request.data_len < kRequestMaxSize)";
LABEL_24:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v5, v6, v7, v8, v9, v10, (uint64_t)v25);
    return HDLCFrameFree();
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_22:
    *a2 = 12;
LABEL_23:
    v25 = "success";
    goto LABEL_24;
  }
  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_22;
  }
  v32 = 10943819;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v19, v20, v21, v22, v23, v24, v27);
    goto LABEL_22;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || (HDLCFrameInject() & 1) == 0)
  {
    goto LABEL_22;
  }
  if ((ETLSendCommand((uint64_t (**)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))v11, (uint64_t)v30, *(unsigned int *)(a1 + 32)) & 1) == 0)
  {
    *a2 = 5;
    goto LABEL_23;
  }
  if ((ETLSubsysFindMatchingResponse((uint64_t)v11, (unsigned __int8 **)v28, *(_DWORD *)(a1 + 32)) & 1) == 0)
  {
    *a2 = 5;
    goto LABEL_23;
  }
  if (DWORD2(v28[0]) != 6)
  {
    *a2 = 40;
    v25 = "sizeof( result) == HDLCFrameGetPayloadLength( &rsp)";
    goto LABEL_24;
  }
  if (*(_BYTE *)(*(_QWORD *)&v28[0] + 4) != 1)
  {
    *a2 = -10;
    v25 = "VinylError::kStatusSuccess == result.cmd_ack_status";
    goto LABEL_24;
  }
  HDLCFrameFree();
  if (!HDLCFrameCreateUplink()
    || !ETLMaverickAddBSPCommandHeader()
    || (HDLCFrameInjectUnsignedShort() & 1) == 0)
  {
    *a2 = 12;
    goto LABEL_23;
  }
  *a2 = eUICC::PollResult<eUICC::StoreData::Response::{unnamed type#1}>((uint64_t)v30, v4, v11, *(unsigned int *)(a1 + 32));
  return HDLCFrameFree();
}

uint64_t eUICC::PollResult<eUICC::StoreData::Response::{unnamed type#1}>(uint64_t a1, _BYTE *a2, _QWORD *a3, uint64_t a4)
{
  std::chrono::steady_clock::time_point v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int rep;
  BOOL v21;
  size_t v22;
  uint64_t v23;
  void *__src[2];
  __int128 v26;
  uint64_t v27;
  std::chrono::nanoseconds __ns;

  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v27 = 0;
  *(_OWORD *)__src = 0u;
  v26 = 0u;
  bzero(a2, 0x177DuLL);
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9)
      goto LABEL_25;
    v16 = v9;
    v17 = HDLCFrameEncode();
    if (!(_DWORD)v17)
      goto LABEL_24;
    v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    if (!*a3)
    {
LABEL_24:
      free(v16);
LABEL_25:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      v23 = 5;
      goto LABEL_26;
    }
    v19 = ((uint64_t (*)(_QWORD *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, _QWORD))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    rep = __ns.__rep_;
    free(v16);
    if (v19)
      v21 = rep == (_DWORD)v18;
    else
      v21 = 0;
    if (!v21)
      goto LABEL_25;
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer)
      TelephonyUtilRingBufferInitialize();
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_25;
    }
    if (LODWORD(__src[1]) < 9)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 0x177D)
        v22 = 6013;
      else
        v22 = LODWORD(__src[1]);
      memcpy(a2, __src[0], v22);
      if (a2[8] != 2)
      {
        v23 = 0;
        goto LABEL_26;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  v23 = 60;
LABEL_26:
  HDLCFrameFree();
  return v23;
}

BOOL ETLeUICCGetCSN(uint64_t a1, _OWORD *a2, char a3, int a4)
{
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  char v12;
  __int16 v13;
  char v14;
  int v15;

  v14 = 0;
  v13 = 0;
  v12 = a3;
  v15 = a4;
  v10 = 0xAAAAAAAAAAAAAAAALL;
  v11 = a1;
  v9 = 0xAAAAAAAAAAAAAAAALL;
  eUICC::GetCSN::Perform((uint64_t)&v11, &v9);
  if (a2 && !*(_DWORD *)v9 && *(_BYTE *)(v9 + 8) == 1)
    *a2 = *(_OWORD *)(v9 + 10);
  v5 = (std::__shared_weak_count *)v10;
  if (!v10)
    return a2 != 0;
  v6 = (unint64_t *)(v10 + 8);
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (v7)
    return a2 != 0;
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a2 != 0;
}

uint64_t ETLeUICCGetSimType(uint64_t a1, int *a2, char a3, int a4)
{
  int v5;
  uint64_t v6;
  int v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char v15;
  __int16 v16;
  char v17;
  int v18;

  *a2 = 0;
  v17 = 0;
  v16 = 0;
  v15 = a3;
  v18 = a4;
  v13 = 0xAAAAAAAAAAAAAAAALL;
  v14 = a1;
  v12 = 0xAAAAAAAAAAAAAAAALL;
  eUICC::GetCSN::Perform((uint64_t)&v14, &v12);
  v5 = *(unsigned __int8 *)(v12 + 8);
  if (v5 == 1)
  {
    v7 = 2;
    goto LABEL_5;
  }
  v6 = 0;
  if (v5 == 3)
  {
    v7 = 1;
LABEL_5:
    *a2 = v7;
    v6 = 1;
  }
  v8 = (std::__shared_weak_count *)v13;
  if (!v13)
    return v6;
  v9 = (unint64_t *)(v13 + 8);
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (v10)
    return v6;
  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
  std::__shared_weak_count::__release_weak(v8);
  return v6;
}

void std::__shared_ptr_pointer<eUICC::InitPersoSession::Response *,std::shared_ptr<eUICC::InitPersoSession::Response>::__shared_ptr_default_delete<eUICC::InitPersoSession::Response,eUICC::InitPersoSession::Response>,std::allocator<eUICC::InitPersoSession::Response>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<eUICC::InitPersoSession::Response *,std::shared_ptr<eUICC::InitPersoSession::Response>::__shared_ptr_default_delete<eUICC::InitPersoSession::Response,eUICC::InitPersoSession::Response>,std::allocator<eUICC::InitPersoSession::Response>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<eUICC::InitPersoSession::Response *,std::shared_ptr<eUICC::InitPersoSession::Response>::__shared_ptr_default_delete<eUICC::InitPersoSession::Response,eUICC::InitPersoSession::Response>,std::allocator<eUICC::InitPersoSession::Response>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x80000001DAD15062)
    return a1 + 24;
  if (((v3 & 0x80000001DAD15062 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001DAD15062))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001DAD15062 & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 24;
  return 0;
}

void std::__shared_ptr_pointer<eUICC::AuthPersoSession::Response *,std::shared_ptr<eUICC::AuthPersoSession::Response>::__shared_ptr_default_delete<eUICC::AuthPersoSession::Response,eUICC::AuthPersoSession::Response>,std::allocator<eUICC::AuthPersoSession::Response>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<eUICC::AuthPersoSession::Response *,std::shared_ptr<eUICC::AuthPersoSession::Response>::__shared_ptr_default_delete<eUICC::AuthPersoSession::Response,eUICC::AuthPersoSession::Response>,std::allocator<eUICC::AuthPersoSession::Response>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<eUICC::AuthPersoSession::Response *,std::shared_ptr<eUICC::AuthPersoSession::Response>::__shared_ptr_default_delete<eUICC::AuthPersoSession::Response,eUICC::AuthPersoSession::Response>,std::allocator<eUICC::AuthPersoSession::Response>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x80000001DAD15153)
    return a1 + 24;
  if (((v3 & 0x80000001DAD15153 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001DAD15153))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001DAD15153 & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 24;
  return 0;
}

void std::__shared_ptr_pointer<eUICC::FinalizePersoSession::Response *,std::shared_ptr<eUICC::FinalizePersoSession::Response>::__shared_ptr_default_delete<eUICC::FinalizePersoSession::Response,eUICC::FinalizePersoSession::Response>,std::allocator<eUICC::FinalizePersoSession::Response>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<eUICC::FinalizePersoSession::Response *,std::shared_ptr<eUICC::FinalizePersoSession::Response>::__shared_ptr_default_delete<eUICC::FinalizePersoSession::Response,eUICC::FinalizePersoSession::Response>,std::allocator<eUICC::FinalizePersoSession::Response>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<eUICC::FinalizePersoSession::Response *,std::shared_ptr<eUICC::FinalizePersoSession::Response>::__shared_ptr_default_delete<eUICC::FinalizePersoSession::Response,eUICC::FinalizePersoSession::Response>,std::allocator<eUICC::FinalizePersoSession::Response>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x80000001DAD15248)
    return a1 + 24;
  if (((v3 & 0x80000001DAD15248 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001DAD15248))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001DAD15248 & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 24;
  return 0;
}

void std::__shared_ptr_pointer<eUICC::ValidatePerso::Response *,std::shared_ptr<eUICC::ValidatePerso::Response>::__shared_ptr_default_delete<eUICC::ValidatePerso::Response,eUICC::ValidatePerso::Response>,std::allocator<eUICC::ValidatePerso::Response>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<eUICC::ValidatePerso::Response *,std::shared_ptr<eUICC::ValidatePerso::Response>::__shared_ptr_default_delete<eUICC::ValidatePerso::Response,eUICC::ValidatePerso::Response>,std::allocator<eUICC::ValidatePerso::Response>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<eUICC::ValidatePerso::Response *,std::shared_ptr<eUICC::ValidatePerso::Response>::__shared_ptr_default_delete<eUICC::ValidatePerso::Response,eUICC::ValidatePerso::Response>,std::allocator<eUICC::ValidatePerso::Response>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x80000001DAD1533ALL)
    return a1 + 24;
  if (((v3 & 0x80000001DAD1533ALL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001DAD1533ALL))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001DAD1533ALL & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 24;
  return 0;
}

void std::__shared_ptr_pointer<eUICC::GetCSN::Response *,std::shared_ptr<eUICC::GetCSN::Response>::__shared_ptr_default_delete<eUICC::GetCSN::Response,eUICC::GetCSN::Response>,std::allocator<eUICC::GetCSN::Response>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<eUICC::GetCSN::Response *,std::shared_ptr<eUICC::GetCSN::Response>::__shared_ptr_default_delete<eUICC::GetCSN::Response,eUICC::GetCSN::Response>,std::allocator<eUICC::GetCSN::Response>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<eUICC::GetCSN::Response *,std::shared_ptr<eUICC::GetCSN::Response>::__shared_ptr_default_delete<eUICC::GetCSN::Response,eUICC::GetCSN::Response>,std::allocator<eUICC::GetCSN::Response>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x80000001DAD1541DLL)
    return a1 + 24;
  if (((v3 & 0x80000001DAD1541DLL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001DAD1541DLL))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001DAD1541DLL & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 24;
  return 0;
}

uint64_t APPLIB_DIAG_Unlock(_BYTE *a1, int a2, unsigned __int8 *a3, int a4)
{
  uint64_t result;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  int v32;
  char __src;
  char v34[2047];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 13 && a4 == 6)
  {
    bzero(a1, a2);
    *a1 = 65;
    v8 = *a3;
    a1[1] = v8;
    v9 = a3[1];
    a1[2] = v9;
    v10 = a3[2];
    a1[3] = v10;
    v11 = a3[3];
    a1[4] = v11;
    v12 = a3[4];
    a1[5] = v12;
    v13 = a3[5];
    a1[6] = v13;
    v14 = crc_16_l_table[v8 ^ 0xA];
    v15 = crc_16_l_table[(v9 ^ v14) ^ 0x5C];
    v16 = crc_16_l_table[(v10 ^ v15 ^ HIBYTE(v14))];
    v17 = crc_16_l_table[(v11 ^ v16 ^ HIBYTE(v15))];
    v18 = crc_16_l_table[(v12 ^ v17 ^ HIBYTE(v16))];
    v19 = crc_16_l_table[(v13 ^ v18 ^ HIBYTE(v17))];
    v20 = v19 ^ ~(v18 >> 8);
    a1[7] = v20;
    v21 = BYTE1(v20);
    a1[8] = v21;
    if (a2 >= 0x12)
    {
      v32 = v21;
      bzero(v34, 0x7FFuLL);
      __src = 65;
      if ((v8 - 125) > 1)
      {
        v22 = 1;
      }
      else
      {
        v34[0] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        v22 = 2;
      }
      v34[v22 - 1] = v8;
      v23 = v22 + 1;
      if ((v9 - 125) <= 1)
      {
        v34[v23 - 1] = 125;
        LODWORD(v23) = v22 + 2;
        LOBYTE(v9) = v9 ^ 0x20;
      }
      v34[v23 - 1] = v9;
      v24 = v23 + 1;
      if ((v10 - 125) <= 1)
      {
        v34[v24 - 1] = 125;
        LOBYTE(v10) = v10 ^ 0x20;
        LODWORD(v24) = v23 + 2;
      }
      v34[v24 - 1] = v10;
      v25 = v24 + 1;
      if ((v11 - 125) <= 1)
      {
        v34[v25 - 1] = 125;
        LODWORD(v25) = v24 + 2;
        LOBYTE(v11) = v11 ^ 0x20;
      }
      v34[v25 - 1] = v11;
      v26 = v25 + 1;
      if ((v12 - 125) <= 1)
      {
        v34[v26 - 1] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v26) = v25 + 2;
      }
      v27 = ~(v19 ^ BYTE1(v18));
      v34[v26 - 1] = v12;
      v28 = v26 + 1;
      if ((v13 - 125) <= 1)
      {
        v34[v28 - 1] = 125;
        LOBYTE(v13) = v13 ^ 0x20;
        LODWORD(v28) = v26 + 2;
      }
      v34[v28 - 1] = v13;
      v29 = v28 + 1;
      if ((v27 - 125) <= 1)
      {
        v34[v29 - 1] = 125;
        LODWORD(v29) = v28 + 2;
        LOBYTE(v27) = v27 ^ 0x20;
      }
      v30 = v32;
      v34[v29 - 1] = v27;
      v31 = v29 + 1;
      if ((v32 - 125) <= 1)
      {
        v34[v31 - 1] = 125;
        v30 = v32 ^ 0x20;
        LODWORD(v31) = v29 + 2;
      }
      v34[v31 - 1] = v30;
      memcpy(a1, &__src, v31 + 1);
      result = (v31 + 2);
      a1[v31 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_Lock(_WORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = 11387;
    *((_BYTE *)a1 + 2) = 61;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2117938299;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_CreateICCID_EFS_File(char *a1, int a2)
{
  __int16 v3;
  __int128 v4;
  __int128 v5;
  _BYTE v6[30];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a2 < 64)
    return 0xFFFFFFFFLL;
  v4 = 0u;
  v5 = 0u;
  memset(v6, 0, sizeof(v6));
  v3 = 8523;
  BYTE2(v4) = 1;
  BYTE4(v5) = 1;
  BYTE8(v5) = 1;
  BYTE14(v5) = 10;
  qmemcpy(v6, "sim.txt", 7);
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 42);
}

uint64_t APPLIB_DIAG_GetICCID(char *a1, int a2)
{
  __int16 v3;
  char v4;
  __int128 v5;
  __int128 v6;
  _BYTE v7[29];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a2 < 64)
    return 0xFFFFFFFFLL;
  v5 = 0u;
  v6 = 0u;
  memset(v7, 0, sizeof(v7));
  v3 = 8576;
  v4 = 72;
  BYTE1(v5) = 1;
  BYTE5(v5) = 119;
  *(_WORD *)((char *)&v5 + 9) = 4097;
  BYTE11(v6) = 107;
  HIBYTE(v6) = 107;
  v7[7] = 1;
  v7[15] = 10;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 55);
}

uint64_t APPLIB_DIAG_Read_Meid(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 1943);
}

uint64_t APPLIB_DIAG_Write_Meid(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 8)
    return 0xFFFFFFFFLL;
  else
    return APPLIB_DIAG_NvItemWrite(a1, a2, 1943, __src, a4);
}

uint64_t APPLIB_DIAG_Read_Msl(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 85);
}

uint64_t APPLIB_DIAG_Write_Msl(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 6)
    return 0xFFFFFFFFLL;
  else
    return APPLIB_DIAG_NvItemWrite(a1, a2, 85, __src, a4);
}

uint64_t APPLIB_DIAG_Read_Otksl(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 85);
}

uint64_t APPLIB_DIAG_Write_Otksl(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 6)
    return 0xFFFFFFFFLL;
  else
    return APPLIB_DIAG_NvItemWrite(a1, a2, 219, __src, a4);
}

uint64_t APPLIB_DIAG_Write_AKey(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 9)
    return 0xFFFFFFFFLL;
  else
    return APPLIB_DIAG_NvItemWrite(a1, a2, 25, __src, a4);
}

uint64_t APPLIB_DIAG_Write_AKeyCSum(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 8)
    return 0xFFFFFFFFLL;
  else
    return APPLIB_DIAG_NvItemWrite(a1, a2, 26, __src, a4);
}

uint64_t APPLIB_DIAG_Write_BlueToothAddr(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 6)
    return 0xFFFFFFFFLL;
  else
    return APPLIB_DIAG_NvItemWrite(a1, a2, 50001, __src, a4);
}

uint64_t APPLIB_DIAG_Read_BlueToothAddr(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 50001);
}

uint64_t APPLIB_DIAG_Write_WiFi_MAC_Addr(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 6)
    return 0xFFFFFFFFLL;
  else
    return APPLIB_DIAG_NvItemWrite(a1, a2, 50002, __src, a4);
}

uint64_t APPLIB_DIAG_Read_WiFi_MAC_Addr(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 50002);
}

uint64_t APPLIB_DIAG_Write_WiFi_Cal_Data(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 64)
    return 0xFFFFFFFFLL;
  else
    return APPLIB_DIAG_NvItemWrite(a1, a2, 50003, __src, a4);
}

uint64_t APPLIB_DIAG_Read_WiFi_Cal_Data(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 50003);
}

uint64_t APPLIB_DIAG_Write_USB2ETHERNET_MAC_Addr(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 6)
    return 0xFFFFFFFFLL;
  else
    return APPLIB_DIAG_NvItemWrite(a1, a2, 50004, __src, a4);
}

uint64_t APPLIB_DIAG_Read_USB2ETHERNET_MAC_Addr(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 50004);
}

uint64_t APPLIB_DIAG_GetSerialNumAndChipID(_QWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 8)
  {
    bzero(a1, a2);
    *a1 = 0x9B390003000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x9B390003000CFE4BLL;
      *((_BYTE *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetNonce(_QWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 8)
  {
    bzero(a1, a2);
    *a1 = 0x82E10002000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x82E10002000CFE4BLL;
      *((_BYTE *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_SfpNvBackup(_QWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 8)
  {
    bzero(a1, a2);
    *a1 = 0xFC590007000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0xFC590007000CFE4BLL;
      *((_BYTE *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_SfpNvRestore(_QWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 8)
  {
    bzero(a1, a2);
    *a1 = 0x7F910008000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x7F910008000CFE4BLL;
      *((_BYTE *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadRootManifest(_DWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x17)
  {
    bzero(a1, a2);
    *a1 = 851275;
    a1[1] = 10;
    *((_WORD *)a1 + 4) = 5546;
    if (a2 >= 20)
    {
      *(_QWORD *)a1 = 0xA000CFD4BLL;
      *((_WORD *)a1 + 4) = 5546;
      *((_BYTE *)a1 + 10) = 126;
      return 11;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_StartProvision(_WORD *a1, unsigned int a2, const void *a3, unsigned int a4)
{
  int v8;
  int v9;
  char *v10;
  char v11;
  char v12;
  char v13;
  uint64_t result;
  uint64_t v15;
  int v16;
  unsigned __int8 *v17;
  char v18;
  int v19;
  _BYTE __src[2048];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1 || 2 * (unint64_t)a4 + 22 >= a2)
    return 0xFFFFFFFFLL;
  bzero(a1, a2);
  *(_DWORD *)a1 = 851531;
  a1[2] = 0;
  a1[3] = a4;
  memcpy(a1 + 4, a3, a4);
  v8 = 8 * (a4 + 8);
  if (8 * ((_WORD)a4 + 8))
  {
    LOWORD(v9) = -1;
    v10 = (char *)a1;
    do
    {
      v11 = *v10++;
      v9 = crc_16_l_table[(v11 ^ v9)] ^ ((unsigned __int16)(v9 & 0xFF00) >> 8);
      v8 -= 8;
    }
    while ((_WORD)v8);
    v12 = ~(_BYTE)v9;
    v13 = (unsigned __int16)~(_WORD)v9 >> 8;
  }
  else
  {
    v12 = 0;
    v13 = 0;
  }
  *((_BYTE *)a1 + a4 + 8) = v12;
  *((_BYTE *)a1 + a4 + 9) = v13;
  v15 = a4 + 10;
  result = 0xFFFFFFFFLL;
  if ((int)v15 <= 1024 && 2 * (int)v15 <= (int)a2)
  {
    bzero(__src, 0x800uLL);
    if ((int)v15 < 1)
    {
      v16 = 0;
    }
    else
    {
      v16 = 0;
      v17 = (unsigned __int8 *)a1;
      do
      {
        v19 = *v17++;
        v18 = v19;
        if ((v19 - 125) <= 1)
        {
          __src[v16] = 125;
          v18 ^= 0x20u;
          ++v16;
        }
        __src[v16++] = v18;
        --v15;
      }
      while (v15);
    }
    memcpy(a1, __src, v16);
    result = (v16 + 1);
    *((_BYTE *)a1 + v16) = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_FinishProvision(_WORD *a1, unsigned int a2, const void *a3, unsigned int a4)
{
  int v8;
  int v9;
  char *v10;
  char v11;
  char v12;
  char v13;
  uint64_t result;
  uint64_t v15;
  int v16;
  unsigned __int8 *v17;
  char v18;
  int v19;
  _BYTE __src[2048];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1 || 2 * (unint64_t)a4 + 22 >= a2)
    return 0xFFFFFFFFLL;
  bzero(a1, a2);
  *(_DWORD *)a1 = 851531;
  a1[2] = 1;
  a1[3] = a4;
  memcpy(a1 + 4, a3, a4);
  v8 = 8 * (a4 + 8);
  if (8 * ((_WORD)a4 + 8))
  {
    LOWORD(v9) = -1;
    v10 = (char *)a1;
    do
    {
      v11 = *v10++;
      v9 = crc_16_l_table[(v11 ^ v9)] ^ ((unsigned __int16)(v9 & 0xFF00) >> 8);
      v8 -= 8;
    }
    while ((_WORD)v8);
    v12 = ~(_BYTE)v9;
    v13 = (unsigned __int16)~(_WORD)v9 >> 8;
  }
  else
  {
    v12 = 0;
    v13 = 0;
  }
  *((_BYTE *)a1 + a4 + 8) = v12;
  *((_BYTE *)a1 + a4 + 9) = v13;
  v15 = a4 + 10;
  result = 0xFFFFFFFFLL;
  if ((int)v15 <= 1024 && 2 * (int)v15 <= (int)a2)
  {
    bzero(__src, 0x800uLL);
    if ((int)v15 < 1)
    {
      v16 = 0;
    }
    else
    {
      v16 = 0;
      v17 = (unsigned __int8 *)a1;
      do
      {
        v19 = *v17++;
        v18 = v19;
        if ((v19 - 125) <= 1)
        {
          __src[v16] = 125;
          v18 ^= 0x20u;
          ++v16;
        }
        __src[v16++] = v18;
        --v15;
      }
      while (v15);
    }
    memcpy(a1, __src, v16);
    result = (v16 + 1);
    *((_BYTE *)a1 + v16) = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_WriteCalibrationManifest(_WORD *a1, unsigned int a2, const void *a3, unsigned int a4)
{
  uint64_t v8;
  int v9;
  int v10;
  char *v11;
  char v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  int v17;
  int v18;
  _BYTE __src[2048];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1 || 2 * (unint64_t)a4 + 22 >= a2)
    return 0xFFFFFFFFLL;
  bzero(a1, a2);
  *(_DWORD *)a1 = 851531;
  a1[2] = 6;
  a1[3] = a4;
  memcpy(a1 + 4, a3, a4);
  v8 = a4 + 8;
  v9 = 8 * (a4 + 8);
  if (8 * ((_WORD)a4 + 8))
  {
    LOWORD(v10) = -1;
    v11 = (char *)a1;
    do
    {
      v12 = *v11++;
      v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
      v9 -= 8;
    }
    while ((_WORD)v9);
    *((_BYTE *)a1 + v8) = ~(_BYTE)v10;
    *((_BYTE *)a1 + a4 + 9) = (unsigned __int16)~(_WORD)v10 >> 8;
    result = 0xFFFFFFFFLL;
    if (a4 > 0x3F6)
      return result;
  }
  else
  {
    *((_BYTE *)a1 + v8) = 0;
    *((_BYTE *)a1 + a4 + 9) = 0;
    result = 0xFFFFFFFFLL;
    if (a4 > 0x3F6)
      return result;
  }
  v14 = a4 + 10;
  if (2 * (int)v14 <= (int)a2)
  {
    bzero(__src, 0x800uLL);
    v15 = 0;
    LODWORD(v16) = 0;
    do
    {
      while (1)
      {
        v18 = *((unsigned __int8 *)a1 + v15);
        if ((v18 - 125) > 1)
          break;
        v17 = v16 + 1;
        __src[(int)v16] = 125;
        __src[(int)v16 + 1] = v18 ^ 0x20;
        v16 = (int)v16 + 1 + 1;
        if (v14 == ++v15)
          goto LABEL_16;
      }
      v17 = v16;
      __src[(int)v16] = v18;
      v16 = (int)v16 + 1;
      ++v15;
    }
    while (v14 != v15);
LABEL_16:
    memcpy(a1, __src, v16);
    result = (v17 + 2);
    *((_BYTE *)a1 + v16) = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadCalibrationBackup(_QWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0xCFE90005000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0xCFE90005000CFE4BLL;
      *((_BYTE *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_BackupCalibrationData(_QWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0xD6310004000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0xD6310004000CFE4BLL;
      *((_BYTE *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_RestoreCalibrationData(_QWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0x66490009000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x66490009000CFE4BLL;
      *((_BYTE *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadManifestStatus(_QWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0x53D000C000CFD4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x53D000C000CFD4BLL;
      *((_BYTE *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_CheckCalibrationData(_QWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0x129000D000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x129000D000CFE4BLL;
      *((_BYTE *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadCalCounter(_QWORD *a1, int a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0x2B41000E000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x2B41000E000CFE4BLL;
      *((_BYTE *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t ETLSMSCreateAddress(uint64_t a1, char *__s)
{
  unsigned __int8 v4;
  unsigned __int8 v5;

  v4 = strlen(__s);
  if ((v4 & 0xF0) != 0)
    v5 = 15;
  else
    v5 = v4;
  *(_BYTE *)a1 = v5;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 1) = 0;
  memcpy((void *)(a1 + 1), __s, v5);
  return 1;
}

uint64_t ETLSMSCreateMessage(uint64_t a1, char *__s)
{
  unsigned __int8 v4;
  unsigned __int8 v5;

  v4 = strlen(__s);
  if ((v4 & 0xF8u) <= 0xC7uLL)
    v5 = v4;
  else
    v5 = -57;
  *(_BYTE *)a1 = v5;
  *(_OWORD *)(a1 + 17) = 0u;
  *(_OWORD *)(a1 + 33) = 0u;
  *(_OWORD *)(a1 + 49) = 0u;
  *(_OWORD *)(a1 + 65) = 0u;
  *(_OWORD *)(a1 + 81) = 0u;
  *(_OWORD *)(a1 + 97) = 0u;
  *(_OWORD *)(a1 + 113) = 0u;
  *(_OWORD *)(a1 + 129) = 0u;
  *(_OWORD *)(a1 + 145) = 0u;
  *(_OWORD *)(a1 + 161) = 0u;
  *(_OWORD *)(a1 + 177) = 0u;
  *(_QWORD *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 1) = 0u;
  memcpy((void *)(a1 + 1), __s, v5);
  return 1;
}

uint64_t ETLSMSCreateSendSMSCommand(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t FreeSpace;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v19;
  const char *v20;
  uint64_t v21;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v6, v7, v8, v9, v10, v11, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    v19 = "ETLSubsysAddHeaderInternal";
    v20 = "Failed to inject\n";
LABEL_13:
    _ETLDebugPrint((uint64_t)v19, (uint64_t)v20, v12, v13, v14, v15, v16, v17, v21);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 0xD7)
  {
    v21 = 216;
    v19 = "ETLRequireFreeSpace";
    v20 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_13;
  }
  if (*a2 <= 0xFu
    && *a3 <= 0xC7u
    && HDLCFrameInjectUnsignedChar()
    && HDLCFrameInject()
    && HDLCFrameInjectUnsignedChar())
  {
    return HDLCFrameInject();
  }
  return 0;
}

uint64_t ETLSMSParseSendSMSResponse(unsigned int *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;

  v8 = a1[2];
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    v9 = **(_DWORD **)a1;
    if (v9 == 75)
    {
      if (BYTE1(v9) == 252)
      {
        v10 = HIWORD(v9);
        if ((_DWORD)v10 == 1)
        {
          if (v8 - 4 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLSMSParseSendSMSResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 2);
            return 0;
          }
          else
          {
            v11 = *(unsigned __int16 *)(*(_QWORD *)a1 + 4);
            *a2 = v11;
            _ETLDebugPrint((uint64_t)"ETLSMSParseSendSMSResponse", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, v11);
            return 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLSMSSendSMS(_QWORD *a1, unsigned __int8 *a2, unsigned __int8 *a3, _WORD *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  BOOL v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v35;
  _OWORD v36[2];
  uint64_t v37;
  _OWORD v38[2];
  uint64_t v39;
  int v40;

  memset(v38, 0, sizeof(v38));
  v39 = 0;
  memset(v36, 0, sizeof(v36));
  v37 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSMSSendSMS", (uint64_t)"Failed to create command frame\n", v10, v11, v12, v13, v14, v15, v35);
    goto LABEL_24;
  }
  if (!ETLSMSCreateSendSMSCommand((uint64_t)v38, a2, a3))
    goto LABEL_24;
  v16 = malloc((2 * DWORD2(v38[0]) + 32));
  if (!v16)
    goto LABEL_24;
  v17 = v16;
  v18 = HDLCFrameEncode();
  if (!(_DWORD)v18)
    goto LABEL_26;
  v19 = v18;
  v40 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0)
    ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
  if (!*a1)
  {
LABEL_26:
    free(v17);
    goto LABEL_24;
  }
  v20 = ((uint64_t (*)(_QWORD *, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD))*a1)(a1, v17, v19, &v40, 1, a5, 0);
  v21 = v40;
  free(v17);
  if (v20)
    v22 = v21 == (_DWORD)v19;
  else
    v22 = 0;
  if (!v22)
    goto LABEL_24;
  LOBYTE(v40) = 75;
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v23 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v40, a5);
  v30 = 0;
  if (v23 && v40 == 75)
  {
    if (DWORD2(v36[0]) < 4)
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v24, v25, v26, v27, v28, v29, DWORD2(v36[0]));
    }
    else
    {
      v31 = **(_DWORD **)&v36[0];
      if (**(_DWORD **)&v36[0] == 75)
      {
        if (BYTE1(v31) == 252)
        {
          v32 = HIWORD(v31);
          if ((_DWORD)v32 == 1)
          {
            if ((DWORD2(v36[0]) - 4) > 1)
            {
              v33 = *(unsigned __int16 *)(*(_QWORD *)&v36[0] + 4);
              *a4 = v33;
              _ETLDebugPrint((uint64_t)"ETLSMSParseSendSMSResponse", (uint64_t)"Status was %u\n", v24, v25, v26, v27, v28, v29, v33);
              v30 = 1;
              goto LABEL_25;
            }
            _ETLDebugPrint((uint64_t)"ETLSMSParseSendSMSResponse", (uint64_t)"response requires %u bytes, got %u\n", v24, v25, v26, v27, v28, v29, 2);
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v24, v25, v26, v27, v28, v29, v32);
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v24, v25, v26, v27, v28, v29, BYTE1(v31));
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v24, v25, v26, v27, v28, v29, **(_DWORD **)&v36[0]);
      }
    }
LABEL_24:
    v30 = 0;
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v30;
}

uint64_t ETLFlushResponseBuffer()
{
  TelephonyUtilRingBufferReset();
  return 1;
}

uint64_t ETLFlushResponseFull(uint64_t a1)
{
  uint64_t (*v2)(uint64_t);

  TelephonyUtilRingBufferReset();
  v2 = *(uint64_t (**)(uint64_t))(a1 + 24);
  if (v2)
    return v2(a1);
  else
    return 0;
}

uint64_t ETLGetResponse(uint64_t a1, _BYTE **a2, _BYTE *a3)
{
  uint64_t v6;
  uint64_t v7;

  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  v6 = ETLFrameReadFromTransport(a1, (uint64_t)a2);
  if ((_DWORD)v6)
  {
    v7 = *((unsigned int *)a2 + 2);
    if ((_ETLDebugFlags & 2) != 0)
    {
      ((void (*)(const char *, uint64_t, _QWORD, uint64_t))*(&gDelegate + 1))("", 1, *a2, v7);
      LODWORD(v7) = *((_DWORD *)a2 + 2);
    }
    if ((_DWORD)v7)
      *a3 = **a2;
  }
  return v6;
}

uint64_t ETLGetResponseUsingBuffer(uint64_t a1, _BYTE **a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v6;
  uint64_t v7;

  v6 = ETLFrameReadFromTransport(a1, (uint64_t)a2);
  if ((_DWORD)v6)
  {
    v7 = *((unsigned int *)a2 + 2);
    if ((_ETLDebugFlags & 2) != 0)
    {
      ((void (*)(const char *, uint64_t, _QWORD, uint64_t))*(&gDelegate + 1))("", 1, *a2, v7);
      LODWORD(v7) = *((_DWORD *)a2 + 2);
    }
    if ((_DWORD)v7)
      *a4 = **a2;
  }
  return v6;
}

uint64_t ETLFindMatchingResponse(uint64_t a1, unsigned __int8 **a2, _BYTE *a3, unsigned int a4)
{
  if (!_ETLResponseRingBuffer)
    TelephonyUtilRingBufferInitialize();
  return ETLFindMatchingResponseUsingBuffer(a1, a2, (uint64_t)&_ETLResponseRingBuffer, a3, a4);
}

uint64_t ETLFindMatchingResponseUsingBuffer(uint64_t a1, unsigned __int8 **a2, uint64_t a3, _BYTE *a4, unsigned int a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  _BOOL8 v20;
  uint64_t v21;
  double v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v26;
  mach_timebase_info info;

  v9 = mach_absolute_time();
  if (a5 == -1)
  {
    if (ETLFrameReadFromTransport(a1, (uint64_t)a2))
    {
      do
      {
        v17 = *((unsigned int *)a2 + 2);
        if ((_ETLDebugFlags & 2) != 0)
        {
          ((void (*)(const char *, uint64_t, _QWORD, uint64_t))*(&gDelegate + 1))("", 1, *a2, v17);
          v17 = *((unsigned int *)a2 + 2);
        }
        if ((_DWORD)v17)
        {
          v18 = **a2;
          if ((_DWORD)v18 == *a4)
            return 1;
        }
        else
        {
          v18 = 0;
          if (!*a4)
            return 1;
        }
        if ((v18 - 19) <= 0x34 && ((1 << (v18 - 19)) & 0x10800000000027) != 0)
        {
LABEL_26:
          _ETLDebugPrint((uint64_t)"ETLFindMatchingResponseUsingBuffer", (uint64_t)"Received error code %u\n", v11, v17, v13, v14, v15, v16, v18);
          *a4 = v18;
          return 1;
        }
        HDLCFrameFree();
      }
      while ((ETLFrameReadFromTransport(a1, (uint64_t)a2) & 1) != 0);
    }
  }
  else
  {
    v10 = v9;
    while (ETLFrameReadFromTransport(a1, (uint64_t)a2))
    {
      v17 = *((unsigned int *)a2 + 2);
      if ((_ETLDebugFlags & 2) != 0)
      {
        ((void (*)(const char *, uint64_t, _QWORD, uint64_t))*(&gDelegate + 1))("", 1, *a2, v17);
        v17 = *((unsigned int *)a2 + 2);
      }
      if ((_DWORD)v17)
      {
        v18 = **a2;
        v19 = *a4;
        v20 = (_DWORD)v18 == v19;
        if ((_DWORD)v18 == v19)
          return v20;
      }
      else
      {
        v18 = 0;
        v20 = *a4 == 0;
        if (!*a4)
          return v20;
      }
      if ((v18 - 19) <= 0x34 && ((1 << (v18 - 19)) & 0x10800000000027) != 0)
        goto LABEL_26;
      HDLCFrameFree();
      v21 = mach_absolute_time();
      v22 = *(double *)&ETLGetTimeDifferenceMilliseconds_conversion;
      if (*(double *)&ETLGetTimeDifferenceMilliseconds_conversion == 0.0)
      {
        info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
        mach_timebase_info(&info);
        LODWORD(v24) = info.denom;
        LODWORD(v23) = info.numer;
        v22 = (double)v23 * 0.000001 / (double)v24;
        ETLGetTimeDifferenceMilliseconds_conversion = *(_QWORD *)&v22;
      }
      if ((v22 * (double)(v21 - v10)) >= a5)
        return v20;
    }
  }
  _ETLDebugPrint((uint64_t)"ETLFindMatchingResponseUsingBuffer", (uint64_t)"Failed to receive response from Baseband\n", v11, v12, v13, v14, v15, v16, v26);
  return 0;
}

uint64_t ETLSendCommand(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3)
{
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  int v13;

  v5 = malloc((2 * *(_DWORD *)(a2 + 8) + 32));
  if (!v5)
    return 0;
  v6 = v5;
  v7 = HDLCFrameEncode();
  if ((_DWORD)v7)
  {
    v8 = v7;
    v9 = -1431655766;
    v13 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0)
      ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v6, v7);
    if (*a1)
    {
      v10 = (*a1)(a1, v6, v8, &v13, 1, a3, 0);
      v9 = v13;
    }
    else
    {
      v10 = 0;
    }
    if (v9 == (_DWORD)v8)
      v11 = v10;
    else
      v11 = 0;
  }
  else
  {
    v11 = 0;
  }
  free(v6);
  return v11;
}

uint64_t ETLSendRaw(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  int v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  int v17;

  if (HDLCFrameCreateUplink())
  {
    v8 = HDLCFrameInjectUnsignedChar();
    if (a4 && v8)
    {
      if ((HDLCFrameInject() & 1) == 0)
        goto LABEL_14;
    }
    else if (!v8)
    {
      goto LABEL_14;
    }
    v10 = malloc(0x55555574uLL);
    if (v10)
    {
      v11 = v10;
      v12 = HDLCFrameEncode();
      if ((_DWORD)v12)
      {
        v13 = v12;
        v14 = -1431655766;
        v17 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0)
          ((void (*)(const char *, _QWORD, void *, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
        if (*a1)
        {
          v15 = (*a1)(a1, v11, v13, &v17, 1, a5, 0);
          v14 = v17;
        }
        else
        {
          v15 = 0;
        }
        if (v14 == (_DWORD)v13)
          v9 = v15;
        else
          v9 = 0;
      }
      else
      {
        v9 = 0;
      }
      free(v11);
      goto LABEL_21;
    }
LABEL_14:
    v9 = 0;
LABEL_21:
    HDLCFrameFree();
    return v9;
  }
  return 0;
}

BOOL ETLRequireFreeSpace(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int FreeSpace;

  FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < a2)
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v3, v4, v5, v6, v7, v8, a2);
  return FreeSpace >= a2;
}

BOOL ETLCheckPayloadLength(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;

  v8 = a3;
  v9 = *(_DWORD *)(a1 + 8) - a2;
  if (v9 < a3)
    _ETLDebugPrint((uint64_t)"ETLCheckPayloadLength", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, a3);
  return v9 >= v8;
}

BOOL ETLExpectResponseCode(unsigned int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 != a2)
    _ETLDebugPrint((uint64_t)"ETLExpectResponseCode", (uint64_t)"Received response code is %u, expected %u\n", a3, a4, a5, a6, a7, a8, a1);
  return a1 == a2;
}

uint64_t ETLNVRAMExtTranslateID(int a1, const char **a2)
{
  uint64_t result;
  const char *v4;

  result = 0;
  if (a1 <= 67287)
  {
    switch(a1)
    {
      case 65633:
        v4 = "/nv/item_files/modem/mmode/lte_bandpref";
        break;
      case 65728:
        v4 = "/nv/item_files/modem/utils/a2/sps_dynamic_usb_endpoint";
        break;
      case 65768:
        v4 = "/nv/item_files/hsusb/device_composition";
        break;
      default:
        return result;
    }
LABEL_15:
    *a2 = v4;
    a2[1] = (const char *)0xAAAAAAAA00000000;
    return 1;
  }
  else
  {
    switch(a1)
    {
      case 67288:
        v4 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh0";
        goto LABEL_15;
      case 67289:
        v4 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh1";
        goto LABEL_15;
      case 67290:
        v4 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_enable";
        goto LABEL_15;
      case 67297:
        v4 = "/nv/item_files/gps/cgps/me/gnss_main_wwan_tx_antenna_im_jamming_power";
        goto LABEL_15;
      case 67298:
        v4 = "/nv/item_files/gps/cgps/me/gnss_aux_wwan_tx_antenna_im_jamming_power";
        goto LABEL_15;
      case 67299:
        v4 = "/nv/item_files/gps/cgps/me/gnss_wlan_bt_delta_tx_antenna_im_jamming_power";
        goto LABEL_15;
      default:
        return result;
    }
  }
}

uint64_t ETLNVRAMExtWrite(_QWORD *a1, int a2, uint64_t a3, unsigned int a4, _DWORD *a5, unsigned int a6)
{
  char *v7;

  *a5 = 0xFFFF;
  if (a2 > 67287)
  {
    switch(a2)
    {
      case 67288:
        v7 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh0";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      case 67289:
        v7 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh1";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      case 67290:
        v7 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_enable";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      case 67297:
        v7 = "/nv/item_files/gps/cgps/me/gnss_main_wwan_tx_antenna_im_jamming_power";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      case 67298:
        v7 = "/nv/item_files/gps/cgps/me/gnss_aux_wwan_tx_antenna_im_jamming_power";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      case 67299:
        v7 = "/nv/item_files/gps/cgps/me/gnss_wlan_bt_delta_tx_antenna_im_jamming_power";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      default:
        goto LABEL_16;
    }
  }
  switch(a2)
  {
    case 65633:
      v7 = "/nv/item_files/modem/mmode/lte_bandpref";
      return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
    case 65728:
      v7 = "/nv/item_files/modem/utils/a2/sps_dynamic_usb_endpoint";
      return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
    case 65768:
      v7 = "/nv/item_files/hsusb/device_composition";
      return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
  }
LABEL_16:
  *a5 = 0x10000;
  return 0;
}

uint64_t ETLNVRAMExtRead(uint64_t (**a1)(_QWORD, void *, uint64_t, int *, uint64_t, uint64_t, _QWORD), int a2, void *a3, unsigned int a4, unsigned int *a5, unsigned int *a6, unsigned int a7)
{
  char *v9;

  *a5 = 0xFFFF;
  if (a2 > 67287)
  {
    switch(a2)
    {
      case 67288:
        v9 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh0";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      case 67289:
        v9 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh1";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      case 67290:
        v9 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_enable";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      case 67297:
        v9 = "/nv/item_files/gps/cgps/me/gnss_main_wwan_tx_antenna_im_jamming_power";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      case 67298:
        v9 = "/nv/item_files/gps/cgps/me/gnss_aux_wwan_tx_antenna_im_jamming_power";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      case 67299:
        v9 = "/nv/item_files/gps/cgps/me/gnss_wlan_bt_delta_tx_antenna_im_jamming_power";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      default:
        goto LABEL_16;
    }
  }
  switch(a2)
  {
    case 65633:
      v9 = "/nv/item_files/modem/mmode/lte_bandpref";
      return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
    case 65728:
      v9 = "/nv/item_files/modem/utils/a2/sps_dynamic_usb_endpoint";
      return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
    case 65768:
      v9 = "/nv/item_files/hsusb/device_composition";
      return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
  }
LABEL_16:
  *a5 = 0x10000;
  return 0;
}

uint64_t APPLIB_DIAG_GPS_SA_RF_VERIF_MODE_SWITCH(_DWORD *a1, int a2, int a3)
{
  uint64_t result;
  __int16 v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int __src;
  __int16 v14;
  _BYTE v15[2042];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x12)
    return result;
  bzero(a1, a2);
  *a1 = 6622539;
  *((_WORD *)a1 + 2) = 276;
  *((_BYTE *)a1 + 6) = a3;
  v7 = crc_16_l_table[a3 ^ 0x3B] ^ 0xFFB0;
  *((_BYTE *)a1 + 7) = crc_16_l_table[a3 ^ 0x3B] ^ 0xB0;
  v8 = HIBYTE(v7);
  *((_BYTE *)a1 + 8) = HIBYTE(v7);
  if (a2 < 18)
    return 0xFFFFFFFFLL;
  v9 = v7;
  bzero(v15, 0x7FAuLL);
  __src = 6622539;
  v14 = 276;
  if ((a3 - 125) <= 1)
  {
    v15[0] = 125;
    v10 = 7;
    v15[1] = a3 ^ 0x20;
    v11 = 8;
    if ((v9 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v10 = 6;
  v15[0] = a3;
  v11 = 7;
  if ((v9 - 125) <= 1)
  {
LABEL_9:
    *((_BYTE *)&__src + v11) = 125;
    LODWORD(v11) = v10 + 2;
    LOBYTE(v9) = v9 ^ 0x20;
  }
LABEL_10:
  *((_BYTE *)&__src + v11) = v9;
  v12 = v11 + 1;
  if ((v8 - 125) <= 1)
  {
    *((_BYTE *)&__src + v12) = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v12) = v11 + 2;
  }
  *((_BYTE *)&__src + v12) = v8;
  memcpy(a1, &__src, v12 + 1);
  result = (v12 + 2);
  *((_BYTE *)a1 + v12 + 1) = 126;
  return result;
}

uint64_t APPLIB_DIAG_GPS_GEN8_HW_CONFIG(char *a1, int a2, uint64_t a3)
{
  uint64_t result;
  char v7;
  uint64_t v8;
  unsigned __int16 v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned int v14;
  unsigned int v15;
  unsigned __int16 v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  _BYTE *v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE __src[2048];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x16)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 6622539;
    *((_WORD *)a1 + 2) = 12826;
    v7 = *(_BYTE *)(a3 + 4);
    *(_DWORD *)(a1 + 6) = *(_DWORD *)a3;
    a1[10] = v7;
    *(_WORD *)(a1 + 11) = 0;
    a1[13] = 0;
    v8 = a1[6];
    v9 = crc_16_l_table[v8 ^ 0x33];
    v10 = crc_16_l_table[a1[7] ^ 0xD6 ^ v9];
    v11 = crc_16_l_table[(a1[8] ^ v10 ^ HIBYTE(v9))];
    v12 = crc_16_l_table[(a1[9] ^ v11 ^ HIBYTE(v10))];
    v13 = crc_16_l_table[(a1[10] ^ v12 ^ HIBYTE(v11))];
    v14 = crc_16_l_table[(v13 ^ HIBYTE(v12))];
    v15 = crc_16_l_table[(v14 ^ HIBYTE(v13))];
    v16 = crc_16_l_table[crc_16_l_table[(v14 ^ HIBYTE(v13))] ^ (v14 >> 8)];
    *((_WORD *)a1 + 7) = v16 ^ ~HIBYTE(crc_16_l_table[(v14 ^ HIBYTE(v13))]);
    if (a2 >= 32)
    {
      bzero(__src, 0x800uLL);
      v17 = *a1;
      if ((v17 - 125) > 1)
      {
        v18 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v17) = v17 ^ 0x20;
        v18 = 1;
      }
      __src[v18] = v17;
      v19 = v18 + 1;
      v20 = a1[1];
      if ((v20 - 125) <= 1)
      {
        __src[v19] = 125;
        LODWORD(v19) = v18 | 2;
        LOBYTE(v20) = v20 ^ 0x20;
      }
      v21 = &__src[v19];
      *v21 = v20;
      *(_DWORD *)(v21 + 1) = 840564837;
      v22 = v19 + 5;
      if ((v8 - 125) <= 1)
      {
        __src[v22] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        LODWORD(v22) = v19 + 6;
      }
      __src[v22] = v8;
      v23 = v22 + 1;
      v24 = a1[7];
      if ((v24 - 125) <= 1)
      {
        __src[v23] = 125;
        LODWORD(v23) = v22 + 2;
        LOBYTE(v24) = v24 ^ 0x20;
      }
      __src[v23] = v24;
      v25 = v23 + 1;
      v26 = a1[8];
      if ((v26 - 125) <= 1)
      {
        __src[v25] = 125;
        LODWORD(v25) = v23 + 2;
        LOBYTE(v26) = v26 ^ 0x20;
      }
      __src[v25] = v26;
      v27 = v25 + 1;
      v28 = a1[9];
      if ((v28 - 125) <= 1)
      {
        __src[v27] = 125;
        LOBYTE(v28) = v28 ^ 0x20;
        LODWORD(v27) = v25 + 2;
      }
      v29 = ~(v16 ^ BYTE1(v15));
      __src[v27] = v28;
      v30 = v27 + 1;
      v31 = a1[10];
      if ((v31 - 125) <= 1)
      {
        __src[v30] = 125;
        LOBYTE(v31) = v31 ^ 0x20;
        LODWORD(v30) = v27 + 2;
      }
      v32 = ((unsigned __int16)(v16 ^ ~(unsigned __int16)(v15 >> 8)) >> 8);
      v33 = &__src[v30];
      *v33 = v31;
      *(_WORD *)(v33 + 1) = 0;
      v33[3] = 0;
      v34 = v30 + 4;
      if ((v29 - 125) <= 1)
      {
        __src[v34] = 125;
        LOBYTE(v29) = v29 ^ 0x20;
        LODWORD(v34) = v30 + 5;
      }
      __src[v34] = v29;
      v35 = v34 + 1;
      if ((v32 - 125) <= 1)
      {
        __src[v35] = 125;
        LOBYTE(v32) = v32 ^ 0x20;
        LODWORD(v35) = v34 + 2;
      }
      __src[v35] = v32;
      memcpy(a1, __src, v35 + 1);
      result = (v35 + 2);
      a1[v35 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_FTM_GNSS_EXTERNAL_LNA(unsigned __int8 *a1, int a2, int a3)
{
  uint64_t result;
  uint64_t v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  int __src;
  char v26;
  _BYTE v27[2043];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x11)
    return result;
  bzero(a1, a2);
  *(_DWORD *)a1 = 2231115;
  a1[4] = -3;
  a1[6] = a3;
  v7 = a1[5];
  v8 = crc_16_l_table[crc_16_l_table[v7 ^ 0xBA] ^ a3 ^ 0xEC];
  v9 = crc_16_l_table[(a1[7] ^ v8 ^ HIBYTE(crc_16_l_table[v7 ^ 0xBA]))];
  v10 = crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))];
  v11 = crc_16_l_table[(a1[9] ^ v10 ^ HIBYTE(v9))];
  v12 = v11 ^ ~(v10 >> 8);
  *((_WORD *)a1 + 5) = v11 ^ ~HIBYTE(crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))]);
  if (a2 < 24)
    return 0xFFFFFFFFLL;
  bzero(v27, 0x7FBuLL);
  __src = 2231115;
  v26 = -3;
  if ((v7 - 125) <= 1)
  {
    v27[0] = 125;
    v13 = 6;
    v27[1] = v7 ^ 0x20;
    v14 = 7;
    if ((a3 - 125) > 1)
      goto LABEL_10;
    goto LABEL_9;
  }
  v13 = 5;
  v27[0] = v7;
  v14 = 6;
  if ((a3 - 125) <= 1)
  {
LABEL_9:
    *((_BYTE *)&__src + v14) = 125;
    LOBYTE(a3) = a3 ^ 0x20;
    LODWORD(v14) = v13 + 2;
  }
LABEL_10:
  *((_BYTE *)&__src + v14) = a3;
  v15 = v14 + 1;
  v16 = a1[7];
  if ((v16 - 125) <= 1)
  {
    *((_BYTE *)&__src + v15) = 125;
    LODWORD(v15) = v14 + 2;
    LOBYTE(v16) = v16 ^ 0x20;
  }
  *((_BYTE *)&__src + v15) = v16;
  v17 = v15 + 1;
  v18 = a1[8];
  if ((v18 - 125) <= 1)
  {
    *((_BYTE *)&__src + v17) = 125;
    LOBYTE(v18) = v18 ^ 0x20;
    LODWORD(v17) = v15 + 2;
  }
  v19 = ~(v11 ^ BYTE1(v10));
  *((_BYTE *)&__src + v17) = v18;
  v20 = v17 + 1;
  v21 = a1[9];
  if ((v21 - 125) <= 1)
  {
    *((_BYTE *)&__src + v20) = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v20) = v17 + 2;
  }
  v22 = (unsigned __int16)(v11 ^ ~(unsigned __int16)(v10 >> 8)) >> 8;
  *((_BYTE *)&__src + v20) = v21;
  v23 = v20 + 1;
  if ((v19 - 125) <= 1)
  {
    *((_BYTE *)&__src + v23) = 125;
    LOBYTE(v19) = v19 ^ 0x20;
    LODWORD(v23) = v20 + 2;
  }
  *((_BYTE *)&__src + v23) = v19;
  v24 = v23 + 1;
  if (BYTE1(v12) - 125 <= 1)
  {
    *((_BYTE *)&__src + v24) = 125;
    v22 = BYTE1(v12) ^ 0x20;
    LODWORD(v24) = v23 + 2;
  }
  *((_BYTE *)&__src + v24) = v22;
  memcpy(a1, &__src, v24 + 1);
  result = (v24 + 2);
  a1[v24 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_GPS_GEN8_StartIQTest(unsigned __int8 *a1, int a2)
{
  uint64_t result;
  unsigned __int16 v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned int v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned int v16;
  uint64_t v17;
  size_t v18;
  int v19;
  int v20;
  _BYTE __src[2048];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 16)
  {
    bzero(a1, a2);
    *(_OWORD *)a1 = xmmword_1DAD15530;
    *((_WORD *)a1 + 8) = 2560;
    v5 = crc_16_l_table[a1[7] ^ 0x6DLL];
    v6 = crc_16_l_table[a1[8] ^ 0xA6 ^ v5];
    v7 = crc_16_l_table[(a1[9] ^ v6 ^ HIBYTE(v5))];
    v8 = crc_16_l_table[(a1[10] ^ v7 ^ HIBYTE(v6))];
    v9 = crc_16_l_table[(a1[11] ^ v8 ^ HIBYTE(v7))];
    v10 = crc_16_l_table[(a1[12] ^ v9 ^ HIBYTE(v8))];
    v11 = crc_16_l_table[(a1[13] ^ v10 ^ HIBYTE(v9))];
    v12 = crc_16_l_table[(a1[14] ^ v11 ^ HIBYTE(v10))];
    v13 = crc_16_l_table[(a1[15] ^ v12 ^ HIBYTE(v11))];
    v14 = crc_16_l_table[(v13 ^ HIBYTE(v12))];
    LOWORD(v13) = crc_16_l_table[v14 ^ (v13 >> 8) ^ 0xA];
    v15 = crc_16_l_table[(a1[18] ^ v13 ^ HIBYTE(v14))];
    LOWORD(v13) = crc_16_l_table[(a1[19] ^ v15 ^ BYTE1(v13))];
    v16 = crc_16_l_table[(a1[20] ^ v13 ^ HIBYTE(v15))];
    *((_WORD *)a1 + 11) = crc_16_l_table[(a1[21] ^ v16 ^ BYTE1(v13))] ^ ~(unsigned __int16)(v16 >> 8);
    if (a2 >= 0x30)
    {
      bzero(__src, 0x800uLL);
      v17 = 0;
      LODWORD(v18) = 0;
      do
      {
        while (1)
        {
          v20 = a1[v17];
          if ((v20 - 125) > 1)
            break;
          v19 = v18 + 1;
          __src[(int)v18] = 125;
          __src[(int)v18 + 1] = v20 ^ 0x20;
          v18 = (int)v18 + 1 + 1;
          if (++v17 == 24)
            goto LABEL_9;
        }
        v19 = v18;
        __src[(int)v18] = v20;
        v18 = (int)v18 + 1;
        ++v17;
      }
      while (v17 != 24);
LABEL_9:
      memcpy(a1, __src, v18);
      result = (v19 + 2);
      a1[v18] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GPS_GEN8_SV_TRACK(char *a1, int a2, _DWORD *a3)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  unsigned __int16 v9;
  unsigned __int16 v10;
  unsigned int v11;
  unsigned __int16 v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int __src;
  __int16 v31;
  char v32[2042];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x12)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 6622539;
    *((_WORD *)a1 + 2) = 12827;
    v7 = *(_DWORD *)((char *)a3 + 3);
    *(_DWORD *)(a1 + 6) = *a3;
    *(_DWORD *)(a1 + 9) = v7;
    v8 = a1[6];
    LOWORD(v7) = crc_16_l_table[v8 ^ 0xEB];
    v9 = crc_16_l_table[(a1[7] ^ v7) ^ 0xCF];
    LOWORD(v7) = crc_16_l_table[(a1[8] ^ v9 ^ BYTE1(v7))];
    v10 = crc_16_l_table[(a1[9] ^ v7 ^ HIBYTE(v9))];
    LOWORD(v7) = crc_16_l_table[(a1[10] ^ v10 ^ BYTE1(v7))];
    v11 = crc_16_l_table[(a1[11] ^ v7 ^ HIBYTE(v10))];
    v12 = crc_16_l_table[(a1[12] ^ v11 ^ BYTE1(v7))];
    *(_WORD *)(a1 + 13) = v12 ^ ~HIBYTE(crc_16_l_table[(a1[11] ^ v7 ^ HIBYTE(v10))]);
    if (a2 >= 30)
    {
      bzero(v32, 0x7FAuLL);
      __src = 6622539;
      v31 = 12827;
      if ((v8 - 125) > 1)
      {
        v13 = 6;
      }
      else
      {
        v32[0] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        v13 = 7;
      }
      *((_BYTE *)&__src + v13) = v8;
      v14 = v13 + 1;
      v15 = a1[7];
      if ((v15 - 125) <= 1)
      {
        *((_BYTE *)&__src + v14) = 125;
        LODWORD(v14) = v13 + 2;
        LOBYTE(v15) = v15 ^ 0x20;
      }
      *((_BYTE *)&__src + v14) = v15;
      v16 = v14 + 1;
      v17 = a1[8];
      if ((v17 - 125) <= 1)
      {
        *((_BYTE *)&__src + v16) = 125;
        LOBYTE(v17) = v17 ^ 0x20;
        LODWORD(v16) = v14 + 2;
      }
      *((_BYTE *)&__src + v16) = v17;
      v18 = v16 + 1;
      v19 = a1[9];
      if ((v19 - 125) <= 1)
      {
        *((_BYTE *)&__src + v18) = 125;
        LODWORD(v18) = v16 + 2;
        LOBYTE(v19) = v19 ^ 0x20;
      }
      *((_BYTE *)&__src + v18) = v19;
      v20 = v18 + 1;
      v21 = a1[10];
      if ((v21 - 125) <= 1)
      {
        *((_BYTE *)&__src + v20) = 125;
        LODWORD(v20) = v18 + 2;
        LOBYTE(v21) = v21 ^ 0x20;
      }
      *((_BYTE *)&__src + v20) = v21;
      v22 = v20 + 1;
      v23 = a1[11];
      if ((v23 - 125) <= 1)
      {
        *((_BYTE *)&__src + v22) = 125;
        LOBYTE(v23) = v23 ^ 0x20;
        LODWORD(v22) = v20 + 2;
      }
      v24 = ~(v12 ^ BYTE1(v11));
      *((_BYTE *)&__src + v22) = v23;
      v25 = v22 + 1;
      v26 = a1[12];
      if ((v26 - 125) <= 1)
      {
        *((_BYTE *)&__src + v25) = 125;
        LOBYTE(v26) = v26 ^ 0x20;
        LODWORD(v25) = v22 + 2;
      }
      v27 = ((unsigned __int16)(v12 ^ ~(unsigned __int16)(v11 >> 8)) >> 8);
      *((_BYTE *)&__src + v25) = v26;
      v28 = v25 + 1;
      if ((v24 - 125) <= 1)
      {
        *((_BYTE *)&__src + v28) = 125;
        LOBYTE(v24) = v24 ^ 0x20;
        LODWORD(v28) = v25 + 2;
      }
      *((_BYTE *)&__src + v28) = v24;
      v29 = v28 + 1;
      if ((v27 - 125) <= 1)
      {
        *((_BYTE *)&__src + v29) = 125;
        LOBYTE(v27) = v27 ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      *((_BYTE *)&__src + v29) = v27;
      memcpy(a1, &__src, v29 + 1);
      result = (v29 + 2);
      a1[v29 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_MemoryPoke_Byte(char *a1, int a2, int a3, void *__src, int a5)
{
  uint64_t result;
  int v9;
  int v10;
  char *v11;
  char v12;
  char v13;
  char v14;
  uint64_t v15;
  int v16;
  unsigned __int8 *v17;
  char v18;
  int v19;
  _BYTE __srca[2048];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a5 && a3 && a1 && a2 >= 0xD && __src)
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 5) = 0;
    *a1 = 5;
    *(_DWORD *)(a1 + 1) = a3;
    a1[5] = a5;
    memcpy(a1 + 6, __src, a5);
    v9 = 8 * (a5 + 6);
    if (8 * ((_WORD)a5 + 6))
    {
      LOWORD(v10) = -1;
      v11 = a1;
      do
      {
        v12 = *v11++;
        v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
        v9 -= 8;
      }
      while ((_WORD)v9);
      v13 = ~(_BYTE)v10;
      v14 = (unsigned __int16)~(_WORD)v10 >> 8;
    }
    else
    {
      v13 = 0;
      v14 = 0;
    }
    a1[a5 + 6] = v13;
    a1[a5 + 7] = v14;
    v15 = (a5 + 8);
    result = 0xFFFFFFFFLL;
    if ((int)v15 <= 1024 && 2 * (int)v15 <= a2)
    {
      bzero(__srca, 0x800uLL);
      if ((int)v15 < 1)
      {
        v16 = 0;
      }
      else
      {
        v16 = 0;
        v17 = (unsigned __int8 *)a1;
        do
        {
          v19 = *v17++;
          v18 = v19;
          if ((v19 - 125) <= 1)
          {
            __srca[v16] = 125;
            v18 ^= 0x20u;
            ++v16;
          }
          __srca[v16++] = v18;
          --v15;
        }
        while (v15);
      }
      memcpy(a1, __srca, v16);
      result = (v16 + 1);
      a1[v16] = 126;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_MemoryPoke_Word(char *a1, int a2, int a3, void *__src, int a5)
{
  uint64_t result;
  int v8;
  int v9;
  int v10;
  char *v11;
  char v12;
  char v13;
  char v14;
  uint64_t v15;
  int v16;
  unsigned __int8 *v17;
  char v18;
  int v19;
  _BYTE __srca[2048];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a5 && a3 && a1 && a2 >= 0xD && __src)
  {
    *(_QWORD *)a1 = 0;
    *a1 = 6;
    *(_DWORD *)(a1 + 1) = a3;
    v8 = 2 * a5;
    *(_QWORD *)(a1 + 5) = 0;
    a1[5] = a5;
    memcpy(a1 + 6, __src, 2 * a5);
    v9 = 8 * (v8 + 6);
    if ((v9 & 0xFFF0) != 0)
    {
      LOWORD(v10) = -1;
      v11 = a1;
      do
      {
        v12 = *v11++;
        v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
        v9 -= 8;
      }
      while ((_WORD)v9);
      v13 = ~(_BYTE)v10;
      v14 = (unsigned __int16)~(_WORD)v10 >> 8;
    }
    else
    {
      v13 = 0;
      v14 = 0;
    }
    a1[v8 + 6] = v13;
    a1[v8 + 7] = v14;
    v15 = (v8 + 8);
    result = 0xFFFFFFFFLL;
    if ((int)v15 <= 1024 && 2 * (int)v15 <= a2)
    {
      bzero(__srca, 0x800uLL);
      if ((int)v15 < 1)
      {
        v16 = 0;
      }
      else
      {
        v16 = 0;
        v17 = (unsigned __int8 *)a1;
        do
        {
          v19 = *v17++;
          v18 = v19;
          if ((v19 - 125) <= 1)
          {
            __srca[v16] = 125;
            v18 ^= 0x20u;
            ++v16;
          }
          __srca[v16++] = v18;
          --v15;
        }
        while (v15);
      }
      memcpy(a1, __srca, v16);
      result = (v16 + 1);
      a1[v16] = 126;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_MemoryPoke_DWord(char *a1, int a2, int a3, void *__src, int a5)
{
  uint64_t result;
  int v8;
  int v9;
  int v10;
  char *v11;
  char v12;
  uint64_t v13;
  int v14;
  unsigned __int8 *v15;
  char v16;
  int v17;
  _BYTE __srca[2048];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a5)
  {
    if (a3)
    {
      if (a1)
      {
        if (a2 >= 0xD)
        {
          if (__src)
          {
            *(_QWORD *)a1 = 0;
            *a1 = 7;
            *(_DWORD *)(a1 + 1) = a3;
            v8 = 4 * a5;
            *(_QWORD *)(a1 + 5) = 0;
            a1[5] = a5;
            memcpy(a1 + 6, __src, 4 * a5);
            v9 = 8 * (v8 + 6);
            LOWORD(v10) = -1;
            v11 = a1;
            do
            {
              v12 = *v11++;
              v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
              v9 -= 8;
            }
            while ((_WORD)v9);
            a1[v8 + 6] = ~(_BYTE)v10;
            a1[v8 + 7] = (unsigned __int16)~(_WORD)v10 >> 8;
            v13 = (v8 + 8);
            result = 0xFFFFFFFFLL;
            if ((int)v13 <= 1024 && 2 * (int)v13 <= a2)
            {
              bzero(__srca, 0x800uLL);
              if ((int)v13 < 1)
              {
                v14 = 0;
              }
              else
              {
                v14 = 0;
                v15 = (unsigned __int8 *)a1;
                do
                {
                  v17 = *v15++;
                  v16 = v17;
                  if ((v17 - 125) <= 1)
                  {
                    __srca[v14] = 125;
                    v16 ^= 0x20u;
                    ++v14;
                  }
                  __srca[v14++] = v16;
                  --v13;
                }
                while (v13);
              }
              memcpy(a1, __srca, v14);
              result = (v14 + 1);
              a1[v14] = 126;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GPS_SessionControl(char *a1, int a2, char a3, void *__src, int a5)
{
  uint64_t result;
  uint64_t v9;
  int v10;
  int v11;
  char *v12;
  char v13;
  uint64_t v14;
  int v15;
  unsigned __int8 *v16;
  char v17;
  int v18;
  _BYTE __srca[2048];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 39 && __src && a5)
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 5) = 0;
    *a1 = 108;
    a1[1] = a3;
    *((_WORD *)a1 + 1) = a5;
    memcpy(a1 + 4, __src, a5);
    v9 = a5 + 4;
    v10 = 8 * (a5 + 4);
    if (8 * ((_WORD)a5 + 4))
    {
      LOWORD(v11) = -1;
      v12 = a1;
      do
      {
        v13 = *v12++;
        v11 = crc_16_l_table[(v13 ^ v11)] ^ ((unsigned __int16)(v11 & 0xFF00) >> 8);
        v10 -= 8;
      }
      while ((_WORD)v10);
      a1[v9] = ~(_BYTE)v11;
      a1[a5 + 5] = (unsigned __int16)~(_WORD)v11 >> 8;
      result = 0xFFFFFFFFLL;
      if (a5 > 1018)
        return result;
    }
    else
    {
      a1[v9] = 0;
      a1[a5 + 5] = 0;
      result = 0xFFFFFFFFLL;
      if (a5 > 1018)
        return result;
    }
    v14 = (a5 + 6);
    if (2 * (int)v14 <= a2)
    {
      bzero(__srca, 0x800uLL);
      if (a5 < -5)
      {
        v15 = 0;
      }
      else
      {
        v15 = 0;
        v16 = (unsigned __int8 *)a1;
        do
        {
          v18 = *v16++;
          v17 = v18;
          if ((v18 - 125) <= 1)
          {
            __srca[v15] = 125;
            v17 ^= 0x20u;
            ++v15;
          }
          __srca[v15++] = v17;
          --v14;
        }
        while (v14);
      }
      memcpy(a1, __srca, v15);
      result = (v15 + 1);
      a1[v15] = 126;
    }
  }
  return result;
}

uint64_t HDLCFrameCreateDownlink()
{
  return MEMORY[0x1E0DE0118]();
}

uint64_t HDLCFrameCreateUplink()
{
  return MEMORY[0x1E0DE0120]();
}

uint64_t HDLCFrameEncode()
{
  return MEMORY[0x1E0DE0128]();
}

uint64_t HDLCFrameEncodeAndCache()
{
  return MEMORY[0x1E0DE0130]();
}

uint64_t HDLCFrameFree()
{
  return MEMORY[0x1E0DE0138]();
}

uint64_t HDLCFrameGetFreeSpace()
{
  return MEMORY[0x1E0DE0140]();
}

uint64_t HDLCFrameInject()
{
  return MEMORY[0x1E0DE0148]();
}

uint64_t HDLCFrameInjectUnsignedChar()
{
  return MEMORY[0x1E0DE0150]();
}

uint64_t HDLCFrameInjectUnsignedInt()
{
  return MEMORY[0x1E0DE0158]();
}

uint64_t HDLCFrameInjectUnsignedShort()
{
  return MEMORY[0x1E0DE0160]();
}

uint64_t TelephonyUtilBinToHex()
{
  return MEMORY[0x1E0DE3680]();
}

uint64_t TelephonyUtilDecodeHexWithDefault()
{
  return MEMORY[0x1E0DE3698]();
}

uint64_t TelephonyUtilEncodeHex()
{
  return MEMORY[0x1E0DE36A0]();
}

uint64_t TelephonyUtilLogBinaryToBuffer()
{
  return MEMORY[0x1E0DE36C8]();
}

uint64_t TelephonyUtilRingBufferGetSize()
{
  return MEMORY[0x1E0DE36D0]();
}

uint64_t TelephonyUtilRingBufferInitialize()
{
  return MEMORY[0x1E0DE36D8]();
}

uint64_t TelephonyUtilRingBufferInsertTransport()
{
  return MEMORY[0x1E0DE36E0]();
}

uint64_t TelephonyUtilRingBufferLinearize()
{
  return MEMORY[0x1E0DE36E8]();
}

uint64_t TelephonyUtilRingBufferReset()
{
  return MEMORY[0x1E0DE36F0]();
}

uint64_t TelephonyUtilRingBufferSkip()
{
  return MEMORY[0x1E0DE36F8]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

uint64_t capabilities::etl::supportsBBAppsCrash(capabilities::etl *this)
{
  return MEMORY[0x1E0DE3230](this);
}

uint64_t capabilities::etl::getMavSHAHashLenType(capabilities::etl *this)
{
  return MEMORY[0x1E0DE3238](this);
}

uint64_t capabilities::etl::maverickTxPowerUsesRFSubsys(capabilities::etl *this)
{
  return MEMORY[0x1E0DE3240](this);
}

uint64_t capabilities::etl::getMaverickIPALoopbackV2ParametersType(capabilities::etl *this)
{
  return MEMORY[0x1E0DE3248](this);
}

uint64_t capabilities::radio::mav20Plus(capabilities::radio *this)
{
  return MEMORY[0x1E0DE33C0](this);
}

uint64_t capabilities::radio::mavLegacy(capabilities::radio *this)
{
  return MEMORY[0x1E0DE33C8](this);
}

uint64_t ctu::tokenize()
{
  return MEMORY[0x1E0DE39C8]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1E0DE4248](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1E0DE4258](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1E0DE4288](this, a2);
}

void std::this_thread::sleep_for (const std::chrono::nanoseconds *__ns)
{
  MEMORY[0x1E0DE43C0](__ns);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4428](this, __s, __n);
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1E0DE46B0]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1E0DE46B8]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1E0DE46C8]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1E0DE4700]();
}

{
  return MEMORY[0x1E0DE4708]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1E0DE47E0]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1E0DE47E8]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE48F0](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE4900](this);
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x1E0DE4B38]();
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x1E0DE4B98](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x1E0DE4C50](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x1E0DE4C68](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x1E0DE4C80](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1E0DE4D28]();
}

void std::terminate(void)
{
  MEMORY[0x1E0DE4E18]();
}

void operator delete(void *__p)
{
  off_1EA1F1A98(__p);
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1EA1F1AA0(__sz);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1E0DE5068](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE5080](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x1E0DE5098]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x1E0DE50A0](a1);
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x1E0DE50D8](a1, lptinfo, a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1E0C80B68]();
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return (void *)MEMORY[0x1E0C81828](__count, __size);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1E0C83C50]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1E0C83DB8](info);
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x1E0C83E68](__size);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1E0C84070](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1E0C85438](*(_QWORD *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
{
  return MEMORY[0x1E0C85550](*(_QWORD *)&__errnum, __strerrbuf, __buflen);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1E0C855B0](__dst, __src, __n);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85698](__str, __endptr, *(_QWORD *)&__base);
}

